diff --git a/CHANGELOG.md b/CHANGELOG.md
index d464b7c6..6ce33c8e 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,48 @@
+## Version 4.3.0 (Deceber 15, 2015)
+
+- Enhancements and bug fixes for VAST video ads.
+
+## Version 4.2.0 (November 30, 2015)
+
+- Support for mediating Facebook Native Video ads.
+- Mediated Facebook Native Ads now display the AdChoices icon.
+- Support for Facebook SDK 8.4.1
+
+## Version 4.1.0 (November 12, 2015)
+
+- A number of Native Ad classes now require `Activity` instances instead of `Context`. Most users should be unaffected by this change, and it fixes a crash caused by handling themes incorrectly. The following classes are affected:
+
+  - `CustomEventNative` and its implementations including `MoPubCustomEventNative`.
+  - `MoPubAdAdapter` and `MoPubRecyclerAdapter`.
+  - `MoPubAdRenderer` and its implementations.
+  - `MoPubStreamAdPlacer`
+  - `MoPubNative`
+  - `NativeAd` and `NativeAdSource`
+  - `NativeAdViewHelper`
+
+- Vungle's ad adapters have been updated for their 3.3.0 SDK.
+- Tapjoy adapters for interstitials and rewarded video are included for their 11.2.2 SDK. 
+- The Play Services adapters have been tested with Play Services 7.8.0.
+
+## Version 4.0.0 (October 6, 2015)
+
+Version 4.0.0 includes a number of improvements to our Native Ads systems under the hood. This means a few changes for publishers integrating the ads. The [Native Ads Integration Guide](https://github.com/mopub/mopub-android-sdk/wiki/Native-Ads-Integration) describes all the steps you'll need to integrate 4.0.0.
+
+**Native Ads Changes**
+ - `MoPubNativeAdRenderer` has been replaced by `MoPubStaticNativeRenderer` 
+ - When requesting ads using `MoPubNative`, you must instantiate and register a `MoPubStaticNativeAdRenderer`. See the [Integration Document](https://github.com/mopub/mopub-android-sdk/wiki/Manual-Integration-of-Native-Ads) for more details.
+ - `NativeResponse` has been replaced with `NativeAd`
+ - `NativeAd` has a new API that supports creating and rendering `View`s for Native Ads.
+   - `#createAdView` returns a `View` that can hold data for the `NativeAd`
+   - `#renderAdView` will populate the `View` with ad data. 
+   - Other lifecycle methods from `NativeResponse` remain:
+     - `#prepare`, `#clear`, `#destroy`
+ - The process of writing new `CustomEventNative` instances has changed. These changes will support more dynamic, flexible, and attractive Native Ad formats in the future. All bundled native Custom Event files have been updated to use the new API.
+
+**Removed Old Code**
+ - Removed legacy banner/interestitial listeners, deprecated in 1.11
+ - Removed legacy custom event implementation ("custom event methods") deprecated in 1.10
+
 ## Version 3.13.0 (September 21, 2015)
 
 - **Android M Support** - Replaced usage of the now-deprecated HttpClient with HttpURLConnection.
diff --git a/README.md b/README.md
index f7b2a0b0..c972a01a 100644
--- a/README.md
+++ b/README.md
@@ -27,7 +27,7 @@ The MoPub SDK is available via:
     }
 
     dependencies {
-        compile('com.mopub:mopub-sdk:3.13.0@aar') {
+        compile('com.mopub:mopub-sdk:4.1.0@aar') {
             transitive = true
         }
     }
@@ -60,10 +60,9 @@ The MoPub SDK is available via:
     **For additional integration instructions, please see the [Getting Started guide](https://github.com/mopub/mopub-android-sdk/wiki/Getting-Started#requirements-and-dependencies).**
 
 ## New in this Version
+Please view the [changelog](https://github.com/mopub/mopub-android-sdk/blob/master/CHANGELOG.md) for a complete list of additions, fixes, and enhancements in the latest release.
 
-Please view the [changelog](https://github.com/mopub/mopub-android-sdk/blob/master/CHANGELOG.md) for a complete list of additions, fixes, and enhancements in the lastest release..
-
-- **Android M Support** - Replaced usage of the now-deprecated HttpClient with HttpURLConnection.
+- Enhancements and bug fixes for VAST video ads.
 
 ## Requirements
 
@@ -72,7 +71,7 @@ Please view the [changelog](https://github.com/mopub/mopub-android-sdk/blob/mast
 - android-support-annotations.jar, r22 (**Updated in 3.7.0**)
 - android-support-v7-recyclerview.jar, r22 (**Updated in 3.9.0**)
 - MoPub Volley Library (mopub-volley-1.1.0.jar - available on JCenter) (**Updated in 3.6.0**)
-- **Recommended** Google Play Services 7.0.0
+- **Recommended** Google Play Services 7.8.0
 
 ## Upgrading from 3.2.0 and Prior
 In 3.3.0 a dependency on android-support-annotations.jar was added. If you are using Maven or Gradle to include the MoPub SDK, this dependency is included in the build scripts. For instructions on adding dependencies for Eclipse projects, see our [Getting Started Guide](https://github.com/mopub/mopub-android-sdk/wiki/Getting-Started#adding-the-support-libraries-to-your-project)
diff --git a/extras/src/com/mopub/mobileads/FacebookBanner.java b/extras/src/com/mopub/mobileads/FacebookBanner.java
index f0513a57..c8a0b879 100644
--- a/extras/src/com/mopub/mobileads/FacebookBanner.java
+++ b/extras/src/com/mopub/mobileads/FacebookBanner.java
@@ -16,7 +16,7 @@
 import java.util.Map;
 
 /**
- * Tested with Facebook SDK 3.23.1.
+ * Tested with Facebook SDK 4.8.1.
  */
 public class FacebookBanner extends CustomEventBanner implements AdListener {
     public static final String PLACEMENT_ID_KEY = "placement_id";
diff --git a/extras/src/com/mopub/mobileads/FacebookInterstitial.java b/extras/src/com/mopub/mobileads/FacebookInterstitial.java
index 3ff45d1b..ef4bb874 100644
--- a/extras/src/com/mopub/mobileads/FacebookInterstitial.java
+++ b/extras/src/com/mopub/mobileads/FacebookInterstitial.java
@@ -11,7 +11,7 @@
 import java.util.Map;
 
 /**
- * Tested with Facebook SDK 3.23.1.
+ * Tested with Facebook SDK 4.8.1.
  */
 public class FacebookInterstitial extends CustomEventInterstitial implements InterstitialAdListener {
     public static final String PLACEMENT_ID_KEY = "placement_id";
diff --git a/extras/src/com/mopub/mobileads/GooglePlayServicesBanner.java b/extras/src/com/mopub/mobileads/GooglePlayServicesBanner.java
index 17273749..d1268306 100644
--- a/extras/src/com/mopub/mobileads/GooglePlayServicesBanner.java
+++ b/extras/src/com/mopub/mobileads/GooglePlayServicesBanner.java
@@ -17,7 +17,7 @@
 import static com.google.android.gms.ads.AdSize.MEDIUM_RECTANGLE;
 
 /*
- * Compatible with version 7.0.0 of the Google Play Services SDK.
+ * Compatible with version 7.8.0 of the Google Play Services SDK.
  */
 
 // Note: AdMob ads will now use this class as Google has deprecated the AdMob SDK.
diff --git a/extras/src/com/mopub/mobileads/GooglePlayServicesInterstitial.java b/extras/src/com/mopub/mobileads/GooglePlayServicesInterstitial.java
index 9aab1650..7417ac76 100644
--- a/extras/src/com/mopub/mobileads/GooglePlayServicesInterstitial.java
+++ b/extras/src/com/mopub/mobileads/GooglePlayServicesInterstitial.java
@@ -10,7 +10,7 @@
 import java.util.Map;
 
 /*
- * Compatible with version 7.0.0 of the Google Play Services SDK.
+ * Compatible with version 7.8.0 of the Google Play Services SDK.
  */
 
 // Note: AdMob ads will now use this class as Google has deprecated the AdMob SDK.
diff --git a/extras/src/com/mopub/mobileads/TapjoyInterstitial.java b/extras/src/com/mopub/mobileads/TapjoyInterstitial.java
new file mode 100644
index 00000000..c20b64e5
--- /dev/null
+++ b/extras/src/com/mopub/mobileads/TapjoyInterstitial.java
@@ -0,0 +1,92 @@
+package com.mopub.mobileads;
+
+import android.content.Context;
+import android.text.TextUtils;
+
+import com.mopub.common.logging.MoPubLog;
+import com.tapjoy.TJActionRequest;
+import com.tapjoy.TJError;
+import com.tapjoy.TJPlacement;
+import com.tapjoy.TJPlacementListener;
+
+import java.util.Map;
+
+// Tested with Tapjoy SDK 11.1.0
+public class TapjoyInterstitial extends CustomEventInterstitial implements TJPlacementListener {
+    private TJPlacement tjPlacement;
+    private CustomEventInterstitialListener mInterstitialListener;
+
+    @Override
+    protected void loadInterstitial(Context context,
+            CustomEventInterstitialListener customEventInterstitialListener,
+            Map<String, Object> localExtras,
+            Map<String, String> serverExtras) {
+        MoPubLog.d("Requesting Tapjoy interstitial");
+
+        mInterstitialListener = customEventInterstitialListener;
+
+        String name = serverExtras.get("name");
+        if (TextUtils.isEmpty(name)) {
+            MoPubLog.d("Tapjoy interstitial loaded with empty 'name' field. Request will fail.");
+        }
+        tjPlacement = new TJPlacement(context, name, this);
+        tjPlacement.requestContent();
+    }
+
+    @Override
+    protected void onInvalidate() {
+        // No custom cleanup to do here.
+    }
+
+    @Override
+    protected void showInterstitial() {
+        MoPubLog.d("Tapjoy interstitial will be shown");
+        tjPlacement.showContent();
+    }
+
+    // Tapjoy
+
+    @Override
+    public void onRequestSuccess(TJPlacement placement) {
+        if (placement.isContentAvailable()) {
+            MoPubLog.d("Tapjoy interstitial request successful");
+            mInterstitialListener.onInterstitialLoaded();
+        } else {
+            MoPubLog.d("No Tapjoy interstitials available");
+            mInterstitialListener.onInterstitialFailed(MoPubErrorCode.NETWORK_NO_FILL);
+        }
+    }
+
+    @Override
+    public void onRequestFailure(TJPlacement placement, TJError error) {
+        MoPubLog.d("Tapjoy interstitial request failed");
+        mInterstitialListener.onInterstitialFailed(MoPubErrorCode.NETWORK_NO_FILL);
+    }
+
+    @Override
+    public void onContentShow(TJPlacement placement) {
+        MoPubLog.d("Tapjoy interstitial shown");
+        mInterstitialListener.onInterstitialShown();
+    }
+
+    @Override
+    public void onContentDismiss(TJPlacement placement) {
+        MoPubLog.d("Tapjoy interstitial dismissed");
+        mInterstitialListener.onInterstitialDismissed();
+    }
+
+    @Override
+    public void onContentReady(TJPlacement placement) {
+    }
+
+    @Override
+    public void onPurchaseRequest(TJPlacement placement, TJActionRequest request,
+            String productId) {
+    }
+
+    @Override
+    public void onRewardRequest(TJPlacement placement, TJActionRequest request, String itemId,
+            int quantity) {
+    }
+
+}
diff --git a/extras/src/com/mopub/mobileads/TapjoyRewardedVideo.java b/extras/src/com/mopub/mobileads/TapjoyRewardedVideo.java
new file mode 100644
index 00000000..5b989a17
--- /dev/null
+++ b/extras/src/com/mopub/mobileads/TapjoyRewardedVideo.java
@@ -0,0 +1,132 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.support.annotation.NonNull;
+import android.text.TextUtils;
+
+import com.mopub.common.LifecycleListener;
+import com.mopub.common.MediationSettings;
+import com.mopub.common.logging.MoPubLog;
+import com.tapjoy.TJActionRequest;
+import com.tapjoy.TJError;
+import com.tapjoy.TJPlacement;
+import com.tapjoy.TJPlacementListener;
+
+import java.util.Map;
+
+// Tested with Tapjoy SDK 11.1.0
+public class TapjoyRewardedVideo extends CustomEventRewardedVideo {
+    private static final String TAPJOY_AD_NETWORK_CONSTANT = "tapjoy_id";
+    private TJPlacement tjPlacement;
+    private static TapjoyRewardedVideoListener sTapjoyListener = new TapjoyRewardedVideoListener();
+
+    @Override
+    protected CustomEventRewardedVideoListener getVideoListenerForSdk() {
+        return sTapjoyListener;
+    }
+
+    @Override
+    protected LifecycleListener getLifecycleListener() {
+        return null;
+    }
+
+    @Override
+    protected String getAdNetworkId() {
+        return TAPJOY_AD_NETWORK_CONSTANT;
+    }
+
+    @Override
+    protected void onInvalidate() {
+    }
+
+    @Override
+    protected boolean checkAndInitializeSdk(@NonNull Activity launcherActivity,
+            @NonNull Map<String, Object> localExtras,
+            @NonNull Map<String, String> serverExtras)
+            throws Exception {
+        // Always return false, no special initialization steps to be done from here
+        return false;
+    }
+
+    @Override
+    protected void loadWithSdkInitialized(@NonNull Activity activity,
+            @NonNull Map<String, Object> localExtras,
+            @NonNull Map<String, String> serverExtras)
+            throws Exception {
+        MoPubLog.d("Requesting Tapjoy rewarded video");
+
+        String name = serverExtras.get("name");
+        if (TextUtils.isEmpty(name)) {
+            MoPubLog.d("Tapjoy interstitial loaded with empty 'name' field. Request will fail.");
+        }
+        tjPlacement = new TJPlacement(activity, name, sTapjoyListener);
+        tjPlacement.requestContent();
+    }
+
+    @Override
+    protected boolean hasVideoAvailable() {
+        return tjPlacement.isContentAvailable();
+    }
+
+    @Override
+    protected void showVideo() {
+        if (hasVideoAvailable()) {
+            MoPubLog.d("Tapjoy rewarded video will be shown.");
+            tjPlacement.showContent();
+        } else {
+            MoPubLog.d("Failed to show Tapjoy rewarded video.");
+        }
+
+    }
+
+    private static class TapjoyRewardedVideoListener implements TJPlacementListener, CustomEventRewardedVideoListener {
+        @Override
+        public void onRequestSuccess(TJPlacement placement) {
+            if (!placement.isContentAvailable()) {
+                MoPubLog.d("No Tapjoy rewarded videos available");
+                MoPubRewardedVideoManager.onRewardedVideoLoadFailure(TapjoyRewardedVideo.class, TAPJOY_AD_NETWORK_CONSTANT, MoPubErrorCode.NETWORK_NO_FILL);
+            }
+        }
+
+        @Override
+        public void onContentReady(TJPlacement placement) {
+            MoPubLog.d("Tapjoy rewarded video content is ready");
+            MoPubRewardedVideoManager.onRewardedVideoLoadSuccess(TapjoyRewardedVideo.class, TAPJOY_AD_NETWORK_CONSTANT);
+        }
+
+        @Override
+        public void onRequestFailure(TJPlacement placement, TJError error) {
+            MoPubLog.d("Tapjoy rewarded video request failed");
+            MoPubRewardedVideoManager.onRewardedVideoLoadFailure(TapjoyRewardedVideo.class, TAPJOY_AD_NETWORK_CONSTANT, MoPubErrorCode.NETWORK_NO_FILL);
+        }
+
+        @Override
+        public void onContentShow(TJPlacement placement) {
+            MoPubLog.d("Tapjoy rewarded video content shown");
+            MoPubRewardedVideoManager.onRewardedVideoStarted(TapjoyRewardedVideo.class, TAPJOY_AD_NETWORK_CONSTANT);
+        }
+
+        @Override
+        public void onContentDismiss(TJPlacement placement) {
+            MoPubLog.d("Tapjoy rewarded video content dismissed");
+            MoPubRewardedVideoManager.onRewardedVideoClosed(TapjoyRewardedVideo.class, TAPJOY_AD_NETWORK_CONSTANT);
+        }
+
+        @Override
+        public void onPurchaseRequest(TJPlacement placement, TJActionRequest request,
+                String productId) {
+        }
+
+        @Override
+        public void onRewardRequest(TJPlacement placement, TJActionRequest request, String itemId,
+                int quantity) {
+        }
+    }
+
+    public static final class TapjoyMediationSettings implements MediationSettings {
+        public TapjoyMediationSettings() {
+
+        }
+    }
+
+}
diff --git a/extras/src/com/mopub/mobileads/VungleInterstitial.java b/extras/src/com/mopub/mobileads/VungleInterstitial.java
index 1e2ea4b8..09a39731 100644
--- a/extras/src/com/mopub/mobileads/VungleInterstitial.java
+++ b/extras/src/com/mopub/mobileads/VungleInterstitial.java
@@ -26,14 +26,13 @@
 
     private final VunglePub mVunglePub;
     private final Handler mHandler;
-    private final ScheduledThreadPoolExecutor mScheduledThreadPoolExecutor;
     private CustomEventInterstitialListener mCustomEventInterstitialListener;
     private boolean mIsLoading;
 
     public VungleInterstitial() {
         mHandler = new Handler(Looper.getMainLooper());
-        mScheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(10);
         mVunglePub = VunglePub.getInstance();
+        mIsLoading = false;
     }
 
     @Override
@@ -62,7 +61,11 @@ protected void loadInterstitial(Context context,
         // init clears the event listener.
         mVunglePub.init(context, appId);
         mVunglePub.setEventListeners(this);
-        scheduleOnInterstitialLoaded();
+        if (mVunglePub.isAdPlayable()) {
+            notifyAdAvailable();
+        } else {
+            mIsLoading = true;
+        }
     }
 
     @Override
@@ -77,7 +80,6 @@ protected void showInterstitial() {
     @Override
     protected void onInvalidate() {
         mVunglePub.clearEventListeners();
-        mScheduledThreadPoolExecutor.shutdownNow();
         mIsLoading = false;
     }
 
@@ -85,28 +87,15 @@ private boolean extrasAreValid(Map<String, String> serverExtras) {
         return serverExtras.containsKey(APP_ID_KEY);
     }
 
-    private void scheduleOnInterstitialLoaded() {
-        Runnable runnable = new Runnable() {
+    private void notifyAdAvailable() {
+        Log.d("MoPub", "Vungle interstitial ad successfully loaded.");
+        mIsLoading = false;
+        mHandler.post(new Runnable() {
             @Override
             public void run() {
-            if (mVunglePub.isAdPlayable()) {
-                Log.d("MoPub", "Vungle interstitial ad successfully loaded.");
-                mScheduledThreadPoolExecutor.shutdownNow();
-                mHandler.post(new Runnable() {
-                    @Override
-                    public void run() {
-                        mCustomEventInterstitialListener.onInterstitialLoaded();
-                    }
-                });
-                mIsLoading = false;
-            }
+                mCustomEventInterstitialListener.onInterstitialLoaded();
             }
-        };
-
-        if (!mIsLoading) {
-            mScheduledThreadPoolExecutor.scheduleAtFixedRate(runnable, 1, 1, TimeUnit.SECONDS);
-            mIsLoading = true;
-        }
+        });
     }
 
     /*
@@ -151,12 +140,8 @@ public void onAdUnavailable(final String s) {
 
     @Override
     public void onAdPlayableChanged(final boolean playable) {
-        // Do nothing here. After loading is kicked off, we scheduleOnInterstitialLoaded and check until
-        // we have a playable ad or we timeout.
-    }
-
-    @Deprecated // for testing
-    ScheduledThreadPoolExecutor getScheduledThreadPoolExecutor() {
-        return mScheduledThreadPoolExecutor;
+        if (mIsLoading && playable) {
+            notifyAdAvailable();
+        }
     }
 }
diff --git a/extras/src/com/mopub/mobileads/VungleRewardedVideo.java b/extras/src/com/mopub/mobileads/VungleRewardedVideo.java
index 9d020b40..8f5a8245 100644
--- a/extras/src/com/mopub/mobileads/VungleRewardedVideo.java
+++ b/extras/src/com/mopub/mobileads/VungleRewardedVideo.java
@@ -36,7 +36,7 @@
 
     // This has to be reinitialized every time the CE loads to avoid conflict with the interstitials.
     private static VunglePub sVunglePub;
-    private static VungleRewardedVideoListener sVungleListener = new VungleRewardedVideoListener();
+    private static VungleRewardedVideoListener sVungleListener;
     private static boolean sInitialized;
     private static final LifecycleListener sLifecycleListener = new BaseLifecycleListener() {
         @Override
@@ -53,14 +53,12 @@ public void onResume(@NonNull final Activity activity) {
     };
 
     private final Handler mHandler;
-    private final ScheduledThreadPoolExecutor mScheduledThreadPoolExecutor;
     private boolean mIsLoading;
     private String mAdUnitId;
 
-
     public VungleRewardedVideo() {
+        sVungleListener = new VungleRewardedVideoListener();
         mHandler = new Handler(Looper.getMainLooper());
-        mScheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(1);
         mIsLoading = false;
     }
 
@@ -105,7 +103,11 @@ protected void loadWithSdkInitialized(@NonNull final Activity activity, @NonNull
         if (adUnitObject instanceof String) {
             mAdUnitId = (String) adUnitObject;
         }
-        scheduleOnVideoLoaded();
+        if (sVunglePub.isAdPlayable()) {
+            notifyAdAvailable();
+        } else {
+            mIsLoading = true;
+        }
     }
 
     @Override
@@ -154,36 +156,24 @@ private void modifyAdConfig(AdConfig adConfig, VungleMediationSettings mediation
         }
     }
 
-    private void scheduleOnVideoLoaded() {
-        Runnable runnable = new Runnable() {
+    private void notifyAdAvailable() {
+        MoPubLog.d("Vungle rewarded video ad successfully loaded.");
+        mIsLoading = false;
+        mHandler.post(new Runnable() {
             @Override
             public void run() {
-                if (sVunglePub.isAdPlayable()) {
-                    MoPubLog.d("Vungle interstitial ad successfully loaded.");
-                    mScheduledThreadPoolExecutor.shutdownNow();
-                    mHandler.post(new Runnable() {
-                        @Override
-                        public void run() {
-                            MoPubRewardedVideoManager.onRewardedVideoLoadSuccess(VungleRewardedVideo.class, VUNGLE_AD_NETWORK_CONSTANT);
-                        }
-                    });
-                    mIsLoading = false;
-                }
+                MoPubRewardedVideoManager.onRewardedVideoLoadSuccess(VungleRewardedVideo.class,
+                        VUNGLE_AD_NETWORK_CONSTANT);
             }
-        };
-
-        if (!mIsLoading) {
-            mScheduledThreadPoolExecutor.scheduleAtFixedRate(runnable, 1, 1, TimeUnit.SECONDS);
-            mIsLoading = true;
-        }
+        });
     }
 
     @Override
     protected void onInvalidate() {
-        mScheduledThreadPoolExecutor.shutdownNow();
+        mIsLoading = false;
     }
 
-    private static class VungleRewardedVideoListener implements EventListener,
+    private class VungleRewardedVideoListener implements EventListener,
             CustomEventRewardedVideoListener {
 
         @Override
@@ -210,8 +200,9 @@ public void onAdUnavailable(final String s) {
 
         @Override
         public void onAdPlayableChanged(final boolean playable) {
-            // Do nothing here. After loading is kicked off, we scheduleOnInterstitialLoaded and check until
-            // we have a playable ad or we timeout.
+            if (mIsLoading && playable) {
+                notifyAdAvailable();
+            }
         }
 
         @Override
diff --git a/extras/src/com/mopub/nativeads/FacebookAdRenderer.java b/extras/src/com/mopub/nativeads/FacebookAdRenderer.java
new file mode 100644
index 00000000..72e87349
--- /dev/null
+++ b/extras/src/com/mopub/nativeads/FacebookAdRenderer.java
@@ -0,0 +1,209 @@
+package com.mopub.nativeads;
+
+import android.app.Activity;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ImageView;
+import android.widget.RelativeLayout;
+import android.widget.TextView;
+
+import com.facebook.ads.MediaView;
+import com.mopub.common.Preconditions;
+
+import java.util.WeakHashMap;
+
+import static android.view.View.VISIBLE;
+
+/**
+ * Include this class if you want to use Facebook native video ads. This renderer handles Facebook
+ * static and video native ads. This will automatically replace the main image view with the
+ * Facebook MediaView that handles showing the main asset.
+ */
+public class FacebookAdRenderer implements MoPubAdRenderer<FacebookNative.FacebookVideoEnabledNativeAd> {
+    private final ViewBinder mViewBinder;
+
+    // This is used instead of View.setTag, which causes a memory leak in 2.3
+    // and earlier: https://code.google.com/p/android/issues/detail?id=18273
+    final WeakHashMap<View, FacebookNativeViewHolder> mViewHolderMap;
+
+    /**
+     * Constructs a native ad renderer with a view binder.
+     *
+     * @param viewBinder The view binder to use when inflating and rendering an ad.
+     */
+    public FacebookAdRenderer(final ViewBinder viewBinder) {
+        mViewBinder = viewBinder;
+        mViewHolderMap = new WeakHashMap<View, FacebookNativeViewHolder>();
+    }
+
+    @Override
+    public View createAdView(final Activity activity, final ViewGroup parent) {
+        final View adView = LayoutInflater
+                .from(activity)
+                .inflate(mViewBinder.layoutId, parent, false);
+        final View mainImageView = adView.findViewById(mViewBinder.mainImageId);
+        if (mainImageView == null) {
+            return adView;
+        }
+
+        final ViewGroup.LayoutParams mainImageViewLayoutParams = mainImageView.getLayoutParams();
+        final MediaView.LayoutParams mediaViewLayoutParams = new MediaView.LayoutParams(
+                mainImageViewLayoutParams.width, mainImageViewLayoutParams.height);
+
+        if (mainImageViewLayoutParams instanceof ViewGroup.MarginLayoutParams) {
+            final ViewGroup.MarginLayoutParams marginParams =
+                    (ViewGroup.MarginLayoutParams) mainImageViewLayoutParams;
+            mediaViewLayoutParams.setMargins(marginParams.leftMargin,
+                    marginParams.topMargin,
+                    marginParams.rightMargin,
+                    marginParams.bottomMargin);
+        }
+
+        if (mainImageViewLayoutParams instanceof RelativeLayout.LayoutParams) {
+            final RelativeLayout.LayoutParams mainImageViewRelativeLayoutParams =
+                    (RelativeLayout.LayoutParams) mainImageViewLayoutParams;
+            final int[] rules = mainImageViewRelativeLayoutParams.getRules();
+            for (int i = 0; i < rules.length; i++) {
+                mediaViewLayoutParams.addRule(i, rules[i]);
+            }
+            mainImageView.setVisibility(View.INVISIBLE);
+        } else {
+            mainImageView.setVisibility(View.GONE);
+        }
+
+        final MediaView mediaView = new MediaView(activity);
+        ViewGroup mainImageParent = (ViewGroup) mainImageView.getParent();
+        int mainImageIndex = mainImageParent.indexOfChild(mainImageView);
+        mainImageParent.addView(mediaView, mainImageIndex + 1, mediaViewLayoutParams);
+        return adView;
+    }
+
+    @Override
+    public void renderAdView(final View view,
+            final FacebookNative.FacebookVideoEnabledNativeAd facebookVideoEnabledNativeAd) {
+        FacebookNativeViewHolder facebookNativeViewHolder = mViewHolderMap.get(view);
+        if (facebookNativeViewHolder == null) {
+            facebookNativeViewHolder = FacebookNativeViewHolder.fromViewBinder(view, mViewBinder);
+            mViewHolderMap.put(view, facebookNativeViewHolder);
+        }
+
+        update(facebookNativeViewHolder, facebookVideoEnabledNativeAd);
+        NativeRendererHelper.updateExtras(facebookNativeViewHolder.getMainView(),
+                mViewBinder.extras,
+                facebookVideoEnabledNativeAd.getExtras());
+        setViewVisibility(facebookNativeViewHolder, VISIBLE);
+    }
+
+    @Override
+    public boolean supports(final BaseNativeAd nativeAd) {
+        Preconditions.checkNotNull(nativeAd);
+        return nativeAd instanceof FacebookNative.FacebookVideoEnabledNativeAd;
+    }
+
+    private void update(final FacebookNativeViewHolder facebookNativeViewHolder,
+            final FacebookNative.FacebookVideoEnabledNativeAd nativeAd) {
+        final ImageView mainImageView = facebookNativeViewHolder.getMainImageView();
+        NativeRendererHelper.addTextView(facebookNativeViewHolder.getTitleView(),
+                nativeAd.getTitle());
+        NativeRendererHelper.addTextView(facebookNativeViewHolder.getTextView(), nativeAd.getText());
+        NativeRendererHelper.addTextView(facebookNativeViewHolder.getCallToActionView(),
+                nativeAd.getCallToAction());
+        NativeImageHelper.loadImageView(nativeAd.getMainImageUrl(), mainImageView);
+        NativeImageHelper.loadImageView(nativeAd.getIconImageUrl(),
+                facebookNativeViewHolder.getIconImageView());
+        NativeRendererHelper.addPrivacyInformationIcon(
+                facebookNativeViewHolder.getPrivacyInformationIconImageView(),
+                nativeAd.getPrivacyInformationIconImageUrl(),
+                nativeAd.getPrivacyInformationIconClickThroughUrl());
+        final MediaView mediaView = facebookNativeViewHolder.getMediaView();
+        if (mediaView != null && mainImageView != null) {
+            nativeAd.updateMediaView(mediaView);
+            mediaView.setVisibility(View.VISIBLE);
+            if (facebookNativeViewHolder.isMainImageViewInRelativeView()) {
+                mainImageView.setVisibility(View.INVISIBLE);
+            } else {
+                mainImageView.setVisibility(View.GONE);
+            }
+
+        }
+    }
+
+    private static void setViewVisibility(final FacebookNativeViewHolder facebookNativeViewHolder,
+            final int visibility) {
+        if (facebookNativeViewHolder.getMainView() != null) {
+            facebookNativeViewHolder.getMainView().setVisibility(visibility);
+        }
+    }
+
+    static class FacebookNativeViewHolder {
+        private final StaticNativeViewHolder mStaticNativeViewHolder;
+        private final MediaView mMediaView;
+        private final boolean isMainImageViewInRelativeView;
+
+        // Use fromViewBinder instead of a constructor
+        private FacebookNativeViewHolder(final StaticNativeViewHolder staticNativeViewHolder,
+                final MediaView mediaView, final boolean mainImageViewInRelativeView) {
+            mStaticNativeViewHolder = staticNativeViewHolder;
+            mMediaView = mediaView;
+            isMainImageViewInRelativeView = mainImageViewInRelativeView;
+        }
+
+        static FacebookNativeViewHolder fromViewBinder(final View view,
+                final ViewBinder viewBinder) {
+            StaticNativeViewHolder staticNativeViewHolder = StaticNativeViewHolder.fromViewBinder(view, viewBinder);
+            final View mainImageView = staticNativeViewHolder.mainImageView;
+            boolean mainImageViewInRelativeView = false;
+            MediaView mediaView = null;
+            if (mainImageView != null) {
+                final ViewGroup mainImageParent = (ViewGroup) mainImageView.getParent();
+                if (mainImageParent instanceof RelativeLayout) {
+                    mainImageViewInRelativeView = true;
+                }
+                final int mainImageIndex = mainImageParent.indexOfChild(mainImageView);
+                final View viewAfterImageView = mainImageParent.getChildAt(mainImageIndex + 1);
+                if (viewAfterImageView instanceof MediaView) {
+                    mediaView = (MediaView) viewAfterImageView;
+                }
+            }
+            return new FacebookNativeViewHolder(staticNativeViewHolder, mediaView, mainImageViewInRelativeView);
+        }
+
+        public View getMainView() {
+            return mStaticNativeViewHolder.mainView;
+        }
+
+        public TextView getTitleView() {
+            return mStaticNativeViewHolder.titleView;
+        }
+
+        public TextView getTextView() {
+            return mStaticNativeViewHolder.textView;
+        }
+
+        public TextView getCallToActionView() {
+            return mStaticNativeViewHolder.callToActionView;
+        }
+
+        public ImageView getMainImageView() {
+            return mStaticNativeViewHolder.mainImageView;
+        }
+
+        public ImageView getIconImageView() {
+            return mStaticNativeViewHolder.iconImageView;
+        }
+
+        public ImageView getPrivacyInformationIconImageView() {
+            return mStaticNativeViewHolder.privacyInformationIconImageView;
+        }
+
+        public MediaView getMediaView() {
+            return mMediaView;
+        }
+
+        public boolean isMainImageViewInRelativeView() {
+            return isMainImageViewInRelativeView;
+        }
+    }
+}
+
diff --git a/extras/src/com/mopub/nativeads/FacebookNative.java b/extras/src/com/mopub/nativeads/FacebookNative.java
index 76985261..ab951a6d 100644
--- a/extras/src/com/mopub/nativeads/FacebookNative.java
+++ b/extras/src/com/mopub/nativeads/FacebookNative.java
@@ -1,5 +1,6 @@
 package com.mopub.nativeads;
 
+import android.app.Activity;
 import android.content.Context;
 import android.view.View;
 
@@ -7,22 +8,46 @@
 import com.facebook.ads.AdError;
 import com.facebook.ads.AdListener;
 import com.facebook.ads.ImpressionListener;
+import com.facebook.ads.MediaView;
 import com.facebook.ads.NativeAd;
 import com.facebook.ads.NativeAd.Rating;
+import com.mopub.common.Preconditions;
+import com.mopub.common.logging.MoPubLog;
 
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
-/*
- * Tested with Facebook SDK 3.23.1
+import static com.mopub.nativeads.NativeImageHelper.preCacheImages;
+
+/**
+ * Tested with Facebook SDK 4.8.1. FacebookAdRenderer is also necessary in order to show video ads.
+ * Video ads will only be shown if VIDEO_ENABLED is set to true or a server configuration
+ * "video_enabled" flag is set to true. The server configuration will override the local
+ * configuration.
  */
 public class FacebookNative extends CustomEventNative {
     private static final String PLACEMENT_ID_KEY = "placement_id";
+    private static final String VIDEO_ENABLED_KEY = "video_enabled";
+
+    /**
+     * Sets whether or not Facebook native video ads will be shown. This value is overridden with
+     * server extras.
+     */
+    private static boolean VIDEO_ENABLED = false;
+
+    /**
+     * Sets whether or not there is a video renderer available. This class will check for the
+     * default Facebook video renderer. This value can be overridden with {@link
+     * FacebookNative#setVideoRendererAvailable} if there already is a custom Facebook video
+     * renderer.
+     */
+    private static Boolean sIsVideoRendererAvailable = null;
 
     // CustomEventNative implementation
     @Override
-    protected void loadNativeAd(final Context context,
+    protected void loadNativeAd(final Activity activity,
             final CustomEventNativeListener customEventNativeListener,
             final Map<String, Object> localExtras,
             final Map<String, String> serverExtras) {
@@ -35,10 +60,66 @@ protected void loadNativeAd(final Context context,
             return;
         }
 
-        final FacebookForwardingNativeAd facebookForwardingNativeAd =
-                new FacebookForwardingNativeAd(context,
-                        new NativeAd(context, placementId), customEventNativeListener);
-        facebookForwardingNativeAd.loadAd();
+        final String videoEnabledString = serverExtras.get(VIDEO_ENABLED_KEY);
+        boolean videoEnabledFromServer = Boolean.parseBoolean(videoEnabledString);
+
+        if (sIsVideoRendererAvailable == null) {
+            try {
+                Class.forName("com.mopub.nativeads.FacebookAdRenderer");
+                sIsVideoRendererAvailable = true;
+            } catch (ClassNotFoundException e) {
+                sIsVideoRendererAvailable = false;
+            }
+        }
+
+        if (shouldUseVideoEnabledNativeAd(sIsVideoRendererAvailable, videoEnabledString,
+                videoEnabledFromServer)) {
+            final FacebookVideoEnabledNativeAd facebookVideoEnabledNativeAd =
+                    new FacebookVideoEnabledNativeAd(activity,
+                            new NativeAd(activity, placementId), customEventNativeListener);
+            facebookVideoEnabledNativeAd.loadAd();
+        } else {
+            final FacebookStaticNativeAd facebookStaticNativeAd = new FacebookStaticNativeAd(
+                    activity, new NativeAd(activity, placementId), customEventNativeListener);
+            facebookStaticNativeAd.loadAd();
+        }
+    }
+
+    /**
+     * Sets whether Facebook native video ads may be shown. This value is overridden by the value of
+     * the "video_enabled" key that may be sent from the MoPub ad server.
+     * com.mopub.nativeads.FacebookAdRenderer must also be used to display video-enabled ads.
+     *
+     * @param videoEnabled True if you want to enable Facebook native video.
+     */
+    public static void setVideoEnabled(final boolean videoEnabled) {
+        VIDEO_ENABLED = videoEnabled;
+    }
+
+    /**
+     * Sets whether a renderer is available that supports Facebook video ads.
+     * <p/>
+     * If you use a custom renderer class that is not com.mopub.nativeads.FacebookAdRenderer to show
+     * video-enabled native ads, you should set this to true.
+     *
+     * @param videoRendererAvailable Whether or not there is a renderer available for video-enabled
+     *                               Facebook native ads.
+     */
+    public static void setVideoRendererAvailable(final boolean videoRendererAvailable) {
+        sIsVideoRendererAvailable = videoRendererAvailable;
+    }
+
+    static boolean shouldUseVideoEnabledNativeAd(final boolean isVideoRendererAvailable,
+            final String videoEnabledString, final boolean videoEnabledFromServer) {
+        if (!isVideoRendererAvailable) {
+            return false;
+        }
+        return (videoEnabledString != null && videoEnabledFromServer) ||
+                (videoEnabledString == null && VIDEO_ENABLED);
+    }
+
+    static Boolean isVideoRendererAvailable() {
+        return sIsVideoRendererAvailable;
     }
 
     private boolean extrasAreValid(final Map<String, String> serverExtras) {
@@ -46,14 +127,14 @@ private boolean extrasAreValid(final Map<String, String> serverExtras) {
         return (placementId != null && placementId.length() > 0);
     }
 
-    static class FacebookForwardingNativeAd extends BaseForwardingNativeAd implements AdListener, ImpressionListener {
+    static class FacebookStaticNativeAd extends StaticNativeAd implements AdListener, ImpressionListener {
         private static final String SOCIAL_CONTEXT_FOR_AD = "socialContextForAd";
 
         private final Context mContext;
         private final NativeAd mNativeAd;
         private final CustomEventNativeListener mCustomEventNativeListener;
 
-        FacebookForwardingNativeAd(final Context context,
+        FacebookStaticNativeAd(final Context context,
                 final NativeAd nativeAd,
                 final CustomEventNativeListener customEventNativeListener) {
             mContext = context.getApplicationContext();
@@ -80,10 +161,10 @@ public void onAdLoaded(final Ad ad) {
             setTitle(mNativeAd.getAdTitle());
             setText(mNativeAd.getAdBody());
 
-            NativeAd.Image coverImage = mNativeAd.getAdCoverImage();
+            final NativeAd.Image coverImage = mNativeAd.getAdCoverImage();
             setMainImageUrl(coverImage == null ? null : coverImage.getUrl());
 
-            NativeAd.Image icon = mNativeAd.getAdIcon();
+            final NativeAd.Image icon = mNativeAd.getAdIcon();
             setIconImageUrl(icon == null ? null : icon.getUrl());
 
             setCallToAction(mNativeAd.getAdCallToAction());
@@ -91,6 +172,11 @@ public void onAdLoaded(final Ad ad) {
 
             addExtra(SOCIAL_CONTEXT_FOR_AD, mNativeAd.getAdSocialContext());
 
+            final NativeAd.Image adChoicesIconImage = mNativeAd.getAdChoicesIcon();
+            setPrivacyInformationIconImageUrl(adChoicesIconImage == null ? null : adChoicesIconImage
+                    .getUrl());
+            setPrivacyInformationIconClickThroughUrl(mNativeAd.getAdChoicesLinkUrl());
+
             final List<String> imageUrls = new ArrayList<String>();
             final String mainImageUrl = getMainImageUrl();
             if (mainImageUrl != null) {
@@ -100,11 +186,15 @@ public void onAdLoaded(final Ad ad) {
             if (iconUrl != null) {
                 imageUrls.add(getIconImageUrl());
             }
+            final String privacyInformationIconImageUrl = getPrivacyInformationIconImageUrl();
+            if (privacyInformationIconImageUrl != null) {
+                imageUrls.add(privacyInformationIconImageUrl);
+            }
 
-            preCacheImages(mContext, imageUrls, new ImageListener() {
+            preCacheImages(mContext, imageUrls, new NativeImageHelper.ImageListener() {
                 @Override
                 public void onImagesCached() {
-                    mCustomEventNativeListener.onNativeAdLoaded(FacebookForwardingNativeAd.this);
+                    mCustomEventNativeListener.onNativeAdLoaded(FacebookStaticNativeAd.this);
                 }
 
                 @Override
@@ -142,8 +232,6 @@ public void onLoggingImpression(final Ad ad) {
         @Override
         public void prepare(final View view) {
             mNativeAd.registerViewForInteraction(view);
-            setOverridingClickTracker(true);
-            setOverridingImpressionTracker(true);
         }
 
         @Override
@@ -164,4 +252,240 @@ private Double getDoubleRating(final Rating rating) {
             return MAX_STAR_RATING * rating.getValue() / rating.getScale();
         }
     }
+
+
+    static class FacebookVideoEnabledNativeAd extends BaseNativeAd implements AdListener, ImpressionListener {
+        private static final String SOCIAL_CONTEXT_FOR_AD = "socialContextForAd";
+
+        static final double MIN_STAR_RATING = 0;
+        static final double MAX_STAR_RATING = 5;
+
+        private final Context mContext;
+        private final NativeAd mNativeAd;
+        private final CustomEventNativeListener mCustomEventNativeListener;
+
+        private Double mStarRating;
+
+        private final Map<String, Object> mExtras;
+
+        FacebookVideoEnabledNativeAd(final Context context,
+                final NativeAd nativeAd,
+                final CustomEventNativeListener customEventNativeListener) {
+            mContext = context.getApplicationContext();
+            mNativeAd = nativeAd;
+            mCustomEventNativeListener = customEventNativeListener;
+            mExtras = new HashMap<String, Object>();
+        }
+
+        void loadAd() {
+            mNativeAd.setAdListener(this);
+            mNativeAd.setImpressionListener(this);
+            mNativeAd.loadAd();
+        }
+
+        /**
+         * Returns the String corresponding to the ad's title.
+         */
+        final public String getTitle() {
+            return mNativeAd.getAdTitle();
+        }
+
+        /**
+         * Returns the String corresponding to the ad's body text. May be null.
+         */
+        final public String getText() {
+            return mNativeAd.getAdBody();
+        }
+
+        /**
+         * Returns the String url corresponding to the ad's main image. May be null.
+         */
+        final public String getMainImageUrl() {
+            final NativeAd.Image coverImage = mNativeAd.getAdCoverImage();
+            return coverImage == null ? null : coverImage.getUrl();
+        }
+
+        /**
+         * Returns the String url corresponding to the ad's icon image. May be null.
+         */
+        final public String getIconImageUrl() {
+            final NativeAd.Image icon = mNativeAd.getAdIcon();
+            return icon == null ? null : icon.getUrl();
+        }
+
+        /**
+         * Returns the Call To Action String (i.e. "Download" or "Learn More") associated with this ad.
+         */
+        final public String getCallToAction() {
+            return mNativeAd.getAdCallToAction();
+        }
+
+        /**
+         * For app install ads, this returns the associated star rating (on a 5 star scale) for the
+         * advertised app. Note that this method may return null if the star rating was either never set
+         * or invalid.
+         */
+        final public Double getStarRating() {
+            return mStarRating;
+        }
+
+        /**
+         * Returns the Privacy Information click through url.
+         *
+         * @return String representing the Privacy Information Icon click through url, or {@code null}
+         * if not set.
+         */
+        final public String getPrivacyInformationIconClickThroughUrl() {
+            return mNativeAd.getAdChoicesLinkUrl();
+        }
+
+        /**
+         * Returns the Privacy Information image url.
+         *
+         * @return String representing the Privacy Information Icon click through url, or {@code
+         * null} if not set.
+         */
+        final public String getPrivacyInformationIconImageUrl() {
+            return mNativeAd.getAdChoicesIcon() == null ? null : mNativeAd.getAdChoicesIcon().getUrl();
+        }
+
+        // AdListener
+        @Override
+        public void onAdLoaded(final Ad ad) {
+            // This identity check is from Facebook's Native API sample code:
+            // https://developers.facebook.com/docs/audience-network/android/native-api
+            if (!mNativeAd.equals(ad) || !mNativeAd.isAdLoaded()) {
+                mCustomEventNativeListener.onNativeAdFailed(NativeErrorCode.NETWORK_INVALID_STATE);
+                return;
+            }
+
+            setStarRating(getDoubleRating(mNativeAd.getAdStarRating()));
+
+            addExtra(SOCIAL_CONTEXT_FOR_AD, mNativeAd.getAdSocialContext());
+
+            final List<String> imageUrls = new ArrayList<String>();
+            final String mainImageUrl = getMainImageUrl();
+            if (mainImageUrl != null) {
+                imageUrls.add(mainImageUrl);
+            }
+            final String iconImageUrl = getIconImageUrl();
+            if (iconImageUrl != null) {
+                imageUrls.add(iconImageUrl);
+            }
+            final String privacyInformationIconImageUrl = getPrivacyInformationIconImageUrl();
+            if (privacyInformationIconImageUrl != null) {
+                imageUrls.add(privacyInformationIconImageUrl);
+            }
+
+            preCacheImages(mContext, imageUrls, new NativeImageHelper.ImageListener() {
+                @Override
+                public void onImagesCached() {
+                    mCustomEventNativeListener.onNativeAdLoaded(FacebookVideoEnabledNativeAd.this);
+                }
+
+                @Override
+                public void onImagesFailedToCache(NativeErrorCode errorCode) {
+                    mCustomEventNativeListener.onNativeAdFailed(errorCode);
+                }
+            });
+        }
+
+        @Override
+        public void onError(final Ad ad, final AdError adError) {
+            if (adError == null) {
+                mCustomEventNativeListener.onNativeAdFailed(NativeErrorCode.UNSPECIFIED);
+            } else if (adError.getErrorCode() == AdError.NO_FILL.getErrorCode()) {
+                mCustomEventNativeListener.onNativeAdFailed(NativeErrorCode.NETWORK_NO_FILL);
+            } else if (adError.getErrorCode() == AdError.INTERNAL_ERROR.getErrorCode()) {
+                mCustomEventNativeListener.onNativeAdFailed(NativeErrorCode.NETWORK_INVALID_STATE);
+            } else {
+                mCustomEventNativeListener.onNativeAdFailed(NativeErrorCode.UNSPECIFIED);
+            }
+        }
+
+        @Override
+        public void onAdClicked(final Ad ad) {
+            notifyAdClicked();
+        }
+
+        // ImpressionListener
+        @Override
+        public void onLoggingImpression(final Ad ad) {
+            notifyAdImpressed();
+        }
+
+        // BaseForwardingNativeAd
+        @Override
+        public void prepare(final View view) {
+            mNativeAd.registerViewForInteraction(view);
+        }
+
+        @Override
+        public void clear(final View view) {
+            mNativeAd.unregisterView();
+        }
+
+        @Override
+        public void destroy() {
+            mNativeAd.destroy();
+        }
+
+        /**
+         * Given a particular String key, return the associated Object value from the ad's extras map.
+         * See {@link StaticNativeAd#getExtras()} for more information.
+         */
+        final public Object getExtra(final String key) {
+            if (!Preconditions.NoThrow.checkNotNull(key, "getExtra key is not allowed to be null")) {
+                return null;
+            }
+            return mExtras.get(key);
+        }
+
+        /**
+         * Returns a copy of the extras map, reflecting additional ad content not reflected in any
+         * of the above hardcoded setters. This is particularly useful for passing down custom fields
+         * with MoPub's direct-sold native ads or from mediated networks that pass back additional
+         * fields.
+         */
+        final public Map<String, Object> getExtras() {
+            return new HashMap<String, Object>(mExtras);
+        }
+
+        final public void addExtra( final String key, final Object value) {
+            if (!Preconditions.NoThrow.checkNotNull(key, "addExtra key is not allowed to be null")) {
+                return;
+            }
+            mExtras.put(key, value);
+        }
+
+        /**
+         * Attaches the native ad to the MediaView, if it exists.
+         *
+         * @param mediaView The View that holds the main media.
+         */
+        public void updateMediaView(final MediaView mediaView) {
+            if (mediaView != null) {
+                mediaView.setNativeAd(mNativeAd);
+            }
+        }
+
+        private void setStarRating(final Double starRating) {
+            if (starRating == null) {
+                mStarRating = null;
+            } else if (starRating >= MIN_STAR_RATING && starRating <= MAX_STAR_RATING) {
+                mStarRating = starRating;
+            } else {
+                MoPubLog.d("Ignoring attempt to set invalid star rating (" + starRating + "). Must be "
+                        + "between " + MIN_STAR_RATING + " and " + MAX_STAR_RATING + ".");
+            }
+        }
+
+        private Double getDoubleRating(final Rating rating) {
+            if (rating == null) {
+                return null;
+            }
+
+            return MAX_STAR_RATING * rating.getValue() / rating.getScale();
+        }
+    }
 }
diff --git a/extras/src/com/mopub/nativeads/InMobiNative.java b/extras/src/com/mopub/nativeads/InMobiNative.java
index ae00d72a..0c0c7a04 100644
--- a/extras/src/com/mopub/nativeads/InMobiNative.java
+++ b/extras/src/com/mopub/nativeads/InMobiNative.java
@@ -10,6 +10,7 @@
 import com.inmobi.monetization.IMErrorCode;
 import com.inmobi.monetization.IMNative;
 import com.inmobi.monetization.IMNativeListener;
+import com.mopub.common.logging.MoPubLog;
 
 import org.json.JSONException;
 import org.json.JSONObject;
@@ -21,6 +22,7 @@
 
 import static com.mopub.common.util.Json.getJsonValue;
 import static com.mopub.common.util.Numbers.parseDouble;
+import static com.mopub.nativeads.NativeImageHelper.preCacheImages;
 
 /*
  * Tested with InMobi SDK 4.4.1
@@ -30,17 +32,11 @@
 
     // CustomEventNative implementation
     @Override
-    protected void loadNativeAd(final Context context,
+    protected void loadNativeAd(final Activity activity,
             final CustomEventNativeListener customEventNativeListener,
             final Map<String, Object> localExtras,
             final Map<String, String> serverExtras) {
 
-        if (!(context instanceof Activity)) {
-            customEventNativeListener.onNativeAdFailed(NativeErrorCode.NATIVE_ADAPTER_CONFIGURATION_ERROR);
-            return;
-        }
-        final Activity activity = (Activity) context;
-
         final String appId;
         if (extrasAreValid(serverExtras)) {
             appId = serverExtras.get(APP_ID_KEY);
@@ -50,10 +46,13 @@ protected void loadNativeAd(final Context context,
         }
 
         InMobi.initialize(activity, appId);
-        final InMobiForwardingNativeAd inMobiForwardingNativeAd =
-                new InMobiForwardingNativeAd(context, customEventNativeListener);
-        inMobiForwardingNativeAd.setIMNative(new IMNative(inMobiForwardingNativeAd));
-        inMobiForwardingNativeAd.loadAd();
+        final InMobiStaticNativeAd inMobiStaticNativeAd =
+                new InMobiStaticNativeAd(activity,
+                        new ImpressionTracker(activity),
+                        new NativeClickHandler(activity),
+                        customEventNativeListener);
+        inMobiStaticNativeAd.setIMNative(new IMNative(inMobiStaticNativeAd));
+        inMobiStaticNativeAd.loadAd();
     }
 
     private boolean extrasAreValid(final Map<String, String> serverExtras) {
@@ -61,7 +60,7 @@ private boolean extrasAreValid(final Map<String, String> serverExtras) {
         return (placementId != null && placementId.length() > 0);
     }
 
-    static class InMobiForwardingNativeAd extends BaseForwardingNativeAd implements IMNativeListener {
+    static class InMobiStaticNativeAd extends StaticNativeAd implements IMNativeListener {
         static final int IMPRESSION_MIN_TIME_VIEWED = 0;
 
         // Modifiable keys
@@ -78,11 +77,17 @@ private boolean extrasAreValid(final Map<String, String> serverExtras) {
 
         private final Context mContext;
         private final CustomEventNativeListener mCustomEventNativeListener;
+        private final ImpressionTracker mImpressionTracker;
+        private final NativeClickHandler mNativeClickHandler;
         private IMNative mImNative;
 
-        InMobiForwardingNativeAd(final Context context,
+        InMobiStaticNativeAd(final Context context,
+                final ImpressionTracker impressionTracker,
+                final NativeClickHandler nativeClickHandler,
                 final CustomEventNativeListener customEventNativeListener) {
             mContext = context.getApplicationContext();
+            mImpressionTracker = impressionTracker;
+            mNativeClickHandler = nativeClickHandler;
             mCustomEventNativeListener = customEventNativeListener;
         }
 
@@ -105,7 +110,7 @@ public void onNativeRequestSucceeded(final IMNative imNative) {
             try {
                 parseJson(imNative);
             } catch (JSONException e) {
-                mCustomEventNativeListener.onNativeAdFailed(NativeErrorCode.INVALID_JSON);
+                mCustomEventNativeListener.onNativeAdFailed(NativeErrorCode.INVALID_RESPONSE);
                 return;
             }
 
@@ -120,10 +125,10 @@ public void onNativeRequestSucceeded(final IMNative imNative) {
                 imageUrls.add(iconUrl);
             }
 
-            preCacheImages(mContext, imageUrls, new ImageListener() {
+            preCacheImages(mContext, imageUrls, new NativeImageHelper.ImageListener() {
                 @Override
                 public void onImagesCached() {
-                    mCustomEventNativeListener.onNativeAdLoaded(InMobiForwardingNativeAd.this);
+                    mCustomEventNativeListener.onNativeAdLoaded(InMobiStaticNativeAd.this);
                 }
 
                 @Override
@@ -146,6 +151,7 @@ public void onNativeRequestFailed(final IMErrorCode errorCode) {
             }
         }
 
+        // Lifecycle Handlers
         @Override
         public void prepare(final View view) {
             if (view != null && view instanceof ViewGroup) {
@@ -155,16 +161,33 @@ public void prepare(final View view) {
             } else {
                 Log.e("MoPub", "InMobi did not receive ViewGroup to attachToView, unable to record impressions");
             }
+            mImpressionTracker.addView(view, this);
+            mNativeClickHandler.setOnClickListener(view, this);
         }
 
         @Override
-        public void handleClick(final View view) {
-            mImNative.handleClick(null);
+        public void clear(final View view) {
+            mImpressionTracker.removeView(view);
+            mNativeClickHandler.clearOnClickListener(view);
         }
 
         @Override
         public void destroy() {
             mImNative.detachFromView();
+            mImpressionTracker.destroy();
+        }
+
+        // Event Handlers
+        @Override
+        public void recordImpression(final View view) {
+            notifyAdImpressed();
+        }
+
+        @Override
+        public void handleClick(final View view) {
+            notifyAdClicked();
+            mNativeClickHandler.openClickDestinationUrl(getClickDestinationUrl(), view);
+            mImNative.handleClick(null);
         }
 
         void parseJson(final IMNative imNative) throws JSONException  {
@@ -184,7 +207,15 @@ void parseJson(final IMNative imNative) throws JSONException  {
                 setIconImageUrl(getJsonValue(iconJsonObject, URL, String.class));
             }
 
-            setClickDestinationUrl(getJsonValue(jsonObject, LANDING_URL, String.class));
+            final String clickDestinationUrl = getJsonValue(jsonObject, LANDING_URL, String.class);
+            if (clickDestinationUrl == null) {
+                final String errorMessage = "InMobi JSON response missing required key: "
+                        + LANDING_URL + ". Failing over.";
+                MoPubLog.d(errorMessage);
+                throw new JSONException(errorMessage);
+            }
+
+            setClickDestinationUrl(clickDestinationUrl);
             setCallToAction(getJsonValue(jsonObject, CTA, String.class));
 
             try {
diff --git a/extras/src/com/mopub/nativeads/MillennialNative.java b/extras/src/com/mopub/nativeads/MillennialNative.java
index 26efa0a8..7a312731 100644
--- a/extras/src/com/mopub/nativeads/MillennialNative.java
+++ b/extras/src/com/mopub/nativeads/MillennialNative.java
@@ -16,6 +16,8 @@
 import java.util.List;
 import java.util.Map;
 
+import static com.mopub.nativeads.NativeImageHelper.preCacheImages;
+
 public class MillennialNative extends CustomEventNative {
     public static final String DCN_KEY = "dcn";
     public static final String APID_KEY = "adUnitID";
@@ -23,7 +25,7 @@
     private static final Handler UI_THREAD_HANDLER = new Handler(Looper.getMainLooper());
 
     @Override
-    protected void loadNativeAd(final Context context,
+    protected void loadNativeAd(final Activity activity,
             final CustomEventNativeListener listener,
             final Map<String, Object> localExtras,
             final Map<String, String> serverExtras) {
@@ -33,7 +35,7 @@ protected void loadNativeAd(final Context context,
 
         if ( !MMSDK.isInitialized() ) {
             try {
-                MMSDK.initialize((Activity) context);
+                MMSDK.initialize(activity);
             } catch ( Exception e ) {
                 Log.e(LOGCAT_TAG, "Unable to initialize the Millennial SDK-- " + e.getMessage());
                 e.printStackTrace();
@@ -81,9 +83,14 @@ public void run() {
         }
 
         try {
-            NativeAd n = NativeAd.createInstance(placementId, NativeAd.NATIVE_TYPE_INLINE);
-            final MillennialForwardingNativeAd mmForwardingNativeAd = new MillennialForwardingNativeAd(context, n, listener);
-            mmForwardingNativeAd.loadAd();
+            NativeAd nativeAd = NativeAd.createInstance(placementId, NativeAd.NATIVE_TYPE_INLINE);
+            final MillennialStaticNativeAd millennialStaticNativeAd =
+                    new MillennialStaticNativeAd(activity,
+                            nativeAd,
+                            new ImpressionTracker(activity),
+                            new NativeClickHandler(activity),
+                            listener);
+            millennialStaticNativeAd.loadAd();
         } catch ( MMException e ) {
             UI_THREAD_HANDLER.post(new Runnable() {
                 @Override
@@ -97,21 +104,29 @@ public void run() {
     private boolean extrasAreValid(final Map<String, String> serverExtras) {
         String placementId = serverExtras.get(APID_KEY);
         return (serverExtras.containsKey(APID_KEY) &&
-                placementId != null & placementId.length() > 0 );
+                placementId != null && placementId.length() > 0 );
     }
 
 
-    static class MillennialForwardingNativeAd extends BaseForwardingNativeAd implements NativeAd.NativeListener {
-        private Context context;
-        private NativeAd nativeAd;
-        private CustomEventNativeListener listener;
-        private MillennialForwardingNativeAd millennialForwardingNativeAd;
-
-        public MillennialForwardingNativeAd(final Context context, final NativeAd nativeAd, final CustomEventNativeListener customEventNativeListener) {
-            this.context = context.getApplicationContext();
-            this.nativeAd = nativeAd;
-            this.listener = customEventNativeListener;
-            this.millennialForwardingNativeAd = this;
+    static class MillennialStaticNativeAd extends StaticNativeAd implements NativeAd.NativeListener {
+        private final Context mContext;
+        private NativeAd mNativeAd;
+        private final ImpressionTracker mImpressionTracker;
+        private final NativeClickHandler mNativeClickHandler;
+        private final CustomEventNativeListener mListener;
+        private final MillennialStaticNativeAd mMillennialStaticNativeAd;
+
+        public MillennialStaticNativeAd(final Context context,
+                final NativeAd nativeAd,
+                final ImpressionTracker impressionTracker,
+                final NativeClickHandler nativeClickHandler,
+                final CustomEventNativeListener customEventNativeListener) {
+            mContext = context.getApplicationContext();
+            mNativeAd = nativeAd;
+            mImpressionTracker = impressionTracker;
+            mNativeClickHandler = nativeClickHandler;
+            mListener = customEventNativeListener;
+            mMillennialStaticNativeAd = this;
 
             nativeAd.setListener(this);
         }
@@ -119,86 +134,110 @@ public MillennialForwardingNativeAd(final Context context, final NativeAd native
         void loadAd() {
             Log.i(LOGCAT_TAG, "Loading native ad...");
             try {
-                nativeAd.load(this.context, null);
+                mNativeAd.load(mContext, null);
             } catch (MMException e) {
                 Log.w(MillennialNative.LOGCAT_TAG, "Caught configuration error Exception.");
                 e.printStackTrace();
                 UI_THREAD_HANDLER.post(new Runnable() {
                     @Override
                     public void run() {
-                        listener.onNativeAdFailed(NativeErrorCode.NATIVE_ADAPTER_CONFIGURATION_ERROR);
+                        mListener.onNativeAdFailed(NativeErrorCode
+                                .NATIVE_ADAPTER_CONFIGURATION_ERROR);
                     }
                 });
             }
         }
 
-        // BaseForwardingNativeAd
+        // Lifecycle Handlers
         @Override
-        public void destroy() {
-            nativeAd.setListener(null);
-            nativeAd = null;
+        public void prepare(final View view) {
+            // Must access these methods directly to get impressions to fire.
+            mNativeAd.getIconImage();
+            mNativeAd.getDisclaimer();
+            mImpressionTracker.addView(view, this);
+            mNativeClickHandler.setOnClickListener(view, this);
         }
 
         @Override
-        public void prepare(final View view) {
-            // Must access these methods directly to get impressions to fire.
-            nativeAd.getIconImage();
-            nativeAd.getDisclaimer();
+        public void clear(final View view) {
+            mImpressionTracker.removeView(view);
+            mNativeClickHandler.clearOnClickListener(view);
         }
 
         @Override
-        public void handleClick(final View view) {
-            nativeAd.fireClicked();
-            Log.i(LOGCAT_TAG, "Millennial native ad clicked!");
+        public void destroy() {
+            mImpressionTracker.destroy();
+            mNativeAd.setListener(null);
+            mNativeAd = null;
         }
 
+        // Event Handlers
         @Override
-        public void recordImpression() {
-            super.recordImpression();
+        public void recordImpression(final View view) {
+            notifyAdImpressed();
             try {
-                nativeAd.fireImpression();
+                mNativeAd.fireImpression();
                 Log.i(LOGCAT_TAG, "Millennial native impression recorded.");
             } catch ( MMException m ) {
                 Log.e(LOGCAT_TAG, "Millennial native impression NOT tracked: " + m.getMessage() );
             }
         }
 
-        // MM'S Native listener
+        @Override
+        public void handleClick(final View view) {
+            notifyAdClicked();
+            mNativeClickHandler.openClickDestinationUrl(getClickDestinationUrl(), view);
+            mNativeAd.fireClicked();
+            Log.i(LOGCAT_TAG, "Millennial native ad clicked!");
+        }
+
+        // MM'S Native mListener
         @Override
         public void onLoaded(NativeAd nativeAd) {
             // Set assets
             String iconImageUrl = nativeAd.getImageUrl(NativeAd.ComponentName.ICON_IMAGE, 1);
             String mainImageUrl = nativeAd.getImageUrl(NativeAd.ComponentName.MAIN_IMAGE, 1);
 
-            this.setTitle(nativeAd.getTitle().getText().toString());
-            this.setText(nativeAd.getBody().getText().toString());
-            this.setCallToAction(nativeAd.getCallToActionButton().getText().toString());
-            this.setClickDestinationUrl(nativeAd.getCallToActionUrl());
-            this.setIconImageUrl(iconImageUrl);
-            this.setMainImageUrl(mainImageUrl);
+            setTitle(nativeAd.getTitle().getText().toString());
+            setText(nativeAd.getBody().getText().toString());
+            setCallToAction(nativeAd.getCallToActionButton().getText().toString());
+
+            final String clickDestinationUrl = nativeAd.getCallToActionUrl();
+            if (clickDestinationUrl == null) {
+                UI_THREAD_HANDLER.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        Log.d(LOGCAT_TAG,
+                                "Millennial native encountered null destination url. Failing over.");
+                        mListener.onNativeAdFailed(
+                                NativeErrorCode.NATIVE_ADAPTER_CONFIGURATION_ERROR);
+                    }
+                });
+                return;
+            }
+
+            setClickDestinationUrl(clickDestinationUrl);
+            setIconImageUrl(iconImageUrl);
+            setMainImageUrl(mainImageUrl);
 
             final List<String> urls = new ArrayList<String>();
             if ( iconImageUrl != null ) { urls.add(iconImageUrl); }
             if ( mainImageUrl != null ) { urls.add(mainImageUrl); }
 
-            // Use MoPub's click/impression trackers
-            this.setOverridingImpressionTracker(false);
-            this.setOverridingClickTracker(false);
-
             UI_THREAD_HANDLER.post(new Runnable() {
                 @Override
                 public void run() {
                     // This has to be run on the main thread:
-                    preCacheImages(context, urls, new ImageListener() {
+                    preCacheImages(mContext, urls, new NativeImageHelper.ImageListener() {
                         @Override
                         public void onImagesCached() {
-                            listener.onNativeAdLoaded(millennialForwardingNativeAd);
+                            mListener.onNativeAdLoaded(mMillennialStaticNativeAd);
                             Log.i(LOGCAT_TAG, "Millennial native ad loaded");
                         }
 
                         @Override
                         public void onImagesFailedToCache(NativeErrorCode errorCode) {
-                            listener.onNativeAdFailed(errorCode);
+                            mListener.onNativeAdFailed(errorCode);
                         }
                     });
 
@@ -236,7 +275,7 @@ public void onLoadFailed(NativeAd nativeAd, NativeAd.NativeErrorStatus nativeErr
             UI_THREAD_HANDLER.post(new Runnable() {
                 @Override
                 public void run() {
-                    listener.onNativeAdFailed(error);
+                    mListener.onNativeAdFailed(error);
                 }
             });
             Log.i(LOGCAT_TAG, "Millennial native ad failed: " + nativeErrorStatus.getDescription() );
diff --git a/mopub-sample/AndroidManifest.xml b/mopub-sample/AndroidManifest.xml
index e481ce62..79e638a0 100644
--- a/mopub-sample/AndroidManifest.xml
+++ b/mopub-sample/AndroidManifest.xml
@@ -1,15 +1,18 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
       package="com.mopub.simpleadsdemo"
-      android:versionCode="30"
-      android:versionName="3.13.0">
+      android:versionCode="34"
+      android:versionName="4.3.0">
     <uses-sdk android:minSdkVersion="9"
-              android:targetSdkVersion="22"/>
+              android:targetSdkVersion="23"/>
 
     <uses-permission android:name="android.permission.INTERNET" />
     <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
     <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
 
+    <!-- This is added as a workaround for the manifest merger duplicating exoplayer
+         and play services permissions. -->
+    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
 
     <!-- For MRAID 2 -->
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
diff --git a/mopub-sample/build.gradle b/mopub-sample/build.gradle
index c239e950..dcedaf82 100644
--- a/mopub-sample/build.gradle
+++ b/mopub-sample/build.gradle
@@ -9,17 +9,18 @@ apply plugin: 'com.android.application'
 
 group = 'com.mopub'
 description = '''MoPub Sample App'''
-version = '3.13.0'
+version = '4.3.0'
 
 android {
-    compileSdkVersion 22
-    buildToolsVersion '22.0.1'
+    compileSdkVersion 23
+    buildToolsVersion '23.0.2'
+    lintOptions { abortOnError false }
 
     defaultConfig {
-        versionCode 30
+        versionCode 34
         versionName version
         minSdkVersion 9
-        targetSdkVersion 22
+        targetSdkVersion 23
     }
 
     buildTypes {
@@ -54,8 +55,8 @@ android {
 }
 
 dependencies {
-    compile 'com.android.support:support-v4:22.0.0'
-    compile 'com.google.android.gms:play-services-ads:7.0.0'
-    compile 'com.android.support:recyclerview-v7:22.0.0'
+    compile 'com.android.support:support-v4:22.2.0'
+    compile 'com.google.android.gms:play-services-ads:7.8.0'
+    compile 'com.android.support:recyclerview-v7:22.2.0'
     compile project(':mopub-sdk')
 }
diff --git a/mopub-sample/res/layout/native_ad_list_item.xml b/mopub-sample/res/layout/native_ad_list_item.xml
index c5af0a25..e81c3379 100644
--- a/mopub-sample/res/layout/native_ad_list_item.xml
+++ b/mopub-sample/res/layout/native_ad_list_item.xml
@@ -62,13 +62,13 @@
         android:paddingBottom="10dp" />
 
     <ImageView
-        android:id="@+id/native_daa_icon_image"
+        android:id="@+id/native_privacy_information_icon_image"
         android:layout_width="40dp"
         android:layout_height="40dp"
         android:padding="10dp"
         android:layout_alignParentRight="true"
         android:layout_alignParentEnd="true"
         android:layout_alignParentTop="true"
-        android:contentDescription="@string/native_daa_icon_image"/>
+        android:contentDescription="@string/native_privacy_information_icon_image"/>
 
 </RelativeLayout>
diff --git a/mopub-sample/res/layout/native_list_view_fragment.xml b/mopub-sample/res/layout/native_list_view_fragment.xml
index ff83a0ee..d63273d1 100644
--- a/mopub-sample/res/layout/native_list_view_fragment.xml
+++ b/mopub-sample/res/layout/native_list_view_fragment.xml
@@ -53,6 +53,6 @@
     <ListView
         android:id="@+id/native_list_view"
         android:layout_width="match_parent"
-        android:layout_height="wrap_content"
+        android:layout_height="match_parent"
         android:padding="5dp"/>
 </LinearLayout>
diff --git a/mopub-sample/res/layout/video_ad_list_item.xml b/mopub-sample/res/layout/video_ad_list_item.xml
new file mode 100644
index 00000000..286dd0e3
--- /dev/null
+++ b/mopub-sample/res/layout/video_ad_list_item.xml
@@ -0,0 +1,74 @@
+<RelativeLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/native_outer_view"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:background="@android:color/white">
+    <ImageView android:id="@+id/native_icon_image"
+        android:layout_width="64dp"
+        android:layout_height="64dp"
+        android:background="@null"
+        android:layout_alignParentLeft="true"
+        android:layout_alignParentTop="true"
+        android:layout_marginTop="10dp"
+        android:layout_marginLeft="10dp"
+        />
+
+    <TextView android:id="@+id/native_title"
+        android:layout_width="match_parent"
+        android:layout_marginLeft="84dp"
+        android:layout_marginTop="32dp"
+        android:layout_height="wrap_content"
+        android:layout_alignParentTop="true"
+        android:layout_alignParentLeft="true"
+        android:textColor="@android:color/darker_gray"
+        android:textStyle="bold" />
+
+    <TextView android:id="@+id/native_text"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_below="@+id/native_icon_image"
+        android:layout_alignParentLeft="true"
+        android:layout_marginLeft="10dp"
+        android:layout_marginTop="10dp"
+        android:textColor="@android:color/darker_gray" />
+
+
+    <com.mopub.nativeads.MediaLayout
+        android:id="@+id/native_media_layout"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:background="#000000"
+        android:layout_marginTop="10dp"
+        android:layout_marginLeft="10dp"
+        android:layout_marginRight="10dp"
+        android:layout_marginBottom="10dp"
+        android:layout_below="@+id/native_text"
+        android:layout_centerHorizontal="true" />
+
+    <Button
+        android:id="@+id/native_cta"
+        android:layout_width="wrap_content"
+        android:layout_height="35dp"
+        android:text="@string/learn_more"
+        android:textColor="@android:color/black"
+        android:textStyle="bold"
+        android:layout_marginRight="10dp"
+        android:layout_marginTop="10dp"
+        android:layout_below="@+id/native_media_layout"
+        android:textSize="12sp"
+        android:layout_alignParentRight="true"
+        android:clickable="true"
+        android:paddingBottom="10dp" />
+
+    <ImageView
+        android:id="@+id/native_privacy_information_icon_image"
+        android:layout_width="40dp"
+        android:layout_height="40dp"
+        android:padding="10dp"
+        android:layout_alignParentRight="true"
+        android:layout_alignParentEnd="true"
+        android:layout_alignParentTop="true"
+        android:contentDescription="@string/native_privacy_information_icon_image"/>
+
+</RelativeLayout>
diff --git a/mopub-sample/res/values/strings.xml b/mopub-sample/res/values/strings.xml
index 05230fda..bb9d7d0d 100644
--- a/mopub-sample/res/values/strings.xml
+++ b/mopub-sample/res/values/strings.xml
@@ -8,7 +8,7 @@
     <string name="show_ad">Show Ad</string>
     <string name="native_icon_image">native_icon_image</string>
     <string name="native_main_image">native_main_image</string>
-    <string name="native_daa_icon_image">DAA icon image</string>
+    <string name="native_privacy_information_icon_image">Privacy Information Icon image</string>
     <string name="learn_more">Learn More</string>
     <string name="save">Save Ad Unit</string>
     <string name="ad_unit_id">Ad Unit Id:</string>
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/LoggingUtils.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/LoggingUtils.java
index 22aa7e69..c39e77f5 100644
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/LoggingUtils.java
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/LoggingUtils.java
@@ -67,7 +67,7 @@ public void publish(final LogRecord logRecord) {
             if (MoPubErrorCode.WARMUP.toString().equals(logRecord.getMessage())) {
                 Utils.logToast(mContext, MoPubErrorCode.WARMUP.toString());
             }
-            // Toasts the no connection message if a native response failed due to no internet
+            // Toasts the no connection message if a native ad failed due to no internet
             if (MoPubErrorCode.NO_CONNECTION.toString().equals(logRecord.getMessage())) {
                 Utils.logToast(mContext, MoPubErrorCode.NO_CONNECTION.toString());
             }
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeGalleryFragment.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeGalleryFragment.java
index 978916e0..b7141689 100644
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeGalleryFragment.java
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeGalleryFragment.java
@@ -12,9 +12,11 @@
 import android.view.ViewGroup;
 import android.widget.TextView;
 
+import com.mopub.nativeads.MediaViewBinder;
 import com.mopub.nativeads.MoPubNativeAdLoadedListener;
-import com.mopub.nativeads.MoPubNativeAdRenderer;
+import com.mopub.nativeads.MoPubStaticNativeAdRenderer;
 import com.mopub.nativeads.MoPubStreamAdPlacer;
+import com.mopub.nativeads.MoPubVideoNativeAdRenderer;
 import com.mopub.nativeads.RequestParameters;
 import com.mopub.nativeads.ViewBinder;
 
@@ -69,21 +71,36 @@ public void onClick(View view) {
         views.mAdUnitIdView.setText(adUnitId);
         mViewPager = (ViewPager) view.findViewById(R.id.gallery_pager);
 
-        // This ad placer is used to automatically insert ads into the ViewPager.
-        mStreamAdPlacer = new MoPubStreamAdPlacer(getActivity());
-        final MoPubNativeAdRenderer adRenderer = new MoPubNativeAdRenderer(
+        // Set up a renderer for a static native ad.
+        final MoPubStaticNativeAdRenderer moPubStaticNativeAdRenderer = new MoPubStaticNativeAdRenderer(
                 new ViewBinder.Builder(R.layout.native_ad_list_item)
                         .titleId(R.id.native_title)
                         .textId(R.id.native_text)
                         .mainImageId(R.id.native_main_image)
                         .iconImageId(R.id.native_icon_image)
                         .callToActionId(R.id.native_cta)
-                        .daaIconImageId(R.id.native_daa_icon_image)
+                        .privacyInformationIconImageId(R.id.native_privacy_information_icon_image)
                         .build()
         );
-        mPagerAdapter = new CustomPagerAdapter(getChildFragmentManager(), mStreamAdPlacer);
-        mStreamAdPlacer.registerAdRenderer(adRenderer);
+
+        // Set up a renderer for a video native ad.
+        final MoPubVideoNativeAdRenderer moPubVideoNativeAdRenderer = new MoPubVideoNativeAdRenderer(
+                new MediaViewBinder.Builder(R.layout.video_ad_list_item)
+                        .titleId(R.id.native_title)
+                        .textId(R.id.native_text)
+                        .mediaLayoutId(R.id.native_media_layout)
+                        .iconImageId(R.id.native_icon_image)
+                        .callToActionId(R.id.native_cta)
+                        .privacyInformationIconImageId(R.id.native_privacy_information_icon_image)
+                        .build());
+
+        // This ad placer is used to automatically insert ads into the ViewPager.
+        mStreamAdPlacer = new MoPubStreamAdPlacer(getActivity());
+        mStreamAdPlacer.registerAdRenderer(moPubStaticNativeAdRenderer);
+        mStreamAdPlacer.registerAdRenderer(moPubVideoNativeAdRenderer);
         mStreamAdPlacer.setAdLoadedListener(this);
+
+        mPagerAdapter = new CustomPagerAdapter(getChildFragmentManager(), mStreamAdPlacer);
         mViewPager.setAdapter(mPagerAdapter);
 
         return view;
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeListViewFragment.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeListViewFragment.java
index 07e4374c..b0e6cc5e 100644
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeListViewFragment.java
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeListViewFragment.java
@@ -9,13 +9,16 @@
 import android.widget.ArrayAdapter;
 import android.widget.ListView;
 
+import com.mopub.nativeads.MediaViewBinder;
 import com.mopub.nativeads.MoPubAdAdapter;
-import com.mopub.nativeads.MoPubNativeAdRenderer;
+import com.mopub.nativeads.MoPubStaticNativeAdRenderer;
+import com.mopub.nativeads.MoPubVideoNativeAdRenderer;
 import com.mopub.nativeads.RequestParameters;
 import com.mopub.nativeads.ViewBinder;
 
 import java.util.EnumSet;
 
+import static com.mopub.nativeads.MoPubNativeAdPositioning.MoPubServerPositioning;
 import static com.mopub.nativeads.RequestParameters.NativeAdAsset;
 
 public class NativeListViewFragment extends Fragment {
@@ -70,22 +73,37 @@ public void onClick(View view) {
 
         // Create an ad adapter that gets its positioning information from the MoPub Ad Server.
         // This adapter will be used in place of the original adapter for the ListView.
-        mAdAdapter = new MoPubAdAdapter(getActivity(), adapter);
+        mAdAdapter = new MoPubAdAdapter(getActivity(), adapter, new MoPubServerPositioning());
 
-        // Set up an renderer that knows how to put ad data in an ad view.
-        final MoPubNativeAdRenderer adRenderer = new MoPubNativeAdRenderer(
+        // Set up a renderer that knows how to put ad data in your custom native view.
+        final MoPubStaticNativeAdRenderer staticAdRender = new MoPubStaticNativeAdRenderer(
                 new ViewBinder.Builder(R.layout.native_ad_list_item)
                         .titleId(R.id.native_title)
                         .textId(R.id.native_text)
                         .mainImageId(R.id.native_main_image)
                         .iconImageId(R.id.native_icon_image)
                         .callToActionId(R.id.native_cta)
-                        .daaIconImageId(R.id.native_daa_icon_image)
+                        .privacyInformationIconImageId(R.id.native_privacy_information_icon_image)
                         .build());
 
-        // Register the renderer with the MoPubAdAdapter and then set the adapter on the ListView.
-        mAdAdapter.registerAdRenderer(adRenderer);
+        // Set up a renderer for a video native ad.
+        final MoPubVideoNativeAdRenderer videoAdRenderer = new MoPubVideoNativeAdRenderer(
+                new MediaViewBinder.Builder(R.layout.video_ad_list_item)
+                        .titleId(R.id.native_title)
+                        .textId(R.id.native_text)
+                        .mediaLayoutId(R.id.native_media_layout)
+                        .iconImageId(R.id.native_icon_image)
+                        .callToActionId(R.id.native_cta)
+                        .privacyInformationIconImageId(R.id.native_privacy_information_icon_image)
+                        .build());
+
+
+        // Register the renderers with the MoPubAdAdapter and then set the adapter on the ListView.
+        mAdAdapter.registerAdRenderer(videoAdRenderer);
+        mAdAdapter.registerAdRenderer(staticAdRender);
         listView.setAdapter(mAdAdapter);
+
+        mAdAdapter.loadAds(mAdConfiguration.getAdUnitId(), mRequestParameters);
         return view;
     }
 
@@ -95,11 +113,4 @@ public void onDestroyView() {
         mAdAdapter.destroy();
         super.onDestroyView();
     }
-
-    @Override
-    public void onResume() {
-        // MoPub recommends loading knew ads when the user returns to your activity.
-        mAdAdapter.loadAds(mAdConfiguration.getAdUnitId(), mRequestParameters);
-        super.onResume();
-    }
 }
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeRecyclerViewFragment.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeRecyclerViewFragment.java
index 3b13ef73..a0421841 100644
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeRecyclerViewFragment.java
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeRecyclerViewFragment.java
@@ -14,8 +14,11 @@
 import android.widget.Button;
 import android.widget.TextView;
 
+import com.mopub.nativeads.MediaViewBinder;
 import com.mopub.nativeads.MoPubNativeAdPositioning;
+import com.mopub.nativeads.MoPubStaticNativeAdRenderer;
 import com.mopub.nativeads.MoPubRecyclerAdapter;
+import com.mopub.nativeads.MoPubVideoNativeAdRenderer;
 import com.mopub.nativeads.RequestParameters;
 import com.mopub.nativeads.ViewBinder;
 
@@ -82,14 +85,31 @@ public void onClick(final View v) {
 
         mRecyclerAdapter = new MoPubRecyclerAdapter(getActivity(), originalAdapter,
                 new MoPubNativeAdPositioning.MoPubServerPositioning());
-        mRecyclerAdapter.registerViewBinder(new ViewBinder.Builder(R.layout.native_ad_list_item)
-                .titleId(R.id.native_title)
-                .textId(R.id.native_text)
-                .mainImageId(R.id.native_main_image)
-                .iconImageId(R.id.native_icon_image)
-                .callToActionId(R.id.native_cta)
-                .daaIconImageId(R.id.native_daa_icon_image)
-                .build());
+
+        MoPubStaticNativeAdRenderer moPubStaticNativeAdRenderer = new MoPubStaticNativeAdRenderer(
+                new ViewBinder.Builder(R.layout.native_ad_list_item)
+                        .titleId(R.id.native_title)
+                        .textId(R.id.native_text)
+                        .mainImageId(R.id.native_main_image)
+                        .iconImageId(R.id.native_icon_image)
+                        .callToActionId(R.id.native_cta)
+                        .privacyInformationIconImageId(R.id.native_privacy_information_icon_image)
+                        .build()
+        );
+
+        // Set up a renderer for a video native ad.
+        MoPubVideoNativeAdRenderer moPubVideoNativeAdRenderer = new MoPubVideoNativeAdRenderer(
+                new MediaViewBinder.Builder(R.layout.video_ad_list_item)
+                        .titleId(R.id.native_title)
+                        .textId(R.id.native_text)
+                        .mediaLayoutId(R.id.native_media_layout)
+                        .iconImageId(R.id.native_icon_image)
+                        .callToActionId(R.id.native_cta)
+                        .privacyInformationIconImageId(R.id.native_privacy_information_icon_image)
+                        .build());
+
+        mRecyclerAdapter.registerAdRenderer(moPubStaticNativeAdRenderer);
+        mRecyclerAdapter.registerAdRenderer(moPubVideoNativeAdRenderer);
 
         mRecyclerView.setAdapter(mRecyclerAdapter);
         mRecyclerView.setLayoutManager(new LinearLayoutManager(getActivity()));
diff --git a/mopub-sample/src/test/resources/org.robolectric.Config.properties b/mopub-sample/src/test/resources/robolectric.properties
similarity index 100%
rename from mopub-sample/src/test/resources/org.robolectric.Config.properties
rename to mopub-sample/src/test/resources/robolectric.properties
diff --git a/mopub-sdk/build.gradle b/mopub-sdk/build.gradle
index 3ae55932..75d418b2 100644
--- a/mopub-sdk/build.gradle
+++ b/mopub-sdk/build.gradle
@@ -1,8 +1,16 @@
 // This buildscript will assemble the MoPub SDK into an AAR.
 buildscript {
+
+	repositories {
+		mavenCentral()
+		jcenter()
+	}
+
 	dependencies {
+		classpath 'com.android.tools.build:gradle:1.5.0'
 		classpath 'com.github.dcendents:android-maven-gradle-plugin:1.3'
 	}
+
 }
 
 plugins {
@@ -15,6 +23,10 @@ repositories {
 	}
 }
 
+configurations {
+	javadocDeps
+}
+
 apply plugin: 'com.android.library'
 apply plugin: 'com.github.dcendents.android-maven'
 
@@ -24,77 +36,95 @@ task wrapper(type: Wrapper) {
 
 group = 'com.mopub'
 description = '''MoPub Android SDK'''
-version = '3.13.0'
+version = '4.3.0'
 
 android {
-    compileSdkVersion 23
-    buildToolsVersion '23.0.1'
 
-    defaultConfig {
-        versionCode 30
-        versionName version
-        minSdkVersion 14
-        targetSdkVersion 23
-        consumerProguardFiles 'proguard.txt'
-    }
+	compileSdkVersion 23
+	buildToolsVersion '23.0.1'
+	lintOptions { abortOnError false }
+
+	defaultConfig {
+		versionCode 34
+		versionName version
+		minSdkVersion 14
+		targetSdkVersion 23
+		consumerProguardFiles 'proguard.txt'
+	}
 
 	useLibrary 'org.apache.http.legacy'
 
 	sourceSets {
-        main {
-            manifest.srcFile 'AndroidManifest.xml'
-            java.srcDirs = ['src/main/java']
-            resources.srcDirs = ['src/main/java']
-            aidl.srcDirs = ['src/main']
-            renderscript.srcDirs = ['src/main']
-            res.srcDirs = ['res']
-            assets.srcDirs = ['assets']
-        }
-    }
-
-    testOptions {
-        unitTests {
-            // This causes android platform methods from the test JAR
-            // to return null, false, etc instead of throwing an exception.
-            // We should periodically disable this and tackle the broken tests
-            // as it exposes when we are hitting platform APIs in our tests.
-            // If these tests *require* platform APIs we may want to make them
-            // connected tests instead.
-            returnDefaultValues = true
-
-            // Test JVM settings since we have a lot of classes loaded.
-            all {
-                jvmArgs '-XX:MaxPermSize=4096m', '-Xmx8192m'
-                forkEvery 200
-            }
-        }
-    }
-
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), file('proguard.txt')
-        }
-      
-        debug {
-            minifyEnabled false
-        }
-    }
-
-    // Note: You will also need a local.properties file to set the location of the SDK in the same 
-    // way that the existing SDK requires, using the sdk.dir property.
-    // Alternatively, you can set an environment variable called ANDROID_HOME. There is no 
-    // difference between the two methods, you can use the one you prefer.
+		main {
+			manifest.srcFile 'AndroidManifest.xml'
+			java.srcDirs = ['src/main/java']
+			resources.srcDirs = ['src/main/resources']
+			aidl.srcDirs = ['src/main']
+			renderscript.srcDirs = ['src/main']
+			res.srcDirs = ['res']
+			assets.srcDirs = ['assets']
+		}
+	}
+
+	testOptions {
+		unitTests {
+			// This causes android platform methods from the test JAR
+			// to return null, false, etc instead of throwing an exception.
+			// We should periodically disable this and tackle the broken tests
+			// as it exposes when we are hitting platform APIs in our tests.
+			// If these tests *require* platform APIs we may want to make them
+			// connected tests instead.
+			returnDefaultValues = true
+
+			// Test JVM settings since we have a lot of classes loaded.
+			all {
+				jvmArgs '-XX:MaxPermSize=4096m', '-Xmx8192m'
+				forkEvery 200
+			}
+		}
+	}
+
+	buildTypes {
+		release {
+			minifyEnabled false
+			proguardFiles getDefaultProguardFile('proguard-android.txt'), file('proguard.txt')
+		}
+
+		debug {
+			minifyEnabled false
+		}
+	}
+
+	// Note: You will also need a local.properties file to set the location of the SDK in the same
+	// way that the existing SDK requires, using the sdk.dir property.
+	// Alternatively, you can set an environment variable called ANDROID_HOME. There is no
+	// difference between the two methods, you can use the one you prefer.
 }
 
 
 
 dependencies {
-	compile 'com.android.support:support-v4:23.0.1'
-	compile 'com.android.support:support-annotations:23.0.1'
-	compile 'com.android.support:recyclerview-v7:23.0.1'
+
+	compile 'com.android.support:support-v4:23.1.1'
+	compile 'com.android.support:support-annotations:23.1.1'
+	compile 'com.android.support:recyclerview-v7:23.1.1'
 	compile 'com.mopub.volley:mopub-volley:1.1.0'
 	// anchor: additional dependencies
+	compile 'com.google.android.exoplayer:exoplayer:r1.4.2'
+
+
+	javadocDeps 'com.google.android.exoplayer:exoplayer:r1.4.2:sources'
+	javadocDeps 'com.mopub.volley:mopub-volley:1.1.0:sources'
+	javadocDeps 'com.android.support:support-v4:23.1.1:sources'
+	javadocDeps 'com.android.support:support-annotations:23.1.1:sources'
+	javadocDeps 'com.android.support:recyclerview-v7:23.1.1:sources'
+
+	testCompile 'junit:junit:4.10'
+	testCompile 'org.robolectric:robolectric:3.0'
+	testCompile 'org.robolectric:shadows-support-v4:3.0'
+	testCompile 'org.robolectric:shadows-httpclient:3.0'
+	testCompile 'com.squareup:fest-android:1.0.7'
+	testCompile 'org.mockito:mockito-core:1.9.5'
 }
 
 def siteUrl = 'https://github.com/mopub/mopub-android-sdk'
@@ -190,6 +220,7 @@ task sourcesJar(type: Jar) {
 task javadoc(type: Javadoc) {
 	source = android.sourceSets.main.java.srcDirs
 	classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
+	classpath += configurations.javadocDeps
 }
 
 task javadocJar(type: Jar, dependsOn: javadoc) {
diff --git a/mopub-sdk/pom.xml b/mopub-sdk/pom.xml
index caee1e26..5b6fcdf0 100644
--- a/mopub-sdk/pom.xml
+++ b/mopub-sdk/pom.xml
@@ -44,6 +44,13 @@
             <version>1.1.0</version>
         </dependency>
 
+        <dependency>
+            <groupId>com.google.android.exoplayer</groupId>
+            <artifactId>exoplayer</artifactId>
+            <version>r1.4.2</version>
+            <type>aar</type>
+        </dependency>
+
         <!--android & oobolectric-->
         <dependency>
             <groupId>com.google.android</groupId>
diff --git a/mopub-sdk/proguard.txt b/mopub-sdk/proguard.txt
index 0a2e3c08..3ad22097 100644
--- a/mopub-sdk/proguard.txt
+++ b/mopub-sdk/proguard.txt
@@ -16,3 +16,8 @@
 -keep class com.google.android.gms.common.GooglePlayServicesUtil {*;}
 -keep class com.google.android.gms.ads.identifier.AdvertisingIdClient {*;}
 -keep class com.google.android.gms.ads.identifier.AdvertisingIdClient$Info {*;}
+-dontwarn com.google.android.gms.**
+
+# Filter out warnings that refer to legacy Code.
+-dontwarn org.apache.http.**
+-dontwarn com.mopub.volley.toolbox.**
diff --git a/mopub-sdk/src/main/java/com/mopub/common/AdType.java b/mopub-sdk/src/main/java/com/mopub/common/AdType.java
index 86543d5a..607adbd2 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/AdType.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/AdType.java
@@ -8,7 +8,8 @@
     public static final String HTML = "html";
     public static final String MRAID = "mraid";
     public static final String INTERSTITIAL = "interstitial";
-    public static final String NATIVE = "json";
+    public static final String STATIC_NATIVE = "json";
+    public static final String VIDEO_NATIVE = "json_video";
     public static final String CUSTOM = "custom";
     public static final String CLEAR = "clear";
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/DataKeys.java b/mopub-sdk/src/main/java/com/mopub/common/DataKeys.java
index 3adb73e3..75cf02bb 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/DataKeys.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/DataKeys.java
@@ -8,6 +8,7 @@
     public static final String HTML_RESPONSE_BODY_KEY = "Html-Response-Body";
     public static final String REDIRECT_URL_KEY = "Redirect-Url";
     public static final String CLICKTHROUGH_URL_KEY = "Clickthrough-Url";
+    public static final String CLICK_TRACKING_URL_KEY = "Click-Tracking-Url";
     public static final String SCROLLABLE_KEY = "Scrollable";
     public static final String CREATIVE_ORIENTATION_KEY = "com_mopub_orientation";
     public static final String JSON_BODY_KEY = "com_mopub_native_json";
@@ -15,4 +16,12 @@
     public static final String AD_UNIT_ID_KEY = "com_mopub_ad_unit_id";
     public static final String AD_WIDTH = "com_mopub_ad_width";
     public static final String AD_HEIGHT = "com_mopub_ad_height";
+
+    // Native Video fields
+    public static final String PLAY_VISIBLE_PERCENT = "Play-Visible-Percent";
+    public static final String PAUSE_VISIBLE_PERCENT = "Pause-Visible-Percent";
+    public static final String IMPRESSION_MIN_VISIBLE_PERCENT = "Impression-Min-Visible-Percent";
+    public static final String IMPRESSION_VISIBLE_MS = "Impression-Visible-Ms";
+    public static final String MAX_BUFFER_MS = "Max-Buffer-Ms";
+    public static final String EVENT_DETAILS = "Event-Details";
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/MoPub.java b/mopub-sdk/src/main/java/com/mopub/common/MoPub.java
index 53e91de0..d2a9337a 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/MoPub.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/MoPub.java
@@ -8,7 +8,7 @@
 import com.mopub.mobileads.MoPubRewardedVideoManager;
 
 public class MoPub {
-    public static final String SDK_VERSION = "3.13.0";
+    public static final String SDK_VERSION = "4.3.0";
 
     public static enum LocationAwareness { NORMAL, TRUNCATED, DISABLED }
 
diff --git a/mopub-sdk/src/main/java/com/mopub/common/MoPubBrowser.java b/mopub-sdk/src/main/java/com/mopub/common/MoPubBrowser.java
index 8433719f..3e373970 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/MoPubBrowser.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/MoPubBrowser.java
@@ -35,6 +35,7 @@
 
 public class MoPubBrowser extends Activity {
     public static final String DESTINATION_URL_KEY = "URL";
+    public static final int MOPUB_BROWSER_REQUEST_CODE = 1;
     private static final int INNER_LAYOUT_ID = 1;
 
     private WebView mWebView;
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/BaseEvent.java b/mopub-sdk/src/main/java/com/mopub/common/event/BaseEvent.java
index 210b6aa8..3e89e7f4 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/event/BaseEvent.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/BaseEvent.java
@@ -62,7 +62,13 @@ public int getType() {
     public enum Name {
         AD_REQUEST("ad_request"),
         IMPRESSION_REQUEST("impression_request"),
-        CLICK_REQUEST("click_request");
+        CLICK_REQUEST("click_request"),
+        DOWNLOAD_START("download_start"),
+        DOWNLOAD_VIDEO_READY("download_video_ready"),
+        DOWNLOAD_BUFFERING("download_video_buffering"),
+        DOWNLOAD_FINISHED("download_finished"),
+        ERROR_DURING_PLAYBACK("error_during_playback"),
+        ERROR_FAILED_TO_PLAY("error_failed_to_play");
 
         @NonNull private final String mName;
         private Name(@NonNull String name) {
@@ -76,7 +82,8 @@ public String getName() {
     }
 
     public enum Category {
-        REQUESTS("requests");
+        REQUESTS("requests"),
+        NATIVE_VIDEO("native_video");
 
         @NonNull private final String mCategory;
         private Category(@NonNull String category) {
@@ -90,7 +97,8 @@ public String getCategory() {
     }
 
     public enum SamplingRate {
-        AD_REQUEST(0.1);
+        AD_REQUEST(0.1),
+        NATIVE_VIDEO(0.1);
 
         private final double mSamplingRate;
         private SamplingRate(double samplingRate) {
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/Event.java b/mopub-sdk/src/main/java/com/mopub/common/event/Event.java
index 4228ab35..949ce72f 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/event/Event.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/Event.java
@@ -1,6 +1,10 @@
 package com.mopub.common.event;
 
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.logging.MoPubLog;
 
 /**
  * Immutable data class with client event data.
@@ -21,4 +25,50 @@ public Event build() {
             return new Event(this);
         }
     }
+
+    /**
+     * Creates a BaseEvent from the specified event and the metadata surrounding the event.
+     *
+     * @param name         Event name: See {@link com.mopub.common.event.BaseEvent.Name} for
+     *                     constants.
+     * @param category     Category: See {@link com.mopub.common.event.BaseEvent.Category} for
+     *                     constants.
+     * @param samplingRate The percentage of events to sample. See {@link com.mopub.common.event.BaseEvent.SamplingRate}
+     *                     for constants.
+     * @param eventDetails Data object containing the remaining meta data around this event.
+     * @return An {@link BaseEvent} with all the parts combined, or {@code null} if there is no
+     * metadata available.
+     */
+    @Nullable
+    public static BaseEvent createEventFromDetails(@NonNull final BaseEvent.Name name,
+            @NonNull final BaseEvent.Category category,
+            @NonNull final BaseEvent.SamplingRate samplingRate,
+            @Nullable EventDetails eventDetails) {
+        Preconditions.checkNotNull(name);
+        Preconditions.checkNotNull(category);
+        Preconditions.checkNotNull(samplingRate);
+
+        if (eventDetails == null) {
+            MoPubLog.d("Unable to log event due to no details present");
+            return null;
+        }
+
+        return new Event.Builder(name,
+                category,
+                samplingRate.getSamplingRate())
+                .withAdUnitId(eventDetails.getAdUnitId())
+                .withAdCreativeId(eventDetails.getDspCreativeId())
+                .withAdType(eventDetails.getAdType())
+                .withAdNetworkType(eventDetails.getAdNetworkType())
+                .withAdWidthPx(eventDetails.getAdWidthPx())
+                .withAdHeightPx(eventDetails.getAdHeightPx())
+                .withGeoLat(eventDetails.getGeoLatitude())
+                .withGeoLon(eventDetails.getGeoLongitude())
+                .withGeoAccuracy(eventDetails.getGeoAccuracy())
+                .withPerformanceDurationMs(eventDetails.getPerformanceDurationMs())
+                .withRequestId(eventDetails.getRequestId())
+                .withRequestStatusCode(eventDetails.getRequestStatusCode())
+                .withRequestUri(eventDetails.getRequestUri())
+                .build();
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/EventDetails.java b/mopub-sdk/src/main/java/com/mopub/common/event/EventDetails.java
new file mode 100644
index 00000000..dcba998a
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/EventDetails.java
@@ -0,0 +1,256 @@
+package com.mopub.common.event;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.util.Json;
+
+import java.util.HashMap;
+import java.util.Map;
+
+public class EventDetails {
+
+    public static class Builder {
+        @NonNull private final Map<String, String> eventDetailsMap;
+
+        public Builder() {
+            eventDetailsMap = new HashMap<String, String>();
+        }
+
+        @NonNull
+        public Builder adUnitId(@Nullable final String adUnitId) {
+            if (adUnitId != null) {
+                eventDetailsMap.put(AD_UNIT_ID_KEY, adUnitId);
+            }
+            return this;
+        }
+
+        @NonNull
+        public Builder dspCreativeId(@Nullable final String dspCreativeId) {
+            if (dspCreativeId != null) {
+                eventDetailsMap.put(DSP_CREATIVE_ID_KEY, dspCreativeId);
+            }
+            return this;
+        }
+
+        @NonNull
+        public Builder adType(@Nullable final String adType) {
+            if (adType != null) {
+                eventDetailsMap.put(AD_TYPE_KEY, adType);
+            }
+            return this;
+        }
+
+        @NonNull
+        public Builder adNetworkType(@Nullable final String adNetworkType) {
+            if (adNetworkType != null) {
+                eventDetailsMap.put(AD_NETWORK_TYPE_KEY, adNetworkType);
+            }
+            return this;
+        }
+
+        @NonNull
+        public Builder adWidthPx(@Nullable final Integer adWidthPx) {
+            if (adWidthPx != null) {
+                eventDetailsMap.put(AD_WIDTH_PX_KEY, String.valueOf(adWidthPx));
+            }
+            return this;
+        }
+
+        @NonNull
+        public Builder adHeightPx(@Nullable final Integer adHeightPx) {
+            if (adHeightPx != null) {
+                eventDetailsMap.put(AD_HEIGHT_PX_KEY, String.valueOf(adHeightPx));
+            }
+            return this;
+        }
+
+        @NonNull
+        public Builder geoLatitude(@Nullable final Double geoLatitude) {
+            if (geoLatitude != null) {
+                eventDetailsMap.put(GEO_LATITUDE_KEY, String.valueOf(geoLatitude));
+            }
+            return this;
+        }
+
+        @NonNull
+        public Builder geoLongitude(@Nullable final Double geoLongitude) {
+            if (geoLongitude != null) {
+                eventDetailsMap.put(GEO_LONGITUDE_KEY, String.valueOf(geoLongitude));
+            }
+            return this;
+        }
+
+        @NonNull
+        public Builder geoAccuracy(@Nullable final Float geoAccuracy) {
+            if (geoAccuracy != null) {
+                eventDetailsMap.put(GEO_ACCURACY_KEY, String.valueOf((double) geoAccuracy));
+            }
+            return this;
+        }
+
+        @NonNull
+        public Builder performanceDurationMs(@Nullable final Long performanceDurationMs) {
+            if (performanceDurationMs != null) {
+                eventDetailsMap.put(PERFORMANCE_DURATION_MS_KEY,
+                        String.valueOf((double) performanceDurationMs));
+            }
+            return this;
+        }
+
+        @NonNull
+        public Builder requestId(@Nullable final String requestId) {
+            if (requestId != null) {
+                eventDetailsMap.put(REQUEST_ID_KEY, requestId);
+            }
+            return this;
+        }
+
+        @NonNull
+        public Builder requestStatusCode(@Nullable final Integer requestStatusCode) {
+            if (requestStatusCode != null) {
+                eventDetailsMap.put(REQUEST_STATUS_CODE_KEY, String.valueOf(requestStatusCode));
+            }
+            return this;
+        }
+
+        @NonNull
+        public Builder requestUri(@Nullable final String requestUri) {
+            if (requestUri != null) {
+                eventDetailsMap.put(REQUEST_URI_KEY, requestUri);
+            }
+            return this;
+        }
+
+        @NonNull
+        public EventDetails build() {
+            return new EventDetails(eventDetailsMap);
+        }
+    }
+
+
+    private static final String AD_UNIT_ID_KEY = "ad_unit_id";
+    private static final String DSP_CREATIVE_ID_KEY = "dsp_creative_id";
+    private static final String AD_TYPE_KEY = "ad_type";
+    private static final String AD_NETWORK_TYPE_KEY = "ad_network_type";
+    private static final String AD_WIDTH_PX_KEY = "ad_width_px";
+    private static final String AD_HEIGHT_PX_KEY = "ad_height_px_key";
+    private static final String GEO_LATITUDE_KEY = "geo_latitude";
+    private static final String GEO_LONGITUDE_KEY = "geo_longitude";
+    private static final String GEO_ACCURACY_KEY = "geo_accuracy_key";
+    private static final String PERFORMANCE_DURATION_MS_KEY = "performance_duration_ms";
+    private static final String REQUEST_ID_KEY = "request_id_key";
+    private static final String REQUEST_STATUS_CODE_KEY = "request_status_code";
+    private static final String REQUEST_URI_KEY = "request_uri_key";
+
+    @NonNull private final Map<String, String> mEventDetailsMap;
+
+    private EventDetails(@NonNull final Map<String, String> eventDetailsMap) {
+        Preconditions.checkNotNull(eventDetailsMap);
+        mEventDetailsMap = eventDetailsMap;
+    }
+
+    @Nullable
+    public String getAdUnitId() {
+        return mEventDetailsMap.get(AD_UNIT_ID_KEY);
+    }
+
+    @Nullable
+    public String getDspCreativeId() {
+        return mEventDetailsMap.get(DSP_CREATIVE_ID_KEY);
+    }
+
+    @Nullable
+    public String getAdType() {
+        return mEventDetailsMap.get(AD_TYPE_KEY);
+    }
+
+    @Nullable
+    public String getAdNetworkType() {
+        return mEventDetailsMap.get(AD_NETWORK_TYPE_KEY);
+    }
+
+    @Nullable
+    public Double getAdWidthPx() {
+        return getNullableDoubleValue(mEventDetailsMap, AD_WIDTH_PX_KEY);
+    }
+
+    @Nullable
+    public Double getAdHeightPx() {
+        return getNullableDoubleValue(mEventDetailsMap, AD_HEIGHT_PX_KEY);
+
+    }
+
+    @Nullable
+    public Double getGeoLatitude() {
+        return getNullableDoubleValue(mEventDetailsMap, GEO_LATITUDE_KEY);
+    }
+
+    @Nullable
+    public Double getGeoLongitude() {
+        return getNullableDoubleValue(mEventDetailsMap, GEO_LONGITUDE_KEY);
+    }
+
+    @Nullable
+    public Double getGeoAccuracy() {
+        return getNullableDoubleValue(mEventDetailsMap, GEO_ACCURACY_KEY);
+    }
+
+    @Nullable
+    public Double getPerformanceDurationMs() {
+        return getNullableDoubleValue(mEventDetailsMap, PERFORMANCE_DURATION_MS_KEY);
+    }
+
+    @Nullable
+    public String getRequestId() {
+        return mEventDetailsMap.get(REQUEST_ID_KEY);
+    }
+
+    @Nullable
+    public Integer getRequestStatusCode() {
+        return getNullableIntegerValue(mEventDetailsMap, REQUEST_STATUS_CODE_KEY);
+    }
+
+    @Nullable
+    public String getRequestUri() {
+        return mEventDetailsMap.get(REQUEST_URI_KEY);
+    }
+
+    public String toJsonString() {
+        return Json.mapToJsonString(mEventDetailsMap);
+    }
+
+    @Override
+    public String toString() {
+        return toJsonString();
+    }
+
+    @Nullable
+    private static Double getNullableDoubleValue(@NonNull final Map<String, String> map,
+            @NonNull final String key) {
+        final String value = map.get(key);
+        if (value == null) {
+            return null;
+        }
+        try {
+            return Double.parseDouble(value);
+        } catch (NumberFormatException e) {
+            return null;
+        }
+    }
+
+    @Nullable
+    private static Integer getNullableIntegerValue(@NonNull final Map<String, String> map,
+            @NonNull final String key) {
+        final String value = map.get(key);
+        if (value == null) {
+            return null;
+        }
+        try {
+            return Integer.parseInt(value);
+        } catch (NumberFormatException e) {
+            return null;
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/EventSampler.java b/mopub-sdk/src/main/java/com/mopub/common/event/EventSampler.java
index 607d28d8..9b514448 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/event/EventSampler.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/EventSampler.java
@@ -5,6 +5,8 @@
 import com.mopub.common.Preconditions;
 import com.mopub.common.VisibleForTesting;
 
+import java.util.LinkedHashMap;
+import java.util.Map;
 import java.util.Random;
 
 /**
@@ -12,7 +14,15 @@
  */
 public class EventSampler {
 
+    @VisibleForTesting static final int MAX_SIZE = 100;
+    private static final float LOAD_FACTOR = 0.75f;
+    /**
+     * The capacity is just large enough to hold the max size without rehashing.
+     */
+    private static final int CAPACITY = (int) (MAX_SIZE / LOAD_FACTOR + 2);
+
     @NonNull private Random mRandom;
+    @NonNull private LinkedHashMap<String, Boolean> mSampleDecisionsCache;
 
     public EventSampler() {
         this(new Random());
@@ -21,19 +31,41 @@ public EventSampler() {
     @VisibleForTesting
     public EventSampler(@NonNull Random random) {
         mRandom = random;
+        mSampleDecisionsCache = new LinkedHashMap<String, Boolean>(CAPACITY, LOAD_FACTOR, true) {
+            @Override
+            protected boolean removeEldestEntry(Map.Entry<String, Boolean> eldest) {
+                return size() > MAX_SIZE;
+            }
+        };
     }
 
     /**
-     * Samples events based on custom rules.
+     * Samples events based on custom rules. Events with the same request ID will either all pass or
+     * be discarded together.
      *
      * @param baseEvent The event to be sampled.
-     *
-     * @return Will return {@code true} if the event passed sampling and {@code false}
-     * if it is to be discarded.
+     * @return Will return {@code true} if the event passed sampling and {@code false} if it is to
+     * be discarded.
      */
     boolean sample(@NonNull BaseEvent baseEvent) {
         Preconditions.checkNotNull(baseEvent);
 
-        return mRandom.nextDouble() < baseEvent.getSamplingRate();
+        final String requestId = baseEvent.getRequestId();
+        if (requestId == null) {
+            return mRandom.nextDouble() < baseEvent.getSamplingRate();
+        }
+
+        final Boolean existingSample = mSampleDecisionsCache.get(requestId);
+        if (existingSample != null) {
+            return existingSample;
+        }
+        final boolean newSample = mRandom.nextDouble() < baseEvent.getSamplingRate();
+        mSampleDecisionsCache.put(requestId, newSample);
+        return newSample;
+    }
+
+    @VisibleForTesting
+    int getCacheSize() {
+        return mSampleDecisionsCache.size();
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/Drawables.java b/mopub-sdk/src/main/java/com/mopub/common/util/Drawables.java
index 20a08910..d1ae9267 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/Drawables.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Drawables.java
@@ -24,7 +24,10 @@
 
     THATCHED_BACKGROUND("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"),
 
-    NATIVE_DAA_ICON("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");
+    NATIVE_PRIVACY_INFORMATION_ICON("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"),
+    NATIVE_MUTED("iVBORw0KGgoAAAANSUhEUgAAAEIAAAA6CAYAAAAEJY9EAAAAAXNSR0IArs4c6QAABIlJREFUaAXVmluITVEYx53BuJNLbuUShsSDKEIeSYnkYRIPHvBESbyQy2BKvEheRpIHRSQPiHhQPJBLGB5EYuZhMHhB7pfx+5/OPtacOftyztl7nb2++mbttda3vvV9v/Zea+19JtMtBdLR0TGVMOrQdvR+JpP5YzusjO0JzfkAUEN9I7rQaH/G9S5gfDXaEr9UINWUDUxuQlAsU9AVurApVQPB3bCWRBf5JDvdpz2x5qqAAMJKMloekFWvgL5EuqyDAMIyMlmdSDYVOLUKAghaD9ZXEG9iQ62BAMJ8stAOkUqxAgIIM8l+K2plvnJIJx4YEKYR2Ha0RzkB2hqTKAggTCKR3aj1XaBUgImBAMIYgtmD9ik1qGrYJwICCCNIphEdWI2kypkzdhBAGJKDoNIZiRUEEHQH7ENHOkMgF2hsIIDQF58N6Nicb6eKWEAAoZasd6J1TmVvBFvx3g4E+diGJv7GyFz9mUcnVJXNfLN4QVmS4GMQA+ah2s0e4KOF8v8hB4Ph1GegMixFdGCaVcqAcmyJbzTj9qP5RZi2syRyMqo/7L3DnbebraGtCR9XsncElbk424Km+eCzzoSQS76e2GtJ5Hiu7ltgpzu2ATVz1NKwnr5bNfxRx6YCA6qpkyk+ES0nB33k8RUfCJ59Ty4miMg4tJ/XmuLyfUBsvjBCIHgu3wmEtj0X5HRIkF1gRIRwk0erLZbtMyTAWLoJ9g6OjoU4y8OICOEJ/o7IZ3axDHGemm5gXCBBxRP0lUswhmIzGzUXRo0zRRD24vO7Gp0CoYAjwlgg2wDpBEF2zjwaZlKCQT3sMTGHmNddIKjTSRAKvEwYRSE4DaIMGL4QnAehBJCX6K/sVfCfFm9hLGbm7KOhZIwtUqfDMFmKve8J1FkQBoSgLbIQTv6cUdjhJIgyIXi5F4XhHIiIEF57WfuUXWA4BSIiBO0OepsOO2d0guEMCCDoLbkBDVoT8ltkxHOGYNTjM3ug+q0LB0QrfiQIXi4RYawCxmDdEa3oX29wisuJAbHl74RCmwgwujNmfA2Gn7k4U+gghfW3PjH5QvDsI8B4m337xPAUt8crBs5BS/14q9849RNf0nKSCfRbqrmuNVNvJP7sq3RQAIJBjjIpfIW/Rt+biv+9UM8Xzg+gozRLTPKC4DYX+mKuybQtQQegD9HL2P2hjCz40Jfsxai+zN1Dr+Kjo2IQONJRVz8FCMYw1WOQoiBi8OvrwrzNfI3COiD6Dpsd6Mcw27T2xwJCyQGjjWIX+kV11yQ2EEocGHol1oL2Q3WXJFYQShwYTykaUVcOagq701aUbYjjDzAe4ecg6sJBLZty7HeEBxIYt7k+7NXTXiYGQokD4zrF0bRDUHyJgtAEwLhEoVNhqiVxEMoeGGcpzqeZhBUQORgnKK+kFYY1EDkATZQ30gjDKggeEW2nh9C7aYNhFYSSB4beFvWC9lh1H7F+GLMOQokD4yeFTp/PVS8irUXaEm2qCghlBIxvFLtRvZ+Y8onKObPBxnUs3yMqCZRvGb0Zr48tdWg7ehFIHyityj8qXk0CqNjsSgAAAABJRU5ErkJggg=="),
+    NATIVE_UNMUTED("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"),
+    NATIVE_PLAY("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");
 
     private final String encodedString;
 
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/ResponseHeader.java b/mopub-sdk/src/main/java/com/mopub/common/util/ResponseHeader.java
index 6e407f85..93a0f227 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/ResponseHeader.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/ResponseHeader.java
@@ -25,6 +25,13 @@
     USER_AGENT("User-Agent"),
     ACCEPT_LANGUAGE("Accept-Language"),
 
+    // Native Video fields
+    PLAY_VISIBLE_PERCENT("X-Play-Visible-Percent"),
+    PAUSE_VISIBLE_PERCENT("X-Pause-Visible-Percent"),
+    IMPRESSION_MIN_VISIBLE_PERCENT("X-Impression-Min-Visible-Percent"),
+    IMPRESSION_VISIBLE_MS("X-Impression-Visible-Ms"),
+    MAX_BUFFER_MS("X-Max-Buffer-Ms"),
+
     @Deprecated CUSTOM_SELECTOR("X-Customselector");
 
     private final String key;
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdTypeTranslator.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdTypeTranslator.java
index f2d5e8c9..36878ac2 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdTypeTranslator.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/AdTypeTranslator.java
@@ -26,6 +26,7 @@
         HTML_INTERSTITIAL("html_interstitial", "com.mopub.mobileads.HtmlInterstitial"),
         VAST_VIDEO_INTERSTITIAL("vast_interstitial", "com.mopub.mobileads.VastVideoInterstitial"),
         MOPUB_NATIVE("mopub_native", "com.mopub.nativeads.MoPubCustomEventNative"),
+        MOPUB_VIDEO_NATIVE("mopub_video_native", "com.mopub.nativeads.MoPubCustomEventVideoNative"),
 
         UNSPECIFIED("", null);
 
@@ -67,8 +68,10 @@ public static String getCustomEventName(@NonNull AdFormat adFormat,
             @NonNull Map<String, String> headers) {
         if (AdType.CUSTOM.equalsIgnoreCase(adType)) {
             return extractHeader(headers, ResponseHeader.CUSTOM_EVENT_NAME);
-        } else if (AdType.NATIVE.equalsIgnoreCase(adType)){
+        } else if (AdType.STATIC_NATIVE.equalsIgnoreCase(adType)){
             return CustomEventType.MOPUB_NATIVE.toString();
+        } else if (AdType.VIDEO_NATIVE.equalsIgnoreCase(adType)){
+            return CustomEventType.MOPUB_VIDEO_NATIVE.toString();
         } else if (AdType.HTML.equalsIgnoreCase(adType) || AdType.MRAID.equalsIgnoreCase(adType)) {
             return (AdFormat.INTERSTITIAL.equals(adFormat)
                     ? CustomEventType.fromString(adType + INTERSTITIAL_SUFFIX)
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdViewController.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdViewController.java
index 20e7c2da..b7968b90 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdViewController.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/AdViewController.java
@@ -270,11 +270,6 @@ void loadFailUrl(MoPubErrorCode errorCode) {
         }
     }
 
-    @Deprecated
-    void setFailUrl(String failUrl) {
-        // Does nothing.
-    }
-
     void setNotLoading() {
         this.mIsLoading = false;
         if (mActiveRequest != null) {
@@ -333,21 +328,6 @@ public int getAdHeight() {
         return 0;
     }
 
-    @Deprecated
-    public String getClickTrackingUrl() {
-        return mAdResponse == null ? null : mAdResponse.getClickTrackingUrl();
-    }
-
-    @Deprecated
-    public String getRedirectUrl() {
-        return mAdResponse == null ? null : mAdResponse.getRedirectUrl();
-    }
-
-    @Deprecated
-    public String getResponseString() {
-        return mAdResponse == null ? null : mAdResponse.getStringBody();
-    }
-
     public boolean getAutorefreshEnabled() {
         return mAutoRefreshEnabled;
     }
@@ -397,11 +377,6 @@ public void setTesting(boolean enabled) {
         mIsTesting = enabled;
     }
 
-    @Deprecated
-    Object getAdConfiguration() {
-        return null;
-    }
-
     boolean isDestroyed() {
         return mIsDestroyed;
     }
@@ -446,6 +421,7 @@ void trackImpression() {
 
     void registerClick() {
         if (mAdResponse != null) {
+            // Click tracker fired from Banners and Interstitials
             TrackingRequest.makeTrackingHttpRequest(mAdResponse.getClickTrackingUrl(),
                     mContext, BaseEvent.Name.CLICK_REQUEST);
         }
@@ -591,40 +567,4 @@ Integer getRefreshTimeMillis() {
     void setRefreshTimeMillis(@Nullable final Integer refreshTimeMillis) {
         mRefreshTimeMillis = refreshTimeMillis;
     }
-
-    @Deprecated
-    public void customEventDidLoadAd() {
-        setNotLoading();
-        trackImpression();
-        scheduleRefreshTimerIfEnabled();
-    }
-
-    @Deprecated
-    public void customEventDidFailToLoadAd() {
-        loadFailUrl(MoPubErrorCode.UNSPECIFIED);
-    }
-
-    @Deprecated
-    public void customEventActionWillBegin() {
-        registerClick();
-    }
-
-    @Deprecated
-    public void setClickthroughUrl(String clickthroughUrl) {
-        // Does nothing
-    }
-
-    /**
-     * @deprecated As of release 2.4
-     */
-    @Deprecated
-    public boolean isFacebookSupported() {
-        return false;
-    }
-
-    /**
-     * @deprecated As of release 2.4
-     */
-    @Deprecated
-    public void setFacebookSupported(boolean enabled) {}
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseVideoPlayerActivity.java b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseVideoPlayerActivity.java
index 8d608d91..1a4dc8b5 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseVideoPlayerActivity.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseVideoPlayerActivity.java
@@ -7,13 +7,15 @@
 import android.media.AudioManager;
 
 import com.mopub.common.logging.MoPubLog;
+import com.mopub.nativeads.NativeVideoController;
+import com.mopub.nativeads.NativeVideoViewController;
 
 import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
 import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
 import static com.mopub.mobileads.VastVideoViewController.VAST_VIDEO_CONFIG;
 
 public class BaseVideoPlayerActivity extends Activity {
-    static final String VIDEO_CLASS_EXTRAS_KEY = "video_view_class_name";
+    public static final String VIDEO_CLASS_EXTRAS_KEY = "video_view_class_name";
     public static final String VIDEO_URL = "video_url";
 
     public static void startMraid(final Context context, final String videoUrl) {
@@ -37,7 +39,8 @@ static Intent createIntentMraid(final Context context,
     static void startVast(final Context context,
             final VastVideoConfig vastVideoConfig,
             final long broadcastIdentifier) {
-        final Intent intentVideoPlayerActivity = createIntentVast(context, vastVideoConfig, broadcastIdentifier);
+        final Intent intentVideoPlayerActivity = createIntentVast(context, vastVideoConfig,
+                broadcastIdentifier);
         try {
             context.startActivity(intentVideoPlayerActivity);
         } catch (ActivityNotFoundException e) {
@@ -56,6 +59,24 @@ static Intent createIntentVast(final Context context,
         return intentVideoPlayerActivity;
     }
 
+    public static void startNativeVideo(final Context context, final long nativeVideoId, final VastVideoConfig vastVideoConfig) {
+        final Intent intentVideoPlayerActivity = createIntentNativeVideo(context, nativeVideoId, vastVideoConfig);
+        try {
+            context.startActivity(intentVideoPlayerActivity);
+        } catch (ActivityNotFoundException e) {
+            MoPubLog.d("Activity MraidVideoPlayerActivity not found. Did you declare it in your AndroidManifest.xml?");
+        }
+    }
+
+    public static Intent createIntentNativeVideo(final Context context, final long nativeVideoId, final VastVideoConfig vastVideoConfig) {
+        final Intent intentVideoPlayerActivity = new Intent(context, MraidVideoPlayerActivity.class);
+        intentVideoPlayerActivity.setFlags(FLAG_ACTIVITY_NEW_TASK);
+        intentVideoPlayerActivity.putExtra(VIDEO_CLASS_EXTRAS_KEY, "native");
+        intentVideoPlayerActivity.putExtra(NativeVideoViewController.NATIVE_VIDEO_ID, nativeVideoId);
+        intentVideoPlayerActivity.putExtra(NativeVideoViewController.NATIVE_VAST_VIDEO_CONFIG, vastVideoConfig);
+        return intentVideoPlayerActivity;
+    }
+
     @Override
     protected void onDestroy() {
         super.onDestroy();
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseVideoViewController.java b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseVideoViewController.java
index 6856f4a9..9cae4baf 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseVideoViewController.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseVideoViewController.java
@@ -32,7 +32,7 @@ void onStartActivityForResult(final Class<? extends Activity> clazz,
     }
 
     protected BaseVideoViewController(final Context context, @Nullable final Long broadcastIdentifier, final BaseVideoViewControllerListener baseVideoViewControllerListener) {
-        mContext = context.getApplicationContext();
+        mContext = context;
         mBroadcastIdentifier = broadcastIdentifier;
         mBaseVideoViewControllerListener = baseVideoViewControllerListener;
         mLayout = new RelativeLayout(mContext);
@@ -51,7 +51,8 @@ protected void onCreate() {
     protected abstract void onResume();
     protected abstract void onDestroy();
     protected abstract void onSaveInstanceState(@NonNull Bundle outState);
-    protected abstract void onConfigurationChanged(@Nullable Configuration configuration);
+    protected abstract void onConfigurationChanged(Configuration configuration);
+    protected abstract void onBackPressed();
 
     public boolean backButtonEnabled() {
         return true;
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubInterstitial.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubInterstitial.java
index 5aa4176d..25bf2a69 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubInterstitial.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubInterstitial.java
@@ -7,6 +7,7 @@
 
 import com.mopub.common.AdFormat;
 import com.mopub.common.MoPub;
+import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.mobileads.factories.CustomEventInterstitialAdapterFactory;
 
@@ -42,14 +43,6 @@ boolean isReady() {
         public void onInterstitialDismissed(MoPubInterstitial interstitial);
     }
 
-    private MoPubInterstitialListener mListener;
-
-    @Deprecated
-    public interface MoPubInterstitialListener {
-        public void OnInterstitialLoaded();
-        public void OnInterstitialFailed();
-    }
-
     public MoPubInterstitial(Activity activity, String id) {
         mActivity = activity;
         mAdUnitId = id;
@@ -177,8 +170,6 @@ public void onCustomEventInterstitialLoaded() {
 
         if (mInterstitialAdListener != null) {
             mInterstitialAdListener.onInterstitialLoaded(this);
-        } else if (mListener != null) {
-            mListener.OnInterstitialLoaded();
         }
     }
 
@@ -223,26 +214,6 @@ public void onCustomEventInterstitialDismissed() {
         }
     }
 
-    @Deprecated
-    public void setLocationAwareness(LocationAwareness locationAwareness) {
-        MoPub.setLocationAwareness(locationAwareness.getNewLocationAwareness());
-    }
-
-    @Deprecated
-    public LocationAwareness getLocationAwareness() {
-        return LocationAwareness.fromMoPubLocationAwareness(MoPub.getLocationAwareness());
-    }
-
-    @Deprecated
-    public void setLocationPrecision(int precision) {
-        MoPub.setLocationPrecision(precision);
-    }
-
-    @Deprecated
-    public int getLocationPrecision() {
-        return MoPub.getLocationPrecision();
-    }
-
     ////////////////////////////////////////////////////////////////////////////////////////////////
 
     public class MoPubInterstitialView extends MoPubView {
@@ -298,47 +269,9 @@ protected void adFailed(MoPubErrorCode errorCode) {
         }
     }
 
-    @Deprecated // for testing
+    @VisibleForTesting
+    @Deprecated
     void setInterstitialView(MoPubInterstitialView interstitialView) {
         mInterstitialView = interstitialView;
     }
-
-    @Deprecated
-    public void setListener(MoPubInterstitialListener listener) {
-        mListener = listener;
-    }
-
-    @Deprecated
-    public MoPubInterstitialListener getListener() {
-        return mListener;
-    }
-
-    @Deprecated
-    public void customEventDidLoadAd() {
-        if (mInterstitialView != null) mInterstitialView.trackImpression();
-    }
-
-    @Deprecated
-    public void customEventDidFailToLoadAd() {
-        if (mInterstitialView != null) mInterstitialView.loadFailUrl(MoPubErrorCode.UNSPECIFIED);
-    }
-
-    @Deprecated
-    public void customEventActionWillBegin() {
-        if (mInterstitialView != null) mInterstitialView.registerClick();
-    }
-
-    /**
-     * @deprecated As of release 2.4
-     */
-    @Deprecated
-    public void setFacebookSupported(boolean enabled) {}
-
-    /**
-     * @deprecated As of release 2.4
-     */
-    @Deprecated
-    public boolean isFacebookSupported() {
-        return false;
-    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubView.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubView.java
index c3c092b1..d05b71c0 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubView.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubView.java
@@ -14,7 +14,6 @@
 import android.widget.FrameLayout;
 
 import com.mopub.common.AdFormat;
-import com.mopub.common.MoPub;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.util.ManifestUtils;
 import com.mopub.common.util.Visibility;
@@ -24,490 +23,335 @@
 import java.util.Map;
 import java.util.TreeMap;
 
-import static com.mopub.common.LocationService.LocationAwareness;
 import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
 
 public class MoPubView extends FrameLayout {
-	public interface BannerAdListener {
-		public void onBannerLoaded(MoPubView banner);
-
-		public void onBannerFailed(MoPubView banner, MoPubErrorCode errorCode);
-
-		public void onBannerClicked(MoPubView banner);
-
-		public void onBannerExpanded(MoPubView banner);
-
-		public void onBannerCollapsed(MoPubView banner);
-	}
-
-	public static final int DEFAULT_LOCATION_PRECISION = 6;
-	@Nullable
-	protected AdViewController mAdViewController;
-	protected CustomEventBannerAdapter mCustomEventBannerAdapter;
-
-	private Context mContext;
-	private int mScreenVisibility;
-	private BroadcastReceiver mScreenStateReceiver;
-
-	private BannerAdListener mBannerAdListener;
-
-	private OnAdWillLoadListener mOnAdWillLoadListener;
-	private OnAdLoadedListener mOnAdLoadedListener;
-	private OnAdFailedListener mOnAdFailedListener;
-	private OnAdPresentedOverlayListener mOnAdPresentedOverlayListener;
-	private OnAdClosedListener mOnAdClosedListener;
-	private OnAdClickedListener mOnAdClickedListener;
-
-	public MoPubView(Context context) {
-		this(context, null);
-	}
-
-	public MoPubView(Context context, AttributeSet attrs) {
-		super(context, attrs);
-
-		ManifestUtils.checkWebViewActivitiesDeclared(context);
-
-		mContext = context;
-		mScreenVisibility = getVisibility();
-
-		setHorizontalScrollBarEnabled(false);
-		setVerticalScrollBarEnabled(false);
-
-		// There is a rare bug in Froyo/2.2 where creation of a WebView causes a
-		// NullPointerException. (http://code.google.com/p/android/issues/detail?id=10789)
-		// It happens when the WebView can't access the local file store to make a cache file.
-		// Here, we'll work around it by trying to create a file store and then just go inert
-		// if it's not accessible.
-		if (WebViewDatabase.getInstance(context) == null) {
-			MoPubLog.e("Disabling MoPub. Local cache file is inaccessible so MoPub will " +
-					"fail if we try to create a WebView. Details of this Android bug found at:" +
-					"http://code.google.com/p/android/issues/detail?id=10789");
-			return;
-		}
-
-		mAdViewController = AdViewControllerFactory.create(context, this);
-		registerScreenStateBroadcastReceiver();
-	}
-
-	private void registerScreenStateBroadcastReceiver() {
-		mScreenStateReceiver = new BroadcastReceiver() {
-			public void onReceive(final Context context, final Intent intent) {
-				if (!Visibility.isScreenVisible(mScreenVisibility) || intent == null) {
-					return;
-				}
-
-				final String action = intent.getAction();
-
-				if (Intent.ACTION_USER_PRESENT.equals(action)) {
-					setAdVisibility(View.VISIBLE);
-				} else if (Intent.ACTION_SCREEN_OFF.equals(action)) {
-					setAdVisibility(View.GONE);
-				}
-			}
-		};
-
-		final IntentFilter filter = new IntentFilter(Intent.ACTION_SCREEN_OFF);
-		filter.addAction(Intent.ACTION_USER_PRESENT);
-		mContext.registerReceiver(mScreenStateReceiver, filter);
-	}
-
-	private void unregisterScreenStateBroadcastReceiver() {
-		try {
-			mContext.unregisterReceiver(mScreenStateReceiver);
-		} catch (Exception IllegalArgumentException) {
-			MoPubLog.d("Failed to unregister screen state broadcast receiver (never registered).");
-		}
-	}
-
-	public void loadAd() {
-		if (mAdViewController != null) {
-			mAdViewController.loadAd();
-		}
-	}
-
-	/*
-	 * Tears down the ad view: no ads will be shown once this method executes. The parent
-	 * Activity's onDestroy implementation must include a call to this method.
-	 */
-	public void destroy() {
-		unregisterScreenStateBroadcastReceiver();
-		removeAllViews();
-
-		if (mAdViewController != null) {
-			mAdViewController.cleanup();
-			mAdViewController = null;
-		}
-
-		if (mCustomEventBannerAdapter != null) {
-			mCustomEventBannerAdapter.invalidate();
-			mCustomEventBannerAdapter = null;
-		}
-	}
-
-	Integer getAdTimeoutDelay() {
-		return (mAdViewController != null) ? mAdViewController.getAdTimeoutDelay() : null;
-	}
-
-	protected void loadFailUrl(MoPubErrorCode errorCode) {
-		if (mAdViewController != null) mAdViewController.loadFailUrl(errorCode);
-	}
-
-	protected void loadCustomEvent(String customEventClassName, Map<String, String> serverExtras) {
-		if (mAdViewController == null) {
-			return;
-		}
-		if (TextUtils.isEmpty(customEventClassName)) {
-			MoPubLog.d("Couldn't invoke custom event because the server did not specify one.");
-			loadFailUrl(ADAPTER_NOT_FOUND);
-			return;
-		}
-
-		if (mCustomEventBannerAdapter != null) {
-			mCustomEventBannerAdapter.invalidate();
-		}
-
-		MoPubLog.d("Loading custom event adapter.");
-
-		mCustomEventBannerAdapter = CustomEventBannerAdapterFactory.create(
-				this,
-				customEventClassName,
-				serverExtras,
-				mAdViewController.getBroadcastIdentifier(),
-				mAdViewController.getAdReport());
-		mCustomEventBannerAdapter.loadAd();
-	}
-
-	protected void registerClick() {
-		if (mAdViewController != null) {
-			mAdViewController.registerClick();
-
-			// Let any listeners know that an ad was clicked
-			adClicked();
-		}
-	}
-
-	protected void trackNativeImpression() {
-		MoPubLog.d("Tracking impression for native adapter.");
-		if (mAdViewController != null) mAdViewController.trackImpression();
-	}
-
-	@Override
-	protected void onWindowVisibilityChanged(final int visibility) {
-		// Ignore transitions between View.GONE and View.INVISIBLE
-		if (Visibility.hasScreenVisibilityChanged(mScreenVisibility, visibility)) {
-			mScreenVisibility = visibility;
-			setAdVisibility(mScreenVisibility);
-		}
-	}
-
-	@Override
-	protected void onVisibilityChanged(View changedView, int visibility) {
-		super.onVisibilityChanged(changedView, visibility);
-		if (changedView == this) {
-			setAdVisibility(visibility);
-		}
-	}
-
-	private void setAdVisibility(final int visibility) {
-		if (mAdViewController == null) {
-			return;
-		}
-
-		if (Visibility.isScreenVisible(visibility)) {
-			mAdViewController.unpauseRefresh();
-		} else {
-			mAdViewController.pauseRefresh();
-		}
-	}
-
-	protected void adLoaded() {
-		MoPubLog.d("adLoaded");
-
-		if (mBannerAdListener != null) {
-			mBannerAdListener.onBannerLoaded(this);
-		} else if (mOnAdLoadedListener != null) {
-			mOnAdLoadedListener.OnAdLoaded(this);
-		}
-	}
-
-	protected void adFailed(MoPubErrorCode errorCode) {
-		if (mBannerAdListener != null) {
-			mBannerAdListener.onBannerFailed(this, errorCode);
-		} else if (mOnAdFailedListener != null) {
-			mOnAdFailedListener.OnAdFailed(this);
-		}
-	}
-
-	protected void adPresentedOverlay() {
-		if (mBannerAdListener != null) {
-			mBannerAdListener.onBannerExpanded(this);
-		} else if (mOnAdPresentedOverlayListener != null) {
-			mOnAdPresentedOverlayListener.OnAdPresentedOverlay(this);
-		}
-	}
-
-	protected void adClosed() {
-		if (mBannerAdListener != null) {
-			mBannerAdListener.onBannerCollapsed(this);
-		} else if (mOnAdClosedListener != null) {
-			mOnAdClosedListener.OnAdClosed(this);
-		}
-	}
-
-	protected void adClicked() {
-		if (mBannerAdListener != null) {
-			mBannerAdListener.onBannerClicked(this);
-		} else if (mOnAdClickedListener != null) {
-			mOnAdClickedListener.OnAdClicked(this);
-		}
-	}
-
-	protected void nativeAdLoaded() {
-		if (mAdViewController != null) mAdViewController.scheduleRefreshTimerIfEnabled();
-		adLoaded();
-	}
-
-	////////////////////////////////////////////////////////////////////////////////////////////////
-
-	public void setAdUnitId(String adUnitId) {
-		if (mAdViewController != null) mAdViewController.setAdUnitId(adUnitId);
-	}
-
-	public String getAdUnitId() {
-		return (mAdViewController != null) ? mAdViewController.getAdUnitId() : null;
-	}
-
-	public void setKeywords(String keywords) {
-		if (mAdViewController != null) mAdViewController.setKeywords(keywords);
-	}
-
-	public String getKeywords() {
-		return (mAdViewController != null) ? mAdViewController.getKeywords() : null;
-	}
-
-	public void setLocation(Location location) {
-		if (mAdViewController != null) mAdViewController.setLocation(location);
-	}
-
-	public Location getLocation() {
-		return (mAdViewController != null) ? mAdViewController.getLocation() : null;
-	}
-
-	public void setTimeout(int milliseconds) {
-		if (mAdViewController != null) mAdViewController.setTimeout(milliseconds);
-	}
-
-	public int getAdWidth() {
-		return (mAdViewController != null) ? mAdViewController.getAdWidth() : 0;
-	}
-
-	public int getAdHeight() {
-		return (mAdViewController != null) ? mAdViewController.getAdHeight() : 0;
-	}
-
-	public String getResponseString() {
-		return (mAdViewController != null) ? mAdViewController.getResponseString() : null;
-	}
-
-	@Deprecated
-	public void setClickthroughUrl(String url) {
-		// Does nothing.
-	}
-
-	public String getClickTrackingUrl() {
-		return (mAdViewController != null) ? mAdViewController.getClickTrackingUrl() : null;
-	}
-
-	@Deprecated
-	public String getClickthroughUrl() {
-		return getClickTrackingUrl();
-	}
-
-	public Activity getActivity() {
-		return (Activity) mContext;
-	}
-
-	public void setBannerAdListener(BannerAdListener listener) {
-		mBannerAdListener = listener;
-	}
-
-	public BannerAdListener getBannerAdListener() {
-		return mBannerAdListener;
-	}
-
-	public void setLocalExtras(Map<String, Object> localExtras) {
-		if (mAdViewController != null) mAdViewController.setLocalExtras(localExtras);
-	}
-
-	public Map<String, Object> getLocalExtras() {
-		if (mAdViewController != null) {
-			return mAdViewController.getLocalExtras();
-		}
-		return new TreeMap<String, Object>();
-	}
-
-	public void setAutorefreshEnabled(boolean enabled) {
-		if (mAdViewController != null) {
-			mAdViewController.forceSetAutorefreshEnabled(enabled);
-		}
-	}
-
-	public boolean getAutorefreshEnabled() {
-		if (mAdViewController != null) return mAdViewController.getAutorefreshEnabled();
-		else {
-			MoPubLog.d("Can't get autorefresh status for destroyed MoPubView. " +
-					"Returning false.");
-			return false;
-		}
-	}
-
-	public void setAdContentView(View view) {
-		if (mAdViewController != null) mAdViewController.setAdContentView(view);
-	}
-
-	public void setTesting(boolean testing) {
-		if (mAdViewController != null) mAdViewController.setTesting(testing);
-	}
-
-	public boolean getTesting() {
-		if (mAdViewController != null) return mAdViewController.getTesting();
-		else {
-			MoPubLog.d("Can't get testing status for destroyed MoPubView. " +
-					"Returning false.");
-			return false;
-		}
-	}
-
-	public void forceRefresh() {
-		if (mCustomEventBannerAdapter != null) {
-			mCustomEventBannerAdapter.invalidate();
-			mCustomEventBannerAdapter = null;
-		}
-
-		if (mAdViewController != null) mAdViewController.forceRefresh();
-	}
-
-	public AdViewController getAdViewController() {
-		return mAdViewController;
-	}
-
-	public AdFormat getAdFormat() {
-		return AdFormat.BANNER;
-	}
-
-	@Deprecated
-	public void setLocationAwareness(LocationAwareness locationAwareness) {
-		MoPub.setLocationAwareness(locationAwareness.getNewLocationAwareness());
-	}
-
-	@Deprecated
-	public LocationAwareness getLocationAwareness() {
-		return LocationAwareness.fromMoPubLocationAwareness(MoPub.getLocationAwareness());
-	}
-
-	@Deprecated
-	public void setLocationPrecision(int precision) {
-		MoPub.setLocationPrecision(precision);
-	}
-
-	@Deprecated
-	public int getLocationPrecision() {
-		return MoPub.getLocationPrecision();
-	}
-
-	@Deprecated
-	public interface OnAdWillLoadListener {
-		public void OnAdWillLoad(MoPubView m, String url);
-	}
-
-	@Deprecated
-	public interface OnAdLoadedListener {
-		public void OnAdLoaded(MoPubView m);
-	}
-
-	@Deprecated
-	public interface OnAdFailedListener {
-		public void OnAdFailed(MoPubView m);
-	}
-
-	@Deprecated
-	public interface OnAdClosedListener {
-		public void OnAdClosed(MoPubView m);
-	}
-
-	@Deprecated
-	public interface OnAdClickedListener {
-		public void OnAdClicked(MoPubView m);
-	}
-
-	@Deprecated
-	public interface OnAdPresentedOverlayListener {
-		public void OnAdPresentedOverlay(MoPubView m);
-	}
-
-	@Deprecated
-	public void setOnAdWillLoadListener(OnAdWillLoadListener listener) {
-		mOnAdWillLoadListener = listener;
-	}
-
-	@Deprecated
-	public void setOnAdLoadedListener(OnAdLoadedListener listener) {
-		mOnAdLoadedListener = listener;
-	}
-
-	@Deprecated
-	public void setOnAdFailedListener(OnAdFailedListener listener) {
-		mOnAdFailedListener = listener;
-	}
-
-	@Deprecated
-	public void setOnAdPresentedOverlayListener(OnAdPresentedOverlayListener listener) {
-		mOnAdPresentedOverlayListener = listener;
-	}
-
-	@Deprecated
-	public void setOnAdClosedListener(OnAdClosedListener listener) {
-		mOnAdClosedListener = listener;
-	}
-
-	@Deprecated
-	public void setOnAdClickedListener(OnAdClickedListener listener) {
-		mOnAdClickedListener = listener;
-	}
-
-	@Deprecated
-	protected void adWillLoad(String url) {
-		MoPubLog.d("adWillLoad: " + url);
-		if (mOnAdWillLoadListener != null) mOnAdWillLoadListener.OnAdWillLoad(this, url);
-	}
-
-	@Deprecated
-	public void customEventDidLoadAd() {
-		if (mAdViewController != null) mAdViewController.customEventDidLoadAd();
-	}
-
-	@Deprecated
-	public void customEventDidFailToLoadAd() {
-		if (mAdViewController != null) mAdViewController.customEventDidFailToLoadAd();
-	}
-
-	@Deprecated
-	public void customEventActionWillBegin() {
-		if (mAdViewController != null) mAdViewController.customEventActionWillBegin();
-	}
-
-	/**
-	 * @deprecated As of release 2.4
-	 */
-	@Deprecated
-	public void setFacebookSupported(boolean enabled) {
-	}
-
-	/**
-	 * @deprecated As of release 2.4
-	 */
-	@Deprecated
-	public boolean isFacebookSupported() {
-		return false;
-	}
+    public interface BannerAdListener {
+        public void onBannerLoaded(MoPubView banner);
+        public void onBannerFailed(MoPubView banner, MoPubErrorCode errorCode);
+        public void onBannerClicked(MoPubView banner);
+        public void onBannerExpanded(MoPubView banner);
+        public void onBannerCollapsed(MoPubView banner);
+    }
+
+    @Nullable
+    protected AdViewController mAdViewController;
+    protected CustomEventBannerAdapter mCustomEventBannerAdapter;
+
+    private Context mContext;
+    private int mScreenVisibility;
+    private BroadcastReceiver mScreenStateReceiver;
+
+    private BannerAdListener mBannerAdListener;
+
+    public MoPubView(Context context) {
+        this(context, null);
+    }
+
+    public MoPubView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+
+        ManifestUtils.checkWebViewActivitiesDeclared(context);
+
+        mContext = context;
+        mScreenVisibility = getVisibility();
+
+        setHorizontalScrollBarEnabled(false);
+        setVerticalScrollBarEnabled(false);
+
+        // There is a rare bug in Froyo/2.2 where creation of a WebView causes a
+        // NullPointerException. (http://code.google.com/p/android/issues/detail?id=10789)
+        // It happens when the WebView can't access the local file store to make a cache file.
+        // Here, we'll work around it by trying to create a file store and then just go inert
+        // if it's not accessible.
+        if (WebViewDatabase.getInstance(context) == null) {
+            MoPubLog.e("Disabling MoPub. Local cache file is inaccessible so MoPub will " +
+                    "fail if we try to create a WebView. Details of this Android bug found at:" +
+                    "http://code.google.com/p/android/issues/detail?id=10789");
+            return;
+        }
+
+        mAdViewController = AdViewControllerFactory.create(context, this);
+        registerScreenStateBroadcastReceiver();
+    }
+
+    private void registerScreenStateBroadcastReceiver() {
+        mScreenStateReceiver = new BroadcastReceiver() {
+            public void onReceive(final Context context, final Intent intent) {
+                if (!Visibility.isScreenVisible(mScreenVisibility) || intent == null) {
+                    return;
+                }
+
+                final String action = intent.getAction();
+
+                if (Intent.ACTION_USER_PRESENT.equals(action)) {
+                    setAdVisibility(View.VISIBLE);
+                } else if (Intent.ACTION_SCREEN_OFF.equals(action)) {
+                    setAdVisibility(View.GONE);
+                }
+            }
+        };
+
+        final IntentFilter filter = new IntentFilter(Intent.ACTION_SCREEN_OFF);
+        filter.addAction(Intent.ACTION_USER_PRESENT);
+        mContext.registerReceiver(mScreenStateReceiver, filter);
+    }
+
+    private void unregisterScreenStateBroadcastReceiver() {
+        try {
+            mContext.unregisterReceiver(mScreenStateReceiver);
+        } catch (Exception IllegalArgumentException) {
+            MoPubLog.d("Failed to unregister screen state broadcast receiver (never registered).");
+        }
+    }
+
+    public void loadAd() {
+        if (mAdViewController != null) {
+            mAdViewController.loadAd();
+        }
+    }
+
+    /*
+     * Tears down the ad view: no ads will be shown once this method executes. The parent
+     * Activity's onDestroy implementation must include a call to this method.
+     */
+    public void destroy() {
+        unregisterScreenStateBroadcastReceiver();
+        removeAllViews();
+
+        if (mAdViewController != null) {
+            mAdViewController.cleanup();
+            mAdViewController = null;
+        }
+
+        if (mCustomEventBannerAdapter != null) {
+            mCustomEventBannerAdapter.invalidate();
+            mCustomEventBannerAdapter = null;
+        }
+    }
+
+    Integer getAdTimeoutDelay() {
+        return (mAdViewController != null) ? mAdViewController.getAdTimeoutDelay() : null;
+    }
+
+    protected void loadFailUrl(MoPubErrorCode errorCode) {
+        if (mAdViewController != null) mAdViewController.loadFailUrl(errorCode);
+    }
+
+    protected void loadCustomEvent(String customEventClassName, Map<String, String> serverExtras) {
+        if (mAdViewController == null) {
+            return;
+        }
+        if (TextUtils.isEmpty(customEventClassName)) {
+            MoPubLog.d("Couldn't invoke custom event because the server did not specify one.");
+            loadFailUrl(ADAPTER_NOT_FOUND);
+            return;
+        }
+
+        if (mCustomEventBannerAdapter != null) {
+            mCustomEventBannerAdapter.invalidate();
+        }
+
+        MoPubLog.d("Loading custom event adapter.");
+
+        mCustomEventBannerAdapter = CustomEventBannerAdapterFactory.create(
+                this,
+                customEventClassName,
+                serverExtras,
+                mAdViewController.getBroadcastIdentifier(),
+                mAdViewController.getAdReport());
+        mCustomEventBannerAdapter.loadAd();
+    }
+
+    protected void registerClick() {
+        if (mAdViewController != null) {
+            mAdViewController.registerClick();
+
+            // Let any listeners know that an ad was clicked
+            adClicked();
+        }
+    }
+
+    protected void trackNativeImpression() {
+        MoPubLog.d("Tracking impression for native adapter.");
+        if (mAdViewController != null) mAdViewController.trackImpression();
+    }
+
+    @Override
+    protected void onWindowVisibilityChanged(final int visibility) {
+        // Ignore transitions between View.GONE and View.INVISIBLE
+        if (Visibility.hasScreenVisibilityChanged(mScreenVisibility, visibility)) {
+            mScreenVisibility = visibility;
+            setAdVisibility(mScreenVisibility);
+        }
+    }
+
+    private void setAdVisibility(final int visibility) {
+        if (mAdViewController == null) {
+            return;
+        }
+
+        if (Visibility.isScreenVisible(visibility)) {
+            mAdViewController.unpauseRefresh();
+        } else {
+            mAdViewController.pauseRefresh();
+        }
+    }
+
+    protected void adLoaded() {
+        MoPubLog.d("adLoaded");
+        
+        if (mBannerAdListener != null) {
+            mBannerAdListener.onBannerLoaded(this);
+        }
+    }
+
+    protected void adFailed(MoPubErrorCode errorCode) {
+        if (mBannerAdListener != null) {
+            mBannerAdListener.onBannerFailed(this, errorCode);
+        }
+    }
+
+    protected void adPresentedOverlay() {
+        if (mBannerAdListener != null) {
+            mBannerAdListener.onBannerExpanded(this);
+        }
+    }
+
+    protected void adClosed() {
+        if (mBannerAdListener != null) {
+            mBannerAdListener.onBannerCollapsed(this);
+        }
+    }
+
+    protected void adClicked() {
+        if (mBannerAdListener != null) {
+            mBannerAdListener.onBannerClicked(this);
+        }
+    }
+
+    protected void nativeAdLoaded() {
+        if (mAdViewController != null) mAdViewController.scheduleRefreshTimerIfEnabled();
+        adLoaded();
+    }
+
+    ////////////////////////////////////////////////////////////////////////////////////////////////
+
+    public void setAdUnitId(String adUnitId) {
+        if (mAdViewController != null) mAdViewController.setAdUnitId(adUnitId);
+    }
+
+    public String getAdUnitId() {
+        return (mAdViewController != null) ? mAdViewController.getAdUnitId() : null;
+    }
+
+    public void setKeywords(String keywords) {
+        if (mAdViewController != null) mAdViewController.setKeywords(keywords);
+    }
+
+    public String getKeywords() {
+        return (mAdViewController != null) ? mAdViewController.getKeywords() : null;
+    }
+
+    public void setLocation(Location location) {
+        if (mAdViewController != null) mAdViewController.setLocation(location);
+    }
+
+    public Location getLocation() {
+        return (mAdViewController != null) ? mAdViewController.getLocation() : null;
+    }
+
+    public void setTimeout(int milliseconds) {
+        if (mAdViewController != null) mAdViewController.setTimeout(milliseconds);
+    }
+
+    public int getAdWidth() {
+        return (mAdViewController != null) ? mAdViewController.getAdWidth() : 0;
+    }
+
+    public int getAdHeight() {
+        return (mAdViewController != null) ? mAdViewController.getAdHeight() : 0;
+    }
+
+    public Activity getActivity() {
+        return (Activity) mContext;
+    }
+
+    public void setBannerAdListener(BannerAdListener listener) {
+        mBannerAdListener = listener;
+    }
+
+    public BannerAdListener getBannerAdListener() {
+        return mBannerAdListener;
+    }
+
+    public void setLocalExtras(Map<String, Object> localExtras) {
+        if (mAdViewController != null) mAdViewController.setLocalExtras(localExtras);
+    }
+
+    public Map<String, Object> getLocalExtras() {
+        if (mAdViewController != null) {
+            return mAdViewController.getLocalExtras();
+        }
+        return new TreeMap<String, Object>();
+    }
+
+    public void setAutorefreshEnabled(boolean enabled) {
+        if (mAdViewController != null) {
+            mAdViewController.forceSetAutorefreshEnabled(enabled);
+        }
+    }
+
+    public boolean getAutorefreshEnabled() {
+        if (mAdViewController != null) return mAdViewController.getAutorefreshEnabled();
+        else {
+            MoPubLog.d("Can't get autorefresh status for destroyed MoPubView. " +
+                    "Returning false.");
+            return false;
+        }
+    }
+
+    public void setAdContentView(View view) {
+        if (mAdViewController != null) mAdViewController.setAdContentView(view);
+    }
+
+    public void setTesting(boolean testing) {
+        if (mAdViewController != null) mAdViewController.setTesting(testing);
+    }
+
+    public boolean getTesting() {
+        if (mAdViewController != null) return mAdViewController.getTesting();
+        else {
+            MoPubLog.d("Can't get testing status for destroyed MoPubView. " +
+                    "Returning false.");
+            return false;
+        }
+    }
+
+    public void forceRefresh() {
+        if (mCustomEventBannerAdapter != null) {
+            mCustomEventBannerAdapter.invalidate();
+            mCustomEventBannerAdapter = null;
+        }
+
+        if (mAdViewController != null) mAdViewController.forceRefresh();
+    }
+
+    AdViewController getAdViewController() {
+        return mAdViewController;
+    }
+
+    public AdFormat getAdFormat() {
+        return AdFormat.BANNER;
+    }
+
+    @Deprecated
+    public String getResponseString() {
+        return null;
+    }
+
+    @Deprecated
+    public String getClickTrackingUrl() {
+        return null;
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidVideoPlayerActivity.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidVideoPlayerActivity.java
index 9f58f6f9..bbbf6322 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidVideoPlayerActivity.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidVideoPlayerActivity.java
@@ -14,6 +14,7 @@
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.util.Intents;
 import com.mopub.mraid.MraidVideoViewController;
+import com.mopub.nativeads.NativeVideoViewController;
 
 import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_FAIL;
@@ -79,7 +80,7 @@ protected void onSaveInstanceState(@NonNull Bundle outState) {
     }
 
     @Override
-    public void onConfigurationChanged(@Nullable Configuration newConfig) {
+    public void onConfigurationChanged(final Configuration newConfig) {
         super.onConfigurationChanged(newConfig);
         if (mBaseVideoController != null) {
             mBaseVideoController.onConfigurationChanged(newConfig);
@@ -90,6 +91,7 @@ public void onConfigurationChanged(@Nullable Configuration newConfig) {
     public void onBackPressed() {
         if (mBaseVideoController != null && mBaseVideoController.backButtonEnabled()) {
             super.onBackPressed();
+            mBaseVideoController.onBackPressed();
         }
     }
 
@@ -107,6 +109,8 @@ private BaseVideoViewController createVideoViewController(Bundle savedInstanceSt
             return new VastVideoViewController(this, getIntent().getExtras(), savedInstanceState, mBroadcastIdentifier, this);
         } else if ("mraid".equals(clazz)) {
             return new MraidVideoViewController(this, getIntent().getExtras(), savedInstanceState, this);
+        } else if ("native".equals(clazz)) {
+            return new NativeVideoViewController(this, getIntent().getExtras(), savedInstanceState, this);
         } else {
             throw new IllegalStateException("Unsupported video type: " + clazz);
         }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/RepeatingHandlerRunnable.java b/mopub-sdk/src/main/java/com/mopub/mobileads/RepeatingHandlerRunnable.java
index 2c26fa69..05a8c05d 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/RepeatingHandlerRunnable.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/RepeatingHandlerRunnable.java
@@ -13,9 +13,9 @@
 public abstract class RepeatingHandlerRunnable implements Runnable {
     @NonNull protected final Handler mHandler;
     private volatile boolean mIsRunning;
-    private volatile long mUpdateIntervalMillis;
+    protected volatile long mUpdateIntervalMillis;
 
-    RepeatingHandlerRunnable(@NonNull final Handler handler) {
+    public RepeatingHandlerRunnable(@NonNull final Handler handler) {
         Preconditions.checkNotNull(handler);
         mHandler = handler;
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastBaseInLineWrapperXmlManager.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastBaseInLineWrapperXmlManager.java
index f1998357..b2016d12 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/VastBaseInLineWrapperXmlManager.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastBaseInLineWrapperXmlManager.java
@@ -1,6 +1,7 @@
 package com.mopub.mobileads;
 
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.text.TextUtils;
 
 import com.mopub.common.Preconditions;
@@ -21,6 +22,7 @@
     private static final String CREATIVE = "Creative";
     private static final String COMPANION_ADS = "CompanionAds";
     private static final String ERROR = "Error";
+    private static final String EXTENSIONS = "Extensions";
 
     @NonNull protected final Node mNode;
 
@@ -140,4 +142,20 @@
 
         return companionAdXmlManagers;
     }
+
+    /**
+     * If there is an Extensions section with at least one Extension, return its XML manager.
+     *
+     * @return The {@link VastExtensionParentXmlManager} or null if there are no Extensions or
+     * Extension child nodes.
+     */
+    @Nullable
+    VastExtensionParentXmlManager getVastExtensionParentXmlManager() {
+        Node vastExtensionsNode = XmlUtils.getFirstMatchingChildNode(mNode, EXTENSIONS);
+        if (vastExtensionsNode == null) {
+            return null;
+        }
+
+        return new VastExtensionParentXmlManager(vastExtensionsNode);
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastCompanionAdXmlManager.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastCompanionAdXmlManager.java
index abacc76c..1d977fb1 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/VastCompanionAdXmlManager.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastCompanionAdXmlManager.java
@@ -28,6 +28,7 @@
     private static final String EVENT = "event";
     private static final String WIDTH = "width";
     private static final String HEIGHT = "height";
+    private static final String AD_SLOT_ID = "adSlotID";
 
     // Attribute values
     private static final String CREATIVE_VIEW = "creativeView";
@@ -63,6 +64,16 @@ Integer getHeight() {
         return XmlUtils.getAttributeValueAsInt(mCompanionNode, HEIGHT);
     }
 
+    /**
+     * Gets the adSlotID attribute from the companion ad or {@code null} if not present.
+     *
+     * @return String adSlotId attribute or {@code null}.
+     */
+    @Nullable
+    String getAdSlotId() {
+        return XmlUtils.getAttributeValue(mCompanionNode, AD_SLOT_ID);
+    }
+
     @NonNull
     VastResourceXmlManager getResourceXmlManager() {
         return mResourceXmlManager;
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastExtensionParentXmlManager.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastExtensionParentXmlManager.java
new file mode 100644
index 00000000..c4145a13
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastExtensionParentXmlManager.java
@@ -0,0 +1,51 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+import com.mopub.mobileads.util.XmlUtils;
+
+import org.w3c.dom.Node;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * This XML manager handles Extensions nodes, which may in turn contain Extension nodes.
+ */
+public class VastExtensionParentXmlManager {
+
+    private static final String EXTENSION = "Extension";
+    @NonNull private final Node mVastExtensionParentNode;
+
+    VastExtensionParentXmlManager(@NonNull Node vastExtensionParentNode) {
+        Preconditions.checkNotNull(vastExtensionParentNode);
+
+        mVastExtensionParentNode = vastExtensionParentNode;
+    }
+
+    /**
+     * If there are Extension sections, return their XML managers.
+     *
+     * @return The {@link VastExtensionXmlManager}s or an empty list if there are no Extension
+     * nodes.
+     */
+    @NonNull
+    List<VastExtensionXmlManager> getVastExtensionXmlManagers() {
+        final List<VastExtensionXmlManager> vastExtensionXmlManagers = new
+                ArrayList<VastExtensionXmlManager>();
+
+        final List<Node> vastExtensionNodes =
+                XmlUtils.getMatchingChildNodes(mVastExtensionParentNode, EXTENSION);
+        if (vastExtensionNodes == null) {
+            return vastExtensionXmlManagers;
+        }
+
+        for (Node vastExtensionNode : vastExtensionNodes) {
+            vastExtensionXmlManagers.add(new VastExtensionXmlManager(vastExtensionNode));
+        }
+
+        return vastExtensionXmlManagers;
+    }
+
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastExtensionXmlManager.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastExtensionXmlManager.java
new file mode 100644
index 00000000..0e0a1c8a
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastExtensionXmlManager.java
@@ -0,0 +1,69 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import com.mopub.common.Preconditions;
+import com.mopub.mobileads.util.XmlUtils;
+
+import org.w3c.dom.Node;
+
+/**
+ * This XML manager handles Extension nodes.
+ */
+public class VastExtensionXmlManager {
+    // Elements
+    public static final String VIDEO_VIEWABILITY_TRACKER = "MoPubViewabilityTracker";
+
+    // Attributes
+    public static final String TYPE = "type";
+
+    private final Node mExtensionNode;
+
+    public VastExtensionXmlManager(@NonNull Node extensionNode) {
+        Preconditions.checkNotNull(extensionNode);
+
+        this.mExtensionNode = extensionNode;
+    }
+
+    /**
+     * If there is an Extension node with a MoPubViewabilityTracker element, return its data object.
+     *
+     * @return The {@link VideoViewabilityTracker} parsed from the given node or null if missing or
+     * invalid.
+     */
+    @Nullable
+    VideoViewabilityTracker getVideoViewabilityTracker() {
+        Node videoViewabilityTrackerNode =
+                XmlUtils.getFirstMatchingChildNode(mExtensionNode, VIDEO_VIEWABILITY_TRACKER);
+        if (videoViewabilityTrackerNode == null) {
+            return null;
+        }
+
+        VideoViewabilityTrackerXmlManager videoViewabilityTrackerXmlManager =
+                new VideoViewabilityTrackerXmlManager(videoViewabilityTrackerNode);
+        Integer viewablePlaytime = videoViewabilityTrackerXmlManager.getViewablePlaytimeMS();
+        Integer percentViewable = videoViewabilityTrackerXmlManager.getPercentViewable();
+        String videoViewabilityTrackerUrl =
+                videoViewabilityTrackerXmlManager.getVideoViewabilityTrackerUrl();
+
+        if (viewablePlaytime == null || percentViewable == null
+                || TextUtils.isEmpty(videoViewabilityTrackerUrl)) {
+            return null;
+        }
+
+        return new VideoViewabilityTracker(viewablePlaytime, percentViewable,
+                videoViewabilityTrackerUrl);
+    }
+
+    /**
+     * If the node has a "type" attribute, return its value.
+     *
+     * @return A String with the value of the "type" attribute or null if missing.
+     */
+    @Nullable
+    String getType() {
+        return XmlUtils.getAttributeValue(mExtensionNode, TYPE);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastManager.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastManager.java
index 11e41f7b..3478c8f5 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/VastManager.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastManager.java
@@ -39,8 +39,11 @@
     private double mScreenAspectRatio;
     private int mScreenAreaDp;
 
-    public VastManager(@NonNull final Context context) {
+    private final boolean mShouldPreCacheVideo;
+
+    public VastManager(@NonNull final Context context, boolean shouldPreCacheVideo) {
         initializeScreenDimensions(context);
+        mShouldPreCacheVideo = shouldPreCacheVideo;
     }
 
     /**
@@ -55,6 +58,7 @@ public void prepareVastVideoConfiguration(@Nullable final String vastXml,
             @NonNull final Context context) {
         Preconditions.checkNotNull(vastManagerListener, "vastManagerListener cannot be null");
         Preconditions.checkNotNull(context, "context cannot be null");
+
         if (mVastXmlManagerAggregator == null) {
             mVastManagerListener = vastManagerListener;
             mVastXmlManagerAggregator = new VastXmlManagerAggregator(this, mScreenAspectRatio,
@@ -92,7 +96,8 @@ public void onAggregationComplete(@Nullable final VastVideoConfig vastVideoConfi
             return;
         }
 
-        if (updateDiskMediaFileUrl(vastVideoConfig)) {
+        // Return immediately if we already have a cached video or if video precache is not required.
+        if (!mShouldPreCacheVideo || updateDiskMediaFileUrl(vastVideoConfig)) {
             mVastManagerListener.onVastVideoConfigurationPrepared(vastVideoConfig);
             return;
         }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoConfig.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoConfig.java
index 913f4bf3..299bc3bb 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoConfig.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoConfig.java
@@ -18,11 +18,14 @@
 import com.mopub.common.util.DeviceUtils;
 import com.mopub.common.util.Intents;
 import com.mopub.common.util.Strings;
+import com.mopub.exceptions.IntentNotResolvableException;
 
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 
 import static com.mopub.network.TrackingRequest.makeVastTrackingHttpRequest;
 
@@ -45,6 +48,7 @@
     @Nullable private String mSkipOffset;
     @Nullable private VastCompanionAdConfig mLandscapeVastCompanionAdConfig;
     @Nullable private VastCompanionAdConfig mPortraitVastCompanionAdConfig;
+    @NonNull private Map<String, VastCompanionAdConfig> mSocialActionsCompanionAds;
     @Nullable private VastIconConfig mVastIconConfig;
 
     // Custom extensions
@@ -52,6 +56,7 @@
     @Nullable private String mCustomSkipText;
     @Nullable private String mCustomCloseIconUrl;
     @NonNull private DeviceUtils.ForceOrientation mCustomForceOrientation = DeviceUtils.ForceOrientation.FORCE_LANDSCAPE; // Default is forcing landscape
+    @Nullable private VideoViewabilityTracker mVideoViewabilityTracker;
 
     /**
      * Flag to indicate if the VAST xml document has explicitly set the orientation as opposed to
@@ -70,6 +75,7 @@ public VastVideoConfig() {
         mSkipTrackers = new ArrayList<VastTracker>();
         mClickTrackers = new ArrayList<VastTracker>();
         mErrorTrackers = new ArrayList<VastTracker>();
+        mSocialActionsCompanionAds = new HashMap<String, VastCompanionAdConfig>();
     }
 
     /**
@@ -168,6 +174,11 @@ public void setVastCompanionAd(@Nullable final VastCompanionAdConfig landscapeVa
         mPortraitVastCompanionAdConfig = portraitVastCompanionAdConfig;
     }
 
+    public void setSocialActionsCompanionAds(
+            @NonNull final Map<String, VastCompanionAdConfig> socialActionsCompanionAds) {
+        this.mSocialActionsCompanionAds = socialActionsCompanionAds;
+    }
+
     public void setVastIconConfig(@Nullable final VastIconConfig vastIconConfig) {
         mVastIconConfig = vastIconConfig;
     }
@@ -203,6 +214,12 @@ public void setSkipOffset(@Nullable final String skipOffset) {
         }
     }
 
+    public void setVideoViewabilityTracker(@Nullable final VideoViewabilityTracker videoViewabilityTracker) {
+        if (videoViewabilityTracker != null) {
+            mVideoViewabilityTracker = videoViewabilityTracker;
+        }
+    }
+
     /**
      * Getters
      */
@@ -289,6 +306,11 @@ public VastCompanionAdConfig getVastCompanionAd(final int orientation) {
         }
     }
 
+    @NonNull
+    public Map<String, VastCompanionAdConfig> getSocialActionsCompanionAds() {
+        return mSocialActionsCompanionAds;
+    }
+
     @Nullable
     public VastIconConfig getVastIconConfig() {
         return mVastIconConfig;
@@ -309,6 +331,11 @@ public String getCustomCloseIconUrl() {
         return mCustomCloseIconUrl;
     }
 
+    @Nullable
+    public VideoViewabilityTracker getVideoViewabilityTracker() {
+        return mVideoViewabilityTracker;
+    }
+
     public boolean isCustomForceOrientationSet() {
         return mIsForceOrientationSet;
     }
@@ -362,23 +389,50 @@ public void handleImpression(@NonNull final Context context, int contentPlayHead
 
     /**
      * Called when the video is clicked. Handles forwarding the user to the specified click through
-     * url.
+     * url, calling {@link Activity#onActivityResult(int, int, Intent)} when done.
      *
-     * @param activity        This has to be an activity to call startActivityForResult.
+     * @param activity        Used to call startActivityForResult with provided requestCode.
      * @param contentPlayHead Current video playback time when clicked.
-     * @param requestCode     The code that identifies what kind of activity request is going to be
-     *                        made
+     * @param requestCode     Code that identifies what kind of activity request is going to be
+     *                        made.
      */
-    public void handleClick(@NonNull final Activity activity, final int contentPlayHead,
+    public void handleClickForResult(@NonNull final Activity activity, final int contentPlayHead,
             final int requestCode) {
-        Preconditions.checkNotNull(activity, "activity cannot be null");
+        handleClick(activity, contentPlayHead, requestCode);
+    }
+
+    /**
+     * Called when the video is clicked. Handles forwarding the user to the specified click through
+     * url. Does not provide any feedback when opened activity is finished.
+     *
+     * @param context         Used to call startActivity.
+     * @param contentPlayHead Current video playback time when clicked.
+     */
+    public void handleClickWithoutResult(@NonNull final Context context,
+            final int contentPlayHead) {
+        handleClick(context.getApplicationContext(), contentPlayHead, null);
+    }
+
+    /**
+     * Called when the video is clicked. Handles forwarding the user to the specified click through
+     * url.
+     *
+     * @param context         If an Activity context, used to call startActivityForResult with
+     *                        provided requestCode; otherwise, used to call startActivity.
+     * @param contentPlayHead Current video playback time when clicked.
+     * @param requestCode     Required when the context is an Activity; code that identifies what
+     *                        kind of activity request is going to be made.
+     */
+    private void handleClick(@NonNull final Context context, final int contentPlayHead,
+            @Nullable final Integer requestCode) {
+        Preconditions.checkNotNull(context, "context cannot be null");
 
         makeVastTrackingHttpRequest(
                 mClickTrackers,
                 null,
                 contentPlayHead,
                 mNetworkMediaFileUrl,
-                activity
+                context
         );
 
         if (TextUtils.isEmpty(mClickThroughUrl)) {
@@ -404,12 +458,23 @@ public void urlHandlingSucceeded(@NonNull String url,
 
                             final Class clazz = MoPubBrowser.class;
                             final Intent intent = Intents.getStartActivityIntent(
-                                    activity, clazz, bundle);
+                                    context, clazz, bundle);
                             try {
-                                activity.startActivityForResult(intent, requestCode);
+                                if (context instanceof Activity) {
+                                    // Activity context requires a requestCode
+                                    Preconditions.checkNotNull(requestCode);
+
+                                    ((Activity) context)
+                                            .startActivityForResult(intent, requestCode);
+                                } else {
+                                    Intents.startActivity(context, intent);
+                                }
                             } catch (ActivityNotFoundException e) {
                                 MoPubLog.d("Activity " + clazz.getName() + " not found. Did you " +
                                         "declare it in your AndroidManifest.xml?");
+                            } catch (IntentNotResolvableException e) {
+                                MoPubLog.d("Activity " + clazz.getName() + " not found. Did you " +
+                                        "declare it in your AndroidManifest.xml?");
                             }
                         }
                     }
@@ -420,7 +485,7 @@ public void urlHandlingFailed(@NonNull String url,
                     }
                 })
                 .withoutMoPubBrowser()
-                .build().handleUrl(activity, mClickThroughUrl);
+                .build().handleUrl(context, mClickThroughUrl);
     }
 
     /**
@@ -506,7 +571,7 @@ public void handleComplete(@NonNull Context context, int contentPlayHead) {
      * @param context         The context. Can be application or activity context.
      * @param contentPlayHead Current video playback time.
      */
-    public void handleError(@NonNull Context context, @NonNull VastErrorCode errorCode,
+    public void handleError(@NonNull Context context, @Nullable VastErrorCode errorCode,
             int contentPlayHead) {
         Preconditions.checkNotNull(context, "context cannot be null");
         makeVastTrackingHttpRequest(
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoCtaButtonWidget.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoCtaButtonWidget.java
index 0ca1a1ff..7d3dc4c9 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoCtaButtonWidget.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoCtaButtonWidget.java
@@ -23,6 +23,7 @@
     private boolean mIsVideoComplete;
     private boolean mHasCompanionAd;
     private boolean mHasClickthroughUrl;
+    private boolean mHasSocialActions;
 
     public VastVideoCtaButtonWidget(@NonNull final Context context, final int videoViewId,
             final boolean hasCompanionAd, final boolean hasClickthroughUrl) {
@@ -30,6 +31,7 @@ public VastVideoCtaButtonWidget(@NonNull final Context context, final int videoV
 
         mHasCompanionAd = hasCompanionAd;
         mHasClickthroughUrl = hasClickthroughUrl;
+        mHasSocialActions = false;
 
         setId((int) Utils.generateUniqueId());
 
@@ -46,11 +48,11 @@ public VastVideoCtaButtonWidget(@NonNull final Context context, final int videoV
         mLandscapeLayoutParams.addRule(RelativeLayout.ALIGN_BOTTOM, videoViewId);
         mLandscapeLayoutParams.addRule(RelativeLayout.ALIGN_RIGHT, videoViewId);
 
-        // portrait layout: placed center below video view
+        // portrait layout: placed bottom-right corner of screen
         mPortraitLayoutParams = new RelativeLayout.LayoutParams(width, height);
         mPortraitLayoutParams.setMargins(margin, margin, margin, margin);
-        mPortraitLayoutParams.addRule(RelativeLayout.BELOW, videoViewId);
-        mPortraitLayoutParams.addRule(RelativeLayout.CENTER_HORIZONTAL);
+        mPortraitLayoutParams.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM);
+        mPortraitLayoutParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
 
         updateLayoutAndVisibility();
     }
@@ -66,6 +68,14 @@ void updateCtaText(@NonNull final String customCtaText) {
         mCtaButtonDrawable.setCtaText(customCtaText);
     }
 
+    void setHasSocialActions(final boolean hasSocialActions) {
+        mHasSocialActions = hasSocialActions;
+    }
+
+    boolean getHasSocialActions() {
+        return mHasSocialActions;
+    }
+
     void notifyVideoSkippable() {
         mIsVideoSkippable = true;
         updateLayoutAndVisibility();
@@ -91,7 +101,8 @@ private void updateLayoutAndVisibility() {
         }
 
         // If video has finished playing and there's a companion ad, do not show CTA button
-        if (mIsVideoComplete && mHasCompanionAd) {
+        // Unless the ad has social actions
+        if (mIsVideoComplete && mHasCompanionAd && !mHasSocialActions) {
             setVisibility(View.GONE);
             return;
         }
@@ -100,29 +111,25 @@ private void updateLayoutAndVisibility() {
 
         switch (currentOrientation) {
             case Configuration.ORIENTATION_LANDSCAPE:
-                setVisibility(View.VISIBLE);
                 setLayoutParams(mLandscapeLayoutParams);
                 break;
             case Configuration.ORIENTATION_PORTRAIT:
-                setVisibility(View.VISIBLE);
                 setLayoutParams(mPortraitLayoutParams);
                 break;
             case Configuration.ORIENTATION_UNDEFINED:
                 MoPubLog.d("Screen orientation undefined: CTA button widget defaulting to portrait layout");
-                setVisibility(View.VISIBLE);
                 setLayoutParams(mPortraitLayoutParams);
                 break;
             case Configuration.ORIENTATION_SQUARE:
                 MoPubLog.d("Screen orientation is deprecated ORIENTATION_SQUARE: CTA button widget defaulting to portrait layout");
-                setVisibility(View.VISIBLE);
                 setLayoutParams(mPortraitLayoutParams);
                 break;
             default:
                 MoPubLog.d("Unrecognized screen orientation: CTA button widget defaulting to portrait layout");
-                setVisibility(View.VISIBLE);
                 setLayoutParams(mPortraitLayoutParams);
                 break;
         }
+        setVisibility(View.VISIBLE);
     }
 
     // for testing
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoProgressBarWidget.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoProgressBarWidget.java
index 7f7eb5d3..9af9ded0 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoProgressBarWidget.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoProgressBarWidget.java
@@ -14,8 +14,9 @@
 
 public class VastVideoProgressBarWidget extends ImageView {
     @NonNull private ProgressBarDrawable mProgressBarDrawable;
+    private final int mProgressBarHeight;
 
-    public VastVideoProgressBarWidget(@NonNull final Context context, final int anchorId) {
+    public VastVideoProgressBarWidget(@NonNull final Context context) {
         super(context);
 
         setId((int) Utils.generateUniqueId());
@@ -23,27 +24,33 @@ public VastVideoProgressBarWidget(@NonNull final Context context, final int anch
         mProgressBarDrawable = new ProgressBarDrawable(context);
         setImageDrawable(mProgressBarDrawable);
 
-        final int progressBarHeight
-                = Dips.dipsToIntPixels(DrawableConstants.ProgressBar.HEIGHT_DIPS, context);
+        mProgressBarHeight =
+                Dips.dipsToIntPixels(DrawableConstants.ProgressBar.HEIGHT_DIPS, context);
+    }
 
+    public void setAnchorId(final int anchorId) {
         final RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(
                 RelativeLayout.LayoutParams.MATCH_PARENT,
-                progressBarHeight);
-
+                mProgressBarHeight);
         layoutParams.addRule(RelativeLayout.ALIGN_BOTTOM, anchorId);
-
         setLayoutParams(layoutParams);
+
     }
 
-    void calibrateAndMakeVisible(final int duration, final int skipOffset) {
+    public void calibrateAndMakeVisible(final int duration, final int skipOffset) {
         mProgressBarDrawable.setDurationAndSkipOffset(duration, skipOffset);
         setVisibility(View.VISIBLE);
     }
 
-    void updateProgress(final int progress) {
+    public void updateProgress(final int progress) {
         mProgressBarDrawable.setProgress(progress);
     }
 
+    public void reset() {
+        mProgressBarDrawable.reset();
+        mProgressBarDrawable.setProgress(0);
+    }
+
     // for testing
     @Deprecated
     @VisibleForTesting
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewController.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewController.java
index 77f9cece..1867cc50 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewController.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewController.java
@@ -16,6 +16,7 @@
 import android.view.Gravity;
 import android.view.MotionEvent;
 import android.view.View;
+import android.view.ViewTreeObserver;
 import android.webkit.WebView;
 import android.webkit.WebViewClient;
 import android.widget.ImageView;
@@ -26,14 +27,19 @@
 import com.mopub.common.VisibleForTesting;
 import com.mopub.common.util.Dips;
 import com.mopub.common.util.Utils;
+import com.mopub.mobileads.resource.DrawableConstants;
 
 import java.io.Serializable;
+import java.util.Map;
 
 import static android.content.pm.ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
 import static android.content.pm.ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
+import static com.mopub.common.MoPubBrowser.MOPUB_BROWSER_REQUEST_CODE;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_CLICK;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
+import static com.mopub.mobileads.VastXmlManagerAggregator.ADS_BY_AD_SLOT_ID;
+import static com.mopub.mobileads.VastXmlManagerAggregator.SOCIAL_ACTIONS_AD_SLOT_ID;
 import static com.mopub.network.TrackingRequest.makeVastTrackingHttpRequest;
 
 public class VastVideoViewController extends BaseVideoViewController {
@@ -43,7 +49,6 @@
 
     private static final long VIDEO_PROGRESS_TIMER_CHECKER_DELAY = 50;
     private static final long VIDEO_COUNTDOWN_UPDATE_INTERVAL = 250;
-    private static final int MOPUB_BROWSER_REQUEST_CODE = 1;
     private static final int SEEKER_POSITION_NOT_INITIALIZED = -1;
 
     /**
@@ -70,9 +75,12 @@
     @NonNull private VastVideoCloseButtonWidget mCloseButtonWidget;
 
     @Nullable private VastCompanionAdConfig mVastCompanionAdConfig;
+    @Nullable private final VastIconConfig mVastIconConfig;
     @NonNull private final View mLandscapeCompanionAdView;
     @NonNull private final View mPortraitCompanionAdView;
-    @Nullable private final VastIconConfig mVastIconConfig;
+    @NonNull private final Map<String, VastCompanionAdConfig> mSocialActionsCompanionAds;
+    @NonNull private View mAdsByView;
+    @NonNull private final View mSocialActionsView;
     @NonNull private final View mIconView;
 
     @NonNull private final VastVideoViewProgressRunnable mProgressCheckerRunnable;
@@ -86,6 +94,7 @@
     private boolean mVideoError;
     private boolean mHasSkipOffset = false;
     private boolean mIsCalibrationDone = false;
+    private boolean mHasSocialActions = false;
     private int mDuration;
 
     /**
@@ -125,6 +134,7 @@
 
         mVastCompanionAdConfig = mVastVideoConfig.getVastCompanionAd(
                 activity.getResources().getConfiguration().orientation);
+        mSocialActionsCompanionAds = mVastVideoConfig.getSocialActionsCompanionAds();
         mVastIconConfig = mVastVideoConfig.getVastIconConfig();
 
         mClickThroughListener = new View.OnTouchListener() {
@@ -133,7 +143,7 @@ public boolean onTouch(View view, MotionEvent motionEvent) {
                 if (motionEvent.getAction() == MotionEvent.ACTION_UP && shouldAllowClickThrough()) {
                     mIsClosing = true;
                     broadcastAction(ACTION_INTERSTITIAL_CLICK);
-                    mVastVideoConfig.handleClick(activity,
+                    mVastVideoConfig.handleClickForResult(activity,
                             mIsVideoFinishedPlaying ? mDuration : getCurrentPosition(),
                             MOPUB_BROWSER_REQUEST_CODE);
                 }
@@ -147,6 +157,9 @@ public boolean onTouch(View view, MotionEvent motionEvent) {
         // Solid black background
         getLayout().setBackgroundColor(Color.BLACK);
 
+        // Blurred last frame
+        addBlurredLastVideoFrameImageView(activity, View.INVISIBLE);
+
         // Video view
         mVideoView = createVideoView(activity, View.VISIBLE);
         mVideoView.requestFocus();
@@ -173,13 +186,28 @@ public boolean onTouch(View view, MotionEvent motionEvent) {
 
         // Icon view
         mIconView = createIconView(activity, mVastIconConfig, View.INVISIBLE);
-
-        // Blurred last frame
-        addBlurredLastVideoFrameImageView(activity, View.INVISIBLE);
+        mIconView.getViewTreeObserver().addOnGlobalLayoutListener(
+                new ViewTreeObserver.OnGlobalLayoutListener() {
+                    @Override
+                    public void onGlobalLayout() {
+                        // Wait until mIconView has been laid out to get accurate height
+                        mAdsByView = createAdsByView(activity);
+                        mIconView.getViewTreeObserver().removeGlobalOnLayoutListener(this);
+                    }
+                }
+        );
 
         // CTA button
         addCtaButtonWidget(activity);
 
+        // Social Actions
+        final int ctaHeight = Dips.dipsToIntPixels(DrawableConstants.CtaButton.HEIGHT_DIPS,
+                activity);
+        mSocialActionsView = createSocialActionsView(activity,
+                mSocialActionsCompanionAds.get(SOCIAL_ACTIONS_AD_SLOT_ID),
+                ctaHeight, RelativeLayout.ALIGN_TOP, mCtaButtonWidget, View.INVISIBLE,
+                DrawableConstants.SocialActions.SOCIAL_ACTIONS_LEFT_MARGIN_DIPS);
+
         // Close button snapped to top-right corner of screen
         // Always add last to layout since it must be visible above all other views
         addCloseButtonWidget(activity, View.GONE);
@@ -190,6 +218,28 @@ public boolean onTouch(View view, MotionEvent motionEvent) {
         mCountdownRunnable = new VastVideoViewCountdownRunnable(this, mainHandler);
     }
 
+    @VisibleForTesting
+    View createAdsByView(Activity activity) {
+        return createSocialActionsView(activity,
+                mSocialActionsCompanionAds.get(ADS_BY_AD_SLOT_ID),
+                mIconView.getHeight(),
+                RelativeLayout.RIGHT_OF, mIconView, View.VISIBLE,
+                DrawableConstants.SocialActions.ADS_BY_LEFT_MARGIN_DIPS
+        );
+    }
+
+    @Deprecated // Just use for testing
+    @VisibleForTesting
+    boolean getHasSocialActions() {
+        return mHasSocialActions;
+    }
+
+    @Deprecated // Just use for testing
+    @VisibleForTesting
+    View getSocialActionsView() {
+        return mSocialActionsView;
+    }
+
     @Override
     protected VideoView getVideoView() {
         return mVideoView;
@@ -258,7 +308,7 @@ protected void onSaveInstanceState(@NonNull Bundle outState) {
     }
 
     @Override
-    protected void onConfigurationChanged(@Nullable final Configuration newConfig) {
+    protected void onConfigurationChanged(final Configuration newConfig) {
         final int orientation = getContext().getResources().getConfiguration().orientation;
         mVastCompanionAdConfig = mVastVideoConfig.getVastCompanionAd(orientation);
         if (mLandscapeCompanionAdView.getVisibility() == View.VISIBLE ||
@@ -276,6 +326,9 @@ protected void onConfigurationChanged(@Nullable final Configuration newConfig) {
         }
     }
 
+    @Override
+    protected void onBackPressed() { }
+
     // Enable the device's back button when the video close button has been displayed
     @Override
     public boolean backButtonEnabled() {
@@ -321,7 +374,7 @@ public void onPrepared(MediaPlayer mp) {
                 // Therefore set it here so that we have access to it at all times
                 mDuration = mVideoView.getDuration();
                 adjustSkipOffset();
-                if (mVastCompanionAdConfig == null) {
+                if (mVastCompanionAdConfig == null || mHasSocialActions) {
                     videoView.prepareBlurredLastVideoFrame(mBlurredLastVideoFrameImageView,
                             mVastVideoConfig.getDiskMediaFileUrl());
                 }
@@ -350,7 +403,18 @@ public void onCompletion(MediaPlayer mp) {
                 videoView.setVisibility(View.INVISIBLE);
 
                 mProgressBarWidget.setVisibility(View.GONE);
-                mIconView.setVisibility(View.GONE);
+
+                if (mHasSocialActions) {
+                    // Social Actions need the blurred last frame to fill the screen regardless
+                    // of the companion ad.
+                    if (mBlurredLastVideoFrameImageView.getDrawable() != null) {
+                        mBlurredLastVideoFrameImageView.setScaleType(ImageView.ScaleType.CENTER_CROP);
+                        mBlurredLastVideoFrameImageView.setVisibility(View.VISIBLE);
+                    }
+                    // Also, avoid removing DAA icon for social actions
+                } else {
+                    mIconView.setVisibility(View.GONE);
+                }
 
                 mTopGradientStripWidget.notifyVideoComplete();
                 mBottomGradientStripWidget.notifyVideoComplete();
@@ -425,7 +489,8 @@ private void addBottomGradientStripWidget(@NonNull final Context context) {
     }
 
     private void addProgressBarWidget(@NonNull final Context context, int initialVisibility) {
-        mProgressBarWidget = new VastVideoProgressBarWidget(context, mVideoView.getId());
+        mProgressBarWidget = new VastVideoProgressBarWidget(context);
+        mProgressBarWidget.setAnchorId(mVideoView.getId());
         mProgressBarWidget.setVisibility(initialVisibility);
         getLayout().addView(mProgressBarWidget);
     }
@@ -534,35 +599,7 @@ View createCompanionAdView(@NonNull final Context context,
                         RelativeLayout.LayoutParams.MATCH_PARENT);
         getLayout().addView(relativeLayout, layoutParams);
 
-        VastWebView companionView = VastWebView.createView(context,
-                vastCompanionAdConfig.getVastResource());
-
-        // For javascript, HTML, and IFrames, ignore the traditional clickthrough url and open all
-        // new urls in the MoPub Browser. For static images, use the clickthrough url specified in
-        // the VAST document. These two handleClicks make it so that the correct behavior happens
-        // in these special cases. onVastWebViewClick is called in both circumstances to fire the
-        // click trackers.
-        companionView.setVastWebViewClickListener(new VastWebView.VastWebViewClickListener() {
-            @Override
-            public void onVastWebViewClick() {
-                broadcastAction(ACTION_INTERSTITIAL_CLICK);
-                makeVastTrackingHttpRequest(
-                        vastCompanionAdConfig.getClickTrackers(),
-                        null,
-                        mDuration,
-                        null,
-                        context
-                );
-                vastCompanionAdConfig.handleClick(context, MOPUB_BROWSER_REQUEST_CODE, null);
-            }
-        });
-        companionView.setWebViewClient(new WebViewClient() {
-            @Override
-            public boolean shouldOverrideUrlLoading(WebView view, String url) {
-                vastCompanionAdConfig.handleClick(context, MOPUB_BROWSER_REQUEST_CODE, url);
-                return true;
-            }
-        });
+        VastWebView companionView = createCompanionVastWebView(context, vastCompanionAdConfig);
 
         companionView.setVisibility(initialVisibility);
 
@@ -576,6 +613,62 @@ public boolean shouldOverrideUrlLoading(WebView view, String url) {
         return companionView;
     }
 
+    /**
+     * Creates and lays out the webviews used to display the social actions.
+     *
+     * @param context The context.
+     * @param vastCompanionAdConfig The data used to populate the view.
+     * @param anchorHeight The height in pixels of the view to use as anchor for the view.
+     * @param layoutVerb The way to layout the view relative to the anchorView.
+     * @param anchorView The view to use as anchor when laying out the view.
+     * @param initialVisibility The visibility the view should have.
+     * @return the populated webview
+     */
+    @NonNull
+    @VisibleForTesting
+    View createSocialActionsView(@NonNull final Context context,
+            @Nullable final VastCompanionAdConfig vastCompanionAdConfig, final int anchorHeight,
+            final int layoutVerb, @NonNull final View anchorView, final int initialVisibility,
+            final int leftMarginDips) {
+        Preconditions.checkNotNull(context);
+        Preconditions.checkNotNull(anchorView);
+
+        if (vastCompanionAdConfig == null) {
+            final View emptyView = new View(context);
+            emptyView.setVisibility(View.INVISIBLE);
+            return emptyView;
+        }
+
+        mHasSocialActions = true;
+        mCtaButtonWidget.setHasSocialActions(mHasSocialActions);
+
+        VastWebView companionView = createCompanionVastWebView(context, vastCompanionAdConfig);
+
+        final int width = Dips.dipsToIntPixels(vastCompanionAdConfig.getWidth(), context);
+        final int height = Dips.dipsToIntPixels(vastCompanionAdConfig.getHeight(), context);
+        final int offset = (anchorHeight - height) / 2;
+        final int leftMargin = Dips.dipsToIntPixels(leftMarginDips, context);
+
+        final RelativeLayout.LayoutParams companionAdLayout =
+                new RelativeLayout.LayoutParams(width, height);
+        companionAdLayout.addRule(layoutVerb, anchorView.getId());
+        companionAdLayout.addRule(RelativeLayout.ALIGN_TOP, anchorView.getId());
+        companionAdLayout.setMargins(leftMargin, offset, 0, 0);
+
+        RelativeLayout relativeLayout = new RelativeLayout(context);
+        relativeLayout.setGravity(Gravity.CENTER_VERTICAL);
+        RelativeLayout.LayoutParams layoutParams =
+                new RelativeLayout.LayoutParams(
+                        RelativeLayout.LayoutParams.WRAP_CONTENT,
+                        RelativeLayout.LayoutParams.WRAP_CONTENT);
+        relativeLayout.addView(companionView, layoutParams);
+
+        getLayout().addView(relativeLayout, companionAdLayout);
+
+        companionView.setVisibility(initialVisibility);
+        return companionView;
+    }
+
     /**
      * Creates and lays out the webview used to display the icon.
      *
@@ -615,13 +708,15 @@ public boolean shouldOverrideUrlLoading(WebView view, String url) {
         });
         iconView.setVisibility(initialVisibility);
 
-        // Add extra room for the WebView to account for the natural padding in Android WebViews.
         RelativeLayout.LayoutParams layoutParams =
                 new RelativeLayout.LayoutParams(
-                        Dips.asIntPixels(vastIconConfig.getWidth() + WEBVIEW_PADDING, context),
-                        Dips.asIntPixels(vastIconConfig.getHeight() + WEBVIEW_PADDING, context));
-        layoutParams.addRule(RelativeLayout.ALIGN_PARENT_LEFT);
-        layoutParams.addRule(RelativeLayout.ALIGN_PARENT_TOP);
+                        Dips.asIntPixels(vastIconConfig.getWidth(), context),
+                        Dips.asIntPixels(vastIconConfig.getHeight(), context));
+        final int leftMargin = Dips.dipsToIntPixels(
+                DrawableConstants.PrivacyInfoIcon.LEFT_MARGIN_DIPS, context);
+        final int topMargin = Dips.dipsToIntPixels(
+                DrawableConstants.PrivacyInfoIcon.TOP_MARGIN_DIPS, context);
+        layoutParams.setMargins(leftMargin, topMargin, 0, 0);
 
         getLayout().addView(iconView, layoutParams);
 
@@ -643,6 +738,7 @@ void makeVideoInteractable() {
         mCloseButtonWidget.setVisibility(View.VISIBLE);
 
         mCtaButtonWidget.notifyVideoSkippable();
+        mSocialActionsView.setVisibility(View.VISIBLE);
     }
 
     boolean shouldBeInteractable() {
@@ -704,6 +800,44 @@ private void stopRunnables() {
         mCountdownRunnable.stop();
     }
 
+    @NonNull
+    private VastWebView createCompanionVastWebView(@NonNull final Context context,
+            @NonNull final VastCompanionAdConfig vastCompanionAdConfig) {
+        Preconditions.checkNotNull(context);
+        Preconditions.checkNotNull(vastCompanionAdConfig);
+
+        VastWebView companionView = VastWebView.createView(context,
+                vastCompanionAdConfig.getVastResource());
+
+        // For javascript, HTML, and IFrames, ignore the traditional clickthrough url and open all
+        // new urls in the MoPub Browser. For static images, use the clickthrough url specified in
+        // the VAST document. These two handleClicks make it so that the correct behavior happens
+        // in these special cases. onVastWebViewClick is called in both circumstances to fire the
+        // click trackers.
+        companionView.setVastWebViewClickListener(new VastWebView.VastWebViewClickListener() {
+            @Override
+            public void onVastWebViewClick() {
+                broadcastAction(ACTION_INTERSTITIAL_CLICK);
+                makeVastTrackingHttpRequest(
+                        vastCompanionAdConfig.getClickTrackers(),
+                        null,
+                        mDuration,
+                        null,
+                        context
+                );
+                vastCompanionAdConfig.handleClick(context, MOPUB_BROWSER_REQUEST_CODE, null);
+            }
+        });
+        companionView.setWebViewClient(new WebViewClient() {
+            @Override
+            public boolean shouldOverrideUrlLoading(WebView view, String url) {
+                vastCompanionAdConfig.handleClick(context, MOPUB_BROWSER_REQUEST_CODE, url);
+                return true;
+            }
+        });
+        return companionView;
+    }
+
     // for testing
     @Deprecated
     @VisibleForTesting
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastXmlManagerAggregator.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastXmlManagerAggregator.java
index a539f01e..5f024d94 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/VastXmlManagerAggregator.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastXmlManagerAggregator.java
@@ -27,8 +27,10 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 
 import static com.mopub.network.TrackingRequest.makeVastTrackingHttpRequest;
 
@@ -40,6 +42,11 @@
  */
 public class VastXmlManagerAggregator extends AsyncTask<String, Void, VastVideoConfig> {
 
+    private static final String MOPUB = "MoPub";
+
+    public static final String ADS_BY_AD_SLOT_ID = "adsBy";
+    public static final String SOCIAL_ACTIONS_AD_SLOT_ID = "socialActions";
+
     /**
      * Listener for when the xml parsing is done.
      */
@@ -226,14 +233,17 @@ VastVideoConfig evaluateVastXmlManager(@NonNull final String vastXml,
                 for (VastLinearXmlManager linearXmlManager : linearXmlManagers) {
                     populateLinearTrackersAndIcon(linearXmlManager, vastVideoConfig);
                 }
+                populateVideoViewabilityTracker(vastWrapperXmlManager, vastVideoConfig);
 
+                final List<VastCompanionAdXmlManager> companionAdXmlManagers =
+                        vastWrapperXmlManager.getCompanionAdXmlManagers();
                 // Only populate a companion ad if we don't already have one from one of the
                 // redirects
                 if (!vastVideoConfig.hasCompanionAd()) {
                     vastVideoConfig.setVastCompanionAd(
-                            getBestCompanionAd(vastWrapperXmlManager.getCompanionAdXmlManagers(),
+                            getBestCompanionAd(companionAdXmlManagers,
                                     CompanionOrientation.LANDSCAPE),
-                            getBestCompanionAd(vastWrapperXmlManager.getCompanionAdXmlManagers(),
+                            getBestCompanionAd(companionAdXmlManagers,
                                     CompanionOrientation.PORTRAIT));
                 } else {
                     // Otherwise append the companion trackers if it doesn't have resources
@@ -242,7 +252,7 @@ VastVideoConfig evaluateVastXmlManager(@NonNull final String vastXml,
                     final VastCompanionAdConfig portraitCompanionAd = vastVideoConfig.getVastCompanionAd(
                             Configuration.ORIENTATION_PORTRAIT);
                     if (landscapeCompanionAd != null && portraitCompanionAd != null) {
-                        for (final VastCompanionAdXmlManager companionAdXmlManager : vastWrapperXmlManager.getCompanionAdXmlManagers()) {
+                        for (final VastCompanionAdXmlManager companionAdXmlManager : companionAdXmlManagers) {
                             if (!companionAdXmlManager.hasResources()) {
                                 landscapeCompanionAd.addClickTrackers(
                                         companionAdXmlManager.getClickTrackers());
@@ -257,6 +267,11 @@ VastVideoConfig evaluateVastXmlManager(@NonNull final String vastXml,
                     }
                 }
 
+                if (vastVideoConfig.getSocialActionsCompanionAds().isEmpty()) {
+                    vastVideoConfig.setSocialActionsCompanionAds(
+                            getSocialActionsCompanionAds(companionAdXmlManagers));
+                }
+
                 populateMoPubCustomElements(xmlManager, vastVideoConfig);
 
                 return vastVideoConfig;
@@ -301,13 +316,19 @@ private VastVideoConfig evaluateInLineXmlManager(
                 vastVideoConfig.setClickThroughUrl(linearXmlManager.getClickThroughUrl());
                 vastVideoConfig.setNetworkMediaFileUrl(bestMediaFileUrl);
 
+                final List<VastCompanionAdXmlManager> companionAdXmlManagers =
+                        vastInLineXmlManager.getCompanionAdXmlManagers();
                 vastVideoConfig.setVastCompanionAd(
-                        getBestCompanionAd(vastInLineXmlManager.getCompanionAdXmlManagers(),
+                        getBestCompanionAd(companionAdXmlManagers,
                                 CompanionOrientation.LANDSCAPE),
-                        getBestCompanionAd(vastInLineXmlManager.getCompanionAdXmlManagers(),
+                        getBestCompanionAd(companionAdXmlManagers,
                                 CompanionOrientation.PORTRAIT));
+                vastVideoConfig.setSocialActionsCompanionAds(
+                        getSocialActionsCompanionAds(companionAdXmlManagers));
                 errorTrackers.addAll(vastInLineXmlManager.getErrorTrackers());
                 vastVideoConfig.addErrorTrackers(errorTrackers);
+                populateVideoViewabilityTracker(vastInLineXmlManager, vastVideoConfig);
+
                 return vastVideoConfig;
             }
         }
@@ -315,6 +336,31 @@ private VastVideoConfig evaluateInLineXmlManager(
         return null;
     }
 
+    private void populateVideoViewabilityTracker(
+            @NonNull final VastBaseInLineWrapperXmlManager vastInLineXmlManager,
+            @NonNull VastVideoConfig vastVideoConfig) {
+        Preconditions.checkNotNull(vastInLineXmlManager);
+        Preconditions.checkNotNull(vastVideoConfig);
+
+        if (vastVideoConfig.getVideoViewabilityTracker() != null) {
+            return;
+        }
+
+        final VastExtensionParentXmlManager vastExtensionParentXmlManager =
+                vastInLineXmlManager.getVastExtensionParentXmlManager();
+        if (vastExtensionParentXmlManager != null) {
+            final List<VastExtensionXmlManager> vastExtensionXmlManagers =
+                    vastExtensionParentXmlManager.getVastExtensionXmlManagers();
+            for (VastExtensionXmlManager vastExtensionXmlManager : vastExtensionXmlManagers) {
+                if (MOPUB.equals(vastExtensionXmlManager.getType())) {
+                    vastVideoConfig.setVideoViewabilityTracker(vastExtensionXmlManager
+                            .getVideoViewabilityTracker());
+                    break;
+                }
+            }
+        }
+    }
+
     /**
      * Retrieves the Wrapper's redirect uri and follows it to return the next VAST xml String.
      *
@@ -502,7 +548,7 @@ VastCompanionAdConfig getBestCompanionAd(
                     continue;
                 }
 
-                Point vastScaledDimensions = getScaledDimensions(width, height);
+                Point vastScaledDimensions = getScaledDimensions(width, height, type, orientation);
                 VastResource vastResource = VastResource.fromVastResourceXmlManager(
                         companionXmlManager.getResourceXmlManager(), type,
                         vastScaledDimensions.x, vastScaledDimensions.y);
@@ -541,47 +587,119 @@ VastCompanionAdConfig getBestCompanionAd(
         return null;
     }
 
+    @VisibleForTesting
+    @NonNull
+    Map<String, VastCompanionAdConfig> getSocialActionsCompanionAds(
+            @NonNull final List<VastCompanionAdXmlManager> managers) {
+        Preconditions.checkNotNull(managers, "managers cannot be null");
+
+        final Map<String, VastCompanionAdConfig> socialActionsCompanionAds =
+                new HashMap<String, VastCompanionAdConfig>();
+
+        for (VastCompanionAdXmlManager companionXmlManager : managers) {
+            final Integer width = companionXmlManager.getWidth();
+            final Integer height = companionXmlManager.getHeight();
+            if (width == null || height == null) {
+                continue;
+            }
+
+            final String adSlotId = companionXmlManager.getAdSlotId();
+            if (ADS_BY_AD_SLOT_ID.equals(adSlotId)) {
+                // adsBy companion ads must be 25-75dips wide and 10-50dips tall
+                if (width < 25 || width > 75 || height < 10 || height > 50) {
+                    continue;
+                }
+            } else if (SOCIAL_ACTIONS_AD_SLOT_ID.equals(adSlotId)) {
+                // socialActions companion ads must be 50-150dips wide and 10-50dips tall
+                if (width < 50 || width > 150 || height < 10 || height > 50) {
+                    continue;
+                }
+            } else {
+                // Social Actions companion ads must have adsBy or socialActions as adSlotId
+                continue;
+            }
+
+            VastResource vastResource = VastResource.fromVastResourceXmlManager(
+                    companionXmlManager.getResourceXmlManager(), VastResource.Type.HTML_RESOURCE,
+                    width, height);
+            if (vastResource == null) {
+                continue;
+            }
+
+            socialActionsCompanionAds.put(adSlotId,
+                    new VastCompanionAdConfig(
+                        width,
+                        height,
+                        vastResource,
+                        companionXmlManager.getClickThroughUrl(),
+                        companionXmlManager.getClickTrackers(),
+                        companionXmlManager.getCompanionCreativeViewTrackers()));
+        }
+
+        return socialActionsCompanionAds;
+    }
+
     /**
      * Given a width and height for a resource, if the dimensions are larger than the screen size
-     * then scale them down to fit in the screen while maintaining the aspect ratio. Scaling
-     * takes into account the default Android WebView padding.
+     * then scale them down to fit in the screen. This maintains the aspect ratio if the resource is
+     * not an HTMLResource. Since HTML can freely fill any space, the maximum size of an
+     * HTMLResource is the screen size. Scaling takes into account the default Android WebView
+     * padding.
      *
-     * @param widthDp width of the resource in dips
-     * @param heightDp height of the resource in dips
+     * @param widthDp     width of the resource in dips
+     * @param heightDp    height of the resource in dips
+     * @param type        The type of the resource. HTMLResource uses special scaling.
+     * @param orientation Expected orientation of the resource
      * @return the new scaled dimensions that honor the aspect ratio
      */
     @VisibleForTesting
     @NonNull
-    Point getScaledDimensions(int widthDp, int heightDp) {
-        Point defaultPoint = new Point(widthDp, heightDp);
-        final Display display = ((WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+    Point getScaledDimensions(int widthDp, int heightDp, final VastResource.Type type,
+            final CompanionOrientation orientation) {
+        final Point defaultPoint = new Point(widthDp, heightDp);
+        final Display display = ((WindowManager) mContext.getSystemService(
+                Context.WINDOW_SERVICE)).getDefaultDisplay();
         int x = display.getWidth();
         int y = display.getHeight();
 
-        // For landscape, width is always greater than height
-        int screenWidth = Math.max(x, y);
-        int screenHeight = Math.min(x, y);
-
         int widthPx = Dips.dipsToIntPixels(widthDp, mContext);
         int heightPx = Dips.dipsToIntPixels(heightDp, mContext);
 
+        final int screenWidthPx, screenHeightPx;
+        if (CompanionOrientation.LANDSCAPE == orientation) {
+            screenWidthPx = Math.max(x, y);
+            screenHeightPx = Math.min(x, y);
+        } else {
+            screenWidthPx = Math.min(x, y);
+            screenHeightPx = Math.max(x, y);
+        }
+
         // Return if the width and height already fit in the screen
-        if (widthPx <= screenWidth && heightPx <= screenHeight) {
+        if (widthPx <= (screenWidthPx - VastVideoViewController.WEBVIEW_PADDING) &&
+                heightPx <= (screenHeightPx - VastVideoViewController.WEBVIEW_PADDING)) {
             return defaultPoint;
         }
 
-        float widthRatio = (float) widthPx / screenWidth;
-        float heightRatio = (float) heightPx / screenHeight;
-
-        Point point = new Point();
-        if (widthRatio >= heightRatio) {
-            point.x = screenWidth - VastVideoViewController.WEBVIEW_PADDING;
-            point.y = (int) (heightPx / widthRatio) - VastVideoViewController.WEBVIEW_PADDING;
+        final Point point = new Point();
+        if (VastResource.Type.HTML_RESOURCE == type) {
+            point.x = Math.min(screenWidthPx, widthPx);
+            point.y = Math.min(screenHeightPx, heightPx);
         } else {
-            point.x = (int) (widthPx / heightRatio) - VastVideoViewController.WEBVIEW_PADDING;
-            point.y = screenHeight - VastVideoViewController.WEBVIEW_PADDING;
+            float widthRatio = (float) widthPx / screenWidthPx;
+            float heightRatio = (float) heightPx / screenHeightPx;
+
+            if (widthRatio >= heightRatio) {
+                point.x = screenWidthPx;
+                point.y = (int) (heightPx / widthRatio);
+            } else {
+                point.x = (int) (widthPx / heightRatio);
+                point.y = screenHeightPx;
+            }
         }
 
+        point.x -= VastVideoViewController.WEBVIEW_PADDING;
+        point.y -= VastVideoViewController.WEBVIEW_PADDING;
+
         if (point.x < 0 || point.y < 0) {
             return defaultPoint;
         }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VideoViewabilityTracker.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VideoViewabilityTracker.java
new file mode 100644
index 00000000..4605651d
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VideoViewabilityTracker.java
@@ -0,0 +1,23 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+
+public class VideoViewabilityTracker extends VastTracker {
+    private final int mViewablePlaytimeMS;
+    private final int mPercentViewable;
+
+    public VideoViewabilityTracker(final int viewablePlaytimeMS, final int percentViewable,
+            @NonNull final String trackerUrl) {
+        super(trackerUrl);
+        mViewablePlaytimeMS = viewablePlaytimeMS;
+        mPercentViewable = percentViewable;
+    }
+
+    public int getViewablePlaytimeMS() {
+        return mViewablePlaytimeMS;
+    }
+
+    public int getPercentViewable() {
+        return mPercentViewable;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VideoViewabilityTrackerXmlManager.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VideoViewabilityTrackerXmlManager.java
new file mode 100644
index 00000000..69438c34
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VideoViewabilityTrackerXmlManager.java
@@ -0,0 +1,112 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Strings;
+import com.mopub.mobileads.util.XmlUtils;
+
+import org.w3c.dom.Node;
+
+/**
+ * Data Object for the MoPubViewabilityTracker VAST Custom Extension.
+ */
+public class VideoViewabilityTrackerXmlManager {
+    // Attributes
+    public static final String VIEWABLE_PLAYTIME = "viewablePlaytime";
+    public static final String PERCENT_VIEWABLE = "percentViewable";
+
+    private final Node mVideoViewabilityNode;
+
+    VideoViewabilityTrackerXmlManager(@NonNull final Node videoViewabilityNode) {
+        Preconditions.checkNotNull(videoViewabilityNode);
+
+        mVideoViewabilityNode = videoViewabilityNode;
+    }
+
+    /**
+     * The amount of milliseconds the video must be playing to fire the impression, parsed from the
+     * "viewablePlaytime" attribute. The following two formats are valid for this attribute:
+     *     HH:MM:SS[.mmm]
+     *     SS[.mmm]
+     *
+     * @return The value of the "viewablePlaytime" attribute parsed into milliseconds or null if
+     * missing or invalid.
+     */
+    @Nullable
+    Integer getViewablePlaytimeMS() {
+        String viewablePlaytimeStr =
+                XmlUtils.getAttributeValue(mVideoViewabilityNode, VIEWABLE_PLAYTIME);
+        if (viewablePlaytimeStr == null) {
+            return null;
+        }
+
+        Integer viewablePlaytimeMS = null;
+        if (Strings.isAbsoluteTracker(viewablePlaytimeStr)) {
+            try {
+                viewablePlaytimeMS = Strings.parseAbsoluteOffset(viewablePlaytimeStr);
+            } catch (NumberFormatException e) {
+                MoPubLog.d(String.format("Invalid VAST viewablePlaytime format " +
+                        "for \"HH:MM:SS[.mmm]\": %s:", viewablePlaytimeStr));
+            }
+        } else {
+            try {
+                viewablePlaytimeMS = (int) (Float.parseFloat(viewablePlaytimeStr) * 1000);
+            } catch (NumberFormatException e) {
+                MoPubLog.d(String.format("Invalid VAST viewablePlaytime format" +
+                        " for \"SS[.mmm]\": %s:", viewablePlaytimeStr));
+            }
+        }
+
+        if (viewablePlaytimeMS == null || viewablePlaytimeMS < 0) {
+            return null;
+        }
+
+        return viewablePlaytimeMS;
+    }
+
+    /**
+     * The percentage of the video that must be in view for the tracker to be fired, parsed from the
+     * "percentViewable" attribute. The attribute may or may not have the percentage sign though it
+     * must be a number between 0 and 100, inclusive. Any decimal digits are discarded (e.g.,
+     * "99.9%" is parsed into "99").
+     *
+     * @return The value of the percentViewable attribute parsed into an integer between 0 and 100,
+     * or null if missing or invalid.
+     */
+    @Nullable
+    Integer getPercentViewable() {
+        String percentViewableStr =
+                XmlUtils.getAttributeValue(mVideoViewabilityNode, PERCENT_VIEWABLE);
+        if (percentViewableStr == null) {
+            return null;
+        }
+
+        Integer percentViewable = null;
+        try {
+            percentViewable = (int) (Float.parseFloat(percentViewableStr.replace("%", "")));
+        } catch (NumberFormatException e) {
+            MoPubLog.d(String.format("Invalid VAST percentViewable format for \"d{1,3}%%\": %s:",
+                    percentViewableStr));
+        }
+
+        if (percentViewable == null || percentViewable < 0 || percentViewable > 100) {
+            return null;
+        }
+
+        return percentViewable;
+    }
+
+    /**
+     * The tracker URL to be fired when the viewablePlaytime and percentViewable values are met,
+     * parsed from the body of the node.
+     *
+     * @return A String with the tracker URL or null if missing.
+     */
+    @Nullable
+    String getVideoViewabilityTrackerUrl() {
+        return XmlUtils.getNodeValue(mVideoViewabilityNode);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/MoPubViewFactory.java b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/MoPubViewFactory.java
index b24a90f7..8a335dc9 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/MoPubViewFactory.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/MoPubViewFactory.java
@@ -2,12 +2,14 @@
 
 import android.content.Context;
 
+import com.mopub.common.VisibleForTesting;
 import com.mopub.mobileads.MoPubView;
 
 public class MoPubViewFactory {
     protected static MoPubViewFactory instance = new MoPubViewFactory();
 
-    @Deprecated // for testing
+    @VisibleForTesting
+    @Deprecated
     public static void setInstance(MoPubViewFactory factory) {
         instance = factory;
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/VastManagerFactory.java b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/VastManagerFactory.java
index 68f918c2..2d754c77 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/VastManagerFactory.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/VastManagerFactory.java
@@ -8,11 +8,15 @@
     protected static VastManagerFactory instance = new VastManagerFactory();
 
     public static VastManager create(final Context context) {
-        return instance.internalCreate(context);
+        return instance.internalCreate(context, true);
     }
 
-    public VastManager internalCreate(final Context context) {
-        return new VastManager(context);
+    public static VastManager create(final Context context, boolean preCacheVideo) {
+        return instance.internalCreate(context, preCacheVideo);
+    }
+
+    public VastManager internalCreate(final Context context, boolean preCacheVideo) {
+        return new VastManager(context, preCacheVideo);
     }
 
     @Deprecated // for testing
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/resource/CloseButtonDrawable.java b/mopub-sdk/src/main/java/com/mopub/mobileads/resource/CloseButtonDrawable.java
index 8fc410a5..0cdb4fa7 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/resource/CloseButtonDrawable.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/resource/CloseButtonDrawable.java
@@ -6,13 +6,22 @@
 
 public class CloseButtonDrawable extends BaseWidgetDrawable {
     private final Paint closeButtonPaint;
+    /**
+     * Used to ensure that the rounded edges of the X stay in the bounds of the drawable
+     */
+    private final float halfStrokeWidth;
 
     public CloseButtonDrawable() {
+        this(DrawableConstants.CloseButton.STROKE_WIDTH);
+    }
+
+    public CloseButtonDrawable(float strokeWidth) {
         super();
 
+        halfStrokeWidth = strokeWidth / 2;
         closeButtonPaint = new Paint();
         closeButtonPaint.setColor(DrawableConstants.CloseButton.STROKE_COLOR);
-        closeButtonPaint.setStrokeWidth(DrawableConstants.CloseButton.STROKE_WIDTH);
+        closeButtonPaint.setStrokeWidth(strokeWidth);
         closeButtonPaint.setStrokeCap(DrawableConstants.CloseButton.STROKE_CAP);
     }
 
@@ -20,7 +29,9 @@ public CloseButtonDrawable() {
     public void draw(final Canvas canvas) {
         final int w = getBounds().width();
         final int h = getBounds().height();
-        canvas.drawLine(0, h, w, 0, closeButtonPaint);
-        canvas.drawLine(0, 0, w, h, closeButtonPaint);
+        canvas.drawLine(0+halfStrokeWidth, h-halfStrokeWidth,
+                w-halfStrokeWidth, 0+halfStrokeWidth, closeButtonPaint);
+        canvas.drawLine(0+halfStrokeWidth, 0+halfStrokeWidth,
+                w-halfStrokeWidth, h-halfStrokeWidth, closeButtonPaint);
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/resource/DrawableConstants.java b/mopub-sdk/src/main/java/com/mopub/mobileads/resource/DrawableConstants.java
index 5c2b844f..b3dd1bff 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/resource/DrawableConstants.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/resource/DrawableConstants.java
@@ -6,6 +6,8 @@
 
 public class DrawableConstants {
 
+    public static final int TRANSPARENT_GRAY = 0x88000000;
+
     public static class ProgressBar {
         public static final int HEIGHT_DIPS = 4;
         public static final int NUGGET_WIDTH_DIPS = 4;
@@ -42,12 +44,12 @@
     }
 
     public static class CtaButton {
-        public static final int WIDTH_DIPS = 200;
-        public static final int HEIGHT_DIPS = 42;
+        public static final int WIDTH_DIPS = 150;
+        public static final int HEIGHT_DIPS = 38;
         public static final int MARGIN_DIPS = 16;
         public static final int CORNER_RADIUS_DIPS = 6;
         public static final int OUTLINE_STROKE_WIDTH_DIPS = 2;
-        public static final float TEXT_SIZE_SP = 20f;
+        public static final float TEXT_SIZE_SP = 15f;
 
         public static final int BACKGROUND_COLOR = Color.BLACK;
         public static final int BACKGROUND_ALPHA = 51;
@@ -58,7 +60,7 @@
         public static final Paint.Style OUTLINE_STYLE = Paint.Style.STROKE;
 
         public static final String DEFAULT_CTA_TEXT = "Learn More";
-        public static final Typeface TEXT_TYPEFACE = Typeface.create("Helvetica", Typeface.BOLD);
+        public static final Typeface TEXT_TYPEFACE = Typeface.create("Helvetica", Typeface.NORMAL);
         public static final int TEXT_COLOR = Color.WHITE;
         public static final Paint.Align TEXT_ALIGN = Paint.Align.CENTER;
     }
@@ -82,10 +84,20 @@
     public static class GradientStrip {
         public static final int GRADIENT_STRIP_HEIGHT_DIPS = 72;
         public static final int START_COLOR = Color.argb(102, 0, 0, 0);
-        public static final int END_COLOR = Color.argb(0, 255, 255, 255);
+        public static final int END_COLOR = Color.argb(0, 0, 0, 0);
     }
 
     public static class BlurredLastVideoFrame {
-        public static final int ALPHA = 128;
+        public static final int ALPHA = 100;
+    }
+
+    public static class PrivacyInfoIcon {
+        public static final int LEFT_MARGIN_DIPS = 12;
+        public static final int TOP_MARGIN_DIPS = 12;
+    }
+
+    public static class SocialActions {
+        public static final int ADS_BY_LEFT_MARGIN_DIPS = 6;
+        public static final int SOCIAL_ACTIONS_LEFT_MARGIN_DIPS = 16;
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/resource/ProgressBarDrawable.java b/mopub-sdk/src/main/java/com/mopub/mobileads/resource/ProgressBarDrawable.java
index 88fc74dc..7bfc5d0e 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/resource/ProgressBarDrawable.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/resource/ProgressBarDrawable.java
@@ -63,6 +63,10 @@ public void draw(final Canvas canvas) {
         }
     }
 
+    public void reset() {
+        mLastProgress = 0;
+    }
+
     public void setDurationAndSkipOffset(final int duration, final int skipOffset) {
         mDuration = duration;
         mSkipOffset = skipOffset;
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidVideoViewController.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidVideoViewController.java
index 8aea4da9..14976812 100644
--- a/mopub-sdk/src/main/java/com/mopub/mraid/MraidVideoViewController.java
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidVideoViewController.java
@@ -6,7 +6,6 @@
 import android.media.MediaPlayer;
 import android.os.Bundle;
 import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
 import android.view.View;
 import android.widget.ImageButton;
 import android.widget.RelativeLayout;
@@ -88,8 +87,10 @@ protected void onResume() {}
     protected void onSaveInstanceState(@NonNull Bundle outState) {}
 
     @Override
-    protected void onConfigurationChanged(@Nullable Configuration newConfig) {
-    }
+    protected void onConfigurationChanged(final Configuration newConfig) {}
+
+    @Override
+    protected void onBackPressed() {}
 
     private void createInterstitialCloseButton() {
         mCloseButton = new ImageButton(getContext());
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/AdRendererRegistry.java b/mopub-sdk/src/main/java/com/mopub/nativeads/AdRendererRegistry.java
new file mode 100644
index 00000000..daad0fb1
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/AdRendererRegistry.java
@@ -0,0 +1,90 @@
+package com.mopub.nativeads;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.Preconditions;
+
+import java.util.ArrayList;
+
+/**
+ * A data structure providing methods to store and retrieve native ad renderers.
+ */
+public class AdRendererRegistry {
+
+    @NonNull private final ArrayList<MoPubAdRenderer> mMoPubAdRenderers;
+
+    public AdRendererRegistry() {
+        mMoPubAdRenderers = new ArrayList<MoPubAdRenderer>();
+    }
+
+    /**
+     * Registers an ad renderer for rendering a specific native ad format.
+     * Note that if multiple ad renderers support a specific native ad format, the first
+     * one registered will be used.
+     */
+    public void registerAdRenderer(@NonNull final MoPubAdRenderer moPubAdRenderer) {
+        mMoPubAdRenderers.add(moPubAdRenderer);
+    }
+
+    public int getAdRendererCount() {
+        return mMoPubAdRenderers.size();
+    }
+
+    @NonNull
+    public Iterable<MoPubAdRenderer> getRendererIterable() {
+        return mMoPubAdRenderers;
+    }
+
+    /**
+     * Returns the view type of the first registered ad renderer that supports rendering the
+     * {@link NativeAd} passed in. View types reserved for native ads are greater than or equal
+     * to 1, hence we add 1 when returning the view type.
+     *
+     * @param nativeAd The {@link NativeAd} to render.
+     * @return The integer representing the view type of the first renderer registered that
+     *         supports rendering the {@link NativeAd}.
+     */
+    public int getViewTypeForAd(@NonNull final NativeAd nativeAd) {
+        Preconditions.checkNotNull(nativeAd);
+        for (int i = 0; i < mMoPubAdRenderers.size(); ++i) {
+            if (nativeAd.getMoPubAdRenderer() == mMoPubAdRenderers.get(i)) {
+                return i + 1;
+            }
+        }
+        return 0;
+    }
+
+    /**
+     * Returns the first registered ad renderer that supports rendering the native ad passed in.
+     *
+     * @param nativeAd The native ad to render.
+     * @return The renderer that supports rendering the native ad.
+     */
+    @Nullable
+    public MoPubAdRenderer getRendererForAd(@NonNull final BaseNativeAd nativeAd) {
+        Preconditions.checkNotNull(nativeAd);
+        for (MoPubAdRenderer moPubAdRenderer : mMoPubAdRenderers) {
+            if (moPubAdRenderer.supports(nativeAd)) {
+                return moPubAdRenderer;
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Returns the renderer corresponding to view type passed in. View types reserved for native
+     * ads are greater than or equal to 1, hence we subtract 1 when matching the renderer.
+     *
+     * @param viewType The integer representing the view type of renderer.
+     * @return The renderer mapped to the view type.
+     */
+    @Nullable
+    public MoPubAdRenderer getRendererForViewType(final int viewType) {
+        try {
+            return mMoPubAdRenderers.get(viewType - 1);
+        } catch (IndexOutOfBoundsException e) {
+            return null;
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/AdapterHelper.java b/mopub-sdk/src/main/java/com/mopub/nativeads/AdapterHelper.java
index 28bd5620..bc114f96 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/AdapterHelper.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/AdapterHelper.java
@@ -13,8 +13,6 @@
 
 import java.lang.ref.WeakReference;
 
-import static com.mopub.nativeads.MoPubNative.MoPubNativeListener;
-
 /**
  * @deprecated As of release 2.4, use {@link com.mopub.nativeads.MoPubAdAdapter} or
  * {@link com.mopub.nativeads.MoPubStreamAdPlacer} instead
@@ -43,9 +41,8 @@ public AdapterHelper(@NonNull final Context context, final int start, final int
     @NonNull
     public View getAdView(@Nullable final View convertView,
             @Nullable final ViewGroup parent,
-            @Nullable final NativeResponse nativeResponse,
-            @Nullable final ViewBinder viewBinder,
-            @Nullable @SuppressWarnings("unused") final MoPubNativeListener moPubNativeListener) {
+            @Nullable final NativeAd nativeAd,
+            @Nullable final ViewBinder viewBinder) {
         final Activity activity = mActivity.get();
         if (activity == null) {
             MoPubLog.w("Weak reference to Activity Context in"
@@ -57,7 +54,7 @@ public View getAdView(@Nullable final View convertView,
                 convertView,
                 parent,
                 activity,
-                nativeResponse,
+                nativeAd,
                 viewBinder
         );
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/BaseNativeAd.java b/mopub-sdk/src/main/java/com/mopub/nativeads/BaseNativeAd.java
new file mode 100644
index 00000000..90b53bcd
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/BaseNativeAd.java
@@ -0,0 +1,158 @@
+package com.mopub.nativeads;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.view.View;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.logging.MoPubLog;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * This is the base class for implementations of all native ad formats. When implementing a new
+ * native ad format, be sure to also implement and register an appropriate {@link MoPubAdRenderer}
+ * that supports the format.
+ */
+public abstract class BaseNativeAd {
+
+    public interface NativeEventListener {
+        void onAdImpressed();
+        void onAdClicked();
+    }
+
+    @NonNull final private Set<String> mImpressionTrackers;
+    @NonNull final private Set<String> mClickTrackers;
+    @Nullable private NativeEventListener mNativeEventListener;
+
+    protected BaseNativeAd() {
+        mImpressionTrackers = new HashSet<String>();
+        mClickTrackers = new HashSet<String>();
+    }
+
+    // Lifecycle Handlers
+    /**
+     * Your {@link BaseNativeAd} subclass should implement this method if the network requires the developer
+     * to prepare state for recording an impression or click before a view is rendered to screen.
+     *
+     * This method is optional.
+     */
+    public abstract void prepare(@NonNull final View view);
+
+    /**
+     * Your {@link BaseNativeAd} subclass should implement this method if the network requires the developer
+     * to reset or clear state of the native ad after it goes off screen and before it is rendered
+     * again.
+     *
+     * This method is optional.
+     */
+    public abstract void clear(@NonNull final View view);
+
+    /**
+     * Your {@link BaseNativeAd} subclass should implement this method if the network requires the developer
+     * to destroy or cleanup their native ad when they are permanently finished with it.
+     *
+     * This method is optional.
+     */
+    public abstract void destroy();
+
+    public void setNativeEventListener(
+            @Nullable final NativeEventListener nativeEventListener) {
+        mNativeEventListener = nativeEventListener;
+    }
+
+    // Event Notifiers
+    /**
+     * Notifies the SDK that the ad has been shown. This will cause the SDK to record an impression
+     * for the ad. This method must be called when the native ad is impressed in order for the
+     * MoPub impression trackers to fire correctly.
+     */
+    protected final void notifyAdImpressed() {
+        if (mNativeEventListener != null) {
+            mNativeEventListener.onAdImpressed();
+        }
+    }
+
+    /**
+     * Notifies the SDK that the user has clicked the ad. This will cause the SDK to record an
+     * click for the ad. This method must be called when the native ad is clicked in order for the
+     * MoPub click trackers to fire correctly.
+     */
+    protected final void notifyAdClicked() {
+        if (mNativeEventListener != null) {
+            mNativeEventListener.onAdClicked();
+        }
+    }
+
+    final protected void addImpressionTrackers(final Object impressionTrackers) throws ClassCastException {
+        if (!(impressionTrackers instanceof JSONArray)) {
+            throw new ClassCastException("Expected impression trackers of type JSONArray.");
+        }
+
+        final JSONArray trackers = (JSONArray) impressionTrackers;
+        for (int i = 0; i < trackers.length(); i++) {
+            try {
+                addImpressionTracker(trackers.getString(i));
+            } catch (JSONException e) {
+                // This will only occur if we access a non-existent index in JSONArray.
+                MoPubLog.d("Unable to parse impression trackers.");
+            }
+        }
+    }
+
+    final protected void addClickTrackers(final Object clickTrackers) throws ClassCastException {
+        if (!(clickTrackers instanceof JSONArray)) {
+            throw new ClassCastException("Expected click trackers of type JSONArray.");
+        }
+
+        final JSONArray trackers = (JSONArray) clickTrackers;
+        for (int i = 0; i < trackers.length(); i++) {
+            try {
+                addClickTracker(trackers.getString(i));
+            } catch (JSONException e) {
+                // This will only occur if we access a non-existent index in JSONArray.
+                MoPubLog.d("Unable to parse click trackers.");
+            }
+        }
+    }
+
+    final public void addImpressionTracker(@NonNull final String url) {
+        if (!Preconditions.NoThrow.checkNotNull(url, "impressionTracker url is not allowed to be null")) {
+            return;
+        }
+        mImpressionTrackers.add(url);
+    }
+
+    final public void addClickTracker(@NonNull final String url) {
+        if (!Preconditions.NoThrow.checkNotNull(url, "clickTracker url is not allowed to be null")) {
+            return;
+        }
+        mClickTrackers.add(url);
+    }
+
+    /**
+     * Returns a Set<String> of all impression trackers associated with this native ad. Note that
+     * network requests will automatically be made to each of these impression trackers when the
+     * native ad is display on screen. See {@link StaticNativeAd#getImpressionMinPercentageViewed}
+     * and {@link StaticNativeAd#getImpressionMinTimeViewed()} for relevant
+     * impression-tracking parameters.
+     */
+    @NonNull
+    Set<String> getImpressionTrackers() {
+        return new HashSet<String>(mImpressionTrackers);
+    }
+
+    /**
+     * Returns a Set<String> of all click trackers associated with this native ad. Note that
+     * network requests will automatically be made to each of these click trackers when the
+     * native ad is clicked.
+     */
+    @NonNull
+    Set<String> getClickTrackers() {
+        return new HashSet<String>(mClickTrackers);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ClickInterface.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ClickInterface.java
new file mode 100644
index 00000000..84b36260
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/ClickInterface.java
@@ -0,0 +1,11 @@
+package com.mopub.nativeads;
+
+import android.view.View;
+
+/**
+ * This interface should be implemented by native ad formats that want to make use of the
+ * {@link NativeClickHandler} to track clicks and open click destinations.
+ */
+public interface ClickInterface {
+    void handleClick(View view);
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNative.java b/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNative.java
index 8893bd1f..dc61916d 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNative.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNative.java
@@ -1,6 +1,6 @@
 package com.mopub.nativeads;
 
-import android.content.Context;
+import android.app.Activity;
 import android.support.annotation.NonNull;
 
 import java.util.Map;
@@ -20,7 +20,7 @@
      * native ad from a third-party ad network, or execute any application code. It must also notify
      * the provided {@link CustomEventNativeListener} Object of certain lifecycle events.
      *
-     * @param context The activity context.
+     * @param activity The activity.
      * @param customEventNativeListener An Object that must be notified of certain lifecycle
      * events.
      * @param localExtras A Map containing additional custom data that is set within your
@@ -31,36 +31,20 @@
      * that you want to associate with a given custom event request. This data may be used to pass
      * dynamic information, such as publisher IDs, without changes in application code.
      */
-    protected abstract void loadNativeAd(@NonNull final Context context,
+    protected abstract void loadNativeAd(@NonNull final Activity activity,
             @NonNull final CustomEventNativeListener customEventNativeListener,
             @NonNull final Map<String, Object> localExtras,
             @NonNull final Map<String, String> serverExtras);
 
-    public interface ImageListener {
-        /**
-         * Called when images are successfully cached. If you haven't already called {@link
-         * CustomEventNativeListener#onNativeAdLoaded}, you should typically do so now.
-         */
-        void onImagesCached();
-
-        /**
-         * Called when images failed to cache. You should typically call {@link
-         * CustomEventNativeListener#onNativeAdFailed} from this callback.
-         *
-         * @param errorCode An enum value with the relevant error message.
-         */
-        void onImagesFailedToCache(NativeErrorCode errorCode);
-    }
-
     public interface CustomEventNativeListener {
         /**
          * Your custom event subclass must call this method when it successfully loads a native ad.
          * Failure to do so will disrupt the mediation waterfall and cause future ad requests to
          * stall.
          *
-         * @param nativeAd The ad that was succesfully loaded.
+         * @param nativeAd The ad that was successfully loaded.
          */
-        void onNativeAdLoaded(NativeAdInterface nativeAd);
+        void onNativeAdLoaded(BaseNativeAd nativeAd);
 
         /**
          * Your custom event subclass must call this method when it fails to load a native ad.
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNativeAdapter.java b/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNativeAdapter.java
index b695033b..c84b77b7 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNativeAdapter.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNativeAdapter.java
@@ -1,9 +1,10 @@
 package com.mopub.nativeads;
 
-import android.content.Context;
+import android.app.Activity;
 import android.support.annotation.NonNull;
 
 import com.mopub.common.DataKeys;
+import com.mopub.common.event.EventDetails;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.nativeads.factories.CustomEventNativeFactory;
 import com.mopub.network.AdResponse;
@@ -13,13 +14,15 @@
 final class CustomEventNativeAdapter {
     private CustomEventNativeAdapter() {}
 
-    public static void loadNativeAd(@NonNull final Context context,
+    public static void loadNativeAd(@NonNull final Activity activity,
             @NonNull final Map<String, Object> localExtras,
             @NonNull final AdResponse adResponse,
             @NonNull final CustomEventNative.CustomEventNativeListener customEventNativeListener) {
 
         final CustomEventNative customEventNative;
         String customEventNativeClassName = adResponse.getCustomEventClassName();
+
+        MoPubLog.d("Attempting to invoke custom event: " + customEventNativeClassName);
         try {
             customEventNative = CustomEventNativeFactory.create(customEventNativeClassName);
         } catch (Exception e) {
@@ -31,11 +34,18 @@ public static void loadNativeAd(@NonNull final Context context,
             localExtras.put(DataKeys.JSON_BODY_KEY, adResponse.getJsonBody());
         }
 
+        final EventDetails eventDetails = adResponse.getEventDetails();
+        if (eventDetails != null) {
+            localExtras.put(DataKeys.EVENT_DETAILS, eventDetails);
+        }
+
+        localExtras.put(DataKeys.CLICK_TRACKING_URL_KEY, adResponse.getClickTrackingUrl());
+
         // Custom event classes can be developed by any third party and may not be tested.
         // We catch all exceptions here to prevent crashes from untested code.
         try {
             customEventNative.loadNativeAd(
-                    context,
+                    activity,
                     customEventNativeListener,
                     localExtras,
                     adResponse.getServerExtras()
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/HttpDiskCompositeDataSource.java b/mopub-sdk/src/main/java/com/mopub/nativeads/HttpDiskCompositeDataSource.java
new file mode 100644
index 00000000..069bf59a
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/HttpDiskCompositeDataSource.java
@@ -0,0 +1,493 @@
+package com.mopub.nativeads;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import com.google.android.exoplayer.upstream.DataSource;
+import com.google.android.exoplayer.upstream.DataSpec;
+import com.google.android.exoplayer.upstream.DefaultHttpDataSource;
+import com.google.android.exoplayer.upstream.HttpDataSource;
+import com.mopub.common.CacheService;
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.event.BaseEvent;
+import com.mopub.common.event.Event;
+import com.mopub.common.event.EventDetails;
+import com.mopub.common.event.MoPubEvents;
+import com.mopub.common.logging.MoPubLog;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.IOException;
+import java.util.TreeSet;
+
+/**
+ * This data source caches data on disk as it is read from an {@link HttpDataSource}. This expects
+ * relatively large files, and this will segment the files. If any segment becomes invalid, the
+ * entire file is effectively cleared from the cache.
+ */
+public class HttpDiskCompositeDataSource implements DataSource {
+
+    // Keys are prefixed since URLs can end basically however they want, and key names could
+    // potentially be part of the URL and get the cache confused.
+    @VisibleForTesting static final String INTERVALS_KEY_PREFIX = "intervals-sorted-";
+    @VisibleForTesting static final String EXPECTED_FILE_SIZE_KEY_PREFIX = "expectedsize-";
+
+    // These are used to serialize/deserialize the intervals list
+    private static final String START = "start";
+    private static final String LENGTH = "length";
+
+    /**
+     * The constant used in {@link DefaultHttpDataSource} is private even though this is a pretty
+     * standard constant used in Exoplayer. This represents the constant that tells the HTTP
+     * connection to get all remaining bytes available.
+     */
+    @VisibleForTesting static final int LENGTH_UNBOUNDED = -1;
+
+    /**
+     * HTTP response 416 means trying to request for bytes that the server does not have.
+     */
+    private static final int HTTP_RESPONSE_REQUESTED_RANGE_NOT_SATISFIABLE = 416;
+
+    /**
+     * The current block size is arbitrarily set at 500KiB. This has to be bigger than the biggest
+     * read request from the consumer of this class's read method. This also has to be reasonably
+     * small to accommodate devices that don't have a lot of memory to work with.
+     */
+    @VisibleForTesting static final int BLOCK_SIZE = 500 * 1024;
+
+    /**
+     * The network data source
+     */
+    @NonNull private final HttpDataSource mHttpDataSource;
+
+    /**
+     * Bytes from disk. This is the in-memory working copy.
+     */
+    @Nullable private byte[] mCachedBytes;
+
+    /**
+     * Base key of the cache. This is the URI of the {@link DataSpec}.
+     */
+    @Nullable private String mKey;
+
+    /**
+     * This is the set of intervals that the cache thinks are valid. Intervals have a start and a
+     * length.
+     */
+    @NonNull private final TreeSet<IntInterval> mIntervals;
+
+    /**
+     * The absolute index of the first byte that is currently being requested.
+     */
+    private int mStartInFile;
+
+    /**
+     * The total number of bytes read in the current block. This indicates the current cursor
+     * position. mDataBlockOffset plus mStartInFile is the cursor position for the file.
+     * mDataBlockOffset plus mStartInDataBlock is the cursor position for the current data block.
+     */
+    private int mDataBlockOffset;
+
+    /**
+     * Which segment of the file the current block is on.
+     */
+    private int mSegment;
+
+    /**
+     * The index of the physical byte array for the current block.
+     */
+    private int mStartInDataBlock;
+
+    /**
+     * Whether or not this has an {@link HttpDataSource} that is already open.
+     */
+    private boolean mIsHttpSourceOpen;
+
+    /**
+     * The expected size of the entire file.
+     */
+    @Nullable private Integer mExpectedFileLength = null;
+
+    /**
+     * Data needed to open another {@link HttpDataSource}.
+     */
+    @Nullable private DataSpec mDataSpec;
+
+    /**
+     * Whether or not the cache has been written to during the current session.
+     */
+    private boolean mIsDirty;
+
+    /**
+     * Used to store metadata around event logging.
+     */
+    @Nullable private final EventDetails mEventDetails;
+
+    /**
+     * Whether or not the event for starting the download has already been fired.
+     */
+    private boolean mHasLoggedDownloadStart;
+
+    public HttpDiskCompositeDataSource(@NonNull final Context context,
+            @NonNull final String userAgent, @Nullable final EventDetails eventDetails) {
+        this(context, userAgent, eventDetails,
+                new DefaultHttpDataSource(userAgent, null, null,
+                        DefaultHttpDataSource.DEFAULT_CONNECT_TIMEOUT_MILLIS,
+                        DefaultHttpDataSource.DEFAULT_READ_TIMEOUT_MILLIS,
+                        false));
+    }
+
+    @VisibleForTesting
+    HttpDiskCompositeDataSource(@NonNull final Context context,
+            @NonNull final String userAgent, @Nullable final EventDetails eventDetails,
+            @NonNull final HttpDataSource httpDataSource) {
+        mHttpDataSource = httpDataSource;
+        CacheService.initialize(context);
+        mIntervals = new TreeSet<IntInterval>();
+        mEventDetails = eventDetails;
+    }
+
+    @Override
+    public long open(@NonNull final DataSpec dataSpec) throws IOException {
+        Preconditions.checkNotNull(dataSpec);
+        if (dataSpec.uri == null) {
+            return LENGTH_UNBOUNDED;
+        }
+
+        mIsDirty = false;
+
+        mDataSpec = dataSpec;
+        mKey = dataSpec.uri.toString();
+        if (mKey == null) {
+            return LENGTH_UNBOUNDED;
+        }
+        mStartInFile = (int) dataSpec.absoluteStreamPosition;
+        mSegment = mStartInFile / BLOCK_SIZE;
+        mCachedBytes = CacheService.getFromDiskCache(mSegment + mKey);
+        mStartInDataBlock = mStartInFile % BLOCK_SIZE;
+        mDataBlockOffset = 0;
+
+        mExpectedFileLength = getExpectedFileLengthFromDisk(mKey);
+
+        populateIntervalsFromDisk(mKey, mIntervals);
+
+        int mDataRequestStartPoint = getFirstContiguousPointAfter(mStartInFile, mIntervals);
+
+        // Cache miss
+        if (mCachedBytes == null) {
+            mCachedBytes = new byte[BLOCK_SIZE];
+
+            // It's not in the cache, but we expected it to be there.
+            if (mDataRequestStartPoint > mStartInFile) {
+                MoPubLog.d("Cache segment " + mSegment + " was evicted. Invalidating cache");
+                mIntervals.clear();
+                mDataRequestStartPoint = (int) dataSpec.absoluteStreamPosition;
+            }
+        }
+
+        long size;
+        // If we think there are more bytes left to read from the network
+        if (mExpectedFileLength == null || mDataRequestStartPoint != mExpectedFileLength) {
+            final long lengthToUse;
+            if (mDataSpec.length == LENGTH_UNBOUNDED) {
+                lengthToUse = LENGTH_UNBOUNDED;
+            } else {
+                // Make sure to take into account that the start point is at a later point
+                lengthToUse = mDataSpec.length - (mDataRequestStartPoint - mStartInFile);
+            }
+            // Modify the data spec to include the new params
+            DataSpec modifiedDataSpec = new DataSpec(dataSpec.uri, mDataRequestStartPoint,
+                    lengthToUse, dataSpec.key, dataSpec.flags);
+
+            try {
+                size = mHttpDataSource.open(modifiedDataSpec);
+                if (mExpectedFileLength == null && lengthToUse == LENGTH_UNBOUNDED) {
+                    // If we don't have an expected file length set, set it if we requested the
+                    // rest of the file.
+                    mExpectedFileLength = (int) (mStartInFile + size);
+                    CacheService.putToDiskCache(EXPECTED_FILE_SIZE_KEY_PREFIX + mKey,
+                            String.valueOf(mExpectedFileLength).getBytes());
+                }
+                mIsHttpSourceOpen = true;
+                if (!mHasLoggedDownloadStart) {
+                    MoPubEvents.log(Event.createEventFromDetails(
+                            BaseEvent.Name.DOWNLOAD_START,
+                            BaseEvent.Category.NATIVE_VIDEO,
+                            BaseEvent.SamplingRate.NATIVE_VIDEO,
+                            mEventDetails));
+                    mHasLoggedDownloadStart = true;
+                }
+            } catch (HttpDataSource.InvalidResponseCodeException e) {
+                // This shouldn't happen anymore, but if we accidentally requested too many bytes
+                // because we already had the bytes before that point, then it's still fine.
+                if (e.responseCode == HTTP_RESPONSE_REQUESTED_RANGE_NOT_SATISFIABLE) {
+                    size = mExpectedFileLength == null ? mDataRequestStartPoint - mStartInFile : mExpectedFileLength - mStartInFile;
+                } else {
+                    throw e;
+                }
+                mIsHttpSourceOpen = false;
+            }
+        } else {
+            size = dataSpec.length == LENGTH_UNBOUNDED ? mExpectedFileLength - mStartInFile : dataSpec.length;
+        }
+        return size;
+    }
+
+    private static void populateIntervalsFromDisk(@NonNull final String key,
+            @NonNull final TreeSet<IntInterval> intervals) {
+        Preconditions.checkNotNull(key);
+        Preconditions.checkNotNull(intervals);
+
+        intervals.clear();
+        byte[] intervalsFromDisk = CacheService.getFromDiskCache(INTERVALS_KEY_PREFIX + key);
+        if (intervalsFromDisk != null) {
+            String intervalsStringData = new String(intervalsFromDisk);
+            try {
+                JSONArray jsonIntervalArray = new JSONArray(intervalsStringData);
+                for (int i = 0; i < jsonIntervalArray.length(); i++) {
+                    JSONObject jsonInterval = new JSONObject((String) jsonIntervalArray.get(i));
+                    intervals.add(new IntInterval(jsonInterval.getInt(START),
+                            jsonInterval.getInt(LENGTH)));
+                }
+            } catch (JSONException e) {
+                MoPubLog.d("clearing cache since invalid json intervals found", e);
+                intervals.clear();
+            } catch (ClassCastException e) {
+                MoPubLog.d("clearing cache since unable to read json data");
+                intervals.clear();
+            }
+        }
+    }
+
+    private static Integer getExpectedFileLengthFromDisk(@NonNull final String key) {
+        Preconditions.checkNotNull(key);
+
+        byte[] maxSizeByteArray = CacheService.getFromDiskCache(
+                EXPECTED_FILE_SIZE_KEY_PREFIX + key);
+        if (maxSizeByteArray != null) {
+            try {
+                return Integer.parseInt(new String(maxSizeByteArray));
+            } catch (NumberFormatException e) {
+                return null;
+            }
+        }
+        return null;
+    }
+
+    @Override
+    public void close() throws IOException {
+        if (!TextUtils.isEmpty(mKey) && mCachedBytes != null) {
+            CacheService.putToDiskCache(mSegment + mKey, mCachedBytes);
+            addNewInterval(mIntervals, mStartInFile, mDataBlockOffset);
+            writeIntervalsToDisk(mIntervals, mKey);
+            if (mIsDirty && mExpectedFileLength != null && getFirstContiguousPointAfter(
+                    0, mIntervals) == mExpectedFileLength) {
+                MoPubEvents.log(Event.createEventFromDetails(
+                        BaseEvent.Name.DOWNLOAD_FINISHED,
+                        BaseEvent.Category.NATIVE_VIDEO,
+                        BaseEvent.SamplingRate.NATIVE_VIDEO,
+                        mEventDetails));
+            }
+        }
+        mCachedBytes = null;
+
+        mHttpDataSource.close();
+        mIsHttpSourceOpen = false;
+        mStartInFile = 0;
+        mDataBlockOffset = 0;
+        mStartInDataBlock = 0;
+        mExpectedFileLength = null;
+        mIsDirty = false;
+    }
+
+    private static void writeIntervalsToDisk(@NonNull final TreeSet<IntInterval> intervals,
+            @NonNull final String key) {
+        Preconditions.checkNotNull(intervals);
+        Preconditions.checkNotNull(key);
+
+        final JSONArray jsonIntervals = new JSONArray();
+        for (IntInterval interval : intervals) {
+            jsonIntervals.put(interval);
+        }
+        CacheService.putToDiskCache(INTERVALS_KEY_PREFIX + key,
+                jsonIntervals.toString().getBytes());
+    }
+
+    @Override
+    public int read(final byte[] buffer, final int offset, final int length) throws IOException {
+        if (length > BLOCK_SIZE) {
+            MoPubLog.d(
+                    "Reading more than the block size (" + BLOCK_SIZE + " bytes) at once is not possible. length = " + length);
+            return -1;
+        }
+        if (mDataSpec == null) {
+            MoPubLog.d("Unable to read from data source when no spec provided");
+            return -1;
+        }
+        if (mCachedBytes == null) {
+            MoPubLog.d("No cache set up. Call open before read.");
+            return -1;
+        }
+
+        // Number of bytes available in the current block
+        final int bytesAvailableInCurrentBlock = BLOCK_SIZE - mStartInDataBlock - mDataBlockOffset;
+
+        // The position of the next expected break (could be end of file)
+        final int farthestContiguousPoint = getFirstContiguousPointAfter(
+                mStartInFile + mDataBlockOffset, mIntervals);
+        // Amount of data expected to be in the cache
+        final int validBytesLeftInCache = farthestContiguousPoint - mStartInFile - mDataBlockOffset;
+        // The number of expected bytes to be able to read from the cache
+        final int bytesToRead = Math.min(validBytesLeftInCache, length);
+        // To keep track of actual bytes read from the cache
+        int bytesReadFromDisk = 0;
+        // If the data is available at least partially on disk
+        if (areBytesAvailableInCache(farthestContiguousPoint, mStartInFile, mDataBlockOffset)) {
+            // The case of when all of the bytes are available in the current block
+            if (bytesToRead <= bytesAvailableInCurrentBlock) {
+                System.arraycopy(mCachedBytes, mStartInDataBlock + mDataBlockOffset, buffer, offset,
+                        bytesToRead);
+                mDataBlockOffset += bytesToRead;
+                bytesReadFromDisk += bytesToRead;
+            } else {
+                // Read all of the available bytes in the current block
+                System.arraycopy(mCachedBytes, mStartInDataBlock + mDataBlockOffset, buffer, offset,
+                        bytesAvailableInCurrentBlock);
+                mDataBlockOffset += bytesAvailableInCurrentBlock;
+                bytesReadFromDisk += bytesAvailableInCurrentBlock;
+
+                // Flush the cache
+                writeCacheToDiskAndClearVariables();
+
+                // Read in the next segment from disk
+                mCachedBytes = CacheService.getFromDiskCache(mSegment + mKey);
+                if (mCachedBytes == null) {
+                    // If there is a mismatch between expected bytes available in the cache and what
+                    // is actually in the cache, this is an unrecoverable problem. Reset the cache
+                    // and clear the data and open a new HTTP connection starting at the current position.
+                    MoPubLog.d("Unexpected cache miss. Invalidating cache");
+                    mIntervals.clear();
+                    mCachedBytes = new byte[BLOCK_SIZE];
+                    mHttpDataSource.close();
+
+                    mHttpDataSource.open(
+                            new DataSpec(mDataSpec.uri, mStartInFile + mDataBlockOffset,
+                                    LENGTH_UNBOUNDED, mDataSpec.key, mDataSpec.flags));
+                    mIsHttpSourceOpen = true;
+                } else {
+                    // If the data is available in the cache, read the remaining bytes into the
+                    // buffer, additionally offset by what has already been written to the buffer.
+                    System.arraycopy(mCachedBytes, mStartInDataBlock + mDataBlockOffset, buffer,
+                            offset + bytesReadFromDisk,
+                            bytesToRead - bytesReadFromDisk);
+                    mDataBlockOffset += bytesToRead - bytesReadFromDisk;
+                    bytesReadFromDisk = bytesToRead;
+                }
+            }
+        }
+
+        // If we have read enough data from disk, don't ask for network data
+        final int bytesToReadFromNetwork = length - bytesReadFromDisk;
+        if (bytesToReadFromNetwork <= 0) {
+            return bytesReadFromDisk;
+        }
+
+        mIsDirty = true;
+
+        // This should never happen, but if we lose network or something, this might happen
+        if (!mIsHttpSourceOpen) {
+            MoPubLog.d("end of cache reached. No http source open");
+            return -1;
+        }
+
+        // Read from network and store to disk
+        int bytesReadFromNetwork = mHttpDataSource.read(buffer, offset + bytesReadFromDisk,
+                bytesToReadFromNetwork);
+
+        final int bytesAvailableInCurrentBlockForNetwork =
+                BLOCK_SIZE - mStartInDataBlock - mDataBlockOffset;
+        if (bytesAvailableInCurrentBlockForNetwork < bytesReadFromNetwork) {
+            // If there is not enough room in the current block, write up to the end of the current
+            // block, set up a new segment (which may have data in the cache already), and write
+            // the rest of the data.
+            System.arraycopy(buffer, offset + bytesReadFromDisk, mCachedBytes,
+                    mStartInDataBlock + mDataBlockOffset, bytesAvailableInCurrentBlockForNetwork);
+            mDataBlockOffset += bytesAvailableInCurrentBlockForNetwork;
+
+            writeCacheToDiskAndClearVariables();
+
+            mCachedBytes = CacheService.getFromDiskCache(mSegment + mKey);
+            if (mCachedBytes == null) {
+                mCachedBytes = new byte[BLOCK_SIZE];
+            }
+
+            System.arraycopy(buffer,
+                    offset + bytesAvailableInCurrentBlockForNetwork + bytesReadFromDisk,
+                    mCachedBytes, mStartInDataBlock + mDataBlockOffset,
+                    bytesReadFromNetwork - bytesAvailableInCurrentBlockForNetwork);
+            mDataBlockOffset += bytesReadFromNetwork - bytesAvailableInCurrentBlockForNetwork;
+        } else {
+            System.arraycopy(buffer, offset + bytesReadFromDisk, mCachedBytes,
+                    mStartInDataBlock + mDataBlockOffset, bytesReadFromNetwork);
+            mDataBlockOffset += bytesReadFromNetwork;
+        }
+
+        return bytesReadFromNetwork + bytesReadFromDisk;
+    }
+
+    private static boolean areBytesAvailableInCache(final int farthestContiguousPoint,
+            final int startInFile, final int dataBlockOffset) {
+        return farthestContiguousPoint > startInFile + dataBlockOffset;
+    }
+
+    private void writeCacheToDiskAndClearVariables() {
+        CacheService.putToDiskCache(mSegment + mKey, mCachedBytes);
+        addNewInterval(mIntervals, mStartInFile, mDataBlockOffset);
+        mStartInDataBlock = 0;
+        mStartInFile = mStartInFile + mDataBlockOffset;
+        mDataBlockOffset = 0;
+        mSegment = mStartInFile / BLOCK_SIZE;
+    }
+
+    /**
+     * Gets the first contiguous point from disk that we have starting from the given point. If
+     * there is no segment that contains this point, return that point.
+     */
+    @VisibleForTesting
+    static int getFirstContiguousPointAfter(int point,
+            @NonNull final TreeSet<IntInterval> intervals) {
+        Preconditions.checkNotNull(intervals);
+
+        int lastContiguousPoint = point;
+        for (final IntInterval interval : intervals) {
+            if (interval.getStart() <= lastContiguousPoint) {
+                lastContiguousPoint = Math.max(lastContiguousPoint,
+                        interval.getStart() + interval.getLength());
+            }
+        }
+        return lastContiguousPoint;
+    }
+
+    /**
+     * Adds the interval if the interval does not already exist.
+     *
+     * @param intervals The current set of intervals
+     * @param start     The starting point of this interval
+     * @param length    The length of this interval
+     */
+    @VisibleForTesting
+    static void addNewInterval(@NonNull final TreeSet<IntInterval> intervals, final int start,
+            final int length) {
+        Preconditions.checkNotNull(intervals);
+
+        if (getFirstContiguousPointAfter(start, intervals) >= start + length) {
+            return;
+        }
+        intervals.add(new IntInterval(start, length));
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ImpressionInterface.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ImpressionInterface.java
new file mode 100644
index 00000000..6f84021f
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/ImpressionInterface.java
@@ -0,0 +1,15 @@
+package com.mopub.nativeads;
+
+import android.view.View;
+
+/**
+ * This interface should be implemented by native ad formats that want to make use of the
+ * {@link ImpressionTracker} to track impressions.
+ */
+public interface ImpressionInterface {
+    int getImpressionMinPercentageViewed();
+    int getImpressionMinTimeViewed();
+    void recordImpression(View view);
+    boolean isImpressionRecorded();
+    void setImpressionRecorded();
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ImpressionTracker.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ImpressionTracker.java
index 176f0e65..d757285d 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/ImpressionTracker.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/ImpressionTracker.java
@@ -1,7 +1,8 @@
 package com.mopub.nativeads;
 
-import android.content.Context;
+import android.app.Activity;
 import android.os.Handler;
+import android.os.Looper;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.view.View;
@@ -16,18 +17,22 @@
 import static com.mopub.nativeads.VisibilityTracker.VisibilityChecker;
 import static com.mopub.nativeads.VisibilityTracker.VisibilityTrackerListener;
 
-class ImpressionTracker {
+/**
+ * Impression tracker used to call {@link ImpressionInterface#recordImpression(View)} when a
+ * percentage of a native ad has been on screen for a duration of time.
+ */
+public class ImpressionTracker {
 
     private static final int PERIOD = 250;
 
     // Object tracking visibility of added views
     @NonNull private final VisibilityTracker mVisibilityTracker;
 
-    // All views and responses being tracked for impressions
-    @NonNull private final Map<View, NativeResponse> mTrackedViews;
+    // All views and ads being tracked for impressions
+    @NonNull private final Map<View, ImpressionInterface> mTrackedViews;
 
     // Visible views being polled for time on screen before tracking impression
-    @NonNull private final Map<View, TimestampWrapper<NativeResponse>> mPollingViews;
+    @NonNull private final Map<View, TimestampWrapper<ImpressionInterface>> mPollingViews;
 
     // Handler for polling visible views
     @NonNull private final Handler mPollHandler;
@@ -41,17 +46,17 @@
     // Listener for when a view becomes visible or non visible
     @Nullable private VisibilityTrackerListener mVisibilityTrackerListener;
 
-    ImpressionTracker(@NonNull final Context context) {
-        this(new WeakHashMap<View, NativeResponse>(),
-                new WeakHashMap<View, TimestampWrapper<NativeResponse>>(),
+    public ImpressionTracker(@NonNull final Activity activity) {
+        this(new WeakHashMap<View, ImpressionInterface>(),
+                new WeakHashMap<View, TimestampWrapper<ImpressionInterface>>(),
                 new VisibilityChecker(),
-                new VisibilityTracker(context),
-                new Handler());
+                new VisibilityTracker(activity),
+                new Handler(Looper.getMainLooper()));
     }
 
     @VisibleForTesting
-    ImpressionTracker(@NonNull final Map<View, NativeResponse> trackedViews,
-            @NonNull final Map<View, TimestampWrapper<NativeResponse>> pollingViews,
+    ImpressionTracker(@NonNull final Map<View, ImpressionInterface> trackedViews,
+            @NonNull final Map<View, TimestampWrapper<ImpressionInterface>> pollingViews,
             @NonNull final VisibilityChecker visibilityChecker,
             @NonNull final VisibilityTracker visibilityTracker,
             @NonNull final Handler handler) {
@@ -64,23 +69,23 @@
             @Override
             public void onVisibilityChanged(@NonNull final List<View> visibleViews, @NonNull final List<View> invisibleViews) {
                 for (final View view : visibleViews) {
-                    // It's possible for native response to be null if the view was GC'd from this class
+                    // It's possible for native ad to be null if the view was GC'd from this class
                     // but not from VisibilityTracker
                     // If it's null then clean up the view from this class
-                    final NativeResponse nativeResponse = mTrackedViews.get(view);
-                    if (nativeResponse == null) {
+                    final ImpressionInterface impressionInterface = mTrackedViews.get(view);
+                    if (impressionInterface == null) {
                         removeView(view);
                         continue;
                     }
 
-                    // If the native response is already polling, don't recreate it
-                    final TimestampWrapper<NativeResponse> polling = mPollingViews.get(view);
-                    if (polling != null && nativeResponse.equals(polling.mInstance)) {
+                    // If the native ad is already polling, don't recreate it
+                    final TimestampWrapper<ImpressionInterface> polling = mPollingViews.get(view);
+                    if (polling != null && impressionInterface.equals(polling.mInstance)) {
                         continue;
                     }
 
                     // Add a new polling view
-                    mPollingViews.put(view, new TimestampWrapper<NativeResponse>(nativeResponse));
+                    mPollingViews.put(view, new TimestampWrapper<ImpressionInterface>(impressionInterface));
                 }
 
                 for (final View view : invisibleViews) {
@@ -98,24 +103,24 @@ public void onVisibilityChanged(@NonNull final List<View> visibleViews, @NonNull
     /**
      * Tracks the given view for impressions.
      */
-    void addView(final View view, @NonNull final NativeResponse nativeResponse) {
-        // View is already associated with same native response
-        if (mTrackedViews.get(view) == nativeResponse) {
+    public void addView(final View view, @NonNull final ImpressionInterface impressionInterface) {
+        // View is already associated with the same native ad
+        if (mTrackedViews.get(view) == impressionInterface) {
             return;
         }
 
-        // Clean up state if view is being recycled and associated with a different response
+        // Clean up state if view is being recycled and associated with a different ad
         removeView(view);
 
-        if (nativeResponse.getRecordedImpression() || nativeResponse.isDestroyed()) {
+        if (impressionInterface.isImpressionRecorded()) {
             return;
         }
 
-        mTrackedViews.put(view, nativeResponse);
-        mVisibilityTracker.addView(view, nativeResponse.getImpressionMinPercentageViewed());
+        mTrackedViews.put(view, impressionInterface);
+        mVisibilityTracker.addView(view, impressionInterface.getImpressionMinPercentageViewed());
     }
 
-    void removeView(final View view) {
+    public void removeView(final View view) {
         mTrackedViews.remove(view);
         removePollingView(view);
         mVisibilityTracker.removeView(view);
@@ -124,14 +129,14 @@ void removeView(final View view) {
     /**
      * Immediately clear all views. Useful for when we re-request ads for an ad placer
      */
-    void clear() {
+    public void clear() {
         mTrackedViews.clear();
         mPollingViews.clear();
         mVisibilityTracker.clear();
         mPollHandler.removeMessages(0);
     }
 
-    void destroy() {
+    public void destroy() {
         clear();
         mVisibilityTracker.destroy();
         mVisibilityTrackerListener = null;
@@ -163,9 +168,9 @@ private void removePollingView(final View view) {
 
         @Override
         public void run() {
-            for (final Map.Entry<View, TimestampWrapper<NativeResponse>> entry : mPollingViews.entrySet()) {
+            for (final Map.Entry<View, TimestampWrapper<ImpressionInterface>> entry : mPollingViews.entrySet()) {
                 final View view = entry.getKey();
-                final TimestampWrapper<NativeResponse> timestampWrapper = entry.getValue();
+                final TimestampWrapper<ImpressionInterface> timestampWrapper = entry.getValue();
 
                 // If it's been visible for the min impression time, trigger the callback
                 if (!mVisibilityChecker.hasRequiredTimeElapsed(
@@ -175,6 +180,7 @@ public void run() {
                 }
 
                 timestampWrapper.mInstance.recordImpression(view);
+                timestampWrapper.mInstance.setImpressionRecorded();
 
                 // Removed in a separate loop to avoid a ConcurrentModification exception.
                 mRemovedViews.add(view);
@@ -197,4 +203,4 @@ public void run() {
     VisibilityTrackerListener getVisibilityTrackerListener() {
         return mVisibilityTrackerListener;
     }
-}
\ No newline at end of file
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/IntInterval.java b/mopub-sdk/src/main/java/com/mopub/nativeads/IntInterval.java
new file mode 100644
index 00000000..bdbc0bb7
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/IntInterval.java
@@ -0,0 +1,77 @@
+package com.mopub.nativeads;
+
+import android.support.annotation.Nullable;
+
+/**
+ * Stores an integer interval in the form of a start and a length.
+ */
+public class IntInterval implements Comparable<IntInterval>{
+    private int start;
+    private int length;
+
+    public IntInterval(int start, int length) {
+        this.start = start;
+        this.length = length;
+    }
+
+    public int getStart() {
+        return start;
+    }
+
+    public int getLength() {
+        return length;
+    }
+
+    public void setStart(int start) {
+        this.start = start;
+    }
+
+    public void setLength(int length) {
+        this.length = length;
+    }
+
+    /**
+     * For comparing intervals directly to this object.
+     * @param start The start of the interval
+     * @param length The length of the interval
+     * @return Whether or not the given interval and this object have the same values.
+     */
+    public boolean equals(int start, int length) {
+        return this.start == start && this.length == length;
+    }
+
+    @Override
+    public String toString() {
+        return "{start : " + start + ", length : " + length + "}";
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (!(o instanceof IntInterval)) {
+            return false;
+        }
+
+        final IntInterval other = (IntInterval) o;
+        return this.start == other.start && this.length == other.length;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = 29;
+        result = 31 * result + start;
+        result = 31 * result + length;
+        return result;
+    }
+
+    @Override
+    @SuppressWarnings("ConstantConditions")
+    public int compareTo(@Nullable final IntInterval another) {
+        if (start == another.start) {
+            return length - another.length;
+        }
+        return start - another.start;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MediaLayout.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MediaLayout.java
new file mode 100644
index 00000000..8cfd81bc
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MediaLayout.java
@@ -0,0 +1,395 @@
+package com.mopub.nativeads;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.graphics.Color;
+import android.graphics.SurfaceTexture;
+import android.graphics.drawable.Drawable;
+import android.graphics.drawable.GradientDrawable;
+import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.AttributeSet;
+import android.view.TextureView;
+import android.view.View;
+import android.widget.ImageView;
+import android.widget.ProgressBar;
+import android.widget.RelativeLayout;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Dips;
+import com.mopub.common.util.Drawables;
+import com.mopub.common.util.Utils;
+import com.mopub.mobileads.VastVideoProgressBarWidget;
+import com.mopub.mobileads.resource.DrawableConstants.GradientStrip;
+
+@TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+public class MediaLayout extends RelativeLayout {
+    public enum Mode { IMAGE, PLAYING, LOADING, BUFFERING, PAUSED, FINISHED }
+    public enum MuteState { MUTED, UNMUTED }
+
+    private static final int GRADIENT_STRIP_HEIGHT_DIPS = 35;
+    private static final int MUTE_SIZE_DIPS = 36;
+    private static final int CONTROL_SIZE_DIPS = 40;
+    private static final int PINNER_PADDING_DIPS = 10;
+
+    private static final float ASPECT_MULTIPLIER_WIDTH_TO_HEIGHT = 9f / 16;
+    private static final float ASPECT_MULTIPLIER_HEIGHT_TO_WIDTH = 16f / 9;
+
+    @NonNull private volatile Mode mMode = Mode.IMAGE;
+    @NonNull private MuteState mMuteState;
+
+    @NonNull private ImageView mMainImageView;
+
+    // These views are video-only, ordered by their z index. Don't create them if they aren't needed.
+    @Nullable private TextureView mVideoTextureView;
+    @Nullable private ProgressBar mLoadingSpinner;
+    @Nullable private ImageView mPlayButton;
+    @Nullable private ImageView mBottomGradient;
+    @Nullable private ImageView mTopGradient;
+    @Nullable private VastVideoProgressBarWidget mVideoProgress;
+    @Nullable private ImageView mMuteControl;
+    @Nullable private View mOverlay;
+    @Nullable private Drawable mMutedDrawable;
+    @Nullable private Drawable mUnmutedDrawable;
+
+    private boolean mIsInitialized;
+
+    // Measurements
+    private final int mControlSizePx;
+    private final int mGradientStripHeightPx;
+    private final int mMuteSizePx;
+    private final int mPaddingPx;
+
+    // Constructors
+    public MediaLayout(@NonNull final Context context) {
+        this(context, null);
+    }
+
+    public MediaLayout(@NonNull final Context context, @Nullable final AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public MediaLayout(@NonNull final Context context, @Nullable final AttributeSet attrs,
+            final int defStyleAttr) {
+        super(context, attrs, defStyleAttr);
+        Preconditions.checkNotNull(context);
+
+        mMuteState = MuteState.MUTED;
+
+        // Create and layout the main imageView and set its modes.
+        LayoutParams params = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
+        params.addRule(RelativeLayout.CENTER_IN_PARENT);
+        mMainImageView = new ImageView(context);
+        mMainImageView.setLayoutParams(params);
+        mMainImageView.setScaleType(ImageView.ScaleType.CENTER_CROP);
+        addView(mMainImageView);
+
+        mControlSizePx = Dips.asIntPixels(CONTROL_SIZE_DIPS, context);
+        mGradientStripHeightPx = Dips.asIntPixels(GRADIENT_STRIP_HEIGHT_DIPS, context);
+        mMuteSizePx = Dips.asIntPixels(MUTE_SIZE_DIPS, context);
+        mPaddingPx = Dips.asIntPixels(PINNER_PADDING_DIPS, context);
+    }
+
+    public void setSurfaceTextureListener(@Nullable final TextureView.SurfaceTextureListener stl) {
+        if (mVideoTextureView != null) {
+            mVideoTextureView.setSurfaceTextureListener(stl);
+
+            SurfaceTexture st = mVideoTextureView.getSurfaceTexture();
+            if (st != null && stl != null) {
+                stl.onSurfaceTextureAvailable(st, mVideoTextureView.getWidth(), mVideoTextureView.getHeight());
+            }
+        }
+    }
+
+    /**
+     * Users should call this method when the view will be used for video. Video views are not
+     * instantiated in the image-only case in order to save time and memory.
+     */
+    public void initForVideo() {
+        if (mIsInitialized) {
+            return;
+        }
+
+        // Init and set up all the video view items.
+        final LayoutParams videoTextureLayoutParams =
+                new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
+        videoTextureLayoutParams.addRule(RelativeLayout.CENTER_IN_PARENT);
+        mVideoTextureView = new TextureView(getContext());
+        mVideoTextureView.setLayoutParams(videoTextureLayoutParams);
+        mVideoTextureView.setId((int) Utils.generateUniqueId());
+        addView(mVideoTextureView);
+
+        // Place texture beneath image.
+        mMainImageView.bringToFront();
+
+        final LayoutParams loadingSpinnerParams = new LayoutParams(mControlSizePx, mControlSizePx);
+        loadingSpinnerParams.addRule(RelativeLayout.ALIGN_PARENT_TOP);
+        loadingSpinnerParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
+        mLoadingSpinner = new ProgressBar(getContext());
+        mLoadingSpinner.setLayoutParams(loadingSpinnerParams);
+        mLoadingSpinner.setPadding(0, mPaddingPx, mPaddingPx, 0);
+        mLoadingSpinner.setIndeterminate(true);
+        addView(mLoadingSpinner);
+
+        final LayoutParams bottomGradientParams =
+                new LayoutParams(LayoutParams.MATCH_PARENT, mGradientStripHeightPx);
+        bottomGradientParams.addRule(RelativeLayout.ALIGN_BOTTOM, mVideoTextureView.getId());
+        mBottomGradient = new ImageView(getContext());
+        mBottomGradient.setLayoutParams(bottomGradientParams);
+        final GradientDrawable bottomGradientDrawable =
+                new GradientDrawable(GradientDrawable.Orientation.BOTTOM_TOP,
+                new int[] {GradientStrip.START_COLOR, GradientStrip.END_COLOR});
+        mBottomGradient.setImageDrawable(bottomGradientDrawable);
+        addView(mBottomGradient);
+
+        final LayoutParams topGradientParams =
+                new LayoutParams(LayoutParams.MATCH_PARENT, mGradientStripHeightPx);
+        topGradientParams.addRule(RelativeLayout.ALIGN_TOP, mVideoTextureView.getId());
+        mTopGradient = new ImageView(getContext());
+        mTopGradient.setLayoutParams(topGradientParams);
+        final GradientDrawable topGradientDrawable =
+                new GradientDrawable(GradientDrawable.Orientation.TOP_BOTTOM,
+                        new int[] {GradientStrip.START_COLOR, GradientStrip.END_COLOR});
+        mTopGradient.setImageDrawable(topGradientDrawable);
+        addView(mTopGradient);
+
+        mVideoProgress = new VastVideoProgressBarWidget(getContext());
+        mVideoProgress.setAnchorId(mVideoTextureView.getId());
+        mVideoProgress.calibrateAndMakeVisible(1000, 0);
+        addView(mVideoProgress);
+
+        mMutedDrawable = Drawables.NATIVE_MUTED.createDrawable(getContext());
+        mUnmutedDrawable = Drawables.NATIVE_UNMUTED.createDrawable(getContext());
+        final LayoutParams muteControlParams = new LayoutParams(mMuteSizePx, mMuteSizePx);
+        muteControlParams.addRule(RelativeLayout.ALIGN_PARENT_LEFT);
+        muteControlParams.addRule(RelativeLayout.ABOVE, mVideoProgress.getId());
+        mMuteControl = new ImageView(getContext());
+        mMuteControl.setLayoutParams(muteControlParams);
+        mMuteControl.setScaleType(ImageView.ScaleType.CENTER_INSIDE);
+        mMuteControl.setPadding(mPaddingPx, mPaddingPx, mPaddingPx, mPaddingPx);
+        mMuteControl.setImageDrawable(mMutedDrawable);
+        addView(mMuteControl);
+
+        final LayoutParams overlayParams =
+                new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
+        overlayParams.addRule(RelativeLayout.CENTER_IN_PARENT);
+        mOverlay = new View(getContext());
+        mOverlay.setLayoutParams(overlayParams);
+        mOverlay.setBackgroundColor(Color.TRANSPARENT);
+        addView(mOverlay);
+
+        final LayoutParams playButtonParams = new LayoutParams(mControlSizePx, mControlSizePx);
+        playButtonParams.addRule(RelativeLayout.CENTER_IN_PARENT);
+        mPlayButton = new ImageView(getContext());
+        mPlayButton.setLayoutParams(playButtonParams);
+        mPlayButton.setImageDrawable(Drawables.NATIVE_PLAY.createDrawable(getContext()));
+        addView(mPlayButton);
+
+        mIsInitialized = true;
+        updateViewState();
+    }
+
+    /**
+     * Resets the view, removing all the OnClickListeners and setting the view to hide
+     */
+    public void reset() {
+        setMode(Mode.IMAGE);
+        setPlayButtonClickListener(null);
+        setMuteControlClickListener(null);
+        setVideoClickListener(null);
+    }
+
+    @Override
+    protected void onMeasure(final int widthMeasureSpec, final int heightMeasureSpec) {
+        final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
+        final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
+
+        final int measWidth = MeasureSpec.getSize(widthMeasureSpec);
+        final int measHeight = MeasureSpec.getSize(heightMeasureSpec);
+
+        final int curWidth = getMeasuredWidth();
+        final int curHeight = getMeasuredHeight();
+
+        int finalWidth;
+        if (widthMode == MeasureSpec.EXACTLY) {
+            finalWidth = measWidth;
+        } else if (widthMode == MeasureSpec.AT_MOST) {
+            // Cap width at max width.
+            finalWidth = Math.min(measWidth, curWidth);
+        } else {
+            // MeasWidth is meaningless. Stay with current width.
+            finalWidth = curWidth;
+        }
+
+        // Set height based on width + height constraints.
+        int finalHeight = (int) (ASPECT_MULTIPLIER_WIDTH_TO_HEIGHT * finalWidth);
+
+        // Check if the layout is giving us bounds smaller than we want, conform to those if needed.
+        if (heightMode == MeasureSpec.EXACTLY && measHeight < finalHeight) {
+            finalHeight = measHeight;
+            finalWidth = (int) (ASPECT_MULTIPLIER_HEIGHT_TO_WIDTH * finalHeight);
+        }
+
+        if (Math.abs(finalHeight - curHeight) >= 2
+                || Math.abs(finalWidth - curWidth) >= 2) {
+            MoPubLog.v(String.format("Resetting mediaLayout size to w: %d h: %d", finalWidth, finalHeight));
+            getLayoutParams().width = finalWidth;
+            getLayoutParams().height = finalHeight;
+        }
+
+        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+    }
+
+    public void setMainImageDrawable(@NonNull Drawable drawable) {
+        Preconditions.checkNotNull(drawable);
+        mMainImageView.setImageDrawable(drawable);
+    }
+
+    public void resetProgress() {
+        if (mVideoProgress != null) {
+            mVideoProgress.reset();
+        }
+    }
+
+    public void updateProgress(final int progressTenthPercentage) {
+        if (mVideoProgress != null) {
+            mVideoProgress.updateProgress(progressTenthPercentage);
+        }
+    }
+
+    public TextureView getTextureView() {
+        return mVideoTextureView;
+    }
+
+    public void setMode(@NonNull final Mode mode) {
+        Preconditions.checkNotNull(mode);
+        mMode = mode;
+        post(new Runnable() {
+            @Override
+            public void run() {
+                updateViewState();
+            }
+        });
+    }
+
+    @Nullable
+    public ImageView getMainImageView() {
+        return mMainImageView;
+    }
+
+    public void setMuteControlClickListener(@Nullable OnClickListener muteControlListener) {
+        if (mMuteControl != null) {
+            mMuteControl.setOnClickListener(muteControlListener);
+        }
+    }
+
+    public void setPlayButtonClickListener(@Nullable OnClickListener playButtonListener) {
+        if (mPlayButton != null && mOverlay != null) {
+            mOverlay.setOnClickListener(playButtonListener);
+            mPlayButton.setOnClickListener(playButtonListener);
+        }
+    }
+
+    public void setVideoClickListener(@Nullable OnClickListener videoClickListener) {
+        if (mVideoTextureView != null) {
+            mVideoTextureView.setOnClickListener(videoClickListener);
+        }
+    }
+
+    public void setMuteState(@NonNull final MuteState muteState) {
+        Preconditions.checkNotNull(muteState);
+        if (muteState == mMuteState) {
+            return;
+        }
+        mMuteState = muteState;
+        if (mMuteControl != null) {
+            switch (mMuteState) {
+                case MUTED:
+                    mMuteControl.setImageDrawable(mMutedDrawable);
+                    break;
+                case UNMUTED:
+                default:
+                    mMuteControl.setImageDrawable(mUnmutedDrawable);
+            }
+        }
+    }
+
+    private void updateViewState() {
+        switch (mMode) {
+            case IMAGE:
+                setMainImageVisibility(VISIBLE);
+                setLoadingSpinnerVisibility(INVISIBLE);
+                setVideoControlVisibility(INVISIBLE);
+                setPlayButtonVisibility(INVISIBLE);
+                break;
+            case LOADING:
+                setMainImageVisibility(VISIBLE);
+                setLoadingSpinnerVisibility(VISIBLE);
+                setVideoControlVisibility(INVISIBLE);
+                setPlayButtonVisibility(INVISIBLE);
+                break;
+            case BUFFERING:
+                setMainImageVisibility(INVISIBLE);
+                setLoadingSpinnerVisibility(VISIBLE);
+                setVideoControlVisibility(VISIBLE);
+                setPlayButtonVisibility(INVISIBLE);
+            case PLAYING:
+                setMainImageVisibility(INVISIBLE);
+                setLoadingSpinnerVisibility(INVISIBLE);
+                setVideoControlVisibility(VISIBLE);
+                setPlayButtonVisibility(INVISIBLE);
+                break;
+            case PAUSED:
+                setMainImageVisibility(INVISIBLE);
+                setLoadingSpinnerVisibility(INVISIBLE);
+                setVideoControlVisibility(VISIBLE);
+                setPlayButtonVisibility(VISIBLE);
+                break;
+            case FINISHED:
+                setMainImageVisibility(VISIBLE);
+                setLoadingSpinnerVisibility(INVISIBLE);
+                setVideoControlVisibility(INVISIBLE);
+                setPlayButtonVisibility(VISIBLE);
+                break;
+            default:
+                break;
+        }
+    }
+
+    private void setMainImageVisibility(final int visibility) {
+        mMainImageView.setVisibility(visibility);
+    }
+
+    private void setLoadingSpinnerVisibility(final int visibility) {
+        if (mLoadingSpinner != null) {
+            mLoadingSpinner.setVisibility(visibility);
+        }
+
+        if (mTopGradient != null) {
+            mTopGradient.setVisibility(visibility);
+        }
+    }
+
+    private void setVideoControlVisibility(final int visibility) {
+        if (mBottomGradient != null) {
+            mBottomGradient.setVisibility(visibility);
+        }
+
+        if (mVideoProgress != null) {
+            mVideoProgress.setVisibility(visibility);
+        }
+
+        if (mMuteControl != null) {
+            mMuteControl.setVisibility(visibility);
+        }
+    }
+
+    private void setPlayButtonVisibility(final int visibility) {
+        if (mPlayButton != null && mOverlay != null) {
+            mPlayButton.setVisibility(visibility);
+            mOverlay.setVisibility(visibility);
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MediaViewBinder.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MediaViewBinder.java
new file mode 100644
index 00000000..4b0f9efb
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MediaViewBinder.java
@@ -0,0 +1,99 @@
+package com.mopub.nativeads;
+
+import android.support.annotation.NonNull;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+public class MediaViewBinder {
+    public final static class Builder {
+        private final int layoutId;
+        private int mediaLayoutId;
+        private int titleId;
+        private int textId;
+        private int iconImageId;
+        private int callToActionId;
+        private int privacyInformationIconImageId;
+
+        @NonNull private Map<String, Integer> extras = Collections.emptyMap();
+
+        public Builder(final int layoutId) {
+            this.layoutId = layoutId;
+            this.extras = new HashMap<String, Integer>();
+        }
+
+        @NonNull
+        public final Builder mediaLayoutId(final int mediaLayoutId) {
+            this.mediaLayoutId = mediaLayoutId;
+            return this;
+        }
+
+        @NonNull
+        public final Builder titleId(final int titlteId) {
+            this.titleId = titlteId;
+            return this;
+        }
+
+        @NonNull
+        public final Builder textId(final int textId) {
+            this.textId = textId;
+            return this;
+        }
+
+        @NonNull
+        public final Builder iconImageId(final int iconImageId) {
+            this.iconImageId = iconImageId;
+            return this;
+        }
+
+        @NonNull
+        public final Builder callToActionId(final int callToActionId) {
+            this.callToActionId = callToActionId;
+            return this;
+        }
+
+        @NonNull
+        public final Builder privacyInformationIconImageId(final int privacyInformationIconImageId) {
+            this.privacyInformationIconImageId = privacyInformationIconImageId;
+            return this;
+        }
+
+        @NonNull
+        public final Builder addExtras(final Map<String, Integer> resourceIds) {
+            this.extras = new HashMap<String, Integer>(resourceIds);
+            return this;
+        }
+
+        @NonNull
+        public final Builder addExtra(final String key, final int resourceId) {
+            this.extras.put(key, resourceId);
+            return this;
+        }
+
+        @NonNull
+        public final MediaViewBinder build() {
+            return new MediaViewBinder(this);
+        }
+    }
+
+    final int layoutId;
+    final int mediaLayoutId;
+    final int titleId;
+    final int textId;
+    final int callToActionId;
+    final int iconImageId;
+    final int privacyInformationIconImageId;
+    @NonNull final Map<String, Integer> extras;
+
+    private MediaViewBinder(@NonNull final Builder builder) {
+        this.layoutId = builder.layoutId;
+        this.mediaLayoutId = builder.mediaLayoutId;
+        this.titleId = builder.titleId;
+        this.textId = builder.textId;
+        this.callToActionId = builder.callToActionId;
+        this.iconImageId = builder.iconImageId;
+        this.privacyInformationIconImageId = builder.privacyInformationIconImageId;
+        this.extras = builder.extras;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MediaViewHolder.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MediaViewHolder.java
new file mode 100644
index 00000000..54121e39
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MediaViewHolder.java
@@ -0,0 +1,49 @@
+package com.mopub.nativeads;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.view.View;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+
+class MediaViewHolder {
+    @Nullable View mainView;
+    @Nullable MediaLayout mediaLayout;
+    @Nullable TextView titleView;
+    @Nullable TextView textView;
+    @Nullable ImageView iconImageView;
+    @Nullable TextView callToActionView;
+    @Nullable ImageView privacyInformationIconImageView;
+
+    @VisibleForTesting
+    static final MediaViewHolder EMPTY_MEDIA_VIEW_HOLDER = new MediaViewHolder();
+
+    // Use fromViewBinder instead of a constructor
+    private MediaViewHolder() {}
+
+    @NonNull
+    static MediaViewHolder fromViewBinder(@NonNull final View view,
+            @NonNull final MediaViewBinder mediaViewBinder) {
+        final MediaViewHolder mediaViewHolder = new MediaViewHolder();
+        mediaViewHolder.mainView = view;
+        try {
+            mediaViewHolder.titleView = (TextView) view.findViewById(mediaViewBinder.titleId);
+            mediaViewHolder.textView = (TextView) view.findViewById(mediaViewBinder.textId);
+            mediaViewHolder.callToActionView =
+                    (TextView) view.findViewById(mediaViewBinder.callToActionId);
+            mediaViewHolder.mediaLayout = (MediaLayout) view.findViewById(mediaViewBinder.mediaLayoutId);
+            mediaViewHolder.iconImageView =
+                    (ImageView) view.findViewById(mediaViewBinder.iconImageId);
+            mediaViewHolder.privacyInformationIconImageView =
+                    (ImageView) view.findViewById(mediaViewBinder.privacyInformationIconImageId);
+            return mediaViewHolder;
+        } catch (ClassCastException exception) {
+            MoPubLog.w("Could not cast from id in MediaViewBinder to expected View type",
+                    exception);
+            return EMPTY_MEDIA_VIEW_HOLDER;
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdAdapter.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdAdapter.java
index 314dda0e..18ec136c 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdAdapter.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdAdapter.java
@@ -1,5 +1,6 @@
 package com.mopub.nativeads;
 
+import android.app.Activity;
 import android.content.Context;
 import android.database.DataSetObserver;
 import android.support.annotation.NonNull;
@@ -51,41 +52,41 @@
      * wish to hard-code positions in your app, see {@link MoPubAdAdapter(Context,
      * MoPubClientPositioning)}.
      *
-     * @param context The activity context.
+     * @param activity The activity.
      * @param originalAdapter Your original adapter.
      */
-    public MoPubAdAdapter(@NonNull final Context context, @NonNull final Adapter originalAdapter) {
-        this(context, originalAdapter, MoPubNativeAdPositioning.serverPositioning());
+    public MoPubAdAdapter(@NonNull final Activity activity, @NonNull final Adapter originalAdapter) {
+        this(activity, originalAdapter, MoPubNativeAdPositioning.serverPositioning());
     }
 
     /**
      * Creates a new MoPubAdAdapter object, using server positioning.
      *
-     * @param context The activity context.
+     * @param activity The activity.
      * @param originalAdapter Your original adapter.
      * @param adPositioning A positioning object for specifying where ads will be placed in your
      * stream. See {@link MoPubNativeAdPositioning#serverPositioning()}.
      */
-    public MoPubAdAdapter(@NonNull final Context context,
+    public MoPubAdAdapter(@NonNull final Activity activity,
             @NonNull final Adapter originalAdapter,
             @NonNull final MoPubServerPositioning adPositioning) {
-        this(new MoPubStreamAdPlacer(context, adPositioning), originalAdapter,
-                new VisibilityTracker(context));
+        this(new MoPubStreamAdPlacer(activity, adPositioning), originalAdapter,
+                new VisibilityTracker(activity));
     }
 
     /**
      * Creates a new MoPubAdAdapter object, using client positioning.
      *
-     * @param context The activity context.
+     * @param activity The activity.
      * @param originalAdapter Your original adapter.
      * @param adPositioning A positioning object for specifying where ads will be placed in your
      * stream. See {@link MoPubNativeAdPositioning#clientPositioning()}.
      */
-    public MoPubAdAdapter(@NonNull final Context context,
+    public MoPubAdAdapter(@NonNull final Activity activity,
             @NonNull final Adapter originalAdapter,
             @NonNull final MoPubClientPositioning adPositioning) {
-        this(new MoPubStreamAdPlacer(context, adPositioning), originalAdapter,
-                new VisibilityTracker(context));
+        this(new MoPubStreamAdPlacer(activity, adPositioning), originalAdapter,
+                new VisibilityTracker(activity));
     }
 
     @VisibleForTesting
@@ -123,20 +124,11 @@ public void onAdLoaded(final int position) {
                 handleAdLoaded(position);
             }
 
-            @Override
-            public void onInitialAdLoaded() {
-
-            }
-
             @Override
             public void onAdRemoved(final int position) {
                 handleAdRemoved(position);
             }
 
-            @Override
-            public void onPositionsLoaded() {
-
-            }
         });
 
         mStreamAdPlacer.setItemCount(mOriginalAdapter.getCount());
@@ -159,18 +151,15 @@ void handleAdRemoved(final int position) {
     }
 
     /**
-     * Registers a {@link MoPubNativeAdRenderer} to use when displaying ads in your stream.
+     * Registers a {@link MoPubStaticNativeAdRenderer}, supporting a specific native ad format,
+     * to use when displaying ads in your stream. Note that if multiple ad renderers support
+     * a specific native ad format, the first one registered will be used.
      *
      * This renderer will automatically create and render your view when you call {@link #getView}.
-     * If you register a second renderer, it will replace the first, although this behavior is
-     * subject to change in a future SDK version.
      *
      * @param adRenderer The ad renderer.
-     *
-     * @deprecated in version 3.9.0, use {@link #registerViewBinder(ViewBinder)} instead.
      */
-    @Deprecated
-    public final void registerAdRenderer(@NonNull final MoPubNativeAdRenderer adRenderer) {
+    public final void registerAdRenderer(@NonNull final MoPubAdRenderer adRenderer) {
         if (!Preconditions.NoThrow.checkNotNull(
                 adRenderer, "Tried to set a null ad renderer on the placer.")) {
             return;
@@ -178,23 +167,6 @@ public final void registerAdRenderer(@NonNull final MoPubNativeAdRenderer adRend
         mStreamAdPlacer.registerAdRenderer(adRenderer);
     }
 
-    /**
-     * Registers a {@link ViewBinder} to use when displaying ads in your stream.
-     *
-     * This binder will be used automatically to create and render your view when you call
-     * {@link #getView}. If you register a second {@link ViewBinder}, it will replace the first,
-     * although this behavior is subject to change in a future SDK version.
-     *
-     * @param viewBinder The view binder
-     */
-    public final void registerViewBinder(@NonNull final ViewBinder viewBinder) {
-        if (!Preconditions.NoThrow.checkNotNull(
-                viewBinder, "Tried to set a null view binder on the placer.")) {
-            return;
-        }
-        mStreamAdPlacer.registerAdRenderer(new MoPubNativeAdRenderer(viewBinder));
-    }
-
     /**
      * Sets a listener that will be called after the SDK loads new ads from the server and places
      * them into your stream.
@@ -239,7 +211,7 @@ public void loadAds(@NonNull final String adUnitId) {
      */
     public void loadAds(@NonNull final String adUnitId,
             @Nullable final RequestParameters requestParameters) {
-        mStreamAdPlacer.loadAds(adUnitId, requestParameters,null);
+        mStreamAdPlacer.loadAds(adUnitId, requestParameters);
     }
 
     /**
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdRenderer.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdRenderer.java
index 686b3c52..e79548bb 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdRenderer.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdRenderer.java
@@ -1,6 +1,6 @@
 package com.mopub.nativeads;
 
-import android.content.Context;
+import android.app.Activity;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.view.View;
@@ -9,28 +9,28 @@
 /**
  * An interface for creating ad views and rendering them using ad data.
  *
- * Normally you will use the subclass {@link com.mopub.nativeads.MoPubNativeAdRenderer} with {@link
+ * Normally you will use the subclass {@link MoPubStaticNativeAdRenderer} with {@link
  * com.mopub.nativeads.ViewBinder} to customize your ad view with your own layout. However, if you
  * wish to programmatically create or manage your ad view, you can implement {@code MoPubAdRenderer}
  * directly.
  *
  * @param <T> The ad payload type.
  */
-public interface MoPubAdRenderer<T> {
+public interface MoPubAdRenderer<T extends BaseNativeAd> {
     /**
      * Creates a new view to be used as an ad.
      *
      * This method is called when you call {@link com.mopub.nativeads.MoPubStreamAdPlacer#getAdView}
      * and the convertView is null. You must return a valid view.
      *
-     * @param context The context. Useful for creating a view.
+     * @param activity The activity. Useful for creating a view.
      * @param parent The parent that the view will eventually be attached to. You might use the
      * parent to determine layout parameters, but should return the view without attaching it to the
      * parent.
      * @return A new ad view.
      */
     @NonNull
-    View createAdView(@NonNull Context context, @Nullable ViewGroup parent);
+    View createAdView(@NonNull Activity activity, @Nullable ViewGroup parent);
 
     /**
      * Renders a view created by {@link #createAdView} by filling it with ad data.
@@ -39,4 +39,12 @@
      * @param ad The ad data that should be bound to the view.
      */
     void renderAdView(@NonNull View view, @NonNull T ad);
+
+    /**
+     * Determines if this renderer supports the type of native ad passed in.
+     *
+     * @param nativeAd The native ad to render.
+     * @return True if the renderer can render the native ad and false if it cannot.
+     */
+    boolean supports(@NonNull BaseNativeAd nativeAd);
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubCustomEventNative.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubCustomEventNative.java
index 327ef4f8..47f19090 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubCustomEventNative.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubCustomEventNative.java
@@ -1,5 +1,6 @@
 package com.mopub.nativeads;
 
+import android.app.Activity;
 import android.content.Context;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
@@ -7,8 +8,7 @@
 
 import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
-import com.mopub.nativeads.events.NativeAdEventsObserver;
-import com.mopub.nativeads.events.NativeAdType;
+import com.mopub.nativeads.NativeImageHelper.ImageListener;
 
 import org.json.JSONArray;
 import org.json.JSONException;
@@ -24,12 +24,12 @@
 
 import static com.mopub.common.DataKeys.JSON_BODY_KEY;
 import static com.mopub.common.util.Numbers.parseDouble;
-import static com.mopub.nativeads.NativeResponse.Parameter;
+import static com.mopub.nativeads.NativeImageHelper.preCacheImages;
 
 public class MoPubCustomEventNative extends CustomEventNative {
 
     @Override
-    protected void loadNativeAd(@NonNull final Context context,
+    protected void loadNativeAd(@NonNull final Activity activity,
             @NonNull final CustomEventNativeListener customEventNativeListener,
             @NonNull final Map<String, Object> localExtras,
             @NonNull final Map<String, String> serverExtras) {
@@ -37,36 +37,88 @@ protected void loadNativeAd(@NonNull final Context context,
         Object json = localExtras.get(JSON_BODY_KEY);
         // null or non-JSONObjects should not be passed in localExtras as JSON_BODY_KEY
         if (!(json instanceof JSONObject)) {
-            customEventNativeListener.onNativeAdFailed(NativeErrorCode.INVALID_JSON);
+            customEventNativeListener.onNativeAdFailed(NativeErrorCode.INVALID_RESPONSE);
             return;
         }
 
-        final MoPubForwardingNativeAd moPubForwardingNativeAd =
-                new MoPubForwardingNativeAd(context.getApplicationContext(),
+        final MoPubStaticNativeAd moPubStaticNativeAd =
+                new MoPubStaticNativeAd(activity,
                         (JSONObject) json,
+                        new ImpressionTracker(activity),
+                        new NativeClickHandler(activity),
                         customEventNativeListener);
 
         try {
-            moPubForwardingNativeAd.loadAd();
+            moPubStaticNativeAd.loadAd();
         } catch (IllegalArgumentException e) {
             customEventNativeListener.onNativeAdFailed(NativeErrorCode.UNSPECIFIED);
         }
     }
 
-    static class MoPubForwardingNativeAd extends BaseForwardingNativeAd {
+    static class MoPubStaticNativeAd extends StaticNativeAd {
+        enum Parameter {
+            IMPRESSION_TRACKER("imptracker", true),
+            CLICK_TRACKER("clktracker", true),
+
+            TITLE("title", false),
+            TEXT("text", false),
+            MAIN_IMAGE("mainimage", false),
+            ICON_IMAGE("iconimage", false),
+
+            CLICK_DESTINATION("clk", false),
+            FALLBACK("fallback", false),
+            CALL_TO_ACTION("ctatext", false),
+            STAR_RATING("starrating", false);
+
+            @NonNull final String name;
+            final boolean required;
+
+            Parameter(@NonNull final String name, final boolean required) {
+                this.name = name;
+                this.required = required;
+            }
+
+            @Nullable
+            static Parameter from(@NonNull final String name) {
+                for (final Parameter parameter : values()) {
+                    if (parameter.name.equals(name)) {
+                        return parameter;
+                    }
+                }
+
+                return null;
+            }
+
+            @NonNull
+            @VisibleForTesting
+            static final Set<String> requiredKeys = new HashSet<String>();
+            static {
+                for (final Parameter parameter : values()) {
+                    if (parameter.required) {
+                        requiredKeys.add(parameter.name);
+                    }
+                }
+            }
+        }
 
         @VisibleForTesting
-        static final String DAA_CLICKTHROUGH_URL = "https://www.mopub.com/optout";
+        static final String PRIVACY_INFORMATION_CLICKTHROUGH_URL = "https://www.mopub.com/optout";
 
         @NonNull private final Context mContext;
         @NonNull private final CustomEventNativeListener mCustomEventNativeListener;
         @NonNull private final JSONObject mJsonObject;
+        @NonNull private final ImpressionTracker mImpressionTracker;
+        @NonNull private final NativeClickHandler mNativeClickHandler;
 
-        MoPubForwardingNativeAd(@NonNull final Context context,
+        MoPubStaticNativeAd(@NonNull final Context context,
                 @NonNull final JSONObject jsonBody,
+                @NonNull final ImpressionTracker impressionTracker,
+                @NonNull final NativeClickHandler nativeClickHandler,
                 @NonNull final CustomEventNativeListener customEventNativeListener) {
             mJsonObject = jsonBody;
-            mContext = context;
+            mContext = context.getApplicationContext();
+            mImpressionTracker = impressionTracker;
+            mNativeClickHandler = nativeClickHandler;
             mCustomEventNativeListener = customEventNativeListener;
         }
 
@@ -90,11 +142,12 @@ void loadAd() throws IllegalArgumentException {
                     addExtra(key, mJsonObject.opt(key));
                 }
             }
+            setPrivacyInformationIconClickThroughUrl(PRIVACY_INFORMATION_CLICKTHROUGH_URL);
 
             preCacheImages(mContext, getAllImageUrls(), new ImageListener() {
                 @Override
                 public void onImagesCached() {
-                    mCustomEventNativeListener.onNativeAdLoaded(MoPubForwardingNativeAd.this);
+                    mCustomEventNativeListener.onNativeAdLoaded(MoPubStaticNativeAd.this);
                 }
 
                 @Override
@@ -127,11 +180,12 @@ private void addInstanceVariable(@NonNull final Parameter key,
                     case IMPRESSION_TRACKER:
                         addImpressionTrackers(value);
                         break;
-                    case CLICK_TRACKER:
-                        break;
                     case CLICK_DESTINATION:
                         setClickDestinationUrl((String) value);
                         break;
+                    case CLICK_TRACKER:
+                        parseClickTrackers(value);
+                        break;
                     case CALL_TO_ACTION:
                         setCallToAction((String) value);
                         break;
@@ -157,19 +211,11 @@ private void addInstanceVariable(@NonNull final Parameter key,
             }
         }
 
-        private void addImpressionTrackers(final Object impressionTrackers) throws ClassCastException {
-            if (!(impressionTrackers instanceof JSONArray)) {
-                throw new ClassCastException("Expected impression trackers of type JSONArray.");
-            }
-
-            final JSONArray trackers = (JSONArray) impressionTrackers;
-            for (int i = 0; i < trackers.length(); i++) {
-                try {
-                    addImpressionTracker(trackers.getString(i));
-                } catch (JSONException e) {
-                    // This will only occur if we access a non-existent index in JSONArray.
-                    MoPubLog.d("Unable to parse impression trackers.");
-                }
+        private void parseClickTrackers(@NonNull final Object clickTrackers) {
+            if (clickTrackers instanceof JSONArray) {
+                addClickTrackers(clickTrackers);
+            } else {
+                addClickTracker((String) clickTrackers);
             }
         }
 
@@ -203,22 +249,34 @@ private boolean isImageKey(@Nullable final String name) {
             return imageUrls;
         }
 
+        // Lifecycle Handlers
+        @Override
+        public void prepare(@NonNull final View view) {
+            mImpressionTracker.addView(view, this);
+            mNativeClickHandler.setOnClickListener(view, this);
+        }
+
         @Override
-        public String getDaaIconClickthroughUrl() {
-            return DAA_CLICKTHROUGH_URL;
+        public void clear(@NonNull final View view) {
+            mImpressionTracker.removeView(view);
+            mNativeClickHandler.clearOnClickListener(view);
         }
 
         @Override
-        public void handleClick(@Nullable View view) {
-            super.handleClick(view);
-            NativeAdEventsObserver.instance().onAdClicked(NativeAdType.Mopub);
+        public void destroy() {
+            mImpressionTracker.destroy();
         }
 
+        // Event Handlers
         @Override
-        public void recordImpression() {
-            super.recordImpression();
-            NativeAdEventsObserver.instance().onAdImpressed(NativeAdType.Mopub);
+        public void recordImpression(@NonNull final View view) {
+            notifyAdImpressed();
+        }
 
+        @Override
+        public void handleClick(@Nullable final View view) {
+            notifyAdClicked();
+            mNativeClickHandler.openClickDestinationUrl(getClickDestinationUrl(), view);
         }
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubCustomEventVideoNative.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubCustomEventVideoNative.java
new file mode 100644
index 00000000..363acc00
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubCustomEventVideoNative.java
@@ -0,0 +1,929 @@
+package com.mopub.nativeads;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.content.Context;
+import android.graphics.SurfaceTexture;
+import android.media.AudioManager;
+import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+import android.view.TextureView;
+import android.view.View;
+
+import com.mopub.common.DataKeys;
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.event.BaseEvent;
+import com.mopub.common.event.Event;
+import com.mopub.common.event.EventDetails;
+import com.mopub.common.event.MoPubEvents;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Utils;
+import com.mopub.mobileads.MraidVideoPlayerActivity;
+import com.mopub.mobileads.VastManager;
+import com.mopub.mobileads.VastTracker;
+import com.mopub.mobileads.VastVideoConfig;
+import com.mopub.mobileads.VideoViewabilityTracker;
+import com.mopub.mobileads.factories.VastManagerFactory;
+import com.mopub.nativeads.NativeVideoController.NativeVideoProgressRunnable;
+import com.mopub.network.TrackingRequest;
+
+import org.json.JSONArray;
+import org.json.JSONObject;
+
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Set;
+
+import static com.mopub.common.DataKeys.EVENT_DETAILS;
+import static com.mopub.common.DataKeys.IMPRESSION_MIN_VISIBLE_PERCENT;
+import static com.mopub.common.DataKeys.IMPRESSION_VISIBLE_MS;
+import static com.mopub.common.DataKeys.JSON_BODY_KEY;
+import static com.mopub.common.DataKeys.MAX_BUFFER_MS;
+import static com.mopub.common.DataKeys.PAUSE_VISIBLE_PERCENT;
+import static com.mopub.common.DataKeys.PLAY_VISIBLE_PERCENT;
+import static com.mopub.nativeads.NativeImageHelper.preCacheImages;
+import static com.mopub.nativeads.NativeVideoController.VisibilityTrackingEvent;
+
+@TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+public class MoPubCustomEventVideoNative extends CustomEventNative {
+
+    @Override
+    protected void loadNativeAd(@NonNull final Activity activity,
+            @NonNull final CustomEventNativeListener customEventNativeListener,
+            @NonNull final Map<String, Object> localExtras,
+            @NonNull final Map<String, String> serverExtras) {
+        final Object json = localExtras.get(JSON_BODY_KEY);
+        // null or non-JSONObjects should not be passed in localExtras as JSON_BODY_KEY
+        if (!(json instanceof JSONObject)) {
+            customEventNativeListener.onNativeAdFailed(NativeErrorCode.INVALID_RESPONSE);
+            return;
+        }
+
+        final Object eventDetailsObject = localExtras.get(EVENT_DETAILS);
+        final EventDetails eventDetails = eventDetailsObject instanceof EventDetails ?
+                (EventDetails) eventDetailsObject : null;
+
+        final VideoResponseHeaders videoResponseHeaders = new VideoResponseHeaders(serverExtras);
+        if (!videoResponseHeaders.hasValidHeaders()) {
+            customEventNativeListener.onNativeAdFailed(NativeErrorCode.INVALID_RESPONSE);
+            return;
+        }
+
+        final Object clickTrackingUrlFromHeaderObject =
+                localExtras.get(DataKeys.CLICK_TRACKING_URL_KEY);
+        // Ensure click tracking url is a non-empty String
+        if (!(clickTrackingUrlFromHeaderObject instanceof String) ||
+                TextUtils.isEmpty((String) clickTrackingUrlFromHeaderObject)) {
+            customEventNativeListener.onNativeAdFailed(NativeErrorCode.UNSPECIFIED);
+            return;
+        }
+
+        final String clickTrackingUrlFromHeader = (String) clickTrackingUrlFromHeaderObject;
+        final MoPubVideoNativeAd videoNativeAd = new MoPubVideoNativeAd(activity, (JSONObject) json,
+                customEventNativeListener, videoResponseHeaders, eventDetails,
+                clickTrackingUrlFromHeader);
+        try {
+            videoNativeAd.loadAd();
+        } catch (IllegalArgumentException e) {
+            customEventNativeListener.onNativeAdFailed(NativeErrorCode.UNSPECIFIED);
+        }
+    }
+
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+    public static class MoPubVideoNativeAd extends VideoNativeAd
+            implements VastManager.VastManagerListener, NativeVideoProgressRunnable.ProgressListener,
+            AudioManager.OnAudioFocusChangeListener {
+
+        enum Parameter {
+            IMPRESSION_TRACKER("imptracker", true),
+            CLICK_TRACKER("clktracker", true),
+            TITLE("title", false),
+            TEXT("text", false),
+            IMAGE_URL("mainimage", false),
+            ICON_URL("iconimage", false),
+            CLICK_DESTINATION("clk", false),
+            FALLBACK("fallback", false),
+            CALL_TO_ACTION("ctatext", false),
+            VAST_VIDEO("video", false);
+
+            @NonNull final String mName;
+            final boolean mRequired;
+
+            Parameter(@NonNull final String name, final boolean required) {
+                Preconditions.checkNotNull(name);
+                mName = name;
+                mRequired = required;
+            }
+
+            @Nullable
+            static Parameter from(@NonNull final String name) {
+                Preconditions.checkNotNull(name);
+                for (final Parameter parameter : values()) {
+                    if (parameter.mName.equals(name)) {
+                        return parameter;
+                    }
+                }
+
+                return null;
+            }
+
+            @NonNull
+            @VisibleForTesting
+            static final Set<String> requiredKeys = new HashSet<String>();
+            static {
+                for (final Parameter parameter : values()) {
+                    if (parameter.mRequired) {
+                        requiredKeys.add(parameter.mName);
+                    }
+                }
+            }
+        }
+
+        public enum VideoState {
+            CREATED, LOADING, BUFFERING, PAUSED, PLAYING, PLAYING_MUTED, ENDED, FAILED_LOAD
+        }
+
+        static final String PRIVACY_INFORMATION_CLICKTHROUGH_URL = "https://www.mopub.com/optout/";
+
+        @NonNull private final Context mContext;
+        @NonNull private final JSONObject mJsonObject;
+        @NonNull private VideoState mVideoState;
+        @NonNull private final VisibilityTracker mVideoVisibleTracking;
+        @NonNull private final String mMoPubClickTrackingUrl;
+        @NonNull private final CustomEventNativeListener mCustomEventNativeListener;
+        @NonNull private final VideoResponseHeaders mVideoResponseHeaders;
+        @NonNull private final NativeVideoControllerFactory mNativeVideoControllerFactory;
+        @Nullable private NativeVideoController mNativeVideoController;
+
+        // We need to hold a reference to the VastManager because internal VAST classes
+        // hold only weak refs to this.
+        @NonNull private final VastManager mVastManager;
+        @Nullable VastVideoConfig mVastVideoConfig;
+        @Nullable private MediaLayout mMediaLayout;
+        @Nullable private View mRootView;
+        @Nullable private final EventDetails mEventDetails;
+
+        private final long mId;
+        private boolean mNeedsSeek;
+        private boolean mNeedsPrepare;
+        private boolean mPauseCanBeTracked = false;
+        private boolean mResumeCanBeTracked = false;
+
+        // These variables influence video state.
+        private int mLatestVideoControllerState;
+        private boolean mError;
+        private boolean mLatestVisibility;
+        private boolean mMuted;
+        private boolean mEnded;
+
+        public MoPubVideoNativeAd(
+                @NonNull final Activity activity,
+                @NonNull final JSONObject jsonObject,
+                @NonNull final CustomEventNativeListener customEventNativeListener,
+                @NonNull final VideoResponseHeaders videoResponseHeaders,
+                @Nullable final EventDetails eventDetails,
+                @NonNull final String clickTrackingUrl) {
+            this(activity, jsonObject, customEventNativeListener, videoResponseHeaders,
+                    new VisibilityTracker(activity), new NativeVideoControllerFactory(),
+                    eventDetails, clickTrackingUrl, VastManagerFactory.create(activity.getApplicationContext(), false));
+        }
+
+        @VisibleForTesting
+        MoPubVideoNativeAd(
+                @NonNull final Activity activity,
+                @NonNull final JSONObject jsonObject,
+                @NonNull final CustomEventNativeListener customEventNativeListener,
+                @NonNull final VideoResponseHeaders videoResponseHeaders,
+                @NonNull final VisibilityTracker visibilityTracker,
+                @NonNull final NativeVideoControllerFactory nativeVideoControllerFactory,
+                @Nullable final EventDetails eventDetails,
+                @NonNull final String clickTrackingUrl,
+                @NonNull final VastManager vastManager) {
+            Preconditions.checkNotNull(activity);
+            Preconditions.checkNotNull(jsonObject);
+            Preconditions.checkNotNull(customEventNativeListener);
+            Preconditions.checkNotNull(videoResponseHeaders);
+            Preconditions.checkNotNull(visibilityTracker);
+            Preconditions.checkNotNull(nativeVideoControllerFactory);
+            Preconditions.checkNotNull(clickTrackingUrl);
+            Preconditions.checkNotNull(vastManager);
+
+            mContext = activity.getApplicationContext();
+            mJsonObject = jsonObject;
+            mCustomEventNativeListener = customEventNativeListener;
+            mVideoResponseHeaders = videoResponseHeaders;
+
+            mNativeVideoControllerFactory = nativeVideoControllerFactory;
+            mMoPubClickTrackingUrl = clickTrackingUrl;
+
+            mEventDetails = eventDetails;
+
+            mId = Utils.generateUniqueId();
+            mNeedsSeek = true;
+            mVideoState = VideoState.CREATED;
+
+            mNeedsPrepare = true;
+            mLatestVideoControllerState = NativeVideoController.STATE_IDLE;
+            mMuted = true;
+            mVideoVisibleTracking = visibilityTracker;
+            mVideoVisibleTracking.setVisibilityTrackerListener(new VisibilityTracker
+                    .VisibilityTrackerListener() {
+                @Override
+                public void onVisibilityChanged(final List<View> visibleViews,
+                        final List<View> invisibleViews) {
+                    if (!visibleViews.isEmpty() && !mLatestVisibility) { // State transition
+                        mLatestVisibility = true;
+                        maybeChangeState();
+                    } else if (!invisibleViews.isEmpty() && mLatestVisibility) { // state transition
+                        mLatestVisibility = false;
+                        maybeChangeState();
+                    }
+                }
+            });
+            mVastManager = vastManager;
+        }
+
+        void loadAd() throws IllegalArgumentException {
+            if (!containsRequiredKeys(mJsonObject)) {
+                throw new IllegalArgumentException("JSONObject did not contain required keys.");
+            }
+
+            final Iterator<String> keys = mJsonObject.keys();
+            while (keys.hasNext()) {
+                final String key = keys.next();
+                final Parameter parameter = Parameter.from(key);
+
+                if (parameter != null) {
+                    try {
+                        addInstanceVariable(parameter, mJsonObject.opt(key));
+                    } catch (ClassCastException e) {
+                        throw new IllegalArgumentException("JSONObject key (" + key
+                                + ") contained unexpected value.");
+                    }
+                } else {
+                    addExtra(key, mJsonObject.opt(key));
+                }
+            }
+            setPrivacyInformationIconClickThroughUrl(PRIVACY_INFORMATION_CLICKTHROUGH_URL);
+
+            preCacheImages(mContext, getAllImageUrls(), new NativeImageHelper.ImageListener() {
+                @Override
+                public void onImagesCached() {
+                    mVastManager.prepareVastVideoConfiguration(getVastVideo(),
+                            MoPubVideoNativeAd.this, mContext);
+                }
+
+                @Override
+                public void onImagesFailedToCache(final NativeErrorCode errorCode) {
+                    mCustomEventNativeListener.onNativeAdFailed(errorCode);
+                }
+            });
+        }
+
+        @Override
+        public void onVastVideoConfigurationPrepared(@Nullable VastVideoConfig vastVideoConfig) {
+            if (vastVideoConfig == null) {
+                mCustomEventNativeListener.onNativeAdFailed(NativeErrorCode.INVALID_RESPONSE);
+                return;
+            }
+
+            final List<NativeVideoController.VisibilityTrackingEvent> visibilityTrackingEvents =
+                    new ArrayList<VisibilityTrackingEvent>();
+
+            // Custom visibility tracking event from http response headers
+            final VisibilityTrackingEvent visibilityTrackingEvent = new VisibilityTrackingEvent();
+            visibilityTrackingEvent.strategy = new HeaderVisibilityStrategy(this);
+            visibilityTrackingEvent.minimumPercentageVisible =
+                    mVideoResponseHeaders.getImpressionMinVisiblePercent();
+            visibilityTrackingEvent.totalRequiredPlayTimeMs =
+                    mVideoResponseHeaders.getImpressionVisibleMs();
+            visibilityTrackingEvents.add(visibilityTrackingEvent);
+
+            // Visibility tracking event from http response Vast payload
+            mVastVideoConfig = vastVideoConfig;
+            final VideoViewabilityTracker vastVideoViewabilityTracker =
+                    mVastVideoConfig.getVideoViewabilityTracker();
+            if (vastVideoViewabilityTracker != null) {
+                final VisibilityTrackingEvent vastVisibilityTrackingEvent =
+                        new VisibilityTrackingEvent();
+                vastVisibilityTrackingEvent.strategy =
+                        new PayloadVisibilityStrategy(mContext,
+                                vastVideoViewabilityTracker.getTrackingUrl());
+                vastVisibilityTrackingEvent.minimumPercentageVisible =
+                        vastVideoViewabilityTracker.getPercentViewable();
+                vastVisibilityTrackingEvent.totalRequiredPlayTimeMs =
+                        vastVideoViewabilityTracker.getViewablePlaytimeMS();
+                visibilityTrackingEvents.add(vastVisibilityTrackingEvent);
+            }
+
+            Set<String> clickTrackers = new HashSet<String>();
+            clickTrackers.add(mMoPubClickTrackingUrl);
+            clickTrackers.addAll(getClickTrackers());
+
+            final ArrayList<VastTracker> vastClickTrackers = new ArrayList<VastTracker>();
+            for (String clickTrackingUrl : clickTrackers) {
+                vastClickTrackers.add(new VastTracker(clickTrackingUrl, false));
+            }
+            mVastVideoConfig.addClickTrackers(vastClickTrackers);
+
+            // Always use click destination URL from JSON "clk" value instead of from VAST document
+            mVastVideoConfig.setClickThroughUrl(getClickDestinationUrl());
+
+            mNativeVideoController = mNativeVideoControllerFactory.createForId(
+                    mId, mContext, visibilityTrackingEvents, mVastVideoConfig, mEventDetails);
+
+            mCustomEventNativeListener.onNativeAdLoaded(this);
+        }
+
+        private boolean containsRequiredKeys(@NonNull final JSONObject jsonObject) {
+            Preconditions.checkNotNull(jsonObject);
+
+            final Set<String> keys = new HashSet<String>();
+            final Iterator<String> jsonKeys = jsonObject.keys();
+            while (jsonKeys.hasNext()) {
+                keys.add(jsonKeys.next());
+            }
+
+            return keys.containsAll(Parameter.requiredKeys);
+        }
+
+        private void addInstanceVariable(@NonNull final Parameter key,
+                @Nullable final Object value) throws ClassCastException {
+            Preconditions.checkNotNull(key);
+            Preconditions.checkNotNull(value);
+
+            try {
+                switch (key) {
+                    case IMPRESSION_TRACKER:
+                        addImpressionTrackers(value);
+                        break;
+                    case TITLE:
+                        setTitle((String) value);
+                        break;
+                    case TEXT:
+                        setText((String) value);
+                        break;
+                    case IMAGE_URL:
+                        setMainImageUrl((String) value);
+                        break;
+                    case ICON_URL:
+                        setIconImageUrl((String) value);
+                        break;
+                    case CLICK_DESTINATION:
+                        setClickDestinationUrl((String) value);
+                        break;
+                    case CLICK_TRACKER:
+                        parseClickTrackers(value);
+                        break;
+                    case CALL_TO_ACTION:
+                        setCallToAction((String) value);
+                        break;
+                    case VAST_VIDEO:
+                        setVastVideo((String) value);
+                        break;
+                    default:
+                        MoPubLog.d("Unable to add JSON key to internal mapping: " + key.mName);
+                        break;
+                }
+            } catch (ClassCastException e) {
+                if (!key.mRequired) {
+                    MoPubLog.d("Ignoring class cast exception for optional key: " + key.mName);
+                } else {
+                    throw e;
+                }
+            }
+        }
+
+        private void parseClickTrackers(@NonNull final Object clickTrackers) {
+            if (clickTrackers instanceof JSONArray) {
+                addClickTrackers(clickTrackers);
+            } else {
+                addClickTracker((String) clickTrackers);
+            }
+        }
+
+        @Override
+        public void render(@NonNull MediaLayout mediaLayout) {
+            Preconditions.checkNotNull(mediaLayout);
+
+            mVideoVisibleTracking.addView(mRootView,
+                    mediaLayout,
+                    mVideoResponseHeaders.getPlayVisiblePercent(),
+                    mVideoResponseHeaders.getPauseVisiblePercent());
+
+            mMediaLayout = mediaLayout;
+            mMediaLayout.initForVideo();
+
+            mMediaLayout.setSurfaceTextureListener(new TextureView.SurfaceTextureListener() {
+                @Override
+                public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int
+                        height) {
+
+                    mNativeVideoController.setListener(MoPubVideoNativeAd.this);
+                    mNativeVideoController.setOnAudioFocusChangeListener(MoPubVideoNativeAd.this);
+                    mNativeVideoController.setProgressListener(MoPubVideoNativeAd.this);
+                    mNativeVideoController.setTextureView(mMediaLayout.getTextureView());
+                    mMediaLayout.resetProgress();
+
+                    // If we're returning to an ended video, make a note of that so we don't flash
+                    // a bunch of UI changes while we prepare the data.
+                    final long duration = mNativeVideoController.getDuration();
+                    final long currentPosition = mNativeVideoController.getCurrentPosition();
+                    if (mLatestVideoControllerState == NativeVideoController.STATE_ENDED
+                        || (duration > 0 && duration - currentPosition < NativeVideoController.RESUME_FINISHED_THRESHOLD)) {
+                        mEnded = true;
+                    }
+
+                    if (mNeedsPrepare) {
+                        mNeedsPrepare = false;
+                        mNativeVideoController.prepare(MoPubVideoNativeAd.this);
+                    }
+
+                    mNeedsSeek = true;
+                    maybeChangeState();
+                }
+
+                @Override
+                public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width,
+                        int height) { }
+
+                @Override
+                public boolean onSurfaceTextureDestroyed(final SurfaceTexture surface) {
+                    mNeedsPrepare = true;
+                    mNativeVideoController.release(MoPubVideoNativeAd.this);
+                    applyState(VideoState.PAUSED);
+                    return true;
+                }
+
+                @Override
+                public void onSurfaceTextureUpdated(SurfaceTexture surface) { }
+            });
+
+            mMediaLayout.setPlayButtonClickListener(new View.OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    mMediaLayout.resetProgress();
+                    mNativeVideoController.seekTo(0);
+                    mEnded = false;
+                    mNeedsSeek = false;
+                }
+            });
+
+            mMediaLayout.setMuteControlClickListener(new View.OnClickListener() {
+                @Override
+                public void onClick(final View v) {
+                    mMuted = !mMuted;
+                    maybeChangeState();
+                }
+            });
+
+            mMediaLayout.setOnClickListener(new View.OnClickListener() {
+                @Override
+                public void onClick(final View v) {
+                    prepareToLeaveView();
+                    mNativeVideoController.triggerImpressionTrackers();
+                    MraidVideoPlayerActivity.startNativeVideo(mContext, mId, mVastVideoConfig);
+                }
+            });
+
+            if (mNativeVideoController.getPlaybackState() == NativeVideoController.STATE_CLEARED) {
+                mNativeVideoController.prepare(this);
+            }
+
+            applyState(VideoState.PAUSED);
+        }
+
+        // Lifecycle Handlers
+        @Override
+        public void prepare(@NonNull final View view) {
+            Preconditions.checkNotNull(view);
+            mRootView = view;
+            mRootView.setOnClickListener(new View.OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    prepareToLeaveView();
+                    // No need to call notifyAdClicked since handleCtaClick does clickTracking
+                    mNativeVideoController.triggerImpressionTrackers();
+                    mNativeVideoController.handleCtaClick(mContext);
+                }
+            });
+        }
+
+        @Override
+        public void clear(@NonNull final View view) {
+            Preconditions.checkNotNull(view);
+            mNativeVideoController.clear();
+            cleanUpMediaLayout();
+        }
+
+        @Override
+        public void destroy() {
+            cleanUpMediaLayout();
+            mNativeVideoController.setPlayWhenReady(false);
+            mNativeVideoController.release(this);
+            NativeVideoController.remove(mId);
+            mVideoVisibleTracking.destroy();
+        }
+
+        @Override
+        public void onStateChanged(final boolean playWhenReady, final int playbackState) {
+            mLatestVideoControllerState = playbackState;
+            maybeChangeState();
+        }
+
+        @Override
+        public void onError(final Exception e) {
+            MoPubLog.w("Error playing back video.", e);
+            mError = true;
+            maybeChangeState();
+        }
+
+        @Override
+        public void updateProgress(final int progressTenthPercent) {
+            mMediaLayout.updateProgress(progressTenthPercent);
+        }
+
+        @Override
+        public void onAudioFocusChange(int focusChange) {
+            if (focusChange == AudioManager.AUDIOFOCUS_LOSS
+                    || focusChange == AudioManager.AUDIOFOCUS_LOSS_TRANSIENT) {
+                // Mute the video
+                mMuted = true;
+                maybeChangeState();
+            } else if (focusChange == AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK) {
+                // Lower the volume
+                mNativeVideoController.setAudioVolume(0.3f);
+            } else if (focusChange == AudioManager.AUDIOFOCUS_GAIN) {
+                // Resume playback
+                mNativeVideoController.setAudioVolume(1.0f);
+                maybeChangeState();
+            }
+        }
+
+        private void cleanUpMediaLayout() {
+            // When clearing, we also clear medialayout references so if we're rendered again
+            // with the same view, we reset the video state correctly.
+            if (mMediaLayout != null) {
+                mMediaLayout.setMode(MediaLayout.Mode.IMAGE);
+                mMediaLayout.setSurfaceTextureListener(null);
+                mMediaLayout.setPlayButtonClickListener(null);
+                mMediaLayout.setMuteControlClickListener(null);
+                mMediaLayout.setOnClickListener(null);
+                mVideoVisibleTracking.removeView(mMediaLayout);
+                mMediaLayout = null;
+            }
+        }
+
+        private void prepareToLeaveView() {
+            mNeedsSeek = true;
+            mNeedsPrepare = true;
+
+            // Clean up any references to this class when storing the NativeVideoController
+            // in a static location and starting a new activity
+            mNativeVideoController.setListener(null);
+            mNativeVideoController.setOnAudioFocusChangeListener(null);
+            mNativeVideoController.setProgressListener(null);
+            mNativeVideoController.clear();
+
+            applyState(VideoState.PAUSED, true);
+        }
+
+        private void maybeChangeState() {
+            VideoState newState = mVideoState;
+
+            if (mError) {
+                newState = VideoState.FAILED_LOAD;
+            } else if (mEnded) {
+                newState = VideoState.ENDED;
+            } else {
+                if (mLatestVideoControllerState == NativeVideoController.STATE_PREPARING
+                        || mLatestVideoControllerState == NativeVideoController.STATE_IDLE) {
+                    newState = VideoState.LOADING;
+                } else if (mLatestVideoControllerState == NativeVideoController.STATE_BUFFERING) {
+                    newState = VideoState.BUFFERING;
+                } else if (mLatestVideoControllerState == NativeVideoController.STATE_ENDED) {
+                    mEnded = true;
+                    newState = VideoState.ENDED;
+                } else if (mLatestVideoControllerState == NativeVideoController.STATE_READY) {
+                    if (mLatestVisibility) {
+                        newState = mMuted ? VideoState.PLAYING_MUTED : VideoState.PLAYING;
+                    } else {
+                        newState = VideoState.PAUSED;
+                    }
+                }
+            }
+
+            applyState(newState);
+        }
+
+        @VisibleForTesting
+        void applyState(@NonNull final VideoState videoState) {
+            applyState(videoState, false);
+        }
+
+        @VisibleForTesting
+        void applyState(@NonNull final VideoState videoState, boolean transitionToFullScreen) {
+            Preconditions.checkNotNull(videoState);
+
+            // Check and set mVideoState so any changes we make to exo state don't
+            // trigger a duplicate run of this.
+            if (mVideoState == videoState) {
+                return;
+            }
+            VideoState previousState = mVideoState;
+            mVideoState = videoState;
+
+            switch (videoState) {
+                case FAILED_LOAD:
+                    mVastVideoConfig.handleError(mContext, null, 0);
+                    mNativeVideoController.setAppAudioEnabled(false);
+                    mMediaLayout.setMode(MediaLayout.Mode.IMAGE);
+                    // Only log the failed to play event when the video has not started
+                    if (previousState != VideoState.PLAYING && previousState != VideoState.PLAYING_MUTED) {
+                        MoPubEvents.log(Event.createEventFromDetails(
+                                BaseEvent.Name.ERROR_FAILED_TO_PLAY,
+                                BaseEvent.Category.NATIVE_VIDEO,
+                                BaseEvent.SamplingRate.NATIVE_VIDEO,
+                                mEventDetails));
+                    }
+                    break;
+                case CREATED:
+                case LOADING:
+                    mNativeVideoController.setPlayWhenReady(true);
+                    mMediaLayout.setMode(MediaLayout.Mode.LOADING);
+                    break;
+                case BUFFERING:
+                    mNativeVideoController.setPlayWhenReady(true);
+                    mMediaLayout.setMode(MediaLayout.Mode.BUFFERING);
+                    break;
+                case PAUSED:
+                    if (transitionToFullScreen) {
+                        // Prevents firing resume trackers when we return from full-screen.
+                        mResumeCanBeTracked = false;
+                    }
+
+                    if (!transitionToFullScreen) {
+                        mNativeVideoController.setAppAudioEnabled(false);
+                        if (mPauseCanBeTracked) {
+                            TrackingRequest.makeVastTrackingHttpRequest(
+                                    mVastVideoConfig.getPauseTrackers(),
+                                    null, // VastErrorCode
+                                    (int) mNativeVideoController.getCurrentPosition(),
+                                    null, // Asset URI
+                                    mContext);
+                            mPauseCanBeTracked = false;
+                            mResumeCanBeTracked = true;
+                        }
+                    }
+                    mNativeVideoController.setPlayWhenReady(false);
+                    mMediaLayout.setMode(MediaLayout.Mode.PAUSED);
+                    break;
+                case PLAYING:
+                    handleResumeTrackersAndSeek(previousState);
+
+                    mNativeVideoController.setPlayWhenReady(true);
+                    mNativeVideoController.setAudioEnabled(true);
+                    mNativeVideoController.setAppAudioEnabled(true);
+                    mMediaLayout.setMode(MediaLayout.Mode.PLAYING);
+                    mMediaLayout.setMuteState(MediaLayout.MuteState.UNMUTED);
+                    break;
+                case PLAYING_MUTED:
+                    handleResumeTrackersAndSeek(previousState);
+
+                    mNativeVideoController.setPlayWhenReady(true);
+                    mNativeVideoController.setAudioEnabled(false);
+                    mNativeVideoController.setAppAudioEnabled(false);
+                    mMediaLayout.setMode(MediaLayout.Mode.PLAYING);
+                    mMediaLayout.setMuteState(MediaLayout.MuteState.MUTED);
+                    break;
+                case ENDED:
+                    if (mNativeVideoController.hasFinalFrame()) {
+                        mMediaLayout.setMainImageDrawable(mNativeVideoController.getFinalFrame());
+                    }
+                    mPauseCanBeTracked = false;
+                    mResumeCanBeTracked = false;
+                    mVastVideoConfig.handleComplete(mContext, 0);
+                    mNativeVideoController.setAppAudioEnabled(false);
+                    mMediaLayout.setMode(MediaLayout.Mode.FINISHED);
+                    mMediaLayout.updateProgress(1000);
+                    break;
+            }
+        }
+
+        private void handleResumeTrackersAndSeek(VideoState previousState) {
+            if (mResumeCanBeTracked
+                    && previousState != VideoState.PLAYING
+                    && previousState != VideoState.PLAYING_MUTED) {  // If we've played before, fire resume trackers.
+                TrackingRequest.makeVastTrackingHttpRequest(
+                        mVastVideoConfig.getResumeTrackers(),
+                        null, // VastErrorCode
+                        (int) mNativeVideoController.getCurrentPosition(),
+                        null, // Asset URI
+                        mContext
+                );
+                mResumeCanBeTracked = false;
+            }
+
+            mPauseCanBeTracked = true;
+
+            // We force a seek here to get keyframe rendering in ExtractorSampleSource.
+            if (mNeedsSeek) {
+                mNeedsSeek = false;
+                mNativeVideoController.seekTo(mNativeVideoController.getCurrentPosition());
+            }
+        }
+
+
+        private boolean isImageKey(@Nullable final String name) {
+            return name != null && name.toLowerCase(Locale.US).endsWith("image");
+        }
+
+        @NonNull
+        private List<String> getExtrasImageUrls() {
+            final List<String> extrasBitmapUrls = new ArrayList<String>(getExtras().size());
+            for (final Map.Entry<String, Object> entry : getExtras().entrySet()) {
+                if (isImageKey(entry.getKey()) && entry.getValue() instanceof String) {
+                    extrasBitmapUrls.add((String) entry.getValue());
+                }
+            }
+
+            return extrasBitmapUrls;
+        }
+
+        @NonNull
+        private List<String> getAllImageUrls() {
+            final List<String> imageUrls = new ArrayList<String>();
+            if (getMainImageUrl() != null) {
+                imageUrls.add(getMainImageUrl());
+            }
+            if (getIconImageUrl() != null) {
+                imageUrls.add(getIconImageUrl());
+            }
+
+            imageUrls.addAll(getExtrasImageUrls());
+            return imageUrls;
+        }
+
+        @Deprecated
+        @VisibleForTesting
+        boolean needsPrepare() {
+            return mNeedsPrepare;
+        }
+
+        @Deprecated
+        @VisibleForTesting
+        boolean hasEnded() {
+            return mEnded;
+        }
+
+        @Deprecated
+        @VisibleForTesting
+        boolean needsSeek() {
+            return mNeedsSeek;
+        }
+
+        @Deprecated
+        @VisibleForTesting
+        boolean isMuted() {
+            return mMuted;
+        }
+
+        @Deprecated
+        @VisibleForTesting
+        long getId() {
+            return mId;
+        }
+
+        @Deprecated
+        @VisibleForTesting
+        VideoState getVideoState() {
+            return mVideoState;
+        }
+
+        @Deprecated
+        @VisibleForTesting
+        void setLatestVisibility(boolean latestVisibility) {
+            mLatestVisibility = latestVisibility;
+        }
+
+        @Deprecated
+        @VisibleForTesting
+        void setMuted(boolean muted) {
+            mMuted = muted;
+        }
+
+        @Deprecated
+        @VisibleForTesting
+        MediaLayout getMediaLayout() {
+            return mMediaLayout;
+        }
+    }
+
+    @VisibleForTesting
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+    static class HeaderVisibilityStrategy implements VisibilityTrackingEvent.OnTrackedStrategy {
+        @NonNull private final WeakReference<MoPubVideoNativeAd> mMoPubVideoNativeAd;
+
+        HeaderVisibilityStrategy(@NonNull final MoPubVideoNativeAd moPubVideoNativeAd) {
+            mMoPubVideoNativeAd = new WeakReference<MoPubVideoNativeAd>(moPubVideoNativeAd);
+        }
+
+        @Override
+        public void execute() {
+            final MoPubVideoNativeAd moPubVideoNativeAd = mMoPubVideoNativeAd.get();
+            if (moPubVideoNativeAd != null) {
+                moPubVideoNativeAd.notifyAdImpressed();
+            }
+        }
+    }
+
+    @VisibleForTesting
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+    static class PayloadVisibilityStrategy implements VisibilityTrackingEvent.OnTrackedStrategy {
+        @NonNull private final Context mContext;
+        @NonNull private final String mUrl;
+
+        PayloadVisibilityStrategy(@NonNull final Context context, @NonNull final String url) {
+            mContext = context.getApplicationContext();
+            mUrl = url;
+        }
+
+        @Override
+        public void execute() {
+            TrackingRequest.makeTrackingHttpRequest(mUrl, mContext);
+        }
+    }
+
+    /**
+     * Created purely for the purpose of mocking to ease testing.
+     */
+    @VisibleForTesting
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+    static class NativeVideoControllerFactory {
+        public NativeVideoController createForId(final long id,
+                @NonNull final Context context,
+                @NonNull final List<VisibilityTrackingEvent> visibilityTrackingEvents,
+                @NonNull final VastVideoConfig vastVideoConfig,
+                @Nullable final EventDetails eventDetails) {
+            return NativeVideoController.createForId(id, context, visibilityTrackingEvents,
+                    vastVideoConfig, eventDetails);
+        }
+    }
+
+    @VisibleForTesting
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+    static class VideoResponseHeaders {
+        private boolean mHeadersAreValid;
+        private int mPlayVisiblePercent;
+        private int mPauseVisiblePercent;
+        private int mImpressionMinVisiblePercent;
+        private int mImpressionVisibleMs;
+        private int mMaxBufferMs;
+
+        VideoResponseHeaders(@NonNull final Map<String, String> serverExtras) {
+            try {
+                mPlayVisiblePercent = Integer.parseInt(serverExtras.get(PLAY_VISIBLE_PERCENT));
+                mPauseVisiblePercent = Integer.parseInt(serverExtras.get(PAUSE_VISIBLE_PERCENT));
+                mImpressionMinVisiblePercent =
+                        Integer.parseInt(serverExtras.get(IMPRESSION_MIN_VISIBLE_PERCENT));
+                mImpressionVisibleMs = Integer.parseInt(serverExtras.get(IMPRESSION_VISIBLE_MS));
+                mMaxBufferMs = Integer.parseInt(serverExtras.get(MAX_BUFFER_MS));
+                mHeadersAreValid = true;
+            } catch (NumberFormatException e) {
+                mHeadersAreValid = false;
+            }
+        }
+
+        boolean hasValidHeaders() {
+            return mHeadersAreValid;
+        }
+
+        int getPlayVisiblePercent() {
+            return mPlayVisiblePercent;
+        }
+
+        int getPauseVisiblePercent() {
+            return mPauseVisiblePercent;
+        }
+
+        int getImpressionMinVisiblePercent() {
+            return mImpressionMinVisiblePercent;
+        }
+
+        int getImpressionVisibleMs() {
+            return mImpressionVisibleMs;
+        }
+
+        int getMaxBufferMs() {
+            return mMaxBufferMs;
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNative.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNative.java
index 04123976..bcc9ccc3 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNative.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNative.java
@@ -1,9 +1,8 @@
 package com.mopub.nativeads;
 
-import android.content.Context;
+import android.app.Activity;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-import android.view.View;
 
 import com.mopub.common.AdFormat;
 import com.mopub.common.Constants;
@@ -29,91 +28,65 @@
 import static com.mopub.nativeads.CustomEventNative.CustomEventNativeListener;
 import static com.mopub.nativeads.NativeErrorCode.CONNECTION_ERROR;
 import static com.mopub.nativeads.NativeErrorCode.EMPTY_AD_RESPONSE;
-import static com.mopub.nativeads.NativeErrorCode.INVALID_JSON;
 import static com.mopub.nativeads.NativeErrorCode.INVALID_REQUEST_URL;
+import static com.mopub.nativeads.NativeErrorCode.INVALID_RESPONSE;
+import static com.mopub.nativeads.NativeErrorCode.NATIVE_RENDERER_CONFIGURATION_ERROR;
 import static com.mopub.nativeads.NativeErrorCode.SERVER_ERROR_RESPONSE_CODE;
 import static com.mopub.nativeads.NativeErrorCode.UNSPECIFIED;
 
 public class MoPubNative {
 
     public interface MoPubNativeNetworkListener {
-        public void onNativeLoad(final NativeResponse nativeResponse);
-        public void onNativeFail(final NativeErrorCode errorCode);
+        void onNativeLoad(final NativeAd nativeAd);
+        void onNativeFail(final NativeErrorCode errorCode);
     }
 
-    static final MoPubNativeNetworkListener EMPTY_NETWORK_LISTENER = new
-            MoPubNativeNetworkListener() {
+    static final MoPubNativeNetworkListener EMPTY_NETWORK_LISTENER =
+            new MoPubNativeNetworkListener() {
         @Override
-        public void onNativeLoad(@NonNull final NativeResponse nativeResponse) {
+        public void onNativeLoad(@NonNull final NativeAd nativeAd) {
             // If this listener is invoked, it means that MoPubNative instance has been destroyed
-            // so destroy any leftover incoming NativeResponses
-            nativeResponse.destroy();
+            // so destroy any leftover incoming NativeAds
+            nativeAd.destroy();
         }
         @Override
         public void onNativeFail(final NativeErrorCode errorCode) {
         }
     };
 
-    static final MoPubNativeEventListener EMPTY_EVENT_LISTENER = new
-            MoPubNativeEventListener() {
-        @Override
-        public void onNativeImpression(@Nullable final View view) {
-        }
-        @Override
-        public void onNativeClick(@Nullable final View view) {
-        }
-    };
-
-    public interface MoPubNativeEventListener {
-        public void onNativeImpression(final View view);
-        public void onNativeClick(final View view);
-    }
-
-    /**
-     * @deprecated As of release 2.4, use {@link MoPubNativeEventListener} and
-     * {@link MoPubNativeNetworkListener} instead.
-     */
-    @Deprecated
-    public interface MoPubNativeListener extends MoPubNativeNetworkListener, MoPubNativeEventListener {
-    }
-
-    // must be an activity context since 3rd party networks need it
-    @NonNull private final WeakReference<Context> mContext;
+    // must be an activity since 3rd party networks need it
+    @NonNull private final WeakReference<Activity> mActivity;
     @NonNull private final String mAdUnitId;
     @NonNull private MoPubNativeNetworkListener mMoPubNativeNetworkListener;
-    @NonNull private MoPubNativeEventListener mMoPubNativeEventListener;
 
     // For small sets TreeMap, takes up less memory than HashMap
     @NonNull private Map<String, Object> mLocalExtras = new TreeMap<String, Object>();
     @NonNull private final AdRequest.Listener mVolleyListener;
     @Nullable private AdRequest mNativeRequest;
+    @NonNull AdRendererRegistry mAdRendererRegistry;
 
-    /**
-     * @deprecated As of release 2.4, use {@link MoPubNative(Context, String,
-     * MoPubNativeNetworkListener)} and {@link #setNativeEventListener(MoPubNativeEventListener)}
-     * instead.
-     */
-    @Deprecated
-    public MoPubNative(@NonNull final Context context,
+    public MoPubNative(@NonNull final Activity activity,
             @NonNull final String adUnitId,
-            @NonNull final MoPubNativeListener moPubNativeListener) {
-        this(context, adUnitId, (MoPubNativeNetworkListener) moPubNativeListener);
-        setNativeEventListener(moPubNativeListener);
+            @NonNull final MoPubNativeNetworkListener moPubNativeNetworkListener) {
+        this(activity, adUnitId, new AdRendererRegistry(), moPubNativeNetworkListener);
     }
 
-    public MoPubNative(@NonNull final Context context,
-                @NonNull final String adUnitId,
-                @NonNull final MoPubNativeNetworkListener moPubNativeNetworkListener) {
-        Preconditions.checkNotNull(context, "Context may not be null.");
+    @VisibleForTesting
+    public MoPubNative(@NonNull final Activity activity,
+            @NonNull final String adUnitId,
+            @NonNull AdRendererRegistry adRendererRegistry,
+            @NonNull final MoPubNativeNetworkListener moPubNativeNetworkListener) {
+        Preconditions.checkNotNull(activity, "Activity may not be null.");
         Preconditions.checkNotNull(adUnitId, "AdUnitId may not be null.");
+        Preconditions.checkNotNull(adRendererRegistry, "AdRendererRegistry may not be null.");
         Preconditions.checkNotNull(moPubNativeNetworkListener, "MoPubNativeNetworkListener may not be null.");
 
-        ManifestUtils.checkNativeActivitiesDeclared(context);
+        ManifestUtils.checkNativeActivitiesDeclared(activity);
 
-        mContext = new WeakReference<Context>(context);
+        mActivity = new WeakReference<Activity>(activity);
         mAdUnitId = adUnitId;
         mMoPubNativeNetworkListener = moPubNativeNetworkListener;
-        mMoPubNativeEventListener = EMPTY_EVENT_LISTENER;
+        mAdRendererRegistry = adRendererRegistry;
         mVolleyListener = new AdRequest.Listener() {
             @Override
             public void onSuccess(@NonNull final AdResponse response) {
@@ -127,22 +100,25 @@ public void onErrorResponse(@NonNull final VolleyError volleyError) {
         };
 
         // warm up cache for google play services info
-        fetchAdvertisingInfoAsync(context, null);
+        fetchAdvertisingInfoAsync(activity, null);
     }
 
-    public void setNativeEventListener(@Nullable final MoPubNativeEventListener nativeEventListener) {
-        mMoPubNativeEventListener = (nativeEventListener == null)
-                ? EMPTY_EVENT_LISTENER : nativeEventListener;
+    /**
+     * Registers an ad renderer for rendering a specific native ad format.
+     * Note that if multiple ad renderers support a specific native ad format, the first
+     * one registered will be used.
+     */
+    public void registerAdRenderer(MoPubAdRenderer moPubAdRenderer) {
+        mAdRendererRegistry.registerAdRenderer(moPubAdRenderer);
     }
 
     public void destroy() {
-        mContext.clear();
+        mActivity.clear();
         if (mNativeRequest != null) {
             mNativeRequest.cancel();
             mNativeRequest = null;
         }
         mMoPubNativeNetworkListener = EMPTY_NETWORK_LISTENER;
-        mMoPubNativeEventListener = EMPTY_EVENT_LISTENER;
     }
 
     public void setLocalExtras(@Nullable final Map<String, Object> localExtras) {
@@ -163,12 +139,12 @@ public void makeRequest(@Nullable final RequestParameters requestParameters) {
 
     public void makeRequest(@Nullable final RequestParameters requestParameters,
             @Nullable Integer sequenceNumber) {
-        final Context context = getContextOrDestroy();
-        if (context == null) {
+        final Activity activity = getActivityOrDestroy();
+        if (activity == null) {
             return;
         }
 
-        if (!DeviceUtils.isNetworkAvailable(context)) {
+        if (!DeviceUtils.isNetworkAvailable(activity)) {
             mMoPubNativeNetworkListener.onNativeFail(CONNECTION_ERROR);
             return;
         }
@@ -179,12 +155,12 @@ public void makeRequest(@Nullable final RequestParameters requestParameters,
     private void loadNativeAd(
             @Nullable final RequestParameters requestParameters,
             @Nullable final Integer sequenceNumber) {
-        final Context context = getContextOrDestroy();
-        if (context == null) {
+        final Activity activity = getActivityOrDestroy();
+        if (activity == null) {
             return;
         }
 
-        final NativeUrlGenerator generator = new NativeUrlGenerator(context)
+        final NativeUrlGenerator generator = new NativeUrlGenerator(activity)
                 .withAdUnitId(mAdUnitId)
                 .withRequest(requestParameters);
 
@@ -202,8 +178,8 @@ private void loadNativeAd(
     }
 
     void requestNativeAd(@Nullable final String endpointUrl) {
-        final Context context = getContextOrDestroy();
-        if (context == null) {
+        final Activity activity = getActivityOrDestroy();
+        if (activity == null) {
             return;
         }
 
@@ -212,42 +188,49 @@ void requestNativeAd(@Nullable final String endpointUrl) {
             return;
         }
 
-        mNativeRequest = new AdRequest(endpointUrl, AdFormat.NATIVE, mAdUnitId, context, mVolleyListener);
-        RequestQueue requestQueue = Networking.getRequestQueue(context);
+        mNativeRequest = new AdRequest(endpointUrl, AdFormat.NATIVE, mAdUnitId, activity, mVolleyListener);
+        RequestQueue requestQueue = Networking.getRequestQueue(activity);
         requestQueue.add(mNativeRequest);
     }
 
     private void onAdLoad(@NonNull final AdResponse response) {
-        final Context context = getContextOrDestroy();
-        if (context == null) {
+        final Activity activity = getActivityOrDestroy();
+        if (activity == null) {
             return;
         }
         final CustomEventNativeListener customEventNativeListener =
                 new CustomEventNativeListener() {
                     @Override
-                    public void onNativeAdLoaded(@NonNull final NativeAdInterface nativeAd) {
-                        final Context context = getContextOrDestroy();
-                        if (context == null) {
+                    public void onNativeAdLoaded(@NonNull final BaseNativeAd nativeAd) {
+                        final Activity activity = getActivityOrDestroy();
+                        if (activity == null) {
+                            return;
+                        }
+
+                        MoPubAdRenderer renderer = mAdRendererRegistry.getRendererForAd(nativeAd);
+                        if (renderer == null) {
+                            onNativeAdFailed(NATIVE_RENDERER_CONFIGURATION_ERROR);
                             return;
                         }
-                        mMoPubNativeNetworkListener.onNativeLoad(new NativeResponse(context,
-                                response.getImpressionTrackingUrl(),
-                                response.getClickTrackingUrl(),
-                                mAdUnitId,
-                                nativeAd,
-                                mMoPubNativeEventListener));
+
+                        mMoPubNativeNetworkListener.onNativeLoad(new NativeAd(activity,
+                                        response.getImpressionTrackingUrl(),
+                                        response.getClickTrackingUrl(),
+                                        mAdUnitId,
+                                        nativeAd,
+                                        renderer)
+                        );
                     }
 
                     @Override
                     public void onNativeAdFailed(final NativeErrorCode errorCode) {
+                        MoPubLog.v(String.format("Native Ad failed to load with error: %s.", errorCode));
                         requestNativeAd(response.getFailoverUrl());
                     }
                 };
 
-
-
         CustomEventNativeAdapter.loadNativeAd(
-                context,
+                activity,
                 mLocalExtras,
                 response,
                 customEventNativeListener
@@ -261,10 +244,10 @@ void onAdError(@NonNull final VolleyError volleyError) {
             MoPubNetworkError error = (MoPubNetworkError) volleyError;
             switch (error.getReason()) {
                 case BAD_BODY:
-                    mMoPubNativeNetworkListener.onNativeFail(INVALID_JSON);
+                    mMoPubNativeNetworkListener.onNativeFail(INVALID_RESPONSE);
                     return;
                 case BAD_HEADER_DATA:
-                    mMoPubNativeNetworkListener.onNativeFail(INVALID_JSON);
+                    mMoPubNativeNetworkListener.onNativeFail(INVALID_RESPONSE);
                     return;
                 case WARMING_UP:
                     // Used for the sample app to signal a toast.
@@ -285,7 +268,7 @@ void onAdError(@NonNull final VolleyError volleyError) {
             NetworkResponse response = volleyError.networkResponse;
             if (response != null && response.statusCode >= 500 && response.statusCode < 600) {
                 mMoPubNativeNetworkListener.onNativeFail(SERVER_ERROR_RESPONSE_CODE);
-            } else if (response == null && !DeviceUtils.isNetworkAvailable(mContext.get())) {
+            } else if (response == null && !DeviceUtils.isNetworkAvailable(mActivity.get())) {
                 MoPubLog.c(String.valueOf(MoPubErrorCode.NO_CONNECTION.toString()));
                 mMoPubNativeNetworkListener.onNativeFail(CONNECTION_ERROR);
             } else {
@@ -294,27 +277,20 @@ void onAdError(@NonNull final VolleyError volleyError) {
         }
     }
 
-    Context getContextOrDestroy() {
-        final Context context = mContext.get();
-        if (context == null) {
+    Activity getActivityOrDestroy() {
+        final Activity activity = mActivity.get();
+        if (activity == null) {
             destroy();
-            MoPubLog.d("Weak reference to Activity Context in MoPubNative became null. This instance" +
+            MoPubLog.d("Weak reference to Activity in MoPubNative became null. This instance" +
                     " of MoPubNative is destroyed and No more requests will be processed.");
         }
-        return context;
+        return activity;
     }
 
-    @NonNull
     @VisibleForTesting
     @Deprecated
+    @NonNull
     MoPubNativeNetworkListener getMoPubNativeNetworkListener() {
         return mMoPubNativeNetworkListener;
     }
-
-    @NonNull
-    @VisibleForTesting
-    @Deprecated
-    MoPubNativeEventListener getMoPubNativeEventListener() {
-        return mMoPubNativeEventListener;
-    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdPositioning.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdPositioning.java
index d3e1b6c9..4d92b43f 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdPositioning.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdPositioning.java
@@ -134,49 +134,4 @@ public static MoPubClientPositioning clientPositioning() {
     public static MoPubServerPositioning serverPositioning() {
         return new MoPubServerPositioning();
     }
-
-    /**
-     * Creates and returns a {@link MoPubNativeAdPositioning.Builder}.
-     *
-     * @return A new builder.
-     * @deprecated We recommend using {@link #serverPositioning()} and specifying positioning in
-     * the MoPub UI. If you still want to hard-code positioning information in your app,
-     * use {@link #clientPositioning} instead of this builder.
-     */
-    @NonNull
-    @Deprecated
-    public static Builder newBuilder() {
-        return new Builder();
-    }
-
-    /**
-     * A Builder class for the ad positioning.
-     */
-    @Deprecated
-    public static final class Builder extends MoPubClientPositioning {
-        @NonNull
-        @Override
-        public Builder addFixedPosition(final int position) {
-            super.addFixedPosition(position);
-            return this;
-        }
-
-        @NonNull
-        @Override
-        public Builder enableRepeatingPositions(final int interval) {
-            super.enableRepeatingPositions(interval);
-            return this;
-        }
-
-        /**
-         * Creates and returns a new immutable positioning object.
-         *
-         * @return A new positioning object.
-         */
-        @NonNull
-        @Deprecated
-        public MoPubClientPositioning build() {
-            return this;
-        }
-    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubRecyclerAdapter.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubRecyclerAdapter.java
index 3f4baadd..e4ba5530 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubRecyclerAdapter.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubRecyclerAdapter.java
@@ -1,6 +1,6 @@
 package com.mopub.nativeads;
 
-import android.content.Context;
+import android.app.Activity;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.support.v7.widget.LinearLayoutManager;
@@ -39,23 +39,23 @@
     @NonNull private ContentChangeStrategy mStrategy = INSERT_AT_END;
     @Nullable private MoPubNativeAdLoadedListener mAdLoadedListener;
 
-    public MoPubRecyclerAdapter(@NonNull Context context,
+    public MoPubRecyclerAdapter(@NonNull Activity activity,
             @NonNull RecyclerView.Adapter originalAdapter) {
-        this(context, originalAdapter, MoPubNativeAdPositioning.serverPositioning());
+        this(activity, originalAdapter, MoPubNativeAdPositioning.serverPositioning());
     }
 
-    public MoPubRecyclerAdapter(@NonNull Context context,
+    public MoPubRecyclerAdapter(@NonNull Activity activity,
             @NonNull RecyclerView.Adapter originalAdapter,
             @NonNull MoPubServerPositioning adPositioning) {
-        this(new MoPubStreamAdPlacer(context, adPositioning), originalAdapter,
-                new VisibilityTracker(context));
+        this(new MoPubStreamAdPlacer(activity, adPositioning), originalAdapter,
+                new VisibilityTracker(activity));
     }
 
-    public MoPubRecyclerAdapter(@NonNull Context context,
+    public MoPubRecyclerAdapter(@NonNull Activity activity,
             @NonNull RecyclerView.Adapter originalAdapter,
             @NonNull MoPubClientPositioning adPositioning) {
-        this(new MoPubStreamAdPlacer(context, adPositioning), originalAdapter,
-                new VisibilityTracker(context));
+        this(new MoPubStreamAdPlacer(activity, adPositioning), originalAdapter,
+                new VisibilityTracker(activity));
     }
 
     @VisibleForTesting
@@ -196,10 +196,14 @@ public void setAdLoadedListener(@Nullable final MoPubNativeAdLoadedListener list
     }
 
     /**
-     * Registers a view binder for rendering "static" native ads with images.
+     * Registers an ad renderer for rendering a specific native ad format. Note that if multiple ad
+     * renderers support a specific native ad format, the first one registered will be used.
      */
-    public void registerViewBinder(@NonNull ViewBinder viewBinder) {
-        mStreamAdPlacer.registerAdRenderer(new MoPubNativeAdRenderer(viewBinder), NATIVE_AD_VIEW_TYPE_BASE + 1);
+    public void registerAdRenderer(@NonNull MoPubAdRenderer adRenderer) {
+        if (!Preconditions.NoThrow.checkNotNull(adRenderer, "Cannot register a null adRenderer")) {
+            return;
+        }
+        mStreamAdPlacer.registerAdRenderer(adRenderer);
     }
 
     /**
@@ -404,13 +408,14 @@ public int getItemCount() {
     public RecyclerView.ViewHolder onCreateViewHolder(final ViewGroup parent, final int viewType) {
         if (viewType >= NATIVE_AD_VIEW_TYPE_BASE && viewType <= NATIVE_AD_VIEW_TYPE_BASE + mStreamAdPlacer.getAdViewTypeCount()) {
             // Create the view and a view holder.
-            final MoPubAdRenderer adRenderer = mStreamAdPlacer.getAdRendererForViewType(viewType);
+            final MoPubAdRenderer adRenderer = mStreamAdPlacer.getAdRendererForViewType(viewType - NATIVE_AD_VIEW_TYPE_BASE);
             if (adRenderer == null) {
                 MoPubLog.w("No view binder was registered for ads in MoPubRecyclerAdapter.");
                 // This will cause a null pointer exception.
                 return null;
             }
-            return new MoPubRecyclerViewHolder(adRenderer.createAdView(parent.getContext(), parent));
+            return new MoPubRecyclerViewHolder(
+                    adRenderer.createAdView((Activity) parent.getContext(), parent));
         }
 
         return mOriginalAdapter.onCreateViewHolder(parent, viewType);
@@ -418,9 +423,9 @@ public int getItemCount() {
 
     @Override
     public void onBindViewHolder(final RecyclerView.ViewHolder holder, final int position) {
-        Object adData = mStreamAdPlacer.getAdData(position);
-        if (adData != null) {
-            mStreamAdPlacer.bindAdView((NativeAdData) adData, holder.itemView);
+        Object adResponse = mStreamAdPlacer.getAdData(position);
+        if (adResponse != null) {
+            mStreamAdPlacer.bindAdView((NativeAd) adResponse, holder.itemView);
             return;
         }
 
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubStaticNativeAdRenderer.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubStaticNativeAdRenderer.java
new file mode 100644
index 00000000..819d8d8f
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubStaticNativeAdRenderer.java
@@ -0,0 +1,90 @@
+package com.mopub.nativeads;
+
+import android.app.Activity;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+
+import java.util.WeakHashMap;
+
+import static android.view.View.VISIBLE;
+
+/**
+ * An implementation of {@link com.mopub.nativeads.MoPubAdRenderer} for rendering native ads.
+ */
+public class MoPubStaticNativeAdRenderer implements MoPubAdRenderer<StaticNativeAd> {
+    @NonNull private final ViewBinder mViewBinder;
+
+    // This is used instead of View.setTag, which causes a memory leak in 2.3
+    // and earlier: https://code.google.com/p/android/issues/detail?id=18273
+    @VisibleForTesting @NonNull final WeakHashMap<View, StaticNativeViewHolder> mViewHolderMap;
+
+    /**
+     * Constructs a native ad renderer with a view binder.
+     *
+     * @param viewBinder The view binder to use when inflating and rendering an ad.
+     */
+    public MoPubStaticNativeAdRenderer(@NonNull final ViewBinder viewBinder) {
+        mViewBinder = viewBinder;
+        mViewHolderMap = new WeakHashMap<View, StaticNativeViewHolder>();
+    }
+
+    @Override
+    @NonNull
+    public View createAdView(@NonNull final Activity activity, @Nullable final ViewGroup parent) {
+        return LayoutInflater
+                .from(activity)
+                .inflate(mViewBinder.layoutId, parent, false);
+    }
+
+    @Override
+    public void renderAdView(@NonNull final View view,
+            @NonNull final StaticNativeAd staticNativeAd) {
+        StaticNativeViewHolder staticNativeViewHolder = mViewHolderMap.get(view);
+        if (staticNativeViewHolder == null) {
+            staticNativeViewHolder = StaticNativeViewHolder.fromViewBinder(view, mViewBinder);
+            mViewHolderMap.put(view, staticNativeViewHolder);
+        }
+
+        update(staticNativeViewHolder, staticNativeAd);
+        NativeRendererHelper.updateExtras(staticNativeViewHolder.mainView,
+                mViewBinder.extras,
+                staticNativeAd.getExtras());
+        setViewVisibility(staticNativeViewHolder, VISIBLE);
+    }
+
+    @Override
+    public boolean supports(@NonNull final BaseNativeAd nativeAd) {
+        Preconditions.checkNotNull(nativeAd);
+        return nativeAd instanceof StaticNativeAd;
+    }
+
+    private void update(@NonNull final StaticNativeViewHolder staticNativeViewHolder,
+            @NonNull final StaticNativeAd staticNativeAd) {
+        NativeRendererHelper.addTextView(staticNativeViewHolder.titleView,
+                staticNativeAd.getTitle());
+        NativeRendererHelper.addTextView(staticNativeViewHolder.textView, staticNativeAd.getText());
+        NativeRendererHelper.addTextView(staticNativeViewHolder.callToActionView,
+                staticNativeAd.getCallToAction());
+        NativeImageHelper.loadImageView(staticNativeAd.getMainImageUrl(),
+                staticNativeViewHolder.mainImageView);
+        NativeImageHelper.loadImageView(staticNativeAd.getIconImageUrl(),
+                staticNativeViewHolder.iconImageView);
+        NativeRendererHelper.addPrivacyInformationIcon(
+                staticNativeViewHolder.privacyInformationIconImageView,
+                staticNativeAd.getPrivacyInformationIconImageUrl(),
+                staticNativeAd.getPrivacyInformationIconClickThroughUrl());
+    }
+
+    private void setViewVisibility(@NonNull final StaticNativeViewHolder staticNativeViewHolder,
+            final int visibility) {
+        if (staticNativeViewHolder.mainView != null) {
+            staticNativeViewHolder.mainView.setVisibility(visibility);
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubStreamAdPlacer.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubStreamAdPlacer.java
index 00de00c9..2aacb163 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubStreamAdPlacer.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubStreamAdPlacer.java
@@ -1,5 +1,6 @@
 package com.mopub.nativeads;
 
+import android.app.Activity;
 import android.content.Context;
 import android.os.Handler;
 import android.support.annotation.NonNull;
@@ -18,881 +19,711 @@
 import java.lang.ref.WeakReference;
 import java.util.ArrayList;
 import java.util.HashMap;
-import java.util.Map;
 import java.util.WeakHashMap;
 
 /**
  * {@code MoPubStreamAdPlacer} facilitates loading ads and placing them into a content stream.
- * <p/>
+ *
  * If you are inserting ads into a ListView, we recommend that you use a {@link MoPubAdAdapter}
  * instead of this class.
- * <p/>
+ *
  * To start loading ads, call {@link #loadAds}. We recommend passing targeting information to
  * increase the chance that you show ads that are relevant to your users.
- * <p/>
+ *
  * This class is not intended to be used by multiple threads. All calls should be made from the main
  * UI thread.
  */
 public class MoPubStreamAdPlacer {
-	/**
-	 * Constant representing that the view type for a given position is a regular content item
-	 * instead of an ad.
-	 */
-	public static final int CONTENT_VIEW_TYPE = 0;
-	public static final int DEFAULT_AD_VIEW_TYPE = -1;
-	private final static MoPubNativeAdLoadedListener EMPTY_NATIVE_AD_LOADED_LISTENER =
-			new MoPubNativeAdLoadedListener() {
-				@Override
-				public void onPositionsLoaded() {
-				}
-
-				@Override
-				public void onInitialAdLoaded() {
-
-				}
-
-				@Override
-				public void onAdLoaded(final int position) {
-				}
-
-				@Override
-				public void onAdRemoved(final int position) {
-				}
-			};
-
-	@NonNull
-	private final Context mContext;
-	@NonNull
-	private final Handler mPlacementHandler;
-	@NonNull
-	private final Runnable mPlacementRunnable;
-	@NonNull
-	private final PositioningSource mPositioningSource;
-	@NonNull
-	private final NativeAdSource mAdSource;
-	@NonNull
-	private final ImpressionTracker mImpressionTracker;
-
-	@NonNull
-	private final HashMap<NativeResponse, WeakReference<View>> mViewMap;
-	@NonNull
-	private final WeakHashMap<View, NativeResponse> mNativeResponseMap;
-
-	private boolean mHasReceivedPositions;
-	@Nullable
-	private PlacementData mPendingPlacementData;
-	private boolean mHasReceivedAds;
-	private boolean mHasPlacedAds;
-	@NonNull
-	private PlacementData mPlacementData;
-
-	private int adViewType = DEFAULT_AD_VIEW_TYPE;
-	@Nullable
-	private MoPubNativeAdRenderer mAdRenderer;
-	@Nullable
-	private String mAdUnitId;
-
-	private ArrayList<Integer> delayedStackRequests = new ArrayList<>();
-
-	@NonNull
-	private MoPubNativeAdLoadedListener mAdLoadedListener =
-			EMPTY_NATIVE_AD_LOADED_LISTENER;
-
-	// The visible range is the range of items which we believe are visible, inclusive.
-	// Placing ads near this range makes for a smoother user experience when scrolling up
-	// or down.
-	public static final int MAX_VISIBLE_RANGE = 100;
-	private int mVisibleRangeStart;
-	private int mVisibleRangeEnd;
-
-	private int mItemCount;
-	// A buffer around the visible range where we'll place ads if possible.
-	private static final int RANGE_BUFFER = 10;
-	private boolean mNeedsPlacement;
-
-	/**
-	 * Creates a new MoPubStreamAdPlacer object.
-	 * <p/>
-	 * By default, the StreamAdPlacer will contact the server to determine ad positions. If you
-	 * wish to hard-code positions in your app, see {@link MoPubStreamAdPlacer(Context,
-	 * MoPubClientPositioning)}.
-	 *
-	 * @param context The activity context.
-	 */
-	public MoPubStreamAdPlacer(@NonNull final Context context) {
-		// MoPubClientPositioning is mutable, so we must take care not to hold a
-		// reference to it that might be subsequently modified by the caller.
-		this(context, MoPubNativeAdPositioning.serverPositioning());
-	}
-
-	public MoPubStreamAdPlacer(@NonNull final Context context, int adCacheSize) {
-		// MoPubClientPositioning is mutable, so we must take care not to hold a
-		// reference to it that might be subsequently modified by the caller.
-		this(context, MoPubNativeAdPositioning.serverPositioning(), adCacheSize);
-	}
-
-	/**
-	 * Creates a new MoPubStreamAdPlacer object, using server positioning.
-	 *
-	 * @param context       The activity context.
-	 * @param adPositioning A positioning object for specifying where ads will be placed in your
-	 *                      stream. See {@link MoPubNativeAdPositioning#serverPositioning()}.
-	 */
-	public MoPubStreamAdPlacer(@NonNull final Context context,
-	                           @NonNull final MoPubServerPositioning adPositioning) {
-		this(context,
-				new NativeAdSource(),
-				new ImpressionTracker(context),
-				new ServerPositioningSource(context));
-	}
-
-	public MoPubStreamAdPlacer(@NonNull final Context context,
-	                           @NonNull final MoPubServerPositioning adPositioning, int adCacheSize) {
-		this(context,
-				new NativeAdSource(adCacheSize),
-				new ImpressionTracker(context),
-				new ServerPositioningSource(context));
-	}
-
-	/**
-	 * Creates a new MoPubStreamAdPlacer object, using client positioning.
-	 *
-	 * @param context       The activity context.
-	 * @param adPositioning A positioning object for specifying where ads will be placed in your
-	 *                      stream. See {@link MoPubNativeAdPositioning#clientPositioning()}.
-	 */
-	public MoPubStreamAdPlacer(@NonNull final Context context,
-	                           @NonNull final MoPubClientPositioning adPositioning) {
-		// MoPubClientPositioning is mutable, so we must take care not to hold a
-		// reference to it that might be subsequently modified by the caller.
-		this(context,
-				new NativeAdSource(),
-				new ImpressionTracker(context),
-				new ClientPositioningSource(adPositioning));
-	}
-
-	@VisibleForTesting
-	MoPubStreamAdPlacer(@NonNull final Context context,
-	                    @NonNull final NativeAdSource adSource,
-	                    @NonNull final ImpressionTracker impressionTracker,
-	                    @NonNull final PositioningSource positioningSource) {
-		Preconditions.checkNotNull(context, "context is not allowed to be null");
-		Preconditions.checkNotNull(adSource, "adSource is not allowed to be null");
-		Preconditions.checkNotNull(impressionTracker, "impressionTracker is not allowed to be " +
-				"null");
-		Preconditions.checkNotNull(positioningSource, "positioningSource is not allowed to be " +
-				"null");
-
-		mContext = context;
-		mImpressionTracker = impressionTracker;
-		mPositioningSource = positioningSource;
-		mAdSource = adSource;
-		mPlacementData = PlacementData.empty();
-
-		mNativeResponseMap = new WeakHashMap<>();
-		mViewMap = new HashMap<>();
-
-		mPlacementHandler = new Handler();
-		mPlacementRunnable = new Runnable() {
-			@Override
-			public void run() {
-				if (!mNeedsPlacement) {
-					return;
-				}
-				placeAds();
-				mNeedsPlacement = false;
-			}
-		};
-
-		mVisibleRangeStart = 0;
-		mVisibleRangeEnd = 0;
-	}
-
-	/**
-	 * Registers an ad renderer to use when displaying ads in your stream.
-	 * <p/>
-	 * This renderer will automatically create and render your view when you call {@link
-	 * #getAdView}. If you register a second renderer, it will replace the first, although this
-	 * behavior is subject to change in a future SDK version.
-	 *
-	 * @param adRenderer The ad renderer.
-	 */
-	public void registerAdRenderer(@NonNull final MoPubNativeAdRenderer adRenderer) {
-		registerAdRenderer(adRenderer, -1);
-	}
-
-	public void registerAdRenderer(@NonNull final MoPubNativeAdRenderer adRenderer, int viewType) {
-		if (!NoThrow.checkNotNull(adRenderer, "Cannot register a null adRenderer")) {
-			return;
-		}
-		adViewType = viewType;
-		mAdRenderer = adRenderer;
-	}
-
-	@Nullable
-	public MoPubAdRenderer getAdRendererForViewType(int viewType) {
-		if (viewType == adViewType) {
-			return mAdRenderer;
-		}
-
-		return null;
-	}
-
-	/**
-	 * Sets a listener that will be called after the SDK loads new ads from the server and places
-	 * them into your stream.
-	 * <p/>
-	 * The listener will be active between when you call {@link #loadAds} and when you call {@link
-	 * #destroy()}. You can also set the listener to {@code null} to remove the listener.
-	 * <p/>
-	 * Note that there is not a one to one correspondence between calls to {@link #loadAds} and this
-	 * listener. The SDK will call the listener every time an ad loads.
-	 *
-	 * @param listener The listener.
-	 */
-	public void setAdLoadedListener(@Nullable final MoPubNativeAdLoadedListener listener) {
-		mAdLoadedListener = (listener == null) ? EMPTY_NATIVE_AD_LOADED_LISTENER : listener;
-	}
-
-	/**
-	 * Start loading ads from the MoPub server.
-	 * <p/>
-	 * We recommend using {@link #loadAds(String, RequestParameters,Map<String,Object>)} instead of this method, in
-	 * order to pass targeting information to the server.
-	 *
-	 * @param adUnitId The ad unit ID to use when loading ads.
-	 */
-	public void loadAds(@NonNull final String adUnitId) {
-		loadAds(adUnitId, /* requestParameters */ null, null);
-	}
-
-	public void loadAds(@NonNull final String adUnitId,@Nullable Map<String,Object> localExtras) {
-		loadAds(adUnitId, /* requestParameters */ null, localExtras);
-	}
-
-	/**
-	 * Start loading ads from the MoPub server, using the given request targeting information.
-	 * <p/>
-	 * When loading ads, {@link MoPubNativeAdLoadedListener#onAdLoaded(int)} will be called for
-	 * each ad that is added to the stream.
-	 * <p/>
-	 * To refresh ads in your stream, call {@code loadAds} again. When new ads load, they will
-	 * replace the current ads in your stream. If you are using {@code MoPubNativeAdLoadedListener}
-	 * you will see a call to {@code onAdRemoved} for each of the old ads, followed by a calls to
-	 * {@code onAdLoaded}.
-	 *
-	 * @param adUnitId          The ad unit ID to use when loading ads.
-	 * @param requestParameters Targeting information to pass to the ad server.
-	 */
-	public void loadAds(@NonNull final String adUnitId,
-	                    @Nullable final RequestParameters requestParameters,@Nullable Map<String,Object> localExtras) {
-		if (!NoThrow.checkNotNull(adUnitId, "Cannot load ads with a null ad unit ID")) {
-			return;
-		}
-
-		if (mAdRenderer == null) {
-			MoPubLog.w("You must call registerAdRenderer before loading ads");
-			return;
-		}
-
-		mAdUnitId = adUnitId;
-
-		mHasPlacedAds = false;
-		mHasReceivedPositions = false;
-		mHasReceivedAds = false;
-
-		mPositioningSource.loadPositions(adUnitId, new PositioningListener() {
-			@Override
-			public void onLoad(@NonNull final MoPubClientPositioning positioning) {
-				handlePositioningLoad(positioning);
-			}
-
-			@Override
-			public void onFailed() {
-				// This will happen only if positions couldn't be loaded after several tries
-				MoPubLog.d("Unable to show ads because ad positions could not be loaded from " +
-						"the MoPub ad server.");
-			}
-		});
-
-		mAdSource.setAdSourceListener(new NativeAdSource.AdSourceListener() {
-			@Override
-			public void onAdsAvailable() {
-				handleAdsAvailable();
-			}
-		});
-
-		mAdSource.loadAds(mContext, adUnitId, requestParameters, localExtras);
-	}
-
-	@VisibleForTesting
-	void handlePositioningLoad(@NonNull final MoPubClientPositioning positioning) {
-		PlacementData placementData = PlacementData.fromAdPositioning(positioning);
-		if (mHasReceivedAds) {
-			handleAdsAvailable();
-		} else {
-			mPendingPlacementData = placementData;
-		}
-		mHasReceivedPositions = true;
-		mAdLoadedListener.onPositionsLoaded();
-	}
-
-	@VisibleForTesting
-	void handleAdsAvailable() {
-		// If we've already placed ads, just notify that we need placement.
-		if (mHasPlacedAds) {
-//			notifyNeedsPlacement();
-			return;
-		}
-
-		// Otherwise, we may need to place initial ads.
-		if (mHasReceivedPositions) {
-			placeInitialAds(mPendingPlacementData);
-		}
-		mHasReceivedAds = true;
-	}
-
-	private void placeInitialAds(PlacementData placementData) {
-		// Remove ads that may be present and immediately place ads again. This prevents the UI
-		// from flashing grossly.
-		removeAdsInRange(0, mItemCount);
-
-		mPlacementData = placementData;
-
-//		placeAds();
-		mHasPlacedAds = true;
-		for (Integer integer : delayedStackRequests) {
-			placeAd(integer);
-		}
-		delayedStackRequests.clear();
-
-		if (mAdLoadedListener != null) {
-			mAdLoadedListener.onInitialAdLoaded();
-		}
-	}
-
-	public void setVisibleRange(int start, int end) {
-		mVisibleRangeStart = start;
-		mVisibleRangeEnd = end;
-	}
-
-	public void stackPlace(int position) {
-		delayedStackRequests.add(position);
-	}
-
-	public int getItemCount() {
-		return mItemCount;
-	}
-
-	public boolean isAdLoaded(int position) {
-		return mPlacementData.isAdLoaded(position);
-	}
-
-	public boolean isAdLoadedByOriginalPosition(int position) {
-		return mPlacementData.isAdLoadedByOriginalPosition(position);
-	}
-
-	public boolean isAdLoadedByIndex(int index) {
-		return mPlacementData.isAdLoadedByIndex(index);
-	}
-
-	public int getAdIndex(int position) {
-		return mPlacementData.getAdIndex(position);
-	}
-
-	/**
-	 * Inserts ads that should appear in the given range.
-	 * <p/>
-	 * By default, the ad placer will place ads withing the first 10 positions in your stream,
-	 * according to the positions you've specified. You can use this method as your user scrolls
-	 * through your stream to place ads into the currently visible range.
-	 * <p/>
-	 * This method takes advantage of a short-lived in memory ad cache, and will immediately place
-	 * any ads from the cache. If there are no ads in the cache, this method will load additional
-	 * ads from the server and place them once they are loaded. If you call {@code placeAdsInRange}
-	 * again before ads are retrieved from the server, the new ads will show in the new positions
-	 * rather than the old positions.
-	 * <p/>
-	 * You can pass any integer as a startPosition and endPosition for the range, including negative
-	 * numbers or numbers greater than the current stream item count. The ad placer will only place
-	 * ads between 0 and item count.
-	 *
-	 * @param startPosition The start of the range in which to place ads, inclusive.
-	 * @param endPosition   The end of the range in which to place ads, exclusive.
-	 */
-	public void placeAdsInRange(final int startPosition, final int endPosition) {
-		mVisibleRangeStart = startPosition;
-		mVisibleRangeEnd = Math.min(endPosition, startPosition + MAX_VISIBLE_RANGE);
-		notifyNeedsPlacement();
-	}
-
-	/**
-	 * Whether the given position is an ad.
-	 * <p/>
-	 * This will return {@code true} only if there is an ad loaded for this position. You can listen
-	 * for ads to load using {@link MoPubNativeAdLoadedListener#onAdLoaded(int)}.
-	 *
-	 * @param position The position to check for an ad, expressed in terms of the position in the
-	 *                 stream including ads.
-	 * @return Whether there is an ad at the given position.
-	 */
-	public boolean isAd(final int position) {
-		return mPlacementData.isPlacedAd(position);
-	}
-
-	/**
-	 * Stops loading ads, immediately clearing any ads currently in the stream.
-	 * <p/>
-	 * This method also stops ads from loading as the user moves through the stream. If you want to
-	 * just remove ads but want to continue loading them, call {@link #removeAdsInRange(int, int)}.
-	 * <p/>
-	 * When ads are cleared, {@link MoPubNativeAdLoadedListener#onAdRemoved} will be called for each
-	 * ad that is removed from the stream.
-	 */
-	public void clearAds() {
-		removeAdsInRange(0, mItemCount);
-		mAdSource.clear();
-	}
-
-	/**
-	 * Destroys the ad placer, preventing it from future use.
-	 * <p/>
-	 * You must call this method before the hosting activity for this class is destroyed in order to
-	 * avoid a memory leak. Typically you should destroy the adapter in the life-cycle method that
-	 * is counterpoint to the method you used to create the adapter. For example, if you created the
-	 * adapter in {@code Fragment#onCreateView} you should destroy it in {code
-	 * Fragment#onDestroyView}.
-	 */
-	public void destroy() {
-		mPlacementHandler.removeMessages(0);
-		mAdSource.clear();
-		mImpressionTracker.destroy();
-		mPlacementData.clearAds();
-	}
-
-	/**
-	 * Returns an ad data object, or {@code null} if there is no ad at this position.
-	 * <p/>
-	 * This method is useful when implementing your own Adapter using {@code MoPubStreamAdPlacer}.
-	 * To avoid worrying about view type, consider using {@link MoPubAdAdapter} instead of this
-	 * class.
-	 *
-	 * @param position The position where to place an ad.
-	 * @return An object representing ad data.
-	 */
-	@Nullable
-	public NativeAdData getAdData(final int position) {
-		return mPlacementData.getPlacedAd(position);
-	}
-
-	@Nullable
-	public NativeAdData getAdDataByIndex(final int index) {
-		return mPlacementData.getPlacedAdByIndex(index);
-	}
-
-	@Nullable
-	public NativeAdData getAdDataByOriginalPosition(final int index) {
-		return mPlacementData.getPlacedAdByOriginalPosition(index);
-	}
-
-	/**
-	 * Gets the ad at the given position, or {@code null} if there is no ad at the given position.
-	 * <p/>
-	 * This method will attempt to reuse the convertView if it is not {@code null}, and will
-	 * otherwise create it. See {@link MoPubAdRenderer#createAdView(Context, ViewGroup)}.
-	 *
-	 * @param position    The position to place an ad into.
-	 * @param convertView A recycled view into which to render data, or {@code null}.
-	 * @param parent      The parent that the view will eventually be attached to.
-	 * @return The newly placed ad view.
-	 */
-	@Nullable
-	public View getAdView(final int position, @Nullable final View convertView,
-	                      @Nullable final ViewGroup parent) {
-		final NativeAdData adData = mPlacementData.getPlacedAd(position);
-		if (adData == null) {
-			return null;
-		}
-
-		final View view = (convertView != null) ?
-				convertView : adData.getAdRenderer().createAdView(mContext, parent);
-		bindAdView(adData, view);
-		return view;
-	}
-
-	/**
-	 * Given an ad and a view, attaches the ad data to the view and prepares the ad for display.
-	 *
-	 * @param adData the ad to bind.
-	 * @param adView the view to bind it to.
-	 */
-	public void bindAdView(@NonNull NativeAdData adData, @NonNull View adView) {
-		NativeResponse nativeResponse = adData.getAd();
-		WeakReference<View> mappedViewRef = mViewMap.get(nativeResponse);
-		View mappedView = null;
-		if (mappedViewRef != null) {
-			mappedView = mappedViewRef.get();
-		}
-		if (!adView.equals(mappedView)) {
-			clearNativeResponse(mappedView);
-			clearNativeResponse(adView);
-			prepareNativeResponse(nativeResponse, adView);
-			//noinspection unchecked
-			adData.getAdRenderer().renderAdView(adView, nativeResponse);
-		}
-	}
-
-	public void clearAdView(NativeAdData adData, View adView) {
-		if (adData == null) {
-			return;
-		}
-		NativeResponse nativeResponse = adData.getAd();
-		clearNativeResponse(adView);
-		mViewMap.remove(nativeResponse);
-	}
-
-	/**
-	 * Removes ads in the given range from [originalStartPosition, originalEndPosition).
-	 *
-	 * @param originalStartPosition The start position to clear (inclusive), expressed as the original content
-	 *                              position before ads were inserted.
-	 * @param originalEndPosition   The position after end position to clear (exclusive), expressed as the
-	 *                              original content position before ads were inserted.
-	 * @return The number of ads removed.
-	 */
-	public int removeAdsInRange(int originalStartPosition, int originalEndPosition) {
-		int[] positions = mPlacementData.getPlacedAdPositions();
-
-		int adjustedStartRange = mPlacementData.getAdjustedPosition(originalStartPosition);
-		int adjustedEndRange = mPlacementData.getAdjustedPosition(originalEndPosition);
-
-		ArrayList<Integer> removedPositions = new ArrayList<>();
-		// Traverse in reverse order to make this less error-prone for developers who are removing
-		// views directly from their UI.
-		for (int i = positions.length - 1; i >= 0; --i) {
-			int position = positions[i];
-			if (position < adjustedStartRange || position >= adjustedEndRange) {
-				continue;
-			}
-
-			removedPositions.add(position);
-
-//            // Decrement the start range for any removed ads. We don't bother to decrement the end
-//            // range, as it is OK if it isn't 100% accurate.
-//            if (position < mVisibleRangeStart) {
-//                mVisibleRangeStart--;
-//            }
-//            mItemCount--;
-		}
-
-		int clearedAdsCount = mPlacementData.clearAdsInRange(adjustedStartRange, adjustedEndRange);
-		for (int position : removedPositions) {
-			mAdLoadedListener.onAdRemoved(position);
-		}
-		return clearedAdsCount;
-	}
-
-	/**
-	 * Returns the number of ad view types that can be placed by this ad placer. The number of
-	 * possible ad view types is currently 1, but this is subject to change in future SDK versions.
-	 *
-	 * @return The number of ad view types.
-	 * @see #getAdViewType
-	 */
-	public int getAdViewTypeCount() {
-		return 1;
-	}
-
-	/**
-	 * The ad view type for this position.
-	 * <p/>
-	 * Returns 0 if this is a regular content item. Otherwise, returns a number between 1 and {@link
-	 * #getAdViewTypeCount}.
-	 * <p/>
-	 * This method is useful when implementing your own Adapter using {@code MoPubStreamAdPlacer}.
-	 * To avoid worrying about view type, consider using {@link MoPubAdAdapter} instead of this
-	 * class.
-	 *
-	 * @param position The stream position.
-	 * @return The ad view type.
-	 */
-	public int getAdViewType(final int position) {
-		return isAd(position) ? 1 : CONTENT_VIEW_TYPE;
-	}
-
-	/**
-	 * Returns the original position of an item considering ads in the stream.
-	 * <p/>
-	 * For example if your stream looks like:
-	 * <p/>
-	 * {@code Item0 Ad Item1 Item2 Ad Item3 </code>
-	 * <p/>
-	 * {@code getOriginalPosition(5)} will return {@code 3}.
-	 *
-	 * @param position The adjusted position.
-	 * @return The original position before placing ads.
-	 */
-	public int getOriginalPosition(final int position) {
-		return mPlacementData.getOriginalPosition(position);
-	}
-
-	public int getOriginalAdPosition(final int position) {
-		return mPlacementData.getOriginalAdPosition(position);
-	}
-
-	public int getPlacedPosition(final int position) {
-		return mPlacementData.getPlacedPosition(position);
-	}
-
-	public int getInsertPosition(final int position) {
-		return mPlacementData.getInsertPosition(position);
-	}
-
-	/**
-	 * Returns the position of an item considering ads in the stream.
-	 *
-	 * @param originalPosition The original position.
-	 * @return The position adjusted by placing ads.
-	 */
-	public int getAdjustedPosition(final int originalPosition) {
-		return mPlacementData.getAdjustedPosition(originalPosition);
-	}
-
-	/**
-	 * Returns the original number of items considering ads in the stream.
-	 *
-	 * @param count The number of items in the stream.
-	 * @return The original number of items before placing ads.
-	 */
-	public int getOriginalCount(final int count) {
-		return mPlacementData.getOriginalCount(count);
-	}
-
-	/**
-	 * Returns the number of items considering ads in the stream.
-	 *
-	 * @param originalCount The original number of items.
-	 * @return The number of items adjusted by placing ads.
-	 */
-	public int getAdjustedCount(final int originalCount) {
-		return mPlacementData.getAdjustedCount(originalCount);
-	}
-
-	public int getAdCount() {
-		return mPlacementData.getPlacedCount();
-	}
-
-	/**
-	 * Sets the original number of items in your stream.
-	 * <p/>
-	 * You must call this method so that the placer knows where valid positions are to place ads.
-	 * After calling this method, the ad placer will call {@link
-	 * MoPubNativeAdLoadedListener#onAdLoaded (int)} each time an ad is loaded in the stream.
-	 *
-	 * @param originalCount The original number of items.
-	 */
-	public void setItemCount(final int originalCount) {
-		mItemCount = mPlacementData.getAdjustedCount(originalCount);
-
-		// If we haven't already placed ads, we'll let ads get placed by the normal loadAds call
-//		if (mHasPlacedAds) {
-//			notifyNeedsPlacement();
-//		}
-	}
-
-	/**
-	 * Inserts a content row at the given position, adjusting ad positions accordingly.
-	 * <p/>
-	 * Use this method if you are inserting an item into your stream and want to increment ad
-	 * positions based on that new item.
-	 * <p/>
-	 * For example if your stream looks like:
-	 * <p/>
-	 * {@code Item0 Ad Item1 Item2 Ad Item3}
-	 * <p/>
-	 * and you insert an item at position 2, your new stream will look like:
-	 * <p/>
-	 * {@code Item0 Ad Item1 Item2 NewItem Ad Item3}
-	 *
-	 * @param originalPosition The position at which to add an item. If you have an adjusted
-	 *                         position, you will need to call {@link #getOriginalPosition} to get this value.
-	 */
-	public void insertItem(final int originalPosition) {
-		mPlacementData.insertItem(originalPosition);
-	}
-
-	/**
-	 * Removes the content row at the given position, adjusting ad positions accordingly.
-	 * <p/>
-	 * Use this method if you are removing an item from your stream and want to decrement ad
-	 * positions based on that removed item.
-	 * <p/>
-	 * For example if your stream looks like:
-	 * <p/>
-	 * {@code Item0 Ad Item1 Item2 Ad Item3}
-	 * <p/>
-	 * and you remove an item at position 2, your new stream will look like:
-	 * <p/>
-	 * {@code Item0 Ad Item1 Ad Item3}
-	 *
-	 * @param originalPosition The position at which to add an item. If you have an adjusted
-	 *                         position, you will need to call {@link #getOriginalPosition} to get this value.
-	 */
-	public void removeItem(final int originalPosition) {
-		mPlacementData.removeItem(originalPosition);
-	}
-
-	/**
-	 * Moves the content row at the given position adjusting ad positions accordingly.
-	 * <p/>
-	 * Use this method if you are moving an item in your stream and want to have ad positions move
-	 * as well.
-	 * <p/>
-	 * For example if your stream looks like:
-	 * <p/>
-	 * {@code Item0 Ad Item1 Item2 Ad Item3}
-	 * <p/>
-	 * and you move item at position 2 to position 3, your new stream will look like:
-	 * <p/>
-	 * {@code Item0 Ad Item1 Ad Item3 Item2}
-	 *
-	 * @param originalPosition The position from which to move an item. If you have an adjusted
-	 *                         position, you will need to call {@link #getOriginalPosition} to get this value.
-	 * @param newPosition      The new position, also expressed in terms of the original position.
-	 */
-	public void moveItem(final int originalPosition, final int newPosition) {
-		mPlacementData.moveItem(originalPosition, newPosition);
-	}
-
-	private void notifyNeedsPlacement() {
-		// Avoid posting if this method has already been called.
-//		if (mNeedsPlacement) {
-//			return;
-//		}
-//		mNeedsPlacement = true;
-//
-//		// Post the placement to happen on the next UI render loop.
-//		mPlacementHandler.post(mPlacementRunnable);
-	}
-
-	/**
-	 * Places ads using the current visible range.
-	 */
-	private void placeAds() {
-		for (Integer integer : delayedStackRequests) {
-			if (mPlacementData.shouldPlaceAd(integer)) {
-				if (!tryPlaceAd(integer)) {
-					return;
-				}
-			} else {
-				MoPubLog.e("there is no place for stacked ad");
-			}
-		}
-		delayedStackRequests.clear();
-		// Place ads within the visible range
-		if (!tryPlaceAdsInRange(mVisibleRangeStart, mVisibleRangeEnd)) {
-			return;
-		}
-
-		// Place ads after the visible range so that user will see an ad if they scroll down. We
-		// don't place an ad before the visible range, because we are trying to be mindful of
-		// changes that will affect scrolling.
-		tryPlaceAdsInRange(mVisibleRangeEnd, mVisibleRangeEnd + RANGE_BUFFER);
-	}
-
-	public boolean tryPlaceAdsInRange() {
-		return tryPlaceAdsInRange(mVisibleRangeStart, mVisibleRangeEnd);
-	}
-
-	/**
-	 * Attempts to place ads in the range [start, end], returning false if there is no ad available
-	 * to be placed.
-	 *
-	 * @param start The start of the range in which to place ads, inclusive.
-	 * @param end   The end of the range in which to place ads, exclusive.
-	 * @return false if there is no ad available to be placed.
-	 */
-	public boolean tryPlaceAdsInRange(final int start, final int end) {
-		int position = start;
-		int lastPosition = end - 1;
-		while (position <= lastPosition && position != PlacementData.NOT_FOUND) {
-			if (position >= mItemCount) {
-				break;
-			}
-			if (mPlacementData.shouldPlaceAd(position)) {
-				if (!tryPlaceAd(position)) {
-					return false;
-				}
-				lastPosition++;
-			}
-			position = mPlacementData.nextInsertionPosition(position);
-		}
-		return true;
-	}
-
-	public boolean placeAd(int position) {
-		if (mPlacementData.shouldPlaceAd(position)) {
-			return tryPlaceAd(position);
-		}
-		return false;
-	}
-
-	/**
-	 * Attempts to place an ad at the given position, returning false if there is no ad available to
-	 * be placed.
-	 *
-	 * @param position The position to place the ad at.
-	 * @return false if there is no ad available to be placed.
-	 */
-	public boolean tryPlaceAd(final int position) {
-		final NativeResponse adResponse = mAdSource.dequeueAd();
-		if (adResponse == null) {
-			return false;
-		}
-
-		final NativeAdData adData = createAdData(adResponse);
-		mPlacementData.placeAd(position, adData);
-		mItemCount++;
-
-		mAdLoadedListener.onAdLoaded(position);
-		return true;
-	}
-
-	@NonNull
-	private NativeAdData createAdData(@NonNull final NativeResponse adResponse) {
-		Preconditions.checkNotNull(mAdUnitId);
-		Preconditions.checkNotNull(mAdRenderer);
-
-		//noinspection ConstantConditions
-		return new NativeAdData(mAdUnitId, mAdRenderer, adResponse);
-	}
-
-	/**
-	 * Clears any native response click trackers and impression tracking are set up for this view.
-	 */
-	private void clearNativeResponse(@Nullable final View view) {
-		if (view == null) {
-			return;
-		}
-		mImpressionTracker.removeView(view);
-		final NativeResponse lastNativeResponse = mNativeResponseMap.get(view);
-		if (lastNativeResponse != null) {
-			lastNativeResponse.clear(view);
-			mNativeResponseMap.remove(view);
-			mViewMap.remove(lastNativeResponse);
-		}
-	}
-
-	/**
-	 * Prepares a view and nativeresponse for display by attaching click handlers
-	 * and setting up impression tracking.
-	 */
-	public void prepareNativeResponse(@NonNull final NativeResponse nativeResponse, @NonNull final View view) {
-		mViewMap.put(nativeResponse, new WeakReference<View>(view));
-		mNativeResponseMap.put(view, nativeResponse);
-		if (!nativeResponse.isOverridingImpressionTracker()) {
-			mImpressionTracker.addView(view, nativeResponse);
-		}
-		nativeResponse.prepare(view,mAdRenderer.getViewBinder());
-	}
+    /**
+     * Constant representing that the view type for a given position is a regular content item
+     * instead of an ad.
+     */
+    public static final int CONTENT_VIEW_TYPE = 0;
+    private static final int DEFAULT_AD_VIEW_TYPE = -1;
+    private final static MoPubNativeAdLoadedListener EMPTY_NATIVE_AD_LOADED_LISTENER =
+            new MoPubNativeAdLoadedListener() {
+                @Override
+                public void onAdLoaded(final int position) {
+                }
+
+                @Override
+                public void onAdRemoved(final int position) {
+                }
+            };
+
+    @NonNull private final Activity mActivity;
+    @NonNull private final Handler mPlacementHandler;
+    @NonNull private final Runnable mPlacementRunnable;
+    @NonNull private final PositioningSource mPositioningSource;
+    @NonNull private final NativeAdSource mAdSource;
+
+    @NonNull private final HashMap<NativeAd, WeakReference<View>> mViewMap;
+    @NonNull private final WeakHashMap<View, NativeAd> mNativeAdMap;
+
+    private boolean mHasReceivedPositions;
+    @Nullable private PlacementData mPendingPlacementData;
+    private boolean mHasReceivedAds;
+    private boolean mHasPlacedAds;
+    @NonNull private PlacementData mPlacementData;
+
+    @Nullable private String mAdUnitId;
+
+    @NonNull private MoPubNativeAdLoadedListener mAdLoadedListener =
+            EMPTY_NATIVE_AD_LOADED_LISTENER;
+
+    // The visible range is the range of items which we believe are visible, inclusive.
+    // Placing ads near this range makes for a smoother user experience when scrolling up
+    // or down.
+    private static final int MAX_VISIBLE_RANGE = 100;
+    private int mVisibleRangeStart;
+    private int mVisibleRangeEnd;
+
+    private int mItemCount;
+    // A buffer around the visible range where we'll place ads if possible.
+    private static final int RANGE_BUFFER = 6;
+    private boolean mNeedsPlacement;
+
+    /**
+     * Creates a new MoPubStreamAdPlacer object.
+     *
+     * By default, the StreamAdPlacer will contact the server to determine ad positions. If you
+     * wish to hard-code positions in your app, see {@link MoPubStreamAdPlacer(Context,
+     * MoPubClientPositioning)}.
+     *
+     * @param activity The activity.
+     */
+    public MoPubStreamAdPlacer(@NonNull final Activity activity) {
+        // MoPubClientPositioning is mutable, so we must take care not to hold a
+        // reference to it that might be subsequently modified by the caller.
+        this(activity, MoPubNativeAdPositioning.serverPositioning());
+    }
+
+    /**
+     * Creates a new MoPubStreamAdPlacer object, using server positioning.
+     *
+     * @param activity The activity.
+     * @param adPositioning A positioning object for specifying where ads will be placed in your
+     * stream. See {@link MoPubNativeAdPositioning#serverPositioning()}.
+     */
+    public MoPubStreamAdPlacer(@NonNull final Activity activity,
+            @NonNull final MoPubServerPositioning adPositioning) {
+        this(activity, new NativeAdSource(), new ServerPositioningSource(activity));
+    }
+
+    /**
+     * Creates a new MoPubStreamAdPlacer object, using client positioning.
+     *
+     * @param activity The activity.
+     * @param adPositioning A positioning object for specifying where ads will be placed in your
+     * stream. See {@link MoPubNativeAdPositioning#clientPositioning()}.
+     */
+    public MoPubStreamAdPlacer(@NonNull final Activity activity,
+            @NonNull final MoPubClientPositioning adPositioning) {
+        // MoPubClientPositioning is mutable, so we must take care not to hold a
+        // reference to it that might be subsequently modified by the caller.
+        this(activity, new NativeAdSource(), new ClientPositioningSource(adPositioning));
+    }
+
+    @VisibleForTesting
+    MoPubStreamAdPlacer(@NonNull final Activity activity,
+            @NonNull final NativeAdSource adSource,
+            @NonNull final PositioningSource positioningSource) {
+        Preconditions.checkNotNull(activity, "activity is not allowed to be null");
+        Preconditions.checkNotNull(adSource, "adSource is not allowed to be null");
+        Preconditions.checkNotNull(positioningSource, "positioningSource is not allowed to be " +
+                "null");
+
+        mActivity = activity;
+        mPositioningSource = positioningSource;
+        mAdSource = adSource;
+        mPlacementData = PlacementData.empty();
+
+        mNativeAdMap = new WeakHashMap<>();
+        mViewMap = new HashMap<>();
+
+        mPlacementHandler = new Handler();
+        mPlacementRunnable = new Runnable() {
+            @Override
+            public void run() {
+                if (!mNeedsPlacement) {
+                    return;
+                }
+                placeAds();
+                mNeedsPlacement = false;
+            }
+        };
+
+        mVisibleRangeStart = 0;
+        mVisibleRangeEnd = 0;
+    }
+
+    /**
+     * Registers an ad renderer for rendering a specific native ad format in your stream.
+     * Note that if multiple ad renderers support a specific native ad format, the first
+     * one registered will be used.
+     *
+     * This renderer will automatically create and render your view when you call {@link
+     * #getAdView}.
+     *
+     * @param adRenderer The ad renderer.
+     */
+    public void registerAdRenderer(@NonNull final MoPubAdRenderer adRenderer) {
+        if (!NoThrow.checkNotNull(adRenderer, "Cannot register a null adRenderer")) {
+            return;
+        }
+
+        mAdSource.registerAdRenderer(adRenderer);
+    }
+
+    @Nullable
+    public MoPubAdRenderer getAdRendererForViewType(int viewType) {
+        return mAdSource.getAdRendererForViewType(viewType);
+    }
+
+    /**
+     * Sets a listener that will be called after the SDK loads new ads from the server and places
+     * them into your stream.
+     *
+     * The listener will be active between when you call {@link #loadAds} and when you call {@link
+     * #destroy()}. You can also set the listener to {@code null} to remove the listener.
+     *
+     * Note that there is not a one to one correspondence between calls to {@link #loadAds} and this
+     * listener. The SDK will call the listener every time an ad loads.
+     *
+     * @param listener The listener.
+     */
+    public void setAdLoadedListener(@Nullable final MoPubNativeAdLoadedListener listener) {
+        mAdLoadedListener = (listener == null) ? EMPTY_NATIVE_AD_LOADED_LISTENER : listener;
+    }
+
+    /**
+     * Start loading ads from the MoPub server.
+     *
+     * We recommend using {@link #loadAds(String, RequestParameters)} instead of this method, in
+     * order to pass targeting information to the server.
+     *
+     * @param adUnitId The ad unit ID to use when loading ads.
+     */
+    public void loadAds(@NonNull final String adUnitId) {
+        loadAds(adUnitId, /* requestParameters */ null);
+    }
+
+    /**
+     * Start loading ads from the MoPub server, using the given request targeting information.
+     *
+     * When loading ads, {@link MoPubNativeAdLoadedListener#onAdLoaded(int)} will be called for
+     * each ad that is added to the stream.
+     *
+     * To refresh ads in your stream, call {@code loadAds} again. When new ads load, they will
+     * replace the current ads in your stream. If you are using {@code MoPubNativeAdLoadedListener}
+     * you will see a call to {@code onAdRemoved} for each of the old ads, followed by a calls to
+     * {@code onAdLoaded}.
+     *
+     * @param adUnitId The ad unit ID to use when loading ads.
+     * @param requestParameters Targeting information to pass to the ad server.
+     */
+    public void loadAds(@NonNull final String adUnitId,
+            @Nullable final RequestParameters requestParameters) {
+        if (!NoThrow.checkNotNull(adUnitId, "Cannot load ads with a null ad unit ID")) {
+            return;
+        }
+
+        if (mAdSource.getAdRendererCount() == 0) {
+            MoPubLog.w("You must register at least 1 ad renderer by calling registerAdRenderer " +
+                    "before loading ads");
+            return;
+        }
+
+        mAdUnitId = adUnitId;
+
+        mHasPlacedAds = false;
+        mHasReceivedPositions = false;
+        mHasReceivedAds = false;
+
+        mPositioningSource.loadPositions(adUnitId, new PositioningListener() {
+            @Override
+            public void onLoad(@NonNull final MoPubClientPositioning positioning) {
+                handlePositioningLoad(positioning);
+            }
+
+            @Override
+            public void onFailed() {
+                // This will happen only if positions couldn't be loaded after several tries
+                MoPubLog.d("Unable to show ads because ad positions could not be loaded from " +
+                        "the MoPub ad server.");
+            }
+        });
+
+        mAdSource.setAdSourceListener(new NativeAdSource.AdSourceListener() {
+            @Override
+            public void onAdsAvailable() {
+                handleAdsAvailable();
+            }
+        });
+
+        mAdSource.loadAds(mActivity, adUnitId, requestParameters);
+    }
+
+    @VisibleForTesting
+    void handlePositioningLoad(@NonNull final MoPubClientPositioning positioning) {
+        PlacementData placementData = PlacementData.fromAdPositioning(positioning);
+        if (mHasReceivedAds) {
+            placeInitialAds(placementData);
+        } else {
+            mPendingPlacementData = placementData;
+        }
+        mHasReceivedPositions = true;
+    }
+
+    @VisibleForTesting
+    void handleAdsAvailable() {
+        // If we've already placed ads, just notify that we need placement.
+        if (mHasPlacedAds) {
+            notifyNeedsPlacement();
+            return;
+        }
+
+        // Otherwise, we may need to place initial ads.
+        if (mHasReceivedPositions) {
+            placeInitialAds(mPendingPlacementData);
+        }
+        mHasReceivedAds = true;
+    }
+
+    private void placeInitialAds(PlacementData placementData) {
+        // Remove ads that may be present and immediately place ads again. This prevents the UI
+        // from flashing grossly.
+        removeAdsInRange(0, mItemCount);
+
+        mPlacementData = placementData;
+        placeAds();
+        mHasPlacedAds = true;
+    }
+
+    /**
+     * Inserts ads that should appear in the given range.
+     *
+     * By default, the ad placer will place ads withing the first 10 positions in your stream,
+     * according to the positions you've specified. You can use this method as your user scrolls
+     * through your stream to place ads into the currently visible range.
+     *
+     * This method takes advantage of a short-lived in memory ad cache, and will immediately place
+     * any ads from the cache. If there are no ads in the cache, this method will load additional
+     * ads from the server and place them once they are loaded. If you call {@code placeAdsInRange}
+     * again before ads are retrieved from the server, the new ads will show in the new positions
+     * rather than the old positions.
+     *
+     * You can pass any integer as a startPosition and endPosition for the range, including negative
+     * numbers or numbers greater than the current stream item count. The ad placer will only place
+     * ads between 0 and item count.
+     *
+     * @param startPosition The start of the range in which to place ads, inclusive.
+     * @param endPosition The end of the range in which to place ads, exclusive.
+     */
+    public void placeAdsInRange(final int startPosition, final int endPosition) {
+        mVisibleRangeStart = startPosition;
+        mVisibleRangeEnd = Math.min(endPosition, startPosition + MAX_VISIBLE_RANGE);
+        notifyNeedsPlacement();
+    }
+
+    /**
+     * Whether the given position is an ad.
+     *
+     * This will return {@code true} only if there is an ad loaded for this position. You can listen
+     * for ads to load using {@link MoPubNativeAdLoadedListener#onAdLoaded(int)}.
+     *
+     * @param position The position to check for an ad, expressed in terms of the position in the
+     * stream including ads.
+     * @return Whether there is an ad at the given position.
+     */
+    public boolean isAd(final int position) {
+        return mPlacementData.isPlacedAd(position);
+    }
+
+    /**
+     * Stops loading ads, immediately clearing any ads currently in the stream.
+     *
+     * This method also stops ads from loading as the user moves through the stream. If you want to
+     * just remove ads but want to continue loading them, call {@link #removeAdsInRange(int, int)}.
+     *
+     * When ads are cleared, {@link MoPubNativeAdLoadedListener#onAdRemoved} will be called for each
+     * ad that is removed from the stream.
+     */
+    public void clearAds() {
+        removeAdsInRange(0, mItemCount);
+        mAdSource.clear();
+    }
+
+    /**
+     * Destroys the ad placer, preventing it from future use.
+     *
+     * You must call this method before the hosting activity for this class is destroyed in order to
+     * avoid a memory leak. Typically you should destroy the adapter in the life-cycle method that
+     * is counterpoint to the method you used to create the adapter. For example, if you created the
+     * adapter in {@code Fragment#onCreateView} you should destroy it in {code
+     * Fragment#onDestroyView}.
+     */
+    public void destroy() {
+        mPlacementHandler.removeMessages(0);
+        mAdSource.clear();
+        mPlacementData.clearAds();
+    }
+
+    /**
+     * Returns an ad data object, or {@code null} if there is no ad at this position.
+     *
+     * This method is useful when implementing your own Adapter using {@code MoPubStreamAdPlacer}.
+     * To avoid worrying about view type, consider using {@link MoPubAdAdapter} instead of this
+     * class.
+     *
+     * @param position The position where to place an ad.
+     * @return An object representing ad data.
+     */
+    @Nullable
+    public Object getAdData(final int position) {
+        return mPlacementData.getPlacedAd(position);
+    }
+
+    /**
+     * Gets the ad at the given position, or {@code null} if there is no ad at the given position.
+     *
+     * This method will attempt to reuse the convertView if it is not {@code null}, and will
+     * otherwise create it. See {@link MoPubAdRenderer#createAdView(Activity, ViewGroup)}.
+     *
+     * @param position The position to place an ad into.
+     * @param convertView A recycled view into which to render data, or {@code null}.
+     * @param parent The parent that the view will eventually be attached to.
+     * @return The newly placed ad view.
+     */
+    @Nullable
+    public View getAdView(final int position, @Nullable final View convertView,
+            @Nullable final ViewGroup parent) {
+        final NativeAd nativeAd = mPlacementData.getPlacedAd(position);
+        if (nativeAd == null) {
+            return null;
+        }
+
+        final View view = (convertView != null) ?
+                convertView : nativeAd.createAdView(mActivity, parent);
+        bindAdView(nativeAd, view);
+        return view;
+    }
+
+    /**
+     * Given an ad and a view, attaches the ad data to the view and prepares the ad for display.
+     * @param nativeAd the ad to bind.
+     * @param adView the view to bind it to.
+     */
+    public void bindAdView(@NonNull NativeAd nativeAd, @NonNull View adView) {
+        WeakReference<View> mappedViewRef = mViewMap.get(nativeAd);
+        View mappedView = null;
+        if (mappedViewRef != null) {
+            mappedView = mappedViewRef.get();
+        }
+        if (!adView.equals(mappedView)) {
+            clearNativeAd(mappedView);
+            clearNativeAd(adView);
+            prepareNativeAd(nativeAd, adView);
+            nativeAd.renderAdView(adView);
+        }
+    }
+
+    /**
+     * Removes ads in the given range from [originalStartPosition, originalEndPosition).
+     *
+     * @param originalStartPosition The start position to clear (inclusive), expressed as the original content
+     * position before ads were inserted.
+     * @param originalEndPosition The position after end position to clear (exclusive), expressed as the
+     * original content position before ads were inserted.
+     * @return The number of ads removed.
+     */
+    public int removeAdsInRange(int originalStartPosition, int originalEndPosition) {
+        int[] positions = mPlacementData.getPlacedAdPositions();
+
+        int adjustedStartRange = mPlacementData.getAdjustedPosition(originalStartPosition);
+        int adjustedEndRange = mPlacementData.getAdjustedPosition(originalEndPosition);
+
+        ArrayList<Integer> removedPositions = new ArrayList<>();
+        // Traverse in reverse order to make this less error-prone for developers who are removing
+        // views directly from their UI.
+        for (int i = positions.length - 1; i >= 0; --i) {
+            int position = positions[i];
+            if (position < adjustedStartRange || position >= adjustedEndRange) {
+                continue;
+            }
+
+            removedPositions.add(position);
+
+            // Decrement the start range for any removed ads. We don't bother to decrement the end
+            // range, as it is OK if it isn't 100% accurate.
+            if (position < mVisibleRangeStart) {
+                mVisibleRangeStart--;
+            }
+            mItemCount--;
+        }
+
+        int clearedAdsCount = mPlacementData.clearAdsInRange(adjustedStartRange, adjustedEndRange);
+        for (int position : removedPositions) {
+            mAdLoadedListener.onAdRemoved(position);
+        }
+        return clearedAdsCount;
+    }
+
+    /**
+     * Returns the number of ad view types that can be placed by this ad placer. The number of
+     * possible ad view types is currently 1, but this is subject to change in future SDK versions.
+     *
+     * @return The number of ad view types.
+     * @see #getAdViewType
+     */
+    public int getAdViewTypeCount() {
+        return mAdSource.getAdRendererCount();
+    }
+
+    /**
+     * The ad view type for this position.
+     *
+     * Returns 0 if this is a regular content item. Otherwise, returns a number between 1 and {@link
+     * #getAdViewTypeCount}.
+     *
+     * This method is useful when implementing your own Adapter using {@code MoPubStreamAdPlacer}.
+     * To avoid worrying about view type, consider using {@link MoPubAdAdapter} instead of this
+     * class.
+     *
+     * @param position The stream position.
+     * @return The ad view type.
+     */
+    public int getAdViewType(final int position) {
+        NativeAd nativeAd = mPlacementData.getPlacedAd(position);
+        if (nativeAd == null) {
+            return CONTENT_VIEW_TYPE;
+        }
+
+        return mAdSource.getViewTypeForAd(nativeAd);
+    }
+
+    /**
+     * Returns the original position of an item considering ads in the stream.
+     *
+     * For example if your stream looks like:
+     *
+     * {@code Item0 Ad Item1 Item2 Ad Item3 </code>
+     *
+     * {@code getOriginalPosition(5)} will return {@code 3}.
+     *
+     * @param position The adjusted position.
+     * @return The original position before placing ads.
+     */
+    public int getOriginalPosition(final int position) {
+        return mPlacementData.getOriginalPosition(position);
+    }
+
+    /**
+     * Returns the position of an item considering ads in the stream.
+     *
+     * @param originalPosition The original position.
+     * @return The position adjusted by placing ads.
+     */
+    public int getAdjustedPosition(final int originalPosition) {
+        return mPlacementData.getAdjustedPosition(originalPosition);
+    }
+
+    /**
+     * Returns the original number of items considering ads in the stream.
+     *
+     * @param count The number of items in the stream.
+     * @return The original number of items before placing ads.
+     */
+    public int getOriginalCount(final int count) {
+        return mPlacementData.getOriginalCount(count);
+    }
+
+    /**
+     * Returns the number of items considering ads in the stream.
+     *
+     * @param originalCount The original number of items.
+     * @return The number of items adjusted by placing ads.
+     */
+    public int getAdjustedCount(final int originalCount) {
+        return mPlacementData.getAdjustedCount(originalCount);
+    }
+
+    /**
+     * Sets the original number of items in your stream.
+     *
+     * You must call this method so that the placer knows where valid positions are to place ads.
+     * After calling this method, the ad placer will call {@link
+     * MoPubNativeAdLoadedListener#onAdLoaded (int)} each time an ad is loaded in the stream.
+     *
+     * @param originalCount The original number of items.
+     */
+    public void setItemCount(final int originalCount) {
+        mItemCount = mPlacementData.getAdjustedCount(originalCount);
+
+        // If we haven't already placed ads, we'll let ads get placed by the normal loadAds call
+        if (mHasPlacedAds) {
+            notifyNeedsPlacement();
+        }
+    }
+
+    /**
+     * Inserts a content row at the given position, adjusting ad positions accordingly.
+     *
+     * Use this method if you are inserting an item into your stream and want to increment ad
+     * positions based on that new item.
+     *
+     * For example if your stream looks like:
+     *
+     * {@code Item0 Ad Item1 Item2 Ad Item3}
+     *
+     * and you insert an item at position 2, your new stream will look like:
+     *
+     * {@code Item0 Ad Item1 Item2 NewItem Ad Item3}
+     *
+     * @param originalPosition The position at which to add an item. If you have an adjusted
+     * position, you will need to call {@link #getOriginalPosition} to get this value.
+     */
+    public void insertItem(final int originalPosition) {
+        mPlacementData.insertItem(originalPosition);
+    }
+
+    /**
+     * Removes the content row at the given position, adjusting ad positions accordingly.
+     *
+     * Use this method if you are removing an item from your stream and want to decrement ad
+     * positions based on that removed item.
+     *
+     * For example if your stream looks like:
+     *
+     * {@code Item0 Ad Item1 Item2 Ad Item3}
+     *
+     * and you remove an item at position 2, your new stream will look like:
+     *
+     * {@code Item0 Ad Item1 Ad Item3}
+     *
+     * @param originalPosition The position at which to add an item. If you have an adjusted
+     * position, you will need to call {@link #getOriginalPosition} to get this value.
+     */
+    public void removeItem(final int originalPosition) {
+        mPlacementData.removeItem(originalPosition);
+    }
+
+    /**
+     * Moves the content row at the given position adjusting ad positions accordingly.
+     *
+     * Use this method if you are moving an item in your stream and want to have ad positions move
+     * as well.
+     *
+     * For example if your stream looks like:
+     *
+     * {@code Item0 Ad Item1 Item2 Ad Item3}
+     *
+     * and you move item at position 2 to position 3, your new stream will look like:
+     *
+     * {@code Item0 Ad Item1 Ad Item3 Item2}
+     *
+     * @param originalPosition The position from which to move an item. If you have an adjusted
+     * position, you will need to call {@link #getOriginalPosition} to get this value.
+     * @param newPosition The new position, also expressed in terms of the original position.
+     */
+    public void moveItem(final int originalPosition, final int newPosition) {
+        mPlacementData.moveItem(originalPosition, newPosition);
+    }
+
+    private void notifyNeedsPlacement() {
+        // Avoid posting if this method has already been called.
+        if (mNeedsPlacement) {
+            return;
+        }
+        mNeedsPlacement = true;
+
+        // Post the placement to happen on the next UI render loop.
+        mPlacementHandler.post(mPlacementRunnable);
+    }
+
+    /**
+     * Places ads using the current visible range.
+     */
+    private void placeAds() {
+        // Place ads within the visible range
+        if (!tryPlaceAdsInRange(mVisibleRangeStart, mVisibleRangeEnd)) {
+            return;
+        }
+
+        // Place ads after the visible range so that user will see an ad if they scroll down. We
+        // don't place an ad before the visible range, because we are trying to be mindful of
+        // changes that will affect scrolling.
+        tryPlaceAdsInRange(mVisibleRangeEnd, mVisibleRangeEnd + RANGE_BUFFER);
+    }
+
+    /**
+     * Attempts to place ads in the range [start, end], returning false if there is no ad available
+     * to be placed.
+     *
+     * @param start The start of the range in which to place ads, inclusive.
+     * @param end The end of the range in which to place ads, exclusive.
+     * @return false if there is no ad available to be placed.
+     */
+    private boolean tryPlaceAdsInRange(final int start, final int end) {
+        int position = start;
+        int lastPosition = end - 1;
+        while (position <= lastPosition && position != PlacementData.NOT_FOUND) {
+            if (position >= mItemCount) {
+                break;
+            }
+            if (mPlacementData.shouldPlaceAd(position)) {
+                if (!tryPlaceAd(position)) {
+                    return false;
+                }
+                lastPosition++;
+            }
+            position = mPlacementData.nextInsertionPosition(position);
+        }
+        return true;
+    }
+
+    /**
+     * Attempts to place an ad at the given position, returning false if there is no ad available to
+     * be placed.
+     *
+     * @param position The position to place the ad at.
+     * @return false if there is no ad available to be placed.
+     */
+    private boolean tryPlaceAd(final int position) {
+        final NativeAd nativeAd = mAdSource.dequeueAd();
+        if (nativeAd == null) {
+            return false;
+        }
+
+        mPlacementData.placeAd(position, nativeAd);
+        mItemCount++;
+
+        mAdLoadedListener.onAdLoaded(position);
+        return true;
+    }
+
+    /**
+     * Clears any {@link NativeAd} click trackers and impression tracking are set up for this view.
+     */
+    private void clearNativeAd(@Nullable final View view) {
+        if (view == null) {
+            return;
+        }
+        final NativeAd lastNativeAd = mNativeAdMap.get(view);
+        if (lastNativeAd != null) {
+            lastNativeAd.clear(view);
+            mNativeAdMap.remove(view);
+            mViewMap.remove(lastNativeAd);
+        }
+    }
+
+    /**
+     * Prepares a view and {@link NativeAd} for display by attaching click handlers
+     * and setting up impression tracking.
+     */
+    private void prepareNativeAd(@NonNull final NativeAd nativeAd, @NonNull final View view) {
+        mViewMap.put(nativeAd, new WeakReference<View>(view));
+        mNativeAdMap.put(view, nativeAd);
+        nativeAd.prepare(view);
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubVideoNativeAdRenderer.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubVideoNativeAdRenderer.java
new file mode 100644
index 00000000..a4a3da39
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubVideoNativeAdRenderer.java
@@ -0,0 +1,93 @@
+package com.mopub.nativeads;
+
+import android.app.Activity;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+
+import java.util.WeakHashMap;
+
+import static android.view.View.VISIBLE;
+
+public class MoPubVideoNativeAdRenderer implements MoPubAdRenderer<VideoNativeAd> {
+    @NonNull private final MediaViewBinder mMediaViewBinder;
+
+    // This is used instead of View.setTag, which causes a memory leak in 2.3
+    // and earlier: https://code.google.com/p/android/issues/detail?id=18273
+    @VisibleForTesting
+    @NonNull final WeakHashMap<View, MediaViewHolder> mMediaViewHolderMap;
+
+    /**
+     * Constructs a native ad renderer with a view binder.
+     *
+     * @param mediaViewBinder The view binder to use when inflating and rendering an ad.
+     */
+    public MoPubVideoNativeAdRenderer(@NonNull final MediaViewBinder mediaViewBinder) {
+        mMediaViewBinder = mediaViewBinder;
+        mMediaViewHolderMap = new WeakHashMap<View, MediaViewHolder>();
+    }
+
+    @Override
+    @NonNull
+    public View createAdView(@NonNull final Activity activity, @Nullable final ViewGroup parent) {
+        return LayoutInflater
+                .from(activity)
+                .inflate(mMediaViewBinder.layoutId, parent, false);
+    }
+
+    @Override
+    public void renderAdView(@NonNull final View view,
+            @NonNull final VideoNativeAd videoNativeAd) {
+        MediaViewHolder mediaViewHolder = mMediaViewHolderMap.get(view);
+        if (mediaViewHolder == null) {
+            mediaViewHolder = MediaViewHolder.fromViewBinder(view, mMediaViewBinder);
+            mMediaViewHolderMap.put(view, mediaViewHolder);
+        }
+
+        update(mediaViewHolder, videoNativeAd);
+        NativeRendererHelper.updateExtras(mediaViewHolder.mainView, mMediaViewBinder.extras, videoNativeAd.getExtras());
+        setViewVisibility(mediaViewHolder, VISIBLE);
+
+        MediaLayout mediaLayout = (MediaLayout) view.findViewById(mMediaViewBinder.mediaLayoutId);
+        videoNativeAd.render(mediaLayout);
+    }
+
+    @Override
+    public boolean supports(@NonNull final BaseNativeAd nativeAd) {
+        Preconditions.checkNotNull(nativeAd);
+        return nativeAd instanceof VideoNativeAd;
+    }
+
+    private void update(@NonNull final MediaViewHolder mediaViewHolder,
+            @NonNull final VideoNativeAd videoNativeAd) {
+        NativeRendererHelper.addTextView(mediaViewHolder.titleView,
+                videoNativeAd.getTitle());
+        NativeRendererHelper.addTextView(mediaViewHolder.textView, videoNativeAd.getText());
+        NativeRendererHelper.addCtaButton(mediaViewHolder.callToActionView,
+                mediaViewHolder.mainView, videoNativeAd.getCallToAction()
+        );
+        if (mediaViewHolder.mediaLayout != null) {
+            NativeImageHelper.loadImageView(videoNativeAd.getMainImageUrl(),
+                    mediaViewHolder.mediaLayout.getMainImageView());
+        }
+        NativeImageHelper.loadImageView(videoNativeAd.getIconImageUrl(),
+                mediaViewHolder.iconImageView);
+        NativeRendererHelper.addPrivacyInformationIcon(
+                mediaViewHolder.privacyInformationIconImageView,
+                videoNativeAd.getPrivacyInformationIconImageUrl(),
+                videoNativeAd.getPrivacyInformationIconClickThroughUrl());
+    }
+
+    private void setViewVisibility(@NonNull final MediaViewHolder mediaViewHolder,
+            final int visibility) {
+        if (mediaViewHolder.mainView != null) {
+            mediaViewHolder.mainView.setVisibility(visibility);
+        }
+    }
+}
+
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAd.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAd.java
new file mode 100644
index 00000000..08124786
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAd.java
@@ -0,0 +1,220 @@
+package com.mopub.nativeads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.view.View;
+import android.view.ViewGroup;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.nativeads.MoPubCustomEventNative.MoPubStaticNativeAd;
+import com.mopub.nativeads.MoPubCustomEventVideoNative.MoPubVideoNativeAd;
+import com.mopub.network.AdResponse;
+import com.mopub.network.TrackingRequest;
+
+import java.util.HashSet;
+import java.util.Set;
+
+import static com.mopub.nativeads.BaseNativeAd.NativeEventListener;
+
+/**
+ * This class represents a native ad instance returned from the MoPub Ad Server, MoPub Exchange, or
+ * a mediated native ad network. This class can be used to create and render a {@link View} that
+ * displays a native ad, tracking impressions and clicks for it.
+ *
+ * Using {@link MoPubStreamAdPlacer}, you can automatically have {@link NativeAd}s rendered into
+ * {@link View}s and inserted into your app's content stream without manipulating this class
+ * directly.
+ *
+ * In general you should get instances of {@link NativeAd} from {@link MoPubNative} instances in its
+ * {@link MoPubNative.MoPubNativeNetworkListener#onAdLoad(AdResponse)} callback
+ * and should not construct them directly.
+ *
+ * When you have a {@link NativeAd} instance and wish to show a view you should:
+ *
+ * 1. Call {@link #createAdView(Activity, ViewGroup)} to inflate a {@link View} that can show this ad.
+ * 2. Call {@link #renderAdView(View)} with a compatible {@link View} to render the ad data into the view.
+ * 3. Just before the ad is shown to the user, call {@link #prepare(View)}.
+ * 4. When the ad view is no longer shown to the user, call {@link #clear(View)}. You can later
+ *    call {@link #prepare(View)} again if the ad will be shown to users.
+ * 5. When the ad will never be shown again, call {@link #destroy()}.
+ */
+public class NativeAd {
+
+    /**
+     * Listen for MoPub specific click and impression events
+     */
+    public interface MoPubNativeEventListener {
+        void onImpression(final View view);
+        void onClick(final View view);
+    }
+
+    @NonNull private final Context mContext;
+    @NonNull private final BaseNativeAd mBaseNativeAd;
+    @NonNull private final MoPubAdRenderer mMoPubAdRenderer;
+    @NonNull private final Set<String> mImpressionTrackers;
+    @NonNull private final Set<String> mClickTrackers;
+    @NonNull private final String mAdUnitId;
+    @Nullable private MoPubNativeEventListener mMoPubNativeEventListener;
+
+    private boolean mRecordedImpression;
+    private boolean mIsClicked;
+    private boolean mIsDestroyed;
+
+    public NativeAd(@NonNull final Context context,
+            @NonNull final String moPubImpressionTrackerUrl,
+            @NonNull final String moPubClickTrackerUrl,
+            @NonNull final String adUnitId,
+            @NonNull final BaseNativeAd baseNativeAd,
+            @NonNull final MoPubAdRenderer moPubAdRenderer) {
+        mContext = context.getApplicationContext();
+
+        mAdUnitId = adUnitId;
+
+        mImpressionTrackers = new HashSet<String>();
+        mImpressionTrackers.add(moPubImpressionTrackerUrl);
+        mImpressionTrackers.addAll(baseNativeAd.getImpressionTrackers());
+
+        mClickTrackers = new HashSet<String>();
+        mClickTrackers.add(moPubClickTrackerUrl);
+        mClickTrackers.addAll(baseNativeAd.getClickTrackers());
+
+        mBaseNativeAd = baseNativeAd;
+        mBaseNativeAd.setNativeEventListener(new NativeEventListener() {
+            @Override
+            public void onAdImpressed() {
+                recordImpression(null);
+            }
+
+            @Override
+            public void onAdClicked() {
+                handleClick(null);
+            }
+        });
+
+        mMoPubAdRenderer = moPubAdRenderer;
+    }
+
+    @Override
+    public String toString() {
+        final StringBuilder stringBuilder = new StringBuilder("\n");
+        stringBuilder.append("impressionTrackers").append(":").append(mImpressionTrackers).append("\n");
+        stringBuilder.append("clickTrackers").append(":").append(mClickTrackers).append("\n");
+        stringBuilder.append("recordedImpression").append(":").append(mRecordedImpression).append("\n");
+        stringBuilder.append("isClicked").append(":").append(mIsClicked).append("\n");
+        stringBuilder.append("isDestroyed").append(":").append(mIsDestroyed).append("\n");
+        return stringBuilder.toString();
+    }
+
+    public void setMoPubNativeEventListener(@Nullable final MoPubNativeEventListener moPubNativeEventListener) {
+        mMoPubNativeEventListener = moPubNativeEventListener;
+    }
+
+    @NonNull
+    public String getAdUnitId() {
+        return mAdUnitId;
+    }
+
+    public boolean isDestroyed() {
+        return mIsDestroyed;
+    }
+
+    /**
+     * Returns the {@link BaseNativeAd} object for this {@link NativeAd}. This object is created by
+     * a {@link CustomEventNative} subclass after a successful ad request and is specific to the ad
+     * source. If it comes from the MoPub Exchange or is a directly-served ad it will be of the type
+     * {@link MoPubStaticNativeAd} or {@link MoPubVideoNativeAd}. If it is returned by a mediated ad
+     * network it may have another type.
+     */
+    @NonNull
+    public BaseNativeAd getBaseNativeAd() {
+        return mBaseNativeAd;
+    }
+
+    @NonNull
+    public View createAdView(@NonNull final Activity activity, @Nullable final ViewGroup parent) {
+        return mMoPubAdRenderer.createAdView(activity, parent);
+    }
+
+    public void renderAdView(View view) {
+        //noinspection unchecked
+        mMoPubAdRenderer.renderAdView(view, mBaseNativeAd);
+    }
+
+    @NonNull
+    public MoPubAdRenderer getMoPubAdRenderer() {
+        return mMoPubAdRenderer;
+    }
+
+    // Lifecycle Handlers
+
+    /**
+     * Prepares the {@link NativeAd} to be seen on screen. You should call this method after calling
+     * {@link #renderAdView(View)} with the same {@link View} and before the ad is shown on-screen.
+     * This method is commonly used to initialize impression tracking and other state associated
+     * with the {@link View}.
+     */
+    public void prepare(@NonNull final View view) {
+        if (mIsDestroyed) {
+            return;
+        }
+
+        mBaseNativeAd.prepare(view);
+    }
+
+    /**
+     * Clears {@link NativeAd} state associated with this {@link View}. Call this when the {@link NativeAd} is no
+     * longer seen by a user. If you would like to render a different {@link NativeAd} into the same View,
+     * you must call this method first.
+     */
+    public void clear(@NonNull final View view) {
+        if (mIsDestroyed) {
+            return;
+        }
+
+        mBaseNativeAd.clear(view);
+    }
+
+    /**
+     * Cleans up all {@link NativeAd} state. Call this method when the {@link NativeAd} will never be shown to a
+     * user again.
+     */
+    public void destroy() {
+        if (mIsDestroyed) {
+            return;
+        }
+
+        mBaseNativeAd.destroy();
+        mIsDestroyed = true;
+    }
+
+    // Event Handlers
+    @VisibleForTesting
+    void recordImpression(@Nullable final View view) {
+        if (mRecordedImpression || mIsDestroyed) {
+            return;
+        }
+
+        TrackingRequest.makeTrackingHttpRequest(mImpressionTrackers, mContext);
+        if (mMoPubNativeEventListener != null) {
+            mMoPubNativeEventListener.onImpression(view);
+        }
+
+        mRecordedImpression = true;
+    }
+
+    @VisibleForTesting
+    void handleClick(@Nullable final View view) {
+        if (mIsClicked || mIsDestroyed) {
+            return;
+        }
+
+        TrackingRequest.makeTrackingHttpRequest(mClickTrackers, mContext);
+        if (mMoPubNativeEventListener != null) {
+            mMoPubNativeEventListener.onClick(view);
+        }
+
+        mIsClicked = true;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdData.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdData.java
index 54e125e8..8ecc0be3 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdData.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdData.java
@@ -5,14 +5,14 @@
 /**
  * An object that represents placed ads in a {@link com.mopub.nativeads.MoPubStreamAdPlacer}
  */
-public class NativeAdData {
+class NativeAdData {
     @NonNull private final String adUnitId;
     @NonNull private final MoPubAdRenderer adRenderer;
-    @NonNull private final NativeResponse adResponse;
+    @NonNull private final NativeAd adResponse;
 
     NativeAdData(@NonNull final String adUnitId,
             @NonNull final MoPubAdRenderer adRenderer,
-            @NonNull final NativeResponse adResponse) {
+            @NonNull final NativeAd adResponse) {
         this.adUnitId = adUnitId;
         this.adRenderer = adRenderer;
         this.adResponse = adResponse;
@@ -24,12 +24,12 @@ String getAdUnitId() {
     }
 
     @NonNull
-    public  MoPubAdRenderer getAdRenderer() {
+    MoPubAdRenderer getAdRenderer() {
         return adRenderer;
     }
 
     @NonNull
-    public NativeResponse getAd() {
+    NativeAd getAd() {
         return adResponse;
     }
 }
\ No newline at end of file
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdSource.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdSource.java
index ce5881b1..7d2b43be 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdSource.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdSource.java
@@ -1,6 +1,6 @@
 package com.mopub.nativeads;
 
-import android.content.Context;
+import android.app.Activity;
 import android.os.Handler;
 import android.os.SystemClock;
 import android.support.annotation.NonNull;
@@ -10,7 +10,6 @@
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Map;
 
 import static com.mopub.nativeads.MoPubNative.MoPubNativeNetworkListener;
 
@@ -31,13 +30,16 @@
  * This class is not thread safe and should only be called from the UI thread.
  */
 class NativeAdSource {
-    private static final int CACHE_LIMIT = 3;
+    /**
+     * Number of ads to cache
+     */
+    private static final int CACHE_LIMIT = 1;
+
     private static final int EXPIRATION_TIME_MILLISECONDS = 15 * 60 * 1000; // 15 minutes
-    private static final int DEFAULT_RETRY_TIME_MILLISECONDS = 1000; // 1 second
     private static final int MAXIMUM_RETRY_TIME_MILLISECONDS = 5 * 60 * 1000; // 5 minutes.
-    private static final double EXPONENTIAL_BACKOFF_FACTOR = 2.0;
+    @VisibleForTesting static final int[] RETRY_TIME_ARRAY_MILLISECONDS = new int[]{1000, 3000, 5000, 25000, 60000, MAXIMUM_RETRY_TIME_MILLISECONDS};
 
-    @NonNull private final List<TimestampWrapper<NativeResponse>> mNativeAdCache;
+    @NonNull private final List<TimestampWrapper<NativeAd>> mNativeAdCache;
     @NonNull private final Handler mReplenishCacheHandler;
     @NonNull private final Runnable mReplenishCacheRunnable;
     @NonNull private final MoPubNativeNetworkListener mMoPubNativeNetworkListener;
@@ -45,7 +47,7 @@
     @VisibleForTesting boolean mRequestInFlight;
     @VisibleForTesting boolean mRetryInFlight;
     @VisibleForTesting int mSequenceNumber;
-    @VisibleForTesting int mRetryTimeMilliseconds;
+    @VisibleForTesting int mCurrentRetries;
 
     @Nullable private AdSourceListener mAdSourceListener;
 
@@ -53,7 +55,7 @@
     @Nullable private RequestParameters mRequestParameters;
     @Nullable private MoPubNative mMoPubNative;
 
-    private int cacheLimit;
+    @NonNull private final AdRendererRegistry mAdRendererRegistry;
 
     /**
      * A listener for when ads are available for dequeueing.
@@ -66,17 +68,15 @@
     }
 
     NativeAdSource() {
-        this(CACHE_LIMIT);
-    }
-
-    NativeAdSource(int cacheLimit) {
-        this(new ArrayList<TimestampWrapper<NativeResponse>>(cacheLimit), new Handler());
-        this.cacheLimit = cacheLimit;
+        this(new ArrayList<TimestampWrapper<NativeAd>>(CACHE_LIMIT),
+                new Handler(),
+                new AdRendererRegistry());
     }
 
     @VisibleForTesting
-    NativeAdSource(@NonNull final List<TimestampWrapper<NativeResponse>> nativeAdCache,
-            @NonNull final Handler replenishCacheHandler) {
+    NativeAdSource(@NonNull final List<TimestampWrapper<NativeAd>> nativeAdCache,
+            @NonNull final Handler replenishCacheHandler,
+            @NonNull AdRendererRegistry adRendererRegistry) {
         mNativeAdCache = nativeAdCache;
         mReplenishCacheHandler = replenishCacheHandler;
         mReplenishCacheRunnable = new Runnable() {
@@ -87,10 +87,12 @@ public void run() {
             }
         };
 
+        mAdRendererRegistry = adRendererRegistry;
+
         // Construct native URL and start filling the cache
         mMoPubNativeNetworkListener = new MoPubNativeNetworkListener() {
             @Override
-            public void onNativeLoad(@NonNull final NativeResponse nativeResponse) {
+            public void onNativeLoad(@NonNull final NativeAd nativeAd) {
                 // This can be null if the ad source was cleared as the AsyncTask is posting
                 // back to the UI handler. Drop this response.
                 if (mMoPubNative == null) {
@@ -101,7 +103,7 @@ public void onNativeLoad(@NonNull final NativeResponse nativeResponse) {
                 mSequenceNumber++;
                 resetRetryTime();
 
-                mNativeAdCache.add(new TimestampWrapper<NativeResponse>(nativeResponse));
+                mNativeAdCache.add(new TimestampWrapper<NativeAd>(nativeAd));
                 if (mNativeAdCache.size() == 1 && mAdSourceListener != null) {
                     mAdSourceListener.onAdsAvailable();
                 }
@@ -114,21 +116,46 @@ public void onNativeFail(final NativeErrorCode errorCode) {
                 // Reset the retry time for the next time we dequeue.
                 mRequestInFlight = false;
 
-                // Stopping requests after the max retry time prevents us from using battery when
+                // Stopping requests after the max retry count prevents us from using battery when
                 // the user is not interacting with the stream, eg. the app is backgrounded.
-                if (mRetryTimeMilliseconds >= MAXIMUM_RETRY_TIME_MILLISECONDS) {
+                if (mCurrentRetries >= RETRY_TIME_ARRAY_MILLISECONDS.length - 1) {
                     resetRetryTime();
                     return;
                 }
 
                 updateRetryTime();
                 mRetryInFlight = true;
-                mReplenishCacheHandler.postDelayed(mReplenishCacheRunnable, mRetryTimeMilliseconds);
+                mReplenishCacheHandler.postDelayed(mReplenishCacheRunnable, getRetryTime());
             }
         };
 
         mSequenceNumber = 0;
-        mRetryTimeMilliseconds = DEFAULT_RETRY_TIME_MILLISECONDS;
+        resetRetryTime();
+    }
+
+    int getAdRendererCount() {
+        return mAdRendererRegistry.getAdRendererCount();
+    }
+
+    public int getViewTypeForAd(@NonNull final NativeAd nativeAd) {
+        return mAdRendererRegistry.getViewTypeForAd(nativeAd);
+    }
+
+    /**
+     * Registers an ad renderer for rendering a specific native ad format.
+     * Note that if multiple ad renderers support a specific native ad format, the first
+     * one registered will be used.
+     */
+    void registerAdRenderer(@NonNull final MoPubAdRenderer moPubNativeAdRenderer) {
+        mAdRendererRegistry.registerAdRenderer(moPubNativeAdRenderer);
+        if (mMoPubNative != null) {
+            mMoPubNative.registerAdRenderer(moPubNativeAdRenderer);
+        }
+    }
+
+    @Nullable
+    public MoPubAdRenderer getAdRendererForViewType(final int viewType) {
+        return mAdRendererRegistry.getRendererForViewType(viewType);
     }
 
     /**
@@ -139,18 +166,10 @@ void setAdSourceListener(@Nullable final AdSourceListener adSourceListener) {
         mAdSourceListener = adSourceListener;
     }
 
-    void loadAds(@NonNull final Context context,
+    void loadAds(@NonNull final Activity activity,
             @NonNull final String adUnitId,
             final RequestParameters requestParameters) {
-        loadAds(requestParameters, new MoPubNative(context, adUnitId, mMoPubNativeNetworkListener));
-    }
-
-    void loadAds(@NonNull final Context context,
-                 @NonNull final String adUnitId,
-                 final RequestParameters requestParameters,@Nullable Map<String, Object> localExtras) {
-        MoPubNative mopubNative = new MoPubNative(context, adUnitId, mMoPubNativeNetworkListener);
-        mopubNative.setLocalExtras(localExtras);
-        loadAds(requestParameters, mopubNative);
+        loadAds(requestParameters, new MoPubNative(activity, adUnitId, mMoPubNativeNetworkListener));
     }
 
     @VisibleForTesting
@@ -158,6 +177,10 @@ void loadAds(final RequestParameters requestParameters,
              final MoPubNative moPubNative) {
         clear();
 
+        for (MoPubAdRenderer renderer : mAdRendererRegistry.getRendererIterable()) {
+            moPubNative.registerAdRenderer(renderer);
+        }
+
         mRequestParameters = requestParameters;
         mMoPubNative = moPubNative;
 
@@ -176,7 +199,7 @@ void clear() {
 
         mRequestParameters = null;
 
-        for (final TimestampWrapper<NativeResponse> timestampWrapper : mNativeAdCache) {
+        for (final TimestampWrapper<NativeAd> timestampWrapper : mNativeAdCache) {
             timestampWrapper.mInstance.destroy();
         }
         mNativeAdCache.clear();
@@ -198,7 +221,7 @@ void clear() {
      * @return Ad ad item that should be rendered into a view.
      */
     @Nullable
-    NativeResponse dequeueAd() {
+    NativeAd dequeueAd() {
         final long now = SystemClock.uptimeMillis();
 
         // Starting an ad request takes several millis. Post for performance reasons.
@@ -208,7 +231,7 @@ NativeResponse dequeueAd() {
 
         // Dequeue the first ad that hasn't expired.
         while (!mNativeAdCache.isEmpty()) {
-            TimestampWrapper<NativeResponse> responseWrapper = mNativeAdCache.remove(0);
+            TimestampWrapper<NativeAd> responseWrapper = mNativeAdCache.remove(0);
 
             if (now - responseWrapper.mCreatedTimestamp < EXPIRATION_TIME_MILLISECONDS) {
                 return responseWrapper.mInstance;
@@ -219,16 +242,22 @@ NativeResponse dequeueAd() {
 
     @VisibleForTesting
     void updateRetryTime() {
-        // Backoff time calculations
-        mRetryTimeMilliseconds = (int) (mRetryTimeMilliseconds * EXPONENTIAL_BACKOFF_FACTOR);
-        if (mRetryTimeMilliseconds > MAXIMUM_RETRY_TIME_MILLISECONDS) {
-            mRetryTimeMilliseconds = MAXIMUM_RETRY_TIME_MILLISECONDS;
+        if (mCurrentRetries < RETRY_TIME_ARRAY_MILLISECONDS.length - 1) {
+            mCurrentRetries++;
         }
     }
 
     @VisibleForTesting
     void resetRetryTime() {
-        mRetryTimeMilliseconds = DEFAULT_RETRY_TIME_MILLISECONDS;
+        mCurrentRetries = 0;
+    }
+
+    @VisibleForTesting
+    int getRetryTime() {
+        if (mCurrentRetries >= RETRY_TIME_ARRAY_MILLISECONDS.length) {
+            mCurrentRetries = RETRY_TIME_ARRAY_MILLISECONDS.length - 1;
+        }
+        return RETRY_TIME_ARRAY_MILLISECONDS[mCurrentRetries];
     }
 
     /**
@@ -238,17 +267,12 @@ void resetRetryTime() {
      */
     @VisibleForTesting
     void replenishCache() {
-        if (!mRequestInFlight && mMoPubNative != null && mNativeAdCache.size() < cacheLimit) {
+        if (!mRequestInFlight && mMoPubNative != null && mNativeAdCache.size() < CACHE_LIMIT) {
             mRequestInFlight = true;
             mMoPubNative.makeRequest(mRequestParameters, mSequenceNumber);
         }
     }
 
-    @VisibleForTesting
-    void setCacheLimit(int cacheLimit) {
-        this.cacheLimit = cacheLimit;
-    }
-
     @Deprecated
     @VisibleForTesting
     void setMoPubNative(final MoPubNative moPubNative) {
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdViewHelper.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdViewHelper.java
index 326b9623..b600d00d 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdViewHelper.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdViewHelper.java
@@ -1,5 +1,6 @@
 package com.mopub.nativeads;
 
+import android.app.Activity;
 import android.content.Context;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
@@ -13,7 +14,7 @@
 import java.util.WeakHashMap;
 
 /**
- * @deprecated As of release 2.4, use {@link com.mopub.nativeads.MoPubNativeAdRenderer} instead
+ * @deprecated As of release 2.4, use {@link MoPubStaticNativeAdRenderer} instead
  */
 @Deprecated
 class NativeAdViewHelper {
@@ -26,78 +27,60 @@ private NativeAdViewHelper() {
         AD
     }
 
-    // Because the impression tracker requires tracking drawing views,
-    // each context requires a separate impression tracker. To avoid leaking, keep weak references.
-    @VisibleForTesting
-    static final WeakHashMap<Context, ImpressionTracker> sImpressionTrackerMap =
-            new WeakHashMap<Context, ImpressionTracker>();
-
-    // Used to keep track of the last NativeResponse a view was associated with in order to clean
-    // up its state before associating with a new NativeResponse
-    static private final WeakHashMap<View, NativeResponse> sNativeResponseMap =
-            new WeakHashMap<View, NativeResponse>();
+    /**
+     * Used to keep track of the last {@link NativeAd} a view was associated with in order to clean
+     * up its state before associating with a new {@link NativeAd}
+     */
+    static private final WeakHashMap<View, NativeAd> sNativeAdMap =
+            new WeakHashMap<View, NativeAd>();
 
     @Deprecated
     @NonNull
     static View getAdView(@Nullable View convertView,
             @Nullable final ViewGroup parent,
-            @NonNull final Context context,
-            @Nullable final NativeResponse nativeResponse,
+            @NonNull final Activity activity,
+            @Nullable final NativeAd nativeAd,
             @Nullable final ViewBinder viewBinder) {
 
         Preconditions.NoThrow.checkNotNull(viewBinder, "ViewBinder is null.");
 
         if (convertView != null) {
-            clearNativeResponse(context, convertView);
+            clearNativeAd(activity, convertView);
         }
 
-        if (nativeResponse == null || nativeResponse.isDestroyed() || viewBinder == null) {
-            MoPubLog.d("nativeResponse or viewBinder null or invalid. Returning empty view");
+        if (nativeAd == null || nativeAd.isDestroyed() || viewBinder == null) {
+            MoPubLog.d("NativeAd or viewBinder null or invalid. Returning empty view");
             // Only create a view if one hasn't been created already
             if (convertView == null || !ViewType.EMPTY.equals(convertView.getTag())) {
-                convertView = new View(context);
+                convertView = new View(activity);
                 convertView.setTag(ViewType.EMPTY);
                 convertView.setVisibility(View.GONE);
             }
         } else {
-            final MoPubNativeAdRenderer moPubNativeAdRenderer = new MoPubNativeAdRenderer(viewBinder);
             // Only create a view if one hasn't been created already
             if (convertView == null || !ViewType.AD.equals(convertView.getTag())) {
-                convertView = moPubNativeAdRenderer.createAdView(context, parent);
+                convertView = nativeAd.createAdView(activity, parent);
                 convertView.setTag(ViewType.AD);
             }
-            prepareNativeResponse(context, convertView, nativeResponse);
-            moPubNativeAdRenderer.renderAdView(convertView, nativeResponse);
+            prepareNativeAd(activity, convertView, nativeAd);
+            nativeAd.renderAdView(convertView);
         }
 
         return convertView;
     }
 
-    private static void clearNativeResponse(@NonNull final Context context,
+    private static void clearNativeAd(@NonNull final Context context,
             @NonNull final View view) {
-        getImpressionTracker(context).removeView(view);
-        final NativeResponse nativeResponse = sNativeResponseMap.get(view);
-        if (nativeResponse != null) {
-            nativeResponse.clear(view);
+        final NativeAd nativeAd = sNativeAdMap.get(view);
+        if (nativeAd != null) {
+            nativeAd.clear(view);
         }
     }
 
-    private static void prepareNativeResponse(@NonNull final Context context,
+    private static void prepareNativeAd(@NonNull final Context context,
             @NonNull final View view,
-            @NonNull final NativeResponse nativeResponse) {
-        sNativeResponseMap.put(view, nativeResponse);
-        if (!nativeResponse.isOverridingImpressionTracker()) {
-            getImpressionTracker(context).addView(view, nativeResponse);
-        }
-        nativeResponse.prepare(view,null);
-    }
-
-    private static ImpressionTracker getImpressionTracker(@NonNull final Context context) {
-        ImpressionTracker impressionTracker = sImpressionTrackerMap.get(context);
-        if (impressionTracker == null) {
-            impressionTracker = new ImpressionTracker(context);
-            sImpressionTrackerMap.put(context, impressionTracker);
-        }
-        return impressionTracker;
+            @NonNull final NativeAd nativeAd) {
+        sNativeAdMap.put(view, nativeAd);
+        nativeAd.prepare(view);
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeClickHandler.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeClickHandler.java
new file mode 100644
index 00000000..fd66bc7a
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeClickHandler.java
@@ -0,0 +1,150 @@
+package com.mopub.nativeads;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.view.ViewGroup;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.UrlAction;
+import com.mopub.common.UrlHandler;
+import com.mopub.common.VisibleForTesting;
+
+/**
+ * A collection of methods to help with detecting clicks, and handling click destination urls
+ * for native ads.
+ */
+public class NativeClickHandler {
+    @NonNull private final Context mContext;
+    private boolean mClickInProgress;
+
+    public NativeClickHandler(@NonNull final Context context) {
+        Preconditions.checkNotNull(context);
+        mContext = context.getApplicationContext();
+    }
+
+    /**
+     * Sets the on click listener on all views in the native ad view hierarchy to invoke
+     * {@link ClickInterface#handleClick(View)} when a view in the view hierarchy is clicked.
+     *
+     * @param view The top view of the native ad view hierarchy
+     * @param clickInterface The native ad implementing the click interface
+     */
+    public void setOnClickListener(@NonNull final View view,
+            @NonNull final ClickInterface clickInterface) {
+        if (!Preconditions.NoThrow.checkNotNull(view, "Cannot set click listener on a null view")) {
+            return;
+        }
+        if (!Preconditions.NoThrow.checkNotNull(clickInterface,
+                "Cannot set click listener with a null ClickInterface")) {
+            return;
+        }
+
+        setOnClickListener(view, new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                clickInterface.handleClick(v);
+            }
+        });
+    }
+
+    /**
+     * Uses recursion in order to set the on click listener on all views in the view hierarchy.
+     * This is necessary since certain views, such as a button, will not forward the click event
+     * to their parent.
+     *
+     * @param view The top view of the native ad view hierarchy
+     * @param onClickListener The click listener to be invoked on click
+     */
+    private void setOnClickListener(@NonNull final View view,
+            @Nullable final OnClickListener onClickListener) {
+        view.setOnClickListener(onClickListener);
+        if ((view instanceof ViewGroup)) {
+            ViewGroup viewGroup = (ViewGroup)view;
+            for (int i = 0; i < viewGroup.getChildCount(); i++) {
+                setOnClickListener(viewGroup.getChildAt(i), onClickListener);
+            }
+        }
+    }
+
+    /**
+     * Clears the on click listener from all views in the the native ad view hierarchy.
+     *
+     * @param view The top view of the native ad view hierarchy.
+     */
+    public void clearOnClickListener(@NonNull final View view) {
+        if (!Preconditions.NoThrow.checkNotNull(view, "Cannot clear click listener from a null view")) {
+            return;
+        }
+
+        setOnClickListener(view, (OnClickListener) null);
+    }
+
+    /**
+     * Handles resolving and opening the click destination url. A spinning progress view is shown
+     * while the click destination is being resolved.
+     *
+     * @param clickDestinationUrl The click destination url
+     * @param view The view on which to display the spinning progress view
+     */
+    public void openClickDestinationUrl(@NonNull final String clickDestinationUrl,
+            @Nullable final View view) {
+        openClickDestinationUrl(clickDestinationUrl, view, new SpinningProgressView(mContext));
+    }
+
+    @VisibleForTesting
+    void openClickDestinationUrl(@NonNull final String clickDestinationUrl,
+            @Nullable final View view,
+            @NonNull final SpinningProgressView spinningProgressView) {
+        // Use NoThrow here because the clickDestinationUrl will be passed in
+        // by third party custom event writers
+        if (!Preconditions.NoThrow.checkNotNull(clickDestinationUrl,
+                "Cannot open a null click destination url")) {
+            return;
+        }
+        Preconditions.checkNotNull(spinningProgressView);
+
+        if (mClickInProgress) {
+            return;
+        }
+        mClickInProgress = true;
+
+        if (view != null) {
+            spinningProgressView.addToRoot(view);
+        }
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(
+                        UrlAction.IGNORE_ABOUT_SCHEME,
+                        UrlAction.OPEN_NATIVE_BROWSER,
+                        UrlAction.OPEN_APP_MARKET,
+                        UrlAction.OPEN_IN_APP_BROWSER,
+                        UrlAction.HANDLE_SHARE_TWEET,
+                        UrlAction.FOLLOW_DEEP_LINK_WITH_FALLBACK,
+                        UrlAction.FOLLOW_DEEP_LINK)
+                .withResultActions(new UrlHandler.ResultActions() {
+                    @Override
+                    public void urlHandlingSucceeded(@NonNull String url,
+                            @NonNull UrlAction urlAction) {
+                        removeSpinningProgressView();
+                        mClickInProgress = false;
+                    }
+
+                    @Override
+                    public void urlHandlingFailed(@NonNull String url,
+                            @NonNull UrlAction lastFailedUrlAction) {
+                        removeSpinningProgressView();
+                        mClickInProgress = false;
+                    }
+
+                    private void removeSpinningProgressView() {
+                        if (view != null) {
+                            spinningProgressView.removeFromRoot();
+                        }
+                    }
+                })
+                .build().handleUrl(mContext, clickDestinationUrl);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeErrorCode.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeErrorCode.java
index 0dd85382..ff8ad9fd 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeErrorCode.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeErrorCode.java
@@ -4,7 +4,7 @@
 
 public enum NativeErrorCode {
     EMPTY_AD_RESPONSE("Server returned empty response."),
-    INVALID_JSON("Unable to parse JSON response from server."),
+    INVALID_RESPONSE("Unable to parse response from server."),
     IMAGE_DOWNLOAD_FAILURE("Unable to download images associated with ad."),
     INVALID_REQUEST_URL("Invalid request url."),
     UNEXPECTED_RESPONSE_CODE("Received unexpected response code from server."),
@@ -17,8 +17,9 @@
     NETWORK_NO_FILL("Third-party network failed to provide an ad."),
     NETWORK_INVALID_STATE("Third-party network failed due to invalid internal state."),
 
-    NATIVE_ADAPTER_CONFIGURATION_ERROR("Custom Event Native was configured incorrectly."),
-    NATIVE_ADAPTER_NOT_FOUND("Unable to find Custom Event Native.");
+    NATIVE_RENDERER_CONFIGURATION_ERROR("A required renderer was not registered for the CustomEventNative."),
+    NATIVE_ADAPTER_CONFIGURATION_ERROR("CustomEventNative was configured incorrectly."),
+    NATIVE_ADAPTER_NOT_FOUND("Unable to find CustomEventNative.");
 
     private final String message;
 
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeFullScreenVideoView.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeFullScreenVideoView.java
new file mode 100644
index 00000000..91ea4256
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeFullScreenVideoView.java
@@ -0,0 +1,434 @@
+package com.mopub.nativeads;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.content.res.Configuration;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.ColorFilter;
+import android.graphics.Paint;
+import android.graphics.RectF;
+import android.graphics.SurfaceTexture;
+import android.graphics.drawable.Drawable;
+import android.graphics.drawable.GradientDrawable;
+import android.graphics.drawable.GradientDrawable.Orientation;
+import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+import android.view.TextureView;
+import android.view.TextureView.SurfaceTextureListener;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ImageView;
+import android.widget.ProgressBar;
+import android.widget.RelativeLayout;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.util.Dips;
+import com.mopub.common.util.Drawables;
+import com.mopub.common.util.Utils;
+import com.mopub.mobileads.VastVideoProgressBarWidget;
+import com.mopub.mobileads.resource.CloseButtonDrawable;
+import com.mopub.mobileads.resource.CtaButtonDrawable;
+import com.mopub.mobileads.resource.DrawableConstants;
+import com.mopub.mobileads.resource.DrawableConstants.GradientStrip;
+
+@TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+public class NativeFullScreenVideoView extends RelativeLayout {
+
+    public enum Mode { LOADING, PLAYING, PAUSED, FINISHED }
+
+    @VisibleForTesting @NonNull Mode mMode;
+    private int mOrientation;
+
+    // Views
+    @NonNull private final ImageView mCachedVideoFrameView;
+    @NonNull private final TextureView mVideoTexture;
+    @NonNull private final ProgressBar mLoadingSpinner;
+    @NonNull private final ImageView mBottomGradient;
+    @NonNull private final ImageView mTopGradient;
+    @NonNull private final VastVideoProgressBarWidget mVideoProgress;
+    @NonNull private final View mOverlay;
+    @NonNull private final ImageView mPlayButton;
+    @NonNull private final ImageView mPrivacyInformationIcon;
+    @NonNull private final ImageView mCtaButton;
+    @NonNull private final ImageView mCloseControl;
+
+    // Measurements
+    @VisibleForTesting final int mCtaWidthPx;
+    @VisibleForTesting final int mCtaHeightPx;
+    @VisibleForTesting final int mCtaMarginPx;
+    @VisibleForTesting final int mCloseControlSizePx;
+    @VisibleForTesting final int mClosePaddingPx;
+    @VisibleForTesting final int mPrivacyInformationIconSizePx;
+    @VisibleForTesting final int mPlayControlSizePx;
+    @VisibleForTesting final int mGradientStripHeightPx;
+
+    public NativeFullScreenVideoView(@NonNull final Context context, int orientation, @Nullable String ctaText) {
+        this(context, orientation, ctaText,
+                new ImageView(context),
+                new TextureView(context), new ProgressBar(context), new ImageView(context),
+                new ImageView(context), new VastVideoProgressBarWidget(context), new View(context),
+                new ImageView(context), new ImageView(context), new ImageView(context),
+                new ImageView(context));
+    }
+
+    @VisibleForTesting
+    NativeFullScreenVideoView(@NonNull final Context context, int orientation,
+            @Nullable final String ctaText,
+            @NonNull final ImageView cachedImageView,
+            @NonNull final TextureView videoTexture,
+            @NonNull final ProgressBar loadingSpinner, @NonNull final ImageView bottomGradient,
+            @NonNull final ImageView topGradient,
+            @NonNull final VastVideoProgressBarWidget videoProgress, @NonNull final View overlay,
+            @NonNull final ImageView playButton, @NonNull final ImageView privacyInformationIcon,
+            @NonNull final ImageView ctaButton, @NonNull final ImageView closeControl) {
+        super(context);
+        Preconditions.checkNotNull(context);
+        Preconditions.checkNotNull(cachedImageView);
+        Preconditions.checkNotNull(videoTexture);
+        Preconditions.checkNotNull(loadingSpinner);
+        Preconditions.checkNotNull(bottomGradient);
+        Preconditions.checkNotNull(topGradient);
+        Preconditions.checkNotNull(videoProgress);
+        Preconditions.checkNotNull(overlay);
+        Preconditions.checkNotNull(playButton);
+        Preconditions.checkNotNull(privacyInformationIcon);
+        Preconditions.checkNotNull(ctaButton);
+        Preconditions.checkNotNull(closeControl);
+
+        mOrientation = orientation;
+        mMode = Mode.LOADING;
+
+        mCtaWidthPx = Dips.asIntPixels(200, context);
+        mCtaHeightPx = Dips.asIntPixels(42, context);
+        mCtaMarginPx = Dips.asIntPixels(10, context);
+        mCloseControlSizePx = Dips.asIntPixels(50, context);
+        mClosePaddingPx = Dips.asIntPixels(8, context);
+        mPrivacyInformationIconSizePx = Dips.asIntPixels(44, context);
+        mPlayControlSizePx = Dips.asIntPixels(50, context);
+        mGradientStripHeightPx = Dips.asIntPixels(45, context);
+
+        // Instantiate and initialize the views.
+        final RelativeLayout.LayoutParams videoTextureLayoutParams =
+                new RelativeLayout.LayoutParams(LayoutParams.MATCH_PARENT,
+                        LayoutParams.MATCH_PARENT);
+        videoTextureLayoutParams.addRule(CENTER_IN_PARENT);
+
+        mVideoTexture = videoTexture;
+        mVideoTexture.setId((int) Utils.generateUniqueId());
+        mVideoTexture.setLayoutParams(videoTextureLayoutParams);
+        addView(mVideoTexture);
+
+        mCachedVideoFrameView = cachedImageView;
+        mCachedVideoFrameView.setId((int) Utils.generateUniqueId());
+        mCachedVideoFrameView.setLayoutParams(videoTextureLayoutParams);
+        mCachedVideoFrameView.setBackgroundColor(Color.TRANSPARENT);
+        addView(mCachedVideoFrameView);
+
+        RelativeLayout.LayoutParams spinnerParams =
+                new RelativeLayout.LayoutParams(mPlayControlSizePx, mPlayControlSizePx);
+        spinnerParams.addRule(RelativeLayout.CENTER_IN_PARENT);
+        mLoadingSpinner = loadingSpinner;
+        mLoadingSpinner.setId((int) Utils.generateUniqueId());
+        mLoadingSpinner.setBackground(new LoadingBackground(context));
+        mLoadingSpinner.setLayoutParams(spinnerParams);
+        mLoadingSpinner.setIndeterminate(true);
+        addView(mLoadingSpinner);
+
+        RelativeLayout.LayoutParams bottomGradientParams = new RelativeLayout.LayoutParams(
+                RelativeLayout.LayoutParams.MATCH_PARENT, mGradientStripHeightPx);
+        bottomGradientParams.addRule(RelativeLayout.ALIGN_BOTTOM, mVideoTexture.getId());
+        mBottomGradient = bottomGradient;
+        mBottomGradient.setId((int) Utils.generateUniqueId());
+        mBottomGradient.setLayoutParams(bottomGradientParams);
+        final GradientDrawable bottomGradientDrawable = new GradientDrawable(Orientation.BOTTOM_TOP,
+                new int[] {GradientStrip.START_COLOR, GradientStrip.END_COLOR});
+        mBottomGradient.setImageDrawable(bottomGradientDrawable);
+        addView(mBottomGradient);
+
+        RelativeLayout.LayoutParams topGradientParams = new RelativeLayout.LayoutParams(
+                RelativeLayout.LayoutParams.MATCH_PARENT, mGradientStripHeightPx);
+        topGradientParams.addRule(RelativeLayout.ALIGN_PARENT_TOP);
+        mTopGradient = topGradient;
+        mTopGradient.setId((int) Utils.generateUniqueId());
+        mTopGradient.setLayoutParams(topGradientParams);
+        final GradientDrawable topGradientDrawable = new GradientDrawable(Orientation.TOP_BOTTOM,
+                new int[] {GradientStrip.START_COLOR, GradientStrip.END_COLOR});
+        mTopGradient.setImageDrawable(topGradientDrawable);
+        addView(mTopGradient);
+
+        mVideoProgress = videoProgress;
+        mVideoProgress.setId((int) Utils.generateUniqueId());
+        mVideoProgress.setAnchorId(mVideoTexture.getId());
+        mVideoProgress.calibrateAndMakeVisible(1000, 0);
+        addView(mVideoProgress);
+
+        final RelativeLayout.LayoutParams overlayParams =
+                new LayoutParams(LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);
+        overlayParams.addRule(RelativeLayout.CENTER_IN_PARENT);
+        mOverlay = overlay;
+        mOverlay.setId((int) Utils.generateUniqueId());
+        mOverlay.setLayoutParams(overlayParams);
+        mOverlay.setBackgroundColor(DrawableConstants.TRANSPARENT_GRAY);
+        addView(mOverlay);
+
+        RelativeLayout.LayoutParams playButtonParams =
+                new RelativeLayout.LayoutParams(mPlayControlSizePx, mPlayControlSizePx);
+        playButtonParams.addRule(RelativeLayout.CENTER_IN_PARENT);
+        mPlayButton = playButton;
+        mPlayButton.setId((int) Utils.generateUniqueId());
+        mPlayButton.setLayoutParams(playButtonParams);
+        mPlayButton.setImageDrawable(Drawables.NATIVE_PLAY.createDrawable(context));
+        addView(mPlayButton);
+
+        mPrivacyInformationIcon = privacyInformationIcon;
+        mPrivacyInformationIcon.setId((int) Utils.generateUniqueId());
+        mPrivacyInformationIcon.setImageDrawable(
+                Drawables.NATIVE_PRIVACY_INFORMATION_ICON.createDrawable(context));
+        mPrivacyInformationIcon.setPadding(mClosePaddingPx, mClosePaddingPx, mClosePaddingPx * 2,
+                mClosePaddingPx * 2);
+        addView(mPrivacyInformationIcon);
+
+        CtaButtonDrawable ctaDrawable = new CtaButtonDrawable(context);
+        if (!TextUtils.isEmpty(ctaText)) {
+            ctaDrawable.setCtaText(ctaText);
+        }
+        mCtaButton = ctaButton;
+        mCtaButton.setId((int) Utils.generateUniqueId());
+        mCtaButton.setImageDrawable(ctaDrawable);
+        addView(mCtaButton);
+
+        mCloseControl = closeControl;
+        mCloseControl.setId((int) Utils.generateUniqueId());
+        mCloseControl.setImageDrawable(new CloseButtonDrawable());
+        mCloseControl.setPadding(mClosePaddingPx * 3, mClosePaddingPx, mClosePaddingPx, mClosePaddingPx * 3);
+        addView(mCloseControl);
+
+        updateViewState();
+    }
+
+    public void resetProgress() {
+        mVideoProgress.reset();
+    }
+
+    public void setMode(@NonNull final Mode mode) {
+        Preconditions.checkNotNull(mode);
+        if (mMode == mode) {
+            return;
+        }
+
+        mMode = mode;
+        updateViewState();
+    }
+
+    @NonNull
+    public TextureView getTextureView() {
+        return mVideoTexture;
+    }
+
+    public void setOrientation(final int orientation) {
+        if (mOrientation == orientation) {
+            return;
+        }
+        mOrientation = orientation;
+        updateViewState();
+    }
+
+    public void setSurfaceTextureListener(
+            @Nullable final SurfaceTextureListener surfaceTextureListener) {
+        mVideoTexture.setSurfaceTextureListener(surfaceTextureListener);
+
+        SurfaceTexture surfaceTexture = mVideoTexture.getSurfaceTexture();
+        if (surfaceTexture != null && surfaceTextureListener != null) {
+            surfaceTextureListener.onSurfaceTextureAvailable(
+                    surfaceTexture, mVideoTexture.getWidth(), mVideoTexture.getHeight());
+        }
+    }
+
+    public void setCloseControlListener(@Nullable OnClickListener closeControlListener) {
+        mCloseControl.setOnClickListener(closeControlListener);
+    }
+
+    public void setPrivacyInformationClickListener(
+            @Nullable OnClickListener privacyInformationListener) {
+        mPrivacyInformationIcon.setOnClickListener(privacyInformationListener);
+    }
+
+    public void setCtaClickListener(@Nullable OnClickListener ctaListener) {
+        mCtaButton.setOnClickListener(ctaListener);
+    }
+
+    public void setPlayControlClickListener(@Nullable OnClickListener playControlListener) {
+        mPlayButton.setOnClickListener(playControlListener);
+        mOverlay.setOnClickListener(playControlListener);
+    }
+
+    public void updateProgress(final int progressPercentage) {
+        mVideoProgress.updateProgress(progressPercentage);
+    }
+
+    public void setCachedVideoFrame(@Nullable Bitmap cachedVideoFrame) {
+        mCachedVideoFrameView.setImageBitmap(cachedVideoFrame);
+    }
+
+    private void updateViewState() {
+        switch (mMode) {
+            case LOADING:
+                setCachedImageVisibility(VISIBLE);
+                setLoadingSpinnerVisibility(VISIBLE);
+                setVideoProgressVisibility(INVISIBLE);
+                setPlayButtonVisibility(INVISIBLE);
+                break;
+            case PLAYING:
+                setCachedImageVisibility(INVISIBLE);
+                setLoadingSpinnerVisibility(INVISIBLE);
+                setVideoProgressVisibility(VISIBLE);
+                setPlayButtonVisibility(INVISIBLE);
+                break;
+            case PAUSED:
+                setCachedImageVisibility(INVISIBLE);
+                setLoadingSpinnerVisibility(INVISIBLE);
+                setVideoProgressVisibility(VISIBLE);
+                setPlayButtonVisibility(VISIBLE);
+                break;
+            case FINISHED:
+                setCachedImageVisibility(VISIBLE);
+                setLoadingSpinnerVisibility(INVISIBLE);
+                setVideoProgressVisibility(INVISIBLE);
+                setPlayButtonVisibility(VISIBLE);
+                break;
+            default:
+                break;
+        }
+
+        updateVideoTextureLayout();
+        updateControlLayouts();
+    }
+
+    private void setCachedImageVisibility(final int visibility) {
+        mCachedVideoFrameView.setVisibility(visibility);
+    }
+
+    private void setLoadingSpinnerVisibility(final int visibility) {
+        mLoadingSpinner.setVisibility(visibility);
+    }
+
+    private void setVideoProgressVisibility(final int visibility) {
+        mVideoProgress.setVisibility(visibility);
+    }
+
+    private void setPlayButtonVisibility(final int visibility) {
+        mPlayButton.setVisibility(visibility);
+        mOverlay.setVisibility(visibility);
+    }
+
+    private void updateVideoTextureLayout() {
+        final Configuration configuration = getContext().getResources().getConfiguration();
+        ViewGroup.LayoutParams layoutParams = mVideoTexture.getLayoutParams();
+        int newWidth = Dips.dipsToIntPixels((float) configuration.screenWidthDp, getContext());
+        if (newWidth != layoutParams.width) {
+            layoutParams.width = newWidth;
+        }
+        int newHeight = Dips.dipsToIntPixels((float) configuration.screenWidthDp * 9 / 16, getContext());
+        if (newHeight != layoutParams.height) {
+            layoutParams.height = newHeight;
+        }
+    }
+
+    private void updateControlLayouts() {
+        final RelativeLayout.LayoutParams ctaParams =
+                new RelativeLayout.LayoutParams(mCtaWidthPx, mCtaHeightPx);
+        ctaParams.setMargins(mCtaMarginPx, mCtaMarginPx, mCtaMarginPx, mCtaMarginPx);
+        final RelativeLayout.LayoutParams privacyInformationIconParams =
+                new RelativeLayout.LayoutParams(mPrivacyInformationIconSizePx,
+                        mPrivacyInformationIconSizePx);
+        final RelativeLayout.LayoutParams closeParams =
+                new RelativeLayout.LayoutParams(mCloseControlSizePx, mCloseControlSizePx);
+
+
+        switch (mOrientation) {
+            case Configuration.ORIENTATION_PORTRAIT:
+                ctaParams.addRule(RelativeLayout.BELOW, mVideoTexture.getId());
+                ctaParams.addRule(RelativeLayout.CENTER_HORIZONTAL);
+
+                privacyInformationIconParams.addRule(RelativeLayout.ALIGN_PARENT_TOP);
+                privacyInformationIconParams.addRule(RelativeLayout.ALIGN_PARENT_LEFT);
+
+                closeParams.addRule(RelativeLayout.ALIGN_PARENT_TOP);
+                closeParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
+                break;
+            case Configuration.ORIENTATION_LANDSCAPE:
+                ctaParams.addRule(RelativeLayout.ABOVE, mVideoProgress.getId());
+                ctaParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
+
+                privacyInformationIconParams.addRule(RelativeLayout.ALIGN_TOP, mVideoTexture.getId());
+                privacyInformationIconParams.addRule(RelativeLayout.ALIGN_LEFT, mVideoTexture.getId());
+
+                closeParams.addRule(RelativeLayout.ALIGN_TOP, mVideoTexture.getId());
+                closeParams.addRule(RelativeLayout.ALIGN_RIGHT, mVideoTexture.getId());
+                break;
+            default:
+                // Do nothing.
+                break;
+        }
+
+        mCtaButton.setLayoutParams(ctaParams);
+        mPrivacyInformationIcon.setLayoutParams(privacyInformationIconParams);
+        mCloseControl.setLayoutParams(closeParams);
+    }
+
+    @VisibleForTesting
+    static class LoadingBackground extends Drawable {
+        @NonNull private final RectF mButtonRect;
+        @NonNull private final Paint mPaint;
+        @VisibleForTesting final int mCornerRadiusPx;
+
+        LoadingBackground(@NonNull final Context context) {
+            this(context, new RectF(), new Paint());
+        }
+
+        LoadingBackground(@NonNull final Context context,
+                @NonNull final RectF rectF,
+                @NonNull final Paint paint) {
+            Preconditions.checkNotNull(context);
+            Preconditions.checkNotNull(rectF);
+            Preconditions.checkNotNull(paint);
+
+            mButtonRect = rectF;
+            mPaint = paint;
+            mPaint.setColor(Color.BLACK);
+            mPaint.setAlpha(128);
+            mPaint.setAntiAlias(true);
+            mCornerRadiusPx = Dips.asIntPixels(5, context);
+        }
+
+        @Override
+        public void draw(Canvas canvas) {
+            mButtonRect.set(getBounds());
+
+            // Rounded rectangle background fill
+            canvas.drawRoundRect(mButtonRect, mCornerRadiusPx, mCornerRadiusPx, mPaint);
+        }
+
+        @Override
+        public void setAlpha(int alpha) { }
+
+        @Override
+        public void setColorFilter(ColorFilter cf) { }
+
+        @Override
+        public int getOpacity() {
+            return 0;
+        }
+    };
+
+    @Deprecated
+    @VisibleForTesting
+    ImageView getCtaButton() {
+        return mCtaButton;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeImageHelper.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeImageHelper.java
new file mode 100644
index 00000000..c01a329b
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeImageHelper.java
@@ -0,0 +1,122 @@
+package com.mopub.nativeads;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+import android.widget.ImageView;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.nativeads.CustomEventNative.CustomEventNativeListener;
+import com.mopub.network.Networking;
+import com.mopub.volley.VolleyError;
+import com.mopub.volley.toolbox.ImageLoader;
+
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * Collection of helper methods to assist with image downloading and displaying
+ */
+public class NativeImageHelper {
+
+    public interface ImageListener {
+        /**
+         * Called when images are successfully cached. If you haven't already called {@link
+         * CustomEventNativeListener#onNativeAdLoaded}, you should typically do so now.
+         */
+        void onImagesCached();
+
+        /**
+         * Called when images failed to cache. You should typically call {@link
+         * CustomEventNativeListener#onNativeAdFailed} from this callback.
+         *
+         * @param errorCode An enum value with the relevant error message.
+         */
+        void onImagesFailedToCache(NativeErrorCode errorCode);
+    }
+
+    /**
+     * Pre caches the given set of image urls. We recommend using this method to warm the image
+     * cache before calling {@link CustomEventNativeListener#onNativeAdLoaded}. Doing so will
+     * force images to cache before displaying the ad.
+     */
+    public static void preCacheImages(@NonNull final Context context,
+            @NonNull final List<String> imageUrls,
+            @NonNull final ImageListener imageListener) {
+        final ImageLoader imageLoader = Networking.getImageLoader(context);
+        // These Atomics are only accessed on the main thread.
+        // We use Atomics here so we can change their values while keeping a reference for the inner class.
+        final AtomicInteger imageCounter = new AtomicInteger(imageUrls.size());
+        final AtomicBoolean anyFailures = new AtomicBoolean(false);
+        ImageLoader.ImageListener volleyImageListener = new ImageLoader.ImageListener() {
+            @Override
+            public void onResponse(final ImageLoader.ImageContainer imageContainer, final boolean isImmediate) {
+                // Image Loader returns a "default" response immediately. We want to ignore this
+                // unless the image is already cached.
+                if (imageContainer.getBitmap() != null) {
+                    final int count = imageCounter.decrementAndGet();
+                    if (count == 0 && !anyFailures.get()) {
+                        imageListener.onImagesCached();
+                    }
+                }
+            }
+
+            @Override
+            public void onErrorResponse(final VolleyError volleyError) {
+                MoPubLog.d("Failed to download a native ads image:", volleyError);
+                boolean anyPreviousErrors = anyFailures.getAndSet(true);
+                imageCounter.decrementAndGet();
+                if (!anyPreviousErrors) {
+                    imageListener.onImagesFailedToCache(NativeErrorCode.IMAGE_DOWNLOAD_FAILURE);
+                }
+            }
+        };
+
+        for (String url : imageUrls) {
+            if (TextUtils.isEmpty(url)) {
+                anyFailures.set(true);
+                imageListener.onImagesFailedToCache(NativeErrorCode.IMAGE_DOWNLOAD_FAILURE);
+                return;
+            }
+            imageLoader.get(url, volleyImageListener);
+        }
+    }
+
+    /**
+     * Helper method that takes an image url and loads the image into an image view.
+     *
+     * @param url The image url
+     * @param imageView The image view into which to load the image
+     */
+    public static void loadImageView(@Nullable final String url, @Nullable final ImageView imageView) {
+        if (!Preconditions.NoThrow.checkNotNull(imageView, "Cannot load image into null ImageView")) {
+            return;
+        }
+
+        if (!Preconditions.NoThrow.checkNotNull(url, "Cannot load image with null url")) {
+            imageView.setImageDrawable(null);
+            return;
+        }
+
+        final ImageLoader mImageLoader = Networking.getImageLoader(imageView.getContext());
+        mImageLoader.get(url, new ImageLoader.ImageListener() {
+            @Override
+            public void onResponse(final ImageLoader.ImageContainer imageContainer,
+                    final boolean isImmediate) {
+                if (!isImmediate) {
+                    MoPubLog.d("Image was not loaded immediately into your ad view. You should call preCacheImages as part of your custom event loading process.");
+                }
+                imageView.setImageBitmap(imageContainer.getBitmap());
+            }
+
+            @Override
+            public void onErrorResponse(final VolleyError volleyError) {
+                MoPubLog.d("Failed to load image.", volleyError);
+                imageView.setImageDrawable(null);
+            }
+        });
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeRendererHelper.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeRendererHelper.java
new file mode 100644
index 00000000..53c1f451
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeRendererHelper.java
@@ -0,0 +1,141 @@
+package com.mopub.nativeads;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.view.View;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import com.mopub.common.UrlAction;
+import com.mopub.common.UrlHandler;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Drawables;
+
+import java.util.Map;
+
+/**
+ * A set of helper methods for Native Ad Rendering
+ */
+public class NativeRendererHelper {
+    public static void addTextView(@Nullable final TextView textView,
+            @Nullable final String contents) {
+        if (textView == null) {
+            MoPubLog.d("Attempted to add text (" + contents + ") to null TextView.");
+            return;
+        }
+
+        // Clear previous value
+        textView.setText(null);
+
+        if (contents == null) {
+            MoPubLog.d("Attempted to set TextView contents to null.");
+        } else {
+            textView.setText(contents);
+        }
+    }
+
+    /**
+     * Fills in the Privacy Information Icon with the specified image url and attaches a click
+     * listener for the clickthrough url.
+     *
+     * @param privacyInformationIconImageView   The image view of where the icon is supposed to be
+     *                                          placed. If this is null, this method does nothing.
+     * @param privacyInformationImageUrl        The image url. If this is null, the default MoPub
+     *                                          icon is used.
+     * @param privacyInformationClickthroughUrl The clickthrough url for the privacy information
+     *                                          icon. If this is null, the icon will be cleared.
+     */
+    public static void addPrivacyInformationIcon(final ImageView privacyInformationIconImageView,
+            final String privacyInformationImageUrl,
+            final String privacyInformationClickthroughUrl) {
+        if (privacyInformationIconImageView == null) {
+            return;
+        }
+        if (privacyInformationClickthroughUrl == null) {
+            privacyInformationIconImageView.setImageDrawable(null);
+            privacyInformationIconImageView.setOnClickListener(null);
+            privacyInformationIconImageView.setVisibility(View.INVISIBLE);
+            return;
+        }
+
+        final Context context = privacyInformationIconImageView.getContext();
+        if (context == null) {
+            return;
+        }
+
+        if (privacyInformationImageUrl == null) {
+            privacyInformationIconImageView.setImageDrawable(
+                    Drawables.NATIVE_PRIVACY_INFORMATION_ICON.createDrawable(context));
+        } else {
+            NativeImageHelper.loadImageView(privacyInformationImageUrl,
+                    privacyInformationIconImageView);
+        }
+
+        privacyInformationIconImageView.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(final View v) {
+                new UrlHandler.Builder()
+                        .withSupportedUrlActions(
+                                UrlAction.IGNORE_ABOUT_SCHEME,
+                                UrlAction.OPEN_NATIVE_BROWSER,
+                                UrlAction.OPEN_IN_APP_BROWSER,
+                                UrlAction.HANDLE_SHARE_TWEET,
+                                UrlAction.FOLLOW_DEEP_LINK_WITH_FALLBACK,
+                                UrlAction.FOLLOW_DEEP_LINK)
+                        .build().handleUrl(context, privacyInformationClickthroughUrl);
+            }
+        });
+        privacyInformationIconImageView.setVisibility(View.VISIBLE);
+    }
+
+    public static void addCtaButton(@Nullable final TextView ctaTextView,
+            @Nullable final View rootView, @Nullable final String contents) {
+        addTextView(ctaTextView, contents);
+
+        if (ctaTextView == null || rootView == null) {
+            return;
+        }
+
+        // Defer click to rootView's onClickListener, which should also fire click and
+        // impression trackers as needed.
+        ctaTextView.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(final View v) {
+                rootView.performClick();
+            }
+        });
+    }
+
+    public static void updateExtras(@Nullable final View mainView,
+            @NonNull final Map<String, Integer> extrasIds,
+            @NonNull final Map<String, Object> extras) {
+        if (mainView == null) {
+            MoPubLog.w("Attempted to bind extras on a null main view.");
+            return;
+        }
+
+        for (final String key : extrasIds.keySet()) {
+            final int resourceId = extrasIds.get(key);
+            final View view = mainView.findViewById(resourceId);
+            final Object content = extras.get(key);
+
+            if (view instanceof ImageView) {
+                // Clear previous image
+                ((ImageView) view).setImageDrawable(null);
+                final Object object = extras.get(key);
+                if (object != null && object instanceof String) {
+                    NativeImageHelper.loadImageView((String) object, (ImageView) view);
+                }
+            } else if (view instanceof TextView) {
+                // Clear previous text value
+                ((TextView) view).setText(null);
+                if (content instanceof String) {
+                    NativeRendererHelper.addTextView((TextView) view, (String) content);
+                }
+            } else {
+                MoPubLog.d("View bound to " + key + " should be an instance of TextView or ImageView.");
+            }
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeVideoController.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeVideoController.java
new file mode 100644
index 00000000..4ef5ea6e
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeVideoController.java
@@ -0,0 +1,619 @@
+package com.mopub.nativeads;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.media.AudioManager;
+import android.media.AudioManager.OnAudioFocusChangeListener;
+import android.media.MediaCodec;
+import android.net.Uri;
+import android.os.Build;
+import android.os.Handler;
+import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.view.Surface;
+import android.view.TextureView;
+
+import com.google.android.exoplayer.ExoPlaybackException;
+import com.google.android.exoplayer.ExoPlayer;
+import com.google.android.exoplayer.MediaCodecAudioTrackRenderer;
+import com.google.android.exoplayer.MediaCodecVideoTrackRenderer;
+import com.google.android.exoplayer.extractor.Extractor;
+import com.google.android.exoplayer.extractor.ExtractorSampleSource;
+import com.google.android.exoplayer.extractor.mp4.Mp4Extractor;
+import com.google.android.exoplayer.upstream.Allocator;
+import com.google.android.exoplayer.upstream.DataSource;
+import com.google.android.exoplayer.upstream.DefaultAllocator;
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.event.BaseEvent;
+import com.mopub.common.event.Event;
+import com.mopub.common.event.EventDetails;
+import com.mopub.common.event.MoPubEvents;
+import com.mopub.mobileads.RepeatingHandlerRunnable;
+import com.mopub.mobileads.VastTracker;
+import com.mopub.mobileads.VastVideoConfig;
+import com.mopub.nativeads.NativeVideoController.NativeVideoProgressRunnable.ProgressListener;
+import com.mopub.nativeads.VisibilityTracker.VisibilityChecker;
+import com.mopub.network.TrackingRequest;
+
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Wrapper class around the {@link ExoPlayer} to provide a nice interface into the player along
+ * with some helper methods. This class is not thread safe.
+ */
+@TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+public class NativeVideoController implements ExoPlayer.Listener,OnAudioFocusChangeListener {
+
+    public interface Listener {
+        void onStateChanged(boolean playWhenReady, int playbackState);
+        void onError(Exception e);
+    }
+
+    @NonNull private final static Map<Long, NativeVideoController> sManagerMap =
+            new HashMap<Long, NativeVideoController>(4);
+
+    public static final int STATE_READY = ExoPlayer.STATE_READY;
+    public static final int STATE_BUFFERING = ExoPlayer.STATE_BUFFERING;
+    public static final int STATE_IDLE = ExoPlayer.STATE_IDLE;
+    public static final int STATE_PREPARING = ExoPlayer.STATE_PREPARING;
+    public static final int STATE_ENDED = ExoPlayer.STATE_ENDED;
+    public static final int STATE_CLEARED = ExoPlayer.STATE_ENDED + 1;
+
+    public static final long RESUME_FINISHED_THRESHOLD = 750L;
+
+    private static final int BUFFER_SEGMENT_SIZE = 64 * 1024; // 64 kB
+    private static final int BUFFER_SEGMENT_COUNT = 32; // 64 kB * 32 ~= 2 MB
+
+    @NonNull private final Context mContext;
+    @NonNull private final Handler mHandler;
+    @NonNull private final ExoPlayerFactory mExoPlayerFactory;
+    @NonNull private VastVideoConfig mVastVideoConfig;
+    @NonNull private NativeVideoProgressRunnable mNativeVideoProgressRunnable;
+    @NonNull private AudioManager mAudioManager;
+
+    @Nullable private Listener mListener;
+    @Nullable private OnAudioFocusChangeListener mOnAudioFocusChangeListener;
+    @Nullable private Surface mSurface;
+    @Nullable private TextureView mTextureView;
+    @Nullable private WeakReference<Object> mOwnerRef;
+    @Nullable private volatile ExoPlayer mExoPlayer;
+    @Nullable private BitmapDrawable mFinalFrame;
+    @Nullable private MediaCodecAudioTrackRenderer mAudioTrackRenderer;
+    @Nullable private MediaCodecVideoTrackRenderer mVideoTrackRenderer;
+    @Nullable private EventDetails mEventDetails;
+
+    private boolean mPlayWhenReady;
+    private boolean mAudioEnabled;
+    private boolean mAppAudioEnabled;
+    private int mPreviousExoPlayerState = ExoPlayer.STATE_IDLE;
+    private boolean mExoPlayerStateStartedFromIdle = true;
+
+    /**
+     * Create a new NativeVideoController for this id with the given parameters.
+     * Any existing entry with the same id is removed.
+     * @param id
+     * @return
+     */
+    @NonNull
+    public static NativeVideoController createForId(final long id,
+            @NonNull final Context context,
+            @NonNull final List<VisibilityTrackingEvent> visibilityTrackingEvents,
+            @NonNull final VastVideoConfig vastVideoConfig,
+            @Nullable final EventDetails eventDetails) {
+        NativeVideoController nvc = new NativeVideoController(context, visibilityTrackingEvents,
+                vastVideoConfig, eventDetails);
+        sManagerMap.put(id, nvc);
+        return nvc;
+    }
+
+    @NonNull
+    @VisibleForTesting
+    public static NativeVideoController createForId(final long id,
+            @NonNull final Context context,
+            @NonNull final VastVideoConfig vastVideoConfig,
+            @NonNull final NativeVideoProgressRunnable nativeVideoProgressRunnable,
+            @NonNull final ExoPlayerFactory exoPlayerFactory,
+            @Nullable final EventDetails eventDetails,
+            @NonNull final AudioManager audioManager) {
+        NativeVideoController nvc = new NativeVideoController(context, vastVideoConfig,
+                nativeVideoProgressRunnable, exoPlayerFactory, eventDetails, audioManager);
+        sManagerMap.put(id, nvc);
+        return nvc;
+    }
+
+    @VisibleForTesting
+    static void setForId(final long id,
+            @NonNull final NativeVideoController nativeVideoController) {
+        sManagerMap.put(id, nativeVideoController);
+    }
+
+    @Nullable
+    public static NativeVideoController getForId(final long id) {
+        return sManagerMap.get(id);
+    }
+
+    @Nullable
+    public static NativeVideoController remove(final long id) {
+        return sManagerMap.remove(id);
+    }
+
+    private NativeVideoController(@NonNull final Context context,
+            @NonNull final List<VisibilityTrackingEvent> visibilityTrackingEvents,
+            @NonNull final VastVideoConfig vastVideoConfig,
+            @Nullable final EventDetails eventDetails) {
+        this(context, vastVideoConfig,
+                new NativeVideoProgressRunnable(context,
+                        new Handler(Looper.getMainLooper()),
+                        visibilityTrackingEvents,
+                        vastVideoConfig),
+                new ExoPlayerFactory(),
+                eventDetails, 
+                (AudioManager) context.getSystemService(Context.AUDIO_SERVICE));
+    }
+
+    private NativeVideoController(@NonNull final Context context,
+            @NonNull final VastVideoConfig vastVideoConfig,
+            @NonNull final NativeVideoProgressRunnable nativeVideoProgressRunnable,
+            @NonNull final ExoPlayerFactory exoPlayerFactory,
+            @Nullable final EventDetails eventDetails,
+            @NonNull final AudioManager audioManager) {
+        Preconditions.checkNotNull(context);
+        Preconditions.checkNotNull(vastVideoConfig);
+        Preconditions.checkNotNull(exoPlayerFactory);
+        Preconditions.checkNotNull(audioManager);
+
+        mContext = context.getApplicationContext();
+        mHandler = new Handler(Looper.getMainLooper());
+        mVastVideoConfig = vastVideoConfig;
+        mNativeVideoProgressRunnable = nativeVideoProgressRunnable;
+        mExoPlayerFactory = exoPlayerFactory;
+        mEventDetails = eventDetails;
+        mAudioManager = audioManager;
+    }
+
+    public void setListener(@Nullable final Listener listener) {
+        mListener = listener;
+    }
+
+    public void setProgressListener(@Nullable final ProgressListener progressListener) {
+        mNativeVideoProgressRunnable.setProgressListener(progressListener);
+    }
+
+    public void setOnAudioFocusChangeListener(@Nullable final OnAudioFocusChangeListener onAudioFocusChangeListener) {
+        mOnAudioFocusChangeListener = onAudioFocusChangeListener;
+    }
+
+    public void setPlayWhenReady(final boolean playWhenReady) {
+        if (mPlayWhenReady == playWhenReady) {
+            return;
+        }
+
+        mPlayWhenReady = playWhenReady;
+        setExoPlayWhenReady();
+    }
+
+    public int getPlaybackState() {
+        if (mExoPlayer == null) {
+            return STATE_CLEARED;
+        }
+
+        return mExoPlayer.getPlaybackState();
+    }
+
+    public void setAudioEnabled(final boolean audioEnabled) {
+        mAudioEnabled = audioEnabled;
+        setExoAudio();
+    }
+
+    public void setAppAudioEnabled(final boolean audioEnabled) {
+        if (mAppAudioEnabled == audioEnabled) {
+            return;
+        }
+        mAppAudioEnabled = audioEnabled;
+
+        if (mAppAudioEnabled) {
+            mAudioManager.requestAudioFocus(this,
+                    AudioManager.STREAM_MUSIC,
+                    // Request permanent focus.
+                    AudioManager.AUDIOFOCUS_GAIN);
+        } else {
+            mAudioManager.abandonAudioFocus(this);
+        }
+    }
+
+    public void setAudioVolume(final float volume) {
+        if (!mAudioEnabled) {
+            return;
+        }
+
+        setExoAudio(volume);
+    }
+
+    @Override
+    public void onAudioFocusChange(int focusChange) {
+        if (mOnAudioFocusChangeListener == null) {
+            return;
+        }
+
+        mOnAudioFocusChangeListener.onAudioFocusChange(focusChange);
+    }
+
+    public void setTextureView(@NonNull final TextureView textureView) {
+        Preconditions.checkNotNull(textureView);
+
+        mSurface = new Surface(textureView.getSurfaceTexture());
+        mTextureView = textureView;
+        mNativeVideoProgressRunnable.setTextureView(mTextureView);
+        setExoSurface(mSurface);
+    }
+
+    /**
+     * This method is called to prepare the controller for playback. Calling this method will
+     * initiate video download.
+     */
+    public void prepare(@NonNull final Object owner) {
+        Preconditions.checkNotNull(owner);
+
+        mOwnerRef = new WeakReference<Object>(owner);
+        clearExistingPlayer();
+        preparePlayer();
+        setExoSurface(mSurface);
+    }
+
+    /**
+     * The controller will stop rendering to its surfacetexture when this method is called.
+     */
+    public void clear() {
+        setPlayWhenReady(false);
+        mSurface = null;
+        clearExistingPlayer();
+    }
+
+    /**
+     * Releases video player resources. After calling this, you must call prepare() again.
+     */
+    public void release(@NonNull final Object owner) {
+        Preconditions.checkNotNull(owner);
+
+        final Object object = mOwnerRef == null ? null : mOwnerRef.get();
+        if (object == owner) {
+            clearExistingPlayer();
+        }
+    }
+
+    @Override
+    public void onPlayerStateChanged(final boolean playWhenReady, final int newState) {
+        updateProgressRunnable(playWhenReady, newState);
+
+        if (newState == STATE_ENDED && mFinalFrame == null) {
+            mFinalFrame = new BitmapDrawable(mContext.getResources(), mTextureView.getBitmap());
+        }
+
+        if (mPreviousExoPlayerState == ExoPlayer.STATE_READY && newState == ExoPlayer.STATE_BUFFERING) {
+            MoPubEvents.log(Event.createEventFromDetails(
+                    BaseEvent.Name.DOWNLOAD_BUFFERING,
+                    BaseEvent.Category.NATIVE_VIDEO,
+                    BaseEvent.SamplingRate.NATIVE_VIDEO,
+                    mEventDetails));
+        }
+
+        if (mExoPlayerStateStartedFromIdle &&
+                mPreviousExoPlayerState == ExoPlayer.STATE_BUFFERING &&
+                newState == ExoPlayer.STATE_READY) {
+            MoPubEvents.log(Event.createEventFromDetails(
+                    BaseEvent.Name.DOWNLOAD_VIDEO_READY,
+                    BaseEvent.Category.NATIVE_VIDEO,
+                    BaseEvent.SamplingRate.NATIVE_VIDEO,
+                    mEventDetails));
+        }
+
+        mPreviousExoPlayerState = newState;
+        if (newState == ExoPlayer.STATE_READY) {
+            mExoPlayerStateStartedFromIdle = false;
+        } else if (newState == ExoPlayer.STATE_IDLE) {
+            mExoPlayerStateStartedFromIdle = true;
+        }
+
+        if (mListener != null) {
+            mListener.onStateChanged(playWhenReady, newState);
+        }
+    }
+
+    public void seekTo(final long ms) {
+        if (mExoPlayer == null) {
+            return;
+        }
+
+        mExoPlayer.seekTo(ms);
+        mNativeVideoProgressRunnable.seekTo(ms);
+    }
+
+    public long getCurrentPosition() {
+        return mNativeVideoProgressRunnable.getCurrentPosition();
+    }
+
+    public long getDuration() {
+        return mNativeVideoProgressRunnable.getDuration();
+    }
+
+    @Override
+    public void onPlayWhenReadyCommitted() {}
+
+    @Override
+    public void onPlayerError(ExoPlaybackException e) {
+        if (mListener == null) {
+            return;
+        }
+
+        MoPubEvents.log(Event.createEventFromDetails(
+                BaseEvent.Name.ERROR_DURING_PLAYBACK,
+                BaseEvent.Category.NATIVE_VIDEO,
+                BaseEvent.SamplingRate.NATIVE_VIDEO,
+                mEventDetails));
+
+        mListener.onError(e);
+    }
+
+    /**
+     * Handles forwarding the user to the specified click through url. Also, fires all unfired
+     * impression trackers (which should already have been handled in the transition from in-stream
+     * to full-screen. See
+     * {@link com.mopub.nativeads.MoPubCustomEventVideoNative.MoPubVideoNativeAd#render(MediaLayout)}
+     */
+    public void handleCtaClick(@NonNull final Context context) {
+        triggerImpressionTrackers();
+        mVastVideoConfig.handleClickWithoutResult(context, 0);
+    }
+
+    public boolean hasFinalFrame() {
+        return mFinalFrame != null;
+    }
+
+    @Nullable
+    public Drawable getFinalFrame() {
+        return mFinalFrame;
+    }
+
+    void triggerImpressionTrackers() {
+        mNativeVideoProgressRunnable.checkImpressionTrackers(true);
+    }
+
+    private void updateProgressRunnable(final boolean playWhenReady, final int state) {
+        if (playWhenReady && state == STATE_READY) {
+            mNativeVideoProgressRunnable.startRepeating(50);
+        } else {
+            mNativeVideoProgressRunnable.stop();
+        }
+    }
+
+    private void clearExistingPlayer() {
+        if (mExoPlayer == null) {
+            return;
+        }
+
+        setExoSurface(null);
+        mExoPlayer.stop();
+        mExoPlayer.release();
+        mExoPlayer = null;
+        mNativeVideoProgressRunnable.setExoPlayer(null);
+    }
+
+    private void preparePlayer() {
+        if (mExoPlayer == null) {
+            mExoPlayer = mExoPlayerFactory.newInstance(2, 1000, 5000);
+            mNativeVideoProgressRunnable.setExoPlayer(mExoPlayer);
+            mExoPlayer.addListener(this);
+
+            // Set up data sources
+            final Allocator allocator = new DefaultAllocator(BUFFER_SEGMENT_SIZE);
+            final Extractor extractor = new Mp4Extractor();
+
+            final DataSource httpSource = new HttpDiskCompositeDataSource(mContext, "exo_demo",
+                    mEventDetails);
+
+            final String videoUrl = mVastVideoConfig.getNetworkMediaFileUrl();
+
+            final ExtractorSampleSource sampleSource = new ExtractorSampleSource(Uri.parse(videoUrl),
+                    httpSource, allocator, BUFFER_SEGMENT_SIZE * BUFFER_SEGMENT_COUNT, extractor);
+            mVideoTrackRenderer = new MediaCodecVideoTrackRenderer(
+                    sampleSource, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING,
+                    0, mHandler, null, 10);
+            mAudioTrackRenderer = new MediaCodecAudioTrackRenderer(sampleSource);
+            mExoPlayer.prepare(mAudioTrackRenderer, mVideoTrackRenderer);
+        }
+
+        setExoAudio();
+        setExoPlayWhenReady();
+    }
+
+    private void setExoPlayWhenReady() {
+        if (mExoPlayer == null) {
+            return;
+        }
+
+        mExoPlayer.setPlayWhenReady(mPlayWhenReady);
+        updateProgressRunnable(mExoPlayer.getPlayWhenReady(), mExoPlayer.getPlaybackState());
+    }
+
+    private void setExoAudio() {
+        setExoAudio(mAudioEnabled ? 1.0f : 0.0f);
+    }
+
+    private void setExoAudio(final float volume) {
+        Preconditions.checkArgument(volume >= 0.0f && volume <= 1.0f);
+        if (mExoPlayer == null) {
+            return;
+        }
+
+        mExoPlayer.sendMessage(
+                mAudioTrackRenderer, MediaCodecAudioTrackRenderer.MSG_SET_VOLUME, volume);
+    }
+
+    private void setExoSurface(@Nullable final Surface surface) {
+        if (mExoPlayer == null) {
+            return;
+        }
+
+        mExoPlayer.sendMessage(
+                mVideoTrackRenderer, MediaCodecVideoTrackRenderer.MSG_SET_SURFACE, surface);
+    }
+
+    /**
+     * Created purely for the purpose of mocking to ease testing.
+     */
+    @VisibleForTesting
+    static class ExoPlayerFactory {
+        public ExoPlayer newInstance(int rendererCount, int minBufferMs, int minRebufferMs) {
+            return ExoPlayer.Factory.newInstance(rendererCount, minBufferMs, minRebufferMs);
+        }
+    }
+
+    static class VisibilityTrackingEvent {
+        interface OnTrackedStrategy {
+            void execute();
+        }
+
+        OnTrackedStrategy strategy;
+        int minimumPercentageVisible;
+        int totalRequiredPlayTimeMs;
+        int totalQualifiedPlayCounter;
+        boolean isTracked;
+    }
+
+    static class NativeVideoProgressRunnable extends RepeatingHandlerRunnable {
+        public interface ProgressListener {
+            /**
+             * Should send a number from 0 to 1000.
+             * @param progressTenthPercent
+             */
+            void updateProgress(int progressTenthPercent);
+        }
+
+        @NonNull private final Context mContext;
+        @NonNull private final VisibilityChecker mVisibilityChecker;
+        @NonNull private final List<VisibilityTrackingEvent> mVisibilityTrackingEvents;
+        @NonNull private final VastVideoConfig mVastVideoConfig;
+        @Nullable private ExoPlayer mExoPlayer;
+        @Nullable private TextureView mTextureView;
+        @Nullable private ProgressListener mProgressListener;
+        private long mCurrentPosition;
+        private long mDuration;
+
+        NativeVideoProgressRunnable(@NonNull final Context context,
+                @NonNull final Handler handler,
+                @NonNull final List<VisibilityTrackingEvent> visibilityTrackingEvents,
+                @NonNull final VastVideoConfig vastVideoConfig) {
+            this(context, handler, visibilityTrackingEvents, new VisibilityChecker(),
+                    vastVideoConfig);
+        }
+
+        @VisibleForTesting
+        NativeVideoProgressRunnable(@NonNull final Context context,
+                @NonNull final Handler handler,
+                @NonNull final List<VisibilityTrackingEvent> visibilityTrackingEvents,
+                @NonNull final VisibilityChecker visibilityChecker,
+                @NonNull final VastVideoConfig vastVideoConfig) {
+            super(handler);
+            Preconditions.checkNotNull(context);
+            Preconditions.checkNotNull(handler);
+            Preconditions.checkNotNull(visibilityTrackingEvents);
+            Preconditions.checkNotNull(vastVideoConfig);
+
+            mContext = context.getApplicationContext();
+            mVisibilityTrackingEvents = visibilityTrackingEvents;
+            mVisibilityChecker = visibilityChecker;
+            mVastVideoConfig = vastVideoConfig;
+            mDuration = -1L; // Initialized to -1 so we can distinguish between "never started" and a zero-length video.
+        }
+
+        void setExoPlayer(@Nullable final ExoPlayer exoPlayer) {
+            mExoPlayer = exoPlayer;
+        }
+
+        void setTextureView(@Nullable final TextureView textureView) {
+            mTextureView = textureView;
+        }
+
+        void setProgressListener(@Nullable final ProgressListener progressListener) {
+            mProgressListener = progressListener;
+        }
+
+        void seekTo(long currentPosition) {
+            mCurrentPosition = currentPosition;
+        }
+
+        long getCurrentPosition() {
+            return mCurrentPosition;
+        }
+
+        long getDuration() {
+            return mDuration;
+        }
+
+        void checkImpressionTrackers(final boolean forceTrigger) {
+            for (VisibilityTrackingEvent event : mVisibilityTrackingEvents) {
+                if (event.isTracked) {
+                    continue;
+                }
+                if (forceTrigger || mVisibilityChecker.isVisible(mTextureView, mTextureView,
+                        event.minimumPercentageVisible)) {
+                    event.totalQualifiedPlayCounter += mUpdateIntervalMillis;
+                    if (forceTrigger ||
+                            event.totalQualifiedPlayCounter >= event.totalRequiredPlayTimeMs) {
+                        event.strategy.execute();
+                        event.isTracked = true;
+                    }
+                }
+            }
+        }
+
+        @Override
+        public void doWork() {
+            if (mExoPlayer == null || !mExoPlayer.getPlayWhenReady()) {
+                return;
+            }
+
+            mCurrentPosition = mExoPlayer.getCurrentPosition();
+            mDuration = mExoPlayer.getDuration();
+            if (mDuration <= 0) {
+                return;
+            }
+
+            checkImpressionTrackers(false);
+
+            if (mProgressListener != null) {
+                float tenthsOfPercentPlayed = ((float) mCurrentPosition / mDuration) * 1000;
+                mProgressListener.updateProgress((int) tenthsOfPercentPlayed);
+            }
+
+            final List<VastTracker> trackers =
+                    mVastVideoConfig.getUntriggeredTrackersBefore(
+                            (int) mCurrentPosition, (int) mDuration);
+            if (!trackers.isEmpty()) {
+                final List<String> trackingUrls = new ArrayList<String>();
+                for (VastTracker tracker : trackers) {
+                    if (tracker.isTracked()) {
+                        continue;
+                    }
+                    trackingUrls.add(tracker.getTrackingUrl());
+                    tracker.setTracked();
+                }
+                TrackingRequest.makeTrackingHttpRequest(trackingUrls, mContext);
+            }
+        }
+
+        @Deprecated
+        @VisibleForTesting
+        void setUpdateIntervalMillis(final long updateIntervalMillis) {
+            mUpdateIntervalMillis = updateIntervalMillis;
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeVideoViewController.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeVideoViewController.java
new file mode 100644
index 00000000..99e7c58e
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeVideoViewController.java
@@ -0,0 +1,330 @@
+package com.mopub.nativeads;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.content.Context;
+import android.content.res.Configuration;
+import android.graphics.Bitmap;
+import android.graphics.SurfaceTexture;
+import android.media.AudioManager;
+import android.os.Build;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.view.TextureView;
+import android.view.View;
+import android.view.ViewGroup.LayoutParams;
+import android.widget.VideoView;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.UrlAction;
+import com.mopub.common.UrlHandler;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.mobileads.BaseVideoViewController;
+import com.mopub.mobileads.VastVideoConfig;
+import com.mopub.nativeads.MoPubCustomEventVideoNative.MoPubVideoNativeAd;
+import com.mopub.nativeads.NativeFullScreenVideoView.Mode;
+import com.mopub.nativeads.NativeVideoController.NativeVideoProgressRunnable;
+
+@TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+public class NativeVideoViewController extends BaseVideoViewController implements TextureView
+        .SurfaceTextureListener, NativeVideoController.Listener,
+        AudioManager.OnAudioFocusChangeListener {
+
+    enum VideoState { NONE, LOADING, BUFFERING, PAUSED, PLAYING, ENDED, FAILED_LOAD }
+
+    @NonNull public static final String NATIVE_VIDEO_ID = "native_video_id";
+    @NonNull public static final String NATIVE_VAST_VIDEO_CONFIG = "native_vast_video_config";
+
+    @NonNull private VideoState mVideoState;
+    @NonNull private VastVideoConfig mVastVideoConfig;
+    @NonNull private final NativeFullScreenVideoView mFullScreenVideoView;
+    @NonNull private final NativeVideoController mNativeVideoController;
+    @Nullable private Bitmap mCachedVideoFrame;
+    /*
+     * This state variable prevents the view from flickering when NativeVideoController state
+     * changes but the video has already finished playing.
+     */
+    private boolean mEnded;
+    private boolean mError;
+    private int mLatestVideoControllerState;
+
+    public NativeVideoViewController(@NonNull final Context context,
+            @NonNull final Bundle intentExtras,
+            @NonNull final Bundle savedInstanceState,
+            @NonNull final BaseVideoViewControllerListener baseVideoViewControllerListener) {
+        this(context, intentExtras, savedInstanceState, baseVideoViewControllerListener,
+                new NativeFullScreenVideoView(context,
+                        context.getResources().getConfiguration().orientation,
+                        ((VastVideoConfig) intentExtras.get(NATIVE_VAST_VIDEO_CONFIG))
+                                .getCustomCtaText()));
+    }
+
+    @VisibleForTesting
+    NativeVideoViewController(@NonNull final Context context,
+            @NonNull final Bundle intentExtras,
+            @NonNull final Bundle savedInstanceState,
+            @NonNull final BaseVideoViewControllerListener baseVideoViewControllerListener,
+            @NonNull final NativeFullScreenVideoView fullScreenVideoView) {
+        super(context, null, baseVideoViewControllerListener);
+        Preconditions.checkNotNull(context);
+        Preconditions.checkNotNull(intentExtras);
+        Preconditions.checkNotNull(baseVideoViewControllerListener);
+        Preconditions.checkNotNull(fullScreenVideoView);
+
+        mVideoState = VideoState.NONE;
+        mVastVideoConfig = ((VastVideoConfig) intentExtras.get(NATIVE_VAST_VIDEO_CONFIG));
+        mFullScreenVideoView = fullScreenVideoView;
+        final long videoId = (long) intentExtras.get(NATIVE_VIDEO_ID);
+        mNativeVideoController = NativeVideoController.getForId(videoId);
+
+        // Variables being checked below may be null but if they are it indicates
+        // a serious error in setting up this activity and we should detect it
+        // as soon as possible
+        Preconditions.checkNotNull(mVastVideoConfig);
+        Preconditions.checkNotNull(mNativeVideoController);
+    }
+
+    @Override
+    protected VideoView getVideoView() {
+        return null;
+    }
+
+    @Override
+    protected void onCreate() {
+        mFullScreenVideoView.setSurfaceTextureListener(this);
+        mFullScreenVideoView.setMode(Mode.LOADING);
+        mFullScreenVideoView.setPlayControlClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                if (mEnded) {
+                    mEnded = false;
+                    mFullScreenVideoView.resetProgress();
+                    mNativeVideoController.seekTo(0);
+                }
+                applyState(VideoState.PLAYING);
+            }
+        });
+
+        mFullScreenVideoView.setCloseControlListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                applyState(VideoState.PAUSED, true);
+                getBaseVideoViewControllerListener().onFinish();
+            }
+        });
+
+        mFullScreenVideoView.setCtaClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                mNativeVideoController.setPlayWhenReady(false);
+                mCachedVideoFrame = mFullScreenVideoView.getTextureView().getBitmap();
+                mNativeVideoController.handleCtaClick((Activity) getContext());
+            }
+        });
+
+        mFullScreenVideoView.setPrivacyInformationClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                mNativeVideoController.setPlayWhenReady(false);
+                mCachedVideoFrame = mFullScreenVideoView.getTextureView().getBitmap();
+                new UrlHandler.Builder().withSupportedUrlActions(UrlAction.OPEN_IN_APP_BROWSER)
+                        .build().handleUrl(getContext(),
+                        MoPubVideoNativeAd.PRIVACY_INFORMATION_CLICKTHROUGH_URL);
+            }
+        });
+
+        final LayoutParams adViewLayout =
+                new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
+        mFullScreenVideoView.setLayoutParams(adViewLayout);
+        getBaseVideoViewControllerListener().onSetContentView(mFullScreenVideoView);
+
+        mNativeVideoController.setProgressListener(new NativeVideoProgressRunnable
+                .ProgressListener() {
+
+            @Override
+            public void updateProgress(final int progressTenthPercent) {
+                mFullScreenVideoView.updateProgress(progressTenthPercent);
+            }
+        });
+    }
+
+    @Override
+    protected void onResume() {
+        if (mCachedVideoFrame != null) {
+            mFullScreenVideoView.setCachedVideoFrame(mCachedVideoFrame);
+        }
+        mNativeVideoController.prepare(this);
+        mNativeVideoController.setListener(this);
+        mNativeVideoController.setOnAudioFocusChangeListener(this);
+    }
+
+    @Override
+    protected void onPause() { }
+
+    @Override
+    protected void onDestroy() { }
+
+    @Override
+    protected void onSaveInstanceState(@NonNull final Bundle outState) { }
+
+    @Override
+    protected void onConfigurationChanged(final Configuration configuration) {
+        mFullScreenVideoView.setOrientation(configuration.orientation);
+    }
+
+    @Override
+    protected void onBackPressed() {
+        applyState(VideoState.PAUSED, true);
+    }
+
+    @Override
+    public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) {
+        mNativeVideoController.setTextureView(mFullScreenVideoView.getTextureView());
+
+        if (!mEnded) {
+            mNativeVideoController.seekTo(mNativeVideoController.getCurrentPosition());
+        }
+        mNativeVideoController.setPlayWhenReady(!mEnded);
+        long currentPosition = mNativeVideoController.getCurrentPosition();
+        long duration = mNativeVideoController.getDuration();
+        long remaining = duration - currentPosition;
+        if (remaining < NativeVideoController.RESUME_FINISHED_THRESHOLD) {
+            mEnded = true;
+            maybeChangeState();
+        }
+    }
+
+    @Override
+    public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width, int height) { }
+
+    @Override
+    public boolean onSurfaceTextureDestroyed(final SurfaceTexture surface) {
+        mNativeVideoController.release(this);
+        applyState(VideoState.PAUSED);
+        return true;
+    }
+
+    @Override
+    public void onSurfaceTextureUpdated(SurfaceTexture surface) { }
+
+    @Override
+    public void onStateChanged(final boolean playWhenReady, final int playbackState) {
+        mLatestVideoControllerState = playbackState;
+        maybeChangeState();
+    }
+
+    @Override
+    public void onError(final Exception e) {
+        MoPubLog.w("Error playing back video.", e);
+        mError = true;
+        maybeChangeState();
+    }
+
+    @Override
+    public void onAudioFocusChange(int focusChange) {
+        if (focusChange == AudioManager.AUDIOFOCUS_LOSS
+                || focusChange == AudioManager.AUDIOFOCUS_LOSS_TRANSIENT) {
+            // Pause Video
+            applyState(VideoState.PAUSED);
+        } else if (focusChange == AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK) {
+            // Lower the volume
+            mNativeVideoController.setAudioVolume(0.3f);
+        } else if (focusChange == AudioManager.AUDIOFOCUS_GAIN) {
+            // Resume playback
+            mNativeVideoController.setAudioVolume(1.0f);
+            maybeChangeState();
+        }
+    }
+
+    private void maybeChangeState() {
+        VideoState newState = mVideoState;
+
+        if (mError) {
+            newState = VideoState.FAILED_LOAD;
+        } else if (mEnded) {
+            newState = VideoState.ENDED;
+        } else {
+            if (mLatestVideoControllerState == NativeVideoController.STATE_PREPARING
+                    || mLatestVideoControllerState == NativeVideoController.STATE_IDLE) {
+                newState = VideoState.LOADING;
+            } else if (mLatestVideoControllerState == NativeVideoController.STATE_BUFFERING) {
+                newState = VideoState.BUFFERING;
+            } else if (mLatestVideoControllerState == NativeVideoController.STATE_READY) {
+                newState = VideoState.PLAYING;
+            } else if (mLatestVideoControllerState == NativeVideoController.STATE_ENDED
+                    || mLatestVideoControllerState == NativeVideoController.STATE_CLEARED){
+                newState = VideoState.ENDED;
+            }
+        }
+
+        applyState(newState);
+    }
+
+
+    @VisibleForTesting
+    void applyState(@NonNull final VideoState videoState) {
+        applyState(videoState, false);
+    }
+
+    @VisibleForTesting
+    void applyState(@NonNull final VideoState videoState, boolean transitionToInline) {
+        Preconditions.checkNotNull(videoState);
+        if (mVideoState == videoState) {
+            return;
+        }
+
+        switch (videoState) {
+            case FAILED_LOAD:
+                // Spin endlessly for an error state
+                mNativeVideoController.setPlayWhenReady(false);
+                mNativeVideoController.setAudioEnabled(false);
+                mNativeVideoController.setAppAudioEnabled(false);
+                mFullScreenVideoView.setMode(Mode.LOADING);
+                mVastVideoConfig.handleError(getContext(), null, 0);
+                break;
+            case LOADING:
+            case BUFFERING:
+                mNativeVideoController.setPlayWhenReady(true);
+                mFullScreenVideoView.setMode(Mode.LOADING);
+                break;
+            case PLAYING:
+                mNativeVideoController.setPlayWhenReady(true);
+                mNativeVideoController.setAudioEnabled(true);
+                mNativeVideoController.setAppAudioEnabled(true);
+                mFullScreenVideoView.setMode(Mode.PLAYING);
+                break;
+            case PAUSED:
+                if (!transitionToInline) {
+                    mNativeVideoController.setAppAudioEnabled(false);
+                }
+                mNativeVideoController.setPlayWhenReady(false);
+                mFullScreenVideoView.setMode(Mode.PAUSED);
+                break;
+            case ENDED:
+                mEnded = true;
+                mNativeVideoController.setAppAudioEnabled(false);
+                mFullScreenVideoView.updateProgress(1000);
+                mFullScreenVideoView.setMode(Mode.FINISHED);
+                mVastVideoConfig.handleComplete(getContext(), 0);
+                break;
+            default:
+                // nothing
+        }
+
+        mVideoState = videoState;
+    }
+
+    @Deprecated
+    @VisibleForTesting
+    NativeFullScreenVideoView getNativeFullScreenVideoView() {
+        return mFullScreenVideoView;
+    }
+
+    @Deprecated
+    @VisibleForTesting
+    VideoState getVideoState() {
+        return mVideoState;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeViewHolder.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeViewHolder.java
deleted file mode 100644
index 0e68ae12..00000000
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeViewHolder.java
+++ /dev/null
@@ -1,140 +0,0 @@
-package com.mopub.nativeads;
-
-import android.content.Context;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.view.View;
-import android.widget.ImageView;
-import android.widget.TextView;
-
-import com.mopub.common.UrlAction;
-import com.mopub.common.UrlHandler;
-import com.mopub.common.VisibleForTesting;
-import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.Drawables;
-
-class NativeViewHolder {
-    @Nullable View mainView;
-    @Nullable TextView titleView;
-    @Nullable TextView textView;
-    @Nullable TextView callToActionView;
-    @Nullable ImageView mainImageView;
-    @Nullable ImageView iconImageView;
-    @Nullable ImageView daaIconImageView;
-
-    @VisibleForTesting
-    static final NativeViewHolder EMPTY_VIEW_HOLDER = new NativeViewHolder();
-
-    // Use fromViewBinder instead of a constructor
-    private NativeViewHolder() {}
-
-    @NonNull
-    static NativeViewHolder fromViewBinder(@NonNull final View view,
-            @NonNull final ViewBinder viewBinder) {
-        final NativeViewHolder nativeViewHolder = new NativeViewHolder();
-        nativeViewHolder.mainView = view;
-        try {
-            nativeViewHolder.titleView = (TextView) view.findViewById(viewBinder.titleId);
-            nativeViewHolder.textView = (TextView) view.findViewById(viewBinder.textId);
-            nativeViewHolder.callToActionView = (TextView) view.findViewById(viewBinder.callToActionId);
-            nativeViewHolder.mainImageView = (ImageView) view.findViewById(viewBinder.mainImageId);
-            nativeViewHolder.iconImageView = (ImageView) view.findViewById(viewBinder.iconImageId);
-            nativeViewHolder.daaIconImageView = (ImageView) view.findViewById(viewBinder.daaIconImageId);
-            return nativeViewHolder;
-        } catch (ClassCastException exception) {
-            MoPubLog.w("Could not cast from id in ViewBinder to expected View type", exception);
-            return EMPTY_VIEW_HOLDER;
-        }
-    }
-
-    void update(@NonNull final NativeResponse nativeResponse) {
-        addTextView(titleView, nativeResponse.getTitle());
-        addTextView(textView, nativeResponse.getText());
-        addTextView(callToActionView, nativeResponse.getCallToAction());
-        nativeResponse.loadMainImage(mainImageView);
-        nativeResponse.loadIconImage(iconImageView);
-        addDaaIcon(nativeResponse.getDaaIconClickthroughUrl());
-    }
-
-    void updateExtras(@NonNull final NativeResponse nativeResponse,
-                      @NonNull final ViewBinder viewBinder) {
-        if (mainView == null) {
-            MoPubLog.w("Attempted to bind extras on a null main view.");
-            return;
-        }
-        for (final String key : viewBinder.extras.keySet()) {
-            final int resourceId = viewBinder.extras.get(key);
-            final View view = mainView.findViewById(resourceId);
-            final Object content = nativeResponse.getExtra(key);
-
-            if (view instanceof ImageView) {
-                // Clear previous image
-                ((ImageView) view).setImageDrawable(null);
-                nativeResponse.loadExtrasImage(key, (ImageView) view);
-            } else if (view instanceof TextView) {
-                // Clear previous text value
-                ((TextView) view).setText(null);
-                if (content instanceof String) {
-                    addTextView((TextView) view, (String) content);
-                }
-            } else {
-                MoPubLog.d("View bound to " + key + " should be an instance of TextView or ImageView.");
-            }
-        }
-    }
-
-    private void addTextView(@Nullable final TextView textView, @Nullable final String contents) {
-        if (textView == null) {
-            MoPubLog.d("Attempted to add text (" + contents + ") to null TextView.");
-            return;
-        }
-
-        // Clear previous value
-        textView.setText(null);
-
-        if (contents == null) {
-            MoPubLog.d("Attempted to set TextView contents to null.");
-        } else {
-            textView.setText(contents);
-        }
-    }
-
-    private void addDaaIcon(@Nullable final String daaClickthroughUrl) {
-        if (daaIconImageView == null) {
-            return;
-        }
-        if (daaClickthroughUrl == null) {
-            daaIconImageView.setImageDrawable(null);
-            daaIconImageView.setOnClickListener(null);
-            daaIconImageView.setVisibility(View.INVISIBLE);
-            return;
-        }
-        final Context context = daaIconImageView.getContext();
-        if (context == null) {
-            return;
-        }
-        daaIconImageView.setImageDrawable(
-                Drawables.NATIVE_DAA_ICON.createDrawable(context));
-        daaIconImageView.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(final View v) {
-                new UrlHandler.Builder()
-                        .withSupportedUrlActions(
-                                UrlAction.IGNORE_ABOUT_SCHEME,
-                                UrlAction.OPEN_NATIVE_BROWSER,
-                                UrlAction.OPEN_IN_APP_BROWSER,
-                                UrlAction.HANDLE_SHARE_TWEET,
-                                UrlAction.FOLLOW_DEEP_LINK_WITH_FALLBACK,
-                                UrlAction.FOLLOW_DEEP_LINK)
-                        .build().handleUrl(context, daaClickthroughUrl);
-            }
-        });
-        daaIconImageView.setVisibility(View.VISIBLE);
-    }
-
-    public void setViewVisibility(final int visibility) {
-        if (mainView != null) {
-            mainView.setVisibility(visibility);
-        }
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/PlacementData.java b/mopub-sdk/src/main/java/com/mopub/nativeads/PlacementData.java
index ec98a480..d8ba46c6 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/PlacementData.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/PlacementData.java
@@ -11,594 +11,517 @@
 /**
  * A data that represents placed ads in a {@link com.mopub.nativeads.MoPubStreamAdPlacer},
  * useful for tracking insertion and placed ad positions.
- * <p/>
+ *
  * It maintains four lists of integers
  * 1) Desired insertion positions - positions to place ads
  * 2) Desired original positions - original position for each ad to place
  * 2) Adjusted ad positions - ad positions that were placed
  * 3) Original ad positions - original position of the item after each placed ad
- * <p/>
+ *
  * For example, consider the following ad positions:
  * ORIGINAL LIST    ADJUSTED LIST
- * Item 0           Item 0
- * Item 1           Ad
- * Item 2           Item 1
- * Item 3           Ad
- * Item 2
- * Ad
- * Item 3
- * <p/>
+ *   Item 0           Item 0
+ *   Item 1           Ad
+ *   Item 2           Item 1
+ *   Item 3           Ad
+ *                    Item 2
+ *                    Ad
+ *                    Item 3
+ *
  * List starts as:
- * Item 0
- * Item 1
- * Item 2
- * Item 3
+ *   Item 0
+ *   Item 1
+ *   Item 2
+ *   Item 3
  * desiredOriginalPositions: {1, 2, 3}
  * desiredInsertionPositions: {1, 2, 3}
  * originalPositions: {}
  * adjustedPositions: {}
- * <p/>
+ *
  * If we place at position 2:
- * Item 0
- * Item 1
- * Ad
- * Item 2
- * Item 3
+ *   Item 0
+ *   Item 1
+ *   Ad
+ *   Item 2
+ *   Item 3
  * desiredOriginalPositions: {1, 3}
  * desiredInsertionPositions: {1, 4}
  * originalPositions: {2}
  * adjustedPositions: {2}
- * <p/>
+ *
  * If the developer adds a content item at position 2
- * Item 0
- * Item 1
- * New Item
- * Ad
- * Item 3
- * Item 4
+ *   Item 0
+ *   Item 1
+ *   New Item
+ *   Ad
+ *   Item 3
+ *   Item 4
  * desiredOriginalPositions: {1, 4}
  * desiredInsertionPositions: {1, 5}
  * originalPositions: {3}
  * adjustedPositions: {3}
- * <p/>
+ *
  * Now, place at position 1
- * Item 0
- * Ad
- * Item 1
- * New Item
- * Ad
- * Item 3
- * Item 4
+ *   Item 0
+ *   Ad
+ *   Item 1
+ *   New Item
+ *   Ad
+ *   Item 3
+ *   Item 4
  * desiredOriginalPositions: {4}
  * desiredInsertionPositions: {6}
  * originalPositions: {1, 3}
  * adjustedPositions: {1, 4}
- * <p/>
+ *
  * Place at position 6
- * Item 0
- * Ad
- * Item 1
- * New Item
- * Ad
- * Item 3
- * Ad
- * Item 4
+ *   Item 0
+ *   Ad
+ *   Item 1
+ *   New Item
+ *   Ad
+ *   Item 3
+ *   Ad
+ *   Item 4
  * desiredOriginalPositions: {}
  * desiredInsertionPositions: {}
  * originalPositions: {1, 3, 4}
  * adjustedPositions: {1, 4, 6}
- * <p/>
+ *
  * Clear ad at position 1
- * Item 0
- * Item 1
- * New Item
- * Ad
- * Item 3
- * Ad
- * Item 4
+ *   Item 0
+ *   Item 1
+ *   New Item
+ *   Ad
+ *   Item 3
+ *   Ad
+ *   Item 4
  * desiredOriginalPositions: {1}
  * desiredInsertionPositions: {1}
  * originalPositions: {3, 4}
  * adjustedPositions: {3, 5}
- * <p/>
+ *
  * Clear ad at position 5
- * Item 0
- * Item 1
- * New Item
- * Ad
- * Item 3
- * Item 4
+ *   Item 0
+ *   Item 1
+ *   New Item
+ *   Ad
+ *   Item 3
+ *   Item 4
  * desiredOriginalPositions: {1, 4}
  * desiredInsertionPositions: {1, 5}
  * originalPositions: {3}
  * adjustedPositions: {3}
- * <p/>
+ *
  * Some runtime guarantees in terms of number of insertion ads:
  * - Finds the next or previous insertion position in O(logN)
  * - Maps from adjusted to original positions and vice versa in O(logN)
  * - Places an ad (moves positions from desired to placed) in O(N)
  */
 class PlacementData {
-	/**
-	 * Returned when positions are not found.
-	 */
-	public final static int NOT_FOUND = -1;
-
-	// Cap the number of ads to avoid unrestrained memory usage. 200 allows the 5 positioning
-	// arrays to fit in less than 4K.
-	private final static int MAX_ADS = 200;
-
-	// Initialize all of these to their max capacity. This prevents garbage collection when
-	// reallocating the list, which causes noticeable stuttering when scrolling on some devices.
-	@NonNull
-	private final int[] mDesiredOriginalPositions = new int[MAX_ADS];
-	@NonNull
-	private final int[] mDesiredInsertionPositions = new int[MAX_ADS];
-	private int mDesiredCount = 0;
-	@NonNull
-	private final int[] mOriginalAdPositions = new int[MAX_ADS];
-	@NonNull
-	private final int[] mAdjustedAdPositions = new int[MAX_ADS];
-	@NonNull
-	private final NativeAdData[] mAdDataObjects = new NativeAdData[MAX_ADS];
-	private int mPlacedCount = 0;
-
-	/**
-	 * @param desiredInsertionPositions Insertion positions, expressed as original positions
-	 */
-	private PlacementData(@NonNull final int[] desiredInsertionPositions) {
-		mDesiredCount = Math.min(desiredInsertionPositions.length, MAX_ADS);
-		System.arraycopy(desiredInsertionPositions, 0, mDesiredInsertionPositions, 0, mDesiredCount);
-		System.arraycopy(desiredInsertionPositions, 0, mDesiredOriginalPositions, 0, mDesiredCount);
-	}
-
-	@NonNull
-	static PlacementData fromAdPositioning(@NonNull final MoPubClientPositioning adPositioning) {
-		final List<Integer> fixed = adPositioning.getFixedPositions();
-		final int interval = adPositioning.getRepeatingInterval();
-
-		final int size = (interval == MoPubClientPositioning.NO_REPEAT ? fixed.size() : MAX_ADS);
-		final int[] desiredInsertionPositions = new int[size];
-
-		// Fixed positions are in terms of final positions. Calculate current insertion positions
-		// by decrementing numAds at each index.
-		int numAds = 0;
-		int lastPos = 0;
-		for (final Integer position : fixed) {
-			lastPos = position - numAds;
-			desiredInsertionPositions[numAds++] = lastPos;
-		}
-
-		// Expand the repeating positions, if there are any
-		while (numAds < size) {
-			lastPos = lastPos + interval - 1;
-			desiredInsertionPositions[numAds++] = lastPos;
-		}
-		return new PlacementData(desiredInsertionPositions);
-	}
-
-	@NonNull
-	static PlacementData empty() {
-		return new PlacementData(new int[]{});
-	}
-
-	/**
-	 * Whether the given position should be an ad.
-	 */
-	public boolean shouldPlaceAd(final int position) {
-		final int index = binarySearch(mDesiredInsertionPositions, 0, mDesiredCount, position);
-		return index >= 0;
-	}
-
-	/**
-	 * The next position after this position that should be an ad. Returns NOT_FOUND if there are no
-	 * more ads.
-	 */
-	int nextInsertionPosition(final int position) {
-		final int index = binarySearchGreaterThan(
-				mDesiredInsertionPositions, mDesiredCount, position);
-		if (index == mDesiredCount) {
-			return NOT_FOUND;
-		}
-		return mDesiredInsertionPositions[index];
-	}
-
-	/**
-	 * The next position after this position that should be an ad. Returns NOT_FOUND if there
-	 * are no more ads.
-	 */
-	int previousInsertionPosition(final int position) {
-		final int index = binarySearchFirstEquals(
-				mDesiredInsertionPositions, mDesiredCount, position);
-		if (index == 0) {
-			return NOT_FOUND;
-		}
-		return mDesiredInsertionPositions[index - 1];
-	}
-
-	/**
-	 * Sets ad data at the given position.
-	 */
-	void placeAd(final int adjustedPosition, final NativeAdData adData) {
-		// See if this is a insertion ad
-		final int desiredIndex = binarySearchFirstEquals(
-				mDesiredInsertionPositions, mDesiredCount, adjustedPosition);
-		if (desiredIndex == mDesiredCount
-				|| mDesiredInsertionPositions[desiredIndex] != adjustedPosition) {
-			MoPubLog.w("Attempted to insert an ad at an invalid position");
-			return;
-		}
-
-		// Add to placed array
-		final int originalPosition = mDesiredOriginalPositions[desiredIndex];
-		int placeIndex = binarySearchGreaterThan(
-				mOriginalAdPositions, mPlacedCount, originalPosition);
-		if (placeIndex < mPlacedCount) {
-			final int num = mPlacedCount - placeIndex;
-			System.arraycopy(mOriginalAdPositions, placeIndex,
-					mOriginalAdPositions, placeIndex + 1, num);
-			System.arraycopy(mAdjustedAdPositions, placeIndex,
-					mAdjustedAdPositions, placeIndex + 1, num);
-			System.arraycopy(mAdDataObjects, placeIndex, mAdDataObjects, placeIndex + 1, num);
-		}
-		mOriginalAdPositions[placeIndex] = originalPosition;
-		mAdjustedAdPositions[placeIndex] = adjustedPosition;
-		if (adData != null) {
-			mAdDataObjects[placeIndex] = adData;
-		}
-		mPlacedCount++;
-
-		// Remove desired index
-		final int num = mDesiredCount - desiredIndex - 1;
-		System.arraycopy(mDesiredInsertionPositions, desiredIndex + 1,
-				mDesiredInsertionPositions, desiredIndex, num);
-		System.arraycopy(mDesiredOriginalPositions, desiredIndex + 1,
-				mDesiredOriginalPositions, desiredIndex, num);
-		mDesiredCount--;
-
-		// Increment adjusted positions
-		for (int i = desiredIndex; i < mDesiredCount; ++i) {
-			mDesiredInsertionPositions[i]++;
-		}
-		for (int i = placeIndex + 1; i < mPlacedCount; ++i) {
-			mAdjustedAdPositions[i]++;
-		}
-	}
-
-	/**
-	 * @see {@link com.mopub.nativeads.MoPubStreamAdPlacer#isAd(int)}
-	 */
-	boolean isPlacedAd(final int position) {
-		final int index = binarySearch(mAdjustedAdPositions, 0, mPlacedCount, position);
-		return index >= 0;
-	}
-
-	boolean isAdLoaded(final int position) {
-		final int index = binarySearch(mAdjustedAdPositions, 0, mPlacedCount, position);
-		return index >= 0;
-	}
-
-	boolean isAdLoadedByOriginalPosition(final int position) {
-		final int index = binarySearch(mOriginalAdPositions, 0, mPlacedCount, position);
-		return index >= 0;
-	}
-
-	boolean isAdLoadedByIndex(final int index) {
-		if (index >= 0) {
-			return getPlacedCount() > index;
-		}
-		return false;
-	}
-
-	/**
-	 * Returns the ad data associated with the given ad position, or {@code null} if there is
-	 * no ad at this position.
-	 */
-	@Nullable
-	NativeAdData getPlacedAd(final int position) {
-		final int index = binarySearch(mAdjustedAdPositions, 0, mPlacedCount, position);
-		return getPlacedAdByIndex(index);
-	}
-
-	NativeAdData getPlacedAdByOriginalPosition(final int position) {
-		final int index = binarySearch(mOriginalAdPositions, 0, mPlacedCount, position);
-		return getPlacedAdByIndex(index);
-	}
-
-	@Nullable
-	NativeAdData getPlacedAdByIndex(final int index) {
-		if (index < 0) {
-			return null;
-		}
-		return mAdDataObjects[index];
-	}
-
-	/**
-	 * Returns all placed ad positions. This method allocates new memory on every invocation. Do
-	 * not call it from performance critical code.
-	 */
-	@NonNull
-	int[] getPlacedAdPositions() {
-		int[] positions = new int[mPlacedCount];
-		System.arraycopy(mAdjustedAdPositions, 0, positions, 0, mPlacedCount);
-		return positions;
-	}
-
-	/**
-	 * @see com.mopub.nativeads.MoPubStreamAdPlacer#getOriginalPosition(int)
-	 */
-	int getOriginalPosition(final int position) {
-		final int index = binarySearch(mAdjustedAdPositions, 0, mPlacedCount, position);
-
-		// No match, ~index is the number of ads before this pos.
-		if (index < 0) {
-			return position - ~index;
-		}
-
-		// This is an ad - there is no original position
-		return NOT_FOUND;
-	}
-
-	int getOriginalAdPosition(final int position) {
-		final int index = binarySearch(mAdjustedAdPositions, 0, mPlacedCount, position);
-
-		// No match, ~index is the number of ads before this pos.
-		if (index < 0) {
-			return NOT_FOUND;
-		}
-
-		return mOriginalAdPositions[index];
-	}
-
-	int getPlacedPosition(final int position) {
-		final int index = binarySearch(mAdjustedAdPositions, 0, mPlacedCount, position);
-
-		// No match, ~index is the number of ads before this pos.
-		if (index < 0) {
-			return position - ~index;
-		}
-
-		return position - index;
-	}
-
-	int getInsertPosition(final int position) {
-		final int index = binarySearchGreaterThan(mAdjustedAdPositions, mPlacedCount, position);
-
-		return position - index;
-	}
-
-	/**
-	 * @see com.mopub.nativeads.MoPubStreamAdPlacer#getAdjustedPosition(int)
-	 */
-	int getAdjustedPosition(final int originalPosition) {
-		// This is an ad. Since binary search doesn't properly handle dups, find the first non-ad.
-		int index = binarySearchGreaterThan(mOriginalAdPositions, mPlacedCount, originalPosition);
-		return originalPosition + index;
-	}
-
-	int getAdIndex(final int adjustedPosition) {
-		int adjIndex = binarySearch(mAdjustedAdPositions, 0, mPlacedCount, adjustedPosition);
-		if (adjIndex < 0) {
-			adjIndex = 0;
-		}
-		int originalPosition = adjustedPosition - adjIndex;
-		int index = binarySearch(mOriginalAdPositions, 0, mPlacedCount, originalPosition);
-//		final int index = binarySearch(mAdjustedAdPositions, 0, mPlacedCount, adjustedPosition);
-		return index;
-	}
-
-	int getPlacedCount() {
-		return mPlacedCount;
-	}
-
-	/**
-	 * @see com.mopub.nativeads.MoPubStreamAdPlacer#getOriginalCount(int)
-	 */
-	int getOriginalCount(final int count) {
-		if (count == 0) {
-			return 0;
-		}
-
-		// The last item will never be an ad
-		final int originalPos = getOriginalPosition(count - 1);
-		return (originalPos == NOT_FOUND) ? NOT_FOUND : originalPos + 1;
-	}
-
-	/**
-	 * @see com.mopub.nativeads.MoPubStreamAdPlacer#getAdjustedCount(int)
-	 */
-	int getAdjustedCount(final int originalCount) {
-		if (originalCount == 0) {
-			return 0;
-		}
-		return getAdjustedPosition(originalCount - 1) + 1;
-	}
-
-	/**
-	 * Clears the ads in the given range. After calling this method, the ad positions
-	 * will be removed from the placed ad positions and put back into the desired ad insertion
-	 * positions.
-	 */
-	int clearAdsInRange(final int adjustedStartRange, final int adjustedEndRange) {
-		// Temporary arrays to store the cleared positions. Using temporary arrays makes it
-		// easy to debug what positions are being cleared.
-		int[] clearOriginalPositions = new int[mPlacedCount];
-		int[] clearAdjustedPositions = new int[mPlacedCount];
-		int clearCount = 0;
-
-		// Add to the clear position arrays any positions that fall inside
-		// [adjustedRangeStart, adjustedRangeEnd).
-		for (int i = 0; i < mPlacedCount; ++i) {
-			int originalPosition = mOriginalAdPositions[i];
-			int adjustedPosition = mAdjustedAdPositions[i];
-			if (adjustedStartRange <= adjustedPosition && adjustedPosition < adjustedEndRange) {
-				// When copying adjusted positions, subtract the current clear count because there
-				// is no longer an ad incrementing the desired insertion position.
-				clearOriginalPositions[clearCount] = originalPosition;
-				clearAdjustedPositions[clearCount] = adjustedPosition - clearCount;
-
-				// Destroying and nulling out the ad objects to avoids a memory leak.
-				mAdDataObjects[i].getAd().destroy();
-				mAdDataObjects[i] = null;
-				clearCount++;
-			} else if (clearCount > 0) {
-				// The position is not in the range; shift it by the number of cleared ads.
-				int newIndex = i - clearCount;
-				mOriginalAdPositions[newIndex] = originalPosition;
-				mAdjustedAdPositions[newIndex] = adjustedPosition - clearCount;
-				mAdDataObjects[newIndex] = mAdDataObjects[i];
-			}
-		}
-
-		// If we have cleared nothing, this method was a no-op.
-		if (clearCount == 0) {
-			return 0;
-		}
-
-		// Modify the desired positions arrays in order to make space to put back the
-		// cleared ad positions. For example if the desired array was {1, 10,
-		// 15} and we need to insert {3, 7} we'll shift the desired array to be {1, ?, ? , 10, 15}.
-		int firstCleared = clearAdjustedPositions[0];
-		int desiredIndex = binarySearchFirstEquals(
-				mDesiredInsertionPositions, mDesiredCount, firstCleared);
-		for (int i = mDesiredCount - 1; i >= desiredIndex; --i) {
-			mDesiredOriginalPositions[i + clearCount] = mDesiredOriginalPositions[i];
-			mDesiredInsertionPositions[i + clearCount] = mDesiredInsertionPositions[i] - clearCount;
-		}
-
-		// Copy the cleared ad positions into the desired arrays.
-		for (int i = 0; i < clearCount; ++i) {
-			mDesiredOriginalPositions[desiredIndex + i] = clearOriginalPositions[i];
-			mDesiredInsertionPositions[desiredIndex + i] = clearAdjustedPositions[i];
-		}
-
-		// Update the array counts, and we're done.
-		mDesiredCount = mDesiredCount + clearCount;
-		mPlacedCount = mPlacedCount - clearCount;
-		return clearCount;
-	}
-
-	/**
-	 * Clears the ads in the given range. After calling this method the ad's position
-	 * will be back to the desired insertion positions.
-	 */
-	void clearAds() {
-		if (mPlacedCount == 0) {
-			return;
-		}
-
-		clearAdsInRange(0, mAdjustedAdPositions[mPlacedCount - 1] + 1);
-	}
-
-	/**
-	 * @see com.mopub.nativeads.MoPubStreamAdPlacer#insertItem(int)
-	 */
-	void insertItem(final int originalPosition) {
-
-		// Increment desired arrays.
-		int indexToIncrement = binarySearchFirstEquals(
-				mDesiredOriginalPositions, mDesiredCount, originalPosition);
-		for (int i = indexToIncrement; i < mDesiredCount; ++i) {
-			mDesiredOriginalPositions[i]++;
-			mDesiredInsertionPositions[i]++;
-		}
-
-		// Increment placed arrays.
-		indexToIncrement = binarySearchFirstEquals(
-				mOriginalAdPositions, mPlacedCount, originalPosition);
-		for (int i = indexToIncrement; i < mPlacedCount; ++i) {
-			mOriginalAdPositions[i]++;
-			mAdjustedAdPositions[i]++;
-		}
-	}
-
-	/**
-	 * @see com.mopub.nativeads.MoPubStreamAdPlacer#removeItem(int)
-	 */
-	void removeItem(final int originalPosition) {
-		// When removing items, we only decrement ad position values *greater* than the original
-		// position we're removing. The original position associated with an ad is the original
-		// position of the first content item after the ad, so we shouldn't change the original
-		// position of an ad that matches the original position removed.
-		int indexToDecrement = binarySearchGreaterThan(
-				mDesiredOriginalPositions, mDesiredCount, originalPosition);
-
-		// Decrement desired arrays.
-		for (int i = indexToDecrement; i < mDesiredCount; ++i) {
-			mDesiredOriginalPositions[i]--;
-			mDesiredInsertionPositions[i]--;
-		}
-
-		indexToDecrement = binarySearchGreaterThan(
-				mOriginalAdPositions, mPlacedCount, originalPosition);
-
-		for (int i = indexToDecrement; i < mPlacedCount; ++i) {
-			mOriginalAdPositions[i]--;
-			mAdjustedAdPositions[i]--;
-		}
-	}
-
-	/**
-	 * @see com.mopub.nativeads.MoPubStreamAdPlacer#moveItem(int, int)
-	 */
-	void moveItem(final int originalPosition, final int newPosition) {
-		removeItem(originalPosition);
-		insertItem(newPosition);
-	}
-
-	private static int binarySearchFirstEquals(int[] array, int count, int value) {
-		int index = binarySearch(array, 0, count, value);
-
-		// If not found, binarySearch returns the 2's complement of the index of the nearest
-		// value higher than the target value, which is also the insertion index.
-		if (index < 0) {
-			return ~index;
-		}
-
-		int duplicateValue = array[index];
-		while (index >= 0 && array[index] == duplicateValue) {
-			index--;
-		}
-
-		return index + 1;
-	}
-
-	private static int binarySearchGreaterThan(int[] array, int count, int value) {
-		int index = binarySearch(array, 0, count, value);
-
-		// If not found, binarySearch returns the 2's complement of the index of the nearest
-		// value higher than the target value, which is also the insertion index.
-		if (index < 0) {
-			return ~index;
-		}
-
-		int duplicateValue = array[index];
-		while (index < count && array[index] == duplicateValue) {
-			index++;
-		}
-
-		return index;
-	}
-
-	/**
-	 * Copied from Arrays.java, which isn't available until Gingerbread.
-	 */
-	private static int binarySearch(int[] array, int startIndex, int endIndex, int value) {
-		int lo = startIndex;
-		int hi = endIndex - 1;
-
-		while (lo <= hi) {
-			int mid = (lo + hi) >>> 1;
-			int midVal = array[mid];
-
-			if (midVal < value) {
-				lo = mid + 1;
-			} else if (midVal > value) {
-				hi = mid - 1;
-			} else {
-				return mid;  // value found
-			}
-		}
-		return ~lo;  // value not present
-	}
+    /**
+     * Returned when positions are not found.
+     */
+    public final static int NOT_FOUND = -1;
+
+    // Cap the number of ads to avoid unrestrained memory usage. 200 allows the 5 positioning
+    // arrays to fit in less than 4K.
+    private final static int MAX_ADS = 200;
+
+    // Initialize all of these to their max capacity. This prevents garbage collection when
+    // reallocating the list, which causes noticeable stuttering when scrolling on some devices.
+    @NonNull private final int[] mDesiredOriginalPositions = new int[MAX_ADS];
+    @NonNull private final int[] mDesiredInsertionPositions = new int[MAX_ADS];
+    private int mDesiredCount = 0;
+    @NonNull private final int[] mOriginalAdPositions = new int[MAX_ADS];
+    @NonNull private final int[] mAdjustedAdPositions = new int[MAX_ADS];
+    @NonNull private final NativeAd[] mNativeAds = new NativeAd[MAX_ADS];
+    private int mPlacedCount = 0;
+
+    /**
+     * @param desiredInsertionPositions Insertion positions, expressed as original positions
+     */
+    private PlacementData(@NonNull final int[] desiredInsertionPositions) {
+        mDesiredCount = Math.min(desiredInsertionPositions.length, MAX_ADS);
+        System.arraycopy(desiredInsertionPositions, 0, mDesiredInsertionPositions, 0, mDesiredCount);
+        System.arraycopy(desiredInsertionPositions, 0, mDesiredOriginalPositions, 0, mDesiredCount);
+    }
+
+    @NonNull
+    static PlacementData fromAdPositioning(@NonNull final MoPubClientPositioning adPositioning) {
+        final List<Integer> fixed = adPositioning.getFixedPositions();
+        final int interval = adPositioning.getRepeatingInterval();
+
+        final int size = (interval == MoPubClientPositioning.NO_REPEAT ? fixed.size() : MAX_ADS);
+        final int[] desiredInsertionPositions = new int[size];
+
+        // Fixed positions are in terms of final positions. Calculate current insertion positions
+        // by decrementing numAds at each index.
+        int numAds = 0;
+        int lastPos = 0;
+        for (final Integer position : fixed) {
+            lastPos = position - numAds;
+            desiredInsertionPositions[numAds++] = lastPos;
+        }
+
+        // Expand the repeating positions, if there are any
+        while (numAds < size) {
+            lastPos = lastPos + interval - 1;
+            desiredInsertionPositions[numAds++] = lastPos;
+        }
+        return new PlacementData(desiredInsertionPositions);
+    }
+
+    @NonNull
+    static PlacementData empty() {
+        return new PlacementData(new int[] {});
+    }
+
+    /**
+     * Whether the given position should be an ad.
+     */
+    boolean shouldPlaceAd(final int position) {
+        final int index = binarySearch(mDesiredInsertionPositions, 0, mDesiredCount, position);
+        return index >= 0;
+    }
+
+    /**
+     * The next position after this position that should be an ad. Returns NOT_FOUND if there are no
+     * more ads.
+     */
+    int nextInsertionPosition(final int position) {
+        final int index = binarySearchGreaterThan(
+                mDesiredInsertionPositions, mDesiredCount, position);
+        if (index == mDesiredCount) {
+            return NOT_FOUND;
+        }
+        return mDesiredInsertionPositions[index];
+    }
+
+    /**
+     * The next position after this position that should be an ad. Returns NOT_FOUND if there
+     * are no more ads.
+     */
+    int previousInsertionPosition(final int position) {
+        final int index = binarySearchFirstEquals(
+                mDesiredInsertionPositions,  mDesiredCount, position);
+        if (index == 0) {
+            return NOT_FOUND;
+        }
+        return mDesiredInsertionPositions[index - 1];
+    }
+
+    /**
+     * Sets ad data at the given position.
+     */
+    void placeAd(final int adjustedPosition, final NativeAd nativeAd) {
+        // See if this is a insertion ad
+        final int desiredIndex = binarySearchFirstEquals(
+                mDesiredInsertionPositions, mDesiredCount, adjustedPosition);
+        if (desiredIndex == mDesiredCount
+                || mDesiredInsertionPositions[desiredIndex] != adjustedPosition) {
+            MoPubLog.w("Attempted to insert an ad at an invalid position");
+            return;
+        }
+
+        // Add to placed array
+        final int originalPosition = mDesiredOriginalPositions[desiredIndex];
+        int placeIndex = binarySearchGreaterThan(
+                mOriginalAdPositions, mPlacedCount, originalPosition);
+        if (placeIndex < mPlacedCount) {
+            final int num = mPlacedCount - placeIndex;
+            System.arraycopy(mOriginalAdPositions, placeIndex,
+                    mOriginalAdPositions, placeIndex + 1, num);
+            System.arraycopy(mAdjustedAdPositions, placeIndex,
+                    mAdjustedAdPositions, placeIndex + 1, num);
+            System.arraycopy(mNativeAds, placeIndex, mNativeAds, placeIndex + 1, num);
+        }
+        mOriginalAdPositions[placeIndex] = originalPosition;
+        mAdjustedAdPositions[placeIndex] = adjustedPosition;
+        mNativeAds[placeIndex] = nativeAd;
+        mPlacedCount++;
+
+        // Remove desired index
+        final int num = mDesiredCount - desiredIndex - 1;
+        System.arraycopy(mDesiredInsertionPositions, desiredIndex + 1,
+                mDesiredInsertionPositions, desiredIndex, num);
+        System.arraycopy(mDesiredOriginalPositions, desiredIndex + 1,
+                mDesiredOriginalPositions, desiredIndex, num);
+        mDesiredCount--;
+
+        // Increment adjusted positions
+        for (int i = desiredIndex; i < mDesiredCount; ++i) {
+            mDesiredInsertionPositions[i]++;
+        }
+        for (int i = placeIndex + 1; i < mPlacedCount; ++i) {
+            mAdjustedAdPositions[i]++;
+        }
+    }
+
+    /**
+     * @see {@link com.mopub.nativeads.MoPubStreamAdPlacer#isAd(int)}
+     */
+    boolean isPlacedAd(final int position) {
+        final int index = binarySearch(mAdjustedAdPositions, 0, mPlacedCount, position);
+        return index >= 0;
+    }
+
+    /**
+     * Returns the ad data associated with the given ad position, or {@code null} if there is
+     * no ad at this position.
+     */
+    @Nullable
+    NativeAd getPlacedAd(final int position) {
+        final int index = binarySearch(mAdjustedAdPositions, 0, mPlacedCount, position);
+        if (index < 0) {
+            return null;
+        }
+        return mNativeAds[index];
+    }
+
+    /**
+     * Returns all placed ad positions. This method allocates new memory on every invocation. Do
+     * not call it from performance critical code.
+     */
+    @NonNull
+    int[] getPlacedAdPositions() {
+        int[] positions = new int[mPlacedCount];
+        System.arraycopy(mAdjustedAdPositions, 0, positions, 0, mPlacedCount);
+        return positions;
+    }
+
+    /**
+     * @see com.mopub.nativeads.MoPubStreamAdPlacer#getOriginalPosition(int)
+     */
+    int getOriginalPosition(final int position) {
+        final int index = binarySearch(mAdjustedAdPositions, 0, mPlacedCount, position);
+
+        // No match, ~index is the number of ads before this pos.
+        if (index < 0) {
+            return position - ~index;
+        }
+
+        // This is an ad - there is no original position
+        return NOT_FOUND;
+    }
+
+    /**
+     * @see com.mopub.nativeads.MoPubStreamAdPlacer#getAdjustedPosition(int)
+     */
+    int getAdjustedPosition(final int originalPosition) {
+        // This is an ad. Since binary search doesn't properly handle dups, find the first non-ad.
+        int index = binarySearchGreaterThan(mOriginalAdPositions, mPlacedCount, originalPosition);
+        return originalPosition + index;
+    }
+
+    /**
+     * @see com.mopub.nativeads.MoPubStreamAdPlacer#getOriginalCount(int)
+     */
+    int getOriginalCount(final int count) {
+        if (count == 0) {
+            return 0;
+        }
+
+        // The last item will never be an ad
+        final int originalPos = getOriginalPosition(count - 1);
+        return (originalPos == NOT_FOUND) ? NOT_FOUND : originalPos + 1;
+    }
+
+    /**
+     * @see com.mopub.nativeads.MoPubStreamAdPlacer#getAdjustedCount(int)
+     */
+    int getAdjustedCount(final int originalCount) {
+        if (originalCount == 0) {
+            return 0;
+        }
+        return getAdjustedPosition(originalCount - 1) + 1;
+    }
+
+    /**
+     * Clears the ads in the given range. After calling this method, the ad positions
+     * will be removed from the placed ad positions and put back into the desired ad insertion
+     * positions.
+     */
+    int clearAdsInRange(final int adjustedStartRange, final int adjustedEndRange) {
+        // Temporary arrays to store the cleared positions. Using temporary arrays makes it
+        // easy to debug what positions are being cleared.
+        int[] clearOriginalPositions = new int[mPlacedCount];
+        int[] clearAdjustedPositions = new int[mPlacedCount];
+        int clearCount = 0;
+
+        // Add to the clear position arrays any positions that fall inside
+        // [adjustedRangeStart, adjustedRangeEnd).
+        for (int i = 0; i < mPlacedCount; ++i) {
+            int originalPosition = mOriginalAdPositions[i];
+            int adjustedPosition = mAdjustedAdPositions[i];
+            if (adjustedStartRange <= adjustedPosition && adjustedPosition < adjustedEndRange) {
+                // When copying adjusted positions, subtract the current clear count because there
+                // is no longer an ad incrementing the desired insertion position.
+                clearOriginalPositions[clearCount] = originalPosition;
+                clearAdjustedPositions[clearCount] = adjustedPosition - clearCount;
+
+                // Destroying and nulling out the ad objects to avoids a memory leak.
+                mNativeAds[i].destroy();
+                mNativeAds[i] = null;
+                clearCount++;
+            } else if (clearCount > 0) {
+                // The position is not in the range; shift it by the number of cleared ads.
+                int newIndex = i - clearCount;
+                mOriginalAdPositions[newIndex] = originalPosition;
+                mAdjustedAdPositions[newIndex] = adjustedPosition - clearCount;
+                mNativeAds[newIndex] = mNativeAds[i];
+            }
+        }
+
+        // If we have cleared nothing, this method was a no-op.
+        if (clearCount == 0) {
+            return 0;
+        }
+
+        // Modify the desired positions arrays in order to make space to put back the
+        // cleared ad positions. For example if the desired array was {1, 10,
+        // 15} and we need to insert {3, 7} we'll shift the desired array to be {1, ?, ? , 10, 15}.
+        int firstCleared = clearAdjustedPositions[0];
+        int desiredIndex = binarySearchFirstEquals(
+                mDesiredInsertionPositions, mDesiredCount, firstCleared);
+        for (int i = mDesiredCount - 1; i >= desiredIndex; --i) {
+            mDesiredOriginalPositions[i + clearCount] = mDesiredOriginalPositions[i];
+            mDesiredInsertionPositions[i + clearCount] = mDesiredInsertionPositions[i] - clearCount;
+        }
+
+        // Copy the cleared ad positions into the desired arrays.
+        for (int i = 0; i < clearCount; ++i) {
+            mDesiredOriginalPositions[desiredIndex + i] = clearOriginalPositions[i];
+            mDesiredInsertionPositions[desiredIndex + i] = clearAdjustedPositions[i];
+        }
+
+        // Update the array counts, and we're done.
+        mDesiredCount = mDesiredCount + clearCount;
+        mPlacedCount = mPlacedCount - clearCount;
+        return clearCount;
+    }
+
+    /**
+     * Clears the ads in the given range. After calling this method the ad's position
+     * will be back to the desired insertion positions.
+     */
+    void clearAds() {
+        if (mPlacedCount == 0) {
+            return;
+        }
+
+        clearAdsInRange(0, mAdjustedAdPositions[mPlacedCount - 1] + 1);
+    }
+
+    /**
+     * @see com.mopub.nativeads.MoPubStreamAdPlacer#insertItem(int)
+     */
+    void insertItem(final int originalPosition) {
+
+        // Increment desired arrays.
+        int indexToIncrement = binarySearchFirstEquals(
+                mDesiredOriginalPositions, mDesiredCount, originalPosition);
+        for (int i = indexToIncrement; i < mDesiredCount; ++i) {
+            mDesiredOriginalPositions[i]++;
+            mDesiredInsertionPositions[i]++;
+        }
+
+        // Increment placed arrays.
+        indexToIncrement = binarySearchFirstEquals(
+                mOriginalAdPositions, mPlacedCount, originalPosition);
+        for (int i = indexToIncrement; i < mPlacedCount; ++i) {
+            mOriginalAdPositions[i]++;
+            mAdjustedAdPositions[i]++;
+        }
+    }
+
+    /**
+     * @see com.mopub.nativeads.MoPubStreamAdPlacer#removeItem(int)
+     */
+    void removeItem(final int originalPosition) {
+        // When removing items, we only decrement ad position values *greater* than the original
+        // position we're removing. The original position associated with an ad is the original
+        // position of the first content item after the ad, so we shouldn't change the original
+        // position of an ad that matches the original position removed.
+        int indexToDecrement = binarySearchGreaterThan(
+                mDesiredOriginalPositions, mDesiredCount, originalPosition);
+
+        // Decrement desired arrays.
+        for (int i = indexToDecrement; i < mDesiredCount; ++i) {
+            mDesiredOriginalPositions[i]--;
+            mDesiredInsertionPositions[i]--;
+        }
+
+        indexToDecrement = binarySearchGreaterThan(
+                mOriginalAdPositions, mPlacedCount, originalPosition);
+
+        for (int i = indexToDecrement; i < mPlacedCount; ++i) {
+            mOriginalAdPositions[i]--;
+            mAdjustedAdPositions[i]--;
+        }
+    }
+
+    /**
+     * @see com.mopub.nativeads.MoPubStreamAdPlacer#moveItem(int, int)
+     */
+    void moveItem(final int originalPosition, final int newPosition) {
+        removeItem(originalPosition);
+        insertItem(newPosition);
+    }
+
+    private static int binarySearchFirstEquals(int[] array, int count, int value) {
+        int index = binarySearch(array, 0, count, value);
+
+        // If not found, binarySearch returns the 2's complement of the index of the nearest
+        // value higher than the target value, which is also the insertion index.
+        if (index < 0) {
+            return ~index;
+        }
+
+        int duplicateValue = array[index];
+        while (index >= 0 && array[index] == duplicateValue) {
+            index--;
+        }
+
+        return index + 1;
+    }
+
+    private static int binarySearchGreaterThan(int[] array, int count, int value) {
+        int index = binarySearch(array, 0, count, value);
+
+        // If not found, binarySearch returns the 2's complement of the index of the nearest
+        // value higher than the target value, which is also the insertion index.
+        if (index < 0) {
+            return ~index;
+        }
+
+        int duplicateValue = array[index];
+        while (index < count && array[index] == duplicateValue) {
+            index++;
+        }
+
+        return index;
+    }
+
+    /**
+     * Copied from Arrays.java, which isn't available until Gingerbread.
+     */
+    private static int binarySearch(int[] array, int startIndex, int endIndex, int value) {
+        int lo = startIndex;
+        int hi = endIndex - 1;
+
+        while (lo <= hi) {
+            int mid = (lo + hi) >>> 1;
+            int midVal = array[mid];
+
+            if (midVal < value) {
+                lo = mid + 1;
+            } else if (midVal > value) {
+                hi = mid - 1;
+            } else {
+                return mid;  // value found
+            }
+        }
+        return ~lo;  // value not present
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/StaticNativeAd.java b/mopub-sdk/src/main/java/com/mopub/nativeads/StaticNativeAd.java
new file mode 100644
index 00000000..e306e1fe
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/StaticNativeAd.java
@@ -0,0 +1,267 @@
+package com.mopub.nativeads;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.view.View;
+
+import com.mopub.common.Preconditions.NoThrow;
+import com.mopub.common.logging.MoPubLog;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * This the base class for implementations of the static native ad format.
+ */
+public abstract class StaticNativeAd extends BaseNativeAd implements ImpressionInterface, ClickInterface {
+    private static final int IMPRESSION_MIN_PERCENTAGE_VIEWED = 50;
+
+    static final double MIN_STAR_RATING = 0;
+    static final double MAX_STAR_RATING = 5;
+
+    // Basic fields
+    @Nullable private String mMainImageUrl;
+    @Nullable private String mIconImageUrl;
+    @Nullable private String mClickDestinationUrl;
+    @Nullable private String mCallToAction;
+    @Nullable private String mTitle;
+    @Nullable private String mText;
+    @Nullable private Double mStarRating;
+    @Nullable private String mPrivacyInformationIconClickThroughUrl;
+    @Nullable private String mPrivacyInformationIconImageUrl;
+
+    // Impression logistics
+    private boolean mImpressionRecorded;
+    private int mImpressionMinTimeViewed;
+
+    // Extras
+    @NonNull private final Map<String, Object> mExtras;
+
+    public StaticNativeAd() {
+        mImpressionMinTimeViewed = 1000;
+
+        mExtras = new HashMap<String, Object>();
+    }
+
+    // Getters
+    /**
+     * Returns the String corresponding to the ad's title.
+     */
+    @Nullable
+    final public String getTitle() {
+        return mTitle;
+    }
+
+    /**
+     * Returns the String corresponding to the ad's body text.
+     */
+    @Nullable
+    final public String getText() {
+        return mText;
+    }
+    /**
+     * Returns the String url corresponding to the ad's main image.
+     */
+    @Nullable
+    final public String getMainImageUrl() {
+        return mMainImageUrl;
+    }
+
+    /**
+     * Returns the String url corresponding to the ad's icon image.
+     */
+    @Nullable
+    final public String getIconImageUrl() {
+        return mIconImageUrl;
+    }
+
+    /**
+     * Returns the Call To Action String (i.e. "Download" or "Learn More") associated with this ad.
+     */
+    @Nullable
+    final public String getCallToAction() {
+        return mCallToAction;
+    }
+
+    /**
+     * For app install ads, this returns the associated star rating (on a 5 star scale) for the
+     * advertised app. Note that this method may return null if the star rating was either never set
+     * or invalid.
+     */
+    @Nullable
+    final public Double getStarRating() {
+        return mStarRating;
+    }
+
+    /**
+     * Returns the Privacy Information click through url. No Privacy Information Icon will be shown
+     * unless this is set to something non-null using {@link #setPrivacyInformationIconClickThroughUrl(String)}.
+     *
+     * @return String representing the Privacy Information Icon click through url, or {@code null}
+     * if not set.
+     */
+    @Nullable
+    final public String getPrivacyInformationIconClickThroughUrl() {
+        return mPrivacyInformationIconClickThroughUrl;
+    }
+
+    /**
+     * Returns the Privacy Information image url.
+     *
+     * @return String representing the Privacy Information Icon image url, or {@code null} if not
+     * set.
+     */
+    @Nullable
+    public String getPrivacyInformationIconImageUrl() {
+        return mPrivacyInformationIconImageUrl;
+    }
+
+    // Extras Getters
+    /**
+     * Given a particular String key, return the associated Object value from the ad's extras map.
+     * See {@link StaticNativeAd#getExtras()} for more information.
+     */
+    @Nullable
+    final public Object getExtra(@NonNull final String key) {
+        if (!NoThrow.checkNotNull(key, "getExtra key is not allowed to be null")) {
+            return null;
+        }
+        return mExtras.get(key);
+    }
+
+    /**
+     * Returns a copy of the extras map, reflecting additional ad content not reflected in any
+     * of the above hardcoded setters. This is particularly useful for passing down custom fields
+     * with MoPub's direct-sold native ads or from mediated networks that pass back additional
+     * fields.
+     */
+    @NonNull
+    final public Map<String, Object> getExtras() {
+        return new HashMap<String, Object>(mExtras);
+    }
+
+    /**
+     * Returns the String url that the device will attempt to resolve when the ad is clicked.
+     */
+    @Nullable
+    final public String getClickDestinationUrl() {
+        return mClickDestinationUrl;
+    }
+
+    final public void setMainImageUrl(@Nullable final String mainImageUrl) {
+        mMainImageUrl = mainImageUrl;
+    }
+
+    final public void setIconImageUrl(@Nullable final String iconImageUrl) {
+        mIconImageUrl = iconImageUrl;
+    }
+
+    final public void setClickDestinationUrl(@Nullable final String clickDestinationUrl) {
+        mClickDestinationUrl = clickDestinationUrl;
+    }
+
+    final public void setCallToAction(@Nullable final String callToAction) {
+        mCallToAction = callToAction;
+    }
+
+    final public void setTitle(@Nullable final String title) {
+        mTitle = title;
+    }
+
+    final public void setText(@Nullable final String text) {
+        mText = text;
+    }
+
+    final public void setStarRating(@Nullable final Double starRating) {
+        if (starRating == null) {
+            mStarRating = null;
+        } else if (starRating >= MIN_STAR_RATING && starRating <= MAX_STAR_RATING) {
+            mStarRating = starRating;
+        } else {
+            MoPubLog.d("Ignoring attempt to set invalid star rating (" + starRating + "). Must be "
+                    + "between " + MIN_STAR_RATING + " and " + MAX_STAR_RATING + ".");
+        }
+    }
+
+    final public void setPrivacyInformationIconClickThroughUrl(
+            @Nullable final String privacyInformationIconClickThroughUrl) {
+        mPrivacyInformationIconClickThroughUrl = privacyInformationIconClickThroughUrl;
+    }
+
+    final public void setPrivacyInformationIconImageUrl(
+            @Nullable String privacyInformationIconImageUrl) {
+        mPrivacyInformationIconImageUrl = privacyInformationIconImageUrl;
+    }
+
+    final public void addExtra(@NonNull final String key, @Nullable final Object value) {
+        if (!NoThrow.checkNotNull(key, "addExtra key is not allowed to be null")) {
+            return;
+        }
+        mExtras.put(key, value);
+    }
+
+    final public void setImpressionMinTimeViewed(final int impressionMinTimeViewed) {
+        if (impressionMinTimeViewed >= 0) {
+            mImpressionMinTimeViewed = impressionMinTimeViewed;
+        }
+    }
+
+    // Lifecycle Handlers
+    @Override
+    public void prepare(@NonNull final View view) { }
+
+    @Override
+    public void clear(@NonNull final View view) { }
+
+    @Override
+    public void destroy() { }
+
+    // Event Handlers
+    /**
+     * Your {@link StaticNativeAd} subclass should implement this method if the network requires the developer
+     * to explicitly record an impression of a view rendered to screen.
+     *
+     * This method is optional.
+     */
+    @Override
+    public void recordImpression(@NonNull final View view) { }
+
+    /**
+     * Returns the minimum viewable percentage of the ad that must be onscreen for it to be
+     * considered visible. See {@link StaticNativeAd#getImpressionMinTimeViewed()} for
+     * additional impression tracking considerations.
+     */
+    @Override
+    final public int getImpressionMinPercentageViewed() {
+        return IMPRESSION_MIN_PERCENTAGE_VIEWED;
+    }
+
+    /**
+     * Returns the minimum amount of time (in milliseconds) the ad that must be onscreen before an
+     * impression is recorded. See {@link StaticNativeAd#getImpressionMinPercentageViewed()}
+     * for additional impression tracking considerations.
+     */
+    @Override
+    final public int getImpressionMinTimeViewed() {
+        return mImpressionMinTimeViewed;
+    }
+
+    @Override
+    final public boolean isImpressionRecorded() {
+        return mImpressionRecorded;
+    }
+
+    @Override
+    final public void setImpressionRecorded() {
+        mImpressionRecorded = true;
+    }
+
+    /**
+     * Your {@link StaticNativeAd} subclass should implement this method if the network requires the developer
+     * to explicitly handle click events of views rendered to screen.
+     *
+     * This method is optional.
+     */
+    @Override
+    public void handleClick(@NonNull final View view) { }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/StaticNativeViewHolder.java b/mopub-sdk/src/main/java/com/mopub/nativeads/StaticNativeViewHolder.java
new file mode 100644
index 00000000..2a5f538b
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/StaticNativeViewHolder.java
@@ -0,0 +1,49 @@
+package com.mopub.nativeads;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.view.View;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+
+class StaticNativeViewHolder {
+    @Nullable View mainView;
+    @Nullable TextView titleView;
+    @Nullable TextView textView;
+    @Nullable TextView callToActionView;
+    @Nullable ImageView mainImageView;
+    @Nullable ImageView iconImageView;
+    @Nullable ImageView privacyInformationIconImageView;
+
+    @VisibleForTesting
+    static final StaticNativeViewHolder EMPTY_VIEW_HOLDER = new StaticNativeViewHolder();
+
+    // Use fromViewBinder instead of a constructor
+    private StaticNativeViewHolder() {}
+
+    @NonNull
+    static StaticNativeViewHolder fromViewBinder(@NonNull final View view,
+            @NonNull final ViewBinder viewBinder) {
+        final StaticNativeViewHolder staticNativeViewHolder = new StaticNativeViewHolder();
+        staticNativeViewHolder.mainView = view;
+        try {
+            staticNativeViewHolder.titleView = (TextView) view.findViewById(viewBinder.titleId);
+            staticNativeViewHolder.textView = (TextView) view.findViewById(viewBinder.textId);
+            staticNativeViewHolder.callToActionView =
+                    (TextView) view.findViewById(viewBinder.callToActionId);
+            staticNativeViewHolder.mainImageView =
+                    (ImageView) view.findViewById(viewBinder.mainImageId);
+            staticNativeViewHolder.iconImageView =
+                    (ImageView) view.findViewById(viewBinder.iconImageId);
+            staticNativeViewHolder.privacyInformationIconImageView =
+                    (ImageView) view.findViewById(viewBinder.privacyInformationIconImageId);
+            return staticNativeViewHolder;
+        } catch (ClassCastException exception) {
+            MoPubLog.w("Could not cast from id in ViewBinder to expected View type", exception);
+            return EMPTY_VIEW_HOLDER;
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/VideoNativeAd.java b/mopub-sdk/src/main/java/com/mopub/nativeads/VideoNativeAd.java
new file mode 100644
index 00000000..71f3fa9a
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/VideoNativeAd.java
@@ -0,0 +1,162 @@
+package com.mopub.nativeads;
+
+import android.annotation.TargetApi;
+import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.view.View;
+
+import com.mopub.common.Preconditions;
+
+import java.util.HashMap;
+import java.util.Map;
+
+@TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+public abstract class VideoNativeAd extends BaseNativeAd implements NativeVideoController.Listener {
+
+    // Basic fields
+    @Nullable private String mMainImageUrl;
+    @Nullable private String mIconImageUrl;
+    @Nullable private String mClickDestinationUrl;
+    @Nullable private String mCallToAction;
+    @Nullable private String mTitle;
+    @Nullable private String mText;
+    @Nullable private String mPrivacyInformationIconClickThroughUrl;
+    @Nullable private String mPrivacyInformationIconImageUrl;
+    @Nullable private String mVastVideo;
+
+    // Extras
+    @NonNull
+    private final Map<String, Object> mExtras;
+
+    public VideoNativeAd() {
+        mExtras = new HashMap<String, Object>();
+    }
+
+    // Getters
+    @Nullable
+    public String getTitle() {
+        return mTitle;
+    }
+
+    @Nullable
+    public String getText() {
+        return mText;
+    }
+
+    @Nullable
+    public String getMainImageUrl() {
+        return mMainImageUrl;
+    }
+
+    @Nullable
+    public String getIconImageUrl() {
+        return mIconImageUrl;
+    }
+
+    @Nullable
+    public String getClickDestinationUrl() {
+        return mClickDestinationUrl;
+    }
+
+    @Nullable
+    public String getVastVideo() {
+        return mVastVideo;
+    }
+
+    @Nullable
+    public String getCallToAction() {
+        return mCallToAction;
+    }
+
+    @Nullable
+    public String getPrivacyInformationIconClickThroughUrl() {
+        return mPrivacyInformationIconClickThroughUrl;
+    }
+
+    /**
+     * Returns the Privacy Information image url.
+     *
+     * @return String representing the Privacy Information Icon image url, or {@code null} if not
+     * set.
+     */
+    @Nullable
+    public String getPrivacyInformationIconImageUrl() {
+        return mPrivacyInformationIconImageUrl;
+    }
+
+    /**
+     * Given a particular String key, return the associated Object value from the ad's extras
+     * map. See {@link VideoNativeAd#getExtras()} for more information.
+     */
+    @Nullable
+    final public Object getExtra(@NonNull final String key) {
+        if (!Preconditions.NoThrow.checkNotNull(key, "getExtra key is not allowed to be null")) {
+            return null;
+        }
+        return mExtras.get(key);
+    }
+
+    final public Map<String, Object> getExtras() {
+        return mExtras;
+    }
+
+    // Setters
+    public void setTitle(@Nullable String title) {
+        mTitle = title;
+    }
+
+    public void setText(@Nullable String text) {
+        mText = text;
+    }
+
+    public void setMainImageUrl(@Nullable String mainImageUrl) {
+        mMainImageUrl = mainImageUrl;
+    }
+
+    public void setIconImageUrl(@Nullable String iconImageUrl) {
+        mIconImageUrl = iconImageUrl;
+    }
+
+    public void setClickDestinationUrl(@Nullable String clickDestinationUrl) {
+        mClickDestinationUrl = clickDestinationUrl;
+    }
+
+    public void setVastVideo(String vastVideo) {
+        mVastVideo = vastVideo;
+    }
+
+    public void setCallToAction(@Nullable String callToAction) {
+        mCallToAction = callToAction;
+    }
+
+    public void setPrivacyInformationIconClickThroughUrl(
+            @Nullable String privacyInformationIconClickThroughUrl) {
+        mPrivacyInformationIconClickThroughUrl = privacyInformationIconClickThroughUrl;
+    }
+
+    public void setPrivacyInformationIconImageUrl(
+            @Nullable String privacyInformationIconImageUrl) {
+        mPrivacyInformationIconImageUrl = privacyInformationIconImageUrl;
+    }
+
+    final public void addExtra(@NonNull final String key, @Nullable final Object value) {
+        if (!Preconditions.NoThrow.checkNotNull(key, "addExtra key is not allowed to be null")) {
+            return;
+        }
+        mExtras.put(key, value);
+    }
+
+    // Lifecycle Handlers
+    @Override
+    public void prepare(@NonNull final View view) { }
+
+    @Override
+    public void clear(@NonNull final View view) { }
+
+    @Override
+    public void destroy() { }
+
+    // Render
+    public void render(@NonNull MediaLayout mediaLayout) { }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ViewBinder.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ViewBinder.java
index bbebba8f..9350f0e7 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/ViewBinder.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/ViewBinder.java
@@ -14,7 +14,7 @@
         private int callToActionId;
         private int mainImageId;
         private int iconImageId;
-        private int daaIconImageId;
+        private int privacyInformationIconImageId;
         @NonNull private Map<String, Integer> extras = Collections.emptyMap();
 
         public Builder(final int layoutId) {
@@ -41,8 +41,8 @@ public final Builder callToActionId(final int callToActionId) {
         }
 
         @NonNull
-        public final Builder mainImageId(final int mainImageId) {
-            this.mainImageId = mainImageId;
+        public final Builder mainImageId(final int mediaLayoutId) {
+            this.mainImageId = mediaLayoutId;
             return this;
         }
 
@@ -53,8 +53,8 @@ public final Builder iconImageId(final int iconImageId) {
         }
 
         @NonNull
-        public final Builder daaIconImageId(final int daaIconImageId) {
-            this.daaIconImageId = daaIconImageId;
+        public final Builder privacyInformationIconImageId(final int privacyInformationIconImageId) {
+            this.privacyInformationIconImageId = privacyInformationIconImageId;
             return this;
         }
 
@@ -82,7 +82,7 @@ public final ViewBinder build() {
     final int callToActionId;
     final int mainImageId;
     final int iconImageId;
-    final int daaIconImageId;
+    final int privacyInformationIconImageId;
     @NonNull final Map<String, Integer> extras;
 
     private ViewBinder(@NonNull final Builder builder) {
@@ -92,7 +92,7 @@ private ViewBinder(@NonNull final Builder builder) {
         this.callToActionId = builder.callToActionId;
         this.mainImageId = builder.mainImageId;
         this.iconImageId = builder.iconImageId;
-        this.daaIconImageId = builder.daaIconImageId;
+        this.privacyInformationIconImageId = builder.privacyInformationIconImageId;
         this.extras = builder.extras;
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/VisibilityTracker.java b/mopub-sdk/src/main/java/com/mopub/nativeads/VisibilityTracker.java
index b98a4481..7732643d 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/VisibilityTracker.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/VisibilityTracker.java
@@ -1,7 +1,6 @@
 package com.mopub.nativeads;
 
 import android.app.Activity;
-import android.content.Context;
 import android.graphics.Rect;
 import android.os.Handler;
 import android.os.SystemClock;
@@ -41,7 +40,7 @@
     private long mAccessCounter = 0;
 
     // Listener that passes all visible and invisible views when a visibility check occurs
-    static interface VisibilityTrackerListener {
+    interface VisibilityTrackerListener {
         void onVisibilityChanged(List<View> visibleViews, List<View> invisibleViews);
     }
 
@@ -50,7 +49,10 @@
 
     static class TrackingInfo {
         int mMinViewablePercent;
+        // Must be less than mMinVisiblePercent
+        int mMaxInvisiblePercent;
         long mAccessOrder;
+        View mRootView;
     }
 
     // Views that are being tracked, mapped to the min viewable percentage
@@ -71,15 +73,15 @@
     // Whether the visibility runnable is scheduled
     private boolean mIsVisibilityScheduled;
 
-    public VisibilityTracker(@NonNull final Context context) {
-        this(context,
+    public VisibilityTracker(@NonNull final Activity activity) {
+        this(activity,
                 new WeakHashMap<View, TrackingInfo>(10),
                 new VisibilityChecker(),
                 new Handler());
     }
 
     @VisibleForTesting
-    VisibilityTracker(@NonNull final Context context,
+    VisibilityTracker(@NonNull final Activity activity,
             @NonNull final Map<View, TrackingInfo> trackedViews,
             @NonNull final VisibilityChecker visibilityChecker,
             @NonNull final Handler visibilityHandler) {
@@ -89,7 +91,7 @@ public VisibilityTracker(@NonNull final Context context) {
         mVisibilityRunnable = new VisibilityRunnable();
         mTrimmedViews = new ArrayList<View>(NUM_ACCESSES_BEFORE_TRIMMING);
 
-        final View rootView = ((Activity) context).getWindow().getDecorView();
+        final View rootView = activity.getWindow().getDecorView();
         mRootView = new WeakReference<View>(rootView);
         final ViewTreeObserver viewTreeObserver = rootView.getViewTreeObserver();
         if (!viewTreeObserver.isAlive()) {
@@ -116,6 +118,14 @@ void setVisibilityTrackerListener(
      * Tracks the given view for visibility.
      */
     void addView(@NonNull final View view, final int minPercentageViewed) {
+        addView(view, view, minPercentageViewed);
+    }
+
+    void addView(@NonNull View rootView, @NonNull final View view, final int minPercentageViewed) {
+      addView(rootView, view, minPercentageViewed, minPercentageViewed);
+    }
+
+    void addView(@NonNull View rootView, @NonNull final View view, final int minVisiblePercentageViewed, final int maxInvisiblePercentageViewed) {
         // Find the view if already tracked
         TrackingInfo trackingInfo = mTrackedViews.get(view);
         if (trackingInfo == null) {
@@ -123,7 +133,12 @@ void addView(@NonNull final View view, final int minPercentageViewed) {
             mTrackedViews.put(view, trackingInfo);
             scheduleVisibilityCheck();
         }
-        trackingInfo.mMinViewablePercent = minPercentageViewed;
+
+        int maxInvisiblePercent = Math.min(maxInvisiblePercentageViewed, minVisiblePercentageViewed);
+
+        trackingInfo.mRootView = rootView;
+        trackingInfo.mMinViewablePercent = minVisiblePercentageViewed;
+        trackingInfo.mMaxInvisiblePercent = maxInvisiblePercent;
         trackingInfo.mAccessOrder = mAccessCounter;
 
         // Trim the number of tracked views to a reasonable number
@@ -207,10 +222,12 @@ public void run() {
             for (final Map.Entry<View, TrackingInfo> entry : mTrackedViews.entrySet()) {
                 final View view = entry.getKey();
                 final int minPercentageViewed = entry.getValue().mMinViewablePercent;
+                final int maxInvisiblePercent = entry.getValue().mMaxInvisiblePercent;
+                final View rootView = entry.getValue().mRootView;
 
-                if (mVisibilityChecker.isVisible(view, minPercentageViewed)) {
+                if (mVisibilityChecker.isVisible(rootView, view, minPercentageViewed)) {
                     mVisibleViews.add(view);
-                } else {
+                } else if (!mVisibilityChecker.isVisible(rootView, view, maxInvisiblePercent)){
                     mInvisibleViews.add(view);
                 }
             }
@@ -239,14 +256,14 @@ boolean hasRequiredTimeElapsed(final long startTimeMillis, final int minTimeView
         /**
          * Whether the view is at least certain % visible
          */
-        boolean isVisible(@Nullable final View view, final int minPercentageViewed) {
+        boolean isVisible(@Nullable final View rootView, @Nullable final View view, final int minPercentageViewed) {
             // ListView & GridView both call detachFromParent() for views that can be recycled for
             // new data. This is one of the rare instances where a view will have a null parent for
             // an extended period of time and will not be the main window.
             // view.getGlobalVisibleRect() doesn't check that case, so if the view has visibility
-            // of View.VISIBLE but has no parent it is likely in the recycle bin of a
+            // of View.VISIBLE but it's group has no parent it is likely in the recycle bin of a
             // ListView / GridView and not on screen.
-            if (view == null || view.getVisibility() != View.VISIBLE || view.getParent() == null) {
+            if (view == null || view.getVisibility() != View.VISIBLE || rootView.getParent() == null) {
                 return false;
             }
 
diff --git a/mopub-sdk/src/main/java/com/mopub/network/AdRequest.java b/mopub-sdk/src/main/java/com/mopub/network/AdRequest.java
index 53fdbc30..5497d6b2 100644
--- a/mopub-sdk/src/main/java/com/mopub/network/AdRequest.java
+++ b/mopub-sdk/src/main/java/com/mopub/network/AdRequest.java
@@ -3,6 +3,7 @@
 import android.content.Context;
 import android.location.Location;
 import android.net.Uri;
+import android.os.Build;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
@@ -16,6 +17,7 @@
 import com.mopub.common.VisibleForTesting;
 import com.mopub.common.event.BaseEvent;
 import com.mopub.common.event.Event;
+import com.mopub.common.event.EventDetails;
 import com.mopub.common.event.MoPubEvents;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.util.Json;
@@ -38,6 +40,7 @@
 import static com.mopub.network.HeaderUtils.extractBooleanHeader;
 import static com.mopub.network.HeaderUtils.extractHeader;
 import static com.mopub.network.HeaderUtils.extractIntegerHeader;
+import static com.mopub.network.HeaderUtils.extractPercentHeaderString;
 
 public class AdRequest extends Request<AdResponse> {
 
@@ -123,7 +126,8 @@ public Listener getListener() {
 
         // In the case of a CLEAR response, the REFRESH_TIME header must still be respected. Ensure
         // that it is parsed and passed along to the MoPubNetworkError.
-        final Integer refreshTimeSeconds = extractIntegerHeader(headers, ResponseHeader.REFRESH_TIME);
+        final Integer refreshTimeSeconds = extractIntegerHeader(headers,
+                ResponseHeader.REFRESH_TIME);
         final Integer refreshTimeMilliseconds = refreshTimeSeconds == null
                 ? null
                 : refreshTimeSeconds * 1000;
@@ -141,11 +145,14 @@ public Listener getListener() {
             );
         }
 
-        builder.setNetworkType(extractHeader(headers, ResponseHeader.NETWORK_TYPE));
+        String networkType = extractHeader(headers, ResponseHeader.NETWORK_TYPE);
+        builder.setNetworkType(networkType);
 
         String redirectUrl = extractHeader(headers, ResponseHeader.REDIRECT_URL);
         builder.setRedirectUrl(redirectUrl);
 
+        // X-Clickthrough is parsed into the AdResponse as the click tracker
+        // Used by AdViewController, Rewarded Video, Native Adapter, MoPubNative
         String clickTrackingUrl = extractHeader(headers, ResponseHeader.CLICK_TRACKING_URL);
         builder.setClickTrackingUrl(clickTrackingUrl);
 
@@ -160,8 +167,9 @@ public Listener getListener() {
         boolean isScrollable = extractBooleanHeader(headers, ResponseHeader.SCROLLABLE, false);
         builder.setScrollable(isScrollable);
 
-        builder.setDimensions(extractIntegerHeader(headers, ResponseHeader.WIDTH),
-                extractIntegerHeader(headers, ResponseHeader.HEIGHT));
+        Integer width = extractIntegerHeader(headers, ResponseHeader.WIDTH);
+        Integer height = extractIntegerHeader(headers, ResponseHeader.HEIGHT);
+        builder.setDimensions(width, height);
 
         Integer adTimeoutDelaySeconds = extractIntegerHeader(headers, ResponseHeader.AD_TIMEOUT);
         builder.setAdTimeoutDelayMilliseconds(
@@ -172,7 +180,7 @@ public Listener getListener() {
         // Response Body encoding / decoding
         String responseBody = parseStringBody(networkResponse);
         builder.setResponseBody(responseBody);
-        if (AdType.NATIVE.equals(adTypeString)) {
+        if (AdType.STATIC_NATIVE.equals(adTypeString) || AdType.VIDEO_NATIVE.equals(adTypeString)) {
             try {
                 builder.setJsonBody(new JSONObject(responseBody));
             } catch (JSONException e) {
@@ -194,28 +202,66 @@ public Listener getListener() {
         if (TextUtils.isEmpty(customEventData)) {
             customEventData = extractHeader(headers, ResponseHeader.NATIVE_PARAMS);
         }
+
+        final Map<String, String> serverExtras;
         try {
-            builder.setServerExtras(Json.jsonStringToMap(customEventData));
+            serverExtras = Json.jsonStringToMap(customEventData);
         } catch (JSONException e) {
             return Response.error(
                     new MoPubNetworkError("Failed to decode server extras for custom event data.",
                             e, MoPubNetworkError.Reason.BAD_HEADER_DATA));
         }
 
-        // Some MoPub-specific custom events get their serverExtras from the response itself:
+        if (redirectUrl != null) {
+            serverExtras.put(DataKeys.REDIRECT_URL_KEY, redirectUrl);
+        }
+        if (clickTrackingUrl != null) {
+            // X-Clickthrough parsed into serverExtras
+            // Used by Banner, Interstitial
+            serverExtras.put(DataKeys.CLICKTHROUGH_URL_KEY, clickTrackingUrl);
+        }
         if (eventDataIsInResponseBody(adTypeString, fullAdTypeString)) {
-            Map<String, String> eventDataMap = new TreeMap<String, String>();
-            eventDataMap.put(DataKeys.HTML_RESPONSE_BODY_KEY, responseBody);
-            eventDataMap.put(DataKeys.SCROLLABLE_KEY, Boolean.toString(isScrollable));
-            eventDataMap.put(DataKeys.CREATIVE_ORIENTATION_KEY, extractHeader(headers, ResponseHeader.ORIENTATION));
-            if (redirectUrl != null) {
-                eventDataMap.put(DataKeys.REDIRECT_URL_KEY, redirectUrl);
-            }
-            if (clickTrackingUrl != null) {
-                eventDataMap.put(DataKeys.CLICKTHROUGH_URL_KEY, clickTrackingUrl);
+            // Some MoPub-specific custom events get their serverExtras from the response itself:
+            serverExtras.put(DataKeys.HTML_RESPONSE_BODY_KEY, responseBody);
+            serverExtras.put(DataKeys.SCROLLABLE_KEY, Boolean.toString(isScrollable));
+            serverExtras.put(DataKeys.CREATIVE_ORIENTATION_KEY, extractHeader(headers, ResponseHeader.ORIENTATION));
+        }
+        if (AdType.VIDEO_NATIVE.equals(adTypeString)) {
+            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN) {
+                return Response.error(new MoPubNetworkError("Native Video ads are only supported" +
+                        " for Android API Level 16 (JellyBean) and above.",
+                        MoPubNetworkError.Reason.UNSPECIFIED));
+
             }
-            builder.setServerExtras(eventDataMap);
+            serverExtras.put(DataKeys.PLAY_VISIBLE_PERCENT,
+                    extractPercentHeaderString(headers, ResponseHeader.PLAY_VISIBLE_PERCENT));
+            serverExtras.put(DataKeys.PAUSE_VISIBLE_PERCENT,
+                    extractPercentHeaderString(headers, ResponseHeader.PAUSE_VISIBLE_PERCENT));
+            serverExtras.put(DataKeys.IMPRESSION_MIN_VISIBLE_PERCENT,
+                    extractPercentHeaderString(headers,
+                            ResponseHeader.IMPRESSION_MIN_VISIBLE_PERCENT));
+            serverExtras.put(DataKeys.IMPRESSION_VISIBLE_MS, extractHeader(headers,
+                    ResponseHeader.IMPRESSION_VISIBLE_MS));
+            serverExtras.put(DataKeys.MAX_BUFFER_MS, extractHeader(headers,
+                    ResponseHeader.MAX_BUFFER_MS));
+
+            builder.setEventDetails(new EventDetails.Builder()
+                            .adUnitId(mAdUnitId)
+                            .adType(adTypeString)
+                            .adNetworkType(networkType)
+                            .adWidthPx(width)
+                            .adHeightPx(height)
+                            .geoLatitude(location == null ? null : location.getLatitude())
+                            .geoLongitude(location == null ? null : location.getLongitude())
+                            .geoAccuracy(location == null ? null : location.getAccuracy())
+                            .performanceDurationMs(networkResponse.networkTimeMs)
+                            .requestId(requestId)
+                            .requestStatusCode(networkResponse.statusCode)
+                            .requestUri(getUrl())
+                            .build()
+            );
         }
+        builder.setServerExtras(serverExtras);
 
         AdResponse adResponse = builder.build();
         logScribeEvent(adResponse, networkResponse, location);
diff --git a/mopub-sdk/src/main/java/com/mopub/network/AdResponse.java b/mopub-sdk/src/main/java/com/mopub/network/AdResponse.java
index 8c7bc330..6a955e86 100644
--- a/mopub-sdk/src/main/java/com/mopub/network/AdResponse.java
+++ b/mopub-sdk/src/main/java/com/mopub/network/AdResponse.java
@@ -3,6 +3,7 @@
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 
+import com.mopub.common.event.EventDetails;
 import com.mopub.common.util.DateAndTime;
 
 import org.json.JSONObject;
@@ -54,6 +55,9 @@
     @Nullable
     private final JSONObject mJsonBody;
 
+    @Nullable
+    private final EventDetails mEventDetails;
+
     @Nullable
     private final String mCustomEventClassName;
     @NonNull
@@ -80,6 +84,7 @@ private AdResponse(@NonNull Builder builder) {
         mScrollable = builder.scrollable;
         mResponseBody = builder.responseBody;
         mJsonBody = builder.jsonBody;
+        mEventDetails = builder.eventDetails;
         mCustomEventClassName = builder.customEventClassName;
         mServerExtras = builder.serverExtras;
         mTimestamp = DateAndTime.now().getTime();
@@ -94,6 +99,11 @@ public JSONObject getJsonBody() {
         return mJsonBody;
     }
 
+    @Nullable
+    public EventDetails getEventDetails() {
+        return mEventDetails;
+    }
+
     @Nullable
     public String getStringBody() {
         return mResponseBody;
@@ -203,6 +213,7 @@ public Builder toBuilder() {
                 .setScrollable(mScrollable)
                 .setResponseBody(mResponseBody)
                 .setJsonBody(mJsonBody)
+                .setEventDetails(mEventDetails)
                 .setCustomEventClassName(mCustomEventClassName)
                 .setServerExtras(mServerExtras);
     }
@@ -230,6 +241,8 @@ public Builder toBuilder() {
         private String responseBody;
         private JSONObject jsonBody;
 
+        private EventDetails eventDetails;
+
         private String customEventClassName;
         private Map<String, String> serverExtras = new TreeMap<String, String>();
 
@@ -315,6 +328,11 @@ public Builder setJsonBody(@Nullable final JSONObject jsonBody) {
             return this;
         }
 
+        public Builder setEventDetails(@Nullable final EventDetails eventDetails) {
+            this.eventDetails = eventDetails;
+            return this;
+        }
+
         public Builder setCustomEventClassName(@Nullable final String customEventClassName) {
             this.customEventClassName = customEventClassName;
             return this;
diff --git a/mopub-sdk/src/main/java/com/mopub/network/HeaderUtils.java b/mopub-sdk/src/main/java/com/mopub/network/HeaderUtils.java
index a4754422..1732beab 100644
--- a/mopub-sdk/src/main/java/com/mopub/network/HeaderUtils.java
+++ b/mopub-sdk/src/main/java/com/mopub/network/HeaderUtils.java
@@ -25,6 +25,18 @@ public static boolean extractBooleanHeader(Map<String, String> headers, Response
         return formatBooleanHeader(extractHeader(headers, responseHeader), defaultValue);
     }
 
+    public static Integer extractPercentHeader(Map<String, String> headers, ResponseHeader responseHeader) {
+        return formatPercentHeader(extractHeader(headers, responseHeader));
+    }
+
+    @Nullable
+    public static String extractPercentHeaderString(Map<String, String> headers,
+            ResponseHeader responseHeader) {
+        Integer percentHeaderValue = extractPercentHeader(headers, responseHeader);
+        return percentHeaderValue != null ? percentHeaderValue.toString() : null;
+    }
+
+
     public static String extractHeader(HttpResponse response, ResponseHeader responseHeader) {
         Header header = response.getFirstHeader(responseHeader.getKey());
         return header != null ? header.getValue() : null;
@@ -70,4 +82,19 @@ private static Integer formatIntHeader(String headerValue) {
             return null;
         }
     }
+
+    @Nullable
+    private static Integer formatPercentHeader(@Nullable String headerValue) {
+        if (headerValue == null) {
+            return null;
+        }
+
+        final Integer percentValue = formatIntHeader(headerValue.replace("%", ""));
+
+        if (percentValue == null || percentValue < 0 || percentValue > 100) {
+            return null;
+        }
+
+        return percentValue;
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/network/TrackingRequest.java b/mopub-sdk/src/main/java/com/mopub/network/TrackingRequest.java
index e2e93b04..78bb26f7 100644
--- a/mopub-sdk/src/main/java/com/mopub/network/TrackingRequest.java
+++ b/mopub-sdk/src/main/java/com/mopub/network/TrackingRequest.java
@@ -93,17 +93,6 @@ public static void makeVastTrackingHttpRequest(
         );
     }
 
-    public static void makeTrackingHttpRequest(@Nullable final Iterable<String> urls,
-            @Nullable final Context context) {
-        makeTrackingHttpRequest(urls, context, null, null);
-    }
-
-    public static void makeTrackingHttpRequest(@Nullable final Iterable<String> urls,
-            @Nullable final Context context,
-            final BaseEvent.Name name) {
-        makeTrackingHttpRequest(urls, context, null, name);
-    }
-
     public static void makeTrackingHttpRequest(@Nullable final Iterable<String> urls,
             @Nullable final Context context,
             @Nullable final Listener listener,
@@ -163,4 +152,15 @@ public static void makeTrackingHttpRequest(@Nullable final String url,
             makeTrackingHttpRequest(Arrays.asList(url), context, listener, name);
         }
     }
+
+    public static void makeTrackingHttpRequest(@Nullable final Iterable<String> urls,
+            @Nullable final Context context) {
+        makeTrackingHttpRequest(urls, context, null, null);
+    }
+
+    public static void makeTrackingHttpRequest(@Nullable final Iterable<String> urls,
+            @Nullable final Context context,
+            final BaseEvent.Name name) {
+        makeTrackingHttpRequest(urls, context, null, name);
+    }
 }
diff --git a/mopub-sdk/src/main/resources/fabric/com.mopub.sdk.android.mopub.properties b/mopub-sdk/src/main/resources/fabric/com.mopub.sdk.android.mopub.properties
index 34d02ef3..220fb003 100644
--- a/mopub-sdk/src/main/resources/fabric/com.mopub.sdk.android.mopub.properties
+++ b/mopub-sdk/src/main/resources/fabric/com.mopub.sdk.android.mopub.properties
@@ -1,3 +1,3 @@
 fabric-identifier=com.mopub.sdk.android:mopub
-fabric-version=3.13.0+kit
+fabric-version=4.3.0+kit
 fabric-build-type=source
diff --git a/mopub-sdk/src/test/java/com/mopub/TestSdkHelper.java b/mopub-sdk/src/test/java/com/mopub/TestSdkHelper.java
new file mode 100644
index 00000000..0f91d2e6
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/TestSdkHelper.java
@@ -0,0 +1,23 @@
+package com.mopub;
+
+import android.os.Build;
+
+import org.robolectric.util.ReflectionHelpers;
+
+public class TestSdkHelper {
+
+    /**
+     * Sets the SDK level using reflection. Must only be used in tests, in situations where
+     * Robolectric does not support a given level. Only sets SDK level for one test.
+     * If you need this value to apply to the whole class, take care to set this in {@code #setUp}.
+     *
+     * Be careful when setting this value before calling Robolectric code, as it can interfere with
+     * some Robolectric behaviors (like attempting to call older API methods that do not
+     * exist in the android.jar you are executing against.)
+     *
+     */
+    public static void setReportedSdkLevel(final int sdkLevel) {
+        ReflectionHelpers.setStaticField(Build.VERSION.class, "SDK_INT", sdkLevel);
+    }
+
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/AdReportTest.java b/mopub-sdk/src/test/java/com/mopub/common/AdReportTest.java
index 6bdefe59..75d415c2 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/AdReportTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/AdReportTest.java
@@ -4,12 +4,14 @@
 
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.common.util.test.support.TestDateAndTime;
+import com.mopub.mobileads.BuildConfig;
 import com.mopub.network.AdResponse;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
+import org.robolectric.annotation.Config;
 
 import java.text.SimpleDateFormat;
 import java.util.Date;
@@ -19,6 +21,7 @@
 import static org.mockito.Mockito.stub;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class AdReportTest {
 
     public AdReport subject;
diff --git a/mopub-sdk/src/test/java/com/mopub/common/BrowserWebViewClientTest.java b/mopub-sdk/src/test/java/com/mopub/common/BrowserWebViewClientTest.java
index 08917adb..03930940 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/BrowserWebViewClientTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/BrowserWebViewClientTest.java
@@ -8,11 +8,14 @@
 import android.webkit.WebView;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.anyString;
@@ -24,6 +27,7 @@
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class BrowserWebViewClientTest {
 
     private final WebView MOOT_WEB_VIEW = null;
@@ -165,7 +169,7 @@ public void shouldOverrideUrlLoading_withoutMatchingSupporedUrl_shouldReturnFals
     }
 
     private void makeDeeplinkResolvable(String deeplink) {
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(Intent.ACTION_VIEW,
+        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(Intent.ACTION_VIEW,
                 Uri.parse(deeplink)), new ResolveInfo());
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/CacheServiceTest.java b/mopub-sdk/src/test/java/com/mopub/common/CacheServiceTest.java
index ce7282a3..14bcb296 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/CacheServiceTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/CacheServiceTest.java
@@ -3,6 +3,7 @@
 import android.app.Activity;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 
 import org.junit.Before;
 import org.junit.Test;
@@ -10,6 +11,7 @@
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
 
 import java.io.ByteArrayInputStream;
 import java.io.File;
@@ -26,6 +28,7 @@
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class CacheServiceTest {
 
     private Activity context;
diff --git a/mopub-sdk/src/test/java/com/mopub/common/ClientMetadataTest.java b/mopub-sdk/src/test/java/com/mopub/common/ClientMetadataTest.java
index ba6fcd75..31f38117 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/ClientMetadataTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/ClientMetadataTest.java
@@ -5,20 +5,22 @@
 import android.telephony.TelephonyManager;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 import com.mopub.mobileads.test.support.MoPubShadowTelephonyManager;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
 
 import static android.Manifest.permission.ACCESS_NETWORK_STATE;
 import static org.fest.assertions.api.Assertions.assertThat;
-import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(SdkTestRunner.class)
-@Config(shadows = {MoPubShadowTelephonyManager.class})
+@Config(constants = BuildConfig.class,
+        shadows = {MoPubShadowTelephonyManager.class})
 public class ClientMetadataTest {
 
     public Activity activityContext;
@@ -27,9 +29,9 @@
     @Before
     public void setUp() throws Exception {
         activityContext = Robolectric.buildActivity(Activity.class).create().get();
-        shadowOf(activityContext).grantPermissions(ACCESS_NETWORK_STATE);
+        Shadows.shadowOf(activityContext).grantPermissions(ACCESS_NETWORK_STATE);
         shadowTelephonyManager = (MoPubShadowTelephonyManager)
-                shadowOf((TelephonyManager) activityContext.getSystemService(Context.TELEPHONY_SERVICE));
+                Shadows.shadowOf((TelephonyManager) activityContext.getSystemService(Context.TELEPHONY_SERVICE));
     }
 
     // This has to be first or the singleton will be initialized by an earlier test. We should
diff --git a/mopub-sdk/src/test/java/com/mopub/common/CloseableLayoutTest.java b/mopub-sdk/src/test/java/com/mopub/common/CloseableLayoutTest.java
index 5c5f35e1..5ebd9c47 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/CloseableLayoutTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/CloseableLayoutTest.java
@@ -10,18 +10,21 @@
 import com.mopub.common.CloseableLayout.ClosePosition;
 import com.mopub.common.CloseableLayout.OnCloseListener;
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class CloseableLayoutTest {
     private CloseableLayout subject;
 
@@ -142,7 +145,7 @@ public void onInterceptTouchEvent_closeRegionDown_shouldReturnTrue() {
         subject.onTouchEvent(closeRegionUp);
         assertThat(subject.isClosePressed()).isTrue();
 
-        Robolectric.getUiThreadScheduler().advanceToLastPostedRunnable();
+        Robolectric.getForegroundThreadScheduler().advanceToLastPostedRunnable();
         assertThat(subject.isClosePressed()).isFalse();
     }
 
diff --git a/mopub-sdk/src/test/java/com/mopub/common/DownloadResponseTest.java b/mopub-sdk/src/test/java/com/mopub/common/DownloadResponseTest.java
index b0de5153..178bc7b3 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/DownloadResponseTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/DownloadResponseTest.java
@@ -2,12 +2,14 @@
 
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.common.util.ResponseHeader;
+import com.mopub.mobileads.BuildConfig;
 import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
 
 import org.apache.http.HttpResponse;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
 
 import java.util.Locale;
 
@@ -19,6 +21,7 @@
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class DownloadResponseTest {
 
     DownloadResponse subject;
diff --git a/mopub-sdk/src/test/java/com/mopub/common/GpsHelperTest.java b/mopub-sdk/src/test/java/com/mopub/common/GpsHelperTest.java
index 25ce4ba3..a54830ea 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/GpsHelperTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/GpsHelperTest.java
@@ -7,12 +7,15 @@
 import com.mopub.common.factories.MethodBuilderFactory;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.common.util.test.support.TestMethodBuilderFactory;
+import com.mopub.mobileads.BuildConfig;
 
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLooper;
 
 import java.util.concurrent.Semaphore;
 
@@ -25,6 +28,7 @@
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class GpsHelperTest {
     private MethodBuilder methodBuilder;
     private Activity context;
@@ -293,8 +297,8 @@ static public void populateAndVerifyClientMetadata(Context context, TestAdInfo a
     }
 
     private void safeAcquireSemaphore() throws Exception {
-        Robolectric.runBackgroundTasks();
-        Robolectric.runUiThreadTasks();
+        Robolectric.getBackgroundThreadScheduler().advanceBy(0);
+        ShadowLooper.runUiThreadTasks();
         semaphore.acquire();
     }
 
diff --git a/mopub-sdk/src/test/java/com/mopub/common/HttpResponsesTest.java b/mopub-sdk/src/test/java/com/mopub/common/HttpResponsesTest.java
index 814bcf55..0d8ee5d9 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/HttpResponsesTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/HttpResponsesTest.java
@@ -8,11 +8,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.Shadows;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
-import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(RobolectricTestRunner.class)
 public class HttpResponsesTest {
@@ -33,7 +33,7 @@ public void asBitmap_shouldReturnBitmap() throws Exception {
 
         assertThat(bitmap).isNotNull();
         assertThat(bitmap).isInstanceOf(Bitmap.class);
-        assertThat(shadowOf(bitmap).getCreatedFromBytes()).isEqualTo(imageData.getBytes());
+        assertThat(Shadows.shadowOf(bitmap).getCreatedFromBytes()).isEqualTo(imageData.getBytes());
     }
 
     @Test
diff --git a/mopub-sdk/src/test/java/com/mopub/common/MoPubBrowserTest.java b/mopub-sdk/src/test/java/com/mopub/common/MoPubBrowserTest.java
index 41e8f54c..7ecf4ae8 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/MoPubBrowserTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/MoPubBrowserTest.java
@@ -6,17 +6,20 @@
 import android.webkit.WebView;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
 
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class MoPubBrowserTest {
 
     private MoPubBrowser subject;
diff --git a/mopub-sdk/src/test/java/com/mopub/common/MoPubHttpUrlConnectionTest.java b/mopub-sdk/src/test/java/com/mopub/common/MoPubHttpUrlConnectionTest.java
index c961763e..474dfa45 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/MoPubHttpUrlConnectionTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/MoPubHttpUrlConnectionTest.java
@@ -5,15 +5,14 @@
 import android.webkit.WebView;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 import com.mopub.network.Networking;
 
-import org.apache.http.HttpRequest;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
-import org.robolectric.tester.org.apache.http.RequestMatcher;
-import org.robolectric.tester.org.apache.http.TestHttpResponse;
+import org.robolectric.annotation.Config;
 
 import java.net.HttpURLConnection;
 import java.net.MalformedURLException;
@@ -23,6 +22,7 @@
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class MoPubHttpUrlConnectionTest {
     private static final String url = "http://www.mopub.com";
     private String userAgent;
diff --git a/mopub-sdk/src/test/java/com/mopub/common/UrlHandlerTest.java b/mopub-sdk/src/test/java/com/mopub/common/UrlHandlerTest.java
index d70faa57..14a9cb95 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/UrlHandlerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/UrlHandlerTest.java
@@ -8,6 +8,7 @@
 import android.support.annotation.NonNull;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 import com.mopub.network.MoPubRequestQueue;
 import com.mopub.network.Networking;
 
@@ -16,6 +17,9 @@
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.robolectric.Robolectric;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowApplication;
 
 import static com.mopub.common.UrlAction.FOLLOW_DEEP_LINK;
 import static com.mopub.common.UrlAction.FOLLOW_DEEP_LINK_WITH_FALLBACK;
@@ -35,6 +39,7 @@
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class UrlHandlerTest {
     private Context context;
     @Mock private UrlHandler.ResultActions mockResultActions;
@@ -59,7 +64,7 @@ public void urlHandler_withoutMoPubBrowser_shouldCallOnClickSuccessButNotStartAc
 
         verify(mockResultActions).urlHandlingSucceeded(url, OPEN_IN_APP_BROWSER);
         verifyNoMoreCallbacks();
-        final Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        final Intent startedActivity = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(startedActivity).isNull();
     }
 
@@ -159,7 +164,7 @@ public void urlHandler_withMatchingPhoneSchemeUrl_shouldStartActivity() {
                 .withMoPubSchemeListener(mockMoPubSchemeListener)
                 .build().handleResolvedUrl(context, url, true, null);
 
-        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+        final Intent startedActivity = ShadowApplication.getInstance().peekNextStartedActivity();
         assertThat(startedActivity.getAction()).isEqualTo(Intent.ACTION_VIEW);
         assertThat(startedActivity.getData()).isEqualTo(Uri.parse(url));
     }
@@ -178,7 +183,7 @@ public void urlHandler_withValidNativeBrowserUrl_shouldCallOnClickSuccess_should
 
         verify(mockResultActions).urlHandlingSucceeded(url, OPEN_NATIVE_BROWSER);
         verifyNoMoreCallbacks();
-        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+        final Intent startedActivity = ShadowApplication.getInstance().peekNextStartedActivity();
         assertThat(startedActivity.getAction()).isEqualTo(Intent.ACTION_VIEW);
         assertThat(startedActivity.getData()).isEqualTo(Uri.parse(urlToLoad));
     }
@@ -196,7 +201,7 @@ public void urlHandler_withMatchingInAppBrowserHttpUrl_shouldCallOnClickSuccess_
 
         verify(mockResultActions).urlHandlingSucceeded(url, OPEN_IN_APP_BROWSER);
         verifyNoMoreCallbacks();
-        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+        final Intent startedActivity = ShadowApplication.getInstance().peekNextStartedActivity();
         assertThat(startedActivity.getComponent().getClassName())
                 .isEqualTo(MoPubBrowser.class.getName());
         assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(url);
@@ -215,7 +220,7 @@ public void urlHandler_withMatchingInAppBrowserHttpsUrl_shouldCallOnClickSuccess
 
         verify(mockResultActions).urlHandlingSucceeded(url, OPEN_IN_APP_BROWSER);
         verifyNoMoreCallbacks();
-        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+        final Intent startedActivity = ShadowApplication.getInstance().peekNextStartedActivity();
         assertThat(startedActivity.getComponent().getClassName())
                 .isEqualTo(MoPubBrowser.class.getName());
         assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(url);
@@ -232,7 +237,7 @@ public void urlHandler_withMatchingShareUrl_shouldCallOnClickSuccess_shouldStart
 
         verify(mockResultActions).urlHandlingSucceeded(shareTweetUrl, HANDLE_SHARE_TWEET);
         verifyNoMoreCallbacks();
-        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+        final Intent startedActivity = ShadowApplication.getInstance().peekNextStartedActivity();
         assertThat(startedActivity.getAction()).isEqualTo(Intent.ACTION_CHOOSER);
     }
 
@@ -249,7 +254,7 @@ public void urlHandler_withMatchingDeepLinkUrl_shouldCallOnClickSuccess_shouldSt
 
         verify(mockResultActions).urlHandlingSucceeded(deepLinkUrl, FOLLOW_DEEP_LINK);
         verifyNoMoreCallbacks();
-        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+        final Intent startedActivity = ShadowApplication.getInstance().peekNextStartedActivity();
         assertThat(startedActivity.getAction()).isEqualTo(Intent.ACTION_VIEW);
         assertThat(startedActivity.getData()).isEqualTo(Uri.parse(deepLinkUrl));
     }
@@ -267,7 +272,7 @@ public void urlHandler_withMatchingDeeplinkPlus_shouldCallOnClickSuccess_shouldS
 
         verify(mockResultActions).urlHandlingSucceeded(deeplinkPlusUrl, FOLLOW_DEEP_LINK_WITH_FALLBACK);
         verifyNoMoreCallbacks();
-        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+        final Intent startedActivity = ShadowApplication.getInstance().peekNextStartedActivity();
         assertThat(startedActivity.getAction()).isEqualTo(Intent.ACTION_VIEW);
         assertThat(startedActivity.getData()).isEqualTo(Uri.parse(primaryUrl));
     }
@@ -285,11 +290,11 @@ public void urlHandler_withMatchingUnresolvableDeeplinkPlus_withResolvableFallba
                 .withResultActions(mockResultActions)
                 .build().handleUrl(context, deeplinkPlusUrl);
 
-        Robolectric.runBackgroundTasks();
+        Robolectric.getBackgroundThreadScheduler().advanceBy(0);
         verify(mockResultActions).urlHandlingSucceeded(fallbackUrlAfterRedirects,
                 OPEN_IN_APP_BROWSER);
         verifyNoMoreCallbacks();
-        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+        final Intent startedActivity = ShadowApplication.getInstance().peekNextStartedActivity();
         assertThat(startedActivity.getComponent().getClassName())
                 .isEqualTo(MoPubBrowser.class.getName());
         assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY))
@@ -879,11 +884,11 @@ private void verifyNoMoreCallbacks() {
     }
 
     private void verifyNoStartedActivity() {
-        assertThat(Robolectric.getShadowApplication().peekNextStartedActivity()).isNull();
+        assertThat(ShadowApplication.getInstance().peekNextStartedActivity()).isNull();
     }
 
     private void makeDeeplinkResolvable(String deeplink) {
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(Intent.ACTION_VIEW,
+        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(Intent.ACTION_VIEW,
                 Uri.parse(deeplink)), new ResolveInfo());
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/BaseEventTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/BaseEventTest.java
index 55a087f4..085d607f 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/event/BaseEventTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/BaseEventTest.java
@@ -2,17 +2,20 @@
 
 import com.mopub.common.ClientMetadata;
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
+import org.robolectric.annotation.Config;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class BaseEventTest {
 
     private BaseEvent subject;
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/ErrorEventTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/ErrorEventTest.java
index 05cd07f6..957552b1 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/event/ErrorEventTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/ErrorEventTest.java
@@ -1,14 +1,17 @@
 package com.mopub.common.event;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class ErrorEventTest {
 
     private ErrorEvent subject;
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/EventDispatcherTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/EventDispatcherTest.java
index 1c32fd16..9b3fef29 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/event/EventDispatcherTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/EventDispatcherTest.java
@@ -6,11 +6,13 @@
 import android.os.Message;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
+import org.robolectric.annotation.Config;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -23,6 +25,7 @@
 
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class EventDispatcherTest {
 
     private EventDispatcher subject;
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/EventSamplerTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/EventSamplerTest.java
index d6494a11..b4b2d15e 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/event/EventSamplerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/EventSamplerTest.java
@@ -1,11 +1,14 @@
 package com.mopub.common.event;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
+import org.mockito.stubbing.OngoingStubbing;
+import org.robolectric.annotation.Config;
 
 import java.util.Random;
 
@@ -13,6 +16,7 @@
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class EventSamplerTest {
 
     private EventSampler subject;
@@ -42,4 +46,44 @@ public void sample_withRandomNumberGreaterOrEqualTo10Percent_shouldReturnFalse()
 
         assertThat(result).isFalse();
     }
+
+    @Test
+    public void sample_withSameRequestId_shouldReturnSameValueRegardlessOfSampleRate() throws Exception {
+        when(mockRandom.nextDouble()).thenReturn(0.09).thenReturn(0.999);
+        when(mockBaseEvent.getRequestId()).thenReturn("rid");
+
+        boolean firstResult = subject.sample(mockBaseEvent);
+        assertThat(firstResult).isTrue();
+
+        boolean secondResult = subject.sample(mockBaseEvent);
+        assertThat(secondResult).isTrue();
+    }
+
+    @Test
+    public void sample_withDifferentRequestId_shouldReturnResultBasedOnSampleRate() throws Exception {
+        when(mockRandom.nextDouble()).thenReturn(0.09).thenReturn(0.999);
+        when(mockBaseEvent.getRequestId()).thenReturn("rid1").thenReturn("rid2");
+
+        boolean firstResult = subject.sample(mockBaseEvent);
+        assertThat(firstResult).isTrue();
+
+        boolean secondResult = subject.sample(mockBaseEvent);
+        assertThat(secondResult).isFalse();
+    }
+
+    @Test
+    public void sample_withTooManyEvents_shouldHoldAMaximumNumberOfRequestIds() {
+        when(mockRandom.nextDouble()).thenReturn(0.001);
+        OngoingStubbing<String> ongoingStubbing = when(mockBaseEvent.getRequestId()).thenReturn(
+                "rid0");
+        for (int i = 1; i < EventSampler.MAX_SIZE * 3; i++) {
+            ongoingStubbing = ongoingStubbing.thenReturn("rid" + i);
+        }
+
+        for (int i = 0; i < EventSampler.MAX_SIZE * 3; i++) {
+            subject.sample(mockBaseEvent);
+        }
+
+        assertThat(subject.getCacheSize()).isEqualTo(EventSampler.MAX_SIZE);
+    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/EventSerializerTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/EventSerializerTest.java
index 22a6bebc..52e4eb84 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/event/EventSerializerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/EventSerializerTest.java
@@ -4,6 +4,7 @@
 
 import com.mopub.common.ClientMetadata;
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 
 import org.json.JSONArray;
 import org.json.JSONObject;
@@ -12,6 +13,7 @@
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
 
 import java.util.ArrayList;
 
@@ -19,6 +21,7 @@
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class EventSerializerTest {
 
     private EventSerializer subject;
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/EventTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/EventTest.java
index 6a3e58f2..3384f75e 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/event/EventTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/EventTest.java
@@ -1,14 +1,17 @@
 package com.mopub.common.event;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class EventTest {
 
     private Event subject;
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/MoPubEventsTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/MoPubEventsTest.java
index d555f34e..2bf68573 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/event/MoPubEventsTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/MoPubEventsTest.java
@@ -1,10 +1,12 @@
 package com.mopub.common.event;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
 
 import java.util.ArrayList;
 
@@ -14,6 +16,7 @@
 
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class MoPubEventsTest {
 
     @Before
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/ScribeEventRecorderTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/ScribeEventRecorderTest.java
index 5681be25..7305cc7b 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/event/ScribeEventRecorderTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/ScribeEventRecorderTest.java
@@ -3,6 +3,7 @@
 import android.os.Handler;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 import com.mopub.network.ScribeBackoffPolicy;
 import com.mopub.network.ScribeRequest;
 import com.mopub.network.ScribeRequestManager;
@@ -13,6 +14,7 @@
 import org.mockito.Mock;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
+import org.robolectric.annotation.Config;
 
 import java.util.List;
 import java.util.Queue;
@@ -28,6 +30,7 @@
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class ScribeEventRecorderTest {
 
     private ScribeEventRecorder subject;
diff --git a/mopub-sdk/src/test/java/com/mopub/common/test/support/SdkTestRunner.java b/mopub-sdk/src/test/java/com/mopub/common/test/support/SdkTestRunner.java
index 2fcb133e..9f3cf277 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/test/support/SdkTestRunner.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/test/support/SdkTestRunner.java
@@ -39,31 +39,28 @@
 import org.junit.runners.model.InitializationError;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.DefaultTestLifecycle;
-import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RobolectricGradleTestRunner;
 import org.robolectric.TestLifecycle;
-import org.robolectric.bytecode.ClassInfo;
-import org.robolectric.bytecode.Setup;
-import org.robolectric.util.RobolectricBackgroundExecutorService;
+import org.robolectric.internal.bytecode.InstrumentationConfiguration;
+import org.robolectric.util.concurrent.RoboExecutorService;
 
 import static com.mopub.common.MoPub.LocationAwareness;
 import static org.mockito.Mockito.mock;
 
-public class SdkTestRunner extends RobolectricTestRunner {
+public class SdkTestRunner extends RobolectricGradleTestRunner {
 
     public SdkTestRunner(Class<?> testClass) throws InitializationError {
         super(testClass);
     }
 
     @Override
-    public Setup createSetup() {
-        return new Setup() {
-            @Override
-            public boolean shouldInstrument(ClassInfo classInfo) {
-                return classInfo.getName().equals(AsyncTasks.class.getName())
-                        || classInfo.getName().equals(MoPubHttpUrlConnection.class.getName())
-                        || super.shouldInstrument(classInfo);
-            }
-        };
+    public InstrumentationConfiguration createClassLoaderConfig() {
+        InstrumentationConfiguration.Builder builder = InstrumentationConfiguration.newBuilder();
+        builder.addInstrumentedClass(AsyncTasks.class.getName());
+        builder.addInstrumentedClass(MoPubHttpUrlConnection.class.getName());
+        // To mitigate: https://github.com/robolectric/robolectric/issues/2129
+        builder.addInstrumentedPackage("org.xyz.testMp");
+        return builder.build();
     }
 
     @Override
@@ -98,7 +95,7 @@ public void prepareTest(Object test) {
 
             MockitoAnnotations.initMocks(test);
 
-            AsyncTasks.setExecutor(new RobolectricBackgroundExecutorService());
+            AsyncTasks.setExecutor(new RoboExecutorService());
             CacheService.clearAndNullCaches();
         }
     }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/AsyncTasksTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/AsyncTasksTest.java
index 2bfebb20..63212fdb 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/util/AsyncTasksTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/AsyncTasksTest.java
@@ -1,18 +1,19 @@
 package com.mopub.common.util;
 
+import android.annotation.TargetApi;
 import android.os.AsyncTask;
 import android.os.Build.VERSION_CODES;
 import android.os.Handler;
 import android.os.Looper;
 
+import com.mopub.TestSdkHelper;
 import com.mopub.mobileads.test.support.ThreadUtils;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLooper;
 
 import java.util.concurrent.Executor;
 
@@ -37,25 +38,28 @@ protected Void doInBackground(String... strings) {
         });
     }
 
-    @Config(reportSdk = VERSION_CODES.GINGERBREAD_MR1)
     @Test
     public void safeExecuteOnExecutor_beforeHoneycomb_shouldCallExecuteWithParams() throws Exception {
+        TestSdkHelper.setReportedSdkLevel(VERSION_CODES.GINGERBREAD_MR1);
         AsyncTasks.safeExecuteOnExecutor(asyncTask, "hello");
 
         verify(asyncTask).execute(eq("hello"));
     }
 
-    @Config(reportSdk = VERSION_CODES.GINGERBREAD_MR1)
+
     @Test
     public void safeExecutorOnExecutor_beforeHoneycomb_withNullParam_shouldCallExecute() throws Exception {
+        TestSdkHelper.setReportedSdkLevel(VERSION_CODES.GINGERBREAD_MR1);
+
         AsyncTasks.safeExecuteOnExecutor(asyncTask, (String) null);
 
         verify(asyncTask).execute(eq((String) null));
     }
 
-    @Config(reportSdk = VERSION_CODES.GINGERBREAD_MR1)
+
     @Test
     public void safeExecutorOnExecutor_beforeHoneycomb_withNullAsyncTask_shouldThrowIllegalArgumentException() throws Exception {
+        TestSdkHelper.setReportedSdkLevel(VERSION_CODES.GINGERBREAD_MR1);
         try {
             AsyncTasks.safeExecuteOnExecutor(null, "hello");
             fail("Should have thrown NullPointerException");
@@ -64,31 +68,36 @@ public void safeExecutorOnExecutor_beforeHoneycomb_withNullAsyncTask_shouldThrow
         }
     }
 
-    @Config(reportSdk = VERSION_CODES.GINGERBREAD_MR1)
+
     @Test
     public void safeExecutorOnExecutor_beforeHoneycomb_runningOnABackgroundThread_shouldThrowIllegalStateException() throws Exception {
+        TestSdkHelper.setReportedSdkLevel(VERSION_CODES.GINGERBREAD_MR1);
         ensureFastFailWhenTaskIsRunOnBackgroundThread();
     }
 
-    @Config(reportSdk = VERSION_CODES.HONEYCOMB)
+
+    @TargetApi(VERSION_CODES.HONEYCOMB)
     @Test
     public void safeExecuteOnExecutor_atLeastHoneycomb_shouldCallExecuteWithParamsWithExecutor() throws Exception {
+        TestSdkHelper.setReportedSdkLevel(VERSION_CODES.HONEYCOMB);
         AsyncTasks.safeExecuteOnExecutor(asyncTask, "goodbye");
 
         verify(asyncTask).executeOnExecutor(any(Executor.class), eq("goodbye"));
     }
 
-    @Config(reportSdk = VERSION_CODES.HONEYCOMB)
+    @TargetApi(VERSION_CODES.HONEYCOMB)
     @Test
     public void safeExecutorOnExecutor_atLeastHoneycomb_withNullParam_shouldCallExecuteWithParamsWithExecutor() throws Exception {
+        TestSdkHelper.setReportedSdkLevel(VERSION_CODES.HONEYCOMB);
         AsyncTasks.safeExecuteOnExecutor(asyncTask, (String) null);
 
         verify(asyncTask).executeOnExecutor(any(Executor.class), eq((String) null));
     }
 
-    @Config(reportSdk = VERSION_CODES.HONEYCOMB)
+
     @Test
     public void safeExecutorOnExecutor_atLeastHoneycomb_withNullAsyncTask_shouldThrowIllegalArgumentException() throws Exception {
+        TestSdkHelper.setReportedSdkLevel(VERSION_CODES.HONEYCOMB);
         try {
             AsyncTasks.safeExecuteOnExecutor(null, "hello");
             fail("Should have thrown NullPointerException");
@@ -97,9 +106,10 @@ public void safeExecutorOnExecutor_atLeastHoneycomb_withNullAsyncTask_shouldThro
         }
     }
 
-    @Config(reportSdk = VERSION_CODES.HONEYCOMB)
+
     @Test
     public void safeExecutorOnExecutor_atLeastHoneycomb_runningOnABackgroundThread_shouldThrowIllegalStateException() throws Exception {
+        TestSdkHelper.setReportedSdkLevel(VERSION_CODES.HONEYCOMB);
         ensureFastFailWhenTaskIsRunOnBackgroundThread();
     }
 
@@ -124,6 +134,6 @@ public void run() {
         }).start();
 
         ThreadUtils.pause(10);
-        Robolectric.runUiThreadTasks();
+        ShadowLooper.runUiThreadTasks();
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/DeviceUtilsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/DeviceUtilsTest.java
index 4a7bf40a..d26247a6 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/util/DeviceUtilsTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/DeviceUtilsTest.java
@@ -8,16 +8,19 @@
 
 import com.mopub.common.CreativeOrientation;
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 import com.mopub.nativeads.test.support.MoPubShadowDisplay;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class DeviceUtilsTest {
 
     private Activity testActivity;
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/DipsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/DipsTest.java
index c0d46973..283038e0 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/util/DipsTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/DipsTest.java
@@ -5,16 +5,19 @@
 import android.util.DisplayMetrics;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
+import org.robolectric.annotation.Config;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class DipsTest {
 
     @Mock private Activity activity;
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/FilesTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/FilesTest.java
index 0b65e22e..cffb7ace 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/util/FilesTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/FilesTest.java
@@ -6,6 +6,7 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
 
 import java.io.File;
@@ -24,7 +25,7 @@
 
     @Before
     public void setup() throws Exception {
-        activity = new Activity();
+        activity = Robolectric.buildActivity(Activity.class).create().get();
 
         expectedDirectoryPath = activity.getFilesDir() + File.separator + "testDirectory";
         expectedFilePath = activity.getFilesDir() + File.separator + "test.txt";
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/IntentsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/IntentsTest.java
index 94aa1180..260747e3 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/util/IntentsTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/IntentsTest.java
@@ -17,6 +17,7 @@
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.shadows.ShadowApplication;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -42,7 +43,7 @@ public void setUp() {
     public void startActivity_withActivityContext_shouldStartActivityWithNoNewFlags() throws IntentNotResolvableException {
         Intents.startActivity(activityContext, new Intent());
 
-        final Intent intent = Robolectric.getShadowApplication().peekNextStartedActivity();
+        final Intent intent = ShadowApplication.getInstance().peekNextStartedActivity();
         assertThat(Utils.bitMaskContainsFlag(intent.getFlags(), FLAG_ACTIVITY_NEW_TASK)).isFalse();
     }
 
@@ -198,7 +199,7 @@ public void launchIntentForUserClick_shouldStartActivity() throws Exception {
         Intent intent = mock(Intent.class);
 
         Intents.launchIntentForUserClick(context, intent, null);
-        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+        final Intent startedActivity = ShadowApplication.getInstance().peekNextStartedActivity();
 
         assertThat(startedActivity).isNotNull();
     }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/JsonTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/JsonTest.java
index 8636e84e..3c4bbd4f 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/util/JsonTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/JsonTest.java
@@ -1,10 +1,12 @@
 package com.mopub.common.util;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
 
 import java.util.HashMap;
 import java.util.Map;
@@ -12,6 +14,7 @@
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class JsonTest {
     private Map<String,String> expectedMap;
 
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/ManifestUtilsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/ManifestUtilsTest.java
index 9bfa41ec..8db4a294 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/util/ManifestUtilsTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/ManifestUtilsTest.java
@@ -9,6 +9,7 @@
 import android.content.pm.ResolveInfo;
 import android.os.Build;
 
+import com.mopub.TestSdkHelper;
 import com.mopub.common.MoPubBrowser;
 import com.mopub.mobileads.MoPubActivity;
 import com.mopub.mobileads.MraidActivity;
@@ -23,7 +24,7 @@
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.shadows.ShadowLog;
 import org.robolectric.shadows.ShadowToast;
 
@@ -93,10 +94,10 @@ public void checkNativeSdkActivitiesDeclared_shouldIncludeOneActivityDeclaration
 
     @Test
     public void displayWarningForMissingActivities_withAllActivitiesDeclared_shouldNotShowLogOrToast() throws Exception {
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidActivity.class), mockResolveInfo);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidVideoPlayerActivity.class), mockResolveInfo);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubBrowser.class), mockResolveInfo);
+        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MraidActivity.class), mockResolveInfo);
+        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MraidVideoPlayerActivity.class), mockResolveInfo);
+        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MoPubBrowser.class), mockResolveInfo);
 
         ShadowLog.setupLogging();
         setDebugMode(true);
@@ -109,9 +110,9 @@ public void displayWarningForMissingActivities_withAllActivitiesDeclared_shouldN
 
     @Test
      public void displayWarningForMissingActivities_withOneMissingActivity_shouldLogOnlyThatOne() throws Exception {
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidActivity.class), mockResolveInfo);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidVideoPlayerActivity.class), mockResolveInfo);
+        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MraidActivity.class), mockResolveInfo);
+        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MraidVideoPlayerActivity.class), mockResolveInfo);
         // Here, we leave out MoPubBrowser on purpose
 
         ShadowLog.setupLogging();
@@ -173,10 +174,10 @@ public void displayWarningForMisconfiguredActivities_withAllActivitiesConfigured
         when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(true);
         ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
 
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidActivity.class), mockResolveInfo);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidVideoPlayerActivity.class), mockResolveInfo);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubBrowser.class), mockResolveInfo);
+        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MraidActivity.class), mockResolveInfo);
+        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MraidVideoPlayerActivity.class), mockResolveInfo);
+        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MoPubBrowser.class), mockResolveInfo);
 
         ShadowLog.setupLogging();
         setDebugMode(true);
@@ -206,10 +207,10 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
         when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(true);
         ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
 
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidActivity.class), mockResolveInfo);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidVideoPlayerActivity.class), mockResolveInfo);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubBrowser.class), mockResolveInfo);
+        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MraidActivity.class), mockResolveInfo);
+        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MraidVideoPlayerActivity.class), mockResolveInfo);
+        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MoPubBrowser.class), mockResolveInfo);
 
         ShadowLog.setupLogging();
 
@@ -237,7 +238,7 @@ public void displayWarningForMisconfiguredActivities_withOneMisconfiguredActivit
         when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(false);
         ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
 
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
 
         ShadowLog.setupLogging();
 
@@ -249,17 +250,18 @@ public void displayWarningForMisconfiguredActivities_withOneMisconfiguredActivit
     }
 
     @SuppressWarnings("unchecked")
-    @Config(reportSdk = Build.VERSION_CODES.HONEYCOMB_MR1)
+
     @TargetApi(13)
     @Test
     public void displayWarningForMisconfiguredActivities_withMissingScreenSize_withApiLessThan13_shouldNotLogOrShowToast() throws Exception {
+        TestSdkHelper.setReportedSdkLevel(Build.VERSION_CODES.HONEYCOMB);
         ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
         when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN))).thenReturn(true);
         when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(true);
         when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(false);
         ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
 
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
 
         ShadowLog.setupLogging();
         setDebugMode(true);
@@ -285,7 +287,7 @@ public void displayWarningForMisconfiguredActivities_withMissingScreenSize_withT
         when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(false);
         ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
 
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
 
         ShadowLog.setupLogging();
         setDebugMode(true);
@@ -306,7 +308,7 @@ public void displayWarningForMisconfiguredActivities_withMisconfiguredActivities
         when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(false);
         ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
 
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
 
         setDebugMode(true);
 
@@ -327,7 +329,7 @@ public void displayWarningForMisconfiguredActivities_withMisconfiguredActivities
         when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(false);
         ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
 
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
 
         setDebugMode(false);
 
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/UtilsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/UtilsTest.java
index 384e40b8..0bb01118 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/util/UtilsTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/UtilsTest.java
@@ -1,9 +1,11 @@
 package com.mopub.common.util;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
 
 import java.util.HashSet;
 import java.util.Set;
@@ -11,6 +13,7 @@
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class UtilsTest {
     @Test
     public void generateUniqueId_withMultipleInvocations_shouldReturnUniqueValues() throws Exception {
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/VersionCodeTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/VersionCodeTest.java
index c42a0681..2dcaa3fd 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/util/VersionCodeTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/VersionCodeTest.java
@@ -4,8 +4,8 @@
 
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.util.ReflectionHelpers;
 
 import static com.mopub.common.util.VersionCode.BASE;
 import static com.mopub.common.util.VersionCode.CUR_DEVELOPMENT;
@@ -19,19 +19,19 @@
 public class VersionCodeTest {
     @Test
     public void currentApiLevel_shouldReflectActualApiLevel() throws Exception {
-        Robolectric.Reflection.setFinalStaticField(Build.VERSION.class, "SDK_INT", 4);
+        ReflectionHelpers.setStaticField(Build.VERSION.class, "SDK_INT", 4);
         assertThat(VersionCode.currentApiLevel()).isEqualTo(DONUT);
 
-        Robolectric.Reflection.setFinalStaticField(Build.VERSION.class, "SDK_INT", 8);
+        ReflectionHelpers.setStaticField(Build.VERSION.class, "SDK_INT", 8);
         assertThat(VersionCode.currentApiLevel()).isEqualTo(FROYO);
 
-        Robolectric.Reflection.setFinalStaticField(Build.VERSION.class, "SDK_INT", 14);
+        ReflectionHelpers.setStaticField(Build.VERSION.class, "SDK_INT", 14);
         assertThat(VersionCode.currentApiLevel()).isEqualTo(ICE_CREAM_SANDWICH);
     }
 
     @Test
     public void currentApiLevel_whenUnknownApiLevel_shouldReturnCurDevelopment() throws Exception {
-        Robolectric.Reflection.setFinalStaticField(Build.VERSION.class, "SDK_INT", 900);
+        ReflectionHelpers.setStaticField(Build.VERSION.class, "SDK_INT", 900);
         assertThat(VersionCode.currentApiLevel()).isEqualTo(CUR_DEVELOPMENT);
     }
 
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/VisibilityTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/VisibilityTest.java
index 0aa6f25d..81810ae6 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/util/VisibilityTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/VisibilityTest.java
@@ -3,13 +3,16 @@
 import android.view.View;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class VisibilityTest {
     @Test
     public void isScreenVisible_shouldOnlyReturnTrueForViewVisible() throws Exception {
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertGestureListenerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertGestureListenerTest.java
index 09ae4f1d..cd34ddc2 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertGestureListenerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertGestureListenerTest.java
@@ -12,6 +12,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
+import org.robolectric.annotation.Config;
 
 import static com.mopub.mobileads.AdAlertGestureListener.ZigZagState.FAILED;
 import static com.mopub.mobileads.AdAlertGestureListener.ZigZagState.FINISHED;
@@ -22,6 +23,7 @@
 import static org.mockito.Mockito.stub;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class AdAlertGestureListenerTest {
     @Mock
     private View mockView;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertReporterTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertReporterTest.java
index d199d9f8..da4c0bb0 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertReporterTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertReporterTest.java
@@ -18,6 +18,8 @@
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowApplication;
 
 import java.io.File;
 import java.io.FileOutputStream;
@@ -35,6 +37,7 @@
 import static org.mockito.Mockito.verify;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class AdAlertReporterTest {
     private final static String EMAIL_ADDRESS = "creative-review@mopub.com";
     private AdAlertReporter subject;
@@ -193,7 +196,7 @@ public void send_shouldCreateEmailChooserIntent() throws Exception {
         subject = new AdAlertReporter(Robolectric.buildActivity(Activity.class).create().get(), mockView, mockAdReport);
         subject.send();
 
-        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent intent = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(intent.getAction()).isEqualTo(Intent.ACTION_CHOOSER);
         assertThat(intent.getStringExtra(Intent.EXTRA_TITLE)).isEqualTo("Send Email...");
         assertThat(intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdLoaderTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdLoaderTest.java
index 8f8639da..dbf9250f 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/AdLoaderTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/AdLoaderTest.java
@@ -8,6 +8,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
+import org.robolectric.annotation.Config;
 
 import java.util.HashMap;
 import java.util.Map;
@@ -21,6 +22,7 @@
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class AdLoaderTest {
 
     @Mock
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdRequestStatusMappingTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdRequestStatusMappingTest.java
index b82dcbe8..bc66ea83 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/AdRequestStatusMappingTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/AdRequestStatusMappingTest.java
@@ -5,10 +5,12 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class AdRequestStatusMappingTest {
     private AdRequestStatusMapping subject;
     private String key1;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdTypeTranslatorTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdTypeTranslatorTest.java
index 2d782a64..5123a7f2 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/AdTypeTranslatorTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/AdTypeTranslatorTest.java
@@ -12,6 +12,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
 
 import java.util.HashMap;
 
@@ -20,6 +21,7 @@
 import static org.mockito.Mockito.stub;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class AdTypeTranslatorTest {
     private String customEventName;
     private MoPubView moPubView;
@@ -118,7 +120,7 @@ public void getCustomEventName_whenNameNotInHeaders_shouldBeNull() {
 
     @Test
     public void getCustomEventName_withNativeFormat_shouldBeMoPubNative() {
-        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.NATIVE, AdType.NATIVE, null, headers);
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.NATIVE, AdType.STATIC_NATIVE, null, headers);
 
         assertThat(customEventName).isEqualTo("com.mopub.nativeads.MoPubCustomEventNative");
     }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdViewControllerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdViewControllerTest.java
index aad6cc28..02afa4e4 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/AdViewControllerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/AdViewControllerTest.java
@@ -30,6 +30,10 @@
 import org.mockito.ArgumentCaptor;
 import org.mockito.Mock;
 import org.robolectric.Robolectric;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.Shadows;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLooper;
 
 import java.util.Collections;
 
@@ -46,9 +50,10 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyZeroInteractions;
 import static org.mockito.Mockito.when;
-import static org.robolectric.Robolectric.shadowOf;
+
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class AdViewControllerTest {
 
     private static final int[] HTML_ERROR_CODES = new int[]{400, 401, 402, 403, 404, 405, 407, 408,
@@ -67,7 +72,7 @@
     @Before
     public void setup() {
         activity = Robolectric.buildActivity(Activity.class).create().get();
-        shadowOf(activity).grantPermissions(android.Manifest.permission.ACCESS_NETWORK_STATE);
+        Shadows.shadowOf(activity).grantPermissions(android.Manifest.permission.ACCESS_NETWORK_STATE);
 
         when(mockMoPubView.getAdFormat()).thenReturn(AdFormat.BANNER);
         when(mockMoPubView.getContext()).thenReturn(activity);
@@ -106,25 +111,25 @@ public void cleanup_shouldNotHoldViewOrUrlGenerator() {
 
     @Test
     public void adDidFail_shouldScheduleRefreshTimer_shouldCallMoPubViewAdFailed() throws Exception {
-        Robolectric.pauseMainLooper();
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+        ShadowLooper.pauseMainLooper();
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(0);
 
         subject.adDidFail(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
 
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(1);
         verify(mockMoPubView).adFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
     }
 
     @Test
     public void adDidFail_withNullMoPubView_shouldNotScheduleRefreshTimer_shouldNotCallMoPubViewAdFailed() throws Exception {
-        Robolectric.pauseMainLooper();
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+        ShadowLooper.pauseMainLooper();
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(0);
 
         // This sets the MoPubView to null
         subject.cleanup();
         subject.adDidFail(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
 
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(0);
         verify(mockMoPubView, never()).adFailed(any(MoPubErrorCode.class));
     }
 
@@ -133,40 +138,40 @@ public void adDidFail_withNullMoPubView_shouldNotScheduleRefreshTimer_shouldNotC
     public void scheduleRefreshTimer_shouldNotScheduleIfRefreshTimeIsNull() throws Exception {
         response = response.toBuilder().setRefreshTimeMilliseconds(null).build();
         subject.onAdLoadSuccess(response);
-        Robolectric.pauseMainLooper();
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+        ShadowLooper.pauseMainLooper();
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(0);
 
         subject.scheduleRefreshTimerIfEnabled();
 
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(0);
     }
 
     @Test
     public void scheduleRefreshTimer_shouldNotScheduleIfRefreshTimeIsZero() {
         response = response.toBuilder().setRefreshTimeMilliseconds(0).build();
         subject.onAdLoadSuccess(response);
-        Robolectric.pauseMainLooper();
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+        ShadowLooper.pauseMainLooper();
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(0);
 
         subject.scheduleRefreshTimerIfEnabled();
 
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(0);
     }
 
     @Test
     public void scheduleRefreshTimerIfEnabled_shouldCancelOldRefreshAndScheduleANewOne() throws Exception {
         response = response.toBuilder().setRefreshTimeMilliseconds(30).build();
         subject.onAdLoadSuccess(response);
-        Robolectric.pauseMainLooper();
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+        ShadowLooper.pauseMainLooper();
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(1);
 
         subject.scheduleRefreshTimerIfEnabled();
 
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(1);
 
         subject.scheduleRefreshTimerIfEnabled();
 
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(1);
     }
 
     @Test
@@ -174,29 +179,29 @@ public void scheduleRefreshTimer_shouldNotScheduleRefreshIfAutorefreshIsOff() th
         response = response.toBuilder().setRefreshTimeMilliseconds(30).build();
         subject.onAdLoadSuccess(response);
 
-        Robolectric.pauseMainLooper();
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+        ShadowLooper.pauseMainLooper();
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(1);
 
         subject.forceSetAutorefreshEnabled(false);
 
         subject.scheduleRefreshTimerIfEnabled();
 
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(0);
     }
 
     @Test
     public void scheduleRefreshTimer_whenAdViewControllerNotConfiguredByResponse_shouldHaveDefaultRefreshTime() throws Exception {
-        Robolectric.pauseMainLooper();
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+        ShadowLooper.pauseMainLooper();
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(0);
 
         subject.scheduleRefreshTimerIfEnabled();
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(1);
 
-        Robolectric.idleMainLooper(AdViewController.DEFAULT_REFRESH_TIME_MILLISECONDS - 1);
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+        ShadowLooper.idleMainLooper(AdViewController.DEFAULT_REFRESH_TIME_MILLISECONDS - 1);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(1);
 
-        Robolectric.idleMainLooper(1);
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+        ShadowLooper.idleMainLooper(1);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(0);
     }
 
     @Test
@@ -260,14 +265,14 @@ public void enablingAutoRefresh_withoutCallingLoadAd_shouldNotScheduleNewRefresh
     public void disablingAutoRefresh_shouldCancelRefreshTimers() throws Exception {
         response = response.toBuilder().setRefreshTimeMilliseconds(30).build();
         subject.onAdLoadSuccess(response);
-        Robolectric.pauseMainLooper();
+        ShadowLooper.pauseMainLooper();
 
         subject.loadAd();
         subject.forceSetAutorefreshEnabled(true);
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(1);
 
         subject.forceSetAutorefreshEnabled(false);
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(0);
     }
 
     @Test
@@ -308,8 +313,8 @@ public void fetchAd_withNullMoPubView_shouldNotMakeRequest() throws Exception {
 
     @Test
     public void loadAd_shouldNotLoadWithoutConnectivity() throws Exception {
-        ConnectivityManager connectivityManager = (ConnectivityManager) Robolectric.application.getSystemService(Context.CONNECTIVITY_SERVICE);
-        shadowOf(connectivityManager.getActiveNetworkInfo()).setConnectionStatus(false);
+        ConnectivityManager connectivityManager = (ConnectivityManager) RuntimeEnvironment.application.getSystemService(Context.CONNECTIVITY_SERVICE);
+        Shadows.shadowOf(connectivityManager.getActiveNetworkInfo()).setConnectionStatus(false);
 
         subject.loadAd();
         verifyZeroInteractions(mockRequestQueue);
@@ -394,7 +399,7 @@ public void run() {
             }
         }).start();
         ThreadUtils.pause(100);
-        Robolectric.runUiThreadTasks();
+        ShadowLooper.runUiThreadTasks();
 
         verify(mockMoPubView).removeAllViews();
         ArgumentCaptor<FrameLayout.LayoutParams> layoutParamsCaptor = ArgumentCaptor.forClass(FrameLayout.LayoutParams.class);
@@ -420,7 +425,7 @@ public void run() {
             }
         }).start();
         ThreadUtils.pause(10);
-        Robolectric.runUiThreadTasks();
+        ShadowLooper.runUiThreadTasks();
 
         verify(mockMoPubView, never()).removeAllViews();
         verify(mockMoPubView, never()).addView(any(View.class), any(FrameLayout.LayoutParams.class));
@@ -582,7 +587,7 @@ public void getErrorCodeFromVolleyError_whenNoConnection_shouldReturnErrorCodeNo
     public void getErrorCodeFromVolleyError_withNullResponse_whenConnectionValid_shouldReturnErrorCodeUnspecified() {
         final VolleyError noConnectionError = new NoConnectionError();
 
-        shadowOf(activity).grantPermissions(Manifest.permission.INTERNET);
+        Shadows.shadowOf(activity).grantPermissions(Manifest.permission.INTERNET);
         final MoPubErrorCode errorCode = AdViewController.getErrorCodeFromVolleyError(
                 noConnectionError, activity);
 
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseHtmlWebViewTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseHtmlWebViewTest.java
index 18e64903..d1d56c5c 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseHtmlWebViewTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseHtmlWebViewTest.java
@@ -6,6 +6,7 @@
 import android.view.View;
 import android.view.ViewGroup;
 
+import com.mopub.TestSdkHelper;
 import com.mopub.common.AdReport;
 import com.mopub.common.test.support.SdkTestRunner;
 
@@ -14,6 +15,7 @@
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.robolectric.Robolectric;
+import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowWebView;
 
@@ -22,9 +24,9 @@
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
-import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class BaseHtmlWebViewTest {
 
     @Mock
@@ -32,29 +34,30 @@
     private BaseHtmlWebView subject;
     private MotionEvent touchDown;
     private MotionEvent touchUp;
+    private Activity testActivity;
 
     @Before
     public void setUp() throws Exception {
-        subject = new BaseHtmlWebView(Robolectric.buildActivity(Activity.class).create().get(), mockAdReport);
+        testActivity = Robolectric.buildActivity(Activity.class).create().get();
+        subject = new BaseHtmlWebView(testActivity, mockAdReport);
 
         touchDown = createMotionEvent(MotionEvent.ACTION_DOWN);
         touchUp = createMotionEvent(MotionEvent.ACTION_UP);
     }
 
-    @Config(reportSdk = VERSION_CODES.JELLY_BEAN_MR2)
+    @Config(sdk = VERSION_CODES.JELLY_BEAN_MR2)
     @Test
     public void pluginState_atLeastJellybeanMr2_shouldDefaultToOff_shouldNeverBeEnabled()  {
-        subject = new BaseHtmlWebView(Robolectric.buildActivity(Activity.class).create().get(), mockAdReport);
         assertThat(subject.getSettings().getPluginState()).isEqualTo(PluginState.OFF);
 
         subject.enablePlugins(true);
         assertThat(subject.getSettings().getPluginState()).isEqualTo(PluginState.OFF);
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void pluginState_atLeastIcsButBelowJellybeanMr2_shouldDefaultToOn_shouldAllowToggling() {
-        subject = new BaseHtmlWebView(Robolectric.buildActivity(Activity.class).create().get(), mockAdReport);
+        TestSdkHelper.setReportedSdkLevel(VERSION_CODES.ICE_CREAM_SANDWICH);
+        subject = new BaseHtmlWebView(testActivity, mockAdReport);
         assertThat(subject.getSettings().getPluginState()).isEqualTo(PluginState.ON);
 
         subject.enablePlugins(false);
@@ -64,10 +67,11 @@ public void pluginState_atLeastIcsButBelowJellybeanMr2_shouldDefaultToOn_shouldA
         assertThat(subject.getSettings().getPluginState()).isEqualTo(PluginState.ON);
     }
 
-    @Config(reportSdk = VERSION_CODES.GINGERBREAD_MR1)
     @Test
     public void pluginState_beforeIcs_shouldDefaultToOff_shouldAllowToggling() {
-        subject = new BaseHtmlWebView(Robolectric.buildActivity(Activity.class).create().get(), mockAdReport);
+        TestSdkHelper.setReportedSdkLevel(VERSION_CODES.GINGERBREAD_MR1);
+
+        subject = new BaseHtmlWebView(testActivity, mockAdReport);
         assertThat(subject.getSettings().getPluginState()).isEqualTo(PluginState.OFF);
 
         subject.enablePlugins(true);
@@ -80,10 +84,10 @@ public void pluginState_beforeIcs_shouldDefaultToOff_shouldAllowToggling() {
     @Test
     public void init_shouldSetWebViewScrollability() throws Exception {
         subject.init(false);
-        assertThat(shadowOf(subject).getOnTouchListener()).isNotNull();
+        assertThat(Shadows.shadowOf(subject).getOnTouchListener()).isNotNull();
 
         subject.init(true);
-        assertThat(shadowOf(subject).getOnTouchListener()).isNotNull();
+        assertThat(Shadows.shadowOf(subject).getOnTouchListener()).isNotNull();
     }
 
     @Test
@@ -97,7 +101,7 @@ public void loadUrl_whenUrlIsJavascript_shouldCallSuperLoadUrl() throws Exceptio
         String javascriptUrl = "javascript:function() {alert(\"guy\")};";
         subject.loadUrl(javascriptUrl);
 
-        assertThat(shadowOf(subject).getLastLoadedUrl()).isEqualTo(javascriptUrl);
+        assertThat(Shadows.shadowOf(subject).getLastLoadedUrl()).isEqualTo(javascriptUrl);
     }
 
     @Test
@@ -105,7 +109,7 @@ public void loadHtmlResponse_shouldCallLoadDataWithBaseURL() throws Exception {
         String htmlResponse = "some random html response";
         subject.loadHtmlResponse(htmlResponse);
 
-        ShadowWebView.LoadDataWithBaseURL lastLoadData = shadowOf(subject).getLastLoadDataWithBaseURL();
+        ShadowWebView.LoadDataWithBaseURL lastLoadData = Shadows.shadowOf(subject).getLastLoadDataWithBaseURL();
         assertThat(lastLoadData.baseUrl).isEqualTo("http://ads.mopub.com/");
         assertThat(lastLoadData.data).isEqualTo(htmlResponse);
         assertThat(lastLoadData.mimeType).isEqualTo("text/html");
@@ -118,7 +122,7 @@ public void sendTouchEvent_withScrollingDisabled_shouldSetUserClicked() throws E
         assertThat(subject.wasClicked()).isFalse();
 
         subject.initializeOnTouchListener(false);
-        View.OnTouchListener onTouchListener = shadowOf(subject).getOnTouchListener();
+        View.OnTouchListener onTouchListener = Shadows.shadowOf(subject).getOnTouchListener();
 
         onTouchListener.onTouch(subject, touchUp);
         assertThat(subject.wasClicked()).isTrue();
@@ -129,7 +133,7 @@ public void sendTouchEvent_withScrollingEnabled_shouldSetUserClicked() throws Ex
         assertThat(subject.wasClicked()).isFalse();
 
         subject.initializeOnTouchListener(true);
-        View.OnTouchListener onTouchListener = shadowOf(subject).getOnTouchListener();
+        View.OnTouchListener onTouchListener = Shadows.shadowOf(subject).getOnTouchListener();
 
         onTouchListener.onTouch(subject, touchUp);
         assertThat(subject.wasClicked()).isTrue();
@@ -138,7 +142,7 @@ public void sendTouchEvent_withScrollingEnabled_shouldSetUserClicked() throws Ex
     @Test
     public void sendTouchEvent_withScrollingDisabled_withLotsOfRandomMotionEvents_shouldEventuallySetUserClicked() throws Exception {
         subject.initializeOnTouchListener(false);
-        View.OnTouchListener onTouchListener = shadowOf(subject).getOnTouchListener();
+        View.OnTouchListener onTouchListener = Shadows.shadowOf(subject).getOnTouchListener();
 
         onTouchListener.onTouch(subject, touchDown);
         assertThat(subject.wasClicked()).isFalse();
@@ -161,7 +165,7 @@ public void sendTouchEvent_withScrollingDisabled_withLotsOfRandomMotionEvents_sh
     @Test
     public void sendTouchEvent_withScrollingEnabled_withLotsOfRandomMotionEvents_shouldEventuallySetUserClicked() throws Exception {
         subject.initializeOnTouchListener(true);
-        View.OnTouchListener onTouchListener = shadowOf(subject).getOnTouchListener();
+        View.OnTouchListener onTouchListener = Shadows.shadowOf(subject).getOnTouchListener();
 
         onTouchListener.onTouch(subject, touchDown);
         assertThat(subject.wasClicked()).isFalse();
@@ -184,7 +188,7 @@ public void sendTouchEvent_withScrollingEnabled_withLotsOfRandomMotionEvents_sho
     @Test
     public void onResetClicked_shouldonResetClicked() throws Exception {
         subject.initializeOnTouchListener(false);
-        View.OnTouchListener onTouchListener = shadowOf(subject).getOnTouchListener();
+        View.OnTouchListener onTouchListener = Shadows.shadowOf(subject).getOnTouchListener();
 
         onTouchListener.onTouch(subject, touchDown);
         onTouchListener.onTouch(subject, touchUp);
@@ -207,7 +211,7 @@ public void onResetClicked_whenTouchStateIsUnset_shouldKeepTouchStateUnset() thr
     public void setWebViewScrollingEnabled_whenScrollableIsTrue_onTouchListenerShouldAlwaysReturnFalse() throws Exception {
         subject.initializeOnTouchListener(true);
 
-        View.OnTouchListener onTouchListener = shadowOf(subject).getOnTouchListener();
+        View.OnTouchListener onTouchListener = Shadows.shadowOf(subject).getOnTouchListener();
         // ACTION_DOWN is guaranteed to be run before ACTION_MOVE
         onTouchListener.onTouch(subject, createMotionEvent(MotionEvent.ACTION_DOWN));
         boolean shouldConsumeTouch = onTouchListener.onTouch(subject, createMotionEvent(MotionEvent.ACTION_MOVE));
@@ -219,7 +223,7 @@ public void setWebViewScrollingEnabled_whenScrollableIsTrue_onTouchListenerShoul
     public void setWebViewScrollingEnabled_whenScrollableIsFalse_whenActionMove_onTouchListenerShouldReturnTrue() throws Exception {
         subject.initializeOnTouchListener(false);
 
-        View.OnTouchListener onTouchListener = shadowOf(subject).getOnTouchListener();
+        View.OnTouchListener onTouchListener = Shadows.shadowOf(subject).getOnTouchListener();
         boolean shouldConsumeTouch = onTouchListener.onTouch(subject, createMotionEvent(MotionEvent.ACTION_MOVE));
 
         assertThat(shouldConsumeTouch).isTrue();
@@ -229,7 +233,7 @@ public void setWebViewScrollingEnabled_whenScrollableIsFalse_whenActionMove_onTo
     public void setWebViewScrollingEnabled_whenScrollableIsFalse_whenMotionEventIsNotActionMove_onTouchListenerShouldReturnFalse() throws Exception {
         subject.initializeOnTouchListener(false);
 
-        View.OnTouchListener onTouchListener = shadowOf(subject).getOnTouchListener();
+        View.OnTouchListener onTouchListener = Shadows.shadowOf(subject).getOnTouchListener();
 
         boolean shouldConsumeTouch = onTouchListener.onTouch(subject, touchUp);
         assertThat(shouldConsumeTouch).isFalse();
@@ -244,7 +248,7 @@ public void setWebViewScrollingEnabled_whenScrollableIsFalse_whenMotionEventIsNo
     @Test
     public void destroy_shouldRemoveSelfFromParent() throws Exception {
         ViewGroup parentView = mock(ViewGroup.class);
-        ShadowWebView shadow = shadowOf(subject);
+        ShadowWebView shadow = Shadows.shadowOf(subject);
         shadow.setMyParent(parentView);
 
         subject.destroy();
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseInterstitialActivityTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseInterstitialActivityTest.java
index f5eefa09..4dc63c99 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseInterstitialActivityTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseInterstitialActivityTest.java
@@ -13,11 +13,13 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
 
 import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class BaseInterstitialActivityTest {
     private BaseInterstitialActivity subject;
     private long broadcastIdentifier;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseVideoPlayerActivityTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseVideoPlayerActivityTest.java
index 0691d5e0..7c420081 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseVideoPlayerActivityTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseVideoPlayerActivityTest.java
@@ -12,6 +12,8 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowApplication;
 
 import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
 import static com.mopub.mobileads.BaseVideoPlayerActivity.VIDEO_URL;
@@ -26,6 +28,7 @@
 import static org.mockito.Mockito.withSettings;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class BaseVideoPlayerActivityTest {
     private static final String MRAID_VIDEO_URL = "http://mraidVideo";
 
@@ -68,7 +71,7 @@ public void onDestroy_shouldReleaseAudioFocus() throws Exception {
     static void assertVastVideoPlayerActivityStarted(final Class clazz,
             final VastVideoConfig vastVideoConfig,
             final long broadcastIdentifier) {
-        final Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        final Intent intent = ShadowApplication.getInstance().getNextStartedActivity();
         assertIntentAndBroadcastIdentifierAreCorrect(intent, clazz, broadcastIdentifier);
 
         final VastVideoConfig expectedVastVideoConfig =
@@ -77,7 +80,7 @@ static void assertVastVideoPlayerActivityStarted(final Class clazz,
     }
 
     public static void assertMraidVideoPlayerActivityStarted(final Class clazz, final String url) {
-        final Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        final Intent intent = ShadowApplication.getInstance().getNextStartedActivity();
         assertIntentAndBroadcastIdentifierAreCorrect(intent, clazz, null);
 
         assertThat(intent.getStringExtra(VIDEO_URL)).isEqualTo(url);
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseWebViewTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseWebViewTest.java
index d9415f2d..c63b638d 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseWebViewTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseWebViewTest.java
@@ -12,6 +12,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowWebView;
 
@@ -19,9 +20,9 @@
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
-import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class BaseWebViewTest {
     private Activity context;
     private BaseWebView subject;
@@ -31,7 +32,7 @@ public void setup() {
         context = Robolectric.buildActivity(Activity.class).create().get();
     }
 
-    @Config(reportSdk = VERSION_CODES.JELLY_BEAN_MR1)
+    @Config(sdk = VERSION_CODES.JELLY_BEAN_MR1)
     @Test
     public void beforeJellyBeanMr1_shouldDisablePluginsByDefault() throws Exception {
         subject = new BaseWebView(context);
@@ -43,7 +44,7 @@ public void beforeJellyBeanMr1_shouldDisablePluginsByDefault() throws Exception
         assertThat(webSettings.getPluginState()).isEqualTo(WebSettings.PluginState.ON);
     }
 
-    @Config(reportSdk = VERSION_CODES.JELLY_BEAN_MR2)
+    @Config(sdk = VERSION_CODES.JELLY_BEAN_MR2)
     @Test
     public void atLeastJellybeanMr2_shouldPass() throws Exception {
         subject = new BaseWebView(context);
@@ -57,7 +58,7 @@ public void atLeastJellybeanMr2_shouldPass() throws Exception {
     public void destroy_shouldRemoveSelfFromParent_beforeCallingDestroy() throws Exception {
         subject = new BaseWebView(context);
         ViewGroup parent = mock(ViewGroup.class);
-        ShadowWebView shadow = shadowOf(subject);
+        ShadowWebView shadow = Shadows.shadowOf(subject);
         shadow.setMyParent(parent);
 
         subject.destroy();
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventAdLoaderTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventAdLoaderTest.java
index c3dbf03d..072156bd 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventAdLoaderTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventAdLoaderTest.java
@@ -5,6 +5,7 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
 
 import java.util.HashMap;
 import java.util.Map;
@@ -16,6 +17,7 @@
 import static org.mockito.Mockito.verify;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class CustomEventAdLoaderTest {
 
     private AdViewController adViewController;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventBannerAdapterTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventBannerAdapterTest.java
index ed91f90b..a08a9163 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventBannerAdapterTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventBannerAdapterTest.java
@@ -17,6 +17,8 @@
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLooper;
 
 import java.util.HashMap;
 import java.util.Map;
@@ -36,6 +38,7 @@
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class CustomEventBannerAdapterTest {
     private CustomEventBannerAdapter subject;
     @Mock
@@ -86,11 +89,11 @@ public void constructor_shouldPopulateLocalExtrasWithAdWidthAndHeight() throws E
     public void timeout_shouldSignalFailureAndInvalidateWithDefaultDelay() throws Exception {
         subject.loadAd();
 
-        Robolectric.idleMainLooper(CustomEventBannerAdapter.DEFAULT_BANNER_TIMEOUT_DELAY - 1);
+        ShadowLooper.idleMainLooper(CustomEventBannerAdapter.DEFAULT_BANNER_TIMEOUT_DELAY - 1);
         verify(moPubView, never()).loadFailUrl(eq(NETWORK_TIMEOUT));
         assertThat(subject.isInvalidated()).isFalse();
 
-        Robolectric.idleMainLooper(1);
+        ShadowLooper.idleMainLooper(1);
         verify(moPubView).loadFailUrl(eq(NETWORK_TIMEOUT));
         assertThat(subject.isInvalidated()).isTrue();
     }
@@ -101,11 +104,11 @@ public void timeout_withNegativeAdTimeoutDelay_shouldSignalFailureAndInvalidateW
 
         subject.loadAd();
 
-        Robolectric.idleMainLooper(CustomEventBannerAdapter.DEFAULT_BANNER_TIMEOUT_DELAY - 1);
+        ShadowLooper.idleMainLooper(CustomEventBannerAdapter.DEFAULT_BANNER_TIMEOUT_DELAY - 1);
         verify(moPubView, never()).loadFailUrl(eq(NETWORK_TIMEOUT));
         assertThat(subject.isInvalidated()).isFalse();
 
-        Robolectric.idleMainLooper(1);
+        ShadowLooper.idleMainLooper(1);
         verify(moPubView).loadFailUrl(eq(NETWORK_TIMEOUT));
         assertThat(subject.isInvalidated()).isTrue();
     }
@@ -116,11 +119,11 @@ public void timeout_withNonNullAdTimeoutDelay_shouldSignalFailureAndInvalidateWi
 
         subject.loadAd();
 
-        Robolectric.idleMainLooper(77000 - 1);
+        ShadowLooper.idleMainLooper(77000 - 1);
         verify(moPubView, never()).loadFailUrl(eq(NETWORK_TIMEOUT));
         assertThat(subject.isInvalidated()).isFalse();
 
-        Robolectric.idleMainLooper(1);
+        ShadowLooper.idleMainLooper(1);
         verify(moPubView).loadFailUrl(eq(NETWORK_TIMEOUT));
         assertThat(subject.isInvalidated()).isTrue();
     }
@@ -163,33 +166,33 @@ public void loadAd_shouldPropagateServerExtrasToLoadBanner() throws Exception {
 
     @Test
     public void loadAd_shouldScheduleTimeout_bannerLoadedAndFailed_shouldCancelTimeout() throws Exception {
-        Robolectric.pauseMainLooper();
+        ShadowLooper.pauseMainLooper();
 
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(0);
 
         subject.loadAd();
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(1);
 
         subject.onBannerLoaded(null);
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(0);
 
         subject.loadAd();
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(1);
 
         subject.onBannerFailed(null);
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(0);
     }
 
     @Test
     public void loadAd_shouldScheduleTimeoutRunnableBeforeCallingLoadBanner() throws Exception {
-        Robolectric.pauseMainLooper();
+        ShadowLooper.pauseMainLooper();
 
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(0);
 
         Answer assertTimeoutRunnableHasStarted = new Answer() {
             @Override
             public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+                assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(1);
                 return null;
             }
         };
@@ -209,14 +212,14 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
 
     @Test
     public void loadAd_whenCallingOnBannerFailed_shouldCancelExistingTimeoutRunnable() throws Exception {
-        Robolectric.pauseMainLooper();
+        ShadowLooper.pauseMainLooper();
 
         Answer justCallOnBannerFailed = new Answer() {
             @Override
             public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+                assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(1);
                 subject.onBannerFailed(null);
-                assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+                assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(0);
                 return null;
             }
         };
@@ -230,9 +233,9 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
                         any(Map.class)
                 );
 
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(0);
         subject.loadAd();
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(0);
     }
 
     @Test
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventInterstitialAdapterTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventInterstitialAdapterTest.java
index 3649c405..fcbf5a2e 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventInterstitialAdapterTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventInterstitialAdapterTest.java
@@ -15,6 +15,8 @@
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLooper;
 
 import java.util.HashMap;
 import java.util.Map;
@@ -35,6 +37,7 @@
 import static org.mockito.Mockito.verify;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class CustomEventInterstitialAdapterTest {
     private static long BROADCAST_IDENTIFER = 123;
     private CustomEventInterstitialAdapter subject;
@@ -87,11 +90,11 @@ public void constructor_withInvalidClassName_shouldCallOnCustomEventInterstitial
     @Test
     public void timeout_shouldSignalFailureAndInvalidateWithDefaultDelay() throws Exception {
         subject.loadInterstitial();
-        Robolectric.idleMainLooper(CustomEventInterstitialAdapter.DEFAULT_INTERSTITIAL_TIMEOUT_DELAY - 1);
+        ShadowLooper.idleMainLooper(CustomEventInterstitialAdapter.DEFAULT_INTERSTITIAL_TIMEOUT_DELAY - 1);
         verify(interstitialAdapterListener, never()).onCustomEventInterstitialFailed(eq(NETWORK_TIMEOUT));
         assertThat(subject.isInvalidated()).isFalse();
 
-        Robolectric.idleMainLooper(1);
+        ShadowLooper.idleMainLooper(1);
         verify(interstitialAdapterListener).onCustomEventInterstitialFailed(eq(NETWORK_TIMEOUT));
         assertThat(subject.isInvalidated()).isTrue();
     }
@@ -101,11 +104,11 @@ public void timeout_withNegativeAdTimeoutDelay_shouldSignalFailureAndInvalidateW
         stub(mockMoPubInterstitial.getAdTimeoutDelay()).toReturn(-1);
 
         subject.loadInterstitial();
-        Robolectric.idleMainLooper(CustomEventInterstitialAdapter.DEFAULT_INTERSTITIAL_TIMEOUT_DELAY - 1);
+        ShadowLooper.idleMainLooper(CustomEventInterstitialAdapter.DEFAULT_INTERSTITIAL_TIMEOUT_DELAY - 1);
         verify(interstitialAdapterListener, never()).onCustomEventInterstitialFailed(eq(NETWORK_TIMEOUT));
         assertThat(subject.isInvalidated()).isFalse();
 
-        Robolectric.idleMainLooper(1);
+        ShadowLooper.idleMainLooper(1);
         verify(interstitialAdapterListener).onCustomEventInterstitialFailed(eq(NETWORK_TIMEOUT));
         assertThat(subject.isInvalidated()).isTrue();
     }
@@ -115,11 +118,11 @@ public void timeout_withNonNullAdTimeoutDelay_shouldSignalFailureAndInvalidateWi
         stub(mockMoPubInterstitial.getAdTimeoutDelay()).toReturn(77);
 
         subject.loadInterstitial();
-        Robolectric.idleMainLooper(77000 - 1);
+        ShadowLooper.idleMainLooper(77000 - 1);
         verify(interstitialAdapterListener, never()).onCustomEventInterstitialFailed(eq(NETWORK_TIMEOUT));
         assertThat(subject.isInvalidated()).isFalse();
 
-        Robolectric.idleMainLooper(1);
+        ShadowLooper.idleMainLooper(1);
         verify(interstitialAdapterListener).onCustomEventInterstitialFailed(eq(NETWORK_TIMEOUT));
         assertThat(subject.isInvalidated()).isTrue();
     }
@@ -162,33 +165,33 @@ public void loadInterstitial_shouldPropagateServerExtrasToInterstitial() throws
 
     @Test
     public void loadInterstitial_shouldScheduleTimeout_interstitialLoadedAndFailed_shouldCancelTimeout() throws Exception {
-        Robolectric.pauseMainLooper();
+        ShadowLooper.pauseMainLooper();
 
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(0);
 
         subject.loadInterstitial();
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(1);
 
         subject.onInterstitialLoaded();
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(0);
 
         subject.loadInterstitial();
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(1);
 
         subject.onInterstitialFailed(null);
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(0);
     }
 
     @Test
     public void loadInterstitial_shouldScheduleTimeoutRunnableBeforeCallingLoadInterstitial() throws Exception {
-        Robolectric.pauseMainLooper();
+        ShadowLooper.pauseMainLooper();
 
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(0);
 
         Answer assertTimeoutRunnableHasStarted = new Answer() {
             @Override
             public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+                assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(1);
                 return null;
             }
         };
@@ -207,14 +210,14 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
 
     @Test
     public void loadInterstitial_whenCallingOnInterstitialFailed_shouldCancelExistingTimeoutRunnable() throws Exception {
-        Robolectric.pauseMainLooper();
+        ShadowLooper.pauseMainLooper();
 
         Answer justCallOnInterstitialFailed = new Answer() {
             @Override
             public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+                assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(1);
                 subject.onInterstitialFailed(null);
-                assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+                assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(0);
                 return null;
             }
         };
@@ -228,9 +231,9 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
                         any(Map.class)
                 );
 
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(0);
         subject.loadInterstitial();
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(0);
     }
 
     @Test
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/EventForwardingBroadcastReceiverTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/EventForwardingBroadcastReceiverTest.java
index e028844b..b4944b80 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/EventForwardingBroadcastReceiverTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/EventForwardingBroadcastReceiverTest.java
@@ -14,7 +14,8 @@
 import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.shadows.ShadowLocalBroadcastManager;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.support.v4.ShadowLocalBroadcastManager;
 
 import java.util.HashMap;
 import java.util.Iterator;
@@ -36,6 +37,7 @@
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class EventForwardingBroadcastReceiverTest {
 
     private CustomEventInterstitialListener customEventInterstitialListener;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlBannerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlBannerTest.java
index 4b7f81c9..2fdd7a26 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlBannerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlBannerTest.java
@@ -13,6 +13,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
+import org.robolectric.annotation.Config;
 
 import java.util.HashMap;
 import java.util.Map;
@@ -31,6 +32,7 @@
 import static org.mockito.Mockito.verify;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class HtmlBannerTest {
 
     private HtmlBanner subject;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlBannerWebViewTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlBannerWebViewTest.java
index aea2d409..89168462 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlBannerWebViewTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlBannerWebViewTest.java
@@ -11,6 +11,8 @@
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.robolectric.Robolectric;
+import org.robolectric.Shadows;
+import org.robolectric.annotation.Config;
 
 import static com.mopub.mobileads.CustomEventBanner.CustomEventBannerListener;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_INVALID_STATE;
@@ -18,9 +20,9 @@
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
-import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class HtmlBannerWebViewTest {
     private HtmlBannerWebView subject;
     @Mock
@@ -41,7 +43,7 @@ public void setup() throws Exception {
     @Test
     public void init_shouldSetupWebViewClient() throws Exception {
         subject.init(customEventBannerListener, false, clickthroughUrl, redirectUrl);
-        WebViewClient webViewClient = shadowOf(subject).getWebViewClient();
+        WebViewClient webViewClient = Shadows.shadowOf(subject).getWebViewClient();
         assertThat(webViewClient).isNotNull();
         assertThat(webViewClient).isInstanceOf(HtmlWebViewClient.class);
     }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlInterstitialTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlInterstitialTest.java
index 19d7184e..df8821fe 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlInterstitialTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlInterstitialTest.java
@@ -10,21 +10,22 @@
 import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.shadows.ShadowLocalBroadcastManager;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowApplication;
+import org.robolectric.shadows.support.v4.ShadowLocalBroadcastManager;
 
 import java.util.HashMap;
 import java.util.Map;
 
-import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
-import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
-import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
 import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
-import static com.mopub.mobileads.EventForwardingBroadcastReceiverTest.getIntentForActionAndIdentifier;
 import static com.mopub.common.DataKeys.CLICKTHROUGH_URL_KEY;
 import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
 import static com.mopub.common.DataKeys.REDIRECT_URL_KEY;
 import static com.mopub.common.DataKeys.SCROLLABLE_KEY;
+import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
+import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
+import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
+import static com.mopub.mobileads.EventForwardingBroadcastReceiverTest.getIntentForActionAndIdentifier;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_INVALID_STATE;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.anyString;
@@ -33,6 +34,7 @@
 import static org.mockito.Mockito.verify;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class HtmlInterstitialTest extends ResponseBodyInterstitialTest {
     private CustomEventInterstitialListener customEventInterstitialListener;
     private Activity context;
@@ -85,7 +87,7 @@ public void showInterstitial_withMinimumExtras_shouldStartMoPubActivityWithDefau
         subject.loadInterstitial(context, customEventInterstitialListener, localExtras, serverExtras);
         subject.showInterstitial();
 
-        Intent nextStartedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent nextStartedActivity = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(nextStartedActivity.getStringExtra(HTML_RESPONSE_BODY_KEY)).isEqualTo(expectedResponse);
         assertThat(nextStartedActivity.getBooleanExtra(SCROLLABLE_KEY, false)).isFalse();
         assertThat(nextStartedActivity.getStringExtra(REDIRECT_URL_KEY)).isNull();
@@ -103,7 +105,7 @@ public void showInterstitial_shouldStartMoPubActivityWithAllExtras() throws Exce
         subject.loadInterstitial(context, customEventInterstitialListener, localExtras, serverExtras);
         subject.showInterstitial();
 
-        Intent nextStartedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent nextStartedActivity = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(nextStartedActivity.getStringExtra(HTML_RESPONSE_BODY_KEY)).isEqualTo(expectedResponse);
         assertThat(nextStartedActivity.getBooleanExtra(SCROLLABLE_KEY, false)).isTrue();
         assertThat(nextStartedActivity.getStringExtra(REDIRECT_URL_KEY)).isEqualTo("redirectUrl");
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlInterstitialWebViewTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlInterstitialWebViewTest.java
index 4d1763d8..a649c6a9 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlInterstitialWebViewTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlInterstitialWebViewTest.java
@@ -11,6 +11,8 @@
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.robolectric.Robolectric;
+import org.robolectric.Shadows;
+import org.robolectric.annotation.Config;
 
 import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
 import static com.mopub.mobileads.HtmlInterstitialWebView.HtmlInterstitialWebViewListener;
@@ -19,9 +21,9 @@
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
-import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class HtmlInterstitialWebViewTest {
 
     @Mock AdReport mockAdReport;
@@ -44,7 +46,7 @@ public void setUp() throws Exception {
     @Test
     public void init_shouldSetupWebViewClient() throws Exception {
         subject.init(customEventInterstitialListener, false, clickthroughUrl, redirectUrl);
-        WebViewClient webViewClient = shadowOf(subject).getWebViewClient();
+        WebViewClient webViewClient = Shadows.shadowOf(subject).getWebViewClient();
         assertThat(webViewClient).isNotNull();
         assertThat(webViewClient).isInstanceOf(HtmlWebViewClient.class);
     }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlWebViewClientTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlWebViewClientTest.java
index d2db93fd..3f388835 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlWebViewClientTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlWebViewClientTest.java
@@ -16,6 +16,9 @@
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
 import org.robolectric.Robolectric;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowApplication;
 
 import static com.mopub.mobileads.MoPubErrorCode.UNSPECIFIED;
 import static org.fest.assertions.api.Assertions.assertThat;
@@ -30,6 +33,7 @@
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class HtmlWebViewClientTest {
 
     private static final String CLICKTHROUGH_URL = "http://clickthrough";
@@ -88,13 +92,13 @@ public void shouldOverrideUrlLoading_withCustomApplicationIntent_withUserClick_a
         String customUrl = "myintent://something";
         stub(htmlWebView.wasClicked()).toReturn(true);
         subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(Intent.ACTION_VIEW, Uri.parse(customUrl)), new ResolveInfo());
+        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(Intent.ACTION_VIEW, Uri.parse(customUrl)), new ResolveInfo());
 
         boolean didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, customUrl);
 
         assertThat(didOverrideUrl).isTrue();
         verify(htmlWebViewListener).onClicked();
-        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent intent = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(intent).isNotNull();
     }
 
@@ -109,7 +113,7 @@ public void shouldOverrideUrlLoading_withCustomApplicationIntent_withoutUserClic
         assertThat(didOverrideUrl).isTrue();
         verify(htmlWebViewListener, never()).onClicked();
         verify(htmlWebView, never()).onResetUserClick();
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+        assertThat(ShadowApplication.getInstance().getNextStartedActivity()).isNull();
     }
 
     @Test
@@ -123,7 +127,7 @@ public void shouldOverrideUrlLoading_withCustomApplicationIntent_withUserClick_b
         assertThat(didOverrideUrl).isTrue();
         verify(htmlWebViewListener, never()).onClicked();
         verify(htmlWebView, never()).onResetUserClick();
-        Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent startedIntent = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(startedIntent).isNull();
     }
 
@@ -137,7 +141,7 @@ public void shouldOverrideUrlLoading_withHttpUrl_withUserClick_shouldOpenBrowser
         assertThat(didOverrideUrl).isTrue();
         verify(htmlWebViewListener).onClicked();
 
-        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent startedActivity = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(startedActivity.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
         assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(validUrl);
         assertThat(startedActivity.getData()).isNull();
@@ -153,7 +157,7 @@ public void shouldOverrideUrlLoading_withHttpUrl_withoutUserClick_shouldNotOpenB
         assertThat(didOverrideUrl).isTrue();
         verify(htmlWebViewListener, never()).onClicked();
         verify(htmlWebView, never()).onResetUserClick();
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+        assertThat(ShadowApplication.getInstance().getNextStartedActivity()).isNull();
     }
 
     @Test
@@ -163,7 +167,7 @@ public void shouldOverrideUrlLoading_withClickTrackingRedirect_withUserClick_sho
 
         subject.shouldOverrideUrlLoading(htmlWebView, validUrl);
 
-        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent startedActivity = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(validUrl);
     }
 
@@ -174,7 +178,7 @@ public void shouldOverrideUrlLoading_withClickTrackingRedirect_withoutUserClick_
 
         subject.shouldOverrideUrlLoading(htmlWebView, validUrl);
 
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+        assertThat(ShadowApplication.getInstance().getNextStartedActivity()).isNull();
     }
 
     @Test
@@ -184,7 +188,7 @@ public void shouldOverrideUrlLoading_withEmptyUrl_withUserClick_shouldFailSilent
 
         subject.shouldOverrideUrlLoading(htmlWebView, "");
 
-        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent startedActivity = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(startedActivity).isNull();
     }
 
@@ -195,7 +199,7 @@ public void shouldOverrideUrlLoading_withEmptyUrl_withoutUserClick_shouldLoadAbo
 
         subject.shouldOverrideUrlLoading(htmlWebView, "");
 
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+        assertThat(ShadowApplication.getInstance().getNextStartedActivity()).isNull();
     }
 
     @Test
@@ -209,7 +213,7 @@ public void shouldOverrideUrlLoading_withNativeBrowserScheme_withUserClick_shoul
         assertThat(shouldOverrideUrl).isTrue();
         verify(htmlWebViewListener).onClicked();
         verify(htmlWebView).onResetUserClick();
-        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent startedActivity = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(startedActivity.getAction()).isEqualTo("android.intent.action.VIEW");
         assertThat(startedActivity.getData().toString()).isEqualTo("http://www.mopub.com");
     }
@@ -225,7 +229,7 @@ public void shouldOverrideUrlLoading_withNativeBrowserScheme_withoutUserClick_sh
         assertThat(shouldOverrideUrl).isTrue();
         verify(htmlWebViewListener, never()).onClicked();
         verify(htmlWebView, never()).onResetUserClick();
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+        assertThat(ShadowApplication.getInstance().getNextStartedActivity()).isNull();
     }
 
     @Test
@@ -239,7 +243,7 @@ public void shouldOverrideUrlLoading_withNativeBrowserScheme_butOpaqueUri_withUs
         assertThat(shouldOverrideUrl).isTrue();
         verify(htmlWebViewListener, never()).onClicked();
         verify(htmlWebView, never()).onResetUserClick();
-        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent startedActivity = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(startedActivity).isNull();
     }
 
@@ -255,7 +259,7 @@ public void shouldOverrideUrlLoading_withNativeBrowserScheme_butOpaqueUri_withou
         verify(htmlWebViewListener, never()).onClicked();
         verify(htmlWebView, never()).onResetUserClick();
 
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+        assertThat(ShadowApplication.getInstance().getNextStartedActivity()).isNull();
     }
 
     @Test
@@ -266,7 +270,7 @@ public void shouldOverrideUrlLoading_withNativeBrowserScheme_withInvalidHostSche
         boolean shouldOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, "something://blah?url=invalid");
 
         assertThat(shouldOverrideUrl).isTrue();
-        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent startedActivity = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(startedActivity).isNull();
 
         verify(htmlWebViewListener, never()).onClicked();
@@ -283,7 +287,7 @@ public void shouldOverrideUrlLoading_withNativeBrowserScheme_withInvalidHostSche
         assertThat(shouldOverrideUrl).isTrue();
         verify(htmlWebViewListener, never()).onClicked();
         verify(htmlWebView, never()).onResetUserClick();
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+        assertThat(ShadowApplication.getInstance().getNextStartedActivity()).isNull();
     }
 
     @Test
@@ -292,7 +296,7 @@ public void shouldOverrideUrlLoading_withAboutBlankUrl_shouldFailSilently() {
 
         subject.shouldOverrideUrlLoading(htmlWebView, "about:blank");
 
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+        assertThat(ShadowApplication.getInstance().getNextStartedActivity()).isNull();
         verify(htmlWebViewListener, never()).onClicked();
         verify(htmlWebView, never()).onResetUserClick();
     }
@@ -352,7 +356,7 @@ public void onPageStarted_whenLoadedUrlStartsWithRedirect_withUserClick_shouldOp
 
         verify(view).stopLoading();
 
-        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent intent = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(intent.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(url);
         assertThat(intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
         assertThat(intent.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
@@ -368,7 +372,7 @@ public void onPageStarted_whenLoadedUrlStartsWithRedirect_withoutUserClick_shoul
 
         verify(view).stopLoading();
 
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+        assertThat(ShadowApplication.getInstance().getNextStartedActivity()).isNull();
     }
 
     @Test
@@ -380,7 +384,7 @@ public void onPageStarted_whenLoadedUrlStartsWithRedirectAndHasClickthrough_with
 
         verify(view).stopLoading();
 
-        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent intent = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(intent.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(url);
         assertThat(intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
         assertThat(intent.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
@@ -395,7 +399,7 @@ public void onPageStarted_whenLoadedUrlStartsWithRedirectAndHasClickthrough_with
 
         verify(view).stopLoading();
 
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+        assertThat(ShadowApplication.getInstance().getNextStartedActivity()).isNull();
     }
 
     @Test
@@ -429,7 +433,7 @@ public void onPageStarted_whenLoadedUrlDoesntStartWithRedirect_shouldDoNothing()
 
         verify(view, never()).stopLoading();
 
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+        assertThat(ShadowApplication.getInstance().getNextStartedActivity()).isNull();
     }
 
     private void assertPhoneUrlStartedCorrectIntent(String url) {
@@ -437,7 +441,7 @@ private void assertPhoneUrlStartedCorrectIntent(String url) {
 
         stub(htmlWebView.wasClicked()).toReturn(true);
         didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, url);
-        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent startedActivity = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(startedActivity.getAction()).isEqualTo(Intent.ACTION_VIEW);
         assertThat(startedActivity.getData().toString()).isEqualTo(url);
         assertThat(didOverrideUrl).isTrue();
@@ -448,7 +452,7 @@ private void assertPhoneUrlStartedCorrectIntent(String url) {
 
         stub(htmlWebView.wasClicked()).toReturn(false);
         didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, url);
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+        assertThat(ShadowApplication.getInstance().getNextStartedActivity()).isNull();
         assertThat(didOverrideUrl).isTrue();
         verify(htmlWebViewListener, never()).onClicked();
         verify(htmlWebView, never()).onResetUserClick();
@@ -463,7 +467,7 @@ private void assertNothingHappensWithoutClick(final String url) {
 
         verify(htmlWebViewListener, never()).onClicked();
         verify(htmlWebView, never()).onResetUserClick();
-        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent startedActivity = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(startedActivity).isNull();
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubActivityTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubActivityTest.java
index 4dd42595..1254bd10 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubActivityTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubActivityTest.java
@@ -21,7 +21,11 @@
 import org.mockito.ArgumentCaptor;
 import org.mockito.Mock;
 import org.robolectric.Robolectric;
-import org.robolectric.shadows.ShadowLocalBroadcastManager;
+import org.robolectric.annotation.Config;
+import org.robolectric.internal.ShadowExtractor;
+import org.robolectric.shadows.ShadowActivity;
+import org.robolectric.shadows.ShadowApplication;
+import org.robolectric.shadows.support.v4.ShadowLocalBroadcastManager;
 import org.robolectric.util.ActivityController;
 
 import static com.mopub.common.DataKeys.CLICKTHROUGH_URL_KEY;
@@ -45,9 +49,9 @@
 import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
-import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class MoPubActivityTest {
     private static final String EXPECTED_HTML_DATA = "htmlData";
     private static final boolean EXPECTED_IS_SCROLLABLE = true;
@@ -181,7 +185,7 @@ public void onDestroy_shouldFireJavascriptWebviewDidClose() throws Exception {
     public void start_shouldStartMoPubActivityWithCorrectParameters() throws Exception {
         MoPubActivity.start(subject, "expectedResponse", mockAdReport, true, "redirectUrl", "clickthroughUrl", CreativeOrientation.PORTRAIT, testBroadcastIdentifier);
 
-        Intent nextStartedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent nextStartedActivity = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(nextStartedActivity.getStringExtra(HTML_RESPONSE_BODY_KEY)).isEqualTo("expectedResponse");
         assertThat(nextStartedActivity.getBooleanExtra(SCROLLABLE_KEY, false)).isTrue();
         assertThat(nextStartedActivity.getStringExtra(REDIRECT_URL_KEY)).isEqualTo("redirectUrl");
@@ -231,7 +235,7 @@ public void getAdView_shouldSetUpForBroadcastingFail() throws Exception {
         Intent intent = intentCaptor.getValue();
         assertThat(intent.getAction()).isEqualTo(ACTION_INTERSTITIAL_FAIL);
 
-        assertThat(shadowOf(subject).isFinishing()).isTrue();
+        assertThat(subject.isFinishing()).isTrue();
     }
 
     @Test
@@ -251,7 +255,7 @@ public void broadcastingInterstitialListener_onInterstitialFailed_shouldBroadcas
         broadcastingInterstitialListener.onInterstitialFailed(null);
 
         verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
-        assertThat(shadowOf(subject).isFinishing()).isTrue();
+        assertThat(((ShadowActivity) ShadowExtractor.extract(subject)).isFinishing()).isTrue();
     }
 
     @Test
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubConversionTrackerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubConversionTrackerTest.java
index 6052109a..8e0af80a 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubConversionTrackerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubConversionTrackerTest.java
@@ -6,7 +6,6 @@
 import com.mopub.network.MoPubRequestQueue;
 import com.mopub.network.Networking;
 import com.mopub.network.TrackingRequest;
-import com.mopub.volley.RequestQueue;
 import com.mopub.volley.VolleyError;
 
 import org.junit.Before;
@@ -15,6 +14,7 @@
 import org.mockito.ArgumentCaptor;
 import org.mockito.Captor;
 import org.mockito.Mock;
+import org.robolectric.annotation.Config;
 
 import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.never;
@@ -22,6 +22,7 @@
 import static org.mockito.Mockito.verify;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class MoPubConversionTrackerTest {
     private MoPubConversionTracker subject;
     private Activity context;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubInterstitialTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubInterstitialTest.java
index 67e4752b..2c0b3f95 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubInterstitialTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubInterstitialTest.java
@@ -2,8 +2,6 @@
 
 import android.app.Activity;
 
-import com.mopub.common.LocationService;
-import com.mopub.common.MoPub;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.mobileads.test.support.TestAdViewControllerFactory;
 import com.mopub.mobileads.test.support.TestCustomEventInterstitialAdapterFactory;
@@ -13,6 +11,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
 
 import java.math.BigDecimal;
 import java.util.HashMap;
@@ -31,6 +30,7 @@
 import static org.mockito.Mockito.verify;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class MoPubInterstitialTest {
 
     private static final String KEYWORDS_VALUE = "expected_keywords";
@@ -105,13 +105,6 @@ public void getInterstitialAdListenerTest() throws Exception {
         assertThat(subject.getInterstitialAdListener()).isSameAs(interstitialAdListener);
     }
 
-    @Test
-    public void setLocationAwarenss_shouldChangeGlobalSetting() {
-        assertThat(MoPub.getLocationAwareness()).isEqualTo(MoPub.LocationAwareness.NORMAL);
-        subject.setLocationAwareness(LocationService.LocationAwareness.DISABLED);
-        assertThat(MoPub.getLocationAwareness()).isEqualTo(MoPub.LocationAwareness.DISABLED);
-    }
-
     @Test
     public void getTestingTest() throws Exception {
         subject.setInterstitialView(interstitialView);
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubRewardedVideoManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubRewardedVideoManagerTest.java
index 9ffe543d..f519befc 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubRewardedVideoManagerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubRewardedVideoManagerTest.java
@@ -22,6 +22,8 @@
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLooper;
 
 import java.util.Map;
 
@@ -34,6 +36,7 @@
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class
         MoPubRewardedVideoManagerTest {
 
@@ -67,7 +70,7 @@ public Object answer(final InvocationOnMock invocationOnMock) throws Throwable {
     @After
     public void tearDown() {
         // Unpause the main looper in case a test terminated while the looper was paused.
-        Robolectric.unPauseMainLooper();
+        ShadowLooper.unPauseMainLooper();
     }
 
     @Test
@@ -82,13 +85,13 @@ public void callbackMethods_withNullListener_shouldNotError() {
 
         // Robolectric executes its handlers immediately, so if we want the async behavior we see
         // in an actual app we have to pause the main looper until we're done successfully loading the ad.
-        Robolectric.pauseMainLooper();
+        ShadowLooper.pauseMainLooper();
 
         MoPubRewardedVideoManager.loadVideo("testAdUnit");
         // Triggers a call to MoPubRewardedVideoManager.onRewardedVideoLoadSuccess
         requestListener.onSuccess(testResponse);
 
-        Robolectric.unPauseMainLooper();
+        ShadowLooper.unPauseMainLooper();
 
         MoPubRewardedVideoManager.onRewardedVideoClicked(TestCustomEvent.class, "id!");
         MoPubRewardedVideoManager.onRewardedVideoStarted(TestCustomEvent.class, "id!");
@@ -159,12 +162,12 @@ public void onAdSuccess_shouldInstantiateCustomEvent_andLoad() {
 
         // Robolectric executes its handlers immediately, so if we want the async behavior we see
         // in an actual app we have to pause the main looper until we're done successfully loading the ad.
-        Robolectric.pauseMainLooper();
+        ShadowLooper.pauseMainLooper();
 
         MoPubRewardedVideoManager.loadVideo("testAdUnit");
         requestListener.onSuccess(testResponse);
 
-        Robolectric.unPauseMainLooper();
+        ShadowLooper.unPauseMainLooper();
 
         assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isTrue();
         verify(mockVideoListener).onRewardedVideoLoadSuccess(eq("testAdUnit"));
@@ -180,12 +183,12 @@ public void playVideo_shouldSetHasVideoFalse() {
 
         // Robolectric executes its handlers immediately, so if we want the async behavior we see
         // in an actual app we have to pause the main looper until we're done successfully loading the ad.
-        Robolectric.pauseMainLooper();
+        ShadowLooper.pauseMainLooper();
 
         MoPubRewardedVideoManager.loadVideo("testAdUnit");
         requestListener.onSuccess(testResponse);
 
-        Robolectric.unPauseMainLooper();
+        ShadowLooper.unPauseMainLooper();
 
         assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isTrue();
         MoPubRewardedVideoManager.showVideo("testAdUnit");
@@ -203,12 +206,12 @@ public void playVideo_whenNotHasVideo_shouldFail() {
 
         // Robolectric executes its handlers immediately, so if we want the async behavior we see
         // in an actual app we have to pause the main looper until we're done successfully loading the ad.
-        Robolectric.pauseMainLooper();
+        ShadowLooper.pauseMainLooper();
 
         MoPubRewardedVideoManager.loadVideo("testAdUnit");
         requestListener.onSuccess(testResponse);
 
-        Robolectric.unPauseMainLooper();
+        ShadowLooper.unPauseMainLooper();
 
         verify(mockVideoListener).onRewardedVideoLoadFailure(eq("testAdUnit"), eq(MoPubErrorCode.NETWORK_NO_FILL));
 
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubShadowMediaPlayer.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubShadowMediaPlayer.java
new file mode 100644
index 00000000..eb0820e6
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubShadowMediaPlayer.java
@@ -0,0 +1,25 @@
+package com.mopub.mobileads;
+
+import android.media.MediaPlayer;
+
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadows.ShadowMediaPlayer;
+import org.robolectric.shadows.util.DataSource;
+
+/**
+ */
+@Implements(MediaPlayer.class)
+public class MoPubShadowMediaPlayer extends ShadowMediaPlayer {
+
+    /*
+     * Override to avoid the "no setup extension" that Robo 3.0 ShadowMediaPlayer gives you.
+     */
+    @Override
+    public void doSetDataSource(final DataSource dataSource) {
+        MediaInfo stubMediaInfo = new MediaInfo(123, 123);
+        if (getMediaInfo(dataSource) == null) {
+            addMediaInfo(dataSource, stubMediaInfo);
+        }
+        super.doSetDataSource(dataSource);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubViewTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubViewTest.java
index 4bab198e..16fd1507 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubViewTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubViewTest.java
@@ -5,8 +5,6 @@
 import android.content.Intent;
 import android.view.View;
 
-import com.mopub.common.LocationService;
-import com.mopub.common.MoPub;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.mobileads.test.support.TestAdViewControllerFactory;
 import com.mopub.mobileads.test.support.TestCustomEventBannerAdapterFactory;
@@ -15,6 +13,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowApplication;
 
 import java.util.HashMap;
@@ -29,6 +28,7 @@
 import static org.mockito.Mockito.verify;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class MoPubViewTest {
     private MoPubView subject;
     private Map<String,String> paramsMap = new HashMap<String, String>();
@@ -191,15 +191,8 @@ public void loadCustomEvent_whenParamsMapIsNull_shouldCallLoadFailUrl() throws E
         verify(customEventBannerAdapter, never()).loadAd();
     }
 
-    @Test
-    public void setLocationAwarenss_shouldChangeGlobalSetting() {
-        assertThat(MoPub.getLocationAwareness()).isEqualTo(MoPub.LocationAwareness.NORMAL);
-        subject.setLocationAwareness(LocationService.LocationAwareness.DISABLED);
-        assertThat(MoPub.getLocationAwareness()).isEqualTo(MoPub.LocationAwareness.DISABLED);
-    }
-
     private void broadcastIntent(final Intent intent) {
-        final List<ShadowApplication.Wrapper> wrappers = Robolectric.getShadowApplication().getRegisteredReceivers();
+        final List<ShadowApplication.Wrapper> wrappers = ShadowApplication.getInstance().getRegisteredReceivers();
 
         for (final ShadowApplication.Wrapper wrapper : wrappers) {
             wrapper.broadcastReceiver.onReceive(context, intent);
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidActivityTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidActivityTest.java
index 84737b46..2d2e16f3 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidActivityTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidActivityTest.java
@@ -25,8 +25,9 @@
 import org.mockito.ArgumentCaptor;
 import org.mockito.Mock;
 import org.robolectric.Robolectric;
+import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
-import org.robolectric.shadows.ShadowLocalBroadcastManager;
+import org.robolectric.shadows.support.v4.ShadowLocalBroadcastManager;
 import org.robolectric.util.ActivityController;
 
 import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
@@ -42,9 +43,10 @@
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.verify;
-import static org.robolectric.Robolectric.shadowOf;
+
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class MraidActivityTest {
     static final String EXPECTED_SOURCE = "expected source";
 
@@ -181,23 +183,23 @@ public void onCreate_shouldSetLayoutOfMraidView() throws Exception {
         assertThat(actualLayoutParams.height).isEqualTo(FrameLayout.LayoutParams.MATCH_PARENT);
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Config(sdk = VERSION_CODES.ICE_CREAM_SANDWICH)
     @Ignore("Mraid 2.0")
     @Test
     public void onCreate_atLeastIcs_shouldSetHardwareAcceleratedFlag() throws Exception {
         subject.onCreate(null);
 
-        boolean hardwareAccelerated = shadowOf(subject.getWindow()).getFlag(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
+        boolean hardwareAccelerated = Shadows.shadowOf(subject.getWindow()).getFlag(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
         assertThat(hardwareAccelerated).isTrue();
     }
 
-    @Config(reportSdk = VERSION_CODES.HONEYCOMB_MR2)
+    @Config(sdk = VERSION_CODES.HONEYCOMB_MR2)
     @Ignore("Mraid 2.0")
     @Test
     public void onCreate_beforeIcs_shouldNotSetHardwareAcceleratedFlag() throws Exception {
         subject.onCreate(null);
 
-        boolean hardwareAccelerated = shadowOf(subject.getWindow()).getFlag(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
+        boolean hardwareAccelerated = Shadows.shadowOf(subject.getWindow()).getFlag(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
         assertThat(hardwareAccelerated).isFalse();
     }
 
@@ -309,7 +311,7 @@ public void onPause_shouldOnPauseMraidView() throws Exception {
     @Test
     public void onResume_shouldResumeMraidView() throws Exception {
         subject.onCreate(null);
-        Robolectric.shadowOf(subject).pauseAndThenResume();
+        Shadows.shadowOf(subject).pauseAndThenResume();
 
         verify(mraidWebView).onResume();
     }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidVideoPlayerActivityTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidVideoPlayerActivityTest.java
index 9a3e3090..ef88b18d 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidVideoPlayerActivityTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidVideoPlayerActivityTest.java
@@ -17,6 +17,8 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.Shadows;
+import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowActivity;
 
 import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
@@ -24,9 +26,9 @@
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
-import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class MraidVideoPlayerActivityTest {
     private static final String VAST = "vast";
     private static final String MRAID = "mraid";
@@ -118,7 +120,7 @@ public void onSetContentView_shouldActuallySetContentView() throws Exception {
 
         subject.onSetContentView(expectedView);
 
-        assertThat(shadowOf(subject).getContentView()).isEqualTo(expectedView);
+        assertThat(Shadows.shadowOf(subject).getContentView()).isEqualTo(expectedView);
     }
 
     @Test
@@ -148,7 +150,7 @@ public void onStartActivityForResult_shouldStartAnActivityWithRelevantRequestCod
 
         subject.onStartActivityForResult(MoPubBrowser.class, 100, expectedExtras);
 
-        final ShadowActivity.IntentForResult intentForResult = shadowOf(subject).getNextStartedActivityForResult();
+        final ShadowActivity.IntentForResult intentForResult = Shadows.shadowOf(subject).getNextStartedActivityForResult();
 
         assertThat(intentForResult.intent.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
         assertThat(intentForResult.intent.getExtras()).isEqualTo(expectedExtras);
@@ -161,7 +163,7 @@ public void onStartActivityForResult_withNullClass_shouldNotStartAnActivity() th
 
         subject.onStartActivityForResult(null, 100, new Bundle());
 
-        final ShadowActivity.IntentForResult intentForResult = shadowOf(subject).getNextStartedActivityForResult();
+        final ShadowActivity.IntentForResult intentForResult = Shadows.shadowOf(subject).getNextStartedActivityForResult();
         assertThat(intentForResult).isNull();
     }
 
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/RepeatingHandlerRunnableTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/RepeatingHandlerRunnableTest.java
index 3c51f6f7..e6314478 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/RepeatingHandlerRunnableTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/RepeatingHandlerRunnableTest.java
@@ -9,6 +9,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
+import org.robolectric.annotation.Config;
 
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.reset;
@@ -16,6 +17,7 @@
 import static org.mockito.Mockito.verifyZeroInteractions;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class RepeatingHandlerRunnableTest {
 
     @Mock Handler mockHandler;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastAdXmlManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastAdXmlManagerTest.java
index 0b20146d..97b53591 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastAdXmlManagerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastAdXmlManagerTest.java
@@ -5,12 +5,14 @@
 
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
 import org.w3c.dom.Node;
 
 import static com.mopub.mobileads.test.support.VastUtils.createNode;
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class VastAdXmlManagerTest {
 
     private VastAdXmlManager subject;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastBaseInLineWrapperXmlManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastBaseInLineWrapperXmlManagerTest.java
index 143b211a..01533c96 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastBaseInLineWrapperXmlManagerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastBaseInLineWrapperXmlManagerTest.java
@@ -5,6 +5,7 @@
 
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
 import org.w3c.dom.Node;
 
 import java.util.List;
@@ -13,8 +14,8 @@
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class VastBaseInLineWrapperXmlManagerTest {
-
     private VastBaseInLineWrapperXmlManager subject;
 
     @Test
@@ -331,4 +332,63 @@ public void getCompanionAdXmlManagers_withNoCreativesNodes_shouldReturnEmptyList
 
         assertThat(subject.getLinearXmlManagers()).isEmpty();
     }
+
+    @Test
+    public void getVastExtensionsXmlManager_shouldReturnExtensions() throws Exception {
+        String inLineXml = "<InLine>" +
+                "               <Extensions>" +
+                "                   <Extension>Extension 1</Extension>" +
+                "                   <Extension>Extension 2</Extension>" +
+                "               </Extensions>" +
+                "           </InLine>";
+
+        Node inLineNode = createNode(inLineXml);
+        subject = new VastInLineXmlManager(inLineNode);
+
+        assertThat(subject.getVastExtensionParentXmlManager()).isNotNull();
+        assertThat(subject.getVastExtensionParentXmlManager().getVastExtensionXmlManagers())
+                .hasSize(2);
+    }
+
+    @Test
+    public void getVastExtensionParentXmlManager_withMultipleParentExtensions_shouldReturnFirstParentExtensionOnly() throws Exception {
+        String inLineXml = "<InLine>" +
+                "               <Extensions>" +
+                "                   <Extension>Extension 1</Extension>" +
+                "               </Extensions>" +
+                "               <Extensions>" +
+                "                   <Extension>Extension 2</Extension>" +
+                "                   <Extension>Extension 3</Extension>" +
+                "               </Extensions>" +
+                "           </InLine>";
+
+        Node inLineNode = createNode(inLineXml);
+        subject = new VastInLineXmlManager(inLineNode);
+
+        assertThat(subject.getVastExtensionParentXmlManager()).isNotNull();
+        assertThat(subject.getVastExtensionParentXmlManager().getVastExtensionXmlManagers())
+                .hasSize(1);
+    }
+
+    @Test
+    public void getVastExtensionParentXmlManager_withoutExtensions_shouldReturnNull() throws Exception {
+        String inLineXml = "<InLine>" +
+                "                 <Creative>" +
+                "                     <CompanionAds>" +
+                "                         <Companion>" +
+                "                             <TrackingEvents>" +
+                "                                 <Tracking event=\"creativeView\">" +
+                "                                     <![CDATA[http://tracking/m/closeThree]]>" +
+                "                                 </Tracking>" +
+                "                             </TrackingEvents>" +
+                "                         </Companion>"+
+                "                     </CompanionAds>" +
+                "                 </Creative>" +
+                "           </InLine>";
+
+        Node inLineNode = createNode(inLineXml);
+        subject = new VastInLineXmlManager(inLineNode);
+
+        assertThat(subject.getVastExtensionParentXmlManager()).isNull();
+    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastCompanionAdConfigTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastCompanionAdConfigTest.java
index ffbe32f0..e77fcc62 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastCompanionAdConfigTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastCompanionAdConfigTest.java
@@ -16,6 +16,8 @@
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowApplication;
 
 import static com.mopub.common.VolleyRequestMatcher.isUrl;
 import static org.fest.assertions.api.Assertions.assertThat;
@@ -24,6 +26,7 @@
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class VastCompanionAdConfigTest {
 
     private static final String RESOLVED_CLICKTHROUGH_URL = "http://www.mopub.com/";
@@ -83,8 +86,8 @@ public void handleClick_shouldNotTrackClick() throws Exception {
     public void handleClick_shouldOpenMoPubBrowser() throws Exception {
         subject.handleClick(context, 1, null);
 
-        Robolectric.runBackgroundTasks();
-        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        Robolectric.getBackgroundThreadScheduler().advanceBy(0);
+        Intent startedActivity = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(startedActivity.getComponent().getClassName())
                 .isEqualTo("com.mopub.common.MoPubBrowser");
         assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY))
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastCompanionAdConfigXmlManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastCompanionAdConfigXmlManagerTest.java
index a199dbf9..6c608e42 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastCompanionAdConfigXmlManagerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastCompanionAdConfigXmlManagerTest.java
@@ -6,12 +6,14 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
 import org.w3c.dom.Node;
 
 import static com.mopub.mobileads.test.support.VastUtils.createNode;
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class VastCompanionAdConfigXmlManagerTest {
 
     private VastCompanionAdXmlManager subject;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastExtensionParentXmlManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastExtensionParentXmlManagerTest.java
new file mode 100644
index 00000000..74faa3ab
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastExtensionParentXmlManagerTest.java
@@ -0,0 +1,40 @@
+package com.mopub.mobileads;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+
+import static com.mopub.mobileads.test.support.VastUtils.createNode;
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class VastExtensionParentXmlManagerTest {
+    private VastExtensionParentXmlManager subject;
+
+    @Test
+    public void getVastExtensionXmlManagers_shouldReturnExtensionManagers() throws Exception {
+        String parentExtensionXml = "<Extensions>" +
+                "                       <Extension>Extension 1</Extension>" +
+                "                       <Extension>Extension 2</Extension>" +
+                "                    </Extensions>";
+
+        subject = new VastExtensionParentXmlManager(createNode(parentExtensionXml));
+
+        assertThat(subject.getVastExtensionXmlManagers()).isNotNull();
+        assertThat(subject.getVastExtensionXmlManagers()).hasSize(2);
+    }
+
+    @Test
+    public void getVastExtensionXmlManagers_withoutExtensions_shouldReturnEmptyList() throws Exception {
+        String parentExtensionXml = "<Extensions></Extensions>";
+
+        subject = new VastExtensionParentXmlManager(createNode(parentExtensionXml));
+
+        assertThat(subject.getVastExtensionXmlManagers()).isNotNull();
+        assertThat(subject.getVastExtensionXmlManagers()).isEmpty();
+    }
+
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastExtensionXmlManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastExtensionXmlManagerTest.java
new file mode 100644
index 00000000..b5f09038
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastExtensionXmlManagerTest.java
@@ -0,0 +1,100 @@
+package com.mopub.mobileads;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+
+import static com.mopub.mobileads.test.support.VastUtils.createNode;
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class VastExtensionXmlManagerTest {
+    private VastExtensionXmlManager subject;
+
+    @Test
+    public void getType_shouldReturnExtensionType() throws Exception {
+        String extensionXml = "<Extension type=\"MyExtensionType\"></Extension>";
+
+        subject = new VastExtensionXmlManager(createNode(extensionXml));
+
+        assertThat(subject.getType()).isEqualTo("MyExtensionType");
+    }
+
+    @Test
+    public void getVideoViewabilityTracker_shouldReturnVideoViewabilityTracker() throws Exception {
+        String extensionXml = "<Extension type=\"MoPub\">" +
+                "                  <MoPubViewabilityTracker" +
+                "                          viewablePlaytime=\"2.5\"" +
+                "                          percentViewable=\"50%\">" +
+                "                      <![CDATA[http://ad.server.com/impression/dot.gif]]>" +
+                "                  </MoPubViewabilityTracker>" +
+                "              </Extension>";
+
+        subject = new VastExtensionXmlManager(createNode(extensionXml));
+        VideoViewabilityTracker tracker = subject.getVideoViewabilityTracker();
+
+        assertThat(tracker).isNotNull();
+        assertThat(tracker.getViewablePlaytimeMS()).isEqualTo(2500);
+        assertThat(tracker.getPercentViewable()).isEqualTo(50);
+        assertThat(tracker.getTrackingUrl()).isEqualTo("http://ad.server.com/impression/dot.gif");
+    }
+
+    @Test
+    public void getVideoViewabilityTracker_withoutViewabilityTracker_shouldReturnNull() throws Exception {
+        String extensionXml = "<Extension type=\"MoPub\"></Extension>";
+
+        subject = new VastExtensionXmlManager(createNode(extensionXml));
+        VideoViewabilityTracker tracker = subject.getVideoViewabilityTracker();
+
+        assertThat(tracker).isNull();
+    }
+
+    @Test
+    public void getVideoViewabilityTracker_withoutVieweablePlaytime_shouldReturnNull() throws Exception {
+        String extensionXml = "<Extension type=\"MoPub\">" +
+                "                  <MoPubViewabilityTracker" +
+                "                          percentViewable=\"50%\">" +
+                "                      <![CDATA[http://ad.server.com/impression/dot.gif]]>" +
+                "                  </MoPubViewabilityTracker>" +
+                "              </Extension>";
+
+        subject = new VastExtensionXmlManager(createNode(extensionXml));
+        VideoViewabilityTracker tracker = subject.getVideoViewabilityTracker();
+
+        assertThat(tracker).isNull();
+    }
+
+    @Test
+    public void getVideoViewabilityTracker_withoutPercentViewable_shouldReturnNull() throws Exception {
+        String extensionXml = "<Extension type=\"MoPub\">" +
+                "                  <MoPubViewabilityTracker" +
+                "                          viewablePlaytime=\"2.5\">" +
+                "                      <![CDATA[http://ad.server.com/impression/dot.gif]]>" +
+                "                  </MoPubViewabilityTracker>" +
+                "              </Extension>";
+
+        subject = new VastExtensionXmlManager(createNode(extensionXml));
+        VideoViewabilityTracker tracker = subject.getVideoViewabilityTracker();
+
+        assertThat(tracker).isNull();
+    }
+
+    @Test
+    public void getVideoViewabilityTracker_withoutTrackerUrl_shouldReturnNull() throws Exception {
+        String extensionXml = "<Extension type=\"MoPub\">" +
+                "                  <MoPubViewabilityTracker" +
+                "                          viewablePlaytime=\"2.5\"" +
+                "                          percentViewable=\"50%\">" +
+                "                  </MoPubViewabilityTracker>" +
+                "              </Extension>";
+
+        subject = new VastExtensionXmlManager(createNode(extensionXml));
+        VideoViewabilityTracker tracker = subject.getVideoViewabilityTracker();
+
+        assertThat(tracker).isNull();
+    }
+
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastIconConfigTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastIconConfigTest.java
index 7833472d..292a0414 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastIconConfigTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastIconConfigTest.java
@@ -15,6 +15,8 @@
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowApplication;
 
 import static com.mopub.common.VolleyRequestMatcher.isUrl;
 import static org.fest.assertions.api.Assertions.assertThat;
@@ -23,6 +25,7 @@
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class VastIconConfigTest {
 
     private VastIconConfig subject;
@@ -92,8 +95,8 @@ public void handleClick_shouldNotTrackClick() throws Exception {
     public void handleClick_shouldOpenMoPubBrowser() throws Exception {
         subject.handleClick(context, null);
 
-        Robolectric.runBackgroundTasks();
-        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        Robolectric.getBackgroundThreadScheduler().advanceBy(0);
+        Intent startedActivity = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(startedActivity.getComponent().getClassName())
                 .isEqualTo("com.mopub.common.MoPubBrowser");
         assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY))
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastIconConfigXmlManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastIconConfigXmlManagerTest.java
index e0e501ab..1789c222 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastIconConfigXmlManagerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastIconConfigXmlManagerTest.java
@@ -6,12 +6,14 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
 import org.w3c.dom.Node;
 
 import static com.mopub.mobileads.test.support.VastUtils.createNode;
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class VastIconConfigXmlManagerTest {
 
     private VastIconXmlManager subject;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastLinearXmlManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastLinearXmlManagerTest.java
index 57d5625e..65e91898 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastLinearXmlManagerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastLinearXmlManagerTest.java
@@ -6,6 +6,7 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
 import org.w3c.dom.Node;
 
 import java.util.List;
@@ -14,6 +15,7 @@
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class VastLinearXmlManagerTest {
 
     private VastLinearXmlManager subject;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastMacroHelperTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastMacroHelperTest.java
index 89005ec6..c2fd0853 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastMacroHelperTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastMacroHelperTest.java
@@ -7,6 +7,7 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
 
 import java.util.Arrays;
 import java.util.Collections;
@@ -14,6 +15,7 @@
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class VastMacroHelperTest {
 
     private static final String ERROR_CODE = "errorcode";
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastManagerTest.java
index 9b653256..e36212ca 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastManagerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastManagerTest.java
@@ -16,6 +16,7 @@
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLooper;
 
 import java.util.concurrent.Semaphore;
 
@@ -26,8 +27,8 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 
-@Config(shadows = {ShadowMoPubHttpUrlConnection.class})
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class, shadows = {ShadowMoPubHttpUrlConnection.class})
 public class VastManagerTest {
     static final String EXTENSIONS_SNIPPET_PLACEHOLDER = "<![CDATA[EXTENSIONS_SNIPPET]]>";
     static final String TEST_VAST_XML_STRING = "<VAST version='2.0'><Ad id='62833'><Wrapper><AdSystem>Tapad</AdSystem><VASTAdTagURI>http://dsp.x-team.staging.mopub.com/xml</VASTAdTagURI><Impression>http://myTrackingURL/wrapper/impression1</Impression><Impression>http://myTrackingURL/wrapper/impression2</Impression><Creatives><Creative AdID='62833'><Linear><TrackingEvents><Tracking event='creativeView'>http://myTrackingURL/wrapper/creativeView</Tracking><Tracking event='start'>http://myTrackingURL/wrapper/start</Tracking><Tracking event='midpoint'>http://myTrackingURL/wrapper/midpoint</Tracking><Tracking event='progress' offset='00:00:03.100'>http://myTrackingURL/wrapper/progress</Tracking><Tracking event='firstQuartile'>http://myTrackingURL/wrapper/firstQuartile</Tracking><Tracking event='thirdQuartile'>http://myTrackingURL/wrapper/thirdQuartile</Tracking><Tracking event='complete'>http://myTrackingURL/wrapper/complete</Tracking><Tracking event='close'>http://myTrackingURL/wrapper/close</Tracking><Tracking event='skip'>http://myTrackingURL/wrapper/skip</Tracking><Tracking event='mute'>http://myTrackingURL/wrapper/mute</Tracking><Tracking event='unmute'>http://myTrackingURL/wrapper/unmute</Tracking><Tracking event='pause'>http://myTrackingURL/wrapper/pause</Tracking><Tracking event='resume'>http://myTrackingURL/wrapper/resume</Tracking><Tracking event='fullscreen'>http://myTrackingURL/wrapper/fullscreen</Tracking></TrackingEvents><VideoClicks><ClickTracking>http://myTrackingURL/wrapper/click</ClickTracking></VideoClicks></Linear></Creative><Creative AdID=\"601364-Companion\"> <CompanionAds><Companion width=\"9000\"></Companion> </CompanionAds></Creative></Creatives><![CDATA[EXTENSIONS_SNIPPET]]><Error><![CDATA[http://wrapperErrorTracker]]></Error></Wrapper></Ad></VAST><MP_TRACKING_URLS><MP_TRACKING_URL>http://www.mopub.com/imp1</MP_TRACKING_URL><MP_TRACKING_URL>http://www.mopub.com/imp2</MP_TRACKING_URL></MP_TRACKING_URLS>";
@@ -44,7 +45,7 @@
     public void setup() {
         context = Robolectric.buildActivity(Activity.class).create().get();
         CacheService.initializeDiskCache(context);
-        subject = new VastManager(context);
+        subject = new VastManager(context, true);
 
         semaphore = new Semaphore(0);
         vastManagerListener = mock(VastManagerListener.class);
@@ -67,8 +68,8 @@ public void tearDown() {
     private void prepareVastVideoConfiguration() {
         subject.prepareVastVideoConfiguration(TEST_VAST_XML_STRING, vastManagerListener, context);
 
-        Robolectric.runBackgroundTasks();
-        Robolectric.runUiThreadTasks();
+        Robolectric.getBackgroundThreadScheduler().advanceBy(0);
+        ShadowLooper.runUiThreadTasks();
     }
 
     @Test
@@ -249,8 +250,8 @@ public void prepareVastVideoConfiguration_withExtensionsUnderWrapper_shouldConta
                 vastManagerListener,
                 context);
 
-        Robolectric.runBackgroundTasks();
-        Robolectric.runUiThreadTasks();
+        Robolectric.getBackgroundThreadScheduler().advanceBy(0);
+        ShadowLooper.runUiThreadTasks();
         semaphore.acquire();
         verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfig.class));
 
@@ -319,8 +320,8 @@ public void prepareVastVideoConfiguration_withExtensionsUnderBothWrapperAndInlin
                 vastManagerListener,
                 context);
 
-        Robolectric.runBackgroundTasks();
-        Robolectric.runUiThreadTasks();
+        Robolectric.getBackgroundThreadScheduler().advanceBy(0);
+        ShadowLooper.runUiThreadTasks();
         semaphore.acquire();
 
         verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfig.class));
@@ -491,8 +492,8 @@ public void prepareVastVideoConfiguration_withSkipOffsets_shouldReturnLastParsed
                 vastManagerListener,
                 context);
 
-        Robolectric.runBackgroundTasks();
-        Robolectric.runUiThreadTasks();
+        Robolectric.getBackgroundThreadScheduler().advanceBy(0);
+        ShadowLooper.runUiThreadTasks();
         semaphore.acquire();
 
         verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfig.class));
@@ -521,8 +522,8 @@ public void prepareVastVideoConfiguration_withNoMediaUrlInXml_shouldReturnNull()
         subject.prepareVastVideoConfiguration(TEST_VAST_BAD_NEST_URL_XML_STRING,
                 vastManagerListener, context);
 
-        Robolectric.runBackgroundTasks();
-        Robolectric.runUiThreadTasks();
+        Robolectric.getBackgroundThreadScheduler().advanceBy(0);
+        ShadowLooper.runUiThreadTasks();
         semaphore.acquire();
 
         verify(vastManagerListener).onVastVideoConfigurationPrepared(null);
@@ -533,8 +534,8 @@ public void prepareVastVideoConfiguration_withNoMediaUrlInXml_shouldReturnNull()
     public void prepareVastVideoConfiguration_withNullXml_shouldReturnNull() throws Exception {
         subject.prepareVastVideoConfiguration(null, vastManagerListener, context);
 
-        Robolectric.runBackgroundTasks();
-        Robolectric.runUiThreadTasks();
+        Robolectric.getBackgroundThreadScheduler().advanceBy(0);
+        ShadowLooper.runUiThreadTasks();
         semaphore.acquire();
 
         verify(vastManagerListener).onVastVideoConfigurationPrepared(null);
@@ -545,8 +546,8 @@ public void prepareVastVideoConfiguration_withNullXml_shouldReturnNull() throws
     public void prepareVastVideoConfiguration_withEmptyXml_shouldReturnNull() throws Exception {
         subject.prepareVastVideoConfiguration("", vastManagerListener, context);
 
-        Robolectric.runBackgroundTasks();
-        Robolectric.runUiThreadTasks();
+        Robolectric.getBackgroundThreadScheduler().advanceBy(0);
+        ShadowLooper.runUiThreadTasks();
         semaphore.acquire();
 
         verify(vastManagerListener).onVastVideoConfigurationPrepared(null);
@@ -584,14 +585,14 @@ public void prepareVastVideoConfiguration_withUninitializedDiskCache_shouldRetur
     public void cancel_shouldCancelBackgroundProcessingAndNotNotifyListenerWithNull() throws Exception {
         ShadowMoPubHttpUrlConnection.addPendingResponse(200, TEST_NESTED_VAST_XML_STRING);
 
-        Robolectric.getBackgroundScheduler().pause();
+        Robolectric.getBackgroundThreadScheduler().pause();
 
         subject.prepareVastVideoConfiguration(TEST_VAST_XML_STRING, vastManagerListener, context);
 
         subject.cancel();
 
-        Robolectric.runBackgroundTasks();
-        Robolectric.runUiThreadTasks();
+        Robolectric.getBackgroundThreadScheduler().advanceBy(0);
+        ShadowLooper.runUiThreadTasks();
         semaphore.acquire();
 
         verify(vastManagerListener).onVastVideoConfigurationPrepared(null);
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastMediaXmlManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastMediaXmlManagerTest.java
index 729b2ace..c50ec72c 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastMediaXmlManagerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastMediaXmlManagerTest.java
@@ -5,12 +5,14 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
 import org.w3c.dom.Node;
 
 import static com.mopub.mobileads.test.support.VastUtils.createNode;
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class VastMediaXmlManagerTest {
 
     private VastMediaXmlManager subject;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastResourceTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastResourceTest.java
index 322a98a6..01fcbe31 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastResourceTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastResourceTest.java
@@ -6,12 +6,14 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
+import org.robolectric.annotation.Config;
 
 import static com.mopub.mobileads.VastResource.fromVastResourceXmlManager;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Mockito.verify;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class VastResourceTest {
 
     private VastResource subject;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastResourceXmlManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastResourceXmlManagerTest.java
index 78f08b22..fab514c3 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastResourceXmlManagerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastResourceXmlManagerTest.java
@@ -5,12 +5,14 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
 import org.w3c.dom.Node;
 
 import static com.mopub.mobileads.test.support.VastUtils.createNode;
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class VastResourceXmlManagerTest {
 
     private VastResourceXmlManager subject;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoBlurLastVideoFrameTaskTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoBlurLastVideoFrameTaskTest.java
index bea34a0c..59262336 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoBlurLastVideoFrameTaskTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoBlurLastVideoFrameTaskTest.java
@@ -6,6 +6,7 @@
 import android.os.Build;
 import android.widget.ImageView;
 
+import com.mopub.TestSdkHelper;
 import com.mopub.common.test.support.SdkTestRunner;
 
 import org.junit.Before;
@@ -26,6 +27,7 @@
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class VastVideoBlurLastVideoFrameTaskTest {
     @Mock private MediaMetadataRetriever mockMediaMetadataRetriever;
     @Mock private ImageView mockBlurredLastVideoFrameImageView;
@@ -47,18 +49,18 @@ public void setUp() throws Exception {
                 mockBlurredLastVideoFrameImageView, videoDuration);
     }
 
-    @Config(reportSdk = Build.VERSION_CODES.GINGERBREAD)
     @Test
     public void doInBackground_beforeGingerbreadMr1_shouldReturnFalse() throws Exception {
+        TestSdkHelper.setReportedSdkLevel(Build.VERSION_CODES.GINGERBREAD);
         assertThat(subject.doInBackground(videoPath)).isFalse();
         verifyNoMoreInteractions(mockMediaMetadataRetriever);
         assertThat(subject.getBlurredLastVideoFrame()).isNull();
     }
 
     @TargetApi(Build.VERSION_CODES.GINGERBREAD_MR1)
-    @Config(reportSdk = Build.VERSION_CODES.GINGERBREAD_MR1)
     @Test
     public void doInBackground_atLeastGingerbreadMr1_shouldSetVideoPath_shouldUseVideoDurationMinusOffset_shouldReturnTrue() throws Exception {
+        TestSdkHelper.setReportedSdkLevel(Build.VERSION_CODES.GINGERBREAD_MR1);
         assertThat(subject.doInBackground(videoPath)).isTrue();
         verify(mockMediaMetadataRetriever).setDataSource(videoPath);
         verify(mockMediaMetadataRetriever).getFrameAtTime(9800000,
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoCloseButtonWidgetTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoCloseButtonWidgetTest.java
index c7c825c1..91b85528 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoCloseButtonWidgetTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoCloseButtonWidgetTest.java
@@ -21,6 +21,7 @@
 import org.mockito.Captor;
 import org.mockito.Mock;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
@@ -31,6 +32,7 @@
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class VastVideoCloseButtonWidgetTest {
     private Context context;
     private VastVideoCloseButtonWidget subject;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoConfigTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoConfigTest.java
index b41ec047..504a0822 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoConfigTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoConfigTest.java
@@ -12,6 +12,8 @@
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowApplication;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -25,6 +27,7 @@
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class VastVideoConfigTest {
 
     @Mock MoPubRequestQueue mockRequestQueue;
@@ -144,26 +147,26 @@ public void getUntriggeredTrackersBefore_shouldReturnAllTrackersSorted() throws
     }
 
     @Test
-    public void handleClick_withNullClickThroughUrl_shouldNotOpenNewActivity() throws Exception {
-        subject.handleClick(activity, 1234, 1);
+    public void handleClickForResult_withNullClickThroughUrl_shouldNotOpenNewActivity() throws Exception {
+        subject.handleClickForResult(activity, 1234, 1);
 
-        Robolectric.getUiThreadScheduler().unPause();
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+        Robolectric.getForegroundThreadScheduler().unPause();
+        assertThat(ShadowApplication.getInstance().getNextStartedActivity()).isNull();
     }
 
     @Test
-    public void handleClick_withMoPubNativeBrowserClickThroughUrl_shouldOpenExternalBrowser_shouldMakeTrackingHttpRequest() throws Exception {
+    public void handleClickForResult_withMoPubNativeBrowserClickThroughUrl_shouldOpenExternalBrowser_shouldMakeTrackingHttpRequest() throws Exception {
         subject.setClickThroughUrl(
                 "mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.mopub.com%2F");
         subject.addClickTrackers(
                 Arrays.asList(new VastTracker("http://trackerone+content=[CONTENTPLAYHEAD]"),
                         new VastTracker("http://trackertwo+error=[ERRORCODE]&asset=[ASSETURI]")));
 
-        subject.handleClick(activity, 2345, 1234);
+        subject.handleClickForResult(activity, 2345, 1234);
 
-        Robolectric.getUiThreadScheduler().unPause();
-        Robolectric.runBackgroundTasks();
-        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        Robolectric.getForegroundThreadScheduler().unPause();
+        Robolectric.getBackgroundThreadScheduler().advanceBy(0);
+        Intent intent = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(intent.getDataString()).isEqualTo("http://www.mopub.com/");
         assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
         verify(mockRequestQueue).add(argThat(isUrl("http://trackerone+content=00:00:02.345")));
@@ -172,22 +175,42 @@ public void handleClick_withMoPubNativeBrowserClickThroughUrl_shouldOpenExternal
     }
 
     @Test
-    public void handleClick_withMalformedMoPubNativeBrowserClickThroughUrl_shouldNotOpenANewActivity() throws Exception {
+    public void handleClickWithoutResult_shouldOpenExternalBrowser_shouldMakeTrackingHttpRequest() throws Exception {
+        subject.setClickThroughUrl(
+                "mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.mopub.com%2F");
+        subject.addClickTrackers(
+                Arrays.asList(new VastTracker("http://trackerone+content=[CONTENTPLAYHEAD]"),
+                        new VastTracker("http://trackertwo+error=[ERRORCODE]&asset=[ASSETURI]")));
+
+        subject.handleClickWithoutResult(activity.getApplicationContext(), 2345);
+
+        Robolectric.getForegroundThreadScheduler().unPause();
+        Robolectric.getBackgroundThreadScheduler().advanceBy(0);
+        Intent intent = ShadowApplication.getInstance().getNextStartedActivity();
+        assertThat(intent.getDataString()).isEqualTo("http://www.mopub.com/");
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        verify(mockRequestQueue).add(argThat(isUrl("http://trackerone+content=00:00:02.345")));
+        verify(mockRequestQueue).add(argThat(isUrl("http://trackertwo+error=&asset=video_url")));
+        verifyNoMoreInteractions(mockRequestQueue);
+    }
+
+    @Test
+    public void handleClickForResult_withMalformedMoPubNativeBrowserClickThroughUrl_shouldNotOpenANewActivity() throws Exception {
         // url2 is an invalid query parameter
         subject.setClickThroughUrl(
                 "mopubnativebrowser://navigate?url2=http%3A%2F%2Fwww.mopub.com%2F");
 
-        subject.handleClick(activity, 3456, 1);
+        subject.handleClickForResult(activity, 3456, 1);
 
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+        assertThat(ShadowApplication.getInstance().getNextStartedActivity()).isNull();
     }
 
     @Test
-    public void handleClick_withAboutBlankClickThroughUrl_shouldFailSilently() throws Exception {
+    public void handleClickForResult_withAboutBlankClickThroughUrl_shouldFailSilently() throws Exception {
         subject.setClickThroughUrl("about:blank");
 
-        subject.handleClick(activity, 4567, 1);
+        subject.handleClickForResult(activity, 4567, 1);
 
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+        assertThat(ShadowApplication.getInstance().getNextStartedActivity()).isNull();
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoCtaButtonWidgetTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoCtaButtonWidgetTest.java
index 988d36b1..2943bfea 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoCtaButtonWidgetTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoCtaButtonWidgetTest.java
@@ -11,10 +11,12 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class VastVideoCtaButtonWidgetTest {
     private Context context;
     private VastVideoCtaButtonWidget subject;
@@ -164,6 +166,18 @@ public void notifyVideoComplete_withCompanionAdAndOrientationUndefined_shouldBeG
         assertThat(subject.getLayoutParams()).isNull();
     }
 
+    @Test
+    public void notifyVideoComplete_withCompanionAd_withSocialActions_shouldBeVisible() throws Exception {
+        context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_UNDEFINED;
+        subject = new VastVideoCtaButtonWidget(context, 0, true, true);
+        subject.setHasSocialActions(true);
+        subject.setVisibility(View.VISIBLE);
+
+        subject.notifyVideoComplete();
+
+        assertThat(subject.getVisibility()).isEqualTo(View.VISIBLE);
+    }
+
     // Video is complete, no companion ad, has clickthrough url, CTA button already visible
 
     @Test
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoGradientStripWidgetTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoGradientStripWidgetTest.java
index f4b3c240..5d397b97 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoGradientStripWidgetTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoGradientStripWidgetTest.java
@@ -14,10 +14,12 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class VastVideoGradientStripWidgetTest {
     private Context context;
     private VastVideoGradientStripWidget subject;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoInterstitialTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoInterstitialTest.java
index 2ea08001..8c7e91e9 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoInterstitialTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoInterstitialTest.java
@@ -11,12 +11,13 @@
 import com.mopub.mobileads.test.support.TestVastManagerFactory;
 import com.mopub.mobileads.test.support.VastUtils;
 
-import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
-import org.robolectric.shadows.ShadowLocalBroadcastManager;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.httpclient.FakeHttp;
+import org.robolectric.shadows.support.v4.ShadowLocalBroadcastManager;
 
 import java.util.Arrays;
 import java.util.HashMap;
@@ -36,11 +37,11 @@
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.withSettings;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class VastVideoInterstitialTest extends ResponseBodyInterstitialTest {
     private Context context;
     private CustomEventInterstitialListener customEventInterstitialListener;
@@ -60,7 +61,7 @@ public void setUp() throws Exception {
         expectedResponse = "<VAST>hello</VAST>";
         videoUrl = "http://www.video.com";
 
-        context = new Activity();
+        context = Robolectric.buildActivity(Activity.class).create().get();
         customEventInterstitialListener = mock(CustomEventInterstitialListener.class);
         localExtras = new HashMap<String, Object>();
         serverExtras = new HashMap<String, String>();
@@ -93,7 +94,7 @@ public void loadInterstitial_shouldParseHtmlResponseBodyServerExtra() throws Exc
 
     @Test
     public void loadInterstitial_shouldInitializeDiskCache() throws Exception {
-        Robolectric.addPendingHttpResponse(response);
+        FakeHttp.addPendingHttpResponse(response);
 
         CacheServiceTest.assertDiskCacheIsUninitialized();
         subject.loadInterstitial(context, customEventInterstitialListener, localExtras, serverExtras);
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoProgressBarWidgetTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoProgressBarWidgetTest.java
index 9b857699..d214c516 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoProgressBarWidgetTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoProgressBarWidgetTest.java
@@ -11,6 +11,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Mockito.never;
@@ -19,6 +20,7 @@
 import static org.mockito.Mockito.verify;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class VastVideoProgressBarWidgetTest {
     private Context context;
     private VastVideoProgressBarWidget subject;
@@ -27,7 +29,8 @@
     @Before
     public void setUp() throws Exception {
         context = Robolectric.buildActivity(Activity.class).create().get();
-        subject = new VastVideoProgressBarWidget(context, 0);
+        subject = new VastVideoProgressBarWidget(context);
+        subject.setAnchorId(0);
         progressBarDrawableSpy = spy(subject.getImageViewDrawable());
         subject.setImageViewDrawable(progressBarDrawableSpy);
     }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoRadialCountdownWidgetTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoRadialCountdownWidgetTest.java
index 841f5c0d..e92e60c9 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoRadialCountdownWidgetTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoRadialCountdownWidgetTest.java
@@ -7,12 +7,11 @@
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.mobileads.resource.RadialCountdownDrawable;
 
-import junit.framework.TestCase;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.anyInt;
@@ -22,6 +21,7 @@
 import static org.mockito.Mockito.verify;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class VastVideoRadialCountdownWidgetTest {
     private Context context;
     private VastVideoRadialCountdownWidget subject;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewControllerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewControllerTest.java
index ca2435c6..ad511fe5 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewControllerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewControllerTest.java
@@ -21,6 +21,7 @@
 import android.widget.ImageView;
 import android.widget.VideoView;
 
+import com.mopub.TestSdkHelper;
 import com.mopub.common.MoPubBrowser;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.common.util.DeviceUtils.ForceOrientation;
@@ -40,23 +41,29 @@
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.robolectric.Robolectric;
+import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
+import org.robolectric.internal.ShadowExtractor;
+import org.robolectric.shadows.ShadowApplication;
 import org.robolectric.shadows.ShadowImageView;
-import org.robolectric.shadows.ShadowLocalBroadcastManager;
 import org.robolectric.shadows.ShadowRelativeLayout;
 import org.robolectric.shadows.ShadowTextView;
 import org.robolectric.shadows.ShadowVideoView;
-import org.robolectric.tester.org.apache.http.RequestMatcher;
-import org.robolectric.tester.org.apache.http.TestHttpResponse;
+import org.robolectric.shadows.httpclient.FakeHttp;
+import org.robolectric.shadows.httpclient.RequestMatcher;
+import org.robolectric.shadows.httpclient.TestHttpResponse;
+import org.robolectric.shadows.support.v4.ShadowLocalBroadcastManager;
 
 import java.io.File;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
 
 import static android.content.pm.ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
 import static android.content.pm.ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
 import static com.mopub.common.VolleyRequestMatcher.isUrl;
-import static com.mopub.common.util.ResponseHeader.USER_AGENT;
 import static com.mopub.mobileads.BaseVideoViewController.BaseVideoViewControllerListener;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_FAIL;
@@ -68,6 +75,8 @@
 import static com.mopub.mobileads.VastVideoViewController.MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON;
 import static com.mopub.mobileads.VastVideoViewController.RESUMED_VAST_CONFIG;
 import static com.mopub.mobileads.VastVideoViewController.VAST_VIDEO_CONFIG;
+import static com.mopub.mobileads.VastXmlManagerAggregator.ADS_BY_AD_SLOT_ID;
+import static com.mopub.mobileads.VastXmlManagerAggregator.SOCIAL_ACTIONS_AD_SLOT_ID;
 import static com.mopub.volley.toolbox.ImageLoader.ImageListener;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
@@ -86,11 +95,9 @@
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.Mockito.verifyZeroInteractions;
 import static org.mockito.Mockito.when;
-import static org.robolectric.Robolectric.shadowOf;
-import static org.robolectric.Robolectric.shadowOf_;
 
 @RunWith(SdkTestRunner.class)
-@Config(shadows = {ShadowVastVideoView.class})
+@Config(constants = BuildConfig.class, shadows = {ShadowVastVideoView.class})
 public class VastVideoViewControllerTest {
     public static final int NETWORK_DELAY = 100;
 
@@ -200,18 +207,28 @@ public void setUp() throws Exception {
         when(mMockVastIconConfig.getVastResource()).thenReturn(vastResource);
         vastVideoConfig.setVastIconConfig(mMockVastIconConfig);
 
+
+        final ArrayList<VastTracker> vastTrackers = new ArrayList<>();
+        VastCompanionAdConfig socialActionsCompanionAd =
+                new VastCompanionAdConfig(65, 20, vastResource, "", vastTrackers, vastTrackers);
+        Map<String, VastCompanionAdConfig> socialActionsCompanionAds =
+                new HashMap<String, VastCompanionAdConfig>();
+        socialActionsCompanionAds.put(ADS_BY_AD_SLOT_ID, socialActionsCompanionAd);
+        socialActionsCompanionAds.put(SOCIAL_ACTIONS_AD_SLOT_ID, socialActionsCompanionAd);
+        vastVideoConfig.setSocialActionsCompanionAds(socialActionsCompanionAds);
+
         when(mockMediaMetadataRetriever.getFrameAtTime(anyLong(), anyInt())).thenReturn(mockBitmap);
 
         bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
 
         expectedBrowserRequestCode = 1;
 
-        Robolectric.getUiThreadScheduler().pause();
-        Robolectric.getBackgroundScheduler().pause();
-        Robolectric.clearPendingHttpResponses();
+        Robolectric.getForegroundThreadScheduler().pause();
+        Robolectric.getBackgroundThreadScheduler().pause();
+        FakeHttp.clearPendingHttpResponses();
 
         // Used to give responses to Vast Download Tasks.
-        Robolectric.addHttpResponseRule(new RequestMatcher() {
+        FakeHttp.addHttpResponseRule(new RequestMatcher() {
             @Override
             public boolean matches(HttpRequest request) {
                 return true;
@@ -225,8 +242,8 @@ public boolean matches(HttpRequest request) {
 
     @After
     public void tearDown() throws Exception {
-        Robolectric.getUiThreadScheduler().reset();
-        Robolectric.getBackgroundScheduler().reset();
+        Robolectric.getForegroundThreadScheduler().reset();
+        Robolectric.getBackgroundThreadScheduler().reset();
 
         ShadowLocalBroadcastManager.getInstance(context).unregisterReceiver(broadcastReceiver);
     }
@@ -238,7 +255,7 @@ public void constructor_shouldAddCtaButtonWidgetToLayoutAndSetInvisibleWithOnTou
         VastVideoCtaButtonWidget ctaButtonWidget = subject.getCtaButtonWidget();
         assertThat(ctaButtonWidget.getParent()).isEqualTo(subject.getLayout());
         assertThat(ctaButtonWidget.getVisibility()).isEqualTo(View.INVISIBLE);
-        ShadowImageView ctaButtonWidgetShadow = shadowOf(ctaButtonWidget);
+        ShadowImageView ctaButtonWidgetShadow = Shadows.shadowOf(ctaButtonWidget);
         assertThat(ctaButtonWidgetShadow.getOnTouchListener()).isNotNull();
         assertThat(ctaButtonWidgetShadow.getOnTouchListener()).isEqualTo(
                 getShadowVideoView().getOnTouchListener());
@@ -251,7 +268,7 @@ public void constructor_shouldAddProgressBarWidgetToLayoutAndSetInvisibleWithNoL
         VastVideoProgressBarWidget progressBarWidget = subject.getProgressBarWidget();
         assertThat(progressBarWidget.getParent()).isEqualTo(subject.getLayout());
         assertThat(progressBarWidget.getVisibility()).isEqualTo(View.INVISIBLE);
-        ShadowImageView progressBarWidgetShadow = shadowOf(progressBarWidget);
+        ShadowImageView progressBarWidgetShadow = Shadows.shadowOf(progressBarWidget);
         assertThat(progressBarWidgetShadow.getOnTouchListener()).isNull();
     }
 
@@ -262,10 +279,42 @@ public void constructor_shouldAddRadialCountdownWidgetToLayoutAndSetInvisibleWit
         VastVideoRadialCountdownWidget radialCountdownWidget = subject.getRadialCountdownWidget();
         assertThat(radialCountdownWidget.getParent()).isEqualTo(subject.getLayout());
         assertThat(radialCountdownWidget.getVisibility()).isEqualTo(View.INVISIBLE);
-        ShadowImageView radialCountdownWidgetShadow = shadowOf(radialCountdownWidget);
+        ShadowImageView radialCountdownWidgetShadow = Shadows.shadowOf(radialCountdownWidget);
         assertThat(radialCountdownWidgetShadow.getOnTouchListener()).isNull();
     }
 
+    @Test
+    public void constructor_shouldAddIconViewToLayoutAndSetInvisibleWithWebViewClickListener() throws Exception {
+        initializeSubject();
+
+        View iconView = subject.getIconView();
+        assertThat(iconView.getParent()).isEqualTo(subject.getLayout());
+        assertThat(iconView.getVisibility()).isEqualTo(View.INVISIBLE);
+        assertThat(((VastWebView)iconView).getVastWebViewClickListener()).isNotNull();
+    }
+
+    @Test
+    public void constructor_withAdsByCompanion_shouldAddAdsByViewToLayout() throws Exception {
+        initializeSubject();
+
+        View adsByView = subject.createAdsByView((Activity) context);
+        assertThat(adsByView.getVisibility()).isEqualTo(View.VISIBLE);
+        assertThat(subject.getHasSocialActions()).isTrue();
+        assertThat(subject.getCtaButtonWidget().getHasSocialActions()).isTrue();
+        assertThat(((VastWebView) adsByView).getVastWebViewClickListener()).isNotNull();
+    }
+
+    @Test
+    public void constructor_withSocialActionsCompanion_shouldAddSocialActionsViewToLayout() throws Exception {
+        initializeSubject();
+
+        View socialActionsView = subject.getSocialActionsView();
+        assertThat(socialActionsView.getVisibility()).isEqualTo(View.INVISIBLE);
+        assertThat(subject.getHasSocialActions()).isTrue();
+        assertThat(subject.getCtaButtonWidget().getHasSocialActions()).isTrue();
+        assertThat(((VastWebView) socialActionsView).getVastWebViewClickListener()).isNotNull();
+    }
+
     @Test
     public void constructor_shouldAddCloseButtonWidgetToLayoutAndSetToGoneWithOnTouchListeners() throws Exception {
         initializeSubject();
@@ -274,13 +323,13 @@ public void constructor_shouldAddCloseButtonWidgetToLayoutAndSetToGoneWithOnTouc
         assertThat(closeButtonWidget.getParent()).isEqualTo(subject.getLayout());
         assertThat(closeButtonWidget.getVisibility()).isEqualTo(View.GONE);
 
-        ShadowRelativeLayout closeButtonWidgetShadow = (ShadowRelativeLayout) shadowOf(closeButtonWidget);
+        ShadowRelativeLayout closeButtonWidgetShadow = (ShadowRelativeLayout) Shadows.shadowOf(closeButtonWidget);
         assertThat(closeButtonWidgetShadow.getOnTouchListener()).isNull();
 
-        ShadowImageView closeButtonImageViewShadow = shadowOf(closeButtonWidget.getImageView());
+        ShadowImageView closeButtonImageViewShadow = Shadows.shadowOf(closeButtonWidget.getImageView());
         assertThat(closeButtonImageViewShadow.getOnTouchListener()).isNotNull();
 
-        ShadowTextView closeButtonTextViewShadow = shadowOf(closeButtonWidget.getTextView());
+        ShadowTextView closeButtonTextViewShadow = Shadows.shadowOf(closeButtonWidget.getTextView());
         assertThat(closeButtonTextViewShadow.getOnTouchListener()).isNotNull();
     }
 
@@ -291,7 +340,7 @@ public void constructor_shouldAddTopGradientStripWidgetToLayoutWithNoListeners()
         VastVideoGradientStripWidget topGradientStripWidget = subject.getTopGradientStripWidget();
         assertThat(topGradientStripWidget.getParent()).isEqualTo(subject.getLayout());
 
-        ShadowImageView topGradientStripWidgetShadow = shadowOf(topGradientStripWidget);
+        ShadowImageView topGradientStripWidgetShadow = Shadows.shadowOf(topGradientStripWidget);
         assertThat(topGradientStripWidgetShadow.getOnTouchListener()).isNull();
     }
 
@@ -302,7 +351,7 @@ public void constructor_shouldAddBottomGradientStripWidgetToLayoutWithNoListener
         VastVideoGradientStripWidget bottomGradientStripWidget = subject.getBottomGradientStripWidget();
         assertThat(bottomGradientStripWidget.getParent()).isEqualTo(subject.getLayout());
 
-        ShadowImageView bottomGradientStripWidgetShadow = shadowOf(bottomGradientStripWidget);
+        ShadowImageView bottomGradientStripWidgetShadow = Shadows.shadowOf(bottomGradientStripWidget);
         assertThat(bottomGradientStripWidgetShadow.getOnTouchListener()).isNull();
     }
 
@@ -313,14 +362,14 @@ public void constructor_shouldAddBlurredLastVideoFrameWidgetToLayoutAndSetInvisi
         ImageView blurredLastVideoFrameImageView = subject.getBlurredLastVideoFrameImageView();
         assertThat(blurredLastVideoFrameImageView.getParent()).isEqualTo(subject.getLayout());
         assertThat(blurredLastVideoFrameImageView.getVisibility()).isEqualTo(View.INVISIBLE);
-        ShadowImageView blurredLastVideoFrameImageViewShadow = shadowOf(blurredLastVideoFrameImageView);
+        ShadowImageView blurredLastVideoFrameImageViewShadow = Shadows.shadowOf(blurredLastVideoFrameImageView);
         assertThat(blurredLastVideoFrameImageViewShadow.getOnTouchListener()).isNull();
     }
 
     @Test
     public void constructor_shouldSetVideoListenersAndVideoPath() throws Exception {
         initializeSubject();
-        ShadowVideoView videoView = shadowOf(subject.getVideoView());
+        ShadowVideoView videoView = Shadows.shadowOf(subject.getVideoView());
 
         assertThat(videoView.getOnCompletionListener()).isNotNull();
         assertThat(videoView.getOnErrorListener()).isNotNull();
@@ -504,7 +553,7 @@ public void onCreate_shouldBroadcastInterstitialShow() throws Exception {
 
         initializeSubject();
 
-        Robolectric.getUiThreadScheduler().unPause();
+        Robolectric.getForegroundThreadScheduler().unPause();
         subject.onCreate();
         verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
     }
@@ -618,7 +667,7 @@ public void onDestroy_shouldBroadcastInterstitialDismiss() throws Exception {
         initializeSubject();
 
         subject.onDestroy();
-        Robolectric.getUiThreadScheduler().unPause();
+        Robolectric.getForegroundThreadScheduler().unPause();
 
         verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
     }
@@ -716,11 +765,11 @@ public void onTouch_withTouchUp_whenVideoLessThan16Seconds_andClickBeforeEnd_sho
 
         getShadowVideoView().getOnPreparedListener().onPrepared(null);
 
-        Robolectric.getUiThreadScheduler().unPause();
+        Robolectric.getForegroundThreadScheduler().unPause();
 
         getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(0, 0));
 
-        Intent nextStartedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent nextStartedActivity = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(nextStartedActivity).isNull();
     }
 
@@ -733,12 +782,12 @@ public void onTouch_withTouchUp_whenVideoLessThan16Seconds_andClickAfterEnd_shou
 
         getShadowVideoView().getOnPreparedListener().onPrepared(null);
 
-        Robolectric.getUiThreadScheduler().unPause();
+        Robolectric.getForegroundThreadScheduler().unPause();
 
         getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(0, 0));
 
-        Robolectric.runBackgroundTasks();
-        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+        Robolectric.getBackgroundThreadScheduler().advanceBy(0);
+        final Intent startedActivity = ShadowApplication.getInstance().peekNextStartedActivity();
         assertThat(startedActivity.getComponent().getClassName())
                 .isEqualTo(MoPubBrowser.class.getName());
         assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(
@@ -756,11 +805,11 @@ public void onTouch_withTouchUp_whenVideoLongerThan16Seconds_andClickBefore5Seco
 
         getShadowVideoView().getOnPreparedListener().onPrepared(null);
 
-        Robolectric.getUiThreadScheduler().unPause();
+        Robolectric.getForegroundThreadScheduler().unPause();
 
         getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(0, 0));
 
-        Intent nextStartedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent nextStartedActivity = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(nextStartedActivity).isNull();
     }
 
@@ -773,12 +822,12 @@ public void onTouch_withTouchUp_whenVideoLongerThan16Seconds_andClickAfter5Secon
 
         getShadowVideoView().getOnPreparedListener().onPrepared(null);
 
-        Robolectric.getUiThreadScheduler().unPause();
+        Robolectric.getForegroundThreadScheduler().unPause();
 
         getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(0, 0));
 
-        Robolectric.runBackgroundTasks();
-        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+        Robolectric.getBackgroundThreadScheduler().advanceBy(0);
+        final Intent startedActivity = ShadowApplication.getInstance().peekNextStartedActivity();
         assertThat(startedActivity.getComponent().getClassName())
                 .isEqualTo(MoPubBrowser.class.getName());
         assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(
@@ -825,7 +874,7 @@ public void onTouch_whenCloseButtonNotVisible_shouldNotPingClickThroughTrackers(
         subject.setCloseButtonVisible(false);
 
         getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(0, 0));
-        assertThat(Robolectric.httpRequestWasMade()).isFalse();
+        assertThat(FakeHttp.httpRequestWasMade()).isFalse();
     }
 
     @Test
@@ -1113,9 +1162,10 @@ public void onPrepared_shouldCalibrateAndMakeVisibleProgressBarWidget() throws E
         verify(progressBarWidgetSpy).calibrateAndMakeVisible(10000, 5000);
     }
 
-    @Config(reportSdk = VERSION_CODES.GINGERBREAD)
     @Test
     public void onPrepared_beforeGingerbreadMr1_shouldNotSetBlurredLastVideoFrame() throws Exception {
+
+        TestSdkHelper.setReportedSdkLevel(VERSION_CODES.GINGERBREAD);
         VastVideoConfig vastVideoConfig = new VastVideoConfig();
         vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
         bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
@@ -1123,19 +1173,19 @@ public void onPrepared_beforeGingerbreadMr1_shouldNotSetBlurredLastVideoFrame()
         initializeSubject();
 
         getShadowVideoView().getOnPreparedListener().onPrepared(null);
-        Robolectric.getBackgroundScheduler().unPause();
-        Robolectric.getUiThreadScheduler().unPause();
+        Robolectric.getBackgroundThreadScheduler().unPause();
+        Robolectric.getForegroundThreadScheduler().unPause();
         Thread.sleep(NETWORK_DELAY);
 
         assertThat(subject.getBlurredLastVideoFrameImageView().getDrawable()).isNull();
 
-        ShadowImageView imageView = shadowOf(subject.getBlurredLastVideoFrameImageView());
+        ShadowImageView imageView = Shadows.shadowOf(subject.getBlurredLastVideoFrameImageView());
         assertThat(imageView.getOnTouchListener()).isNull();
     }
 
-    @Config(reportSdk = VERSION_CODES.GINGERBREAD_MR1)
     @Test
     public void onPrepared_atLeastGingerbreadMr1_shouldSetBlurredLastVideoFrame() throws Exception {
+        TestSdkHelper.setReportedSdkLevel(VERSION_CODES.GINGERBREAD_MR1);
         VastVideoConfig vastVideoConfig = new VastVideoConfig();
         vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
         bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
@@ -1143,8 +1193,8 @@ public void onPrepared_atLeastGingerbreadMr1_shouldSetBlurredLastVideoFrame() th
         initializeSubject();
 
         getShadowVideoView().getOnPreparedListener().onPrepared(null);
-        Robolectric.getBackgroundScheduler().unPause();
-        Robolectric.getUiThreadScheduler().unPause();
+        Robolectric.getBackgroundThreadScheduler().unPause();
+        Robolectric.getForegroundThreadScheduler().unPause();
         Thread.sleep(NETWORK_DELAY);
 
         final ImageView blurredLastVideoFrameImageView = subject.getBlurredLastVideoFrameImageView();
@@ -1152,7 +1202,7 @@ public void onPrepared_atLeastGingerbreadMr1_shouldSetBlurredLastVideoFrame() th
         assertThat(
                 ((BitmapDrawable) blurredLastVideoFrameImageView.getDrawable()).getBitmap()).isNotNull();
 
-        ShadowImageView imageView = shadowOf(subject.getBlurredLastVideoFrameImageView());
+        ShadowImageView imageView = Shadows.shadowOf(subject.getBlurredLastVideoFrameImageView());
         assertThat(imageView.getOnTouchListener()).isNull();
     }
 
@@ -1262,6 +1312,10 @@ public void onCompletion_shouldStopProgressCheckerAndCountdown() throws Exceptio
 
     @Test
     public void onCompletion_whenCompanionAdAvailable_shouldShowCompanionAdAndHideBlurredLastVideoFrame() throws Exception {
+        final VastVideoConfig vastVideoConfig =
+                (VastVideoConfig) bundle.getSerializable(VAST_VIDEO_CONFIG);
+        vastVideoConfig.setSocialActionsCompanionAds(new HashMap<String, VastCompanionAdConfig>());
+        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
         initializeSubject();
 
         final View companionView = subject.getLandscapeCompanionAdView();
@@ -1272,8 +1326,8 @@ public void onCompletion_whenCompanionAdAvailable_shouldShowCompanionAdAndHideBl
         assertThat(blurredLastVideoFrameImageView.getVisibility()).isEqualTo(View.INVISIBLE);
 
         getShadowVideoView().getOnPreparedListener().onPrepared(null);
-        Robolectric.getBackgroundScheduler().unPause();
-        Robolectric.getUiThreadScheduler().unPause();
+        Robolectric.getBackgroundThreadScheduler().unPause();
+        Robolectric.getForegroundThreadScheduler().unPause();
         Thread.sleep(NETWORK_DELAY);
 
         getShadowVideoView().getOnCompletionListener().onCompletion(null);
@@ -1292,8 +1346,8 @@ public void onCompletion_whenCompanionAdAvailable_shouldOnlyShowTopGradientStrip
         final VastVideoGradientStripWidget bottomGradientStripWidget = subject.getBottomGradientStripWidget();
 
         getShadowVideoView().getOnPreparedListener().onPrepared(null);
-        Robolectric.getBackgroundScheduler().unPause();
-        Robolectric.getUiThreadScheduler().unPause();
+        Robolectric.getBackgroundThreadScheduler().unPause();
+        Robolectric.getForegroundThreadScheduler().unPause();
         Thread.sleep(NETWORK_DELAY);
 
         getShadowVideoView().getOnCompletionListener().onCompletion(null);
@@ -1319,8 +1373,8 @@ public void onCompletion_whenCompanionAdNotAvailable_shouldHideCompanionAdAndSho
         assertThat(blurredLastVideoFrameImageView.getVisibility()).isEqualTo(View.INVISIBLE);
 
         getShadowVideoView().getOnPreparedListener().onPrepared(null);
-        Robolectric.getBackgroundScheduler().unPause();
-        Robolectric.getUiThreadScheduler().unPause();
+        Robolectric.getBackgroundThreadScheduler().unPause();
+        Robolectric.getForegroundThreadScheduler().unPause();
         Thread.sleep(NETWORK_DELAY);
 
         getShadowVideoView().getOnCompletionListener().onCompletion(null);
@@ -1347,8 +1401,8 @@ public void onCompletion_whenCompanionAdNotAvailable_shouldHideBothGradientStrip
         final VastVideoGradientStripWidget bottomGradientStripWidget = subject.getBottomGradientStripWidget();
 
         getShadowVideoView().getOnPreparedListener().onPrepared(null);
-        Robolectric.getBackgroundScheduler().unPause();
-        Robolectric.getUiThreadScheduler().unPause();
+        Robolectric.getBackgroundThreadScheduler().unPause();
+        Robolectric.getForegroundThreadScheduler().unPause();
         Thread.sleep(NETWORK_DELAY);
 
         getShadowVideoView().getOnCompletionListener().onCompletion(null);
@@ -1403,6 +1457,30 @@ public void onCompletion_whenCompanionAdNotAvailableAndBlurredLastVideoFrameNotP
         assertThat(bottomGradientStripWidget.getVisibility()).isEqualTo(View.GONE);
     }
 
+    @Test
+    public void onCompletion_withSocialActions_shouldShowCompanionAdAndShowBlurredLastVideoFrame() throws Exception {
+        initializeSubject();
+
+        final View companionView = subject.getLandscapeCompanionAdView();
+        final ImageView blurredLastVideoFrameImageView = subject.getBlurredLastVideoFrameImageView();
+
+        assertThat(subject.getVideoView().getVisibility()).isEqualTo(View.VISIBLE);
+        assertThat(companionView.getVisibility()).isEqualTo(View.INVISIBLE);
+        assertThat(blurredLastVideoFrameImageView.getVisibility()).isEqualTo(View.INVISIBLE);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+        Robolectric.getBackgroundThreadScheduler().unPause();
+        Robolectric.getForegroundThreadScheduler().unPause();
+        Thread.sleep(NETWORK_DELAY);
+
+        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+
+        assertThat(subject.getVastVideoView().getBlurLastVideoFrameTask()).isNotNull();
+        assertThat(subject.getVideoView().getVisibility()).isEqualTo(View.INVISIBLE);
+        assertThat(companionView.getVisibility()).isEqualTo(View.VISIBLE);
+        assertThat(blurredLastVideoFrameImageView.getVisibility()).isEqualTo(View.VISIBLE);
+    }
+
     @Test
     public void onError_shouldFireVideoErrorAndReturnFalse() throws Exception {
         initializeSubject();
@@ -1410,7 +1488,7 @@ public void onError_shouldFireVideoErrorAndReturnFalse() throws Exception {
         Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_FAIL, testBroadcastIdentifier);
 
         boolean result = getShadowVideoView().getOnErrorListener().onError(null, 0, 0);
-        Robolectric.getUiThreadScheduler().unPause();
+        Robolectric.getForegroundThreadScheduler().unPause();
 
         assertThat(result).isFalse();
         verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
@@ -1431,12 +1509,17 @@ public void onError_shouldStopProgressChecker() throws Exception {
         verify(spyCountdownRunnable).stop();
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH_MR1)
+
     @Test
+    @Config(shadows = {MoPubShadowMediaPlayer.class})
     public void onError_withVideoFilePermissionErrorBelowJellyBean_shouldRetryPlayingTheVideo() throws Exception {
+        TestSdkHelper.setReportedSdkLevel(VERSION_CODES.ICE_CREAM_SANDWICH);
+
         File file = new File("disk_video_path");
         file.createNewFile();
 
+        // ShadowMediaPlayer setup needed to
+
         initializeSubject();
 
         assertThat(getShadowVideoView().getCurrentVideoState()).isEqualTo(-1);
@@ -1444,6 +1527,9 @@ public void onError_withVideoFilePermissionErrorBelowJellyBean_shouldRetryPlayin
         assertThat(subject.getVastVideoView().getVideoRetries()).isEqualTo(0);
         getShadowVideoView().getOnErrorListener().onError(new MediaPlayer(), 1, Integer.MIN_VALUE);
 
+        // Robo 3.0 introduces a requirement that ShadowMediaPlayer be set up with MediaInfo for a data source.
+        // Because we generate a file descriptor datasource at runtime, we can't set it up easily in this test.
+
         assertThat(getShadowVideoView().isPlaying()).isTrue();
         assertThat(subject.getVastVideoView().getVideoRetries()).isEqualTo(1);
 
@@ -1513,7 +1599,7 @@ public void videoRunnablesRun_shouldFireOffAllProgressTrackers() throws Exceptio
         subject.onResume();
 
         // this runs the videoProgressChecker and countdown runnable
-        Robolectric.getUiThreadScheduler().unPause();
+        Robolectric.getForegroundThreadScheduler().unPause();
 
         verify(mockRequestQueue).add(
                 argThat(isUrl("first?errorcode=&asseturi=video_url&contentplayhead=00:00:09.002")));
@@ -1534,11 +1620,12 @@ public void videoRunnablesRun_whenDurationIsInvalid_shouldNotMakeAnyNetworkCalls
         setVideoViewParams(0, 100);
 
         subject.onResume();
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(2);
+        Robolectric.getForegroundThreadScheduler().runOneTask();
+        Robolectric.getForegroundThreadScheduler().runOneTask();
 
-        Robolectric.getUiThreadScheduler().runTasks(2);
         // make sure the repeated task hasn't run yet
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(2);
         verifyZeroInteractions(mockRequestQueue);
     }
 
@@ -1555,18 +1642,20 @@ public void videoRunnablesRun_whenCurrentTimeLessThanTwoSeconds_shouldNotFireSta
         setVideoViewParams(1999, 100000);
         subject.onResume();
 
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(2);
 
-        Robolectric.getUiThreadScheduler().runTasks(2);
+        Robolectric.getForegroundThreadScheduler().runOneTask();
+        Robolectric.getForegroundThreadScheduler().runOneTask();
         // make sure the repeated task hasn't run yet
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(2);
 
         // Since it has not yet been a second, we expect that the start tracker has not been fired
         verifyZeroInteractions(mockRequestQueue);
 
         // run checker another time
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
-        Robolectric.getUiThreadScheduler().runTasks(2);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(2);
+        Robolectric.getForegroundThreadScheduler().runOneTask();
+        Robolectric.getForegroundThreadScheduler().runOneTask();
 
         verifyZeroInteractions(mockRequestQueue);
     }
@@ -1586,16 +1675,17 @@ public void videoRunnablesRun_whenCurrentTimeGreaterThanTwoSeconds_shouldFireSta
         spyOnVideoView();
         setVideoViewParams(2000, 100000);
         subject.onResume();
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(2);
 
-        Robolectric.getUiThreadScheduler().unPause();
+        Robolectric.getForegroundThreadScheduler().unPause();
 
         verify(mockRequestQueue).add(
                 argThat(isUrl("start?errorcode=&asseturi=video_url&contentplayhead=00:00:02.000")));
 
         // run checker another time
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
-        Robolectric.getUiThreadScheduler().runTasks(2);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(2);
+        Robolectric.getForegroundThreadScheduler().runOneTask();
+        Robolectric.getForegroundThreadScheduler().runOneTask();
 
         verifyNoMoreInteractions(mockRequestQueue);
     }
@@ -1616,15 +1706,16 @@ public void videoRunnablesRun_whenProgressIsPastFirstQuartile_shouldOnlyPingFirs
         setVideoViewParams(26, 100);
         subject.onResume();
 
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(2);
 
-        Robolectric.getUiThreadScheduler().unPause();
+        Robolectric.getForegroundThreadScheduler().unPause();
 
         verify(mockRequestQueue).add(
                 argThat(isUrl("first?errorcode=&asseturi=video_url&contentplayhead=00:00:00.026")));
 
         // run checker another time
-        Robolectric.getUiThreadScheduler().runTasks(2);
+        Robolectric.getForegroundThreadScheduler().runOneTask();
+        Robolectric.getForegroundThreadScheduler().runOneTask();
 
         verifyNoMoreInteractions(mockRequestQueue);
     }
@@ -1646,16 +1737,17 @@ public void videoRunnablesRun_whenProgressIsPastMidQuartile_shouldPingFirstQuart
         setVideoViewParams(51, 100);
 
         subject.onResume();
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(2);
 
-        Robolectric.getUiThreadScheduler().unPause();
+        Robolectric.getForegroundThreadScheduler().unPause();
 
         verify(mockRequestQueue).add(
                 argThat(isUrl("first?errorcode=&asseturi=video_url&contentplayhead=00:00:00.051")));
         verify(mockRequestQueue).add(argThat(isUrl(
                 "second?errorcode=&asseturi=video_url&contentplayhead=00:00:00.051")));
 
-        Robolectric.getUiThreadScheduler().runTasks(2);
+        Robolectric.getForegroundThreadScheduler().runOneTask();
+        Robolectric.getForegroundThreadScheduler().runOneTask();
 
         verifyNoMoreInteractions(mockRequestQueue);
     }
@@ -1678,9 +1770,9 @@ public void videoRunnablesRun_whenProgressIsPastThirdQuartile_shouldPingFirstQua
         setVideoViewParams(76, 100);
 
         subject.onResume();
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(2);
 
-        Robolectric.getUiThreadScheduler().unPause();
+        Robolectric.getForegroundThreadScheduler().unPause();
 
         verify(mockRequestQueue).add(
                 argThat(isUrl("first?errorcode=&asseturi=video_url&contentplayhead=00:00:00.076")));
@@ -1689,7 +1781,8 @@ public void videoRunnablesRun_whenProgressIsPastThirdQuartile_shouldPingFirstQua
         verify(mockRequestQueue).add(
                 argThat(isUrl("third?errorcode=&asseturi=video_url&contentplayhead=00:00:00.076")));
 
-        Robolectric.getUiThreadScheduler().runTasks(2);
+        Robolectric.getForegroundThreadScheduler().runOneTask();
+        Robolectric.getForegroundThreadScheduler().runOneTask();
 
         verifyNoMoreInteractions(mockRequestQueue);
     }
@@ -1741,9 +1834,9 @@ public void videoRunnablesRun_asVideoPlays_shouldPingAllThreeTrackersIndividuall
 
     private void seekToAndAssertRequestsMade(int position, String... trackingUrls) {
         when(spyVideoView.getCurrentPosition()).thenReturn(position);
+        Robolectric.getForegroundThreadScheduler().advanceToLastPostedRunnable();
 
         for (String url : trackingUrls) {
-            Robolectric.getUiThreadScheduler().unPause();
             verify(mockRequestQueue).add(argThat(isUrl(url)));
         }
     }
@@ -1757,7 +1850,7 @@ public void videoRunnablesRun_whenCurrentPositionIsGreaterThanShowCloseButtonDel
         subject.onResume();
 
         assertThat(subject.isShowCloseButtonEventFired()).isFalse();
-        Robolectric.getUiThreadScheduler().unPause();
+        Robolectric.getForegroundThreadScheduler().unPause();
 
         assertThat(subject.isShowCloseButtonEventFired()).isTrue();
     }
@@ -1781,7 +1874,7 @@ public void videoRunnablesRun_whenCurrentPositionIsGreaterThanSkipOffset_shouldS
         assertThat(subject.getHasSkipOffset()).isTrue();
 
         assertThat(subject.isShowCloseButtonEventFired()).isFalse();
-        Robolectric.getUiThreadScheduler().unPause();
+        Robolectric.getForegroundThreadScheduler().unPause();
 
         assertThat(subject.isShowCloseButtonEventFired()).isTrue();
     }
@@ -1804,7 +1897,7 @@ public void videoRunnablesRun_whenCurrentPositionIsLessThanSkipOffset_shouldNotS
         assertThat(subject.getHasSkipOffset()).isTrue();
 
         assertThat(subject.isShowCloseButtonEventFired()).isFalse();
-        Robolectric.getUiThreadScheduler().unPause();
+        Robolectric.getForegroundThreadScheduler().unPause();
 
         assertThat(subject.isShowCloseButtonEventFired()).isFalse();
     }
@@ -2023,7 +2116,7 @@ public void onClickCloseButtonImageView_whenCloseButtonIsVisible_shouldFireClose
         // We don't have direct access to the CloseButtonWidget icon's close event, so we manually
         // invoke its onTouchListener's onTouch callback with a fake MotionEvent.ACTION_UP action.
         View.OnTouchListener closeButtonImageViewOnTouchListener =
-                shadowOf(subject.getCloseButtonWidget().getImageView()).getOnTouchListener();
+                Shadows.shadowOf(subject.getCloseButtonWidget().getImageView()).getOnTouchListener();
         closeButtonImageViewOnTouchListener.onTouch(null, GestureUtils.createActionUp(0, 0));
 
         verify(mockRequestQueue).add(
@@ -2046,7 +2139,7 @@ public void onClickCloseButtonTextView_whenCloseButtonIsVisible_shouldFireCloseT
         // We don't have direct access to the CloseButtonWidget text's close event, so we manually
         // invoke its onTouchListener's onTouch callback with a fake MotionEvent.ACTION_UP action.
         View.OnTouchListener closeButtonTextViewOnTouchListener =
-                shadowOf(subject.getCloseButtonWidget().getTextView()).getOnTouchListener();
+                Shadows.shadowOf(subject.getCloseButtonWidget().getTextView()).getOnTouchListener();
         closeButtonTextViewOnTouchListener.onTouch(null, GestureUtils.createActionUp(0, 0));
 
         verify(mockRequestQueue).add(
@@ -2139,13 +2232,14 @@ public void handleIconDisplay_withCurrentPositionGreaterThanOffsetPlusDuration_s
     }
 
     @Test
-    public void makeInteractable_shouldHideCountdownWidgetAndShowCtaAndCloseButtonWidgets() throws Exception {
+    public void makeInteractable_shouldHideCountdownWidgetAndShowCtaAndCloseButtonWidgetsAndShowSocialActions() throws Exception {
         initializeSubject();
 
         subject.makeVideoInteractable();
 
         assertThat(subject.getRadialCountdownWidget().getVisibility()).isEqualTo(View.GONE);
         assertThat(subject.getCloseButtonWidget().getVisibility()).isEqualTo(View.VISIBLE);
+        assertThat(subject.getSocialActionsView().getVisibility()).isEqualTo(View.VISIBLE);
     }
 
     private void initializeSubject() throws IllegalAccessException {
@@ -2177,6 +2271,6 @@ private void setVideoViewParams(int currentPosition, int duration) throws Illega
     }
 
     private ShadowVastVideoView getShadowVideoView() {
-        return (ShadowVastVideoView) shadowOf_(subject.getVastVideoView());
+        return (ShadowVastVideoView) ShadowExtractor.extract(subject.getVastVideoView());
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewCountdownRunnableTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewCountdownRunnableTest.java
index 7b17304c..fd69364c 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewCountdownRunnableTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewCountdownRunnableTest.java
@@ -8,12 +8,14 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
+import org.robolectric.annotation.Config;
 
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class VastVideoViewCountdownRunnableTest {
 
     @Mock VastVideoViewController mockVideoViewController;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewProgressRunnableTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewProgressRunnableTest.java
index 1f5eabdb..1ae2abae 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewProgressRunnableTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewProgressRunnableTest.java
@@ -14,6 +14,7 @@
 import org.mockito.ArgumentCaptor;
 import org.mockito.Captor;
 import org.mockito.Mock;
+import org.robolectric.annotation.Config;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -26,6 +27,7 @@
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class VastVideoViewProgressRunnableTest {
     @Mock VastVideoViewController mockVastVideoViewController;
     @Mock Context mockContext;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewTest.java
index 064b8b78..0842ecda 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewTest.java
@@ -9,6 +9,7 @@
 import android.os.AsyncTask;
 import android.os.Build;
 
+import com.mopub.TestSdkHelper;
 import com.mopub.common.test.support.SdkTestRunner;
 
 import org.junit.Before;
@@ -30,6 +31,7 @@
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class VastVideoViewTest {
 
     @Mock private MediaMetadataRetriever mockMediaMetadataRetriever;
@@ -84,10 +86,10 @@ public void onDestroy_withBlurLastVideoFrameTaskFinished_shouldNotCancelTask() t
         verify(mockBlurLastVideoFrameTask, never()).cancel(anyBoolean());
     }
 
-
-    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1)
     @Test
+    @Config(shadows = {MoPubShadowMediaPlayer.class})
     public void retryMediaPlayer_withVideoFilePermissionErrorAndBelowJellyBean_shouldReturnTrue() throws Exception {
+        TestSdkHelper.setReportedSdkLevel(Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1);
         File file = new File("disk_video_path");
         file.createNewFile();
 
@@ -99,9 +101,10 @@ public void retryMediaPlayer_withVideoFilePermissionErrorAndBelowJellyBean_shoul
         file.delete();
     }
 
-    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1)
     @Test
+    @Config(shadows = {MoPubShadowMediaPlayer.class})
     public void retryMediaPlayer_shouldNotRunMoreThanOnce() throws Exception {
+        TestSdkHelper.setReportedSdkLevel(Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1);
         File file = new File("disk_video_path");
         file.createNewFile();
 
@@ -117,9 +120,10 @@ public void retryMediaPlayer_shouldNotRunMoreThanOnce() throws Exception {
         file.delete();
     }
 
-    @Config(reportSdk = Build.VERSION_CODES.JELLY_BEAN)
+    @Config(sdk= Build.VERSION_CODES.JELLY_BEAN)
     @Test
     public void retryMediaPlayer_withAndroidVersionAboveJellyBean_shouldReturnFalse() throws Exception {
+        TestSdkHelper.setReportedSdkLevel(Build.VERSION_CODES.JELLY_BEAN);
         File file = new File("disk_video_path");
         file.createNewFile();
 
@@ -131,9 +135,9 @@ public void retryMediaPlayer_withAndroidVersionAboveJellyBean_shouldReturnFalse(
         file.delete();
     }
 
-    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void retryMediaPlayer_withOtherVideoError_shouldReturnFalse() throws Exception {
+        TestSdkHelper.setReportedSdkLevel(Build.VERSION_CODES.ICE_CREAM_SANDWICH);
         File file = new File("disk_video_path");
         file.createNewFile();
 
@@ -145,9 +149,9 @@ public void retryMediaPlayer_withOtherVideoError_shouldReturnFalse() throws Exce
         file.delete();
     }
 
-    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void retryMediaPlayer_withExceptionThrown_shouldReturnFalseAndIncrementRetryCount() throws Exception {
+        TestSdkHelper.setReportedSdkLevel(Build.VERSION_CODES.ICE_CREAM_SANDWICH);
         File file = new File("disk_video_path");
         if (file.exists()) {
             assertThat(file.delete()).isTrue();
@@ -159,9 +163,11 @@ public void retryMediaPlayer_withExceptionThrown_shouldReturnFalseAndIncrementRe
         assertThat(subject.getVideoRetries()).isEqualTo(1);
     }
 
-    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1)
     @Test
+    @Config(shadows = {MoPubShadowMediaPlayer.class})
     public void onResume_shouldResetVideoRetryCountToZero() throws Exception {
+        TestSdkHelper.setReportedSdkLevel(Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1);
+
         File file = new File("disk_video_path");
         file.createNewFile();
 
@@ -175,17 +181,17 @@ public void onResume_shouldResetVideoRetryCountToZero() throws Exception {
         file.delete();
     }
 
-    @Config(reportSdk = Build.VERSION_CODES.GINGERBREAD)
     @Test
     public void createMediaMetadataRetriever_beforeGingerbreadMr1_shouldReturnNull() throws Exception {
+        TestSdkHelper.setReportedSdkLevel(Build.VERSION_CODES.GINGERBREAD);
         MediaMetadataRetriever mediaMetadataRetriever = subject.createMediaMetadataRetriever();
 
         assertThat(mediaMetadataRetriever).isNull();
     }
 
-    @Config(reportSdk = Build.VERSION_CODES.GINGERBREAD_MR1)
     @Test
     public void createMediaMetadataRetriever_atLeastGingerbreadMr1_shouldReturnNewMediaMetadataRetriever() throws Exception {
+        TestSdkHelper.setReportedSdkLevel(Build.VERSION_CODES.GINGERBREAD_MR1);
         MediaMetadataRetriever mediaMetadataRetriever = subject.createMediaMetadataRetriever();
 
         assertThat(mediaMetadataRetriever).isNotNull();
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastWebViewTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastWebViewTest.java
index 3ee435f1..c103d26d 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastWebViewTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastWebViewTest.java
@@ -7,6 +7,7 @@
 import android.webkit.WebSettings;
 import android.webkit.WebView;
 
+import com.mopub.TestSdkHelper;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.mobileads.test.support.GestureUtils;
 import com.mopub.mobileads.test.support.VastUtils;
@@ -16,15 +17,16 @@
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.robolectric.Robolectric;
+import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowWebView;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.verify;
-import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class VastWebViewTest {
 
     private VastWebView subject;
@@ -41,11 +43,11 @@ public void setup() {
 
     @Test
     public void constructor_shouldSetOnTouchListener() throws Exception {
-        assertThat(Robolectric.shadowOf(subject).getOnTouchListener())
+        assertThat(Shadows.shadowOf(subject).getOnTouchListener())
                 .isInstanceOf(VastWebView.VastWebViewOnTouchListener.class);
     }
 
-    @Config(reportSdk = Build.VERSION_CODES.JELLY_BEAN_MR2)
+    @Config(sdk = Build.VERSION_CODES.JELLY_BEAN_MR2)
     @Test
     public void pluginState_atLeastJellybeanMr2_shouldDefaultToOff_shouldNeverBeEnabled()  {
         subject = new VastWebView(Robolectric.buildActivity(Activity.class).create().get());
@@ -55,10 +57,10 @@ public void pluginState_atLeastJellybeanMr2_shouldDefaultToOff_shouldNeverBeEnab
         assertThat(subject.getSettings().getPluginState()).isEqualTo(WebSettings.PluginState.OFF);
     }
 
-    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void pluginState_atLeastIcsButBelowJellybeanMr2_shouldDefaultToOn_shouldAllowToggling() {
-        subject = new VastWebView(Robolectric.buildActivity(Activity.class).create().get());
+        TestSdkHelper.setReportedSdkLevel(Build.VERSION_CODES.ICE_CREAM_SANDWICH);
+        subject = new VastWebView(context);
         assertThat(subject.getSettings().getPluginState()).isEqualTo(WebSettings.PluginState.ON);
 
         subject.enablePlugins(false);
@@ -68,10 +70,10 @@ public void pluginState_atLeastIcsButBelowJellybeanMr2_shouldDefaultToOn_shouldA
         assertThat(subject.getSettings().getPluginState()).isEqualTo(WebSettings.PluginState.ON);
     }
 
-    @Config(reportSdk = Build.VERSION_CODES.GINGERBREAD_MR1)
     @Test
     public void pluginState_beforeIcs_shouldDefaultToOff_shouldAllowToggling() {
-        subject = new VastWebView(Robolectric.buildActivity(Activity.class).create().get());
+        TestSdkHelper.setReportedSdkLevel(Build.VERSION_CODES.GINGERBREAD_MR1);
+        subject = new VastWebView(context);
         assertThat(subject.getSettings().getPluginState()).isEqualTo(WebSettings.PluginState.OFF);
 
         subject.enablePlugins(true);
@@ -87,7 +89,7 @@ public void loadData_shouldCallLoadDataWithBaseURL() throws Exception {
         subject.loadData(data);
 
         ShadowWebView.LoadDataWithBaseURL lastLoadData
-                = shadowOf(subject).getLastLoadDataWithBaseURL();
+                = Shadows.shadowOf(subject).getLastLoadDataWithBaseURL();
         assertThat(lastLoadData.baseUrl).isEqualTo("http://ads.mopub.com/");
         assertThat(lastLoadData.data).isEqualTo(data);
         assertThat(lastLoadData.mimeType).isEqualTo("text/html");
@@ -97,7 +99,7 @@ public void loadData_shouldCallLoadDataWithBaseURL() throws Exception {
 
     @Test
     public void VastWebViewOnTouchListener_withActionDown_withActionUp_shouldCallOnVastWebViewClick() throws Exception {
-        View.OnTouchListener onTouchListener = shadowOf(subject).getOnTouchListener();
+        View.OnTouchListener onTouchListener = Shadows.shadowOf(subject).getOnTouchListener();
         onTouchListener.onTouch(subject, GestureUtils.createActionDown(0, 0));
         onTouchListener.onTouch(subject, GestureUtils.createActionUp(0, 0));
 
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastWrapperXmlManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastWrapperXmlManagerTest.java
index 2d8d1aa4..887fd533 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastWrapperXmlManagerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastWrapperXmlManagerTest.java
@@ -4,12 +4,14 @@
 
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
 import org.w3c.dom.Node;
 
 import static com.mopub.mobileads.test.support.VastUtils.createNode;
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class VastWrapperXmlManagerTest {
 
     private VastWrapperXmlManager subject;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastXmlManagerAggregatorTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastXmlManagerAggregatorTest.java
index 46f1bc31..21870e61 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastXmlManagerAggregatorTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastXmlManagerAggregatorTest.java
@@ -25,6 +25,7 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
+import java.util.Map;
 import java.util.concurrent.Semaphore;
 
 import static com.mopub.common.VolleyRequestMatcher.isUrl;
@@ -38,8 +39,8 @@
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.Mockito.when;
 
-@Config(shadows = {ShadowMoPubHttpUrlConnection.class})
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class, shadows = {ShadowMoPubHttpUrlConnection.class})
 public class VastXmlManagerAggregatorTest {
     static final String TEST_VAST_XML_STRING = "<VAST version='2.0'>" +
             "    <Ad id='empty'>" +
@@ -112,6 +113,15 @@
             "                    </CompanionAds>" +
             "                </Creative>" +
             "            </Creatives>" +
+            "            <Extensions>" +
+            "                <Extension type=\"MoPub\">" +
+            "                    <MoPubViewabilityTracker" +
+            "                            viewablePlaytime=\"2.5\"" +
+            "                            percentViewable=\"50%\">" +
+            "                        <![CDATA[http://ad.server.com/impression/dot.gif]]>" +
+            "                    </MoPubViewabilityTracker>" +
+            "                </Extension>" +
+            "            </Extensions>" +
             "            <Error><![CDATA[http://wrapperErrorOne?errorcode=[ERRORCODE]]]></Error>" +
             "            <Error><![CDATA[http://wrapperErrorTwo?errorcode=[ERRORCODE]]]></Error>" +
             "        </Wrapper>" +
@@ -184,6 +194,48 @@
             "                            <CompanionClickTracking><![CDATA[http://companionClickTracking1]]></CompanionClickTracking>" +
             "                            <CompanionClickTracking><![CDATA[http://companionClickTracking2]]></CompanionClickTracking>" +
             "                        </Companion>" +
+            "                        <Companion id=\"valid\" height=\"10000\" width=\"10000\">" +
+            "                            <HTMLResource>" +
+            "                                <![CDATA[" +
+            "                                    <link rel=\"stylesheet\" href=\"https://ton.twimg.com/exchange-media/staging/video_companions_style-29c86cb8e4193a6c4da8.css\">" +
+            "                                    <div class=\"tweet_wrapper\">" +
+            "                                    <div class=\"tweet\">" +
+            "                                    <img class=\"icon\" src=\"https://pbs.twimg.com/profile_images/641346383606235136/XLhN-zvk_reasonably_small.jpg\"/>" +
+            "                                    <span class=\"title\">Frappuccino</span>" +
+            "                                    <span id=\"tweet_text\" class=\"tweet-text\">" +
+            "                                    " +
+            "                                    The best use of your Frappuccino cup is to hold your Frappuccino. The second best is to hold your terrarium. \uD83C\uDF35☀️" +
+            "                                    </span>" +
+            "                                    </div>" +
+            "                                    </div>" +
+            "                                ]]>" +
+            "                            </HTMLResource>" +
+            "                            <TrackingEvents>" +
+            "                                <Tracking event=\"creativeView\">http://myTrackingURL/firstCompanionCreativeView</Tracking>" +
+            "                            </TrackingEvents>" +
+            "                            <CompanionClickThrough>http://frappucinoCompanion.com</CompanionClickThrough>" +
+            "                        </Companion>" +
+            "                        <Companion height=\"30\" width=\"65\" adSlotID=\"adsBy\">" +
+            "                            <HTMLResource>" +
+            "                                <![CDATA[" +
+            "                                    <link rel=\"stylesheet\" href=\"https://ton.twimg.com/exchange-media/staging/video_companions_style-29c86cb8e4193a6c4da8.css\">" +
+            "                                    <div class=\"ads-by-twitter\">" +
+            "                                    Ads by <div class=\"larry\"></div>" +
+            "                                    </div>" +
+            "                                ]]>" +
+            "                            </HTMLResource>" +
+            "                        </Companion>" +
+            "                        <Companion height=\"22\" width=\"130\" adSlotID=\"socialActions\">" +
+            "                            <HTMLResource>" +
+            "                                <![CDATA[" +
+            "                                    <link rel=\"stylesheet\" href=\"https://ton.twimg.com/exchange-media/staging/video_companions_style-29c86cb8e4193a6c4da8.css\">" +
+            "                                    <div class=\"social-actions\">" +
+            "                                    <a href=\"mopubshare://tweet?screen_name=frappuccino&tweet_id=590877845037056000\" class=\"retweet-button\"><div class=\"icon\"></div>310&nbsp;</a>" +
+            "                                    <a href=\"twitter://intent/favorite?id=590877845037056000\" class=\"like-button\"><div class=\"icon\"></div>1118&nbsp;</a>" +
+            "                                    </div>" +
+            "                                ]]>" +
+            "                            </HTMLResource>" +
+            "                        </Companion>" +
             "                    </CompanionAds>" +
             "                </Creative>" +
             "            </Creatives>" +
@@ -216,6 +268,15 @@
             "                    </Linear>" +
             "                </Creative>" +
             "            </Creatives>" +
+            "            <Extensions>" +
+            "                <Extension type=\"MoPub\">" +
+            "                    <MoPubViewabilityTracker" +
+            "                            viewablePlaytime=\"3.5\"" +
+            "                            percentViewable=\"70%\">" +
+            "                        <![CDATA[http://ad.server.com/impression/dot.png]]>" +
+            "                    </MoPubViewabilityTracker>" +
+            "                </Extension>" +
+            "            </Extensions>" +
             "        </InLine>" +
             "    </Ad>" +
             "</VAST>";
@@ -495,7 +556,7 @@ public void getBestMediaFileUrl_withInvalidMediaTypeAndNullMediaType_shouldRetur
     @Test
     public void getBestCompanionAd_shouldReturnCompanionAd() throws Exception {
         final VastCompanionAdXmlManager companionXmlManager = initializeCompanionXmlManagerMock(
-                300, 250, "image_url", "image/jpeg", null, null);
+                300, 250, "image_url", "image/jpeg", null, null, null);
 
         final VastCompanionAdConfig bestCompanionAd =
                 subject.getBestCompanionAd(Arrays.asList(companionXmlManager),
@@ -506,7 +567,7 @@ public void getBestCompanionAd_shouldReturnCompanionAd() throws Exception {
     @Test
     public void getBestCompanionAd_withInvalidVastResource_shouldReturnNull() throws Exception {
         final VastCompanionAdXmlManager companionXmlManager = initializeCompanionXmlManagerMock(
-                300, 250, "image_url", "image/INVALID", null, null);
+                300, 250, "image_url", "image/INVALID", null, null, null);
 
         final VastCompanionAdConfig bestCompanionAd =
                 subject.getBestCompanionAd(Arrays.asList(companionXmlManager),
@@ -517,7 +578,7 @@ public void getBestCompanionAd_withInvalidVastResource_shouldReturnNull() throws
     @Test
     public void getBestCompanionAd_withNullDimension_shouldReturnNull() throws Exception {
         final VastCompanionAdXmlManager companionXmlManager =
-                initializeCompanionXmlManagerMock(null, 250, "image_url", "image/png", null, null);
+                initializeCompanionXmlManagerMock(null, 250, "image_url", "image/png", null, null, null);
 
         final VastCompanionAdConfig bestCompanionAd = subject.getBestCompanionAd(
                 Arrays.asList(companionXmlManager),
@@ -528,7 +589,7 @@ public void getBestCompanionAd_withNullDimension_shouldReturnNull() throws Excep
     @Test
     public void getBestCompanionAd_withWidthTooSmall_shouldReturnNull() throws Exception {
         final VastCompanionAdXmlManager companionXmlManager =
-                initializeCompanionXmlManagerMock(299, 250, "image_url", "image/png", null, null);
+                initializeCompanionXmlManagerMock(299, 250, "image_url", "image/png", null, null, null);
 
         final VastCompanionAdConfig bestCompanionAd = subject.getBestCompanionAd(
                 Arrays.asList(companionXmlManager),
@@ -539,7 +600,7 @@ public void getBestCompanionAd_withWidthTooSmall_shouldReturnNull() throws Excep
     @Test
     public void getBestCompanionAd_withHeightTooSmall_shouldReturnNull() throws Exception {
         final VastCompanionAdXmlManager companionXmlManager =
-                initializeCompanionXmlManagerMock(300, 249, "image_url", "image/png", null, null);
+                initializeCompanionXmlManagerMock(300, 249, "image_url", "image/png", null, null, null);
 
         final VastCompanionAdConfig bestCompanionAd = subject.getBestCompanionAd(
                 Arrays.asList(companionXmlManager),
@@ -556,10 +617,10 @@ public void getBestCompanionAd_withSameAspectRatios_shouldReturnCompanionAdWithA
 
         // Triple screen size
         final VastCompanionAdXmlManager companionXmlManager1 =
-                initializeCompanionXmlManagerMock(2400, 1440, "image_url1", "image/png", null, null);
+                initializeCompanionXmlManagerMock(2400, 1440, "image_url1", "image/png", null, null, null);
         // Double screen size
         final VastCompanionAdXmlManager companionXmlManager2 =
-                initializeCompanionXmlManagerMock(1600, 960, "image_url2", "image/bmp", null, null);
+                initializeCompanionXmlManagerMock(1600, 960, "image_url2", "image/bmp", null, null, null);
 
         VastCompanionAdConfig bestCompanionAd = subject.getBestCompanionAd(
                 Arrays.asList(companionXmlManager1, companionXmlManager2),
@@ -576,10 +637,10 @@ public void getBestCompanionAd_withSameAspectRatios_shouldReturnCompanionAdWithA
 
         // Triple screen size
         final VastCompanionAdXmlManager companionXmlManager1 =
-                initializeCompanionXmlManagerMock(2400, 1440, "image_url1", "image/png", null, null);
+                initializeCompanionXmlManagerMock(2400, 1440, "image_url1", "image/png", null, null, null);
         // Half screen size
         final VastCompanionAdXmlManager companionXmlManager2 =
-                initializeCompanionXmlManagerMock(400, 250, "image_url2", "image/bmp", null, null);
+                initializeCompanionXmlManagerMock(400, 250, "image_url2", "image/bmp", null, null, null);
 
         VastCompanionAdConfig bestCompanionAd = subject.getBestCompanionAd(
                 Arrays.asList(companionXmlManager1, companionXmlManager2),
@@ -596,10 +657,10 @@ public void getBestCompanionAd_withSameArea_shouldReturnLandscapeCompanionAdWith
 
         // Landscape
         final VastCompanionAdXmlManager companionXmlManager1 =
-                initializeCompanionXmlManagerMock(400, 250, "image_url1", "image/png", null, null);
+                initializeCompanionXmlManagerMock(400, 250, "image_url1", "image/png", null, null, null);
         // Portrait
         final VastCompanionAdXmlManager companionXmlManager2 =
-                initializeCompanionXmlManagerMock(250, 400, "image_url2", "image/bmp", null, null);
+                initializeCompanionXmlManagerMock(250, 400, "image_url2", "image/bmp", null, null, null);
 
         VastCompanionAdConfig bestCompanionAd = subject.getBestCompanionAd(
                 Arrays.asList(companionXmlManager1, companionXmlManager2),
@@ -616,10 +677,10 @@ public void getBestCompanionAd_withSameArea_shouldReturnPortraitCompanionAdWithA
 
         // Landscape
         final VastCompanionAdXmlManager companionXmlManager1 =
-                initializeCompanionXmlManagerMock(400, 300, "image_url1", "image/png", null, null);
+                initializeCompanionXmlManagerMock(400, 300, "image_url1", "image/png", null, null, null);
         // Portrait
         final VastCompanionAdXmlManager companionXmlManager2 =
-                initializeCompanionXmlManagerMock(300, 400, "image_url2", "image/bmp", null, null);
+                initializeCompanionXmlManagerMock(300, 400, "image_url2", "image/bmp", null, null, null);
 
         VastCompanionAdConfig bestCompanionAd = subject.getBestCompanionAd(
                 Arrays.asList(companionXmlManager1, companionXmlManager2),
@@ -632,13 +693,13 @@ public void getBestCompanionAd_withAllThreeResourceTypes_shouldReturnStaticResou
         // Static Resource
         final VastCompanionAdXmlManager companionXmlManager1 =
                 initializeCompanionXmlManagerMock(400, 250, "StaticResource", "image/png", null,
-                        null);
+                        null, null);
         // HTML Resource
         final VastCompanionAdXmlManager companionXmlManager2 =
-                initializeCompanionXmlManagerMock(250, 400, null, null, null, "HTMLResource");
+                initializeCompanionXmlManagerMock(250, 400, null, null, null, "HTMLResource", null);
         // IFrame Resource
         final VastCompanionAdXmlManager companionXmlManager3 =
-                initializeCompanionXmlManagerMock(250, 400, null, null, "IFrameResource", null);
+                initializeCompanionXmlManagerMock(250, 400, null, null, "IFrameResource", null, null);
 
         VastCompanionAdConfig bestCompanionAd = subject.getBestCompanionAd(
                 Arrays.asList(companionXmlManager3, companionXmlManager2, companionXmlManager1),
@@ -650,10 +711,10 @@ public void getBestCompanionAd_withAllThreeResourceTypes_shouldReturnStaticResou
     public void getBestCompanionAd_withHTMLAndStaticResourceTypes_shouldReturnStaticResourceType() throws Exception {
         // Static Resource
         final VastCompanionAdXmlManager companionXmlManager1 =
-                initializeCompanionXmlManagerMock(400, 250, "StaticResource", "image/png", null, null);
+                initializeCompanionXmlManagerMock(400, 250, "StaticResource", "image/png", null, null, null);
         // HTML Resource
         final VastCompanionAdXmlManager companionXmlManager2 =
-                initializeCompanionXmlManagerMock(250, 400, null, null, null, "HTMLResource");
+                initializeCompanionXmlManagerMock(250, 400, null, null, null, "HTMLResource", null);
 
         VastCompanionAdConfig bestCompanionAd = subject.getBestCompanionAd(
                 Arrays.asList(companionXmlManager2, companionXmlManager1),
@@ -665,9 +726,9 @@ public void getBestCompanionAd_withHTMLAndStaticResourceTypes_shouldReturnStatic
     public void getBestCompanionAd_withInvalidStaticResource_withValidHtmlResource_shouldReturnHtmlResource() throws Exception {
         final VastCompanionAdXmlManager companionXmlManager1 =
                 initializeCompanionXmlManagerMock(400, 250, "StaticResource", "INVALID",
-                        "IFrameResource", null);
+                        "IFrameResource", null, null);
         final VastCompanionAdXmlManager companionXmlManager2 =
-                initializeCompanionXmlManagerMock(300, 400, null, null, null, "HTMLResource");
+                initializeCompanionXmlManagerMock(300, 400, null, null, null, "HTMLResource", null);
 
         VastCompanionAdConfig bestCompanionAd = subject.getBestCompanionAd(
                 Arrays.asList(companionXmlManager2, companionXmlManager1),
@@ -685,9 +746,9 @@ public void getBestCompanionAd_withCompanionAdTooSmall_shouldReturnCompanionAdWi
         // 305 x 305 is both fewer pixels (screen area) and a worse aspect ratio. It still should be
         // chosen because 240 is not wide enough to be considered for a companion ad
         final VastCompanionAdXmlManager companionXmlManager1 =
-                initializeCompanionXmlManagerMock(305, 305, "image_url1", "image/png", null, null);
+                initializeCompanionXmlManagerMock(305, 305, "image_url1", "image/png", null, null, null);
         final VastCompanionAdXmlManager companionXmlManager2 =
-                initializeCompanionXmlManagerMock(240, 400, "image_url2", "image/bmp", null, null);
+                initializeCompanionXmlManagerMock(240, 400, "image_url2", "image/bmp", null, null, null);
 
         VastCompanionAdConfig bestCompanionAd = subject.getBestCompanionAd(
                 Arrays.asList(companionXmlManager1, companionXmlManager2),
@@ -696,73 +757,493 @@ public void getBestCompanionAd_withCompanionAdTooSmall_shouldReturnCompanionAdWi
     }
 
     @Test
-    public void getScaledDimensions_withWidthLargerThanScreen_shouldScaleWidthAndHeight() throws Exception {
+    public void getSocialActionsCompanionAds_shouldReturnSocialActionsCompanionAds() throws Exception {
+        final VastCompanionAdXmlManager adsByXmlManager =
+                initializeCompanionXmlManagerMock(65, 20, null, "HTMLResource", null,
+                        "<p>Ads by</p>", "adsBy");
+        final VastCompanionAdXmlManager socialActionsXmlManager =
+                initializeCompanionXmlManagerMock(130, 30, null, "HTMLResource", null,
+                        "<p>Retweet Like</p>", "socialActions");
+
+        final Map<String, VastCompanionAdConfig> socialActionsCompanionAds =
+                subject.getSocialActionsCompanionAds(
+                        Arrays.asList(adsByXmlManager, socialActionsXmlManager));
+        final VastCompanionAdConfig adsByVastConfig = socialActionsCompanionAds.get("adsBy");
+        final VastCompanionAdConfig socialActionsVastConfig = socialActionsCompanionAds
+                .get("socialActions");
+
+        assertThat(adsByVastConfig.getWidth()).isEqualTo(65);
+        assertThat(adsByVastConfig.getHeight()).isEqualTo(20);
+        assertThat(adsByVastConfig.getVastResource().getResource()).isEqualTo("<p>Ads by</p>");
+        assertThat(socialActionsVastConfig.getWidth()).isEqualTo(130);
+        assertThat(socialActionsVastConfig.getHeight()).isEqualTo(30);
+        assertThat(socialActionsVastConfig.getVastResource().getResource())
+                .isEqualTo("<p>Retweet Like</p>");
+    }
+
+    @Test
+    public void getSocialActionsCompanionAds_withoutSocialActions_shouldNotReturnSocialActionsCompanionAds() throws Exception {
+        final VastCompanionAdXmlManager adsByXmlManager =
+                initializeCompanionXmlManagerMock(65, 20, null, "HTMLResource", null,
+                        "<p>Ads by</p>", "NOTadsBy");
+        final VastCompanionAdXmlManager socialActionsXmlManager =
+                initializeCompanionXmlManagerMock(130, 30, null, "HTMLResource", null,
+                        "<p>Retweet Like</p>", "NOTsocialActions");
+
+        final Map<String, VastCompanionAdConfig> socialActionsCompanionAds =
+                subject.getSocialActionsCompanionAds(
+                        Arrays.asList(adsByXmlManager, socialActionsXmlManager));
+
+        assertThat(socialActionsCompanionAds.size()).isEqualTo(0);
+    }
+
+    @Test
+    public void getSocialActionsCompanionAds_withoutHTMLResource_shouldNotReturnSocialActionsCompanionAds() throws Exception {
+        final VastCompanionAdXmlManager adsByXmlManager =
+                initializeCompanionXmlManagerMock(65, 20, null, "HTMLResource", null, null,
+                        "adsBy");
+        final VastCompanionAdXmlManager socialActionsXmlManager =
+                initializeCompanionXmlManagerMock(130, 30, null, "HTMLResource", null,
+                        null, "socialActions");
+
+        final Map<String, VastCompanionAdConfig> socialActionsCompanionAds =
+                subject.getSocialActionsCompanionAds(
+                        Arrays.asList(adsByXmlManager, socialActionsXmlManager));
+        final VastCompanionAdConfig adsByVastConfig = socialActionsCompanionAds.get("adsBy");
+        final VastCompanionAdConfig socialActionsVastConfig = socialActionsCompanionAds
+                .get("socialActions");
+
+        assertThat(socialActionsCompanionAds.size()).isEqualTo(0);
+    }
+
+    @Test
+    public void getSocialActionsCompanionAds_whenTooWide_shouldNotReturnSocialActionsCompanionAds() throws Exception {
+        final VastCompanionAdXmlManager adsByXmlManager =
+                initializeCompanionXmlManagerMock(76, 20, null, "HTMLResource", null,
+                        "<p>Ads by</p>", "adsBy");
+        final VastCompanionAdXmlManager socialActionsXmlManager =
+                initializeCompanionXmlManagerMock(151, 30, null, "HTMLResource", null,
+                        "<p>Retweet Like</p>", "socialActions");
+
+        final Map<String, VastCompanionAdConfig> socialActionsCompanionAds =
+                subject.getSocialActionsCompanionAds(
+                        Arrays.asList(adsByXmlManager, socialActionsXmlManager));
+
+        assertThat(socialActionsCompanionAds.size()).isEqualTo(0);
+    }
+
+    @Test
+    public void getSocialActionsCompanionAds_whenTooTall_shouldNotReturnSocialActionsCompanionAds() throws Exception {
+        final VastCompanionAdXmlManager adsByXmlManager =
+                initializeCompanionXmlManagerMock(65, 51, null, "HTMLResource", null,
+                        "<p>Ads by</p>", "adsBy");
+        final VastCompanionAdXmlManager socialActionsXmlManager =
+                initializeCompanionXmlManagerMock(130, 51, null, "HTMLResource", null,
+                        "<p>Retweet Like</p>", "socialActions");
+
+        final Map<String, VastCompanionAdConfig> socialActionsCompanionAds =
+                subject.getSocialActionsCompanionAds(
+                        Arrays.asList(adsByXmlManager, socialActionsXmlManager));
+
+        assertThat(socialActionsCompanionAds.size()).isEqualTo(0);
+    }
+
+    @Test
+    public void evaluateVastXmlManager_withSocialActions_shouldKeepSocialActionsFromInLineAndNotOverwriteFromWrapper() throws Exception {
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, TEST_NESTED_VAST_XML_STRING);
+        VastVideoConfig vastVideoConfig = subject.evaluateVastXmlManager(
+                TEST_VAST_XML_STRING, new ArrayList<VastTracker>());
+
+        VastCompanionAdConfig adsByCompanionAd = vastVideoConfig.getSocialActionsCompanionAds()
+                .get(VastXmlManagerAggregator.ADS_BY_AD_SLOT_ID);
+        assertThat(adsByCompanionAd.getVastResource().getType())
+                .isEqualTo(VastResource.Type.HTML_RESOURCE);
+        assertThat(adsByCompanionAd.getVastResource().getResource().trim())
+                .isEqualTo(
+                        "<link rel=\"stylesheet\" href=\"https://ton.twimg.com/exchange-media/staging/video_companions_style-29c86cb8e4193a6c4da8.css\">" +
+                                "                                    <div class=\"ads-by-twitter\">" +
+                                "                                    Ads by <div class=\"larry\"></div>" +
+                                "                                    </div>");
+        VastCompanionAdConfig socialActionsCompanionAd = vastVideoConfig
+                .getSocialActionsCompanionAds()
+                .get(VastXmlManagerAggregator.SOCIAL_ACTIONS_AD_SLOT_ID);
+        assertThat(socialActionsCompanionAd.getVastResource()
+                .getType()).isEqualTo(VastResource.Type.HTML_RESOURCE);
+        assertThat(socialActionsCompanionAd.getVastResource().getResource().trim())
+        .isEqualTo("<link rel=\"stylesheet\" href=\"https://ton.twimg.com/exchange-media/staging/video_companions_style-29c86cb8e4193a6c4da8.css\">" +
+                "                                    <div class=\"social-actions\">" +
+                "                                    <a href=\"mopubshare://tweet?screen_name=frappuccino&tweet_id=590877845037056000\" class=\"retweet-button\"><div class=\"icon\"></div>310&nbsp;</a>" +
+                "                                    <a href=\"twitter://intent/favorite?id=590877845037056000\" class=\"like-button\"><div class=\"icon\"></div>1118&nbsp;</a>" +
+                "                                    </div>");
+    }
+
+    @Test
+    public void
+    getScaledDimensions_withStaticResource_withWidthLargerThanScreen_shouldScaleWidthAndHeight() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        // Width and height are evaluated in landscape
+        Point landscapePoint = subject.getScaledDimensions(1600, 400,
+                VastResource.Type.STATIC_RESOURCE,
+                VastXmlManagerAggregator.CompanionOrientation.LANDSCAPE);
+        assertThat(landscapePoint.x).isEqualTo(800 - VastVideoViewController.WEBVIEW_PADDING);
+        assertThat(landscapePoint.y).isEqualTo(200 - VastVideoViewController.WEBVIEW_PADDING);
+
+        // Width and height are evaluated in portrait
+        Point portraitPoint = subject.getScaledDimensions(960, 600,
+                VastResource.Type.STATIC_RESOURCE,
+                VastXmlManagerAggregator.CompanionOrientation.PORTRAIT);
+        assertThat(portraitPoint.x).isEqualTo(480 - VastVideoViewController.WEBVIEW_PADDING);
+        assertThat(portraitPoint.y).isEqualTo(300 - VastVideoViewController.WEBVIEW_PADDING);
+    }
+
+    @Test
+    public void getScaledDimensions_withStaticResource_withHeightLargerThanScreen_shouldScaleWidthAndHeight() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        // Width and height are evaluated in landscape
+        Point landscapePoint = subject.getScaledDimensions(400, 960,
+                VastResource.Type.STATIC_RESOURCE,
+                VastXmlManagerAggregator.CompanionOrientation.LANDSCAPE);
+        assertThat(landscapePoint.x).isEqualTo(200 - VastVideoViewController.WEBVIEW_PADDING);
+        assertThat(landscapePoint.y).isEqualTo(480 - VastVideoViewController.WEBVIEW_PADDING);
+
+        // Width and height are evaluated in portrait
+        Point portraitPoint = subject.getScaledDimensions(400, 1600,
+                VastResource.Type.STATIC_RESOURCE,
+                VastXmlManagerAggregator.CompanionOrientation.PORTRAIT);
+        assertThat(portraitPoint.x).isEqualTo(200 - VastVideoViewController.WEBVIEW_PADDING);
+        assertThat(portraitPoint.y).isEqualTo(800 - VastVideoViewController.WEBVIEW_PADDING);
+    }
+
+    @Test
+    public void getScaledDimensions_withStaticResource_withWidthAndHeightEqualToScreen_shouldNotScaleWidthAndHeight() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        // Width and height are evaluated in landscape
+        Point landscapePoint = subject.getScaledDimensions(
+                800 - VastVideoViewController.WEBVIEW_PADDING,
+                480 - VastVideoViewController.WEBVIEW_PADDING,
+                VastResource.Type.STATIC_RESOURCE,
+                VastXmlManagerAggregator.CompanionOrientation.LANDSCAPE);
+        assertThat(landscapePoint.x).isEqualTo(800 - VastVideoViewController.WEBVIEW_PADDING);
+        assertThat(landscapePoint.y).isEqualTo(480 - VastVideoViewController.WEBVIEW_PADDING);
+
+        // Width and height are evaluated in portrait
+        Point portraitPoint = subject.getScaledDimensions(
+                480 - VastVideoViewController.WEBVIEW_PADDING,
+                800 - VastVideoViewController.WEBVIEW_PADDING,
+                VastResource.Type.STATIC_RESOURCE,
+                VastXmlManagerAggregator.CompanionOrientation.PORTRAIT);
+        assertThat(portraitPoint.x).isEqualTo(480 - VastVideoViewController.WEBVIEW_PADDING);
+        assertThat(portraitPoint.y).isEqualTo(800 - VastVideoViewController.WEBVIEW_PADDING);
+    }
+
+    @Test
+    public void getScaledDimensions_withStaticResource_withWidthAdjustedToLessThanZero_shouldNotScaleWidthAndHeight() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(
+                Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        // Width and height are evaluated in landscape
+        Point landscapePoint = subject.getScaledDimensions(1600, 2,
+                VastResource.Type.STATIC_RESOURCE,
+                VastXmlManagerAggregator.CompanionOrientation.LANDSCAPE);
+        assertThat(landscapePoint.x).isEqualTo(1600);
+        assertThat(landscapePoint.y).isEqualTo(2);
+
+        // Width and height are evaluated in portrait
+        Point portraitPoint = subject.getScaledDimensions(1600, 2,
+                VastResource.Type.STATIC_RESOURCE,
+                VastXmlManagerAggregator.CompanionOrientation.PORTRAIT);
+        assertThat(portraitPoint.x).isEqualTo(1600);
+        assertThat(portraitPoint.y).isEqualTo(2);
+    }
+
+    @Test
+    public void getScaledDimensions_withStaticResource_withHeightAdjustedToLessThanZero_shouldNotScaleWidthAndHeight() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        // Width and height are evaluated in landscape
+        Point landscapePoint = subject.getScaledDimensions(2, 960,
+                VastResource.Type.STATIC_RESOURCE,
+                VastXmlManagerAggregator.CompanionOrientation.LANDSCAPE);
+        assertThat(landscapePoint.x).isEqualTo(2);
+        assertThat(landscapePoint.y).isEqualTo(960);
+
+        // Width and height are evaluated in portrait
+        Point portraitPoint = subject.getScaledDimensions(2, 960,
+                VastResource.Type.STATIC_RESOURCE,
+                VastXmlManagerAggregator.CompanionOrientation.PORTRAIT);
+        assertThat(portraitPoint.x).isEqualTo(2);
+        assertThat(portraitPoint.y).isEqualTo(960);
+    }
+
+    @Test
+    public void getScaledDimensions_withHTMLResource_withWidthLargerThanScreen_shouldScaleWidthAndHeight()
+            throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        // Width and height are evaluated in landscape
+        Point landscapePoint = subject.getScaledDimensions(1600, 400,
+                VastResource.Type.HTML_RESOURCE,
+                VastXmlManagerAggregator.CompanionOrientation.LANDSCAPE);
+        assertThat(landscapePoint.x).isEqualTo(800 - VastVideoViewController.WEBVIEW_PADDING);
+        assertThat(landscapePoint.y).isEqualTo(400 - VastVideoViewController.WEBVIEW_PADDING);
+
+        // Width and height are evaluated in portrait
+        Point portraitPoint = subject.getScaledDimensions(960, 600,
+                VastResource.Type.HTML_RESOURCE,
+                VastXmlManagerAggregator.CompanionOrientation.PORTRAIT);
+        assertThat(portraitPoint.x).isEqualTo(480 - VastVideoViewController.WEBVIEW_PADDING);
+        assertThat(portraitPoint.y).isEqualTo(600 - VastVideoViewController.WEBVIEW_PADDING);
+    }
+
+    @Test
+    public void getScaledDimensions_withHTMLResource_withHeightLargerThanScreen_shouldScaleWidthAndHeight() throws Exception {
         // Default screen width is 480, height is 800
         final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
         assertThat(display.getWidth()).isEqualTo(480);
         assertThat(display.getHeight()).isEqualTo(800);
 
         // Width and height are evaluated in landscape
-        Point point = subject.getScaledDimensions(1600, 400);
+        Point landscapePoint = subject.getScaledDimensions(400, 960,
+                VastResource.Type.HTML_RESOURCE,
+                VastXmlManagerAggregator.CompanionOrientation.LANDSCAPE);
+        assertThat(landscapePoint.x).isEqualTo(400 - VastVideoViewController.WEBVIEW_PADDING);
+        assertThat(landscapePoint.y).isEqualTo(480 - VastVideoViewController.WEBVIEW_PADDING);
+
+        // Width and height are evaluated in portrait
+        Point portraitPoint = subject.getScaledDimensions(400, 1600,
+                VastResource.Type.HTML_RESOURCE,
+                VastXmlManagerAggregator.CompanionOrientation.PORTRAIT);
+        assertThat(portraitPoint.x).isEqualTo(400 - VastVideoViewController.WEBVIEW_PADDING);
+        assertThat(portraitPoint.y).isEqualTo(800 - VastVideoViewController.WEBVIEW_PADDING);
+    }
+
+    @Test
+    public void getScaledDimensions_withHTMLResource_withWidthAdjustedToLessThanZero_shouldNotScaleWidthAndHeight() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(
+                Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        // Width and height are evaluated in landscape
+        Point landscapePoint = subject.getScaledDimensions(1600, 2,
+                VastResource.Type.HTML_RESOURCE,
+                VastXmlManagerAggregator.CompanionOrientation.LANDSCAPE);
+        assertThat(landscapePoint.x).isEqualTo(1600);
+        assertThat(landscapePoint.y).isEqualTo(2);
 
-        assertThat(point.x).isEqualTo(800 - VastVideoViewController.WEBVIEW_PADDING);
-        assertThat(point.y).isEqualTo(200 - VastVideoViewController.WEBVIEW_PADDING);
+        // Width and height are evaluated in portrait
+        Point portraitPoint = subject.getScaledDimensions(1600, 2,
+                VastResource.Type.HTML_RESOURCE,
+                VastXmlManagerAggregator.CompanionOrientation.PORTRAIT);
+        assertThat(portraitPoint.x).isEqualTo(1600);
+        assertThat(portraitPoint.y).isEqualTo(2);
     }
 
     @Test
-    public void getScaledDimensions_withHeightLargerThanScreen_shouldScaleWidthAndHeight() throws Exception {
+    public void getScaledDimensions_withHTMLResource_withHeightAdjustedToLessThanZero_shouldNotScaleWidthAndHeight() throws Exception {
         // Default screen width is 480, height is 800
         final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
         assertThat(display.getWidth()).isEqualTo(480);
         assertThat(display.getHeight()).isEqualTo(800);
 
         // Width and height are evaluated in landscape
-        Point point = subject.getScaledDimensions(400, 960);
+        Point landscapePoint = subject.getScaledDimensions(2, 960,
+                VastResource.Type.HTML_RESOURCE,
+                VastXmlManagerAggregator.CompanionOrientation.LANDSCAPE);
+        assertThat(landscapePoint.x).isEqualTo(2);
+        assertThat(landscapePoint.y).isEqualTo(960);
+
+        // Width and height are evaluated in portrait
+        Point portraitPoint = subject.getScaledDimensions(2, 960,
+                VastResource.Type.HTML_RESOURCE,
+                VastXmlManagerAggregator.CompanionOrientation.PORTRAIT);
+        assertThat(portraitPoint.x).isEqualTo(2);
+        assertThat(portraitPoint.y).isEqualTo(960);
+    }
+
+    @Test
+    public void getScaledDimensions_withHTMLResource_withWidthAndHeightEqualToScreen_shouldNotScaleWidthAndHeight() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
 
-        assertThat(point.x).isEqualTo(200 - VastVideoViewController.WEBVIEW_PADDING);
-        assertThat(point.y).isEqualTo(480 - VastVideoViewController.WEBVIEW_PADDING);
+        // Width and height are evaluated in landscape
+        Point landscapePoint = subject.getScaledDimensions(
+                800 - VastVideoViewController.WEBVIEW_PADDING,
+                480 - VastVideoViewController.WEBVIEW_PADDING,
+                VastResource.Type.HTML_RESOURCE,
+                VastXmlManagerAggregator.CompanionOrientation.LANDSCAPE);
+        assertThat(landscapePoint.x).isEqualTo(800 - VastVideoViewController.WEBVIEW_PADDING);
+        assertThat(landscapePoint.y).isEqualTo(480 - VastVideoViewController.WEBVIEW_PADDING);
+
+        // Width and height are evaluated in portrait
+        Point portraitPoint = subject.getScaledDimensions(
+                480 - VastVideoViewController.WEBVIEW_PADDING,
+                800 - VastVideoViewController.WEBVIEW_PADDING,
+                VastResource.Type.HTML_RESOURCE,
+                VastXmlManagerAggregator.CompanionOrientation.PORTRAIT);
+        assertThat(portraitPoint.x).isEqualTo(480 - VastVideoViewController.WEBVIEW_PADDING);
+        assertThat(portraitPoint.y).isEqualTo(800 - VastVideoViewController.WEBVIEW_PADDING);
     }
 
     @Test
-    public void getScaledDimensions_withWidthAndHeightSmallerThanScreen_shouldNotScaleWidthAndHeight() throws Exception {
+    public void getScaledDimensions_withHTMLResource_withWidthAndHeightLargerThanScreen_shouldScaleWidthAndHeight() throws Exception {
         // Default screen width is 480, height is 800
         final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
         assertThat(display.getWidth()).isEqualTo(480);
         assertThat(display.getHeight()).isEqualTo(800);
 
         // Width and height are evaluated in landscape
-        Point point = subject.getScaledDimensions(800, 480);
+        Point landscapePoint = subject.getScaledDimensions(5000, 5000,
+                VastResource.Type.HTML_RESOURCE,
+                VastXmlManagerAggregator.CompanionOrientation.LANDSCAPE);
+        assertThat(landscapePoint.x).isEqualTo(800 - VastVideoViewController.WEBVIEW_PADDING);
+        assertThat(landscapePoint.y).isEqualTo(480 - VastVideoViewController.WEBVIEW_PADDING);
 
-        assertThat(point.x).isEqualTo(800);
-        assertThat(point.y).isEqualTo(480);
+        // Width and height are evaluated in portrait
+        Point portraitPoint = subject.getScaledDimensions(1337, 4200,
+                VastResource.Type.HTML_RESOURCE,
+                VastXmlManagerAggregator.CompanionOrientation.PORTRAIT);
+        assertThat(portraitPoint.x).isEqualTo(480 - VastVideoViewController.WEBVIEW_PADDING);
+        assertThat(portraitPoint.y).isEqualTo(800 - VastVideoViewController.WEBVIEW_PADDING);
     }
 
     @Test
-    public void getScaledDimensions_withWidthAdjustedToLessThanZero_shouldNotScaleWidthAndHeight() throws Exception {
+    public void getScaledDimensions_withIFrameResource_withWidthLargerThanScreen_shouldScaleWidthAndHeight() throws Exception {
         // Default screen width is 480, height is 800
         final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
         assertThat(display.getWidth()).isEqualTo(480);
         assertThat(display.getHeight()).isEqualTo(800);
 
         // Width and height are evaluated in landscape
-        Point point = subject.getScaledDimensions(1600, 2);
+        Point landscapePoint = subject.getScaledDimensions(1600, 400,
+                VastResource.Type.IFRAME_RESOURCE,
+                VastXmlManagerAggregator.CompanionOrientation.LANDSCAPE);
+        assertThat(landscapePoint.x).isEqualTo(800 - VastVideoViewController.WEBVIEW_PADDING);
+        assertThat(landscapePoint.y).isEqualTo(200 - VastVideoViewController.WEBVIEW_PADDING);
 
-        assertThat(point.x).isEqualTo(1600);
-        assertThat(point.y).isEqualTo(2);
+        // Width and height are evaluated in portrait
+        Point portraitPoint = subject.getScaledDimensions(960, 600,
+                VastResource.Type.IFRAME_RESOURCE,
+                VastXmlManagerAggregator.CompanionOrientation.PORTRAIT);
+        assertThat(portraitPoint.x).isEqualTo(480 - VastVideoViewController.WEBVIEW_PADDING);
+        assertThat(portraitPoint.y).isEqualTo(300 - VastVideoViewController.WEBVIEW_PADDING);
     }
 
     @Test
-    public void getScaledDimensions_withHeightAdjustedToLessThanZero_shouldNotScaleWidthAndHeight() throws Exception {
+    public void getScaledDimensions_withIFrameResource_withHeightLargerThanScreen_shouldScaleWidthAndHeight() throws Exception {
         // Default screen width is 480, height is 800
         final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
         assertThat(display.getWidth()).isEqualTo(480);
         assertThat(display.getHeight()).isEqualTo(800);
 
         // Width and height are evaluated in landscape
-        Point point = subject.getScaledDimensions(2, 960);
+        Point landscapePoint = subject.getScaledDimensions(400, 960,
+                VastResource.Type.IFRAME_RESOURCE,
+                VastXmlManagerAggregator.CompanionOrientation.LANDSCAPE);
+        assertThat(landscapePoint.x).isEqualTo(200 - VastVideoViewController.WEBVIEW_PADDING);
+        assertThat(landscapePoint.y).isEqualTo(480 - VastVideoViewController.WEBVIEW_PADDING);
 
-        assertThat(point.x).isEqualTo(2);
-        assertThat(point.y).isEqualTo(960);
+        // Width and height are evaluated in portrait
+        Point portraitPoint = subject.getScaledDimensions(400, 1600,
+                VastResource.Type.IFRAME_RESOURCE,
+                VastXmlManagerAggregator.CompanionOrientation.PORTRAIT);
+        assertThat(portraitPoint.x).isEqualTo(200 - VastVideoViewController.WEBVIEW_PADDING);
+        assertThat(portraitPoint.y).isEqualTo(800 - VastVideoViewController.WEBVIEW_PADDING);
+    }
+
+    @Test
+    public void getScaledDimensions_withIFrameResource_withWidthAndHeightEqualToScreen_shouldNotScaleWidthAndHeight() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        // Width and height are evaluated in landscape
+        Point landscapePoint = subject.getScaledDimensions(
+                800 - VastVideoViewController.WEBVIEW_PADDING,
+                480 - VastVideoViewController.WEBVIEW_PADDING,
+                VastResource.Type.IFRAME_RESOURCE,
+                VastXmlManagerAggregator.CompanionOrientation.LANDSCAPE);
+        assertThat(landscapePoint.x).isEqualTo(800 - VastVideoViewController.WEBVIEW_PADDING);
+        assertThat(landscapePoint.y).isEqualTo(480 - VastVideoViewController.WEBVIEW_PADDING);
+
+        // Width and height are evaluated in portrait
+        Point portraitPoint = subject.getScaledDimensions(
+                480 - VastVideoViewController.WEBVIEW_PADDING,
+                800 - VastVideoViewController.WEBVIEW_PADDING,
+                VastResource.Type.IFRAME_RESOURCE,
+                VastXmlManagerAggregator.CompanionOrientation.PORTRAIT);
+        assertThat(portraitPoint.x).isEqualTo(480 - VastVideoViewController.WEBVIEW_PADDING);
+        assertThat(portraitPoint.y).isEqualTo(800 - VastVideoViewController.WEBVIEW_PADDING);
+    }
+
+    @Test
+    public void getScaledDimensions_withIFrameResource_withWidthAdjustedToLessThanZero_shouldNotScaleWidthAndHeight() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(
+                Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        // Width and height are evaluated in landscape
+        Point landscapePoint = subject.getScaledDimensions(1600, 2,
+                VastResource.Type.IFRAME_RESOURCE,
+                VastXmlManagerAggregator.CompanionOrientation.LANDSCAPE);
+        assertThat(landscapePoint.x).isEqualTo(1600);
+        assertThat(landscapePoint.y).isEqualTo(2);
+
+        // Width and height are evaluated in portrait
+        Point portraitPoint = subject.getScaledDimensions(1600, 2,
+                VastResource.Type.IFRAME_RESOURCE,
+                VastXmlManagerAggregator.CompanionOrientation.PORTRAIT);
+        assertThat(portraitPoint.x).isEqualTo(1600);
+        assertThat(portraitPoint.y).isEqualTo(2);
+    }
+
+    @Test
+    public void getScaledDimensions_withIFrameResource_withHeightAdjustedToLessThanZero_shouldNotScaleWidthAndHeight() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        // Width and height are evaluated in landscape
+        Point landscapePoint = subject.getScaledDimensions(2, 960,
+                VastResource.Type.IFRAME_RESOURCE,
+                VastXmlManagerAggregator.CompanionOrientation.LANDSCAPE);
+        assertThat(landscapePoint.x).isEqualTo(2);
+        assertThat(landscapePoint.y).isEqualTo(960);
+
+        // Width and height are evaluated in portrait
+        Point portraitPoint = subject.getScaledDimensions(2, 960,
+                VastResource.Type.IFRAME_RESOURCE,
+                VastXmlManagerAggregator.CompanionOrientation.PORTRAIT);
+        assertThat(portraitPoint.x).isEqualTo(2);
+        assertThat(portraitPoint.y).isEqualTo(960);
     }
 
     @Test
@@ -1094,7 +1575,8 @@ public void evaluateVastXmlManager_withInvalidXml_shouldReturnNullVastVideoConfi
 
     @Test
     public void evaluateVastXmlManager_withRedirectHavingNoCompanionAd_shouldReturnVastVideoConfigurationWithCompanionAdOfWrapper() throws Exception {
-        ShadowMoPubHttpUrlConnection.addPendingResponse(200, TEST_NESTED_NO_COMPANION_VAST_XML_STRING);
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200,
+                TEST_NESTED_NO_COMPANION_VAST_XML_STRING);
         VastVideoConfig vastVideoConfig = subject.evaluateVastXmlManager(
                 TEST_VAST_XML_STRING, new ArrayList<VastTracker>());
 
@@ -1130,6 +1612,42 @@ public void evaluateVastXmlManager_withSequenceNumbers_shouldReturnVastVideoConf
                 .containsOnly("http://negativeSequence");
     }
 
+    @Test
+    public void evaluateVastXmlManager_withVideoViewabilityTrackerInLine_shouldReturnVastVideoConfigurationWithVideoViewabilityTracker() {
+        VastVideoConfig vastVideoConfig = subject.evaluateVastXmlManager(
+                TEST_NESTED_NO_COMPANION_VAST_XML_STRING, new ArrayList<VastTracker>());
+
+        VideoViewabilityTracker tracker = vastVideoConfig.getVideoViewabilityTracker();
+        assertThat(tracker.getPercentViewable()).isEqualTo(70);
+        assertThat(tracker.getViewablePlaytimeMS()).isEqualTo(3500);
+        assertThat(tracker.getTrackingUrl()).isEqualTo("http://ad.server.com/impression/dot.png");
+    }
+
+    @Test
+    public void evaluateVastXmlManager_withVideoViewabilityTrackerInWrapper_shouldReturnVastVideoConfigurationWithVideoViewabilityTracker() throws Exception {
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, TEST_NESTED_VAST_XML_STRING);
+        VastVideoConfig vastVideoConfig = subject.evaluateVastXmlManager(TEST_VAST_XML_STRING,
+                new ArrayList<VastTracker>());
+
+        VideoViewabilityTracker tracker = vastVideoConfig.getVideoViewabilityTracker();
+        assertThat(tracker.getPercentViewable()).isEqualTo(50);
+        assertThat(tracker.getViewablePlaytimeMS()).isEqualTo(2500);
+        assertThat(tracker.getTrackingUrl()).isEqualTo("http://ad.server.com/impression/dot.gif");
+    }
+
+    @Test
+    public void evaluateVastXmlManager_withVideoViewabilityTrackerBothInWrapperAndInLine_shouldReturnVastVideoConfigurationWithVideoViewabilityTrackerFromInLine() throws Exception {
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200,
+                TEST_NESTED_NO_COMPANION_VAST_XML_STRING);
+        VastVideoConfig vastVideoConfig = subject.evaluateVastXmlManager(TEST_VAST_XML_STRING,
+                new ArrayList<VastTracker>());
+
+        VideoViewabilityTracker tracker = vastVideoConfig.getVideoViewabilityTracker();
+        assertThat(tracker.getPercentViewable()).isEqualTo(70);
+        assertThat(tracker.getViewablePlaytimeMS()).isEqualTo(3500);
+        assertThat(tracker.getTrackingUrl()).isEqualTo("http://ad.server.com/impression/dot.png");
+    }
+
     @Test
     public void isValidSequenceNumber_withNull_shouldReturnTrue() {
         assertThat(VastXmlManagerAggregator.isValidSequenceNumber(null)).isTrue();
@@ -1244,10 +1762,12 @@ private VastCompanionAdXmlManager initializeCompanionXmlManagerMock(
             final String staticResource,
             final String staticResourceType,
             final String iFrameResource,
-            final String htmlResource) {
+            final String htmlResource,
+            final String adSlotId) {
         VastCompanionAdXmlManager companionXmlManager = mock(VastCompanionAdXmlManager.class);
         when(companionXmlManager.getWidth()).thenReturn(width);
         when(companionXmlManager.getHeight()).thenReturn(height);
+        when(companionXmlManager.getAdSlotId()).thenReturn(adSlotId);
 
         VastResourceXmlManager mockResourceXmlManager = initializeVastResourceXmlManagerMock(
                 staticResource,
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastXmlManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastXmlManagerTest.java
index b056537f..798d13e9 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastXmlManagerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastXmlManagerTest.java
@@ -7,6 +7,7 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
 import org.xml.sax.SAXException;
 
 import java.io.IOException;
@@ -17,6 +18,7 @@
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class VastXmlManagerTest {
     private static final String XML_HEADER_TAG = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>";
     private static final String TEST_VAST_XML_STRING = "<VAST xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" version=\"2.0\" xsi:noNamespaceSchemaLocation=\"vast.xsd\">" +
@@ -327,6 +329,13 @@
             "                           <MoPubSkipText>skip</MoPubSkipText>" +
             "                           <MoPubCloseIcon>http://ton.twitter.com/exchange-media/images/v4/star_icon_3x.png</MoPubCloseIcon>" +
             "                           <MoPubForceOrientation>device</MoPubForceOrientation>" +
+            "                           <MoPubViewabilityTracker" +
+"                                           viewablePlaytime=\"2.5\"" +
+            "                               percentViewable=\"50%\">" +
+            "                               <![CDATA[" +
+            "                                   http://ad.server.com/impression/dot.gif" +
+            "                               ]]>" +
+            "                           </MoPubViewabilityTracker>" +
             "                        </Extension>" +
             "                    </Extensions>" +
             "                </InLine>" +
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VideoDownloaderTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VideoDownloaderTest.java
index 1ff5949f..ed1cee96 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VideoDownloaderTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VideoDownloaderTest.java
@@ -27,8 +27,8 @@
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 
-@Config(shadows = {ShadowAsyncTasks.class, ShadowMoPubHttpUrlConnection.class})
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class, shadows = {ShadowAsyncTasks.class, ShadowMoPubHttpUrlConnection.class})
 public class VideoDownloaderTest {
     @Mock VideoDownloaderListener mockListener;
     private final static String expectedUrl1 = "http://video_url";
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VideoViewabilityTrackerXmlManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VideoViewabilityTrackerXmlManagerTest.java
new file mode 100644
index 00000000..7e435cdc
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VideoViewabilityTrackerXmlManagerTest.java
@@ -0,0 +1,236 @@
+package com.mopub.mobileads;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+
+import static com.mopub.mobileads.test.support.VastUtils.createNode;
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class VideoViewabilityTrackerXmlManagerTest {
+    private VideoViewabilityTrackerXmlManager subject;
+
+    @Test
+    public void getViewablePlaytimeMS_shouldParseHourFormat() throws Exception {
+        String videoViewabilityXml = "<MoPubViewabilityTracker" +
+                "                             viewablePlaytime=\"01:01:01.001\"" +
+                "                             percentViewable=\"50%\">" +
+                "                         <![CDATA[http://ad.server.com/impression/dot.gif]]>" +
+                "                     </MoPubViewabilityTracker>";
+
+        subject = new VideoViewabilityTrackerXmlManager(createNode(videoViewabilityXml));
+
+        assertThat(subject.getViewablePlaytimeMS()).isEqualTo(3661001);
+    }
+
+    @Test
+    public void getViewablePlaytimeMS_shouldParseSecondsFormat() throws Exception {
+        String videoViewabilityXml = "<MoPubViewabilityTracker" +
+                "                             viewablePlaytime=\"01.001\"" +
+                "                             percentViewable=\"50%\">" +
+                "                         <![CDATA[http://ad.server.com/impression/dot.gif]]>" +
+                "                     </MoPubViewabilityTracker>";
+
+        subject = new VideoViewabilityTrackerXmlManager(createNode(videoViewabilityXml));
+
+        assertThat(subject.getViewablePlaytimeMS()).isEqualTo(1001);
+    }
+
+    @Test
+    public void getViewablePlaytimeMS_shouldParseIntegerFormat() throws Exception {
+        String videoViewabilityXml = "<MoPubViewabilityTracker" +
+                "                             viewablePlaytime=\"2\"" +
+                "                             percentViewable=\"50%\">" +
+                "                         <![CDATA[http://ad.server.com/impression/dot.gif]]>" +
+                "                     </MoPubViewabilityTracker>";
+
+        subject = new VideoViewabilityTrackerXmlManager(createNode(videoViewabilityXml));
+
+        assertThat(subject.getViewablePlaytimeMS()).isEqualTo(2000);
+    }
+
+    @Test
+    public void getViewablePlaytimeMS_withoutViewablePlaytimeMS_shouldReturnNull() throws Exception {
+        String videoViewabilityXml = "<MoPubViewabilityTracker" +
+                "                             percentViewable=\"50%\">" +
+                "                         <![CDATA[http://ad.server.com/impression/dot.gif]]>" +
+                "                     </MoPubViewabilityTracker>";
+
+        subject = new VideoViewabilityTrackerXmlManager(createNode(videoViewabilityXml));
+
+        assertThat(subject.getViewablePlaytimeMS()).isNull();
+    }
+
+    @Test
+    public void getViewablePlaytimeMS_withNegativeInteger_shouldReturnNull() throws Exception {
+        String videoViewabilityXml = "<MoPubViewabilityTracker" +
+                "                             viewablePlaytime=\"-1\"" +
+                "                             percentViewable=\"50%\">" +
+                "                         <![CDATA[http://ad.server.com/impression/dot.gif]]>" +
+                "                     </MoPubViewabilityTracker>";
+
+        subject = new VideoViewabilityTrackerXmlManager(createNode(videoViewabilityXml));
+
+        assertThat(subject.getViewablePlaytimeMS()).isNull();
+    }
+
+    @Test
+    public void getViewablePlaytimeMS_withInvalidHourFormat_shouldReturnNull() throws Exception {
+        String videoViewabilityXml = "<MoPubViewabilityTracker" +
+                "                             viewablePlaytime=\"a01:01:01.001\"" +
+                "                             percentViewable=\"50%\">" +
+                "                         <![CDATA[http://ad.server.com/impression/dot.gif]]>" +
+                "                     </MoPubViewabilityTracker>";
+
+        subject = new VideoViewabilityTrackerXmlManager(createNode(videoViewabilityXml));
+
+        assertThat(subject.getViewablePlaytimeMS()).isNull();
+    }
+
+    @Test
+    public void getViewablePlaytimeMS_withInvalidSecondsFormat_shouldReturnNull() throws Exception {
+        String videoViewabilityXml = "<MoPubViewabilityTracker" +
+                "                             viewablePlaytime=\"a01.001\"" +
+                "                             percentViewable=\"50%\">" +
+                "                         <![CDATA[http://ad.server.com/impression/dot.gif]]>" +
+                "                     </MoPubViewabilityTracker>";
+
+        subject = new VideoViewabilityTrackerXmlManager(createNode(videoViewabilityXml));
+
+        assertThat(subject.getViewablePlaytimeMS()).isNull();
+    }
+
+    @Test
+    public void getViewablePlaytimeMS_withInvalidViewablePlaytimeMS_shouldReturnNull() throws Exception {
+        String videoViewabilityXml = "<MoPubViewabilityTracker" +
+                "                             viewablePlaytime=\"1234!@#$%^*(asdf\"" +
+                "                             percentViewable=\"50%\">" +
+                "                         <![CDATA[http://ad.server.com/impression/dot.gif]]>" +
+                "                     </MoPubViewabilityTracker>";
+
+        subject = new VideoViewabilityTrackerXmlManager(createNode(videoViewabilityXml));
+
+        assertThat(subject.getViewablePlaytimeMS()).isNull();
+    }
+
+    @Test
+    public void getPercentViewable_shouldParseWithPercentSign() throws Exception {
+        String videoViewabilityXml = "<MoPubViewabilityTracker" +
+                "                             viewablePlaytime=\"1\"" +
+                "                             percentViewable=\"25%\">" +
+                "                         <![CDATA[http://ad.server.com/impression/dot.gif]]>" +
+                "                     </MoPubViewabilityTracker>";
+
+        subject = new VideoViewabilityTrackerXmlManager(createNode(videoViewabilityXml));
+
+        assertThat(subject.getPercentViewable()).isEqualTo(25);
+    }
+
+    @Test
+    public void getPercentViewable_shouldParseWithoutPercentSign() throws Exception {
+        String videoViewabilityXml = "<MoPubViewabilityTracker" +
+                "                             viewablePlaytime=\"1\"" +
+                "                             percentViewable=\"25\">" +
+                "                         <![CDATA[http://ad.server.com/impression/dot.gif]]>" +
+                "                     </MoPubViewabilityTracker>";
+
+        subject = new VideoViewabilityTrackerXmlManager(createNode(videoViewabilityXml));
+
+        assertThat(subject.getPercentViewable()).isEqualTo(25);
+    }
+
+    @Test
+    public void getPercentViewable_shouldTruncateFloats() throws Exception {
+        String videoViewabilityXml = "<MoPubViewabilityTracker" +
+                "                             viewablePlaytime=\"1\"" +
+                "                             percentViewable=\"25.9\">" +
+                "                         <![CDATA[http://ad.server.com/impression/dot.gif]]>" +
+                "                     </MoPubViewabilityTracker>";
+
+        subject = new VideoViewabilityTrackerXmlManager(createNode(videoViewabilityXml));
+
+        assertThat(subject.getPercentViewable()).isEqualTo(25);
+    }
+
+    @Test
+    public void getPercentViewable_withoutPercentViewable_shouldReturnNull() throws Exception {
+        String videoViewabilityXml = "<MoPubViewabilityTracker" +
+                "                             viewablePlaytime=\"1\">" +
+                "                         <![CDATA[http://ad.server.com/impression/dot.gif]]>" +
+                "                     </MoPubViewabilityTracker>";
+
+        subject = new VideoViewabilityTrackerXmlManager(createNode(videoViewabilityXml));
+
+        assertThat(subject.getPercentViewable()).isNull();
+    }
+
+    @Test
+    public void getPercentViewable_withNegativeInteger_shouldReturnNull() throws Exception {
+        String videoViewabilityXml = "<MoPubViewabilityTracker" +
+                "                             viewablePlaytime=\"1\"" +
+                "                             percentViewable=\"-25\">" +
+                "                         <![CDATA[http://ad.server.com/impression/dot.gif]]>" +
+                "                     </MoPubViewabilityTracker>";
+
+        subject = new VideoViewabilityTrackerXmlManager(createNode(videoViewabilityXml));
+
+        assertThat(subject.getPercentViewable()).isNull();
+    }
+
+    @Test
+    public void getPercentViewable_withIntegerGreaterThan100_shouldReturnNull() throws Exception {
+        String videoViewabilityXml = "<MoPubViewabilityTracker" +
+                "                             viewablePlaytime=\"1\"" +
+                "                             percentViewable=\"101\">" +
+                "                         <![CDATA[http://ad.server.com/impression/dot.gif]]>" +
+                "                     </MoPubViewabilityTracker>";
+
+        subject = new VideoViewabilityTrackerXmlManager(createNode(videoViewabilityXml));
+
+        assertThat(subject.getPercentViewable()).isNull();
+    }
+
+    @Test
+    public void getPercentViewable_withInvalidPercentViewable_shouldReturnNull() throws Exception {
+        String videoViewabilityXml = "<MoPubViewabilityTracker" +
+                "                             viewablePlaytime=\"1\"" +
+                "                             percentViewable=\"1234!@#$%^*(asdf\">" +
+                "                         <![CDATA[http://ad.server.com/impression/dot.gif]]>" +
+                "                     </MoPubViewabilityTracker>";
+
+        subject = new VideoViewabilityTrackerXmlManager(createNode(videoViewabilityXml));
+
+        assertThat(subject.getPercentViewable()).isNull();
+    }
+
+    @Test
+    public void getVideoViewabilityTrackerUrl_shouldReturnVideoViewabilityTrackerUrl() throws Exception {
+        String videoViewabilityXml = "<MoPubViewabilityTracker" +
+                "                             viewablePlaytime=\"2\"" +
+                "                             percentViewable=\"50%\">" +
+                "                         <![CDATA[http://ad.server.com/impression/dot.gif]]>" +
+                "                     </MoPubViewabilityTracker>";
+
+        subject = new VideoViewabilityTrackerXmlManager(createNode(videoViewabilityXml));
+
+        assertThat(subject.getVideoViewabilityTrackerUrl())
+                .isEqualTo("http://ad.server.com/impression/dot.gif");
+    }
+
+    @Test
+    public void getVideoViewabilityTrackerUrl_withoutTrackerUrl_shouldReturnEmptyString() throws Exception {
+        String videoViewabilityXml = "<MoPubViewabilityTracker" +
+                "                             viewablePlaytime=\"2\"" +
+                "                             percentViewable=\"50%\">" +
+                "                     </MoPubViewabilityTracker>";
+
+        subject = new VideoViewabilityTrackerXmlManager(createNode(videoViewabilityXml));
+
+        assertThat(subject.getVideoViewabilityTrackerUrl()).isEmpty();
+    }
+
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/ViewGestureDetectorTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/ViewGestureDetectorTest.java
index 0c0935ef..feb326a2 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/ViewGestureDetectorTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/ViewGestureDetectorTest.java
@@ -11,6 +11,8 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
+import org.robolectric.Shadows;
+import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowGestureDetector;
 
 import static com.mopub.mobileads.ViewGestureDetector.UserClickListener;
@@ -19,9 +21,10 @@
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.stub;
 import static org.mockito.Mockito.verify;
-import static org.robolectric.Robolectric.shadowOf;
+
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class ViewGestureDetectorTest {
     private Activity context;
     private ViewGestureDetector subject;
@@ -46,7 +49,7 @@ public void setUp() throws Exception {
     public void constructor_shouldDisableLongPressAndSetGestureListener() throws Exception {
         subject = new ViewGestureDetector(context, view, mockAdReport);
 
-        ShadowGestureDetector shadowGestureDetector = shadowOf(subject);
+        ShadowGestureDetector shadowGestureDetector = Shadows.shadowOf(subject);
 
         assertThat(subject.isLongpressEnabled()).isFalse();
         assertThat(shadowGestureDetector.getListener()).isNotNull();
@@ -84,18 +87,20 @@ public void onTouchEvent_whenActionDown_shouldForwardOnTouchEvent() throws Excep
 
         subject.sendTouchEvent(expectedMotionEvent);
 
-        MotionEvent actualMotionEvent = shadowOf(subject).getOnTouchEventMotionEvent();
+        MotionEvent actualMotionEvent = Shadows.shadowOf(subject).getOnTouchEventMotionEvent();
 
         assertThat(actualMotionEvent).isEqualTo(expectedMotionEvent);
     }
 
     @Test
     public void onTouchEvent_whenActionMoveWithinView_shouldForwardOnTouchEvent() throws Exception {
-        MotionEvent expectedMotionEvent = createActionMove(160);
+        MotionEvent downEvent = createMotionEvent(MotionEvent.ACTION_DOWN);
+        subject.sendTouchEvent(downEvent);
 
+        MotionEvent expectedMotionEvent = createActionMove(160);
         subject.sendTouchEvent(expectedMotionEvent);
 
-        MotionEvent actualMotionEvent = shadowOf(subject).getOnTouchEventMotionEvent();
+        MotionEvent actualMotionEvent = Shadows.shadowOf(subject).getOnTouchEventMotionEvent();
 
         assertThat(actualMotionEvent).isEqualTo(expectedMotionEvent);
         verify(adAlertGestureListener, never()).reset();
@@ -105,7 +110,7 @@ public void onTouchEvent_whenActionMoveWithinView_shouldForwardOnTouchEvent() th
     public void sendTouchEvent_whenReceiveTouchEventOutsideOfViewInXDirection_shouldResetAlertState() throws Exception {
         subject.sendTouchEvent(createActionMove(350));
 
-        MotionEvent actualMotionEvent = shadowOf(subject).getOnTouchEventMotionEvent();
+        MotionEvent actualMotionEvent = Shadows.shadowOf(subject).getOnTouchEventMotionEvent();
 
         assertThat(actualMotionEvent).isNull();
         verify(adAlertGestureListener).reset();
@@ -116,7 +121,7 @@ public void sendTouchEvent_whenReceiveTouchEventOutsideOfViewInYDirection_should
         MotionEvent verticalMotion = MotionEvent.obtain(0, 0, MotionEvent.ACTION_MOVE, 160, 200, 0);
         subject.sendTouchEvent(verticalMotion);
 
-        MotionEvent actualMotionEvent = shadowOf(subject).getOnTouchEventMotionEvent();
+        MotionEvent actualMotionEvent = Shadows.shadowOf(subject).getOnTouchEventMotionEvent();
 
         assertThat(actualMotionEvent).isNull();
         verify(adAlertGestureListener).reset();
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/WebViewAdUrlGeneratorTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/WebViewAdUrlGeneratorTest.java
index 529c4a44..0c20e34f 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/WebViewAdUrlGeneratorTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/WebViewAdUrlGeneratorTest.java
@@ -38,6 +38,8 @@
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowConnectivityManager;
 import org.robolectric.shadows.ShadowLocationManager;
@@ -61,11 +63,9 @@
 import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.when;
-import static org.robolectric.Robolectric.application;
-import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(SdkTestRunner.class)
-@Config(shadows = {MoPubShadowTelephonyManager.class})
+@Config(constants = BuildConfig.class, shadows = {MoPubShadowTelephonyManager.class})
 public class WebViewAdUrlGeneratorTest {
 
     private static final String TEST_UDID = "20b013c721c";
@@ -84,7 +84,7 @@
     @Before
     public void setup() {
         context = spy(Robolectric.buildActivity(Activity.class).create().get());
-        shadowOf(context).grantPermissions(ACCESS_NETWORK_STATE);
+        Shadows.shadowOf(context).grantPermissions(ACCESS_NETWORK_STATE);
 
         // Set the expected screen dimensions to arbitrary numbers
         final Resources spyResources = spy(context.getResources());
@@ -118,11 +118,11 @@ public Object answer(final InvocationOnMock invocationOnMock) throws Throwable {
 
         subject = new WebViewAdUrlGenerator(context,
                 new MraidNativeCommandHandler().isStorePictureSupported(context));
-        Settings.Secure.putString(application.getContentResolver(), Settings.Secure.ANDROID_ID, TEST_UDID);
+        Settings.Secure.putString(RuntimeEnvironment.application.getContentResolver(), Settings.Secure.ANDROID_ID, TEST_UDID);
         expectedUdid = "sha%3A" + Utils.sha1(TEST_UDID);
-        configuration = application.getResources().getConfiguration();
-        shadowTelephonyManager = (MoPubShadowTelephonyManager) shadowOf((TelephonyManager) application.getSystemService(Context.TELEPHONY_SERVICE));
-        shadowConnectivityManager = shadowOf((ConnectivityManager) application.getSystemService(Context.CONNECTIVITY_SERVICE));
+        configuration = RuntimeEnvironment.application.getResources().getConfiguration();
+        shadowTelephonyManager = (MoPubShadowTelephonyManager) Shadows.shadowOf((TelephonyManager) RuntimeEnvironment.application.getSystemService(Context.TELEPHONY_SERVICE));
+        shadowConnectivityManager = Shadows.shadowOf((ConnectivityManager) RuntimeEnvironment.application.getSystemService(Context.CONNECTIVITY_SERVICE));
         methodBuilder = TestMethodBuilderFactory.getSingletonMock();
         Networking.useHttps(false);
     }
@@ -332,7 +332,7 @@ public void generateAdUrl_shouldSetNetworkType() throws Exception {
     public void generateAdUrl_whenNoNetworkPermission_shouldGenerateUnknownNetworkType() throws Exception {
         AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
 
-        shadowOf(context).denyPermissions(ACCESS_NETWORK_STATE);
+        Shadows.shadowOf(context).denyPermissions(ACCESS_NETWORK_STATE);
         shadowConnectivityManager.setActiveNetworkInfo(createNetworkInfo(TYPE_MOBILE));
 
         String adUrl = generateMinimumUrlString();
@@ -380,8 +380,8 @@ public void generateAdUrl_whenLocationServiceGpsProviderHasMostRecentLocation_sh
 
         // Mock out the LocationManager's last known location to be more recent than the
         // developer-supplied location.
-        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
-                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
+        ShadowLocationManager shadowLocationManager = Shadows.shadowOf(
+                (LocationManager) RuntimeEnvironment.application.getSystemService(Context.LOCATION_SERVICE));
         Location locationFromSdk = new Location("");
         locationFromSdk.setLatitude(37);
         locationFromSdk.setLongitude(-122);
@@ -404,8 +404,8 @@ public void generateAdUrl_whenDeveloperSuppliesMoreRecentLocationThanLocationSer
         locationFromDeveloper.setAccuracy(3.5f);
         locationFromDeveloper.setTime(1000);
 
-        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
-                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
+        ShadowLocationManager shadowLocationManager = Shadows.shadowOf(
+                (LocationManager) RuntimeEnvironment.application.getSystemService(Context.LOCATION_SERVICE));
 
         // Mock out the LocationManager's last known location to be older than the
         // developer-supplied location.
@@ -433,8 +433,8 @@ public void generateAdUrl_whenLocationServiceNetworkProviderHasMostRecentLocatio
 
         // Mock out the LocationManager's last known location to be more recent than the
         // developer-supplied location.
-        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
-                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
+        ShadowLocationManager shadowLocationManager = Shadows.shadowOf(
+                (LocationManager) RuntimeEnvironment.application.getSystemService(Context.LOCATION_SERVICE));
         Location locationFromSdk = new Location("");
         locationFromSdk.setLatitude(38);
         locationFromSdk.setLongitude(-123);
@@ -480,8 +480,8 @@ public void disableLocationCollection_whenLocationServiceHasMostRecentLocation_s
         MoPub.setLocationAwareness(MoPub.LocationAwareness.DISABLED);
 
         // Mock out the LocationManager's last known location.
-        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
-                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
+        ShadowLocationManager shadowLocationManager = Shadows.shadowOf(
+                (LocationManager) RuntimeEnvironment.application.getSystemService(Context.LOCATION_SERVICE));
         Location locationFromSdk = new Location("");
         locationFromSdk.setLatitude(37);
         locationFromSdk.setLongitude(-122);
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/factories/CustomEventBannerFactoryTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/factories/CustomEventBannerFactoryTest.java
index 771f97c1..388ae73f 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/factories/CustomEventBannerFactoryTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/factories/CustomEventBannerFactoryTest.java
@@ -2,17 +2,20 @@
 
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.mobileads.AdTypeTranslator;
+import com.mopub.mobileads.BuildConfig;
 import com.mopub.mobileads.CustomEventBanner;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
 
 import static com.mopub.mobileads.AdTypeTranslator.CustomEventType.HTML_BANNER;
 import static com.mopub.mobileads.AdTypeTranslator.CustomEventType.MRAID_BANNER;
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class CustomEventBannerFactoryTest {
 
     private CustomEventBannerFactory subject;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/factories/CustomEventInterstitialFactoryTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/factories/CustomEventInterstitialFactoryTest.java
index 81146585..86ca874d 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/factories/CustomEventInterstitialFactoryTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/factories/CustomEventInterstitialFactoryTest.java
@@ -2,17 +2,20 @@
 
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.mobileads.AdTypeTranslator;
+import com.mopub.mobileads.BuildConfig;
 import com.mopub.mobileads.CustomEventInterstitial;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
 
 import static com.mopub.mobileads.AdTypeTranslator.CustomEventType.HTML_INTERSTITIAL;
 import static com.mopub.mobileads.AdTypeTranslator.CustomEventType.MRAID_INTERSTITIAL;
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class CustomEventInterstitialFactoryTest {
 
     private CustomEventInterstitialFactory subject;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestHttpResponseWithHeaders.java b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestHttpResponseWithHeaders.java
index 1a7fde20..8c3229b5 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestHttpResponseWithHeaders.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestHttpResponseWithHeaders.java
@@ -2,7 +2,7 @@
 
 import org.apache.http.Header;
 import org.apache.http.message.BasicHeader;
-import org.robolectric.tester.org.apache.http.TestHttpResponse;
+import org.robolectric.shadows.httpclient.TestHttpResponse;
 
 import java.util.HashMap;
 import java.util.Map;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestVastManagerFactory.java b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestVastManagerFactory.java
index d2e60e1b..9ccbb2c9 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestVastManagerFactory.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestVastManagerFactory.java
@@ -19,7 +19,7 @@ private static TestVastManagerFactory getTestFactory() {
     }
 
     @Override
-    public VastManager internalCreate(final Context context) {
+    public VastManager internalCreate(final Context context, final boolean preCacheVideo) {
         return getTestFactory().mockVastManager;
     }
 }
\ No newline at end of file
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/WebViewsTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/util/WebViewsTest.java
index 712eef93..08372f7f 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/util/WebViewsTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/util/WebViewsTest.java
@@ -5,15 +5,18 @@
 import android.webkit.WebView;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
 
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class WebViewsTest {
 
     @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/XmlUtilsTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/util/XmlUtilsTest.java
index 426819d4..5ec0131c 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/util/XmlUtilsTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/util/XmlUtilsTest.java
@@ -1,10 +1,12 @@
 package com.mopub.mobileads.util;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
 import org.w3c.dom.Document;
 import org.w3c.dom.Node;
 import org.xml.sax.InputSource;
@@ -24,6 +26,7 @@
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class XmlUtilsTest {
 
     // From Microsoft's sample xml documents page: https://msdn.microsoft.com/en-us/library/bb387026.aspx
diff --git a/mopub-sdk/src/test/java/com/mopub/mraid/MraidBannerTest.java b/mopub-sdk/src/test/java/com/mopub/mraid/MraidBannerTest.java
index 79d601c8..7a3ba220 100644
--- a/mopub-sdk/src/test/java/com/mopub/mraid/MraidBannerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mraid/MraidBannerTest.java
@@ -5,6 +5,7 @@
 import android.view.View;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 import com.mopub.mobileads.test.support.TestMraidControllerFactory;
 import com.mopub.mraid.MraidController.MraidListener;
 
@@ -13,6 +14,7 @@
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
 import org.mockito.Mock;
+import org.robolectric.annotation.Config;
 
 import java.util.HashMap;
 import java.util.Map;
@@ -25,6 +27,7 @@
 import static org.mockito.Mockito.verify;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class MraidBannerTest {
     private static final String INPUT_HTML_DATA = "%3Chtml%3E%3C%2Fhtml%3E";
 
diff --git a/mopub-sdk/src/test/java/com/mopub/mraid/MraidBridgeTest.java b/mopub-sdk/src/test/java/com/mopub/mraid/MraidBridgeTest.java
index 7ecdaadb..04db1b0d 100644
--- a/mopub-sdk/src/test/java/com/mopub/mraid/MraidBridgeTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mraid/MraidBridgeTest.java
@@ -11,6 +11,7 @@
 import com.mopub.common.AdReport;
 import com.mopub.common.Constants;
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 import com.mopub.mraid.MraidBridge.MraidBridgeListener;
 import com.mopub.mraid.MraidBridge.MraidWebView;
 import com.mopub.mraid.MraidNativeCommandHandler.MraidCommandFailureListener;
@@ -24,6 +25,7 @@
 import org.mockito.Mock;
 import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowApplication;
 
 import java.net.URI;
 import java.util.HashMap;
@@ -44,6 +46,7 @@
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class MraidBridgeTest {
     @Mock MraidNativeCommandHandler mockNativeCommandHandler;
     @Mock MraidBridgeListener mockBridgeListener;
@@ -69,7 +72,7 @@ public void setUp() {
     }
 
     @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-    @Config(reportSdk = Build.VERSION_CODES.JELLY_BEAN_MR1, emulateSdk = Build.VERSION_CODES.JELLY_BEAN_MR1)
+    @Config(sdk = Build.VERSION_CODES.JELLY_BEAN_MR1)
     @Test
     public void attachView_atLeastJellyBeanMr1_withInterstitial_shouldAutoPlayVideo() {
         when(mockInterstitialWebView.getSettings()).thenReturn(mockWebSettings);
@@ -80,7 +83,7 @@ public void attachView_atLeastJellyBeanMr1_withInterstitial_shouldAutoPlayVideo(
     }
 
     @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-    @Config(reportSdk = Build.VERSION_CODES.JELLY_BEAN_MR1, emulateSdk = Build.VERSION_CODES.JELLY_BEAN_MR1)
+    @Config(sdk = Build.VERSION_CODES.JELLY_BEAN_MR1)
     @Test
     public void attachView_atLeastJellyBeanMr1_withInline_shouldNotAutoPlayVideo() {
         when(mockBannerWebView.getSettings()).thenReturn(mockWebSettings);
@@ -91,7 +94,7 @@ public void attachView_atLeastJellyBeanMr1_withInline_shouldNotAutoPlayVideo() {
     }
 
     @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-    @Config(reportSdk = Build.VERSION_CODES.JELLY_BEAN, emulateSdk = Build.VERSION_CODES.JELLY_BEAN)
+    @Config(sdk = Build.VERSION_CODES.JELLY_BEAN)
     @Test
     public void attachView_belowJellyBeanMr1_withInterstitial_shouldNotAutoPlayVideo() {
         when(mockInterstitialWebView.getSettings()).thenReturn(mockWebSettings);
@@ -105,7 +108,7 @@ public void attachView_belowJellyBeanMr1_withInterstitial_shouldNotAutoPlayVideo
     }
 
     @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-    @Config(reportSdk = Build.VERSION_CODES.JELLY_BEAN, emulateSdk = Build.VERSION_CODES.JELLY_BEAN)
+    @Config(sdk = Build.VERSION_CODES.JELLY_BEAN)
     @Test
     public void attachView_belowJellyBeanMr1_withInline_shouldNotAutoPlayVideo() {
         when(mockBannerWebView.getSettings()).thenReturn(mockWebSettings);
@@ -219,7 +222,7 @@ public void handleShouldOverrideUrl_smsUrl_clicked_shouldStartActivity() {
 
         boolean result = subjectBanner.handleShouldOverrideUrl("sms://123456789");
 
-        Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent startedIntent = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(startedIntent).isNotNull();
         assertThat(startedIntent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
         assertThat(startedIntent.getComponent()).isNull();
diff --git a/mopub-sdk/src/test/java/com/mopub/mraid/MraidControllerTest.java b/mopub-sdk/src/test/java/com/mopub/mraid/MraidControllerTest.java
index be20f706..6a21c2a5 100644
--- a/mopub-sdk/src/test/java/com/mopub/mraid/MraidControllerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mraid/MraidControllerTest.java
@@ -11,11 +11,13 @@
 import android.view.View;
 import android.widget.FrameLayout;
 
+import com.mopub.TestSdkHelper;
 import com.mopub.common.AdReport;
 import com.mopub.common.CloseableLayout.ClosePosition;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.common.util.Utils;
 import com.mopub.mobileads.BaseVideoPlayerActivityTest;
+import com.mopub.mobileads.BuildConfig;
 import com.mopub.mobileads.MraidVideoPlayerActivity;
 import com.mopub.mraid.MraidBridge.MraidBridgeListener;
 import com.mopub.mraid.MraidBridge.MraidWebView;
@@ -35,7 +37,9 @@
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowApplication;
 
 import java.net.URI;
 
@@ -54,6 +58,7 @@
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class MraidControllerTest {
     private long broadcastIdentifier = 123;
     @Mock private AdReport mockAdReport;
@@ -74,7 +79,7 @@
 
     @Before
     public void setUp() {
-        Robolectric.setDisplayMetricsDensity(1.0f);
+        ShadowApplication.setDisplayMetricsDensity(1.0f);
 
         activity = spy(Robolectric.buildActivity(Activity.class).create().get());
         activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
@@ -483,7 +488,7 @@ public void handleCustomClose_shouldCallCustomCloseChangedListener() {
     public void handleOpen_withMoPubNativeBrowserUrl_shouldOpenExternalBrowser() {
         subject.handleOpen("mopubnativebrowser://navigate?url=https%3A%2F%2Fwww.example.com");
 
-        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent intent = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(intent.getDataString()).isEqualTo("https://www.example.com");
         assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
     }
@@ -493,18 +498,18 @@ public void handleOpen_withMalformedMoPubNativeBrowserUrl_shouldNotStartNewActiv
         // invalid host parameter 'nav'
         subject.handleOpen("mopubnativebrowser://nav?url=https%3A%2F%2Fwww.example.com");
 
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+        assertThat(ShadowApplication.getInstance().getNextStartedActivity()).isNull();
     }
 
     @Test
     public void handleOpen_withApplicationUrl_shouldStartNewIntent() {
         String applicationUrl = "amzn://blah";
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(Intent.ACTION_VIEW, Uri
+        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(Intent.ACTION_VIEW, Uri
                 .parse(applicationUrl)), new ResolveInfo());
 
         subject.handleOpen(applicationUrl);
 
-        Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent startedIntent = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(startedIntent).isNotNull();
         // Since we are not using an Activity context, we should have FLAG_ACTIVITY_NEW_TASK
         assertThat(Utils.bitMaskContainsFlag(startedIntent.getFlags(),
@@ -520,8 +525,8 @@ public void handleOpen_withHttpApplicationUrl_shouldStartMoPubBrowser() {
 
         subject.handleOpen(applicationUrl);
 
-        Robolectric.runBackgroundTasks();
-        Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
+        Robolectric.getBackgroundThreadScheduler().advanceBy(0);
+        Intent startedIntent = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(startedIntent).isNotNull();
         // Since we are not using an Activity context, we should have FLAG_ACTIVITY_NEW_TASK
         assertThat(Utils.bitMaskContainsFlag(startedIntent.getFlags(),
@@ -539,7 +544,7 @@ public void handleOpen_withApplicationUrlThatCantBeHandled_shouldDefaultToMoPubB
 
         subject.handleOpen(applicationUrl);
 
-        Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent startedIntent = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(startedIntent).isNull();
 
         verify(mockMraidListener).onOpen();
@@ -551,7 +556,7 @@ public void handleOpen_withAboutBlankUrl_shouldFailSilently() {
 
         subject.handleOpen(url);
 
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+        assertThat(ShadowApplication.getInstance().getNextStartedActivity()).isNull();
     }
 
     @Test
@@ -680,11 +685,11 @@ public void handleSetOrientationProperties_withForcedOrientation_withMissingConf
         assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.NONE);
     }
 
-    @Config(reportSdk = Build.VERSION_CODES.HONEYCOMB_MR1)
     @Test
     public void handleSetOrientationProperties_beforeHoneycombMr2_withMissingConfigChangeScreenSize_shouldUpdateProperties() throws Exception {
         setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
                 ActivityInfo.CONFIG_ORIENTATION);
+        TestSdkHelper.setReportedSdkLevel(Build.VERSION_CODES.HONEYCOMB_MR1);
 
         subject.handleSetOrientationProperties(false, MraidOrientation.LANDSCAPE);
 
@@ -692,11 +697,11 @@ public void handleSetOrientationProperties_beforeHoneycombMr2_withMissingConfigC
         assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.LANDSCAPE);
     }
 
-    @Config(reportSdk = Build.VERSION_CODES.HONEYCOMB_MR2)
     @Test
     public void handleSetOrientationProperties_atLeastHoneycombMr2_withMissingConfigChangeScreenSize_shouldThrowMraidCommandException() throws Exception {
         setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
                 ActivityInfo.CONFIG_ORIENTATION);
+        TestSdkHelper.setReportedSdkLevel(Build.VERSION_CODES.HONEYCOMB_MR2);
 
         try {
             subject.handleSetOrientationProperties(false, MraidOrientation.LANDSCAPE);
diff --git a/mopub-sdk/src/test/java/com/mopub/mraid/MraidInterstitialTest.java b/mopub-sdk/src/test/java/com/mopub/mraid/MraidInterstitialTest.java
index 5424e6f2..3d38b27f 100644
--- a/mopub-sdk/src/test/java/com/mopub/mraid/MraidInterstitialTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mraid/MraidInterstitialTest.java
@@ -1,10 +1,10 @@
 package com.mopub.mraid;
 
 import android.app.Activity;
-import android.content.Context;
 import android.content.Intent;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 import com.mopub.mobileads.ResponseBodyInterstitialTest;
 
 import org.junit.Before;
@@ -13,26 +13,28 @@
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.robolectric.Robolectric;
+import org.robolectric.Shadows;
+import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowActivity;
-import org.robolectric.shadows.ShadowLocalBroadcastManager;
+import org.robolectric.shadows.support.v4.ShadowLocalBroadcastManager;
 
 import java.util.HashMap;
 import java.util.Map;
 
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
 import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_CLICK;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
-import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiverTest.getIntentForActionAndIdentifier;
-import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_INVALID_STATE;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
-import static org.robolectric.Robolectric.shadowOf_;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class MraidInterstitialTest extends ResponseBodyInterstitialTest {
     private static final String EXPECTED_HTML_DATA = "<html></html>";
     private long broadcastIdentifier;
@@ -41,7 +43,7 @@
 
     private Map<String, Object> localExtras;
     private Map<String, String> serverExtras;
-    private Context context;
+    private Activity context;
 
     @Before
     public void setUp() throws Exception {
@@ -105,7 +107,7 @@ public void showInterstitial_shouldStartActivityWithIntent() throws Exception {
                 serverExtras);
         subject.showInterstitial();
 
-        ShadowActivity shadowActivity = shadowOf_(context);
+        ShadowActivity shadowActivity = Shadows.shadowOf(context);
         Intent intent = shadowActivity.getNextStartedActivityForResult().intent;
 
         assertThat(intent.getComponent().getClassName())
diff --git a/mopub-sdk/src/test/java/com/mopub/mraid/MraidNativeCommandHandlerTest.java b/mopub-sdk/src/test/java/com/mopub/mraid/MraidNativeCommandHandlerTest.java
index 8b6b6e1c..7217f6ba 100644
--- a/mopub-sdk/src/test/java/com/mopub/mraid/MraidNativeCommandHandlerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mraid/MraidNativeCommandHandlerTest.java
@@ -17,17 +17,17 @@
 import android.view.WindowManager;
 import android.widget.LinearLayout;
 
+import com.mopub.TestSdkHelper;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.common.util.test.support.ShadowAsyncTasks;
 import com.mopub.common.util.test.support.ShadowMoPubHttpUrlConnection;
+import com.mopub.mobileads.BuildConfig;
 import com.mopub.mobileads.test.support.FileUtils;
 import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
-import com.mopub.mobileads.test.support.ThreadUtils;
 import com.mopub.mraid.MraidNativeCommandHandler.DownloadImageAsyncTask;
 import com.mopub.mraid.MraidNativeCommandHandler.DownloadImageAsyncTask.DownloadImageAsyncTaskListener;
 import com.mopub.mraid.MraidNativeCommandHandler.MraidCommandFailureListener;
 
-import org.apache.http.HttpResponse;
 import org.hamcrest.BaseMatcher;
 import org.hamcrest.Description;
 import org.junit.After;
@@ -39,8 +39,10 @@
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
+import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowAlertDialog;
+import org.robolectric.shadows.ShadowApplication;
 import org.robolectric.shadows.ShadowEnvironment;
 import org.robolectric.shadows.ShadowLog;
 import org.robolectric.shadows.ShadowToast;
@@ -67,10 +69,9 @@
 import static org.mockito.Mockito.stub;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
-import static org.robolectric.Robolectric.shadowOf;
 
-@Config(shadows = {ShadowAsyncTasks.class, ShadowMoPubHttpUrlConnection.class})
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class, shadows = {ShadowAsyncTasks.class, ShadowMoPubHttpUrlConnection.class})
 public class MraidNativeCommandHandlerTest {
     private static final String IMAGE_URI_VALUE = "file://tmp/expectedFile.jpg";
     private static final String REMOTE_IMAGE_URL = "http://www.mopub.com/expectedFile.jpg";
@@ -102,7 +103,7 @@ public void setUp() throws Exception {
 
         // Mount external storage and grant necessary permissions
         ShadowEnvironment.setExternalStorageState(MEDIA_MOUNTED);
-        Robolectric.getShadowApplication().grantPermissions(Manifest.permission.WRITE_EXTERNAL_STORAGE);
+        ShadowApplication.getInstance().grantPermissions(Manifest.permission.WRITE_EXTERNAL_STORAGE);
     }
 
     @After
@@ -115,7 +116,7 @@ public void showUserDownloadImageAlert_withActivityContext_shouldDisplayAlertDia
         subject.storePicture(context, IMAGE_URI_VALUE, mockMraidCommandFailureListener);
 
         AlertDialog alertDialog = ShadowAlertDialog.getLatestAlertDialog();
-        ShadowAlertDialog shadowAlertDialog = shadowOf(alertDialog);
+        ShadowAlertDialog shadowAlertDialog = Shadows.shadowOf(alertDialog);
 
         assertThat(alertDialog.isShowing());
 
@@ -145,7 +146,7 @@ public void showUserDownloadImageAlert_withAppContext_shouldToastAndStartDownloa
 
     @Test(expected = MraidCommandException.class)
     public void showUserDownloadImageAlert_whenStorePictureNotSupported_shouldThrowMraidCommandException() throws Exception {
-        Robolectric.getShadowApplication().denyPermissions(Manifest.permission.WRITE_EXTERNAL_STORAGE);
+        ShadowApplication.getInstance().denyPermissions(Manifest.permission.WRITE_EXTERNAL_STORAGE);
 
         subject.storePicture(context, IMAGE_URI_VALUE, mockMraidCommandFailureListener);
     }
@@ -168,7 +169,7 @@ public void showUserDownloadImageAlert_whenCancelClicked_shouldDismissDialog_sho
         subject.storePicture(context, IMAGE_URI_VALUE, mockMraidCommandFailureListener);
 
         AlertDialog alertDialog = ShadowAlertDialog.getLatestAlertDialog();
-        ShadowAlertDialog shadowAlertDialog = shadowOf(alertDialog);
+        ShadowAlertDialog shadowAlertDialog = Shadows.shadowOf(alertDialog);
 
         alertDialog.getButton(BUTTON_NEGATIVE).performClick();
         assertThat(shadowAlertDialog.hasBeenDismissed()).isTrue();
@@ -320,7 +321,7 @@ public void downloadImage_withMimeTypeAndFileExtension_shouldSavePictureWithFile
     }
 
     @Ignore("Mraid 2.0")
-    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Config(sdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withMinimumValidParams_atLeastICS_shouldCreateEventIntent() throws Exception {
         setupCalendarParams();
@@ -329,7 +330,7 @@ public void createCalendarEvent_withMinimumValidParams_atLeastICS_shouldCreateEv
 
         verify(mockMraidCommandFailureListener, never()).onFailure(any(MraidCommandException.class));
 
-        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent intent = ShadowApplication.getInstance().getNextStartedActivity();
 
         assertThat(intent.getType()).isEqualTo(ANDROID_CALENDAR_CONTENT_TYPE);
         assertThat(intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
@@ -338,7 +339,7 @@ public void createCalendarEvent_withMinimumValidParams_atLeastICS_shouldCreateEv
     }
 
     @Ignore("Mraid 2.0")
-    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Config(sdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withoutSecondsOnStartDate_atLeastICS_shouldCreateEventIntent() throws Exception {
         setupCalendarParams();
@@ -348,7 +349,7 @@ public void createCalendarEvent_withoutSecondsOnStartDate_atLeastICS_shouldCreat
 
         verify(mockMraidCommandFailureListener, never()).onFailure(any(MraidCommandException.class));
 
-        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent intent = ShadowApplication.getInstance().getNextStartedActivity();
 
         assertThat(intent.getType()).isEqualTo(ANDROID_CALENDAR_CONTENT_TYPE);
         assertThat(intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
@@ -357,7 +358,7 @@ public void createCalendarEvent_withoutSecondsOnStartDate_atLeastICS_shouldCreat
     }
 
     @Ignore("Mraid 2.0")
-    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Config(sdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withDailyRecurrence_shouldCreateCalendarIntent() throws Exception {
         setupCalendarParams();
@@ -365,14 +366,14 @@ public void createCalendarEvent_withDailyRecurrence_shouldCreateCalendarIntent()
 
         subject.createCalendarEvent(context, params);
 
-        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent intent = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(intent.getType()).isEqualTo(ANDROID_CALENDAR_CONTENT_TYPE);
         assertThat(intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
         assertThat(intent.getStringExtra(CalendarContract.Events.RRULE)).isEqualTo("FREQ=DAILY;");
     }
 
     @Ignore("Mraid 2.0")
-    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Config(sdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withDailyRecurrence_withInterval_shouldCreateCalendarIntent() throws Exception {
         setupCalendarParams();
@@ -381,12 +382,12 @@ public void createCalendarEvent_withDailyRecurrence_withInterval_shouldCreateCal
 
         subject.createCalendarEvent(context, params);
 
-        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent intent = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(intent.getStringExtra(CalendarContract.Events.RRULE)).isEqualTo("FREQ=DAILY;INTERVAL=2;");
     }
 
     @Ignore("Mraid 2.0")
-    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Config(sdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withWeeklyRecurrence_shouldCreateCalendarIntent() throws Exception {
         setupCalendarParams();
@@ -394,12 +395,12 @@ public void createCalendarEvent_withWeeklyRecurrence_shouldCreateCalendarIntent(
 
         subject.createCalendarEvent(context, params);
 
-        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent intent = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(intent.getStringExtra(CalendarContract.Events.RRULE)).isEqualTo("FREQ=WEEKLY;");
     }
 
     @Ignore("Mraid 2.0")
-    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Config(sdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withWeeklyRecurrence_withInterval_withOutWeekday_shouldCreateCalendarIntent() throws Exception {
         setupCalendarParams();
@@ -408,12 +409,12 @@ public void createCalendarEvent_withWeeklyRecurrence_withInterval_withOutWeekday
 
         subject.createCalendarEvent(context, params);
 
-        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent intent = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(intent.getStringExtra(CalendarContract.Events.RRULE)).isEqualTo("FREQ=WEEKLY;INTERVAL=7;");
     }
 
     @Ignore("Mraid 2.0")
-    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Config(sdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withWeeklyRecurrence_onAllWeekDays_shouldCreateCalendarIntent() throws Exception {
         setupCalendarParams();
@@ -422,12 +423,12 @@ public void createCalendarEvent_withWeeklyRecurrence_onAllWeekDays_shouldCreateC
 
         subject.createCalendarEvent(context, params);
 
-        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent intent = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(intent.getStringExtra(CalendarContract.Events.RRULE)).isEqualTo("FREQ=WEEKLY;BYDAY=SU,MO,TU,WE,TH,FR,SA;");
     }
 
     @Ignore("Mraid 2.0")
-    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Config(sdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withWeeklyRecurrence_onDuplicateWeekDays_shouldCreateCalendarIntent() throws Exception {
         setupCalendarParams();
@@ -436,12 +437,12 @@ public void createCalendarEvent_withWeeklyRecurrence_onDuplicateWeekDays_shouldC
 
         subject.createCalendarEvent(context, params);
 
-        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent intent = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(intent.getStringExtra(CalendarContract.Events.RRULE)).isEqualTo("FREQ=WEEKLY;BYDAY=WE,TU,SU;");
     }
 
     @Ignore("Mraid 2.0")
-    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Config(sdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withWeeklyRecurrence_withInterval_withWeekDay_shouldCreateCalendarIntent() throws Exception {
         setupCalendarParams();
@@ -451,12 +452,12 @@ public void createCalendarEvent_withWeeklyRecurrence_withInterval_withWeekDay_sh
 
         subject.createCalendarEvent(context, params);
 
-        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent intent = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(intent.getStringExtra(CalendarContract.Events.RRULE)).isEqualTo("FREQ=WEEKLY;INTERVAL=1;BYDAY=MO;");
     }
 
     @Ignore("Mraid 2.0")
-    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Config(sdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withDailyRecurrence_withWeeklyRecurrence_withMonthlyOccurence_shouldCreateDailyCalendarIntent() throws Exception {
         setupCalendarParams();
@@ -468,12 +469,12 @@ public void createCalendarEvent_withDailyRecurrence_withWeeklyRecurrence_withMon
 
         subject.createCalendarEvent(context, params);
 
-        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent intent = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(intent.getStringExtra(CalendarContract.Events.RRULE)).isEqualTo("FREQ=DAILY;INTERVAL=2;");
     }
 
     @Ignore("Mraid 2.0")
-    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Config(sdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withMonthlyRecurrence_withOutInterval_shouldCreateCalendarIntent() throws Exception {
         setupCalendarParams();
@@ -481,12 +482,12 @@ public void createCalendarEvent_withMonthlyRecurrence_withOutInterval_shouldCrea
 
         subject.createCalendarEvent(context, params);
 
-        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent intent = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(intent.getStringExtra(CalendarContract.Events.RRULE)).isEqualTo("FREQ=MONTHLY;");
     }
 
     @Ignore("Mraid 2.0")
-    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Config(sdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withMonthlyRecurrence_withInterval_shouldCreateCalendarIntent() throws Exception {
         setupCalendarParams();
@@ -495,12 +496,12 @@ public void createCalendarEvent_withMonthlyRecurrence_withInterval_shouldCreateC
 
         subject.createCalendarEvent(context, params);
 
-        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent intent = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(intent.getStringExtra(CalendarContract.Events.RRULE)).isEqualTo("FREQ=MONTHLY;INTERVAL=2;");
     }
 
     @Ignore("Mraid 2.0")
-    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Config(sdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withMonthlyRecurrence_withOutInterval_withDaysOfMonth_shouldCreateCalendarIntent() throws Exception {
         setupCalendarParams();
@@ -509,7 +510,7 @@ public void createCalendarEvent_withMonthlyRecurrence_withOutInterval_withDaysOf
 
         subject.createCalendarEvent(context, params);
 
-        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent intent = ShadowApplication.getInstance().getNextStartedActivity();
         assertThat(intent.getStringExtra(CalendarContract.Events.RRULE)).isEqualTo("FREQ=MONTHLY;BYMONTHDAY=2,-15;");
     }
 
@@ -522,7 +523,7 @@ public void createCalendarEvent_withMonthlyRecurrence_withInvalidDaysOfMonth_sho
 
         subject.createCalendarEvent(context, params);
 
-        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent intent = ShadowApplication.getInstance().getNextStartedActivity();
 
         assertThat(intent).isNull();
         assertThat(ShadowLog.getLogs().size()).isEqualTo(1);
@@ -537,14 +538,14 @@ public void createCalendarEvent_withWeeklyRecurrence_withInvalidDaysOfWeek_shoul
 
         subject.createCalendarEvent(context, params);
 
-        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent intent = ShadowApplication.getInstance().getNextStartedActivity();
 
         assertThat(intent).isNull();
         assertThat(ShadowLog.getLogs().size()).isEqualTo(1);
     }
 
     @Ignore("Mraid 2.0")
-    @Config(reportSdk = Build.VERSION_CODES.HONEYCOMB_MR2)
+    @Config(sdk = Build.VERSION_CODES.HONEYCOMB_MR2)
     @Test
     public void createCalendarEvent_beforeIcs_shouldFireErrorEvent() throws Exception {
         subject.createCalendarEvent(context, params);
@@ -586,7 +587,7 @@ public void createCalendarEvent_withNullDate_shouldFireErrorEvent() throws Excep
     }
 
     @Ignore("Mraid 2.0")
-    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Config(sdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void
     createCalendarEvent_withValidParamsAllExceptRecurrence_atLeastICS_shouldCreateEventIntent() throws Exception {
@@ -598,7 +599,7 @@ public void createCalendarEvent_withNullDate_shouldFireErrorEvent() throws Excep
 
         subject.createCalendarEvent(context, params);
 
-        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        Intent intent = ShadowApplication.getInstance().getNextStartedActivity();
 
         assertThat(intent.getType()).isEqualTo(ANDROID_CALENDAR_CONTENT_TYPE);
         assertThat(intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
@@ -640,7 +641,7 @@ public void isSmsAvailable_whenCanNotAcceptIntent_shouldReturnFalse() throws Exc
 
     @Test
     public void isStorePictureAvailable_whenPermissionDeclaredAndMediaMounted_shouldReturnTrue() throws Exception {
-        Robolectric.getShadowApplication().grantPermissions(Manifest.permission.WRITE_EXTERNAL_STORAGE);
+        ShadowApplication.getInstance().grantPermissions(Manifest.permission.WRITE_EXTERNAL_STORAGE);
         ShadowEnvironment.setExternalStorageState(Environment.MEDIA_MOUNTED);
 
         assertThat(subject.isStorePictureSupported(context)).isTrue();
@@ -648,7 +649,7 @@ public void isStorePictureAvailable_whenPermissionDeclaredAndMediaMounted_should
 
     @Test
     public void isStorePictureAvailable_whenPermissionDenied_shouldReturnFalse() throws Exception {
-        Robolectric.getShadowApplication().denyPermissions(Manifest.permission.WRITE_EXTERNAL_STORAGE);
+        ShadowApplication.getInstance().denyPermissions(Manifest.permission.WRITE_EXTERNAL_STORAGE);
         ShadowEnvironment.setExternalStorageState(Environment.MEDIA_MOUNTED);
 
         assertThat(subject.isStorePictureSupported(context)).isFalse();
@@ -656,30 +657,30 @@ public void isStorePictureAvailable_whenPermissionDenied_shouldReturnFalse() thr
 
     @Test
     public void isStorePictureAvailable_whenMediaUnmounted_shouldReturnFalse() throws Exception {
-        Robolectric.getShadowApplication().grantPermissions(Manifest.permission.WRITE_EXTERNAL_STORAGE);
+        ShadowApplication.getInstance().grantPermissions(Manifest.permission.WRITE_EXTERNAL_STORAGE);
         ShadowEnvironment.setExternalStorageState(Environment.MEDIA_UNMOUNTED);
 
         assertThat(subject.isStorePictureSupported(context)).isFalse();
     }
 
-    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void isCalendarAvailable_atLeastIcs_shouldReturnTrue() throws Exception {
+        TestSdkHelper.setReportedSdkLevel(Build.VERSION_CODES.ICE_CREAM_SANDWICH);
         context = createMockContextWithSpecificIntentData(null, null, ANDROID_CALENDAR_CONTENT_TYPE, "android.intent.action.INSERT");
         assertThat(subject.isCalendarAvailable(context)).isTrue();
     }
 
-    @Config(reportSdk = Build.VERSION_CODES.HONEYCOMB_MR2)
     @Test
     public void isCalendarAvailable_beforeIcs_shouldReturnFalse() throws Exception {
+        TestSdkHelper.setReportedSdkLevel(Build.VERSION_CODES.HONEYCOMB_MR2);
         context = createMockContextWithSpecificIntentData(null, null, ANDROID_CALENDAR_CONTENT_TYPE, "android.intent.action.INSERT");
         assertThat(subject.isCalendarAvailable(context)).isFalse();
     }
 
-    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void isCalendarAvailable_atLeastIcs_butCanNotAcceptIntent_shouldReturnFalse() throws
             Exception {
+        TestSdkHelper.setReportedSdkLevel(Build.VERSION_CODES.ICE_CREAM_SANDWICH);
         context = createMockContextWithSpecificIntentData(null, null, "vnd.android.cursor.item/NOPE", "android.intent.action.INSERT");
         assertThat(subject.isCalendarAvailable(context)).isFalse();
     }
@@ -709,13 +710,14 @@ public void isInlineVideoAvailable_whenViewsAreHardwareAccelerated_whenWindowIsN
         assertThat(subject.isInlineVideoAvailable(activity, mockView)).isFalse();
     }
 
-    @Config(reportSdk = Build.VERSION_CODES.HONEYCOMB)
     @TargetApi(11)
     @Test
     public void isInlineVideoAvailable_whenViewsAreHardwareAccelerated_whenWindowIsHardwareAccelerated_whenApiLevelIsLessThanHoneycombMR1_shouldReturnFalse() throws Exception {
         Activity activity = Robolectric.buildActivity(Activity.class).create().get();
         activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
 
+        TestSdkHelper.setReportedSdkLevel(Build.VERSION_CODES.HONEYCOMB);
+
         View mockView = mock(View.class);
         when(mockView.isHardwareAccelerated()).thenReturn(true);
         when(mockView.getLayerType()).thenReturn(View.LAYER_TYPE_HARDWARE);
@@ -855,7 +857,7 @@ public Void answer(InvocationOnMock invocation) throws Throwable {
                 if (!(invocation.getArguments()[0] instanceof Intent)) {
                     throw new ClassCastException("For some reason you are not passing the calendar intent properly");
                 }
-                Context shadowContext = Robolectric.getShadowApplication().getApplicationContext();
+                Context shadowContext = ShadowApplication.getInstance().getApplicationContext();
                 shadowContext.startActivity((Intent) invocation.getArguments()[0]);
                 return null;
             }
diff --git a/mopub-sdk/src/test/java/com/mopub/mraid/MraidVideoViewControllerTest.java b/mopub-sdk/src/test/java/com/mopub/mraid/MraidVideoViewControllerTest.java
index 1ffe7e85..d133ec0d 100644
--- a/mopub-sdk/src/test/java/com/mopub/mraid/MraidVideoViewControllerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mraid/MraidVideoViewControllerTest.java
@@ -6,6 +6,7 @@
 import android.widget.ImageButton;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 import com.mopub.mobileads.EventForwardingBroadcastReceiver;
 
 import org.apache.http.HttpRequest;
@@ -14,10 +15,13 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
-import org.robolectric.shadows.ShadowLocalBroadcastManager;
+import org.robolectric.Shadows;
+import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowVideoView;
-import org.robolectric.tester.org.apache.http.RequestMatcher;
-import org.robolectric.tester.org.apache.http.TestHttpResponse;
+import org.robolectric.shadows.httpclient.FakeHttp;
+import org.robolectric.shadows.httpclient.RequestMatcher;
+import org.robolectric.shadows.httpclient.TestHttpResponse;
+import org.robolectric.shadows.support.v4.ShadowLocalBroadcastManager;
 
 import static android.view.View.GONE;
 import static android.view.View.VISIBLE;
@@ -28,9 +32,9 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
-import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class MraidVideoViewControllerTest {
     private Context context;
     private Bundle bundle;
@@ -46,10 +50,10 @@ public void setUp() throws Exception {
 
         bundle.putString(VIDEO_URL, "http://video_url");
 
-        Robolectric.getUiThreadScheduler().pause();
-        Robolectric.getBackgroundScheduler().pause();
+        Robolectric.getForegroundThreadScheduler().pause();
+        Robolectric.getBackgroundThreadScheduler().pause();
 
-        Robolectric.addHttpResponseRule(new RequestMatcher() {
+        FakeHttp.addHttpResponseRule(new RequestMatcher() {
             @Override
             public boolean matches(HttpRequest request) {
                 return true;
@@ -61,9 +65,9 @@ public boolean matches(HttpRequest request) {
 
     @After
     public void tearDown() throws Exception {
-        Robolectric.getUiThreadScheduler().reset();
-        Robolectric.getBackgroundScheduler().reset();
-        Robolectric.clearPendingHttpResponses();
+        Robolectric.getForegroundThreadScheduler().reset();
+        Robolectric.getBackgroundThreadScheduler().reset();
+        FakeHttp.clearPendingHttpResponses();
 
         ShadowLocalBroadcastManager.getInstance(context).unregisterReceiver(broadcastReceiver);
     }
@@ -71,7 +75,7 @@ public void tearDown() throws Exception {
     @Test
     public void constructor_shouldSetListenersAndVideoPath() throws Exception {
         initializeSubject();
-        ShadowVideoView shadowSubject = shadowOf(subject.getVideoView());
+        ShadowVideoView shadowSubject = Shadows.shadowOf(subject.getVideoView());
 
         assertThat(shadowSubject.getOnCompletionListener()).isNotNull();
         assertThat(shadowSubject.getOnErrorListener()).isNotNull();
@@ -88,7 +92,7 @@ public void onCreate_shouldCreateAndHideCloseButton() throws Exception {
         ImageButton closeButton = getCloseButton();
 
         assertThat(closeButton).isNotNull();
-        assertThat(shadowOf(closeButton).getOnClickListener()).isNotNull();
+        assertThat(Shadows.shadowOf(closeButton).getOnClickListener()).isNotNull();
         assertThat(closeButton.getVisibility()).isEqualTo(GONE);
     }
 
@@ -157,7 +161,7 @@ private void initializeSubject() {
     }
 
     private ShadowVideoView getShadowVideoView() {
-        return shadowOf(subject.getVideoView());
+        return Shadows.shadowOf(subject.getVideoView());
     }
 
     ImageButton getCloseButton() {
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/AdRendererRegistryTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/AdRendererRegistryTest.java
new file mode 100644
index 00000000..aa358452
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/AdRendererRegistryTest.java
@@ -0,0 +1,97 @@
+package com.mopub.nativeads;
+
+import android.app.Activity;
+import android.content.Context;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class AdRendererRegistryTest {
+
+    private AdRendererRegistry subject;
+    private NativeAd mNativeAd;
+    private Context context;
+
+    @Mock
+    MoPubStaticNativeAdRenderer mockRenderer;
+    @Mock
+    BaseNativeAd mockNativeAd;
+
+    @Before
+    public void setUp() {
+        context = Robolectric.buildActivity(Activity.class).create().get();
+        subject = new AdRendererRegistry();
+        mNativeAd = new NativeAd(context, "impression", "click", "adunit",
+                mock(BaseNativeAd.class), mockRenderer);
+        when(mockRenderer.supports(mockNativeAd)).thenReturn(true);
+    }
+
+    @Test
+    public void registerAdRenderer_shouldAddRendererToRegistry() {
+        subject.registerAdRenderer(mockRenderer);
+        assertThat(subject.getRendererIterable()).containsOnly(mockRenderer);
+    }
+
+    @Test
+    public void getRendererCount_shouldReturnCount() {
+        subject.registerAdRenderer(mockRenderer);
+        assertThat(subject.getAdRendererCount()).isEqualTo(1);
+    }
+
+    @Test
+    public void getViewTypeForAd_() {
+        subject.registerAdRenderer(mockRenderer);
+        assertThat(subject.getAdRendererCount()).isEqualTo(1);
+    }
+
+    @Test
+    public void getViewTypeForAd_shouldReturnIndexPlusOneOfMatchedRenderer() {
+        subject.registerAdRenderer(mock(MoPubStaticNativeAdRenderer.class));
+        subject.registerAdRenderer(mockRenderer);
+
+        assertThat(subject.getViewTypeForAd(mNativeAd)).isEqualTo(2);
+    }
+
+    @Test
+    public void getViewTypeForAd_withNoMatchingRednerer_shouldReturn0() {
+        subject.registerAdRenderer(mock(MoPubStaticNativeAdRenderer.class));
+
+        assertThat(subject.getViewTypeForAd(mNativeAd)).isEqualTo(0);
+    }
+
+    @Test
+    public void getRendererForAd_shouldReturnRendererSupportingNativeAd() {
+        subject.registerAdRenderer(mockRenderer);
+        subject.registerAdRenderer(mock(MoPubStaticNativeAdRenderer.class));
+
+        assertThat(subject.getRendererForAd(mockNativeAd)).isEqualTo(mockRenderer);
+    }
+
+    @Test
+    public void getRendererForAd_withNoSupportingRenderer_shouldReturnNull() {
+        subject.registerAdRenderer(mock(MoPubStaticNativeAdRenderer.class));
+
+        assertThat(subject.getRendererForAd(mockNativeAd)).isEqualTo(null);
+    }
+
+    @Test
+    public void getRendererForViewType_shouldReturnRendererSupportingNativeAd() {
+    }
+
+    @Test
+    public void getRendererForViewType_withNoSupportingRenderer_shouldReturnNull() {
+    }
+}
\ No newline at end of file
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/AdapterHelperTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/AdapterHelperTest.java
index a2f85dbd..a9b49fa1 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/AdapterHelperTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/AdapterHelperTest.java
@@ -4,16 +4,19 @@
 import android.content.Context;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class AdapterHelperTest {
     private AdapterHelper subject;
     private Activity context;
@@ -37,9 +40,8 @@ public void constructor_whenPassedAnApplicationContext_shouldThrowIllegalArgumen
     @Test
     public void getAdView_withNullActivityContext_shouldReturnEmptyViewWithApplicationContext() {
         subject.clearActivityContext();
-        Context viewContext = subject.getAdView(null, null, mock(NativeResponse.class),
-                mock(ViewBinder.class),
-                null).getContext();
+        Context viewContext = subject.getAdView(null, null, mock(NativeAd.class),
+                mock(ViewBinder.class)).getContext();
         assertThat(viewContext).isEqualTo(context.getApplication());
     }
 
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/BaseNativeAdTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/BaseNativeAdTest.java
new file mode 100644
index 00000000..a697fbb0
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/BaseNativeAdTest.java
@@ -0,0 +1,69 @@
+package com.mopub.nativeads;
+
+import android.support.annotation.NonNull;
+import android.view.View;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
+import com.mopub.nativeads.BaseNativeAd.NativeEventListener;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.annotation.Config;
+
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class BaseNativeAdTest {
+
+    private BaseNativeAd subject;
+    @Mock NativeEventListener mockEventListener;
+
+    @Before
+    public void setUp() {
+        subject = new BaseNativeAd() {
+            @Override
+            public void prepare(@NonNull View view) { }
+
+            @Override
+            public void clear(@NonNull View view) { }
+
+            @Override
+            public void destroy() { }
+        };
+    }
+
+    @Test
+    public void notifyAdImpressed_withListenerSet_shouldCallOnAdImpressed() {
+        subject.setNativeEventListener(mockEventListener);
+        subject.notifyAdImpressed();
+
+        verify(mockEventListener).onAdImpressed();
+    }
+
+    @Test
+    public void notifyAdImpressed_withoutListenerSet_shouldNotCallOnAdImpressed() {
+        subject.notifyAdImpressed();
+
+        verifyNoMoreInteractions(mockEventListener);
+    }
+
+    @Test
+    public void notifyAdClicked_withListenerSet_shouldCallOnAdClicked() {
+        subject.setNativeEventListener(mockEventListener);
+        subject.notifyAdClicked();
+
+        verify(mockEventListener).onAdClicked();
+    }
+
+    @Test
+    public void notifyAdClicked_withoutListenerSet_shouldNotCallOnAdClicked() {
+        subject.notifyAdClicked();
+
+        verifyNoMoreInteractions(mockEventListener);
+    }
+}
\ No newline at end of file
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/CustomEventNativeAdapterTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/CustomEventNativeAdapterTest.java
index 6a067014..c11abba5 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/CustomEventNativeAdapterTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/CustomEventNativeAdapterTest.java
@@ -3,15 +3,19 @@
 import android.app.Activity;
 
 import com.mopub.common.AdType;
+import com.mopub.common.DataKeys;
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 import com.mopub.nativeads.test.support.TestCustomEventNativeFactory;
 import com.mopub.network.AdResponse;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
 
 import java.util.HashMap;
+import java.util.Map;
 
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
@@ -20,6 +24,7 @@
 import static org.mockito.Mockito.verify;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class CustomEventNativeAdapterTest {
 
     private Activity context;
@@ -38,8 +43,9 @@ public void setUp() throws Exception {
         serverExtras.put("key", "value");
 
         testAdResponse = new AdResponse.Builder()
-                .setAdType(AdType.NATIVE)
+                .setAdType(AdType.STATIC_NATIVE)
                 .setCustomEventClassName("com.mopub.nativeads.MoPubCustomEventNative")
+                .setClickTrackingUrl("clicktrackingurl")
                 .setResponseBody("body")
                 .setServerExtras(serverExtras)
                 .build();
@@ -51,10 +57,12 @@ public void setUp() throws Exception {
 
     @Test
     public void loadNativeAd_withValidInput_shouldCallLoadNativeAdOnTheCustomEvent() throws Exception {
+        Map<String, Object> expectedLocalExtras = new HashMap<String, Object>();
+        expectedLocalExtras.put(DataKeys.CLICK_TRACKING_URL_KEY, "clicktrackingurl");
         CustomEventNativeAdapter.loadNativeAd(context, localExtras, testAdResponse, mCustomEventNativeListener);
-        verify(mCustomEventNative).loadNativeAd(context, mCustomEventNativeListener, localExtras, serverExtras);
+        verify(mCustomEventNative).loadNativeAd(context, mCustomEventNativeListener, expectedLocalExtras, serverExtras);
         verify(mCustomEventNativeListener, never()).onNativeAdFailed(any(NativeErrorCode.class));
-        verify(mCustomEventNativeListener, never()).onNativeAdLoaded(any(NativeAdInterface.class));
+        verify(mCustomEventNativeListener, never()).onNativeAdLoaded(any(BaseNativeAd.class));
     }
 
     @Test
@@ -65,7 +73,7 @@ public void loadNativeAd_withInvalidClassName_shouldNotifyListenerOfOnNativeAdFa
 
         CustomEventNativeAdapter.loadNativeAd(context, localExtras, testAdResponse, mCustomEventNativeListener);
         verify(mCustomEventNativeListener).onNativeAdFailed(NativeErrorCode.NATIVE_ADAPTER_NOT_FOUND);
-        verify(mCustomEventNativeListener, never()).onNativeAdLoaded(any(NativeAdInterface.class));
+        verify(mCustomEventNativeListener, never()).onNativeAdLoaded(any(BaseNativeAd.class));
         verify(mCustomEventNative, never()).loadNativeAd(context, mCustomEventNativeListener, localExtras, serverExtras);
     }
 
@@ -78,6 +86,6 @@ public void loadNativeAd_withInvalidCustomEventNativeData_shouldNotAddToServerEx
         CustomEventNativeAdapter.loadNativeAd(context, localExtras, testAdResponse, mCustomEventNativeListener);
         verify(mCustomEventNative).loadNativeAd(eq(context), eq(mCustomEventNativeListener), eq(localExtras), eq(new HashMap<String, String>()));
         verify(mCustomEventNativeListener, never()).onNativeAdFailed(any(NativeErrorCode.class));
-        verify(mCustomEventNativeListener, never()).onNativeAdLoaded(any(NativeAdInterface.class));
+        verify(mCustomEventNativeListener, never()).onNativeAdLoaded(any(BaseNativeAd.class));
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/HttpDiskCompositeDataSourceTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/HttpDiskCompositeDataSourceTest.java
new file mode 100644
index 00000000..24f3725b
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/HttpDiskCompositeDataSourceTest.java
@@ -0,0 +1,493 @@
+package com.mopub.nativeads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.net.Uri;
+
+import com.google.android.exoplayer.upstream.DataSpec;
+import com.google.android.exoplayer.upstream.HttpDataSource;
+import com.mopub.common.CacheService;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+
+import java.util.Arrays;
+import java.util.Random;
+import java.util.TreeSet;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.refEq;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.verifyZeroInteractions;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class HttpDiskCompositeDataSourceTest {
+
+    private static final int BASE_SEED = 1234567890;
+    @Mock HttpDataSource mockHttpDataSource;
+    private HttpDiskCompositeDataSource subject;
+    private DataSpec dataSpec;
+    private Uri uri;
+
+
+    @Before
+    public void setUp() throws Exception {
+        Context context = Robolectric.buildActivity(Activity.class).create().get();
+        CacheService.initialize(context);
+        subject = new HttpDiskCompositeDataSource(context, "userAgent", null, mockHttpDataSource);
+        uri = new Uri.Builder().scheme("http").path("www.someurl").build();
+        dataSpec = new DataSpec(uri, 0, -1, null);
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        CacheService.clearAndNullCaches();
+    }
+
+    @Test
+    public void open_withNullDataSpecUri_shouldReturnLengthUnbounded() throws Exception {
+        DataSpec dataSpecWithNullUri = new DataSpec(null);
+
+        final long result = subject.open(dataSpecWithNullUri);
+
+        assertThat(result).isEqualTo(HttpDiskCompositeDataSource.LENGTH_UNBOUNDED);
+        verifyZeroInteractions(mockHttpDataSource);
+    }
+
+    @Test
+    public void open_withNoCachedData_shouldOpenHttpDataSource() throws Exception {
+        when(mockHttpDataSource.open(any(DataSpec.class))).thenReturn(200000L);
+
+        long result = subject.open(dataSpec);
+
+        assertThat(result).isEqualTo(200000L);
+        verify(mockHttpDataSource).open(refEq(dataSpec));
+        verifyNoMoreInteractions(mockHttpDataSource);
+    }
+
+    @Test
+    public void open_withAllDataCached_shouldNotOpenHttpDataSource() throws Exception {
+        // When the entire file is cached, there's no need to open the network.
+        when(mockHttpDataSource.open(any(DataSpec.class))).thenReturn(100000L);
+        byte[] data = generateRandomByteArray(100000, 0);
+        byte[] expectedFileSize = "100000".getBytes();
+        byte[] intervals = "[\"{start : 0, length : 100000}\"]".getBytes();
+        CacheService.putToDiskCache("0" + uri.toString(), data);
+        CacheService.putToDiskCache(
+                HttpDiskCompositeDataSource.EXPECTED_FILE_SIZE_KEY_PREFIX + uri.toString(),
+                expectedFileSize);
+        CacheService.putToDiskCache(
+                HttpDiskCompositeDataSource.INTERVALS_KEY_PREFIX + uri.toString(), intervals);
+
+        long result = subject.open(dataSpec);
+
+        assertThat(result).isEqualTo(100000);
+        verifyZeroInteractions(mockHttpDataSource);
+    }
+
+    @Test
+    public void open_withSomeDataCached_shouldOpenHttpDataSourceAtAppropriateStartPoint() throws Exception {
+        // The idea behind this test is that we think we have the first 33333 bytes and need to ask
+        // the network for byte 33333 and onward.
+        when(mockHttpDataSource.open(any(DataSpec.class))).thenReturn(100000L);
+        byte[] data = generateRandomByteArray(100000, 0);
+        byte[] expectedFileSize = "100000".getBytes();
+        byte[] intervals = "[\"{start : 0, length : 33333}\"]".getBytes();
+        CacheService.putToDiskCache("0" + uri.toString(), data);
+        CacheService.putToDiskCache(
+                HttpDiskCompositeDataSource.EXPECTED_FILE_SIZE_KEY_PREFIX + uri.toString(),
+                expectedFileSize);
+        CacheService.putToDiskCache(
+                HttpDiskCompositeDataSource.INTERVALS_KEY_PREFIX + uri.toString(), intervals);
+
+        long result = subject.open(dataSpec);
+
+        assertThat(result).isEqualTo(100000);
+        DataSpec expectedDataSpec = new DataSpec(dataSpec.uri, 33333, -1, null);
+        // Using refEq because equals() is just the Java default, and they're not the same object.
+        verify(mockHttpDataSource).open(refEq(expectedDataSpec));
+    }
+
+    @Test
+    public void read_with2048ExpectedBytes_shouldFillBufferWith2048Bytes_shouldReturnNumberOfBytesRead2048() throws Exception {
+        // This is the case where we're reading from a cache that has all the necessary bytes
+        byte[] data = generateRandomByteArray(100000, 0);
+        byte[] expectedFileSize = "100000".getBytes();
+        byte[] intervals = "[\"{start : 0, length : 100000}\"]".getBytes();
+        // Pretend we have all the bytes in the cache, complete with the expected file size and
+        // a valid intervals set.
+        CacheService.putToDiskCache("0" + uri.toString(), data);
+        CacheService.putToDiskCache(
+                HttpDiskCompositeDataSource.EXPECTED_FILE_SIZE_KEY_PREFIX + uri.toString(),
+                expectedFileSize);
+        CacheService.putToDiskCache(
+                HttpDiskCompositeDataSource.INTERVALS_KEY_PREFIX + uri.toString(), intervals);
+        byte[] readBuffer = new byte[2048];
+
+        subject.open(dataSpec);
+        int bytesRead = subject.read(readBuffer, 0, 2048);
+
+        // Verify that all 2048 bytes are expected and that the return value of read() is 2048
+        assertThat(bytesRead).isEqualTo(2048);
+        byte[] expectedData = new byte[2048];
+        System.arraycopy(data, 0, expectedData, 0, 2048);
+        assertThat(readBuffer).isEqualTo(expectedData);
+        verifyZeroInteractions(mockHttpDataSource);
+    }
+
+    @Test
+    public void read_withAllDataCached_whenReadingAcrossSegmentBoundaries_shouldReturnAllBytes() throws Exception {
+        // This is the case where we're reading from a cache that has all the necessary bytes, but
+        // some of it is in the next block. We need to finish reading from the current block, set
+        // up reading from the next block, and then do it.
+        byte[] data1 = generateRandomByteArray(HttpDiskCompositeDataSource.BLOCK_SIZE, 0);
+        byte[] data2 = generateRandomByteArray(HttpDiskCompositeDataSource.BLOCK_SIZE, 1);
+        String expectedFileLengthString = String.valueOf(
+                2 * HttpDiskCompositeDataSource.BLOCK_SIZE);
+        byte[] intervals = ("[\"{start : 0, length : " + expectedFileLengthString + "}\"]").getBytes();
+        CacheService.putToDiskCache("0" + uri.toString(), data1);
+        CacheService.putToDiskCache("1" + uri.toString(), data2);
+        CacheService.putToDiskCache(
+                HttpDiskCompositeDataSource.EXPECTED_FILE_SIZE_KEY_PREFIX + uri.toString(),
+                expectedFileLengthString.getBytes());
+        CacheService.putToDiskCache(
+                HttpDiskCompositeDataSource.INTERVALS_KEY_PREFIX + uri.toString(), intervals);
+        // Expect to read the last 1337 bytes from the first block and the rest from the second block
+        DataSpec modifiedDataSpec = new DataSpec(dataSpec.uri,
+                HttpDiskCompositeDataSource.BLOCK_SIZE - 1337, -1, null);
+        byte[] readBuffer = new byte[4096];
+
+        subject.open(modifiedDataSpec);
+        int bytesRead = subject.read(readBuffer, 0, 4096);
+
+        assertThat(bytesRead).isEqualTo(4096);
+        byte[] expectedBytes = new byte[4096];
+        System.arraycopy(data1, HttpDiskCompositeDataSource.BLOCK_SIZE - 1337, expectedBytes, 0,
+                1337);
+        System.arraycopy(data2, 0, expectedBytes, 1337, 4096 - 1337);
+        assertThat(readBuffer).isEqualTo(expectedBytes);
+        verifyZeroInteractions(mockHttpDataSource);
+    }
+
+    @Test
+    public void read_withEmptyCache_shouldReadBytesFromNetwork() throws Exception {
+        // Sets up an empty cache and read directly from the network
+        final byte[] bytesFromNetwork = generateRandomByteArray(2048, 0);
+        when(mockHttpDataSource.open(any(DataSpec.class))).thenReturn(100000L);
+        setUpMockHttpDataSourceToReturnBytesFromNetwork(bytesFromNetwork, mockHttpDataSource);
+        byte[] readBuffer = new byte[2048];
+
+        subject.open(dataSpec);
+        int bytesRead = subject.read(readBuffer, 0, 2048);
+
+        assertThat(bytesRead).isEqualTo(2048);
+        assertThat(readBuffer).isEqualTo(bytesFromNetwork);
+        verify(mockHttpDataSource).open(refEq(dataSpec));
+        verify(mockHttpDataSource).read(any(byte[].class), eq(0), eq(2048));
+        verifyNoMoreInteractions(mockHttpDataSource);
+    }
+
+    @Test
+    public void read_withSomeDataInCache_shouldReadRestOfBytesFromNetwork() throws Exception {
+        // This is the case where there is some data in the cache, and we run out of cached data.
+        // The rest of the bytes are from the network.
+        final byte[] bytesFromNetwork = generateRandomByteArray(2048, 0);
+        when(mockHttpDataSource.open(any(DataSpec.class))).thenReturn(100000L);
+        setUpMockHttpDataSourceToReturnBytesFromNetwork(bytesFromNetwork, mockHttpDataSource);
+        byte[] data = generateRandomByteArray(2048, 1);
+        byte[] segment0 = new byte[HttpDiskCompositeDataSource.BLOCK_SIZE];
+        byte[] expectedFileSize = "100000".getBytes();
+        byte[] intervals = ("[\"{start : 0, length : 2048}\"]").getBytes();
+        // So we have the first 2048 bytes in the cache
+        System.arraycopy(data, 0, segment0, 0, 2048);
+        CacheService.putToDiskCache("0" + uri.toString(), segment0);
+        CacheService.putToDiskCache(
+                HttpDiskCompositeDataSource.EXPECTED_FILE_SIZE_KEY_PREFIX + uri.toString(),
+                expectedFileSize);
+        CacheService.putToDiskCache(
+                HttpDiskCompositeDataSource.INTERVALS_KEY_PREFIX + uri.toString(), intervals);
+        // However, we want to read 4096 bytes (We have to go to the network for the rest).
+        byte[] readBuffer = new byte[4096];
+
+        subject.open(dataSpec);
+        int bytesRead = subject.read(readBuffer, 0, 4096);
+
+        // Make sure that the bytes read have both the first 2048 bytes from the cache and the 2048
+        // bytes from the network.
+        assertThat(bytesRead).isEqualTo(4096);
+        byte[] expectedBytes = new byte[4096];
+        System.arraycopy(data, 0, expectedBytes, 0, 2048);
+        System.arraycopy(bytesFromNetwork, 0, expectedBytes, 2048, 2048);
+        assertThat(readBuffer).isEqualTo(expectedBytes);
+        DataSpec modifiedDataSpec = new DataSpec(dataSpec.uri, 2048, -1, null);
+        verify(mockHttpDataSource).open(refEq(modifiedDataSpec));
+        // Verify that we stored the bytes from network starting from index 2048 for 2048 bytes
+        verify(mockHttpDataSource).read(any(byte[].class), eq(2048), eq(2048));
+        verifyNoMoreInteractions(mockHttpDataSource);
+    }
+
+    @Test
+    public void read_withSomeDataInCacheBeforeBlockBoundary_whenApproachingBlockBoundary_shouldReadBytesFromDisk_shouldReadBytesFromNetwork_shouldSetUpNextBlock() throws Exception {
+        // This is the situation where the cache ends 1024 bytes before the second block boundary.
+        // We need to read the first 1024 bytes from the cache, read the next 3072 bytes, store
+        // the first 1024 bytes in the current block, close it out, flush it, set up the next block,
+        // and store the next 2048 bytes into that block.
+        final byte[] bytesFromNetwork = generateRandomByteArray(3072, 0);
+        when(mockHttpDataSource.open(any(DataSpec.class))).thenReturn(
+                (long) (HttpDiskCompositeDataSource.BLOCK_SIZE * 4));
+        setUpMockHttpDataSourceToReturnBytesFromNetwork(bytesFromNetwork, mockHttpDataSource);
+        byte[] data = generateRandomByteArray(HttpDiskCompositeDataSource.BLOCK_SIZE, 1);
+        byte[] expectedFileSize = String.valueOf(
+                HttpDiskCompositeDataSource.BLOCK_SIZE * 4).getBytes();
+        // Typical access patterns of video is to request for the first 44 bytes, the last 3886
+        // bytes, and then start at byte 44 and request till the end of the video. We are pretending
+        // that we did that, and stopped 1024 bytes before the end of the 2nd block.
+        byte[] intervals = ("[\"{start : 0, length : 44}\", \"{start : " +
+                (HttpDiskCompositeDataSource.BLOCK_SIZE * 4 - 3886) +
+                ", length : 3886}\", \"{start : 44, length : " +
+                (HttpDiskCompositeDataSource.BLOCK_SIZE * 2 - 1024 - 44) + "}\"]")
+                .getBytes();
+        CacheService.putToDiskCache("1" + uri.toString(), data);
+        CacheService.putToDiskCache(
+                HttpDiskCompositeDataSource.EXPECTED_FILE_SIZE_KEY_PREFIX + uri.toString(),
+                expectedFileSize);
+        CacheService.putToDiskCache(
+                HttpDiskCompositeDataSource.INTERVALS_KEY_PREFIX + uri.toString(), intervals);
+        byte[] readBuffer = new byte[4096];
+        dataSpec = new DataSpec(dataSpec.uri, 2 * HttpDiskCompositeDataSource.BLOCK_SIZE - 2048, -1,
+                dataSpec.key, dataSpec.flags);
+
+        subject.open(dataSpec);
+        int bytesRead = subject.read(readBuffer, 0, 4096);
+
+        assertThat(bytesRead).isEqualTo(4096);
+        byte[] expectedBytes = new byte[4096];
+        System.arraycopy(data, HttpDiskCompositeDataSource.BLOCK_SIZE - 2048, expectedBytes, 0,
+                1024);
+        System.arraycopy(bytesFromNetwork, 0, expectedBytes, 1024, 3072);
+        assertThat(readBuffer).isEqualTo(expectedBytes);
+        DataSpec modifiedDataSpec = new DataSpec(dataSpec.uri,
+                2 * HttpDiskCompositeDataSource.BLOCK_SIZE - 1024, -1, null);
+        verify(mockHttpDataSource).open(refEq(modifiedDataSpec));
+        verify(mockHttpDataSource).read(any(byte[].class), eq(1024), eq(3072));
+        // Also verify that the 2nd block was written to disk correctly.
+        byte[] expectedBlock = new byte[HttpDiskCompositeDataSource.BLOCK_SIZE];
+        System.arraycopy(data, 0, expectedBlock, 0, HttpDiskCompositeDataSource.BLOCK_SIZE - 1024);
+        System.arraycopy(bytesFromNetwork, 0, expectedBlock,
+                HttpDiskCompositeDataSource.BLOCK_SIZE - 1024, 1024);
+        assertThat(CacheService.getFromDiskCache("1" + uri.toString())).isEqualTo(
+                expectedBlock);
+    }
+
+    @Test
+    public void close_withoutFirstCallingOpen_shouldNotWriteToDisk() throws Exception {
+        subject.close();
+
+        assertThat(CacheService.containsKeyDiskCache("0" + uri.toString())).isFalse();
+        assertThat(CacheService.containsKeyDiskCache(
+                HttpDiskCompositeDataSource.EXPECTED_FILE_SIZE_KEY_PREFIX + uri.toString())).isFalse();
+        assertThat(CacheService.containsKeyDiskCache(
+                HttpDiskCompositeDataSource.INTERVALS_KEY_PREFIX + uri.toString())).isFalse();
+    }
+
+    @Test
+    public void close_withCurrentActiveBlock_shouldWriteToDisk() throws Exception {
+        // Verifying that close() actually writes the current data to disk
+        final byte[] bytesFromNetwork = generateRandomByteArray(1000, 0);
+        when(mockHttpDataSource.open(any(DataSpec.class))).thenReturn(5000L);
+        setUpMockHttpDataSourceToReturnBytesFromNetwork(bytesFromNetwork, mockHttpDataSource);
+        byte[] readBuffer = new byte[1000];
+
+        subject.open(dataSpec);
+        subject.read(readBuffer, 0, 1000);
+        subject.close();
+
+        assertThat(readBuffer).isEqualTo(bytesFromNetwork);
+        byte[] expectedBlock = new byte[HttpDiskCompositeDataSource.BLOCK_SIZE];
+        System.arraycopy(bytesFromNetwork, 0, expectedBlock, 0, 1000);
+        assertThat(CacheService.getFromDiskCache("0" + uri.toString())).isEqualTo(expectedBlock);
+        assertThat(CacheService.getFromDiskCache(
+                HttpDiskCompositeDataSource.EXPECTED_FILE_SIZE_KEY_PREFIX + uri.toString())).isEqualTo(
+                "5000".getBytes());
+        assertThat(CacheService.getFromDiskCache(
+                HttpDiskCompositeDataSource.INTERVALS_KEY_PREFIX + uri.toString())).isEqualTo(
+                "[\"{start : 0, length : 1000}\"]".getBytes());
+    }
+
+    @Test
+    public void addNewInterval_shouldAddNewIntervalToIntervals() {
+        IntInterval interval = new IntInterval(5, 42);
+        TreeSet<IntInterval> intervalList = new TreeSet<IntInterval>();
+
+        HttpDiskCompositeDataSource.addNewInterval(intervalList, 5, 42);
+
+        assertThat(intervalList).containsOnly(interval);
+    }
+
+    @Test
+    public void addNewInterval_withExistingInterval_shouldNotAddNewInterval() {
+        IntInterval interval1 = new IntInterval(5, 42);
+        IntInterval interval2 = new IntInterval(500, 200);
+        TreeSet<IntInterval> intervalList = new TreeSet<IntInterval>();
+        intervalList.add(interval1);
+        intervalList.add(interval2);
+
+        HttpDiskCompositeDataSource.addNewInterval(intervalList, 5, 42);
+
+        assertThat(intervalList).containsOnly(interval1, interval2);
+    }
+
+    @Test
+    public void addNewInterval_withExistingIntervalInParts_shouldNotAddNewInterval() {
+        // The union of these two intervals is 5 with a length of 45 (ie. from 5 to 50).
+        // An interval from 7 to 50 (start at 7, length 43) should not be added to the interval set.
+        IntInterval interval1 = new IntInterval(10, 40);
+        IntInterval interval2 = new IntInterval(5, 20);
+        TreeSet<IntInterval> intervalList = new TreeSet<IntInterval>();
+        intervalList.add(interval1);
+        intervalList.add(interval2);
+
+        HttpDiskCompositeDataSource.addNewInterval(intervalList, 7, 43);
+
+        assertThat(intervalList).containsOnly(interval1, interval2);
+    }
+
+    @Test
+    public void addNewInterval_withNonExistingIntervals_shouldAddNewInterval() {
+        // The existing intervals here are from 10 to 100 and 150 to 250. 7 to 50 is not part of
+        // that, even though the first interval already has part of that covered, 7 to 9 is not
+        // covered by anything, so this interval should be added.
+        IntInterval interval1 = new IntInterval(10, 90);
+        IntInterval interval2 = new IntInterval(150, 100);
+        TreeSet<IntInterval> intervalList = new TreeSet<IntInterval>();
+        intervalList.add(interval1);
+        intervalList.add(interval2);
+
+        HttpDiskCompositeDataSource.addNewInterval(intervalList, 7, 43);
+
+        assertThat(intervalList).containsExactly(new IntInterval(7, 43), interval1, interval2);
+    }
+
+    @Test
+    public void getFirstContiguousPointAfter_withNoIntervals_shouldReturnInput() {
+        TreeSet<IntInterval> intervalList = new TreeSet<IntInterval>();
+        int startPoint = 12345;
+
+        int firstContiguousPointAfterStartPoint = HttpDiskCompositeDataSource.getFirstContiguousPointAfter(
+                startPoint, intervalList);
+
+        assertThat(firstContiguousPointAfterStartPoint).isEqualTo(startPoint);
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void getFirstContiguousPointAfter_withMultipleConnectedAndDisconnectedIntervals_shouldReturnFirstContiguousPointAfterStartPoint() {
+        IntInterval[] intervalArray = new IntInterval[8];
+
+        // Goes from 500 to 1250
+        intervalArray[0] = new IntInterval(500, 200);
+        intervalArray[1] = new IntInterval(700, 300);
+        intervalArray[2] = new IntInterval(1000, 250);
+
+        // Separate section that goes from 2000 to 3000
+        intervalArray[3] = new IntInterval(2000, 1000);
+
+        // Goes from 3500 to 4500 but with various sections that overlap
+        intervalArray[4] = new IntInterval(3500, 750);
+        intervalArray[5] = new IntInterval(4000, 100);
+        intervalArray[6] = new IntInterval(4050, 200);
+        intervalArray[7] = new IntInterval(3999, 501);
+
+        TreeSet<IntInterval> intervalList = new TreeSet(Arrays.asList(intervalArray));
+
+        // Before the first section
+        int result = HttpDiskCompositeDataSource.getFirstContiguousPointAfter(499, intervalList);
+        assertThat(result).isEqualTo(499);
+
+        // At the start of the first section
+        result = HttpDiskCompositeDataSource.getFirstContiguousPointAfter(500, intervalList);
+        assertThat(result).isEqualTo(1250);
+
+        // In the first section
+        result = HttpDiskCompositeDataSource.getFirstContiguousPointAfter(567, intervalList);
+        assertThat(result).isEqualTo(1250);
+
+        // Between the first section and the second section
+        result = HttpDiskCompositeDataSource.getFirstContiguousPointAfter(1337, intervalList);
+        assertThat(result).isEqualTo(1337);
+
+        // In the second section
+        result = HttpDiskCompositeDataSource.getFirstContiguousPointAfter(2222, intervalList);
+        assertThat(result).isEqualTo(3000);
+
+        // Between the second section and the third section
+        result = HttpDiskCompositeDataSource.getFirstContiguousPointAfter(3232, intervalList);
+        assertThat(result).isEqualTo(3232);
+
+        // At the start of the third section
+        result = HttpDiskCompositeDataSource.getFirstContiguousPointAfter(3500, intervalList);
+        assertThat(result).isEqualTo(4500);
+
+        // In the third section
+        result = HttpDiskCompositeDataSource.getFirstContiguousPointAfter(3789, intervalList);
+        assertThat(result).isEqualTo(4500);
+
+        // After the third section
+        result = HttpDiskCompositeDataSource.getFirstContiguousPointAfter(4501, intervalList);
+        assertThat(result).isEqualTo(4501);
+    }
+
+    /**
+     * Creates a byte array and fills it with random data. Use the seed offset to generate
+     * subsequent random byte arrays that are not the same random byte array.
+     *
+     * @param length     How many bytes in the byte array
+     * @param seedOffset Offsets the seed so that different, random byte arrays can be created
+     * @return byte array of specified length filled with random bytes\
+     */
+    private byte[] generateRandomByteArray(int length, int seedOffset) {
+        byte[] byteArray = new byte[length];
+        new Random(BASE_SEED + seedOffset).nextBytes(byteArray);
+        return byteArray;
+    }
+
+    /**
+     * Sets up the mock http data source to return the specified bytes when queried.
+     *
+     * @param bytesFromNetwork   The bytes to write to the buffer.
+     * @param mockHttpDataSource The mock object that does this.
+     * @throws HttpDataSource.HttpDataSourceException This should never happen since this is a
+     *                                                mock.
+     */
+    private static void setUpMockHttpDataSourceToReturnBytesFromNetwork(
+            final byte[] bytesFromNetwork,
+            final HttpDataSource mockHttpDataSource) throws HttpDataSource.HttpDataSourceException {
+        when(mockHttpDataSource.read(any(byte[].class), anyInt(), anyInt())).thenAnswer(
+                new Answer<Long>() {
+                    @Override
+                    public Long answer(final InvocationOnMock invocation) throws Throwable {
+                        final Object[] args = invocation.getArguments();
+                        final byte[] byteBuffer = (byte[]) args[0];
+                        final Integer offset = (Integer) args[1];
+                        final Integer length = (Integer) args[2];
+                        System.arraycopy(bytesFromNetwork, 0, byteBuffer, offset, length);
+                        return (long) length;
+                    }
+                });
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/ImpressionTrackerTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/ImpressionTrackerTest.java
index 0bba4e12..6df8b430 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/ImpressionTrackerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/ImpressionTrackerTest.java
@@ -4,6 +4,7 @@
 import android.view.View;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 
 import org.fest.util.Lists;
 import org.junit.Before;
@@ -11,11 +12,11 @@
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowSystemClock;
 
 import java.util.HashMap;
 
-import static com.mopub.nativeads.MoPubNative.MoPubNativeListener;
 import static com.mopub.nativeads.VisibilityTracker.VisibilityChecker;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
@@ -26,15 +27,15 @@
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class ImpressionTrackerTest {
     private ImpressionTracker subject;
-    private TimestampWrapper<NativeResponse> timeStampWrapper;
-    private HashMap<View, NativeResponse> trackedViews;
-    private HashMap<View, TimestampWrapper<NativeResponse>> pollingViews;
+    private TimestampWrapper<ImpressionInterface> timeStampWrapper;
+    private HashMap<View, ImpressionInterface> trackedViews;
+    private HashMap<View, TimestampWrapper<ImpressionInterface>> pollingViews;
 
-    @Mock private NativeResponse nativeResponse;
-    @Mock private NativeResponse nativeResponse2;
-    @Mock private MoPubNativeListener moPubNativeListener;
+    @Mock private ImpressionInterface impressionInterface;
+    @Mock private ImpressionInterface impressionInterface2;
     @Mock private VisibilityTracker visibilityTracker;
     @Mock private Handler handler;
     @Mock private View view;
@@ -45,18 +46,18 @@ public void setUp() {
         view = VisibilityTrackerTest.createViewMock(View.VISIBLE, 100, 100, 100, 100, true, true);
         view2 = VisibilityTrackerTest.createViewMock(View.VISIBLE, 100, 100, 100, 100, true, true);
 
-        pollingViews = new HashMap<View, TimestampWrapper<NativeResponse>>(10);
-        trackedViews = new HashMap<View, NativeResponse>(10);
+        pollingViews = new HashMap<View, TimestampWrapper<ImpressionInterface>>(10);
+        trackedViews = new HashMap<View, ImpressionInterface>(10);
         final VisibilityChecker visibilityChecker = new VisibilityChecker();
         subject = new ImpressionTracker(trackedViews, pollingViews, visibilityChecker,
                 visibilityTracker, handler);
 
-        timeStampWrapper = new TimestampWrapper<NativeResponse>(nativeResponse);
+        timeStampWrapper = new TimestampWrapper<ImpressionInterface>(impressionInterface);
 
-        when(nativeResponse.getImpressionMinPercentageViewed()).thenReturn(50);
-        when(nativeResponse.getImpressionMinTimeViewed()).thenReturn(1000);
-        when(nativeResponse2.getImpressionMinPercentageViewed()).thenReturn(50);
-        when(nativeResponse2.getImpressionMinTimeViewed()).thenReturn(1000);
+        when(impressionInterface.getImpressionMinPercentageViewed()).thenReturn(50);
+        when(impressionInterface.getImpressionMinTimeViewed()).thenReturn(1000);
+        when(impressionInterface2.getImpressionMinPercentageViewed()).thenReturn(50);
+        when(impressionInterface2.getImpressionMinTimeViewed()).thenReturn(1000);
 
         // XXX We need this to ensure that our SystemClock starts
         ShadowSystemClock.uptimeMillis();
@@ -64,99 +65,89 @@ public void setUp() {
 
     @Test
     public void addView_shouldAddViewToTrackedViews_shouldAddViewToVisibilityTracker() {
-        subject.addView(view, nativeResponse);
+        subject.addView(view, impressionInterface);
 
         assertThat(trackedViews).hasSize(1);
-        assertThat(trackedViews.get(view)).isEqualTo(nativeResponse);
-        verify(visibilityTracker).addView(view, nativeResponse.getImpressionMinPercentageViewed());
+        assertThat(trackedViews.get(view)).isEqualTo(impressionInterface);
+        verify(visibilityTracker).addView(view, impressionInterface
+                .getImpressionMinPercentageViewed());
     }
 
     @Test
     public void addView_withRecordedImpression_shouldNotAddView() {
-        when(nativeResponse.getRecordedImpression()).thenReturn(true);
+        when(impressionInterface.isImpressionRecorded()).thenReturn(true);
 
-        subject.addView(view, nativeResponse);
+        subject.addView(view, impressionInterface);
 
         assertThat(trackedViews).hasSize(0);
         verify(visibilityTracker, never())
-                .addView(view, nativeResponse.getImpressionMinPercentageViewed());
+                .addView(view, impressionInterface.getImpressionMinPercentageViewed());
     }
 
     @Test
-    public void addView_withDestroyedNativeResponse_shouldNotAddView() {
-        when(nativeResponse.isDestroyed()).thenReturn(true);
-
-        subject.addView(view, nativeResponse);
-
-        assertThat(trackedViews).isEmpty();
-        verify(visibilityTracker, never())
-                .addView(view, nativeResponse.getImpressionMinPercentageViewed());
-    }
-
-    @Test
-    public void addView_withDifferentNativeResponse_shouldRemoveFromPollingViews() {
-        subject.addView(view, nativeResponse);
+    public void addView_withDifferentImpressionInterface_shouldRemoveFromPollingViews() {
+        subject.addView(view, impressionInterface);
 
         assertThat(trackedViews).hasSize(1);
-        assertThat(trackedViews.get(view)).isEqualTo(nativeResponse);
-        verify(visibilityTracker).addView(view, nativeResponse.getImpressionMinPercentageViewed());
+        assertThat(trackedViews.get(view)).isEqualTo(impressionInterface);
+        verify(visibilityTracker).addView(view, impressionInterface.getImpressionMinPercentageViewed());
 
         pollingViews.put(view, timeStampWrapper);
 
-        subject.addView(view, nativeResponse2);
+        subject.addView(view, impressionInterface2);
 
         assertThat(trackedViews).hasSize(1);
-        assertThat(trackedViews.get(view)).isEqualTo(nativeResponse2);
+        assertThat(trackedViews.get(view)).isEqualTo(impressionInterface2);
         assertThat(pollingViews).isEmpty();
         verify(visibilityTracker, times(2))
-                .addView(view, nativeResponse.getImpressionMinPercentageViewed());
+                .addView(view, impressionInterface.getImpressionMinPercentageViewed());
     }
 
     @Test
-    public void addView_withDifferentAlreadyImpressedNativeResponse_shouldRemoveFromPollingViews_shouldNotTrack() {
-        when(nativeResponse2.getRecordedImpression()).thenReturn(true);
+    public void addView_withDifferentAlreadyImpressedImpressionInterface_shouldRemoveFromPollingViews_shouldNotTrack() {
+        when(impressionInterface2.isImpressionRecorded()).thenReturn(true);
 
-        subject.addView(view, nativeResponse);
+        subject.addView(view, impressionInterface);
 
         assertThat(trackedViews).hasSize(1);
-        assertThat(trackedViews.get(view)).isEqualTo(nativeResponse);
-        verify(visibilityTracker).addView(view, nativeResponse.getImpressionMinPercentageViewed());
+        assertThat(trackedViews.get(view)).isEqualTo(impressionInterface);
+        verify(visibilityTracker).addView(view, impressionInterface.getImpressionMinPercentageViewed());
 
         pollingViews.put(view, timeStampWrapper);
 
-        subject.addView(view, nativeResponse2);
+        subject.addView(view, impressionInterface2);
 
         assertThat(trackedViews).hasSize(0);
         assertThat(trackedViews.get(view)).isNull();
         assertThat(pollingViews).isEmpty();
-        verify(visibilityTracker).addView(view, nativeResponse.getImpressionMinPercentageViewed());
+        verify(visibilityTracker).addView(view, impressionInterface.getImpressionMinPercentageViewed());
     }
 
     @Test
-    public void addView_withSameNativeResponse_shouldNotAddView() {
-        subject.addView(view, nativeResponse);
+    public void addView_withSameImpressionInterface_shouldNotAddView() {
+        subject.addView(view, impressionInterface);
 
         assertThat(trackedViews).hasSize(1);
-        assertThat(trackedViews.get(view)).isEqualTo(nativeResponse);
-        verify(visibilityTracker).addView(view, nativeResponse.getImpressionMinPercentageViewed());
+        assertThat(trackedViews.get(view)).isEqualTo(impressionInterface);
+        verify(visibilityTracker).addView(view, impressionInterface.getImpressionMinPercentageViewed());
 
         pollingViews.put(view, timeStampWrapper);
 
-        subject.addView(view, nativeResponse);
+        subject.addView(view, impressionInterface);
 
         assertThat(trackedViews).hasSize(1);
-        assertThat(trackedViews.get(view)).isEqualTo(nativeResponse);
+        assertThat(trackedViews.get(view)).isEqualTo(impressionInterface);
         assertThat(pollingViews.keySet()).containsOnly(view);
 
         // Still only one call
-        verify(visibilityTracker).addView(view, nativeResponse.getImpressionMinPercentageViewed());
+        verify(visibilityTracker).addView(view, impressionInterface.getImpressionMinPercentageViewed());
     }
 
     @Test
     public void removeView_shouldRemoveViewFromViewTrackedViews_shouldRemoveViewFromPollingMap_shouldRemoveViewFromVisibilityTracker() {
-        trackedViews.put(view, nativeResponse);
-        pollingViews.put(view, new TimestampWrapper<NativeResponse>(nativeResponse));
-        visibilityTracker.addView(view, nativeResponse.getImpressionMinPercentageViewed());
+        trackedViews.put(view, impressionInterface);
+        pollingViews.put(view, new TimestampWrapper<ImpressionInterface>(impressionInterface));
+        visibilityTracker.addView(view, impressionInterface.getImpressionMinPercentageViewed());
 
         subject.removeView(view);
 
@@ -167,12 +158,12 @@ public void removeView_shouldRemoveViewFromViewTrackedViews_shouldRemoveViewFrom
 
     @Test
     public void clear_shouldClearViewTrackedViews_shouldClearPollingViews_shouldClearVisibilityTracker_shouldClearPollHandler() {
-        trackedViews.put(view, nativeResponse);
-        trackedViews.put(view2, nativeResponse);
+        trackedViews.put(view, impressionInterface);
+        trackedViews.put(view2, impressionInterface);
         pollingViews.put(view, timeStampWrapper);
         pollingViews.put(view2, timeStampWrapper);
-        visibilityTracker.addView(view, nativeResponse.getImpressionMinPercentageViewed());
-        visibilityTracker.addView(view2, nativeResponse.getImpressionMinPercentageViewed());
+        visibilityTracker.addView(view, impressionInterface.getImpressionMinPercentageViewed());
+        visibilityTracker.addView(view2, impressionInterface.getImpressionMinPercentageViewed());
 
         subject.clear();
 
@@ -184,12 +175,12 @@ public void clear_shouldClearViewTrackedViews_shouldClearPollingViews_shouldClea
     
     @Test
     public void destroy_shouldCallClear_shouldDestroyVisibilityTracker_shouldSetVisibilityTrackerListenerToNull() throws Exception {
-        trackedViews.put(view, nativeResponse);
-        trackedViews.put(view2, nativeResponse);
+        trackedViews.put(view, impressionInterface);
+        trackedViews.put(view2, impressionInterface);
         pollingViews.put(view, timeStampWrapper);
         pollingViews.put(view2, timeStampWrapper);
-        visibilityTracker.addView(view, nativeResponse.getImpressionMinPercentageViewed());
-        visibilityTracker.addView(view2, nativeResponse.getImpressionMinPercentageViewed());
+        visibilityTracker.addView(view, impressionInterface.getImpressionMinPercentageViewed());
+        visibilityTracker.addView(view2, impressionInterface.getImpressionMinPercentageViewed());
         assertThat(subject.getVisibilityTrackerListener()).isNotNull();
 
         subject.destroy();
@@ -224,7 +215,7 @@ public void scheduleNextPoll_withMessages_shouldNotPostDelayedThePollingRunnable
 
     @Test
     public void visibilityTrackerListener_onVisibilityChanged_withVisibleViews_shouldAddViewToPollingViews_shouldScheduleNextPoll() {
-        subject.addView(view, nativeResponse);
+        subject.addView(view, impressionInterface);
 
         assertThat(pollingViews).isEmpty();
 
@@ -237,7 +228,7 @@ public void visibilityTrackerListener_onVisibilityChanged_withVisibleViews_shoul
 
     @Test
     public void visibilityTrackerListener_onVisibilityChanged_withVisibleViews_shouldRemoveViewFromPollingViews() {
-        subject.addView(view, nativeResponse);
+        subject.addView(view, impressionInterface);
         subject.getVisibilityTrackerListener()
                 .onVisibilityChanged(Lists.newArrayList(view), Lists.<View>newArrayList());
 
@@ -259,10 +250,10 @@ public void pollingRunnableRun_whenLessThanOneSecondHasElapsed_shouldNotTrackImp
         pollingViews.put(view, timeStampWrapper);
 
         // We progress 999 milliseconds
-        Robolectric.getUiThreadScheduler().advanceBy(5555 + 999);
+        Robolectric.getForegroundThreadScheduler().advanceTo(5555 + 999);
         subject.new PollingRunnable().run();
 
-        verify(nativeResponse, never()).recordImpression(view);
+        verify(impressionInterface, never()).recordImpression(view);
 
         assertThat(pollingViews.keySet()).containsOnly(view);
         verify(handler).postDelayed(any(ImpressionTracker.PollingRunnable.class), eq((long) 250));
@@ -275,10 +266,10 @@ public void pollingRunnableRun_whenMoreThanOneSecondHasElapsed_shouldTrackImpres
         pollingViews.put(view, timeStampWrapper);
 
         // We progress 1000 milliseconds
-        Robolectric.getUiThreadScheduler().advanceBy(5555 + 1000);
+        Robolectric.getForegroundThreadScheduler().advanceTo(5555 + 1000);
         subject.new PollingRunnable().run();
 
-        verify(nativeResponse).recordImpression(view);
+        verify(impressionInterface).recordImpression(view);
 
         assertThat(pollingViews).isEmpty();
         verify(handler, never())
@@ -290,16 +281,16 @@ public void pollingRunnableRun_whenWrapperIsNull_shouldThrowNPE() {
         pollingViews.put(view, null);
         subject.new PollingRunnable().run();
 
-        verify(nativeResponse, never()).recordImpression(view);
+        verify(impressionInterface, never()).recordImpression(view);
     }
 
     @Test(expected = NullPointerException.class)
-    public void pollingRunnableRun_whenNativeResponseIsNull_shouldThrowNPE() {
+    public void pollingRunnableRun_whenImpressionInterfaceIsNull_shouldThrowNPE() {
         // This doesn't normally happen; perhaps we're being overly defensive
-        pollingViews.put(view, new TimestampWrapper<NativeResponse>(null));
+        pollingViews.put(view, new TimestampWrapper<ImpressionInterface>(null));
 
         subject.new PollingRunnable().run();
 
-        verify(nativeResponse, never()).recordImpression(view);
+        verify(impressionInterface, never()).recordImpression(view);
     }
 }
\ No newline at end of file
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MediaLayoutTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MediaLayoutTest.java
new file mode 100644
index 00000000..9573d1f8
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MediaLayoutTest.java
@@ -0,0 +1,93 @@
+package com.mopub.nativeads;
+
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.view.View.MeasureSpec;
+import android.view.ViewGroup;
+import android.widget.RelativeLayout;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowApplication;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class MediaLayoutTest {
+
+    MediaLayout spySubject;
+    Context context;
+
+    @Before
+    public void setup() {
+        context = ShadowApplication.getInstance().getApplicationContext();
+        spySubject = spy(new MediaLayout(context));
+        spySubject.setLayoutParams(new RelativeLayout.LayoutParams(300, 300));
+        when(spySubject.getMeasuredHeight()).thenReturn(300);
+        when(spySubject.getMeasuredWidth()).thenReturn(300);
+    }
+
+    @Test
+    @SuppressLint("WrongCall") // onMeasure should not ordinarily be called in application code
+    public void onMeasure_exactWidth_flexibleHeight_shouldBe16By9() {
+        int widthMeasureSpec = MeasureSpec.makeMeasureSpec(500, MeasureSpec.EXACTLY);
+        int heightMeasureSpec = MeasureSpec.makeMeasureSpec(500, MeasureSpec.AT_MOST);
+
+        spySubject.onMeasure(widthMeasureSpec, heightMeasureSpec);
+
+        final ViewGroup.LayoutParams params = spySubject.getLayoutParams();
+
+        assertThat(params.width).isEqualTo(500);
+        assertThat(params.height).isEqualTo((int)(500 * 9f / 16));
+    }
+
+    @Test
+    @SuppressLint("WrongCall") // onMeasure should not ordinarily be called in application code
+    public void onMeasure_flexibleWidth_flexibleHeight_shouldBe16By9() {
+        int widthMeasureSpec = MeasureSpec.makeMeasureSpec(500, MeasureSpec.AT_MOST);
+        int heightMeasureSpec = MeasureSpec.makeMeasureSpec(500, MeasureSpec.AT_MOST);
+
+        spySubject.onMeasure(widthMeasureSpec, heightMeasureSpec);
+
+        final ViewGroup.LayoutParams params = spySubject.getLayoutParams();
+
+        assertThat(params.width).isEqualTo(300);
+        assertThat(params.height).isEqualTo((int)(300 * 9f / 16));
+    }
+
+    @Test
+    @SuppressLint("WrongCall") // onMeasure should not ordinarily be called in application code
+    public void onMeasure_flexibleWidth_ExactHeight_shouldBe16By9() {
+        int widthMeasureSpec = MeasureSpec.makeMeasureSpec(700, MeasureSpec.AT_MOST);
+        int heightMeasureSpec = MeasureSpec.makeMeasureSpec(150, MeasureSpec.EXACTLY);
+
+        spySubject.onMeasure(widthMeasureSpec, heightMeasureSpec);
+
+        final ViewGroup.LayoutParams params = spySubject.getLayoutParams();
+
+        assertThat(params.height).isEqualTo(150);
+        assertThat(params.width).isEqualTo((int)(150 * 16f / 9));
+    }
+
+    @Test
+    @SuppressLint("WrongCall")
+    public void onMeasure_exactWidth_exactHeight_heightShouldBeSmaller() {
+        int widthMeasureSpec = MeasureSpec.makeMeasureSpec(500, MeasureSpec.EXACTLY);
+        int heightMeasureSpec = MeasureSpec.makeMeasureSpec(500, MeasureSpec.EXACTLY);
+
+        spySubject.onMeasure(widthMeasureSpec, heightMeasureSpec);
+
+        final ViewGroup.LayoutParams params = spySubject.getLayoutParams();
+
+        assertThat(params.width).isEqualTo(500);
+        assertThat(params.height).isEqualTo((int)(500 * 9f / 16));
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubAdAdapterTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubAdAdapterTest.java
index 06f1c83d..7e91e7db 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubAdAdapterTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubAdAdapterTest.java
@@ -12,6 +12,7 @@
 import android.widget.ListView;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 
 import org.junit.Before;
 import org.junit.Test;
@@ -21,6 +22,7 @@
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
@@ -33,6 +35,7 @@
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class MoPubAdAdapterTest {
     private static final int AD_POSITION = 1;
 
@@ -186,23 +189,6 @@ public void registerAdRenderer_withNull_shouldNotCallAdPlacer() {
         verify(mockStreamAdPlacer, never()).registerAdRenderer(any(MoPubAdRenderer.class));
     }
 
-    @Test
-    public void registerViewBinder_shouldCallAdPlacer() {
-        subject.registerViewBinder(mockViewBinder);
-
-        final ArgumentCaptor<MoPubAdRenderer> rendererCaptor = new ArgumentCaptor<MoPubAdRenderer>();
-        verify(mockStreamAdPlacer).registerAdRenderer(rendererCaptor.capture());
-        MoPubAdRenderer renderer = rendererCaptor.getValue();
-        assertThat(renderer).isExactlyInstanceOf(MoPubNativeAdRenderer.class);
-    }
-
-    @Test
-    public void registerViewBinder_withNull_shouldNotCallAdPlacer() {
-        subject.registerViewBinder(null);
-
-        verify(mockStreamAdPlacer, never()).registerAdRenderer(any(MoPubAdRenderer.class));
-    }
-
     @Test
     public void setAdLoadedListener_handleAdLoaded_shouldCallCallback_shouldCallObserver() {
         subject.setAdLoadedListener(mockAdLoadedListener);
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubClientPositioningTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubClientPositioningTest.java
index 1f117225..7339313b 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubClientPositioningTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubClientPositioningTest.java
@@ -2,17 +2,20 @@
 
 import com.mopub.common.Preconditions.NoThrow;
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
 
 import org.fest.util.Lists;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
 
 import static com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning.NO_REPEAT;
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class MoPubClientPositioningTest {
 
     private MoPubClientPositioning subject;
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubCustomEventNativeTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubCustomEventNativeTest.java
index 361e8fce..a4273408 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubCustomEventNativeTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubCustomEventNativeTest.java
@@ -4,37 +4,41 @@
 
 import com.mopub.common.DataKeys;
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
+import com.mopub.nativeads.MoPubCustomEventNative.MoPubStaticNativeAd;
 
 import org.json.JSONArray;
 import org.json.JSONObject;
-import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
 
 import java.util.HashMap;
 
 import static com.mopub.nativeads.CustomEventNative.CustomEventNativeListener;
 import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.verify;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class MoPubCustomEventNativeTest {
 
     private MoPubCustomEventNative subject;
     private Activity context;
     private HashMap<String, Object> localExtras;
-    private CustomEventNativeListener mCustomEventNativeListener;
     private HashMap<String, String> serverExtras;
     private JSONObject fakeJsonObject;
 
+    @Mock private CustomEventNativeListener mockCustomEventNativeListener;
+
     @Before
     public void setUp() throws Exception {
         subject = new MoPubCustomEventNative();
-        context = new Activity();
+        context = Robolectric.buildActivity(Activity.class).create().get();
 
         localExtras = new HashMap<String, Object>();
         serverExtras = new HashMap<String, String>();
@@ -47,21 +51,15 @@ public void setUp() throws Exception {
         fakeJsonObject.put("extraimage", "extraimageurl");
 
         localExtras.put(DataKeys.JSON_BODY_KEY, fakeJsonObject);
-
-        mCustomEventNativeListener = mock(CustomEventNativeListener.class);
-    }
-
-    @After
-    public void tearDown() throws Exception {
-        reset(mCustomEventNativeListener);
     }
 
     @Test
-    public void loadNativeAd_withNullResponseBody_shouldNotifyListenerOfOnNativeAdFailed() throws Exception {
+    public void loadNativeAd_withNullResponseBody_shouldNotifyListenerOfOnNativeAdFailed() {
         localExtras.remove(DataKeys.JSON_BODY_KEY);
 
-        subject.loadNativeAd(context, mCustomEventNativeListener, localExtras, serverExtras);
-        verify(mCustomEventNativeListener, never()).onNativeAdLoaded(any(MoPubCustomEventNative.MoPubForwardingNativeAd.class));
-        verify(mCustomEventNativeListener).onNativeAdFailed(NativeErrorCode.INVALID_JSON);
+        subject.loadNativeAd(context, mockCustomEventNativeListener, localExtras, serverExtras);
+        verify(mockCustomEventNativeListener, never())
+                .onNativeAdLoaded(any(MoPubStaticNativeAd.class));
+        verify(mockCustomEventNativeListener).onNativeAdFailed(NativeErrorCode.INVALID_RESPONSE);
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubCustomEventVideoNativeTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubCustomEventVideoNativeTest.java
new file mode 100644
index 00000000..535d0992
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubCustomEventVideoNativeTest.java
@@ -0,0 +1,181 @@
+package com.mopub.nativeads;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.os.Build;
+
+import com.mopub.common.DataKeys;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
+import com.mopub.nativeads.MoPubCustomEventVideoNative.VideoResponseHeaders;
+import com.mopub.network.MaxWidthImageLoader;
+import com.mopub.network.Networking;
+
+import org.json.JSONArray;
+import org.json.JSONObject;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+
+import java.util.HashMap;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+
+@TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class MoPubCustomEventVideoNativeTest {
+
+    private MoPubCustomEventVideoNative subject;
+    private Activity context;
+    private HashMap<String, Object> localExtras;
+    private HashMap<String, String> serverExtras;
+    private JSONObject jsonObject;
+
+    @Mock private CustomEventNative.CustomEventNativeListener mockCustomEventNativeListener;
+
+    @Before
+    public void setUp() throws Exception {
+        subject = new MoPubCustomEventVideoNative();
+        context = Robolectric.buildActivity(Activity.class).create().get();
+
+        localExtras = new HashMap<String, Object>();
+        jsonObject = new JSONObject();
+        jsonObject.put("imptracker", new JSONArray("[\"url1\", \"url2\"]"));
+        jsonObject.put("clktracker", "expected clicktracker");
+        jsonObject.put("mainimage", "mainimageurl");
+        jsonObject.put("iconimage", "iconimageurl");
+        jsonObject.put("extraimage", "extraimageurl");
+        localExtras.put(DataKeys.JSON_BODY_KEY, jsonObject);
+        localExtras.put(DataKeys.CLICK_TRACKING_URL_KEY, "clicktrackingurl");
+
+        serverExtras = new HashMap<String, String>();
+        serverExtras.put("Play-Visible-Percent", "10");
+        serverExtras.put("Pause-Visible-Percent", "5");
+        serverExtras.put("Impression-Min-Visible-Percent", "15");
+        serverExtras.put("Impression-Visible-Ms", "100");
+        serverExtras.put("Max-Buffer-Ms", "20");
+
+    }
+
+    @After
+    public void tearDown() {
+        Networking.setImageLoaderForTesting(null);
+    }
+
+    @Test
+    public void loadNativeAd_withJsonNotInstanceOfJSONObject_shouldNotifyListenerOnNativeAdFailed() {
+        localExtras.put("com_mopub_native_json", "");
+        subject.loadNativeAd(context, mockCustomEventNativeListener, localExtras, serverExtras);
+
+        verify(mockCustomEventNativeListener).onNativeAdFailed(NativeErrorCode.INVALID_RESPONSE);
+        verify(mockCustomEventNativeListener, never()).onNativeAdLoaded(any(BaseNativeAd.class));
+    }
+
+    @Test
+    public void loadNativeAd_withInvalidHeaders_shouldNotifyListenerOnNativeAdFailed() {
+        serverExtras.put("Play-Visible-Percent", "not_a_number");
+        subject.loadNativeAd(context, mockCustomEventNativeListener, localExtras, serverExtras);
+
+        verify(mockCustomEventNativeListener).onNativeAdFailed(NativeErrorCode.INVALID_RESPONSE);
+        verify(mockCustomEventNativeListener, never()).onNativeAdLoaded(any(BaseNativeAd.class));
+    }
+
+    @Test
+    public void loadNativeAd_withMissingRequiredKeys_shouldNotifyListenerOnNativeAdFailed() {
+        jsonObject.remove("imptracker");
+        subject.loadNativeAd(context, mockCustomEventNativeListener, localExtras, serverExtras);
+        verify(mockCustomEventNativeListener).onNativeAdFailed(NativeErrorCode.UNSPECIFIED);
+
+        reset(mockCustomEventNativeListener);
+        jsonObject.remove("clktracker");
+        subject.loadNativeAd(context, mockCustomEventNativeListener, localExtras, serverExtras);
+        verify(mockCustomEventNativeListener).onNativeAdFailed(NativeErrorCode.UNSPECIFIED);
+        verify(mockCustomEventNativeListener, never()).onNativeAdLoaded(any(BaseNativeAd.class));
+    }
+
+    @Test
+    public void loadNativeAd_withMissingClickTracker_shouldNotifyListenerOnNativeAdFailed() {
+        localExtras.remove(DataKeys.CLICK_TRACKING_URL_KEY);
+        subject.loadNativeAd(context, mockCustomEventNativeListener, localExtras, serverExtras);
+        verify(mockCustomEventNativeListener).onNativeAdFailed(NativeErrorCode.UNSPECIFIED);
+        verify(mockCustomEventNativeListener, never()).onNativeAdLoaded(any(BaseNativeAd.class));
+    }
+
+    @Test
+    public void loadNativeAd_withNullClickTracker_shouldNotifyListenerOnNativeAdFailed() {
+        localExtras.put(DataKeys.CLICK_TRACKING_URL_KEY, null);
+        subject.loadNativeAd(context, mockCustomEventNativeListener, localExtras, serverExtras);
+        verify(mockCustomEventNativeListener).onNativeAdFailed(NativeErrorCode.UNSPECIFIED);
+        verify(mockCustomEventNativeListener, never()).onNativeAdLoaded(any(BaseNativeAd.class));
+    }
+
+    @Test
+    public void loadNativeAd_withEmptyClickTracker_shouldNotifyListenerOnNativeAdFailed() {
+        localExtras.put(DataKeys.CLICK_TRACKING_URL_KEY, "");
+        subject.loadNativeAd(context, mockCustomEventNativeListener, localExtras, serverExtras);
+        verify(mockCustomEventNativeListener).onNativeAdFailed(NativeErrorCode.UNSPECIFIED);
+        verify(mockCustomEventNativeListener, never()).onNativeAdLoaded(any(BaseNativeAd.class));
+    }
+
+    @Test
+    public void loadNativeAd_withAllRequirementsMet_shouldNotNotifyListenerFailed_shouldNotThrowException() {
+        Networking.setImageLoaderForTesting(mock(MaxWidthImageLoader.class));
+        subject.loadNativeAd(context, mockCustomEventNativeListener, localExtras, serverExtras);
+
+        verifyNoMoreInteractions(mockCustomEventNativeListener);
+    }
+
+    @Test
+    public void VideoResponseHeaders_constructor_withValidNumberString_shouldInitializeVariablesCorrectly() {
+        VideoResponseHeaders videoResponseHeaders = new VideoResponseHeaders(serverExtras);
+
+        assertThat(videoResponseHeaders.hasValidHeaders()).isTrue();
+        assertThat(videoResponseHeaders.getPlayVisiblePercent()).isEqualTo(10);
+        assertThat(videoResponseHeaders.getPauseVisiblePercent()).isEqualTo(5);
+        assertThat(videoResponseHeaders.getImpressionMinVisiblePercent()).isEqualTo(15);
+        assertThat(videoResponseHeaders.getImpressionVisibleMs()).isEqualTo(100);
+        assertThat(videoResponseHeaders.getMaxBufferMs()).isEqualTo(20);
+    }
+
+    @Test
+    public void VideoResponseHeaders_constructor_withInvalidNumberString_shouldSetHeadersAreValidToFalse() {
+        serverExtras.put("Play-Visible-Percent", "not_a_number");
+        VideoResponseHeaders videoResponseHeaders = new VideoResponseHeaders(serverExtras);
+        assertThat(videoResponseHeaders.hasValidHeaders()).isFalse();
+
+        serverExtras.put("Play-Visible-Percent", "10");
+        serverExtras.put("Pause-Visible-Percent", "not_a_number");
+        videoResponseHeaders = new VideoResponseHeaders(serverExtras);
+        assertThat(videoResponseHeaders.hasValidHeaders()).isFalse();
+
+        serverExtras.put("Pause-Visible-Percent", "5");
+        serverExtras.put("Impression-Min-Visible-Percent", "not_a_number");
+        videoResponseHeaders = new VideoResponseHeaders(serverExtras);
+        assertThat(videoResponseHeaders.hasValidHeaders()).isFalse();
+
+        serverExtras.put("Impression-Min-Visible-Percent", "15");
+        serverExtras.put("Impression-Visible-Ms", "not_a_number");
+        videoResponseHeaders = new VideoResponseHeaders(serverExtras);
+        assertThat(videoResponseHeaders.hasValidHeaders()).isFalse();
+
+        serverExtras.put("Impression-Visible-Ms", "100");
+        serverExtras.put("Max-Buffer-Ms", "not_a_number");
+        videoResponseHeaders = new VideoResponseHeaders(serverExtras);
+        assertThat(videoResponseHeaders.hasValidHeaders()).isFalse();
+
+        serverExtras.put("Max-Buffer-Ms", "20");
+        videoResponseHeaders = new VideoResponseHeaders(serverExtras);
+        assertThat(videoResponseHeaders.hasValidHeaders()).isTrue();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeAdRendererTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeAdRendererTest.java
deleted file mode 100644
index 70a139c0..00000000
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeAdRendererTest.java
+++ /dev/null
@@ -1,173 +0,0 @@
-package com.mopub.nativeads;
-
-import android.app.Activity;
-import android.view.ViewGroup;
-import android.widget.Button;
-import android.widget.ImageView;
-import android.widget.LinearLayout;
-import android.widget.RelativeLayout;
-import android.widget.TextView;
-
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.Utils;
-
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.ExpectedException;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-
-@RunWith(SdkTestRunner.class)
-public class MoPubNativeAdRendererTest {
-    private MoPubNativeAdRenderer subject;
-    private RelativeLayout relativeLayout;
-    private ViewGroup viewGroup;
-    private NativeResponse nativeResponse;
-    private ViewBinder viewBinder;
-    private TextView titleView;
-    private TextView textView;
-    private TextView callToActionView;
-    private ImageView mainImageView;
-    private ImageView iconImageView;
-    private ImageView badView;
-
-    @Before
-    public void setUp() throws Exception {
-        Activity context = Robolectric.buildActivity(Activity.class).create().get();
-        relativeLayout = new RelativeLayout(context);
-        relativeLayout.setId((int) Utils.generateUniqueId());
-        viewGroup = new LinearLayout(context);
-
-        BaseForwardingNativeAd baseForwardingNativeAd = new BaseForwardingNativeAd() {};
-        baseForwardingNativeAd.setTitle("test title");
-        baseForwardingNativeAd.setText("test text");
-        baseForwardingNativeAd.setCallToAction("test call to action");
-        baseForwardingNativeAd.setClickDestinationUrl("destinationUrl");
-
-        nativeResponse = new NativeResponse(context,
-                "impressionTrackerUrl",
-                "clickTrackerUrl",
-                "test ID", baseForwardingNativeAd,
-                mock(MoPubNative.MoPubNativeListener.class));
-
-        titleView = new TextView(context);
-        titleView.setId((int) Utils.generateUniqueId());
-        textView = new TextView(context);
-        textView.setId((int) Utils.generateUniqueId());
-        callToActionView = new Button(context);
-        callToActionView.setId((int) Utils.generateUniqueId());
-        mainImageView = new ImageView(context);
-        mainImageView.setId((int) Utils.generateUniqueId());
-        iconImageView = new ImageView(context);
-        iconImageView.setId((int) Utils.generateUniqueId());
-        badView = new ImageView(context);
-        badView.setId((int) Utils.generateUniqueId());
-
-        relativeLayout.addView(titleView);
-        relativeLayout.addView(textView);
-        relativeLayout.addView(callToActionView);
-        relativeLayout.addView(mainImageView);
-        relativeLayout.addView(iconImageView);
-        relativeLayout.addView(badView);
-
-        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
-                .titleId(titleView.getId())
-                .textId(textView.getId())
-                .callToActionId(callToActionView.getId())
-                .mainImageId(mainImageView.getId())
-                .iconImageId(iconImageView.getId())
-                .build();
-
-        subject = new MoPubNativeAdRenderer(viewBinder);
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void createAdView_withNullContext_shouldThrowNPE() {
-        subject.createAdView(null, viewGroup);
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void renderAdView_withNullView_shouldThrowNPE() {
-        subject.renderAdView(null, nativeResponse);
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void renderAdView_withNullNativeResponse_shouldThrowNPE() {
-        subject.renderAdView(relativeLayout, null);
-    }
-
-    @Rule public ExpectedException exception = ExpectedException.none();
-
-    @Test
-    public void renderAdView_withNullViewBinder_shouldThrowNPE() {
-        subject = new MoPubNativeAdRenderer(null);
-
-        exception.expect(NullPointerException.class);
-        subject.renderAdView(relativeLayout, nativeResponse);
-    }
-
-    @Test
-    public void renderAdView_shouldReturnPopulatedView() {
-        subject.renderAdView(relativeLayout, nativeResponse);
-
-        assertThat(((TextView)relativeLayout.findViewById(titleView.getId())).getText()).isEqualTo("test title");
-        assertThat(((TextView)relativeLayout.findViewById(textView.getId())).getText()).isEqualTo(
-                "test text");
-        assertThat(((TextView)relativeLayout.findViewById(callToActionView.getId())).getText()).isEqualTo("test call to action");
-
-        // not testing images due to testing complexity
-    }
-
-    @Test
-    public void renderAdView_withFailedViewBinder_shouldReturnEmptyViews() {
-        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
-                .titleId(titleView.getId())
-                .textId(badView.getId())
-                .callToActionId(callToActionView.getId())
-                .mainImageId(mainImageView.getId())
-                .iconImageId(iconImageView.getId())
-                .build();
-
-        subject = new MoPubNativeAdRenderer(viewBinder);
-        subject.renderAdView(relativeLayout, nativeResponse);
-
-        assertThat(((TextView)relativeLayout.findViewById(titleView.getId())).getText())
-                .isEqualTo("");
-        assertThat(((TextView)relativeLayout.findViewById(textView.getId())).getText())
-                .isEqualTo("");
-        assertThat(((TextView)relativeLayout.findViewById(callToActionView.getId())).getText())
-                .isEqualTo("");
-    }
-
-    @Test
-    public void renderAdView_withNoViewHolder_shouldCreateNativeViewHolder() {
-        subject.renderAdView(relativeLayout, nativeResponse);
-
-        NativeViewHolder expectedViewHolder = NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
-        NativeViewHolder viewHolder = subject.mViewHolderMap.get(relativeLayout);
-        compareNativeViewHolders(expectedViewHolder, viewHolder);
-    }
-
-    @Test
-    public void getOrCreateNativeViewHolder_withViewHolder_shouldNotReCreateNativeViewHolder() {
-        subject.renderAdView(relativeLayout, nativeResponse);
-        NativeViewHolder expectedViewHolder = subject.mViewHolderMap.get(relativeLayout);
-        subject.renderAdView(relativeLayout, nativeResponse);
-
-        NativeViewHolder viewHolder = subject.mViewHolderMap.get(relativeLayout);
-        assertThat(viewHolder).isEqualTo(expectedViewHolder);
-    }
-
-    static private void compareNativeViewHolders(final NativeViewHolder actualViewHolder,
-            final NativeViewHolder expectedViewHolder) {
-        assertThat(actualViewHolder.titleView).isEqualTo(expectedViewHolder.titleView);
-        assertThat(actualViewHolder.textView).isEqualTo(expectedViewHolder.textView);
-        assertThat(actualViewHolder.callToActionView).isEqualTo(expectedViewHolder.callToActionView);
-        assertThat(actualViewHolder.mainImageView).isEqualTo(expectedViewHolder.mainImageView);
-        assertThat(actualViewHolder.iconImageView).isEqualTo(expectedViewHolder.iconImageView);
-    }
-}
\ No newline at end of file
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeTest.java
index a29e19ee..e7fba934 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeTest.java
@@ -6,8 +6,8 @@
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.common.util.test.support.ShadowAsyncTasks;
 import com.mopub.common.util.test.support.TestMethodBuilderFactory;
+import com.mopub.mobileads.BuildConfig;
 import com.mopub.mobileads.MoPubErrorCode;
-import com.mopub.nativeads.MoPubNative.MoPubNativeEventListener;
 import com.mopub.nativeads.MoPubNative.MoPubNativeNetworkListener;
 import com.mopub.network.MoPubNetworkError;
 import com.mopub.network.MoPubRequestQueue;
@@ -24,19 +24,18 @@
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
+import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowLog;
 
 import java.net.MalformedURLException;
 import java.util.List;
-import java.util.concurrent.Semaphore;
 import java.util.logging.Level;
 
 import static android.Manifest.permission.ACCESS_NETWORK_STATE;
 import static android.Manifest.permission.INTERNET;
 import static com.mopub.common.VolleyRequestMatcher.isUrl;
 import static com.mopub.common.util.Reflection.MethodBuilder;
-import static com.mopub.nativeads.MoPubNative.EMPTY_EVENT_LISTENER;
 import static com.mopub.nativeads.MoPubNative.EMPTY_NETWORK_LISTENER;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
@@ -46,32 +45,28 @@
 import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
-import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(SdkTestRunner.class)
-@Config(shadows = {ShadowAsyncTasks.class})
+@Config(constants = BuildConfig.class, shadows = {ShadowAsyncTasks.class})
 public class MoPubNativeTest {
     private MoPubNative subject;
     private MethodBuilder methodBuilder;
     private Activity context;
-    private Semaphore semaphore;
     private static final String adUnitId = "test_adunit_id";
 
-    @Mock private MoPubNativeEventListener mockEventListener;
-
     @Mock private MoPubNativeNetworkListener mockNetworkListener;
     @Mock private MoPubRequestQueue mockRequestQueue;
-
+    @Mock private AdRendererRegistry mockAdRendererRegistry;
+    @Mock private MoPubStaticNativeAdRenderer mockRenderer;
 
     @Before
     public void setup() {
         context = Robolectric.buildActivity(Activity.class).create().get();
-        shadowOf(context).grantPermissions(ACCESS_NETWORK_STATE);
-        shadowOf(context).grantPermissions(INTERNET);
-        subject = new MoPubNative(context, adUnitId, mockNetworkListener);
+        Shadows.shadowOf(context).grantPermissions(ACCESS_NETWORK_STATE);
+        Shadows.shadowOf(context).grantPermissions(INTERNET);
+        subject = new MoPubNative(context, adUnitId, mockAdRendererRegistry, mockNetworkListener);
         methodBuilder = TestMethodBuilderFactory.getSingletonMock();
         Networking.setRequestQueueForTesting(mockRequestQueue);
-        semaphore = new Semaphore(0);
     }
 
     @After
@@ -80,42 +75,35 @@ public void tearDown() {
     }
 
     @Test
-    public void destroy_shouldSetListenersToEmptyAndClearContext() {
-        assertThat(subject.getContextOrDestroy()).isSameAs(context);
-        assertThat(subject.getMoPubNativeNetworkListener()).isSameAs(mockNetworkListener);
-        subject.setNativeEventListener(mockEventListener);
-        assertThat(subject.getMoPubNativeEventListener()).isSameAs(mockEventListener);
-
-        subject.destroy();
+    public void registerAdRenderer_shouldCallAdRednererRegistryRegisterAdRenderer() throws Exception {
+        subject.registerAdRenderer(mockRenderer);
 
-        assertThat(subject.getContextOrDestroy()).isNull();
-        assertThat(subject.getMoPubNativeNetworkListener()).isSameAs(EMPTY_NETWORK_LISTENER);
-        assertThat(subject.getMoPubNativeEventListener()).isSameAs(EMPTY_EVENT_LISTENER);
+        verify(mockAdRendererRegistry).registerAdRenderer(mockRenderer);
     }
 
     @Test
-    public void setNativeEventListener_shouldSetListener() {
+    public void destroy_shouldSetListenersToEmptyAndClearContext() {
+        assertThat(subject.getActivityOrDestroy()).isSameAs(context);
         assertThat(subject.getMoPubNativeNetworkListener()).isSameAs(mockNetworkListener);
-        subject.setNativeEventListener(mockEventListener);
-        assertThat(subject.getMoPubNativeEventListener()).isSameAs(mockEventListener);
 
-        subject.setNativeEventListener(null);
-        assertThat(subject.getMoPubNativeEventListener()).isSameAs(EMPTY_EVENT_LISTENER);
+        subject.destroy();
+
+        assertThat(subject.getActivityOrDestroy()).isNull();
+        assertThat(subject.getMoPubNativeNetworkListener()).isSameAs(EMPTY_NETWORK_LISTENER);
     }
 
     @Test
     public void loadNativeAd_shouldReturnFast() {
-        Robolectric.getUiThreadScheduler().pause();
+        Robolectric.getForegroundThreadScheduler().pause();
 
         subject.destroy();
         subject.makeRequest();
 
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(0);
     }
 
     @Test
     public void requestNativeAd_shouldFireNetworkRequest() {
-
         subject.requestNativeAd("http://www.mopub.com");
 
         verify(mockNetworkListener, never()).onNativeFail(any(NativeErrorCode.class));
@@ -140,7 +128,7 @@ public Void answer(final InvocationOnMock invocationOnMock) throws Throwable {
 
     @Test
     public void requestNativeAd_withNullUrl_shouldFireNativeFail() {
-        Robolectric.getUiThreadScheduler().pause();
+        Robolectric.getForegroundThreadScheduler().pause();
 
         subject.requestNativeAd(null);
 
@@ -152,7 +140,7 @@ public void requestNativeAd_withNullUrl_shouldFireNativeFail() {
     public void onAdError_shouldNotifyListener() {
         subject.onAdError(new MoPubNetworkError(MoPubNetworkError.Reason.BAD_BODY));
 
-        verify(mockNetworkListener).onNativeFail(eq(NativeErrorCode.INVALID_JSON));
+        verify(mockNetworkListener).onNativeFail(eq(NativeErrorCode.INVALID_RESPONSE));
     }
 
     @Test
@@ -179,7 +167,7 @@ public void onAdError_withVolleyErrorWarmingUp_shouldLogMoPubErrorCodeWarmup_sho
     @Test
     public void onAdError_withNoConnection_shouldLogMoPubErrorCodeNoConnection_shouldNotifyListener() {
         MoPubLog.setSdkHandlerLevel(Level.ALL);
-        shadowOf(context).denyPermissions(INTERNET);
+        Shadows.shadowOf(context).denyPermissions(INTERNET);
 
         subject.onAdError(new NoConnectionError());
 
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubRecyclerAdapterTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubRecyclerAdapterTest.java
index 5bf340ed..444dd1f9 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubRecyclerAdapterTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubRecyclerAdapterTest.java
@@ -1,5 +1,6 @@
 package com.mopub.nativeads;
 
+import android.app.Activity;
 import android.content.Context;
 import android.support.v7.widget.LinearLayoutManager;
 import android.support.v7.widget.RecyclerView;
@@ -7,6 +8,7 @@
 import android.view.ViewGroup;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 
 import org.junit.Before;
 import org.junit.Test;
@@ -15,6 +17,7 @@
 import org.mockito.Mock;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
+import org.robolectric.annotation.Config;
 
 import java.util.HashSet;
 import java.util.Set;
@@ -25,7 +28,6 @@
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.reset;
@@ -37,14 +39,17 @@
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class MoPubRecyclerAdapterTest {
     private static final int AD_POSITION_1 = 1;
     private static final int AD_POSITION_7 = 7;
 
     @Mock MoPubStreamAdPlacer mockStreamAdPlacer;
     @Mock VisibilityTracker mockVisibilityTracker;
-    @Mock NativeAdData mockNativeAdData;
-    @Mock NativeAdData mockNativeAdData2;
+    @Mock
+    NativeAd mMockNativeAd;
+    @Mock
+    NativeAd mMockNativeAd2;
     @Mock MoPubAdRenderer mockAdRenderer;
     @Mock ViewGroup mockParent;
     @Mock View mockAdView;
@@ -73,11 +78,12 @@ public void setUp() throws Exception {
 
         // Mock some simple adjustment behavior for tests. This is creating an ad placer that
         // emulates a content item followed by an ad item, then another content item.
-        when(mockStreamAdPlacer.getAdData(AD_POSITION_1)).thenReturn(mockNativeAdData);
-        when(mockStreamAdPlacer.getAdData(AD_POSITION_7)).thenReturn(mockNativeAdData2);
+        when(mockStreamAdPlacer.getAdData(AD_POSITION_1)).thenReturn(mMockNativeAd);
+        when(mockStreamAdPlacer.getAdData(AD_POSITION_7)).thenReturn(mMockNativeAd2);
         when(mockStreamAdPlacer.getAdRendererForViewType(MoPubRecyclerAdapter.NATIVE_AD_VIEW_TYPE_BASE))
                 .thenReturn(mockAdRenderer);
-        when(mockAdRenderer.createAdView(any(Context.class), any(ViewGroup.class))).thenReturn(mockAdView);
+        when(mockAdRenderer.createAdView(any(Activity.class), any(ViewGroup.class)))
+                .thenReturn(mockAdView);
 
         when(mockStreamAdPlacer.isAd(anyInt())).thenAnswer(new Answer<Boolean>() {
             @Override
@@ -209,22 +215,23 @@ public void computeScrollOffset_withCannotScroll_shouldReturnZero() {
     }
 
     @Test
-    public void registerViewBinder_shouldCallRegisterAdRendererOnStreamAdPlacer() {
-        subject.registerViewBinder(new ViewBinder.Builder(1).build());
+    public void registerAdRenderer_shouldCallRegisterAdRendererOnStreamAdPlacer() {
+        subject.registerAdRenderer(new MoPubStaticNativeAdRenderer(new ViewBinder.Builder(1).build()));
 
         final ArgumentCaptor<MoPubAdRenderer> rendererCaptor = ArgumentCaptor.forClass(MoPubAdRenderer.class);
-        verify(mockStreamAdPlacer).registerAdRenderer(rendererCaptor.capture(), eq(-55));
+        verify(mockStreamAdPlacer).registerAdRenderer(rendererCaptor.capture());
         MoPubAdRenderer renderer = rendererCaptor.getValue();
-        assertThat(renderer).isExactlyInstanceOf(MoPubNativeAdRenderer.class);
+        assertThat(renderer).isExactlyInstanceOf(MoPubStaticNativeAdRenderer.class);
     }
 
     @Test
     public void onCreateViewHolder_whenAdType_shouldInflateAdView() {
+        when(mockStreamAdPlacer.getAdRendererForViewType(0)).thenReturn(mockAdRenderer);
         final RecyclerView.ViewHolder result = subject.onCreateViewHolder(mockParent, MoPubRecyclerAdapter.NATIVE_AD_VIEW_TYPE_BASE);
 
         assertThat(result).isExactlyInstanceOf(MoPubRecyclerViewHolder.class);
 
-        verify(mockStreamAdPlacer).getAdRendererForViewType(MoPubRecyclerAdapter.NATIVE_AD_VIEW_TYPE_BASE);
+        verify(mockStreamAdPlacer).getAdRendererForViewType(0);
         verifyZeroInteractions(originalAdapter);
     }
 
@@ -242,7 +249,7 @@ public void onCreateViewHolder_whenNotAdType_shouldCallOriginalAdapter() {
     public void onBindViewHolder_whenAdPosition_shouldGetAndBindAdData() {
         subject.onBindViewHolder(spyViewHolder, AD_POSITION_1);
 
-        verify(mockStreamAdPlacer).bindAdView(mockNativeAdData, mockAdView);
+        verify(mockStreamAdPlacer).bindAdView(mMockNativeAd, mockAdView);
     }
 
     @Test
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubStaticNativeAdRendererTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubStaticNativeAdRendererTest.java
new file mode 100644
index 00000000..a7bae9ed
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubStaticNativeAdRendererTest.java
@@ -0,0 +1,195 @@
+package com.mopub.nativeads;
+
+import android.graphics.Bitmap;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ImageView;
+import android.widget.RelativeLayout;
+import android.widget.TextView;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.Utils;
+import com.mopub.mobileads.BuildConfig;
+import com.mopub.nativeads.MoPubCustomEventNative.MoPubStaticNativeAd;
+import com.mopub.network.MaxWidthImageLoader;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.volley.toolbox.ImageLoader;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.annotation.Config;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.stub;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class MoPubStaticNativeAdRendererTest {
+    private MoPubStaticNativeAdRenderer subject;
+    private StaticNativeAd mStaticNativeAd;
+    @Mock private RelativeLayout relativeLayout;
+    @Mock private ViewGroup viewGroup;
+    private ViewBinder viewBinder;
+    @Mock private TextView titleView;
+    @Mock private TextView textView;
+    @Mock private TextView callToActionView;
+    @Mock private ImageView mainImageView;
+    @Mock private ImageView iconImageView;
+    @Mock private ImageView privacyInformationIconImageView;
+    @Mock private ImageView badView;
+    @Mock private MoPubRequestQueue mockRequestQueue;
+    @Mock private MaxWidthImageLoader mockImageLoader;
+    @Mock private ImageLoader.ImageContainer mockImageContainer;
+
+    @Before
+    public void setUp() throws Exception {
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+        Networking.setImageLoaderForTesting(mockImageLoader);
+        stub(mockImageContainer.getBitmap()).toReturn(mock(Bitmap.class));
+
+        when(relativeLayout.getId()).thenReturn((int) Utils.generateUniqueId());
+
+        mStaticNativeAd = new StaticNativeAd() {};
+        mStaticNativeAd.setTitle("test title");
+        mStaticNativeAd.setText("test text");
+        mStaticNativeAd.setCallToAction("test call to action");
+        mStaticNativeAd.setClickDestinationUrl("destinationUrl");
+        mStaticNativeAd.setMainImageUrl("testUrl");
+        mStaticNativeAd.setIconImageUrl("testUrl");
+
+        setViewIdInLayout(titleView, relativeLayout);
+        setViewIdInLayout(textView, relativeLayout);
+        setViewIdInLayout(callToActionView, relativeLayout);
+        setViewIdInLayout(mainImageView, relativeLayout);
+        setViewIdInLayout(iconImageView, relativeLayout);
+        setViewIdInLayout(privacyInformationIconImageView, relativeLayout);
+        setViewIdInLayout(badView, relativeLayout);
+
+        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
+                .titleId(titleView.getId())
+                .textId(textView.getId())
+                .callToActionId(callToActionView.getId())
+                .mainImageId(mainImageView.getId())
+                .iconImageId(iconImageView.getId())
+                .privacyInformationIconImageId(privacyInformationIconImageView.getId())
+                .build();
+
+        subject = new MoPubStaticNativeAdRenderer(viewBinder);
+    }
+
+    private void setViewIdInLayout(View mockView, RelativeLayout mockLayout) {
+        int id = (int) Utils.generateUniqueId();
+        when(mockView.getId()).thenReturn(id);
+        when(relativeLayout.findViewById(eq(id))).thenReturn(mockView);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void createAdView_withNullContext_shouldThrowNPE() {
+        subject.createAdView(null, viewGroup);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void renderAdView_withNullView_shouldThrowNPE() {
+        subject.renderAdView(null, mStaticNativeAd);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void renderAdView_withNullNativeAd_shouldThrowNPE() {
+        subject.renderAdView(relativeLayout, null);
+    }
+
+    @Rule public ExpectedException exception = ExpectedException.none();
+
+    @Test
+    public void renderAdView_withNullViewBinder_shouldThrowNPE() {
+        subject = new MoPubStaticNativeAdRenderer(null);
+
+        exception.expect(NullPointerException.class);
+        subject.renderAdView(relativeLayout, mStaticNativeAd);
+    }
+
+    @Test
+    public void renderAdView_shouldReturnPopulatedView() {
+        subject.renderAdView(relativeLayout, mStaticNativeAd);
+
+        verify(titleView).setText(eq("test title"));
+        verify(textView).setText(eq("test text"));
+        verify(callToActionView).setText(eq("test call to action"));
+
+        // not testing images due to testing complexity
+    }
+
+    @Test
+    public void renderAdView_withFailedViewBinder_shouldNotWriteViews() {
+        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
+                .titleId(titleView.getId())
+                .textId(badView.getId())
+                .callToActionId(callToActionView.getId())
+                .mainImageId(mainImageView.getId())
+                .iconImageId(iconImageView.getId())
+                .build();
+
+        subject = new MoPubStaticNativeAdRenderer(viewBinder);
+        subject.renderAdView(relativeLayout, mStaticNativeAd);
+
+        verify(titleView, never()).setText(anyString());
+        verify(textView, never()).setText(anyString());
+        verify(callToActionView, never()).setText(anyString());
+        verify(mainImageView, times(2)).getId();
+        verifyNoMoreInteractions(mainImageView);
+        verify(iconImageView, times(2)).getId();
+        verifyNoMoreInteractions(iconImageView);
+    }
+
+    @Test
+    public void renderAdView_withNoViewHolder_shouldCreateNativeViewHolder() {
+        subject.renderAdView(relativeLayout, mStaticNativeAd);
+
+        StaticNativeViewHolder expectedViewHolder = StaticNativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
+        StaticNativeViewHolder viewHolder = subject.mViewHolderMap.get(relativeLayout);
+        compareNativeViewHolders(expectedViewHolder, viewHolder);
+    }
+
+    @Test
+    public void getOrCreateNativeViewHolder_withViewHolder_shouldNotReCreateNativeViewHolder() {
+        subject.renderAdView(relativeLayout, mStaticNativeAd);
+        StaticNativeViewHolder expectedViewHolder = subject.mViewHolderMap.get(relativeLayout);
+        subject.renderAdView(relativeLayout, mStaticNativeAd);
+
+        StaticNativeViewHolder viewHolder = subject.mViewHolderMap.get(relativeLayout);
+        assertThat(viewHolder).isEqualTo(expectedViewHolder);
+    }
+
+    static private void compareNativeViewHolders(final StaticNativeViewHolder actualViewHolder,
+            final StaticNativeViewHolder expectedViewHolder) {
+        assertThat(actualViewHolder.titleView).isEqualTo(expectedViewHolder.titleView);
+        assertThat(actualViewHolder.textView).isEqualTo(expectedViewHolder.textView);
+        assertThat(actualViewHolder.callToActionView).isEqualTo(expectedViewHolder.callToActionView);
+        assertThat(actualViewHolder.mainImageView).isEqualTo(expectedViewHolder.mainImageView);
+        assertThat(actualViewHolder.iconImageView).isEqualTo(expectedViewHolder.iconImageView);
+        assertThat(actualViewHolder.privacyInformationIconImageView).isEqualTo(
+                expectedViewHolder.privacyInformationIconImageView);
+    }
+
+    @Test
+    public void supports_withCorrectInstanceOfBaseNativeAd_shouldReturnTrue() throws Exception {
+        assertThat(subject.supports(new StaticNativeAd() {})).isTrue();
+        assertThat(subject.supports(mock(MoPubStaticNativeAd.class))).isTrue();
+        assertThat(subject.supports(mock(BaseNativeAd.class))).isFalse();
+        assertThat(subject.supports(mock(MoPubCustomEventVideoNative.MoPubVideoNativeAd.class)))
+                .isFalse();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubForwardingNativeAdTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubStaticNativeAdTest.java
similarity index 62%
rename from mopub-sdk/src/test/java/com/mopub/nativeads/MoPubForwardingNativeAdTest.java
rename to mopub-sdk/src/test/java/com/mopub/nativeads/MoPubStaticNativeAdTest.java
index 668842d0..63b43fc0 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubForwardingNativeAdTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubStaticNativeAdTest.java
@@ -2,8 +2,13 @@
 
 import android.app.Activity;
 import android.graphics.Bitmap;
+import android.view.View;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
+import com.mopub.nativeads.BaseNativeAd.NativeEventListener;
+import com.mopub.nativeads.CustomEventNative.CustomEventNativeListener;
+import com.mopub.nativeads.MoPubCustomEventNative.MoPubStaticNativeAd;
 import com.mopub.nativeads.test.support.MoPubShadowBitmap;
 import com.mopub.nativeads.test.support.MoPubShadowDisplay;
 import com.mopub.network.MaxWidthImageLoader;
@@ -13,6 +18,7 @@
 import com.mopub.volley.toolbox.ImageLoader;
 
 import org.json.JSONArray;
+import org.json.JSONException;
 import org.json.JSONObject;
 import org.junit.Before;
 import org.junit.Test;
@@ -20,6 +26,7 @@
 import org.mockito.Mock;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 
 import java.util.ArrayList;
@@ -27,9 +34,9 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 
-import static com.mopub.nativeads.NativeResponse.Parameter;
-import static com.mopub.nativeads.NativeResponse.Parameter.requiredKeys;
+import static com.mopub.nativeads.MoPubCustomEventNative.MoPubStaticNativeAd.Parameter;
 import static com.mopub.volley.toolbox.ImageLoader.ImageListener;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.fest.assertions.api.Assertions.fail;
@@ -43,62 +50,67 @@
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
-@Config(shadows={MoPubShadowBitmap.class, MoPubShadowDisplay.class})
-public class MoPubForwardingNativeAdTest {
+@Config(constants = BuildConfig.class, shadows={MoPubShadowBitmap.class, MoPubShadowDisplay.class})
+public class MoPubStaticNativeAdTest {
 
+    private MoPubStaticNativeAd subject;
     private JSONObject fakeJsonObject;
-    private MoPubCustomEventNative.MoPubForwardingNativeAd subject;
     private Activity context;
 
-    @Mock
-    private CustomEventNative.CustomEventNativeListener mockCustomEventNativeListener;
-    @Mock
-    private MoPubRequestQueue mockRequestQueue;
-    @Mock
-    private MaxWidthImageLoader mockImageLoader;
-    @Mock
-    private ImageLoader.ImageContainer mockImageContainer;
+    @Mock private View mockView;
+    @Mock private ImpressionTracker mockImpressionTracker;
+    @Mock private NativeClickHandler mMockNativeClickHandler;
+    @Mock private CustomEventNativeListener mockCustomEventNativeListener;
+    @Mock private NativeEventListener mockNativeEventListener;
+    @Mock private MoPubRequestQueue mockRequestQueue;
+    @Mock private MaxWidthImageLoader mockImageLoader;
+    @Mock private ImageLoader.ImageContainer mockImageContainer;
 
     @Before
     public void setUp() throws Exception {
-        context = new Activity();
+        context = Robolectric.buildActivity(Activity.class).create().get();
         fakeJsonObject = new JSONObject();
         fakeJsonObject.put("imptracker", new JSONArray("[\"url1\", \"url2\"]"));
         fakeJsonObject.put("clktracker", "expected clicktracker");
+        subject = new MoPubStaticNativeAd(context, fakeJsonObject, mockImpressionTracker,
+                mMockNativeClickHandler, mockCustomEventNativeListener);
+        subject.setNativeEventListener(mockNativeEventListener);
+
         Networking.setRequestQueueForTesting(mockRequestQueue);
         Networking.setImageLoaderForTesting(mockImageLoader);
         stub(mockImageContainer.getBitmap()).toReturn(mock(Bitmap.class));
     }
 
     @Test
-    public void parameter_requiredKeys_shouldOnlyContainTheRequiredKeys() throws Exception {
+    public void Parameter_requiredKeys_shouldOnlyContainTheRequiredKeys() {
         final HashSet<String> expectedKeys = new HashSet<String>();
         expectedKeys.add("imptracker");
         expectedKeys.add("clktracker");
 
-        assertThat(requiredKeys).isEqualTo(expectedKeys);
+        assertThat(Parameter.requiredKeys).isEqualTo(expectedKeys);
     }
 
     @Test
-    public void parameter_fromString_shouldReturnParameterOnMatch() throws Exception {
+    public void Parameter_fromString_shouldReturnParameterOnMatch() {
         final Parameter parameter = Parameter.from("title");
 
         assertThat(parameter).isEqualTo(Parameter.TITLE);
     }
 
     @Test
-    public void parameter_fromString_shouldReturnNullOnIllegalKey() throws Exception {
+    public void Parameter_fromString_shouldReturnNullOnIllegalKey() {
         final Parameter parameter = Parameter.from("random gibberish");
 
         assertThat(parameter).isNull();
     }
 
     @Test
-    public void loadAd_whenMissingRequiredKeys_shouldThrowIllegalArgumentException() throws Exception {
+    public void loadAd_whenMissingRequiredKeys_shouldThrowIllegalArgumentException() {
         fakeJsonObject.remove("imptracker");
 
         try {
-            subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
+            subject = new MoPubStaticNativeAd(context, fakeJsonObject, mockImpressionTracker,
+                    mMockNativeClickHandler, mockCustomEventNativeListener);
             subject.loadAd();
             fail("Expected IllegalArgumentException");
         } catch (IllegalArgumentException e) {
@@ -111,7 +123,8 @@ public void loadAd_whenRequiredKeyOfWrongType_shouldThrowIllegalArgumentExceptio
         fakeJsonObject.put("imptracker", 12345);
 
         try {
-            subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
+            subject = new MoPubStaticNativeAd(context, fakeJsonObject, mockImpressionTracker,
+                    mMockNativeClickHandler, mockCustomEventNativeListener);
             subject.loadAd();
             fail("Expected IllegalArgumentException");
         } catch (IllegalArgumentException e) {
@@ -120,8 +133,7 @@ public void loadAd_whenRequiredKeyOfWrongType_shouldThrowIllegalArgumentExceptio
     }
 
     @Test
-    public void loadAd_shouldSetRequiredExpectedFields() throws Exception {
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
+    public void loadAd_shouldSetRequiredExpectedFields() {
         subject.loadAd();
         assertThat(subject.getImpressionTrackers()).containsOnly("url1", "url2");
     }
@@ -139,7 +151,8 @@ public void loadAd_shouldSetOptionalExpectedFields() throws Exception {
         fakeJsonObject.put("ctatext", "expected ctatext");
         fakeJsonObject.put("starrating", 5.0);
 
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
+        subject = new MoPubStaticNativeAd(context, fakeJsonObject, mockImpressionTracker,
+                mMockNativeClickHandler, mockCustomEventNativeListener);
         subject.loadAd();
 
         assertThat(subject.getTitle()).isEqualTo("expected title");
@@ -149,7 +162,6 @@ public void loadAd_shouldSetOptionalExpectedFields() throws Exception {
 
         assertThat(subject.getClickDestinationUrl()).isEqualTo("expected clk");
 
-//        assertThat(subject.getFallback()).isEqualTo("expected fallback");
         assertThat(subject.getImpressionTrackers()).containsOnly("url1", "url2");
         assertThat(subject.getCallToAction()).isEqualTo("expected ctatext");
         assertThat(subject.getStarRating()).isEqualTo(5.0);
@@ -159,7 +171,8 @@ public void loadAd_shouldSetOptionalExpectedFields() throws Exception {
     public void loadAd_withIntegerStarRating_shouldSetStarRating() throws Exception {
         fakeJsonObject.put("starrating", 3);
 
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
+        subject = new MoPubStaticNativeAd(context, fakeJsonObject, mockImpressionTracker,
+                mMockNativeClickHandler, mockCustomEventNativeListener);
         subject.loadAd();
 
         assertThat(subject.getStarRating()).isEqualTo(3.0);
@@ -169,7 +182,8 @@ public void loadAd_withIntegerStarRating_shouldSetStarRating() throws Exception
     public void loadAd_withStringStarRating_shouldSetStarRating() throws Exception {
         fakeJsonObject.put("starrating", "2.3");
 
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
+        subject = new MoPubStaticNativeAd(context, fakeJsonObject, mockImpressionTracker,
+                mMockNativeClickHandler, mockCustomEventNativeListener);
         subject.loadAd();
 
         assertThat(subject.getStarRating()).isEqualTo(2.3);
@@ -179,7 +193,8 @@ public void loadAd_withStringStarRating_shouldSetStarRating() throws Exception {
     public void loadAd_withInvalidStringStarRating_shouldNotSetStarRating() throws Exception {
         fakeJsonObject.put("starrating", "this is not a number");
 
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
+        subject = new MoPubStaticNativeAd(context, fakeJsonObject, mockImpressionTracker,
+                mMockNativeClickHandler, mockCustomEventNativeListener);
         subject.loadAd();
 
         assertThat(subject.getStarRating()).isNull();
@@ -189,7 +204,8 @@ public void loadAd_withInvalidStringStarRating_shouldNotSetStarRating() throws E
     public void loadAd_withInvalidlyTypedStarRating_shouldNotSetStarRating() throws Exception {
         fakeJsonObject.put("starrating", new Activity());
 
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
+        subject = new MoPubStaticNativeAd(context, fakeJsonObject, mockImpressionTracker,
+                mMockNativeClickHandler, mockCustomEventNativeListener);
         subject.loadAd();
 
         assertThat(subject.getStarRating()).isNull();
@@ -207,7 +223,8 @@ public void loadAd_whenImpressionTrackersContainsNonStrings_willCoerceToString()
         impressionTrackers.put(2.12);
         fakeJsonObject.put("imptracker", impressionTrackers);
 
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
+        subject = new MoPubStaticNativeAd(context, fakeJsonObject, mockImpressionTracker,
+                mMockNativeClickHandler, mockCustomEventNativeListener);
         subject.loadAd();
 
         assertThat(subject.getImpressionTrackers()).containsOnly("url1", "null", "2.12");
@@ -228,7 +245,8 @@ public void loadAd_shouldSetExtraFields() throws Exception {
         fakeJsonObject.put("key3", new JSONArray(array));
         fakeJsonObject.put("key4", new JSONObject(map));
 
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
+        subject = new MoPubStaticNativeAd(context, fakeJsonObject, mockImpressionTracker,
+                mMockNativeClickHandler, mockCustomEventNativeListener);
         subject.loadAd();
 
         assertThat(subject.getExtra("key1")).isEqualTo("yay json");
@@ -253,7 +271,8 @@ public Void answer(final InvocationOnMock invocationOnMock) throws Throwable {
                     }
                 });
 
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
+        subject = new MoPubStaticNativeAd(context, fakeJsonObject, mockImpressionTracker,
+                mMockNativeClickHandler, mockCustomEventNativeListener);
         subject.loadAd();
 
         verify(mockImageLoader).get(eq("mainimageurl"), any(ImageListener.class));
@@ -280,13 +299,39 @@ public Void answer(final InvocationOnMock invocationOnMock) throws Throwable {
                     }
                 });
 
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
+        subject = new MoPubStaticNativeAd(context, fakeJsonObject, mockImpressionTracker,
+                mMockNativeClickHandler, mockCustomEventNativeListener);
         subject.loadAd();
 
         verify(mockCustomEventNativeListener, never()).onNativeAdLoaded(subject);
         verify(mockCustomEventNativeListener).onNativeAdFailed(NativeErrorCode.IMAGE_DOWNLOAD_FAILURE);
     }
 
+    @Test
+    public void loadAd_shouldParseSingleClickTracker() {
+        subject = new MoPubStaticNativeAd(context, fakeJsonObject, mockImpressionTracker,
+                mMockNativeClickHandler, mockCustomEventNativeListener);
+        subject.loadAd();
+
+        final Set<String> clickTrackers = subject.getClickTrackers();
+        assertThat(clickTrackers.size()).isEqualTo(1);
+        assertThat(clickTrackers.contains("expected clicktracker")).isTrue();
+    }
+
+    @Test
+    public void loadAd_shouldParseMultipleClickTrackers() throws Exception {
+        fakeJsonObject.remove("clktracker");
+        fakeJsonObject.put("clktracker", new JSONArray("[\"clicktracker1\",\"clicktracker2\"]"));
+        subject = new MoPubStaticNativeAd(context, fakeJsonObject, mockImpressionTracker,
+                mMockNativeClickHandler, mockCustomEventNativeListener);
+        subject.loadAd();
+
+        final Set<String> clickTrackers = subject.getClickTrackers();
+        assertThat(clickTrackers.size()).isEqualTo(2);
+        assertThat(clickTrackers.contains("clicktracker1")).isTrue();
+        assertThat(clickTrackers.contains("clicktracker2")).isTrue();
+    }
+
     @Test
     public void getExtrasImageUrls_whenExtrasContainsImages_shouldReturnImageUrls() throws Exception {
         // getExtrasImageUrls requires the key to end with a case-insensitive "image" to be counted as an image
@@ -295,7 +340,9 @@ public void getExtrasImageUrls_whenExtrasContainsImages_shouldReturnImageUrls()
         fakeJsonObject.put("otherIMAGE", "image_url_2");
         fakeJsonObject.put("more filler", "ignored");
         fakeJsonObject.put("lastimage", "image_url_3");
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
+
+        subject = new MoPubStaticNativeAd(context, fakeJsonObject, mockImpressionTracker,
+                mMockNativeClickHandler, mockCustomEventNativeListener);
         subject.loadAd();
 
         assertThat(subject.getExtrasImageUrls()).containsOnly("image_url_1", "image_url_2", "image_url_3");
@@ -308,7 +355,9 @@ public void getExtrasImageUrls_whenExtrasDoesNotContainImageKeys_shouldReturnEmp
         fakeJsonObject.put("imageAtFront", "ignored");
         fakeJsonObject.put("middle_image_in_key", "ignored");
         fakeJsonObject.put("other", "ignored");
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
+
+        subject = new MoPubStaticNativeAd(context, fakeJsonObject, mockImpressionTracker,
+                mMockNativeClickHandler, mockCustomEventNativeListener);
         subject.loadAd();
 
         assertThat(subject.getExtrasImageUrls()).isEmpty();
@@ -319,7 +368,9 @@ public void getAllImageUrls_withExtraImagesAndMainAndIconImages_shouldReturnAllU
         fakeJsonObject.put("mainimage", "mainImageUrl");
         fakeJsonObject.put("iconimage", "iconImageUrl");
         fakeJsonObject.put("extraimage", "extraImageUrl");
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
+
+        subject = new MoPubStaticNativeAd(context, fakeJsonObject, mockImpressionTracker,
+                mMockNativeClickHandler, mockCustomEventNativeListener);
         subject.loadAd();
 
         assertThat(subject.getAllImageUrls()).containsOnly(
@@ -333,9 +384,51 @@ public void getAllImageUrls_withExtraImagesAndMainAndIconImages_shouldReturnAllU
     public void getAllImageUrls_withOnlyExtrasImages_shouldNotIncludeMainOrIconImages() throws Exception {
         fakeJsonObject.put("extra1_image", "expected extra1_image");
         fakeJsonObject.put("extra2_image", "expected extra2_image");
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
+
+        subject = new MoPubStaticNativeAd(context, fakeJsonObject, mockImpressionTracker,
+                mMockNativeClickHandler, mockCustomEventNativeListener);
         subject.loadAd();
 
         assertThat(subject.getAllImageUrls()).containsOnly("expected extra1_image", "expected extra2_image");
     }
+
+    @Test
+    public void prepare_shouldAddViewToImpressionTracker_shouldSetOnClickListener() {
+        subject.prepare(mockView);
+
+        verify(mockImpressionTracker).addView(mockView, subject);
+        verify(mMockNativeClickHandler).setOnClickListener(mockView, subject);
+    }
+
+    @Test
+    public void clear_shouldRemoveViewFromImpressionTracker_shouldClearOnClickListener() {
+        subject.clear(mockView);
+
+        verify(mockImpressionTracker).removeView(mockView);
+        verify(mMockNativeClickHandler).clearOnClickListener(mockView);
+    }
+
+    @Test
+    public void destroy_shouldDestroyImpressionTracker() {
+        subject.destroy();
+
+        verify(mockImpressionTracker).destroy();
+    }
+
+    @Test
+    public void recordImpression_shouldNotifyAdImpressed_shouldTrackImpression() throws Exception {
+        subject.addImpressionTrackers(new JSONArray("[\"impressionUrl\"]"));
+        subject.recordImpression(mockView);
+
+        verify(mockNativeEventListener).onAdImpressed();
+    }
+
+    @Test
+    public void handleClick_shouldNotifyAdClicked_shouldOpenClickDestinationUrl() {
+        subject.setClickDestinationUrl("clickDestinationUrl");
+        subject.handleClick(mockView);
+
+        verify(mockNativeEventListener).onAdClicked();
+        verify(mMockNativeClickHandler).openClickDestinationUrl("clickDestinationUrl", mockView);
+    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubStreamAdPlacerTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubStreamAdPlacerTest.java
index 2e772506..92e3c62d 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubStreamAdPlacerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubStreamAdPlacerTest.java
@@ -1,11 +1,11 @@
 package com.mopub.nativeads;
 
 import android.app.Activity;
-import android.content.Context;
 import android.view.View;
 import android.view.ViewGroup;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
 import com.mopub.nativeads.PositioningSource.PositioningListener;
 
@@ -16,6 +16,7 @@
 import org.mockito.ArgumentCaptor;
 import org.mockito.Mock;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -32,8 +33,9 @@
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class MoPubStreamAdPlacerTest {
-    private Context context;
+    private Activity activity;
 
     MoPubClientPositioning positioning;
 
@@ -42,25 +44,24 @@
     @Mock
     NativeAdSource mockAdSource;
     @Mock
-    MoPubNativeAdRenderer mockAdRenderer;
+    MoPubStaticNativeAdRenderer mockAdRenderer;
     @Mock
     MoPubNativeAdLoadedListener mockAdLoadedListener;
     @Mock
     ImpressionTracker mockImpressionTracker;
 
     @Mock(answer = Answers.RETURNS_DEEP_STUBS)
-    NativeResponse stubNativeResponse;
+    NativeAd mStubNativeAd;
 
     private MoPubStreamAdPlacer subject;
 
     @Before
     public void setup() {
-        context = Robolectric.buildActivity(Activity.class).create().get();
+        activity = Robolectric.buildActivity(Activity.class).create().get();
         positioning = MoPubNativeAdPositioning.clientPositioning()
                 .enableRepeatingPositions(2);
 
-        subject = new MoPubStreamAdPlacer(
-                context, mockAdSource, mockImpressionTracker, mockPositioningSource);
+        subject = new MoPubStreamAdPlacer(activity, mockAdSource, mockPositioningSource);
         subject.registerAdRenderer(mockAdRenderer);
         subject.setAdLoadedListener(mockAdLoadedListener);
     }
@@ -78,7 +79,7 @@ public void isAd_loadPositions_withoutLoadingAds_hasNoAds() {
 
     @Test
     public void isAd_loadAds_withoutLoadingPositions_hasNoAds() {
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        when(mockAdSource.dequeueAd()).thenReturn(mStubNativeAd);
         subject.handleAdsAvailable();
         subject.setItemCount(4);
         checkAdPositions();
@@ -86,7 +87,7 @@ public void isAd_loadAds_withoutLoadingPositions_hasNoAds() {
 
     @Test
     public void isAd_loadAds_thenLoadPositions_hasAds() {
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        when(mockAdSource.dequeueAd()).thenReturn(mStubNativeAd);
         subject.registerAdRenderer(mockAdRenderer);
         subject.loadAds("test-ad-unit-id");
 
@@ -98,7 +99,7 @@ public void isAd_loadAds_thenLoadPositions_hasAds() {
 
     @Test
     public void isAd_loadPositions_thenLoadAds_hasAds() {
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        when(mockAdSource.dequeueAd()).thenReturn(mStubNativeAd);
         subject.registerAdRenderer(mockAdRenderer);
         subject.loadAds("test-ad-unit-id");
 
@@ -108,6 +109,12 @@ public void isAd_loadPositions_thenLoadAds_hasAds() {
         checkAdPositions(1, 3, 5);
     }
 
+    @Test
+    public void getAdViewTypeCount_shouldAdSourceCallGetAdRendererCount() throws Exception {
+        subject.getAdViewTypeCount();
+        verify(mockAdSource).getAdRendererCount();
+    }
+
     @Test
     public void getOriginalPosition_adjustsPositions() {
         assertThat(subject.getOriginalPosition(0)).isEqualTo(0);
@@ -116,7 +123,7 @@ public void getOriginalPosition_adjustsPositions() {
         assertThat(subject.getOriginalPosition(3)).isEqualTo(3);
         assertThat(subject.getOriginalPosition(4)).isEqualTo(4);
 
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        when(mockAdSource.dequeueAd()).thenReturn(mStubNativeAd);
         subject.registerAdRenderer(mockAdRenderer);
         subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
@@ -143,7 +150,7 @@ public void getAdjustedPosition_adjustsPositions() {
         assertThat(subject.getAdjustedPosition(3)).isEqualTo(3);
         assertThat(subject.getAdjustedPosition(4)).isEqualTo(4);
 
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        when(mockAdSource.dequeueAd()).thenReturn(mStubNativeAd);
         subject.registerAdRenderer(mockAdRenderer);
         subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
@@ -170,7 +177,7 @@ public void getOriginalCount_adjustsPositions() {
         assertThat(subject.getOriginalCount(3)).isEqualTo(3);
         assertThat(subject.getOriginalCount(4)).isEqualTo(4);
 
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        when(mockAdSource.dequeueAd()).thenReturn(mStubNativeAd);
         subject.registerAdRenderer(mockAdRenderer);
         subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
@@ -197,7 +204,7 @@ public void getAdjustedCount_adjustsPositions() {
         assertThat(subject.getAdjustedCount(3)).isEqualTo(3);
         assertThat(subject.getAdjustedCount(4)).isEqualTo(4);
 
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        when(mockAdSource.dequeueAd()).thenReturn(mStubNativeAd);
         subject.registerAdRenderer(mockAdRenderer);
         subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
@@ -218,7 +225,7 @@ public void getAdjustedCount_adjustsPositions() {
 
     @Test
     public void placeAds_shouldCallListener() {
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        when(mockAdSource.dequeueAd()).thenReturn(mStubNativeAd);
         subject.registerAdRenderer(mockAdRenderer);
         subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
@@ -237,16 +244,16 @@ public void placeAds_shouldCallListener() {
 
     @Test
     public void placeAdsInRange_shouldPlaceAfter() {
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        when(mockAdSource.dequeueAd()).thenReturn(mStubNativeAd);
         subject.registerAdRenderer(mockAdRenderer);
         subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
 
-        Robolectric.getUiThreadScheduler().pause();
+        Robolectric.getForegroundThreadScheduler().pause();
         subject.setItemCount(100);
         subject.placeAdsInRange(50, 50);
-        Robolectric.getUiThreadScheduler().advanceToLastPostedRunnable();
+        Robolectric.getForegroundThreadScheduler().advanceToLastPostedRunnable();
 
         assertThat(subject.isAd(48)).isFalse();
         assertThat(subject.isAd(49)).isFalse();
@@ -259,16 +266,16 @@ public void placeAdsInRange_shouldPlaceAfter() {
 
     @Test
     public void placeAdsInRange_shouldCallListener() {
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        when(mockAdSource.dequeueAd()).thenReturn(mStubNativeAd);
         subject.registerAdRenderer(mockAdRenderer);
         subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
 
-        Robolectric.getUiThreadScheduler().pause();
+        Robolectric.getForegroundThreadScheduler().pause();
         subject.setItemCount(100);
         subject.placeAdsInRange(50, 54);
-        Robolectric.getUiThreadScheduler().advanceToLastPostedRunnable();
+        Robolectric.getForegroundThreadScheduler().advanceToLastPostedRunnable();
 
         verify(mockAdLoadedListener).onAdLoaded(50);
         verify(mockAdLoadedListener, never()).onAdLoaded(51);
@@ -281,16 +288,16 @@ public void placeAdsInRange_shouldCallListener() {
 
     @Test
     public void placeAdsInRange_aboveItemCount_shouldNotInsert() {
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        when(mockAdSource.dequeueAd()).thenReturn(mStubNativeAd);
         subject.registerAdRenderer(mockAdRenderer);
         subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
 
-        Robolectric.getUiThreadScheduler().pause();
+        Robolectric.getForegroundThreadScheduler().pause();
         subject.setItemCount(0);
         subject.placeAdsInRange(50, 54);
-        Robolectric.getUiThreadScheduler().advanceToLastPostedRunnable();
+        Robolectric.getForegroundThreadScheduler().advanceToLastPostedRunnable();
 
         verify(mockAdLoadedListener, never()).onAdLoaded(50);
     }
@@ -302,7 +309,7 @@ public void getAdView_withNoAds_returnsNull() {
 
     @Test
     public void loadAds_shouldClearAds_afterFirstAdLoads() {
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        when(mockAdSource.dequeueAd()).thenReturn(mStubNativeAd);
         subject.registerAdRenderer(mockAdRenderer);
         subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
@@ -330,7 +337,9 @@ public void loadAds_withFailingPositioningSource_shouldNotLoadAds() {
                 ArgumentCaptor.forClass(PositioningListener.class);
 
         subject.registerAdRenderer(mockAdRenderer);
+        when(mockAdSource.getAdRendererCount()).thenReturn(1);
         subject.loadAds("test-ad-unit-id");
+
         verify(mockPositioningSource).loadPositions(
                 eq("test-ad-unit-id"), listenerCaptor.capture());
         listenerCaptor.getValue().onFailed();
@@ -338,11 +347,10 @@ public void loadAds_withFailingPositioningSource_shouldNotLoadAds() {
     }
 
     @Test
-    public void destroy_shouldClearAdSource_shouldDestroyImpressionTracker_shouldDestroyResponse() {
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+    public void destroy_shouldClearAdSource_shouldDestroyImpressionTracker_shouldDestroyNativeAd() {
+        when(mockAdSource.dequeueAd()).thenReturn(mStubNativeAd);
 
-        subject = new MoPubStreamAdPlacer(context,
-                mockAdSource, mockImpressionTracker, mockPositioningSource);
+        subject = new MoPubStreamAdPlacer(activity, mockAdSource, mockPositioningSource);
         subject.registerAdRenderer(mockAdRenderer);
         subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
@@ -352,16 +360,14 @@ public void destroy_shouldClearAdSource_shouldDestroyImpressionTracker_shouldDes
         subject.destroy();
 
         verify(mockAdSource).clear();
-        verify(mockImpressionTracker).destroy();
-        verify(stubNativeResponse).destroy();
+        verify(mStubNativeAd).destroy();
     }
 
     @Test
     public void getAdView_withNullConvertView_callsRenderer_addsToImpressionTracker() {
-        View view = new View(context);
-        when(mockAdRenderer.createAdView(any(Context.class), any(ViewGroup.class)))
-                .thenReturn(view);
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        View view = new View(activity);
+        when(mStubNativeAd.createAdView(any(Activity.class), any(ViewGroup.class))).thenReturn(view);
+        when(mockAdSource.dequeueAd()).thenReturn(mStubNativeAd);
         subject.registerAdRenderer(mockAdRenderer);
         subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
@@ -369,15 +375,15 @@ public void getAdView_withNullConvertView_callsRenderer_addsToImpressionTracker(
         subject.setItemCount(100);
 
         assertThat(subject.getAdView(1, null, null)).isEqualTo(view);
-        verify(mockAdRenderer).createAdView(any(Context.class), any(ViewGroup.class));
-        verify(mockAdRenderer).renderAdView(view, stubNativeResponse);
-        verify(mockImpressionTracker).addView(view, stubNativeResponse);
+
+        verify(mStubNativeAd).createAdView(eq(activity), any(ViewGroup.class));
+        verify(mStubNativeAd).renderAdView(view);
     }
 
     @Test
-    public void getAdView_withConvertView_callsRenderer_addsToImpressionTracker() {
-        View convertView = new View(context);
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+    public void getAdView_withConvertView_shouldCallRenderer() {
+        View convertView = new View(activity);
+        when(mockAdSource.dequeueAd()).thenReturn(mStubNativeAd);
         subject.registerAdRenderer(mockAdRenderer);
         subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
@@ -385,16 +391,15 @@ public void getAdView_withConvertView_callsRenderer_addsToImpressionTracker() {
         subject.setItemCount(4);
 
         assertThat(subject.getAdView(1, convertView, null)).isEqualTo(convertView);
-        verify(mockAdRenderer, never()).createAdView(any(Context.class), any(ViewGroup.class));
-        verify(mockAdRenderer).renderAdView(convertView, stubNativeResponse);
-        verify(mockImpressionTracker).addView(convertView, stubNativeResponse);
+        verify(mStubNativeAd, never()).createAdView(any(Activity.class), any(ViewGroup.class));
+        verify(mStubNativeAd).renderAdView(convertView);
     }
 
     @Test
-    public void getAdView_shouldRemoveViewFromImpressionTracker_shouldClearPreviousNativeResponse() throws Exception {
-        NativeResponse mockNativeResponse = mock(NativeResponse.class);
+    public void getAdView_shouldClearPreviousNativeAd() throws Exception {
+        NativeAd mockNativeAd = mock(NativeAd.class);
         View mockView = mock(View.class);
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse, mockNativeResponse, stubNativeResponse);
+        when(mockAdSource.dequeueAd()).thenReturn(mStubNativeAd, mockNativeAd, mStubNativeAd);
         subject.registerAdRenderer(mockAdRenderer);
         subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
@@ -402,59 +407,36 @@ public void getAdView_shouldRemoveViewFromImpressionTracker_shouldClearPreviousN
         subject.setItemCount(100);
 
         subject.getAdView(1, mockView, null);
-        verify(mockImpressionTracker).removeView(mockView);
 
-        // Second call should clear the first NativeResponse
+        // Second call should clear the first NativeAd
         subject.getAdView(3, mockView, null);
-        verify(mockImpressionTracker, times(2)).removeView(mockView);
-        verify(stubNativeResponse).clear(mockView);
+        verify(mStubNativeAd).clear(mockView);
 
-        // Third call should clear the second NativeResponse
+        // Third call should clear the second NativeAd
         subject.getAdView(5, mockView, null);
-        verify(mockImpressionTracker, times(3)).removeView(mockView);
-        verify(mockNativeResponse).clear(mockView);
-    }
-
-    @Test
-    public void getAdView_withNetworkImpressionTracker_shouldNotAddViewToImpressionTracker_shouldPrepareNativeResponse() throws Exception {
-        View mockView = mock(View.class);
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
-        subject.registerAdRenderer(mockAdRenderer);
-        subject.loadAds("test-ad-unit-id");
-        subject.handlePositioningLoad(positioning);
-        subject.handleAdsAvailable();
-        subject.setItemCount(100);
-
-        when(stubNativeResponse.isOverridingImpressionTracker()).thenReturn(true);
-        subject.getAdView(1, mockView, null);
-
-        verify(mockImpressionTracker, never()).addView(any(View.class), any(NativeResponse.class));
-        verify(stubNativeResponse).prepare(mockView);
+        verify(mockNativeAd).clear(mockView);
     }
 
     @Test
-    public void getAdView_withoutNetworkImpressionTracker_shouldAddViewToImpressionTracker_shouldPrepareNativeResponse() throws Exception {
+    public void getAdView_shouldPrepareNativeAd() throws Exception {
         View mockView = mock(View.class);
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        when(mockAdSource.dequeueAd()).thenReturn(mStubNativeAd);
         subject.registerAdRenderer(mockAdRenderer);
         subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
         subject.setItemCount(100);
 
-        when(stubNativeResponse.isOverridingImpressionTracker()).thenReturn(false);
         subject.getAdView(1, mockView, null);
 
-        verify(mockImpressionTracker).addView(mockView, stubNativeResponse);
-        verify(stubNativeResponse).prepare(mockView);
+        verify(mStubNativeAd).prepare(mockView);
     }
 
     @Test
-    public void destroy_shouldClearAdSource_shouldDestroyImpressionTracker_shouldResetPlacementData() {
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+    public void destroy_shouldClearAdSource_shouldResetPlacementData() {
+        when(mockAdSource.dequeueAd()).thenReturn(mStubNativeAd);
 
-        subject = new MoPubStreamAdPlacer(context,
-                mockAdSource, mockImpressionTracker, mockPositioningSource);
+        subject = new MoPubStreamAdPlacer(activity, mockAdSource, mockPositioningSource);
         subject.registerAdRenderer(mockAdRenderer);
         subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
@@ -464,13 +446,12 @@ public void destroy_shouldClearAdSource_shouldDestroyImpressionTracker_shouldRes
         subject.destroy();
 
         verify(mockAdSource).clear();
-        verify(mockImpressionTracker).destroy();
-        verify(stubNativeResponse).destroy();
+        verify(mStubNativeAd).destroy();
     }
 
     @Test
     public void modifyClientPositioning_afterConstructingAdPlacer_shouldNotModifyAdPositions() {
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        when(mockAdSource.dequeueAd()).thenReturn(mStubNativeAd);
         subject.registerAdRenderer(mockAdRenderer);
         subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubVideoNativeAdRendererTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubVideoNativeAdRendererTest.java
new file mode 100644
index 00000000..02f53e1f
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubVideoNativeAdRendererTest.java
@@ -0,0 +1,215 @@
+package com.mopub.nativeads;
+
+import android.graphics.Bitmap;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ImageView;
+import android.widget.RelativeLayout;
+import android.widget.TextView;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.Utils;
+import com.mopub.mobileads.BuildConfig;
+import com.mopub.network.MaxWidthImageLoader;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.volley.toolbox.ImageLoader;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.annotation.Config;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.stub;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class MoPubVideoNativeAdRendererTest {
+    private MoPubVideoNativeAdRenderer subject;
+    private VideoNativeAd videoNativeAd;
+    @Mock private RelativeLayout relativeLayout;
+    @Mock private ViewGroup viewGroup;
+    private MediaViewBinder mediaViewBinder;
+    @Mock private TextView titleView;
+    @Mock private TextView textView;
+    @Mock private TextView callToActionView;
+    @Mock private MediaLayout mediaLayoutView;
+    @Mock private ImageView iconImageView;
+    @Mock private ImageView privacyInformationIconImageView;
+    @Mock private ImageView badView;
+    @Mock private MoPubRequestQueue mockRequestQueue;
+    @Mock private MaxWidthImageLoader mockImageLoader;
+    @Mock private ImageLoader.ImageContainer mockImageContainer;
+
+    @Before
+    public void setUp() throws Exception {
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+        Networking.setImageLoaderForTesting(mockImageLoader);
+        stub(mockImageContainer.getBitmap()).toReturn(mock(Bitmap.class));
+
+        when(relativeLayout.getId()).thenReturn((int) Utils.generateUniqueId());
+
+        videoNativeAd = new VideoNativeAd() {
+
+            @Override
+            public void onStateChanged(final boolean playWhenReady, final int playbackState) {
+            }
+
+            @Override
+            public void onError(final Exception e) {
+            }
+        };
+        videoNativeAd.setTitle("test title");
+        videoNativeAd.setText("test text");
+        videoNativeAd.setCallToAction("test call to action");
+        videoNativeAd.setClickDestinationUrl("destinationUrl");
+        videoNativeAd.setMainImageUrl("testUrl");
+        videoNativeAd.setIconImageUrl("testUrl");
+        videoNativeAd.setVastVideo("test video");
+
+        setViewIdInLayout(titleView, relativeLayout);
+        setViewIdInLayout(textView, relativeLayout);
+        setViewIdInLayout(callToActionView, relativeLayout);
+        setViewIdInLayout(mediaLayoutView, relativeLayout);
+        setViewIdInLayout(iconImageView, relativeLayout);
+        setViewIdInLayout(privacyInformationIconImageView, relativeLayout);
+        setViewIdInLayout(badView, relativeLayout);
+
+        mediaViewBinder = new MediaViewBinder.Builder(relativeLayout.getId())
+                .titleId(titleView.getId())
+                .textId(textView.getId())
+                .callToActionId(callToActionView.getId())
+                .mediaLayoutId(mediaLayoutView.getId())
+                .iconImageId(iconImageView.getId())
+                .privacyInformationIconImageId(privacyInformationIconImageView.getId())
+                .build();
+
+        subject = new MoPubVideoNativeAdRenderer(mediaViewBinder);
+    }
+
+    private void setViewIdInLayout(View mockView, RelativeLayout mockLayout) {
+        int id = (int) Utils.generateUniqueId();
+        when(mockView.getId()).thenReturn(id);
+        when(mockLayout.findViewById(eq(id))).thenReturn(mockView);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void createAdView_withNullContext_shouldThrowNPE() {
+        subject.createAdView(null, viewGroup);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void renderAdView_withNullView_shouldThrowNPE() {
+        subject.renderAdView(null, videoNativeAd);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void renderAdView_withNullNativeAd_shouldThrowNPE() {
+        subject.renderAdView(relativeLayout, null);
+    }
+
+    @Rule public ExpectedException exception = ExpectedException.none();
+
+    @Test
+    public void renderAdView_withNullViewBinder_shouldThrowNPE() {
+        subject = new MoPubVideoNativeAdRenderer(null);
+
+        exception.expect(NullPointerException.class);
+        subject.renderAdView(relativeLayout, videoNativeAd);
+    }
+
+    @Test
+    public void renderAdView_shouldReturnPopulatedView() {
+        subject.renderAdView(relativeLayout, videoNativeAd);
+
+        verify(titleView).setText(eq("test title"));
+        verify(textView).setText(eq("test text"));
+        verify(callToActionView).setText(eq("test call to action"));
+
+        // not testing images due to testing complexity
+    }
+
+    @Test
+    public void renderAdView_withFailedViewBinder_shouldNotWriteViews() {
+        mediaViewBinder = new MediaViewBinder.Builder(relativeLayout.getId())
+                .titleId(titleView.getId())
+                .textId(badView.getId())
+                .callToActionId(callToActionView.getId())
+                .mediaLayoutId(mediaLayoutView.getId())
+                .iconImageId(iconImageView.getId())
+                .build();
+
+        subject = new MoPubVideoNativeAdRenderer(mediaViewBinder);
+        subject.renderAdView(relativeLayout, videoNativeAd);
+
+        verify(titleView, never()).setText(anyString());
+        verify(textView, never()).setText(anyString());
+        verify(callToActionView, never()).setText(anyString());
+        verify(mediaLayoutView, times(2)).getId();
+        verifyNoMoreInteractions(mediaLayoutView);
+        verify(iconImageView, times(2)).getId();
+        verifyNoMoreInteractions(iconImageView);
+    }
+
+    @Test
+    public void renderAdView_withNoViewHolder_shouldCreateNativeViewHolder() {
+        subject.renderAdView(relativeLayout, videoNativeAd);
+
+        MediaViewHolder expectedViewHolder = MediaViewHolder.fromViewBinder
+                (relativeLayout,
+                mediaViewBinder);
+        MediaViewHolder viewHolder = subject.mMediaViewHolderMap.get(relativeLayout);
+        compareNativeViewHolders(expectedViewHolder, viewHolder);
+    }
+
+    @Test
+    public void getOrCreateNativeViewHolder_withViewHolder_shouldNotReCreateNativeViewHolder() {
+        subject.renderAdView(relativeLayout, videoNativeAd);
+        MediaViewHolder expectedViewHolder = subject.mMediaViewHolderMap.get(relativeLayout);
+        subject.renderAdView(relativeLayout, videoNativeAd);
+
+        MediaViewHolder viewHolder = subject.mMediaViewHolderMap.get(relativeLayout);
+        assertThat(viewHolder).isEqualTo(expectedViewHolder);
+    }
+
+    static private void compareNativeViewHolders(final MediaViewHolder actualViewHolder,
+            final MediaViewHolder expectedViewHolder) {
+        assertThat(actualViewHolder.titleView).isEqualTo(expectedViewHolder.titleView);
+        assertThat(actualViewHolder.textView).isEqualTo(expectedViewHolder.textView);
+        assertThat(actualViewHolder.callToActionView).isEqualTo(expectedViewHolder.callToActionView);
+        assertThat(actualViewHolder.mediaLayout).isEqualTo(expectedViewHolder.mediaLayout);
+        assertThat(actualViewHolder.iconImageView).isEqualTo(expectedViewHolder.iconImageView);
+        assertThat(actualViewHolder.privacyInformationIconImageView).isEqualTo(
+                expectedViewHolder.privacyInformationIconImageView);
+    }
+
+    @Test
+    public void supports_withCorrectInstanceOfBaseNativeAd_shouldReturnTrue() throws Exception {
+        assertThat(subject.supports(new VideoNativeAd() {
+            @Override
+            public void onStateChanged(final boolean playWhenReady, final int playbackState) {
+            }
+
+            @Override
+            public void onError(final Exception e) {
+            }
+        })).isTrue();
+        assertThat(subject.supports(
+                mock(MoPubCustomEventVideoNative.MoPubVideoNativeAd.class))).isTrue();
+        assertThat(subject.supports(mock(BaseNativeAd.class))).isFalse();
+        assertThat(subject.supports(mock(MoPubCustomEventNative.MoPubStaticNativeAd.class)))
+                .isFalse();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubVideoNativeAdTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubVideoNativeAdTest.java
new file mode 100644
index 00000000..53242996
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubVideoNativeAdTest.java
@@ -0,0 +1,916 @@
+package com.mopub.nativeads;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.graphics.Bitmap;
+import android.graphics.SurfaceTexture;
+import android.graphics.drawable.Drawable;
+import android.media.AudioManager;
+import android.os.Build;
+import android.view.TextureView;
+import android.view.TextureView.SurfaceTextureListener;
+import android.view.View;
+
+import com.mopub.common.event.EventDetails;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BaseVideoPlayerActivity;
+import com.mopub.mobileads.BuildConfig;
+import com.mopub.mobileads.MraidVideoPlayerActivity;
+import com.mopub.mobileads.VastManager;
+import com.mopub.mobileads.VastTracker;
+import com.mopub.mobileads.VastVideoConfig;
+import com.mopub.mobileads.VideoViewabilityTracker;
+import com.mopub.nativeads.BaseNativeAd.NativeEventListener;
+import com.mopub.nativeads.CustomEventNative.CustomEventNativeListener;
+import com.mopub.nativeads.MoPubCustomEventVideoNative.HeaderVisibilityStrategy;
+import com.mopub.nativeads.MoPubCustomEventVideoNative.MoPubVideoNativeAd;
+import com.mopub.nativeads.MoPubCustomEventVideoNative.MoPubVideoNativeAd.VideoState;
+import com.mopub.nativeads.MoPubCustomEventVideoNative.NativeVideoControllerFactory;
+import com.mopub.nativeads.MoPubCustomEventVideoNative.PayloadVisibilityStrategy;
+import com.mopub.nativeads.MoPubCustomEventVideoNative.VideoResponseHeaders;
+import com.mopub.nativeads.NativeVideoController.VisibilityTrackingEvent;
+import com.mopub.network.MaxWidthImageLoader;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.volley.toolbox.ImageLoader;
+import com.mopub.volley.toolbox.ImageLoader.ImageListener;
+
+import org.json.JSONArray;
+import org.json.JSONObject;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowApplication;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import static com.mopub.common.VolleyRequestMatcher.isUrl;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyBoolean;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Matchers.argThat;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.stub;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class MoPubVideoNativeAdTest {
+
+    private MoPubVideoNativeAd subject;
+    private Activity activity;
+    private JSONObject jsonObject;
+    private Map<String, String> serverExtras;
+    private VideoResponseHeaders videoResponseHeaders;
+
+    @Mock private CustomEventNativeListener mockCustomEventNativeListener;
+    @Mock private VastVideoConfig mockVastVideoConfig;
+    @Mock private MaxWidthImageLoader mockImageLoader;
+    @Mock private ImageLoader.ImageContainer mockImageContainer;
+    @Mock private NativeVideoController mockNativeVideoController;
+    @Mock private VisibilityTracker mockVisibilityTracker;
+    @Mock private NativeVideoControllerFactory mockNativeVideoControllerFactory;
+    @Mock private MediaLayout mockMediaLayout;
+    @Mock private View mockRootView;
+    @Mock private SurfaceTexture mockSurfaceTexture;
+    @Mock private TextureView mockTextureView;
+    @Mock private Drawable mockDrawable;
+    @Mock private MoPubRequestQueue mockRequestQueue;
+    @Mock private NativeEventListener mockNativeEventListener;
+    @Mock private VastManager mockVastManager;
+
+    @Before
+    public void setUp() throws Exception {
+        activity = Robolectric.buildActivity(Activity.class).create().get();
+
+        jsonObject = new JSONObject();
+        jsonObject.put("imptracker", new JSONArray("[\"url1\", \"url2\"]"));
+        jsonObject.put("clktracker", "json click tracker");
+        jsonObject.put("title", "title");
+        jsonObject.put("text", "text");
+        jsonObject.put("mainimage", "mainimageurl");
+        jsonObject.put("iconimage", "iconimageurl");
+        jsonObject.put("clk", "clk");
+        jsonObject.put("fallback", "fallback");
+        jsonObject.put("ctatext", "ctatext");
+        jsonObject.put("video", "video");
+        jsonObject.put("extraimage", "extraimageurl");
+
+        serverExtras = new HashMap<String, String>();
+        serverExtras.put("Play-Visible-Percent", "10");
+        serverExtras.put("Pause-Visible-Percent", "5");
+        serverExtras.put("Impression-Min-Visible-Percent", "15");
+        serverExtras.put("Impression-Visible-Ms", "100");
+        serverExtras.put("Max-Buffer-Ms", "20");
+        videoResponseHeaders = new VideoResponseHeaders(serverExtras);
+
+        when(mockVastVideoConfig.getVideoViewabilityTracker())
+                .thenReturn(new VideoViewabilityTracker(98, 76, "viewabilityTracker"));
+
+        subject = new MoPubVideoNativeAd(
+                activity, jsonObject, mockCustomEventNativeListener, videoResponseHeaders,
+                mockVisibilityTracker, mockNativeVideoControllerFactory, null,
+                "header click tracker", mockVastManager);
+        subject.setNativeEventListener(mockNativeEventListener);
+        when(mockNativeVideoControllerFactory
+                .createForId(anyInt(), any(Context.class), any(List.class), eq(mockVastVideoConfig),
+                        any(EventDetails.class)))
+                .thenReturn(mockNativeVideoController);
+
+        when(mockImageLoader.get(anyString(), any(ImageListener.class)))
+                .then(new Answer<Void>() {
+                    @Override
+                    public Void answer(final InvocationOnMock invocationOnMock) throws Throwable {
+                        ImageListener listener = ((ImageListener) invocationOnMock.getArguments()[1]);
+                        listener.onResponse(mockImageContainer, false);
+                        return null;
+                    }
+                });
+        when(mockMediaLayout.getTextureView()).thenReturn(mockTextureView);
+
+        stub(mockImageContainer.getBitmap()).toReturn(mock(Bitmap.class));
+        Networking.setImageLoaderForTesting(mockImageLoader);
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+    }
+
+    @After
+    public void tearDown() {
+        Networking.setImageLoaderForTesting(null);
+        Networking.setRequestQueueForTesting(null);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void loadAd_withoutImpTrackerRequiredKey_shouldThrowIllegalArgumentException() {
+        jsonObject.remove("imptracker");
+        subject.loadAd();
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void loadAd_withoutClkTrackerRequiredKey_shouldThrowIllegalArgumentException() {
+        jsonObject.remove("clktracker");
+        subject.loadAd();
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void loadAd_withInvalidValueForRequiredKey_shouldThrowIllegalArgumentException() throws Exception {
+        jsonObject.put("imptracker", 123);
+        subject.loadAd();
+    }
+
+    @Test
+    public void loadAd_withInvalidValueForOptionalKey_shouldNotThrowExcpetion() throws Exception {
+        jsonObject.put("title", 123);
+        subject.loadAd();
+    }
+
+    @Test
+    public void loadAd_shouldInitializeAssetValues() {
+        subject.loadAd();
+
+        assertThat(subject.getImpressionTrackers()).containsOnly("url1", "url2");
+        assertThat(subject.getTitle()).isEqualTo("title");
+        assertThat(subject.getText()).isEqualTo("text");
+        assertThat(subject.getMainImageUrl()).isEqualTo("mainimageurl");
+        assertThat(subject.getIconImageUrl()).isEqualTo("iconimageurl");
+        assertThat(subject.getClickDestinationUrl()).isEqualTo("clk");
+        assertThat(subject.getCallToAction()).isEqualTo("ctatext");
+        assertThat(subject.getPrivacyInformationIconClickThroughUrl()).isEqualTo(
+                "https://www.mopub.com/optout/");
+        assertThat(subject.getVastVideo()).isEqualTo("video");
+        assertThat(subject.getExtra("extraimage")).isEqualTo("extraimageurl");
+        assertThat(subject.getExtras()).hasSize(1);
+    }
+
+    @Test
+    public void loadAd_shouldPrecacheImages_andLoadVastXml() {
+        subject.loadAd();
+
+        verify(mockImageLoader).get(eq("mainimageurl"), any(ImageListener.class));
+        verify(mockImageLoader).get(eq("iconimageurl"), any(ImageListener.class));
+        verify(mockImageLoader).get(eq("extraimageurl"), any(ImageListener.class));
+        verify(mockVastManager).prepareVastVideoConfiguration(eq("video"),
+                any(VastManager.VastManagerListener.class), any(Context.class));
+    }
+
+    @Test
+    public void onVastVideoConfigurationPrepared_withNullVastVideoConfig_shouldNotifyListenerFailed() {
+        subject.onVastVideoConfigurationPrepared(null);
+        verify(mockCustomEventNativeListener).onNativeAdFailed(NativeErrorCode.INVALID_RESPONSE);
+    }
+
+    @Test
+    public void onVastVideoConfigurationPrepared_shouldConstructNativeVideoController_shouldNotifyListenerOfAdLoaded() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+
+        ArgumentCaptor<List> argumentCaptor = ArgumentCaptor.forClass(List.class);
+        verify(mockNativeVideoControllerFactory).createForId(anyInt(),
+                eq(activity.getApplicationContext()),
+                argumentCaptor.capture(),
+                eq(mockVastVideoConfig),
+                any(EventDetails.class));
+
+        List<VisibilityTrackingEvent> visibilityTrackingEvents = (List<VisibilityTrackingEvent>) argumentCaptor.getValue();
+        assertThat(visibilityTrackingEvents.get(0).strategy).isInstanceOf(HeaderVisibilityStrategy.class);
+        assertThat(visibilityTrackingEvents.get(0).minimumPercentageVisible).isEqualTo(15);
+        assertThat(visibilityTrackingEvents.get(0).totalRequiredPlayTimeMs).isEqualTo(100);
+
+        assertThat(visibilityTrackingEvents.get(1).strategy).isInstanceOf(PayloadVisibilityStrategy.class);
+        assertThat(visibilityTrackingEvents.get(1).minimumPercentageVisible).isEqualTo(76);
+        assertThat(visibilityTrackingEvents.get(1).totalRequiredPlayTimeMs).isEqualTo(98);
+
+        verify(mockVastVideoConfig).addClickTrackers(any(List.class));
+        verify(mockVastVideoConfig).setClickThroughUrl("clk");
+        verify(mockCustomEventNativeListener).onNativeAdLoaded(subject);
+    }
+
+    @Test
+    public void onVastVideoConfigurationPrepared_shouldMergeHeaderAndJsonClickTrackers() {
+        final ArgumentCaptor<List> argumentCaptor = ArgumentCaptor.forClass(List.class);
+
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+
+        verify(mockVastVideoConfig).addClickTrackers(argumentCaptor.capture());
+        final List<VastTracker> actualClickTrackers = (List<VastTracker>) argumentCaptor.getValue();
+        assertThat(actualClickTrackers.size()).isEqualTo(2);
+        final VastTracker headerClickTracker = actualClickTrackers.get(0);
+        final VastTracker jsonClickTracker = actualClickTrackers.get(1);
+        assertThat(headerClickTracker.getTrackingUrl()).isEqualTo("header click tracker");
+        assertThat(headerClickTracker.isRepeatable()).isFalse();
+        assertThat(jsonClickTracker.getTrackingUrl()).isEqualTo("json click tracker");
+        assertThat(jsonClickTracker.isRepeatable()).isFalse();
+    }
+
+    @Test
+    public void onVastVideoConfigurationPrepared_shouldDedupeHeaderAndJsonClickTrackers() throws Exception {
+        jsonObject.remove("clktracker");
+        jsonObject.put("clktracker", "header click tracker");
+        final ArgumentCaptor<List> argumentCaptor = ArgumentCaptor.forClass(List.class);
+
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+
+        verify(mockVastVideoConfig).addClickTrackers(argumentCaptor.capture());
+        final List<VastTracker> actualClickTrackers = (List<VastTracker>) argumentCaptor.getValue();
+        assertThat(actualClickTrackers.size()).isEqualTo(1);
+        final VastTracker clickTracker = actualClickTrackers.get(0);
+        assertThat(clickTracker.getTrackingUrl()).isEqualTo("header click tracker");
+        assertThat(clickTracker.isRepeatable()).isFalse();
+    }
+
+    @Test
+    public void onVastVideoConfigurationPrepared_shouldAcceptJsonArrayClickTrackers() throws Exception {
+        jsonObject.remove("clktracker");
+        jsonObject.put("clktracker",
+                new JSONArray("[\"json click tracker 1\", \"json click tracker 2\"]"));
+        final ArgumentCaptor<List> argumentCaptor = ArgumentCaptor.forClass(List.class);
+
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+
+        verify(mockVastVideoConfig).addClickTrackers(argumentCaptor.capture());
+        final List<VastTracker> actualClickTrackers = (List<VastTracker>) argumentCaptor.getValue();
+        assertThat(actualClickTrackers.size()).isEqualTo(3);
+        final VastTracker jsonClickTracker1 = actualClickTrackers.get(0);
+        final VastTracker jsonClickTracker2 = actualClickTrackers.get(1);
+        final VastTracker headerClickTracker = actualClickTrackers.get(2);
+        assertThat(jsonClickTracker1.getTrackingUrl()).isEqualTo("json click tracker 1");
+        assertThat(jsonClickTracker1.isRepeatable()).isFalse();
+        assertThat(jsonClickTracker2.getTrackingUrl()).isEqualTo("json click tracker 2");
+        assertThat(jsonClickTracker2.isRepeatable()).isFalse();
+        assertThat(headerClickTracker.getTrackingUrl()).isEqualTo("header click tracker");
+        assertThat(headerClickTracker.isRepeatable()).isFalse();
+    }
+
+    @Test
+    public void onVastVideoConfigurationPrepared_shouldDedupeJsonArrayClickTrackers() throws Exception {
+        jsonObject.remove("clktracker");
+        jsonObject.put("clktracker",
+                new JSONArray("[\"json click tracker\", \"header click tracker\"]"));
+        final ArgumentCaptor<List> argumentCaptor = ArgumentCaptor.forClass(List.class);
+
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+
+        verify(mockVastVideoConfig).addClickTrackers(argumentCaptor.capture());
+        final List<VastTracker> actualClickTrackers = (List<VastTracker>) argumentCaptor.getValue();
+        assertThat(actualClickTrackers.size()).isEqualTo(2);
+        final VastTracker headerClickTracker = actualClickTrackers.get(0);
+        final VastTracker jsonClickTracker = actualClickTrackers.get(1);
+        assertThat(headerClickTracker.getTrackingUrl()).isEqualTo("header click tracker");
+        assertThat(headerClickTracker.isRepeatable()).isFalse();
+        assertThat(jsonClickTracker.getTrackingUrl()).isEqualTo("json click tracker");
+        assertThat(jsonClickTracker.isRepeatable()).isFalse();
+    }
+
+    @Test
+    public void render_shouldAddViewToVisibilityTracker() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        verify(mockVisibilityTracker).addView(mockRootView, mockMediaLayout, 10, 5);
+    }
+
+    @Test
+    public void render_shouldSetupMediaLayout() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        verify(mockMediaLayout).setSurfaceTextureListener(any(SurfaceTextureListener.class));
+        verify(mockMediaLayout).setPlayButtonClickListener(any(View.OnClickListener.class));
+        verify(mockMediaLayout).setMuteControlClickListener(any(View.OnClickListener.class));
+        verify(mockMediaLayout).setOnClickListener(any(View.OnClickListener.class));
+    }
+
+    @Test
+    public void render_shouldApplyStatePaused() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        verify(mockMediaLayout).setMode(MediaLayout.Mode.PAUSED);
+    }
+
+    @Test
+    public void render_withPlaybackStateCleared_shouldPrepareNativeVideoController() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        when(mockNativeVideoController.getPlaybackState()).thenReturn(NativeVideoController
+                .STATE_CLEARED);
+        subject.render(mockMediaLayout);
+
+        verify(mockNativeVideoController).prepare(subject);
+    }
+
+    @Test
+    public void MediaLayout_surfaceTextureListener_onSurfaceTextureAvailable_shouldSetupNativeVideoController_shouldResetMediaLayoutProgress() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        ArgumentCaptor<SurfaceTextureListener> argumentCaptor =
+                ArgumentCaptor.forClass(SurfaceTextureListener.class);
+        verify(mockMediaLayout).setSurfaceTextureListener(argumentCaptor.capture());
+        SurfaceTextureListener surfaceTextureListener = argumentCaptor.getValue();
+
+        surfaceTextureListener.onSurfaceTextureAvailable(mockSurfaceTexture, 0, 0);
+
+        verify(mockNativeVideoController).setListener(subject);
+        verify(mockNativeVideoController).setOnAudioFocusChangeListener(subject);
+        verify(mockNativeVideoController).setProgressListener(subject);
+        verify(mockNativeVideoController).setTextureView(mockMediaLayout.getTextureView());
+        verify(mockMediaLayout).resetProgress();
+    }
+
+    @Test
+    public void MediaLayout_surfaceTextureListener_onSurfaceTextureAvailable_withCurrentPositionWithinThreshhold_withStateEnded_shouldSetFinalFrameAsMainImage() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        ArgumentCaptor<SurfaceTextureListener> argumentCaptor =
+                ArgumentCaptor.forClass(SurfaceTextureListener.class);
+        verify(mockMediaLayout).setSurfaceTextureListener(argumentCaptor.capture());
+        SurfaceTextureListener surfaceTextureListener = argumentCaptor.getValue();
+
+        when(mockNativeVideoController.getPlaybackState())
+                .thenReturn(NativeVideoController.STATE_ENDED);
+        when(mockNativeVideoController.getCurrentPosition()).thenReturn(9L);
+        when(mockNativeVideoController.getDuration()).thenReturn(10L);
+        when(mockNativeVideoController.hasFinalFrame()).thenReturn(true);
+        when(mockNativeVideoController.getFinalFrame()).thenReturn(mockDrawable);
+
+        surfaceTextureListener.onSurfaceTextureAvailable(mockSurfaceTexture, 0, 0);
+
+        verify(mockMediaLayout).setMainImageDrawable(mockNativeVideoController.getFinalFrame());
+    }
+
+    @Test
+    public void MediaLayout_surfaceTextureListener_onSurfaceTextureAvailable_withNeedsPrepare_shouldPrepareNativeVideoController() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.render(mockMediaLayout);
+
+        ArgumentCaptor<SurfaceTextureListener> argumentCaptor =
+                ArgumentCaptor.forClass(SurfaceTextureListener.class);
+        verify(mockMediaLayout).setSurfaceTextureListener(argumentCaptor.capture());
+        SurfaceTextureListener surfaceTextureListener = argumentCaptor.getValue();
+
+        surfaceTextureListener.onSurfaceTextureAvailable(mockSurfaceTexture, 0, 0);
+
+        verify(mockNativeVideoController).prepare(subject);
+    }
+
+    @Test
+    public void MediaLayout_surfaceTextureListener_onSurfaceTextureDestroyed_shouldSetNeedsPrepareTrue_shouldReleaseMoPubNativeVideoAd_shouldApplyStatePaused() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        ArgumentCaptor<SurfaceTextureListener> argumentCaptor =
+                ArgumentCaptor.forClass(SurfaceTextureListener.class);
+        verify(mockMediaLayout).setSurfaceTextureListener(argumentCaptor.capture());
+        SurfaceTextureListener surfaceTextureListener = argumentCaptor.getValue();
+
+        surfaceTextureListener.onSurfaceTextureDestroyed(mockSurfaceTexture);
+
+        assertThat(subject.needsPrepare()).isTrue();
+        verify(mockNativeVideoController).release(subject);
+        verify(mockMediaLayout).setMode(MediaLayout.Mode.PAUSED);
+    }
+
+    @Test
+    public void MediaLayout_playButtonClickListener_shouldResetMediaLayoutProgress_shouldSeekTo0_shouldSetEndedFalse_shouldSetNeedsSeekFalse() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        ArgumentCaptor<View.OnClickListener> argumentCaptor =
+                ArgumentCaptor.forClass(View.OnClickListener.class);
+        verify(mockMediaLayout).setPlayButtonClickListener(argumentCaptor.capture());
+
+        View.OnClickListener onClickListener = argumentCaptor.getValue();
+        onClickListener.onClick(null);
+
+        verify(mockMediaLayout).resetProgress();
+        verify(mockNativeVideoController).seekTo(0);
+        assertThat(subject.hasEnded()).isEqualTo(false);
+        assertThat(subject.needsSeek()).isEqualTo(false);
+    }
+
+    @Test
+    public void MediaLayout_muteButtonClickListener_withStateReady_shouldToggleMutedState() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        ArgumentCaptor<View.OnClickListener> argumentCaptor =
+                ArgumentCaptor.forClass(View.OnClickListener.class);
+        verify(mockMediaLayout).setMuteControlClickListener(argumentCaptor.capture());
+
+        View.OnClickListener onClickListener = argumentCaptor.getValue();
+        onClickListener.onClick(null);
+        assertThat(subject.isMuted()).isFalse();
+
+        onClickListener.onClick(null);
+        assertThat(subject.isMuted()).isTrue();
+    }
+
+    @Test
+    public void MediaLayout_clickListener_shouldPrepareToLeaveView_shouldTriggerImpressionTracker_shouldNotDisableAppAudio_shouldStartFullScreenVideoActivity() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        ArgumentCaptor<View.OnClickListener> argumentCaptor =
+                ArgumentCaptor.forClass(View.OnClickListener.class);
+        verify(mockMediaLayout).setOnClickListener(argumentCaptor.capture());
+
+        reset(mockNativeVideoController);
+        View.OnClickListener onClickListener = argumentCaptor.getValue();
+        onClickListener.onClick(null);
+
+        assertThat(subject.needsSeek()).isTrue();
+        assertThat(subject.needsPrepare()).isTrue();
+        assertThat(subject.needsPrepare()).isTrue();
+        verify(mockNativeVideoController).setListener(null);
+        verify(mockNativeVideoController).setOnAudioFocusChangeListener(null);
+        verify(mockNativeVideoController).setProgressListener(null);
+        verify(mockNativeVideoController).clear();
+        verify(mockNativeVideoController).triggerImpressionTrackers();
+        verify(mockMediaLayout).setMode(MediaLayout.Mode.PAUSED);
+        verify(mockNativeVideoController, never()).setAppAudioEnabled(anyBoolean());
+
+        final Intent startedActivity = ShadowApplication.getInstance().peekNextStartedActivity();
+        assertThat(startedActivity.getComponent().getClassName())
+                .isEqualTo(MraidVideoPlayerActivity.class.getName());
+        assertThat(startedActivity.getStringExtra(BaseVideoPlayerActivity.VIDEO_CLASS_EXTRAS_KEY))
+                .isEqualTo("native");
+        assertThat(startedActivity.getLongExtra(NativeVideoViewController.NATIVE_VIDEO_ID, 0L))
+                .isGreaterThan(0L);
+        assertThat(startedActivity.getSerializableExtra(NativeVideoViewController
+                .NATIVE_VAST_VIDEO_CONFIG))
+                .isEqualTo(mockVastVideoConfig);
+    }
+
+    @Test
+    public void prepare_shouldSetOnClickListenerOnView() {
+        subject.prepare(mockRootView);
+        verify(mockRootView).setOnClickListener(any(View.OnClickListener.class));
+    }
+
+    @Test
+    public void RootView_onClickListener_onClick_shouldPrepareToLeaveView_shouldNotDisableAppAudio_shouldNotNotifyAdClicked_shouldTriggerImpressionTrackers_shouldshouldHandleCtaClick() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        ArgumentCaptor<View.OnClickListener> argumentCaptor =
+                ArgumentCaptor.forClass(View.OnClickListener.class);
+        verify(mockRootView).setOnClickListener(argumentCaptor.capture());
+
+        View.OnClickListener onClickListener = argumentCaptor.getValue();
+        reset(mockNativeVideoController);
+        onClickListener.onClick(null);
+
+        assertThat(subject.needsSeek()).isTrue();
+        assertThat(subject.needsPrepare()).isTrue();
+        assertThat(subject.needsPrepare()).isTrue();
+        verify(mockNativeVideoController).setListener(null);
+        verify(mockNativeVideoController).setOnAudioFocusChangeListener(null);
+        verify(mockNativeVideoController).setProgressListener(null);
+        verify(mockNativeVideoController).clear();
+        verify(mockMediaLayout).setMode(MediaLayout.Mode.PAUSED);
+        verify(mockNativeVideoController).handleCtaClick(activity.getApplicationContext());
+        verify(mockNativeEventListener, never()).onAdClicked();
+        verify(mockNativeVideoController).triggerImpressionTrackers();
+        verify(mockNativeVideoController, never()).setAppAudioEnabled(anyBoolean());
+    }
+
+    @Test
+    public void clear_shouldClearNativeVideoController_shouldSetMediaLayoutModeImage_shouldSetMediaLayoutNull_shouldSetMediaLayoutListenersToNull_shouldRemoveMediaLayoutFromVisibilityTracker() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+        subject.clear(mockRootView);
+
+        verify(mockNativeVideoController).clear();
+        verify(mockMediaLayout).setMode(MediaLayout.Mode.IMAGE);
+        verify(mockMediaLayout).setSurfaceTextureListener(null);
+        verify(mockMediaLayout).setPlayButtonClickListener(null);
+        verify(mockMediaLayout).setMuteControlClickListener(null);
+        verify(mockMediaLayout).setOnClickListener(null);
+        verify(mockVisibilityTracker).removeView(mockMediaLayout);
+        assertThat(subject.getMediaLayout()).isNull();
+    }
+
+    @Test
+    public void destroy_shouldSetPlayWhenReadyFalse_shouldReleaseNativeVideoController_shouldRemoveNativeVideoController_shouldDestroyVisibilityTracker() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        reset(mockNativeVideoController);
+        subject.destroy();
+
+        verify(mockMediaLayout).setMode(MediaLayout.Mode.IMAGE);
+        verify(mockMediaLayout).setSurfaceTextureListener(null);
+        verify(mockMediaLayout).setPlayButtonClickListener(null);
+        verify(mockMediaLayout).setMuteControlClickListener(null);
+        verify(mockMediaLayout).setOnClickListener(null);
+        verify(mockVisibilityTracker).removeView(mockMediaLayout);
+
+        assertThat(subject.getMediaLayout()).isNull();
+        verify(mockNativeVideoController).setPlayWhenReady(false);
+        verify(mockNativeVideoController).release(subject);
+        assertThat(NativeVideoController.getForId(subject.getId())).isNull();
+        verify(mockVisibilityTracker).destroy();
+    }
+
+    @Test
+    public void onStateChanged_shouldAppropriatelySetVideoState() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        subject.onStateChanged(true, NativeVideoController.STATE_PREPARING);
+        assertThat(subject.getVideoState()).isEqualTo(VideoState.LOADING);
+
+        subject.onStateChanged(true, NativeVideoController.STATE_IDLE);
+        assertThat(subject.getVideoState()).isEqualTo(VideoState.LOADING);
+
+        subject.onStateChanged(true, NativeVideoController.STATE_BUFFERING);
+        assertThat(subject.getVideoState()).isEqualTo(VideoState.BUFFERING);
+
+        subject.onStateChanged(true, NativeVideoController.STATE_READY);
+        assertThat(subject.getVideoState()).isEqualTo(VideoState.PAUSED);
+
+        subject.setLatestVisibility(true);
+        subject.onStateChanged(true, NativeVideoController.STATE_READY);
+        assertThat(subject.getVideoState()).isEqualTo(VideoState.PLAYING_MUTED);
+
+        subject.setMuted(false);
+        subject.onStateChanged(true, NativeVideoController.STATE_READY);
+        assertThat(subject.getVideoState()).isEqualTo(VideoState.PLAYING);
+
+        subject.onStateChanged(true, NativeVideoController.STATE_ENDED);
+        assertThat(subject.getVideoState()).isEqualTo(VideoState.ENDED);
+        assertThat(subject.hasEnded()).isTrue();
+    }
+
+    @Test
+    public void onError_shouldSetVideoStateError() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        subject.onError(new Exception());
+
+        assertThat(subject.getVideoState()).isEqualTo(VideoState.FAILED_LOAD);
+    }
+
+    @Test
+    public void updateProgress_shouldUpdateMediaLayoutProgress() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        subject.updateProgress(312);
+
+        verify(mockMediaLayout).updateProgress(312);
+    }
+
+    @Test
+    public void onAudioFocusChange_withFocusChangeAudioFocusLossOrAudioFocusLossTransient_shouldMuteTheVideo() throws Exception {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        subject.setMuted(false);
+        subject.onAudioFocusChange(AudioManager.AUDIOFOCUS_LOSS);
+
+        assertThat(subject.isMuted()).isTrue();
+
+        subject.setMuted(false);
+        subject.onAudioFocusChange(AudioManager.AUDIOFOCUS_LOSS_TRANSIENT);
+
+        assertThat(subject.isMuted()).isTrue();
+    }
+
+    @Test
+    public void onAudioFocusChange_withFocusChangeAudioFocusLossTransientCanDuck_shouldLowerVolume() throws Exception {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        subject.onAudioFocusChange(AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK);
+
+        verify(mockNativeVideoController).setAudioVolume(0.3f);
+    }
+
+    @Test
+    public void onAudioFocusChange_withFocusChangeAudioFocusGain_shouldRaiseVolume() throws Exception {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        subject.onAudioFocusChange(AudioManager.AUDIOFOCUS_GAIN);
+
+        verify(mockNativeVideoController).setAudioVolume(1.0f);
+    }
+
+    @Test
+    public void applyState_shouldHandleError_shouldSetAppAudioEnabledFalse_shouldSetMediaLayoutModeImage() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        reset(mockNativeVideoController);
+        subject.applyState(VideoState.FAILED_LOAD);
+
+        verify(mockVastVideoConfig).handleError(activity.getApplicationContext(), null, 0);
+        verify(mockNativeVideoController).setAppAudioEnabled(false);
+        verify(mockMediaLayout).setMode(MediaLayout.Mode.IMAGE);
+    }
+
+    @Test
+    public void applyState_withVideoStateCreatedOrLoading_shouldSetPlayWhenReadyTrue_shouldSetMediaLayoutModeLoading() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        subject.applyState(VideoState.CREATED);
+
+        verify(mockNativeVideoController).setPlayWhenReady(true);
+        verify(mockMediaLayout).setMode(MediaLayout.Mode.LOADING);
+
+        reset(mockNativeVideoController);
+        reset(mockMediaLayout);
+        subject.applyState(VideoState.LOADING);
+
+        verify(mockNativeVideoController).setPlayWhenReady(true);
+        verify(mockMediaLayout).setMode(MediaLayout.Mode.LOADING);
+    }
+
+    @Test
+    public void applyState_withVideoStateBuffering_shouldSetPlayWhenReadyTrue_shouldSetMediaLayoutModeBuffering() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        subject.applyState(VideoState.BUFFERING);
+
+        verify(mockNativeVideoController).setPlayWhenReady(true);
+        verify(mockMediaLayout).setMode(MediaLayout.Mode.BUFFERING);
+    }
+
+    @Test
+    public void applyState_withVideoStatePaused_withTransitionToFullScreenFalse_shouldSetAppAudioEnabledFalse_shouldSetPlayWhenReadyFalse_shouldSetMediaLayoutModePaused() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        subject.applyState(VideoState.PAUSED);
+
+        verify(mockNativeVideoController).setAppAudioEnabled(false);
+        verify(mockNativeVideoController).setPlayWhenReady(false);
+        verify(mockMediaLayout).setMode(MediaLayout.Mode.PAUSED);
+    }
+
+    @Test
+    public void applyState_withVideoStatePlaying_shouldSetPlayWhenReadyTrue_shouldSetAudioEnabledTrue_shouldSetAppAudioEnabledTrue_shouldSetMediaLayoutModePlaying_shouldSetMuteStateUnmuted() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        reset(mockNativeVideoController);
+        subject.applyState(VideoState.PLAYING);
+
+        verify(mockNativeVideoController).setPlayWhenReady(true);
+        verify(mockNativeVideoController).setAudioEnabled(true);
+        verify(mockNativeVideoController).setAppAudioEnabled(true);
+        verify(mockMediaLayout).setMode(MediaLayout.Mode.PLAYING);
+        verify(mockMediaLayout).setMuteState(MediaLayout.MuteState.UNMUTED);
+    }
+
+    @Test
+    public void applyState_withVideoStatePlaying_withNeedsSeek_shouldSeekToCurrentPosition() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        assertThat(subject.needsSeek()).isTrue();
+        when(mockNativeVideoController.getCurrentPosition()).thenReturn(543L);
+        subject.applyState(VideoState.PLAYING);
+
+        verify(mockNativeVideoController).seekTo(mockNativeVideoController.getCurrentPosition());
+    }
+
+    @Test
+    public void applyState_withVideoStatePlayingMuted_shouldSetPlayWhenReadyTrue_shouldSetAudioEnabledFalse_shouldSetAppAudioEnabledTrue_shouldSetMediaLayoutModePlaying_shouldSetMuteStateMuted() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        reset(mockNativeVideoController);
+        subject.applyState(VideoState.PLAYING_MUTED);
+
+        verify(mockNativeVideoController).setPlayWhenReady(true);
+        verify(mockNativeVideoController).setAudioEnabled(false);
+        verify(mockNativeVideoController).setAppAudioEnabled(false);
+        verify(mockMediaLayout).setMode(MediaLayout.Mode.PLAYING);
+        verify(mockMediaLayout).setMuteState(MediaLayout.MuteState.MUTED);
+    }
+
+    @Test
+    public void applyState_withVideoStatePlayingMuted_withNeedsSeek_shouldSeekToCurrentPosition() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        assertThat(subject.needsSeek()).isTrue();
+        when(mockNativeVideoController.getCurrentPosition()).thenReturn(543L);
+        subject.applyState(VideoState.PLAYING_MUTED);
+
+        verify(mockNativeVideoController).seekTo(mockNativeVideoController.getCurrentPosition());
+    }
+
+    @Test
+    public void applyState_withVideoStatePlayingEnded_shouldHandleComplete_shouldSetAppAudioEnabledTrue_shouldSetMediaLayoutModeFinished_shouldUpdateMediaLayoutProgress1000() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        reset(mockNativeVideoController);
+        subject.applyState(VideoState.ENDED);
+
+        verify(mockVastVideoConfig).handleComplete(activity.getApplicationContext(), 0);
+        verify(mockNativeVideoController).setAppAudioEnabled(false);
+        verify(mockMediaLayout).setMode(MediaLayout.Mode.FINISHED);
+        verify(mockMediaLayout).updateProgress(1000);
+
+        verify(mockMediaLayout, never()).setMainImageDrawable(any(Drawable.class));
+    }
+
+    @Test
+    public void applyState_withVideoStatePlayingEnded_withFinalFrame_shouldSetMainImageDrawableOfMediaLayout() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        when(mockNativeVideoController.hasFinalFrame()).thenReturn(true);
+        when(mockNativeVideoController.getFinalFrame()).thenReturn(mockDrawable);
+        subject.applyState(VideoState.ENDED);
+
+        verify(mockMediaLayout).setMainImageDrawable(mockNativeVideoController.getFinalFrame());
+    }
+
+    @Test
+    public void applyState_withVideoStatePause_afterVideoStatePlayingMuted_shouldFirePauseTrackers() {
+        final ArrayList<VastTracker> testList = new ArrayList<VastTracker>();
+        testList.add(new VastTracker("testUrl", true));
+
+        when(mockVastVideoConfig.getPauseTrackers()).thenReturn(testList);
+
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        subject.applyState(VideoState.PLAYING_MUTED);
+        subject.applyState(VideoState.PAUSED);
+
+        verify(mockVastVideoConfig).getPauseTrackers();
+        verify(mockRequestQueue).add(argThat(isUrl("testUrl")));
+    }
+
+    @Test
+    public void applyState_withVideoStatePlayingMuted_afterPaused_afterPlaying_shouldFireResumeTrackers() {
+        final ArrayList<VastTracker> testList = new ArrayList<VastTracker>();
+        testList.add(new VastTracker("testResumeUrl", true));
+
+        when(mockVastVideoConfig.getResumeTrackers()).thenReturn(testList);
+
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        subject.applyState(VideoState.PLAYING_MUTED);
+        subject.applyState(VideoState.PAUSED);
+        subject.applyState(VideoState.BUFFERING);
+        subject.applyState(VideoState.PLAYING_MUTED);
+
+        verify(mockVastVideoConfig).getPauseTrackers();
+        verify(mockRequestQueue).add(argThat(isUrl("testResumeUrl")));
+    }
+
+    @Test
+    public void HeaderVisibilityStrategy_execute_shouldNotifyAdImpressed() throws Exception {
+        HeaderVisibilityStrategy headerVisibilityStrategy
+                = new HeaderVisibilityStrategy(subject);
+        headerVisibilityStrategy.execute();
+
+        verify(mockNativeEventListener).onAdImpressed();
+    }
+
+    @Test
+    public void PayloadVisibilityStrategy_execute_shouldMakeTrackingRequest() throws Exception {
+        PayloadVisibilityStrategy payloadVisibilityStrategy
+                = new PayloadVisibilityStrategy(activity, "payloadUrl");
+        payloadVisibilityStrategy.execute();
+
+        verify(mockRequestQueue).add(argThat(isUrl("payloadUrl")));
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdSourceTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdSourceTest.java
index 13873d0c..ff8d06b1 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdSourceTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdSourceTest.java
@@ -4,11 +4,13 @@
 import android.os.SystemClock;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
+import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowSystemClock;
 
 import java.util.ArrayList;
@@ -21,40 +23,87 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class NativeAdSourceTest {
     private NativeAdSource subject;
-    private ArrayList<TimestampWrapper<NativeResponse>> nativeAdCache;
+    private ArrayList<TimestampWrapper<NativeAd>> nativeAdCache;
     private RequestParameters requestParameters;
     private int defaultRetryTime;
     private int maxRetryTime;
+    private int maxRetries;
 
     @Mock private AdSourceListener mockAdSourceListener;
     @Mock private MoPubNative mockMoPubNative;
-    @Mock private NativeResponse mockNativeResponse;
+    @Mock private NativeAd mMockNativeAd;
     @Mock private Handler mockReplenishCacheHandler;
+    @Mock private AdRendererRegistry mockAdRendererRegistry;
+    @Mock private MoPubStaticNativeAdRenderer mockRenderer;
 
     @Before
     public void setUp() {
-        nativeAdCache = new ArrayList<TimestampWrapper<NativeResponse>>(2);
-        subject = new NativeAdSource(nativeAdCache, mockReplenishCacheHandler);
+        nativeAdCache = new ArrayList<TimestampWrapper<NativeAd>>(2);
+        subject = new NativeAdSource(nativeAdCache, mockReplenishCacheHandler, mockAdRendererRegistry);
         subject.setAdSourceListener(mockAdSourceListener);
 
         requestParameters = new RequestParameters.Builder().build();
 
         defaultRetryTime = 1000;
         maxRetryTime = 5*60*1000;
+        maxRetries = 5;
 
         // XXX We need this to ensure that our SystemClock starts
         ShadowSystemClock.uptimeMillis();
+
+        ArrayList<MoPubAdRenderer> moPubAdRenderers = new ArrayList<MoPubAdRenderer>();
+        moPubAdRenderers.add(mockRenderer);
+        when(mockAdRendererRegistry.getRendererIterable()).thenReturn(moPubAdRenderers);
     }
 
     @Test
     public void constructor_shouldInitializeCorrectly() {
         assertThat(subject.mRequestInFlight).isFalse();
         assertThat(subject.mSequenceNumber).isEqualTo(0);
-        assertThat(subject.mRetryTimeMilliseconds).isEqualTo(defaultRetryTime);
+        assertThat(subject.getRetryTime()).isEqualTo(defaultRetryTime);
+    }
+
+    @Test
+    public void getAdRendererCount_shouldCallAdRendererRegistryGetAdRendererCount() throws Exception {
+        when(mockAdRendererRegistry.getAdRendererCount()).thenReturn(123);
+
+        assertThat(subject.getAdRendererCount()).isEqualTo(123);
+
+        verify(mockAdRendererRegistry).getAdRendererCount();
+    }
+
+    @Test
+    public void getViewTypeForAd_shouldCallAdRendererRegistryGetViewTypeForAd() throws Exception {
+        NativeAd nativeAd = mock(NativeAd.class);
+        when(mockAdRendererRegistry.getViewTypeForAd(nativeAd)).thenReturn(123);
+
+        assertThat(subject.getViewTypeForAd(nativeAd)).isEqualTo(123);
+
+        verify(mockAdRendererRegistry).getViewTypeForAd(nativeAd);
+    }
+
+    @Test
+    public void registerAdRenderer_shouldRegisterAdRendererWithRegistryAndMoPubNative() throws Exception {
+        subject.setMoPubNative(mockMoPubNative);
+        subject.registerAdRenderer(mockRenderer);
+
+        verify(mockAdRendererRegistry).registerAdRenderer(mockRenderer);
+        verify(mockMoPubNative).registerAdRenderer(mockRenderer);
+    }
+
+    @Test
+    public void getAdRendererForViewType_shouldCallAdRendererRegistryGetRendererForViewType() throws Exception {
+        when(mockAdRendererRegistry.getRendererForViewType(123)).thenReturn(mockRenderer);
+
+        assertThat(subject.getAdRendererForViewType(123)).isEqualTo(mockRenderer);
+
+        verify(mockAdRendererRegistry).getRendererForViewType(123);
     }
 
     @Test
@@ -64,15 +113,22 @@ public void loadAds_shouldReplenishCache() {
         verify(mockMoPubNative).makeRequest(requestParameters, 0);
     }
 
+    @Test
+    public void loadAds_shouldReregisterAdRenderersWithNewMoPubNative() throws Exception {
+        subject.loadAds(mock(RequestParameters.class), mockMoPubNative);
+
+        verify(mockMoPubNative).registerAdRenderer(mockRenderer);
+    }
+
     @Test
     public void loadAds_shouldClearNativeAdSource() {
         subject.setMoPubNative(mockMoPubNative);
-        TimestampWrapper<NativeResponse> timestampWrapper =
-                new TimestampWrapper<NativeResponse>(mock(NativeResponse.class));
+        TimestampWrapper<NativeAd> timestampWrapper =
+                new TimestampWrapper<NativeAd>(mock(NativeAd.class));
         nativeAdCache.add(timestampWrapper);
         subject.mRequestInFlight = true;
         subject.mSequenceNumber = 5;
-        subject.mRetryTimeMilliseconds = maxRetryTime;
+        subject.mCurrentRetries = maxRetries;
 
         subject.loadAds(requestParameters, mockMoPubNative);
 
@@ -81,7 +137,8 @@ public void loadAds_shouldClearNativeAdSource() {
         verify(mockMoPubNative).destroy();
         verify(mockReplenishCacheHandler).removeMessages(0);
         assertThat(subject.mSequenceNumber).isEqualTo(0);
-        assertThat(subject.mRetryTimeMilliseconds).isEqualTo(defaultRetryTime);
+        assertThat(subject.mCurrentRetries).isEqualTo(0);
+        assertThat(subject.getRetryTime()).isEqualTo(defaultRetryTime);
 
         // new request has been kicked off
         assertThat(subject.mRequestInFlight).isTrue();
@@ -99,11 +156,11 @@ public void loadAds_shouldDestroyPreviousMoPubNativeInstance() {
     @Test
     public void clear_shouldDestroyMoPubNative_shouldClearNativeAdCache_shouldRemovePollHandlerMessages_shouldResetSequenceNumber_shouldResetRequestInFlight_shouldResetRetryTime() {
         subject.setMoPubNative(mockMoPubNative);
-        TimestampWrapper<NativeResponse> timestampWrapper = new TimestampWrapper<NativeResponse>(mock(NativeResponse.class));
+        TimestampWrapper<NativeAd> timestampWrapper = new TimestampWrapper<NativeAd>(mock(NativeAd.class));
         nativeAdCache.add(timestampWrapper);
         subject.mRequestInFlight = true;
         subject.mSequenceNumber = 5;
-        subject.mRetryTimeMilliseconds = maxRetryTime;
+        subject.mCurrentRetries = maxRetries;
 
         subject.clear();
 
@@ -113,24 +170,24 @@ public void clear_shouldDestroyMoPubNative_shouldClearNativeAdCache_shouldRemove
         verify(mockReplenishCacheHandler).removeMessages(0);
         assertThat(subject.mRequestInFlight).isFalse();
         assertThat(subject.mSequenceNumber).isEqualTo(0);
-        assertThat(subject.mRetryTimeMilliseconds).isEqualTo(defaultRetryTime);
+        assertThat(subject.getRetryTime()).isEqualTo(defaultRetryTime);
     }
 
     @Test
-    public void dequeueAd_withNonStaleResponse_shouldReturnNativeResponse() {
+    public void dequeueAd_withNonStaleAd_shouldReturnNativeAd() {
         subject.setMoPubNative(mockMoPubNative);
-        nativeAdCache.add(new TimestampWrapper<NativeResponse>(mockNativeResponse));
+        nativeAdCache.add(new TimestampWrapper<NativeAd>(mMockNativeAd));
 
-        assertThat(subject.dequeueAd()).isEqualTo(mockNativeResponse);
+        assertThat(subject.dequeueAd()).isEqualTo(mMockNativeAd);
         assertThat(nativeAdCache).isEmpty();
     }
 
     @Test
-    public void dequeueAd_withStaleResponse_shouldReturnNativeResponse() {
+    public void dequeueAd_withStaleAd_shouldReturnNativeAd() {
         subject.setMoPubNative(mockMoPubNative);
 
-        TimestampWrapper<NativeResponse> timestampWrapper = new TimestampWrapper<NativeResponse>(
-                mockNativeResponse);
+        TimestampWrapper<NativeAd> timestampWrapper = new TimestampWrapper<NativeAd>(
+                mMockNativeAd);
         timestampWrapper.mCreatedTimestamp = SystemClock.uptimeMillis() - (15*60*1000+1);
         nativeAdCache.add(timestampWrapper);
 
@@ -142,9 +199,9 @@ public void dequeueAd_withStaleResponse_shouldReturnNativeResponse() {
     public void dequeueAd_noRequestInFlight_shouldReplenishCache() {
         subject.setMoPubNative(mockMoPubNative);
 
-        nativeAdCache.add(new TimestampWrapper<NativeResponse>(mockNativeResponse));
+        nativeAdCache.add(new TimestampWrapper<NativeAd>(mMockNativeAd));
 
-        assertThat(subject.dequeueAd()).isEqualTo(mockNativeResponse);
+        assertThat(subject.dequeueAd()).isEqualTo(mMockNativeAd);
 
         assertThat(nativeAdCache).isEmpty();
         verify(mockReplenishCacheHandler).post(any(Runnable.class));
@@ -154,10 +211,10 @@ public void dequeueAd_noRequestInFlight_shouldReplenishCache() {
     public void dequeueAd_requestInFlight_shouldNotReplenishCache() {
         subject.setMoPubNative(mockMoPubNative);
 
-        nativeAdCache.add(new TimestampWrapper<NativeResponse>(mockNativeResponse));
+        nativeAdCache.add(new TimestampWrapper<NativeAd>(mMockNativeAd));
 
         subject.mRequestInFlight = true;
-        assertThat(subject.dequeueAd()).isEqualTo(mockNativeResponse);
+        assertThat(subject.dequeueAd()).isEqualTo(mMockNativeAd);
 
         assertThat(nativeAdCache).isEmpty();
         verify(mockReplenishCacheHandler, never()).post(any(Runnable.class));
@@ -166,27 +223,27 @@ public void dequeueAd_requestInFlight_shouldNotReplenishCache() {
     @Test
     public void updateRetryTime_shouldUpdateRetryTimeUntilAt10Minutes() {
         int retryTime = 0;
-        while (subject.mRetryTimeMilliseconds < maxRetryTime) {
+        while (subject.mCurrentRetries < maxRetries) {
             subject.updateRetryTime();
-            retryTime = subject.mRetryTimeMilliseconds;
+            retryTime = subject.getRetryTime();
         }
 
         assertThat(retryTime).isEqualTo(maxRetryTime);
 
         // assert it won't change anymore
         subject.updateRetryTime();
-        assertThat(retryTime).isEqualTo(subject.mRetryTimeMilliseconds);
+        assertThat(retryTime).isEqualTo(subject.getRetryTime());
     }
 
     @Test
     public void resetRetryTime_shouldSetRetryTimeTo1Second() {
-        assertThat(subject.mRetryTimeMilliseconds).isEqualTo(defaultRetryTime);
+        assertThat(subject.getRetryTime()).isEqualTo(defaultRetryTime);
 
         subject.updateRetryTime();
-        assertThat(subject.mRetryTimeMilliseconds).isGreaterThan(defaultRetryTime);
+        assertThat(subject.getRetryTime()).isGreaterThan(defaultRetryTime);
 
         subject.resetRetryTime();
-        assertThat(subject.mRetryTimeMilliseconds).isEqualTo(defaultRetryTime);
+        assertThat(subject.getRetryTime()).isEqualTo(defaultRetryTime);
     }
 
     @Test
@@ -228,10 +285,10 @@ public void replenishCache_withCacheSizeAtLimit_shouldNotLoadNativeAd() {
     @Test
     public void moPubNativeNetworkListener_onNativeLoad_shouldAddToCache() {
         subject.setMoPubNative(mockMoPubNative);
-        subject.getMoPubNativeNetworkListener().onNativeLoad(mockNativeResponse);
+        subject.getMoPubNativeNetworkListener().onNativeLoad(mMockNativeAd);
 
         assertThat(nativeAdCache).hasSize(1);
-        assertThat(nativeAdCache.get(0).mInstance).isEqualTo(mockNativeResponse);
+        assertThat(nativeAdCache.get(0).mInstance).isEqualTo(mMockNativeAd);
     }
 
     @Test
@@ -239,7 +296,7 @@ public void moPubNativeNetworkListener_onNativeLoad_withEmptyCache_shouldCallOnA
         subject.setMoPubNative(mockMoPubNative);
 
         assertThat(nativeAdCache).isEmpty();
-        subject.getMoPubNativeNetworkListener().onNativeLoad(mockNativeResponse);
+        subject.getMoPubNativeNetworkListener().onNativeLoad(mMockNativeAd);
 
         assertThat(nativeAdCache).hasSize(1);
         verify(mockAdSourceListener).onAdsAvailable();
@@ -250,7 +307,7 @@ public void moPubNativeNetworkListener_onNativeLoad_withNonEmptyCache_shouldNotC
         subject.setMoPubNative(mockMoPubNative);
 
         nativeAdCache.add(mock(TimestampWrapper.class));
-        subject.getMoPubNativeNetworkListener().onNativeLoad(mockNativeResponse);
+        subject.getMoPubNativeNetworkListener().onNativeLoad(mMockNativeAd);
 
         assertThat(nativeAdCache).hasSize(2);
         verify(mockAdSourceListener, never()).onAdsAvailable();
@@ -260,12 +317,12 @@ public void moPubNativeNetworkListener_onNativeLoad_withNonEmptyCache_shouldNotC
     public void moPubNativeNetworkListener_onNativeLoad_shouldIncrementSequenceNumber_shouldResetRetryTime() {
         subject.setMoPubNative(mockMoPubNative);
 
-        subject.mRetryTimeMilliseconds = maxRetryTime;
+        subject.mCurrentRetries = maxRetries;
         subject.mSequenceNumber = 5;
 
-        subject.getMoPubNativeNetworkListener().onNativeLoad(mockNativeResponse);
+        subject.getMoPubNativeNetworkListener().onNativeLoad(mMockNativeAd);
 
-        assertThat(subject.mRetryTimeMilliseconds).isEqualTo(defaultRetryTime);
+        assertThat(subject.getRetryTime()).isEqualTo(defaultRetryTime);
         assertThat(subject.mSequenceNumber).isEqualTo(6);
     }
 
@@ -280,48 +337,46 @@ public void moPubNativeNetworkListener_onNativeLoad_withFullCache_shouldResetReq
         nativeAdCache.add(mock(TimestampWrapper.class));
         nativeAdCache.add(mock(TimestampWrapper.class));
 
-        subject.getMoPubNativeNetworkListener().onNativeLoad(mockNativeResponse);
+        subject.getMoPubNativeNetworkListener().onNativeLoad(mMockNativeAd);
 
         assertThat(subject.mRequestInFlight).isEqualTo(false);
     }
 
     @Test
-    public void moPubNativeNetworkListener_onNativeLoad_withNonFullCache_shouldReplenishCache() {
+    public void moPubNativeNetworkListener_onNativeLoad_withCacheFilled_shouldNotReplenishCache() {
         subject.setMoPubNative(mockMoPubNative);
 
         subject.mRequestInFlight = true;
 
-        subject.getMoPubNativeNetworkListener().onNativeLoad(mockNativeResponse);
+        subject.getMoPubNativeNetworkListener().onNativeLoad(mMockNativeAd);
 
-        assertThat(subject.mRequestInFlight).isEqualTo(true);
-        verify(mockMoPubNative).makeRequest(any(RequestParameters.class), eq(1));
+        assertThat(subject.mRequestInFlight).isEqualTo(false);
     }
 
     @Test
     public void
     moPubNativeNetworkListener_onNativeFail_shouldResetInFlight_shouldUpdateRetryTime_shouldPostDelayedRunnable() {
         subject.mRequestInFlight = true;
-        subject.mRetryTimeMilliseconds = defaultRetryTime;
 
         subject.getMoPubNativeNetworkListener().onNativeFail(NativeErrorCode.UNSPECIFIED);
 
         assertThat(subject.mRequestInFlight).isEqualTo(false);
         assertThat(subject.mRetryInFlight).isEqualTo(true);
-        assertThat(subject.mRetryTimeMilliseconds).isGreaterThan(defaultRetryTime);
-        verify(mockReplenishCacheHandler).postDelayed(any(Runnable.class), eq((long)subject.mRetryTimeMilliseconds));
+        assertThat(subject.getRetryTime()).isGreaterThan(defaultRetryTime);
+        verify(mockReplenishCacheHandler).postDelayed(any(Runnable.class), eq((long)subject.getRetryTime()));
     }
 
     @Test
     public void
     moPubNativeNetworkListener_onNativeFail_maxRetryTime_shouldResetInflight_shouldResetRetryTime_shouldNotPostDelayedRunnable() {
         subject.mRequestInFlight = true;
-        subject.mRetryTimeMilliseconds = maxRetryTime;
+        subject.mCurrentRetries = maxRetries;
 
         subject.getMoPubNativeNetworkListener().onNativeFail(NativeErrorCode.UNSPECIFIED);
 
         assertThat(subject.mRequestInFlight).isEqualTo(false);
         assertThat(subject.mRetryInFlight).isEqualTo(false);
-        assertThat(subject.mRetryTimeMilliseconds).isEqualTo(defaultRetryTime);
+        assertThat(subject.getRetryTime()).isEqualTo(defaultRetryTime);
         verify(mockReplenishCacheHandler, never()).postDelayed(any(Runnable.class), anyLong());
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdTest.java
new file mode 100644
index 00000000..bb12a011
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdTest.java
@@ -0,0 +1,204 @@
+package com.mopub.nativeads;
+
+import android.app.Activity;
+import android.view.View;
+import android.view.ViewGroup;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
+import com.mopub.nativeads.BaseNativeAd.NativeEventListener;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+
+import java.util.HashSet;
+import java.util.Set;
+
+import static com.mopub.common.VolleyRequestMatcher.isUrl;
+import static com.mopub.nativeads.NativeAd.MoPubNativeEventListener;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.argThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyZeroInteractions;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class NativeAdTest {
+
+    private NativeAd subject;
+    private Activity activity;
+
+    @Mock private View mockView;
+    @Mock private ViewGroup mockParent;
+    @Mock private MoPubStaticNativeAdRenderer mockRenderer;
+    @Mock private MoPubRequestQueue mockRequestQueue;
+    @Mock private MoPubNativeEventListener mockEventListener;
+    @Mock private BaseNativeAd mockBaseNativeAd;
+
+    @Before
+    public void setUp() {
+        activity = Robolectric.buildActivity(Activity.class).create().get();
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+
+        Set<String> impUrls = new HashSet<String>();
+        impUrls.add("impUrl");
+        when(mockBaseNativeAd.getImpressionTrackers()).thenReturn(impUrls);
+
+        Set<String> clkUrls = new HashSet<String>();
+        clkUrls.add("clkUrl");
+        when(mockBaseNativeAd.getClickTrackers()).thenReturn(clkUrls);
+
+        subject = new NativeAd(activity,
+                "moPubImpressionTrackerUrl",
+                "moPubClickTrackerUrl",
+                "adunit_id",
+                mockBaseNativeAd,
+                mockRenderer
+        );
+        subject.setMoPubNativeEventListener(mockEventListener);
+    }
+
+    @Test
+    public void constructor_shouldSetNativeEventListener() {
+        reset(mockBaseNativeAd);
+        subject = new NativeAd(activity, "moPubImpressionTrackerUrl", "moPubClickTrackerUrl",
+                "adunit_id", mockBaseNativeAd, mockRenderer);
+        verify(mockBaseNativeAd).setNativeEventListener(any(NativeEventListener.class));
+    }
+
+    @Test
+    public void constructor_shouldMergeMoPubClickTrackerWithBaseNativeAdClickTrackers() {
+        reset(mockRequestQueue);
+        subject = new NativeAd(activity, "", "moPubClickTrackerUrl", "", mockBaseNativeAd,
+                mockRenderer);
+
+        subject.handleClick(null);
+
+        verify(mockRequestQueue).add(argThat(isUrl("moPubClickTrackerUrl")));
+        verify(mockRequestQueue).add(argThat(isUrl("clkUrl")));
+    }
+
+    @Test
+    public void getAdUnitId_shouldReturnAdUnitId() {
+        assertThat(subject.getAdUnitId()).isEqualTo("adunit_id");
+    }
+
+    @Test
+    public void isDestroyed_withNativeAdDestroyed_shouldReturnTrue() {
+        assertThat(subject.isDestroyed()).isFalse();
+
+        subject.destroy();
+
+        assertThat(subject.isDestroyed()).isTrue();
+    }
+
+    @Test
+    public void createAdView_shouldCallCreateAdViewOnRenderer() {
+        View newView = mock(View.class);
+        when(mockRenderer.createAdView(activity, mockParent))
+                .thenReturn(newView);
+
+        View view = subject.createAdView(activity, mockParent);
+
+        verify(mockRenderer).createAdView(activity, mockParent);
+        assertThat(view).isEqualTo(newView);
+    }
+
+    @Test
+    public void renderAdView_shouldCallRenderAdViewOnRenderer() {
+        subject.createAdView(activity, mockParent);
+
+        verify(mockRenderer).createAdView(activity, mockParent);
+    }
+
+    @Test
+    public void prepare_shouldCallPrepareOnBaseNativeAd() {
+        subject.prepare(mockView);
+
+        verify(mockBaseNativeAd).prepare(mockView);
+    }
+
+    @Test
+    public void prepare_whenDestroyed_shouldReturnFast() {
+        subject.destroy();
+        subject.prepare(mockView);
+
+        verify(mockBaseNativeAd, never()).prepare(mockView);
+    }
+
+    @Test
+    public void clear_shouldCallClearOnBaseNativeAd() {
+        subject.clear(mockView);
+        verify(mockBaseNativeAd).clear(mockView);
+    }
+
+    @Test
+    public void destroy_shouldCallIntoBaseNativeAdOnce() {
+        subject.destroy();
+        verify(mockBaseNativeAd).destroy();
+
+        reset(mockBaseNativeAd);
+
+        subject.destroy();
+        verifyZeroInteractions(mockBaseNativeAd);
+    }
+
+    @Test
+    public void recordImpression_shouldRecordImpressionsOnce() {
+        subject.recordImpression(mockView);
+        verify(mockRequestQueue).add(argThat(isUrl("moPubImpressionTrackerUrl")));
+        verify(mockRequestQueue).add(argThat(isUrl("impUrl")));
+        verify(mockEventListener).onImpression(mockView);
+
+        // reset state
+        reset(mockRequestQueue);
+
+        // verify impression tracking doesn't fire again
+        subject.recordImpression(mockView);
+        verifyZeroInteractions(mockRequestQueue);
+        verifyZeroInteractions(mockEventListener);
+    }
+
+    @Test
+    public void recordImpression_whenDestroyed_shouldReturnFast() {
+        subject.destroy();
+        subject.recordImpression(mockView);
+        verifyZeroInteractions(mockRequestQueue);
+        verifyZeroInteractions(mockEventListener);
+    }
+
+    @Test
+    public void handleClick_shouldTrackClicksOnce() {
+        subject.handleClick(mockView);
+        verify(mockRequestQueue).add(argThat(isUrl("moPubClickTrackerUrl")));
+        verify(mockRequestQueue).add(argThat(isUrl("clkUrl")));
+        verify(mockEventListener).onClick(mockView);
+
+        // reset state
+        reset(mockRequestQueue);
+
+        // verify click tracking doesn't fire again
+        subject.handleClick(mockView);
+        verifyZeroInteractions(mockRequestQueue);
+        verifyZeroInteractions(mockEventListener);
+    }
+
+    @Test
+    public void handleClick_whenDestroyed_shouldReturnFast() {
+        subject.destroy();
+        subject.handleClick(mockView);
+        verifyZeroInteractions(mockRequestQueue);
+        verifyZeroInteractions(mockEventListener);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdViewHelperTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdViewHelperTest.java
index 2443a4d4..62b74958 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdViewHelperTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdViewHelperTest.java
@@ -3,139 +3,85 @@
 import android.app.Activity;
 import android.view.View;
 import android.view.ViewGroup;
-import android.widget.Button;
-import android.widget.LinearLayout;
-import android.widget.RelativeLayout;
-import android.widget.TextView;
 
 import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.Utils;
+import com.mopub.mobileads.BuildConfig;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class NativeAdViewHelperTest {
-    private Activity context;
-    private RelativeLayout relativeLayout;
-    private ViewGroup viewGroup;
-    private BaseForwardingNativeAd mNativeAd;
-    private ViewBinder viewBinder;
-    private TextView titleView;
-    private TextView textView;
-    private TextView callToActionView;
-
-    @Mock private NativeResponse mockNativeResponse1;
-    @Mock private NativeResponse mockNativeResponse2;
-    @Mock private ImpressionTracker mockImpressionTracker;
+    private Activity activity;
+    @Mock private View mockView;
+    @Mock private ViewGroup mockViewGroup;
+    @Mock private ViewBinder mockViewBinder;
+    @Mock private NativeAd mMockNativeAd1;
+    @Mock private NativeAd mMockNativeAd2;
 
     @Before
     public void setUp() throws Exception {
-        context = Robolectric.buildActivity(Activity.class).create().get();
-        relativeLayout = new RelativeLayout(context);
-        relativeLayout.setId((int) Utils.generateUniqueId());
-        viewGroup = new LinearLayout(context);
-
-        mNativeAd = new BaseForwardingNativeAd() {};
-        mNativeAd.setTitle("test title");
-        mNativeAd.setText("test text");
-        mNativeAd.setCallToAction("test call to action");
-
-        titleView = new TextView(context);
-        titleView.setId((int) Utils.generateUniqueId());
-        textView = new TextView(context);
-        textView.setId((int) Utils.generateUniqueId());
-        callToActionView = new Button(context);
-        callToActionView.setId((int) Utils.generateUniqueId());
-
-        relativeLayout.addView(titleView);
-        relativeLayout.addView(textView);
-        relativeLayout.addView(callToActionView);
-        relativeLayout.setTag(NativeAdViewHelper.ViewType.AD);
-
-        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
-                .titleId(titleView.getId())
-                .textId(textView.getId())
-                .callToActionId(callToActionView.getId())
-                .build();
-
-        when(mockNativeResponse1.isDestroyed()).thenReturn(false);
-        when(mockNativeResponse2.isDestroyed()).thenReturn(false);
+        activity = Robolectric.buildActivity(Activity.class).create().get();
+        when(mMockNativeAd1.createAdView(any(Activity.class), any(ViewGroup.class)))
+                .thenReturn(mockView);
+        when(mMockNativeAd2.createAdView(any(Activity.class), any(ViewGroup.class)))
+                .thenReturn(mockView);
+        when(mMockNativeAd1.isDestroyed()).thenReturn(false);
+        when(mMockNativeAd2.isDestroyed()).thenReturn(false);
     }
 
     @Test
-    public void getAdView_shouldReturnPopulatedView() throws Exception {
-        when(mockNativeResponse1.getTitle()).thenReturn("test title");
-        when(mockNativeResponse1.getText()).thenReturn("test text");
-        when(mockNativeResponse1.getCallToAction()).thenReturn("test call to action");
+    public void getAdView_shouldRenderView() throws Exception {
+        NativeAdViewHelper.getAdView(mockView, mockViewGroup, activity, mMockNativeAd1,
+                mockViewBinder);
 
-        View view = NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse1, viewBinder);
-
-        assertThat(((TextView)view.findViewById(titleView.getId())).getText()).isEqualTo("test title");
-        assertThat(((TextView)view.findViewById(textView.getId())).getText()).isEqualTo("test text");
-        assertThat(((TextView)view.findViewById(callToActionView.getId())).getText()).isEqualTo("test call to action");
-        assertThat(view.getTag()).isEqualTo(NativeAdViewHelper.ViewType.AD);
-
-        // not testing images due to testing complexity
+        verify(mMockNativeAd1).createAdView(activity, mockViewGroup);
+        verify(mMockNativeAd1).renderAdView(mockView);
     }
 
     @Test
-    public void getAdView_withDestroyedNativeResponse_shouldReturnEmptyAndGoneConvertView() throws Exception {
-        when(mockNativeResponse1.isDestroyed()).thenReturn(true);
-        View view = NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse1, viewBinder);
+    public void getAdView_withDestroyedNativeAd_shouldReturnEmptyAndGoneConvertView() throws Exception {
+        when(mMockNativeAd1.isDestroyed()).thenReturn(true);
+
+        View view = NativeAdViewHelper.getAdView(mockView, mockViewGroup, activity, mMockNativeAd1,
+                mockViewBinder);
 
-        assertThat(view).isNotEqualTo(relativeLayout);
+        assertThat(view).isNotEqualTo(mockView);
         assertThat(view.getTag()).isEqualTo(NativeAdViewHelper.ViewType.EMPTY);
         assertThat(view.getVisibility()).isEqualTo(View.GONE);
     }
 
     @Test
-    public void getAdView_shouldRemoveViewFromImpressionTracker_shouldClearPreviousNativeResponse() throws Exception {
-        NativeAdViewHelper.sImpressionTrackerMap.put(context, mockImpressionTracker);
-
-        NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse1, viewBinder);
-        verify(mockImpressionTracker).removeView(relativeLayout);
-
-        // Second call should clear the first NativeResponse
-        NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse2, viewBinder);
-        verify(mockImpressionTracker, times(2)).removeView(relativeLayout);
-        verify(mockNativeResponse1).clear(relativeLayout);
-
-        // Third call should clear the second NativeResponse
-        NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse1, viewBinder);
-        verify(mockImpressionTracker, times(3)).removeView(relativeLayout);
-        verify(mockNativeResponse2).clear(relativeLayout);
-    }
-
-    @Test
-    public void getAdView_withNetworkImpressionTracker_shouldNotAddViewToImpressionTracker_shouldPrepareNativeResponse() throws Exception {
-        NativeAdViewHelper.sImpressionTrackerMap.put(context, mockImpressionTracker);
-        when(mockNativeResponse1.isOverridingImpressionTracker()).thenReturn(true);
-
-        NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse1, viewBinder);
-
-        verify(mockImpressionTracker, never()).addView(any(View.class), any(NativeResponse.class));
-        verify(mockNativeResponse1).prepare(relativeLayout);
+    public void getAdView_shouldClearPreviousNativeAd() throws Exception {
+        NativeAdViewHelper.getAdView(mockView, mockViewGroup, activity, mMockNativeAd1,
+                mockViewBinder);
+
+        // Second call should clear the first NativeAd
+        NativeAdViewHelper.getAdView(mockView, mockViewGroup, activity, mMockNativeAd2,
+                mockViewBinder);
+        verify(mMockNativeAd1).clear(mockView);
+
+        // Third call should clear the second NativeAd
+        NativeAdViewHelper.getAdView(mockView, mockViewGroup, activity, mMockNativeAd1,
+                mockViewBinder);
+        verify(mMockNativeAd2).clear(mockView);
     }
 
     @Test
-    public void getAdView_withoutNetworkImpressionTracker_shouldAddViewToImpressionTracker_shouldPrepareNativeResponse() throws Exception {
-        NativeAdViewHelper.sImpressionTrackerMap.put(context, mockImpressionTracker);
-        when(mockNativeResponse1.isOverridingImpressionTracker()).thenReturn(false);
-
-        NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse1, viewBinder);
+    public void getAdView_shouldPrepareNativeAd() throws Exception {
+        NativeAdViewHelper.getAdView(mockView, mockViewGroup, activity, mMockNativeAd1,
+                mockViewBinder);
 
-        verify(mockImpressionTracker).addView(relativeLayout, mockNativeResponse1);
-        verify(mockNativeResponse1).prepare(relativeLayout);
+        verify(mMockNativeAd1).prepare(mockView);
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeClickHandlerTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeClickHandlerTest.java
new file mode 100644
index 00000000..6e0f201e
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeClickHandlerTest.java
@@ -0,0 +1,139 @@
+package com.mopub.nativeads;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.os.Build;
+import android.view.View;
+import android.widget.RelativeLayout;
+import android.widget.TextView;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.Utils;
+import com.mopub.mobileads.BuildConfig;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowApplication;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class NativeClickHandlerTest {
+
+    private NativeClickHandler subject;
+    private Activity context;
+
+    private TextView titleView;
+    private RelativeLayout relativeLayout;
+    private RelativeLayout relativeLayout2;
+
+    @Mock private View mockView;
+    @Mock private ClickInterface mockClickInterface;
+    @Mock private SpinningProgressView mockSpinningProgressView;
+
+    @Before
+    public void setUp() {
+        context = Robolectric.buildActivity(Activity.class).create().get();
+        subject = new NativeClickHandler(context);
+
+        titleView = new TextView(context);
+        titleView.setId((int) Utils.generateUniqueId());
+
+        relativeLayout = new RelativeLayout(context);
+        relativeLayout.setId((int) Utils.generateUniqueId());
+        relativeLayout.addView(titleView);
+
+        relativeLayout2 = new RelativeLayout(context);
+        relativeLayout2.setId((int) Utils.generateUniqueId());
+        relativeLayout2.addView(relativeLayout);
+    }
+
+    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1)
+    @Test
+    public void setOnClickListener_shouldSetClickListenerOnViewHierarchy() {
+        subject.setOnClickListener(relativeLayout2, mockClickInterface);
+
+        titleView.callOnClick();
+        relativeLayout.callOnClick();
+        relativeLayout2.callOnClick();
+
+        verify(mockClickInterface).handleClick(titleView);
+        verify(mockClickInterface).handleClick(relativeLayout);
+        verify(mockClickInterface).handleClick(relativeLayout2);
+    }
+
+    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1)
+    @Test
+    public void clearOnClickListener_shouldClearClickListenerFromViewHierarchy() throws Exception {
+        subject.setOnClickListener(relativeLayout2, mockClickInterface);
+        subject.clearOnClickListener(relativeLayout2);
+
+        assertThat(titleView.hasOnClickListeners()).isFalse();
+        assertThat(relativeLayout.hasOnClickListeners()).isFalse();
+        assertThat(relativeLayout2.hasOnClickListeners()).isFalse();
+    }
+
+    @Test
+    public void handleClick_shouldShowSpinner_shouldRemoveSpinner_WhenSucceeded() {
+        Robolectric.getBackgroundThreadScheduler().pause();
+
+        subject.openClickDestinationUrl("http://www.mopub.com", mockView, mockSpinningProgressView);
+
+        verify(mockSpinningProgressView).addToRoot(mockView);
+
+        Robolectric.getBackgroundThreadScheduler().unPause();
+        verify(mockSpinningProgressView).removeFromRoot();
+    }
+
+    @Test
+    public void handleClick_shouldShowSpinner_shouldRemoveSpinner_WhenFailed() {
+        Robolectric.getBackgroundThreadScheduler().pause();
+
+        subject.openClickDestinationUrl("", mockView, mockSpinningProgressView);
+
+        verify(mockSpinningProgressView).addToRoot(mockView);
+        Robolectric.getBackgroundThreadScheduler().unPause();
+        verify(mockSpinningProgressView).removeFromRoot();
+    }
+
+    @Test
+    public void handleClick_shouldShowSpinnerOnceWhileClickIsResolving() {
+        Robolectric.getBackgroundThreadScheduler().pause();
+
+        subject.openClickDestinationUrl("http://www.mopub.com", mockView, mockSpinningProgressView);
+        subject.openClickDestinationUrl("http://www.mopub.com", mockView, mockSpinningProgressView);
+
+        // only is called once
+        verify(mockSpinningProgressView).addToRoot(mockView);
+
+        Robolectric.getBackgroundThreadScheduler().unPause();
+        verify(mockSpinningProgressView).removeFromRoot();
+    }
+
+    @Test
+    public void handleClick_withNullClickDestinationUrl_shouldNotThrowNPE_shouldDoNothing() throws Exception {
+        subject.openClickDestinationUrl(null, mockView, mockSpinningProgressView);
+
+        verifyNoMoreInteractions(mockSpinningProgressView);
+        assertThat(ShadowApplication.getInstance().peekNextStartedActivity()).isNull();
+    }
+
+    @Test
+    public void handleClick_withNullView_shouldNotShowSpinner() {
+        Robolectric.getBackgroundThreadScheduler().pause();
+
+        subject.openClickDestinationUrl("http://www.mopub.com", null, mockSpinningProgressView);
+
+        verify(mockSpinningProgressView, never()).addToRoot(mockView);
+        Robolectric.getBackgroundThreadScheduler().unPause();
+        verify(mockSpinningProgressView, never()).removeFromRoot();
+    }
+}
\ No newline at end of file
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeFullScreenVideoViewTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeFullScreenVideoViewTest.java
new file mode 100644
index 00000000..bb40db82
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeFullScreenVideoViewTest.java
@@ -0,0 +1,503 @@
+package com.mopub.nativeads;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.content.Context;
+import android.content.res.Configuration;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.RectF;
+import android.graphics.SurfaceTexture;
+import android.graphics.drawable.GradientDrawable;
+import android.os.Build;
+import android.view.TextureView;
+import android.view.View;
+import android.widget.ImageView;
+import android.widget.ProgressBar;
+import android.widget.RelativeLayout;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.Dips;
+import com.mopub.common.util.Drawables;
+import com.mopub.mobileads.BuildConfig;
+import com.mopub.mobileads.VastVideoProgressBarWidget;
+import com.mopub.mobileads.resource.CloseButtonDrawable;
+import com.mopub.mobileads.resource.CtaButtonDrawable;
+import com.mopub.nativeads.NativeFullScreenVideoView.LoadingBackground;
+import com.mopub.nativeads.NativeFullScreenVideoView.Mode;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+import org.robolectric.Shadows;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowConfiguration;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class NativeFullScreenVideoViewTest {
+
+    private NativeFullScreenVideoView subject;
+    private Context context;
+
+    private final int screenWidthDp = 410;
+    private final int screenHeightDp = 730;
+    private int videoWidthLandscapePx;
+    private int videoHeightLandscapePx;
+    private int videoWidthPortraitPx;
+    private int videoHeightPortraitPx;
+
+    private TextureView spyVideoTexture;
+    private ImageView spyCachedImage;
+    private ProgressBar spyLoadingSpinner;
+    private ImageView spyBottomGradient;
+    private ImageView spyTopGradient;
+    private VastVideoProgressBarWidget spyVideoProgress;
+    private View spyOverlay;
+    private ImageView spyPlayButton;
+    private ImageView spyPrivacyInformationIcon;
+    private ImageView spyCtaButton;
+    private ImageView spyCloseControl;
+
+    @Mock TextureView.SurfaceTextureListener mockSurfaceTextureListener;
+    @Mock SurfaceTexture mockSurfaceTexture;
+    @Mock RectF mockRectF;
+    @Mock Paint mockPaint;
+    private ShadowConfiguration shadowConfiguration;
+
+    @Before
+    public void setUp() {
+        context = Robolectric.buildActivity(Activity.class).create().get();
+
+        shadowConfiguration = Shadows.shadowOf(context.getResources().getConfiguration());
+        Configuration configuration = new Configuration();
+        configuration.screenWidthDp = screenWidthDp;
+        configuration.screenHeightDp = screenHeightDp;
+        shadowConfiguration.setTo(configuration);
+
+        videoWidthLandscapePx = Dips.dipsToIntPixels((float) screenWidthDp, context);
+        videoHeightLandscapePx = Dips.dipsToIntPixels((float) screenWidthDp * 9 / 16, context);
+        videoWidthPortraitPx = Dips.dipsToIntPixels((float) screenHeightDp, context);
+        videoHeightPortraitPx = Dips.dipsToIntPixels((float) screenHeightDp * 9 / 16, context);
+
+        spyCachedImage = spy(new ImageView(context));
+        spyVideoTexture = spy(new TextureView(context));
+        spyLoadingSpinner = spy(new ProgressBar(context));
+        spyBottomGradient = spy(new ImageView(context));
+        spyTopGradient = spy(new ImageView(context));
+        spyVideoProgress = spy(new VastVideoProgressBarWidget(context));
+        spyOverlay = spy(new View(context));
+        spyPlayButton = spy(new ImageView(context));
+        spyPrivacyInformationIcon = spy(new ImageView(context));
+        spyCtaButton = spy(new ImageView(context));
+        spyCloseControl = spy(new ImageView(context));
+
+        subject = new NativeFullScreenVideoView(context, Configuration.ORIENTATION_LANDSCAPE, "Learn More",
+                spyCachedImage,
+                spyVideoTexture, spyLoadingSpinner, spyBottomGradient, spyTopGradient,
+                spyVideoProgress, spyOverlay, spyPlayButton, spyPrivacyInformationIcon, spyCtaButton,
+                spyCloseControl);
+
+    }
+
+    @Test
+    public void constructor_shouldInitializeModeToLoading() throws Exception {
+        assertThat(subject.mMode).isEqualTo(Mode.LOADING);
+    }
+
+    @Test
+    public void constructor_shouldSetMeasurementsCorrectly() throws Exception {
+        assertThat(subject.mCtaWidthPx).isEqualTo(200);
+        assertThat(subject.mCtaHeightPx).isEqualTo(42);
+        assertThat(subject.mCtaMarginPx).isEqualTo(10);
+        assertThat(subject.mCloseControlSizePx).isEqualTo(50);
+        assertThat(subject.mClosePaddingPx).isEqualTo(8);
+        assertThat(subject.mPrivacyInformationIconSizePx).isEqualTo(44);
+        assertThat(subject.mPlayControlSizePx).isEqualTo(50);
+        assertThat(subject.mGradientStripHeightPx).isEqualTo(45);
+    }
+
+    @Test
+    public void constructor_shouldAddVideoTextureToLayout_shouldSetWidthAndHeight() throws Exception {
+        assertThat(subject.findViewById(spyVideoTexture.getId())).isEqualTo(spyVideoTexture);
+
+        RelativeLayout.LayoutParams layoutParams =
+                (RelativeLayout.LayoutParams) spyVideoTexture.getLayoutParams();
+        assertThat(layoutParams.width).isEqualTo(videoWidthLandscapePx);
+        assertThat(layoutParams.height).isEqualTo(videoHeightLandscapePx);
+        assertThat(layoutParams.getRules()[RelativeLayout.CENTER_IN_PARENT])
+                .isEqualTo(RelativeLayout.TRUE);
+    }
+
+    @Test
+    public void constructor_shouldAddLoadingSpinnerToLayout() throws Exception {
+        assertThat(subject.findViewById(spyLoadingSpinner.getId())).isEqualTo(spyLoadingSpinner);
+        assertThat(spyLoadingSpinner.isIndeterminate()).isTrue();
+        assertThat(spyLoadingSpinner.getParent()).isEqualTo(subject);
+
+        RelativeLayout.LayoutParams layoutParams =
+                (RelativeLayout.LayoutParams) spyLoadingSpinner.getLayoutParams();
+        assertThat(layoutParams.width).isEqualTo(subject.mPlayControlSizePx);
+        assertThat(layoutParams.height).isEqualTo(subject.mPlayControlSizePx);
+        assertThat(layoutParams.getRules()[RelativeLayout.CENTER_IN_PARENT])
+                .isEqualTo(RelativeLayout.TRUE);
+    }
+
+    @Test
+    public void constructor_shouldAddBottomGradientToLayout() throws Exception {
+        assertThat(subject.findViewById(spyBottomGradient.getId())).isEqualTo(spyBottomGradient);
+        GradientDrawable gradientDrawable = (GradientDrawable) spyBottomGradient.getDrawable();
+        assertThat(gradientDrawable.getOrientation())
+                .isEqualTo(GradientDrawable.Orientation.BOTTOM_TOP);
+        assertThat(spyBottomGradient.getParent()).isEqualTo(subject);
+
+        RelativeLayout.LayoutParams layoutParams =
+                (RelativeLayout.LayoutParams) spyBottomGradient.getLayoutParams();
+        assertThat(layoutParams.width).isEqualTo(RelativeLayout.LayoutParams.MATCH_PARENT);
+        assertThat(layoutParams.height).isEqualTo(subject.mGradientStripHeightPx);
+        assertThat(layoutParams.getRules()[RelativeLayout.ALIGN_BOTTOM])
+                .isEqualTo(spyVideoTexture.getId());
+    }
+
+    @Test
+    public void constructor_shouldAddTopGradientToLayout() throws Exception {
+        assertThat(subject.findViewById(spyTopGradient.getId())).isEqualTo(spyTopGradient);
+        GradientDrawable gradientDrawable = (GradientDrawable) spyTopGradient.getDrawable();
+        assertThat(gradientDrawable.getOrientation())
+                .isEqualTo(GradientDrawable.Orientation.TOP_BOTTOM);
+        assertThat(spyTopGradient.getParent()).isEqualTo(subject);
+
+        RelativeLayout.LayoutParams layoutParams =
+                (RelativeLayout.LayoutParams) spyTopGradient.getLayoutParams();
+        assertThat(layoutParams.width).isEqualTo(RelativeLayout.LayoutParams.MATCH_PARENT);
+        assertThat(layoutParams.height).isEqualTo(subject.mGradientStripHeightPx);
+        assertThat(layoutParams.getRules()[RelativeLayout.ALIGN_PARENT_TOP])
+                .isEqualTo(RelativeLayout.TRUE);
+    }
+
+    @Test
+    public void constructor_shouldAddVideoProgressToLayout() throws Exception {
+        assertThat(subject.findViewById(spyVideoProgress.getId())).isEqualTo(spyVideoProgress);
+        verify(spyVideoProgress).setAnchorId(spyVideoTexture.getId());
+        verify(spyVideoProgress).calibrateAndMakeVisible(1000, 0);
+    }
+
+    @Test
+    public void constructor_shouldAddOverlayToLayout() throws Exception {
+        assertThat(subject.findViewById(spyOverlay.getId())).isEqualTo(spyOverlay);
+        verify(spyOverlay).setBackgroundColor(0x88000000);
+
+        RelativeLayout.LayoutParams layoutParams =
+                (RelativeLayout.LayoutParams) spyOverlay.getLayoutParams();
+        assertThat(layoutParams.width).isEqualTo(RelativeLayout.LayoutParams.MATCH_PARENT);
+        assertThat(layoutParams.height).isEqualTo(RelativeLayout.LayoutParams.MATCH_PARENT);
+        assertThat(layoutParams.getRules()[RelativeLayout.CENTER_IN_PARENT])
+                .isEqualTo(RelativeLayout.TRUE);
+    }
+
+    @Test
+    public void constructor_shouldAddPlayButtonToLayout() throws Exception {
+        assertThat(subject.findViewById(spyOverlay.getId())).isEqualTo(spyOverlay);
+        verify(spyOverlay).setBackgroundColor(0x88000000);
+
+        RelativeLayout.LayoutParams layoutParams =
+                (RelativeLayout.LayoutParams) spyOverlay.getLayoutParams();
+        assertThat(layoutParams.width).isEqualTo(RelativeLayout.LayoutParams.MATCH_PARENT);
+        assertThat(layoutParams.height).isEqualTo(RelativeLayout.LayoutParams.MATCH_PARENT);
+        assertThat(layoutParams.getRules()[RelativeLayout.CENTER_IN_PARENT])
+                .isEqualTo(RelativeLayout.TRUE);
+    }
+
+    @Test
+    public void constructor_shouldAddPrivacyInformationIconToLayout() throws Exception {
+        assertThat(subject.findViewById(spyPrivacyInformationIcon.getId())).isEqualTo(
+                spyPrivacyInformationIcon);
+        verify(spyPrivacyInformationIcon).setImageDrawable(
+                Drawables.NATIVE_PRIVACY_INFORMATION_ICON.createDrawable(context));
+        assertThat(spyPrivacyInformationIcon.getPaddingLeft()).isEqualTo(subject.mClosePaddingPx);
+        assertThat(spyPrivacyInformationIcon.getPaddingTop()).isEqualTo(subject.mClosePaddingPx);
+        assertThat(spyPrivacyInformationIcon.getPaddingRight()).isEqualTo(
+                subject.mClosePaddingPx * 2);
+        assertThat(spyPrivacyInformationIcon.getPaddingBottom()).isEqualTo(
+                subject.mClosePaddingPx * 2);
+
+        RelativeLayout.LayoutParams layoutParams =
+                (RelativeLayout.LayoutParams) spyPrivacyInformationIcon.getLayoutParams();
+        assertThat(layoutParams.width).isEqualTo(subject.mPrivacyInformationIconSizePx);
+        assertThat(layoutParams.height).isEqualTo(subject.mPrivacyInformationIconSizePx);
+        assertThat(layoutParams.getRules()[RelativeLayout.ALIGN_TOP])
+                .isEqualTo(spyVideoTexture.getId());
+        assertThat(layoutParams.getRules()[RelativeLayout.ALIGN_LEFT])
+                .isEqualTo(spyVideoTexture.getId());
+    }
+
+    @Test
+    public void constructor_shouldAddCtaButtonToLayout() throws Exception {
+        assertThat(subject.findViewById(spyCtaButton.getId())).isEqualTo(spyCtaButton);
+        CtaButtonDrawable ctaButtonDrawable = (CtaButtonDrawable) spyCtaButton.getDrawable();
+        assertThat(ctaButtonDrawable.getCtaText()).isEqualTo("Learn More");
+
+        RelativeLayout.LayoutParams layoutParams =
+                (RelativeLayout.LayoutParams) spyCtaButton.getLayoutParams();
+        assertThat(layoutParams.leftMargin).isEqualTo(subject.mCtaMarginPx);
+        assertThat(layoutParams.topMargin).isEqualTo(subject.mCtaMarginPx);
+        assertThat(layoutParams.rightMargin).isEqualTo(subject.mCtaMarginPx);
+        assertThat(layoutParams.bottomMargin).isEqualTo(subject.mCtaMarginPx);
+        assertThat(layoutParams.width).isEqualTo(subject.mCtaWidthPx);
+        assertThat(layoutParams.height).isEqualTo(subject.mCtaHeightPx);
+        assertThat(layoutParams.getRules()[RelativeLayout.ABOVE])
+                .isEqualTo(spyVideoProgress.getId());
+        assertThat(layoutParams.getRules()[RelativeLayout.ALIGN_PARENT_RIGHT])
+                .isEqualTo(RelativeLayout.TRUE);
+    }
+
+    @Test
+    public void constructor_shouldAddCloseControlToLayout() throws Exception {
+        assertThat(subject.findViewById(spyCloseControl.getId())).isEqualTo(spyCloseControl);
+        verify(spyCloseControl).setImageDrawable(any(CloseButtonDrawable.class));
+        assertThat(spyCloseControl.getPaddingLeft()).isEqualTo(subject.mClosePaddingPx * 3);
+        assertThat(spyCloseControl.getPaddingTop()).isEqualTo(subject.mClosePaddingPx);
+        assertThat(spyCloseControl.getPaddingRight()).isEqualTo(subject.mClosePaddingPx);
+        assertThat(spyCloseControl.getPaddingBottom()).isEqualTo(subject.mClosePaddingPx * 3);
+
+                RelativeLayout.LayoutParams layoutParams =
+                        (RelativeLayout.LayoutParams) spyCloseControl.getLayoutParams();
+        assertThat(layoutParams.width).isEqualTo(subject.mCloseControlSizePx);
+        assertThat(layoutParams.height).isEqualTo(subject.mCloseControlSizePx);
+        assertThat(layoutParams.getRules()[RelativeLayout.ALIGN_TOP])
+                .isEqualTo(spyVideoTexture.getId());
+        assertThat(layoutParams.getRules()[RelativeLayout.ALIGN_RIGHT])
+                .isEqualTo(spyVideoTexture.getId());
+    }
+
+    @Test
+    public void resetProgress_shouldCallVideoProgressReset() throws Exception {
+        subject.resetProgress();
+        verify(spyVideoProgress).reset();
+    }
+
+    @Test
+    public void setMode_withModeLoading_shouldUpdateVisibilityAppropriately() throws Exception {
+        // We init in loading state, so we need to get out of loading.
+        subject.setMode(Mode.PAUSED);
+        // Reset our spies.
+        reset(spyVideoTexture, spyLoadingSpinner, spyBottomGradient, spyTopGradient,
+                spyVideoProgress, spyOverlay, spyPlayButton, spyPrivacyInformationIcon, spyCtaButton,
+                spyCloseControl);
+        subject.setMode(Mode.LOADING);
+        verify(spyLoadingSpinner).setVisibility(View.VISIBLE);
+        verify(spyVideoProgress).setVisibility(View.INVISIBLE);
+        verify(spyPlayButton).setVisibility(View.INVISIBLE);
+        verify(spyOverlay).setVisibility(View.INVISIBLE);
+    }
+
+    @Test
+    public void setMode_withModePlaying_shouldUpdateVisibilityAppropriately() throws Exception {
+        // Reset our spies because the constructor calls updateViewState
+        reset(spyVideoTexture, spyLoadingSpinner, spyBottomGradient, spyTopGradient,
+                spyVideoProgress, spyOverlay, spyPlayButton, spyPrivacyInformationIcon, spyCtaButton,
+                spyCloseControl);
+        subject.setMode(Mode.PLAYING);
+        verify(spyLoadingSpinner).setVisibility(View.INVISIBLE);
+        verify(spyVideoProgress).setVisibility(View.VISIBLE);
+        verify(spyPlayButton).setVisibility(View.INVISIBLE);
+        verify(spyOverlay).setVisibility(View.INVISIBLE);
+    }
+
+    @Test
+    public void setMode_withModePaused_shouldUpdateVisibilityAppropriately() throws Exception {
+        // Reset our spies because the constructor calls updateViewState
+        reset(spyVideoTexture, spyLoadingSpinner, spyBottomGradient, spyTopGradient,
+                spyVideoProgress, spyOverlay, spyPlayButton, spyPrivacyInformationIcon, spyCtaButton,
+                spyCloseControl);
+        subject.setMode(Mode.PAUSED);
+        verify(spyLoadingSpinner).setVisibility(View.INVISIBLE);
+        verify(spyVideoProgress).setVisibility(View.VISIBLE);
+        verify(spyPlayButton).setVisibility(View.VISIBLE);
+        verify(spyOverlay).setVisibility(View.VISIBLE);
+    }
+
+    @Test
+    public void setMode_withModeFinished_shouldUpdateVisibilityAppropriately() throws Exception {
+        // Reset our spies because the constructor calls updateViewState
+        reset(spyVideoTexture, spyLoadingSpinner, spyBottomGradient, spyTopGradient,
+                spyVideoProgress, spyOverlay, spyPlayButton, spyPrivacyInformationIcon, spyCtaButton,
+                spyCloseControl);
+        subject.setMode(Mode.FINISHED);
+        verify(spyLoadingSpinner).setVisibility(View.INVISIBLE);
+        verify(spyVideoProgress).setVisibility(View.INVISIBLE);
+        verify(spyPlayButton).setVisibility(View.VISIBLE);
+        verify(spyOverlay).setVisibility(View.VISIBLE);
+    }
+
+    @Test
+    public void setOrientation_withLandscape_shouldSetWidthAndHeightOfVideoTextureAppropriately() throws Exception {
+        Configuration configuration = new Configuration();
+        configuration.screenWidthDp = screenWidthDp;
+        configuration.screenHeightDp = screenHeightDp;
+        shadowConfiguration.setTo(configuration);
+
+        subject.setOrientation(Configuration.ORIENTATION_LANDSCAPE);
+
+        RelativeLayout.LayoutParams layoutParams =
+                (RelativeLayout.LayoutParams) spyVideoTexture.getLayoutParams();
+        assertThat(layoutParams.width).isEqualTo(videoWidthLandscapePx);
+        assertThat(layoutParams.height).isEqualTo(videoHeightLandscapePx);
+        assertThat(layoutParams.getRules()[RelativeLayout.CENTER_IN_PARENT])
+                .isEqualTo(RelativeLayout.TRUE);
+    }
+
+    @Test
+    public void setOrientation_withPortrait_shouldSetWidthAndHeightOfVideoTextureAppropriately() throws Exception {
+        Configuration configuration = new Configuration();
+        configuration.screenWidthDp = screenHeightDp;
+        configuration.screenHeightDp = screenWidthDp;
+        shadowConfiguration.setTo(configuration);
+
+        subject.setOrientation(Configuration.ORIENTATION_PORTRAIT);
+
+        RelativeLayout.LayoutParams layoutParams =
+                (RelativeLayout.LayoutParams) spyVideoTexture.getLayoutParams();
+        assertThat(layoutParams.width).isEqualTo(videoWidthPortraitPx);
+        assertThat(layoutParams.height).isEqualTo(videoHeightPortraitPx);
+        assertThat(layoutParams.getRules()[RelativeLayout.CENTER_IN_PARENT])
+                .isEqualTo(RelativeLayout.TRUE);
+    }
+
+    @Test
+    public void setOrientation_withLandscape_shouldSetControlLayoutsAppropriately() throws Exception {
+        subject.setOrientation(Configuration.ORIENTATION_LANDSCAPE);
+
+        RelativeLayout.LayoutParams layoutParams =
+                (RelativeLayout.LayoutParams) spyPrivacyInformationIcon.getLayoutParams();
+        assertThat(layoutParams.width).isEqualTo(subject.mPrivacyInformationIconSizePx);
+        assertThat(layoutParams.height).isEqualTo(subject.mPrivacyInformationIconSizePx);
+        assertThat(layoutParams.getRules()[RelativeLayout.ALIGN_TOP])
+                .isEqualTo(spyVideoTexture.getId());
+        assertThat(layoutParams.getRules()[RelativeLayout.ALIGN_LEFT])
+                .isEqualTo(spyVideoTexture.getId());
+
+        assertThat(subject.findViewById(spyCtaButton.getId())).isEqualTo(spyCtaButton);
+        CtaButtonDrawable ctaButtonDrawable = (CtaButtonDrawable) spyCtaButton.getDrawable();
+        assertThat(ctaButtonDrawable.getCtaText()).isEqualTo("Learn More");
+
+        layoutParams = (RelativeLayout.LayoutParams) spyCtaButton.getLayoutParams();
+        assertThat(layoutParams.leftMargin).isEqualTo(subject.mCtaMarginPx);
+        assertThat(layoutParams.topMargin).isEqualTo(subject.mCtaMarginPx);
+        assertThat(layoutParams.rightMargin).isEqualTo(subject.mCtaMarginPx);
+        assertThat(layoutParams.bottomMargin).isEqualTo(subject.mCtaMarginPx);
+        assertThat(layoutParams.width).isEqualTo(subject.mCtaWidthPx);
+        assertThat(layoutParams.height).isEqualTo(subject.mCtaHeightPx);
+        assertThat(layoutParams.getRules()[RelativeLayout.ABOVE])
+                .isEqualTo(spyVideoProgress.getId());
+        assertThat(layoutParams.getRules()[RelativeLayout.ALIGN_PARENT_RIGHT])
+                .isEqualTo(RelativeLayout.TRUE);
+
+        layoutParams = (RelativeLayout.LayoutParams) spyCloseControl.getLayoutParams();
+        assertThat(layoutParams.width).isEqualTo(subject.mCloseControlSizePx);
+        assertThat(layoutParams.height).isEqualTo(subject.mCloseControlSizePx);
+        assertThat(layoutParams.getRules()[RelativeLayout.ALIGN_TOP])
+                .isEqualTo(spyVideoTexture.getId());
+        assertThat(layoutParams.getRules()[RelativeLayout.ALIGN_RIGHT])
+                .isEqualTo(spyVideoTexture.getId());
+    }
+
+    @Test
+    public void setOrientation_withPortrait_shouldSetControlLayoutsAppropriately() throws Exception {
+        subject.setOrientation(Configuration.ORIENTATION_PORTRAIT);
+
+        RelativeLayout.LayoutParams layoutParams =
+                (RelativeLayout.LayoutParams) spyPrivacyInformationIcon.getLayoutParams();
+        assertThat(layoutParams.width).isEqualTo(subject.mPrivacyInformationIconSizePx);
+        assertThat(layoutParams.height).isEqualTo(subject.mPrivacyInformationIconSizePx);
+        assertThat(layoutParams.getRules()[RelativeLayout.ALIGN_PARENT_TOP])
+                .isEqualTo(RelativeLayout.TRUE);
+        assertThat(layoutParams.getRules()[RelativeLayout.ALIGN_PARENT_LEFT])
+                .isEqualTo(RelativeLayout.TRUE);
+
+        layoutParams = (RelativeLayout.LayoutParams) spyCtaButton.getLayoutParams();
+        assertThat(layoutParams.leftMargin).isEqualTo(subject.mCtaMarginPx);
+        assertThat(layoutParams.topMargin).isEqualTo(subject.mCtaMarginPx);
+        assertThat(layoutParams.rightMargin).isEqualTo(subject.mCtaMarginPx);
+        assertThat(layoutParams.bottomMargin).isEqualTo(subject.mCtaMarginPx);
+        assertThat(layoutParams.width).isEqualTo(subject.mCtaWidthPx);
+        assertThat(layoutParams.height).isEqualTo(subject.mCtaHeightPx);
+        assertThat(layoutParams.getRules()[RelativeLayout.BELOW])
+                .isEqualTo(spyVideoTexture.getId());
+        assertThat(layoutParams.getRules()[RelativeLayout.CENTER_HORIZONTAL])
+                .isEqualTo(RelativeLayout.TRUE);
+
+        layoutParams = (RelativeLayout.LayoutParams) spyCloseControl.getLayoutParams();
+        assertThat(layoutParams.width).isEqualTo(subject.mCloseControlSizePx);
+        assertThat(layoutParams.height).isEqualTo(subject.mCloseControlSizePx);
+        assertThat(layoutParams.getRules()[RelativeLayout.ALIGN_PARENT_TOP])
+                .isEqualTo(RelativeLayout.TRUE);
+        assertThat(layoutParams.getRules()[RelativeLayout.ALIGN_PARENT_RIGHT])
+                .isEqualTo(RelativeLayout.TRUE);
+    }
+
+    @Test
+    public void setSurfaceTextureListener_withNullSurfaceTexture_shouldSetSurfaceTexture_shouldNotCallListener() throws Exception {
+        when(spyVideoTexture.getSurfaceTexture()).thenReturn(null);
+
+        subject.setSurfaceTextureListener(mockSurfaceTextureListener);
+
+        verify(spyVideoTexture).setSurfaceTextureListener(mockSurfaceTextureListener);
+        verify(mockSurfaceTextureListener, never()).
+                onSurfaceTextureAvailable(any(SurfaceTexture.class), anyInt(), anyInt());
+    }
+
+    @Test
+    public void setSurfaceTextureListener_withNonNullSurfaceTexture_shouldSetSurfaceTexture_shouldCallListener() throws Exception {
+        when(spyVideoTexture.getSurfaceTexture()).thenReturn(mockSurfaceTexture);
+        when(spyVideoTexture.getWidth()).thenReturn(videoWidthLandscapePx);
+        when(spyVideoTexture.getHeight()).thenReturn(videoHeightLandscapePx);
+
+        subject.setSurfaceTextureListener(mockSurfaceTextureListener);
+
+        verify(spyVideoTexture).setSurfaceTextureListener(mockSurfaceTextureListener);
+        verify(mockSurfaceTextureListener).
+                onSurfaceTextureAvailable(mockSurfaceTexture, videoWidthLandscapePx,
+                        videoHeightLandscapePx);
+    }
+
+    @Test
+    public void updateProgress_shouldUpdateVideoProgress() throws Exception {
+        subject.updateProgress(100);
+        verify(spyVideoProgress).updateProgress(100);
+    }
+
+    @Test
+    public void LoadingBackground_constructor_shouldInitializePaint() throws Exception {
+        new LoadingBackground(context, mockRectF, mockPaint);
+
+        verify(mockPaint).setColor(Color.BLACK);
+        verify(mockPaint).setAlpha(128);
+        verify(mockPaint).setAntiAlias(true);
+    }
+
+    @Test
+    public void LoadingBackground_constructor_shouldInitializeMeasurements() throws Exception {
+        LoadingBackground loadingBackground = new LoadingBackground(context, mockRectF, mockPaint);
+
+        assertThat(loadingBackground.mCornerRadiusPx).isEqualTo(5);
+    }
+
+    @Test
+    public void LoadingBackground_getOpacity_shouldReturn0() throws Exception {
+        assertThat(new LoadingBackground(context, mockRectF, mockPaint).getOpacity())
+                .isEqualTo(0);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeResponseTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeResponseTest.java
deleted file mode 100644
index 0bbde894..00000000
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeResponseTest.java
+++ /dev/null
@@ -1,376 +0,0 @@
-package com.mopub.nativeads;
-
-import android.app.Activity;
-import android.support.annotation.NonNull;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.Button;
-import android.widget.LinearLayout;
-import android.widget.RelativeLayout;
-
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.Utils;
-import com.mopub.network.MoPubRequestQueue;
-import com.mopub.network.Networking;
-import com.mopub.volley.Request;
-
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.robolectric.Robolectric;
-
-import java.util.List;
-import java.util.Map;
-
-import static com.mopub.nativeads.MoPubNative.EMPTY_EVENT_LISTENER;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyZeroInteractions;
-import static org.mockito.Mockito.when;
-
-@RunWith(SdkTestRunner.class)
-public class NativeResponseTest {
-
-    private NativeResponse subject;
-    private BaseForwardingNativeAd mNativeAd;
-    private Activity context;
-    private ViewGroup view;
-    private MoPubNative.MoPubNativeListener moPubNativeListener;
-    private NativeResponse subjectWMockBaseNativeAd;
-    private NativeAdInterface mMockNativeAd;
-    private boolean baseNativeAdRecordedImpression;
-    private boolean baseNativeAdIsClicked;
-    @Mock
-    private MoPubRequestQueue mockRequestQueue;
-    private SpinningProgressView mockSpinningProgressView;
-
-
-    @Before
-    public void setUp() throws Exception {
-        setupWithClickUrl("clickDestinationUrl");
-    }
-
-    private void setupWithClickUrl(String clickUrl) {
-        context = Robolectric.buildActivity(Activity.class).create().get();
-        mNativeAd = new BaseForwardingNativeAd() {
-            @Override
-            public void recordImpression() {
-                baseNativeAdRecordedImpression = true;
-            }
-
-            @Override
-            public void handleClick(@NonNull final View view) {
-                baseNativeAdIsClicked = true;
-            }
-        };
-        mNativeAd.setTitle("title");
-        mNativeAd.setText("text");
-        mNativeAd.setMainImageUrl("mainImageUrl");
-        mNativeAd.setIconImageUrl("iconImageUrl");
-        mNativeAd.setClickDestinationUrl(clickUrl);
-        mNativeAd.setCallToAction("callToAction");
-        mNativeAd.addExtra("extra", "extraValue");
-        mNativeAd.addExtra("extraImage", "extraImageUrl");
-        mNativeAd.addImpressionTracker("impressionUrl");
-        mNativeAd.setImpressionMinTimeViewed(500);
-
-        view = new LinearLayout(context);
-
-        Networking.setRequestQueueForTesting(mockRequestQueue);
-
-        moPubNativeListener = mock(MoPubNative.MoPubNativeListener.class);
-
-        subject = new NativeResponse(context,
-                "moPubImpressionTrackerUrl",
-                "moPubClickTrackerUrl",
-                "adunit_id", mNativeAd, moPubNativeListener);
-
-        mMockNativeAd = mock(NativeAdInterface.class);
-        subjectWMockBaseNativeAd = new NativeResponse(context,
-                "moPubImpressionTrackerUrl",
-                "moPubClickTrackerUrl",
-                "adunit_id", mMockNativeAd, moPubNativeListener);
-
-        mockSpinningProgressView = mock(SpinningProgressView.class);
-    }
-
-    @Test
-    public void constructor_shouldSetNativeEventListenerOnNativeAdInterface() {
-        reset(mMockNativeAd);
-        subject = new NativeResponse(context, "moPubImpressionTrackerUrl", "moPubClickTrackerUrl",
-                "adunit_id", mMockNativeAd, moPubNativeListener);
-        verify(mMockNativeAd).setNativeEventListener(any(BaseForwardingNativeAd.NativeEventListener.class));
-    }
-
-    @Test
-    public void getTitle_shouldReturnTitleFromBaseNativeAd() {
-        assertThat(subject.getTitle()).isEqualTo("title");
-    }
-
-    @Test
-    public void getTitle_shouldReturnTextFromBaseNativeAd() {
-        assertThat(subject.getText()).isEqualTo("text");
-    }
-
-    @Test
-    public void getMainImageUrl_shouldReturnMainImageUrlFromBaseNativeAd() {
-        assertThat(subject.getMainImageUrl()).isEqualTo("mainImageUrl");
-    }
-
-    @Test
-    public void getIconImageUrl_shouldReturnIconImageUrlFromBaseNativeAd() {
-        assertThat(subject.getIconImageUrl()).isEqualTo("iconImageUrl");
-    }
-
-    @Test
-    public void getClickDestinationUrl_shouldReturnClickDestinationUrlFromBaseNativeAd() {
-        assertThat(subject.getClickDestinationUrl()).isEqualTo("clickDestinationUrl");
-    }
-
-    @Test
-    public void getCallToAction_shouldReturnCallToActionFromBaseNativeAd() {
-        assertThat(subject.getCallToAction()).isEqualTo("callToAction");
-    }
-
-    @Test
-    public void getExtra_shouldReturnExtraFromBaseNativeAd() {
-        assertThat(subject.getExtra("extra")).isEqualTo("extraValue");
-    }
-
-    @Test
-    public void getExtras_shouldReturnCopyOfExtrasMapFromBaseNativeAd() {
-        final Map<String, Object> extras = subject.getExtras();
-        assertThat(extras.size()).isEqualTo(2);
-        assertThat(extras.get("extra")).isEqualTo("extraValue");
-        assertThat(extras.get("extraImage")).isEqualTo("extraImageUrl");
-        assertThat(extras).isNotSameAs(mNativeAd.getExtras());
-    }
-
-    @Test
-    public void getImpressionTrackers_shouldReturnImpressionTrackersFromMoPubAndFromBaseNativeAd() {
-        final List<String> impressionTrackers = subject.getImpressionTrackers();
-        assertThat(impressionTrackers).containsOnly("moPubImpressionTrackerUrl", "impressionUrl");
-    }
-
-    @Test
-    public void getImpressionMinTimeViewed_shouldReturnImpressionMinTimeViewedFromBaseNativeAd() {
-        assertThat(subject.getImpressionMinTimeViewed()).isEqualTo(500);
-    }
-
-    @Test
-    public void getImpressionMinPercentageViewed_shouldReturnImpressionMinPercentageViewedFromBaseNativeAd() {
-        assertThat(subject.getImpressionMinPercentageViewed()).isEqualTo(50);
-    }
-
-    @Test
-    public void getClickTracker_shouldReturnMoPubClickTracker() {
-        assertThat(subject.getClickTracker()).isEqualTo("moPubClickTrackerUrl");
-    }
-
-    @Test
-    public void prepare_shouldCallPrepareOnBaseNativeAd() {
-        subjectWMockBaseNativeAd.prepare(view);
-        verify(mMockNativeAd).prepare(view);
-    }
-
-    @Test
-    public void prepare_whenDestroyed_shouldReturnFast() {
-        subjectWMockBaseNativeAd.destroy();
-        subjectWMockBaseNativeAd.prepare(view);
-        verify(mMockNativeAd, never()).prepare(view);
-    }
-    
-    @Test
-    public void prepare_withOverridingeClickTracker_shouldNotSetOnClickListener() throws Exception {
-        when(mMockNativeAd.isOverridingClickTracker()).thenReturn(true);
-        View view = mock(View.class);
-        subjectWMockBaseNativeAd.prepare(view);
-        verify(view, never()).setOnClickListener(any(NativeResponse.NativeViewClickListener.class));
-    }
-
-    @Test
-    public void prepare_withoutOverridingClickTracker_shouldSetOnClickListener() throws Exception {
-        when(mMockNativeAd.isOverridingClickTracker()).thenReturn(false);
-        View view = mock(View.class);
-        subjectWMockBaseNativeAd.prepare(view);
-        verify(view).setOnClickListener(any(NativeResponse.NativeViewClickListener.class));
-    }
-
-    @Test
-    public void prepare_shouldAttachClickListenersToViewTree() {
-        RelativeLayout relativeLayout = new RelativeLayout(context);
-        Button callToActionView = new Button(context);
-        callToActionView.setId((int) Utils.generateUniqueId());
-        relativeLayout.addView(callToActionView);
-
-        assertThat(relativeLayout.performClick()).isFalse();
-        assertThat(callToActionView.performClick()).isFalse();
-
-        subject.prepare(relativeLayout);
-
-        assertThat(relativeLayout.performClick()).isTrue();
-        assertThat(callToActionView.performClick()).isTrue();
-    }
-
-    @Test
-    public void recordImpression_shouldRecordImpressionsAndCallIntoBaseNativeAdAndNotifyListenerIdempotently() {
-        assertThat(subject.getRecordedImpression()).isFalse();
-
-        subject.recordImpression(view);
-
-        assertThat(subject.getRecordedImpression()).isTrue();
-
-        assertThat(baseNativeAdRecordedImpression).isTrue();
-        verify(moPubNativeListener).onNativeImpression(view);
-        // There are two impression trackers here.
-        verify(mockRequestQueue, times(2)).add(any(Request.class));
-
-        // reset state
-        baseNativeAdRecordedImpression = false;
-        reset(moPubNativeListener);
-        reset(mockRequestQueue);
-
-        // verify impression tracking doesn't fire again
-        subject.recordImpression(view);
-        assertThat(subject.getRecordedImpression()).isTrue();
-        assertThat(baseNativeAdRecordedImpression).isFalse();
-        verify(moPubNativeListener, never()).onNativeImpression(view);
-        verify(mockRequestQueue, never()).add(any(Request.class));
-    }
-
-    @Test
-    public void recordImpression_whenDestroyed_shouldReturnFast() {
-        subject.destroy();
-        subject.recordImpression(view);
-        assertThat(subject.getRecordedImpression()).isFalse();
-        assertThat(baseNativeAdRecordedImpression).isFalse();
-        verify(moPubNativeListener, never()).onNativeImpression(view);
-        verify(mockRequestQueue, never()).add(any(Request.class));
-    }
-
-    @Test
-    public void handleClick_withNoBaseNativeAdClickDestinationUrl_shouldRecordClickAndCallIntoBaseNativeAdAndNotifyListener() {
-        assertThat(subject.isClicked()).isFalse();
-
-        subject.handleClick(view);
-
-        assertThat(subject.isClicked()).isTrue();
-
-        assertThat(baseNativeAdIsClicked).isTrue();
-        verify(moPubNativeListener).onNativeClick(view);
-        verify(mockRequestQueue).add(any(Request.class));
-
-        // reset state
-        baseNativeAdIsClicked = false;
-        reset(moPubNativeListener);
-        reset(mockRequestQueue);
-
-        // second time, tracking does not fire
-        subject.handleClick(view);
-        assertThat(subject.isClicked()).isTrue();
-        assertThat(baseNativeAdRecordedImpression).isFalse();
-        verify(moPubNativeListener).onNativeClick(view);
-        verifyZeroInteractions(mockRequestQueue);
-    }
-
-    @Ignore("pending")
-    @Test
-    public void handleClick_withBaseNativeAdClickDestinationUrl_shouldRecordClickAndCallIntoBaseNativeAdAndOpenClickDestinationAndNotifyListener() {
-        // Really difficult to test url resolution since it doesn't use the apache http client
-    }
-
-    @Test
-    public void handleClick_shouldShowSpinner_shouldRemoveSpinner_WhenSucceeded() {
-        setupWithClickUrl("http://www.mopub.com");
-
-        Robolectric.getBackgroundScheduler().pause();
-
-        subject.handleClick(view, mockSpinningProgressView);
-
-        verify(mockSpinningProgressView).addToRoot(view);
-        Robolectric.getBackgroundScheduler().unPause();
-        verify(mockSpinningProgressView).removeFromRoot();
-    }
-
-    @Test
-    public void handleClick_shouldShowSpinner_shouldRemoveSpinner_WhenFailed() {
-        setupWithClickUrl("");
-
-        Robolectric.getBackgroundScheduler().pause();
-
-        subject.handleClick(view, mockSpinningProgressView);
-
-        verify(mockSpinningProgressView).addToRoot(view);
-        Robolectric.getBackgroundScheduler().unPause();
-        verify(mockSpinningProgressView).removeFromRoot();
-    }
-
-    @Test
-    public void handleClick_withNullView_shouldNotShowSpinner() {
-        setupWithClickUrl("http://www.mopub.com");
-
-        Robolectric.getBackgroundScheduler().pause();
-
-        subject.handleClick(null, mockSpinningProgressView);
-
-        verify(mockSpinningProgressView, never()).addToRoot(view);
-        Robolectric.getBackgroundScheduler().unPause();
-        verify(mockSpinningProgressView, never()).removeFromRoot();
-    }
-
-    @Test
-    public void handleClick_whenDestroyed_shouldReturnFast() {
-        subject.destroy();
-        subject.handleClick(view);
-        assertThat(subject.isClicked()).isFalse();
-        assertThat(baseNativeAdIsClicked).isFalse();
-        verify(moPubNativeListener, never()).onNativeClick(view);
-        verifyZeroInteractions(mockRequestQueue);
-    }
-
-    @Test
-    public void destroy_shouldCallIntoBaseNativeAd() {
-        subjectWMockBaseNativeAd.destroy();
-        assertThat(subjectWMockBaseNativeAd.isDestroyed()).isTrue();
-        verify(mMockNativeAd).destroy();
-
-        reset(mMockNativeAd);
-
-        subjectWMockBaseNativeAd.destroy();
-        verify(mMockNativeAd, never()).destroy();
-    }
-
-    @Test
-    public void destroy_shouldSetMoPubNativeEventListenerToEmptyMoPubNativeListener() {
-        assertThat(subjectWMockBaseNativeAd.getMoPubNativeEventListener()).isSameAs(moPubNativeListener);
-
-        subjectWMockBaseNativeAd.destroy();
-
-        assertThat(subjectWMockBaseNativeAd.getMoPubNativeEventListener()).isSameAs(EMPTY_EVENT_LISTENER);
-    }
-
-    // NativeViewClickListener tests
-    @Test
-    public void NativeViewClickListener_onClick_shouldQueueClickTrackerAndUrlResolutionTasks() {
-        subject = mock(NativeResponse.class);
-        NativeResponse.NativeViewClickListener nativeViewClickListener = subject.new NativeViewClickListener();
-
-        View view = new View(context);
-        nativeViewClickListener.onClick(view);
-        verify(subject).handleClick(view);
-    }
-
-    @Ignore("pending")
-    @Test
-    public void loadExtrasImage_shouldAsyncLoadImages() {
-        // no easy way to test this since nothing can be mocked
-        // also not a critical test since it directly calls another service
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeUrlGeneratorTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeUrlGeneratorTest.java
index 724736a8..33bd9b0c 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeUrlGeneratorTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeUrlGeneratorTest.java
@@ -26,6 +26,8 @@
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowLocationManager;
 
@@ -41,11 +43,9 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.when;
-import static org.robolectric.Robolectric.application;
-import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(SdkTestRunner.class)
-@Config(shadows = {MoPubShadowTelephonyManager.class})
+@Config(constants = BuildConfig.class, shadows = {MoPubShadowTelephonyManager.class})
 public class NativeUrlGeneratorTest {
     public static final String AD_UNIT_ID = "1234";
     private static final int TEST_SCREEN_WIDTH = 999;
@@ -59,10 +59,10 @@
     public void setup() {
         Networking.useHttps(false);
         context = spy(Robolectric.buildActivity(Activity.class).create().get());
-        shadowOf(context).grantPermissions(ACCESS_NETWORK_STATE);
+        Shadows.shadowOf(context).grantPermissions(ACCESS_NETWORK_STATE);
         when(context.getPackageName()).thenReturn("testBundle");
         shadowTelephonyManager = (MoPubShadowTelephonyManager)
-                shadowOf((TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE));
+                Shadows.shadowOf((TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE));
 
         // Set the expected screen dimensions to arbitrary numbers
         final Resources spyResources = spy(context.getResources());
@@ -191,8 +191,8 @@ public void generateUrlString_whenLocationServiceGpsProviderHasMostRecentLocatio
 
         // Mock out the LocationManager's last known location to be more recent than the
         // developer-supplied location.
-        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
-                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
+        ShadowLocationManager shadowLocationManager = Shadows.shadowOf(
+                (LocationManager) RuntimeEnvironment.application.getSystemService(Context.LOCATION_SERVICE));
         Location locationFromSdk = new Location("");
         locationFromSdk.setLatitude(37);
         locationFromSdk.setLongitude(-122);
@@ -222,8 +222,8 @@ public void generateUrlString_whenDeveloperSuppliesMoreRecentLocationThanLocatio
         locationFromDeveloper.setAccuracy(3.5f);
         locationFromDeveloper.setTime(System.currentTimeMillis() - 777777);
 
-        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
-                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
+        ShadowLocationManager shadowLocationManager = Shadows.shadowOf(
+                (LocationManager) RuntimeEnvironment.application.getSystemService(Context.LOCATION_SERVICE));
 
         // Mock out the LocationManager's last known location to be older than the
         // developer-supplied location.
@@ -258,8 +258,8 @@ public void generateUrlString_whenLocationServiceNetworkProviderHasMostRecentLoc
 
         // Mock out the LocationManager's last known location to be more recent than the
         // developer-supplied location.
-        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
-                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
+        ShadowLocationManager shadowLocationManager = Shadows.shadowOf(
+                (LocationManager) RuntimeEnvironment.application.getSystemService(Context.LOCATION_SERVICE));
         Location locationFromSdk = new Location("");
         locationFromSdk.setLatitude(38);
         locationFromSdk.setLongitude(-123);
@@ -329,8 +329,8 @@ public void disableLocationCollection_whenLocationServiceHasMostRecentLocation_s
         subject = new NativeUrlGenerator(context);
 
         // Mock out the LocationManager's last known location.
-        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
-                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
+        ShadowLocationManager shadowLocationManager = Shadows.shadowOf(
+                (LocationManager) RuntimeEnvironment.application.getSystemService(Context.LOCATION_SERVICE));
         Location locationFromSdk = new Location("");
         locationFromSdk.setLatitude(37);
         locationFromSdk.setLongitude(-122);
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeVideoControllerTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeVideoControllerTest.java
new file mode 100644
index 00000000..11fa6062
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeVideoControllerTest.java
@@ -0,0 +1,748 @@
+package com.mopub.nativeads;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.graphics.Bitmap;
+import android.graphics.SurfaceTexture;
+import android.graphics.drawable.BitmapDrawable;
+import android.media.AudioManager;
+import android.os.Build;
+import android.os.Handler;
+import android.view.Surface;
+import android.view.TextureView;
+
+import com.google.android.exoplayer.ExoPlaybackException;
+import com.google.android.exoplayer.ExoPlayer;
+import com.google.android.exoplayer.MediaCodecAudioTrackRenderer;
+import com.google.android.exoplayer.MediaCodecVideoTrackRenderer;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
+import com.mopub.mobileads.VastTracker;
+import com.mopub.mobileads.VastVideoConfig;
+import com.mopub.nativeads.NativeVideoController.ExoPlayerFactory;
+import com.mopub.nativeads.NativeVideoController.Listener;
+import com.mopub.nativeads.NativeVideoController.NativeVideoProgressRunnable;
+import com.mopub.nativeads.NativeVideoController.NativeVideoProgressRunnable.ProgressListener;
+import com.mopub.nativeads.NativeVideoController.VisibilityTrackingEvent;
+import com.mopub.nativeads.VisibilityTracker.VisibilityChecker;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.network.TrackingRequest;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.util.ReflectionHelpers;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static com.mopub.common.VolleyRequestMatcher.isUrl;
+import static com.mopub.nativeads.NativeVideoController.STATE_BUFFERING;
+import static com.mopub.nativeads.NativeVideoController.STATE_CLEARED;
+import static com.mopub.nativeads.NativeVideoController.STATE_ENDED;
+import static com.mopub.nativeads.NativeVideoController.STATE_IDLE;
+import static com.mopub.nativeads.NativeVideoController.STATE_PREPARING;
+import static com.mopub.nativeads.NativeVideoController.STATE_READY;
+import static com.mopub.nativeads.NativeVideoController.createForId;
+import static com.mopub.nativeads.NativeVideoController.getForId;
+import static com.mopub.nativeads.NativeVideoController.remove;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.argThat;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+@TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class NativeVideoControllerTest {
+
+    private NativeVideoController subject;
+    private Activity activity;
+    private ArrayList<VisibilityTrackingEvent> visibilityTrackingEvents;
+    private VastVideoConfig vastVideoConfig;
+    private NativeVideoProgressRunnable nativeVideoProgressRunnable;
+    @Mock private ExoPlayer mockExoPlayer;
+    @Mock private NativeVideoProgressRunnable mockNativeVideoProgressRunnable;
+    @Mock private TextureView mockTextureView;
+    @Mock private SurfaceTexture mockSurfaceTexture;
+    @Mock private Listener mockListener;
+    @Mock private ProgressListener mockProgressListener;
+    @Mock private VastVideoConfig mockVastVideoConfig;
+    @Mock private Handler mockHandler;
+    @Mock private VisibilityChecker mockVisibilityChecker;
+    @Mock private MoPubRequestQueue mockRequestQueue;
+    @Mock private AudioManager mockAudioManager;
+
+    @Before
+    public void setUp() {
+        activity = Robolectric.buildActivity(Activity.class).create().get();
+        ReflectionHelpers.setStaticField(
+                Build.VERSION.class, "SDK_INT", Build.VERSION_CODES.JELLY_BEAN);
+        visibilityTrackingEvents = new ArrayList<VisibilityTrackingEvent>();
+
+        VisibilityTrackingEvent visibilityTrackingEvent = new VisibilityTrackingEvent();
+        visibilityTrackingEvent.minimumPercentageVisible = 10;
+        visibilityTrackingEvent.totalRequiredPlayTimeMs = 10;
+        visibilityTrackingEvent.strategy = new VisibilityTrackingEvent.OnTrackedStrategy() {
+            @Override
+            public void execute() {
+                TrackingRequest.makeTrackingHttpRequest("trackingUrl1", activity);
+            }
+        };
+
+        VisibilityTrackingEvent visibilityTrackingEvent2 = new VisibilityTrackingEvent();
+        visibilityTrackingEvent2.minimumPercentageVisible = 20;
+        visibilityTrackingEvent2.totalRequiredPlayTimeMs = 20;
+        visibilityTrackingEvent2.strategy = new VisibilityTrackingEvent.OnTrackedStrategy() {
+            @Override
+            public void execute() {
+                TrackingRequest.makeTrackingHttpRequest("trackingUrl2", activity);
+            }
+        };
+
+        VisibilityTrackingEvent visibilityTrackingEvent3 = new VisibilityTrackingEvent();
+        visibilityTrackingEvent3.minimumPercentageVisible = 30;
+        visibilityTrackingEvent3.totalRequiredPlayTimeMs = 30;
+        visibilityTrackingEvent3.strategy = new VisibilityTrackingEvent.OnTrackedStrategy() {
+            @Override
+            public void execute() {
+                TrackingRequest.makeTrackingHttpRequest("trackingUrl3", activity);
+            }
+        };
+        visibilityTrackingEvent3.isTracked = true;
+
+        VisibilityTrackingEvent visibilityTrackingEvent4 = new VisibilityTrackingEvent();
+        visibilityTrackingEvent4.minimumPercentageVisible = 9;
+        visibilityTrackingEvent4.totalRequiredPlayTimeMs = 9;
+        visibilityTrackingEvent4.strategy = new VisibilityTrackingEvent.OnTrackedStrategy() {
+            @Override
+            public void execute() {
+                TrackingRequest.makeTrackingHttpRequest("trackingUrl4", activity);
+            }
+        };
+
+        visibilityTrackingEvents.add(visibilityTrackingEvent);
+        visibilityTrackingEvents.add(visibilityTrackingEvent2);
+        visibilityTrackingEvents.add(visibilityTrackingEvent3);
+        visibilityTrackingEvents.add(visibilityTrackingEvent4);
+
+        vastVideoConfig = new VastVideoConfig();
+        vastVideoConfig.setNetworkMediaFileUrl("networkMediaFileUrl");
+
+        when(mockTextureView.getSurfaceTexture()).thenReturn(mockSurfaceTexture);
+
+        subject = createForId(123,
+                activity,
+                vastVideoConfig,
+                mockNativeVideoProgressRunnable,
+                new ExoPlayerFactory() {
+                    @Override
+                    public ExoPlayer newInstance(int rendererCount, int minBufferMs,
+                            int minRebufferMs) {
+                        return mockExoPlayer;
+                    }
+                },
+                null,
+                mockAudioManager);
+
+        nativeVideoProgressRunnable = new NativeVideoProgressRunnable(activity,
+                mockHandler,
+                visibilityTrackingEvents,
+                mockVisibilityChecker,
+                mockVastVideoConfig);
+        nativeVideoProgressRunnable.setTextureView(mockTextureView);
+        nativeVideoProgressRunnable.setExoPlayer(mockExoPlayer);
+        nativeVideoProgressRunnable.setProgressListener(mockProgressListener);
+
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+    }
+
+    @Test
+    public void createForId_shouldAddNativeVideoControllerToMap_shouldReturnNativeVideoController() {
+        NativeVideoController nativeVideoController =
+                createForId(123, activity, visibilityTrackingEvents, vastVideoConfig, null);
+        assertThat(nativeVideoController).isEqualTo(getForId(123));
+    }
+
+    @Test
+    public void remove_shouldRemoveNativeVideoControllerFromMap() {
+        NativeVideoController nativeVideoController =
+                createForId(123, activity, visibilityTrackingEvents, vastVideoConfig, null);
+        assertThat(nativeVideoController).isEqualTo(getForId(123));
+        remove(123);
+        assertThat(getForId(123)).isNull();
+    }
+
+    @Test
+    public void setPlayWhenReady_shouldUpdatePlayWhenReady() {
+        subject.prepare(this);
+        subject.setPlayWhenReady(true);
+
+        verify(mockExoPlayer).setPlayWhenReady(true);
+    }
+
+    @Test
+    public void setPlayWhenReady_withPlayBackStateReady_withPlayWhenReadyTrue_shouldStartVideoProgressRunnable() {
+        subject.prepare(this);
+        reset(mockNativeVideoProgressRunnable);
+
+        when(mockExoPlayer.getPlaybackState()).thenReturn(STATE_READY);
+        when(mockExoPlayer.getPlayWhenReady()).thenReturn(true);
+        subject.setPlayWhenReady(true);
+
+        verify(mockExoPlayer).setPlayWhenReady(true);
+        verify(mockNativeVideoProgressRunnable).startRepeating(50);
+    }
+
+    @Test
+    public void setPlayWhenReady_withPlayBackStateNotReady_withPlayWhenReadyTrue_shouldStopVideoProgressRunnable() {
+        subject.prepare(this);
+        reset(mockNativeVideoProgressRunnable);
+
+        when(mockExoPlayer.getPlaybackState()).thenReturn(STATE_PREPARING);
+        when(mockExoPlayer.getPlayWhenReady()).thenReturn(true);
+        subject.setPlayWhenReady(true);
+
+        verify(mockExoPlayer).setPlayWhenReady(true);
+        verify(mockNativeVideoProgressRunnable).stop();
+        verify(mockNativeVideoProgressRunnable, never()).startRepeating(anyInt());
+    }
+
+    @Test
+    public void setPlayWhenReady_withPlayBackStateReady_withPlayWhenReadyFalse_shouldStopVideoProgressRunnable() {
+        subject.prepare(this);
+        // initialize the subject to true so that the next call with false will run
+        subject.setPlayWhenReady(true);
+        reset(mockNativeVideoProgressRunnable);
+        reset(mockExoPlayer);
+
+        when(mockExoPlayer.getPlaybackState()).thenReturn(STATE_READY);
+        when(mockExoPlayer.getPlayWhenReady()).thenReturn(false);
+        subject.setPlayWhenReady(false);
+
+        verify(mockExoPlayer).setPlayWhenReady(false);
+        verify(mockNativeVideoProgressRunnable).stop();
+        verify(mockNativeVideoProgressRunnable, never()).startRepeating(anyInt());
+    }
+
+    @Test
+    public void getPlaybackState_withNullExoPlayer_shouldReturnStateCleared() {
+        assertThat(subject.getPlaybackState()).isEqualTo(STATE_CLEARED);
+    }
+
+
+    @Test
+    public void getPlaybackState_withNonNullExoPlayer_shouldReturnExoPlayerState() {
+        subject.prepare(this);
+
+        when(mockExoPlayer.getPlaybackState()).thenReturn(STATE_BUFFERING);
+        assertThat(subject.getPlaybackState()).isEqualTo(STATE_BUFFERING);
+    }
+
+    @Test
+    public void setAudioEnabled_withTrue_shouldSetVolumeOnExoPlayer() {
+        subject.prepare(this);
+        subject.setAudioEnabled(true);
+
+        verify(mockExoPlayer).sendMessage(
+                any(MediaCodecAudioTrackRenderer.class),
+                eq(MediaCodecAudioTrackRenderer.MSG_SET_VOLUME),
+                eq(1.0f));
+    }
+
+    @Test
+    public void setAudioEnabled_withFalse_shouldDisableVolumeOnExoPlayer() {
+        subject.prepare(this);
+        // initialize the subject to true so that the next call with false will run
+        subject.setAudioEnabled(true);
+        reset(mockExoPlayer);
+
+        subject.setAudioEnabled(false);
+
+        verify(mockExoPlayer).sendMessage(
+                any(MediaCodecAudioTrackRenderer.class),
+                eq(MediaCodecAudioTrackRenderer.MSG_SET_VOLUME),
+                eq(0.0f));
+    }
+
+    @Test
+    public void setAppAudioEnabled_withTrue_shouldRequestAudioFocus() throws Exception {
+        subject.setAppAudioEnabled(true);
+
+        verify(mockAudioManager).requestAudioFocus(
+                subject, AudioManager.STREAM_MUSIC, AudioManager.AUDIOFOCUS_GAIN);
+        verify(mockAudioManager, never()).abandonAudioFocus(subject);
+    }
+
+    @Test
+    public void setAppAudioEnabled_withFalse_shouldAbandonAudioFocus() throws Exception {
+        subject.setAppAudioEnabled(true);
+        subject.setAppAudioEnabled(false);
+
+        verify(mockAudioManager).abandonAudioFocus(subject);
+    }
+
+    @Test
+    public void setAudioVolume_withAudioEnabled_shouldSetExoPlayerVolume() throws Exception {
+        subject.prepare(this);
+        subject.setAudioEnabled(true);
+
+        subject.setAudioVolume(0.3f);
+
+        verify(mockExoPlayer).sendMessage(
+                any(MediaCodecAudioTrackRenderer.class),
+                eq(MediaCodecAudioTrackRenderer.MSG_SET_VOLUME),
+                eq(0.3f));
+    }
+
+    @Test
+    public void setAudioVolume_withAudioDisabled_shouldDoNothing() throws Exception {
+        subject.prepare(this);
+
+        subject.setAudioVolume(0.3f);
+
+        verify(mockExoPlayer, never()).sendMessage(
+                any(MediaCodecAudioTrackRenderer.class),
+                eq(MediaCodecAudioTrackRenderer.MSG_SET_VOLUME),
+                eq(0.3f));
+    }
+
+    @Test
+    public void setTextureView_shouldSetTextureViewOnVideoProgressRunnable_shouldSetExoSurface() {
+        subject.prepare(this);
+        reset(mockExoPlayer);
+
+        subject.setTextureView(mockTextureView);
+
+        verify(mockNativeVideoProgressRunnable).setTextureView(mockTextureView);
+        verify(mockExoPlayer).sendMessage(any(MediaCodecVideoTrackRenderer.class),
+                eq(MediaCodecVideoTrackRenderer.MSG_SET_SURFACE),
+                any(Surface.class));
+    }
+
+    @Test
+    public void prepare_shouldClearExistingPlayer() {
+        // setup an initial player
+        subject.prepare(this);
+        subject.setTextureView(mockTextureView);
+
+        reset(mockExoPlayer);
+        reset(mockNativeVideoProgressRunnable);
+        // This will clear the previous player
+        subject.prepare(this);
+
+        verify(mockExoPlayer).sendMessage(any(MediaCodecVideoTrackRenderer.class),
+                eq(MediaCodecVideoTrackRenderer.MSG_SET_SURFACE), eq(null));
+        verify(mockExoPlayer).stop();
+        verify(mockExoPlayer).release();
+        verify(mockNativeVideoProgressRunnable).setExoPlayer(null);
+    }
+
+    @Test
+    public void prepare_shouldPreparePlayer() {
+        ExoPlayerFactory mockExoPlayerFactory = mock(ExoPlayerFactory.class);
+        when(mockExoPlayerFactory.newInstance(2, 1000, 5000)).thenReturn(mockExoPlayer);
+        subject = createForId(123,
+                activity,
+                vastVideoConfig,
+                mockNativeVideoProgressRunnable,
+                mockExoPlayerFactory,
+                null,
+                mockAudioManager);
+        subject.prepare(this);
+
+        verify(mockExoPlayerFactory).newInstance(2, 1000, 5000);
+        verify(mockNativeVideoProgressRunnable).setExoPlayer(mockExoPlayer);
+        verify(mockExoPlayer).addListener(subject);
+        verify(mockExoPlayer).prepare(any(MediaCodecAudioTrackRenderer.class),
+                any(MediaCodecVideoTrackRenderer.class));
+
+        // set audio
+        verify(mockExoPlayer).sendMessage(
+                any(MediaCodecAudioTrackRenderer.class),
+                eq(MediaCodecAudioTrackRenderer.MSG_SET_VOLUME),
+                eq(0.0f));
+
+        // play when ready
+        verify(mockExoPlayer).setPlayWhenReady(false);
+        verify(mockNativeVideoProgressRunnable).stop();
+
+        // set surface
+        verify(mockExoPlayer).sendMessage(any(MediaCodecVideoTrackRenderer.class),
+                eq(MediaCodecVideoTrackRenderer.MSG_SET_SURFACE),
+                eq(null));
+    }
+
+    @Test
+    public void clear_shouldSetPlayWhenReadyFalse_shouldClearExistingPlayer() {
+        // initialize to true so we can set to false
+        subject.setPlayWhenReady(true);
+        subject.prepare(this);
+
+        reset(mockExoPlayer);
+        reset(mockNativeVideoProgressRunnable);
+        subject.clear();
+
+        verify(mockExoPlayer).setPlayWhenReady(false);
+
+        // clear exo player
+        verify(mockExoPlayer).sendMessage(any(MediaCodecVideoTrackRenderer.class),
+                eq(MediaCodecVideoTrackRenderer.MSG_SET_SURFACE), eq(null));
+        verify(mockExoPlayer).stop();
+        verify(mockExoPlayer).release();
+        verify(mockNativeVideoProgressRunnable).setExoPlayer(null);
+    }
+
+    @Test
+    public void release_withMatchingOwner_shouldClearExistingPlayer() {
+        subject.prepare(this);
+
+        reset(mockExoPlayer);
+        reset(mockNativeVideoProgressRunnable);
+        subject.release(this);
+
+        // clear exo player
+        verify(mockExoPlayer).sendMessage(any(MediaCodecVideoTrackRenderer.class),
+                eq(MediaCodecVideoTrackRenderer.MSG_SET_SURFACE), eq(null));
+        verify(mockExoPlayer).stop();
+        verify(mockExoPlayer).release();
+        verify(mockNativeVideoProgressRunnable).setExoPlayer(null);
+    }
+
+    @Test
+    public void release_withMismatchingOwner_shouldNotClearExistingPlayer() {
+        subject.prepare(this);
+
+        reset(mockExoPlayer);
+        reset(mockNativeVideoProgressRunnable);
+        // can be any object as long as its not 'this'
+        subject.release(mockExoPlayer);
+
+        verifyNoMoreInteractions(mockExoPlayer);
+        verifyNoMoreInteractions(mockNativeVideoProgressRunnable);
+    }
+
+    @Test
+    public void onPlayerStateChanged_withPlayWhenReadyTrue_withStateReady_shouldStartProgressRunnable() {
+        subject.prepare(this);
+
+        reset(mockExoPlayer);
+        reset(mockNativeVideoProgressRunnable);
+        subject.onPlayerStateChanged(true, STATE_READY);
+
+        verify(mockNativeVideoProgressRunnable).startRepeating(50);
+    }
+
+
+    @Test
+    public void onPlayerStateChanged_withStateEnded_shouldSetFinalFrame() {
+        subject.setTextureView(mockTextureView);
+        subject.prepare(this);
+
+        reset(mockExoPlayer);
+        reset(mockNativeVideoProgressRunnable);
+        Bitmap mockBitmap = mock(Bitmap.class);
+        when(mockTextureView.getBitmap()).thenReturn(mockBitmap);
+        subject.onPlayerStateChanged(true, STATE_ENDED);
+
+        assertThat(subject.hasFinalFrame()).isTrue();
+        assertThat(subject.getFinalFrame()).isNotNull();
+        assertThat(((BitmapDrawable) subject.getFinalFrame()).getBitmap()).isEqualTo(mockBitmap);
+    }
+
+    @Test
+    public void onPlayerStateChanged_withNonNullListener_shouldNotifyListener() {
+        subject.prepare(this);
+        subject.setListener(mockListener);
+
+        subject.onPlayerStateChanged(true, STATE_IDLE);
+
+        verify(mockListener).onStateChanged(true, STATE_IDLE);
+    }
+
+    @Test
+    public void seekTo_shouldCallExoPlayerSeekTo_shouldCallProgressRunnableSeekTo() {
+        subject.prepare(this);
+        subject.seekTo(321);
+
+        verify(mockExoPlayer).seekTo(321);
+        verify(mockNativeVideoProgressRunnable).seekTo(321);
+    }
+
+    @Test
+    public void getCurrentPosition_shouldReturnProgressRunnableCurrentPosition() {
+        when(mockNativeVideoProgressRunnable.getCurrentPosition()).thenReturn(456L);
+        assertThat(subject.getCurrentPosition()).isEqualTo(456L);
+        verify(mockNativeVideoProgressRunnable).getCurrentPosition();
+    }
+
+    @Test
+    public void getDuration_shouldReturnProgressRunnableDuration() {
+        when(mockNativeVideoProgressRunnable.getDuration()).thenReturn(234L);
+        assertThat(subject.getDuration()).isEqualTo(234L);
+        verify(mockNativeVideoProgressRunnable).getDuration();
+    }
+
+    @Test
+    public void onPlayerError_shouldNotifyListener() {
+        ExoPlaybackException exoPlaybackException = new ExoPlaybackException("exception");
+        subject.setListener(mockListener);
+        subject.onPlayerError(exoPlaybackException);
+
+        verify(mockListener).onError(exoPlaybackException);
+    }
+
+    @Test
+    public void handleCtaClick_shouldInvokeVastVideoConfigHandleClick() {
+        subject = createForId(123,
+                activity,
+                mockVastVideoConfig,
+                mockNativeVideoProgressRunnable,
+                new ExoPlayerFactory() {
+                    @Override
+                    public ExoPlayer newInstance(int rendererCount, int minBufferMs,
+                            int minRebufferMs) {
+                        return mockExoPlayer;
+                    }
+                },
+                null,
+                mockAudioManager);
+
+        subject.handleCtaClick(activity);
+
+        verify(mockVastVideoConfig).handleClickWithoutResult(activity, 0);
+    }
+
+
+    @Test
+    public void NativeVideoProgressRunnable_doWork_shouldTrackEventsWithMinimumPercentVisibleWithMinimumTimePlayed() {
+        when(mockExoPlayer.getCurrentPosition()).thenReturn(10L);
+        when(mockExoPlayer.getDuration()).thenReturn(25L);
+        when(mockExoPlayer.getPlayWhenReady()).thenReturn(true);
+        when(mockVisibilityChecker.isVisible(mockTextureView, mockTextureView, 10)).thenReturn(true);
+        when(mockVisibilityChecker.isVisible(mockTextureView, mockTextureView, 20)).thenReturn(false);
+
+        nativeVideoProgressRunnable.setUpdateIntervalMillis(10);
+        nativeVideoProgressRunnable.doWork();
+
+        verify(mockRequestQueue).add(argThat(isUrl("trackingUrl1")));
+        assertThat(visibilityTrackingEvents.get(0).isTracked).isTrue();
+        assertThat(visibilityTrackingEvents.get(1).isTracked).isFalse();
+
+        // should not track same request twice
+        reset(mockRequestQueue);
+        nativeVideoProgressRunnable.doWork();
+
+        verifyNoMoreInteractions(mockRequestQueue);
+    }
+
+    @Test
+    public void NativeVideoProgressRunnable_doWork_shouldUpdateProgressListenerWithPercentagePlayed() {
+        when(mockExoPlayer.getCurrentPosition()).thenReturn(10L);
+        when(mockExoPlayer.getDuration()).thenReturn(25L);
+        when(mockExoPlayer.getPlayWhenReady()).thenReturn(true);
+
+        nativeVideoProgressRunnable.doWork();
+
+        verify(mockProgressListener).updateProgress((int) (((float) 10L / 25L) * 1000));
+    }
+
+    @Test
+    public void NativeVideoProgressRunnable_doWork_shouldFireUntriggeredTrackersFromVastVideoConfig() {
+        when(mockExoPlayer.getCurrentPosition()).thenReturn(10L);
+        when(mockExoPlayer.getDuration()).thenReturn(25L);
+        when(mockExoPlayer.getPlayWhenReady()).thenReturn(true);
+
+        VastTracker vastTracker = new VastTracker("vastTrackingUrl");
+        List<VastTracker> vastTrackers = new ArrayList<VastTracker>();
+        vastTrackers.add(vastTracker);
+        when(mockVastVideoConfig.getUntriggeredTrackersBefore(10, 25)).thenReturn(vastTrackers);
+
+        nativeVideoProgressRunnable.doWork();
+
+        verify(mockRequestQueue).add(argThat(isUrl("vastTrackingUrl")));
+        assertThat(vastTracker.isTracked()).isTrue();
+
+        reset(mockRequestQueue);
+        nativeVideoProgressRunnable.doWork();
+
+        verifyNoMoreInteractions(mockRequestQueue);
+    }
+
+    @Test
+    public void NativeVideoProgressRunnable_doWork_withNullExoPlayer_shouldReturnFast() {
+        when(mockExoPlayer.getCurrentPosition()).thenReturn(10L);
+        when(mockExoPlayer.getDuration()).thenReturn(25L);
+        when(mockExoPlayer.getPlayWhenReady()).thenReturn(true);
+
+        VastTracker vastTracker = new VastTracker("vastTrackingUrl");
+        List<VastTracker> vastTrackers = new ArrayList<VastTracker>();
+        vastTrackers.add(vastTracker);
+        when(mockVastVideoConfig.getUntriggeredTrackersBefore(10, 25)).thenReturn(vastTrackers);
+        nativeVideoProgressRunnable.setUpdateIntervalMillis(10);
+
+        nativeVideoProgressRunnable.setExoPlayer(null);
+        nativeVideoProgressRunnable.doWork();
+
+        assertThat(visibilityTrackingEvents.get(0).isTracked).isFalse();
+        assertThat(visibilityTrackingEvents.get(1).isTracked).isFalse();
+        assertThat(vastTracker.isTracked()).isFalse();
+        verifyNoMoreInteractions(mockVisibilityChecker);
+        verifyNoMoreInteractions(mockVastVideoConfig);
+        verifyNoMoreInteractions(mockRequestQueue);
+        verifyNoMoreInteractions(mockProgressListener);
+    }
+
+    @Test
+    public void NativeVideoProgressRunnable_doWork_withExoPlayerGetPlayWhenReadyFalse_shouldReturnFast() {
+        when(mockExoPlayer.getCurrentPosition()).thenReturn(10L);
+        when(mockExoPlayer.getDuration()).thenReturn(25L);
+        when(mockExoPlayer.getPlayWhenReady()).thenReturn(false);
+
+        VastTracker vastTracker = new VastTracker("vastTrackingUrl");
+        List<VastTracker> vastTrackers = new ArrayList<VastTracker>();
+        vastTrackers.add(vastTracker);
+        when(mockVastVideoConfig.getUntriggeredTrackersBefore(10, 25)).thenReturn(vastTrackers);
+        nativeVideoProgressRunnable.setUpdateIntervalMillis(10);
+
+        nativeVideoProgressRunnable.doWork();
+
+        assertThat(visibilityTrackingEvents.get(0).isTracked).isFalse();
+        assertThat(visibilityTrackingEvents.get(1).isTracked).isFalse();
+        assertThat(vastTracker.isTracked()).isFalse();
+        verifyNoMoreInteractions(mockVisibilityChecker);
+        verifyNoMoreInteractions(mockVastVideoConfig);
+        verifyNoMoreInteractions(mockRequestQueue);
+        verifyNoMoreInteractions(mockProgressListener);
+    }
+
+    @Test
+    public void NativeVideoProgressRunnable_doWork_withDurationLessThan0_shouldReturnFast() {
+        when(mockExoPlayer.getCurrentPosition()).thenReturn(10L);
+        when(mockExoPlayer.getDuration()).thenReturn(-1L);
+        when(mockExoPlayer.getPlayWhenReady()).thenReturn(true);
+
+        VastTracker vastTracker = new VastTracker("vastTrackingUrl");
+        List<VastTracker> vastTrackers = new ArrayList<VastTracker>();
+        vastTrackers.add(vastTracker);
+        when(mockVastVideoConfig.getUntriggeredTrackersBefore(10, 25)).thenReturn(vastTrackers);
+        nativeVideoProgressRunnable.setUpdateIntervalMillis(10);
+
+        nativeVideoProgressRunnable.doWork();
+
+        assertThat(visibilityTrackingEvents.get(0).isTracked).isFalse();
+        assertThat(visibilityTrackingEvents.get(1).isTracked).isFalse();
+        assertThat(vastTracker.isTracked()).isFalse();
+        verifyNoMoreInteractions(mockVisibilityChecker);
+        verifyNoMoreInteractions(mockVastVideoConfig);
+        verifyNoMoreInteractions(mockRequestQueue);
+        verifyNoMoreInteractions(mockProgressListener);
+    }
+
+    @Test
+    public void NativeVideoProgressRunnable_checkImpressionTrackers_withForceTriggerFalse_shouldOnlyTriggerNotTrackedEvents() {
+        when(mockExoPlayer.getCurrentPosition()).thenReturn(50L);
+        when(mockExoPlayer.getDuration()).thenReturn(50L);
+        when(mockVisibilityChecker.isVisible(eq(mockTextureView), eq(mockTextureView), anyInt()))
+                .thenReturn(true);
+        nativeVideoProgressRunnable.setUpdateIntervalMillis(50);
+
+        nativeVideoProgressRunnable.checkImpressionTrackers(false);
+
+        assertThat(visibilityTrackingEvents.get(0).isTracked).isTrue();
+        assertThat(visibilityTrackingEvents.get(1).isTracked).isTrue();
+        assertThat(visibilityTrackingEvents.get(2).isTracked).isTrue();
+        verify(mockRequestQueue).add(argThat(isUrl("trackingUrl1")));
+        verify(mockRequestQueue).add(argThat(isUrl("trackingUrl2")));
+        verify(mockRequestQueue, never()).add(argThat(isUrl("trackingUrl3")));
+    }
+
+    @Test
+    public void NativeVideoProgressRunnable_checkImpressionTrackers_withForceTriggerTrue_shouldOnlyTriggerNotTrackedEvents() {
+        when(mockExoPlayer.getCurrentPosition()).thenReturn(50L);
+        when(mockExoPlayer.getDuration()).thenReturn(50L);
+        when(mockVisibilityChecker.isVisible(eq(mockTextureView), eq(mockTextureView), anyInt()))
+                .thenReturn(true);
+        nativeVideoProgressRunnable.setUpdateIntervalMillis(50);
+
+        nativeVideoProgressRunnable.checkImpressionTrackers(true);
+
+        assertThat(visibilityTrackingEvents.get(0).isTracked).isTrue();
+        assertThat(visibilityTrackingEvents.get(1).isTracked).isTrue();
+        assertThat(visibilityTrackingEvents.get(2).isTracked).isTrue();
+        verify(mockRequestQueue).add(argThat(isUrl("trackingUrl1")));
+        verify(mockRequestQueue).add(argThat(isUrl("trackingUrl2")));
+        verify(mockRequestQueue, never()).add(argThat(isUrl("trackingUrl3")));
+    }
+
+    @Test
+    public void NativeVideoProgressRunnable_checkImpressionTrackers_withForceTriggerFalse_shouldOnlyTriggerVisibleAndPlayedEvents() {
+        when(mockExoPlayer.getCurrentPosition()).thenReturn(10L);
+        when(mockExoPlayer.getDuration()).thenReturn(10L);
+        // trackingUrl1: visible & played = track
+        when(mockVisibilityChecker.isVisible(eq(mockTextureView), eq(mockTextureView), eq(10)))
+                .thenReturn(true);
+        // trackingUrl2: visible & !played = !track
+        when(mockVisibilityChecker.isVisible(eq(mockTextureView), eq(mockTextureView), eq(20)))
+                .thenReturn(true);
+        // trackingUrl3: already tracked = !track
+        when(mockVisibilityChecker.isVisible(eq(mockTextureView), eq(mockTextureView), eq(30)))
+                .thenReturn(true);
+        // trackingUrl4: !visible & played = !track
+        when(mockVisibilityChecker.isVisible(eq(mockTextureView), eq(mockTextureView), eq(9)))
+                .thenReturn(false);
+        nativeVideoProgressRunnable.setUpdateIntervalMillis(10);
+
+        nativeVideoProgressRunnable.checkImpressionTrackers(false);
+
+        assertThat(visibilityTrackingEvents.get(0).isTracked).isTrue();
+        assertThat(visibilityTrackingEvents.get(1).isTracked).isFalse();
+        assertThat(visibilityTrackingEvents.get(2).isTracked).isTrue();
+        assertThat(visibilityTrackingEvents.get(3).isTracked).isFalse();
+        verify(mockRequestQueue).add(argThat(isUrl("trackingUrl1")));
+        verify(mockRequestQueue, never()).add(argThat(isUrl("trackingUrl2")));
+        verify(mockRequestQueue, never()).add(argThat(isUrl("trackingUrl3")));
+        verify(mockRequestQueue, never()).add(argThat(isUrl("trackingUrl4")));
+    }
+
+    @Test
+    public void NativeVideoProgressRunnable_checkImpressionTrackers_withForceTriggerTrue_shouldTriggerAllUntrackedEvents() {
+        when(mockExoPlayer.getCurrentPosition()).thenReturn(10L);
+        when(mockExoPlayer.getDuration()).thenReturn(10L);
+        // trackingUrl1: visible & played = track
+        when(mockVisibilityChecker.isVisible(eq(mockTextureView), eq(mockTextureView), eq(10)))
+                .thenReturn(true);
+        // trackingUrl2: visible & !played = !track
+        when(mockVisibilityChecker.isVisible(eq(mockTextureView), eq(mockTextureView), eq(20)))
+                .thenReturn(true);
+        // trackingUrl3: already tracked = !track
+        when(mockVisibilityChecker.isVisible(eq(mockTextureView), eq(mockTextureView), eq(30)))
+                .thenReturn(true);
+        // trackingUrl4: !visible & played = !track
+        when(mockVisibilityChecker.isVisible(eq(mockTextureView), eq(mockTextureView), eq(9)))
+                .thenReturn(false);
+        nativeVideoProgressRunnable.setUpdateIntervalMillis(10);
+
+        nativeVideoProgressRunnable.checkImpressionTrackers(true);
+
+        assertThat(visibilityTrackingEvents.get(0).isTracked).isTrue();
+        assertThat(visibilityTrackingEvents.get(1).isTracked).isTrue();
+        assertThat(visibilityTrackingEvents.get(2).isTracked).isTrue();
+        assertThat(visibilityTrackingEvents.get(3).isTracked).isTrue();
+        verify(mockRequestQueue).add(argThat(isUrl("trackingUrl1")));
+        verify(mockRequestQueue).add(argThat(isUrl("trackingUrl2")));
+        verify(mockRequestQueue, never()).add(argThat(isUrl("trackingUrl3")));
+        verify(mockRequestQueue).add(argThat(isUrl("trackingUrl4")));
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeVideoViewControllerTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeVideoViewControllerTest.java
new file mode 100644
index 00000000..79307f38
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeVideoViewControllerTest.java
@@ -0,0 +1,361 @@
+package com.mopub.nativeads;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.content.Intent;
+import android.content.res.Configuration;
+import android.graphics.Bitmap;
+import android.media.AudioManager;
+import android.os.Build;
+import android.os.Bundle;
+import android.view.TextureView;
+import android.view.View;
+import android.view.ViewGroup.LayoutParams;
+
+import com.mopub.common.MoPubBrowser;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BaseVideoViewController.BaseVideoViewControllerListener;
+import com.mopub.mobileads.BuildConfig;
+import com.mopub.mobileads.VastVideoConfig;
+import com.mopub.mobileads.resource.CtaButtonDrawable;
+import com.mopub.nativeads.MoPubCustomEventVideoNative.MoPubVideoNativeAd;
+import com.mopub.nativeads.NativeFullScreenVideoView.Mode;
+import com.mopub.nativeads.NativeVideoController.NativeVideoProgressRunnable.ProgressListener;
+import com.mopub.nativeads.NativeVideoViewController.VideoState;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowApplication;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+@TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class NativeVideoViewControllerTest {
+
+    private NativeVideoViewController subject;
+    private Activity activity;
+    private Bundle intentExtras;
+
+    @Mock private BaseVideoViewControllerListener mockBaseVideoViewControllerListener;
+    @Mock private NativeFullScreenVideoView mockFullScreenVideoView;
+    @Mock private NativeVideoController mockVideoController;
+    @Mock private VastVideoConfig mockVastVideoConfig;
+    @Mock private TextureView mockTextureView;
+    @Mock private Bitmap mockBitmap;
+
+    @Before
+    public void setUp() {
+        activity = Robolectric.buildActivity(Activity.class).create().get();
+
+        intentExtras = new Bundle();
+        intentExtras.putLong(NativeVideoViewController.NATIVE_VIDEO_ID, 123);
+        NativeVideoController.setForId(123, mockVideoController);
+
+        when(mockVastVideoConfig.getCustomCtaText()).thenReturn("Learn More");
+        when(mockFullScreenVideoView.getTextureView()).thenReturn(mockTextureView);
+        when(mockTextureView.getBitmap()).thenReturn(mockBitmap);
+        intentExtras.putSerializable(NativeVideoViewController.NATIVE_VAST_VIDEO_CONFIG, mockVastVideoConfig);
+
+        subject = new NativeVideoViewController(activity, intentExtras, null,
+                mockBaseVideoViewControllerListener, mockFullScreenVideoView);
+    }
+
+    @After
+    public void tearDown() {
+        NativeVideoController.remove(123);
+    }
+
+    @Test
+    public void constructor_shouldSetCtaText() {
+        subject = new NativeVideoViewController(activity, intentExtras, null,
+                mockBaseVideoViewControllerListener);
+        CtaButtonDrawable ctaButtonDrawable =
+                (CtaButtonDrawable) subject.getNativeFullScreenVideoView().getCtaButton()
+                        .getDrawable();
+
+        assertThat(ctaButtonDrawable.getCtaText()).isEqualTo("Learn More");
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void constructor_withNullNativeVideoController_shouldThrowNPE() {
+        NativeVideoController.remove(123);
+        subject = new NativeVideoViewController(activity, intentExtras, null,
+                mockBaseVideoViewControllerListener, mockFullScreenVideoView);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void onCreate_withNullNativeVideoController_shouldThrowNPE() {
+        intentExtras.remove(NativeVideoViewController.NATIVE_VAST_VIDEO_CONFIG);
+        subject = new NativeVideoViewController(activity, intentExtras, null,
+                mockBaseVideoViewControllerListener, mockFullScreenVideoView);
+    }
+
+    @Test
+    public void onCreate_shouldSetupVideoView() {
+        subject.onCreate();
+
+        verify(mockFullScreenVideoView).setSurfaceTextureListener(subject);
+        verify(mockFullScreenVideoView).setMode(Mode.LOADING);
+        verify(mockFullScreenVideoView).setPlayControlClickListener(any(View.OnClickListener.class));
+        verify(mockFullScreenVideoView).setCloseControlListener(any(View.OnClickListener.class));
+        verify(mockFullScreenVideoView).setCtaClickListener(any(View.OnClickListener.class));
+        verify(mockFullScreenVideoView).setPrivacyInformationClickListener(
+                any(View.OnClickListener.class));
+        verify(mockFullScreenVideoView).setLayoutParams(any(LayoutParams.class));
+        verify(mockBaseVideoViewControllerListener).onSetContentView(mockFullScreenVideoView);
+        verify(mockBaseVideoViewControllerListener, never()).onFinish();
+    }
+
+    @Test
+    public void onCreate_shouldSetupNativeVideoController() {
+        subject.onCreate();
+
+        verify(mockVideoController).setProgressListener(any(ProgressListener.class));
+    }
+
+    @Test
+    public void NativeFullScreenVideoView_playControlClickListener_withVideoEnded_shouldResetFullScreenVideoProgress_shouldSeekTo0_shouldApplyPlaying() {
+        ArgumentCaptor<View.OnClickListener> captor = ArgumentCaptor.forClass(View.OnClickListener.class);
+
+        subject.onCreate();
+        subject.applyState(VideoState.ENDED);
+
+        verify(mockFullScreenVideoView).setPlayControlClickListener(captor.capture());
+        captor.getValue().onClick(null);
+
+        verify(mockFullScreenVideoView).resetProgress();
+        verify(mockVideoController).seekTo(0);
+        assertThat(subject.getVideoState()).isEqualTo(VideoState.PLAYING);
+        verify(mockBaseVideoViewControllerListener, never()).onFinish();
+    }
+
+    @Test
+    public void NativeFullScreenVideoView_closeControlClickListener_shouldSetStatePaused_shouldNotDisableAppAudio_shouldFinishActivity() {
+        ArgumentCaptor<View.OnClickListener> captor = ArgumentCaptor.forClass(View.OnClickListener.class);
+
+        subject.onCreate();
+
+        verify(mockFullScreenVideoView).setCloseControlListener(captor.capture());
+        captor.getValue().onClick(null);
+
+        assertThat(subject.getVideoState()).isEqualTo(VideoState.PAUSED);
+        verify(mockVideoController, never()).setAppAudioEnabled(false);
+        verify(mockBaseVideoViewControllerListener).onFinish();
+    }
+
+    @Test
+    public void NativeFullScreenVideoView_ctaClickListener_shouldSetPlayWhenReadyToFalse_shouldHandleCtaClick() {
+        ArgumentCaptor<View.OnClickListener> captor = ArgumentCaptor.forClass(View.OnClickListener.class);
+        subject.onCreate();
+
+        verify(mockFullScreenVideoView).setCtaClickListener(captor.capture());
+        captor.getValue().onClick(null);
+
+        verify(mockVideoController).setPlayWhenReady(false);
+        verify(mockVideoController).handleCtaClick(activity);
+        verify(mockBaseVideoViewControllerListener, never()).onFinish();
+    }
+
+    @Test
+    public void NativeFullScreenVideoView_privacyInformationIconClickListener_shouldSetPlayWhenReadyToFalse_shouldOpenInAppBrowser() {
+        ArgumentCaptor<View.OnClickListener> captor = ArgumentCaptor.forClass(View.OnClickListener.class);
+
+        subject.onCreate();
+
+        verify(mockFullScreenVideoView).setPrivacyInformationClickListener(captor.capture());
+        captor.getValue().onClick(null);
+
+        verify(mockVideoController).setPlayWhenReady(false);
+
+        final Intent startedActivity = ShadowApplication.getInstance().peekNextStartedActivity();
+        assertThat(startedActivity.getComponent().getClassName())
+                .isEqualTo(MoPubBrowser.class.getName());
+        assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY))
+                .isEqualTo(MoPubVideoNativeAd.PRIVACY_INFORMATION_CLICKTHROUGH_URL);
+        verify(mockBaseVideoViewControllerListener, never()).onFinish();
+    }
+
+    @Test
+    public void NativeVideoController_progressListener_shouldUpdateFullScreenVideoProgress() {
+        ArgumentCaptor<ProgressListener> captor = ArgumentCaptor.forClass(ProgressListener.class);
+
+        subject.onCreate();
+
+        verify(mockVideoController).setProgressListener(captor.capture());
+        captor.getValue().updateProgress(10);
+
+        verify(mockFullScreenVideoView).updateProgress(10);
+        verify(mockBaseVideoViewControllerListener, never()).onFinish();
+    }
+
+    @Test
+    public void onResume_shouldPrepareNativeVideoController_shouldSetListeners() {
+        subject.onResume();
+
+        verify(mockVideoController).prepare(subject);
+        verify(mockVideoController).setListener(subject);
+        verify(mockVideoController).setOnAudioFocusChangeListener(subject);
+        verifyNoMoreInteractions(mockBaseVideoViewControllerListener);
+    }
+
+    @Test
+    public void onConfigurationChanged_shouldSetOrientationOfFullScreenVideoView() {
+        Configuration configuration = new Configuration();
+        configuration.orientation = Configuration.ORIENTATION_LANDSCAPE;
+        subject.onConfigurationChanged(configuration);
+
+        verify(mockFullScreenVideoView).setOrientation(Configuration.ORIENTATION_LANDSCAPE);
+        verifyNoMoreInteractions(mockBaseVideoViewControllerListener);
+    }
+
+    @Test
+    public void onBackPressed_shouldApplyStatePaused_shouldNotDisableAppAudio() throws Exception {
+        subject.onBackPressed();
+
+        assertThat(subject.getVideoState()).isEqualTo(VideoState.PAUSED);
+        verify(mockVideoController, never()).setAppAudioEnabled(false);
+    }
+
+    @Test
+    public void onSurfaceTexutureAvailable_shouldSetTextureView_shouldSeekToLastPosition_shouldSetPlayWhenReadyTrue() {
+        TextureView textureView = mock(TextureView.class);
+        when(mockFullScreenVideoView.getTextureView()).thenReturn(textureView);
+        when(mockVideoController.getCurrentPosition()).thenReturn(321L);
+
+        subject.onSurfaceTextureAvailable(null, 0, 0);
+
+        verify(mockVideoController).setTextureView(textureView);
+        verify(mockVideoController).seekTo(321L);
+        verify(mockVideoController).setPlayWhenReady(true);
+        verifyNoMoreInteractions(mockBaseVideoViewControllerListener);
+    }
+
+    @Test
+    public void onSurfaceTextureDestroyed_shouldReleaseVideoController_shouldApplyStatePaused() {
+        subject.onSurfaceTextureDestroyed(null);
+
+        verify(mockVideoController).release(subject);
+        assertThat(subject.getVideoState()).isEqualTo(VideoState.PAUSED);
+        verifyNoMoreInteractions(mockBaseVideoViewControllerListener);
+    }
+
+    @Test
+    public void onStateChanged_shouldAppropriatelySetVideoState() {
+        subject.onStateChanged(true, NativeVideoController.STATE_PREPARING);
+        assertThat(subject.getVideoState()).isEqualTo(VideoState.LOADING);
+
+        subject.onStateChanged(true, NativeVideoController.STATE_IDLE);
+        assertThat(subject.getVideoState()).isEqualTo(VideoState.LOADING);
+
+        subject.onStateChanged(true, NativeVideoController.STATE_BUFFERING);
+        assertThat(subject.getVideoState()).isEqualTo(VideoState.BUFFERING);
+
+        subject.onStateChanged(true, NativeVideoController.STATE_READY);
+        assertThat(subject.getVideoState()).isEqualTo(VideoState.PLAYING);
+
+        subject.onStateChanged(true, NativeVideoController.STATE_ENDED);
+        assertThat(subject.getVideoState()).isEqualTo(VideoState.ENDED);
+
+        subject.onStateChanged(true, NativeVideoController.STATE_CLEARED);
+        assertThat(subject.getVideoState()).isEqualTo(VideoState.ENDED);
+        verifyNoMoreInteractions(mockBaseVideoViewControllerListener);
+    }
+
+    @Test
+    public void onError_shouldAppropriatelySetVideoState() {
+        subject.onError(new Exception());
+        assertThat(subject.getVideoState()).isEqualTo(VideoState.FAILED_LOAD);
+        verifyNoMoreInteractions(mockBaseVideoViewControllerListener);
+    }
+
+    @Test
+    public void onAudioFocusChange_withFocusChangeAudioFocusLossOrAudioFocusLossTransient_shouldPauseVideo() throws Exception {
+        subject.onAudioFocusChange(AudioManager.AUDIOFOCUS_LOSS);
+
+        assertThat(subject.getVideoState()).isEqualTo(VideoState.PAUSED);
+    }
+
+    @Test
+    public void onAudioFocusChange_withFocusChangeAudioFocusLossTransientCanDuck_shouldLowerVolume() throws Exception {
+        subject.onAudioFocusChange(AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK);
+
+        verify(mockVideoController).setAudioVolume(0.3f);
+    }
+
+    @Test
+    public void onAudioFocusChange_withFocusChangeAudioFocusGain_shouldRaiseVolume() throws Exception {
+        subject.onAudioFocusChange(AudioManager.AUDIOFOCUS_GAIN);
+
+        verify(mockVideoController).setAudioVolume(1.0f);
+    }
+
+    @Test
+    public void applyState_withVideoStateFailedLoad_shouldSetPlayWhenReadyFalse_shouldSetAudioEnabledFalse_shouldSetAppAudioEnabledFalse_shouldSetModeLoading_shouldHandleError() {
+        subject.applyState(VideoState.FAILED_LOAD);
+        verify(mockVideoController).setPlayWhenReady(false);
+        verify(mockVideoController).setAudioEnabled(false);
+        verify(mockVideoController).setAppAudioEnabled(false);
+        verify(mockFullScreenVideoView).setMode(Mode.LOADING);
+        verify(mockVastVideoConfig).handleError(activity, null, 0);
+        verifyNoMoreInteractions(mockBaseVideoViewControllerListener);
+    }
+
+    @Test
+    public void applyState_withVideoStateLoadingOrBuffering_shouldSetPlayWhenReadyTrue_shouldSetModeLoading() {
+        subject.applyState(VideoState.LOADING);
+        verify(mockVideoController).setPlayWhenReady(true);
+        verify(mockFullScreenVideoView).setMode(Mode.LOADING);
+
+        reset(mockVideoController);
+        reset(mockFullScreenVideoView);
+
+        subject.applyState(VideoState.BUFFERING);
+        verify(mockVideoController).setPlayWhenReady(true);
+        verify(mockFullScreenVideoView).setMode(Mode.LOADING);
+        verifyNoMoreInteractions(mockBaseVideoViewControllerListener);
+    }
+
+    @Test
+    public void applyState_withVideoStatePlaying_shouldSetPlayWhenReadyTrue_shouldSetAudioEnabled_shouldSetAppAudioEnabled_shouldSetModePlaying() {
+        subject.applyState(VideoState.PLAYING);
+        verify(mockVideoController).setPlayWhenReady(true);
+        verify(mockVideoController).setAudioEnabled(true);
+        verify(mockVideoController).setAppAudioEnabled(true);
+        verify(mockFullScreenVideoView).setMode(Mode.PLAYING);
+        verifyNoMoreInteractions(mockBaseVideoViewControllerListener);
+    }
+
+    @Test
+    public void applyState_withVideoStatePaused_shouldSetAppAudioEnabledFalse_shouldSetPlayWhenReadyFalse_shouldSetModePaused() {
+        subject.applyState(VideoState.PAUSED);
+        verify(mockVideoController).setAppAudioEnabled(false);
+        verify(mockVideoController).setPlayWhenReady(false);
+        verify(mockFullScreenVideoView).setMode(Mode.PAUSED);
+        verifyNoMoreInteractions(mockBaseVideoViewControllerListener);
+    }
+
+    @Test
+    public void applyState_withVideoStateEnded_shuoldSetAppAudioEnabledFalse_shouldUpdateProgress_shouldSetModeFinished() {
+        subject.applyState(VideoState.ENDED);
+        verify(mockVideoController).setAppAudioEnabled(false);
+        verify(mockFullScreenVideoView).updateProgress(1000);
+        verify(mockFullScreenVideoView).setMode(Mode.FINISHED);
+        verify(mockVastVideoConfig).handleComplete(activity, 0);
+        verifyNoMoreInteractions(mockBaseVideoViewControllerListener);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeViewHolderTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeViewHolderTest.java
deleted file mode 100644
index 9f13f133..00000000
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeViewHolderTest.java
+++ /dev/null
@@ -1,465 +0,0 @@
-package com.mopub.nativeads;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.graphics.drawable.BitmapDrawable;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.Button;
-import android.widget.ImageView;
-import android.widget.LinearLayout;
-import android.widget.RelativeLayout;
-import android.widget.TextView;
-
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.Drawables;
-import com.mopub.common.util.Utils;
-import com.mopub.network.MaxWidthImageLoader;
-import com.mopub.network.MoPubRequestQueue;
-import com.mopub.network.Networking;
-import com.mopub.volley.toolbox.ImageLoader;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Captor;
-import org.mockito.Mock;
-import org.robolectric.Robolectric;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.stub;
-import static org.mockito.Mockito.verify;
-
-@RunWith(SdkTestRunner.class)
-public class NativeViewHolderTest {
-    private Context context;
-    private RelativeLayout relativeLayout;
-    private ViewGroup viewGroup;
-    private NativeResponse nativeResponse;
-    private ViewBinder viewBinder;
-    private MoPubNative.MoPubNativeListener mopubNativeListener;
-    private TextView titleView;
-    private TextView textView;
-    private TextView callToActionView;
-    private ImageView mainImageView;
-    private ImageView iconImageView;
-    private TextView extrasTextView;
-    private ImageView extrasImageView;
-    private ImageView extrasImageView2;
-    private ImageView daaIconImageView;
-    private String mainImageUrl;
-    private String iconImageUrl;
-    private String mainImageData;
-    private String iconImageData;
-    private Bitmap iconImage;
-    private Bitmap mainImage;
-    private String extrasImageData;
-    private String extrasImageData2;
-    private Bitmap extrasImage2;
-    private Bitmap extrasImage;
-
-    private static final String IMPRESSION_URL = "http://example.com";
-    private static final String CLICK_URL = "http://test.com";
-    private static final String AD_UNIT_ID = "http://blah.org";
-
-    @Mock
-    private MoPubRequestQueue mockRequestQueue;
-    @Mock
-    private MaxWidthImageLoader mockImageLoader;
-    @Mock
-    private ImageLoader.ImageContainer mockImageContainer;
-    @Mock
-    private Bitmap mockBitmap;
-
-    @Captor
-    private ArgumentCaptor<ImageLoader.ImageListener> mainImageCaptor;
-    @Captor
-    private ArgumentCaptor<ImageLoader.ImageListener> iconImageCaptor;
-
-
-    @Before
-    public void setUp() throws Exception {
-
-        Networking.setRequestQueueForTesting(mockRequestQueue);
-        Networking.setImageLoaderForTesting(mockImageLoader);
-        context = Robolectric.buildActivity(Activity.class).create().get();
-        relativeLayout = new RelativeLayout(context);
-        relativeLayout.setId((int) Utils.generateUniqueId());
-        viewGroup = new LinearLayout(context);
-
-        // Fields in the web ui
-        titleView = new TextView(context);
-        titleView.setId((int) Utils.generateUniqueId());
-        textView = new TextView(context);
-        textView.setId((int) Utils.generateUniqueId());
-        callToActionView = new Button(context);
-        callToActionView.setId((int) Utils.generateUniqueId());
-        mainImageView = new ImageView(context);
-        mainImageView.setId((int) Utils.generateUniqueId());
-        iconImageView = new ImageView(context);
-        iconImageView.setId((int) Utils.generateUniqueId());
-        daaIconImageView = new ImageView(context);
-        daaIconImageView.setId((int) Utils.generateUniqueId());
-
-        // Extras
-        extrasTextView = new TextView(context);
-        extrasTextView.setId((int) Utils.generateUniqueId());
-        extrasImageView = new ImageView(context);
-        extrasImageView.setId((int) Utils.generateUniqueId());
-        extrasImageView2 = new ImageView(context);
-        extrasImageView2.setId((int) Utils.generateUniqueId());
-
-        relativeLayout.addView(titleView);
-        relativeLayout.addView(textView);
-        relativeLayout.addView(callToActionView);
-        relativeLayout.addView(mainImageView);
-        relativeLayout.addView(iconImageView);
-        relativeLayout.addView(extrasTextView);
-        relativeLayout.addView(extrasImageView);
-        relativeLayout.addView(extrasImageView2);
-        relativeLayout.addView(daaIconImageView);
-
-        mainImageUrl = "mainimageurl";
-        iconImageUrl = "iconimageurl";
-        mainImageData = "mainimagedata";
-        iconImageData = "iconimagedata";
-        extrasImageData = "extrasimagedata";
-        extrasImageData2 = "extrasimagedata2";
-        iconImage = BitmapFactory.decodeByteArray(iconImageData.getBytes(), 0, iconImageData.getBytes().length);
-        mainImage = BitmapFactory.decodeByteArray(mainImageData.getBytes(), 0, mainImageData.getBytes().length);
-        extrasImage = BitmapFactory.decodeByteArray(extrasImageData.getBytes(), 0, extrasImageData.getBytes().length);
-        extrasImage2 = BitmapFactory.decodeByteArray(extrasImageData2.getBytes(), 0, extrasImageData2.getBytes().length);
-    }
-
-    @Test
-    public void fromViewBinder_shouldPopulateClassFields() throws Exception {
-        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
-                .titleId(titleView.getId())
-                .textId(textView.getId())
-                .callToActionId(callToActionView.getId())
-                .mainImageId(mainImageView.getId())
-                .iconImageId(iconImageView.getId())
-                .daaIconImageId(daaIconImageView.getId())
-                .build();
-
-        NativeViewHolder nativeViewHolder =
-                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
-
-        assertThat(nativeViewHolder.titleView).isEqualTo(titleView);
-        assertThat(nativeViewHolder.textView).isEqualTo(textView);
-        assertThat(nativeViewHolder.callToActionView).isEqualTo(callToActionView);
-        assertThat(nativeViewHolder.mainImageView).isEqualTo(mainImageView);
-        assertThat(nativeViewHolder.iconImageView).isEqualTo(iconImageView);
-        assertThat(nativeViewHolder.daaIconImageView).isEqualTo(daaIconImageView);
-    }
-
-    @Test
-    public void fromViewBinder_withSubsetOfFields_shouldLeaveOtherFieldsNull() throws Exception {
-        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
-                .titleId(titleView.getId())
-                .iconImageId(iconImageView.getId())
-                .build();
-
-        NativeViewHolder nativeViewHolder =
-                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
-
-        assertThat(nativeViewHolder.titleView).isEqualTo(titleView);
-        assertThat(nativeViewHolder.textView).isNull();
-        assertThat(nativeViewHolder.callToActionView).isNull();
-        assertThat(nativeViewHolder.mainImageView).isNull();
-        assertThat(nativeViewHolder.iconImageView).isEqualTo(iconImageView);
-        assertThat(nativeViewHolder.daaIconImageView).isNull();
-    }
-
-    @Test
-    public void fromViewBinder_withNonExistantIds_shouldLeaveFieldsNull() throws Exception {
-        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
-                .titleId((int) Utils.generateUniqueId())
-                .textId((int) Utils.generateUniqueId())
-                .callToActionId((int) Utils.generateUniqueId())
-                .mainImageId((int) Utils.generateUniqueId())
-                .iconImageId((int) Utils.generateUniqueId())
-                .build();
-
-        NativeViewHolder nativeViewHolder =
-                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
-
-        assertThat(nativeViewHolder.titleView).isNull();
-        assertThat(nativeViewHolder.textView).isNull();
-        assertThat(nativeViewHolder.callToActionView).isNull();
-        assertThat(nativeViewHolder.mainImageView).isNull();
-        assertThat(nativeViewHolder.iconImageView).isNull();
-        assertThat(nativeViewHolder.daaIconImageView).isNull();
-    }
-
-    @Test
-    public void update_shouldAddValuesToViews() throws Exception {
-        // Setup for cache state for image gets
-
-        BaseForwardingNativeAd nativeAd = new BaseForwardingNativeAd() {
-            @Override
-            public String getDaaIconClickthroughUrl() {
-                return MoPubCustomEventNative.MoPubForwardingNativeAd.DAA_CLICKTHROUGH_URL;
-            }
-        };
-        nativeAd.setTitle("titletext");
-        nativeAd.setText("texttext");
-        nativeAd.setMainImageUrl("mainimageurl");
-        nativeAd.setIconImageUrl("iconimageurl");
-        nativeAd.setCallToAction("cta");
-
-        nativeResponse = new NativeResponse(context,
-                IMPRESSION_URL, CLICK_URL, AD_UNIT_ID, nativeAd, null);
-
-        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
-                .titleId(titleView.getId())
-                .textId(textView.getId())
-                .callToActionId(callToActionView.getId())
-                .mainImageId(mainImageView.getId())
-                .iconImageId(iconImageView.getId())
-                .daaIconImageId(daaIconImageView.getId())
-                .build();
-
-        NativeViewHolder nativeViewHolder =
-                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
-
-        nativeViewHolder.update(nativeResponse);
-
-        assertThat(titleView.getText()).isEqualTo("titletext");
-        assertThat(textView.getText()).isEqualTo("texttext");
-        assertThat(callToActionView.getText()).isEqualTo("cta");
-        verify(mockImageLoader).get(eq("mainimageurl"), mainImageCaptor.capture());
-        verify(mockImageLoader).get(eq("iconimageurl"), iconImageCaptor.capture());
-
-        stub(mockImageContainer.getBitmap()).toReturn(mockBitmap);
-        mainImageCaptor.getValue().onResponse(mockImageContainer, true);
-        iconImageCaptor.getValue().onResponse(mockImageContainer, true);
-
-        assertThat(((BitmapDrawable) mainImageView.getDrawable()).getBitmap()).isEqualTo(mockBitmap);
-        assertThat(((BitmapDrawable) iconImageView.getDrawable()).getBitmap()).isEqualTo(mockBitmap);
-
-        assertThat(((BitmapDrawable) daaIconImageView.getDrawable()).getBitmap().describeContents())
-                .isEqualTo(Drawables.NATIVE_DAA_ICON.getBitmap().describeContents());
-
-        daaIconImageView.performClick();
-        final Intent nextActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
-        assertThat(nextActivity.getComponent().getClassName()).isEqualTo(
-                "com.mopub.common.MoPubBrowser");
-        assertThat(nextActivity.getStringExtra("URL")).isEqualTo(
-                MoPubCustomEventNative.MoPubForwardingNativeAd.DAA_CLICKTHROUGH_URL + "/");
-    }
-
-    @Test
-    public void update_withMissingNativeResponseFields_shouldClearPreviousValues() throws Exception {
-        // Set previous values that should be cleared
-        titleView.setText("previoustitletext");
-        textView.setText("previoustexttext");
-        callToActionView.setText("previousctatext");
-        mainImageView.setImageBitmap(
-                BitmapFactory.decodeByteArray("previousmainimagedata".getBytes(), 0,
-                        "previousmainimagedata".getBytes().length));
-        iconImageView.setImageBitmap(
-                BitmapFactory.decodeByteArray("previousiconimagedata".getBytes(), 0,
-                        "previousiconimagedata".getBytes().length));
-
-        // Only required fields in native response
-        nativeResponse = new NativeResponse(context,
-                IMPRESSION_URL, CLICK_URL, AD_UNIT_ID, mock(BaseForwardingNativeAd.class), null);
-
-        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
-                .titleId(titleView.getId())
-                .textId(textView.getId())
-                .callToActionId(callToActionView.getId())
-                .mainImageId(mainImageView.getId())
-                .iconImageId(iconImageView.getId())
-                .build();
-
-        NativeViewHolder nativeViewHolder =
-                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
-
-        nativeViewHolder.update(nativeResponse);
-
-        assertThat(titleView.getText()).isEqualTo("");
-        assertThat(textView.getText()).isEqualTo("");
-        assertThat(callToActionView.getText()).isEqualTo("");
-        assertThat(mainImageView.getDrawable()).isNull();
-        assertThat(iconImageView.getDrawable()).isNull();
-    }
-
-    @Test
-    public void update_withDifferentViewBinder_shouldNotClearPreviousValues() throws Exception {
-        // Set previous values that should be cleared
-        titleView.setText("previoustitletext");
-        textView.setText("previoustexttext");
-
-        BaseForwardingNativeAd nativeAd = new BaseForwardingNativeAd() {};
-        nativeAd.setCallToAction("cta");
-
-        nativeResponse = new NativeResponse(context,
-                IMPRESSION_URL, CLICK_URL, AD_UNIT_ID, nativeAd, null);
-
-        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
-                .callToActionId(callToActionView.getId())
-                .build();
-
-        NativeViewHolder nativeViewHolder =
-                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
-
-        nativeViewHolder.update(nativeResponse);
-
-        assertThat(titleView.getText()).isEqualTo("previoustitletext");
-        assertThat(textView.getText()).isEqualTo("previoustexttext");
-        assertThat(callToActionView.getText()).isEqualTo("cta");
-    }
-
-    @Test
-    public void update_withValidDaaIcon_thenWithNoDaaIcon_shouldRemoveDaaIcon() {
-        BaseForwardingNativeAd nativeAd = new BaseForwardingNativeAd() {
-            @Override
-            public String getDaaIconClickthroughUrl() {
-                return MoPubCustomEventNative.MoPubForwardingNativeAd.DAA_CLICKTHROUGH_URL;
-            }
-        };
-        nativeResponse = new NativeResponse(context,
-                IMPRESSION_URL, CLICK_URL, AD_UNIT_ID, nativeAd, null);
-        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
-                .titleId(titleView.getId())
-                .textId(textView.getId())
-                .callToActionId(callToActionView.getId())
-                .mainImageId(mainImageView.getId())
-                .iconImageId(iconImageView.getId())
-                .daaIconImageId(daaIconImageView.getId())
-                .build();
-        NativeViewHolder nativeViewHolder =
-                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
-
-        nativeViewHolder.update(nativeResponse);
-
-        assertThat(((BitmapDrawable) daaIconImageView.getDrawable()).getBitmap().describeContents())
-                .isEqualTo(Drawables.NATIVE_DAA_ICON.getBitmap().describeContents());
-        assertThat(daaIconImageView.getVisibility()).isEqualTo(View.VISIBLE);
-
-        nativeAd = new BaseForwardingNativeAd() {};
-        nativeResponse = new NativeResponse(context,
-                IMPRESSION_URL, CLICK_URL, AD_UNIT_ID, nativeAd, null);
-
-        nativeViewHolder.update(nativeResponse);
-        daaIconImageView.performClick();
-
-        assertThat(daaIconImageView.getVisibility()).isEqualTo(View.INVISIBLE);
-        assertThat(daaIconImageView.getDrawable()).isNull();
-        assertThat(Robolectric.getShadowApplication().peekNextStartedActivity()).isNull();
-    }
-
-    @Test
-    public void updateExtras_shouldAddValuesToViews() throws Exception {
-        // Setup for cache state for image gets
-
-        BaseForwardingNativeAd nativeAd = new BaseForwardingNativeAd() {};
-        nativeAd.addExtra("extrastext", "extrastexttext");
-        nativeAd.addExtra("extrasimage", "extrasimageurl");
-        nativeAd.addExtra("extrasimage2", "extrasimageurl2");
-
-        nativeResponse = new NativeResponse(context,
-                IMPRESSION_URL, CLICK_URL, AD_UNIT_ID, nativeAd, null);
-
-        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
-                .addExtra("extrastext", extrasTextView.getId())
-                .addExtra("extrasimage", extrasImageView.getId())
-                .addExtra("extrasimage2", extrasImageView2.getId())
-                .build();
-
-        NativeViewHolder nativeViewHolder =
-                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
-
-        nativeViewHolder.updateExtras(nativeResponse, viewBinder);
-
-        assertThat(extrasTextView.getText()).isEqualTo("extrastexttext");
-
-        verify(mockImageLoader).get(eq("extrasimageurl"), mainImageCaptor.capture());
-        verify(mockImageLoader).get(eq("extrasimageurl2"), iconImageCaptor.capture());
-
-        stub(mockImageContainer.getBitmap()).toReturn(mockBitmap);
-        mainImageCaptor.getValue().onResponse(mockImageContainer, true);
-        iconImageCaptor.getValue().onResponse(mockImageContainer, true);
-
-        assertThat(((BitmapDrawable) extrasImageView.getDrawable()).getBitmap()).isEqualTo(mockBitmap);
-        assertThat(((BitmapDrawable) extrasImageView2.getDrawable()).getBitmap()).isEqualTo(mockBitmap);
-    }
-
-    @Test
-    public void updateExtras_withMissingExtrasValues_shouldClearPreviousValues() throws Exception {
-        extrasTextView.setText("previousextrastext");
-        extrasImageView.setImageBitmap(
-                BitmapFactory.decodeByteArray("previousextrasimagedata".getBytes(), 0,
-                        "previousextrasimagedata".getBytes().length));
-        extrasImageView2.setImageBitmap(
-                BitmapFactory.decodeByteArray("previousextrasimagedata2".getBytes(), 0,
-                        "previousextrasimagedata2".getBytes().length));
-
-        nativeResponse = new NativeResponse(context,
-                IMPRESSION_URL, CLICK_URL, AD_UNIT_ID, new BaseForwardingNativeAd(){}, null);
-
-        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
-                .addExtra("extrastext", extrasTextView.getId())
-                .addExtra("extrasimage", extrasImageView.getId())
-                .addExtra("extrasimage2", extrasImageView2.getId())
-                .build();
-
-        NativeViewHolder nativeViewHolder =
-                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
-
-        assertThat(extrasTextView.getText()).isEqualTo("previousextrastext");
-
-        nativeViewHolder.updateExtras(nativeResponse, viewBinder);
-
-        assertThat(extrasTextView.getText()).isEqualTo("");
-        assertThat(extrasImageView.getDrawable()).isNull();
-        assertThat(extrasImageView2.getDrawable()).isNull();
-    }
-
-    @Test
-    public void updateExtras_withMismatchingViewTypes_shouldSetTextViewToImageUrlAndSetExtrasImageViewToNull() throws Exception {
-        BaseForwardingNativeAd nativeAd = new BaseForwardingNativeAd() {};
-        nativeAd.addExtra("extrastext", "extrastexttext");
-        nativeAd.addExtra("extrasimage", "extrasimageurl");
-
-        nativeResponse = new NativeResponse(context,
-                IMPRESSION_URL, CLICK_URL, AD_UNIT_ID, nativeAd, null);
-
-        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
-                .addExtra("extrastext", extrasImageView.getId())
-                .addExtra("extrasimage", extrasTextView.getId())
-                .build();
-
-        NativeViewHolder nativeViewHolder =
-                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
-
-        assertThat(extrasTextView.getText()).isEqualTo("");
-        assertThat(extrasImageView.getDrawable()).isNull();
-
-        nativeViewHolder.updateExtras(nativeResponse, viewBinder);
-
-        // Volley's imageloader will set this to a bitmapdrawable with no bitmap
-        assertThat(extrasTextView.getText()).isEqualTo("extrasimageurl");
-        assertThat(extrasImageView.getDrawable()).isNull();
-    }
-
-    @Test
-    public void fromViewBinder_withMixedViewTypes_shouldReturnEmptyViewHolder() throws Exception {
-        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
-                .titleId(mainImageView.getId())
-                .textId(textView.getId())
-                .build();
-
-        NativeViewHolder nativeViewHolder =
-                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
-        assertThat(nativeViewHolder).isEqualTo(NativeViewHolder.EMPTY_VIEW_HOLDER);
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/PlacementDataTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/PlacementDataTest.java
index bcab2a25..633d1c2b 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/PlacementDataTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/PlacementDataTest.java
@@ -3,6 +3,7 @@
 package com.mopub.nativeads;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 
 import org.junit.Before;
 import org.junit.Test;
@@ -18,9 +19,9 @@
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class PlacementDataTest {
     private PlacementData noAds;
     private PlacementData adAt0;
@@ -31,14 +32,10 @@
     private PlacementData adsRepeating;
     private PlacementData adsAt15repeating;
 
-    @Mock private NativeAdData mockNativeAdData;
-    @Mock private NativeAdData mockNativeAdData2;
-    @Mock private NativeAdData mockNativeAdData3;
-    @Mock private NativeAdData mockNativeAdData4;
-    @Mock private NativeResponse mockNativeResponse;
-    @Mock private NativeResponse mockNativeResponse2;
-    @Mock private NativeResponse mockNativeResponse3;
-    @Mock private NativeResponse mockNativeResponse4;
+    @Mock private NativeAd mMockNativeAd;
+    @Mock private NativeAd mMockNativeAd2;
+    @Mock private NativeAd mMockNativeAd3;
+    @Mock private NativeAd mMockNativeAd4;
 
     @Before
     public void setup() {
@@ -64,11 +61,6 @@ public void setup() {
                 .addFixedPosition(2)
                 .addFixedPosition(3)
                 .addFixedPosition(4));
-
-        when(mockNativeAdData.getAd()).thenReturn(mockNativeResponse);
-        when(mockNativeAdData2.getAd()).thenReturn(mockNativeResponse2);
-        when(mockNativeAdData3.getAd()).thenReturn(mockNativeResponse3);
-        when(mockNativeAdData4.getAd()).thenReturn(mockNativeResponse4);
     }
 
     @Test
@@ -287,15 +279,15 @@ public void placeAds_inOrder_shouldUpdatePositions() {
         checkInsertionPositions(10, adsAt15repeating, 1, 4, 6, 8, 10);
         checkPlacedPositions(20, adsAt15repeating);
 
-        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(1, mMockNativeAd);
         checkInsertionPositions(10, adsAt15repeating, 5, 7, 9);
         checkPlacedPositions(20, adsAt15repeating, 1);
 
-        adsAt15repeating.placeAd(5, mockNativeAdData);
+        adsAt15repeating.placeAd(5, mMockNativeAd);
         checkInsertionPositions(10, adsAt15repeating, 8, 10);
         checkPlacedPositions(20, adsAt15repeating, 1, 5);
 
-        adsAt15repeating.placeAd(8, mockNativeAdData);
+        adsAt15repeating.placeAd(8, mMockNativeAd);
         checkInsertionPositions(10, adsAt15repeating);
         checkPlacedPositions(20, adsAt15repeating, 1, 5, 8);
     }
@@ -305,24 +297,24 @@ public void placeAds_outOfOrder_shouldUpdatePositions() {
         checkInsertionPositions(10, adsAt15repeating, 1, 4, 6, 8, 10);
         checkPlacedPositions(20, adsAt15repeating);
 
-        adsAt15repeating.placeAd(6, mockNativeAdData);
+        adsAt15repeating.placeAd(6, mMockNativeAd);
         checkInsertionPositions(10, adsAt15repeating, 1, 4, 9);
         checkPlacedPositions(20, adsAt15repeating, 6);
 
-        adsAt15repeating.placeAd(4, mockNativeAdData);
+        adsAt15repeating.placeAd(4, mMockNativeAd);
         checkInsertionPositions(10, adsAt15repeating, 1, 10);
         checkPlacedPositions(20, adsAt15repeating, 4, 7);
 
-        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(1, mMockNativeAd);
         checkInsertionPositions(10, adsAt15repeating);
         checkPlacedPositions(20, adsAt15repeating, 1, 5, 8);
     }
 
     @Test
     public void placedAds_getOriginalPositionAndCount() {
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        adsAt15repeating.placeAd(5, mockNativeAdData);
-        adsAt15repeating.placeAd(8, mockNativeAdData);
+        adsAt15repeating.placeAd(1, mMockNativeAd);
+        adsAt15repeating.placeAd(5, mMockNativeAd);
+        adsAt15repeating.placeAd(8, mMockNativeAd);
 
         assertThat(adsAt15repeating.getOriginalPosition(0)).isEqualTo(0);
         assertThat(adsAt15repeating.getOriginalPosition(1)).isEqualTo(NOT_FOUND);
@@ -343,9 +335,9 @@ public void placedAds_getOriginalPositionAndCount() {
 
     @Test
     public void placedAds_getAdjustedPositionAndCount() {
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        adsAt15repeating.placeAd(5, mockNativeAdData);
-        adsAt15repeating.placeAd(8, mockNativeAdData);
+        adsAt15repeating.placeAd(1, mMockNativeAd);
+        adsAt15repeating.placeAd(5, mMockNativeAd);
+        adsAt15repeating.placeAd(8, mMockNativeAd);
 
         assertThat(adsAt15repeating.getAdjustedPosition(0)).isEqualTo(0);
         // Ad here
@@ -370,122 +362,122 @@ public void placedAds_getAdjustedPositionAndCount() {
     @Test
     public void placeAdsClumped_shouldPlaceAdsInOrder() {
         int nextPosition = adsAt1234.nextInsertionPosition(0);
-        adsAt1234.placeAd(nextPosition, mockNativeAdData);
+        adsAt1234.placeAd(nextPosition, mMockNativeAd);
 
         nextPosition = adsAt1234.nextInsertionPosition(nextPosition);
-        adsAt1234.placeAd(nextPosition, mockNativeAdData2);
+        adsAt1234.placeAd(nextPosition, mMockNativeAd2);
 
         nextPosition = adsAt1234.nextInsertionPosition(nextPosition);
-        adsAt1234.placeAd(nextPosition, mockNativeAdData3);
+        adsAt1234.placeAd(nextPosition, mMockNativeAd3);
 
         nextPosition = adsAt1234.nextInsertionPosition(nextPosition);
-        adsAt1234.placeAd(nextPosition, mockNativeAdData4);
+        adsAt1234.placeAd(nextPosition, mMockNativeAd4);
 
         nextPosition = adsAt1234.nextInsertionPosition(nextPosition);
         assertThat(nextPosition).isEqualTo(NOT_FOUND);
 
         assertThat(adsAt1234.isPlacedAd(0)).isFalse();
-        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mockNativeAdData);
-        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mockNativeAdData2);
-        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData3);
-        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mockNativeAdData4);
+        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mMockNativeAd);
+        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mMockNativeAd2);
+        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mMockNativeAd3);
+        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mMockNativeAd4);
         assertThat(adsAt1234.isPlacedAd(5)).isFalse();
     }
 
     @Test
     public void placeAdsClumped_thenRemoveContentBeforeClumpedAds_shouldShiftAds() {
-        adsAt1234.placeAd(1, mockNativeAdData);
-        adsAt1234.placeAd(2, mockNativeAdData2);
-        adsAt1234.placeAd(3, mockNativeAdData3);
-        adsAt1234.placeAd(4, mockNativeAdData4);
+        adsAt1234.placeAd(1, mMockNativeAd);
+        adsAt1234.placeAd(2, mMockNativeAd2);
+        adsAt1234.placeAd(3, mMockNativeAd3);
+        adsAt1234.placeAd(4, mMockNativeAd4);
 
         adsAt1234.removeItem(0);
-        assertThat(adsAt1234.getPlacedAd(0)).isEqualTo(mockNativeAdData);
-        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mockNativeAdData2);
-        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mockNativeAdData3);
-        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData4);
+        assertThat(adsAt1234.getPlacedAd(0)).isEqualTo(mMockNativeAd);
+        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mMockNativeAd2);
+        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mMockNativeAd3);
+        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mMockNativeAd4);
         assertThat(adsAt1234.isPlacedAd(4)).isFalse();
 
         adsAt1234.removeItem(0);
-        assertThat(adsAt1234.getPlacedAd(0)).isEqualTo(mockNativeAdData);
-        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mockNativeAdData2);
-        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mockNativeAdData3);
-        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData4);
+        assertThat(adsAt1234.getPlacedAd(0)).isEqualTo(mMockNativeAd);
+        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mMockNativeAd2);
+        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mMockNativeAd3);
+        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mMockNativeAd4);
         assertThat(adsAt1234.isPlacedAd(4)).isFalse();
     }
 
     @Test
     public void placeAdsClumped_thenRemoveContentAfterClumpedAds_shouldNotShiftAds() {
-        adsAt1234.placeAd(1, mockNativeAdData);
-        adsAt1234.placeAd(2, mockNativeAdData2);
-        adsAt1234.placeAd(3, mockNativeAdData3);
-        adsAt1234.placeAd(4, mockNativeAdData4);
+        adsAt1234.placeAd(1, mMockNativeAd);
+        adsAt1234.placeAd(2, mMockNativeAd2);
+        adsAt1234.placeAd(3, mMockNativeAd3);
+        adsAt1234.placeAd(4, mMockNativeAd4);
 
         adsAt1234.removeItem(1);
         assertThat(adsAt1234.isPlacedAd(0)).isFalse();
-        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mockNativeAdData);
-        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mockNativeAdData2);
-        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData3);
-        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mockNativeAdData4);
+        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mMockNativeAd);
+        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mMockNativeAd2);
+        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mMockNativeAd3);
+        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mMockNativeAd4);
         assertThat(adsAt1234.isPlacedAd(5)).isFalse();
 
         adsAt1234.removeItem(2);
         assertThat(adsAt1234.isPlacedAd(0)).isFalse();
-        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mockNativeAdData);
-        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mockNativeAdData2);
-        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData3);
-        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mockNativeAdData4);
+        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mMockNativeAd);
+        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mMockNativeAd2);
+        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mMockNativeAd3);
+        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mMockNativeAd4);
         assertThat(adsAt1234.isPlacedAd(5)).isFalse();
     }
 
     @Test
     public void placeAdsClumped_thenInsertContentBeforeClumpedAds_shouldShiftAds() {
-        adsAt1234.placeAd(1, mockNativeAdData);
-        adsAt1234.placeAd(2, mockNativeAdData2);
-        adsAt1234.placeAd(3, mockNativeAdData3);
-        adsAt1234.placeAd(4, mockNativeAdData4);
+        adsAt1234.placeAd(1, mMockNativeAd);
+        adsAt1234.placeAd(2, mMockNativeAd2);
+        adsAt1234.placeAd(3, mMockNativeAd3);
+        adsAt1234.placeAd(4, mMockNativeAd4);
 
         adsAt1234.insertItem(1);
         assertThat(adsAt1234.isPlacedAd(0)).isFalse();
         assertThat(adsAt1234.isPlacedAd(1)).isFalse();
-        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mockNativeAdData);
-        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData2);
-        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mockNativeAdData3);
-        assertThat(adsAt1234.getPlacedAd(5)).isEqualTo(mockNativeAdData4);
+        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mMockNativeAd);
+        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mMockNativeAd2);
+        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mMockNativeAd3);
+        assertThat(adsAt1234.getPlacedAd(5)).isEqualTo(mMockNativeAd4);
         assertThat(adsAt1234.isPlacedAd(6)).isFalse();
 
         adsAt1234.insertItem(0);
         assertThat(adsAt1234.isPlacedAd(0)).isFalse();
         assertThat(adsAt1234.isPlacedAd(1)).isFalse();
         assertThat(adsAt1234.isPlacedAd(2)).isFalse();
-        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData);
-        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mockNativeAdData2);
-        assertThat(adsAt1234.getPlacedAd(5)).isEqualTo(mockNativeAdData3);
-        assertThat(adsAt1234.getPlacedAd(6)).isEqualTo(mockNativeAdData4);
+        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mMockNativeAd);
+        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mMockNativeAd2);
+        assertThat(adsAt1234.getPlacedAd(5)).isEqualTo(mMockNativeAd3);
+        assertThat(adsAt1234.getPlacedAd(6)).isEqualTo(mMockNativeAd4);
         assertThat(adsAt1234.isPlacedAd(7)).isFalse();
     }
 
     @Test
     public void placeAdsClumped_thenInsertContentAfterClumpedAds_shouldNotShiftAds() {
-        adsAt1234.placeAd(1, mockNativeAdData);
-        adsAt1234.placeAd(2, mockNativeAdData2);
-        adsAt1234.placeAd(3, mockNativeAdData3);
-        adsAt1234.placeAd(4, mockNativeAdData4);
+        adsAt1234.placeAd(1, mMockNativeAd);
+        adsAt1234.placeAd(2, mMockNativeAd2);
+        adsAt1234.placeAd(3, mMockNativeAd3);
+        adsAt1234.placeAd(4, mMockNativeAd4);
 
         adsAt1234.insertItem(2);
         assertThat(adsAt1234.isPlacedAd(0)).isFalse();
-        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mockNativeAdData);
-        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mockNativeAdData2);
-        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData3);
-        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mockNativeAdData4);
+        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mMockNativeAd);
+        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mMockNativeAd2);
+        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mMockNativeAd3);
+        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mMockNativeAd4);
         assertThat(adsAt1234.isPlacedAd(5)).isFalse();
 
         adsAt1234.removeItem(3);
         assertThat(adsAt1234.isPlacedAd(0)).isFalse();
-        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mockNativeAdData);
-        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mockNativeAdData2);
-        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData3);
-        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mockNativeAdData4);
+        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mMockNativeAd);
+        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mMockNativeAd2);
+        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mMockNativeAd3);
+        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mMockNativeAd4);
         assertThat(adsAt1234.isPlacedAd(5)).isFalse();
     }
 
@@ -499,9 +491,9 @@ public void placedAds_thenClearEmptyRange_doesNothing() {
         checkPlacedPositions(15, adsAt15repeating);
         checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
 
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        adsAt15repeating.placeAd(5, mockNativeAdData);
-        adsAt15repeating.placeAd(8, mockNativeAdData);
+        adsAt15repeating.placeAd(1, mMockNativeAd);
+        adsAt15repeating.placeAd(5, mMockNativeAd);
+        adsAt15repeating.placeAd(8, mMockNativeAd);
         checkPlacedPositions(15, adsAt15repeating, 1, 5, 8);
         checkInsertionPositions(15, adsAt15repeating, 11, 13, 15);
 
@@ -515,9 +507,9 @@ public void placedAds_thenClearAll_shouldResetInsertionPositions() {
         checkPlacedPositions(15, adsAt15repeating);
         checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
 
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        adsAt15repeating.placeAd(5, mockNativeAdData);
-        adsAt15repeating.placeAd(8, mockNativeAdData);
+        adsAt15repeating.placeAd(1, mMockNativeAd);
+        adsAt15repeating.placeAd(5, mMockNativeAd);
+        adsAt15repeating.placeAd(8, mMockNativeAd);
         checkPlacedPositions(15, adsAt15repeating, 1, 5, 8);
         checkInsertionPositions(15, adsAt15repeating, 11, 13, 15);
 
@@ -531,9 +523,9 @@ public void placedAds_thenClearRange_inOrder_shouldResetInsertionPositions() {
         checkPlacedPositions(15, adsAt15repeating);
         checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
 
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        adsAt15repeating.placeAd(5, mockNativeAdData);
-        adsAt15repeating.placeAd(8, mockNativeAdData);
+        adsAt15repeating.placeAd(1, mMockNativeAd);
+        adsAt15repeating.placeAd(5, mMockNativeAd);
+        adsAt15repeating.placeAd(8, mMockNativeAd);
         checkPlacedPositions(15, adsAt15repeating, 1, 5, 8);
         checkInsertionPositions(15, adsAt15repeating, 11, 13, 15);
 
@@ -555,9 +547,9 @@ public void placedAds_thenClearRange_descending_shouldResetInsertionPositions()
         checkPlacedPositions(15, adsAt15repeating);
         checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
 
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        adsAt15repeating.placeAd(5, mockNativeAdData);
-        adsAt15repeating.placeAd(8, mockNativeAdData);
+        adsAt15repeating.placeAd(1, mMockNativeAd);
+        adsAt15repeating.placeAd(5, mMockNativeAd);
+        adsAt15repeating.placeAd(8, mMockNativeAd);
         checkPlacedPositions(15, adsAt15repeating, 1, 5, 8);
         checkInsertionPositions(15, adsAt15repeating, 11, 13, 15);
 
@@ -579,9 +571,9 @@ public void placedAds_thenClearRange_multiple_shouldResetInsertionPositions() {
         checkPlacedPositions(15, adsAt15repeating);
         checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
 
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        adsAt15repeating.placeAd(5, mockNativeAdData);
-        adsAt15repeating.placeAd(8, mockNativeAdData);
+        adsAt15repeating.placeAd(1, mMockNativeAd);
+        adsAt15repeating.placeAd(5, mMockNativeAd);
+        adsAt15repeating.placeAd(8, mMockNativeAd);
         checkPlacedPositions(15, adsAt15repeating, 1, 5, 8);
         checkInsertionPositions(15, adsAt15repeating, 11, 13, 15);
 
@@ -599,9 +591,9 @@ public void placedAds_thenClearRange_descending_multiple_shouldResetInsertionPos
         checkPlacedPositions(15, adsAt15repeating);
         checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
 
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        adsAt15repeating.placeAd(5, mockNativeAdData);
-        adsAt15repeating.placeAd(8, mockNativeAdData);
+        adsAt15repeating.placeAd(1, mMockNativeAd);
+        adsAt15repeating.placeAd(5, mMockNativeAd);
+        adsAt15repeating.placeAd(8, mMockNativeAd);
         checkPlacedPositions(15, adsAt15repeating, 1, 5, 8);
         checkInsertionPositions(15, adsAt15repeating, 11, 13, 15);
 
@@ -616,21 +608,21 @@ public void placedAds_thenClearRange_descending_multiple_shouldResetInsertionPos
 
     @Test
     public void placeAds_thenClear_shouldCallDestroy() {
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        adsAt15repeating.placeAd(5, mockNativeAdData2);
-        adsAt15repeating.placeAd(8, mockNativeAdData3);
+        adsAt15repeating.placeAd(1, mMockNativeAd);
+        adsAt15repeating.placeAd(5, mMockNativeAd2);
+        adsAt15repeating.placeAd(8, mMockNativeAd3);
 
         adsAt15repeating.clearAdsInRange(5, 10);
-        verify(mockNativeResponse, never()).destroy();
-        verify(mockNativeResponse2).destroy();
-        verify(mockNativeResponse3).destroy();
+        verify(mMockNativeAd, never()).destroy();
+        verify(mMockNativeAd2).destroy();
+        verify(mMockNativeAd3).destroy();
     }
 
     @Test
     public void insertItems_afterPlacing() {
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        adsAt15repeating.placeAd(5, mockNativeAdData);
-        adsAt15repeating.placeAd(8, mockNativeAdData);
+        adsAt15repeating.placeAd(1, mMockNativeAd);
+        adsAt15repeating.placeAd(5, mMockNativeAd);
+        adsAt15repeating.placeAd(8, mMockNativeAd);
 
         adsAt15repeating.insertItem(1);
         adsAt15repeating.insertItem(4);
@@ -651,9 +643,9 @@ public void insertItems_beforePlacing() {
 
     @Test
     public void removeThenInsertItem_atZero_shouldBeAtZero() {
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        adsAt15repeating.placeAd(5, mockNativeAdData);
-        adsAt15repeating.placeAd(8, mockNativeAdData);
+        adsAt15repeating.placeAd(1, mMockNativeAd);
+        adsAt15repeating.placeAd(5, mMockNativeAd);
+        adsAt15repeating.placeAd(8, mMockNativeAd);
 
         adsAt15repeating.removeItem(0);
         checkPlacedPositions(20, adsAt15repeating, 0, 4, 7);
@@ -666,18 +658,18 @@ public void removeThenInsertItem_atZero_shouldBeAtZero() {
 
     @Test
     public void placeThenInsertThenPlace() {
-        adsAt15repeating.placeAd(4, mockNativeAdData);
+        adsAt15repeating.placeAd(4, mMockNativeAd);
         adsAt15repeating.insertItem(4);
-        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(1, mMockNativeAd);
 
         checkPlacedPositions(20, adsAt15repeating, 1, 6);
     }
 
     @Test
     public void removeItems_afterPlacing() {
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        adsAt15repeating.placeAd(5, mockNativeAdData);
-        adsAt15repeating.placeAd(8, mockNativeAdData);
+        adsAt15repeating.placeAd(1, mMockNativeAd);
+        adsAt15repeating.placeAd(5, mMockNativeAd);
+        adsAt15repeating.placeAd(8, mMockNativeAd);
 
         checkPlacedPositions(20, adsAt15repeating, 1, 5, 8);
 
@@ -697,9 +689,9 @@ public void removeItems_afterPlacing() {
 
     @Test
     public void removeItemsBetweenAds_thenInsert_shouldClumpAds() {
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        adsAt15repeating.placeAd(5, mockNativeAdData);
-        adsAt15repeating.placeAd(8, mockNativeAdData);
+        adsAt15repeating.placeAd(1, mMockNativeAd);
+        adsAt15repeating.placeAd(5, mMockNativeAd);
+        adsAt15repeating.placeAd(8, mMockNativeAd);
 
         adsAt15repeating.removeItem(4);
         adsAt15repeating.removeItem(4);
@@ -727,9 +719,9 @@ public void removeItems_beforePlacing() {
 
     @Test
     public void removeItem_withClumpedAdsBeforeIt_shouldCorrectlyRemoveItem() throws Exception {
-        adsRepeating.placeAd(2, mockNativeAdData);
-        adsRepeating.placeAd(5, mockNativeAdData);
-        adsRepeating.placeAd(8, mockNativeAdData);
+        adsRepeating.placeAd(2, mMockNativeAd);
+        adsRepeating.placeAd(5, mMockNativeAd);
+        adsRepeating.placeAd(8, mMockNativeAd);
 
         checkPlacedPositions(20, adsRepeating, 2, 5, 8);
         assertThat(adsRepeating.getAdjustedCount(7)).isEqualTo(10);
@@ -751,9 +743,9 @@ public void removeItem_withClumpedAdsBeforeIt_shouldCorrectlyRemoveItem() throws
 
     @Test
     public void removeItems_afterClumpedAds_shouldStayClumped() {
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        adsAt15repeating.placeAd(5, mockNativeAdData);
-        adsAt15repeating.placeAd(8, mockNativeAdData);
+        adsAt15repeating.placeAd(1, mMockNativeAd);
+        adsAt15repeating.placeAd(5, mMockNativeAd);
+        adsAt15repeating.placeAd(8, mMockNativeAd);
 
         adsAt15repeating.removeItem(4);
         adsAt15repeating.removeItem(4);
@@ -772,9 +764,9 @@ public void removeItems_afterClumpedAds_shouldStayClumped() {
 
     @Test
     public void moveItems_afterPlacing() {
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        adsAt15repeating.placeAd(5, mockNativeAdData);
-        adsAt15repeating.placeAd(8, mockNativeAdData);
+        adsAt15repeating.placeAd(1, mMockNativeAd);
+        adsAt15repeating.placeAd(5, mMockNativeAd);
+        adsAt15repeating.placeAd(8, mMockNativeAd);
 
         assertThat(adsAt15repeating.getAdjustedPosition(4)).isEqualTo(6);
         assertThat(adsAt15repeating.getAdjustedPosition(5)).isEqualTo(7);
@@ -789,19 +781,15 @@ public void moveItems_afterPlacing() {
 
     @Test
     public void clearAll_shouldCallDestroyOnAdData_shouldResetPositions() {
-        when(mockNativeAdData.getAd()).thenReturn(mockNativeResponse);
-        when(mockNativeAdData2.getAd()).thenReturn(mockNativeResponse2);
-        when(mockNativeAdData3.getAd()).thenReturn(mockNativeResponse3);
-
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        adsAt15repeating.placeAd(5, mockNativeAdData2);
-        adsAt15repeating.placeAd(8, mockNativeAdData3);
+        adsAt15repeating.placeAd(1, mMockNativeAd);
+        adsAt15repeating.placeAd(5, mMockNativeAd2);
+        adsAt15repeating.placeAd(8, mMockNativeAd3);
 
         adsAt15repeating.clearAds();
 
-        verify(mockNativeResponse).destroy();
-        verify(mockNativeResponse2).destroy();
-        verify(mockNativeResponse3).destroy();
+        verify(mMockNativeAd).destroy();
+        verify(mMockNativeAd2).destroy();
+        verify(mMockNativeAd3).destroy();
 
         // Should reset to original positions
         checkInsertionPositions(10, adsAt15repeating, 1, 4, 6, 8, 10);
@@ -826,7 +814,7 @@ void checkPlacedPositions(int maxValue, PlacementData placementData, Integer...
         for (int i = 0; i < maxValue; i++) {
             if (placementData.isPlacedAd(i)) {
                 actual.add(i);
-                assertThat(placementData.getPlacedAd(i)).isEqualTo(mockNativeAdData);
+                assertThat(placementData.getPlacedAd(i)).isEqualTo(mMockNativeAd);
             } else {
                 assertThat(placementData.getPlacedAd(i)).isNull();
             }
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/PositioningRequestTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/PositioningRequestTest.java
index c67dd6cf..8cf41406 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/PositioningRequestTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/PositioningRequestTest.java
@@ -1,6 +1,7 @@
 package com.mopub.nativeads;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 import com.mopub.network.MoPubNetworkError;
 import com.mopub.volley.NetworkResponse;
 import com.mopub.volley.Response;
@@ -11,6 +12,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
+import org.robolectric.annotation.Config;
 
 import java.util.TreeMap;
 
@@ -18,6 +20,7 @@
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class PositioningRequestTest {
 
     String url = "http://example.com";
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/ServerPositioningSourceTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/ServerPositioningSourceTest.java
index 824a39bc..b33c03ff 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/ServerPositioningSourceTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/ServerPositioningSourceTest.java
@@ -3,12 +3,12 @@
 import android.app.Activity;
 import android.content.Context;
 import android.content.pm.PackageManager;
-import android.os.Build.VERSION_CODES;
 
 import com.mopub.common.ClientMetadata;
 import com.mopub.common.DownloadResponse;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 import com.mopub.mobileads.MoPubErrorCode;
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
 import com.mopub.nativeads.PositioningSource.PositioningListener;
@@ -44,6 +44,7 @@
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class ServerPositioningSourceTest {
     @Mock PositioningListener mockPositioningListener;
     @Captor ArgumentCaptor<PositioningRequest> positionRequestCaptor;
@@ -65,8 +66,6 @@ public void setUp() {
         Activity activity = Robolectric.buildActivity(Activity.class).create().get();
         spyActivity = spy(activity);
 
-
-
         subject = new ServerPositioningSource(spyActivity);
         setupClientMetadata();
         Networking.setRequestQueueForTesting(mockRequestQueue);
@@ -146,22 +145,21 @@ public void loadPositions_thenComplete_withValidResponse_shouldCallOnLoadListene
         verify(mockPositioningListener).onLoad(eq(response));
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void loadPositions_thenComplete_withErrorResponse_shouldRetry() throws Exception {
         subject.loadPositions("test_ad_unit", mockPositioningListener);
 
         verify(mockRequestQueue).add(positionRequestCaptor.capture());
         reset(mockRequestQueue);
+
         // We get VolleyErrors for invalid JSON, 404s, 5xx, and {"error": "WARMING_UP"}
         positionRequestCaptor.getValue().deliverError(new VolleyError("Some test error"));
 
-        Robolectric.getUiThreadScheduler().advanceToLastPostedRunnable();
+        Robolectric.getForegroundThreadScheduler().advanceToLastPostedRunnable();
         verify(mockRequestQueue).add(any(Request.class));
     }
 
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void loadPositions_withPendingRetry_shouldNotRetry() {
         subject.loadPositions("test_ad_unit", mockPositioningListener);
@@ -171,7 +169,7 @@ public void loadPositions_withPendingRetry_shouldNotRetry() {
         positionRequestCaptor.getValue().deliverError(new VolleyError("testError"));
 
         subject.loadPositions("test_ad_unit", mockPositioningListener);
-        Robolectric.getUiThreadScheduler().advanceToLastPostedRunnable();
+        Robolectric.getForegroundThreadScheduler().advanceToLastPostedRunnable();
         // If a retry happened, we'd have two here.
         verify(mockRequestQueue).add(any(Request.class));
     }
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/BaseForwardingNativeAdTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/StaticNativeAdTest.java
similarity index 56%
rename from mopub-sdk/src/test/java/com/mopub/nativeads/BaseForwardingNativeAdTest.java
rename to mopub-sdk/src/test/java/com/mopub/nativeads/StaticNativeAdTest.java
index d9d5a191..22a34c85 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/BaseForwardingNativeAdTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/StaticNativeAdTest.java
@@ -1,29 +1,59 @@
 package com.mopub.nativeads;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(SdkTestRunner.class)
-public class BaseForwardingNativeAdTest {
+@Config(constants = BuildConfig.class)
+public class StaticNativeAdTest {
 
-    private BaseForwardingNativeAd subject;
+    private StaticNativeAd subject;
 
     @Before
     public void setUp() throws Exception {
-        subject = new BaseForwardingNativeAd() {};
+        subject = new StaticNativeAd() {};
+
+        subject.setTitle("title");
+        subject.setText("text");
+        subject.setMainImageUrl("mainImageUrl");
+        subject.setIconImageUrl("iconImageUrl");
+        subject.setClickDestinationUrl("clickDestinationUrl");
+        subject.setCallToAction("callToAction");
+        subject.setStarRating(5.0);
+        subject.setPrivacyInformationIconClickThroughUrl("privacyInformationIconClickThroughUrl");
+        subject.setPrivacyInformationIconImageUrl("privacyInformationIconImageUrl");
+        subject.addExtra("extra", "extraValue");
+        subject.addExtra("extraImage", "extraImageUrl");
+        subject.addImpressionTracker("impressionUrl");
+        subject.setImpressionMinTimeViewed(500);
     }
 
     @Test
-    public void constructor_shouldInitializeMembers() throws Exception {
+    public void getters_shouldReturnCorrectValues() throws Exception {
+        assertThat(subject.getTitle()).isEqualTo("title");
+        assertThat(subject.getText()).isEqualTo("text");
+        assertThat(subject.getMainImageUrl()).isEqualTo("mainImageUrl");
+        assertThat(subject.getIconImageUrl()).isEqualTo("iconImageUrl");
+        assertThat(subject.getClickDestinationUrl()).isEqualTo("clickDestinationUrl");
+        assertThat(subject.getCallToAction()).isEqualTo("callToAction");
+        assertThat(subject.getStarRating()).isEqualTo(5.0);
+        assertThat(subject.getPrivacyInformationIconClickThroughUrl()).isEqualTo(
+                "privacyInformationIconClickThroughUrl");
+        assertThat(subject.getPrivacyInformationIconImageUrl()).isEqualTo
+                ("privacyInformationIconImageUrl");
+        assertThat(subject.getExtra("extra")).isEqualTo("extraValue");
+        assertThat(subject.getExtra("extraImage")).isEqualTo("extraImageUrl");
+        assertThat(subject.getExtras()).hasSize(2);
+        assertThat(subject.getImpressionTrackers()).containsOnly("impressionUrl");
+        assertThat(subject.getImpressionMinTimeViewed()).isEqualTo(500);
         assertThat(subject.getImpressionMinPercentageViewed()).isEqualTo(50);
-        assertThat(subject.getImpressionMinTimeViewed()).isEqualTo(1000);
-        assertThat(subject.getImpressionTrackers()).isEmpty();
-        assertThat(subject.getExtras()).isEmpty();
     }
 
     @Test
@@ -91,4 +121,13 @@ public void setStarRating_withValuesOutsideOfValidRange_shouldNotSetStarRating()
         subject.setStarRating(-0.001);
         assertThat(subject.getStarRating()).isEqualTo(initialStarRating);
     }
+
+    @Test
+    public void isImpressionRecorded_withRecordedImpression_shouldReturnTrue() throws Exception {
+        assertThat(subject.isImpressionRecorded()).isFalse();
+
+        subject.setImpressionRecorded();
+
+        assertThat(subject.isImpressionRecorded()).isTrue();
+    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/StaticNativeViewHolderTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/StaticNativeViewHolderTest.java
new file mode 100644
index 00000000..349dcf82
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/StaticNativeViewHolderTest.java
@@ -0,0 +1,157 @@
+package com.mopub.nativeads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.widget.Button;
+import android.widget.ImageView;
+import android.widget.RelativeLayout;
+import android.widget.TextView;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.Utils;
+import com.mopub.mobileads.BuildConfig;
+import com.mopub.network.MaxWidthImageLoader;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.volley.toolbox.ImageLoader;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Captor;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class StaticNativeViewHolderTest {
+    private Context context;
+    private RelativeLayout relativeLayout;
+    private ViewBinder viewBinder;
+    private TextView titleView;
+    private TextView textView;
+    private TextView callToActionView;
+    private ImageView mainImageView;
+    private ImageView iconImageView;
+    private TextView extrasTextView;
+    private ImageView extrasImageView;
+    private ImageView extrasImageView2;
+    private ImageView privacyInformationIconImageView;
+
+    @Mock private MoPubRequestQueue mockRequestQueue;
+    @Mock private MaxWidthImageLoader mockImageLoader;
+    @Mock private ImageLoader.ImageContainer mockImageContainer;
+    @Mock private Bitmap mockBitmap;
+
+    @Captor private ArgumentCaptor<ImageLoader.ImageListener> mainImageCaptor;
+    @Captor private ArgumentCaptor<ImageLoader.ImageListener> iconImageCaptor;
+
+    @Before
+    public void setUp() throws Exception {
+
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+        Networking.setImageLoaderForTesting(mockImageLoader);
+        context = Robolectric.buildActivity(Activity.class).create().get();
+        relativeLayout = new RelativeLayout(context);
+        relativeLayout.setId((int) Utils.generateUniqueId());
+
+        // Fields in the web ui
+        titleView = new TextView(context);
+        titleView.setId((int) Utils.generateUniqueId());
+        textView = new TextView(context);
+        textView.setId((int) Utils.generateUniqueId());
+        callToActionView = new Button(context);
+        callToActionView.setId((int) Utils.generateUniqueId());
+        mainImageView = new ImageView(context);
+        mainImageView.setId((int) Utils.generateUniqueId());
+        iconImageView = new ImageView(context);
+        iconImageView.setId((int) Utils.generateUniqueId());
+        privacyInformationIconImageView = new ImageView(context);
+        privacyInformationIconImageView.setId((int) Utils.generateUniqueId());
+
+        // Extras
+        extrasTextView = new TextView(context);
+        extrasTextView.setId((int) Utils.generateUniqueId());
+        extrasImageView = new ImageView(context);
+        extrasImageView.setId((int) Utils.generateUniqueId());
+        extrasImageView2 = new ImageView(context);
+        extrasImageView2.setId((int) Utils.generateUniqueId());
+
+        relativeLayout.addView(titleView);
+        relativeLayout.addView(textView);
+        relativeLayout.addView(callToActionView);
+        relativeLayout.addView(mainImageView);
+        relativeLayout.addView(iconImageView);
+        relativeLayout.addView(extrasTextView);
+        relativeLayout.addView(extrasImageView);
+        relativeLayout.addView(extrasImageView2);
+        relativeLayout.addView(privacyInformationIconImageView);
+    }
+
+    @Test
+    public void fromViewBinder_shouldPopulateClassFields() throws Exception {
+        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
+                .titleId(titleView.getId())
+                .textId(textView.getId())
+                .callToActionId(callToActionView.getId())
+                .mainImageId(mainImageView.getId())
+                .iconImageId(iconImageView.getId())
+                .privacyInformationIconImageId(privacyInformationIconImageView.getId())
+                .build();
+
+        StaticNativeViewHolder staticNativeViewHolder =
+                StaticNativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
+
+        assertThat(staticNativeViewHolder.titleView).isEqualTo(titleView);
+        assertThat(staticNativeViewHolder.textView).isEqualTo(textView);
+        assertThat(staticNativeViewHolder.callToActionView).isEqualTo(callToActionView);
+        assertThat(staticNativeViewHolder.mainImageView).isEqualTo(mainImageView);
+        assertThat(staticNativeViewHolder.iconImageView).isEqualTo(iconImageView);
+        assertThat(staticNativeViewHolder.privacyInformationIconImageView).isEqualTo(
+                privacyInformationIconImageView);
+    }
+
+    @Test
+    public void fromViewBinder_withSubsetOfFields_shouldLeaveOtherFieldsNull() throws Exception {
+        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
+                .titleId(titleView.getId())
+                .iconImageId(iconImageView.getId())
+                .build();
+
+        StaticNativeViewHolder staticNativeViewHolder =
+                StaticNativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
+
+        assertThat(staticNativeViewHolder.titleView).isEqualTo(titleView);
+        assertThat(staticNativeViewHolder.textView).isNull();
+        assertThat(staticNativeViewHolder.callToActionView).isNull();
+        assertThat(staticNativeViewHolder.mainImageView).isNull();
+        assertThat(staticNativeViewHolder.iconImageView).isEqualTo(iconImageView);
+        assertThat(staticNativeViewHolder.privacyInformationIconImageView).isNull();
+    }
+
+    @Test
+    public void fromViewBinder_withNonExistantIds_shouldLeaveFieldsNull() throws Exception {
+        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
+                .titleId((int) Utils.generateUniqueId())
+                .textId((int) Utils.generateUniqueId())
+                .callToActionId((int) Utils.generateUniqueId())
+                .mainImageId((int) Utils.generateUniqueId())
+                .iconImageId((int) Utils.generateUniqueId())
+                .build();
+
+        StaticNativeViewHolder staticNativeViewHolder =
+                StaticNativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
+
+        assertThat(staticNativeViewHolder.titleView).isNull();
+        assertThat(staticNativeViewHolder.textView).isNull();
+        assertThat(staticNativeViewHolder.callToActionView).isNull();
+        assertThat(staticNativeViewHolder.mainImageView).isNull();
+        assertThat(staticNativeViewHolder.iconImageView).isNull();
+        assertThat(staticNativeViewHolder.privacyInformationIconImageView).isNull();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/VideoNativeAdTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/VideoNativeAdTest.java
new file mode 100644
index 00000000..8c271a6d
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/VideoNativeAdTest.java
@@ -0,0 +1,64 @@
+package com.mopub.nativeads;
+
+import android.annotation.TargetApi;
+import android.os.Build;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class VideoNativeAdTest {
+
+    private VideoNativeAd subject;
+
+    @Before
+    public void setUp() {
+        subject = new VideoNativeAd() {
+            @Override
+            public void onStateChanged(boolean playWhenReady, int playbackState) { }
+
+            @Override
+            public void onError(Exception e) { }
+        };
+
+        subject.setTitle("title");
+        subject.setText("text");
+        subject.setMainImageUrl("mainImageUrl");
+        subject.setIconImageUrl("iconImageUrl");
+        subject.setClickDestinationUrl("clickDestinationUrl");
+        subject.setVastVideo("vastVideo");
+        subject.setCallToAction("callToAction");
+        subject.setPrivacyInformationIconClickThroughUrl("privacyInformationIconClickThroughUrl");
+        subject.setPrivacyInformationIconImageUrl("privacyInformationIconImageUrl");
+        subject.addExtra("extra", "extraValue");
+        subject.addExtra("extraImage", "extraImageUrl");
+        subject.addImpressionTracker("impressionUrl");
+    }
+
+    @Test
+    public void getters_shouldReturnCorrectValues() {
+        assertThat(subject.getTitle()).isEqualTo("title");
+        assertThat(subject.getText()).isEqualTo("text");
+        assertThat(subject.getMainImageUrl()).isEqualTo("mainImageUrl");
+        assertThat(subject.getIconImageUrl()).isEqualTo("iconImageUrl");
+        assertThat(subject.getClickDestinationUrl()).isEqualTo("clickDestinationUrl");
+        assertThat(subject.getCallToAction()).isEqualTo("callToAction");
+        assertThat(subject.getPrivacyInformationIconClickThroughUrl()).isEqualTo(
+                "privacyInformationIconClickThroughUrl");
+        assertThat(subject.getPrivacyInformationIconImageUrl()).isEqualTo
+                ("privacyInformationIconImageUrl");
+        assertThat(subject.getExtra("extra")).isEqualTo("extraValue");
+        assertThat(subject.getExtra("extraImage")).isEqualTo("extraImageUrl");
+        assertThat(subject.getExtras()).hasSize(2);
+        assertThat(subject.getImpressionTrackers()).containsOnly("impressionUrl");
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/VisibilityTrackerTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/VisibilityTrackerTest.java
index bee7ae9e..5eb3c14a 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/VisibilityTrackerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/VisibilityTrackerTest.java
@@ -10,6 +10,7 @@
 import android.view.Window;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 import com.mopub.nativeads.VisibilityTracker.TrackingInfo;
 
 import org.fest.util.Lists;
@@ -21,6 +22,7 @@
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowSystemClock;
 
 import java.util.ArrayList;
@@ -40,6 +42,7 @@
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class VisibilityTrackerTest {
     private static final int MIN_PERCENTAGE_VIEWED = 50;
 
@@ -217,63 +220,63 @@ public void hasRequiredTimeElapsed_withElapsedTimeLessThanMinTimeViewed_shouldRe
     @Test
     public void isMostlyVisible_whenParentIsNull_shouldReturnFalse() throws Exception {
         view = createViewMock(View.VISIBLE, 100, 100, 100, 100, false, true);
-        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isFalse();
+        assertThat(visibilityChecker.isVisible(view, view, MIN_PERCENTAGE_VIEWED)).isFalse();
     }
 
     @Test
     public void isMostlyVisible_whenViewIsOffScreen_shouldReturnFalse() throws Exception {
         view = createViewMock(View.VISIBLE, 100, 100, 100, 100, true, false);
-        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isFalse();
+        assertThat(visibilityChecker.isVisible(view, view, MIN_PERCENTAGE_VIEWED)).isFalse();
     }
 
     @Test
     public void isMostlyVisible_whenViewIsEntirelyOnScreen_shouldReturnTrue() throws Exception {
         view = createViewMock(View.VISIBLE, 100, 100, 100, 100, true, true);
 
-        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isTrue();
+        assertThat(visibilityChecker.isVisible(view, view, MIN_PERCENTAGE_VIEWED)).isTrue();
     }
 
     @Test
     public void isMostlyVisible_whenViewIs50PercentVisible_shouldReturnTrue() throws Exception {
         view = createViewMock(View.VISIBLE, 50, 100, 100, 100, true, true);
 
-        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isTrue();
+        assertThat(visibilityChecker.isVisible(view, view, MIN_PERCENTAGE_VIEWED)).isTrue();
     }
 
     @Test
     public void isMostlyVisible_whenViewIs49PercentVisible_shouldReturnFalse() throws Exception {
         view = createViewMock(View.VISIBLE, 49, 100, 100, 100, true, true);
 
-        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isFalse();
+        assertThat(visibilityChecker.isVisible(view, view, MIN_PERCENTAGE_VIEWED)).isFalse();
     }
 
     @Test
     public void isMostlyVisible_whenVisibleAreaIsZero_shouldReturnFalse() throws Exception {
         view = createViewMock(View.VISIBLE, 0, 0, 100, 100, true, true);
 
-        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isFalse();
+        assertThat(visibilityChecker.isVisible(view, view, MIN_PERCENTAGE_VIEWED)).isFalse();
     }
 
     @Test
     public void isMostlyVisible_whenViewIsInvisibleOrGone_shouldReturnFalse() throws Exception {
         View view = createViewMock(View.INVISIBLE, 100, 100, 100, 100, true, true);
-        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isFalse();
+        assertThat(visibilityChecker.isVisible(view, view, MIN_PERCENTAGE_VIEWED)).isFalse();
 
         reset(view);
         view = createViewMock(View.GONE, 100, 100, 100, 100, true, true);
-        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isFalse();
+        assertThat(visibilityChecker.isVisible(view, view, MIN_PERCENTAGE_VIEWED)).isFalse();
     }
 
     @Test
     public void isMostlyVisible_whenViewHasZeroWidthAndHeight_shouldReturnFalse() throws Exception {
         view = createViewMock(View.VISIBLE, 100, 100, 0, 0, true, true);
 
-        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isFalse();
+        assertThat(visibilityChecker.isVisible(view, view, MIN_PERCENTAGE_VIEWED)).isFalse();
     }
 
     @Test
     public void isMostlyVisible_whenViewIsNull_shouldReturnFalse() throws Exception {
-        assertThat(visibilityChecker.isVisible(null, MIN_PERCENTAGE_VIEWED)).isFalse();
+        assertThat(visibilityChecker.isVisible(null, null, MIN_PERCENTAGE_VIEWED)).isFalse();
     }
 
     @Test
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/factories/CustomEventNativeFactoryTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/factories/CustomEventNativeFactoryTest.java
index 3a46eb1e..56f0bc59 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/factories/CustomEventNativeFactoryTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/factories/CustomEventNativeFactoryTest.java
@@ -1,16 +1,27 @@
 package com.mopub.nativeads.factories;
 
+import com.mopub.mobileads.BuildConfig;
 import com.mopub.nativeads.CustomEventNative;
 
+import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
-@RunWith(RobolectricTestRunner.class)
+
+@Config(constants = BuildConfig.class)
+@RunWith(RobolectricGradleTestRunner.class)
 public class CustomEventNativeFactoryTest {
+
+    @Before
+    public void setUp() {
+        CustomEventNativeFactory.setInstance(new CustomEventNativeFactory());
+    }
+
     @Test
     public void create_withValidClassName_shouldCreateClass() throws Exception {
         assertCustomEventClassCreated("com.mopub.nativeads.MoPubCustomEventNative");
diff --git a/mopub-sdk/src/test/java/com/mopub/network/AdRequestTest.java b/mopub-sdk/src/test/java/com/mopub/network/AdRequestTest.java
index d7bd6f3b..e15ea711 100644
--- a/mopub-sdk/src/test/java/com/mopub/network/AdRequestTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/network/AdRequestTest.java
@@ -2,7 +2,9 @@
 
 import android.app.Activity;
 import android.location.Location;
+import android.os.Build;
 
+import com.mopub.TestSdkHelper;
 import com.mopub.common.AdFormat;
 import com.mopub.common.AdType;
 import com.mopub.common.DataKeys;
@@ -11,6 +13,7 @@
 import com.mopub.common.event.MoPubEvents;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.common.util.ResponseHeader;
+import com.mopub.mobileads.BuildConfig;
 import com.mopub.volley.NetworkResponse;
 import com.mopub.volley.Response;
 
@@ -23,6 +26,7 @@
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
 
 import java.nio.charset.Charset;
 import java.util.Collections;
@@ -40,6 +44,7 @@
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class AdRequestTest {
 
     @Mock private AdRequest.Listener mockListener;
@@ -63,6 +68,11 @@ public void setup() {
         defaultHeaders.put(ResponseHeader.IMPRESSION_URL.getKey(), "impression");
         defaultHeaders.put(ResponseHeader.FAIL_URL.getKey(), "fail_url");
         defaultHeaders.put(ResponseHeader.REFRESH_TIME.getKey(), "30");
+        defaultHeaders.put(ResponseHeader.PLAY_VISIBLE_PERCENT.getKey(), "50%");
+        defaultHeaders.put(ResponseHeader.PAUSE_VISIBLE_PERCENT.getKey(), "25");
+        defaultHeaders.put(ResponseHeader.IMPRESSION_MIN_VISIBLE_PERCENT.getKey(), "33%");
+        defaultHeaders.put(ResponseHeader.IMPRESSION_VISIBLE_MS.getKey(), "2000");
+        defaultHeaders.put(ResponseHeader.MAX_BUFFER_MS.getKey(), "1000");
 
         MoPubEvents.setEventDispatcher(mockEventDispatcher);
     }
@@ -97,9 +107,13 @@ public void parseNetworkResponse_withStringBody_shouldLogScribeEvent() throws Ex
     }
 
     @Test
-    public void parseNetworkResponse_withServerExtrasInResponseBody_shouldSucceed() throws Exception {
+    public void parseNetworkResponse_withServerExtrasInResponseBody_shouldSucceed_shouldCombineServerExtras() throws Exception {
         defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.HTML);
         defaultHeaders.put(ResponseHeader.FULL_AD_TYPE.getKey(), "anything");
+        defaultHeaders.put(ResponseHeader.CUSTOM_EVENT_NAME.getKey(), "class name");
+        defaultHeaders.put(ResponseHeader.CUSTOM_EVENT_DATA.getKey(),
+                "{customEventKey1: value1, customEventKey2: value2}");
+
         NetworkResponse testResponse =
                 new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
         final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
@@ -111,11 +125,14 @@ public void parseNetworkResponse_withServerExtrasInResponseBody_shouldSucceed()
         assertThat(serverExtras.get(DataKeys.SCROLLABLE_KEY)).isEqualToIgnoringCase("false");
         assertThat(serverExtras.get(DataKeys.REDIRECT_URL_KEY)).isEqualToIgnoringCase("redirect");
         assertThat(serverExtras.get(DataKeys.CLICKTHROUGH_URL_KEY)).isEqualToIgnoringCase("click_tracking");
+
+        assertThat(serverExtras.get("customEventKey1")).isEqualTo("value1");
+        assertThat(serverExtras.get("customEventKey2")).isEqualTo("value2");
     }
 
     @Test
     public void parseNetworkResponse_nonJsonStringBodyForNative_jsonParseShouldFail() {
-        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.NATIVE);
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.STATIC_NATIVE);
         NetworkResponse testResponse =
                 new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
 
@@ -128,7 +145,7 @@ public void parseNetworkResponse_nonJsonStringBodyForNative_jsonParseShouldFail(
 
     @Test
     public void parseNetworkResponse_nonJsonStringBodyForNative_shouldNotLogScribeEvent() {
-        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.NATIVE);
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.STATIC_NATIVE);
         NetworkResponse testResponse =
                 new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
 
@@ -137,9 +154,96 @@ public void parseNetworkResponse_nonJsonStringBodyForNative_shouldNotLogScribeEv
         verify(mockEventDispatcher, never()).dispatch(any(BaseEvent.class));
     }
 
+    @Test
+    @Config(sdk = Build.VERSION_CODES.JELLY_BEAN)
+    public void parseNetworkResponse_forNativeVideo_shouldSucceed() throws Exception {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.VIDEO_NATIVE);
+        NetworkResponse testResponse = new NetworkResponse(200,
+                "{\"abc\": \"def\"}".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        // Check the server extras
+        final Map<String, String> serverExtras = response.result.getServerExtras();
+        assertThat(serverExtras).isNotNull();
+        assertThat(serverExtras).isNotEmpty();
+        assertThat(serverExtras.get(DataKeys.PLAY_VISIBLE_PERCENT)).isEqualTo("50");
+        assertThat(serverExtras.get(DataKeys.PAUSE_VISIBLE_PERCENT)).isEqualTo("25");
+        assertThat(serverExtras.get(DataKeys.IMPRESSION_MIN_VISIBLE_PERCENT)).isEqualTo("33");
+        assertThat(serverExtras.get(DataKeys.IMPRESSION_VISIBLE_MS)).isEqualTo("2000");
+        assertThat(serverExtras.get(DataKeys.MAX_BUFFER_MS)).isEqualTo("1000");
+    }
+
+    @Test
+    @Config(sdk = Build.VERSION_CODES.JELLY_BEAN)
+    public void parseNetworkResponse_forNativeVideo_shouldCombineServerExtrasAndEventData() throws Exception {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.VIDEO_NATIVE);
+        defaultHeaders.put(ResponseHeader.CUSTOM_EVENT_NAME.getKey(), "class name");
+        defaultHeaders.put(ResponseHeader.CUSTOM_EVENT_DATA.getKey(),
+                "{customEventKey1: value1, customEventKey2: value2}");
+        NetworkResponse testResponse = new NetworkResponse(200,
+                "{\"abc\": \"def\"}".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        // Check the server extras
+        final Map<String, String> serverExtras = response.result.getServerExtras();
+        assertThat(serverExtras).isNotNull();
+        assertThat(serverExtras).isNotEmpty();
+
+        assertThat(serverExtras.get(DataKeys.PLAY_VISIBLE_PERCENT)).isEqualTo("50");
+        assertThat(serverExtras.get(DataKeys.PAUSE_VISIBLE_PERCENT)).isEqualTo("25");
+        assertThat(serverExtras.get(DataKeys.IMPRESSION_MIN_VISIBLE_PERCENT)).isEqualTo("33");
+        assertThat(serverExtras.get(DataKeys.IMPRESSION_VISIBLE_MS)).isEqualTo("2000");
+        assertThat(serverExtras.get(DataKeys.MAX_BUFFER_MS)).isEqualTo("1000");
+
+        assertThat(serverExtras.get("customEventKey1")).isEqualTo("value1");
+        assertThat(serverExtras.get("customEventKey2")).isEqualTo("value2");
+    }
+
+    @Test
+    public void parseNetworkResponse_forNativeVideo_onAPILevelBefore16_shouldError() throws Exception {
+        TestSdkHelper.setReportedSdkLevel(Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1);
+
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.VIDEO_NATIVE);
+        NetworkResponse testResponse = new NetworkResponse(200,
+                "{\"abc\": \"def\"}".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        assertThat(response.error).isNotNull();
+        assertThat(response.error).isInstanceOf(MoPubNetworkError.class);
+        assertThat(((MoPubNetworkError) response.error).getReason())
+                .isEqualTo(MoPubNetworkError.Reason.UNSPECIFIED);
+    }
+
+    @Test
+    @Config(sdk = Build.VERSION_CODES.JELLY_BEAN)
+    public void parseNetworkResponse_forNativeVideo_withInvalidValues_shouldSucceed_shouldParseNull() throws Exception {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.VIDEO_NATIVE);
+        defaultHeaders.put(ResponseHeader.PLAY_VISIBLE_PERCENT.getKey(), "-1");
+        defaultHeaders.put(ResponseHeader.PAUSE_VISIBLE_PERCENT.getKey(), "101%");
+        defaultHeaders.put(ResponseHeader.IMPRESSION_MIN_VISIBLE_PERCENT.getKey(), "XX%");
+        NetworkResponse testResponse = new NetworkResponse(200,
+                "{\"abc\": \"def\"}".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        // Check the server extras
+        final Map<String, String> serverExtras = response.result.getServerExtras();
+        assertThat(serverExtras).isNotNull();
+        assertThat(serverExtras).isNotEmpty();
+        assertThat(serverExtras.get(DataKeys.PLAY_VISIBLE_PERCENT)).isNull();
+        assertThat(serverExtras.get(DataKeys.PAUSE_VISIBLE_PERCENT)).isNull();
+        assertThat(serverExtras.get(DataKeys.IMPRESSION_MIN_VISIBLE_PERCENT)).isNull();
+        assertThat(serverExtras.get(DataKeys.IMPRESSION_VISIBLE_MS)).isEqualTo("2000");
+        assertThat(serverExtras.get(DataKeys.MAX_BUFFER_MS)).isEqualTo("1000");
+    }
+
+
     @Test
     public void parseNetworkResponse_withWarmupHeaderTrue_shouldError() {
-        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.NATIVE);
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.STATIC_NATIVE);
         defaultHeaders.put(ResponseHeader.WARMUP.getKey(), "1");
         NetworkResponse testResponse =
                 new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
@@ -152,7 +256,7 @@ public void parseNetworkResponse_withWarmupHeaderTrue_shouldError() {
 
     @Test
     public void parseNetworkResponse_withWarmupHeaderTrue_shouldNotLogScribeEvent() {
-        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.NATIVE);
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.STATIC_NATIVE);
         defaultHeaders.put(ResponseHeader.WARMUP.getKey(), "1");
         NetworkResponse testResponse =
                 new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
@@ -226,7 +330,7 @@ public void parseNetworkResponse_withClearAdType_shouldLogScribeEvent() {
 
     @Test
     public void parseNetworkResponse_withBadJSON_shouldReturnError() {
-        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.NATIVE);
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.STATIC_NATIVE);
         NetworkResponse badNativeNetworkResponse = new NetworkResponse(200,
                 "{[abc}".getBytes(Charset.defaultCharset()),
                 defaultHeaders, false);
diff --git a/mopub-sdk/src/test/java/com/mopub/network/HeaderUtilsTest.java b/mopub-sdk/src/test/java/com/mopub/network/HeaderUtilsTest.java
index f91576ec..5fbf65b7 100644
--- a/mopub-sdk/src/test/java/com/mopub/network/HeaderUtilsTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/network/HeaderUtilsTest.java
@@ -1,17 +1,20 @@
 package com.mopub.network;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
 
 import static com.mopub.common.util.ResponseHeader.AD_TIMEOUT;
 import static com.mopub.common.util.ResponseHeader.SCROLLABLE;
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class HeaderUtilsTest {
     private TestHttpResponseWithHeaders response;
 
diff --git a/mopub-sdk/src/test/java/com/mopub/network/MoPubRequestQueueTest.java b/mopub-sdk/src/test/java/com/mopub/network/MoPubRequestQueueTest.java
index 441ed4c2..8af5748e 100644
--- a/mopub-sdk/src/test/java/com/mopub/network/MoPubRequestQueueTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/network/MoPubRequestQueueTest.java
@@ -7,6 +7,7 @@
 import com.mopub.common.Constants;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.common.util.DeviceUtils;
+import com.mopub.mobileads.BuildConfig;
 import com.mopub.volley.Cache;
 import com.mopub.volley.Network;
 import com.mopub.volley.Request;
@@ -22,6 +23,7 @@
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
 
 import java.io.File;
 
@@ -32,6 +34,7 @@
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class MoPubRequestQueueTest {
 
     private MoPubRequestQueue subject;
diff --git a/mopub-sdk/src/test/java/com/mopub/network/NetworkingTest.java b/mopub-sdk/src/test/java/com/mopub/network/NetworkingTest.java
index 625c8a8c..de48343a 100644
--- a/mopub-sdk/src/test/java/com/mopub/network/NetworkingTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/network/NetworkingTest.java
@@ -3,6 +3,7 @@
 import android.app.Activity;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 
 import org.junit.After;
 import org.junit.Before;
@@ -10,12 +11,14 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
 
 import java.util.concurrent.Semaphore;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class NetworkingTest {
     private Activity context;
     static volatile String sUserAgent;
diff --git a/mopub-sdk/src/test/java/com/mopub/network/PlayServicesUrlRewriterTest.java b/mopub-sdk/src/test/java/com/mopub/network/PlayServicesUrlRewriterTest.java
index a5225b99..b5137256 100644
--- a/mopub-sdk/src/test/java/com/mopub/network/PlayServicesUrlRewriterTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/network/PlayServicesUrlRewriterTest.java
@@ -8,11 +8,13 @@
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.common.util.Reflection;
 import com.mopub.common.util.test.support.TestMethodBuilderFactory;
+import com.mopub.mobileads.BuildConfig;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
@@ -20,6 +22,7 @@
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class PlayServicesUrlRewriterTest {
 
     private Reflection.MethodBuilder methodBuilder;
diff --git a/mopub-sdk/src/test/java/com/mopub/network/RequestManagerTest.java b/mopub-sdk/src/test/java/com/mopub/network/RequestManagerTest.java
index 8cadcfaf..a9a52e2c 100644
--- a/mopub-sdk/src/test/java/com/mopub/network/RequestManagerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/network/RequestManagerTest.java
@@ -3,12 +3,14 @@
 import android.os.Looper;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 import com.mopub.volley.Request;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
+import org.robolectric.annotation.Config;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
@@ -20,6 +22,7 @@
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class RequestManagerTest {
 
     private ScribeRequestManager subject;
diff --git a/mopub-sdk/src/test/java/com/mopub/network/ScribeBackoffPolicyTest.java b/mopub-sdk/src/test/java/com/mopub/network/ScribeBackoffPolicyTest.java
index 56a07c86..794121a1 100644
--- a/mopub-sdk/src/test/java/com/mopub/network/ScribeBackoffPolicyTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/network/ScribeBackoffPolicyTest.java
@@ -1,6 +1,7 @@
 package com.mopub.network;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 import com.mopub.volley.NetworkResponse;
 import com.mopub.volley.NoConnectionError;
 import com.mopub.volley.VolleyError;
@@ -8,11 +9,13 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.fest.assertions.api.Assertions.fail;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class ScribeBackoffPolicyTest {
 
     private ScribeBackoffPolicy subject;
diff --git a/mopub-sdk/src/test/java/com/mopub/network/ScribeRequestManagerTest.java b/mopub-sdk/src/test/java/com/mopub/network/ScribeRequestManagerTest.java
index 854b26a8..7fc1b530 100644
--- a/mopub-sdk/src/test/java/com/mopub/network/ScribeRequestManagerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/network/ScribeRequestManagerTest.java
@@ -3,6 +3,7 @@
 import android.os.Looper;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 import com.mopub.volley.NoConnectionError;
 import com.mopub.volley.Request;
 import com.mopub.volley.VolleyError;
@@ -11,6 +12,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
+import org.robolectric.annotation.Config;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Mockito.doThrow;
@@ -20,6 +22,7 @@
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class ScribeRequestManagerTest {
 
     private ScribeRequestManager subject;
diff --git a/mopub-sdk/src/test/java/com/mopub/network/ScribeRequestTest.java b/mopub-sdk/src/test/java/com/mopub/network/ScribeRequestTest.java
index 7bf2d5bb..3af7d466 100644
--- a/mopub-sdk/src/test/java/com/mopub/network/ScribeRequestTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/network/ScribeRequestTest.java
@@ -5,6 +5,7 @@
 import com.mopub.common.event.BaseEvent;
 import com.mopub.common.event.EventSerializer;
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 import com.mopub.volley.DefaultRetryPolicy;
 import com.mopub.volley.NetworkResponse;
 import com.mopub.volley.Response;
@@ -15,6 +16,7 @@
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
 
 import java.nio.charset.Charset;
 import java.util.HashMap;
@@ -27,6 +29,7 @@
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class ScribeRequestTest {
 
     private ScribeRequest subject;
diff --git a/mopub-sdk/src/test/java/com/mopub/network/TrackingRequestTest.java b/mopub-sdk/src/test/java/com/mopub/network/TrackingRequestTest.java
index 1ae6f03f..62838f9e 100644
--- a/mopub-sdk/src/test/java/com/mopub/network/TrackingRequestTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/network/TrackingRequestTest.java
@@ -4,6 +4,7 @@
 import android.content.Context;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
 import com.mopub.mobileads.VastErrorCode;
 import com.mopub.mobileads.VastTracker;
 
@@ -12,18 +13,19 @@
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
 
 import java.util.Arrays;
 
 import static com.mopub.common.VolleyRequestMatcher.isUrl;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.argThat;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 
 @RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
 public class TrackingRequestTest {
 
     @Mock
diff --git a/mopub-sdk/src/test/resources/org.robolectric.Config.properties b/mopub-sdk/src/test/resources/robolectric.properties
similarity index 92%
rename from mopub-sdk/src/test/resources/org.robolectric.Config.properties
rename to mopub-sdk/src/test/resources/robolectric.properties
index 973e581e..dbe9f738 100644
--- a/mopub-sdk/src/test/resources/org.robolectric.Config.properties
+++ b/mopub-sdk/src/test/resources/robolectric.properties
@@ -1,2 +1,2 @@
-emulateSdk=18
+sdk=21
 shadows=com.mopub.nativeads.test.support.MoPubShadowDisplay,com.mopub.nativeads.test.support.MoPubShadowBitmap,com.mopub.mobileads.test.support.ShadowVastVideoView
