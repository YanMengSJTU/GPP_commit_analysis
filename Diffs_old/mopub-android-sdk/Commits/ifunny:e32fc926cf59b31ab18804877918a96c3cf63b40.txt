diff --git a/CHANGELOG.md b/CHANGELOG.md
index 8c4fdcf2..0d18323e 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,35 @@
+## Version 3.8.0 (June 1, 2015)
+
+- Updated Chartboost support to 5.3.0. This introduces a new shared class called ChartboostShared. If you are using Chartboost Custom Native Networks you will need to include this class in your build along with ChartboostInterstitial.
+
+## Version 3.7.0 (April 30, 2015)
+
+- Updated GooglePlayServices custom events to depend on the Google Play Services `play-services-ads 7.0.0` API.
+- Vungle support updated to SDK 3.3.3.
+- Updated InMobi and Greystripe custom events to accept application IDs from the MoPub UI.
+  - For InMobi: `{"app_id" : "YOUR_INMOBI_APP_ID"}`
+  - For Greystripe: `{"GUID" : "YOUR GREYSTRIPE_GUID"}`
+
+- Added toasts to the MoPub Sample App for ad load failures due to no connection.
+- Fixed a bug in processing VAST progress trackers in a VAST wrapper tag.
+- Fixed a bug where ad refresh times could be incorrect when an ad request was not filled.
+
+- Updated the following dependencies:
+	- support-v4 AAR to 22.0.0
+	- support-annotations JAR to 22.0.0
+	- Android Maven Plugin to 4.2.0
+
+#### Version 3.6.1 (April 6, 2015)
+
+ - **Bug Fix** Fixed a compile error in FacebookBanner.java
+
+## Version 3.6.0 (April 3, 2015)
+
+ - **Facebook Update** Updated supported Facebook Audience Network version to 3.23.1
+ - **Bug fix** Fixed a bug where interstitials could leak memory; Fixes [issue #153](https://github.com/mopub/mopub-android-sdk/issues/153)
+ - **VAST Video** Updated the VAST video player to support Progress events.
+ - Updated **Volley** version to 1.1.0.
+
 ## Version 3.5.0 (March 10, 2015)
 
  - Dependency changes in Maven and Gradle. No new dependencies have been added, but your build script will need to change slightly to include JCenter. See our [Getting Started Guide](https://github.com/mopub/mopub-android-sdk/wiki/Getting-Started#adding-the-support-libraries-to-your-project) for complete instructions.
diff --git a/README.md b/README.md
index e0ac378f..e8517fe9 100644
--- a/README.md
+++ b/README.md
@@ -4,7 +4,14 @@ Thanks for taking a look at MoPub! We take pride in having an easy-to-use, flexi
 
 Sign up for an account at [http://app.mopub.com/](http://app.mopub.com/).
 
-Help is available on the [wiki](https://github.com/mopub/mopub-android-sdk/wiki/Getting-Started).
+## Need Help?
+
+You can find integration documentation on our [wiki](https://github.com/mopub/mopub-android-sdk/wiki/Getting-Started) and
+additional help documentation on our [developer help site](http://dev.twitter.com/mopub). 
+
+To file an issue with our team visit the [MoPub Forum](https://twittercommunity.com/c/fabric/mopub). 
+
+**Note: We will be deprecating the use of GitHub issues in the near future and migrating all issues to the forum to provide a faster response time.**
 
 ## Download
 
@@ -27,19 +34,15 @@ Integration instructions are available on the [wiki](https://github.com/mopub/mo
 
 Please view the [changelog](https://github.com/mopub/mopub-android-sdk/blob/master/CHANGELOG.md) for details.
 
-- Dependency changes in Maven and Gradle. No new dependencies have been added, but your build script will need to change slightly to include JCenter. See our [Getting Started Guide](https://github.com/mopub/mopub-android-sdk/wiki/Getting-Started#adding-the-support-libraries-to-your-project) for complete instructions.
-- Security Improvement: removed the @JavascriptInterface annotation for WebViews.
-- Fixed a bug where video playback would sometimes fail to stop when an ad was dismissed.
-- Fixed a bug where it was not possible to disable ad refresh; Fixes [issue #148](https://github.com/mopub/mopub-android-sdk/issues/148)
-- Fixed a null pointer exception in AdViewController; Fixes [issue #150](https://github.com/mopub/mopub-android-sdk/issues/150)
+- Updated Chartboost support to 5.3.0. This introduces a new shared class called ChartboostShared. If you are using Chartboost Custom Native Networks you will need to include this class in your build along with ChartboostInterstitial.
 
 ## Requirements
 
 - Android 2.3.1 (API Version 9) and up
-- android-support-v4.jar
-- android-support-annotations.jar (**New in 3.3.0**)
-- MoPub Volley Library (mopub-volley-1.0.0.jar - available on JCenter) (**Updated in 3.5.0**)
-- **Recommended** Google Play Services 5.0.89 & up.
+- android-support-v4.jar, r22 (**Updated in 3.7.0**)
+- android-support-annotations.jar, r22 (**Updated in 3.7.0**)
+- MoPub Volley Library (mopub-volley-1.1.0.jar - available on JCenter) (**Updated in 3.6.0**)
+- **Recommended** Google Play Services 7.0.0
 
 ## Upgrading from 3.2.0 and Prior
 In 3.3.0 a dependency on android-support-annotations.jar was added. If you are using Maven or Gradle to include the MoPub SDK, this dependency is included in the build scripts. For instructions on adding dependencies for Eclipse projects, see our [Getting Started Guide](https://github.com/mopub/mopub-android-sdk/wiki/Getting-Started#adding-the-support-libraries-to-your-project)
diff --git a/extras/src/com/mopub/mobileads/AdColonyInterstitial.java b/extras/src/com/mopub/mobileads/AdColonyInterstitial.java
index a4a73e53..6e42be9c 100644
--- a/extras/src/com/mopub/mobileads/AdColonyInterstitial.java
+++ b/extras/src/com/mopub/mobileads/AdColonyInterstitial.java
@@ -15,8 +15,6 @@
 import java.util.concurrent.ScheduledThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 
-import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR;
-
 /*
  * Tested with AdColony SDK 2.0.3.
  */
@@ -36,10 +34,10 @@
     /*
      * These keys are intended for MoPub internal use. Do not modify.
      */
-    private static final String CLIENT_OPTIONS_KEY = "clientOptions";
-    private static final String APP_ID_KEY = "appId";
-    private static final String ALL_ZONE_IDS_KEY = "allZoneIds";
-    private static final String ZONE_ID_KEY = "zoneId";
+    public static final String CLIENT_OPTIONS_KEY = "clientOptions";
+    public static final String APP_ID_KEY = "appId";
+    public static final String ALL_ZONE_IDS_KEY = "allZoneIds";
+    public static final String ZONE_ID_KEY = "zoneId";
 
     private static boolean isAdColonyConfigured = false;
 
diff --git a/extras/src/com/mopub/mobileads/AdColonyRewardedVideo.java b/extras/src/com/mopub/mobileads/AdColonyRewardedVideo.java
index 8b2398f4..4d9baac4 100644
--- a/extras/src/com/mopub/mobileads/AdColonyRewardedVideo.java
+++ b/extras/src/com/mopub/mobileads/AdColonyRewardedVideo.java
@@ -46,10 +46,10 @@
     /*
      * These keys are intended for MoPub internal use. Do not modify.
      */
-    private static final String CLIENT_OPTIONS_KEY = "clientOptions";
-    private static final String APP_ID_KEY = "appId";
-    private static final String ALL_ZONE_IDS_KEY = "allZoneIds";
-    private static final String ZONE_ID_KEY = "zoneId";
+    public static final String CLIENT_OPTIONS_KEY = "clientOptions";
+    public static final String APP_ID_KEY = "appId";
+    public static final String ALL_ZONE_IDS_KEY = "allZoneIds";
+    public static final String ZONE_ID_KEY = "zoneId";
 
     private static boolean sInitialized = false;
     private static LifecycleListener sLifecycleListener = new BaseLifecycleListener() {
diff --git a/extras/src/com/mopub/mobileads/ChartboostInterstitial.java b/extras/src/com/mopub/mobileads/ChartboostInterstitial.java
index db34e6e5..2862ebcf 100644
--- a/extras/src/com/mopub/mobileads/ChartboostInterstitial.java
+++ b/extras/src/com/mopub/mobileads/ChartboostInterstitial.java
@@ -2,31 +2,24 @@
 
 import android.app.Activity;
 import android.content.Context;
+import android.support.annotation.NonNull;
+import android.text.TextUtils;
 import android.util.Log;
 
 import com.chartboost.sdk.Chartboost;
-import com.chartboost.sdk.ChartboostDelegate;
-import com.mopub.common.VisibleForTesting;
+import com.mopub.common.Preconditions;
 
-import java.util.HashMap;
 import java.util.Map;
 
-import static com.chartboost.sdk.Model.CBError.CBImpressionError;
-
-/*
- * Tested with Chartboost SDK 5.0.4.
+/**
+ * A custom event for showing Chartboost interstitial ads.
+ *
+ * Certified with Chartboost 5.3.0
  */
 class ChartboostInterstitial extends CustomEventInterstitial {
-    /*
-     * These keys are intended for MoPub internal use. Do not modify.
-     */
-    public static final String APP_ID_KEY = "appId";
-    public static final String APP_SIGNATURE_KEY = "appSignature";
-    public static final String LOCATION_KEY = "location";
-    public static final String LOCATION_DEFAULT = "Default";
-    private String appId;
-    private String appSignature;
-    private String location;
+
+    @NonNull
+    private String mLocation = ChartboostShared.LOCATION_DEFAULT;
 
     /*
      * Note: Chartboost recommends implementing their specific Activity lifecycle callbacks in your
@@ -34,200 +27,65 @@
      * documentation for more information.
      */
 
-    ChartboostInterstitial() {
-        location = LOCATION_DEFAULT;
-    }
-
-    static SingletonChartboostDelegate getDelegate() {
-        return SingletonChartboostDelegate.instance;
-    }
-
     /*
      * Abstract methods from CustomEventInterstitial
      */
     @Override
-    protected void loadInterstitial(Context context, CustomEventInterstitialListener interstitialListener,
-                                    Map<String, Object> localExtras, Map<String, String> serverExtras) {
+    protected void loadInterstitial(@NonNull Context context,
+            @NonNull CustomEventInterstitialListener interstitialListener,
+            @NonNull Map<String, Object> localExtras, @NonNull Map<String, String> serverExtras) {
+        Preconditions.checkNotNull(context);
+        Preconditions.checkNotNull(interstitialListener);
+        Preconditions.checkNotNull(localExtras);
+        Preconditions.checkNotNull(serverExtras);
+
         if (!(context instanceof Activity)) {
             interstitialListener.onInterstitialFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
             return;
         }
 
-        if (extrasAreValid(serverExtras)) {
-            setAppId(serverExtras.get(APP_ID_KEY));
-            setAppSignature(serverExtras.get(APP_SIGNATURE_KEY));
-            setLocation(
-                    serverExtras.containsKey(LOCATION_KEY)
-                            ? serverExtras.get(LOCATION_KEY)
-                            : LOCATION_DEFAULT);
-        } else {
+        if (serverExtras.containsKey(ChartboostShared.LOCATION_KEY)) {
+            String location = serverExtras.get(ChartboostShared.LOCATION_KEY);
+            mLocation = TextUtils.isEmpty(location) ? mLocation : location;
+        }
+
+        // If there's already a listener for this location, then another instance of
+        // CustomEventInterstitial is still active and we should fail.
+        if (ChartboostShared.getDelegate().hasInterstitialLocation(mLocation) &&
+                ChartboostShared.getDelegate().getInterstitialListener(mLocation) != interstitialListener) {
             interstitialListener.onInterstitialFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
             return;
         }
 
         Activity activity = (Activity) context;
-        Chartboost.startWithAppId(activity, appId, appSignature);
-
-        if (getDelegate().hasLocation(location) &&
-                getDelegate().getListener(location) != interstitialListener) {
+        try {
+            ChartboostShared.initializeSdk(activity, serverExtras);
+            ChartboostShared.getDelegate().registerInterstitialListener(mLocation, interstitialListener);
+        } catch (NullPointerException e) {
+            interstitialListener.onInterstitialFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
+            return;
+        } catch (IllegalStateException e) {
             interstitialListener.onInterstitialFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
             return;
         }
 
-        getDelegate().registerListener(location, interstitialListener);
-        Chartboost.setDelegate(getDelegate());
-        Chartboost.setAutoCacheAds(false);
-        Chartboost.setShouldRequestInterstitialsInFirstSession(true);
-        Chartboost.setShouldDisplayLoadingViewForMoreApps(false);
         Chartboost.onCreate(activity);
         Chartboost.onStart(activity);
-        Chartboost.cacheInterstitial(location);
+        if (Chartboost.hasInterstitial(mLocation)) {
+            ChartboostShared.getDelegate().didCacheInterstitial(mLocation);
+        } else {
+            Chartboost.cacheInterstitial(mLocation);
+        }
     }
 
     @Override
     protected void showInterstitial() {
         Log.d("MoPub", "Showing Chartboost interstitial ad.");
-        Chartboost.showInterstitial(location);
+        Chartboost.showInterstitial(mLocation);
     }
 
     @Override
     protected void onInvalidate() {
-        getDelegate().unregisterListener(location);
-    }
-
-    private void setAppId(String appId) {
-        this.appId = appId;
-    }
-
-    private void setAppSignature(String appSignature) {
-        this.appSignature = appSignature;
-    }
-
-    private void setLocation(String location) {
-        this.location = location;
-    }
-
-    private boolean extrasAreValid(Map<String, String> serverExtras) {
-        return serverExtras.containsKey(APP_ID_KEY) && serverExtras.containsKey(APP_SIGNATURE_KEY);
-    }
-
-    @VisibleForTesting
-    static class SingletonChartboostDelegate extends ChartboostDelegate {
-        private static final CustomEventInterstitialListener NULL_LISTENER = new CustomEventInterstitialListener() {
-            @Override public void onInterstitialLoaded() { }
-            @Override public void onInterstitialFailed(MoPubErrorCode errorCode) { }
-            @Override public void onInterstitialShown() { }
-            @Override public void onInterstitialClicked() { }
-            @Override public void onLeaveApplication() { }
-            @Override public void onInterstitialDismissed() { }
-        };
-        static SingletonChartboostDelegate instance = new SingletonChartboostDelegate();
-        private Map<String, CustomEventInterstitialListener> listenerForLocation =
-                new HashMap<String, CustomEventInterstitialListener>();
-
-        public void registerListener(String location, CustomEventInterstitialListener interstitialListener) {
-            listenerForLocation.put(location, interstitialListener);
-        }
-
-        public void unregisterListener(String location) {
-            listenerForLocation.remove(location);
-        }
-
-        public boolean hasLocation(String location) {
-            return listenerForLocation.containsKey(location);
-        }
-
-        /*
-         * Interstitial delegate methods
-         */
-        @Override
-        public boolean shouldDisplayInterstitial(String location) {
-            return true;
-        }
-
-        @Override
-        public boolean shouldRequestInterstitial(String location) {
-            return true;
-        }
-
-        @Override
-        public void didCacheInterstitial(String location) {
-            Log.d("MoPub", "Chartboost interstitial loaded successfully.");
-            getListener(location).onInterstitialLoaded();
-        }
-
-        @Override
-        public void didFailToLoadInterstitial(String location, CBImpressionError error) {
-            Log.d("MoPub", "Chartboost interstitial ad failed to load. Error: " + error.name());
-            getListener(location).onInterstitialFailed(MoPubErrorCode.NETWORK_NO_FILL);
-        }
-
-        @Override
-        public void didDismissInterstitial(String location) {
-            // Note that this method is fired before didCloseInterstitial and didClickInterstitial.
-            Log.d("MoPub", "Chartboost interstitial ad dismissed.");
-            getListener(location).onInterstitialDismissed();
-        }
-
-        @Override
-        public void didCloseInterstitial(String location) {
-        }
-
-        @Override
-        public void didClickInterstitial(String location) {
-            Log.d("MoPub", "Chartboost interstitial ad clicked.");
-            getListener(location).onInterstitialClicked();
-        }
-
-        @Override
-        public void didDisplayInterstitial(String location) {
-            Log.d("MoPub", "Chartboost interstitial ad shown.");
-            getListener(location).onInterstitialShown();
-        }
-
-        /*
-         * More Apps delegate methods
-         */
-        @Override
-        public boolean shouldRequestMoreApps(String location) {
-            return false;
-        }
-
-        @Override
-        public boolean shouldDisplayMoreApps(String location) {
-            return false;
-        }
-
-        @Override
-        public void didFailToLoadMoreApps(String location, CBImpressionError error) {
-        }
-
-        @Override
-        public void didCacheMoreApps(String location) {
-        }
-
-        @Override
-        public void didDismissMoreApps(String location) {
-        }
-
-        @Override
-        public void didCloseMoreApps(String location) {
-        }
-
-        @Override
-        public void didClickMoreApps(String location) {
-        }
-
-        CustomEventInterstitialListener getListener(String location) {
-            CustomEventInterstitialListener listener = listenerForLocation.get(location);
-            return listener != null ? listener : NULL_LISTENER;
-        }
-    }
-
-    @VisibleForTesting
-    @Deprecated
-    public static void resetDelegate() {
-        SingletonChartboostDelegate.instance = new SingletonChartboostDelegate();
+        ChartboostShared.getDelegate().unregisterInterstitialListener(mLocation);
     }
-
 }
diff --git a/extras/src/com/mopub/mobileads/ChartboostRewardedVideo.java b/extras/src/com/mopub/mobileads/ChartboostRewardedVideo.java
index 0cd02f58..619271b8 100644
--- a/extras/src/com/mopub/mobileads/ChartboostRewardedVideo.java
+++ b/extras/src/com/mopub/mobileads/ChartboostRewardedVideo.java
@@ -3,38 +3,26 @@
 import android.app.Activity;
 import android.os.Handler;
 import android.support.annotation.NonNull;
+import android.text.TextUtils;
+
 import com.chartboost.sdk.Chartboost;
-import com.chartboost.sdk.ChartboostDelegate;
-import com.chartboost.sdk.Model.CBError;
 import com.mopub.common.DataKeys;
 import com.mopub.common.LifecycleListener;
 import com.mopub.common.MediationSettings;
-import com.mopub.common.MoPubReward;
-import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
 
-import java.util.*;
-
-import static com.mopub.mobileads.MoPubErrorCode.VIDEO_DOWNLOAD_ERROR;
+import java.util.Map;
 
 /**
  * A custom event for showing Chartboost rewarded videos.
  *
- * Certified with Chartboost 5.0.4
+ * Certified with Chartboost 5.3.0
  */
 public class ChartboostRewardedVideo extends CustomEventRewardedVideo {
-    public static final String APP_ID_KEY = "appId";
-    public static final String APP_SIGNATURE_KEY = "appSignature";
-    public static final String LOCATION_KEY = "location";
-    public static final String LOCATION_DEFAULT = "Default";
-
-    @NonNull private static final SingletonChartboostDelegate sSingletonChartboostDelegate =
-            new SingletonChartboostDelegate();
     @NonNull private static final LifecycleListener sLifecycleListener =
             new ChartboostLifecycleListener();
-    private static boolean sInitialized = false;
 
-    @NonNull private String mLocation = LOCATION_DEFAULT;
+    @NonNull private String mLocation = ChartboostShared.LOCATION_DEFAULT;
     @NonNull private final Handler mHandler;
 
     public ChartboostRewardedVideo() {
@@ -44,7 +32,7 @@ public ChartboostRewardedVideo() {
     @Override
     @NonNull
     public CustomEventRewardedVideoListener getVideoListenerForSdk() {
-        return sSingletonChartboostDelegate;
+        return ChartboostShared.getDelegate();
     }
 
     @Override
@@ -63,50 +51,37 @@ public String getAdNetworkId() {
     public boolean checkAndInitializeSdk(@NonNull Activity launcherActivity,
             @NonNull Map<String, Object> localExtras,
             @NonNull Map<String, String> serverExtras) throws Exception {
-        synchronized (ChartboostRewardedVideo.class) {
-            if (sInitialized) {
-                return false;
-            }
-
-            if (!serverExtras.containsKey(APP_ID_KEY)) {
-                throw new IllegalStateException("Chartboost rewarded video initialization" +
-                        " failed due to missing application ID.");
-            }
+        // We need to attempt to reinitialize Chartboost on each request, in case an interstitial has been
+        // loaded and used since then.
+        ChartboostShared.initializeSdk(launcherActivity, serverExtras);  // throws IllegalStateException
 
-            if (!serverExtras.containsKey(APP_SIGNATURE_KEY)) {
-                throw new IllegalStateException("Chartboost rewarded video initialization" +
-                        " failed due to missing application signature.");
-            }
-
-            final String appId = serverExtras.get(APP_ID_KEY);
-            final String appSignature = serverExtras.get(APP_SIGNATURE_KEY);
-
-            Chartboost.startWithAppId(launcherActivity, appId, appSignature);
-            Chartboost.setDelegate(sSingletonChartboostDelegate);
-
-            sInitialized = true;
-            return true;
-        }
+        // Always return true so that the lifecycle listener is registered even if an interstitial
+        // did the initialization.
+        return true;
     }
 
     @Override
     protected void loadWithSdkInitialized(@NonNull Activity activity,
             @NonNull Map<String, Object> localExtras, @NonNull Map<String, String> serverExtras)
             throws Exception {
-        if (serverExtras.containsKey(LOCATION_KEY)) {
-            mLocation = serverExtras.get(LOCATION_KEY);
-        } else {
-            mLocation = LOCATION_DEFAULT;
+
+        if (serverExtras.containsKey(ChartboostShared.LOCATION_KEY)) {
+            String location = serverExtras.get(ChartboostShared.LOCATION_KEY);
+            mLocation = TextUtils.isEmpty(location) ? mLocation : location;
         }
 
-        sSingletonChartboostDelegate.mLocationsToLoad.add(mLocation);
+        ChartboostShared.getDelegate().registerRewardedVideoLocation(mLocation);
         setUpMediationSettingsForRequest((String) localExtras.get(DataKeys.AD_UNIT_ID_KEY));
 
         // We do this to ensure that the custom event manager has a chance to get the listener
-        // and ad unit ID before and delegate callbacks are made.
+        // and ad unit ID before any delegate callbacks are made.
         mHandler.post(new Runnable() {
             public void run() {
-                Chartboost.cacheRewardedVideo(mLocation);
+                if (Chartboost.hasRewardedVideo(mLocation)) {
+                    ChartboostShared.getDelegate().didCacheRewardedVideo(mLocation);
+                } else {
+                    Chartboost.cacheRewardedVideo(mLocation);
+                }
             }
         });
     }
@@ -142,79 +117,7 @@ public void showVideo() {
     @Override
     protected void onInvalidate() {
         // This prevents sending didCache or didFailToCache callbacks.
-        sSingletonChartboostDelegate.mLocationsToLoad.remove(mLocation);
-    }
-
-    private static final class SingletonChartboostDelegate extends ChartboostDelegate
-            implements CustomEventRewardedVideoListener {
-
-        private Set<String> mLocationsToLoad = Collections.synchronizedSet(new TreeSet<String>());
-
-        @Override
-        public boolean shouldDisplayRewardedVideo(String location) {
-            return super.shouldDisplayRewardedVideo(location);
-        }
-
-        @Override
-        public void didCacheRewardedVideo(String location) {
-            super.didCacheRewardedVideo(location);
-
-            if (mLocationsToLoad.contains(location)) {
-                MoPubLog.d("Chartboost rewarded video cached for location " + location + ".");
-                MoPubRewardedVideoManager.onRewardedVideoLoadSuccess(ChartboostRewardedVideo.class, location);
-                mLocationsToLoad.remove(location);
-            }
-        }
-
-        @Override
-        public void didFailToLoadRewardedVideo(String location, CBError.CBImpressionError error) {
-            super.didFailToLoadRewardedVideo(location, error);
-
-            if (mLocationsToLoad.contains(location)) {
-                MoPubLog.d("Chartboost rewarded video cache failed for location " + location + ".");
-                MoPubRewardedVideoManager.onRewardedVideoLoadFailure(ChartboostRewardedVideo.class, location, VIDEO_DOWNLOAD_ERROR);
-                mLocationsToLoad.remove(location);
-            }
-        }
-
-        @Override
-        public void didDismissRewardedVideo(String location) {
-            // This is called before didCloseRewardedVideo and didClickRewardedVideo
-            super.didDismissRewardedVideo(location);
-            MoPubRewardedVideoManager.onRewardedVideoClosed(ChartboostRewardedVideo.class, location);
-            MoPubLog.d("Chartboost rewarded video dismissed for location " + location + ".");
-        }
-
-        @Override
-        public void didCloseRewardedVideo(String location) {
-            super.didCloseRewardedVideo(location);
-            MoPubLog.d("Chartboost rewarded video closed for location " + location + ".");
-        }
-
-        @Override
-        public void didClickRewardedVideo(String location) {
-            super.didClickRewardedVideo(location);
-            MoPubRewardedVideoManager.onRewardedVideoClicked(ChartboostRewardedVideo.class, location);
-            MoPubLog.d("Chartboost rewarded video clicked for location " + location + ".");
-        }
-
-        @Override
-        public void didCompleteRewardedVideo(String location, int reward) {
-            super.didCompleteRewardedVideo(location, reward);
-            MoPubLog.d("Chartboost rewarded video completed for location " + location + " with "
-                    + "reward amount " + reward);
-            MoPubRewardedVideoManager.onRewardedVideoCompleted(
-                    ChartboostRewardedVideo.class,
-                    location,
-                    MoPubReward.success(MoPubReward.NO_REWARD_LABEL, reward));
-        }
-
-        @Override
-        public void didDisplayRewardedVideo(String location) {
-            super.didDisplayRewardedVideo(location);
-            MoPubLog.d("Chartboost rewarded video displayed for location " + location + ".");
-            MoPubRewardedVideoManager.onRewardedVideoStarted(ChartboostRewardedVideo.class, location);
-        }
+        ChartboostShared.getDelegate().unregisterRewardedVideoLocation(mLocation);
     }
 
     private static final class ChartboostLifecycleListener implements LifecycleListener {
@@ -265,14 +168,9 @@ public ChartboostMediationSettings(@NonNull final String customId) {
             mCustomId = customId;
         }
 
-        @NonNull public String getCustomId() {
+        @NonNull
+        public String getCustomId() {
             return mCustomId;
         }
     }
-
-    @Deprecated // for testing
-    @VisibleForTesting
-    static void resetInitialization() {
-        sInitialized = false;
-    }
 }
diff --git a/extras/src/com/mopub/mobileads/ChartboostShared.java b/extras/src/com/mopub/mobileads/ChartboostShared.java
new file mode 100644
index 00000000..e146f15a
--- /dev/null
+++ b/extras/src/com/mopub/mobileads/ChartboostShared.java
@@ -0,0 +1,296 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.Log;
+
+import com.chartboost.sdk.Chartboost;
+import com.chartboost.sdk.ChartboostDelegate;
+import com.chartboost.sdk.Model.CBError;
+import com.mopub.common.MoPubReward;
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
+
+import java.util.Collections;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeMap;
+import java.util.TreeSet;
+
+import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR;
+import static com.mopub.mobileads.MoPubErrorCode.VIDEO_DOWNLOAD_ERROR;
+
+/**
+ * Shared infrastructure for initializing the Chartboost SDK when mediated by MoPub
+ *
+ * Certified with Chartboost 5.3.0
+ */
+public class ChartboostShared {
+    private static volatile ChartboostSingletonDelegate sDelegate = new ChartboostSingletonDelegate();
+
+    /*
+     * These keys are intended for MoPub internal use. Do not modify.
+     */
+    public static final String APP_ID_KEY = "appId";
+    public static final String APP_SIGNATURE_KEY = "appSignature";
+    public static final String LOCATION_KEY = "location";
+    public static final String LOCATION_DEFAULT = "Default";
+
+    @Nullable private static String mAppId;
+    @Nullable private static String mAppSignature;
+
+    /**
+     * Initialize the Chartboost SDK for the provided application id and app signature.
+     */
+    public static synchronized boolean initializeSdk(@NonNull Activity launcherActivity,
+            @NonNull Map<String, String> serverExtras) {
+        Preconditions.checkNotNull(launcherActivity);
+        Preconditions.checkNotNull(serverExtras);
+
+        // Validate Chartboost args
+        if (!serverExtras.containsKey(APP_ID_KEY)) {
+            throw new IllegalStateException("Chartboost rewarded video initialization" +
+                    " failed due to missing application ID.");
+        }
+
+        if (!serverExtras.containsKey(APP_SIGNATURE_KEY)) {
+            throw new IllegalStateException("Chartboost rewarded video initialization" +
+                    " failed due to missing application signature.");
+        }
+
+        final String appId = serverExtras.get(APP_ID_KEY);
+        final String appSignature = serverExtras.get(APP_SIGNATURE_KEY);
+
+        if (appId.equals(mAppId) && appSignature.equals(mAppSignature)) {
+            // We don't need to reinitialize.
+            return false;
+        }
+
+        mAppId = appId;
+        mAppSignature = appSignature;
+
+        // Perform all the common SDK initialization steps including startAppWithId
+        Chartboost.startWithAppId(launcherActivity, mAppId, mAppSignature);
+        Chartboost.setImpressionsUseActivities(false);
+        Chartboost.setFramework(Chartboost.CBFramework.CBFrameworkMoPub);
+        Chartboost.setDelegate(sDelegate);
+        Chartboost.setShouldRequestInterstitialsInFirstSession(true);
+        Chartboost.setAutoCacheAds(false);
+        Chartboost.setShouldDisplayLoadingViewForMoreApps(false);
+
+        // Callers of this method need to call onCreate & onStart themselves.
+        return true;
+    }
+
+    @NonNull
+    public static ChartboostSingletonDelegate getDelegate() {
+        return sDelegate;
+    }
+
+    /**
+     * A {@link ChartboostDelegate} that can forward events for Chartboost interstitials
+     * and rewarded videos to the appropriate listener based on the Chartboost location used.
+     */
+    public static class ChartboostSingletonDelegate extends ChartboostDelegate
+            implements CustomEventRewardedVideo.CustomEventRewardedVideoListener {
+        private static final CustomEventInterstitialListener NULL_LISTENER =
+                new CustomEventInterstitialListener() {
+                    @Override
+                    public void onInterstitialLoaded() { }
+
+                    @Override
+                    public void onInterstitialFailed(MoPubErrorCode errorCode) { }
+
+                    @Override
+                    public void onInterstitialShown() { }
+
+                    @Override
+                    public void onInterstitialClicked() { }
+
+                    @Override
+                    public void onLeaveApplication() { }
+
+                    @Override
+                    public void onInterstitialDismissed() { }
+                };
+
+        //***************
+        // Chartboost Location Management for interstitials and rewarded videos
+        //***************
+
+        private Map<String, CustomEventInterstitialListener> mInterstitialListenersForLocation
+                = Collections.synchronizedMap(new TreeMap<String, CustomEventInterstitialListener>());
+
+        private Set<String> mRewardedVideoLocationsToLoad = Collections.synchronizedSet(new TreeSet<String>());
+
+        public void registerInterstitialListener(@NonNull String location,
+                @NonNull CustomEventInterstitialListener interstitialListener) {
+            Preconditions.checkNotNull(location);
+            Preconditions.checkNotNull(interstitialListener);
+            mInterstitialListenersForLocation.put(location, interstitialListener);
+        }
+
+        public void unregisterInterstitialListener(@NonNull String location) {
+            Preconditions.checkNotNull(location);
+            mInterstitialListenersForLocation.remove(location);
+        }
+
+        public void registerRewardedVideoLocation(@NonNull String location) {
+            Preconditions.checkNotNull(location);
+            mRewardedVideoLocationsToLoad.add(location);
+        }
+
+        public void unregisterRewardedVideoLocation(@NonNull String location) {
+            Preconditions.checkNotNull(location);
+            mRewardedVideoLocationsToLoad.remove(location);
+        }
+
+        @NonNull
+        public CustomEventInterstitialListener getInterstitialListener(@NonNull String location) {
+            final CustomEventInterstitialListener listener = mInterstitialListenersForLocation.get(location);
+            return listener != null ? listener : NULL_LISTENER;
+        }
+
+        public boolean hasInterstitialLocation(@NonNull String location) {
+            return mInterstitialListenersForLocation.containsKey(location);
+        }
+
+        //******************
+        // Chartboost Delegate methods.
+        //******************
+
+        //******************
+        // Interstitials
+        //******************
+        @Override
+        public void didCacheInterstitial(String location) {
+            MoPubLog.d("Chartboost interstitial loaded successfully.");
+            getInterstitialListener(location).onInterstitialLoaded();
+        }
+
+        @Override
+        public void didFailToLoadInterstitial(String location, CBError.CBImpressionError error) {
+            String suffix = error != null ? "Error: " + error.name() : "";
+            Log.d("MoPub", "Chartboost interstitial ad failed to load." + suffix);
+            getInterstitialListener(location).onInterstitialFailed(MoPubErrorCode.NETWORK_NO_FILL);
+        }
+
+        @Override
+        public void didDismissInterstitial(String location) {
+            // Note that this method is fired before didCloseInterstitial and didClickInterstitial.
+            MoPubLog.d("Chartboost interstitial ad dismissed.");
+            getInterstitialListener(location).onInterstitialDismissed();
+        }
+
+        @Override
+        public void didCloseInterstitial(String location) {
+            MoPubLog.d("Chartboost interstitial ad closed.");
+        }
+
+        @Override
+        public void didClickInterstitial(String location) {
+            MoPubLog.d("Chartboost interstitial ad clicked.");
+            getInterstitialListener(location).onInterstitialClicked();
+        }
+
+        @Override
+        public void didDisplayInterstitial(String location) {
+            MoPubLog.d("Chartboost interstitial ad shown.");
+            getInterstitialListener(location).onInterstitialShown();
+        }
+
+        //******************
+        // Rewarded Videos
+        //******************
+        @Override
+        public void didCacheRewardedVideo(String location) {
+            super.didCacheRewardedVideo(location);
+
+            if (mRewardedVideoLocationsToLoad.contains(location)) {
+                MoPubLog.d("Chartboost rewarded video cached for location " + location + ".");
+                MoPubRewardedVideoManager.onRewardedVideoLoadSuccess(ChartboostRewardedVideo.class, location);
+                mRewardedVideoLocationsToLoad.remove(location);
+            }
+        }
+
+        @Override
+        public void didFailToLoadRewardedVideo(String location, CBError.CBImpressionError error) {
+            super.didFailToLoadRewardedVideo(location, error);
+            String suffix = error != null ? " with error: " + error.name() : "";
+            if (mRewardedVideoLocationsToLoad.contains(location)) {
+                MoPubErrorCode errorCode = VIDEO_DOWNLOAD_ERROR;
+                MoPubLog.d("Chartboost rewarded video cache failed for location " + location + suffix);
+                if (CBError.CBImpressionError.INVALID_LOCATION.equals(error)) {
+                    errorCode = ADAPTER_CONFIGURATION_ERROR;
+                }
+                MoPubRewardedVideoManager.onRewardedVideoLoadFailure(ChartboostRewardedVideo.class, location, errorCode);
+                mRewardedVideoLocationsToLoad.remove(location);
+            }
+        }
+
+        @Override
+        public void didDismissRewardedVideo(String location) {
+            // This is called before didCloseRewardedVideo and didClickRewardedVideo
+            super.didDismissRewardedVideo(location);
+            MoPubRewardedVideoManager.onRewardedVideoClosed(ChartboostRewardedVideo.class, location);
+            MoPubLog.d("Chartboost rewarded video dismissed for location " + location + ".");
+        }
+
+        @Override
+        public void didCloseRewardedVideo(String location) {
+            super.didCloseRewardedVideo(location);
+            MoPubLog.d("Chartboost rewarded video closed for location " + location + ".");
+        }
+
+        @Override
+        public void didClickRewardedVideo(String location) {
+            super.didClickRewardedVideo(location);
+            MoPubRewardedVideoManager.onRewardedVideoClicked(ChartboostRewardedVideo.class, location);
+            MoPubLog.d("Chartboost rewarded video clicked for location " + location + ".");
+        }
+
+        @Override
+        public void didCompleteRewardedVideo(String location, int reward) {
+            super.didCompleteRewardedVideo(location, reward);
+            MoPubLog.d("Chartboost rewarded video completed for location " + location + " with "
+                    + "reward amount " + reward);
+            MoPubRewardedVideoManager.onRewardedVideoCompleted(
+                    ChartboostRewardedVideo.class,
+                    location,
+                    MoPubReward.success(MoPubReward.NO_REWARD_LABEL, reward));
+        }
+
+        @Override
+        public void didDisplayRewardedVideo(String location) {
+            super.didDisplayRewardedVideo(location);
+            MoPubLog.d("Chartboost rewarded video displayed for location " + location + ".");
+            MoPubRewardedVideoManager.onRewardedVideoStarted(ChartboostRewardedVideo.class, location);
+        }
+
+        //******************
+        // More Apps
+        //******************
+        @Override
+        public boolean shouldRequestMoreApps(String location) {
+            return false;
+        }
+
+        @Override
+        public boolean shouldDisplayMoreApps(final String location) {
+            return false;
+        }
+    }
+
+
+    @VisibleForTesting
+    @Deprecated
+    static void reset() {
+        // Clears all the locations to load and other state.
+        sDelegate = new ChartboostSingletonDelegate();
+        mAppId = null;
+        mAppSignature = null;
+    }
+}
diff --git a/extras/src/com/mopub/mobileads/FacebookBanner.java b/extras/src/com/mopub/mobileads/FacebookBanner.java
index d58000f6..f0513a57 100644
--- a/extras/src/com/mopub/mobileads/FacebookBanner.java
+++ b/extras/src/com/mopub/mobileads/FacebookBanner.java
@@ -1,6 +1,8 @@
 package com.mopub.mobileads;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.Log;
 
 import com.facebook.ads.Ad;
@@ -8,15 +10,16 @@
 import com.facebook.ads.AdListener;
 import com.facebook.ads.AdSize;
 import com.facebook.ads.AdView;
+import com.mopub.common.DataKeys;
 import com.mopub.common.util.Views;
 
 import java.util.Map;
 
 /**
- * Tested with Facebook SDK 3.18.1.
+ * Tested with Facebook SDK 3.23.1.
  */
 public class FacebookBanner extends CustomEventBanner implements AdListener {
-    private static final String PLACEMENT_ID_KEY = "placement_id";
+    public static final String PLACEMENT_ID_KEY = "placement_id";
 
     private AdView mFacebookBanner;
     private CustomEventBannerListener mBannerListener;
@@ -33,15 +36,32 @@ protected void loadBanner(final Context context,
         mBannerListener = customEventBannerListener;
 
         final String placementId;
-        if (extrasAreValid(serverExtras)) {
+        if (serverExtrasAreValid(serverExtras)) {
             placementId = serverExtras.get(PLACEMENT_ID_KEY);
         } else {
             mBannerListener.onBannerFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
             return;
         }
 
-        mFacebookBanner = new AdView(context, placementId, AdSize.BANNER_320_50);
+        int width;
+        int height;
+        if (localExtrasAreValid(localExtras)) {
+            width = (Integer) localExtras.get(DataKeys.AD_WIDTH);
+            height = (Integer) localExtras.get(DataKeys.AD_HEIGHT);
+        } else {
+            mBannerListener.onBannerFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
+            return;
+        }
+
+        AdSize adSize = calculateAdSize(width, height);
+        if (adSize == null) {
+            mBannerListener.onBannerFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
+            return;
+        }
+
+        mFacebookBanner = new AdView(context, placementId, adSize);
         mFacebookBanner.setAdListener(this);
+        mFacebookBanner.disableAutoRefresh();
         mFacebookBanner.loadAd();
     }
 
@@ -82,11 +102,30 @@ public void onAdClicked(Ad ad) {
         mBannerListener.onBannerClicked();
     }
 
-    private boolean extrasAreValid(final Map<String, String> serverExtras) {
+    private boolean serverExtrasAreValid(final Map<String, String> serverExtras) {
         final String placementId = serverExtras.get(PLACEMENT_ID_KEY);
         return (placementId != null && placementId.length() > 0);
     }
 
+    private boolean localExtrasAreValid(@NonNull final Map<String, Object> localExtras) {
+        return localExtras.get(DataKeys.AD_WIDTH) instanceof Integer
+                && localExtras.get(DataKeys.AD_HEIGHT) instanceof Integer;
+    }
+
+    @Nullable
+    private AdSize calculateAdSize(int width, int height) {
+        // Use the smallest AdSize that will properly contain the adView
+        if (height <= AdSize.BANNER_320_50.getHeight()) {
+            return AdSize.BANNER_320_50;
+        } else if (height <= AdSize.BANNER_HEIGHT_90.getHeight()) {
+            return AdSize.BANNER_HEIGHT_90;
+        } else if (height <= AdSize.RECTANGLE_HEIGHT_250.getHeight()) {
+            return AdSize.RECTANGLE_HEIGHT_250;
+        } else {
+            return null;
+        }
+    }
+
     @Deprecated // for testing
     AdView getAdView() {
         return mFacebookBanner;
diff --git a/extras/src/com/mopub/mobileads/FacebookInterstitial.java b/extras/src/com/mopub/mobileads/FacebookInterstitial.java
index a2c59d42..3ff45d1b 100644
--- a/extras/src/com/mopub/mobileads/FacebookInterstitial.java
+++ b/extras/src/com/mopub/mobileads/FacebookInterstitial.java
@@ -11,10 +11,10 @@
 import java.util.Map;
 
 /**
- * Tested with Facebook SDK 3.18.1.
+ * Tested with Facebook SDK 3.23.1.
  */
 public class FacebookInterstitial extends CustomEventInterstitial implements InterstitialAdListener {
-    private static final String PLACEMENT_ID_KEY = "placement_id";
+    public static final String PLACEMENT_ID_KEY = "placement_id";
 
     private InterstitialAd mFacebookInterstitial;
     private CustomEventInterstitialListener mInterstitialListener;
diff --git a/extras/src/com/mopub/mobileads/GooglePlayServicesBanner.java b/extras/src/com/mopub/mobileads/GooglePlayServicesBanner.java
index 87a02d2e..17273749 100644
--- a/extras/src/com/mopub/mobileads/GooglePlayServicesBanner.java
+++ b/extras/src/com/mopub/mobileads/GooglePlayServicesBanner.java
@@ -17,7 +17,7 @@
 import static com.google.android.gms.ads.AdSize.MEDIUM_RECTANGLE;
 
 /*
- * Compatible with version 5.0.89 of the Google Play Services SDK.
+ * Compatible with version 7.0.0 of the Google Play Services SDK.
  */
 
 // Note: AdMob ads will now use this class as Google has deprecated the AdMob SDK.
@@ -26,10 +26,10 @@
     /*
      * These keys are intended for MoPub internal use. Do not modify.
      */
-    private static final String AD_UNIT_ID_KEY = "adUnitID";
-    private static final String AD_WIDTH_KEY = "adWidth";
-    private static final String AD_HEIGHT_KEY = "adHeight";
-    private static final String LOCATION_KEY = "location";
+    public static final String AD_UNIT_ID_KEY = "adUnitID";
+    public static final String AD_WIDTH_KEY = "adWidth";
+    public static final String AD_HEIGHT_KEY = "adHeight";
+    public static final String LOCATION_KEY = "location";
 
     private CustomEventBannerListener mBannerListener;
     private AdView mGoogleAdView;
@@ -66,7 +66,9 @@ protected void loadBanner(
 
         mGoogleAdView.setAdSize(adSize);
 
-        final AdRequest adRequest = new AdRequest.Builder().build();
+        final AdRequest adRequest = new AdRequest.Builder()
+                .setRequestAgent("MoPub")
+                .build();
 
         try {
             mGoogleAdView.loadAd(adRequest);
diff --git a/extras/src/com/mopub/mobileads/GooglePlayServicesInterstitial.java b/extras/src/com/mopub/mobileads/GooglePlayServicesInterstitial.java
index 6a6a4677..9aab1650 100644
--- a/extras/src/com/mopub/mobileads/GooglePlayServicesInterstitial.java
+++ b/extras/src/com/mopub/mobileads/GooglePlayServicesInterstitial.java
@@ -10,7 +10,7 @@
 import java.util.Map;
 
 /*
- * Compatible with version 5.0.89 of the Google Play Services SDK.
+ * Compatible with version 7.0.0 of the Google Play Services SDK.
  */
 
 // Note: AdMob ads will now use this class as Google has deprecated the AdMob SDK.
@@ -19,8 +19,8 @@
     /*
      * These keys are intended for MoPub internal use. Do not modify.
      */
-    private static final String AD_UNIT_ID_KEY = "adUnitID";
-    private static final String LOCATION_KEY = "location";
+    public static final String AD_UNIT_ID_KEY = "adUnitID";
+    public static final String LOCATION_KEY = "location";
 
     private CustomEventInterstitialListener mInterstitialListener;
     private InterstitialAd mGoogleInterstitialAd;
@@ -45,7 +45,9 @@ protected void loadInterstitial(
         mGoogleInterstitialAd.setAdListener(new InterstitialAdListener());
         mGoogleInterstitialAd.setAdUnitId(adUnitId);
 
-        final AdRequest adRequest = new AdRequest.Builder().build();
+        final AdRequest adRequest = new AdRequest.Builder()
+                .setRequestAgent("MoPub")
+                .build();
 
         try {
             mGoogleInterstitialAd.loadAd(adRequest);
diff --git a/extras/src/com/mopub/mobileads/MillennialBanner.java b/extras/src/com/mopub/mobileads/MillennialBanner.java
index 442e9890..5ea0a596 100644
--- a/extras/src/com/mopub/mobileads/MillennialBanner.java
+++ b/extras/src/com/mopub/mobileads/MillennialBanner.java
@@ -18,12 +18,15 @@
  */
 
 class MillennialBanner extends CustomEventBanner {
-    private MMAdView mMillennialAdView;
-    private CustomEventBannerListener mBannerListener;
+
     public static final String APID_KEY = "adUnitID";
     public static final String AD_WIDTH_KEY = "adWidth";
     public static final String AD_HEIGHT_KEY = "adHeight";
 
+    private MMAdView mMillennialAdView;
+    private CustomEventBannerListener mBannerListener;
+
+
     @Override
     protected void loadBanner(final Context context, final CustomEventBannerListener customEventBannerListener,
                               final Map<String, Object> localExtras, final Map<String, String> serverExtras) {
diff --git a/extras/src/com/mopub/mobileads/MillennialInterstitial.java b/extras/src/com/mopub/mobileads/MillennialInterstitial.java
index e0fcec9f..e4ca44b6 100644
--- a/extras/src/com/mopub/mobileads/MillennialInterstitial.java
+++ b/extras/src/com/mopub/mobileads/MillennialInterstitial.java
@@ -18,9 +18,12 @@
  */
 
 class MillennialInterstitial extends CustomEventInterstitial {
+
+    public static final String APID_KEY = "adUnitID";
+
     private MMInterstitial mMillennialInterstitial;
     private CustomEventInterstitialListener mInterstitialListener;
-    public static final String APID_KEY = "adUnitID";
+
 
     @Override
     protected void loadInterstitial(final Context context, final CustomEventInterstitialListener customEventInterstitialListener,
diff --git a/extras/src/com/mopub/mobileads/VungleInterstitial.java b/extras/src/com/mopub/mobileads/VungleInterstitial.java
index 70a572be..1e2ea4b8 100644
--- a/extras/src/com/mopub/mobileads/VungleInterstitial.java
+++ b/extras/src/com/mopub/mobileads/VungleInterstitial.java
@@ -2,6 +2,7 @@
 
 import android.content.Context;
 import android.os.Handler;
+import android.os.Looper;
 import android.util.Log;
 
 import com.vungle.publisher.EventListener;
@@ -12,16 +13,16 @@
 import java.util.concurrent.TimeUnit;
 
 /*
- * Tested with Vungle SDK 3.2.2.
+ * Tested with Vungle SDK 3.3.0
  */
 public class VungleInterstitial extends CustomEventInterstitial implements EventListener {
 
-    public static final String DEFAULT_VUNGLE_APP_ID = "YOUR_DEFAULT_VUNGLE_APP_ID";
+    private static final String DEFAULT_VUNGLE_APP_ID = "YOUR_DEFAULT_VUNGLE_APP_ID";
 
     /*
      * APP_ID_KEY is intended for MoPub internal use. Do not modify.
      */
-    private static final String APP_ID_KEY = "appId";
+    public static final String APP_ID_KEY = "appId";
 
     private final VunglePub mVunglePub;
     private final Handler mHandler;
@@ -30,7 +31,7 @@
     private boolean mIsLoading;
 
     public VungleInterstitial() {
-        mHandler = new Handler();
+        mHandler = new Handler(Looper.getMainLooper());
         mScheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(10);
         mVunglePub = VunglePub.getInstance();
     }
@@ -60,13 +61,13 @@ protected void loadInterstitial(Context context,
 
         // init clears the event listener.
         mVunglePub.init(context, appId);
-        mVunglePub.setEventListener(this);
+        mVunglePub.setEventListeners(this);
         scheduleOnInterstitialLoaded();
     }
 
     @Override
     protected void showInterstitial() {
-        if (mVunglePub.isCachedAdAvailable()) {
+        if (mVunglePub.isAdPlayable()) {
             mVunglePub.playAd();
         } else {
             Log.d("MoPub", "Tried to show a Vungle interstitial ad before it finished loading. Please try again.");
@@ -75,7 +76,7 @@ protected void showInterstitial() {
 
     @Override
     protected void onInvalidate() {
-        mVunglePub.setEventListener(null);
+        mVunglePub.clearEventListeners();
         mScheduledThreadPoolExecutor.shutdownNow();
         mIsLoading = false;
     }
@@ -88,7 +89,7 @@ private void scheduleOnInterstitialLoaded() {
         Runnable runnable = new Runnable() {
             @Override
             public void run() {
-            if (mVunglePub.isCachedAdAvailable()) {
+            if (mVunglePub.isAdPlayable()) {
                 Log.d("MoPub", "Vungle interstitial ad successfully loaded.");
                 mScheduledThreadPoolExecutor.shutdownNow();
                 mHandler.post(new Runnable() {
@@ -136,6 +137,9 @@ public void onAdEnd(final boolean wasCallToActionClicked) {
             public void run() {
                 Log.d("MoPub", "Vungle interstitial ad dismissed.");
                 mCustomEventInterstitialListener.onInterstitialDismissed();
+                if (wasCallToActionClicked) {
+                    mCustomEventInterstitialListener.onInterstitialClicked();
+                }
             }
         });
     }
@@ -146,8 +150,9 @@ public void onAdUnavailable(final String s) {
     }
 
     @Override
-    public void onCachedAdAvailable() {
-        // Due to the inconsistent behavior of this method, we rely on scheduleOnInterstitialLoaded instead.
+    public void onAdPlayableChanged(final boolean playable) {
+        // Do nothing here. After loading is kicked off, we scheduleOnInterstitialLoaded and check until
+        // we have a playable ad or we timeout.
     }
 
     @Deprecated // for testing
diff --git a/extras/src/com/mopub/mobileads/VungleRewardedVideo.java b/extras/src/com/mopub/mobileads/VungleRewardedVideo.java
index f067349a..9d020b40 100644
--- a/extras/src/com/mopub/mobileads/VungleRewardedVideo.java
+++ b/extras/src/com/mopub/mobileads/VungleRewardedVideo.java
@@ -2,6 +2,7 @@
 
 import android.app.Activity;
 import android.os.Handler;
+import android.os.Looper;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
@@ -21,7 +22,7 @@
 /**
  * A custom event for showing Vungle rewarded videos.
  *
- * Certified with Vungle 3.2.2
+ * Certified with Vungle 3.3.0
  */
 public class VungleRewardedVideo extends CustomEventRewardedVideo {
 
@@ -30,8 +31,8 @@
     /*
      * These constants are intended for MoPub internal use. Do not modify.
      */
-    private static final String APP_ID_KEY = "appId";
-    private static final String VUNGLE_AD_NETWORK_CONSTANT = "vngl_id";
+    public static final String APP_ID_KEY = "appId";
+    public static final String VUNGLE_AD_NETWORK_CONSTANT = "vngl_id";
 
     // This has to be reinitialized every time the CE loads to avoid conflict with the interstitials.
     private static VunglePub sVunglePub;
@@ -58,7 +59,7 @@ public void onResume(@NonNull final Activity activity) {
 
 
     public VungleRewardedVideo() {
-        mHandler = new Handler();
+        mHandler = new Handler(Looper.getMainLooper());
         mScheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(1);
         mIsLoading = false;
     }
@@ -99,7 +100,7 @@ protected boolean checkAndInitializeSdk(@NonNull final Activity launcherActivity
     protected void loadWithSdkInitialized(@NonNull final Activity activity, @NonNull final Map<String, Object> localExtras, @NonNull final Map<String, String> serverExtras) throws Exception {
         String appId = serverExtras.containsKey(APP_ID_KEY) ? serverExtras.get(APP_ID_KEY) : DEFAULT_VUNGLE_APP_ID;
         sVunglePub.init(activity, appId);
-        sVunglePub.setEventListener(sVungleListener);
+        sVunglePub.setEventListeners(sVungleListener);
         Object adUnitObject = localExtras.get(DataKeys.AD_UNIT_ID_KEY);
         if (adUnitObject instanceof String) {
             mAdUnitId = (String) adUnitObject;
@@ -109,7 +110,7 @@ protected void loadWithSdkInitialized(@NonNull final Activity activity, @NonNull
 
     @Override
     protected boolean hasVideoAvailable() {
-        return sVunglePub.isCachedAdAvailable();
+        return sVunglePub.isAdPlayable();
     }
 
     @Override
@@ -157,7 +158,7 @@ private void scheduleOnVideoLoaded() {
         Runnable runnable = new Runnable() {
             @Override
             public void run() {
-                if (sVunglePub.isCachedAdAvailable()) {
+                if (sVunglePub.isAdPlayable()) {
                     MoPubLog.d("Vungle interstitial ad successfully loaded.");
                     mScheduledThreadPoolExecutor.shutdownNow();
                     mHandler.post(new Runnable() {
@@ -208,9 +209,9 @@ public void onAdUnavailable(final String s) {
         }
 
         @Override
-        public void onCachedAdAvailable() {
-            // Due to the inconsistent behavior of this method,
-            // we rely on scheduleOnInterstitialLoaded instead.
+        public void onAdPlayableChanged(final boolean playable) {
+            // Do nothing here. After loading is kicked off, we scheduleOnInterstitialLoaded and check until
+            // we have a playable ad or we timeout.
         }
 
         @Override
diff --git a/extras/src/com/mopub/nativeads/FacebookNative.java b/extras/src/com/mopub/nativeads/FacebookNative.java
index 868610b5..76985261 100644
--- a/extras/src/com/mopub/nativeads/FacebookNative.java
+++ b/extras/src/com/mopub/nativeads/FacebookNative.java
@@ -15,7 +15,7 @@
 import java.util.Map;
 
 /*
- * Tested with Facebook SDK 3.18.1
+ * Tested with Facebook SDK 3.23.1
  */
 public class FacebookNative extends CustomEventNative {
     private static final String PLACEMENT_ID_KEY = "placement_id";
diff --git a/extras/src/com/mopub/simpleadsdemo/GreystripeBanner.java b/extras/src/com/mopub/simpleadsdemo/GreystripeBanner.java
index b74cb286..07311691 100644
--- a/extras/src/com/mopub/simpleadsdemo/GreystripeBanner.java
+++ b/extras/src/com/mopub/simpleadsdemo/GreystripeBanner.java
@@ -17,7 +17,13 @@
  * Tested with Greystripe SDK 2.4.0.
  */
 class GreystripeBanner extends CustomEventBanner implements GSAdListener {
-    public static final String DEFAULT_GREYSTRIPE_APP_ID = "YOUR_GREYSTRIPE_APP_ID";
+
+    private static final String DEFAULT_GREYSTRIPE_APP_ID = "YOUR_GREYSTRIPE_APP_ID";
+
+    /*
+     * These keys are intended for MoPub internal use. Do not modify.
+     */
+    public static final String APP_ID_KEY = "GUID";
 
     private CustomEventBannerListener mBannerListener;
     private GSMobileBannerAdView mGreystripeAd;
@@ -32,17 +38,21 @@ protected void loadBanner(final Context context,
                               final Map<String, String> serverExtras) {
         mBannerListener = bannerListener;
 
-        /*
-         * You may also pass this String down in the serverExtras Map by specifying Custom Event Data
-         * in MoPub's web interface.
-         */
         String greystripeAppId = DEFAULT_GREYSTRIPE_APP_ID;
+        if (extrasAreValid(serverExtras)) {
+            greystripeAppId = serverExtras.get(APP_ID_KEY);
+        }
+
         mGreystripeAd = new GSMobileBannerAdView(context, greystripeAppId);
         mGreystripeAd.addListener(this);
 
         mGreystripeAd.refresh();
     }
 
+    private boolean extrasAreValid(Map<String, String> extras) {
+        return extras.containsKey(APP_ID_KEY);
+    }
+
     @Override
     protected void onInvalidate() {
         mGreystripeAd.removeListener(this);
diff --git a/extras/src/com/mopub/simpleadsdemo/GreystripeInterstitial.java b/extras/src/com/mopub/simpleadsdemo/GreystripeInterstitial.java
index 7c9a261d..6540db04 100644
--- a/extras/src/com/mopub/simpleadsdemo/GreystripeInterstitial.java
+++ b/extras/src/com/mopub/simpleadsdemo/GreystripeInterstitial.java
@@ -17,11 +17,17 @@
  * Tested with Greystripe SDK 2.4.0.
  */
 class GreystripeInterstitial extends CustomEventInterstitial implements GSAdListener {
-    public static final String DEFAULT_GREYSTRIPE_APP_ID = "YOUR_GREYSTRIPE_APP_ID";
+
+    private static final String DEFAULT_GREYSTRIPE_APP_ID = "YOUR_GREYSTRIPE_APP_ID";
+
+    /*
+     * These keys are intended for MoPub internal use. Do not modify.
+     */
+    public static final String APP_ID_KEY = "GUID";
 
     private CustomEventInterstitialListener mInterstitialListener;
     private GSFullscreenAd mGreystripeAd;
-    
+
     /*
      * Abstract methods from CustomEventInterstitial
      */
@@ -32,30 +38,33 @@ protected void loadInterstitial(final Context context,
                                     final Map<String, String> serverExtras) {
         mInterstitialListener = interstitialListener;
 
-        /*
-         * You may also pass this String down in the serverExtras Map by specifying Custom Event Data
-         * in MoPub's web interface.
-         */
         String greystripeAppId = DEFAULT_GREYSTRIPE_APP_ID;
-        
+        if (extrasAreValid(serverExtras)) {
+            greystripeAppId = serverExtras.get(APP_ID_KEY);
+        }
+
         mGreystripeAd = new GSFullscreenAd(context, greystripeAppId);
         mGreystripeAd.addListener(this);
-        
+
         mGreystripeAd.fetch();
     }
 
+    private static boolean extrasAreValid(Map<String, String> extras) {
+        return extras.containsKey(APP_ID_KEY);
+    }
+
     @Override
     protected void showInterstitial() {
         if (!mGreystripeAd.isAdReady()) {
             mInterstitialListener.onInterstitialFailed(MoPubErrorCode.NETWORK_INVALID_STATE);
             return;
         }
-        
+
         Log.d("MoPub", "Showing Greystripe interstitial ad.");
         mGreystripeAd.display();
         mInterstitialListener.onInterstitialShown();
     }
-    
+
     @Override
     protected void onInvalidate() {
         mGreystripeAd.removeListener(this);
diff --git a/extras/src/com/mopub/simpleadsdemo/InMobiBanner.java b/extras/src/com/mopub/simpleadsdemo/InMobiBanner.java
index cbbeb8a8..b51fb04c 100644
--- a/extras/src/com/mopub/simpleadsdemo/InMobiBanner.java
+++ b/extras/src/com/mopub/simpleadsdemo/InMobiBanner.java
@@ -21,12 +21,19 @@
  */
 public class InMobiBanner extends CustomEventBanner implements IMBannerListener {
 
+    private static final String DEFAULT_APP_ID = "YOUR_INMOBI_APP_ID_HERE";
+
+    /*
+     * These keys are intended for MoPub internal use. Do not modify.
+     */
+    public static final String APP_ID_KEY = "app_id";
+
     @Override
     protected void loadBanner(Context context,
-                              CustomEventBannerListener bannerListener,
-                              Map<String, Object> localExtras, Map<String, String> serverExtras) {
+            CustomEventBannerListener bannerListener,
+            Map<String, Object> localExtras, Map<String, String> serverExtras) {
         mBannerListener = bannerListener;
-        String inMobiAppId = "YOUR_INMOBI_APP_ID";
+        String inMobiAppId = DEFAULT_APP_ID;
 
         Activity activity = null;
         if (context instanceof Activity) {
@@ -39,15 +46,16 @@ protected void loadBanner(Context context,
             mBannerListener.onBannerFailed(null);
             return;
         }
+
+        if (extrasAreValid(serverExtras)) {
+            inMobiAppId = serverExtras.get(APP_ID_KEY);
+        }
+
         if (!isAppInitialized) {
             InMobi.initialize(activity, inMobiAppId);
             isAppInitialized = true;
         }
 
-		/*
-		 * You may also pass this String down in the serverExtras Map by
-		 * specifying Custom Event Data in MoPub's web interface.
-		 */
         iMBanner = new IMBanner(activity, inMobiAppId,
                 IMBanner.INMOBI_AD_UNIT_320X50);
 
@@ -62,13 +70,17 @@ protected void loadBanner(Context context,
 
     }
 
+    private boolean extrasAreValid(Map<String, String> extras) {
+        return extras.containsKey(APP_ID_KEY);
+    }
+
     private CustomEventBannerListener mBannerListener;
     private IMBanner iMBanner;
     private static boolean isAppInitialized = false;
 
-	/*
-	 * Abstract methods from CustomEventBanner
-	 */
+    /*
+     * Abstract methods from CustomEventBanner
+     */
 
     @Override
     public void onInvalidate() {
diff --git a/extras/src/com/mopub/simpleadsdemo/InMobiInterstitial.java b/extras/src/com/mopub/simpleadsdemo/InMobiInterstitial.java
index 80f222d7..ad45e7d8 100644
--- a/extras/src/com/mopub/simpleadsdemo/InMobiInterstitial.java
+++ b/extras/src/com/mopub/simpleadsdemo/InMobiInterstitial.java
@@ -2,6 +2,7 @@
 
 import android.app.Activity;
 import android.content.Context;
+
 import com.inmobi.commons.InMobi;
 import com.inmobi.monetization.IMErrorCode;
 import com.inmobi.monetization.IMInterstitial;
@@ -10,19 +11,26 @@
 import com.mopub.mobileads.CustomEventInterstitial;
 import com.mopub.mobileads.MoPubErrorCode;
 
-import java.util.*;
+import java.util.HashMap;
+import java.util.Map;
 
 /*
  * Tested with InMobi SDK  4.4.1
  */
 public class InMobiInterstitial extends CustomEventInterstitial implements IMInterstitialListener {
 
+    private static final String DEFAULT_APP_ID = "YOUR_INMOBI_APP_ID_HERE";
+
+    /*
+     * These keys are intended for MoPub internal use. Do not modify.
+     */
+    public static final String APP_ID_KEY = "app_id";
+
     @Override
     protected void loadInterstitial(Context context,
                                     CustomEventInterstitialListener interstitialListener,
                                     Map<String, Object> localExtras, Map<String, String> serverExtras) {
         mInterstitialListener = interstitialListener;
-        String inMobiAppId = "YOUR_INMOBI_APP_ID";
 
         Activity activity = null;
         if (context instanceof Activity) {
@@ -37,10 +45,11 @@ protected void loadInterstitial(Context context,
             return;
         }
 
-		/*
-		 * You may also pass this String down in the serverExtras Map by
-		 * specifying Custom Event Data in MoPub's web interface.
-		 */
+        String inMobiAppId = DEFAULT_APP_ID;
+        if (extrasAreValid(serverExtras)) {
+            inMobiAppId = serverExtras.get(APP_ID_KEY);
+        }
+
         if (!isAppInitialized) {
             InMobi.initialize(activity, inMobiAppId);
             isAppInitialized = true;
@@ -55,13 +64,17 @@ protected void loadInterstitial(Context context,
         iMInterstitial.loadInterstitial();
     }
 
+    private boolean extrasAreValid(Map<String, String> extras) {
+        return extras.containsKey(APP_ID_KEY);
+    }
+
     private CustomEventInterstitialListener mInterstitialListener;
     private IMInterstitial iMInterstitial;
     private static boolean isAppInitialized = false;
 
-	/*
-	 * Abstract methods from CustomEventInterstitial
-	 */
+    /*
+     * Abstract methods from CustomEventInterstitial
+     */
 
     @Override
     public void showInterstitial() {
diff --git a/mopub-sample/AndroidManifest.xml b/mopub-sample/AndroidManifest.xml
index 05f288e6..0c23ce4c 100644
--- a/mopub-sample/AndroidManifest.xml
+++ b/mopub-sample/AndroidManifest.xml
@@ -1,10 +1,10 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
       package="com.mopub.simpleadsdemo"
-      android:versionCode="21"
-      android:versionName="3.5.0">
+      android:versionCode="25"
+      android:versionName="3.8.0">
     <uses-sdk android:minSdkVersion="9" 
-              android:targetSdkVersion="19"/>
+              android:targetSdkVersion="22"/>
 
     <uses-permission android:name="android.permission.INTERNET" />
     <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
diff --git a/mopub-sample/build.gradle b/mopub-sample/build.gradle
index a90d1c35..2bfb1081 100644
--- a/mopub-sample/build.gradle
+++ b/mopub-sample/build.gradle
@@ -9,14 +9,14 @@ group = 'com.mopub'
 description = '''MoPub SDK'''
 
 android {
-    compileSdkVersion 19
-    buildToolsVersion '21.1.1'
+    compileSdkVersion 22
+    buildToolsVersion '22.0.1'
 
     defaultConfig {
-        versionCode 21
-        versionName "3.5.0"
+        versionCode 25
+        versionName "3.8.0"
         minSdkVersion 9
-        targetSdkVersion 19
+        targetSdkVersion 22
     }
 
     buildTypes {
@@ -51,7 +51,7 @@ android {
 }
 
 dependencies {
-    compile 'com.android.support:support-v4:19.1.+'
-    compile 'com.google.android.gms:play-services:5.0.89'
+    compile 'com.android.support:support-v4:22.0.0'
+    compile 'com.google.android.gms:play-services-ads:7.0.0'
     compile project(':mopub-sdk')
 }
diff --git a/mopub-sample/pom.xml b/mopub-sample/pom.xml
index a1d02f01..2411f18d 100644
--- a/mopub-sample/pom.xml
+++ b/mopub-sample/pom.xml
@@ -27,20 +27,20 @@
             <groupId>com.mopub.mobileads</groupId>
             <artifactId>mopub-sdk</artifactId>
             <version>1.0.0-SNAPSHOT</version>
-            <type>jar</type>
+            <type>aar</type>
         </dependency>
 
         <dependency>
             <groupId>com.android.support</groupId>
             <artifactId>support-v4</artifactId>
-            <version>19.1.0</version>
-            <type>jar</type>
+            <version>22.0.0</version>
+            <type>aar</type>
         </dependency>
 
         <dependency>
             <groupId>com.google.android.gms</groupId>
-            <artifactId>play-services</artifactId>
-            <version>5.0.89</version>
+            <artifactId>play-services-ads</artifactId>
+            <version>7.0.0</version>
             <type>aar</type>
         </dependency>
 
@@ -109,13 +109,15 @@
                 </configuration>
             </plugin>
             <plugin>
-                <groupId>com.jayway.maven.plugins.android.generation2</groupId>
+                <groupId>com.simpligility.maven.plugins</groupId>
                 <artifactId>android-maven-plugin</artifactId>
-                <version>3.8.2</version>
+                <version>4.2.0</version>
                 <configuration>
+                    <androidManifestFile>AndroidManifest.xml</androidManifestFile>
+                    <resourceDirectory>res</resourceDirectory>
                     <sdk>
                         <!-- platform or api level (api level 4 = platform 1.6)-->
-                        <platform>19</platform>
+                        <platform>22</platform>
                     </sdk>
                     <undeployBeforeDeploy>true</undeployBeforeDeploy>
                 </configuration>
diff --git a/mopub-sample/proguard.cfg b/mopub-sample/proguard.cfg
index a307513f..9b84b5cf 100644
--- a/mopub-sample/proguard.cfg
+++ b/mopub-sample/proguard.cfg
@@ -16,3 +16,22 @@
 -keep class com.google.android.gms.common.GooglePlayServicesUtil {*;}
 -keep class com.google.android.gms.ads.identifier.AdvertisingIdClient {*;}
 -keep class com.google.android.gms.ads.identifier.AdvertisingIdClient$Info {*;}
+
+# Support for Google Play Services
+# http://developer.android.com/google/play-services/setup.html
+-keep class * extends java.util.ListResourceBundle {
+    protected Object[][] getContents();
+}
+
+-keep public class com.google.android.gms.common.internal.safeparcel.SafeParcelable {
+    public static final *** NULL;
+}
+
+-keepnames @com.google.android.gms.common.annotation.KeepName class *
+-keepclassmembernames class * {
+    @com.google.android.gms.common.annotation.KeepName *;
+}
+
+-keepnames class * implements android.os.Parcelable {
+    public static final ** CREATOR;
+}
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/InterstitialDetailFragment.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/InterstitialDetailFragment.java
index 2314e718..10a1cd82 100644
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/InterstitialDetailFragment.java
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/InterstitialDetailFragment.java
@@ -33,9 +33,11 @@ public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle sa
         views.mLoadButton.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View view) {
+                if (mMoPubInterstitial == null) {
+                    mMoPubInterstitial = new MoPubInterstitial(getActivity(), adUnitId);
+                    mMoPubInterstitial.setInterstitialAdListener(InterstitialDetailFragment.this);
+                }
                 final String keywords = views.mKeywordsField.getText().toString();
-                mMoPubInterstitial = new MoPubInterstitial(getActivity(), adUnitId);
-                mMoPubInterstitial.setInterstitialAdListener(InterstitialDetailFragment.this);
                 mMoPubInterstitial.setKeywords(keywords);
                 mMoPubInterstitial.load();
                 mShowButton.setEnabled(false);
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/LoggingUtils.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/LoggingUtils.java
new file mode 100644
index 00000000..ce5051d3
--- /dev/null
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/LoggingUtils.java
@@ -0,0 +1,93 @@
+package com.mopub.simpleadsdemo;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.mobileads.MoPubErrorCode;
+
+import java.util.logging.Handler;
+import java.util.logging.Level;
+import java.util.logging.LogManager;
+import java.util.logging.LogRecord;
+import java.util.logging.Logger;
+
+/**
+ * Used to intercept logs so that we can view logs at a lower level
+ * than Verbose (ie. Level.FINEST). This will show a toast when we
+ * receive a matching error from the mopub sdk.
+ */
+public class LoggingUtils {
+    private LoggingUtils() {
+    }
+
+    /**
+     * The name of the custom logger we're looking for
+     */
+    private static final String LOGGER_NAME = "com.mopub";
+
+    private static boolean sEnabled;
+
+    /**
+     * Makes it so that this app can intercept Level.FINEST log messages.
+     * This is not thread safe.
+     *
+     * @param context Needs a context to send toasts.
+     */
+    static void enableCanaryLogging(@NonNull final Context context) {
+        if (sEnabled) {
+            return;
+        }
+
+        final Handler handler = new SampleAppLogHandler(context.getApplicationContext());
+        final Logger logger = getLogger();
+
+        logger.setLevel(Level.ALL);
+        logger.addHandler(handler);
+
+        sEnabled = true;
+    }
+
+    private static Logger getLogger() {
+        // This makes sure the static block in MoPubLog is executed before
+        // LogManager#getLogManager is called.
+        MoPubLog.c("Canary level logging enabled");
+
+        return LogManager.getLogManager().getLogger(LOGGER_NAME);
+    }
+
+    private static class SampleAppLogHandler extends Handler {
+
+        @NonNull
+        private final Context mContext;
+
+        protected SampleAppLogHandler(@NonNull final Context context) {
+            super();
+            mContext = context;
+        }
+
+        @Override
+        public void publish(final LogRecord logRecord) {
+            if (logRecord == null) {
+                return;
+            }
+            // Toasts the warmup message if X-Warmup flag is set to 1
+            if (MoPubErrorCode.WARMUP.toString().equals(logRecord.getMessage())) {
+                Utils.logToast(mContext, MoPubErrorCode.WARMUP.toString());
+            }
+            // Toasts the no connection message if a native response failed due to no internet
+            if (MoPubErrorCode.NO_CONNECTION.toString().equals(logRecord.getMessage())) {
+                Utils.logToast(mContext, MoPubErrorCode.NO_CONNECTION.toString());
+            }
+        }
+
+        @Override
+        public void flush() {
+        }
+
+        @Override
+        public void close() throws SecurityException {
+        }
+    }
+}
+
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSQLiteHelper.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSQLiteHelper.java
index 35f1862b..40b417fb 100644
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSQLiteHelper.java
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSQLiteHelper.java
@@ -24,7 +24,7 @@
     public static final String COLUMN_AD_TYPE = "adType";
 
     private static final String DATABASE_NAME = "savedConfigurations.db";
-    private static final int DATABASE_VERSION = 1;
+    private static final int DATABASE_VERSION = 2;
 
     private static final String DATABASE_CREATE = "create table " + TABLE_AD_CONFIGURATIONS
             + " ("
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleActivity.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleActivity.java
index f2ba89bc..8322b4ac 100644
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleActivity.java
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleActivity.java
@@ -1,13 +1,29 @@
 package com.mopub.simpleadsdemo;
 
+import android.annotation.TargetApi;
+import android.os.Build;
 import android.os.Bundle;
 import android.support.v4.app.FragmentActivity;
 import android.support.v4.app.FragmentManager;
+import android.webkit.WebView;
 
 import com.mopub.common.MoPub;
 
 
 public class MoPubSampleActivity extends FragmentActivity {
+
+    // Sample app web views are debuggable.
+    static {
+        setWebDebugging();
+    }
+
+    @TargetApi(Build.VERSION_CODES.KITKAT)
+    private static void setWebDebugging() {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
+            WebView.setWebContentsDebuggingEnabled(true);
+        }
+    }
+
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
@@ -29,5 +45,9 @@ protected void onCreate(Bundle savedInstanceState) {
                     .add(R.id.fragment_container, listFragment)
                     .commit();
         }
+
+        // Intercepts all logs including Level.FINEST so we can show a toast
+        // that is not normally user-facing. This is only used for native ads.
+        LoggingUtils.enableCanaryLogging(this);
     }
 }
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleAdUnit.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleAdUnit.java
index 0192728d..3e2b7dac 100644
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleAdUnit.java
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleAdUnit.java
@@ -19,6 +19,7 @@
         BANNER("Banner", BannerDetailFragment.class),
         MRECT("Mrect", MrectDetailFragment.class),
         INTERSTITIAL("Interstitial", InterstitialDetailFragment.class),
+        REWARDED_VIDEO("Rewarded Video", RewardedVideoDetailFragment.class),
         LIST_VIEW("Native List View", NativeListViewFragment.class),
         CUSTOM_NATIVE("Native Gallery (Custom Stream)", NativeGalleryFragment.class);
 
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/RewardedVideoDetailFragment.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/RewardedVideoDetailFragment.java
new file mode 100644
index 00000000..16eaed98
--- /dev/null
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/RewardedVideoDetailFragment.java
@@ -0,0 +1,107 @@
+package com.mopub.simpleadsdemo;
+
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.v4.app.Fragment;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.Button;
+
+import com.mopub.common.MoPub;
+import com.mopub.common.MoPubReward;
+import com.mopub.mobileads.MoPubErrorCode;
+import com.mopub.mobileads.MoPubRewardedVideoListener;
+
+import java.util.Locale;
+import java.util.Set;
+
+import static com.mopub.simpleadsdemo.Utils.hideSoftKeyboard;
+import static com.mopub.simpleadsdemo.Utils.logToast;
+
+public class RewardedVideoDetailFragment extends Fragment implements MoPubRewardedVideoListener {
+
+    private Button mShowButton;
+    private static boolean rewardedVideoInitialized;
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        super.onCreateView(inflater, container, savedInstanceState);
+        final MoPubSampleAdUnit adConfiguration =
+                MoPubSampleAdUnit.fromBundle(getArguments());
+        final View view = inflater.inflate(R.layout.interstitial_detail_fragment, container, false);
+        final DetailFragmentViewHolder views = DetailFragmentViewHolder.fromView(view);
+        hideSoftKeyboard(views.mKeywordsField);
+
+        if (!rewardedVideoInitialized) {
+            MoPub.initializeRewardedVideo(getActivity());
+            rewardedVideoInitialized = true;
+        }
+        MoPub.setRewardedVideoListener(this);
+
+        final String adUnitId = adConfiguration.getAdUnitId();
+        views.mDescriptionView.setText(adConfiguration.getDescription());
+        views.mAdUnitIdView.setText(adUnitId);
+        views.mLoadButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                MoPub.loadRewardedVideo(adUnitId);
+                mShowButton.setEnabled(false);
+            }
+        });
+        mShowButton = (Button) view.findViewById(R.id.interstitial_show_button);
+        mShowButton.setEnabled(false);
+        mShowButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                MoPub.showRewardedVideo(adUnitId);
+            }
+        });
+
+        return view;
+    }
+
+    @Override
+    public void onDestroyView() {
+        super.onDestroyView();
+    }
+
+    // MoPubRewardedVideoListener implementation
+    @Override
+    public void onRewardedVideoLoadSuccess(@NonNull final String adUnitId) {
+        mShowButton.setEnabled(true);
+        logToast(getActivity(), "Rewarded video loaded.");
+    }
+
+    @Override
+    public void onRewardedVideoLoadFailure(@NonNull final String adUnitId, @NonNull final MoPubErrorCode errorCode) {
+        mShowButton.setEnabled(false);
+        logToast(getActivity(), String.format(Locale.US, "Rewarded video failed to load: %s", errorCode.toString()));
+    }
+
+    @Override
+    public void onRewardedVideoStarted(@NonNull final String adUnitId) {
+        logToast(getActivity(), "Rewarded video started.");
+        mShowButton.setEnabled(false);
+    }
+
+    @Override
+    public void onRewardedVideoPlaybackError(@NonNull final String adUnitId, @NonNull final MoPubErrorCode errorCode) {
+        logToast(getActivity(), String.format(Locale.US, "Rewarded video playback error: %s", errorCode.toString()));
+        mShowButton.setEnabled(false);
+    }
+
+    @Override
+    public void onRewardedVideoClosed(@NonNull final String adUnitId) {
+        logToast(getActivity(), "Rewarded video closed.");
+        mShowButton.setEnabled(false);
+    }
+
+    @Override
+    public void onRewardedVideoCompleted(@NonNull final Set<String> adUnitIds, @NonNull final MoPubReward reward) {
+        logToast(getActivity(),
+                String.format(Locale.US,
+                        "Rewarded video completed with reward  \"%d %s\"",
+                        reward.getAmount(),
+                        reward.getLabel()));
+    }
+}
diff --git a/mopub-sdk/AndroidManifest.xml b/mopub-sdk/AndroidManifest.xml
index 22ac7cb1..988c0a04 100644
--- a/mopub-sdk/AndroidManifest.xml
+++ b/mopub-sdk/AndroidManifest.xml
@@ -5,5 +5,6 @@
 		android:versionName="1.0">
 	<uses-sdk
         android:minSdkVersion="9"
-        android:targetSdkVersion="19"/>
+        android:targetSdkVersion="22"/>
+    <application/>
 </manifest>
\ No newline at end of file
diff --git a/mopub-sdk/build.gradle b/mopub-sdk/build.gradle
index 80abe4ae..ffa183ae 100644
--- a/mopub-sdk/build.gradle
+++ b/mopub-sdk/build.gradle
@@ -11,14 +11,14 @@ group = 'com.mopub'
 description = '''MoPub SDK'''
 
 android {
-    compileSdkVersion 19
-    buildToolsVersion '21.1.1'
+    compileSdkVersion 22
+    buildToolsVersion '22.0.1'
 
     defaultConfig {
-        versionCode 21
-        versionName "3.5.0"
+        versionCode 25
+        versionName "3.8.0"
         minSdkVersion 9
-        targetSdkVersion 19
+        targetSdkVersion 22
         consumerProguardFiles 'proguard.txt'
     }
 
@@ -48,12 +48,14 @@ android {
 }
 
 dependencies {
-    compile 'com.android.support:support-v4:19.1.+'
-    compile 'com.android.support:support-annotations:20.0.0'
-    compile 'com.mopub.volley:mopub-volley:1.0.0'
+    compile 'com.android.support:support-v4:22.0.0'
+    compile 'com.android.support:support-annotations:22.0.0'
+    compile 'com.mopub.volley:mopub-volley:1.1.0'
 }
 
-// Don't run the Robolectric Unit Tests. They don't build properly in Gradle or Android Studio in this version.
+// Don't run the Robolectric Unit Tests.
 check.dependsOn.remove("test")
+check.dependsOn.remove("unitTest")
 check.dependsOn.remove("testDebug")
+check.dependsOn.remove("unitTestDebug")
 
diff --git a/mopub-sdk/pom.xml b/mopub-sdk/pom.xml
index 5c907201..9b391fc2 100644
--- a/mopub-sdk/pom.xml
+++ b/mopub-sdk/pom.xml
@@ -11,7 +11,7 @@
 
     <artifactId>mopub-sdk</artifactId>
     <version>1.0.0-SNAPSHOT</version>
-    <packaging>jar</packaging>
+    <packaging>aar</packaging>
     <name>MoPub SDK</name>
     <description>The SDK for MoPub developers.</description>
 
@@ -25,19 +25,20 @@
         <dependency>
             <groupId>com.android.support</groupId>
             <artifactId>support-annotations</artifactId>
-            <version>20.0.0</version>
+            <version>22.0.0</version>
         </dependency>
 
         <dependency>
             <groupId>com.android.support</groupId>
             <artifactId>support-v4</artifactId>
-            <version>19.1.0</version>
+            <version>22.0.0</version>
+            <type>aar</type>
         </dependency>
 
         <dependency>
             <groupId>com.mopub.volley</groupId>
             <artifactId>mopub-volley</artifactId>
-            <version>1.0.0</version>
+            <version>1.1.0</version>
         </dependency>
 
         <!--test-->
@@ -98,13 +99,15 @@
                 </configuration>
             </plugin>
             <plugin>
-                <groupId>com.jayway.maven.plugins.android.generation2</groupId>
+                <groupId>com.simpligility.maven.plugins</groupId>
                 <artifactId>android-maven-plugin</artifactId>
-                <version>3.8.2</version>
+                <version>4.2.0</version>
                 <configuration>
+                    <androidManifestFile>AndroidManifest.xml</androidManifestFile>
+                    <resourceDirectory>res</resourceDirectory>
                     <sdk>
                         <!-- platform or api level (api level 4 = platform 1.6)-->
-                        <platform>19</platform>
+                        <platform>22</platform>
                     </sdk>
                     <undeployBeforeDeploy>true</undeployBeforeDeploy>
                 </configuration>
diff --git a/mopub-sdk/src/main/java/com/mopub/common/AdUrlGenerator.java b/mopub-sdk/src/main/java/com/mopub/common/AdUrlGenerator.java
index 79dc9d42..397a0d04 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/AdUrlGenerator.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/AdUrlGenerator.java
@@ -3,12 +3,104 @@
 import android.content.Context;
 import android.location.Location;
 import android.support.annotation.Nullable;
+import android.text.TextUtils;
 
-import com.mopub.common.util.Intents;
+import com.mopub.common.util.DateAndTime;
 
 import static com.mopub.common.ClientMetadata.MoPubNetworkType;
 
 public abstract class AdUrlGenerator extends BaseUrlGenerator {
+
+    /**
+     * The ad unit id which identifies a spot for an ad to be placed.
+     */
+    private static final String AD_UNIT_ID_KEY = "id";
+
+    /**
+     * nv = native version. This is the version of MoPub.
+     */
+    private static final String SDK_VERSION_KEY = "nv";
+
+    /**
+     * q = query. This is for big publishers to send up certain
+     * keywords that better match ads.
+     */
+    private static final String KEYWORDS_KEY = "q";
+
+    /**
+     * Location represented in latitude and longitude.
+     * e.g. "47.638,-122.321"
+     */
+    private static final String LAT_LONG_KEY = "ll";
+
+    /**
+     * Estimated accuracy of this location, in meters.
+     * See {@link android.location.Location#getAccuracy()}
+     * for more information.
+     */
+    private static final String LAT_LONG_ACCURACY_KEY = "lla";
+
+    /**
+     * Milliseconds since location was updated.
+     */
+    private static final String LAT_LONG_FRESHNESS_KEY = "llf";
+
+    /**
+     * Whether or not the location came from the MoPub SDK
+     * and not the developer. 1 = from MoPub.
+     */
+    private static final String LAT_LONG_FROM_SDK_KEY = "llsdk";
+
+    /**
+     * Timezone offset. e.g. Pacific Standard Time = -0800.
+     */
+    private static final String TIMEZONE_OFFSET_KEY = "z";
+
+    /**
+     * "p" for portrait, "l" for landscape
+     */
+    private static final String ORIENTATION_KEY = "o";
+
+    /**
+     * Density as represented by a float. See
+     * http://developer.android.com/guide/practices/screens_support.html
+     * for details on values this can be.
+     */
+    private static final String SCREEN_SCALE_KEY = "sc_a";
+
+    /**
+     * Whether or not this is using mraid. 1 = yes.
+     */
+    private static final String IS_MRAID_KEY = "mr";
+
+    /**
+     * mcc, the mobile country code, paired with the mobile network code,
+     * uniquely identifies a carrier in a country.
+     */
+    private static final String MOBILE_COUNTRY_CODE_KEY = "mcc";
+    private static final String MOBILE_NETWORK_CODE_KEY = "mnc";
+
+    /**
+     * The International Organization for Standardization's 2-character country code
+     */
+    private static final String COUNTRY_CODE_KEY = "iso";
+
+    /**
+     * String name of the carrier. e.g. "Verizon%20Wireless"
+     */
+    private static final String CARRIER_NAME_KEY = "cn";
+
+    /**
+     * Carrier type as in what kind of network this device is on.
+     * See {@link android.net.ConnectivityManager} for constants.
+     */
+    private static final String CARRIER_TYPE_KEY = "ct";
+
+    /**
+     * Bundle ID, as in package name.
+     */
+    private static final String BUNDLE_ID_KEY = "bundle";
+
     protected Context mContext;
     protected String mAdUnitId;
     protected String mKeywords;
@@ -34,15 +126,15 @@ public AdUrlGenerator withLocation(Location location) {
     }
 
     protected void setAdUnitId(String adUnitId) {
-        addParam("id", adUnitId);
+        addParam(AD_UNIT_ID_KEY, adUnitId);
     }
 
     protected void setSdkVersion(String sdkVersion) {
-        addParam("nv", sdkVersion);
+        addParam(SDK_VERSION_KEY, sdkVersion);
     }
 
     protected void setKeywords(String keywords) {
-        addParam("q", keywords);
+        addParam(KEYWORDS_KEY, keywords);
     }
 
     protected void setLocation(@Nullable Location location) {
@@ -57,51 +149,94 @@ protected void setLocation(@Nullable Location location) {
         }
 
         if (bestLocation != null) {
-            addParam("ll", bestLocation.getLatitude() + "," + bestLocation.getLongitude());
-            addParam("lla", "" + (int) bestLocation.getAccuracy());
+            addParam(LAT_LONG_KEY, bestLocation.getLatitude() + "," + bestLocation.getLongitude());
+            addParam(LAT_LONG_ACCURACY_KEY, String.valueOf((int) bestLocation.getAccuracy()));
+            addParam(LAT_LONG_FRESHNESS_KEY,
+                    String.valueOf(calculateLocationStalenessInMilliseconds(bestLocation)));
 
             if (bestLocation == locationFromLocationService) {
-                addParam("llsdk", "1");
+                addParam(LAT_LONG_FROM_SDK_KEY, "1");
             }
         }
     }
 
     protected void setTimezone(String timeZoneOffsetString) {
-        addParam("z", timeZoneOffsetString);
+        addParam(TIMEZONE_OFFSET_KEY, timeZoneOffsetString);
     }
 
     protected void setOrientation(String orientation) {
-        addParam("o", orientation);
+        addParam(ORIENTATION_KEY, orientation);
     }
 
     protected void setDensity(float density) {
-        addParam("sc_a", "" + density);
+        addParam(SCREEN_SCALE_KEY, "" + density);
     }
 
     protected void setMraidFlag(boolean mraid) {
-        if (mraid) addParam("mr", "1");
+        if (mraid) {
+            addParam(IS_MRAID_KEY, "1");
+        }
     }
 
     protected void setMccCode(String networkOperator) {
         String mcc = networkOperator == null ? "" : networkOperator.substring(0, mncPortionLength(networkOperator));
-        addParam("mcc", mcc);
+        addParam(MOBILE_COUNTRY_CODE_KEY, mcc);
     }
 
     protected void setMncCode(String networkOperator) {
         String mnc = networkOperator == null ? "" : networkOperator.substring(mncPortionLength(networkOperator));
-        addParam("mnc", mnc);
+        addParam(MOBILE_NETWORK_CODE_KEY, mnc);
     }
 
     protected void setIsoCountryCode(String networkCountryIso) {
-        addParam("iso", networkCountryIso);
+        addParam(COUNTRY_CODE_KEY, networkCountryIso);
     }
 
     protected void setCarrierName(String networkOperatorName) {
-        addParam("cn", networkOperatorName);
+        addParam(CARRIER_NAME_KEY, networkOperatorName);
     }
 
     protected void setNetworkType(MoPubNetworkType networkType) {
-        addParam("ct", networkType);
+        addParam(CARRIER_TYPE_KEY, networkType);
+    }
+
+    protected void setBundleId(String bundleId) {
+        if (!TextUtils.isEmpty(bundleId)) {
+            addParam(BUNDLE_ID_KEY, bundleId);
+        }
+    }
+
+    protected void addBaseParams(final ClientMetadata clientMetadata) {
+        setAdUnitId(mAdUnitId);
+
+        setSdkVersion(clientMetadata.getSdkVersion());
+        setDeviceInfo(clientMetadata.getDeviceManufacturer(),
+                clientMetadata.getDeviceModel(),
+                clientMetadata.getDeviceProduct());
+        setBundleId(clientMetadata.getAppPackageName());
+
+        setKeywords(mKeywords);
+
+        setLocation(mLocation);
+
+        setTimezone(DateAndTime.getTimeZoneOffsetString());
+
+        setOrientation(clientMetadata.getOrientationString());
+        setDeviceDimensions(clientMetadata.getDeviceDimensions());
+        setDensity(clientMetadata.getDensity());
+
+        final String networkOperator = clientMetadata.getNetworkOperatorForUrl();
+        setMccCode(networkOperator);
+        setMncCode(networkOperator);
+
+        setIsoCountryCode(clientMetadata.getIsoCountryCode());
+        setCarrierName(clientMetadata.getNetworkOperatorName());
+
+        setNetworkType(clientMetadata.getActiveNetworkType());
+
+        setAppVersion(clientMetadata.getAppVersion());
+
+        appendAdvertisingInfoTemplates();
     }
 
     private void addParam(String key, MoPubNetworkType value) {
@@ -112,6 +247,13 @@ private int mncPortionLength(String networkOperator) {
         return Math.min(3, networkOperator.length());
     }
 
+    private static int calculateLocationStalenessInMilliseconds(final Location location) {
+        Preconditions.checkNotNull(location);
+        final long locationLastUpdatedInMillis = location.getTime();
+        final long nowInMillis = System.currentTimeMillis();
+        return (int) (nowInMillis - locationLastUpdatedInMillis);
+    }
+
     /**
      * @deprecated As of release 2.4
      */
diff --git a/mopub-sdk/src/main/java/com/mopub/common/BaseUrlGenerator.java b/mopub-sdk/src/main/java/com/mopub/common/BaseUrlGenerator.java
index 495f1bfc..68d88289 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/BaseUrlGenerator.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/BaseUrlGenerator.java
@@ -1,13 +1,17 @@
 package com.mopub.common;
 
+import android.graphics.Point;
 import android.net.Uri;
+import android.support.annotation.NonNull;
 import android.text.TextUtils;
 
+import com.mopub.network.Networking;
 import com.mopub.network.PlayServicesUrlRewriter;
 
 public abstract class BaseUrlGenerator {
 
-
+    private static final String WIDTH_KEY = "w";
+    private static final String HEIGHT_KEY = "h";
 
     private StringBuilder mStringBuilder;
     private boolean mFirstParam;
@@ -15,7 +19,8 @@
     public abstract String generateUrlString(String serverHostname);
 
     protected void initUrlString(String serverHostname, String handlerType) {
-        mStringBuilder = new StringBuilder("http://" + serverHostname + handlerType);
+        String scheme = Networking.useHttps() ? Constants.HTTPS : Constants.HTTP;
+        mStringBuilder = new StringBuilder(scheme).append("://").append(serverHostname).append(handlerType);
         mFirstParam = true;
     }
 
@@ -80,10 +85,20 @@ protected void setUdid(String udid) {
 
     /**
      * Appends special keys/values for advertising id and do-not-track. PlayServicesUrlRewriter will
-     * replace these templates wiht the correct values when the request is processed.
+     * replace these templates with the correct values when the request is processed.
      */
     protected void appendAdvertisingInfoTemplates() {
         addParam("udid", PlayServicesUrlRewriter.UDID_TEMPLATE);
         addParam("dnt", PlayServicesUrlRewriter.DO_NOT_TRACK_TEMPLATE);
     }
+
+    /**
+     * Adds the width and height.
+     *
+     * @param dimensions The width and height of the screen
+     */
+    protected void setDeviceDimensions(@NonNull final Point dimensions) {
+        addParam(WIDTH_KEY, "" + dimensions.x);
+        addParam(HEIGHT_KEY, "" + dimensions.y);
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/ClientMetadata.java b/mopub-sdk/src/main/java/com/mopub/common/ClientMetadata.java
index 6076ad65..412f47be 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/ClientMetadata.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/ClientMetadata.java
@@ -5,15 +5,16 @@
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.content.res.Configuration;
+import android.graphics.Point;
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
 import android.os.Build;
 import android.provider.Settings;
 import android.telephony.TelephonyManager;
-import android.view.Display;
-import android.view.WindowManager;
 
 import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.DeviceUtils;
+import com.mopub.common.util.Dips;
 import com.mopub.common.util.Utils;
 
 import java.util.Locale;
@@ -86,15 +87,13 @@ public int getId() {
         }
     }
 
-    private static ClientMetadata sInstance;
+    private static volatile ClientMetadata sInstance;
 
     // Cached client metadata used for generating URLs and events.
     private final String mDeviceManufacturer;
     private final String mDeviceModel;
     private final String mDeviceProduct;
     private final String mDeviceOsVersion;
-    private final int mDeviceScreenWidthPx;
-    private final int mDeviceScreenHeightPx;
     private final String mSdkVersion;
     private final String mAppVersion;
     private final String mAppPackageName;
@@ -137,7 +136,6 @@ public static ClientMetadata getInstance() {
         return result;
     }
 
-
     // NEVER CALL THIS AS A USER. Get it from the Singletons class.
     public ClientMetadata(Context context) {
         mContext = context.getApplicationContext();
@@ -148,11 +146,6 @@ public ClientMetadata(Context context) {
         mDeviceProduct = Build.PRODUCT;
         mDeviceOsVersion = Build.VERSION.RELEASE;
 
-        WindowManager wm = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
-        Display display = wm.getDefaultDisplay();
-        mDeviceScreenWidthPx = display.getWidth();
-        mDeviceScreenHeightPx = display.getHeight();
-
         mSdkVersion = MoPub.SDK_VERSION;
 
         // Cache context items that don't change:
@@ -357,17 +350,31 @@ public String getDeviceOsVersion() {
     }
 
     /**
-     * @return the device screen width in pixels.
+     * @return the device screen width in dips according to current orientation.
      */
-    public int getDeviceScreenWidthPx() {
-        return mDeviceScreenWidthPx;
+    public int getDeviceScreenWidthDip() {
+        return Dips.screenWidthAsIntDips(mContext);
     }
 
     /**
-     * @return the device screen height in pixels.
+     * @return the device screen height in dips according to current orientation.
      */
-    public int getDeviceScreenHeightPx() {
-        return mDeviceScreenHeightPx;
+    public int getDeviceScreenHeightDip() {
+        return Dips.screenHeightAsIntDips(mContext);
+    }
+
+    /**
+     * This tries to get the physical number of pixels on the device. This attempts to include
+     * the pixels in the notification bar and soft buttons. This method only works after
+     * mContext is initialized.
+     *
+     * @return Width and height of the device. This is 0 by 0 if there is no context.
+     */
+    public Point getDeviceDimensions() {
+        if (Preconditions.NoThrow.checkNotNull(mContext)) {
+            return DeviceUtils.getDeviceDimensions(mContext);
+        }
+        return new Point(0, 0);
     }
 
     /**
@@ -398,6 +405,14 @@ public String getAppName() {
         return mAppName;
     }
 
+    @Deprecated
+    @VisibleForTesting
+    public static void setInstance(ClientMetadata clientMetadata) {
+        synchronized (ClientMetadata.class) {
+            sInstance = clientMetadata;
+        }
+    }
+
     @VisibleForTesting
     public static void clearForTesting() {
         sInstance = null;
diff --git a/mopub-sdk/src/main/java/com/mopub/common/Constants.java b/mopub-sdk/src/main/java/com/mopub/common/Constants.java
index 4bdce8b3..0ca157fe 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/Constants.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/Constants.java
@@ -3,7 +3,10 @@
 public class Constants {
     private Constants() {}
 
-    public static String HOST = "ads.mopub.com";
+    public static final String HTTP = "http";
+    public static final String HTTPS = "https";
+
+    public static final String HOST = "ads.mopub.com";
 
     public static final String AD_HANDLER = "/m/ad";
     public static final String CONVERSION_TRACKING_HANDLER = "/m/open";
@@ -12,4 +15,6 @@ private Constants() {}
 
     public static final int TEN_SECONDS_MILLIS = 10 * 1000;
     public static final int THIRTY_SECONDS_MILLIS = 30 * 1000;
+
+    public static final int TEN_MB = 10 * 1024 * 1024;
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/CreativeOrientation.java b/mopub-sdk/src/main/java/com/mopub/common/CreativeOrientation.java
new file mode 100644
index 00000000..f6fec437
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/CreativeOrientation.java
@@ -0,0 +1,24 @@
+package com.mopub.common;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+/**
+ * Represents the orientation returned for MoPub ads from the MoPub ad server.
+ */
+public enum CreativeOrientation {
+    PORTRAIT, LANDSCAPE, UNDEFINED;
+
+    @NonNull
+    public static CreativeOrientation fromHeader(@Nullable String orientation) {
+        if ("l".equalsIgnoreCase(orientation)) {
+            return LANDSCAPE;
+        }
+
+        if ("p".equalsIgnoreCase(orientation)) {
+            return PORTRAIT;
+        }
+
+        return UNDEFINED;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/DataKeys.java b/mopub-sdk/src/main/java/com/mopub/common/DataKeys.java
index 79b5d9b0..3adb73e3 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/DataKeys.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/DataKeys.java
@@ -9,7 +9,10 @@
     public static final String REDIRECT_URL_KEY = "Redirect-Url";
     public static final String CLICKTHROUGH_URL_KEY = "Clickthrough-Url";
     public static final String SCROLLABLE_KEY = "Scrollable";
+    public static final String CREATIVE_ORIENTATION_KEY = "com_mopub_orientation";
     public static final String JSON_BODY_KEY = "com_mopub_native_json";
     public static final String BROADCAST_IDENTIFIER_KEY = "broadcastIdentifier";
     public static final String AD_UNIT_ID_KEY = "com_mopub_ad_unit_id";
+    public static final String AD_WIDTH = "com_mopub_ad_width";
+    public static final String AD_HEIGHT = "com_mopub_ad_height";
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/DownloadTask.java b/mopub-sdk/src/main/java/com/mopub/common/DownloadTask.java
index 80eed502..7230a2ae 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/DownloadTask.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/DownloadTask.java
@@ -3,9 +3,6 @@
 import android.net.http.AndroidHttpClient;
 import android.os.AsyncTask;
 
-import com.mopub.common.event.ErrorEvent;
-import com.mopub.common.event.Event;
-import com.mopub.common.event.MoPubEvents;
 import com.mopub.common.logging.MoPubLog;
 
 import org.apache.http.HttpResponse;
@@ -13,7 +10,6 @@
 
 public class DownloadTask extends AsyncTask<HttpUriRequest, Void, DownloadResponse> {
     private final DownloadTaskListener mDownloadTaskListener;
-    private final MoPubEvents.Type mEventType;
     private String mUrl;
 
     public static interface DownloadTaskListener {
@@ -21,16 +17,11 @@
     }
 
     public DownloadTask(final DownloadTaskListener downloadTaskListener) throws IllegalArgumentException {
-        this(downloadTaskListener, null);
-    }
-
-    public DownloadTask(final DownloadTaskListener downloadTaskListener, final MoPubEvents.Type eventType) {
         if (downloadTaskListener == null) {
             throw new IllegalArgumentException("DownloadTaskListener must not be null.");
         }
 
         mDownloadTaskListener = downloadTaskListener;
-        mEventType = eventType;
     }
 
     @Override
@@ -42,9 +33,6 @@ protected DownloadResponse doInBackground(final HttpUriRequest... httpUriRequest
 
         final HttpUriRequest httpUriRequest = httpUriRequests[0];
         mUrl = httpUriRequest.getURI().toString();
-        if (mEventType != null) {
-            MoPubEvents.log(new Event.Builder("", "").build());
-        }
 
         AndroidHttpClient httpClient = null;
         try {
diff --git a/mopub-sdk/src/main/java/com/mopub/common/LocationService.java b/mopub-sdk/src/main/java/com/mopub/common/LocationService.java
index 52b2c67b..6602db66 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/LocationService.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/LocationService.java
@@ -3,6 +3,7 @@
 import android.content.Context;
 import android.location.Location;
 import android.location.LocationManager;
+import android.support.annotation.Nullable;
 
 import com.mopub.common.logging.MoPubLog;
 
@@ -48,6 +49,7 @@
      * - The location providers don't exist
      * - Location awareness is disabled in the parent MoPubView
      */
+    @Nullable
     public static Location getLastKnownLocation(final Context context,
             final int locationPrecision,
             final MoPub.LocationAwareness locationLocationAwareness) {
@@ -65,6 +67,8 @@ public static Location getLastKnownLocation(final Context context,
             MoPubLog.d("Failed to retrieve GPS location: access appears to be disabled.");
         } catch (IllegalArgumentException e) {
             MoPubLog.d("Failed to retrieve GPS location: device has no GPS provider.");
+        } catch (NullPointerException e) { // This happens on 4.2.2 on a few Android TV devices
+            MoPubLog.d("Failed to retrieve GPS location: device has no GPS provider.");
         }
 
         Location networkLocation = null;
@@ -74,6 +78,8 @@ public static Location getLastKnownLocation(final Context context,
             MoPubLog.d("Failed to retrieve network location: access appears to be disabled.");
         } catch (IllegalArgumentException e) {
             MoPubLog.d("Failed to retrieve network location: device has no network provider.");
+        }  catch (NullPointerException e) { // This happens on 4.2.2 on a few Android TV devices
+            MoPubLog.d("Failed to retrieve GPS location: device has no network provider.");
         }
 
         if (gpsLocation == null && networkLocation == null) {
diff --git a/mopub-sdk/src/main/java/com/mopub/common/MoPub.java b/mopub-sdk/src/main/java/com/mopub/common/MoPub.java
index 9de497aa..12e2921d 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/MoPub.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/MoPub.java
@@ -8,7 +8,7 @@
 import com.mopub.mobileads.MoPubRewardedVideoManager;
 
 public class MoPub {
-    public static final String SDK_VERSION = "3.5.0";
+    public static final String SDK_VERSION = "3.8.0";
 
     public static enum LocationAwareness { NORMAL, TRUNCATED, DISABLED }
 
diff --git a/mopub-sdk/src/main/java/com/mopub/common/MoPubBrowser.java b/mopub-sdk/src/main/java/com/mopub/common/MoPubBrowser.java
index 241f2f7b..b4e88938 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/MoPubBrowser.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/MoPubBrowser.java
@@ -10,6 +10,7 @@
 import android.os.Bundle;
 import android.view.Gravity;
 import android.view.View;
+import android.view.ViewGroup;
 import android.view.Window;
 import android.webkit.CookieSyncManager;
 import android.webkit.WebChromeClient;
@@ -21,6 +22,7 @@
 import android.widget.RelativeLayout;
 
 import com.mopub.common.logging.MoPubLog;
+import com.mopub.mobileads.BaseWebView;
 import com.mopub.mobileads.util.WebViews;
 
 import static android.view.ViewGroup.LayoutParams.MATCH_PARENT;
@@ -33,7 +35,6 @@
 import static com.mopub.common.util.Drawables.UNLEFT_ARROW;
 import static com.mopub.common.util.Drawables.UNRIGHT_ARROW;
 import static com.mopub.common.util.Intents.deviceCanHandleIntent;
-import static com.mopub.common.util.Intents.isDeepLink;
 
 public class MoPubBrowser extends Activity {
     public static final String DESTINATION_URL_KEY = "URL";
@@ -98,7 +99,8 @@ public boolean shouldOverrideUrlLoading(WebView view, String url) {
                 }
 
                 final Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
-                if (isDeepLink(url) && deviceCanHandleIntent(MoPubBrowser.this, intent)) {
+                if (UrlAction.FOLLOW_DEEP_LINK.shouldTryHandlingUrl(Uri.parse(url))
+                        && deviceCanHandleIntent(MoPubBrowser.this, intent)) {
                     startActivity(intent);
                     finish();
                     return true;
@@ -193,6 +195,15 @@ protected void onResume() {
         WebViews.onResume(mWebView);
     }
 
+    @Override
+    public void finish() {
+        // ZoomButtonController adds buttons to the window's decorview. If they're still visible
+        // when finish() is called, they need to be removed or a Window object will be leaked.
+        ViewGroup decorView = (ViewGroup) getWindow().getDecorView();
+        decorView.removeAllViews();
+        super.finish();
+    }
+
     @Override
     protected void onDestroy() {
         super.onDestroy();
@@ -229,7 +240,7 @@ private View getMoPubBrowserView() {
         innerLayout.addView(mRefreshButton);
         innerLayout.addView(mCloseButton);
 
-        mWebView = new WebView(this);
+        mWebView = new BaseWebView(this);
         RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(MATCH_PARENT, MATCH_PARENT);
         layoutParams.addRule(RelativeLayout.ABOVE, INNER_LAYOUT_ID);
         mWebView.setLayoutParams(layoutParams);
diff --git a/mopub-sdk/src/main/java/com/mopub/common/UrlAction.java b/mopub-sdk/src/main/java/com/mopub/common/UrlAction.java
new file mode 100644
index 00000000..d8fd9c92
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/UrlAction.java
@@ -0,0 +1,246 @@
+package com.mopub.common;
+
+import android.content.Context;
+import android.content.Intent;
+import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Intents;
+import com.mopub.exceptions.IntentNotResolvableException;
+import com.mopub.exceptions.UrlParseException;
+
+import static com.mopub.common.Constants.HTTP;
+import static com.mopub.common.Constants.HTTPS;
+import static com.mopub.common.UrlHandler.MoPubSchemeListener;
+
+/**
+ * {@code UrlAction} describes the different kinds of actions for URLs that {@link UrlHandler} can
+ * potentially perform and how to match against each URL.
+ */
+public enum UrlAction {
+    /**
+     * NOTE: The order in which these are defined determines the priority when matching URLs!
+     * If a URL matches multiple Url Actions, it will be handled by the one that appears first in
+     * this enum (see {@link UrlHandler#handleUrl(Context, String)}).
+     *
+     * Each UrlAction includes its ordinal in a comment as a reminder of this fact.
+     */
+
+    /* 0 */ HANDLE_MOPUB_SCHEME(false) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            return "mopub".equals(uri.getScheme());
+        }
+
+        @Override
+        protected void performAction(@NonNull final Context context, @NonNull final Uri uri,
+                final boolean skipShowMoPubBrowser,
+                @Nullable final MoPubSchemeListener moPubSchemeListener)
+                throws IntentNotResolvableException {
+            final String host = uri.getHost();
+
+            if ("finishLoad".equals(host)) {
+                moPubSchemeListener.onFinishLoad();
+            } else if ("close".equals(host)) {
+                moPubSchemeListener.onClose();
+            } else if ("failLoad".equals(host)) {
+                moPubSchemeListener.onFailLoad();
+            } else {
+                throw new IntentNotResolvableException("Could not handle MoPub Scheme url: " + uri);
+            }
+        }
+    },
+
+    /* 1 */ IGNORE_ABOUT_SCHEME(false) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            return "about".equals(uri.getScheme());
+        }
+
+        @Override
+        protected void performAction(@NonNull final Context context, @NonNull final Uri uri,
+                final boolean skipShowMoPubBrowser,
+                @Nullable final MoPubSchemeListener moPubSchemeListener)
+                throws IntentNotResolvableException {
+            MoPubLog.d("Link to about page ignored.");
+        }
+    },
+
+    /* 2 */ HANDLE_PHONE_SCHEME(true) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            final String scheme = uri.getScheme();
+            return "tel".equals(scheme) || "voicemail".equals(scheme)
+                    || "sms".equals(scheme) || "mailto".equals(scheme)
+                    || "geo".equals(scheme)
+                    || "google.streetview".equals(scheme);
+        }
+
+        @Override
+        protected void performAction(@NonNull final Context context, @NonNull final Uri uri,
+                final boolean skipShowMoPubBrowser,
+                @Nullable final MoPubSchemeListener moPubSchemeListener)
+                throws IntentNotResolvableException {
+            final String errorMessage = "Could not handle intent with URI: " + uri + "\n\tIs " +
+                    "this intent supported on your phone?";
+            Intents.launchActionViewIntent(context, uri, errorMessage);
+        }
+    },
+
+    /* 3 */ OPEN_NATIVE_BROWSER(true) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            return "mopubnativebrowser".equals(uri.getScheme());
+        }
+
+        @Override
+        protected void performAction(@NonNull final Context context, @NonNull final Uri uri,
+                final boolean skipShowMoPubBrowser,
+                @Nullable final MoPubSchemeListener moPubSchemeListener)
+                throws IntentNotResolvableException {
+            final String errorMessage = "Unable to load mopub native browser url: " + uri;
+            try {
+                final Intent intent = Intents.intentForNativeBrowserScheme(uri);
+                Intents.launchIntentForUserClick(context, intent, errorMessage);
+            } catch (UrlParseException e) {
+                throw new IntentNotResolvableException(errorMessage + "\n\t" + e.getMessage());
+            }
+        }
+    },
+
+    /* 4 */ OPEN_APP_MARKET(true) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            final String scheme = uri.getScheme();
+            final String host = uri.getHost();
+
+            return "play.google.com".equals(host) || "market.android.com".equals(host)
+                    || "market".equals(scheme)
+                    || uri.toString().startsWith("play.google.com/")
+                    || uri.toString().startsWith("market.android.com/");
+        }
+
+        @Override
+        protected void performAction(@NonNull final Context context, @NonNull final Uri uri,
+                final boolean skipShowMoPubBrowser,
+                @Nullable final MoPubSchemeListener moPubSchemeListener)
+                throws IntentNotResolvableException {
+            Intents.launchApplicationUrl(context, uri);
+        }
+    },
+
+    /* 5 */ OPEN_IN_APP_BROWSER(true) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            final String scheme = uri.getScheme();
+            return (HTTP.equals(scheme) || HTTPS.equals(scheme));
+        }
+
+        @Override
+        protected void performAction(@NonNull final Context context, @NonNull final Uri uri,
+                final boolean skipShowMoPubBrowser,
+                @Nullable final MoPubSchemeListener moPubSchemeListener)
+                throws IntentNotResolvableException {
+            if (!skipShowMoPubBrowser) {
+                Intents.showMoPubBrowserForUrl(context, uri);
+            }
+        }
+    },
+
+    /**
+     * This handles tweet sharing via the chooser dialog.
+     * See {@link Intents#intentForShareTweet(Uri)} for more details.
+     */
+    /* 6 */ HANDLE_SHARE_TWEET(true) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            Preconditions.checkNotNull(uri);
+            return "mopubshare".equals(uri.getScheme()) && "tweet".equals(uri.getHost());
+        }
+
+        @Override
+        protected void performAction(@NonNull final Context context, @NonNull final Uri uri,
+                final boolean skipShowMoPubBrowser,
+                @Nullable final MoPubSchemeListener moPubSchemeListener)
+                throws IntentNotResolvableException {
+            Preconditions.checkNotNull(context);
+            Preconditions.checkNotNull(uri);
+
+            final String chooserText = "Share via";
+            final String errorMessage = "Could not handle share tweet intent with URI " + uri;
+            try {
+                final Intent shareTweetIntent = Intents.intentForShareTweet(uri);
+                final Intent chooserIntent = Intent.createChooser(shareTweetIntent, chooserText);
+                Intents.launchIntentForUserClick(context, chooserIntent, errorMessage);
+            } catch (UrlParseException e) {
+                throw new IntentNotResolvableException(errorMessage + "\n\t" + e.getMessage());
+            }
+        }
+    },
+
+    /* 7 */ FOLLOW_DEEP_LINK(true) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            final String scheme = uri.getScheme();
+            final String host = uri.getHost();
+            return !TextUtils.isEmpty(scheme) && !TextUtils.isEmpty(host);
+        }
+
+        @Override
+        protected void performAction(@NonNull final Context context, @NonNull final Uri uri,
+                final boolean skipShowMoPubBrowser,
+                @Nullable final MoPubSchemeListener moPubSchemeListener)
+                throws IntentNotResolvableException {
+            Intents.launchApplicationUrl(context, uri);
+        }
+    },
+
+    /* This is essentially an "unspecified" value for UrlAction. */
+    NOOP(false) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            return false;
+        }
+
+        @Override
+        protected void performAction(@NonNull final Context context, @NonNull final Uri uri,
+                final boolean skipShowMoPubBrowser,
+                @Nullable final MoPubSchemeListener moPubSchemeListener)
+                throws IntentNotResolvableException { }
+    };
+
+    public void handleUrl(
+            @NonNull final Context context,
+            @NonNull final Uri destinationUri,
+            final boolean fromUserInteraction,
+            final boolean skipShowMoPubBrowser,
+            @Nullable final MoPubSchemeListener moPubSchemeListener)
+            throws IntentNotResolvableException {
+        MoPubLog.d("Ad event URL: " + destinationUri);
+        if (mRequiresUserInteraction && !fromUserInteraction) {
+            throw new IntentNotResolvableException("Attempted to handle action without user " +
+                    "interaction.");
+        } else {
+            performAction(context, destinationUri, skipShowMoPubBrowser,
+                    moPubSchemeListener);
+        }
+    }
+
+    private final boolean mRequiresUserInteraction;
+
+    UrlAction(boolean requiresUserInteraction) {
+        mRequiresUserInteraction = requiresUserInteraction;
+    }
+
+    public abstract boolean shouldTryHandlingUrl(@NonNull final Uri uri);
+
+    protected abstract void performAction(
+            @NonNull final Context context,
+            @NonNull final Uri uri,
+            final boolean skipShowMoPubBrowser,
+            @Nullable final MoPubSchemeListener moPubSchemeListener)
+            throws IntentNotResolvableException;
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/UrlHandler.java b/mopub-sdk/src/main/java/com/mopub/common/UrlHandler.java
new file mode 100644
index 00000000..9d62edc1
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/UrlHandler.java
@@ -0,0 +1,224 @@
+package com.mopub.common;
+
+import android.content.Context;
+import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Intents;
+import com.mopub.exceptions.IntentNotResolvableException;
+
+import java.util.EnumSet;
+
+
+/**
+ * {@code UrlHandler} facilitates handling user clicks on different URLs, allowing configuration
+ * for which kinds of URLs to handle and then responding accordingly for a given URL.
+ *
+ * This class is designed to be instantiated for a single use by immediately calling its {@link
+ * #handleUrl(Context, String)} method upon constructing it.
+ */
+public class UrlHandler {
+
+    /**
+     * {@code ClickListener} defines the methods that {@link UrlHandler} calls when handling a
+     * certain click succeeds or fails.
+     */
+    public interface ResultActions {
+        /**
+         * Called if the URL matched a supported {@link UrlAction} and was resolvable. Will be
+         * called at most 1 times and is mutually exclusive with
+         * {@link ResultActions#urlHandlingFailed(String, UrlAction)}.
+         */
+        void urlHandlingSucceeded(@NonNull final String url, @NonNull final UrlAction urlAction);
+
+        /**
+         * Called with {@link UrlAction#NOOP} if the URL did not match any supported
+         * {@link UrlAction}s; or, called with the last matching {@link UrlAction} if URL was
+         * unresolvable. Will be called at most 1 times and is mutually exclusive with
+         * {@link ResultActions#urlHandlingSucceeded(String, UrlAction)}.
+         */
+        void urlHandlingFailed(@NonNull final String url,
+                @NonNull final UrlAction lastFailedUrlAction);
+    }
+
+    /**
+     * {@code MoPubSchemeListener} defines the methods that {@link UrlHandler} calls when handling
+     * {@code HANDLE_MOPUB_SCHEME} URLs.
+     */
+    public interface MoPubSchemeListener {
+        void onFinishLoad();
+        void onClose();
+        void onFailLoad();
+    }
+
+    /**
+     * {@code Builder} provides an API to configure an immutable {@link UrlHandler} and create it.
+     */
+    public static class Builder {
+        @NonNull
+        private EnumSet<UrlAction> supportedUrlActions = EnumSet.of(UrlAction.NOOP);
+        @NonNull
+        private ResultActions resultActions = EMPTY_CLICK_LISTENER;
+        @NonNull
+        private MoPubSchemeListener moPubSchemeListener = EMPTY_MOPUB_SCHEME_LISTENER;
+        private boolean skipShowMoPubBrowser = false;
+
+        /**
+         * Sets the {@link UrlAction}s to support in the {@code UrlHandler} to build.
+         *
+         * @param first A {@code UrlAction} for the {@code UrlHandler} to support.
+         * @param others An arbitrary number of {@code UrlAction}s for the {@code UrlHandler} to
+         * support.
+         * @return A {@link com.mopub.common.UrlHandler.Builder} with the desired supported
+         * {@code UrlAction}s added.
+         */
+        public Builder withSupportedUrlActions(@NonNull final UrlAction first,
+                @Nullable final UrlAction... others) {
+            this.supportedUrlActions = EnumSet.of(first, others);
+            return this;
+        }
+
+        /**
+         * Sets the {@link ResultActions} for the {@code UrlHandler} to
+         * build.
+         *
+         * @param resultActions A {@code ClickListener} for the {@code UrlHandler}.
+         * @return A {@link com.mopub.common.UrlHandler.Builder} with the desired
+         * {@code ClickListener} added.
+         */
+        public Builder withResultActions(@NonNull final ResultActions resultActions) {
+            this.resultActions = resultActions;
+            return this;
+        }
+
+        /**
+         * Sets the {@link com.mopub.common.UrlHandler.MoPubSchemeListener} for the
+         * {@code UrlHandler} to build.
+         *
+         * @param moPubSchemeListener A {@code MoPubSchemeListener} for the {@code UrlHandler}.
+         * @return A {@link com.mopub.common.UrlHandler.Builder} with the desired
+         * {@code MoPubSchemeListener} added.
+         */
+        public Builder withMoPubSchemeListener(
+                @NonNull final MoPubSchemeListener moPubSchemeListener) {
+            this.moPubSchemeListener = moPubSchemeListener;
+            return this;
+        }
+
+        /**
+         * If called, will avoid starting a {@link MoPubBrowser} activity where applicable.
+         * (see {@link Intents#showMoPubBrowserForUrl(Context, Uri)})
+         *
+         * @return A {@link com.mopub.common.UrlHandler.Builder} that will skip starting a
+         * {@code MoPubBrowser}.
+         */
+        public Builder withoutMoPubBrowser() {
+            this.skipShowMoPubBrowser = true;
+            return this;
+        }
+
+        /**
+         * Creates an immutable {@link UrlHandler} with the desired configuration, according to the
+         * other {@link com.mopub.common.UrlHandler.Builder} methods called before.
+         *
+         * @return An immutable {@code UrlHandler} with the desired configuration.
+         */
+        public UrlHandler build() {
+            return new UrlHandler(supportedUrlActions, resultActions, moPubSchemeListener,
+                    skipShowMoPubBrowser);
+        }
+    }
+
+    private static final ResultActions EMPTY_CLICK_LISTENER = new ResultActions() {
+        @Override
+        public void urlHandlingSucceeded(@NonNull String url, @NonNull UrlAction urlAction) { }
+        @Override
+        public void urlHandlingFailed(@NonNull String url, @NonNull UrlAction lastFailedUrlAction) { }
+    };
+
+    private static final MoPubSchemeListener EMPTY_MOPUB_SCHEME_LISTENER =
+            new MoPubSchemeListener() {
+        @Override public void onFinishLoad() { }
+
+        @Override public void onClose() { }
+
+        @Override public void onFailLoad() { }
+    };
+
+    @NonNull
+    private EnumSet<UrlAction> mSupportedUrlActions;
+    @NonNull
+    private ResultActions mResultActions;
+    @NonNull
+    private MoPubSchemeListener mMoPubSchemeListener;
+    private boolean mSkipShowMoPubBrowser;
+
+    /**
+     * Do not instantiate UrlHandler directly; use {@link com.mopub.common.UrlHandler.Builder}
+     * instead.
+     */
+    private UrlHandler(
+            @NonNull final EnumSet<UrlAction> supportedUrlActions,
+            @NonNull final ResultActions resultActions,
+            @NonNull final MoPubSchemeListener moPubSchemeListener,
+            final boolean skipShowMoPubBrowser) {
+        mResultActions = resultActions;
+        mMoPubSchemeListener = moPubSchemeListener;
+        mSkipShowMoPubBrowser = skipShowMoPubBrowser;
+        mSupportedUrlActions = supportedUrlActions;
+    }
+
+    /**
+     * Performs the actual click handling by verifying that the {@code destinationUrl} is one of
+     * the configured supported {@link UrlAction}s and then handling it accordingly.
+     *
+     * @param context The activity context.
+     * @param destinationUrl The URL to handle.
+     */
+    public void handleUrl(@NonNull final Context context, @NonNull final String destinationUrl) {
+        handleUrl(context, destinationUrl, true);
+    }
+
+    /**
+     * Performs the actual click handling by verifying that the {@code destinationUrl} is one of
+     * the configured supported {@link UrlAction}s and then handling it accordingly.
+     *
+     * @param context The activity context.
+     * @param destinationUrl The URL to handle.
+     * @param fromUserInteraction Whether this handling was triggered from a user interaction.
+     */
+    public void handleUrl(@NonNull final Context context, @NonNull final String destinationUrl,
+            final boolean fromUserInteraction) {
+        UrlAction lastFailedUrlAction = UrlAction.NOOP;
+
+        if (TextUtils.isEmpty(destinationUrl)) {
+            MoPubLog.d("Attempted to handle empty url.");
+        } else {
+            final Uri destinationUri = Uri.parse(destinationUrl);
+            for (final UrlAction urlAction : mSupportedUrlActions) {
+                if (urlAction.shouldTryHandlingUrl(destinationUri)) {
+                    try {
+                        urlAction.handleUrl(context, destinationUri, fromUserInteraction,
+                                mSkipShowMoPubBrowser, mMoPubSchemeListener);
+                        if (!UrlAction.IGNORE_ABOUT_SCHEME.equals(urlAction) &&
+                                !UrlAction.HANDLE_MOPUB_SCHEME.equals(urlAction)) {
+                            mResultActions.urlHandlingSucceeded(destinationUri.toString(),
+                                    urlAction);
+                        }
+                        return;
+                    } catch (IntentNotResolvableException e) {
+                        MoPubLog.d(e.getMessage(), e);
+                        lastFailedUrlAction = urlAction;
+                        // continue trying to match...
+                    }
+                }
+            }
+            MoPubLog.d("Link ignored. Unable to handle url: " + destinationUrl);
+        }
+
+        mResultActions.urlHandlingFailed(destinationUrl, lastFailedUrlAction);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/BaseEvent.java b/mopub-sdk/src/main/java/com/mopub/common/event/BaseEvent.java
index ef109074..db599026 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/event/BaseEvent.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/BaseEvent.java
@@ -4,6 +4,7 @@
 import android.support.annotation.Nullable;
 
 import com.mopub.common.ClientMetadata;
+import com.mopub.common.Preconditions;
 import com.mopub.common.VisibleForTesting;
 
 import java.text.SimpleDateFormat;
@@ -17,11 +18,12 @@
         EXCHANGE_CLIENT_EVENT("exchange_client_event"),
         EXCHANGE_CLIENT_ERROR("exchange_client_error");
 
-        private final String mScribeCategory;
-        ScribeCategory(String scribeCategory) {
+        @NonNull private final String mScribeCategory;
+        private ScribeCategory(@NonNull String scribeCategory) {
             mScribeCategory = scribeCategory;
         }
 
+        @NonNull
         public String getCategory() {
             return mScribeCategory;
         }
@@ -33,7 +35,7 @@ public String getCategory() {
         NATIVE(2);
 
         private final int mType;
-        SdkProduct(int type) {
+        private SdkProduct(int type) {
             mType = type;
         }
 
@@ -43,12 +45,13 @@ public int getType() {
     }
 
     public static enum AppPlatform {
-        IOS(0),
-        ANDROID(1),
-        MOBILE_WEB(2);
+        NONE(0),
+        IOS(1),
+        ANDROID(2),
+        MOBILE_WEB(3);
 
         private final int mType;
-        AppPlatform(int type) {
+        private AppPlatform(int type) {
             mType = type;
         }
 
@@ -57,9 +60,52 @@ public int getType() {
         }
     }
 
-    @Nullable private ScribeCategory mScribeCategory;
-    @Nullable private final String mEventName;
-    @Nullable private final String mEventCategory;
+    public enum Name {
+        AD_REQUEST("ad_request"),
+        IMPRESSION_REQUEST("impression_request"),
+        CLICK_REQUEST("click_request");
+
+        @NonNull private final String mName;
+        private Name(@NonNull String name) {
+            mName = name;
+        }
+
+        @NonNull
+        public String getName() {
+            return mName;
+        }
+    }
+
+    public enum Category {
+        REQUESTS("requests");
+
+        @NonNull private final String mCategory;
+        private Category(@NonNull String category) {
+            mCategory = category;
+        }
+
+        @NonNull
+        public String getCategory() {
+            return mCategory;
+        }
+    }
+
+    public enum SamplingRate {
+        AD_REQUEST(0.1);
+
+        private final double mSamplingRate;
+        private SamplingRate(double samplingRate) {
+            mSamplingRate = samplingRate;
+        }
+
+        public double getSamplingRate() {
+            return mSamplingRate;
+        }
+    }
+
+    @NonNull private final ScribeCategory mScribeCategory;
+    @NonNull private final Name mName;
+    @NonNull private final Category mCategory;
     @Nullable private final SdkProduct mSdkProduct;
     @Nullable private final String mAdUnitId;
     @Nullable private final String mAdCreativeId;
@@ -67,21 +113,37 @@ public int getType() {
     @Nullable private final String mAdNetworkType;
     @Nullable private final Double mAdWidthPx;
     @Nullable private final Double mAdHeightPx;
+    @Nullable private final Integer mDeviceScreenWidthDip;
+    @Nullable private final Integer mDeviceScreenHeightDip;
     @Nullable private final Double mGeoLat;
     @Nullable private final Double mGeoLon;
     @Nullable private final Double mGeoAccuracy;
+    @Nullable private final MoPubNetworkType mNetworkType;
+    @Nullable private final String mNetworkOperator;
+    @Nullable private final String mNetworkOperatorName;
+    @Nullable private final String mIsoCountryCode;
+    @Nullable private final String mSimOperator;
+    @Nullable private final String mSimOperatorName;
+    @Nullable private final String mSimIsoCountryCode;
     @Nullable private final Double mPerformanceDurationMs;
     @Nullable private final String mRequestId;
     @Nullable private final Integer mRequestStatusCode;
     @Nullable private final String mRequestUri;
     @Nullable private final Integer mRequestRetries;
-    @Nullable private final Long mTimestampUtcMs;
+    private final long mTimestampUtcMs;
     @Nullable private ClientMetadata mClientMetaData;
 
+     /**
+     * The percentage of events, in range 0 - 1.0, to be logged.
+     */
+    private final double mSamplingRate;
+
     public BaseEvent(@NonNull final Builder builder) {
+        Preconditions.checkNotNull(builder);
+
         mScribeCategory = builder.mScribeCategory;
-        mEventName = builder.mEventName;
-        mEventCategory = builder.mEventCategory;
+        mName = builder.mName;
+        mCategory = builder.mCategory;
         mSdkProduct = builder.mSdkProduct;
         mAdUnitId = builder.mAdUnitId;
         mAdCreativeId = builder.mAdCreativeId;
@@ -97,162 +159,237 @@ public BaseEvent(@NonNull final Builder builder) {
         mRequestStatusCode = builder.mRequestStatusCode;
         mRequestUri = builder.mRequestUri;
         mRequestRetries = builder.mRequestRetries;
+        mSamplingRate = builder.mSamplingRate;
         mTimestampUtcMs = System.currentTimeMillis();
+
         mClientMetaData = ClientMetadata.getInstance();
+        if (mClientMetaData != null) {
+            mDeviceScreenWidthDip = mClientMetaData.getDeviceScreenWidthDip();
+            mDeviceScreenHeightDip = mClientMetaData.getDeviceScreenHeightDip();
+            mNetworkType = mClientMetaData.getActiveNetworkType();
+            mNetworkOperator = mClientMetaData.getNetworkOperator();
+            mNetworkOperatorName = mClientMetaData.getNetworkOperatorName();
+            mIsoCountryCode = mClientMetaData.getIsoCountryCode();
+            mSimOperator = mClientMetaData.getSimOperator();
+            mSimOperatorName = mClientMetaData.getSimOperatorName();
+            mSimIsoCountryCode = mClientMetaData.getSimIsoCountryCode();
+        } else {
+            // Need to silence warnings about variables not being initialized
+            mDeviceScreenWidthDip = null;
+            mDeviceScreenHeightDip = null;
+            mNetworkType = null;
+            mNetworkOperator = null;
+            mNetworkOperatorName = null;
+            mIsoCountryCode = null;
+            mSimOperator = null;
+            mSimOperatorName = null;
+            mSimIsoCountryCode = null;
+        }
     }
 
+    @NonNull
     public ScribeCategory getScribeCategory() {
         return mScribeCategory;
     }
 
-    public String getEventName() {
-        return mEventName;
+    @NonNull
+    public Name getName() {
+        return mName;
     }
 
-    public String getEventCategory() {
-        return mEventCategory;
+    @NonNull
+    public Category getCategory() {
+        return mCategory;
     }
 
+    @Nullable
     public SdkProduct getSdkProduct() {
         return mSdkProduct;
     }
 
+    @Nullable
     public String getSdkVersion() {
         return mClientMetaData == null ? null : mClientMetaData.getSdkVersion();
     }
 
+    @Nullable
     public String getAdUnitId() {
         return mAdUnitId;
     }
 
+    @Nullable
     public String getAdCreativeId() {
         return mAdCreativeId;
     }
 
+    @Nullable
     public String getAdType() {
         return mAdType;
     }
 
+    @Nullable
     public String getAdNetworkType() {
         return mAdNetworkType;
     }
 
+    @Nullable
     public Double getAdWidthPx() {
         return mAdWidthPx;
     }
 
+    @Nullable
     public Double getAdHeightPx() {
         return mAdHeightPx;
     }
 
+    @Nullable
     public AppPlatform getAppPlatform() {
         return AppPlatform.ANDROID;
     }
 
+    @Nullable
     public String getAppName() {
         return mClientMetaData == null ? null : mClientMetaData.getAppName();
     }
 
+    @Nullable
     public String getAppPackageName() {
         return mClientMetaData == null ? null : mClientMetaData.getAppPackageName();
     }
 
+    @Nullable
     public String getAppVersion() {
         return mClientMetaData == null ? null : mClientMetaData.getAppVersion();
     }
 
+    @Nullable
     public String getClientAdvertisingId() {
         return mClientMetaData == null ? null : mClientMetaData.getDeviceId();
     }
 
+    @NonNull
+    public String getObfuscatedClientAdvertisingId() {
+        // This is a placeholder for the advertising id until we approve a plan to use the
+        // real value
+        return "ifa:XXXX";
+    }
+
+    @NonNull
     public Boolean getClientDoNotTrack() {
-        return mClientMetaData == null ? null : mClientMetaData.isDoNotTrackSet();
+        // Default to true if we don't have access to the client meta data
+        return mClientMetaData == null || mClientMetaData.isDoNotTrackSet();
     }
 
+    @Nullable
     public String getDeviceManufacturer() {
         return mClientMetaData == null ? null : mClientMetaData.getDeviceManufacturer();
     }
 
+    @Nullable
     public String getDeviceModel() {
         return mClientMetaData == null ? null : mClientMetaData.getDeviceModel();
     }
 
+    @Nullable
     public String getDeviceProduct() {
         return mClientMetaData == null ? null : mClientMetaData.getDeviceProduct();
     }
 
+    @Nullable
     public String getDeviceOsVersion() {
         return mClientMetaData == null ? null : mClientMetaData.getDeviceOsVersion();
     }
 
-    public Integer getDeviceScreenWidthPx() {
-        return mClientMetaData == null ? null : mClientMetaData.getDeviceScreenWidthPx();
+    @Nullable
+    public Integer getDeviceScreenWidthDip() {
+        return mDeviceScreenWidthDip;
     }
 
-    public Integer getDeviceScreenHeightPx() {
-        return mClientMetaData == null ? null : mClientMetaData.getDeviceScreenHeightPx();
+    @Nullable
+    public Integer getDeviceScreenHeightDip() {
+        return mDeviceScreenHeightDip;
     }
 
+    @Nullable
     public Double getGeoLat() {
         return mGeoLat;
     }
 
+    @Nullable
     public Double getGeoLon() {
         return mGeoLon;
     }
 
+    @Nullable
     public Double getGeoAccuracy() {
         return mGeoAccuracy;
     }
 
+    @Nullable
     public Double getPerformanceDurationMs() {
         return mPerformanceDurationMs;
     }
 
+    @Nullable
     public MoPubNetworkType getNetworkType() {
-        return mClientMetaData == null ? null : mClientMetaData.getActiveNetworkType();
+        return mNetworkType;
     }
 
+    @Nullable
     public String getNetworkOperatorCode() {
-        return mClientMetaData == null ? null : mClientMetaData.getNetworkOperator();
+        return mNetworkOperator;
     }
 
+    @Nullable
     public String getNetworkOperatorName() {
-        return mClientMetaData == null ? null : mClientMetaData.getNetworkOperatorName();
+        return mNetworkOperatorName;
     }
 
+    @Nullable
     public String getNetworkIsoCountryCode() {
-        return mClientMetaData == null ? null : mClientMetaData.getIsoCountryCode();
+        return mIsoCountryCode;
     }
 
+    @Nullable
     public String getNetworkSimCode() {
-        return mClientMetaData == null ? null : mClientMetaData.getSimOperator();
+        return mSimOperator;
     }
 
+    @Nullable
     public String getNetworkSimOperatorName() {
-        return mClientMetaData == null ? null : mClientMetaData.getSimOperatorName();
+        return mSimOperatorName;
     }
 
+    @Nullable
     public String getNetworkSimIsoCountryCode() {
-        return mClientMetaData == null ? null : mClientMetaData.getSimIsoCountryCode();
+        return mSimIsoCountryCode;
     }
 
+    @Nullable
     public String getRequestId() {
         return mRequestId;
     }
 
+    @Nullable
     public Integer getRequestStatusCode() {
         return mRequestStatusCode;
     }
 
+    @Nullable
     public String getRequestUri() {
         return mRequestUri;
     }
 
+    @Nullable
     public Integer getRequestRetries() {
         return mRequestRetries;
     }
 
+    public double getSamplingRate() {
+        return mSamplingRate;
+    }
+
+    @NonNull
     public Long getTimestampUtcMs() {
         return mTimestampUtcMs;
     }
@@ -261,8 +398,8 @@ public Long getTimestampUtcMs() {
     public String toString() {
         return  "BaseEvent\n" +
                 "ScribeCategory: " + getScribeCategory() + "\n" +
-                "EventName: " + getEventName() + "\n" +
-                "EventCategory: " + getEventCategory() + "\n" +
+                "Name: " + getName() + "\n" +
+                "Category: " + getCategory() + "\n" +
                 "SdkProduct: " + getSdkProduct() + "\n" +
                 "SdkVersion: " + getSdkVersion() + "\n" +
                 "AdUnitId: " + getAdUnitId() + "\n" +
@@ -279,8 +416,8 @@ public String toString() {
                 "DeviceModel: " + getDeviceModel() + "\n" +
                 "DeviceProduct: " + getDeviceProduct() + "\n" +
                 "DeviceOsVersion: " + getDeviceOsVersion() + "\n" +
-                "DeviceScreenWidth: " + getDeviceScreenWidthPx() + "\n" +
-                "DeviceScreenHeight: " + getDeviceScreenHeightPx() + "\n" +
+                "DeviceScreenWidth: " + getDeviceScreenWidthDip() + "\n" +
+                "DeviceScreenHeight: " + getDeviceScreenHeightDip() + "\n" +
                 "GeoLat: " + getGeoLat() + "\n" +
                 "GeoLon: " + getGeoLon() + "\n" +
                 "GeoAccuracy: " + getGeoAccuracy() + "\n" +
@@ -295,19 +432,15 @@ public String toString() {
                 "RequestId: " + getRequestId() + "\n" +
                 "RequestStatusCode: " + getRequestStatusCode() + "\n" +
                 "RequestUri: " + getRequestUri() + "\n" +
-                "RequestRetries" + getRequestRetries() + "\n" +
+                "RequestRetries: " + getRequestRetries() + "\n" +
+                "SamplingRate: " + getSamplingRate() + "\n" +
                 "TimestampUtcMs: " + new SimpleDateFormat().format(new Date(getTimestampUtcMs())) + "\n";
     }
 
-    @VisibleForTesting
-    void setClientMetaData(ClientMetadata clientMetaData) {
-        mClientMetaData = clientMetaData;
-    }
-
-    static abstract class Builder {
-        @Nullable private ScribeCategory mScribeCategory;
-        @Nullable private String mEventName;
-        @Nullable private String mEventCategory;
+    public static abstract class Builder {
+        @NonNull private ScribeCategory mScribeCategory;
+        @NonNull private Name mName;
+        @NonNull private Category mCategory;
         @Nullable private SdkProduct mSdkProduct;
         @Nullable private String mAdUnitId;
         @Nullable private String mAdCreativeId;
@@ -324,83 +457,112 @@ void setClientMetaData(ClientMetadata clientMetaData) {
         @Nullable private String mRequestUri;
         @Nullable private Integer mRequestRetries;
 
-        public Builder(ScribeCategory scribeCategory, String eventName, String eventCategory) {
+        /**
+         * The percentage of events, in range 0 - 1.0, to be logged.
+         */
+        private double mSamplingRate;
+
+        public Builder(@NonNull ScribeCategory scribeCategory,
+                @NonNull Name name,
+                @NonNull Category category,
+                double samplingRate) {
+            Preconditions.checkNotNull(scribeCategory);
+            Preconditions.checkNotNull(name);
+            Preconditions.checkNotNull(category);
+            Preconditions.checkArgument(samplingRate >= 0 && samplingRate <= 1.0);
+
             mScribeCategory = scribeCategory;
-            mEventName = eventName;
-            mEventCategory = eventCategory;
+            mName = name;
+            mCategory = category;
+            mSamplingRate = samplingRate;
         }
 
-        public Builder withSdkProduct(SdkProduct sdkProduct) {
+        @NonNull
+        public Builder withSdkProduct(@Nullable SdkProduct sdkProduct) {
             mSdkProduct = sdkProduct;
             return this;
         }
 
-        public Builder withAdUnitId(String adUnitId) {
+        @NonNull
+        public Builder withAdUnitId(@Nullable String adUnitId) {
             mAdUnitId = adUnitId;
             return this;
         }
 
-        public Builder withAdCreativeId(String adCreativeId) {
+        @NonNull
+        public Builder withAdCreativeId(@Nullable String adCreativeId) {
             mAdCreativeId = adCreativeId;
             return this;
         }
 
-        public Builder withAdType(String adType) {
+        @NonNull
+        public Builder withAdType(@Nullable String adType) {
             mAdType = adType;
             return this;
         }
 
-        public Builder withAdNetworkType(String adNetworkType) {
+        @NonNull
+        public Builder withAdNetworkType(@Nullable String adNetworkType) {
             mAdNetworkType = adNetworkType;
             return this;
         }
 
-        public Builder withAdWidthPx(Double adWidthPx) {
+        @NonNull
+        public Builder withAdWidthPx(@Nullable Double adWidthPx) {
             mAdWidthPx = adWidthPx;
             return this;
         }
 
-        public Builder withAdHeightPx(Double adHeightPx) {
+        @NonNull
+        public Builder withAdHeightPx(@Nullable Double adHeightPx) {
             mAdHeightPx = adHeightPx;
             return this;
         }
 
-        public Builder withGeoLat(Double geoLat) {
+        @NonNull
+        public Builder withGeoLat(@Nullable Double geoLat) {
             mGeoLat = geoLat;
             return this;
         }
 
-        public Builder withGeoLon(Double geoLon) {
+        @NonNull
+        public Builder withGeoLon(@Nullable Double geoLon) {
             mGeoLon = geoLon;
             return this;
         }
 
-        public Builder withGeoAccuracy(Double geoAccuracy) {
+        @NonNull
+        public Builder withGeoAccuracy(@Nullable Double geoAccuracy) {
             mGeoAccuracy = geoAccuracy;
             return this;
         }
 
-        public Builder withPerformanceDurationMs(Double performanceDurationMs) {
+        @NonNull
+        public Builder withPerformanceDurationMs(@Nullable Double performanceDurationMs) {
             mPerformanceDurationMs = performanceDurationMs;
             return this;
         }
 
-        public Builder withRequestId(String requestId) {
+        @NonNull
+        public Builder withRequestId(@Nullable String requestId) {
             mRequestId = requestId;
             return this;
         }
 
-        public Builder withRequestStatusCode(Integer requestStatusCode) {
+        @NonNull
+        public Builder withRequestStatusCode(@Nullable Integer requestStatusCode) {
             mRequestStatusCode = requestStatusCode;
             return this;
         }
 
-        public Builder withRequestUri(String requestUri) {
+        @NonNull
+        public Builder withRequestUri(@Nullable String requestUri) {
             mRequestUri = requestUri;
             return this;
         }
 
-        public Builder withRequestRetries(Integer requestRetries) {
+        @NonNull
+        public Builder withRequestRetries(@Nullable Integer requestRetries) {
             mRequestRetries = requestRetries;
             return this;
         }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/ErrorEvent.java b/mopub-sdk/src/main/java/com/mopub/common/event/ErrorEvent.java
index 00652b0e..05a3d93f 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/event/ErrorEvent.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/ErrorEvent.java
@@ -1,5 +1,6 @@
 package com.mopub.common.event;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 
 import java.io.PrintWriter;
@@ -17,7 +18,7 @@
     @Nullable private final String mErrorMethodName;
     @Nullable private final Integer mErrorLineNumber;
 
-    private ErrorEvent(Builder builder) {
+    private ErrorEvent(@NonNull Builder builder) {
         super(builder);
         mErrorExceptionClassName = builder.mErrorExceptionClassName;
         mErrorMessage = builder.mErrorMessage;
@@ -28,30 +29,37 @@ private ErrorEvent(Builder builder) {
         mErrorLineNumber = builder.mErrorLineNumber;
     }
 
+    @Nullable
     public String getErrorExceptionClassName() {
         return mErrorExceptionClassName;
     }
 
+    @Nullable
     public String getErrorMessage() {
         return mErrorMessage;
     }
 
+    @Nullable
     public String getErrorStackTrace() {
         return mErrorStackTrace;
     }
 
+    @Nullable
     public String getErrorFileName() {
         return mErrorFileName;
     }
 
+    @Nullable
     public String getErrorClassName() {
         return mErrorClassName;
     }
 
+    @Nullable
     public String getErrorMethodName() {
         return mErrorMethodName;
     }
 
+    @Nullable
     public Integer getErrorLineNumber() {
         return mErrorLineNumber;
     }
@@ -79,46 +87,54 @@ public String toString() {
         @Nullable private String mErrorMethodName;
         @Nullable private Integer mErrorLineNumber;
 
-        public Builder(String eventName, String eventCategory) {
-            super(ScribeCategory.EXCHANGE_CLIENT_ERROR, eventName, eventCategory);
+        public Builder(@NonNull Name name, @NonNull Category category, double samplingRate) {
+            super(ScribeCategory.EXCHANGE_CLIENT_ERROR, name, category, samplingRate);
         }
 
-        public Builder withErrorExceptionClassName(String errorExceptionClassName) {
+        @NonNull
+        public Builder withErrorExceptionClassName(@Nullable String errorExceptionClassName) {
             mErrorExceptionClassName = errorExceptionClassName;
             return this;
         }
 
-        public Builder withErrorMessage(String errorMessage) {
+        @NonNull
+        public Builder withErrorMessage(@Nullable String errorMessage) {
             mErrorMessage = errorMessage;
             return this;
         }
 
-        public Builder withErrorStackTrace(String errorStackTrace) {
+        @NonNull
+        public Builder withErrorStackTrace(@Nullable String errorStackTrace) {
             mErrorStackTrace = errorStackTrace;
             return this;
         }
 
-        public Builder withErrorFileName(String errorFileName) {
+        @NonNull
+        public Builder withErrorFileName(@Nullable String errorFileName) {
             mErrorFileName = errorFileName;
             return this;
         }
 
-        public Builder withErrorClassName(String errorClassName) {
+        @NonNull
+        public Builder withErrorClassName(@Nullable String errorClassName) {
             mErrorClassName = errorClassName;
             return this;
         }
 
-        public Builder withErrorMethodName(String errorMethodName) {
+        @NonNull
+        public Builder withErrorMethodName(@Nullable String errorMethodName) {
             mErrorMethodName = errorMethodName;
             return this;
         }
 
-        public Builder withErrorLineNumber(Integer errorLineNumber) {
+        @NonNull
+        public Builder withErrorLineNumber(@Nullable Integer errorLineNumber) {
             mErrorLineNumber = errorLineNumber;
             return this;
         }
 
-        public Builder withException(Exception exception) {
+        @NonNull
+        public Builder withException(@Nullable Exception exception) {
             mErrorExceptionClassName = exception.getClass().getName();
             mErrorMessage = exception.getMessage();
 
@@ -135,6 +151,7 @@ public Builder withException(Exception exception) {
             return this;
         }
 
+        @NonNull
         @Override
         public ErrorEvent build() {
             return new ErrorEvent(this);
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/Event.java b/mopub-sdk/src/main/java/com/mopub/common/event/Event.java
index 9edd13c8..4228ab35 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/event/Event.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/Event.java
@@ -1,18 +1,21 @@
 package com.mopub.common.event;
 
+import android.support.annotation.NonNull;
+
 /**
  * Immutable data class with client event data.
  */
 public class Event extends BaseEvent {
-    private Event(Builder builder) {
+    private Event(@NonNull Builder builder) {
         super(builder);
     }
 
     public static class Builder extends BaseEvent.Builder {
-        public Builder(String eventName, String eventCategory) {
-            super(ScribeCategory.EXCHANGE_CLIENT_EVENT, eventName, eventCategory);
+        public Builder(@NonNull Name name, @NonNull Category category, double samplingRate) {
+            super(ScribeCategory.EXCHANGE_CLIENT_EVENT, name, category, samplingRate);
         }
 
+        @NonNull
         @Override
         public Event build() {
             return new Event(this);
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/EventDispatcher.java b/mopub-sdk/src/main/java/com/mopub/common/event/EventDispatcher.java
index 9e362d64..f5ca5dbc 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/event/EventDispatcher.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/EventDispatcher.java
@@ -1,7 +1,7 @@
 package com.mopub.common.event;
 
 import android.os.Handler;
-import android.os.HandlerThread;
+import android.os.Looper;
 import android.os.Message;
 
 import com.mopub.common.VisibleForTesting;
@@ -9,17 +9,14 @@
 
 public class EventDispatcher {
     private final Iterable<EventRecorder> mEventRecorders;
-    private final HandlerThread mHandlerThread;
+    private final Looper mLooper;
     private final Handler mMessageHandler;
     private final Handler.Callback mHandlerCallback;
 
     @VisibleForTesting
-    EventDispatcher(Iterable<EventRecorder> recorders, HandlerThread handlerThread) {
+    EventDispatcher(Iterable<EventRecorder> recorders, Looper looper) {
         mEventRecorders = recorders;
-
-        mHandlerThread = handlerThread;
-        mHandlerThread.start();
-
+        mLooper = looper;
         mHandlerCallback = new Handler.Callback() {
             @Override
             public boolean handleMessage(final Message msg) {
@@ -33,10 +30,10 @@ public boolean handleMessage(final Message msg) {
                 return true;
             }
         };
-        mMessageHandler = new Handler(mHandlerThread.getLooper(), mHandlerCallback);
+        mMessageHandler = new Handler(mLooper, mHandlerCallback);
     }
 
-    void dispatch(BaseEvent event) {
+    public void dispatch(BaseEvent event) {
         Message.obtain(mMessageHandler, 0, event).sendToTarget();
     }
 
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/EventSampler.java b/mopub-sdk/src/main/java/com/mopub/common/event/EventSampler.java
new file mode 100644
index 00000000..607d28d8
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/EventSampler.java
@@ -0,0 +1,39 @@
+package com.mopub.common.event;
+
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+
+import java.util.Random;
+
+/**
+ * Samples events based on rules defined in the sample method.
+ */
+public class EventSampler {
+
+    @NonNull private Random mRandom;
+
+    public EventSampler() {
+        this(new Random());
+    }
+
+    @VisibleForTesting
+    public EventSampler(@NonNull Random random) {
+        mRandom = random;
+    }
+
+    /**
+     * Samples events based on custom rules.
+     *
+     * @param baseEvent The event to be sampled.
+     *
+     * @return Will return {@code true} if the event passed sampling and {@code false}
+     * if it is to be discarded.
+     */
+    boolean sample(@NonNull BaseEvent baseEvent) {
+        Preconditions.checkNotNull(baseEvent);
+
+        return mRandom.nextDouble() < baseEvent.getSamplingRate();
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/EventSerializer.java b/mopub-sdk/src/main/java/com/mopub/common/event/EventSerializer.java
index 97af86f9..94cf7c31 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/event/EventSerializer.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/EventSerializer.java
@@ -3,6 +3,8 @@
 import android.support.annotation.NonNull;
 
 import com.mopub.common.ClientMetadata;
+import com.mopub.common.Preconditions;
+import com.mopub.common.logging.MoPubLog;
 
 import org.json.JSONArray;
 import org.json.JSONException;
@@ -10,97 +12,131 @@
 
 import java.util.List;
 
+/**
+ * Serializes events to the data format expected by the Scribe service.
+ */
 public class EventSerializer {
 
-    public JSONArray serializeAsJson(@NonNull List<BaseEvent> events) throws JSONException {
+    /**
+     * Serializes a list of events as a JSON array of flattened JSON objects.
+     *
+     * @param events The events to be serialized.
+     *
+     * @return Will return a {@code JSONArray} of serialized {@code JSONObject}s.
+     */
+    @NonNull
+    public JSONArray serializeAsJson(@NonNull List<BaseEvent> events) {
+        Preconditions.checkNotNull(events);
+
         JSONArray jsonArray = new JSONArray();
         for (BaseEvent event : events) {
-
-            // Note: adding null values to the JSONObject will remove the key value pair
-            JSONObject jsonObject = new JSONObject();
-
-            // Required Scribe Request Keys
-            jsonObject.put("_category_", event.getScribeCategory().getCategory());
-            jsonObject.put("ts", event.getTimestampUtcMs());
-
-            // Name Details
-            jsonObject.put("name", event.getEventName());
-            jsonObject.put("name_category", event.getEventCategory());
-
-            // SDK Details
-            BaseEvent.SdkProduct sdkProduct = event.getSdkProduct();
-            jsonObject.put("sdk_product", sdkProduct == null ? null : sdkProduct.getType());
-            jsonObject.put("sdk_version", event.getSdkVersion());
-
-            // Ad Details
-            jsonObject.put("ad_unit_id", event.getAdUnitId());
-            jsonObject.put("ad_creative_id", event.getAdCreativeId());
-            jsonObject.put("ad_type", event.getAdType());
-            jsonObject.put("ad_network_type", event.getAdNetworkType());
-            jsonObject.put("ad_width_px", event.getAdWidthPx());
-            jsonObject.put("ad_height_px", event.getAdHeightPx());
-
-            // App Details
-            BaseEvent.AppPlatform appPlatform = event.getAppPlatform();
-            jsonObject.put("app_platform", appPlatform == null ? null : appPlatform.getType());
-            jsonObject.put("app_name", event.getAppName());
-            jsonObject.put("app_package_name", event.getAppPackageName());
-            jsonObject.put("app_version", event.getAppVersion());
-
-            // Client Details
-            jsonObject.put("client_advertising_id", event.getClientAdvertisingId());
-            jsonObject.put("client_do_not_track", event.getClientDoNotTrack());
-
-            // Device Details
-            jsonObject.put("device_manufacturer", event.getDeviceManufacturer());
-            jsonObject.put("device_model", event.getDeviceModel());
-            jsonObject.put("device_product", event.getDeviceProduct());
-            jsonObject.put("device_os_version", event.getDeviceOsVersion());
-            jsonObject.put("device_screen_width_px", event.getDeviceScreenWidthPx());
-            jsonObject.put("device_screen_height_px", event.getDeviceScreenHeightPx());
-
-            // Geo Details
-            jsonObject.put("geo_lat", event.getGeoLat());
-            jsonObject.put("geo_lon", event.getGeoLon());
-            jsonObject.put("geo_accuracy_radius_meters", event.getGeoAccuracy());
-
-            // Performance Details
-            jsonObject.put("perf_duration_ms", event.getPerformanceDurationMs());
-
-            // Network Details
-            ClientMetadata.MoPubNetworkType moPubNetworkType = event.getNetworkType();
-            jsonObject.put("network_type", moPubNetworkType == null ? null : moPubNetworkType.getId());
-            jsonObject.put("network_operator_code", event.getNetworkOperatorCode());
-            jsonObject.put("network_operator_name", event.getNetworkOperatorName());
-            jsonObject.put("network_iso_country_code", event.getNetworkIsoCountryCode());
-            jsonObject.put("network_sim_code", event.getNetworkSimCode());
-            jsonObject.put("network_sim_operator_name", event.getNetworkSimOperatorName());
-            jsonObject.put("network_sim_iso_country_code", event.getNetworkSimIsoCountryCode());
-
-            // Request Details
-            jsonObject.put("req_id", event.getRequestId());
-            jsonObject.put("req_status_code", event.getRequestStatusCode());
-            jsonObject.put("req_uri", event.getRequestUri());
-            jsonObject.put("req_retries", event.getRequestRetries());
-
-            // Timestamp Details
-            jsonObject.put("timestamp_client", event.getTimestampUtcMs());
-
-            if (event instanceof ErrorEvent) {
-                ErrorEvent errorEvent = (ErrorEvent) event;
-                // Error Details
-                jsonObject.put("error_exception_class_name", errorEvent.getErrorExceptionClassName());
-                jsonObject.put("error_message", errorEvent.getErrorMessage());
-                jsonObject.put("error_stack_trace", errorEvent.getErrorStackTrace());
-                jsonObject.put("error_file_name", errorEvent.getErrorFileName());
-                jsonObject.put("error_class_name", errorEvent.getErrorClassName());
-                jsonObject.put("error_method_name", errorEvent.getErrorMethodName());
-                jsonObject.put("error_line_number", errorEvent.getErrorLineNumber());
+            try {
+                jsonArray.put(serializeAsJson(event));
+            } catch (JSONException e) {
+                MoPubLog.d("Failed to serialize event \"" + event.getName() + "\" to JSON: ", e);
             }
+        }
+        return jsonArray;
+    }
 
-            jsonArray.put(jsonObject);
+    /**
+     * Serializes a single event as a flattened JSON object. Key values are expected by the Scribe
+     * service.
+     *
+     * @param event The event to be serialized.
+     *
+     * @return Will return a single serialized {@code JSONObject}.
+     */
+    @NonNull
+    public JSONObject serializeAsJson(@NonNull BaseEvent event) throws JSONException {
+        Preconditions.checkNotNull(event);
+
+        // Note: adding null values to the JSONObject will remove the key value pair
+        JSONObject jsonObject = new JSONObject();
+
+        // Required Scribe Request Keys
+        jsonObject.put("_category_", event.getScribeCategory().getCategory());
+        jsonObject.put("ts", event.getTimestampUtcMs());
+
+        // Name Details
+        jsonObject.put("name",  event.getName().getName());
+        jsonObject.put("name_category", event.getCategory().getCategory());
+
+        // SDK Details
+        BaseEvent.SdkProduct sdkProduct = event.getSdkProduct();
+        jsonObject.put("sdk_product", sdkProduct == null ? null : sdkProduct.getType());
+        jsonObject.put("sdk_version", event.getSdkVersion());
+
+        // Ad Details
+        jsonObject.put("ad_unit_id", event.getAdUnitId());
+        jsonObject.put("ad_creative_id", event.getAdCreativeId());
+        jsonObject.put("ad_type", event.getAdType());
+        jsonObject.put("ad_network_type", event.getAdNetworkType());
+        jsonObject.put("ad_width_px", event.getAdWidthPx());
+        jsonObject.put("ad_height_px", event.getAdHeightPx());
+
+        // App Details
+        BaseEvent.AppPlatform appPlatform = event.getAppPlatform();
+        jsonObject.put("app_platform", appPlatform == null ? null : appPlatform.getType());
+        jsonObject.put("app_name", event.getAppName());
+        jsonObject.put("app_package_name", event.getAppPackageName());
+        jsonObject.put("app_version", event.getAppVersion());
+
+        // Client Details
+        // Server side requires these values to be populated to satisfy thrift union
+        jsonObject.put("client_advertising_id", event.getObfuscatedClientAdvertisingId());
+        jsonObject.put("client_do_not_track", event.getClientDoNotTrack());
+
+        // Device Details
+        jsonObject.put("device_manufacturer", event.getDeviceManufacturer());
+        jsonObject.put("device_model", event.getDeviceModel());
+        jsonObject.put("device_product", event.getDeviceProduct());
+        jsonObject.put("device_os_version", event.getDeviceOsVersion());
+
+        // These fields will actually be the dip value until deprecated and new fields
+        // added for future releases
+        jsonObject.put("device_screen_width_px", event.getDeviceScreenWidthDip());
+        jsonObject.put("device_screen_height_px", event.getDeviceScreenHeightDip());
+
+        // Geo Details
+        jsonObject.put("geo_lat", event.getGeoLat());
+        jsonObject.put("geo_lon", event.getGeoLon());
+        jsonObject.put("geo_accuracy_radius_meters", event.getGeoAccuracy());
+
+        // Performance Details
+        jsonObject.put("perf_duration_ms", event.getPerformanceDurationMs());
+
+        // Network Details
+        ClientMetadata.MoPubNetworkType moPubNetworkType = event.getNetworkType();
+        jsonObject.put("network_type", moPubNetworkType == null ? null : moPubNetworkType.getId());
+        jsonObject.put("network_operator_code", event.getNetworkOperatorCode());
+        jsonObject.put("network_operator_name", event.getNetworkOperatorName());
+        jsonObject.put("network_iso_country_code", event.getNetworkIsoCountryCode());
+        jsonObject.put("network_sim_code", event.getNetworkSimCode());
+        jsonObject.put("network_sim_operator_name", event.getNetworkSimOperatorName());
+        jsonObject.put("network_sim_iso_country_code", event.getNetworkSimIsoCountryCode());
+
+        // Request Details
+        jsonObject.put("req_id", event.getRequestId());
+        jsonObject.put("req_status_code", event.getRequestStatusCode());
+        jsonObject.put("req_uri", event.getRequestUri());
+        jsonObject.put("req_retries", event.getRequestRetries());
+
+        // Timestamp Details
+        jsonObject.put("timestamp_client", event.getTimestampUtcMs());
+
+        if (event instanceof ErrorEvent) {
+            ErrorEvent errorEvent = (ErrorEvent) event;
+            // Error Details
+            jsonObject.put("error_exception_class_name", errorEvent.getErrorExceptionClassName());
+            jsonObject.put("error_message", errorEvent.getErrorMessage());
+            jsonObject.put("error_stack_trace", errorEvent.getErrorStackTrace());
+            jsonObject.put("error_file_name", errorEvent.getErrorFileName());
+            jsonObject.put("error_class_name", errorEvent.getErrorClassName());
+            jsonObject.put("error_method_name", errorEvent.getErrorMethodName());
+            jsonObject.put("error_line_number", errorEvent.getErrorLineNumber());
         }
 
-        return jsonArray;
+        return jsonObject;
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/MoPubEvents.java b/mopub-sdk/src/main/java/com/mopub/common/event/MoPubEvents.java
index c2e327d5..3e76abff 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/event/MoPubEvents.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/MoPubEvents.java
@@ -11,29 +11,6 @@
  */
 public class MoPubEvents {
 
-    public enum Type {
-        // Networking
-        AD_REQUEST("ad_request"),
-        IMPRESSION_REQUEST("impression_request"),
-        CLICK_REQUEST("click_request"),
-        POSITIONING_REQUEST("positioning_request"),
-
-        // Errors
-        AD_REQUEST_ERROR("ad_request_error"),
-        TRACKING_ERROR("track_error"),
-
-        // The SDK doesn't distinguish types of tracking at a level where this more-specific logging works yet.
-        IMPRESSION_ERROR("imp_track_error"),
-        CLICK_ERROR("click_track_error"),
-        CONVERSION_ERROR("conv_track_error"),
-        DATA_ERROR("invalid_data");
-
-        public final String mName;
-        Type(String name) {
-            mName = name;
-        }
-    }
-
     private static volatile EventDispatcher sEventDispatcher;
 
     /**
@@ -49,6 +26,15 @@ public static void setEventDispatcher(EventDispatcher dispatcher) {
         sEventDispatcher = dispatcher;
     }
 
+    /**
+     * Returns a singleton event dispatcher constructed with a single background thread meant to be
+     * used for all event logging operations. Operations that end up on the main thread, such as
+     * the result of a network request, should post to this background thread when interacting
+     * with shared resources in order to avoid concurrency issues.
+     *
+     * This design is meant to emulate an {@code IntentService} which we can't use due to
+     * the requirement of the publisher having to update their manifest file.
+     */
     @VisibleForTesting
     static EventDispatcher getDispatcher() {
         EventDispatcher result = sEventDispatcher;
@@ -57,9 +43,10 @@ static EventDispatcher getDispatcher() {
                 result = sEventDispatcher;
                 if (result == null) {
                     ArrayList<EventRecorder> recorders = new ArrayList<EventRecorder>();
-                    recorders.add(new NoopEventRecorder());
-                    HandlerThread handlerThread = new HandlerThread("mopub_event_queue");
-                    result = sEventDispatcher = new EventDispatcher(recorders, handlerThread);
+                    HandlerThread handlerThread = new HandlerThread("mopub_event_logging");
+                    handlerThread.start();
+                    recorders.add(new ScribeEventRecorder(handlerThread.getLooper()));
+                    result = sEventDispatcher = new EventDispatcher(recorders, handlerThread.getLooper());
                 }
             }
         }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/ScribeEventRecorder.java b/mopub-sdk/src/main/java/com/mopub/common/event/ScribeEventRecorder.java
new file mode 100644
index 00000000..96a63ae9
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/ScribeEventRecorder.java
@@ -0,0 +1,142 @@
+package com.mopub.common.event;
+
+import android.os.Handler;
+import android.os.Looper;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.network.ScribeBackoffPolicy;
+import com.mopub.network.ScribeRequest;
+import com.mopub.network.ScribeRequestManager;
+
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Queue;
+
+/**
+ * The ScribeEventRecorder manages events being sent to the Scribe service. It is responsible for
+ * sampling, batching and kicking off network requests. It is also responsible for ensuring batched
+ * events don't grow unbounded.
+ */
+public class ScribeEventRecorder implements EventRecorder {
+    private static final String SCRIBE_URL = "https://analytics.mopub.com/i/jot/exchange_client_event";
+    private static final int QUEUE_MAX_SIZE = 500;
+
+    /**
+     * As of SDK 3.6.0, events are roughly 1200 bytes in size. 1200 * 100 = 0.114441 MiB
+     * This threshhold must always be < 1 MiB
+     */
+    private static final int EVENT_COUNT_SEND_THRESHHOLD = 100;
+
+    /**
+     * 2 minute polling time to check for send up events
+     */
+    private static final int POLLING_PERIOD_MS = 2 * 60 * 1000;
+
+    @NonNull private final EventSampler mEventSampler;
+    @NonNull private final Queue<BaseEvent> mEventQueue;
+    @NonNull private final EventSerializer mEventSerializer;
+    @NonNull private final ScribeRequestManager mScribeRequestManager;
+
+    @NonNull private final Handler mPollHandler;
+    @NonNull private final PollingRunnable mPollingRunnable;
+
+    ScribeEventRecorder(@NonNull Looper looper) {
+        this(new EventSampler(),
+                new LinkedList<BaseEvent>(),
+                new EventSerializer(),
+                new ScribeRequestManager(looper),
+                new Handler(looper));
+    }
+
+    @VisibleForTesting
+    ScribeEventRecorder(@NonNull EventSampler eventSampler,
+            @NonNull Queue<BaseEvent> eventQueue,
+            @NonNull EventSerializer eventSerializer,
+            @NonNull ScribeRequestManager scribeRequestManager,
+            @NonNull Handler handler) {
+        mEventSampler = eventSampler;
+        mEventQueue = eventQueue;
+        mEventSerializer = eventSerializer;
+        mScribeRequestManager = scribeRequestManager;
+        mPollHandler = handler;
+        mPollingRunnable = new PollingRunnable();
+    }
+
+    @Override
+    public void record(@NonNull BaseEvent baseEvent) {
+        if (!mEventSampler.sample(baseEvent)) {
+            return;
+        }
+
+        if (mEventQueue.size() >= QUEUE_MAX_SIZE) {
+            MoPubLog.d("EventQueue is at max capacity. " +
+                    "Event \"" + baseEvent.getName() + "\" is being dropped.");
+            return;
+        }
+
+        mEventQueue.add(baseEvent);
+        if (mEventQueue.size() >= EVENT_COUNT_SEND_THRESHHOLD) {
+            sendEvents();
+        }
+
+        scheduleNextPoll();
+    }
+
+    @VisibleForTesting
+    void sendEvents() {
+        if (mScribeRequestManager.isAtCapacity()) {
+            return;
+        }
+
+        final List<BaseEvent> events = dequeueEvents();
+        if (events.isEmpty()) {
+            return;
+        }
+
+        mScribeRequestManager.makeRequest(
+                new ScribeRequest.ScribeRequestFactory() {
+                    @Override
+                    public ScribeRequest createRequest(ScribeRequest.Listener listener) {
+                        return new ScribeRequest(SCRIBE_URL, events, mEventSerializer, listener);
+                    }
+                },
+                new ScribeBackoffPolicy()
+        );
+    }
+
+    @VisibleForTesting
+    @NonNull
+    List<BaseEvent> dequeueEvents() {
+        ArrayList<BaseEvent> baseEvents = new ArrayList<BaseEvent>();
+
+        // Note: Some queues do not have constant time O(1) performance for its #size()
+        // method, so we're peeking and polling instead
+        while (mEventQueue.peek() != null && baseEvents.size() < EVENT_COUNT_SEND_THRESHHOLD) {
+            baseEvents.add(mEventQueue.poll());
+        }
+        return baseEvents;
+    }
+
+    @VisibleForTesting
+    void scheduleNextPoll() {
+        // Only schedule if there are no messages already scheduled.
+        // The user defined message code, the 'what' param in Handler#hasMessages, defaults to
+        // 0 for posting a delayed runnable
+        if (mPollHandler.hasMessages(0) || mEventQueue.isEmpty()) {
+            return;
+        }
+
+        mPollHandler.postDelayed(mPollingRunnable, POLLING_PERIOD_MS);
+    }
+
+    class PollingRunnable implements Runnable {
+        @Override
+        public void run() {
+            sendEvents();
+            scheduleNextPoll();
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/DeviceUtils.java b/mopub-sdk/src/main/java/com/mopub/common/util/DeviceUtils.java
index 7d54c21d..8d9b34c6 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/DeviceUtils.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/DeviceUtils.java
@@ -1,19 +1,28 @@
 package com.mopub.common.util;
 
+import android.annotation.TargetApi;
 import android.app.Activity;
 import android.app.ActivityManager;
 import android.content.Context;
 import android.content.pm.ActivityInfo;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
+import android.content.res.Configuration;
+import android.graphics.Point;
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
+import android.os.Build;
 import android.os.StatFs;
 import android.provider.Settings;
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.DisplayMetrics;
+import android.view.Display;
 import android.view.Surface;
+import android.view.WindowManager;
 
+import com.mopub.common.CreativeOrientation;
+import com.mopub.common.Preconditions;
 import com.mopub.common.logging.MoPubLog;
 
 import org.apache.http.conn.util.InetAddressUtils;
@@ -38,6 +47,30 @@
 
     private DeviceUtils() {}
 
+    public static enum ForceOrientation {
+        FORCE_PORTRAIT("portrait"),
+        FORCE_LANDSCAPE("landscape"),
+        DEVICE_ORIENTATION("device"),
+        UNDEFINED("");
+
+        @NonNull private final String mKey;
+
+        private ForceOrientation(@NonNull final String key) {
+            mKey = key;
+        }
+
+        @NonNull
+        public static ForceOrientation getForceOrientation(@Nullable String key) {
+            for (final ForceOrientation orientation : ForceOrientation.values()) {
+                if (orientation.mKey.equalsIgnoreCase(key)) {
+                    return orientation;
+                }
+            }
+
+            return UNDEFINED;
+        }
+    }
+
     public static enum IP {
         IPv4,
         IPv6;
@@ -89,7 +122,7 @@ public static String getHashedUdid(final Context context) {
         return Utils.sha1(udid);
     }
 
-    public static boolean isNetworkAvailable(final Context context) {
+    public static boolean isNetworkAvailable(@Nullable final Context context) {
         if (context == null) {
             return false;
         }
@@ -159,46 +192,119 @@ public static long diskCacheSizeBytes(File dir) {
 
     public static int getScreenOrientation(@NonNull final Activity activity) {
         final int rotation = activity.getWindowManager().getDefaultDisplay().getRotation();
-        final DisplayMetrics displayMetrics = new DisplayMetrics();
-        activity.getWindowManager().getDefaultDisplay().getMetrics(displayMetrics);
-
-        final int width = displayMetrics.widthPixels;
-        final int height = displayMetrics.heightPixels;
+        final int deviceOrientation = activity.getResources().getConfiguration().orientation;
 
-        final boolean isPortrait =
-                (((rotation == Surface.ROTATION_0 || rotation == Surface.ROTATION_180)) &&
-                height > width) ||
-                (((rotation == Surface.ROTATION_90 || rotation == Surface.ROTATION_270)) &&
-                width > height);
+        return getScreenOrientationFromRotationAndOrientation(rotation, deviceOrientation);
+    }
 
-        if (isPortrait) {
+    static int getScreenOrientationFromRotationAndOrientation(int rotation, int orientation) {
+        if (Configuration.ORIENTATION_PORTRAIT == orientation) {
             switch (rotation) {
-                case Surface.ROTATION_0:
-                    return ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
-                case Surface.ROTATION_90:
-                    return ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
                 case Surface.ROTATION_180:
-                    return ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT;
                 case Surface.ROTATION_270:
-                    return ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE;
+                    return ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT;
+
+                case Surface.ROTATION_0:
+                case Surface.ROTATION_90:
                 default:
-                    MoPubLog.d("Unknown screen orientation. Defaulting to portrait.");
                     return ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
             }
-        } else {
+        } else if (Configuration.ORIENTATION_LANDSCAPE == orientation) {
             switch (rotation) {
-                case Surface.ROTATION_0:
-                    return ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
-                case Surface.ROTATION_90:
-                    return ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
                 case Surface.ROTATION_180:
-                    return ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE;
                 case Surface.ROTATION_270:
-                    return ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT;
+                    return ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE;
+
+                case Surface.ROTATION_0:
+                case Surface.ROTATION_90:
                 default:
-                    MoPubLog.d("Unknown screen orientation. Defaulting to landscape.");
                     return ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
             }
+        } else {
+            MoPubLog.d("Unknown screen orientation. Defaulting to portrait.");
+            return ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT;
         }
     }
+
+    /**
+     * Lock this activity in the requested orientation, rotating the display if necessary.
+     *
+     * @param creativeOrientation the orientation of the screen needed by the ad creative.
+     */
+    public static void lockOrientation(@NonNull Activity activity, @NonNull CreativeOrientation creativeOrientation) {
+        if (!Preconditions.NoThrow.checkNotNull(creativeOrientation) || !Preconditions.NoThrow.checkNotNull(activity)) {
+            return;
+        }
+
+        Display display = ((WindowManager) activity.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        final int currentRotation = display.getRotation();
+        final int deviceOrientation = activity.getResources().getConfiguration().orientation;
+
+        final int currentOrientation = getScreenOrientationFromRotationAndOrientation(currentRotation, deviceOrientation);
+        int requestedOrientation;
+
+        // Choose a requested orientation that will result in the smallest change from the existing orientation.
+        if (CreativeOrientation.PORTRAIT == creativeOrientation) {
+            if (ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT == currentOrientation) {
+                requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT;
+            } else {
+                requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
+            }
+        } else if (CreativeOrientation.LANDSCAPE == creativeOrientation) {
+            if (ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE == currentOrientation) {
+                requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE;
+            } else {
+                requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
+            }
+        } else {
+            // Don't lock screen orientation if the creative doesn't care.
+            return;
+        }
+
+        activity.setRequestedOrientation(requestedOrientation);
+    }
+
+    /**
+     * This tries to get the physical number of pixels on the device. This attempts to include
+     * the pixels in the notification bar and soft buttons.
+     *
+     * @param context Needs a context (application is fine) to determine width/height.
+     * @return Width and height of the device
+     */
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+    public static Point getDeviceDimensions(@NonNull final Context context) {
+        Integer bestWidthPixels = null;
+        Integer bestHeightPixels = null;
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {
+            final WindowManager windowManager = (WindowManager) context.getSystemService(
+                    Context.WINDOW_SERVICE);
+            final Display display = windowManager.getDefaultDisplay();
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
+                final Point screenSize = new Point();
+                display.getRealSize(screenSize);
+                bestWidthPixels = screenSize.x;
+                bestHeightPixels = screenSize.y;
+            } else {
+                try {
+                    bestWidthPixels = (Integer) new MethodBuilder(display,
+                            "getRawWidth").execute();
+                    bestHeightPixels = (Integer) new MethodBuilder(display,
+                            "getRawHeight").execute();
+                } catch (Exception e) {
+                    // Best effort. If this fails, just get the height and width normally,
+                    // which may not capture the pixels used in the notification bar.
+                    MoPubLog.v("Display#getRawWidth/Height failed.", e);
+                }
+            }
+        }
+
+        if (bestWidthPixels == null || bestHeightPixels == null) {
+            final DisplayMetrics displayMetrics = context.getResources().getDisplayMetrics();
+            bestWidthPixels = displayMetrics.widthPixels;
+            bestHeightPixels = displayMetrics.heightPixels;
+        }
+
+        return new Point(bestWidthPixels, bestHeightPixels);
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/Dips.java b/mopub-sdk/src/main/java/com/mopub/common/util/Dips.java
index 71e2f464..bde599fa 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/Dips.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Dips.java
@@ -1,9 +1,12 @@
 package com.mopub.common.util;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import android.util.DisplayMetrics;
 import android.util.TypedValue;
 
+import com.mopub.common.Preconditions;
+
 public class Dips {
     public static float pixelsToFloatDips(final float pixels, final Context context) {
         return pixels / getDensity(context);
@@ -33,4 +36,16 @@ public static float asFloatPixels(float dips, Context context) {
     public static int asIntPixels(float dips, Context context) {
         return (int) (asFloatPixels(dips, context) + 0.5f);
     }
+
+    public static int screenWidthAsIntDips(@NonNull Context context) {
+        Preconditions.checkNotNull(context);
+
+        return pixelsToIntDips(context.getResources().getDisplayMetrics().widthPixels, context);
+    }
+
+    public static int screenHeightAsIntDips(@NonNull Context context) {
+        Preconditions.checkNotNull(context);
+
+        return pixelsToIntDips(context.getResources().getDisplayMetrics().heightPixels, context);
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/Intents.java b/mopub-sdk/src/main/java/com/mopub/common/util/Intents.java
index ae29fd95..1af522f5 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/Intents.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Intents.java
@@ -10,8 +10,11 @@
 import android.os.Bundle;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.text.TextUtils;
 
+import com.mopub.common.MoPubBrowser;
 import com.mopub.common.Preconditions;
+import com.mopub.common.UrlAction;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.exceptions.IntentNotResolvableException;
 import com.mopub.exceptions.UrlParseException;
@@ -21,11 +24,6 @@
 import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
 
 public class Intents {
-    private static final String PLAY_GOOGLE_COM = "play.google.com";
-    private static final String MARKET_ANDROID_COM = "market.android.com";
-    private static final String MARKET = "market";
-    private static final String HTTP = "http";
-    private static final String HTTPS = "https";
 
     private Intents() {}
 
@@ -75,52 +73,19 @@ public static boolean deviceCanHandleIntent(@NonNull final Context context,
         }
     }
 
-    public static boolean isHttpUrl(final String url) {
-        if (url == null) {
-            return false;
-        }
-
-        final String scheme = Uri.parse(url).getScheme();
-        return (HTTP.equals(scheme) || HTTPS.equals(scheme));
-    }
-
-    private static boolean isAppStoreUrl(final String url) {
-        if (url == null) {
-            return false;
-        }
-
-        final Uri uri = Uri.parse(url);
-        final String scheme = uri.getScheme();
-        final String host = uri.getHost();
-
-        if (PLAY_GOOGLE_COM.equals(host) || MARKET_ANDROID_COM.equals(host)) {
-            return true;
-        }
-
-        if (MARKET.equals(scheme)) {
-            return true;
-        }
-
-        return false;
-    }
-
-    public static boolean isDeepLink(final String url) {
-        return isAppStoreUrl(url) || !isHttpUrl(url);
-    }
-
-    public static boolean canHandleApplicationUrl(final Context context, final String url) {
-        return canHandleApplicationUrl(context, url, true);
+    public static boolean canHandleApplicationUrl(final Context context, final Uri uri) {
+        return canHandleApplicationUrl(context, uri, true);
     }
 
-    public static boolean canHandleApplicationUrl(final Context context, final String url,
+    public static boolean canHandleApplicationUrl(final Context context, final Uri uri,
             final boolean logError) {
         // Determine which activities can handle the intent
-        final Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
+        final Intent intent = new Intent(Intent.ACTION_VIEW, uri);
 
         // If there are no relevant activities, don't follow the link
         if (!Intents.deviceCanHandleIntent(context, intent)) {
             if (logError) {
-                MoPubLog.w("Could not handle application specific action: " + url + ". " +
+                MoPubLog.w("Could not handle application specific action: " + uri + ". " +
                         "You may be running in the emulator or another device which does not " +
                         "have the required application.");
             }
@@ -130,30 +95,24 @@ public static boolean canHandleApplicationUrl(final Context context, final Strin
         return true;
     }
 
-    public static boolean isNativeBrowserScheme(@NonNull final String url) {
-        return url.startsWith("mopubnativebrowser://");
-    }
-
     /**
      * Native Browser Scheme URLs provide a means for advertisers to include links that click out to
      * an external browser, rather than the MoPub in-app browser. Properly formatted native browser
      * URLs take the form of "mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.mopub.com".
      *
-     * @param url
+     * @param uri The Native Browser Scheme URL to open in the external browser.
      * @return An Intent that will open an app-external browser taking the user to a page specified
      * in the query parameter of the passed-in url
      * @throws UrlParseException if the provided url has an invalid format or is non-hierarchical
      */
-    public static Intent intentForNativeBrowserScheme(@NonNull final String url)
+    public static Intent intentForNativeBrowserScheme(@NonNull final Uri uri)
             throws UrlParseException {
-        Preconditions.checkNotNull(url);
+        Preconditions.checkNotNull(uri);
 
-        if (!isNativeBrowserScheme(url)) {
+        if (!UrlAction.OPEN_NATIVE_BROWSER.shouldTryHandlingUrl(uri)) {
             throw new UrlParseException("URL does not have mopubnativebrowser:// scheme.");
         }
 
-        final Uri uri = Uri.parse(url);
-
         if (!"navigate".equals(uri.getHost())) {
             throw new UrlParseException("URL missing 'navigate' host parameter.");
         }
@@ -164,7 +123,7 @@ public static Intent intentForNativeBrowserScheme(@NonNull final String url)
         } catch (UnsupportedOperationException e) {
             // Accessing query parameters only makes sense for hierarchical URIs as per:
             // http://developer.android.com/reference/android/net/Uri.html#getQueryParameter(java.lang.String)
-            MoPubLog.w("Could not handle url: " + url);
+            MoPubLog.w("Could not handle url: " + uri);
             throw new UrlParseException("Passed-in URL did not create a hierarchical URI.");
         }
 
@@ -175,4 +134,124 @@ public static Intent intentForNativeBrowserScheme(@NonNull final String url)
         final Uri intentUri = Uri.parse(urlToOpenInNativeBrowser);
         return new Intent(Intent.ACTION_VIEW, intentUri);
     }
+
+    /**
+     * Share Tweet URLs provide a means for advertisers on Twitter to include tweet links
+     * promoting their products that can be shared via supporting apps on the device.  Any
+     * app with a filter that matches ACTION_SEND and MIME type text/plain is capable of sharing
+     * the tweet link.
+     *
+     * Properly formatted share tweet URLs take the form of
+     * "mopubshare://tweet?screen_name=<SCREEN_NAME>&tweet_id=<TWEET_ID>"
+     *
+     * Both screen_name and tweet_id are required query parameters.  This method does not verify
+     * that their values are existent and valid on Twitter, but UrlParseException would be thrown
+     * if either is missing or empty.
+     *
+     * Example user flow:
+     * Upon clicking "mopubshare://tweet?screen_name=SpaceX&tweet_id=596026229536460802" in an ad,
+     * a chooser dialog with message "Share via" pops up listing existing apps on the device
+     * capable of sharing this tweet link.  After the user chooses an app to share the tweet,
+     * the message “Check out @SpaceX's Tweet: https://twitter.com/SpaceX/status/596026229536460802”
+     * is ready to be shared in the chosen app.
+     *
+     * @param uri The Share Tweet URL indicating the tweet to share
+     * @return An ACTION_SEND intent that will be wrapped in a chooser intent
+     * @throws UrlParseException if the provided url has an invalid format or is non-hierarchical
+     */
+    public static Intent intentForShareTweet(@NonNull final Uri uri)
+            throws UrlParseException {
+        if (!UrlAction.HANDLE_SHARE_TWEET.shouldTryHandlingUrl(uri)) {
+            throw new UrlParseException("URL does not have mopubshare://tweet? format.");
+        }
+
+        final String screenName;
+        final String tweetId;
+
+        try {
+            screenName = uri.getQueryParameter("screen_name");
+            tweetId = uri.getQueryParameter("tweet_id");
+        } catch (UnsupportedOperationException e) {
+            // Accessing query parameters only makes sense for hierarchical URIs as per:
+            // http://developer.android.com/reference/android/net/Uri.html#getQueryParameter(java.lang.String)
+            MoPubLog.w("Could not handle url: " + uri);
+            throw new UrlParseException("Passed-in URL did not create a hierarchical URI.");
+        }
+
+        // If either query parameter is null or empty, throw UrlParseException
+        if (TextUtils.isEmpty(screenName)) {
+            throw new UrlParseException("URL missing non-empty 'screen_name' query parameter.");
+        }
+        if (TextUtils.isEmpty(tweetId)) {
+            throw new UrlParseException("URL missing non-empty 'tweet_id' query parameter.");
+        }
+
+        // Derive the tweet link on Twitter
+        final String tweetUrl = String.format("https://twitter.com/%s/status/%s", screenName, tweetId);
+
+        // Compose the share message
+        final String shareMessage = String.format("Check out @%s's Tweet: %s", screenName, tweetUrl);
+
+        // Construct share intent with the shareMessage in subject and text
+        Intent shareTweetIntent = new Intent(Intent.ACTION_SEND);
+        shareTweetIntent.setType("text/plain");
+        shareTweetIntent.putExtra(Intent.EXTRA_SUBJECT, shareMessage);
+        shareTweetIntent.putExtra(Intent.EXTRA_TEXT, shareMessage);
+
+        return shareTweetIntent;
+    }
+
+    /**
+     * Launches a {@link MoPubBrowser} activity with the desired URL.
+     *  @param context The activity context.
+     * @param uri The URL to load in the started {@link MoPubBrowser} activity.
+     */
+    public static void showMoPubBrowserForUrl(@NonNull final Context context,
+            @NonNull Uri uri) throws IntentNotResolvableException {
+        MoPubLog.d("Final URI to show in browser: " + uri);
+
+        final Bundle extras = new Bundle();
+        extras.putString(MoPubBrowser.DESTINATION_URL_KEY, uri.toString());
+        Intent intent = getStartActivityIntent(context, MoPubBrowser.class, extras);
+
+        String errorMessage = "Could not show MoPubBrowser for url: " + uri + "\n\tPerhaps you " +
+                "forgot to declare com.mopub.common.MoPubBrowser in your Android manifest file.";
+
+        launchIntentForUserClick(context, intent, errorMessage);
+    }
+
+    public static void launchActionViewIntent(Context context, @NonNull final Uri uri,
+            @NonNull final String errorMessage) throws IntentNotResolvableException {
+        final Intent intent = new Intent(Intent.ACTION_VIEW, uri);
+        if (!(context instanceof Activity)) {
+            intent.addFlags(FLAG_ACTIVITY_NEW_TASK);
+        }
+
+        launchIntentForUserClick(context, intent, errorMessage);
+    }
+
+    public static void launchIntentForUserClick(@NonNull final Context context,
+            @NonNull final Intent intent, @Nullable final String errorMessage)
+            throws IntentNotResolvableException {
+        Preconditions.NoThrow.checkNotNull(context);
+        Preconditions.NoThrow.checkNotNull(intent);
+
+        try {
+            Intents.startActivity(context, intent);
+        } catch (IntentNotResolvableException e) {
+            throw new IntentNotResolvableException(errorMessage + "\n" + e.getMessage());
+        }
+    }
+
+    public static void launchApplicationUrl(@NonNull final Context context,
+            @NonNull final Uri uri) throws IntentNotResolvableException {
+        if (Intents.canHandleApplicationUrl(context, uri)) {
+            final String errorMessage = "Unable to open intent for: " + uri;
+            Intents.launchActionViewIntent(context, uri, errorMessage);
+        } else {
+            throw new IntentNotResolvableException("Could not handle application specific " +
+                    "action: " + uri + "\n\tYou may be running in the emulator or another " +
+                    "device which does not have the required application.");
+        }
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/ResponseHeader.java b/mopub-sdk/src/main/java/com/mopub/common/util/ResponseHeader.java
index 995b1224..6e407f85 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/ResponseHeader.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/ResponseHeader.java
@@ -15,6 +15,7 @@
     REDIRECT_URL("X-Launchpage"),
     NATIVE_PARAMS("X-Nativeparams"),
     NETWORK_TYPE("X-Networktype"),
+    ORIENTATION("X-Orientation"),
     REFRESH_TIME("X-Refreshtime"),
     SCROLLABLE("X-Scrollable"),
     WARMUP("X-Warmup"),
@@ -22,6 +23,7 @@
 
     LOCATION("Location"),
     USER_AGENT("User-Agent"),
+    ACCEPT_LANGUAGE("Accept-Language"),
 
     @Deprecated CUSTOM_SELECTOR("X-Customselector");
 
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/Strings.java b/mopub-sdk/src/main/java/com/mopub/common/util/Strings.java
index fed28d0a..bcb949c7 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/Strings.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Strings.java
@@ -1,9 +1,16 @@
 package com.mopub.common.util;
 
+import android.text.TextUtils;
+
 import java.io.IOException;
 import java.io.InputStream;
+import java.util.regex.Pattern;
 
 public class Strings {
+    // Regex patterns
+    private static Pattern percentagePattern = Pattern.compile("((\\d{1,2})|(100))%");
+    private static Pattern absolutePattern = Pattern.compile("\\d{2}:\\d{2}:\\d{2}(.\\d{3})?");
+
     public static String fromStream(InputStream inputStream) throws IOException {
         int numberBytesRead = 0;
         StringBuilder out = new StringBuilder();
@@ -18,4 +25,25 @@ public static String fromStream(InputStream inputStream) throws IOException {
 
         return out.toString();
     }
+
+    public static boolean isPercentageTracker(String progressValue) {
+        return !TextUtils.isEmpty(progressValue)
+                && percentagePattern.matcher(progressValue).matches();
+    }
+
+    public static boolean isAbsoluteTracker(String progressValue) {
+        return !TextUtils.isEmpty(progressValue)
+                && absolutePattern.matcher(progressValue).matches();
+    }
+
+    public static Integer parseAbsoluteOffset(String progressValue) {
+        final String[] split = progressValue.split(":");
+        if (split.length != 3) {
+            return null;
+        }
+
+        return Integer.parseInt(split[0]) * 60 * 60 * 1000 // Hours
+                + Integer.parseInt(split[1]) * 60 * 1000 // Minutes
+                + (int)(Float.parseFloat(split[2]) * 1000);
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/exceptions/IntentNotResolvableException.java b/mopub-sdk/src/main/java/com/mopub/exceptions/IntentNotResolvableException.java
index aa114d2a..4eb87f6f 100644
--- a/mopub-sdk/src/main/java/com/mopub/exceptions/IntentNotResolvableException.java
+++ b/mopub-sdk/src/main/java/com/mopub/exceptions/IntentNotResolvableException.java
@@ -4,4 +4,8 @@
     public IntentNotResolvableException(Throwable throwable) {
         super(throwable);
     }
+
+    public IntentNotResolvableException(String message) {
+        super(message);
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertReporter.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertReporter.java
index c713f193..ca5087ce 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertReporter.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertReporter.java
@@ -5,13 +5,13 @@
 import android.graphics.Bitmap;
 import android.net.Uri;
 import android.support.annotation.Nullable;
+import android.util.Base64;
 import android.view.View;
 
 import com.mopub.common.AdReport;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.util.DateAndTime;
 import com.mopub.common.util.Streams;
-import com.mopub.mobileads.util.Base64;
 
 import java.io.ByteArrayOutputStream;
 import java.io.File;
@@ -75,8 +75,8 @@ public void send() {
 
     private void initEmailIntent() {
         Uri emailScheme = Uri.parse(EMAIL_SCHEME);
-        mEmailIntent = new Intent(Intent.ACTION_SEND_MULTIPLE, emailScheme);
-        mEmailIntent.setType("plain/text");
+        mEmailIntent = new Intent(Intent.ACTION_SEND_MULTIPLE);
+        mEmailIntent.setDataAndType(emailScheme, "plain/text");
         mEmailIntent.putExtra(Intent.EXTRA_EMAIL, new String[]{EMAIL_RECIPIENT});
     }
 
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdViewController.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdViewController.java
index 9f9b7cf3..a049e317 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdViewController.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/AdViewController.java
@@ -18,8 +18,9 @@
 import com.mopub.common.ClientMetadata;
 import com.mopub.common.Constants;
 import com.mopub.common.VisibleForTesting;
-import com.mopub.common.event.MoPubEvents;
+import com.mopub.common.event.BaseEvent;
 import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.DeviceUtils;
 import com.mopub.common.util.Dips;
 import com.mopub.common.util.Utils;
 import com.mopub.mraid.MraidNativeCommandHandler;
@@ -28,6 +29,7 @@
 import com.mopub.network.MoPubNetworkError;
 import com.mopub.network.Networking;
 import com.mopub.network.TrackingRequest;
+import com.mopub.volley.NetworkResponse;
 import com.mopub.volley.RequestQueue;
 import com.mopub.volley.VolleyError;
 
@@ -37,8 +39,6 @@
 import java.util.WeakHashMap;
 
 import static android.Manifest.permission.ACCESS_NETWORK_STATE;
-import static com.mopub.network.MoPubNetworkError.Reason.NO_FILL;
-import static com.mopub.network.MoPubNetworkError.Reason.WARMING_UP;
 
 public class AdViewController {
     static final int DEFAULT_REFRESH_TIME_MILLISECONDS = 60000;  // 1 minute
@@ -51,17 +51,19 @@
                     Gravity.CENTER);
     private final static WeakHashMap<View,Boolean> sViewShouldHonorServerDimensions = new WeakHashMap<View, Boolean>();
 
-    private final Context mContext;
     private final long mBroadcastIdentifier;
 
+    @Nullable
+    private Context mContext;
     @Nullable
     private MoPubView mMoPubView;
-    private final WebViewAdUrlGenerator mUrlGenerator;
+    @Nullable
+    private WebViewAdUrlGenerator mUrlGenerator;
 
     @Nullable
     private AdResponse mAdResponse;
     private final Runnable mRefreshRunnable;
-    @Nullable
+    @NonNull
     private final AdRequest.Listener mAdListener;
 
     private boolean mIsDestroyed;
@@ -70,7 +72,8 @@
     private String mUrl;
 
     // This is the power of the exponential term in the exponential backoff calculation.
-    private int mBackoffPower = 1;
+    @VisibleForTesting
+    int mBackoffPower = 1;
 
     private Map<String, Object> mLocalExtras = new HashMap<String, Object>();
     private boolean mAutoRefreshEnabled = true;
@@ -95,14 +98,15 @@ private static boolean getShouldHonorServerDimensions(View view) {
         return sViewShouldHonorServerDimensions.get(view) != null;
     }
 
-    public AdViewController(Context context, MoPubView view) {
+    public AdViewController(@NonNull Context context, @NonNull MoPubView view) {
         mContext = context;
         mMoPubView = view;
+
         // Default timeout means "never refresh"
         mTimeoutMilliseconds = -1;
         mBroadcastIdentifier = Utils.generateUniqueId();
 
-        mUrlGenerator = new WebViewAdUrlGenerator(context,
+        mUrlGenerator = new WebViewAdUrlGenerator(mContext.getApplicationContext(),
                 MraidNativeCommandHandler.isStorePictureSupported(mContext));
 
         mAdListener = new AdRequest.Listener() {
@@ -132,7 +136,8 @@ void onAdLoadSuccess(@NonNull final AdResponse adResponse) {
         mAdResponse = adResponse;
         // Do other ad loading setup. See AdFetcher & AdLoadTask.
         mTimeoutMilliseconds = mAdResponse.getAdTimeoutMillis() == null
-                ? mTimeoutMilliseconds : mAdResponse.getAdTimeoutMillis();
+                ? mTimeoutMilliseconds
+                : mAdResponse.getAdTimeoutMillis();
         mRefreshTimeMillis = mAdResponse.getRefreshTimeMillis();
         setNotLoading();
 
@@ -146,25 +151,60 @@ void onAdLoadSuccess(@NonNull final AdResponse adResponse) {
 
     @VisibleForTesting
     void onAdLoadError(final VolleyError error) {
-        MoPubErrorCode errorCode = MoPubErrorCode.UNSPECIFIED;
-        // Handle errors. Do backoff & retry if it makes sense.
         if (error instanceof MoPubNetworkError) {
-            MoPubNetworkError mpError = (MoPubNetworkError) error;
-            if (mpError.getReason() == NO_FILL || mpError.getReason() == WARMING_UP) {
-                errorCode = MoPubErrorCode.NO_FILL;
+            // If provided, the MoPubNetworkError's refresh time takes precedence over the
+            // previously set refresh time.
+            // The only types of NetworkErrors that can possibly modify
+            // an ad's refresh time are CLEAR requests. For CLEAR requests that (erroneously) omit a
+            // refresh time header and for all other non-CLEAR types of NetworkErrors, we simply
+            // maintain the previous refresh time value.
+            final MoPubNetworkError moPubNetworkError = (MoPubNetworkError) error;
+            if (moPubNetworkError.getRefreshTimeMillis() != null) {
+                mRefreshTimeMillis = moPubNetworkError.getRefreshTimeMillis();
             }
         }
 
-        if (error.networkResponse != null && error.networkResponse.statusCode >= 400) {
-            // Backoff with the retry timer.
-            mBackoffPower += 1;
-            errorCode = MoPubErrorCode.SERVER_ERROR;
+        final MoPubErrorCode errorCode = getErrorCodeFromVolleyError(error, mContext);
+        if (errorCode == MoPubErrorCode.SERVER_ERROR) {
+            mBackoffPower++;
         }
 
         setNotLoading();
         adDidFail(errorCode);
     }
 
+    @VisibleForTesting
+    @NonNull
+    static MoPubErrorCode getErrorCodeFromVolleyError(@NonNull final VolleyError error,
+            @Nullable final Context context) {
+        final NetworkResponse networkResponse = error.networkResponse;
+
+        // For MoPubNetworkErrors, networkResponse is null.
+        if (error instanceof MoPubNetworkError) {
+            switch (((MoPubNetworkError) error).getReason()) {
+                case WARMING_UP:
+                    return MoPubErrorCode.WARMUP;
+                case NO_FILL:
+                    return MoPubErrorCode.NO_FILL;
+                default:
+                    return MoPubErrorCode.UNSPECIFIED;
+            }
+        }
+
+        if (networkResponse == null) {
+            if (!DeviceUtils.isNetworkAvailable(context)) {
+                return MoPubErrorCode.NO_CONNECTION;
+            }
+            return MoPubErrorCode.UNSPECIFIED;
+        }
+
+        if (error.networkResponse.statusCode >= 400) {
+            return MoPubErrorCode.SERVER_ERROR;
+        }
+
+        return MoPubErrorCode.UNSPECIFIED;
+    }
+
     @Nullable
     public MoPubView getMoPubView() {
         return mMoPubView;
@@ -386,6 +426,8 @@ void cleanup() {
         // thanks to some persistent references in WebViewCore. We manually release some resources
         // to compensate for this "leak".
         mMoPubView = null;
+        mContext = null;
+        mUrlGenerator = null;
 
         // Flag as destroyed. LoadUrlTask checks this before proceeding in its onPostExecute().
         mIsDestroyed = true;
@@ -398,20 +440,20 @@ Integer getAdTimeoutDelay() {
     void trackImpression() {
         if (mAdResponse != null) {
             TrackingRequest.makeTrackingHttpRequest(mAdResponse.getImpressionTrackingUrl(),
-                    mContext, MoPubEvents.Type.IMPRESSION_REQUEST);
+                    mContext, BaseEvent.Name.IMPRESSION_REQUEST);
         }
     }
 
     void registerClick() {
         if (mAdResponse != null) {
             TrackingRequest.makeTrackingHttpRequest(mAdResponse.getClickTrackingUrl(),
-                    mContext, MoPubEvents.Type.CLICK_REQUEST);
+                    mContext, BaseEvent.Name.CLICK_REQUEST);
         }
     }
 
     void fetchAd(String url) {
         MoPubView moPubView = getMoPubView();
-        if (moPubView == null) {
+        if (moPubView == null || mContext == null) {
             MoPubLog.d("Can't load an ad in this ad view because it was destroyed.");
             setNotLoading();
             return;
@@ -420,6 +462,7 @@ void fetchAd(String url) {
         AdRequest adRequest = new AdRequest(url,
                 moPubView.getAdFormat(),
                 mAdUnitId,
+                mContext,
                 mAdListener
         );
         RequestQueue requestQueue = Networking.getRequestQueue(mContext);
@@ -432,8 +475,9 @@ void forceRefresh() {
         loadAd();
     }
 
+    @Nullable
     String generateAdUrl() {
-        return mUrlGenerator
+        return mUrlGenerator == null ? null : mUrlGenerator
                 .withAdUnitId(mAdUnitId)
                 .withKeywords(mKeywords)
                 .withLocation(mLocation)
@@ -483,6 +527,9 @@ private void cancelRefreshTimer() {
     }
 
     private boolean isNetworkAvailable() {
+        if (mContext == null) {
+            return false;
+        }
         // If we don't have network state access, just assume the network is up.
         int result = mContext.checkCallingPermission(ACCESS_NETWORK_STATE);
         if (result == PackageManager.PERMISSION_DENIED) return true;
@@ -529,6 +576,18 @@ public void run() {
         }
     }
 
+    @Deprecated // for testing
+    @VisibleForTesting
+    Integer getRefreshTimeMillis() {
+        return mRefreshTimeMillis;
+    }
+
+    @Deprecated // for testing
+    @VisibleForTesting
+    void setRefreshTimeMillis(@Nullable final Integer refreshTimeMillis) {
+        mRefreshTimeMillis = refreshTimeMillis;
+    }
+
     @Deprecated
     public void customEventDidLoadAd() {
         setNotLoading();
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventBannerAdapter.java b/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventBannerAdapter.java
index 2ff7a2cf..bd9abaad 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventBannerAdapter.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventBannerAdapter.java
@@ -16,7 +16,9 @@
 import java.util.Map;
 import java.util.TreeMap;
 
+import static com.mopub.common.DataKeys.AD_HEIGHT;
 import static com.mopub.common.DataKeys.AD_REPORT_KEY;
+import static com.mopub.common.DataKeys.AD_WIDTH;
 import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
 import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_TIMEOUT;
@@ -71,6 +73,8 @@ public void run() {
         }
         mLocalExtras.put(BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
         mLocalExtras.put(AD_REPORT_KEY, adReport);
+        mLocalExtras.put(AD_WIDTH, mMoPubView.getAdWidth());
+        mLocalExtras.put(AD_HEIGHT, mMoPubView.getAdHeight());
     }
 
     void loadAd() {
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventRewardedVideo.java b/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventRewardedVideo.java
index 266472ab..ec9edbb4 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventRewardedVideo.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventRewardedVideo.java
@@ -82,7 +82,7 @@ final void loadCustomEvent(@NonNull Activity launcherActivity,
      * to do any static initialization the first time this method is run by any class instance.
      * From then on, the SDK should be reused without initialization.
      *
-     * @return true if the SDK performed initialization.
+     * @return true if the SDK performed initialization, false if the SDK was already initialized.
      */
     protected abstract boolean checkAndInitializeSdk(@NonNull Activity launcherActivity,
             @NonNull Map<String, Object> localExtras,
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlInterstitial.java b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlInterstitial.java
index dd1e5bc7..f0643055 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlInterstitial.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlInterstitial.java
@@ -1,8 +1,13 @@
 package com.mopub.mobileads;
 
+import android.support.annotation.NonNull;
+
+import com.mopub.common.CreativeOrientation;
+
 import java.util.Map;
 
 import static com.mopub.common.DataKeys.CLICKTHROUGH_URL_KEY;
+import static com.mopub.common.DataKeys.CREATIVE_ORIENTATION_KEY;
 import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
 import static com.mopub.common.DataKeys.REDIRECT_URL_KEY;
 import static com.mopub.common.DataKeys.SCROLLABLE_KEY;
@@ -12,6 +17,8 @@
     private boolean mIsScrollable;
     private String mRedirectUrl;
     private String mClickthroughUrl;
+    @NonNull
+    private CreativeOrientation mOrientation;
 
     @Override
     protected void extractExtras(Map<String, String> serverExtras) {
@@ -19,6 +26,7 @@ protected void extractExtras(Map<String, String> serverExtras) {
         mIsScrollable = Boolean.valueOf(serverExtras.get(SCROLLABLE_KEY));
         mRedirectUrl = serverExtras.get(REDIRECT_URL_KEY);
         mClickthroughUrl = serverExtras.get(CLICKTHROUGH_URL_KEY);
+        mOrientation = CreativeOrientation.fromHeader(serverExtras.get(CREATIVE_ORIENTATION_KEY));
     }
 
     @Override
@@ -28,6 +36,8 @@ protected void preRenderHtml(CustomEventInterstitialListener customEventIntersti
 
     @Override
     public void showInterstitial() {
-        MoPubActivity.start(mContext, mHtmlData, mAdReport, mIsScrollable, mRedirectUrl, mClickthroughUrl, mBroadcastIdentifier);
+        MoPubActivity.start(mContext, mHtmlData, mAdReport, mIsScrollable,
+                mRedirectUrl, mClickthroughUrl, mOrientation,
+                mBroadcastIdentifier);
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlWebViewClient.java b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlWebViewClient.java
index 9e165d54..b581bb8b 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlWebViewClient.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlWebViewClient.java
@@ -1,21 +1,17 @@
 package com.mopub.mobileads;
 
 import android.content.Context;
-import android.content.Intent;
 import android.graphics.Bitmap;
 import android.net.Uri;
-import android.os.Bundle;
 import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
 import android.webkit.WebView;
 import android.webkit.WebViewClient;
 
-import com.mopub.common.MoPubBrowser;
-import com.mopub.common.Preconditions;
+import com.mopub.common.UrlHandler;
+import com.mopub.common.UrlAction;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.util.Intents;
 import com.mopub.exceptions.IntentNotResolvableException;
-import com.mopub.exceptions.UrlParseException;
 
 import static com.mopub.mobileads.MoPubErrorCode.UNSPECIFIED;
 
@@ -37,39 +33,50 @@
         mContext = htmlWebView.getContext();
     }
 
-    /**
-     * Called upon user click, when the WebView attempts to load a new URL. Attempts to handle mopub
-     * and phone-specific schemes, open mopubnativebrowser links in the device browser, deep-links
-     * in the corresponding application, and all other links in the MoPub in-app browser.
-     */
     @Override
-    public boolean shouldOverrideUrlLoading(WebView view, String url) {
-        MoPubLog.d("Ad clicked. Click URL: " + url);
-
-        if (handleSpecialMoPubScheme(url) || handlePhoneScheme(url)) {
-            return true;
-        }
-
-        // MoPubNativeBrowser URLs
-        if (Intents.isNativeBrowserScheme(url)) {
-            final String errorMessage = "Unable to load mopub native browser url: " + url;
-            try {
-                final Intent intent = Intents.intentForNativeBrowserScheme(url);
-                launchIntentForUserClick(mContext, intent, errorMessage);
-            } catch (UrlParseException e) {
-                MoPubLog.d(errorMessage + ". " + e.getMessage());
-            }
-
-            return true;
-        }
-
-        // Non-http(s) URLs
-        if (!Intents.isHttpUrl(url) && Intents.canHandleApplicationUrl(mContext, url)) {
-            launchApplicationUrl(url);
-            return true;
-        }
-
-        showMoPubBrowserForUrl(url);
+    public boolean shouldOverrideUrlLoading(final WebView view, final String url) {
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(
+                        UrlAction.HANDLE_MOPUB_SCHEME,
+                        UrlAction.IGNORE_ABOUT_SCHEME,
+                        UrlAction.HANDLE_PHONE_SCHEME,
+                        UrlAction.OPEN_APP_MARKET,
+                        UrlAction.OPEN_NATIVE_BROWSER,
+                        UrlAction.OPEN_IN_APP_BROWSER,
+                        UrlAction.HANDLE_SHARE_TWEET,
+                        UrlAction.FOLLOW_DEEP_LINK)
+                .withResultActions(new UrlHandler.ResultActions() {
+                    @Override
+                    public void urlHandlingSucceeded(@NonNull String url,
+                            @NonNull UrlAction urlAction) {
+                        if (mHtmlWebView.wasClicked()) {
+                            mHtmlWebViewListener.onClicked();
+                            mHtmlWebView.onResetUserClick();
+                        }
+                    }
+
+                    @Override
+                    public void urlHandlingFailed(@NonNull String url,
+                            @NonNull UrlAction lastFailedUrlAction) {
+                    }
+                })
+                .withMoPubSchemeListener(new UrlHandler.MoPubSchemeListener() {
+                    @Override
+                    public void onFinishLoad() {
+                        mHtmlWebViewListener.onLoaded(mHtmlWebView);
+                    }
+
+                    @Override
+                    public void onClose() {
+                        mHtmlWebViewListener.onCollapsed();
+                    }
+
+                    @Override
+                    public void onFailLoad() {
+                        mHtmlWebViewListener.onFailed(UNSPECIFIED);
+                    }
+                })
+                .build().handleUrl(mContext, url, mHtmlWebView.wasClicked());
         return true;
     }
 
@@ -78,129 +85,16 @@ public void onPageStarted(WebView view, String url, Bitmap favicon) {
         // If the URL being loaded shares the redirectUrl prefix, open it in the browser.
         if (mRedirectUrl != null && url.startsWith(mRedirectUrl)) {
             view.stopLoading();
-            showMoPubBrowserForUrl(url);
-        }
-    }
-
-    private boolean isSpecialMoPubScheme(String url) {
-        return url.startsWith("mopub://");
-    }
-
-    private boolean handleSpecialMoPubScheme(String url) {
-        if (!isSpecialMoPubScheme(url)) {
-            return false;
-        }
-        Uri uri = Uri.parse(url);
-        String host = uri.getHost();
-
-        if ("finishLoad".equals(host)) {
-            mHtmlWebViewListener.onLoaded(mHtmlWebView);
-        } else if ("close".equals(host)) {
-            mHtmlWebViewListener.onCollapsed();
-        } else if ("failLoad".equals(host)) {
-            mHtmlWebViewListener.onFailed(UNSPECIFIED);
-        } else if ("custom".equals(host)) {
-            handleCustomIntentFromUri(uri);
-        }
-
-        return true;
-    }
-
-    private boolean isPhoneScheme(String url) {
-        return url.startsWith("tel:") || url.startsWith("voicemail:") ||
-                url.startsWith("sms:") || url.startsWith("mailto:") ||
-                url.startsWith("geo:") || url.startsWith("google.streetview:");
-    }
-
-    private boolean handlePhoneScheme(String url) {
-        if (!isPhoneScheme(url)) {
-            return false;
-        }
-        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
-        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-
-        String errorMessage = "Could not handle intent with URI: " + url
-                + ". Is this intent supported on your phone?";
-
-        launchIntentForUserClick(mContext, intent, errorMessage);
-
-        return true;
-    }
-
-    private boolean launchApplicationUrl(String url) {
-        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
-        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-
-        String errorMessage = "Unable to open intent.";
-
-        return launchIntentForUserClick(mContext, intent, errorMessage);
-    }
-
-    private void showMoPubBrowserForUrl(String url) {
-        if (url == null || url.equals("")) {
-            url = "about:blank";
-        }
-        MoPubLog.d("Final URI to show in browser: " + url);
-
-        final Bundle extras = new Bundle();
-        extras.putString(MoPubBrowser.DESTINATION_URL_KEY, url);
-        Intent intent = Intents.getStartActivityIntent(mContext, MoPubBrowser.class, extras);
-
-        String errorMessage = "Could not handle intent action. "
-                + ". Perhaps you forgot to declare com.mopub.common.MoPubBrowser"
-                + " in your Android manifest file.";
-
-        boolean handledByMoPubBrowser = launchIntentForUserClick(mContext, intent, errorMessage);
-
-        if (!handledByMoPubBrowser) {
-            intent = new Intent(Intent.ACTION_VIEW, Uri.parse("about:blank"));
-            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-            launchIntentForUserClick(mContext, intent, null);
-        }
-    }
-
-    private void handleCustomIntentFromUri(Uri uri) {
-        String action;
-        String adData;
-        try {
-            action = uri.getQueryParameter("fnc");
-            adData = uri.getQueryParameter("data");
-        } catch (UnsupportedOperationException e) {
-            MoPubLog.w("Could not handle custom intent with uri: " + uri);
-            return;
+            if (mHtmlWebView.wasClicked()) {
+                try {
+                    Intents.showMoPubBrowserForUrl(mContext, Uri.parse(url));
+                } catch (IntentNotResolvableException e) {
+                    MoPubLog.d(e.getMessage());
+                }
+            } else {
+                MoPubLog.d("Attempted to redirect without user interaction");
+            }
         }
-
-        Intent customIntent = new Intent(action);
-        customIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-        customIntent.putExtra(HtmlBannerWebView.EXTRA_AD_CLICK_DATA, adData);
-
-        String errorMessage = "Could not handle custom intent: " + action
-                + ". Is your intent spelled correctly?";
-
-        launchIntentForUserClick(mContext, customIntent, errorMessage);
     }
 
-    boolean launchIntentForUserClick(@Nullable final Context context, @NonNull final Intent intent,
-            @Nullable final String errorMessage) {
-        Preconditions.NoThrow.checkNotNull(intent);
-
-        if (context == null) {
-            MoPubLog.d(errorMessage);
-            return false;
-        }
-
-        if (!mHtmlWebView.wasClicked()) {
-            return false;
-        }
-
-        try {
-            Intents.startActivity(context, intent);
-            mHtmlWebViewListener.onClicked();
-            mHtmlWebView.onResetUserClick();
-            return true;
-        } catch (IntentNotResolvableException e) {
-            MoPubLog.d(errorMessage);
-            return false;
-        }
-    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubActivity.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubActivity.java
index 92d60c75..bf0168d3 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubActivity.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubActivity.java
@@ -10,8 +10,20 @@
 import android.webkit.WebViewClient;
 
 import com.mopub.common.AdReport;
+import com.mopub.common.CreativeOrientation;
+import com.mopub.common.DataKeys;
+import com.mopub.common.util.DeviceUtils;
 import com.mopub.mobileads.factories.HtmlInterstitialWebViewFactory;
 
+import java.io.Serializable;
+
+import static com.mopub.common.DataKeys.AD_REPORT_KEY;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
+import static com.mopub.common.DataKeys.CLICKTHROUGH_URL_KEY;
+import static com.mopub.common.DataKeys.CREATIVE_ORIENTATION_KEY;
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
+import static com.mopub.common.DataKeys.REDIRECT_URL_KEY;
+import static com.mopub.common.DataKeys.SCROLLABLE_KEY;
 import static com.mopub.mobileads.BaseInterstitialActivity.JavaScriptWebViewCallbacks.WEB_VIEW_DID_APPEAR;
 import static com.mopub.mobileads.BaseInterstitialActivity.JavaScriptWebViewCallbacks.WEB_VIEW_DID_CLOSE;
 import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
@@ -19,21 +31,18 @@
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_FAIL;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
-import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.broadcastAction;
-import static com.mopub.common.DataKeys.AD_REPORT_KEY;
-import static com.mopub.common.DataKeys.CLICKTHROUGH_URL_KEY;
-import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
-import static com.mopub.common.DataKeys.REDIRECT_URL_KEY;
-import static com.mopub.common.DataKeys.SCROLLABLE_KEY;
 import static com.mopub.mobileads.HtmlWebViewClient.MOPUB_FAIL_LOAD;
 import static com.mopub.mobileads.HtmlWebViewClient.MOPUB_FINISH_LOAD;
 
 public class MoPubActivity extends BaseInterstitialActivity {
     private HtmlInterstitialWebView mHtmlInterstitialWebView;
 
-    public static void start(Context context, String htmlData, AdReport adReport, boolean isScrollable, String redirectUrl, String clickthroughUrl, long broadcastIdentifier) {
-        Intent intent = createIntent(context, htmlData, adReport, isScrollable, redirectUrl, clickthroughUrl, broadcastIdentifier);
+    public static void start(Context context, String htmlData, AdReport adReport,
+            boolean isScrollable, String redirectUrl, String clickthroughUrl,
+            CreativeOrientation creativeOrientation, long broadcastIdentifier) {
+        Intent intent = createIntent(context, htmlData, adReport, isScrollable,
+                redirectUrl, clickthroughUrl, creativeOrientation, broadcastIdentifier);
         try {
             context.startActivity(intent);
         } catch (ActivityNotFoundException anfe) {
@@ -41,7 +50,9 @@ public static void start(Context context, String htmlData, AdReport adReport, bo
         }
     }
 
-    static Intent createIntent(Context context, String htmlData, AdReport adReport, boolean isScrollable, String redirectUrl, String clickthroughUrl, long broadcastIdentifier) {
+    static Intent createIntent(Context context,
+            String htmlData, AdReport adReport, boolean isScrollable, String redirectUrl,
+            String clickthroughUrl, CreativeOrientation orientation, long broadcastIdentifier) {
         Intent intent = new Intent(context, MoPubActivity.class);
         intent.putExtra(HTML_RESPONSE_BODY_KEY, htmlData);
         intent.putExtra(SCROLLABLE_KEY, isScrollable);
@@ -49,11 +60,14 @@ static Intent createIntent(Context context, String htmlData, AdReport adReport,
         intent.putExtra(REDIRECT_URL_KEY, redirectUrl);
         intent.putExtra(BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
         intent.putExtra(AD_REPORT_KEY, adReport);
+        intent.putExtra(CREATIVE_ORIENTATION_KEY, orientation);
         intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
         return intent;
     }
 
-    static void preRenderHtml(final Context context, final AdReport adReport, final CustomEventInterstitialListener customEventInterstitialListener, String htmlData) {
+    static void preRenderHtml(final Context context, final AdReport adReport,
+            final CustomEventInterstitialListener customEventInterstitialListener,
+            String htmlData) {
         HtmlInterstitialWebView dummyWebView = HtmlInterstitialWebViewFactory.create(context, adReport, customEventInterstitialListener, false, null, null);
         dummyWebView.enablePlugins(false);
         dummyWebView.setWebViewClient(new WebViewClient() {
@@ -89,6 +103,15 @@ public View getAdView() {
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
 
+        // Lock the device orientation
+        Serializable orientationExtra = getIntent().getSerializableExtra(DataKeys.CREATIVE_ORIENTATION_KEY);
+        CreativeOrientation requestedOrientation;
+        if (orientationExtra == null || !(orientationExtra instanceof CreativeOrientation)) {
+            requestedOrientation = CreativeOrientation.UNDEFINED;
+        } else {
+            requestedOrientation = (CreativeOrientation) orientationExtra;
+        }
+        DeviceUtils.lockOrientation(this, requestedOrientation);
         broadcastAction(this, getBroadcastIdentifier(), ACTION_INTERSTITIAL_SHOW);
     }
 
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubConversionTracker.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubConversionTracker.java
index ced697be..edcf4b3f 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubConversionTracker.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubConversionTracker.java
@@ -2,6 +2,7 @@
 
 import android.content.Context;
 import android.content.SharedPreferences;
+import android.support.annotation.NonNull;
 
 import com.mopub.common.BaseUrlGenerator;
 import com.mopub.common.ClientMetadata;
@@ -31,7 +32,7 @@ public void reportAppOpen(Context context) {
             TrackingRequest.makeTrackingHttpRequest(new ConversionUrlGenerator().generateUrlString(Constants.HOST),
                     mContext, new TrackingRequest.Listener() {
                 @Override
-                public void onResponse() {
+                public void onResponse(@NonNull String url) {
                     mSharedPreferences
                             .edit()
                             .putBoolean(mIsTrackedKey, true)
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubErrorCode.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubErrorCode.java
index e6d13749..d3322c04 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubErrorCode.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubErrorCode.java
@@ -2,10 +2,12 @@
 
 public enum MoPubErrorCode {
     NO_FILL("No ads found."),
+    WARMUP("Ad unit is warming up. Try again in a few minutes."),
     SERVER_ERROR("Unable to connect to MoPub adserver."),
     INTERNAL_ERROR("Unable to serve ad due to invalid internal state."),
     CANCELLED("Ad request was cancelled."),
-    
+    NO_CONNECTION("No internet connection detected."),
+
     ADAPTER_NOT_FOUND("Unable to find Native Network or Custom Event adapter."),
     ADAPTER_CONFIGURATION_ERROR("Native Network or Custom Event adapter was configured incorrectly."),
     NETWORK_TIMEOUT("Third-party network failed to respond in a timely manner."),
@@ -15,17 +17,17 @@
     VIDEO_CACHE_ERROR("Error creating a cache to store downloaded videos."),
     VIDEO_DOWNLOAD_ERROR("Error downloading video."),
 
-    VIDEO_NOT_AVAILABLE("No video loaded for ad unit"),
+    VIDEO_NOT_AVAILABLE("No video loaded for ad unit."),
     VIDEO_PLAYBACK_ERROR("Error playing a video."),
 
     UNSPECIFIED("Unspecified error.");
-    
+
     private final String message;
-    
+
     private MoPubErrorCode(String message) {
         this.message = message;
     }
-    
+
     @Override
     public String toString() {
         return this.message;
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoListener.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoListener.java
index 50d4f927..ff9361f1 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoListener.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoListener.java
@@ -7,7 +7,8 @@
 import java.util.Set;
 
 /**
- * Listener for rewarded video events. Implementers of this interface should be long-lived.
+ * Listener for rewarded video events. Implementers of this interface will receive events for all
+ * rewarded video ad units in the app.:
  */
 public interface MoPubRewardedVideoListener {
 
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoManager.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoManager.java
index f0473b5b..cc285b42 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoManager.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoManager.java
@@ -3,6 +3,7 @@
 import android.app.Activity;
 import android.content.Context;
 import android.os.Handler;
+import android.os.Looper;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 
@@ -14,6 +15,7 @@
 import com.mopub.common.MediationSettings;
 import com.mopub.common.MoPub;
 import com.mopub.common.MoPubReward;
+import com.mopub.common.Preconditions;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.util.MoPubCollections;
 import com.mopub.common.util.Reflection;
@@ -33,15 +35,18 @@
 import java.util.Set;
 import java.util.TreeMap;
 
+/**
+ */
 public class MoPubRewardedVideoManager {
     private static MoPubRewardedVideoManager sInstance;
     private static final int DEFAULT_LOAD_TIMEOUT = Constants.THIRTY_SECONDS_MILLIS;
 
+    @NonNull private final Handler mCallbackHandler;
     @NonNull private WeakReference<Activity> mMainActivity;
     @NonNull private final Context mContext;
     @NonNull private final AdRequestStatusMapping mAdRequestStatus;
     @NonNull private final RewardedVideoData mRewardedVideoData;
-    private MoPubRewardedVideoListener mVideoListener;
+    @Nullable private MoPubRewardedVideoListener mVideoListener;
     
     @NonNull private final Set<MediationSettings> mGlobalMediationSettings;
     @NonNull private final Map<String, Set<MediationSettings>> mInstanceMediationSettings;
@@ -73,7 +78,7 @@ private MoPubRewardedVideoManager(@NonNull Activity mainActivity, MediationSetti
         mMainActivity = new WeakReference<Activity>(mainActivity);
         mContext = mainActivity.getApplicationContext();
         mRewardedVideoData = new RewardedVideoData();
-
+        mCallbackHandler = new Handler(Looper.getMainLooper());
         mGlobalMediationSettings = new HashSet<MediationSettings>();
         MoPubCollections.addAllNonNull(mGlobalMediationSettings, mediationSettings);
         mInstanceMediationSettings = new HashMap<String, Set<MediationSettings>>();
@@ -222,6 +227,7 @@ private static void loadVideo(@NonNull String adUnitId, @NonNull String adUrlStr
                 adUrlString,
                 AdFormat.REWARDED_VIDEO,
                 adUnitId,
+                sInstance.mContext,
                 new RewardedVideoRequestListener(sInstance, adUnitId)
         );
         final RequestQueue requestQueue = Networking.getRequestQueue(sInstance.mContext);
@@ -290,26 +296,37 @@ private void onAdSuccess(AdResponse adResponse, String adUnitId) {
             final Map<String, Object> localExtras = new TreeMap<String, Object>();
             localExtras.put(DataKeys.AD_UNIT_ID_KEY, adUnitId);
 
+            Activity mainActivity = mMainActivity.get();
+            if (mainActivity == null) {
+                MoPubLog.d("Could not load custom event because Activity reference was null. Call" +
+                        " MoPub#updateActivity before requesting more rewarded videos.");
+
+                // Don't go through the ordinary failover process since we have
+                // no activity for the failover to use.
+                mAdRequestStatus.markFail(adUnitId);
+                return;
+            }
+
             // Set up timeout calls.
             Runnable timeout = new Runnable() {
                 @Override
                 public void run() {
                     MoPubLog.d("Custom Event failed to load rewarded video in a timely fashion.");
-                    onRewardedVideoLoadFailure(customEvent.getClass(), customEvent.getAdNetworkId(), MoPubErrorCode.NETWORK_TIMEOUT);
+                    onRewardedVideoLoadFailure(customEvent.getClass(), customEvent.getAdNetworkId(),
+                            MoPubErrorCode.NETWORK_TIMEOUT);
                     customEvent.onInvalidate();
                 }
             };
             mCustomEventTimeoutHandler.postDelayed(timeout, timeoutMillis);
             mTimeoutMap.put(adUnitId, timeout);
 
-            // Load custom event - need an activity reference!
-            customEvent.loadCustomEvent(mMainActivity.get(), localExtras, adResponse.getServerExtras());
+            // Load custom event
+            customEvent.loadCustomEvent(mainActivity, localExtras, adResponse.getServerExtras());
 
             final CustomEventRewardedVideo.CustomEventRewardedVideoListener listener =
                     customEvent.getVideoListenerForSdk();
             final String adNetworkId = customEvent.getAdNetworkId();
             mRewardedVideoData.updateAdUnitCustomEventMapping(adUnitId, customEvent, listener, adNetworkId);
-
         } catch (Exception e) {
             MoPubLog.e(String.format(Locale.US, "Couldn't create custom event with class name %s", customEventClassName));
             failover(adUnitId, MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
@@ -331,6 +348,9 @@ private void onAdError(@NonNull VolleyError volleyError, @NonNull String adUnitI
                     errorCode = MoPubErrorCode.INTERNAL_ERROR;
             }
         }
+        if (volleyError instanceof com.mopub.volley.NoConnectionError) {
+            errorCode = MoPubErrorCode.NO_CONNECTION;
+        }
         failover(adUnitId, errorCode);
     }
 
@@ -340,7 +360,7 @@ private void failover(@NonNull final String adUnitId, @NonNull final MoPubErrorC
 
         if (failoverUrl != null) {
             loadVideo(adUnitId, failoverUrl);
-        } else {
+        } else if (mVideoListener != null) {
             mVideoListener.onRewardedVideoLoadFailure(adUnitId, errorCode);
         }
     }
@@ -364,80 +384,106 @@ private void cancelTimeouts(@NonNull String moPubId) {
      *           custom events should use these methods.
      */
     public static <T extends CustomEventRewardedVideo>
-    void onRewardedVideoLoadSuccess(@NonNull Class<T> customEventClass, @NonNull String thirdPartyId) {
-        if (sInstance != null) {
-            final Set<String> moPubIds = sInstance.mRewardedVideoData.getMoPubIdsForAdNetwork(customEventClass, thirdPartyId);
-            for (String moPubId : moPubIds) {
+    void onRewardedVideoLoadSuccess(@NonNull final Class<T> customEventClass, @NonNull final String thirdPartyId) {
+        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
+            @Override
+            protected void forEach(@NonNull final String moPubId) {
                 sInstance.cancelTimeouts(moPubId);
-                sInstance.mVideoListener.onRewardedVideoLoadSuccess(moPubId);
+                if (sInstance.mVideoListener != null) {
+                    sInstance.mVideoListener.onRewardedVideoLoadSuccess(moPubId);
+                }
             }
-        }
+        });
     }
 
     public static <T extends CustomEventRewardedVideo>
-    void onRewardedVideoLoadFailure(@NonNull Class<T> customEventClass, String thirdPartyId, MoPubErrorCode errorCode) {
-        if (sInstance != null) {
-            final Set<String> moPubIds = sInstance.mRewardedVideoData.getMoPubIdsForAdNetwork(customEventClass, thirdPartyId);
-            for (final String moPubId : moPubIds) {
-                sInstance.cancelTimeouts(moPubId);
-                sInstance.failover(moPubId, errorCode);
+    void onRewardedVideoLoadFailure(@NonNull final Class<T> customEventClass, final String thirdPartyId, final MoPubErrorCode errorCode) {
+        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
+            @Override
+            protected void forEach(@NonNull final String moPubId) {
+                   sInstance.cancelTimeouts(moPubId);
+                   sInstance.failover(moPubId, errorCode);
             }
-        }
+        });
     }
 
     public static <T extends CustomEventRewardedVideo>
-    void onRewardedVideoStarted(@NonNull Class<T> customEventClass, String thirdPartyId) {
-        if (sInstance != null) {
-            final Set<String> moPubIds = sInstance.mRewardedVideoData.getMoPubIdsForAdNetwork(customEventClass, thirdPartyId);
-            for (final String moPubId : moPubIds) {
-                sInstance.mVideoListener.onRewardedVideoStarted(moPubId);
+    void onRewardedVideoStarted(@NonNull final Class<T> customEventClass, final String thirdPartyId) {
+        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
+            @Override
+            protected void forEach(@NonNull final String moPubId) {
+                if (sInstance.mVideoListener != null) {
+                    sInstance.mVideoListener.onRewardedVideoStarted(moPubId);
+                }
                 TrackingRequest.makeTrackingHttpRequest(
                         sInstance.mAdRequestStatus.getImpressionTrackerUrlString(moPubId),
                         sInstance.mContext);
                 sInstance.mAdRequestStatus.clearImpressionUrl(moPubId);
             }
-        }
+        });
     }
 
     public static <T extends CustomEventRewardedVideo>
-    void onRewardedVideoPlaybackError(@NonNull Class<T> customEventClass, String thirdPartyId, MoPubErrorCode errorCode) {
-        if (sInstance != null) {
-            final Iterable<String> moPubIds = sInstance.mRewardedVideoData.getMoPubIdsForAdNetwork(customEventClass, thirdPartyId);
-            for (final String moPubId : moPubIds) {
-                sInstance.mVideoListener.onRewardedVideoPlaybackError(moPubId, errorCode);
+    void onRewardedVideoPlaybackError(@NonNull final Class<T> customEventClass, final String thirdPartyId, final MoPubErrorCode errorCode) {
+        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
+            @Override
+            protected void forEach(@NonNull final String moPubId) {
+                if (sInstance.mVideoListener != null) {
+                    sInstance.mVideoListener.onRewardedVideoPlaybackError(moPubId, errorCode);
+                }
             }
-        }
+        });
+
     }
 
     public static <T extends CustomEventRewardedVideo>
-    void onRewardedVideoClicked(@NonNull Class<T> customEventClass, String thirdPartyId) {
-        if (sInstance != null) {
-            final Set<String> moPubIds = sInstance.mRewardedVideoData.getMoPubIdsForAdNetwork(customEventClass, thirdPartyId);
-            for (final String moPubId : moPubIds) {
+    void onRewardedVideoClicked(@NonNull final Class<T> customEventClass, final String thirdPartyId) {
+        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
+            @Override
+            protected void forEach(@NonNull final String moPubId) {
                 TrackingRequest.makeTrackingHttpRequest(
                         sInstance.mAdRequestStatus.getClickTrackerUrlString(moPubId),
                         sInstance.mContext);
                 sInstance.mAdRequestStatus.clearClickUrl(moPubId);
             }
-        }
+        });
     }
 
     public static <T extends CustomEventRewardedVideo>
-    void onRewardedVideoClosed(@NonNull Class<T> customEventClass, String thirdPartyId) {
-        if (sInstance != null) {
-            final Set<String> moPubIds = sInstance.mRewardedVideoData.getMoPubIdsForAdNetwork(customEventClass, thirdPartyId);
-            for (final String moPubId : moPubIds) {
-                sInstance.mVideoListener.onRewardedVideoClosed(moPubId);
+    void onRewardedVideoClosed(@NonNull final Class<T> customEventClass, final String thirdPartyId) {
+        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
+            @Override
+            protected void forEach(@NonNull final String moPubId) {
+                if (sInstance.mVideoListener != null) {
+                    sInstance.mVideoListener.onRewardedVideoClosed(moPubId);
+                }
             }
-        }
+        });
     }
 
     public static <T extends CustomEventRewardedVideo>
-    void onRewardedVideoCompleted(@NonNull Class<T> customEventClass, String thirdPartyId, @NonNull MoPubReward moPubReward) {
+    void onRewardedVideoCompleted(@NonNull final Class<T> customEventClass, final String thirdPartyId, @NonNull final MoPubReward moPubReward) {
+        // Unlike other callbacks in this class, only call the listener once with all the MoPubIds in the matching set.
+        postToInstance(new Runnable() {
+            @Override
+            public void run() {
+                final Set<String> moPubIds = sInstance.mRewardedVideoData.getMoPubIdsForAdNetwork(customEventClass, thirdPartyId);
+                Set<String> rewarded = new HashSet<String>(moPubIds);
+                if (sInstance.mVideoListener != null) {
+                    sInstance.mVideoListener.onRewardedVideoCompleted(rewarded, moPubReward);
+                }
+            }
+        });
+    }
+
+    /**
+     * Posts the runnable to the static instance's handler. Does nothing if sInstance is null.
+     * Useful for ensuring that all event callbacks run on the main thread.
+     * The {@link Runnable} can assume that sInstance is non-null.
+     */
+    private static void postToInstance(@NonNull Runnable runnable) {
         if (sInstance != null) {
-            final Set<String> moPubIds = sInstance.mRewardedVideoData.getMoPubIdsForAdNetwork(customEventClass, thirdPartyId);
-            Set<String> rewarded = new HashSet<String>(moPubIds);
-            sInstance.mVideoListener.onRewardedVideoCompleted(rewarded, moPubReward);
+            sInstance.mCallbackHandler.post(runnable);
         }
     }
 
@@ -446,4 +492,32 @@ private static void logErrorNotInitialized() {
                 "MoPub.initializeRewardedVideo() before loading or attempting " +
                 "to play video ads.");
     }
+
+    /**
+     * A runnable that calls forEach on each member of the rewarded video data passed to the runnable.
+     */
+    private static abstract class ForEachMoPubIdRunnable implements Runnable {
+
+        @NonNull private final Class<? extends CustomEventRewardedVideo> mCustomEventClass;
+        @NonNull private final String mThirdPartyId;
+
+        ForEachMoPubIdRunnable(@NonNull final Class<? extends CustomEventRewardedVideo> customEventClass,
+                @NonNull final String thirdPartyId) {
+            Preconditions.checkNotNull(customEventClass);
+            Preconditions.checkNotNull(thirdPartyId);
+            mCustomEventClass = customEventClass;
+            mThirdPartyId = thirdPartyId;
+        }
+
+        protected abstract void forEach(@NonNull final String moPubId);
+
+        @Override
+        public void run() {
+            final Set<String> moPubIds = sInstance.mRewardedVideoData
+                    .getMoPubIdsForAdNetwork(mCustomEventClass, mThirdPartyId);
+            for (String moPubId : moPubIds) {
+                forEach(moPubId);
+            }
+        }
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/RepeatingHandlerRunnable.java b/mopub-sdk/src/main/java/com/mopub/mobileads/RepeatingHandlerRunnable.java
new file mode 100644
index 00000000..2c26fa69
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/RepeatingHandlerRunnable.java
@@ -0,0 +1,57 @@
+package com.mopub.mobileads;
+
+import android.os.Handler;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+
+/**
+ * A generic runnable that handles scheduling itself periodically on a Handler and stops when
+ * requested.
+ */
+public abstract class RepeatingHandlerRunnable implements Runnable {
+    @NonNull protected final Handler mHandler;
+    private volatile boolean mIsRunning;
+    private volatile long mUpdateIntervalMillis;
+
+    RepeatingHandlerRunnable(@NonNull final Handler handler) {
+        Preconditions.checkNotNull(handler);
+        mHandler = handler;
+    }
+
+    @Override
+    public void run() {
+        if (mIsRunning) {
+            doWork();
+            mHandler.postDelayed(this, mUpdateIntervalMillis);
+        }
+    }
+
+    public abstract void doWork();
+
+    /**
+     * Start this runnable immediately, repeating at the provided interval.
+     */
+    public void startRepeating(long intervalMillis) {
+        Preconditions.checkArgument(intervalMillis > 0, "intervalMillis must be greater than 0. " +
+                "Saw: %d", intervalMillis);
+        mUpdateIntervalMillis = intervalMillis;
+        if (!mIsRunning) {
+            mIsRunning = true;
+            mHandler.post(this);
+        }
+    }
+
+    /**
+     * Stop this repeating runnable.
+     */
+    public void stop() {
+        mIsRunning = false;
+    }
+
+    @VisibleForTesting
+    boolean shouldBeRunning() {
+        return mIsRunning;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/TaskTracker.java b/mopub-sdk/src/main/java/com/mopub/mobileads/TaskTracker.java
deleted file mode 100644
index ffe0a65b..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/TaskTracker.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package com.mopub.mobileads;
-
-public class TaskTracker {
-    private long mCurrentTaskId = -1l;
-    private long mLastCompletedTaskId;
-
-    public long getCurrentTaskId() {
-        return mCurrentTaskId;
-    }
-
-    public void newTaskStarted() {
-        mCurrentTaskId++;
-    }
-
-    public void markTaskCompleted(long taskId) {
-        if (taskId > mLastCompletedTaskId) {
-            mLastCompletedTaskId = taskId;
-        }
-    }
-
-    public boolean isMostCurrentTask(long taskId) {
-        return taskId >= mLastCompletedTaskId;
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/ToolbarWidget.java b/mopub-sdk/src/main/java/com/mopub/mobileads/ToolbarWidget.java
index 382b0e03..df1fd823 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/ToolbarWidget.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/ToolbarWidget.java
@@ -1,6 +1,7 @@
 package com.mopub.mobileads;
 
 import android.content.Context;
+import android.graphics.Bitmap;
 import android.graphics.Color;
 import android.graphics.drawable.Drawable;
 import android.text.TextUtils;
@@ -11,10 +12,13 @@
 import android.widget.RelativeLayout;
 import android.widget.TextView;
 
-import com.mopub.common.util.Dips;
 import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Dips;
 import com.mopub.common.util.Utils;
 import com.mopub.mobileads.resource.TextDrawable;
+import com.mopub.network.Networking;
+import com.mopub.volley.VolleyError;
+import com.mopub.volley.toolbox.ImageLoader;
 
 import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;
 
@@ -105,6 +109,7 @@ ToolbarWidget build() {
 
     private TextView mTextView;
     private ImageView mImageView;
+    private final ImageLoader mImageLoader;
 
     private static final int TEXT_PADDING_DIPS = 5;
     private static final int IMAGE_PADDING_DIPS = 5;
@@ -125,6 +130,8 @@ private ToolbarWidget(Builder builder) {
         mImagePadding = Dips.dipsToIntPixels(IMAGE_PADDING_DIPS, getContext());
         mImageSideLength = Dips.dipsToIntPixels(IMAGE_SIDE_LENGTH_DIPS, getContext());
 
+        mImageLoader = Networking.getImageLoader(getContext());
+
         setVisibility(builder.visibility);
 
         if (builder.hasDrawable) {
@@ -188,13 +195,48 @@ void updateImageText(final String text) {
         }
     }
 
+    void updateImage(final String imageUrl) {
+        mImageLoader.get(imageUrl, new ImageLoader.ImageListener() {
+            @Override
+            public void onResponse(final ImageLoader.ImageContainer imageContainer,
+                    final boolean isImmediate) {
+                Bitmap bitmap = imageContainer.getBitmap();
+                if (bitmap != null) {
+                    mImageView.setImageBitmap(bitmap);
+                } else {
+                    MoPubLog.d(String.format("%s returned null bitmap", imageUrl));
+                }
+            }
+
+            @Override
+            public void onErrorResponse(final VolleyError volleyError) {
+                MoPubLog.d("Failed to load image.", volleyError);
+            }
+        });
+    }
+
+    @Deprecated // for testing
+    ImageView getImageView() {
+        return mImageView;
+    }
+
+    @Deprecated // for testing
+    void setImageView(ImageView imageView) {
+        mImageView = imageView;
+    }
+
+    @Deprecated // for testing
+    Drawable getImageViewDrawable() {
+        return mImageView.getDrawable();
+    }
+
     @Deprecated // for testing
-    TextDrawable getImageViewDrawable() {
-        return (TextDrawable) mImageView.getDrawable();
+    void setImageViewDrawable(Drawable drawable) {
+        mImageView.setImageDrawable(drawable);
     }
 
     @Deprecated // for testing
-    void setImageViewDrawable(TextDrawable drawable) {
-        mImageView.setImageDrawable((Drawable) drawable);
+    String getTextViewText() {
+        return mTextView.getText().toString();
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastAbsoluteProgressTracker.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastAbsoluteProgressTracker.java
new file mode 100644
index 00000000..63fd8513
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastAbsoluteProgressTracker.java
@@ -0,0 +1,40 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+
+import java.io.Serializable;
+import java.util.Locale;
+
+/**
+ * A Vast tracking URL with an "absolute" trigger threshold. The tracker should be triggered
+ * after a fixed number of milliseconds have been played.
+ */
+public class VastAbsoluteProgressTracker extends VastTracker implements Comparable<VastAbsoluteProgressTracker>, Serializable {
+    private static final long serialVersionUID = 0L;
+    private final int mTrackingMilliseconds;
+
+    public VastAbsoluteProgressTracker(@NonNull final String trackingUrl, int trackingMilliseconds) {
+        super(trackingUrl);
+        Preconditions.checkArgument(trackingMilliseconds >= 0);
+        mTrackingMilliseconds = trackingMilliseconds;
+    }
+
+    public int getTrackingMilliseconds() {
+        return mTrackingMilliseconds;
+    }
+
+    @Override
+    public int compareTo(@NonNull final VastAbsoluteProgressTracker other) {
+        int you = other.getTrackingMilliseconds();
+        int me = getTrackingMilliseconds();
+
+        return me - you;
+    }
+
+    @Override
+    public String toString() {
+        return String.format(Locale.US, "%dms: %s", mTrackingMilliseconds, mTrackingUrl);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastFractionalProgressTracker.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastFractionalProgressTracker.java
new file mode 100644
index 00000000..824f9516
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastFractionalProgressTracker.java
@@ -0,0 +1,40 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+
+import java.io.Serializable;
+import java.util.Locale;
+
+/**
+ * A Vast tracking URL with a "fractional" tracking threshold on the interval [0.0, 1.0].
+ * The tracker should be triggered after the given fraction of the video has been played.
+ */
+public class VastFractionalProgressTracker extends VastTracker implements Comparable<VastFractionalProgressTracker>, Serializable {
+    private static final long serialVersionUID = 0L;
+    private final float mFraction;
+
+    public VastFractionalProgressTracker(@NonNull final String trackingUrl, float trackingFraction) {
+        super(trackingUrl);
+        Preconditions.checkArgument(trackingFraction >= 0);
+        mFraction = trackingFraction;
+    }
+
+    public float trackingFraction() {
+        return mFraction;
+    }
+
+    @Override
+    public int compareTo(@NonNull final VastFractionalProgressTracker other) {
+        float you = other.trackingFraction();
+        float me = trackingFraction();
+
+        return Double.compare(me, you);
+    }
+
+    @Override
+    public String toString() {
+        return String.format(Locale.US, "%2f: %s", mFraction, mTrackingUrl);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastTracker.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastTracker.java
new file mode 100644
index 00000000..36f07711
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastTracker.java
@@ -0,0 +1,35 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+
+import java.io.Serializable;
+
+/**
+ * State encapsulation for VAST tracking URLs that should only be called once. For example, progress
+ * trackers are only called once.
+ */
+public class VastTracker implements Serializable {
+    private static final long serialVersionUID = 0L;
+    @NonNull protected final String mTrackingUrl;
+    private boolean mCalled;
+
+    public VastTracker(@NonNull String trackingUrl) {
+        Preconditions.checkNotNull(trackingUrl);
+        mTrackingUrl = trackingUrl;
+    }
+
+    @NonNull
+    public String getTrackingUrl() {
+        return mTrackingUrl;
+    }
+
+    public void setTracked() {
+        mCalled = true;
+    }
+
+    public boolean isTracked() {
+        return mCalled;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoToolbar.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoToolbar.java
index 2d4431bf..cb89e081 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoToolbar.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoToolbar.java
@@ -6,6 +6,7 @@
 import android.widget.LinearLayout;
 import android.widget.RelativeLayout;
 
+import com.mopub.common.VisibleForTesting;
 import com.mopub.common.util.Dips;
 import com.mopub.common.util.Utils;
 import com.mopub.mobileads.resource.CloseButtonDrawable;
@@ -16,7 +17,7 @@
 import static android.view.Gravity.CENTER_VERTICAL;
 import static android.view.Gravity.LEFT;
 import static android.view.Gravity.RIGHT;
-import static android.view.ViewGroup.LayoutParams.FILL_PARENT;
+import static android.view.ViewGroup.LayoutParams.MATCH_PARENT;
 
 class VastVideoToolbar extends LinearLayout {
     private static final int TOOLBAR_HEIGHT_DIPS = 44;
@@ -42,7 +43,7 @@ public boolean onTouch(View view, MotionEvent motionEvent) {
 
         final int videoToolbarHeight = Dips.dipsToIntPixels(TOOLBAR_HEIGHT_DIPS, getContext());
         final LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(
-                FILL_PARENT,
+                MATCH_PARENT,
                 videoToolbarHeight);
         setLayoutParams(layoutParams);
 
@@ -60,25 +61,59 @@ public boolean onTouch(View view, MotionEvent motionEvent) {
         addView(mCloseButtonWidget);
     }
 
-    String getDisplaySeconds(final long millisecondsRemaining) {
-        return String.valueOf(Math.round(Math.ceil(millisecondsRemaining / 1000f)));
+    /**
+     * Rounds up to the nearest full second. Formally, this is the long
+     * closest to negative infinity above or equal to millis, in milliseconds,
+     * converted to seconds.
+     *
+     * @param millis Time in milliseconds
+     * @return Time in seconds, rounded up.
+     */
+    @VisibleForTesting
+    long convertMillisecondsToSecondsRoundedUp(final long millis) {
+        return Math.round(Math.ceil(millis / 1000f));
     }
 
+    @VisibleForTesting
     void updateDurationWidget(final int remainingTime) {
         if (remainingTime >= THRESHOLD_FOR_HIDING_VIDEO_DURATION) {
-            mDurationWidget.updateText("Ends in " + getDisplaySeconds(remainingTime) + " seconds");
+            mDurationWidget.updateText("Ends in " + formatTime(remainingTime));
         } else if (remainingTime >= 0) {
             mDurationWidget.updateText("Thanks for watching");
         }
     }
 
+    @VisibleForTesting
+    String formatTime(final long milliseconds) {
+        final long seconds = convertMillisecondsToSecondsRoundedUp(milliseconds);
+
+        if (seconds == 1) {
+            return "1 second";
+        } else {
+            return String.valueOf(seconds) + " seconds";
+        }
+    }
+
     void updateCountdownWidget(final int remainingTime) {
         if (remainingTime >= 0 && mCountdownWidget.getVisibility() == View.INVISIBLE) {
             mCloseButtonWidget.setVisibility(View.GONE);
             mCountdownWidget.setVisibility(View.VISIBLE);
         }
 
-        mCountdownWidget.updateImageText(getDisplaySeconds(remainingTime));
+        mCountdownWidget.updateImageText(String.valueOf(convertMillisecondsToSecondsRoundedUp(
+                remainingTime)));
+    }
+
+    void updateLearnMoreButtonText(final String customCtaText) {
+        mLearnMoreWidget.updateText(customCtaText);
+    }
+
+    void updateCloseButtonText(final String customSkipText) {
+        mCloseButtonWidget.updateText(customSkipText);
+    }
+
+    void updateCloseButtonIcon(final String customCloseIconUrl) {
+        mCloseButtonWidget.updateImage(customCloseIconUrl);
     }
 
     void makeInteractable() {
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewController.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewController.java
index 730c40c2..0125daa1 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewController.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewController.java
@@ -11,6 +11,9 @@
 import android.media.MediaPlayer;
 import android.os.Bundle;
 import android.os.Handler;
+import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.text.TextUtils;
 import android.view.Gravity;
 import android.view.MotionEvent;
 import android.view.View;
@@ -22,19 +25,21 @@
 import com.mopub.common.DownloadTask;
 import com.mopub.common.HttpResponses;
 import com.mopub.common.MoPubBrowser;
+import com.mopub.common.Preconditions;
+import com.mopub.common.UrlAction;
+import com.mopub.common.UrlHandler;
 import com.mopub.common.VisibleForTesting;
-import com.mopub.common.event.MoPubEvents;
+import com.mopub.common.event.BaseEvent;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.util.AsyncTasks;
 import com.mopub.common.util.Dips;
 import com.mopub.common.util.Drawables;
-import com.mopub.common.util.Intents;
 import com.mopub.common.util.Streams;
+import com.mopub.common.util.Strings;
 import com.mopub.common.util.VersionCode;
-import com.mopub.exceptions.IntentNotResolvableException;
-import com.mopub.exceptions.UrlParseException;
 import com.mopub.mobileads.util.vast.VastCompanionAd;
 import com.mopub.mobileads.util.vast.VastVideoConfiguration;
+import com.mopub.network.TrackingRequest;
 
 import org.apache.http.HttpStatus;
 import org.apache.http.client.methods.HttpGet;
@@ -42,9 +47,12 @@
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 import static android.content.pm.ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
+import static android.content.pm.ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
 import static com.mopub.common.HttpClient.initializeHttpGet;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_CLICK;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
@@ -54,17 +62,14 @@
 public class VastVideoViewController extends BaseVideoViewController implements DownloadTask.DownloadTaskListener {
     static final String VAST_VIDEO_CONFIGURATION = "vast_video_configuration";
 
-    private static final float FIRST_QUARTER_MARKER = 0.25f;
-    private static final float MID_POINT_MARKER = 0.50f;
-    private static final float THIRD_QUARTER_MARKER = 0.75f;
     private static final long VIDEO_PROGRESS_TIMER_CHECKER_DELAY = 50;
+    private static final long VIDEO_COUNTDOWN_UPDATE_INTERVAL = 250;
     private static final int MOPUB_BROWSER_REQUEST_CODE = 1;
     private static final int MAX_VIDEO_RETRIES = 1;
     private static final int VIDEO_VIEW_FILE_PERMISSION_ERROR = Integer.MIN_VALUE;
 
     static final int DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON = 5 * 1000;
     static final int MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON = 16 * 1000;
-    static final int START_MARK_THRESHOLD = 2000;
 
     private final VastVideoConfiguration mVastVideoConfiguration;
     private final VastCompanionAd mVastCompanionAd;
@@ -73,21 +78,11 @@
     private final ImageView mCompanionAdImageView;
     private final View.OnTouchListener mClickThroughListener;
 
-    private final Handler mHandler;
-    private final Runnable mVideoProgressCheckerRunnable;
-    private boolean mIsVideoProgressShouldBeChecked;
+    private final VastVideoViewProgressRunnable mProgressCheckerRunnable;
+    private final VastVideoViewCountdownRunnable mCountdownRunnable;
     private int mShowCloseButtonDelay = DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON;
 
     private boolean mShowCloseButtonEventFired;
-    private boolean mIsStartMarkHit;
-    private boolean mIsFirstMarkHit;
-    private boolean mIsSecondMarkHit;
-    private boolean mIsThirdMarkHit;
-    // This flag indicates that the final video checkpoint has been reached, therefore allowing
-    // us to fire the video completion tracker in MediaPlayer#onCompletion.
-    // This is a safeguard against inconsistent MediaPlayer#onCompletion callbacks due to differing
-    // implementations across Android versions and devices.
-    private boolean mIsFinalMarkHit;
 
     private int mSeekerPositionOnPause;
     private boolean mIsVideoFinishedPlaying;
@@ -96,14 +91,14 @@
     private boolean mVideoError;
     private boolean mCompletionTrackerFired;
 
+    private boolean mHasSkipOffset = false;
+
     VastVideoViewController(final Context context,
             final Bundle bundle,
             final long broadcastIdentifier,
             final BaseVideoViewControllerListener baseVideoViewControllerListener)
             throws IllegalStateException {
         super(context, broadcastIdentifier, baseVideoViewControllerListener);
-        mHandler = new Handler();
-        mIsVideoProgressShouldBeChecked = false;
         mSeekerPositionOnPause = -1;
         mVideoRetries = 0;
 
@@ -142,7 +137,10 @@ public boolean onTouch(View view, MotionEvent motionEvent) {
         getLayout().addView(mVastVideoToolbar);
 
         mCompanionAdImageView = createCompanionAdImageView(context);
-        mVideoProgressCheckerRunnable = createVideoProgressCheckerRunnable();
+
+        Handler mainHandler = new Handler(Looper.getMainLooper());
+        mProgressCheckerRunnable = new VastVideoViewProgressRunnable(this, mainHandler);
+        mCountdownRunnable = new VastVideoViewCountdownRunnable(this, mainHandler);
     }
 
     @Override
@@ -153,13 +151,28 @@ protected VideoView getVideoView() {
     @Override
     protected void onCreate() {
         super.onCreate();
-        getBaseVideoViewControllerListener().onSetRequestedOrientation(SCREEN_ORIENTATION_LANDSCAPE);
+
+        switch (mVastVideoConfiguration.getCustomForceOrientation()) {
+            case FORCE_PORTRAIT:
+                getBaseVideoViewControllerListener().onSetRequestedOrientation(SCREEN_ORIENTATION_PORTRAIT);
+                break;
+            case FORCE_LANDSCAPE:
+                getBaseVideoViewControllerListener().onSetRequestedOrientation(SCREEN_ORIENTATION_LANDSCAPE);
+                break;
+            case DEVICE_ORIENTATION:
+                break;  // don't do anything
+            case UNDEFINED:
+                break;  // don't do anything
+            default:
+                break;
+        }
+
         downloadCompanionAd();
 
         makeTrackingHttpRequest(
                 mVastVideoConfiguration.getImpressionTrackers(),
                 getContext(),
-                MoPubEvents.Type.IMPRESSION_REQUEST
+                BaseEvent.Name.IMPRESSION_REQUEST
         );
         broadcastAction(ACTION_INTERSTITIAL_SHOW);
     }
@@ -169,7 +182,7 @@ protected void onResume() {
         // When resuming, VideoView needs to reinitialize its MediaPlayer with the video path
         // and therefore reset the count to zero, to let it retry on error
         mVideoRetries = 0;
-        startProgressChecker();
+        startRunnables();
 
         mVideoView.seekTo(mSeekerPositionOnPause);
         if (!mIsVideoFinishedPlaying) {
@@ -179,14 +192,14 @@ protected void onResume() {
 
     @Override
     protected void onPause() {
-        stopProgressChecker();
-        mSeekerPositionOnPause = mVideoView.getCurrentPosition();
+        stopRunnables();
+        mSeekerPositionOnPause = getCurrentPosition();
         mVideoView.pause();
     }
 
     @Override
     protected void onDestroy() {
-        stopProgressChecker();
+        stopRunnables();
         broadcastAction(ACTION_INTERSTITIAL_DISMISS);
     }
 
@@ -246,61 +259,92 @@ private void downloadCompanionAd() {
         }
     }
 
-    private Runnable createVideoProgressCheckerRunnable() {
-        // This Runnable must only be run from the main thread due to accessing
-        // class instance variables
-        return new Runnable() {
-            @Override
-            public void run() {
-                float videoLength = mVideoView.getDuration();
-                float currentPosition = mVideoView.getCurrentPosition();
-
-                if (videoLength > 0) {
-                    float progressPercentage = currentPosition / videoLength;
-
-                    if (!mIsStartMarkHit && currentPosition >= START_MARK_THRESHOLD) {
-                        mIsStartMarkHit = true;
-                        makeTrackingHttpRequest(mVastVideoConfiguration.getStartTrackers(), getContext());
-                    }
-
-                    if (!mIsFirstMarkHit && progressPercentage > FIRST_QUARTER_MARKER) {
-                        mIsFirstMarkHit = true;
-                        makeTrackingHttpRequest(mVastVideoConfiguration.getFirstQuartileTrackers(), getContext());
-                    }
-
-                    if (!mIsSecondMarkHit && progressPercentage > MID_POINT_MARKER) {
-                        mIsSecondMarkHit = true;
-                        makeTrackingHttpRequest(mVastVideoConfiguration.getMidpointTrackers(), getContext());
-                    }
+    private void adjustSkipOffset() {
+        int videoDuration = getDuration();
 
-                    if (!mIsThirdMarkHit && progressPercentage > THIRD_QUARTER_MARKER) {
-                        mIsThirdMarkHit = true;
-                        mIsFinalMarkHit = true;
-                        makeTrackingHttpRequest(mVastVideoConfiguration.getThirdQuartileTrackers(), getContext());
-                    }
+        // Default behavior: video is non-skippable if duration < 16 seconds
+        if (videoDuration < MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON) {
+            mShowCloseButtonDelay = videoDuration;
+        }
 
-                    if (isLongVideo(mVideoView.getDuration()) ) {
-                        mVastVideoToolbar.updateCountdownWidget(mShowCloseButtonDelay - mVideoView.getCurrentPosition());
+        // Override if skipoffset attribute is specified in VAST
+        String skipOffsetString = mVastVideoConfiguration.getSkipOffset();
+        if (skipOffsetString != null) {
+            try {
+                if (Strings.isAbsoluteTracker(skipOffsetString)) {
+                    Integer skipOffsetMilliseconds = Strings.parseAbsoluteOffset(skipOffsetString);
+                    if (skipOffsetMilliseconds != null && skipOffsetMilliseconds < videoDuration) {
+                        mShowCloseButtonDelay = skipOffsetMilliseconds;
+                        mHasSkipOffset = true;
                     }
-
-                    if (shouldBeInteractable()) {
-                        makeVideoInteractable();
+                } else if (Strings.isPercentageTracker(skipOffsetString)) {
+                    float percentage = Float.parseFloat(skipOffsetString.replace("%", "")) / 100f;
+                    int skipOffsetMillisecondsRounded = Math.round(videoDuration * percentage);
+                    if (skipOffsetMillisecondsRounded < videoDuration) {
+                        mShowCloseButtonDelay = skipOffsetMillisecondsRounded;
+                        mHasSkipOffset = true;
                     }
+                } else {
+                    MoPubLog.d(String.format("Invalid VAST skipoffset format: %s", skipOffsetString));
                 }
+            } catch (NumberFormatException e) {
+                MoPubLog.d(String.format("Failed to parse skipoffset %s", skipOffsetString));
+            }
+        }
+    }
 
-                mVastVideoToolbar.updateDurationWidget(mVideoView.getDuration() - mVideoView.getCurrentPosition());
+    /**
+     * Returns untriggered VAST progress trackers with a progress before the provided position.
+     *
+     * @param currentPositionMillis the current video position in milliseconds.
+     * @param videoLengthMillis the total video length.
+     */
+    @NonNull
+    List<VastTracker> getUntriggeredTrackersBefore(int currentPositionMillis, int videoLengthMillis) {
+        if (Preconditions.NoThrow.checkArgument(videoLengthMillis > 0)) {
+            float progressFraction = currentPositionMillis / (float) (videoLengthMillis);
+            List<VastTracker> untriggeredTrackers = new ArrayList<VastTracker>();
+
+            final ArrayList<VastAbsoluteProgressTracker> absoluteTrackers = mVastVideoConfiguration.getAbsoluteTrackers();
+            VastAbsoluteProgressTracker absoluteTest = new VastAbsoluteProgressTracker("", currentPositionMillis);
+            int absoluteTrackerCount = absoluteTrackers.size();
+            for (int i = 0; i < absoluteTrackerCount; i++) {
+                VastAbsoluteProgressTracker tracker = absoluteTrackers.get(i);
+                if (tracker.compareTo(absoluteTest) > 0) {
+                    break;
+                }
+                if (!tracker.isTracked()) {
+                    untriggeredTrackers.add(tracker);
+                }
+            }
 
-                if (mIsVideoProgressShouldBeChecked) {
-                    mHandler.postDelayed(mVideoProgressCheckerRunnable, VIDEO_PROGRESS_TIMER_CHECKER_DELAY);
+            final ArrayList<VastFractionalProgressTracker> fractionalTrackers = mVastVideoConfiguration.getFractionalTrackers();
+            final VastFractionalProgressTracker fractionalTest = new VastFractionalProgressTracker("", progressFraction);
+            int fractionalTrackerCount = fractionalTrackers.size();
+            for (int i = 0; i < fractionalTrackerCount; i++) {
+                VastFractionalProgressTracker tracker = fractionalTrackers.get(i);
+                if (tracker.compareTo(fractionalTest) > 0) {
+                    break;
+                }
+                if (!tracker.isTracked()) {
+                    untriggeredTrackers.add(tracker);
                 }
             }
-        };
+
+            return untriggeredTrackers;
+        } else {
+            return Collections.emptyList();
+        }
+    }
+
+    private int remainingProgressTrackerCount() {
+        return getUntriggeredTrackersBefore(Integer.MAX_VALUE, Integer.MAX_VALUE).size();
     }
 
     private void createVideoBackground(final Context context) {
         GradientDrawable gradientDrawable = new GradientDrawable(
                 GradientDrawable.Orientation.TOP_BOTTOM,
-                new int[] {Color.argb(0,0,0,0), Color.argb(255,0,0,0)}
+                new int[]{Color.argb(0, 0, 0, 0), Color.argb(255, 0, 0, 0)}
         );
         Drawable[] layers = new Drawable[2];
         layers[0] = Drawables.THATCHED_BACKGROUND.createDrawable(context);
@@ -315,12 +359,35 @@ private VastVideoToolbar createVastVideoToolBar(final Context context) {
             @Override
             public boolean onTouch(View view, MotionEvent motionEvent) {
                 if (motionEvent.getAction() == MotionEvent.ACTION_UP) {
+                    TrackingRequest.makeTrackingHttpRequest(
+                            mVastVideoConfiguration.getCloseTrackers(), context);
+                    TrackingRequest.makeTrackingHttpRequest(
+                            mVastVideoConfiguration.getSkipTrackers(), context);
                     getBaseVideoViewControllerListener().onFinish();
                 }
                 return true;
             }
         });
         vastVideoToolbar.setLearnMoreButtonOnTouchListener(mClickThroughListener);
+
+        // update custom CTA text if specified in VAST extension
+        String customCtaText = mVastVideoConfiguration.getCustomCtaText();
+        if (customCtaText != null) {
+            vastVideoToolbar.updateLearnMoreButtonText(customCtaText);
+        }
+
+        // update custom skip text if specified in VAST extensions
+        String customSkipText = mVastVideoConfiguration.getCustomSkipText();
+        if (customSkipText != null) {
+            vastVideoToolbar.updateCloseButtonText(customSkipText);
+        }
+
+        // update custom close icon if specified in VAST extensions
+        String customCloseIconUrl = mVastVideoConfiguration.getCustomCloseIconUrl();
+        if (customCloseIconUrl != null) {
+            vastVideoToolbar.updateCloseButtonIcon(customCloseIconUrl);
+        }
+
         return vastVideoToolbar;
     }
 
@@ -330,9 +397,7 @@ private VideoView createVideoView(final Context context) {
             @Override
             public void onPrepared(MediaPlayer mp) {
                 // Called when media source is ready for playback
-                if (mVideoView.getDuration() < MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON) {
-                    mShowCloseButtonDelay = mVideoView.getDuration();
-                }
+                adjustSkipOffset();
             }
         });
         videoView.setOnTouchListener(mClickThroughListener);
@@ -340,13 +405,15 @@ public void onPrepared(MediaPlayer mp) {
         videoView.setOnCompletionListener(new MediaPlayer.OnCompletionListener() {
             @Override
             public void onCompletion(MediaPlayer mp) {
-                stopProgressChecker();
+                stopRunnables();
                 makeVideoInteractable();
 
                 videoCompleted(false);
                 mIsVideoFinishedPlaying = true;
 
-                if (!mVideoError && mIsFinalMarkHit && !mCompletionTrackerFired) {
+                // Only fire the completion tracker if we hit all the progress marks. Some Android implementations
+                // fire the completion event even if the whole video isn't watched.
+                if (!mVideoError && remainingProgressTrackerCount() == 0 && !mCompletionTrackerFired) {
                     makeTrackingHttpRequest(mVastVideoConfiguration.getCompleteTrackers(), context);
                     mCompletionTrackerFired = true;
                 }
@@ -365,7 +432,7 @@ public boolean onError(final MediaPlayer mediaPlayer, final int what, final int
                 if (retryMediaPlayer(mediaPlayer, what, extra)) {
                     return true;
                 } else {
-                    stopProgressChecker();
+                    stopRunnables();
                     makeVideoInteractable();
                     videoError(false);
                     mVideoError = true;
@@ -422,34 +489,40 @@ boolean retryMediaPlayer(final MediaPlayer mediaPlayer, final int what, final in
      */
     @VisibleForTesting
     void handleClick(final List<String> clickThroughTrackers, final String clickThroughUrl) {
-        makeTrackingHttpRequest(clickThroughTrackers, getContext(), MoPubEvents.Type.CLICK_REQUEST);
+        makeTrackingHttpRequest(clickThroughTrackers, getContext(), BaseEvent.Name.CLICK_REQUEST);
 
-        if (clickThroughUrl == null) {
+        if (TextUtils.isEmpty(clickThroughUrl)) {
             return;
         }
 
         broadcastAction(ACTION_INTERSTITIAL_CLICK);
 
-        if (Intents.isNativeBrowserScheme(clickThroughUrl)) {
-            try {
-                final Intent intent = Intents.intentForNativeBrowserScheme(clickThroughUrl);
-                Intents.startActivity(getContext(), intent);
-                return;
-            } catch (UrlParseException e) {
-                MoPubLog.d(e.getMessage());
-            } catch (IntentNotResolvableException e) {
-                MoPubLog.d("Could not handle intent for URI: " + clickThroughUrl + ". "
-                        + e.getMessage());
-            }
-
-            return;
-        }
-
-        Bundle bundle = new Bundle();
-        bundle.putString(MoPubBrowser.DESTINATION_URL_KEY, clickThroughUrl);
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(
+                        UrlAction.IGNORE_ABOUT_SCHEME,
+                        UrlAction.OPEN_NATIVE_BROWSER,
+                        UrlAction.OPEN_IN_APP_BROWSER,
+                        UrlAction.HANDLE_SHARE_TWEET)
+                .withResultActions(new UrlHandler.ResultActions() {
+                    @Override
+                    public void urlHandlingSucceeded(@NonNull String url,
+                            @NonNull UrlAction urlAction) {
+                        if (urlAction == UrlAction.OPEN_IN_APP_BROWSER) {
+                            Bundle bundle = new Bundle();
+                            bundle.putString(MoPubBrowser.DESTINATION_URL_KEY, clickThroughUrl);
+
+                            getBaseVideoViewControllerListener().onStartActivityForResult(
+                                    MoPubBrowser.class, MOPUB_BROWSER_REQUEST_CODE, bundle);
+                        }
+                    }
 
-        getBaseVideoViewControllerListener().onStartActivityForResult(MoPubBrowser.class,
-                MOPUB_BROWSER_REQUEST_CODE, bundle);
+                    @Override
+                    public void urlHandlingFailed(@NonNull String url,
+                            @NonNull UrlAction lastFailedUrlAction) {
+                    }
+                })
+                .withoutMoPubBrowser()
+                .build().handleUrl(getContext(), clickThroughUrl);
     }
 
     private ImageView createCompanionAdImageView(final Context context) {
@@ -475,42 +548,68 @@ private ImageView createCompanionAdImageView(final Context context) {
         return imageView;
     }
 
-    private boolean isLongVideo(final int duration) {
+    int getDuration() {
+        return mVideoView.getDuration();
+    }
+
+    int getCurrentPosition() {
+        return mVideoView.getCurrentPosition();
+    }
+
+    boolean isLongVideo(final int duration) {
         return (duration >= MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON);
     }
 
-    private void makeVideoInteractable() {
+    void makeVideoInteractable() {
         mShowCloseButtonEventFired = true;
         mVastVideoToolbar.makeInteractable();
     }
 
-    private boolean shouldBeInteractable() {
-        return !mShowCloseButtonEventFired && mVideoView.getCurrentPosition() > mShowCloseButtonDelay;
+    boolean shouldBeInteractable() {
+        return !mShowCloseButtonEventFired && getCurrentPosition() >= mShowCloseButtonDelay;
+    }
+
+    boolean shouldShowCountdown() {
+        // show countdown if any of the following conditions is satisfied:
+        // 1) long video
+        // 2) skipoffset is specified in VAST and is less than video duration
+        final int duration = getDuration();
+        return isLongVideo(duration) || (mHasSkipOffset && mShowCloseButtonDelay < duration);
+    }
+
+    void updateCountdown() {
+        mVastVideoToolbar.updateCountdownWidget(mShowCloseButtonDelay - getCurrentPosition());
+    }
+
+    void updateDuration() {
+        mVastVideoToolbar.updateDurationWidget(getDuration() - getCurrentPosition());
     }
 
     private boolean shouldAllowClickThrough() {
         return mShowCloseButtonEventFired;
     }
 
-    private void startProgressChecker() {
-        if (!mIsVideoProgressShouldBeChecked) {
-            mIsVideoProgressShouldBeChecked = true;
-            mHandler.post(mVideoProgressCheckerRunnable);
-        }
+    private void startRunnables() {
+        mProgressCheckerRunnable.startRepeating(VIDEO_PROGRESS_TIMER_CHECKER_DELAY);
+        mCountdownRunnable.startRepeating(VIDEO_COUNTDOWN_UPDATE_INTERVAL);
     }
 
-    private void stopProgressChecker() {
-        if (mIsVideoProgressShouldBeChecked) {
-            mIsVideoProgressShouldBeChecked = false;
-            mHandler.removeCallbacks(mVideoProgressCheckerRunnable);
-        }
+    private void stopRunnables() {
+        mProgressCheckerRunnable.stop();
+        mCountdownRunnable.stop();
     }
 
     // for testing
     @Deprecated
     @VisibleForTesting
-    boolean getIsVideoProgressShouldBeChecked() {
-        return mIsVideoProgressShouldBeChecked;
+    VastVideoViewProgressRunnable getProgressCheckerRunnable() {
+        return mProgressCheckerRunnable;
+    }
+
+    @Deprecated
+    @VisibleForTesting
+    VastVideoViewCountdownRunnable getCountdownRunnable() {
+        return mCountdownRunnable;
     }
 
     // for testing
@@ -520,6 +619,13 @@ int getVideoRetries() {
         return mVideoRetries;
     }
 
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    boolean getHasSkipOffset() {
+        return mHasSkipOffset;
+    }
+
     // for testing
     @Deprecated
     @VisibleForTesting
@@ -555,13 +661,6 @@ ImageView getCompanionAdImageView() {
         return mCompanionAdImageView;
     }
 
-    // for testing
-    @Deprecated
-    @VisibleForTesting
-    void setFinalMarkHit() {
-        mIsFinalMarkHit = true;
-    }
-
     // for testing
     @Deprecated
     @VisibleForTesting
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewCountdownRunnable.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewCountdownRunnable.java
new file mode 100644
index 00000000..14323626
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewCountdownRunnable.java
@@ -0,0 +1,39 @@
+package com.mopub.mobileads;
+
+import android.os.Handler;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+
+/**
+ * This class is used to update a {@link VastVideoViewController}'s countdown display according to rules
+ * contained in the {@link VastVideoViewController}
+ */
+public class VastVideoViewCountdownRunnable extends RepeatingHandlerRunnable {
+
+    @NonNull private final VastVideoViewController mVideoViewController;
+
+    public VastVideoViewCountdownRunnable(@NonNull VastVideoViewController videoViewController,
+            @NonNull Handler handler) {
+        super(handler);
+        Preconditions.checkNotNull(handler);
+        Preconditions.checkNotNull(videoViewController);
+
+
+        mVideoViewController = videoViewController;
+    }
+
+    @Override
+    public void doWork() {
+        // Countdown and interactable are mutually exclusive. Should we refactor to collapse them?
+        if (mVideoViewController.shouldShowCountdown()) {
+            mVideoViewController.updateCountdown();
+        }
+
+        if (mVideoViewController.shouldBeInteractable()) {
+            mVideoViewController.makeVideoInteractable();
+        }
+
+        mVideoViewController.updateDuration();
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewProgressRunnable.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewProgressRunnable.java
new file mode 100644
index 00000000..1936ada0
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewProgressRunnable.java
@@ -0,0 +1,46 @@
+package com.mopub.mobileads;
+
+import android.os.Handler;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+import com.mopub.network.TrackingRequest;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * A runnable that is used to measure video progress and track video progress events for video ads.
+ *
+ */
+public class VastVideoViewProgressRunnable extends RepeatingHandlerRunnable {
+
+    @NonNull private final VastVideoViewController mVideoViewController;
+    public VastVideoViewProgressRunnable(@NonNull VastVideoViewController videoViewController,
+            @NonNull Handler handler) {
+        super(handler);
+
+        Preconditions.checkNotNull(videoViewController);
+        mVideoViewController = videoViewController;
+    }
+
+    @Override
+    public void doWork() {
+        int videoLength = mVideoViewController.getDuration();
+        int currentPosition = mVideoViewController.getCurrentPosition();
+
+        if (videoLength > 0) {
+            final List<VastTracker> trackersToTrack =
+                    mVideoViewController.getUntriggeredTrackersBefore(currentPosition, videoLength);
+            if (!trackersToTrack.isEmpty()) {
+                final List<String> trackUrls = new ArrayList<String>();
+                for (VastTracker tracker : trackersToTrack) {
+                    trackUrls.add(tracker.getTrackingUrl());
+                    tracker.setTracked();
+                }
+                TrackingRequest.makeTrackingHttpRequest(trackUrls, mVideoViewController.getContext());
+            }
+
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/WebViewAdUrlGenerator.java b/mopub-sdk/src/main/java/com/mopub/mobileads/WebViewAdUrlGenerator.java
index d56aff20..975b69cb 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/WebViewAdUrlGenerator.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/WebViewAdUrlGenerator.java
@@ -5,7 +5,6 @@
 import com.mopub.common.AdUrlGenerator;
 import com.mopub.common.ClientMetadata;
 import com.mopub.common.Constants;
-import com.mopub.common.util.DateAndTime;
 
 public class WebViewAdUrlGenerator extends AdUrlGenerator {
     private final boolean mIsStorePictureSupported;
@@ -19,45 +18,15 @@ public WebViewAdUrlGenerator(Context context, boolean isStorePictureSupported) {
     public String generateUrlString(String serverHostname) {
         initUrlString(serverHostname, Constants.AD_HANDLER);
 
-        final ClientMetadata clientMetadata = ClientMetadata.getInstance(mContext);
-
         setApiVersion("6");
 
-        setAdUnitId(mAdUnitId);
-
-        setSdkVersion(clientMetadata.getSdkVersion());
-
-        setDeviceInfo(clientMetadata.getDeviceManufacturer(),
-                clientMetadata.getDeviceModel(),
-                clientMetadata.getDeviceProduct());
-
-        setKeywords(mKeywords);
-
-        setLocation(mLocation);
-
-        setTimezone(DateAndTime.getTimeZoneOffsetString());
-
-        setOrientation(clientMetadata.getOrientationString());
-
-        setDensity(clientMetadata.getDensity());
+        final ClientMetadata clientMetadata = ClientMetadata.getInstance(mContext);
+        addBaseParams(clientMetadata);
 
         setMraidFlag(true);
 
-        String networkOperator = clientMetadata.getNetworkOperatorForUrl();
-        setMccCode(networkOperator);
-        setMncCode(networkOperator);
-
-        setIsoCountryCode(clientMetadata.getIsoCountryCode());
-        setCarrierName(clientMetadata.getNetworkOperatorName());
-
-        setNetworkType(clientMetadata.getActiveNetworkType());
-
-        setAppVersion(clientMetadata.getAppVersion());
-
         setExternalStoragePermission(mIsStorePictureSupported);
 
-        appendAdvertisingInfoTemplates();
-
         return getFinalUrlString();
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/Base64.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/Base64.java
deleted file mode 100644
index 5a2aebe0..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/Base64.java
+++ /dev/null
@@ -1,725 +0,0 @@
-package com.mopub.mobileads.util;
-
-import java.io.UnsupportedEncodingException;
-
-/**
- * Utilities for encoding and decoding the Base64 representation of
- * binary data.  See RFCs <a
- * href="http://www.ietf.org/rfc/rfc2045.txt">2045</a> and <a
- * href="http://www.ietf.org/rfc/rfc3548.txt">3548</a>.
- */
-public class Base64 {
-    /**
-     * Default values for encoder/decoder flags.
-     */
-    public static final int DEFAULT = 0;
-
-    /**
-     * Encoder flag bit to omit the padding '=' characters at the end
-     * of the output (if any).
-     */
-    public static final int NO_PADDING = 1;
-
-    /**
-     * Encoder flag bit to omit all line terminators (i.e., the output
-     * will be on one long line).
-     */
-    public static final int NO_WRAP = 2;
-
-    /**
-     * Encoder flag bit to indicate lines should be terminated with a
-     * CRLF pair instead of just an LF.  Has no effect if {@code
-     * NO_WRAP} is specified as well.
-     */
-    public static final int CRLF = 4;
-
-    /**
-     * Encoder/decoder flag bit to indicate using the "URL and
-     * filename safe" variant of Base64 (see RFC 3548 section 4) where
-     * {@code -} and {@code _} are used in place of {@code +} and
-     * {@code /}.
-     */
-    public static final int URL_SAFE = 8;
-
-    /**
-     * Flag to pass to Base64OutputStream to indicate that it
-     * should not close the output stream it is wrapping when it
-     * itself is closed.
-     */
-    public static final int NO_CLOSE = 16;
-
-    //  --------------------------------------------------------
-    //  shared code
-    //  --------------------------------------------------------
-
-    /* package */ static abstract class Coder {
-        public byte[] output;
-        public int op;
-
-        /**
-         * Encode/decode another block of input data.  this.output is
-         * provided by the caller, and must be big enough to hold all
-         * the coded data.  On exit, this.opwill be set to the length
-         * of the coded data.
-         *
-         * @param finish true if this is the final call to process for
-         *        this object.  Will finalize the coder state and
-         *        include any final bytes in the output.
-         *
-         * @return true if the input so far is good; false if some
-         *         error has been detected in the input stream..
-         */
-        public abstract boolean process(byte[] input, int offset, int len, boolean finish);
-
-        /**
-         * @return the maximum number of bytes a call to process()
-         * could produce for the given number of input bytes.  This may
-         * be an overestimate.
-         */
-        public abstract int maxOutputSize(int len);
-    }
-
-    //  --------------------------------------------------------
-    //  decoding
-    //  --------------------------------------------------------
-
-    /**
-     * Decode the Base64-encoded data in input and return the data in
-     * a new byte array.
-     *
-     * <p>The padding '=' characters at the end are considered optional, but
-     * if any are present, there must be the correct number of them.
-     *
-     * @param str    the input String to decode, which is converted to
-     *               bytes using the default charset
-     * @param flags  controls certain features of the decoded output.
-     *               Pass {@code DEFAULT} to decode standard Base64.
-     *
-     * @throws IllegalArgumentException if the input contains
-     * incorrect padding
-     */
-    public static byte[] decode(String str, int flags) {
-        return decode(str.getBytes(), flags);
-    }
-
-    /**
-     * Decode the Base64-encoded data in input and return the data in
-     * a new byte array.
-     *
-     * <p>The padding '=' characters at the end are considered optional, but
-     * if any are present, there must be the correct number of them.
-     *
-     * @param input the input array to decode
-     * @param flags  controls certain features of the decoded output.
-     *               Pass {@code DEFAULT} to decode standard Base64.
-     *
-     * @throws IllegalArgumentException if the input contains
-     * incorrect padding
-     */
-    public static byte[] decode(byte[] input, int flags) {
-        return decode(input, 0, input.length, flags);
-    }
-
-    /**
-     * Decode the Base64-encoded data in input and return the data in
-     * a new byte array.
-     *
-     * <p>The padding '=' characters at the end are considered optional, but
-     * if any are present, there must be the correct number of them.
-     *
-     * @param input  the data to decode
-     * @param offset the position within the input array at which to start
-     * @param len    the number of bytes of input to decode
-     * @param flags  controls certain features of the decoded output.
-     *               Pass {@code DEFAULT} to decode standard Base64.
-     *
-     * @throws IllegalArgumentException if the input contains
-     * incorrect padding
-     */
-    public static byte[] decode(byte[] input, int offset, int len, int flags) {
-        // Allocate space for the most data the input could represent.
-        // (It could contain less if it contains whitespace, etc.)
-        Decoder decoder = new Decoder(flags, new byte[len*3/4]);
-
-        if (!decoder.process(input, offset, len, true)) {
-            throw new IllegalArgumentException("bad base-64");
-        }
-
-        // Maybe we got lucky and allocated exactly enough output space.
-        if (decoder.op == decoder.output.length) {
-            return decoder.output;
-        }
-
-        // Need to shorten the array, so allocate a new one of the
-        // right size and copy.
-        byte[] temp = new byte[decoder.op];
-        System.arraycopy(decoder.output, 0, temp, 0, decoder.op);
-        return temp;
-    }
-
-    /* package */ static class Decoder extends Coder {
-        /**
-         * Lookup table for turning bytes into their position in the
-         * Base64 alphabet.
-         */
-        private static final int DECODE[] = {
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
-                52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
-                -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
-                15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
-                -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
-                41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-        };
-
-        /**
-         * Decode lookup table for the "web safe" variant (RFC 3548
-         * sec. 4) where - and _ replace + and /.
-         */
-        private static final int DECODE_WEBSAFE[] = {
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1,
-                52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
-                -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
-                15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63,
-                -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
-                41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-        };
-
-        /** Non-data values in the DECODE arrays. */
-        private static final int SKIP = -1;
-        private static final int EQUALS = -2;
-
-        /**
-         * States 0-3 are reading through the next input tuple.
-         * State 4 is having read one '=' and expecting exactly
-         * one more.
-         * State 5 is expecting no more data or padding characters
-         * in the input.
-         * State 6 is the error state; an error has been detected
-         * in the input and no future input can "fix" it.
-         */
-        private int state;   // state number (0 to 6)
-        private int value;
-
-        final private int[] alphabet;
-
-        public Decoder(int flags, byte[] output) {
-            this.output = output;
-
-            alphabet = ((flags & URL_SAFE) == 0) ? DECODE : DECODE_WEBSAFE;
-            state = 0;
-            value = 0;
-        }
-
-        /**
-         * @return an overestimate for the number of bytes {@code
-         * len} bytes could decode to.
-         */
-        public int maxOutputSize(int len) {
-            return len * 3/4 + 10;
-        }
-
-        /**
-         * Decode another block of input data.
-         *
-         * @return true if the state machine is still healthy.  false if
-         *         bad base-64 data has been detected in the input stream.
-         */
-        public boolean process(byte[] input, int offset, int len, boolean finish) {
-            if (this.state == 6) return false;
-
-            int p = offset;
-            len += offset;
-
-            // Using local variables makes the decoder about 12%
-            // faster than if we manipulate the member variables in
-            // the loop.  (Even alphabet makes a measurable
-            // difference, which is somewhat surprising to me since
-            // the member variable is final.)
-            int state = this.state;
-            int value = this.value;
-            int op = 0;
-            final byte[] output = this.output;
-            final int[] alphabet = this.alphabet;
-
-            while (p < len) {
-                // Try the fast path:  we're starting a new tuple and the
-                // next four bytes of the input stream are all data
-                // bytes.  This corresponds to going through states
-                // 0-1-2-3-0.  We expect to use this method for most of
-                // the data.
-                //
-                // If any of the next four bytes of input are non-data
-                // (whitespace, etc.), value will end up negative.  (All
-                // the non-data values in decode are small negative
-                // numbers, so shifting any of them up and or'ing them
-                // together will result in a value with its top bit set.)
-                //
-                // You can remove this whole block and the output should
-                // be the same, just slower.
-                if (state == 0) {
-                    while (p+4 <= len &&
-                            (value = ((alphabet[input[p] & 0xff] << 18) |
-                                    (alphabet[input[p+1] & 0xff] << 12) |
-                                    (alphabet[input[p+2] & 0xff] << 6) |
-                                    (alphabet[input[p+3] & 0xff]))) >= 0) {
-                        output[op+2] = (byte) value;
-                        output[op+1] = (byte) (value >> 8);
-                        output[op] = (byte) (value >> 16);
-                        op += 3;
-                        p += 4;
-                    }
-                    if (p >= len) break;
-                }
-
-                // The fast path isn't available -- either we've read a
-                // partial tuple, or the next four input bytes aren't all
-                // data, or whatever.  Fall back to the slower state
-                // machine implementation.
-
-                int d = alphabet[input[p++] & 0xff];
-
-                switch (state) {
-                    case 0:
-                        if (d >= 0) {
-                            value = d;
-                            ++state;
-                        } else if (d != SKIP) {
-                            this.state = 6;
-                            return false;
-                        }
-                        break;
-
-                    case 1:
-                        if (d >= 0) {
-                            value = (value << 6) | d;
-                            ++state;
-                        } else if (d != SKIP) {
-                            this.state = 6;
-                            return false;
-                        }
-                        break;
-
-                    case 2:
-                        if (d >= 0) {
-                            value = (value << 6) | d;
-                            ++state;
-                        } else if (d == EQUALS) {
-                            // Emit the last (partial) output tuple;
-                            // expect exactly one more padding character.
-                            output[op++] = (byte) (value >> 4);
-                            state = 4;
-                        } else if (d != SKIP) {
-                            this.state = 6;
-                            return false;
-                        }
-                        break;
-
-                    case 3:
-                        if (d >= 0) {
-                            // Emit the output triple and return to state 0.
-                            value = (value << 6) | d;
-                            output[op+2] = (byte) value;
-                            output[op+1] = (byte) (value >> 8);
-                            output[op] = (byte) (value >> 16);
-                            op += 3;
-                            state = 0;
-                        } else if (d == EQUALS) {
-                            // Emit the last (partial) output tuple;
-                            // expect no further data or padding characters.
-                            output[op+1] = (byte) (value >> 2);
-                            output[op] = (byte) (value >> 10);
-                            op += 2;
-                            state = 5;
-                        } else if (d != SKIP) {
-                            this.state = 6;
-                            return false;
-                        }
-                        break;
-
-                    case 4:
-                        if (d == EQUALS) {
-                            ++state;
-                        } else if (d != SKIP) {
-                            this.state = 6;
-                            return false;
-                        }
-                        break;
-
-                    case 5:
-                        if (d != SKIP) {
-                            this.state = 6;
-                            return false;
-                        }
-                        break;
-                }
-            }
-
-            if (!finish) {
-                // We're out of input, but a future call could provide
-                // more.
-                this.state = state;
-                this.value = value;
-                this.op = op;
-                return true;
-            }
-
-            // Done reading input.  Now figure out where we are left in
-            // the state machine and finish up.
-
-            switch (state) {
-                case 0:
-                    // Output length is a multiple of three.  Fine.
-                    break;
-                case 1:
-                    // Read one extra input byte, which isn't enough to
-                    // make another output byte.  Illegal.
-                    this.state = 6;
-                    return false;
-                case 2:
-                    // Read two extra input bytes, enough to emit 1 more
-                    // output byte.  Fine.
-                    output[op++] = (byte) (value >> 4);
-                    break;
-                case 3:
-                    // Read three extra input bytes, enough to emit 2 more
-                    // output bytes.  Fine.
-                    output[op++] = (byte) (value >> 10);
-                    output[op++] = (byte) (value >> 2);
-                    break;
-                case 4:
-                    // Read one padding '=' when we expected 2.  Illegal.
-                    this.state = 6;
-                    return false;
-                case 5:
-                    // Read all the padding '='s we expected and no more.
-                    // Fine.
-                    break;
-            }
-
-            this.state = state;
-            this.op = op;
-            return true;
-        }
-    }
-
-    //  --------------------------------------------------------
-    //  encoding
-    //  --------------------------------------------------------
-
-    /**
-     * Base64-encode the given data and return a newly allocated
-     * String with the result.
-     *
-     * @param input  the data to encode
-     * @param flags  controls certain features of the encoded output.
-     *               Passing {@code DEFAULT} results in output that
-     *               adheres to RFC 2045.
-     */
-    public static String encodeToString(byte[] input, int flags) {
-        try {
-            return new String(encode(input, flags), "US-ASCII");
-        } catch (UnsupportedEncodingException e) {
-            // US-ASCII is guaranteed to be available.
-            throw new AssertionError(e);
-        }
-    }
-
-    /**
-     * Base64-encode the given data and return a newly allocated
-     * String with the result.
-     *
-     * @param input  the data to encode
-     * @param offset the position within the input array at which to
-     *               start
-     * @param len    the number of bytes of input to encode
-     * @param flags  controls certain features of the encoded output.
-     *               Passing {@code DEFAULT} results in output that
-     *               adheres to RFC 2045.
-     */
-    public static String encodeToString(byte[] input, int offset, int len, int flags) {
-        try {
-            return new String(encode(input, offset, len, flags), "US-ASCII");
-        } catch (UnsupportedEncodingException e) {
-            // US-ASCII is guaranteed to be available.
-            throw new AssertionError(e);
-        }
-    }
-
-    /**
-     * Base64-encode the given data and return a newly allocated
-     * byte[] with the result.
-     *
-     * @param input  the data to encode
-     * @param flags  controls certain features of the encoded output.
-     *               Passing {@code DEFAULT} results in output that
-     *               adheres to RFC 2045.
-     */
-    public static byte[] encode(byte[] input, int flags) {
-        return encode(input, 0, input.length, flags);
-    }
-
-    /**
-     * Base64-encode the given data and return a newly allocated
-     * byte[] with the result.
-     *
-     * @param input  the data to encode
-     * @param offset the position within the input array at which to
-     *               start
-     * @param len    the number of bytes of input to encode
-     * @param flags  controls certain features of the encoded output.
-     *               Passing {@code DEFAULT} results in output that
-     *               adheres to RFC 2045.
-     */
-    public static byte[] encode(byte[] input, int offset, int len, int flags) {
-        Encoder encoder = new Encoder(flags, null);
-
-        // Compute the exact length of the array we will produce.
-        int output_len = len / 3 * 4;
-
-        // Account for the tail of the data and the padding bytes, if any.
-        if (encoder.do_padding) {
-            if (len % 3 > 0) {
-                output_len += 4;
-            }
-        } else {
-            switch (len % 3) {
-                case 0: break;
-                case 1: output_len += 2; break;
-                case 2: output_len += 3; break;
-            }
-        }
-
-        // Account for the newlines, if any.
-        if (encoder.do_newline && len > 0) {
-            output_len += (((len-1) / (3 * Encoder.LINE_GROUPS)) + 1) *
-                    (encoder.do_cr ? 2 : 1);
-        }
-
-        encoder.output = new byte[output_len];
-        encoder.process(input, offset, len, true);
-
-        assert encoder.op == output_len;
-
-        return encoder.output;
-    }
-
-    /* package */ static class Encoder extends Coder {
-        /**
-         * Emit a new line every this many output tuples.  Corresponds to
-         * a 76-character line length (the maximum allowable according to
-         * <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>).
-         */
-        public static final int LINE_GROUPS = 19;
-
-        /**
-         * Lookup table for turning Base64 alphabet positions (6 bits)
-         * into output bytes.
-         */
-        private static final byte ENCODE[] = {
-                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
-                'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
-                'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
-                'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/',
-        };
-
-        /**
-         * Lookup table for turning Base64 alphabet positions (6 bits)
-         * into output bytes.
-         */
-        private static final byte ENCODE_WEBSAFE[] = {
-                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
-                'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
-                'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
-                'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_',
-        };
-
-        final private byte[] tail;
-        /* package */ int tailLen;
-        private int count;
-
-        final public boolean do_padding;
-        final public boolean do_newline;
-        final public boolean do_cr;
-        final private byte[] alphabet;
-
-        public Encoder(int flags, byte[] output) {
-            this.output = output;
-
-            do_padding = (flags & NO_PADDING) == 0;
-            do_newline = (flags & NO_WRAP) == 0;
-            do_cr = (flags & CRLF) != 0;
-            alphabet = ((flags & URL_SAFE) == 0) ? ENCODE : ENCODE_WEBSAFE;
-
-            tail = new byte[2];
-            tailLen = 0;
-
-            count = do_newline ? LINE_GROUPS : -1;
-        }
-
-        /**
-         * @return an overestimate for the number of bytes {@code
-         * len} bytes could encode to.
-         */
-        public int maxOutputSize(int len) {
-            return len * 8/5 + 10;
-        }
-
-        public boolean process(byte[] input, int offset, int len, boolean finish) {
-            // Using local variables makes the encoder about 9% faster.
-            final byte[] alphabet = this.alphabet;
-            final byte[] output = this.output;
-            int op = 0;
-            int count = this.count;
-
-            int p = offset;
-            len += offset;
-            int v = -1;
-
-            // First we need to concatenate the tail of the previous call
-            // with any input bytes available now and see if we can empty
-            // the tail.
-
-            switch (tailLen) {
-                case 0:
-                    // There was no tail.
-                    break;
-
-                case 1:
-                    if (p+2 <= len) {
-                        // A 1-byte tail with at least 2 bytes of
-                        // input available now.
-                        v = ((tail[0] & 0xff) << 16) |
-                                ((input[p++] & 0xff) << 8) |
-                                (input[p++] & 0xff);
-                        tailLen = 0;
-                    };
-                    break;
-
-                case 2:
-                    if (p+1 <= len) {
-                        // A 2-byte tail with at least 1 byte of input.
-                        v = ((tail[0] & 0xff) << 16) |
-                                ((tail[1] & 0xff) << 8) |
-                                (input[p++] & 0xff);
-                        tailLen = 0;
-                    }
-                    break;
-            }
-
-            if (v != -1) {
-                output[op++] = alphabet[(v >> 18) & 0x3f];
-                output[op++] = alphabet[(v >> 12) & 0x3f];
-                output[op++] = alphabet[(v >> 6) & 0x3f];
-                output[op++] = alphabet[v & 0x3f];
-                if (--count == 0) {
-                    if (do_cr) output[op++] = '\r';
-                    output[op++] = '\n';
-                    count = LINE_GROUPS;
-                }
-            }
-
-            // At this point either there is no tail, or there are fewer
-            // than 3 bytes of input available.
-
-            // The main loop, turning 3 input bytes into 4 output bytes on
-            // each iteration.
-            while (p+3 <= len) {
-                v = ((input[p] & 0xff) << 16) |
-                        ((input[p+1] & 0xff) << 8) |
-                        (input[p+2] & 0xff);
-                output[op] = alphabet[(v >> 18) & 0x3f];
-                output[op+1] = alphabet[(v >> 12) & 0x3f];
-                output[op+2] = alphabet[(v >> 6) & 0x3f];
-                output[op+3] = alphabet[v & 0x3f];
-                p += 3;
-                op += 4;
-                if (--count == 0) {
-                    if (do_cr) output[op++] = '\r';
-                    output[op++] = '\n';
-                    count = LINE_GROUPS;
-                }
-            }
-
-            if (finish) {
-                // Finish up the tail of the input.  Note that we need to
-                // consume any bytes in tail before any bytes
-                // remaining in input; there should be at most two bytes
-                // total.
-
-                if (p-tailLen == len-1) {
-                    int t = 0;
-                    v = ((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 4;
-                    tailLen -= t;
-                    output[op++] = alphabet[(v >> 6) & 0x3f];
-                    output[op++] = alphabet[v & 0x3f];
-                    if (do_padding) {
-                        output[op++] = '=';
-                        output[op++] = '=';
-                    }
-                    if (do_newline) {
-                        if (do_cr) output[op++] = '\r';
-                        output[op++] = '\n';
-                    }
-                } else if (p-tailLen == len-2) {
-                    int t = 0;
-                    v = (((tailLen > 1 ? tail[t++] : input[p++]) & 0xff) << 10) |
-                            (((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 2);
-                    tailLen -= t;
-                    output[op++] = alphabet[(v >> 12) & 0x3f];
-                    output[op++] = alphabet[(v >> 6) & 0x3f];
-                    output[op++] = alphabet[v & 0x3f];
-                    if (do_padding) {
-                        output[op++] = '=';
-                    }
-                    if (do_newline) {
-                        if (do_cr) output[op++] = '\r';
-                        output[op++] = '\n';
-                    }
-                } else if (do_newline && op > 0 && count != LINE_GROUPS) {
-                    if (do_cr) output[op++] = '\r';
-                    output[op++] = '\n';
-                }
-
-                assert tailLen == 0;
-                assert p == len;
-            } else {
-                // Save the leftovers in tail to be consumed on the next
-                // call to encodeInternal.
-
-                if (p == len-1) {
-                    tail[tailLen++] = input[p];
-                } else if (p == len-2) {
-                    tail[tailLen++] = input[p];
-                    tail[tailLen++] = input[p+1];
-                }
-            }
-
-            this.op = op;
-            this.count = count;
-
-            return true;
-        }
-    }
-
-    private Base64() { }   // don't instantiate
-}
\ No newline at end of file
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastManager.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastManager.java
index cbfdfeb4..c396547f 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastManager.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastManager.java
@@ -130,12 +130,11 @@ private VastVideoConfiguration createVastVideoConfigurationFromXml(final List<Va
         final List<VastXmlManager.ImageCompanionAdXmlManager> companionXmlManagers = new ArrayList<VastXmlManager.ImageCompanionAdXmlManager>();
         for (VastXmlManager xmlManager : xmlManagers) {
             vastVideoConfiguration.addImpressionTrackers(xmlManager.getImpressionTrackers());
-
-            vastVideoConfiguration.addStartTrackers(xmlManager.getVideoStartTrackers());
-            vastVideoConfiguration.addFirstQuartileTrackers(xmlManager.getVideoFirstQuartileTrackers());
-            vastVideoConfiguration.addMidpointTrackers(xmlManager.getVideoMidpointTrackers());
-            vastVideoConfiguration.addThirdQuartileTrackers(xmlManager.getVideoThirdQuartileTrackers());
+            vastVideoConfiguration.addAbsoluteTrackers(xmlManager.getAbsoluteProgressTrackers());
+            vastVideoConfiguration.addFractionalTrackers(xmlManager.getFractionalProgressTrackers());
             vastVideoConfiguration.addCompleteTrackers(xmlManager.getVideoCompleteTrackers());
+            vastVideoConfiguration.addCloseTrackers(xmlManager.getVideoCloseTrackers());
+            vastVideoConfiguration.addSkipTrackers(xmlManager.getVideoSkipTrackers());
 
             vastVideoConfiguration.addClickTrackers(xmlManager.getClickTrackers());
 
@@ -145,6 +144,13 @@ private VastVideoConfiguration createVastVideoConfigurationFromXml(final List<Va
 
             mediaXmlManagers.addAll(xmlManager.getMediaXmlManagers());
             companionXmlManagers.addAll(xmlManager.getCompanionAdXmlManagers());
+
+            // Load custom extensions
+            vastVideoConfiguration.setCustomCtaText(xmlManager.getCustomCtaText());
+            vastVideoConfiguration.setCustomSkipText(xmlManager.getCustomSkipText());
+            vastVideoConfiguration.setCustomCloseIconUrl(xmlManager.getCustomCloseIconUrl());
+            vastVideoConfiguration.setCustomForceOrientation(xmlManager.getCustomForceOrientation());
+            vastVideoConfiguration.setSkipOffset(xmlManager.getSkipOffset());
         }
 
         vastVideoConfiguration.setNetworkMediaFileUrl(getBestMediaFileUrl(mediaXmlManagers));
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastVideoConfiguration.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastVideoConfiguration.java
index aeae8b9f..ef638cd9 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastVideoConfiguration.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastVideoConfiguration.java
@@ -1,31 +1,45 @@
 package com.mopub.mobileads.util.vast;
 
+import android.support.annotation.Nullable;
+
+import com.mopub.common.util.DeviceUtils;
+import com.mopub.mobileads.VastAbsoluteProgressTracker;
+import com.mopub.mobileads.VastFractionalProgressTracker;
+
 import java.io.Serializable;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 public class VastVideoConfiguration implements Serializable {
-    private static final long serialVersionUID = 0L;
-
-    private ArrayList<String> mImpressionTrackers;
-    private ArrayList<String> mStartTrackers;
-    private ArrayList<String> mFirstQuartileTrackers;
-    private ArrayList<String> mMidpointTrackers;
-    private ArrayList<String> mThirdQuartileTrackers;
-    private ArrayList<String> mCompleteTrackers;
-    private ArrayList<String> mClickTrackers;
+    private static final long serialVersionUID = 1L;
+
+    private final ArrayList<String> mImpressionTrackers;
+    private final ArrayList<VastFractionalProgressTracker> mFractionalTrackers;
+    private final ArrayList<VastAbsoluteProgressTracker> mAbsoluteTrackers;
+    private final ArrayList<String> mCompleteTrackers;
+    private final ArrayList<String> mCloseTrackers;
+    private final ArrayList<String> mSkipTrackers;
+    private final ArrayList<String> mClickTrackers;
     private String mClickThroughUrl;
     private String mNetworkMediaFileUrl;
     private String mDiskMediaFileUrl;
+    private String mSkipOffset;
     private VastCompanionAd mVastCompanionAd;
 
+    // Custom extensions
+    private String mCustomCtaText;
+    private String mCustomSkipText;
+    private String mCustomCloseIconUrl;
+    private DeviceUtils.ForceOrientation mCustomForceOrientation = DeviceUtils.ForceOrientation.FORCE_LANDSCAPE; // Default is forcing landscape
+
     public VastVideoConfiguration() {
         mImpressionTrackers = new ArrayList<String>();
-        mStartTrackers = new ArrayList<String>();
-        mFirstQuartileTrackers = new ArrayList<String>();
-        mMidpointTrackers = new ArrayList<String>();
-        mThirdQuartileTrackers = new ArrayList<String>();
+        mFractionalTrackers = new ArrayList<VastFractionalProgressTracker>();
+        mAbsoluteTrackers = new ArrayList<VastAbsoluteProgressTracker>();
         mCompleteTrackers = new ArrayList<String>();
+        mCloseTrackers = new ArrayList<String>();
+        mSkipTrackers = new ArrayList<String>();
         mClickTrackers = new ArrayList<String>();
     }
 
@@ -37,24 +51,33 @@ public void addImpressionTrackers(final List<String> impressionTrackers) {
         mImpressionTrackers.addAll(impressionTrackers);
     }
 
-    public void addStartTrackers(final List<String> startTrackers) {
-        mStartTrackers.addAll(startTrackers);
+    /**
+     * Add trackers for percentage-based tracking. This includes all quartile trackers and any
+     * "progress" events with other percentages.
+     */
+    public void addFractionalTrackers(final List<VastFractionalProgressTracker> fractionalTrackers) {
+        mFractionalTrackers.addAll(fractionalTrackers);
+        Collections.sort(mFractionalTrackers);
     }
 
-    public void addFirstQuartileTrackers(final List<String> firstQuartileTrackers) {
-        mFirstQuartileTrackers.addAll(firstQuartileTrackers);
+    /**
+     * Add trackers for absolute tracking. This includes start trackers, which have an absolute threshold of 2 seconds.
+     */
+    public void addAbsoluteTrackers(final List<VastAbsoluteProgressTracker> absoluteTrackers) {
+        mAbsoluteTrackers.addAll(absoluteTrackers);
+        Collections.sort(mAbsoluteTrackers);
     }
 
-    public void addMidpointTrackers(final List<String> midpointTrackers) {
-        mMidpointTrackers.addAll(midpointTrackers);
+    public void addCompleteTrackers(final List<String> completeTrackers) {
+        mCompleteTrackers.addAll(completeTrackers);
     }
 
-    public void addThirdQuartileTrackers(final List<String> thirdQuartileTrackers) {
-        mThirdQuartileTrackers.addAll(thirdQuartileTrackers);
+    public void addCloseTrackers(final List<String> closeTrackers) {
+        mCloseTrackers.addAll(closeTrackers);
     }
 
-    public void addCompleteTrackers(final List<String> completeTrackers) {
-        mCompleteTrackers.addAll(completeTrackers);
+    public void addSkipTrackers(final List<String> skipTrackers) {
+        mSkipTrackers.addAll(skipTrackers);
     }
 
     public void addClickTrackers(final List<String> clickTrackers) {
@@ -77,6 +100,36 @@ public void setVastCompanionAd(final VastCompanionAd vastCompanionAd) {
         mVastCompanionAd = vastCompanionAd;
     }
 
+    public void setCustomCtaText(@Nullable final String customCtaText) {
+        if (customCtaText != null) {
+            mCustomCtaText = customCtaText;
+        }
+    }
+
+    public void setCustomSkipText(@Nullable final String customSkipText) {
+        if (customSkipText != null) {
+            mCustomSkipText = customSkipText;
+        }
+    }
+
+    public void setCustomCloseIconUrl(@Nullable final String customCloseIconUrl) {
+        if (customCloseIconUrl != null) {
+            mCustomCloseIconUrl = customCloseIconUrl;
+        }
+    }
+
+    public void setCustomForceOrientation(@Nullable final DeviceUtils.ForceOrientation customForceOrientation) {
+        if (customForceOrientation != null && customForceOrientation != DeviceUtils.ForceOrientation.UNDEFINED) {
+            mCustomForceOrientation = customForceOrientation;
+        }
+    }
+
+    public void setSkipOffset(@Nullable final String skipOffset) {
+        if (skipOffset != null) {
+            mSkipOffset = skipOffset;
+        }
+    }
+
     /**
      * Getters
      */
@@ -85,24 +138,24 @@ public void setVastCompanionAd(final VastCompanionAd vastCompanionAd) {
         return mImpressionTrackers;
     }
 
-    public List<String> getStartTrackers() {
-        return mStartTrackers;
+    public ArrayList<VastAbsoluteProgressTracker> getAbsoluteTrackers() {
+        return mAbsoluteTrackers;
     }
 
-    public List<String> getFirstQuartileTrackers() {
-        return mFirstQuartileTrackers;
+    public ArrayList<VastFractionalProgressTracker> getFractionalTrackers() {
+        return mFractionalTrackers;
     }
 
-    public List<String> getMidpointTrackers() {
-        return mMidpointTrackers;
+    public List<String> getCompleteTrackers() {
+        return mCompleteTrackers;
     }
 
-    public List<String> getThirdQuartileTrackers() {
-        return mThirdQuartileTrackers;
+    public List<String> getCloseTrackers() {
+        return mCloseTrackers;
     }
 
-    public List<String> getCompleteTrackers() {
-        return mCompleteTrackers;
+    public List<String> getSkipTrackers() {
+        return mSkipTrackers;
     }
 
     public List<String> getClickTrackers() {
@@ -124,4 +177,28 @@ public String getDiskMediaFileUrl() {
     public VastCompanionAd getVastCompanionAd() {
         return mVastCompanionAd;
     }
+
+    public String getCustomCtaText() {
+        return mCustomCtaText;
+    }
+
+    public String getCustomSkipText() {
+        return mCustomSkipText;
+    }
+
+    public String getCustomCloseIconUrl() {
+        return mCustomCloseIconUrl;
+    }
+
+    /**
+     * Get custom force orientation
+     * @return ForceOrientation enum (default is FORCE_LANDSCAPE)
+     */
+    public DeviceUtils.ForceOrientation getCustomForceOrientation() {
+        return mCustomForceOrientation;
+    }
+
+    public String getSkipOffset() {
+        return mSkipOffset;
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastXmlManager.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastXmlManager.java
index 86748f05..299288ed 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastXmlManager.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastXmlManager.java
@@ -1,5 +1,14 @@
 package com.mopub.mobileads.util.vast;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.DeviceUtils.ForceOrientation;
+import com.mopub.common.util.Strings;
+import com.mopub.mobileads.VastAbsoluteProgressTracker;
+import com.mopub.mobileads.VastFractionalProgressTracker;
+
 import org.w3c.dom.Document;
 import org.w3c.dom.Node;
 import org.w3c.dom.NodeList;
@@ -10,6 +19,7 @@
 import java.io.StringReader;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 
 import javax.xml.parsers.DocumentBuilder;
@@ -30,18 +40,40 @@
     private static final String VAST_AD_TAG = "VASTAdTagURI";
     private static final String MP_IMPRESSION_TRACKER = "MP_TRACKING_URL";
     private static final String COMPANION = "Companion";
+    private static final String LINEAR = "Linear";
+
+    // Custom element names for VAST 3.0 extensions
+    private static final String CUSTOM_CTA_TEXT = "MoPubCtaText";
+    private static final String CUSTOM_SKIP_TEXT = "MoPubSkipText";
+    private static final String CUSTOM_CLOSE_ICON = "MoPubCloseIcon";
+    private static final String CUSTOM_FORCE_ORIENTATION = "MoPubForceOrientation";
 
     // Attribute names
     private static final String EVENT = "event";
     private static final String WIDTH = "width";
     private static final String HEIGHT = "height";
+    private static final String OFFSET = "offset";
+    private static final String SKIP_OFFSET = "skipoffset";
 
-    // Attibute values
+    // Event Attribute values
     private static final String START = "start";
     private static final String FIRST_QUARTILE = "firstQuartile";
     private static final String MIDPOINT = "midpoint";
     private static final String THIRD_QUARTILE = "thirdQuartile";
     private static final String COMPLETE = "complete";
+    private static final String CLOSE = "close";
+    private static final String PROGRESS = "progress";
+    private static final String SKIP = "skip";
+
+    private static final int START_TRACKER_THRESHOLD = 2000;
+    private static final float FIRST_QUARTER_MARKER = 0.25f;
+    private static final float MID_POINT_MARKER = 0.50f;
+    private static final float THIRD_QUARTER_MARKER = 0.75f;
+
+    // constants for custom extensions
+    private static final int MAX_CTA_TEXT_LENGTH = 15;
+    private static final int MAX_SKIP_TEXT_LENGTH = 8;
+
 
     // This class currently assumes an image type companion ad since that is what we are supporting
     class ImageCompanionAdXmlManager {
@@ -185,29 +217,114 @@ String getVastAdTagURI() {
         return impressionTrackers;
     }
 
-    List<String> getVideoStartTrackers() {
-        return getVideoTrackerByAttribute(START);
-    }
+    /**
+     * Return a sorted list of the video's percent-based progress-trackers. These are the
+     * quartile trackers and any "progress" nodes with percent-based offsets.
+     *
+     * Quartile trackers look like:
+     * {@code
+     * <Tracking event="firstQuartile">
+     *     <![CDATA[trackingURL]]>
+     * </Tracking>
+     * }
+     *
+     * Percent-based progress trackers look like:
+     * {@code
+     * <Tracking event="progress" offset="11%">
+     *     <![CDATA[trackingURL]]>
+     * </Tracking>
+     * }
+     */
+    @NonNull
+    List<VastFractionalProgressTracker> getFractionalProgressTrackers() {
+        // Add all the quartile trackers from VAST 2.0:
+        List<VastFractionalProgressTracker> percentTrackers = new ArrayList<VastFractionalProgressTracker>();
+        addQuartileTrackerWithFraction(percentTrackers, getVideoTrackerByAttribute(FIRST_QUARTILE), FIRST_QUARTER_MARKER);
+        addQuartileTrackerWithFraction(percentTrackers, getVideoTrackerByAttribute(MIDPOINT), MID_POINT_MARKER);
+        addQuartileTrackerWithFraction(percentTrackers, getVideoTrackerByAttribute(THIRD_QUARTILE), THIRD_QUARTER_MARKER);
+
+        // Get any other trackers with event="progress" offset="n%"
+        final List<Node> progressNodes = XmlUtils.getNodesWithElementAndAttribute(mVastDoc, VIDEO_TRACKER, EVENT, PROGRESS);
+        for (Node progressNode : progressNodes) {
+            final String offsetString = XmlUtils.getAttributeValue(progressNode, OFFSET).trim();
+            if (Strings.isPercentageTracker(offsetString)) {
+                String trackingUrl = XmlUtils.getNodeValue(progressNode).trim();
+                try {
+                    float trackingFraction = Float.parseFloat(offsetString.replace("%", "")) / 100f;
+                    percentTrackers.add(new VastFractionalProgressTracker(trackingUrl, trackingFraction));
+                } catch (NumberFormatException e) {
+                    MoPubLog.d(String.format("Failed to parse VAST progress tracker %s", offsetString));
+                }
+            }
+        }
 
-    List<String> getVideoFirstQuartileTrackers() {
-        return getVideoTrackerByAttribute(FIRST_QUARTILE);
+        // Sort the list so we can quickly index it in the video progress runnable.
+        Collections.sort(percentTrackers);
+        return percentTrackers;
     }
 
-    List<String> getVideoMidpointTrackers() {
-        return getVideoTrackerByAttribute(MIDPOINT);
-    }
+    /**
+     * Return a sorted list of the video's absolute progress trackers. This includes start trackers
+     * and any "progress" nodes with absolute offsets.
+     *
+     * Start trackers live in nodes like:
+     * {@code
+     * <Tracking event="start">
+     *     <![CDATA[trackingURL]]>
+     * </Tracking>
+     * }
+     * Absolute progress trackers look like:
+     * {@code
+     * <Tracking event="progress" offset="00:00:10.000">
+     *     <![CDATA[trackingURL]]>
+     * </Tracking>
+     * }
+     */
+    @NonNull
+    List<VastAbsoluteProgressTracker> getAbsoluteProgressTrackers() {
+        List<VastAbsoluteProgressTracker> trackers = new ArrayList<VastAbsoluteProgressTracker>();
+        // Start trackers are treated as absolute trackers with a 2s offset.
+        final List<String> startTrackers = getVideoTrackerByAttribute(START);
+        for (String url : startTrackers) {
+            trackers.add(new VastAbsoluteProgressTracker(url, START_TRACKER_THRESHOLD));
+        }
+
+        // Parse progress trackers and extract the absolute offsets of the form "HH:MM:SS[.mmm]"
+        final List<Node> progressNodes = XmlUtils.getNodesWithElementAndAttribute(mVastDoc, VIDEO_TRACKER, EVENT, PROGRESS);
+        for (Node progressNode : progressNodes) {
+            final String offSetString = XmlUtils.getAttributeValue(progressNode, OFFSET).trim();
+            if (Strings.isAbsoluteTracker(offSetString)) {
+                String trackingUrl = XmlUtils.getNodeValue(progressNode).trim();
+                try {
+                    Integer trackingMilliseconds = Strings.parseAbsoluteOffset(offSetString);
+                    if (trackingMilliseconds != null) {
+                        trackers.add(new VastAbsoluteProgressTracker(trackingUrl, trackingMilliseconds));
+                    }
+                } catch (NumberFormatException e) {
+                    MoPubLog.d(String.format("Failed to parse VAST progress tracker %s", offSetString));
+                }
+            }
+        }
 
-    List<String> getVideoThirdQuartileTrackers() {
-        return getVideoTrackerByAttribute(THIRD_QUARTILE);
+        // Sort the list so we can quickly index it in the video progress runnable.
+        Collections.sort(trackers);
+        return trackers;
     }
 
     List<String> getVideoCompleteTrackers() {
         return getVideoTrackerByAttribute(COMPLETE);
     }
 
+    List<String> getVideoCloseTrackers() {
+        return getVideoTrackerByAttribute(CLOSE);
+    }
+
+    List<String> getVideoSkipTrackers() {
+        return getVideoTrackerByAttribute(SKIP);
+    }
+
     String getClickThroughUrl() {
-        List<String> clickUrlWrapper = XmlUtils.getStringDataAsList(mVastDoc, CLICK_THROUGH);
-        return (clickUrlWrapper.size() > 0) ? clickUrlWrapper.get(0) : null;
+        return XmlUtils.getFirstMatchingStringData(mVastDoc, CLICK_THROUGH);
     }
 
     List<String> getClickTrackers() {
@@ -215,8 +332,58 @@ String getClickThroughUrl() {
     }
 
     String getMediaFileUrl() {
-        List<String> urlWrapper = XmlUtils.getStringDataAsList(mVastDoc, MEDIA_FILE);
-        return (urlWrapper.size() > 0) ? urlWrapper.get(0) : null;
+        return XmlUtils.getFirstMatchingStringData(mVastDoc, MEDIA_FILE);
+    }
+
+    @Nullable
+    String getCustomCtaText() {
+        String customCtaText = XmlUtils.getFirstMatchingStringData(mVastDoc, CUSTOM_CTA_TEXT);
+        if (customCtaText != null && customCtaText.length() <= MAX_CTA_TEXT_LENGTH) {
+            return customCtaText;
+        }
+
+        return null;
+    }
+
+    @Nullable
+    String getCustomSkipText() {
+        String customSkipText = XmlUtils.getFirstMatchingStringData(mVastDoc, CUSTOM_SKIP_TEXT);
+        if (customSkipText != null && customSkipText.length() <= MAX_SKIP_TEXT_LENGTH) {
+            return customSkipText;
+        }
+
+        return null;
+    }
+
+    @Nullable
+    String getCustomCloseIconUrl() {
+        return XmlUtils.getFirstMatchingStringData(mVastDoc, CUSTOM_CLOSE_ICON);
+    }
+
+    @NonNull
+    ForceOrientation getCustomForceOrientation() {
+        return ForceOrientation.getForceOrientation(
+                XmlUtils.getFirstMatchingStringData(mVastDoc, CUSTOM_FORCE_ORIENTATION));
+    }
+
+    @Nullable
+    String getSkipOffset() {
+        List<Node> linearNodeWrapper = XmlUtils.getNodesWithElementAndAttribute(mVastDoc, LINEAR, SKIP_OFFSET, null);
+        Node linearNode = (linearNodeWrapper.isEmpty()) ? null : linearNodeWrapper.get(0);
+        if (linearNode == null) {
+            return null;
+        }
+
+        final String skipOffsetString = XmlUtils.getAttributeValue(linearNode, SKIP_OFFSET);
+        if (skipOffsetString == null) {
+            return null;
+        }
+
+        if (skipOffsetString.trim().isEmpty()) {
+            return null;
+        }
+
+        return skipOffsetString.trim();
     }
 
     List<MediaXmlManager> getMediaXmlManagers() {
@@ -242,4 +409,10 @@ String getMediaFileUrl() {
     private List<String> getVideoTrackerByAttribute(final String attributeValue) {
         return XmlUtils.getStringDataAsList(mVastDoc, VIDEO_TRACKER, EVENT, attributeValue);
     }
+
+    private void addQuartileTrackerWithFraction(List<VastFractionalProgressTracker> trackers, List<String> urls, float fraction) {
+        for (String url : urls) {
+            trackers.add(new VastFractionalProgressTracker(url, fraction));
+        }
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/XmlUtils.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/XmlUtils.java
index 79e92584..9a69d13d 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/XmlUtils.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/XmlUtils.java
@@ -12,11 +12,30 @@
 class XmlUtils {
     private XmlUtils() {}
 
+    /**
+     * Gets the first direct child of the given node with a node named {@code nodeName}.
+     *
+     * Only direct children are checked.
+     */
     static Node getFirstMatchingChildNode(final Node node, final String nodeName) {
         return getFirstMatchingChildNode(node, nodeName, null, null);
     }
 
-    static Node getFirstMatchingChildNode(final Node node, final String nodeName, final String attributeName, final List<String> attributeValues) {
+    /**
+     * Gets the first direct child of the given node with a node named {@code nodeName} that has an
+     * attribute named {@code attributeName} with a value that matches one of {@code attributeValues}.
+     *
+     * Only direct children are checked.
+     *
+     * @param nodeName matching nodes must have this name.
+     * @param attributeName matching nodes must have an attribute with this name.
+     *                      Use null to match nodes with any attributes.
+     * @param attributeValues all matching child nodes' matching attribute will have a value that
+     *                        matches one of these values. Use null to match nodes with any attribute
+     *                        value.
+     */
+    static Node getFirstMatchingChildNode(final Node node, final String nodeName,
+            final String attributeName, final List<String> attributeValues) {
         if (node == null || nodeName == null) {
             return null;
         }
@@ -28,7 +47,21 @@ static Node getFirstMatchingChildNode(final Node node, final String nodeName, fi
         return null;
     }
 
-    static List<Node> getMatchingChildNodes(final Node node, final String nodeName, final String attributeName, final List<String> attributeValues) {
+    /**
+     * Return children of the {@code node} parameter with a matching {@code nodeName} &
+     * {@code attributeName} that matches at least one of the passed-in {@code attributeValues}.
+     * If {@code attributeValues} is empty, no nodes will match. To match names only,
+     * pass null for both {@code attributeName} and {@code attributeValues}.
+     *
+     * @param node the root node to look beneath.
+     * @param nodeName all child nodes will match this element.
+     * @param attributeName all matching child nodes will have an attribute of this name.
+     * @param attributeValues all matching child nodes' matching attribute will have a value that
+     *                        matches one of these values.
+     * @return child nodes that match all parameters
+     */
+    static List<Node> getMatchingChildNodes(final Node node, final String nodeName,
+            final String attributeName, final List<String> attributeValues) {
         if (node == null || nodeName == null) {
             return null;
         }
@@ -45,6 +78,10 @@ static Node getFirstMatchingChildNode(final Node node, final String nodeName, fi
         return nodes;
     }
 
+    /**
+     * Returns {@code true} iff the node has the attribute {@code attributeName} with a value that
+     * matches one of {@code attributeValues}.
+     */
     static boolean nodeMatchesAttributeFilter(final Node node, final String attributeName, final List<String> attributeValues) {
         if (attributeName == null || attributeValues == null) {
             return true;
@@ -95,35 +132,124 @@ static String getAttributeValue(final Node node, final String attributeName) {
         return null;
     }
 
-    static List<String> getStringDataAsList(final Document vastDoc, final String elementName) {
-        return getStringDataAsList(vastDoc, elementName, null, null);
-    }
-
-    static List<String> getStringDataAsList(final Document vastDoc, final String elementName, final String attributeName, final String attributeValue) {
-        final ArrayList<String> results = new ArrayList<String>();
+    /**
+     * Get a list of data from a {@code Document]'s elements that match the {@code elementName},
+     * {@code attributeName}, and {@code attributeValue} filters. Each node that matches these is
+     * processed by the {@code nodeProcessor} and all non-null results returned by the processor are
+     * returned.
+     *
+     * @param vastDoc The {@link org.w3c.dom.Document} we wish to extract data from.
+     * @param elementName Only elements with this name are processed.
+     * @param attributeName Only elements with this attribute are processed.
+     * @param attributeValue Only elements whose attribute with attributeName matches this value are processed.
+     * @param nodeProcessor Takes matching nodes and produces output data for that node.
+     * @return a {@code List<T>} with processed node data.
+     */
+    static <T> List<T> getListFromDocument(final Document vastDoc, final String elementName,
+            final String attributeName, final String attributeValue, NodeProcessor<T> nodeProcessor) {
+        final ArrayList<T> results = new ArrayList<T>();
 
         if (vastDoc == null) {
             return results;
         }
 
         final NodeList nodes = vastDoc.getElementsByTagName(elementName);
-
         if (nodes == null) {
             return results;
         }
 
+        List<String> attributeValues = attributeValue == null ? null : Arrays.asList(attributeValue);
+
         for (int i = 0; i < nodes.getLength(); i++) {
             final Node node = nodes.item(i);
 
-            if (node != null && nodeMatchesAttributeFilter(node, attributeName, Arrays.asList(attributeValue))) {
-                // since we parsed with coalescing set to true, CDATA is added as the child of the element
-                final String nodeValue = getNodeValue(node);
-                if (nodeValue != null) {
-                    results.add(nodeValue);
+            if (node != null && nodeMatchesAttributeFilter(node, attributeName, attributeValues)) {
+                T processed = nodeProcessor.process(node);
+                if (processed != null) {
+                    results.add(processed);
                 }
             }
         }
 
         return results;
     }
+
+    /**
+     * Get first matching data from a {@code Document]'s elements that match the {@code elementName},
+     * {@code attributeName}, and {@code attributeValue} filters. Nodes that match are processed by
+     * the {@code nodeProcessor} until the first non-null result returned by the processor is
+     * returned.
+     *
+     * @param vastDoc The {@link org.w3c.dom.Document} we wish to extract data from.
+     * @param elementName Only elements with this name are processed.
+     * @param attributeName Only elements with this attribute are processed.
+     * @param attributeValue Only elements whose attribute with attributeName matches this value are processed.
+     * @param nodeProcessor Takes matching nodes and produces output data for that node.
+     * @return node data of type {@code <T>} from first node that matches.
+     */
+    static <T> T getFirstMatchFromDocument(final Document vastDoc, final String elementName,
+            final String attributeName, final String attributeValue, NodeProcessor<T> nodeProcessor) {
+        if (vastDoc == null) {
+            return null;
+        }
+
+        final NodeList nodes = vastDoc.getElementsByTagName(elementName);
+        if (nodes == null) {
+            return null;
+        }
+
+        List<String> attributeValues = attributeValue == null ? null : Arrays.asList(attributeValue);
+
+        for (int i = 0; i < nodes.getLength(); i++) {
+            final Node node = nodes.item(i);
+
+            if (node != null && nodeMatchesAttributeFilter(node, attributeName, attributeValues)) {
+                T processed = nodeProcessor.process(node);
+                if (processed != null) {
+                    return processed;
+                }
+            }
+        }
+
+        return null;
+    }
+
+    static String getFirstMatchingStringData(final Document vastDoc, final String elementName) {
+        return getFirstMatchingStringData(vastDoc, elementName, null, null);
+    }
+
+    static String getFirstMatchingStringData(final Document vastDoc, final String elementName, final String attributeName, final String attributeValue) {
+        return getFirstMatchFromDocument(vastDoc, elementName, attributeName, attributeValue, new NodeProcessor<String>() {
+            @Override
+            public String process(final Node node) {
+                return getNodeValue(node);
+            }
+        });
+    }
+
+    static List<String> getStringDataAsList(final Document vastDoc, final String elementName) {
+        return getStringDataAsList(vastDoc, elementName, null, null);
+    }
+
+    static List<String> getStringDataAsList(final Document vastDoc, final String elementName, final String attributeName, final String attributeValue) {
+        return getListFromDocument(vastDoc, elementName, attributeName, attributeValue, new NodeProcessor<String>() {
+            @Override
+            public String process(final Node node) {
+                return getNodeValue(node);
+            }
+        });
+    }
+
+    static List<Node> getNodesWithElementAndAttribute(final Document vastDoc, final String elementName, final String attributeName, final String attributeValue) {
+       return getListFromDocument(vastDoc, elementName, attributeName, attributeValue, new NodeProcessor<Node>() {
+           @Override
+           public Node process(final Node node) {
+               return node;
+           }
+       });
+    }
+
+    public interface NodeProcessor<T> {
+        public T process(Node node);
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidController.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidController.java
index 3f1ea554..cfb4bcf9 100644
--- a/mopub-sdk/src/main/java/com/mopub/mraid/MraidController.java
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidController.java
@@ -10,10 +10,8 @@
 import android.content.pm.ActivityInfo;
 import android.content.pm.PackageManager;
 import android.graphics.Rect;
-import android.net.Uri;
 import android.os.Build.VERSION;
 import android.os.Build.VERSION_CODES;
-import android.os.Bundle;
 import android.os.Handler;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
@@ -30,24 +28,23 @@
 import android.widget.FrameLayout.LayoutParams;
 
 import com.mopub.common.AdReport;
+import com.mopub.common.UrlHandler;
 import com.mopub.common.CloseableLayout;
 import com.mopub.common.CloseableLayout.ClosePosition;
 import com.mopub.common.CloseableLayout.OnCloseListener;
-import com.mopub.common.MoPubBrowser;
 import com.mopub.common.Preconditions;
+import com.mopub.common.UrlAction;
 import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.util.DeviceUtils;
 import com.mopub.common.util.Dips;
-import com.mopub.common.util.Intents;
 import com.mopub.common.util.Views;
-import com.mopub.exceptions.IntentNotResolvableException;
-import com.mopub.exceptions.UrlParseException;
 import com.mopub.mobileads.MraidVideoPlayerActivity;
 import com.mopub.mobileads.util.WebViews;
 import com.mopub.mraid.MraidBridge.MraidBridgeListener;
 import com.mopub.mraid.MraidBridge.MraidWebView;
 
+import java.lang.ref.WeakReference;
 import java.net.URI;
 
 import static android.content.pm.ActivityInfo.CONFIG_ORIENTATION;
@@ -69,7 +66,12 @@
         public void useCustomCloseChanged(boolean useCustomClose);
     }
 
-    @Nullable private Activity mActivity;
+    /**
+     * Holds a weak reference to the activity if the context that is passed in is an activity.
+     * While this field is never null, the reference could become null. This reference starts out
+     * null if the passed-in context is not an activity.
+     */
+    @NonNull private final WeakReference<Activity> mWeakActivity;
     @NonNull private final Context mContext;
     @NonNull private final PlacementType mPlacementType;
 
@@ -131,10 +133,15 @@ public MraidController(@NonNull Context context, @Nullable AdReport adReport,
             @NonNull PlacementType placementType,
             @NonNull MraidBridge bridge, @NonNull MraidBridge twoPartBridge,
             @NonNull ScreenMetricsWaiter screenMetricsWaiter) {
-        mContext = context;
+        mContext = context.getApplicationContext();
+        Preconditions.checkNotNull(mContext);
         mAdReport = adReport;
-        if (mContext instanceof Activity) {
-            mActivity = (Activity) mContext;
+        if (context instanceof Activity) {
+            mWeakActivity = new WeakReference<Activity>((Activity) context);
+        } else {
+            // Make sure mWeakActivity itself is never null, though the reference
+            // it's pointing to could be null.
+            mWeakActivity = new WeakReference<Activity>(null);
         }
 
         mPlacementType = placementType;
@@ -277,7 +284,7 @@ public void onResize(final int width, final int height, final int offsetX,
                 final boolean allowOffscreen) throws MraidCommandException {
             throw new MraidCommandException("Not allowed to resize from an expanded state");
         }
-        
+
         @Override
         public void onExpand(@Nullable final URI uri, final boolean shouldUseCustomClose) {
             // The MRAID spec dictates that this is ignored rather than firing an error
@@ -440,11 +447,12 @@ private View getCurrentWebView() {
 
     private boolean isInlineVideoAvailable() {
         //noinspection SimplifiableIfStatement
-        if (mActivity == null || getCurrentWebView() == null) {
+        final Activity activity = mWeakActivity.get();
+        if (activity == null || getCurrentWebView() == null) {
             return false;
         }
 
-        return mMraidNativeCommandHandler.isInlineVideoAvailable(mActivity, getCurrentWebView());
+        return mMraidNativeCommandHandler.isInlineVideoAvailable(activity, getCurrentWebView());
     }
 
     @VisibleForTesting
@@ -695,9 +703,9 @@ void handleResize(final int widthDips, final int heightDips, final int offsetXDi
 
         if (!resizeRect.contains(closeRect)) {
             throw new MraidCommandException("resizeProperties specified a size ("
-            + widthDips + ", " + height +") and offset ("
-            + offsetXDips + ", " + offsetYDips + ") that don't allow the close region to appear "
-            + "within the resized ad.");
+                    + widthDips + ", " + height + ") and offset ("
+                    + offsetXDips + ", " + offsetYDips + ") that don't allow the close region to appear "
+                    + "within the resized ad.");
         }
 
         // Resized ads always rely on the creative's close button (as if useCustomClose were true)
@@ -844,16 +852,17 @@ void handleShowVideo(@NonNull String videoUrl) {
 
     @VisibleForTesting
     void lockOrientation(final int screenOrientation) throws MraidCommandException {
-        if (mActivity == null || !shouldAllowForceOrientation(mForceOrientation)) {
+        final Activity activity = mWeakActivity.get();
+        if (activity == null || !shouldAllowForceOrientation(mForceOrientation)) {
             throw new MraidCommandException("Attempted to lock orientation to unsupported value: " +
                     mForceOrientation.name());
         }
 
         if (mOriginalActivityOrientation == null) {
-            mOriginalActivityOrientation = mActivity.getRequestedOrientation();
+            mOriginalActivityOrientation = activity.getRequestedOrientation();
         }
 
-        mActivity.setRequestedOrientation(screenOrientation);
+        activity.setRequestedOrientation(screenOrientation);
     }
 
     @VisibleForTesting
@@ -864,14 +873,15 @@ void applyOrientation() throws MraidCommandException {
                 // orientation lock should be removed
                 unApplyOrientation();
             } else {
-                if (mActivity == null) {
+                final Activity activity = mWeakActivity.get();
+                if (activity == null) {
                     throw new MraidCommandException("Unable to set MRAID expand orientation to " +
                             "'none'; expected passed in Activity Context.");
                 }
 
                 // If screen orientation cannot be changed and we can obtain the current
                 // screen orientation, locking it to the current orientation is a best effort
-                lockOrientation(DeviceUtils.getScreenOrientation(mActivity));
+                lockOrientation(DeviceUtils.getScreenOrientation(activity));
             }
         } else {
             // Otherwise, we have a valid, non-NONE orientation. Lock the screen based on this value
@@ -881,8 +891,9 @@ void applyOrientation() throws MraidCommandException {
 
     @VisibleForTesting
     void unApplyOrientation() {
-        if (mActivity != null && mOriginalActivityOrientation != null) {
-            mActivity.setRequestedOrientation(mOriginalActivityOrientation);
+        final Activity activity = mWeakActivity.get();
+        if (activity != null && mOriginalActivityOrientation != null) {
+            activity.setRequestedOrientation(mOriginalActivityOrientation);
         }
         mOriginalActivityOrientation = null;
     }
@@ -895,15 +906,16 @@ boolean shouldAllowForceOrientation(final MraidOrientation newOrientation) {
             return true;
         }
 
-        // If we can't obtain an Activity context, return false
-        if (mActivity == null) {
+        final Activity activity = mWeakActivity.get();
+        // If we can't obtain an Activity, return false
+        if (activity == null) {
             return false;
         }
 
         final ActivityInfo activityInfo;
         try {
-            activityInfo = mActivity.getPackageManager().getActivityInfo(
-                    new ComponentName(mActivity, mActivity.getClass()), 0);
+            activityInfo = activity.getPackageManager().getActivityInfo(
+                    new ComponentName(activity, activity.getClass()), 0);
         } catch (PackageManager.NameNotFoundException e) {
             return false;
         }
@@ -960,6 +972,7 @@ public void loadJavascript(@NonNull String javascript) {
         // -1 until this gets set at least once
         private int mLastRotation = -1;
 
+        @Override
         public void onReceive(Context context, Intent intent) {
             if (mContext == null) {
                 return;
@@ -976,9 +989,12 @@ public void onReceive(Context context, Intent intent) {
         }
 
         public void register(@NonNull final Context context) {
-            mContext = context;
-            mContext.registerReceiver(this,
-                    new IntentFilter(Intent.ACTION_CONFIGURATION_CHANGED));
+            Preconditions.checkNotNull(context);
+            mContext = context.getApplicationContext();
+            if (mContext != null) {
+                mContext.registerReceiver(this,
+                        new IntentFilter(Intent.ACTION_CONFIGURATION_CHANGED));
+            }
         }
 
         public void unregister() {
@@ -1015,51 +1031,19 @@ void handleSetOrientationProperties(final boolean allowOrientationChange,
      * corresponding application, and all other links in the MoPub in-app browser.
      */
     @VisibleForTesting
-    void handleOpen(@NonNull String url) {
-        MoPubLog.d("Opening url: " + url);
-
+    void handleOpen(@NonNull final String url) {
         if (mMraidListener != null) {
             mMraidListener.onOpen();
         }
 
-        // MoPubNativeBrowser URLs
-        if (Intents.isNativeBrowserScheme(url)) {
-            try {
-                final Intent intent = Intents.intentForNativeBrowserScheme(url);
-                Intents.startActivity(mContext, intent);
-            } catch (UrlParseException e) {
-                MoPubLog.d("Unable to load mopub native browser url: " + url + ". "
-                        + e.getMessage());
-            } catch (IntentNotResolvableException e) {
-                MoPubLog.d("Unable to load mopub native browser url: " + url + ". "
-                        + e.getMessage());
-            }
-
-            return;
-        }
-
-        // Non-http(s) URLs
-        if (!Intents.isHttpUrl(url) && Intents.canHandleApplicationUrl(mContext, url)) {
-            Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
-
-            try {
-                Intents.startActivity(mContext, intent);
-            } catch (IntentNotResolvableException e) {
-                MoPubLog.d("Unable to resolve application url: " + url);
-            }
-
-            return;
-        }
-
-        final Bundle extras = new Bundle();
-        extras.putString(MoPubBrowser.DESTINATION_URL_KEY, url);
-
-        final Intent intent = Intents.getStartActivityIntent(mContext, MoPubBrowser.class, extras);
-        try {
-            Intents.startActivity(mContext, intent);
-        } catch (IntentNotResolvableException e) {
-            MoPubLog.d("Unable to launch intent for URL: " + url +  ".");
-        }
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(
+                        UrlAction.IGNORE_ABOUT_SCHEME,
+                        UrlAction.OPEN_NATIVE_BROWSER,
+                        UrlAction.OPEN_IN_APP_BROWSER,
+                        UrlAction.HANDLE_SHARE_TWEET,
+                        UrlAction.FOLLOW_DEEP_LINK)
+                .build().handleUrl(mContext, url);
     }
 
     @VisibleForTesting
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/AdapterHelper.java b/mopub-sdk/src/main/java/com/mopub/nativeads/AdapterHelper.java
index 765cf167..28bd5620 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/AdapterHelper.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/AdapterHelper.java
@@ -8,7 +8,6 @@
 import android.view.ViewGroup;
 
 import com.mopub.common.Preconditions;
-import com.mopub.common.Preconditions.NoThrow;
 import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
 
@@ -44,8 +43,8 @@ public AdapterHelper(@NonNull final Context context, final int start, final int
     @NonNull
     public View getAdView(@Nullable final View convertView,
             @Nullable final ViewGroup parent,
-            @NonNull final NativeResponse nativeResponse,
-            @NonNull final ViewBinder viewBinder,
+            @Nullable final NativeResponse nativeResponse,
+            @Nullable final ViewBinder viewBinder,
             @Nullable @SuppressWarnings("unused") final MoPubNativeListener moPubNativeListener) {
         final Activity activity = mActivity.get();
         if (activity == null) {
@@ -54,11 +53,6 @@ public View getAdView(@Nullable final View convertView,
             return new View(mApplicationContext);
         }
 
-        if (!NoThrow.checkNotNull(nativeResponse, "NativeResponse is null. Returning an empty view")
-                || !NoThrow.checkNotNull(viewBinder, "ViewBinder is null. Returning empty view")) {
-            return new View(activity);
-        }
-
         return NativeAdViewHelper.getAdView(
                 convertView,
                 parent,
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ClickDestinationResolutionListener.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ClickDestinationResolutionListener.java
index 2d1fdcb6..8c5961c1 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/ClickDestinationResolutionListener.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/ClickDestinationResolutionListener.java
@@ -1,15 +1,11 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
-import android.content.Intent;
-import android.net.Uri;
 import android.support.annotation.NonNull;
 
-import com.mopub.common.MoPubBrowser;
+import com.mopub.common.UrlHandler;
+import com.mopub.common.UrlAction;
 import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.Intents;
-import com.mopub.exceptions.IntentNotResolvableException;
-import com.mopub.exceptions.UrlParseException;
 
 import java.lang.ref.WeakReference;
 import java.util.Iterator;
@@ -36,53 +32,31 @@ public ClickDestinationResolutionListener(@NonNull final Context context,
      */
     @Override
     public void onSuccess(@NonNull final String resolvedUrl) {
-        // Handle MoPubNativeBrowser schemes
-        if (Intents.isNativeBrowserScheme(resolvedUrl)) {
-            try {
-                final Intent intent = Intents.intentForNativeBrowserScheme(resolvedUrl);
-                Intents.startActivity(mContext, intent);
-                removeSpinningProgressView();
-                return;
-            } catch (UrlParseException e) {
-                MoPubLog.d(e.getMessage());
-            } catch (IntentNotResolvableException e) {
-                MoPubLog.d("Could not handle intent for URI: " + resolvedUrl);
-            }
-
-            if (mUrlIterator.hasNext()) {
-                UrlResolutionTask.getResolvedUrl(mUrlIterator.next(), this);
-            } else {
-                removeSpinningProgressView();
-            }
-            return;
-        }
-
-        // Handle Android deeplinks
-        if (Intents.isDeepLink(resolvedUrl)) {
-            final Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(resolvedUrl));
-
-            // Open another Android app from the deep link
-            if (Intents.deviceCanHandleIntent(mContext, intent)) {
-                try {
-                    Intents.startActivity(mContext, intent);
-                    return;
-                } catch (IntentNotResolvableException e) {
-                    MoPubLog.d("Could not handle intent with URI: " + resolvedUrl);
-                } finally {
-                    removeSpinningProgressView();
-                }
-            }
-
-            if (mUrlIterator.hasNext()) {
-                UrlResolutionTask.getResolvedUrl(mUrlIterator.next(), this);
-            } else {
-                removeSpinningProgressView();
-            }
-            return;
-        }
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(
+                        UrlAction.IGNORE_ABOUT_SCHEME,
+                        UrlAction.OPEN_NATIVE_BROWSER,
+                        UrlAction.OPEN_APP_MARKET,
+                        UrlAction.OPEN_IN_APP_BROWSER,
+                        UrlAction.HANDLE_SHARE_TWEET,
+                        UrlAction.FOLLOW_DEEP_LINK)
+                .withResultActions(new UrlHandler.ResultActions() {
+                    @Override
+                    public void urlHandlingSucceeded(@NonNull String url,
+                            @NonNull UrlAction urlAction) {
+                    }
 
+                    @Override
+                    public void urlHandlingFailed(@NonNull String url,
+                            @NonNull UrlAction lastFailedUrlAction) {
+                        if (mUrlIterator.hasNext()) {
+                            UrlResolutionTask.getResolvedUrl(mUrlIterator.next(),
+                                    ClickDestinationResolutionListener.this);
+                        }
+                    }
+                })
+                .build().handleUrl(mContext, resolvedUrl);
         removeSpinningProgressView();
-        MoPubBrowser.open(mContext, resolvedUrl);
     }
 
     @Override
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNative.java b/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNative.java
index 51abedc3..8893bd1f 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNative.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNative.java
@@ -6,27 +6,30 @@
 import java.util.Map;
 
 /**
- * CustomEventNative is a base class for custom events that support native ads. By implementing
- * subclasses of CustomEventNative, you can enable the MoPub SDK to support a wider
- * variety of third-party ad networks, or execute any of your application code on demand.
+ * {@code CustomEventNative} is a base class for custom events that support native ads. By
+ * implementing subclasses of {@code CustomEventNative}, you can enable the MoPub SDK to support a
+ * wider variety of third-party ad networks, or execute any of your application code on demand.
  *
- * At runtime, the MoPub SDK will find and instantiate a CustomEventNative subclass as needed
- * and invoke its loadNativeAd() method.
+ * At runtime, the MoPub SDK will find and instantiate a {@code CustomEventNative} subclass as
+ * needed and invoke its {@link #loadNativeAd} method.
  */
 public abstract class CustomEventNative {
     /**
      * When the MoPub SDK receives a response indicating it should load a custom event, it will send
-     * this message to your custom event class. Your implementation of this method can either load
-     * a native ad from a third-party ad network, or execute any application code. It must also
-     * notify the provided CustomEventNativeListener Object of certain lifecycle events.
+     * this message to your custom event class. Your implementation of this method can either load a
+     * native ad from a third-party ad network, or execute any application code. It must also notify
+     * the provided {@link CustomEventNativeListener} Object of certain lifecycle events.
      *
-     * The localExtras parameter is a Map containing additional custom data that is set within
-     * your application by calling MoPubNative.setLocalExtras(Map<String, Object>). Note that the
-     * localExtras Map is a copy of the Map supplied to setLocalExtras().
-     *
-     * The serverExtras parameter is a Map containing additional custom data configurable on the
-     * MoPub website that you want to associate with a given custom event request. This data may be
-     * used to pass dynamic information, such as publisher IDs, without changes in application code.
+     * @param context The activity context.
+     * @param customEventNativeListener An Object that must be notified of certain lifecycle
+     * events.
+     * @param localExtras A Map containing additional custom data that is set within your
+     * application by calling {@link MoPubNative#setLocalExtras(Map<String, Object>)}. Note that the
+     * localExtras Map is a copy of the Map supplied to {@link MoPubNative#setLocalExtras(Map<String,
+     * Object>)}.
+     * @param serverExtras A Map containing additional custom data configurable on the MoPub website
+     * that you want to associate with a given custom event request. This data may be used to pass
+     * dynamic information, such as publisher IDs, without changes in application code.
      */
     protected abstract void loadNativeAd(@NonNull final Context context,
             @NonNull final CustomEventNativeListener customEventNativeListener,
@@ -35,14 +38,16 @@ protected abstract void loadNativeAd(@NonNull final Context context,
 
     public interface ImageListener {
         /**
-         * Called when images are successfully cached. If you haven't already called
-         * {@link CustomEventNativeListener#onNativeAdLoaded}, you should typically do so now.
+         * Called when images are successfully cached. If you haven't already called {@link
+         * CustomEventNativeListener#onNativeAdLoaded}, you should typically do so now.
          */
         void onImagesCached();
 
         /**
-         * Called when images failed to cache. You should typically call
-         * {@link CustomEventNativeListener#onNativeAdFailed} from this callback.
+         * Called when images failed to cache. You should typically call {@link
+         * CustomEventNativeListener#onNativeAdFailed} from this callback.
+         *
+         * @param errorCode An enum value with the relevant error message.
          */
         void onImagesFailedToCache(NativeErrorCode errorCode);
     }
@@ -52,6 +57,8 @@ protected abstract void loadNativeAd(@NonNull final Context context,
          * Your custom event subclass must call this method when it successfully loads a native ad.
          * Failure to do so will disrupt the mediation waterfall and cause future ad requests to
          * stall.
+         *
+         * @param nativeAd The ad that was succesfully loaded.
          */
         void onNativeAdLoaded(NativeAdInterface nativeAd);
 
@@ -59,6 +66,8 @@ protected abstract void loadNativeAd(@NonNull final Context context,
          * Your custom event subclass must call this method when it fails to load a native ad.
          * Failure to do so will disrupt the mediation waterfall and cause future ad requests to
          * stall.
+         *
+         * @param errorCode An enum value with the relevant error message.
          */
         void onNativeAdFailed(NativeErrorCode errorCode);
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdRenderer.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdRenderer.java
index d0f901ef..ac2f0f29 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdRenderer.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdRenderer.java
@@ -11,8 +11,8 @@
  *
  * Normally you will use the subclass {@link com.mopub.nativeads.MoPubNativeAdRenderer} with {@link
  * com.mopub.nativeads.ViewBinder} to customize your ad view with your own layout. However, if you
- * wish to programmatically create or manage your ad view, you can implement {@code
- * }MoPubAdRenderer} directly.
+ * wish to programmatically create or manage your ad view, you can implement {@code MoPubAdRenderer}
+ * directly.
  *
  * @param <T> The ad payload type.
  */
@@ -21,12 +21,12 @@
      * Creates a new view to be used as an ad.
      *
      * This method is called when you call {@link com.mopub.nativeads.MoPubStreamAdPlacer#getAdView}
-     * when the convertView is null. You must return a valid view.
+     * and the convertView is null. You must return a valid view.
      *
+     * @param context The context. Useful for creating a view.
      * @param parent The parent that the view will eventually be attached to. You might use the
      * parent to determine layout parameters, but should return the view without attaching it to the
      * parent.
-     * @param context The context. Useful for creating a view.
      * @return A new ad view.
      */
     View createAdView(@NonNull Context context, @Nullable ViewGroup parent);
@@ -34,7 +34,7 @@
     /**
      * Renders a view created by {@link #createAdView} by filling it with ad data.
      *
-     * @param view The ad View
+     * @param view The ad {@link View}
      * @param ad The ad data that should be bound to the view.
      */
     void renderAdView(@NonNull View view, @NonNull T ad);
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubCustomEventNative.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubCustomEventNative.java
index 7340057b..6c71875d 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubCustomEventNative.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubCustomEventNative.java
@@ -48,7 +48,6 @@ protected void loadNativeAd(@NonNull final Context context,
             moPubForwardingNativeAd.loadAd();
         } catch (IllegalArgumentException e) {
             customEventNativeListener.onNativeAdFailed(NativeErrorCode.UNSPECIFIED);
-            MoPubEvents.log(new ErrorEvent.Builder("","").withException(e).build());
         }
     }
 
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNative.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNative.java
index 5d3ab539..04123976 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNative.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNative.java
@@ -12,6 +12,7 @@
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.util.DeviceUtils;
 import com.mopub.common.util.ManifestUtils;
+import com.mopub.mobileads.MoPubErrorCode;
 import com.mopub.network.AdRequest;
 import com.mopub.network.AdResponse;
 import com.mopub.network.MoPubNetworkError;
@@ -211,7 +212,7 @@ void requestNativeAd(@Nullable final String endpointUrl) {
             return;
         }
 
-        mNativeRequest = new AdRequest(endpointUrl, AdFormat.NATIVE, mAdUnitId, mVolleyListener);
+        mNativeRequest = new AdRequest(endpointUrl, AdFormat.NATIVE, mAdUnitId, context, mVolleyListener);
         RequestQueue requestQueue = Networking.getRequestQueue(context);
         requestQueue.add(mNativeRequest);
     }
@@ -266,6 +267,11 @@ void onAdError(@NonNull final VolleyError volleyError) {
                     mMoPubNativeNetworkListener.onNativeFail(INVALID_JSON);
                     return;
                 case WARMING_UP:
+                    // Used for the sample app to signal a toast.
+                    // This is not customer-facing except in the sample app.
+                    MoPubLog.c(MoPubErrorCode.WARMUP.toString());
+                    mMoPubNativeNetworkListener.onNativeFail(EMPTY_AD_RESPONSE);
+                    return;
                 case NO_FILL:
                     mMoPubNativeNetworkListener.onNativeFail(EMPTY_AD_RESPONSE);
                     return;
@@ -279,6 +285,9 @@ void onAdError(@NonNull final VolleyError volleyError) {
             NetworkResponse response = volleyError.networkResponse;
             if (response != null && response.statusCode >= 500 && response.statusCode < 600) {
                 mMoPubNativeNetworkListener.onNativeFail(SERVER_ERROR_RESPONSE_CODE);
+            } else if (response == null && !DeviceUtils.isNetworkAvailable(mContext.get())) {
+                MoPubLog.c(String.valueOf(MoPubErrorCode.NO_CONNECTION.toString()));
+                mMoPubNativeNetworkListener.onNativeFail(CONNECTION_ERROR);
             } else {
                 mMoPubNativeNetworkListener.onNativeFail(UNSPECIFIED);
             }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubStreamAdPlacer.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubStreamAdPlacer.java
index 316041ac..e89f5d88 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubStreamAdPlacer.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubStreamAdPlacer.java
@@ -21,7 +21,7 @@
 import java.util.WeakHashMap;
 
 /**
- * @code MoPubStreamAdPlacer facilitates loading ads and placing them into a content stream.
+ * {@code MoPubStreamAdPlacer} facilitates loading ads and placing them into a content stream.
  *
  * If you are inserting ads into a ListView, we recommend that you use a {@link MoPubAdAdapter}
  * instead of this class.
@@ -214,7 +214,7 @@ public void loadAds(@NonNull final String adUnitId) {
     /**
      * Start loading ads from the MoPub server, using the given request targeting information.
      *
-     * When loading ads, use {@link MoPubNativeAdLoadedListener#onAdLoaded(int)} will be called for
+     * When loading ads, {@link MoPubNativeAdLoadedListener#onAdLoaded(int)} will be called for
      * each ad that is added to the stream.
      *
      * To refresh ads in your stream, call {@code loadAds} again. When new ads load, they will
@@ -306,7 +306,7 @@ private void placeInitialAds(PlacementData placementData) {
      * Inserts ads that should appear in the given range.
      *
      * By default, the ad placer will place ads withing the first 10 positions in your stream,
-     * according the positions you've specified. You can should use this method as your user scrolls
+     * according to the positions you've specified. You can use this method as your user scrolls
      * through your stream to place ads into the currently visible range.
      *
      * This method takes advantage of a short-lived in memory ad cache, and will immediately place
@@ -393,7 +393,7 @@ public Object getAdData(final int position) {
      * This method will attempt to reuse the convertView if it is not {@code null}, and will
      * otherwise create it. See {@link MoPubAdRenderer#createAdView(Context, ViewGroup)}.
      *
-     * @param position The position where to place an ad.
+     * @param position The position to place an ad into.
      * @param convertView A recycled view into which to render data, or {@code null}.
      * @param parent The parent that the view will eventually be attached to.
      * @return The newly placed ad view.
@@ -428,11 +428,11 @@ public View getAdView(final int position, @Nullable final View convertView,
     }
 
     /**
-     * Removes ads in the given range from [startRange, endRange).
+     * Removes ads in the given range from [originalStartPosition, originalEndPosition).
      *
-     * @param originalStartPosition The start position to clear, expressed as the original content
+     * @param originalStartPosition The start position to clear (inclusive), expressed as the original content
      * position before ads were inserted.
-     * @param originalEndPosition The position after end position to clear, expressed as the
+     * @param originalEndPosition The position after end position to clear (exclusive), expressed as the
      * original content position before ads were inserted.
      * @return The number of ads removed.
      */
@@ -547,8 +547,7 @@ public int getAdjustedCount(final int originalCount) {
      *
      * You must call this method so that the placer knows where valid positions are to place ads.
      * After calling this method, the ad placer will call {@link
-     * MoPubNativeAdLoadedListener#onAdLoaded
-     * (int)} each time an ad is loaded in the stream.
+     * MoPubNativeAdLoadedListener#onAdLoaded (int)} each time an ad is loaded in the stream.
      *
      * @param originalCount The original number of items.
      */
@@ -573,7 +572,7 @@ public void setItemCount(final int originalCount) {
      *
      * and you insert an item at position 2, your new stream will look like:
      *
-     * {@code Item0 Ad Item1 Item2 New Item Ad Item3}
+     * {@code Item0 Ad Item1 Item2 NewItem Ad Item3}
      *
      * @param originalPosition The position at which to add an item. If you have an adjusted
      * position, you will need to call {@link #getOriginalPosition} to get this value.
@@ -609,6 +608,14 @@ public void removeItem(final int originalPosition) {
      * Use this method if you are moving an item in your stream and want to have ad positions move
      * as well.
      *
+     * For example if your stream looks like:
+     *
+     * {@code Item0 Ad Item1 Item2 Ad Item3}
+     *
+     * and you move item at position 2 to position 3, your new stream will look like:
+     *
+     * {@code Item0 Ad Item1 Ad Item3 Item2}
+     *
      * @param originalPosition The position from which to move an item. If you have an adjusted
      * position, you will need to call {@link #getOriginalPosition} to get this value.
      * @param newPosition The new position, also expressed in terms of the original position.
@@ -644,8 +651,12 @@ private void placeAds() {
     }
 
     /**
-     * Attempts to place ads in the range (start, end], returning false if there is no ad available
+     * Attempts to place ads in the range [start, end], returning false if there is no ad available
      * to be placed.
+     *
+     * @param start The start of the range in which to place ads, inclusive.
+     * @param end The end of the range in which to place ads, exclusive.
+     * @return false if there is no ad available to be placed.
      */
     private boolean tryPlaceAdsInRange(final int start, final int end) {
         int position = start;
@@ -668,6 +679,9 @@ private boolean tryPlaceAdsInRange(final int start, final int end) {
     /**
      * Attempts to place an ad at the given position, returning false if there is no ad available to
      * be placed.
+     *
+     * @param position The position to place the ad at.
+     * @return false if there is no ad available to be placed.
      */
     private boolean tryPlaceAd(final int position) {
         final NativeResponse adResponse = mAdSource.dequeueAd();
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdViewHelper.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdViewHelper.java
index 496e89af..2f1c838c 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdViewHelper.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdViewHelper.java
@@ -6,14 +6,12 @@
 import android.view.View;
 import android.view.ViewGroup;
 
+import com.mopub.common.Preconditions;
 import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
 
 import java.util.WeakHashMap;
 
-import static android.view.View.GONE;
-import static com.mopub.nativeads.MoPubNative.MoPubNativeListener;
-
 /**
  * @deprecated As of release 2.4, use {@link com.mopub.nativeads.MoPubNativeAdRenderer} instead
  */
@@ -22,6 +20,12 @@
     private NativeAdViewHelper() {
     }
 
+    @VisibleForTesting
+    enum ViewType {
+        EMPTY,
+        AD
+    }
+
     // Because the impression tracker requires tracking drawing views,
     // each context requires a separate impression tracker. To avoid leaking, keep weak references.
     @VisibleForTesting
@@ -38,20 +42,30 @@ private NativeAdViewHelper() {
     static View getAdView(@Nullable View convertView,
             @Nullable final ViewGroup parent,
             @NonNull final Context context,
-            @NonNull final NativeResponse nativeResponse,
-            @NonNull final ViewBinder viewBinder) {
+            @Nullable final NativeResponse nativeResponse,
+            @Nullable final ViewBinder viewBinder) {
 
-        final MoPubNativeAdRenderer moPubNativeAdRenderer = new MoPubNativeAdRenderer(viewBinder);
-        if (convertView == null) {
-            convertView = moPubNativeAdRenderer.createAdView(context, parent);
-        }
+        Preconditions.NoThrow.checkNotNull(viewBinder, "ViewBinder is null.");
 
-        clearNativeResponse(context, convertView);
+        if (convertView != null) {
+            clearNativeResponse(context, convertView);
+        }
 
-        if (nativeResponse.isDestroyed()) {
-            MoPubLog.d("NativeResponse is destroyed, returning hidden view.");
-            convertView.setVisibility(GONE);
+        if (nativeResponse == null || nativeResponse.isDestroyed() || viewBinder == null) {
+            MoPubLog.d("nativeResponse or viewBinder null or invalid. Returning empty view");
+            // Only create a view if one hasn't been created already
+            if (convertView == null || !ViewType.EMPTY.equals(convertView.getTag())) {
+                convertView = new View(context);
+                convertView.setTag(ViewType.EMPTY);
+                convertView.setVisibility(View.GONE);
+            }
         } else {
+            final MoPubNativeAdRenderer moPubNativeAdRenderer = new MoPubNativeAdRenderer(viewBinder);
+            // Only create a view if one hasn't been created already
+            if (convertView == null || !ViewType.AD.equals(convertView.getTag())) {
+                convertView = moPubNativeAdRenderer.createAdView(context, parent);
+                convertView.setTag(ViewType.AD);
+            }
             prepareNativeResponse(context, convertView, nativeResponse);
             moPubNativeAdRenderer.renderAdView(convertView, nativeResponse);
         }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeResponse.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeResponse.java
index 97d4a693..e332c6cf 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeResponse.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeResponse.java
@@ -8,7 +8,7 @@
 import android.widget.ImageView;
 
 import com.mopub.common.VisibleForTesting;
-import com.mopub.common.event.MoPubEvents;
+import com.mopub.common.event.BaseEvent;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.nativeads.MoPubNative.MoPubNativeEventListener;
 import com.mopub.network.Networking;
@@ -245,7 +245,7 @@ public void recordImpression(@Nullable final View view) {
 
         for (final String impressionTracker : getImpressionTrackers()) {
             TrackingRequest.makeTrackingHttpRequest(
-                    impressionTracker, mContext, MoPubEvents.Type.IMPRESSION_REQUEST);
+                    impressionTracker, mContext, BaseEvent.Name.IMPRESSION_REQUEST);
         }
 
         mNativeAd.recordImpression();
@@ -261,7 +261,7 @@ public void handleClick(@Nullable final View view) {
 
         if (!isClicked()) {
             TrackingRequest.makeTrackingHttpRequest(
-                    mMoPubClickTracker, mContext, MoPubEvents.Type.CLICK_REQUEST);
+                    mMoPubClickTracker, mContext, BaseEvent.Name.CLICK_REQUEST);
         }
 
         openClickDestinationUrl(view);
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeUrlGenerator.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeUrlGenerator.java
index 201d865a..bb9e97b1 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeUrlGenerator.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeUrlGenerator.java
@@ -1,7 +1,6 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
-import android.location.Location;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
@@ -9,9 +8,6 @@
 import com.mopub.common.AdUrlGenerator;
 import com.mopub.common.ClientMetadata;
 import com.mopub.common.Constants;
-import com.mopub.common.LocationService;
-import com.mopub.common.MoPub;
-import com.mopub.common.util.DateAndTime;
 
 class NativeUrlGenerator extends AdUrlGenerator {
     @Nullable private String mDesiredAssets;
@@ -48,42 +44,13 @@ NativeUrlGenerator withSequenceNumber(final int sequenceNumber) {
     public String generateUrlString(final String serverHostname) {
         initUrlString(serverHostname, Constants.AD_HANDLER);
 
-        setAdUnitId(mAdUnitId);
-
-        setKeywords(mKeywords);
-
-        setLocation(mLocation);
-
         ClientMetadata clientMetadata = ClientMetadata.getInstance(mContext);
-        setSdkVersion(clientMetadata.getSdkVersion());
-
-        setDeviceInfo(clientMetadata.getDeviceManufacturer(),
-                clientMetadata.getDeviceModel(),
-                clientMetadata.getDeviceProduct());
-
-        setTimezone(DateAndTime.getTimeZoneOffsetString());
-
-        setOrientation(clientMetadata.getOrientationString());
-
-        setDensity(clientMetadata.getDensity());
-
-        String networkOperator = clientMetadata.getNetworkOperatorForUrl();
-        setMccCode(networkOperator);
-        setMncCode(networkOperator);
-
-        setIsoCountryCode(clientMetadata.getIsoCountryCode());
-        setCarrierName(clientMetadata.getNetworkOperatorName());
-
-        setNetworkType(clientMetadata.getActiveNetworkType());
-
-        setAppVersion(clientMetadata.getAppVersion());
+        addBaseParams(clientMetadata);
 
         setDesiredAssets();
 
         setSequenceNumber();
 
-        appendAdvertisingInfoTemplates();
-
         return getFinalUrlString();
     }
 
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ServerPositioningSource.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ServerPositioningSource.java
index ef207c4d..4d4658cb 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/ServerPositioningSource.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/ServerPositioningSource.java
@@ -8,6 +8,8 @@
 import com.mopub.common.Constants;
 import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.DeviceUtils;
+import com.mopub.mobileads.MoPubErrorCode;
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
 import com.mopub.network.MoPubNetworkError;
 import com.mopub.network.Networking;
@@ -88,6 +90,9 @@ public void onErrorResponse(final VolleyError error) {
                 if (!(error instanceof MoPubNetworkError) ||
                         ((MoPubNetworkError) error).getReason().equals(MoPubNetworkError.Reason.WARMING_UP)) {
                     MoPubLog.e("Failed to load positioning data", error);
+                    if (error.networkResponse == null && !DeviceUtils.isNetworkAvailable(mContext)) {
+                        MoPubLog.c(String.valueOf(MoPubErrorCode.NO_CONNECTION.toString()));
+                    }
                 }
 
                 handleFailure();
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/UrlResolutionTask.java b/mopub-sdk/src/main/java/com/mopub/nativeads/UrlResolutionTask.java
index 9c690202..369653a8 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/UrlResolutionTask.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/UrlResolutionTask.java
@@ -1,12 +1,13 @@
 package com.mopub.nativeads;
 
+import android.net.Uri;
 import android.os.AsyncTask;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 
+import com.mopub.common.UrlAction;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.util.AsyncTasks;
-import com.mopub.common.util.Intents;
 
 import java.io.IOException;
 import java.net.HttpURLConnection;
@@ -54,7 +55,7 @@ protected String doInBackground(@Nullable String... urls) {
             while (locationUrl != null && redirectCount < REDIRECT_LIMIT) {
                 // if location url is not http(s), assume it's an Android deep link
                 // this scheme will fail URL validation so we have to check early
-                if (!Intents.isHttpUrl(locationUrl)) {
+                if (!UrlAction.OPEN_IN_APP_BROWSER.shouldTryHandlingUrl(Uri.parse(locationUrl))) {
                     return locationUrl;
                 }
 
diff --git a/mopub-sdk/src/main/java/com/mopub/network/AdRequest.java b/mopub-sdk/src/main/java/com/mopub/network/AdRequest.java
index 88e78321..53fdbc30 100644
--- a/mopub-sdk/src/main/java/com/mopub/network/AdRequest.java
+++ b/mopub-sdk/src/main/java/com/mopub/network/AdRequest.java
@@ -1,5 +1,8 @@
 package com.mopub.network;
 
+import android.content.Context;
+import android.location.Location;
+import android.net.Uri;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
@@ -7,7 +10,14 @@
 import com.mopub.common.AdFormat;
 import com.mopub.common.AdType;
 import com.mopub.common.DataKeys;
+import com.mopub.common.LocationService;
+import com.mopub.common.MoPub;
 import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.event.BaseEvent;
+import com.mopub.common.event.Event;
+import com.mopub.common.event.MoPubEvents;
+import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.util.Json;
 import com.mopub.common.util.ResponseHeader;
 import com.mopub.mobileads.AdTypeTranslator;
@@ -21,6 +31,7 @@
 import org.json.JSONObject;
 
 import java.io.UnsupportedEncodingException;
+import java.util.Locale;
 import java.util.Map;
 import java.util.TreeMap;
 
@@ -33,12 +44,16 @@
     @NonNull private final AdRequest.Listener mListener;
     @NonNull private final AdFormat mAdFormat;
     @Nullable private final String mAdUnitId;
+    @NonNull private final Context mContext;
 
     public interface Listener extends Response.ErrorListener {
         public void onSuccess(AdResponse response);
     }
 
-    public AdRequest(@NonNull final String url, @NonNull final AdFormat adFormat, @Nullable final String adUnitId,
+    public AdRequest(@NonNull final String url,
+            @NonNull final AdFormat adFormat,
+            @Nullable final String adUnitId,
+            @NonNull Context context,
             @NonNull final Listener listener) {
         super(Method.GET, url, listener);
         Preconditions.checkNotNull(adFormat);
@@ -46,6 +61,7 @@ public AdRequest(@NonNull final String url, @NonNull final AdFormat adFormat, @N
         mAdUnitId = adUnitId;
         mListener = listener;
         mAdFormat = adFormat;
+        mContext = context.getApplicationContext();
         DefaultRetryPolicy retryPolicy = new DefaultRetryPolicy(
                 DefaultRetryPolicy.DEFAULT_TIMEOUT_MS,
                 DefaultRetryPolicy.DEFAULT_MAX_RETRIES,
@@ -59,6 +75,29 @@ public Listener getListener() {
         return mListener;
     }
 
+    @Override
+    public Map<String, String> getHeaders() {
+        TreeMap<String, String> headers = new TreeMap<String, String>();
+
+        // Use default locale first for language code
+        String languageCode = Locale.getDefault().getLanguage();
+
+        // If user's preferred locale is different from default locale, override language code
+        Locale userLocale = mContext.getResources().getConfiguration().locale;
+        if (userLocale != null) {
+            if (! userLocale.getLanguage().trim().isEmpty()) {
+                languageCode = userLocale.getLanguage().trim();
+            }
+        }
+
+        // Do not add header if language is empty
+        if (! languageCode.isEmpty()) {
+            headers.put(ResponseHeader.ACCEPT_LANGUAGE.getKey(), languageCode);
+        }
+
+        return headers;
+    }
+
     @Override
     protected Response<AdResponse> parseNetworkResponse(final NetworkResponse networkResponse) {
         // NOTE: We never get status codes outside of {[200, 299], 304}. Those errors are sent to the
@@ -70,38 +109,65 @@ public Listener getListener() {
         }
 
 
+        Location location = LocationService.getLastKnownLocation(mContext,
+                MoPub.getLocationPrecision(),
+                MoPub.getLocationAwareness());
 
         AdResponse.Builder builder = new AdResponse.Builder();
         builder.setAdUnitId(mAdUnitId);
 
         String adTypeString = extractHeader(headers, ResponseHeader.AD_TYPE);
         String fullAdTypeString = extractHeader(headers, ResponseHeader.FULL_AD_TYPE);
-
         builder.setAdType(adTypeString);
         builder.setFullAdType(fullAdTypeString);
+
+        // In the case of a CLEAR response, the REFRESH_TIME header must still be respected. Ensure
+        // that it is parsed and passed along to the MoPubNetworkError.
+        final Integer refreshTimeSeconds = extractIntegerHeader(headers, ResponseHeader.REFRESH_TIME);
+        final Integer refreshTimeMilliseconds = refreshTimeSeconds == null
+                ? null
+                : refreshTimeSeconds * 1000;
+        builder.setRefreshTimeMilliseconds(refreshTimeMilliseconds);
+
         if (AdType.CLEAR.equals(adTypeString)) {
-            return Response.error(new MoPubNetworkError("No ads found for ad unit.", MoPubNetworkError.Reason.NO_FILL));
+            final AdResponse adResponse = builder.build();
+            logScribeEvent(adResponse, networkResponse, location);
+            return Response.error(
+                    new MoPubNetworkError(
+                            "No ads found for ad unit.",
+                            MoPubNetworkError.Reason.NO_FILL,
+                            refreshTimeMilliseconds
+                    )
+            );
         }
 
         builder.setNetworkType(extractHeader(headers, ResponseHeader.NETWORK_TYPE));
+
         String redirectUrl = extractHeader(headers, ResponseHeader.REDIRECT_URL);
         builder.setRedirectUrl(redirectUrl);
+
         String clickTrackingUrl = extractHeader(headers, ResponseHeader.CLICK_TRACKING_URL);
         builder.setClickTrackingUrl(clickTrackingUrl);
+
         builder.setImpressionTrackingUrl(extractHeader(headers, ResponseHeader.IMPRESSION_URL));
-        builder.setFailoverUrl(extractHeader(headers, ResponseHeader.FAIL_URL));
+
+        String failUrl = extractHeader(headers, ResponseHeader.FAIL_URL);
+        builder.setFailoverUrl(failUrl);
+
+        String requestId = getRequestId(failUrl);
+        builder.setRequestId(requestId);
+
         boolean isScrollable = extractBooleanHeader(headers, ResponseHeader.SCROLLABLE, false);
         builder.setScrollable(isScrollable);
+
         builder.setDimensions(extractIntegerHeader(headers, ResponseHeader.WIDTH),
                 extractIntegerHeader(headers, ResponseHeader.HEIGHT));
 
         Integer adTimeoutDelaySeconds = extractIntegerHeader(headers, ResponseHeader.AD_TIMEOUT);
         builder.setAdTimeoutDelayMilliseconds(
-                adTimeoutDelaySeconds == null ? null : adTimeoutDelaySeconds * 1000);
-
-        Integer refreshTimeSeconds = extractIntegerHeader(headers, ResponseHeader.REFRESH_TIME);
-        builder.setRefreshTimeMilliseconds(
-                refreshTimeSeconds == null ? null : refreshTimeSeconds * 1000);
+                adTimeoutDelaySeconds == null
+                        ? null
+                        : adTimeoutDelaySeconds * 1000);
 
         // Response Body encoding / decoding
         String responseBody = parseStringBody(networkResponse);
@@ -141,6 +207,7 @@ public Listener getListener() {
             Map<String, String> eventDataMap = new TreeMap<String, String>();
             eventDataMap.put(DataKeys.HTML_RESPONSE_BODY_KEY, responseBody);
             eventDataMap.put(DataKeys.SCROLLABLE_KEY, Boolean.toString(isScrollable));
+            eventDataMap.put(DataKeys.CREATIVE_ORIENTATION_KEY, extractHeader(headers, ResponseHeader.ORIENTATION));
             if (redirectUrl != null) {
                 eventDataMap.put(DataKeys.REDIRECT_URL_KEY, redirectUrl);
             }
@@ -150,6 +217,9 @@ public Listener getListener() {
             builder.setServerExtras(eventDataMap);
         }
 
+        AdResponse adResponse = builder.build();
+        logScribeEvent(adResponse, networkResponse, location);
+
         return Response.success(builder.build(),  // Cast needed for Response generic.
                 HttpHeaderParser.parseCacheHeaders(networkResponse));
     }
@@ -175,4 +245,52 @@ protected String parseStringBody(NetworkResponse response) {
     protected void deliverResponse(final AdResponse adResponse) {
         mListener.onSuccess(adResponse);
     }
+
+    @Nullable
+    @VisibleForTesting
+    String getRequestId(@Nullable String failUrl) {
+        if (failUrl == null) {
+            return null;
+        }
+
+        String requestId = null;
+        Uri uri = Uri.parse(failUrl);
+        try {
+            requestId = uri.getQueryParameter("request_id");
+        } catch (UnsupportedOperationException e) {
+            MoPubLog.d("Unable to obtain request id from fail url.");
+        }
+
+        return requestId;
+    }
+
+    @VisibleForTesting
+    void logScribeEvent(@NonNull AdResponse adResponse, @NonNull NetworkResponse networkResponse,
+            @Nullable Location location) {
+        Preconditions.checkNotNull(adResponse);
+        Preconditions.checkNotNull(networkResponse);
+
+        MoPubEvents.log(
+                new Event.Builder(BaseEvent.Name.AD_REQUEST, BaseEvent.Category.REQUESTS,
+                        BaseEvent.SamplingRate.AD_REQUEST.getSamplingRate())
+                        .withAdUnitId(mAdUnitId)
+                        .withAdCreativeId(adResponse.getDspCreativeId())
+                        .withAdType(adResponse.getAdType())
+                        .withAdNetworkType(adResponse.getNetworkType())
+                        .withAdWidthPx(adResponse.getWidth() != null
+                                ? adResponse.getWidth().doubleValue()
+                                : null)
+                        .withAdHeightPx(adResponse.getHeight() != null
+                                ? adResponse.getHeight().doubleValue()
+                                : null)
+                        .withGeoLat(location != null ? location.getLatitude() : null)
+                        .withGeoLon(location != null ? location.getLongitude() : null)
+                        .withGeoAccuracy(location != null ? (double) location.getAccuracy() : null)
+                        .withPerformanceDurationMs((double) networkResponse.networkTimeMs)
+                        .withRequestId(adResponse.getRequestId())
+                        .withRequestStatusCode(networkResponse.statusCode)
+                        .withRequestUri(getUrl())
+                        .build()
+        );
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/network/AdResponse.java b/mopub-sdk/src/main/java/com/mopub/network/AdResponse.java
index d6cf0b57..8c7bc330 100644
--- a/mopub-sdk/src/main/java/com/mopub/network/AdResponse.java
+++ b/mopub-sdk/src/main/java/com/mopub/network/AdResponse.java
@@ -33,6 +33,8 @@
     private final String mImpressionTrackingUrl;
     @Nullable
     private final String mFailoverUrl;
+    @Nullable
+    private final String mRequestId;
 
     @Nullable
     private final Integer mWidth;
@@ -69,6 +71,7 @@ private AdResponse(@NonNull Builder builder) {
         mClickTrackingUrl = builder.clickTrackingUrl;
         mImpressionTrackingUrl = builder.impressionTrackingUrl;
         mFailoverUrl = builder.failoverUrl;
+        mRequestId = builder.requestId;
         mWidth = builder.width;
         mHeight = builder.height;
         mAdTimeoutDelayMillis = builder.adTimeoutDelayMillis;
@@ -136,6 +139,11 @@ public String getFailoverUrl() {
         return mFailoverUrl;
     }
 
+    @Nullable
+    public String getRequestId() {
+        return mRequestId;
+    }
+
     public boolean isScrollable() {
         return mScrollable;
     }
@@ -209,6 +217,7 @@ public Builder toBuilder() {
         private String clickTrackingUrl;
         private String impressionTrackingUrl;
         private String failoverUrl;
+        private String requestId;
 
         private Integer width;
         private Integer height;
@@ -264,6 +273,11 @@ public Builder setFailoverUrl(@Nullable final String failoverUrl) {
             return this;
         }
 
+        public Builder setRequestId(@Nullable final String requestId) {
+            this.requestId = requestId;
+            return this;
+        }
+
         public Builder setDimensions(@Nullable final Integer width,
                 @Nullable final Integer height) {
             this.width = width;
diff --git a/mopub-sdk/src/main/java/com/mopub/network/BackoffPolicy.java b/mopub-sdk/src/main/java/com/mopub/network/BackoffPolicy.java
new file mode 100644
index 00000000..fa17fee8
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/BackoffPolicy.java
@@ -0,0 +1,43 @@
+package com.mopub.network;
+
+import com.mopub.volley.VolleyError;
+
+/**
+ * The backoff policy for a request.
+ */
+public abstract class BackoffPolicy {
+    protected int mBackoffMs;
+    protected int mBackoffMultiplier;
+    protected int mDefaultBackoffTimeMs;
+    protected int mMaxBackoffTimeMs;
+    protected int mRetryCount;
+    protected int mMaxRetries;
+
+    /**
+     * Prepares for the next request attempt by updating the backoff time.
+     *
+     * @param volleyError The error code of the last request attempt.
+     */
+    public abstract void backoff(VolleyError volleyError) throws VolleyError;
+
+    /**
+     * Returns the current backoff time in ms.
+     */
+    public int getBackoffMs() {
+        return mBackoffMs;
+    }
+
+    /**
+     * Returns the current retry count.
+     */
+    public int getRetryCount() {
+        return mRetryCount;
+    }
+
+    /**
+     * Returns true if this policy has attempts remaining, false otherwise.
+     */
+    public boolean hasAttemptRemaining() {
+        return mRetryCount < mMaxRetries;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/CustomSSLSocketFactory.java b/mopub-sdk/src/main/java/com/mopub/network/CustomSSLSocketFactory.java
new file mode 100644
index 00000000..21c48ac1
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/CustomSSLSocketFactory.java
@@ -0,0 +1,95 @@
+package com.mopub.network;
+
+import android.net.SSLCertificateSocketFactory;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.Socket;
+import java.net.UnknownHostException;
+
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+
+/**
+ * An {@link javax.net.ssl.SSLSocketFactory} that supports TLS settings for the MoPub ad servers.
+ */
+public class CustomSSLSocketFactory extends SSLSocketFactory {
+
+    private SSLSocketFactory mCertificateSocketFactory;
+
+    private CustomSSLSocketFactory() {}
+
+    public static CustomSSLSocketFactory getDefault(final int handshakeTimeoutMillis) {
+        CustomSSLSocketFactory factory = new CustomSSLSocketFactory();
+        factory.mCertificateSocketFactory = SSLCertificateSocketFactory.getDefault(handshakeTimeoutMillis, null);
+
+        return factory;
+    }
+
+    // Forward all methods. Enable TLS 1.1 and 1.2 before returning.
+
+    // SocketFactory overrides
+    @Override
+    public Socket createSocket() throws IOException {
+        final Socket socket = mCertificateSocketFactory.createSocket();
+        enableTlsIfAvailable(socket);
+        return socket;
+    }
+
+    @Override
+    public Socket createSocket(final String host, final int i) throws IOException, UnknownHostException {
+        final Socket socket = mCertificateSocketFactory.createSocket(host, i);
+        enableTlsIfAvailable(socket);
+        return socket;
+    }
+
+    @Override
+    public Socket createSocket(final String host, final int port, final InetAddress localhost, final int localPort) throws IOException, UnknownHostException {
+        final Socket socket = mCertificateSocketFactory.createSocket(host, port, localhost, localPort);
+        enableTlsIfAvailable(socket);
+        return socket;
+    }
+
+    @Override
+    public Socket createSocket(final InetAddress address, final int port) throws IOException {
+        final Socket socket = mCertificateSocketFactory.createSocket(address, port);
+        enableTlsIfAvailable(socket);
+        return socket;
+    }
+
+    @Override
+    public Socket createSocket(final InetAddress address, final int port, final InetAddress localhost, final int localPort) throws IOException {
+        final Socket socket = mCertificateSocketFactory.createSocket(address, port, localhost, localPort);
+        enableTlsIfAvailable(socket);
+        return socket;
+    }
+
+    // SSLSocketFactory overrides
+
+    @Override
+    public String[] getDefaultCipherSuites() {
+        return mCertificateSocketFactory.getDefaultCipherSuites();
+    }
+
+    @Override
+    public String[] getSupportedCipherSuites() {
+        return mCertificateSocketFactory.getSupportedCipherSuites();
+    }
+
+    @Override
+    public Socket createSocket(final Socket socketParam, final String host, final int port, final boolean autoClose) throws IOException {
+        Socket socket = mCertificateSocketFactory.createSocket(socketParam, host, port, autoClose);
+        enableTlsIfAvailable(socket);
+        return socket;
+    }
+
+    private void enableTlsIfAvailable(Socket socket) {
+        if (socket instanceof SSLSocket) {
+            SSLSocket sslSocket = (SSLSocket) socket;
+            String[] supportedProtocols = sslSocket.getSupportedProtocols();
+            // Make sure all supported protocols are enabled. Android does not enable TLSv1.1 or
+            // TLSv1.2 by default.
+            sslSocket.setEnabledProtocols(supportedProtocols);
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/HeaderUtils.java b/mopub-sdk/src/main/java/com/mopub/network/HeaderUtils.java
index ae1f841d..a4754422 100644
--- a/mopub-sdk/src/main/java/com/mopub/network/HeaderUtils.java
+++ b/mopub-sdk/src/main/java/com/mopub/network/HeaderUtils.java
@@ -12,6 +12,7 @@
 import java.util.Map;
 
 public class HeaderUtils {
+    @Nullable
     public static String extractHeader(Map<String, String> headers, ResponseHeader responseHeader) {
         return headers.get(responseHeader.getKey());
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/network/MoPubNetworkError.java b/mopub-sdk/src/main/java/com/mopub/network/MoPubNetworkError.java
index 9b4f61cb..43becf67 100644
--- a/mopub-sdk/src/main/java/com/mopub/network/MoPubNetworkError.java
+++ b/mopub-sdk/src/main/java/com/mopub/network/MoPubNetworkError.java
@@ -1,12 +1,13 @@
 package com.mopub.network;
 
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 
 import com.mopub.volley.NetworkResponse;
 import com.mopub.volley.VolleyError;
 
 public class MoPubNetworkError extends VolleyError {
-    public static enum Reason {
+    public enum Reason {
         WARMING_UP,
         NO_FILL,
         BAD_HEADER_DATA,
@@ -16,34 +17,50 @@
     }
 
     @NonNull private final Reason mReason;
+    @Nullable private final Integer mRefreshTimeMillis;
 
     public MoPubNetworkError(@NonNull Reason reason) {
         super();
         mReason = reason;
+        mRefreshTimeMillis = null;
     }
 
     public MoPubNetworkError(@NonNull NetworkResponse networkResponse, @NonNull Reason reason) {
         super(networkResponse);
         mReason = reason;
+        mRefreshTimeMillis = null;
     }
 
     public MoPubNetworkError(@NonNull Throwable cause, @NonNull Reason reason) {
         super(cause);
         mReason = reason;
+        mRefreshTimeMillis = null;
     }
 
     public MoPubNetworkError(@NonNull String message, @NonNull Reason reason) {
-        super(message);
-        mReason = reason;
+        this(message, reason, null);
     }
 
     public MoPubNetworkError(@NonNull String message, @NonNull Throwable cause, @NonNull Reason reason) {
         super(message, cause);
         mReason = reason;
+        mRefreshTimeMillis = null;
+    }
+
+    public MoPubNetworkError(@NonNull String message, @NonNull Reason reason,
+            @Nullable Integer refreshTimeMillis) {
+        super(message);
+        mReason = reason;
+        mRefreshTimeMillis = refreshTimeMillis;
     }
 
     @NonNull
     public Reason getReason() {
         return mReason;
     }
+
+    @Nullable
+    public Integer getRefreshTimeMillis() {
+        return mRefreshTimeMillis;
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/network/MoPubRequestQueue.java b/mopub-sdk/src/main/java/com/mopub/network/MoPubRequestQueue.java
new file mode 100644
index 00000000..9b5d4592
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/MoPubRequestQueue.java
@@ -0,0 +1,166 @@
+package com.mopub.network;
+
+import android.os.Handler;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.volley.Cache;
+import com.mopub.volley.Network;
+import com.mopub.volley.Request;
+import com.mopub.volley.RequestQueue;
+import com.mopub.volley.ResponseDelivery;
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+/**
+ * MoPub's custom implementation of the Google Volley RequestQueue.
+ * This subclass provides convenience methods for adding a delayed request to run at a time in
+ * the future. This is useful for our backoff policy architecture.
+ *
+ * We've overridden certain implementation methods but have kept the contract of the
+ * original method consistent.
+ */
+public class MoPubRequestQueue extends RequestQueue {
+
+    private static final int CAPACITY = 10;
+
+    @NonNull
+    private final Map<Request<?>, DelayedRequestHelper> mDelayedRequests;
+
+    MoPubRequestQueue(Cache cache, Network network, int threadPoolSize, ResponseDelivery delivery) {
+        super(cache, network, threadPoolSize, delivery);
+        mDelayedRequests = new HashMap<Request<?>, DelayedRequestHelper>(CAPACITY);
+    }
+
+    MoPubRequestQueue(Cache cache, Network network, int threadPoolSize) {
+        super(cache, network, threadPoolSize);
+        mDelayedRequests = new HashMap<Request<?>, DelayedRequestHelper>(CAPACITY);
+    }
+
+    MoPubRequestQueue(Cache cache, Network network) {
+        super(cache, network);
+        mDelayedRequests = new HashMap<Request<?>, DelayedRequestHelper>(CAPACITY);
+    }
+
+    /**
+     * Convenience method for adding a request with a time delay to the request queue.
+     *
+     * @param request The request.
+     * @param delayMs The delay in ms for adding the request to the request queue.
+     */
+    public void addDelayedRequest(@NonNull Request<?> request, int delayMs) {
+        Preconditions.checkNotNull(request);
+        addDelayedRequest(request, new DelayedRequestHelper(request, delayMs));
+    }
+
+    @VisibleForTesting
+    void addDelayedRequest(@NonNull Request<?> request, @NonNull DelayedRequestHelper delayedRequestHelper) {
+        Preconditions.checkNotNull(delayedRequestHelper);
+
+        if (mDelayedRequests.containsKey(request)) {
+            cancel(request);
+        }
+
+        delayedRequestHelper.start();
+        mDelayedRequests.put(request, delayedRequestHelper);
+    }
+
+    /**
+     * Override of cancelAll method to ensure delayed requests are cancelled as well.
+     */
+    @Override
+    public void cancelAll(@NonNull RequestFilter filter) {
+        Preconditions.checkNotNull(filter);
+
+        super.cancelAll(filter);
+
+        Iterator<Map.Entry<Request<?>, DelayedRequestHelper>> iterator = mDelayedRequests.entrySet().iterator();
+        while (iterator.hasNext()) {
+            Map.Entry<Request<?>, DelayedRequestHelper> entry = iterator.next();
+            if (filter.apply(entry.getKey())) {
+                // Here we cancel both the request and the handler from posting the delayed runnable
+                entry.getKey().cancel();
+                entry.getValue().cancel();
+                iterator.remove();
+            }
+        }
+    }
+
+    /**
+     * Override of cancelAll method to ensure delayed requests are cancelled as well.
+     */
+    @Override
+    public void cancelAll(@NonNull final Object tag) {
+        Preconditions.checkNotNull(tag);
+
+        super.cancelAll(tag);
+
+        cancelAll(new RequestFilter() {
+            @Override
+            public boolean apply(Request<?> request) {
+                return request.getTag() == tag;
+            }
+        });
+    }
+
+    /**
+     * Convenience method to cancel a single request.
+     *
+     * @param request The request to cancel.
+     */
+    public void cancel(@NonNull final Request<?> request) {
+        Preconditions.checkNotNull(request);
+
+        cancelAll(new RequestFilter() {
+            @Override
+            public boolean apply(Request<?> _request) {
+                return request == _request;
+            }
+        });
+    }
+
+    /**
+     * This helper class is used to package the supporting objects a request needs to
+     * run at a delayed time and cancel if needed.
+     */
+    class DelayedRequestHelper {
+        final int mDelayMs;
+        @NonNull final Handler mHandler;
+        @NonNull final Runnable mDelayedRunnable;
+
+        DelayedRequestHelper(@NonNull final Request<?> request, int delayMs) {
+            this(request, delayMs, new Handler());
+        }
+
+        @VisibleForTesting
+        DelayedRequestHelper(@NonNull final Request<?> request, int delayMs, @NonNull Handler handler) {
+            mDelayMs = delayMs;
+            mHandler = handler;
+            mDelayedRunnable = new Runnable() {
+                @Override
+                public void run() {
+                    mDelayedRequests.remove(request);
+                    MoPubRequestQueue.this.add(request);
+                }
+            };
+        }
+
+        void start() {
+            mHandler.postDelayed(mDelayedRunnable, mDelayMs);
+        }
+
+        void cancel() {
+            mHandler.removeCallbacks(mDelayedRunnable);
+        }
+    }
+
+    @NonNull
+    @Deprecated
+    @VisibleForTesting
+    Map<Request<?>, DelayedRequestHelper> getDelayedRequests() {
+        return mDelayedRequests;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/Networking.java b/mopub-sdk/src/main/java/com/mopub/network/Networking.java
index 26df7aa7..ed087c69 100644
--- a/mopub-sdk/src/main/java/com/mopub/network/Networking.java
+++ b/mopub-sdk/src/main/java/com/mopub/network/Networking.java
@@ -4,10 +4,12 @@
 import android.graphics.Bitmap;
 import android.os.Looper;
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.support.v4.util.LruCache;
 import android.webkit.WebView;
 
 import com.mopub.common.ClientMetadata;
+import com.mopub.common.Constants;
 import com.mopub.common.Preconditions;
 import com.mopub.common.VisibleForTesting;
 import com.mopub.common.util.DeviceUtils;
@@ -22,36 +24,50 @@
 
 import java.io.File;
 
+import javax.net.ssl.SSLSocketFactory;
+
 public class Networking {
-    private static final String CACHE_DIRECTORY_NAME = "mopub-volley-cache";
-    private static final int TEN_MB = 10 * 1024 * 1024;
+    @VisibleForTesting
+    static final String CACHE_DIRECTORY_NAME = "mopub-volley-cache";
+
 
-    private static RequestQueue sRequestQueue;
-    private static String sUserAgent;
-    private static MaxWidthImageLoader sMaxWidthImageLoader;
+    // These are volatile so that double-checked locking works.
+    // See http://en.wikipedia.org/wiki/Double-checked_locking#Usage_in_Java
+    // for more information.
+    private volatile static MoPubRequestQueue sRequestQueue;
+    private volatile static String sUserAgent;
+    private volatile static MaxWidthImageLoader sMaxWidthImageLoader;
+    public static boolean sUseHttps = false;
+
+    @Nullable
+    public static MoPubRequestQueue getRequestQueue() {
+        return sRequestQueue;
+    }
 
     @NonNull
-    public static RequestQueue getRequestQueue(@NonNull Context context) {
-        RequestQueue requestQueue = sRequestQueue;
+    public static MoPubRequestQueue getRequestQueue(@NonNull Context context) {
+        MoPubRequestQueue requestQueue = sRequestQueue;
         // Double-check locking to initialize.
         if (requestQueue == null) {
             synchronized (Networking.class) {
                 requestQueue = sRequestQueue;
                 if (requestQueue == null) {
+
                     // Guarantee ClientMetadata is set up.
                     final ClientMetadata clientMetadata = ClientMetadata.getInstance(context);
-                    HurlStack.UrlRewriter urlRewriter = new PlayServicesUrlRewriter(clientMetadata.getDeviceId(), context);
+                    final HurlStack.UrlRewriter urlRewriter = new PlayServicesUrlRewriter(clientMetadata.getDeviceId(), context);
+                    final SSLSocketFactory socketFactory = CustomSSLSocketFactory.getDefault(Constants.TEN_SECONDS_MILLIS);
 
                     final String userAgent = Networking.getUserAgent(context.getApplicationContext());
-                    HttpStack httpStack = new RequestQueueHttpStack(userAgent, urlRewriter);
+                    HttpStack httpStack = new RequestQueueHttpStack(userAgent, urlRewriter, socketFactory);
 
                     Network network = new BasicNetwork(httpStack);
                     File volleyCacheDir = new File(context.getCacheDir().getPath() + File.separator
                             + CACHE_DIRECTORY_NAME);
-                    Cache cache = new DiskBasedCache(volleyCacheDir, (int) DeviceUtils.diskCacheSizeBytes(volleyCacheDir, TEN_MB));
-                    requestQueue = new RequestQueue(cache, network);
+                    Cache cache = new DiskBasedCache(volleyCacheDir, (int) DeviceUtils.diskCacheSizeBytes(volleyCacheDir, Constants.TEN_MB));
+                    requestQueue = new MoPubRequestQueue(cache, network);
                     sRequestQueue = requestQueue;
-                    sRequestQueue.start();
+                    requestQueue.start();
                 }
             }
         }
@@ -113,17 +129,18 @@ public static String getUserAgent(@NonNull Context context) {
                 if (userAgent == null) {
                     // As of Android 4.4, WebViews may only be instantiated on the UI thread
                     if (Looper.myLooper() == Looper.getMainLooper()) {
-                        sUserAgent = new WebView(context).getSettings().getUserAgentString();
+                        userAgent = new WebView(context).getSettings().getUserAgentString();
                     } else {
                         // In the exceptional case where we can't access the WebView user agent,
                         // fall back to the System-specific user agent.
-                        sUserAgent = System.getProperty("http.agent");
+                        userAgent = System.getProperty("http.agent");
                     }
+                    sUserAgent = userAgent;
                 }
             }
         }
 
-        return sUserAgent;
+        return userAgent;
     }
 
     @VisibleForTesting
@@ -134,7 +151,7 @@ public static synchronized void clearForTesting() {
     }
 
     @VisibleForTesting
-    public static synchronized void setRequestQueueForTesting(RequestQueue queue) {
+    public static synchronized void setRequestQueueForTesting(MoPubRequestQueue queue) {
         sRequestQueue = queue;
     }
 
@@ -147,4 +164,15 @@ public static synchronized void setImageLoaderForTesting(MaxWidthImageLoader ima
     public static synchronized void setUserAgentForTesting(String userAgent) {
         sUserAgent = userAgent;
     }
+
+    /**
+     * Set whether to use HTTPS for communication with MoPub ad servers.
+     */
+    public static void useHttps(boolean useHttps) {
+        sUseHttps = useHttps;
+    }
+
+    public static boolean useHttps() {
+        return sUseHttps;
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/network/RequestManager.java b/mopub-sdk/src/main/java/com/mopub/network/RequestManager.java
new file mode 100644
index 00000000..ba535bf8
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/RequestManager.java
@@ -0,0 +1,104 @@
+package com.mopub.network;
+
+import android.os.Handler;
+import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.volley.Request;
+
+/**
+ * This class is responsible for managing the lifecycle of a request with a backoff policy. This
+ * class currently manages a single request at a time. The API allows for it to support multiple
+ * simultaneous requests in the future.
+ *
+ * Subclasses are responsible for implementing the createRequest method that will create a new
+ * instance of subclass's specific request type.
+ * The subclass is also responsible for listening to success and error responses from its specific
+ * request type.
+ *
+ * @param <T> The type of request factory to generate new requests for each retry.
+ */
+public abstract class RequestManager<T extends RequestManager.RequestFactory> {
+
+    // This interface is used to bound type T of the RequestManager
+    public interface RequestFactory{}
+
+    @Nullable protected Request<?> mCurrentRequest;
+    @Nullable protected T mRequestFactory;
+    @Nullable protected BackoffPolicy mBackoffPolicy;
+    @NonNull protected Handler mHandler;
+
+    public RequestManager(@NonNull Looper looper) {
+        mHandler = new Handler(looper);
+    }
+
+    @NonNull
+    abstract Request<?> createRequest();
+
+    public boolean isAtCapacity() {
+        return mCurrentRequest != null;
+    }
+
+    /**
+     * This method first cancels existing requests in flight and then begins the request
+     * lifecycle for the new request.
+     *
+     * @param requestFactory Factory that constructs a new request for each request retry from the
+     *                       backoff policy.
+     * @param backoffPolicy The request to cancel.
+     */
+    public void makeRequest(@NonNull T requestFactory, @NonNull BackoffPolicy backoffPolicy) {
+        Preconditions.checkNotNull(requestFactory);
+        Preconditions.checkNotNull(backoffPolicy);
+
+        cancelRequest();
+        mRequestFactory = requestFactory;
+        mBackoffPolicy = backoffPolicy;
+        makeRequestInternal();
+    }
+
+    /**
+     * Cancels the request in flight.
+     */
+    public void cancelRequest() {
+        MoPubRequestQueue requestQueue = Networking.getRequestQueue();
+        if (requestQueue != null && mCurrentRequest != null) {
+            requestQueue.cancel(mCurrentRequest);
+        }
+        clearRequest();
+    }
+
+    @VisibleForTesting
+    void makeRequestInternal() {
+        mCurrentRequest = createRequest();
+        MoPubRequestQueue requestQueue = Networking.getRequestQueue();
+        if (requestQueue == null) {
+            MoPubLog.d("MoPubRequest queue is null. Clearing request.");
+            clearRequest();
+            return;
+        }
+
+        if (mBackoffPolicy.getRetryCount() == 0) {
+            requestQueue.add(mCurrentRequest);
+        } else {
+            requestQueue.addDelayedRequest(mCurrentRequest, mBackoffPolicy.getBackoffMs());
+        }
+    }
+
+    @VisibleForTesting
+    void clearRequest() {
+        mCurrentRequest = null;
+        mRequestFactory = null;
+        mBackoffPolicy = null;
+    }
+
+    @Deprecated
+    @VisibleForTesting
+    Request<?> getCurrentRequest() {
+        return mCurrentRequest;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/ScribeBackoffPolicy.java b/mopub-sdk/src/main/java/com/mopub/network/ScribeBackoffPolicy.java
new file mode 100644
index 00000000..5b5b3732
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/ScribeBackoffPolicy.java
@@ -0,0 +1,54 @@
+package com.mopub.network;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.NoConnectionError;
+import com.mopub.volley.VolleyError;
+
+/**
+ * The backoff policy for making requests to the Scribe service.
+ */
+public class ScribeBackoffPolicy extends BackoffPolicy {
+    private static final int DEFAULT_BACKOFF_TIME_MS = 60 * 1000;
+    private static final int MAX_RETRIES = 5;
+    private static final int BACKOFF_MULTIPLIER = 2;
+
+    public ScribeBackoffPolicy() {
+        this(DEFAULT_BACKOFF_TIME_MS, MAX_RETRIES, BACKOFF_MULTIPLIER);
+    }
+
+    @VisibleForTesting
+    ScribeBackoffPolicy(int defaultBackoffTimeMs, int maxRetries, int backoffMultiplier) {
+        mDefaultBackoffTimeMs = defaultBackoffTimeMs;
+        mMaxRetries = maxRetries;
+        mBackoffMultiplier = backoffMultiplier;
+    }
+
+    @Override
+    public void backoff(VolleyError volleyError) throws VolleyError {
+        if (!hasAttemptRemaining()) {
+            throw volleyError;
+        }
+
+        if (volleyError instanceof NoConnectionError) {
+            updateBackoffTime();
+            return;
+        }
+
+        NetworkResponse networkResponse = volleyError.networkResponse;
+        if (networkResponse != null &&
+                (networkResponse.statusCode == 503  || networkResponse.statusCode == 504)) {
+            updateBackoffTime();
+            return;
+        }
+
+        throw volleyError;
+    }
+
+    private void updateBackoffTime() {
+        double multiplier = Math.pow(mBackoffMultiplier, mRetryCount);
+        mBackoffMs = (int) (mDefaultBackoffTimeMs * multiplier);
+        mRetryCount++;
+    }
+}
+
diff --git a/mopub-sdk/src/main/java/com/mopub/network/ScribeRequest.java b/mopub-sdk/src/main/java/com/mopub/network/ScribeRequest.java
new file mode 100644
index 00000000..f04bcdf0
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/ScribeRequest.java
@@ -0,0 +1,83 @@
+package com.mopub.network;
+
+import android.support.annotation.NonNull;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.event.BaseEvent;
+import com.mopub.common.event.EventSerializer;
+import com.mopub.volley.DefaultRetryPolicy;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.Request;
+import com.mopub.volley.Response;
+import com.mopub.volley.toolbox.HttpHeaderParser;
+
+import org.json.JSONArray;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * A POST request for logging custom events to the Scribe service.
+ */
+public class ScribeRequest extends Request<Void> {
+
+    public interface Listener extends Response.ErrorListener {
+        public void onResponse();
+    }
+
+    public interface ScribeRequestFactory extends RequestManager.RequestFactory {
+        public ScribeRequest createRequest(ScribeRequest.Listener listener);
+    }
+
+    @NonNull private final List<BaseEvent> mEvents;
+    @NonNull private final EventSerializer mEventSerializer;
+    @NonNull private final ScribeRequest.Listener mListener;
+
+    public ScribeRequest(@NonNull String url,
+            @NonNull List<BaseEvent> events,
+            @NonNull EventSerializer eventSerializer,
+            @NonNull Listener listener) {
+        super(Method.POST, url, listener);
+
+        mEvents = events;
+        mEventSerializer = eventSerializer;
+        mListener = listener;
+
+        setShouldCache(false);
+
+        // This retry policy applies to socket timeouts only
+        setRetryPolicy(new DefaultRetryPolicy());
+    }
+
+    /**
+     * This is method runs on the background thread
+     */
+    @Override
+    protected Map<String,String> getParams() {
+        JSONArray jsonArray = mEventSerializer.serializeAsJson(mEvents);
+        Map<String,String> params = new HashMap<String, String>();
+        params.put("log", jsonArray.toString());
+        return params;
+    }
+
+    @Override
+    protected Response<Void> parseNetworkResponse(NetworkResponse networkResponse) {
+        // NOTE: We never get status codes outside of {[200, 299], 304}. Those errors are sent to the
+        // error listener.
+        return Response.success(null, HttpHeaderParser.parseCacheHeaders(networkResponse));
+    }
+
+    @Override
+    protected void deliverResponse(Void aVoid) {
+        mListener.onResponse();
+    }
+
+    @NonNull
+    @Deprecated
+    @VisibleForTesting
+    public List<BaseEvent> getEvents() {
+        return mEvents;
+    }
+}
+
diff --git a/mopub-sdk/src/main/java/com/mopub/network/ScribeRequestManager.java b/mopub-sdk/src/main/java/com/mopub/network/ScribeRequestManager.java
new file mode 100644
index 00000000..e1b3fc45
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/ScribeRequestManager.java
@@ -0,0 +1,59 @@
+package com.mopub.network;
+
+import android.os.Looper;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.volley.Request;
+import com.mopub.volley.VolleyError;
+
+import static com.mopub.network.ScribeRequest.ScribeRequestFactory;
+
+/**
+ * Request manager to manage scribe requests. This class implements the specific Scribe
+ * request listener.
+ */
+public class ScribeRequestManager extends RequestManager<ScribeRequestFactory> implements ScribeRequest.Listener {
+
+    public ScribeRequestManager(final Looper looper) {
+        super(looper);
+    }
+
+    // RequestManager
+    @NonNull
+    @Override
+    Request<?> createRequest() {
+        return mRequestFactory.createRequest(this);
+    }
+
+    // ScribeRequest.Listener
+    @Override
+    public void onResponse() {
+        MoPubLog.d("Successfully scribed events");
+        // Get back to the dedicated event logging thread before touching shared resources
+        mHandler.post(new Runnable() {
+            @Override
+            public void run() {
+                clearRequest();
+            }
+        });
+    }
+
+    @Override
+    public void onErrorResponse(final VolleyError volleyError) {
+        // Post back to the dedicated event logging thread before touching shared resources
+        mHandler.post(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    mBackoffPolicy.backoff(volleyError);
+                    makeRequestInternal();
+                } catch (VolleyError e) {
+                    MoPubLog.d("Failed to Scribe events: " + volleyError);
+                    clearRequest();
+                }
+            }
+        });
+    }
+}
+
diff --git a/mopub-sdk/src/main/java/com/mopub/network/TrackingRequest.java b/mopub-sdk/src/main/java/com/mopub/network/TrackingRequest.java
index eff3af17..4570a183 100644
--- a/mopub-sdk/src/main/java/com/mopub/network/TrackingRequest.java
+++ b/mopub-sdk/src/main/java/com/mopub/network/TrackingRequest.java
@@ -5,7 +5,7 @@
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
 
-import com.mopub.common.event.MoPubEvents;
+import com.mopub.common.event.BaseEvent;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.volley.DefaultRetryPolicy;
 import com.mopub.volley.NetworkResponse;
@@ -20,7 +20,7 @@
 public class TrackingRequest extends Request<Void> {
 
     public interface Listener extends Response.ErrorListener {
-        public void onResponse();
+        public void onResponse(@NonNull String url);
     }
 
     @Nullable private final TrackingRequest.Listener mListener;
@@ -49,7 +49,7 @@ private TrackingRequest(@NonNull final String url, @Nullable final Listener list
     @Override
     public void deliverResponse(final Void aVoid) {
         if (mListener != null) {
-            mListener.onResponse();
+            mListener.onResponse(getUrl());
         }
     }
 
@@ -63,14 +63,14 @@ public static void makeTrackingHttpRequest(final Iterable<String> urls, final Co
 
     public static void makeTrackingHttpRequest(final Iterable<String> urls,
             final Context context,
-            final MoPubEvents.Type type) {
-        makeTrackingHttpRequest(urls, context, null, type);
+            final BaseEvent.Name name) {
+        makeTrackingHttpRequest(urls, context, null, name);
     }
 
     public static void makeTrackingHttpRequest(final Iterable<String> urls,
             final Context context,
             @Nullable final Listener listener,
-            final MoPubEvents.Type type) {
+            final BaseEvent.Name name) {
         if (urls == null || context == null) {
             return;
         }
@@ -83,10 +83,10 @@ public static void makeTrackingHttpRequest(final Iterable<String> urls,
 
             final TrackingRequest.Listener internalListener = new TrackingRequest.Listener() {
                 @Override
-                public void onResponse() {
+                public void onResponse(@NonNull String url) {
                     MoPubLog.d("Successfully hit tracking endpoint: " + url);
                     if (listener != null) {
-                        listener.onResponse();
+                        listener.onResponse(url);
                     }
                 }
 
@@ -114,16 +114,16 @@ public static void makeTrackingHttpRequest(final String url,
     }
 
     public static void makeTrackingHttpRequest(final String url,
-            final Context context, final MoPubEvents.Type type) {
-        makeTrackingHttpRequest(url, context, null, type);
+            final Context context, final BaseEvent.Name name) {
+        makeTrackingHttpRequest(url, context, null, name);
     }
 
     public static void makeTrackingHttpRequest(final String url,
             final Context context,
             @Nullable Listener listener,
-            final MoPubEvents.Type type) {
+            final BaseEvent.Name name) {
         if (url != null) {
-            makeTrackingHttpRequest(Arrays.asList(url), context, listener, type);
+            makeTrackingHttpRequest(Arrays.asList(url), context, listener, name);
         }
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/CacheServiceTest.java b/mopub-sdk/src/test/java/com/mopub/common/CacheServiceTest.java
index 025cd79d..16b35e0e 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/CacheServiceTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/CacheServiceTest.java
@@ -9,6 +9,7 @@
 import org.junit.runner.RunWith;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
 
 import java.io.ByteArrayInputStream;
 import java.io.File;
@@ -36,7 +37,7 @@
 
     @Before
     public void setUp() throws Exception {
-        context = new Activity();
+        context = Robolectric.buildActivity(Activity.class).create().get();
         key1 = "http://www.mopub.com/";
         data1 = "image_data_1";
 
diff --git a/mopub-sdk/src/test/java/com/mopub/common/CloseableLayoutTest.java b/mopub-sdk/src/test/java/com/mopub/common/CloseableLayoutTest.java
index 998801ee..5c5f35e1 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/CloseableLayoutTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/CloseableLayoutTest.java
@@ -26,7 +26,6 @@
     private CloseableLayout subject;
 
     @Mock private OnCloseListener mockCloseListener;
-    @Mock private Canvas mockCanvas;
 
     private MotionEvent closeRegionDown;
     private MotionEvent closeRegionUp;
@@ -97,8 +96,8 @@ public void draw_shouldUpdateCloseBounds() {
 
         int expectedTop = 0;
         int expectedLeft = (int) (100 - CloseableLayout.CLOSE_REGION_SIZE_DP);
-
-        subject.draw(mockCanvas);
+        Canvas canvas = new Canvas();
+        subject.draw(canvas);
         Rect closeBounds = subject.getCloseBounds();
         assertThat(closeBounds.top).isEqualTo(expectedTop);
         assertThat(closeBounds.bottom).isEqualTo(
@@ -110,12 +109,13 @@ public void draw_shouldUpdateCloseBounds() {
 
     @Test
     public void draw_withoutCloseBoundsChanged_shouldNotUpdateCloseBounds() {
-        subject.draw(mockCanvas);
+        Canvas canvas = new Canvas();
+        subject.draw(canvas);
         Rect originalCloseBounds = subject.getCloseBounds();
 
         subject.setCloseBounds(new Rect(40, 41, 42, 43));
         subject.setCloseBoundChanged(false);
-        subject.draw(mockCanvas);
+        subject.draw(canvas);
 
         assertThat(subject.getCloseBounds()).isEqualTo(originalCloseBounds);
     }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/CreativeOrientationTest.java b/mopub-sdk/src/test/java/com/mopub/common/CreativeOrientationTest.java
new file mode 100644
index 00000000..0ea85803
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/CreativeOrientationTest.java
@@ -0,0 +1,43 @@
+package com.mopub.common;
+
+import org.junit.Test;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+public class CreativeOrientationTest {
+
+    @Test
+    public void fromHeader_nullParam_shouldBeUndefined() {
+        assertThat(CreativeOrientation.fromHeader(null)).isEqualTo(CreativeOrientation.UNDEFINED);
+    }
+
+    @Test
+    public void fromHeader_emptyParam_shouldBeUndefined() {
+        assertThat(CreativeOrientation.fromHeader("")).isEqualTo(CreativeOrientation.UNDEFINED);
+    }
+
+    @Test
+    public void fromHeader_withGarbage_shouldBeUndefined() {
+        assertThat(CreativeOrientation.fromHeader("p0rtr41t")).isEqualTo(CreativeOrientation.UNDEFINED);
+    }
+
+    @Test
+    public void fromHeader_lParam_shouldBeLandscape() {
+        assertThat(CreativeOrientation.fromHeader("l")).isEqualTo(CreativeOrientation.LANDSCAPE);
+    }
+
+    @Test
+    public void fromHeader_uppercaseL_shouldBeLandscape() {
+        assertThat(CreativeOrientation.fromHeader("L")).isEqualTo(CreativeOrientation.LANDSCAPE);
+    }
+
+    @Test
+    public void fromHeader_pParam_shouldBePortrait() {
+        assertThat(CreativeOrientation.fromHeader("p")).isEqualTo(CreativeOrientation.PORTRAIT);
+    }
+
+    @Test
+    public void fromHeader_uppercaseP_shouldBePortrait() {
+        assertThat(CreativeOrientation.fromHeader("P")).isEqualTo(CreativeOrientation.PORTRAIT);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/GpsHelperTest.java b/mopub-sdk/src/test/java/com/mopub/common/GpsHelperTest.java
index f5b8a175..25ce4ba3 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/GpsHelperTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/GpsHelperTest.java
@@ -53,7 +53,7 @@ public boolean isLimitAdTrackingEnabled() {
 
     @Before
     public void setup() {
-    	context = new Activity();
+    	context = Robolectric.buildActivity(Activity.class).create().get();
         adInfo = new TestAdInfo();
 
         methodBuilder = TestMethodBuilderFactory.getSingletonMock();
diff --git a/mopub-sdk/src/test/java/com/mopub/common/MoPubBrowserTest.java b/mopub-sdk/src/test/java/com/mopub/common/MoPubBrowserTest.java
index b28038c6..e5228497 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/MoPubBrowserTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/MoPubBrowserTest.java
@@ -28,6 +28,7 @@ public void setUp() {
 
         mockWebView = mock(WebView.class);
         subject.setWebView(mockWebView);
+        // In the Gradle testing regime we will change these to build MoPubBrowser as an activity using Robolectric.
     }
 
     @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
diff --git a/mopub-sdk/src/test/java/com/mopub/common/UrlHandlerTest.java b/mopub-sdk/src/test/java/com/mopub/common/UrlHandlerTest.java
new file mode 100644
index 00000000..6002c333
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/UrlHandlerTest.java
@@ -0,0 +1,625 @@
+package com.mopub.common;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.ResolveInfo;
+import android.net.Uri;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+
+import static com.mopub.common.UrlAction.FOLLOW_DEEP_LINK;
+import static com.mopub.common.UrlAction.HANDLE_MOPUB_SCHEME;
+import static com.mopub.common.UrlAction.HANDLE_PHONE_SCHEME;
+import static com.mopub.common.UrlAction.HANDLE_SHARE_TWEET;
+import static com.mopub.common.UrlAction.IGNORE_ABOUT_SCHEME;
+import static com.mopub.common.UrlAction.NOOP;
+import static com.mopub.common.UrlAction.OPEN_IN_APP_BROWSER;
+import static com.mopub.common.UrlAction.OPEN_NATIVE_BROWSER;
+import static com.mopub.common.UrlAction.OPEN_APP_MARKET;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+
+@RunWith(SdkTestRunner.class)
+public class UrlHandlerTest {
+    private Context context;
+    @Mock private UrlHandler.ResultActions mockResultActions;
+    @Mock private UrlHandler.MoPubSchemeListener mockMoPubSchemeListener;
+
+    @Before
+    public void setUp() throws Exception {
+        context = Robolectric.buildActivity(Activity.class).create().get().getApplicationContext();
+    }
+
+    @Test
+    public void urlHandler_withoutMoPubBrowser_shouldCallOnClickSuccessButNotStartActivity() {
+        final String url = "http://some_url";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(OPEN_IN_APP_BROWSER)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .withoutMoPubBrowser()
+                .build().handleUrl(context, url);
+
+        verify(mockResultActions).urlHandlingSucceeded(url, OPEN_IN_APP_BROWSER);
+        verifyNoMoreCallbacks();
+        final Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(startedActivity).isNull();
+    }
+
+    @Test
+    public void urlHandler_withMatchingMoPubSchemeFinishLoad_shouldCallOnFinishLoad() {
+        final String url = "mopub://finishLoad";
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_MOPUB_SCHEME)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+
+        verify(mockMoPubSchemeListener).onFinishLoad();
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withMatchingMoPubSchemeClose_shouldCallOnClose() {
+        final String url = "mopub://close";
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_MOPUB_SCHEME)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+
+        verify(mockMoPubSchemeListener).onClose();
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withMatchingMoPubSchemeFailLoad_shouldCallOnFailLoad() {
+        final String url = "mopub://failLoad";
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_MOPUB_SCHEME)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+
+        verify(mockMoPubSchemeListener).onFailLoad();
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withMatchingAboutSchemeUrl_shouldIgnoreClick() {
+        final String url = "about:blank";
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(
+                        HANDLE_MOPUB_SCHEME,
+                        IGNORE_ABOUT_SCHEME,
+                        HANDLE_PHONE_SCHEME)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+
+        verifyNoMoreCallbacks();
+        verifyNoStartedActivity();
+    }
+
+    @Test
+    public void urlHandler_withMatchingPhoneSchemeTelUrl_shouldCallOnClickSuccess() {
+        assertPhoneSchemeCallback("tel:");
+    }
+
+    @Test
+    public void urlHandler_withMatchingPhoneSchemeVoicemailUrl_shouldCallOnClickSuccess() {
+        assertPhoneSchemeCallback("voicemail:");
+    }
+
+    @Test
+    public void urlHandler_withMatchingPhoneSchemeSMSUrl_shouldCallOnClickSuccess() {
+        assertPhoneSchemeCallback("sms:");
+    }
+
+    @Test
+    public void urlHandler_withMatchingPhoneSchemeMailToUrl_shouldCallOnClickSuccess() {
+        assertPhoneSchemeCallback("mailto:");
+    }
+
+    @Test
+    public void urlHandler_withMatchingPhoneSchemeGeoUrl_shouldCallOnClickSuccess() {
+        assertPhoneSchemeCallback("geo:");
+    }
+
+    @Test
+    public void urlHandler_withMatchingPhoneSchemeStreetViewUrl_shouldCallOnClickSuccess() {
+        assertPhoneSchemeCallback("google.streetview:");
+    }
+
+    @Test
+    public void urlHandler_withMatchingPhoneSchemeUrl_shouldStartActivity() {
+        final String url = "tel:1234567890";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(IGNORE_ABOUT_SCHEME, HANDLE_MOPUB_SCHEME, FOLLOW_DEEP_LINK,
+                        OPEN_IN_APP_BROWSER, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER, HANDLE_SHARE_TWEET)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+
+        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+        assertThat(startedActivity.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        assertThat(startedActivity.getData()).isEqualTo(Uri.parse(url));
+    }
+
+    @Test
+    public void urlHandler_withValidNativeBrowserUrl_shouldCallOnClickSuccess_shouldStartActivity() {
+        final String urlToLoad = "some_url";
+        final String url = "mopubnativebrowser://navigate?url=" + urlToLoad;
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(IGNORE_ABOUT_SCHEME, HANDLE_MOPUB_SCHEME, FOLLOW_DEEP_LINK,
+                        OPEN_IN_APP_BROWSER, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER, HANDLE_SHARE_TWEET)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+
+        verify(mockResultActions).urlHandlingSucceeded(url, OPEN_NATIVE_BROWSER);
+        verifyNoMoreCallbacks();
+        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+        assertThat(startedActivity.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        assertThat(startedActivity.getData()).isEqualTo(Uri.parse(urlToLoad));
+    }
+
+    @Test
+    public void urlHandler_withMatchingInAppBrowserHttpUrl_shouldCallOnClickSuccess_shouldStartActivity() {
+        final String url = "http://some_url";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(IGNORE_ABOUT_SCHEME, HANDLE_MOPUB_SCHEME, FOLLOW_DEEP_LINK,
+                        OPEN_IN_APP_BROWSER, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER, HANDLE_SHARE_TWEET)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+
+        verify(mockResultActions).urlHandlingSucceeded(url, OPEN_IN_APP_BROWSER);
+        verifyNoMoreCallbacks();
+        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+        assertThat(startedActivity.getComponent().getClassName())
+                .isEqualTo(MoPubBrowser.class.getName());
+        assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(url);
+    }
+
+    @Test
+    public void urlHandler_withMatchingInAppBrowserHttpsUrl_shouldCallOnClickSuccess_shouldStartActivity() {
+        final String url = "https://some_url";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(IGNORE_ABOUT_SCHEME, HANDLE_MOPUB_SCHEME, FOLLOW_DEEP_LINK,
+                        OPEN_IN_APP_BROWSER, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER, HANDLE_SHARE_TWEET)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+
+        verify(mockResultActions).urlHandlingSucceeded(url, OPEN_IN_APP_BROWSER);
+        verifyNoMoreCallbacks();
+        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+        assertThat(startedActivity.getComponent().getClassName())
+                .isEqualTo(MoPubBrowser.class.getName());
+        assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(url);
+    }
+
+    @Test
+    public void urlHandler_withMatchingShareUrl_shouldCallOnClickSuccess_shouldStartActivity() {
+        final String shareTweetUrl = "mopubshare://tweet?screen_name=SpaceX&tweet_id=596026229536460802";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_SHARE_TWEET)
+                .withResultActions(mockResultActions)
+                .build().handleUrl(context, shareTweetUrl);
+
+        verify(mockResultActions).urlHandlingSucceeded(shareTweetUrl, HANDLE_SHARE_TWEET);
+        verifyNoMoreCallbacks();
+        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+        assertThat(startedActivity.getAction()).isEqualTo(Intent.ACTION_CHOOSER);
+    }
+
+    @Test
+    public void urlHandler_withMatchingDeepLinkUrl_shouldCallOnClickSuccess_shouldStartActivity() {
+        final String deepLinkUrl = "appscheme://host";
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(Intent.ACTION_VIEW,
+                Uri.parse(deepLinkUrl)), new ResolveInfo());
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(FOLLOW_DEEP_LINK)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, deepLinkUrl);
+
+        verify(mockResultActions).urlHandlingSucceeded(deepLinkUrl, FOLLOW_DEEP_LINK);
+        verifyNoMoreCallbacks();
+        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+        assertThat(startedActivity.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        assertThat(startedActivity.getData()).isEqualTo(Uri.parse(deepLinkUrl));
+    }
+
+    @Test
+    public void urlHandler_withDualMatchingUnresolvableUrlActions_shouldCallOnClickFailOnLastMatchedAction() {
+        final String url = "mopub://invalid";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_MOPUB_SCHEME, FOLLOW_DEEP_LINK)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+
+        verify(mockResultActions).urlHandlingFailed(url, FOLLOW_DEEP_LINK);
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withShareTweetAndDeepLink_shouldCallOnClickFailOnLastMatchedDeepLink() {
+        final String url = "mopubshare://invalid";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_SHARE_TWEET, FOLLOW_DEEP_LINK)
+                .withResultActions(mockResultActions)
+                .build().handleUrl(context, url);
+
+        verify(mockResultActions).urlHandlingFailed(url, FOLLOW_DEEP_LINK);
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withNoConfiguration_shouldDoNothing() {
+        new UrlHandler.Builder().build().handleUrl(context, "");
+
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withoutDestinationUrl_shouldNotError() {
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(IGNORE_ABOUT_SCHEME)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, "");
+
+        verify(mockResultActions).urlHandlingFailed("", NOOP);
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withoutSupportedUrlActions_shouldNotError() {
+        new UrlHandler.Builder()
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, "about:blank");
+
+        verify(mockResultActions).urlHandlingFailed("about:blank", NOOP);
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withoutClickListener_shouldNotError() {
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(IGNORE_ABOUT_SCHEME)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, "about:blank");
+
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withoutMoPubSchemeListener_shouldNotError() {
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(IGNORE_ABOUT_SCHEME)
+                .withResultActions(mockResultActions)
+                .build().handleUrl(context, "about:blank");
+
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withoutMoPubBrowser_shouldNotError() {
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(IGNORE_ABOUT_SCHEME)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .withoutMoPubBrowser()
+                .build().handleUrl(context, "about:blank");
+
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingAboutSchemeUrl_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingUrl(IGNORE_ABOUT_SCHEME);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingMoPubSchemeUrl_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingUrl(HANDLE_MOPUB_SCHEME);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingDeepLinkUrl_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingUrl(FOLLOW_DEEP_LINK);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingInAppBrowserUrl_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingUrl(OPEN_IN_APP_BROWSER);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingPhoneSchemeUrl_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingUrl(HANDLE_PHONE_SCHEME);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingNativeBrowserUrl_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingUrl(OPEN_NATIVE_BROWSER);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingShareTweetUrl_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingUrl(HANDLE_SHARE_TWEET);
+    }
+
+    /**
+     * For the next few unit tests urlHandler_withoutMatching[some]UrlAction_shouldCallOnClickFail,
+     * do not include FOLLOW_DEEP_LINK, since it would be a catch-all and trigger urlHandlingSucceeded.
+     */
+
+    @Test
+    public void urlHandler_withoutMatchingAboutSchemeUrlAction_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingSupportedUrlAction("about:blank", HANDLE_MOPUB_SCHEME,
+                OPEN_IN_APP_BROWSER, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER, HANDLE_SHARE_TWEET);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingMoPubSchemeUrlAction_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingSupportedUrlAction("mopub://close", IGNORE_ABOUT_SCHEME,
+                OPEN_IN_APP_BROWSER, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER, HANDLE_SHARE_TWEET);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingDeepLinkUrlAction_shouldCallUrlHandlingFailed() {
+        final String deepLinkUrl = "appscheme://host";
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(Intent.ACTION_VIEW,
+                Uri.parse(deepLinkUrl)), new ResolveInfo());
+        assertCallbackWithoutMatchingSupportedUrlAction(deepLinkUrl, IGNORE_ABOUT_SCHEME,
+                HANDLE_MOPUB_SCHEME, OPEN_IN_APP_BROWSER, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER,
+                HANDLE_SHARE_TWEET);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingInAppBrowserUrlAction_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingSupportedUrlAction("https://some_url", IGNORE_ABOUT_SCHEME,
+                HANDLE_MOPUB_SCHEME, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER, HANDLE_SHARE_TWEET);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingPhoneSchemeUrlAction_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingSupportedUrlAction("tel:1234567890", IGNORE_ABOUT_SCHEME,
+                HANDLE_MOPUB_SCHEME, OPEN_IN_APP_BROWSER, OPEN_NATIVE_BROWSER, HANDLE_SHARE_TWEET);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingNativeBrowserUrlAction_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingSupportedUrlAction("mopubnativebrowser://navigate?url=some_url",
+                IGNORE_ABOUT_SCHEME, HANDLE_MOPUB_SCHEME, OPEN_IN_APP_BROWSER, HANDLE_PHONE_SCHEME,
+                HANDLE_SHARE_TWEET);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingShareTweetUrlAction_shouldCallUrlHandlingFailed() {
+        final String shareTweetUrl = "mopubshare://tweet?screen_name=SpaceX&tweet_id=596026229536460802";
+        assertCallbackWithoutMatchingSupportedUrlAction(shareTweetUrl, HANDLE_MOPUB_SCHEME,
+                IGNORE_ABOUT_SCHEME, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER, OPEN_APP_MARKET,
+                OPEN_IN_APP_BROWSER);
+    }
+
+    @Test
+    public void urlHandler_withNullDestinationURL_shouldDoNothing() {
+        final String nullUrl = null;
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(IGNORE_ABOUT_SCHEME, HANDLE_MOPUB_SCHEME, FOLLOW_DEEP_LINK,
+                        OPEN_IN_APP_BROWSER, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER, HANDLE_SHARE_TWEET)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, nullUrl);
+
+        verify(mockResultActions).urlHandlingFailed(nullUrl, NOOP);
+        verifyNoMoreCallbacks();
+        verifyNoStartedActivity();
+    }
+
+    @Test
+    public void urlHandler_withEmptyDestinationURL_shouldDoNothing() {
+        final String emptyUrl = "";
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(IGNORE_ABOUT_SCHEME, HANDLE_MOPUB_SCHEME, FOLLOW_DEEP_LINK,
+                        OPEN_IN_APP_BROWSER, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER, HANDLE_SHARE_TWEET)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, emptyUrl);
+
+        verify(mockResultActions).urlHandlingFailed(emptyUrl, NOOP);
+        verifyNoMoreCallbacks();
+        verifyNoStartedActivity();
+    }
+
+    @Test
+    public void urlHandler_withInvalidDestinationURL_shouldDoNothing() {
+        final String invalidUrl = "some_invalid_url";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(IGNORE_ABOUT_SCHEME, HANDLE_MOPUB_SCHEME, FOLLOW_DEEP_LINK,
+                        OPEN_IN_APP_BROWSER, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER, HANDLE_SHARE_TWEET)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, invalidUrl);
+
+        verify(mockResultActions).urlHandlingFailed(invalidUrl, NOOP);
+        verifyNoMoreCallbacks();
+        verifyNoStartedActivity();
+    }
+
+    @Test
+    public void urlHandler_withMatchingMoPubSchemeWithoutMoPubSchemeListener_shouldDoNothing() {
+        final String url = "mopub://finishLoad";
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_MOPUB_SCHEME)
+                .withResultActions(mockResultActions)
+                .build().handleUrl(context, url);
+
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withInvalidMoPubSchemeCustom_shouldNotError() {
+        final String url = "mopub://custom?INVALID";
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_MOPUB_SCHEME)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+
+        verify(mockResultActions).urlHandlingFailed(url, HANDLE_MOPUB_SCHEME);
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withInvalidNativeBrowserUrl_shouldCallUrlHandlingFailed() {
+        final String url = "mopubnativebrowser://INVALID";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(OPEN_NATIVE_BROWSER)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+
+        verify(mockResultActions).urlHandlingFailed(url, OPEN_NATIVE_BROWSER);
+        verifyNoMoreCallbacks();
+        verifyNoStartedActivity();
+    }
+
+    @Test
+    public void urlHandler_withInvalidHostInShareTweetUrl_shouldCallUrlHandlingFailed() {
+        final String url = "mopubshare://invalid";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_SHARE_TWEET)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+
+        verify(mockResultActions).urlHandlingFailed(url, NOOP);
+        verifyNoMoreCallbacks();
+        verifyNoStartedActivity();
+    }
+
+    @Test
+    public void urlHandler_withMissingQueryParametersInShareTweetUrl_shouldCallUrlHandlingFailed() {
+        final String url = "mopubshare://tweet?x=1&y=2";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_SHARE_TWEET)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+
+        verify(mockResultActions).urlHandlingFailed(url, HANDLE_SHARE_TWEET);
+        verifyNoMoreCallbacks();
+        verifyNoStartedActivity();
+    }
+
+    @Test
+    public void urlHandler_withEmptyQueryParametersInShareTweetUrl_shouldCallUrlHandlingFailed() {
+        final String url = "mopubshare://tweet?screen_name=&tweet_id=";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_SHARE_TWEET)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+
+        verify(mockResultActions).urlHandlingFailed(url, HANDLE_SHARE_TWEET);
+        verifyNoMoreCallbacks();
+        verifyNoStartedActivity();
+    }
+
+    @Test
+    public void urlHandler_withMatchingUnresolvableDeepLinkUrl_shouldCallUrlHandlingFailed() {
+        final String deepLinkUrl = "appscheme://host";
+        // The following code would make this url resolvable, so avoiding it to test for an
+        // unresolvable url (yet included for documentation purposes).
+        //  Robolectric.packageManager.addResolveInfoForIntent(new Intent(Intent.ACTION_VIEW,
+        //          Uri.parse(deepLinkUrl)), new ResolveInfo());
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(FOLLOW_DEEP_LINK)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, deepLinkUrl);
+
+        verify(mockResultActions).urlHandlingFailed(deepLinkUrl, FOLLOW_DEEP_LINK);
+        verifyNoMoreCallbacks();
+        verifyNoStartedActivity();
+    }
+
+    private void assertPhoneSchemeCallback(@NonNull final String url) {
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_PHONE_SCHEME)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+
+        verify(mockResultActions).urlHandlingSucceeded(url, HANDLE_PHONE_SCHEME);
+        verifyNoMoreCallbacks();
+    }
+
+    private void assertCallbackWithoutMatchingUrl(@NonNull final UrlAction urlAction) {
+        final String url = "non://matching_url";
+        UrlAction expectedFailUrlAction = NOOP;
+
+        if (urlAction.equals(FOLLOW_DEEP_LINK)) {
+            expectedFailUrlAction = FOLLOW_DEEP_LINK;
+        }
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(urlAction)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+        verify(mockResultActions).urlHandlingFailed(url, expectedFailUrlAction);
+        verifyNoMoreCallbacks();
+    }
+
+    private void assertCallbackWithoutMatchingSupportedUrlAction(@NonNull final String url,
+            @NonNull final UrlAction... otherTypes) {
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(UrlAction.NOOP, otherTypes)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+        verify(mockResultActions).urlHandlingFailed(url, NOOP);
+        verifyNoMoreCallbacks();
+    }
+
+    private void verifyNoMoreCallbacks() {
+        verifyNoMoreInteractions(mockResultActions);
+        verifyNoMoreInteractions(mockMoPubSchemeListener);
+    }
+
+    private void verifyNoStartedActivity() {
+        assertThat(Robolectric.getShadowApplication().peekNextStartedActivity()).isNull();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/BaseEventTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/BaseEventTest.java
index b28eab28..55a087f4 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/event/BaseEventTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/BaseEventTest.java
@@ -3,6 +3,7 @@
 import com.mopub.common.ClientMetadata;
 import com.mopub.common.test.support.SdkTestRunner;
 
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -29,8 +30,8 @@ public void setUp() {
         when(mockClientMetaData.getDeviceModel()).thenReturn("device_model");
         when(mockClientMetaData.getDeviceProduct()).thenReturn("device_product");
         when(mockClientMetaData.getDeviceOsVersion()).thenReturn("device_os_version");
-        when(mockClientMetaData.getDeviceScreenWidthPx()).thenReturn(1337);
-        when(mockClientMetaData.getDeviceScreenHeightPx()).thenReturn(70707);
+        when(mockClientMetaData.getDeviceScreenWidthDip()).thenReturn(1337);
+        when(mockClientMetaData.getDeviceScreenHeightDip()).thenReturn(70707);
         when(mockClientMetaData.getActiveNetworkType()).thenReturn(ClientMetadata.MoPubNetworkType.WIFI);
         when(mockClientMetaData.getNetworkOperator()).thenReturn("network_operator");
         when(mockClientMetaData.getNetworkOperatorName()).thenReturn("network_operator_name");
@@ -38,8 +39,9 @@ public void setUp() {
         when(mockClientMetaData.getSimOperator()).thenReturn("network_sim_operator");
         when(mockClientMetaData.getSimOperatorName()).thenReturn("network_sim_operator_name");
         when(mockClientMetaData.getSimIsoCountryCode()).thenReturn("network_sim_iso_country_code");
+        ClientMetadata.setInstance(mockClientMetaData);
 
-        subject = new Event.Builder("name", "category")
+        subject = new Event.Builder(BaseEvent.Name.AD_REQUEST, BaseEvent.Category.REQUESTS, 0.10000123)
                 .withSdkProduct(BaseEvent.SdkProduct.NATIVE)
                 .withAdUnitId("8cf00598d3664adaaeccd800e46afaca")
                 .withAdCreativeId("3c2b887e2c2a4cd0ae6a925440a62f0d")
@@ -56,7 +58,68 @@ public void setUp() {
                 .withRequestUri("http://ads.mopub.com/m/ad?id=8cf00598d3664adaaeccd800e46afaca")
                 .withRequestRetries(0)
                 .build();
-        subject.setClientMetaData(mockClientMetaData);
+    }
+
+    @After
+    public void tearDown() {
+        ClientMetadata.setInstance(null);
+    }
+
+    @Test
+    public void ScribeCategory_shouldHaveExpectedValues() throws Exception {
+        // We're testing this since our backend data definitions depend on these values matching
+        assertThat(BaseEvent.ScribeCategory.EXCHANGE_CLIENT_EVENT.getCategory())
+                .isEqualTo("exchange_client_event");
+        assertThat(BaseEvent.ScribeCategory.EXCHANGE_CLIENT_ERROR.getCategory())
+                .isEqualTo("exchange_client_error");
+    }
+
+    @Test
+    public void SdkProduct_shouldHaveExpectedValues() throws Exception {
+        // We're testing this since our backend data definitions depend on these values matching
+        assertThat(BaseEvent.SdkProduct.NONE.getType())
+                .isEqualTo(0);
+        assertThat(BaseEvent.SdkProduct.WEB_VIEW.getType())
+                .isEqualTo(1);
+        assertThat(BaseEvent.SdkProduct.NATIVE.getType())
+                .isEqualTo(2);
+    }
+
+    @Test
+    public void AppPlatform_shouldHaveExpectedValues() throws Exception {
+        // We're testing this since our backend data definitions depend on these values matching
+        assertThat(BaseEvent.AppPlatform.NONE.getType())
+                .isEqualTo(0);
+        assertThat(BaseEvent.AppPlatform.IOS.getType())
+                .isEqualTo(1);
+        assertThat(BaseEvent.AppPlatform.ANDROID.getType())
+                .isEqualTo(2);
+        assertThat(BaseEvent.AppPlatform.MOBILE_WEB.getType())
+                .isEqualTo(3);
+    }
+
+    @Test
+    public void Name_shouldHaveExpectedValues() throws Exception {
+        // We're testing this since our backend data definitions depend on these values matching
+        assertThat(BaseEvent.Name.AD_REQUEST.getName())
+                .isEqualTo("ad_request");
+        assertThat(BaseEvent.Name.IMPRESSION_REQUEST.getName())
+                .isEqualTo("impression_request");
+        assertThat(BaseEvent.Name.CLICK_REQUEST.getName())
+                .isEqualTo("click_request");
+    }
+
+    @Test
+    public void Category_shouldHaveExpectedValues() throws Exception {
+        // We're testing this since our backend data definitions depend on these values matching
+        assertThat(BaseEvent.Category.REQUESTS.getCategory())
+                .isEqualTo("requests");
+    }
+
+    @Test
+    public void SamplingRate_shouldHaveExpectedValues() throws Exception {
+        // We're testing this since our backend data definitions depend on these values matching
+        assertThat(BaseEvent.SamplingRate.AD_REQUEST.getSamplingRate()).isEqualTo(0.1);
     }
 
     @Test
@@ -76,6 +139,7 @@ public void constructor_shouldCorrectlyAssignFieldsFromBuilder() throws Exceptio
         assertThat(subject.getRequestStatusCode()).isEqualTo(200);
         assertThat(subject.getRequestUri()).isEqualTo("http://ads.mopub.com/m/ad?id=8cf00598d3664adaaeccd800e46afaca");
         assertThat(subject.getRequestRetries()).isEqualTo(0);
+        assertThat(subject.getSamplingRate()).isEqualTo(0.10000123);
     }
 
     @Test
@@ -103,6 +167,11 @@ public void getClientAdvertisingId_shouldReturnClientMetaDataDeviceId() throws E
         assertThat(subject.getClientAdvertisingId()).isEqualTo("client_device_id");
     }
 
+    @Test
+    public void getObfuscatedClientAdvertisingId_shouldReturnObfuscatedDeviceId() throws Exception {
+        assertThat(subject.getObfuscatedClientAdvertisingId()).isEqualTo("ifa:XXXX");
+    }
+
     @Test
     public void getClientDoNotTrack_shouldReturnClientMetaDataDoNotTrack() throws Exception {
         assertThat(subject.getClientDoNotTrack()).isEqualTo(true);
@@ -129,13 +198,13 @@ public void getDeviceOsVersion_shouldReturnClientMetaDataDeviceOsVersion() throw
     }
 
     @Test
-    public void getDeviceScreenWidthPx_shouldReturnClientMetaDataDeviceScreenWidthPx() throws Exception {
-        assertThat(subject.getDeviceScreenWidthPx()).isEqualTo(1337);
+    public void getDeviceScreenWidthDip_shouldReturnClientMetaDataDeviceScreenWidthDip() throws Exception {
+        assertThat(subject.getDeviceScreenWidthDip()).isEqualTo(1337);
     }
 
     @Test
-    public void getDeviceScreenHeightPx_shouldReturnClientMetaDataDeviceScreenHeightPx() throws Exception {
-        assertThat(subject.getDeviceScreenHeightPx()).isEqualTo(70707);
+    public void getDeviceScreenHeightDip_shouldReturnClientMetaDataDeviceScreenHeightDip() throws Exception {
+        assertThat(subject.getDeviceScreenHeightDip()).isEqualTo(70707);
     }
 
     @Test
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/ErrorEventTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/ErrorEventTest.java
index 0090e949..05cd07f6 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/event/ErrorEventTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/ErrorEventTest.java
@@ -1,21 +1,12 @@
 package com.mopub.common.event;
 
-import com.mopub.common.CacheServiceTest;
 import com.mopub.common.test.support.SdkTestRunner;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-
-import java.io.PrintWriter;
 
 import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
 public class ErrorEventTest {
@@ -24,7 +15,7 @@
 
     @Before
     public void setUp() {
-        subject = new ErrorEvent.Builder("name", "category")
+        subject = new ErrorEvent.Builder(BaseEvent.Name.AD_REQUEST, BaseEvent.Category.REQUESTS, 0.10000123)
                 .withErrorExceptionClassName("error_exception_class_name")
                 .withErrorMessage("error_message")
                 .withErrorStackTrace("error_stack_trace")
@@ -37,8 +28,9 @@ public void setUp() {
 
     @Test
     public void constructor_shouldCorrectlyAssignFieldsFromBuilder() throws Exception {
-        assertThat(subject.getEventName()).isEqualTo("name");
-        assertThat(subject.getEventCategory()).isEqualTo("category");
+        assertThat(subject.getName()).isEqualTo(BaseEvent.Name.AD_REQUEST);
+        assertThat(subject.getCategory()).isEqualTo(BaseEvent.Category.REQUESTS);
+        assertThat(subject.getSamplingRate()).isEqualTo(0.10000123);
         assertThat(subject.getScribeCategory()).isEqualTo(BaseEvent.ScribeCategory.EXCHANGE_CLIENT_ERROR);
         assertThat(subject.getErrorExceptionClassName()).isEqualTo("error_exception_class_name");
         assertThat(subject.getErrorMessage()).isEqualTo("error_message");
@@ -58,12 +50,12 @@ public void builder_withException_shouldCorrectlyPopulateErrorFields() throws Ex
             exception = e;
         }
 
-        subject = new ErrorEvent.Builder("name", "category")
+        subject = new ErrorEvent.Builder(BaseEvent.Name.AD_REQUEST, BaseEvent.Category.REQUESTS, 0.10000123)
                 .withException(exception)
                 .build();
 
-        assertThat(subject.getEventName()).isEqualTo("name");
-        assertThat(subject.getEventCategory()).isEqualTo("category");
+        assertThat(subject.getName()).isEqualTo(BaseEvent.Name.AD_REQUEST);
+        assertThat(subject.getCategory()).isEqualTo(BaseEvent.Category.REQUESTS);
         assertThat(subject.getScribeCategory()).isEqualTo(BaseEvent.ScribeCategory.EXCHANGE_CLIENT_ERROR);
         assertThat(subject.getErrorExceptionClassName()).isEqualTo("java.lang.ClassCastException");
         assertThat(subject.getErrorMessage()).isEqualTo("bad cast");
@@ -74,6 +66,9 @@ public void builder_withException_shouldCorrectlyPopulateErrorFields() throws Ex
         assertThat(subject.getErrorFileName()).isEqualTo("ErrorEventTest.java");
         assertThat(subject.getErrorClassName()).isEqualTo("com.mopub.common.event.ErrorEventTest");
         assertThat(subject.getErrorMethodName()).isEqualTo("builder_withException_shouldCorrectlyPopulateErrorFields");
-        assertThat(subject.getErrorLineNumber()).isEqualTo(56);
+
+        // Ideally we check the actual line number here, but since this file is continuously
+        // changing, it makes the test brittle to do so
+        assertThat(subject.getErrorLineNumber()).isNotNull();
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/EventDispatcherTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/EventDispatcherTest.java
index bd4ee8cf..1c32fd16 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/event/EventDispatcherTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/EventDispatcherTest.java
@@ -2,10 +2,10 @@
 
 import android.app.Activity;
 import android.os.HandlerThread;
+import android.os.Looper;
 import android.os.Message;
 
 import com.mopub.common.test.support.SdkTestRunner;
-import com.ximpleware.extended.parser.WIN1250;
 
 import org.junit.Before;
 import org.junit.Test;
@@ -37,19 +37,13 @@ public void setUp() {
         recorders.add(mockEventRecorder1);
         recorders.add(mockEventRecorder2);
     }
-    
-    @Test
-    public void constructor_shouldStartHandlerThread() throws Exception {
-        subject = new EventDispatcher(recorders, mockHandlerThread);
-        verify(mockHandlerThread).start();
-    }
 
     @Test
     public void handler_handleMessage_shouldCallRecordOnAllRecorders() throws Exception {
         Message message = new Message();
         message.obj = mock(Event.class);
 
-        subject = new EventDispatcher(recorders, mockHandlerThread);
+        subject = new EventDispatcher(recorders, Looper.getMainLooper());
         subject.getHandlerCallback().handleMessage(message);
 
         verify(mockEventRecorder1).record(eq((Event) message.obj));
@@ -61,7 +55,7 @@ public void handler_handleMessage_withNonBaseEventTypeMessageShouldNotRecordOnAn
         Message message = new Message();
         message.obj = mock(Activity.class);
 
-        subject = new EventDispatcher(recorders, mockHandlerThread);
+        subject = new EventDispatcher(recorders, Looper.getMainLooper());
         subject.getHandlerCallback().handleMessage(message);
 
         verify(mockEventRecorder1, never()).record(any(BaseEvent.class));
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/EventSamplerTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/EventSamplerTest.java
new file mode 100644
index 00000000..d6494a11
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/EventSamplerTest.java
@@ -0,0 +1,45 @@
+package com.mopub.common.event;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+
+import java.util.Random;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class EventSamplerTest {
+
+    private EventSampler subject;
+    @Mock Random mockRandom;
+    @Mock BaseEvent mockBaseEvent;
+
+    @Before
+    public void setUp() {
+        subject = new EventSampler(mockRandom);
+        when(mockBaseEvent.getSamplingRate()).thenReturn(0.10);
+    }
+
+    @Test
+    public void sample_withRandomNumberLessThan10Percent_shouldReturnTrue() throws Exception {
+        when(mockRandom.nextDouble()).thenReturn(0.09);
+
+        boolean result = subject.sample(mockBaseEvent);
+
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void sample_withRandomNumberGreaterOrEqualTo10Percent_shouldReturnFalse() throws Exception {
+        when(mockRandom.nextDouble()).thenReturn(0.10);
+
+        boolean result = subject.sample(mockBaseEvent);
+
+        assertThat(result).isFalse();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/EventSerializerTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/EventSerializerTest.java
index e22afbd6..22a6bebc 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/event/EventSerializerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/EventSerializerTest.java
@@ -3,7 +3,6 @@
 import android.app.Activity;
 
 import com.mopub.common.ClientMetadata;
-import com.mopub.common.MoPub;
 import com.mopub.common.test.support.SdkTestRunner;
 
 import org.json.JSONArray;
@@ -80,10 +79,10 @@ public void serializeAsJson_withAllErrorEventFieldsPopulated_shouldCorrectJsonRe
 
     @Test
     public void serializeAsJson_shouldReturnJsonArrayOfEvents() throws Exception {
-        when(mockEvent.getEventName()).thenReturn("event");
-        when(mockEvent.getEventCategory()).thenReturn("event_category");
-        when(mockErrorEvent.getEventName()).thenReturn("error_event");
-        when(mockErrorEvent.getEventCategory()).thenReturn("error_event_category");
+        when(mockEvent.getName()).thenReturn(BaseEvent.Name.AD_REQUEST);
+        when(mockEvent.getCategory()).thenReturn(BaseEvent.Category.REQUESTS);
+        when(mockErrorEvent.getName()).thenReturn(BaseEvent.Name.IMPRESSION_REQUEST);
+        when(mockErrorEvent.getCategory()).thenReturn(BaseEvent.Category.REQUESTS);
 
         ArrayList<BaseEvent> events = new ArrayList<BaseEvent>();
         events.add(mockEvent);
@@ -93,20 +92,20 @@ public void serializeAsJson_shouldReturnJsonArrayOfEvents() throws Exception {
         assertThat(jsonArray.length()).isEqualTo(2);
 
         JSONObject jsonObject1 = jsonArray.getJSONObject(0);
-        assertThat(jsonObject1.getString("name")).isEqualTo("event");
-        assertThat(jsonObject1.getString("name_category")).isEqualTo("event_category");
+        assertThat(jsonObject1.getString("name")).isEqualTo(BaseEvent.Name.AD_REQUEST.getName());
+        assertThat(jsonObject1.getString("name_category")).isEqualTo("requests");
 
         JSONObject jsonObject2 = jsonArray.getJSONObject(1);
-        assertThat(jsonObject2.getString("name")).isEqualTo("error_event");
-        assertThat(jsonObject2.getString("name_category")).isEqualTo("error_event_category");
+        assertThat(jsonObject2.getString("name")).isEqualTo("impression_request");
+        assertThat(jsonObject2.getString("name_category")).isEqualTo("requests");
     }
 
     private void populateBaseEventFields(BaseEvent mockBaseEvent) {
         when(mockBaseEvent.getScribeCategory()).thenReturn(BaseEvent.ScribeCategory.EXCHANGE_CLIENT_EVENT);
-        when(mockBaseEvent.getEventName()).thenReturn("event_name");
-        when(mockBaseEvent.getEventCategory()).thenReturn("event_category");
+        when(mockBaseEvent.getName()).thenReturn(BaseEvent.Name.AD_REQUEST);
+        when(mockBaseEvent.getCategory()).thenReturn(BaseEvent.Category.REQUESTS);
         when(mockBaseEvent.getSdkProduct()).thenReturn(BaseEvent.SdkProduct.NATIVE);
-        when(mockBaseEvent.getSdkVersion()).thenReturn("3.3.0");
+        when(mockBaseEvent.getSdkVersion()).thenReturn("3.5.0");
         when(mockBaseEvent.getAdUnitId()).thenReturn("8cf00598d3664adaaeccd800e46afaca");
         when(mockBaseEvent.getAdCreativeId()).thenReturn("3c2b887e2c2a4cd0ae6a925440a62f0d");
         when(mockBaseEvent.getAdType()).thenReturn("html");
@@ -117,14 +116,15 @@ private void populateBaseEventFields(BaseEvent mockBaseEvent) {
         when(mockBaseEvent.getAppName()).thenReturn("MoPub Sample App");
         when(mockBaseEvent.getAppPackageName()).thenReturn("com.mopub.simpleadsdemo");
         when(mockBaseEvent.getAppVersion()).thenReturn("1.0");
+        when(mockBaseEvent.getObfuscatedClientAdvertisingId()).thenCallRealMethod();
         when(mockBaseEvent.getClientAdvertisingId()).thenReturn("38400000-8cf0-11bd-b23e-10b96e40000d");
         when(mockBaseEvent.getClientDoNotTrack()).thenReturn(false);
         when(mockBaseEvent.getDeviceManufacturer()).thenReturn("LGE");
         when(mockBaseEvent.getDeviceModel()).thenReturn("Nexus 5");
         when(mockBaseEvent.getDeviceProduct()).thenReturn("hammerhead");
         when(mockBaseEvent.getDeviceOsVersion()).thenReturn("5.0");
-        when(mockBaseEvent.getDeviceScreenWidthPx()).thenReturn(1080);
-        when(mockBaseEvent.getDeviceScreenHeightPx()).thenReturn(1920);
+        when(mockBaseEvent.getDeviceScreenWidthDip()).thenReturn(1080);
+        when(mockBaseEvent.getDeviceScreenHeightDip()).thenReturn(1920);
         when(mockBaseEvent.getGeoLat()).thenReturn(37.7833);
         when(mockBaseEvent.getGeoLon()).thenReturn(-122.4183333);
         when(mockBaseEvent.getGeoAccuracy()).thenReturn(10.0);
@@ -148,12 +148,12 @@ private void validateBaseEventFields(JSONObject jsonObject) throws Exception {
         assertThat(jsonObject.getLong("ts")).isEqualTo(1416447053472L);
 
         // Name Details
-        assertThat(jsonObject.getString("name")).isEqualTo("event_name");
-        assertThat(jsonObject.getString("name_category")).isEqualTo("event_category");
+        assertThat(jsonObject.getString("name")).isEqualTo(BaseEvent.Name.AD_REQUEST.getName());
+        assertThat(jsonObject.getString("name_category")).isEqualTo(BaseEvent.Category.REQUESTS.getCategory());
 
         // SDK Details
         assertThat(jsonObject.getInt("sdk_product")).isEqualTo(BaseEvent.SdkProduct.NATIVE.getType());
-        assertThat(jsonObject.getString("sdk_version")).isEqualTo(MoPub.SDK_VERSION);
+        assertThat(jsonObject.getString("sdk_version")).isEqualTo("3.5.0");
 
         // Ad Details
         assertThat(jsonObject.getString("ad_unit_id")).isEqualTo("8cf00598d3664adaaeccd800e46afaca");
@@ -164,13 +164,13 @@ private void validateBaseEventFields(JSONObject jsonObject) throws Exception {
         assertThat(jsonObject.getDouble("ad_height_px")).isEqualTo(50.0);
 
         // App Details
-        assertThat(jsonObject.getInt("app_platform")).isEqualTo(BaseEvent.AppPlatform.ANDROID.getType());
+        assertThat(jsonObject.getInt("app_platform")).isEqualTo(2);
         assertThat(jsonObject.getString("app_name")).isEqualTo("MoPub Sample App");
         assertThat(jsonObject.getString("app_package_name")).isEqualTo("com.mopub.simpleadsdemo");
         assertThat(jsonObject.getString("app_version")).isEqualTo("1.0");
 
         // Client Details
-        assertThat(jsonObject.getString("client_advertising_id")).isEqualTo("38400000-8cf0-11bd-b23e-10b96e40000d");
+        assertThat(jsonObject.getString("client_advertising_id")).isEqualTo("ifa:XXXX");
         assertThat(jsonObject.getBoolean("client_do_not_track")).isEqualTo(false);
 
         // Device Details
@@ -208,3 +208,4 @@ private void validateBaseEventFields(JSONObject jsonObject) throws Exception {
         assertThat(jsonObject.getLong("timestamp_client")).isEqualTo(1416447053472L);
     }
 }
+
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/EventTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/EventTest.java
index a5407f40..6a3e58f2 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/event/EventTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/EventTest.java
@@ -15,13 +15,14 @@
 
     @Before
     public void setUp() {
-        subject = new Event.Builder("name", "category").build();
+        subject = new Event.Builder(BaseEvent.Name.AD_REQUEST, BaseEvent.Category.REQUESTS, 0.10000123).build();
     }
 
     @Test
-    public void constructor_shouldCorrectlyAssignScribeCategoryFromBuilder() throws Exception {
-        assertThat(subject.getEventName()).isEqualTo("name");
-        assertThat(subject.getEventCategory()).isEqualTo("category");
+    public void constructor_shouldCorrectlyAssignScribeCategoryFromBuilder() {
+        assertThat(subject.getName()).isEqualTo(BaseEvent.Name.AD_REQUEST);
+        assertThat(subject.getCategory()).isEqualTo(BaseEvent.Category.REQUESTS);
+        assertThat(subject.getSamplingRate()).isEqualTo(0.10000123);
         assertThat(subject.getScribeCategory()).isEqualTo(BaseEvent.ScribeCategory.EXCHANGE_CLIENT_EVENT);
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/MoPubEventsTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/MoPubEventsTest.java
index d7dcfcce..d555f34e 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/event/MoPubEventsTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/MoPubEventsTest.java
@@ -22,7 +22,7 @@ public void setUp() {
     }
 
     @Test
-    public void getDispatcher_shouldReturnSingletonEventDispatcherWithNoopEventRecorder() throws Exception {
+    public void getDispatcher_shouldReturnSingletonEventDispatcherWithScribeEventRecorder() throws Exception {
         EventDispatcher eventDispatcher = MoPubEvents.getDispatcher();
         EventDispatcher eventDispatcher2 = MoPubEvents.getDispatcher();
 
@@ -35,7 +35,7 @@ public void getDispatcher_shouldReturnSingletonEventDispatcherWithNoopEventRecor
         }
 
         assertThat(eventRecorders.size()).isEqualTo(1);
-        assertThat(eventRecorders.get(0)).isInstanceOf(NoopEventRecorder.class);
+        assertThat(eventRecorders.get(0)).isInstanceOf(ScribeEventRecorder.class);
     }
 
     @Test
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/ScribeEventRecorderTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/ScribeEventRecorderTest.java
new file mode 100644
index 00000000..5681be25
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/ScribeEventRecorderTest.java
@@ -0,0 +1,210 @@
+package com.mopub.common.event;
+
+import android.os.Handler;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.network.ScribeBackoffPolicy;
+import com.mopub.network.ScribeRequest;
+import com.mopub.network.ScribeRequestManager;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+
+import java.util.List;
+import java.util.Queue;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyLong;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class ScribeEventRecorderTest {
+
+    private ScribeEventRecorder subject;
+    @Mock private EventSampler mockEventSampler;
+    @Mock private Queue<BaseEvent> mockQueue;
+    @Mock private EventSerializer mockEventSerializer;
+    @Mock private ScribeRequestManager mockScribeRequestManager;
+    @Mock private Handler mockHandler;
+    @Mock private Event mockEvent;
+
+    @Before
+    public void setUp() {
+        subject = new ScribeEventRecorder(
+                mockEventSampler,
+                mockQueue,
+                mockEventSerializer,
+                mockScribeRequestManager,
+                mockHandler
+        );
+
+        when(mockEventSampler.sample(any(Event.class))).thenReturn(true);
+    }
+
+    @Test
+    public void record_shouldSampleEvent() throws Exception {
+        subject.record(mockEvent);
+        verify(mockEventSampler).sample(mockEvent);
+    }
+
+    @Test
+    public void record_withQueueSizeBelowSendThreshold_shouldQueueEvent_shouldNotSendEvents_shouldScheduleNextPoll() throws Exception {
+        when(mockQueue.size()).thenReturn(99);
+
+        subject.record(mockEvent);
+
+        verify(mockQueue).add(mockEvent);
+        verify(mockScribeRequestManager, never()).makeRequest(any(ScribeRequest.ScribeRequestFactory.class), any(ScribeBackoffPolicy.class));
+        verify(mockHandler).postDelayed(any(ScribeEventRecorder.PollingRunnable.class), eq(Long.valueOf(120000)));
+    }
+
+    @Test
+    public void record_withQueueSizeAtSendThreshold_shouldQueueEvent_shouldSendEvents_shouldScheduleNextPoll() throws Exception {
+        when(mockQueue.size()).thenReturn(100);
+        when(mockQueue.peek()).thenReturn(mockEvent);
+        when(mockQueue.poll()).thenReturn(mockEvent);
+
+        subject.record(mockEvent);
+
+        verify(mockQueue).add(mockEvent);
+        verify(mockScribeRequestManager).makeRequest(any(ScribeRequest.ScribeRequestFactory.class), any(ScribeBackoffPolicy.class));
+        verify(mockHandler).postDelayed(any(ScribeEventRecorder.PollingRunnable.class), eq(Long.valueOf(120000)));
+    }
+
+    @Test
+    public void record_withQueueSizeAtQueueLimit_shouldNotQueueEvent_shouldNotSendEvents_shouldNotScheduleNextPoll() throws Exception {
+        when(mockQueue.size()).thenReturn(500);
+
+        subject.record(mockEvent);
+
+        verify(mockQueue, never()).add(mockEvent);
+        verify(mockScribeRequestManager, never()).makeRequest(any(ScribeRequest.ScribeRequestFactory.class), any(ScribeBackoffPolicy.class));
+        verify(mockHandler, never()).postDelayed(any(ScribeEventRecorder.PollingRunnable.class), anyLong());
+    }
+
+    @Test
+    public void sendEvents_shouldDequeueEvents_shouldAddRequestToScribeRequestManager() throws Exception {
+        when(mockQueue.size()).thenReturn(1);
+        when(mockQueue.peek()).thenReturn(mockEvent).thenReturn(null);
+        when(mockQueue.poll()).thenReturn(mockEvent).thenReturn(null);
+        doAnswer(new Answer() {
+            @Override
+            public Object answer(InvocationOnMock invocation) throws Throwable {
+                ScribeRequest scribeRequest = ((ScribeRequest.ScribeRequestFactory) invocation.getArguments()[0]).createRequest(null);
+                assertThat(scribeRequest.getUrl()).isEqualTo("https://analytics.mopub.com/i/jot/exchange_client_event");
+                assertThat(scribeRequest.getEvents()).containsOnly(mockEvent);
+                return null;
+            }
+        }).when(mockScribeRequestManager).makeRequest(any(ScribeRequest.ScribeRequestFactory.class), any(ScribeBackoffPolicy.class));
+
+        subject.sendEvents();
+
+        verify(mockQueue, times(2)).peek();
+        verify(mockQueue, times(1)).poll();
+        verify(mockScribeRequestManager).makeRequest(any(ScribeRequest.ScribeRequestFactory.class), any(ScribeBackoffPolicy.class));
+    }
+
+    @Test
+    public void sendEvents_withRequestInFlightShouldReturnFast() throws Exception {
+        when(mockScribeRequestManager.isAtCapacity()).thenReturn(true);
+
+        subject.sendEvents();
+
+        verify(mockQueue, never()).poll();
+        verify(mockScribeRequestManager, never()).makeRequest(any(ScribeRequest.ScribeRequestFactory.class), any(ScribeBackoffPolicy.class));
+    }
+    
+    @Test
+    public void dequeEvents_withQueueSizeGreaterThanEventSendThreshhold_shouldDequeueUpToEventSendThreshhold() throws Exception {
+        when(mockQueue.size()).thenReturn(101);
+        when(mockQueue.peek()).thenReturn(mockEvent);
+        when(mockQueue.poll()).thenReturn(mockEvent);
+
+        List<BaseEvent> events = subject.dequeueEvents();
+
+        verify(mockQueue, times(101)).peek();
+        verify(mockQueue, times(100)).poll();
+        assertThat(events.size()).isEqualTo(100);
+    }
+
+    @Test
+    public void dequeEvents_withQueueSizeLessThanEventSendThreshhold_shouldDequeueQueueSize() throws Exception {
+        when(mockQueue.size()).thenReturn(99);
+
+        when(mockQueue.peek()).thenAnswer(new Answer<BaseEvent>() {
+            int i;
+            @Override
+            public BaseEvent answer(InvocationOnMock invocation) throws Throwable {
+                return i++ < 99 ? mockEvent : null;
+            }
+        });
+
+        when(mockQueue.poll()).thenAnswer(new Answer<BaseEvent>() {
+            int i;
+            @Override
+            public BaseEvent answer(InvocationOnMock invocation) throws Throwable {
+                return i++ < 99 ? mockEvent : null;
+            }
+        });
+
+        List<BaseEvent> events = subject.dequeueEvents();
+
+        verify(mockQueue, times(100)).peek();
+        verify(mockQueue, times(99)).poll();
+        assertThat(events.size()).isEqualTo(99);
+    }
+
+    @Test
+    public void scheduleNextPoll_shouldPostDelayedPollingRunnable() throws Exception {
+        when(mockHandler.hasMessages(0)).thenReturn(false);
+        when(mockQueue.isEmpty()).thenReturn(false);
+
+        subject.scheduleNextPoll();
+
+        verify(mockHandler).postDelayed(any(ScribeEventRecorder.PollingRunnable.class), eq(Long.valueOf(120000)));
+    }
+
+    @Test
+    public void scheduleNextPoll_withPollScheduled_shouldNotPostDelayedPollingRunnable() throws Exception {
+        when(mockHandler.hasMessages(0)).thenReturn(true);
+        when(mockQueue.isEmpty()).thenReturn(false);
+
+        subject.scheduleNextPoll();
+
+        verify(mockHandler, never()).postDelayed(any(ScribeEventRecorder.PollingRunnable.class), anyLong());
+    }
+
+    @Test
+    public void scheduleNextPoll_withEmptyRequestQueue_shouldNotPostDelayedPollingRunnable() throws Exception {
+        when(mockHandler.hasMessages(0)).thenReturn(false);
+        when(mockQueue.isEmpty()).thenReturn(true);
+
+        subject.scheduleNextPoll();
+
+        verify(mockHandler, never()).postDelayed(any(ScribeEventRecorder.PollingRunnable.class), anyLong());
+    }
+
+    @Test
+    public void PollingRunnable_run_shouldSendEvents_shouldScheduleNextPoll() throws Exception {
+        when(mockQueue.size()).thenReturn(100);
+        when(mockQueue.peek()).thenReturn(mockEvent);
+        when(mockQueue.poll()).thenReturn(mockEvent);
+
+        ScribeEventRecorder.PollingRunnable pollingRunnable = subject.new PollingRunnable();
+        pollingRunnable.run();
+
+        verify(mockScribeRequestManager).makeRequest(any(ScribeRequest.ScribeRequestFactory.class), any(ScribeBackoffPolicy.class));
+        verify(mockHandler).postDelayed(any(ScribeEventRecorder.PollingRunnable.class), eq(Long.valueOf(120000)));
+    }
+}
+
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/DeviceUtilsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/DeviceUtilsTest.java
new file mode 100644
index 00000000..b7f25039
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/DeviceUtilsTest.java
@@ -0,0 +1,119 @@
+package com.mopub.common.util;
+
+import android.app.Activity;
+import android.content.pm.ActivityInfo;
+import android.content.res.Configuration;
+import android.content.res.Resources;
+import android.view.Surface;
+
+import com.mopub.common.CreativeOrientation;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.nativeads.test.support.MoPubShadowDisplay;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+public class DeviceUtilsTest {
+
+    private Activity testActivity;
+    private Resources testResources;
+
+    @Before
+    public void setup() {
+        testActivity = Robolectric.buildActivity(Activity.class).create().get();
+        testResources = testActivity.getResources();
+    }
+
+    @Test
+    public void getOrientation_whenReverseLandscape_shouldReturnReverseLandscape() {
+        testResources.getConfiguration().orientation = Configuration.ORIENTATION_LANDSCAPE;
+        MoPubShadowDisplay.setStaticRotation(Surface.ROTATION_270);
+
+        assertThat(DeviceUtils.getScreenOrientation(testActivity)).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE);
+    }
+
+    @Test
+    public void getOrientation_whenLandscape_shouldReturnLandscape() {
+        testResources.getConfiguration().orientation = Configuration.ORIENTATION_LANDSCAPE;
+        MoPubShadowDisplay.setStaticRotation(Surface.ROTATION_90);
+
+        assertThat(DeviceUtils.getScreenOrientation(testActivity)).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
+    }
+
+    @Test
+    public void getOrientation_whenPortrait_shouldReturnPortrait() {
+        testResources.getConfiguration().orientation = Configuration.ORIENTATION_PORTRAIT;
+        MoPubShadowDisplay.setStaticRotation(Surface.ROTATION_0);
+
+        assertThat(DeviceUtils.getScreenOrientation(testActivity)).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+    }
+
+    @Test
+    public void getOrientation_whenReversePortrait_shouldReturnReversePortrait() {
+        testResources.getConfiguration().orientation = Configuration.ORIENTATION_PORTRAIT;
+        MoPubShadowDisplay.setStaticRotation(Surface.ROTATION_180);
+
+        assertThat(DeviceUtils.getScreenOrientation(testActivity)).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT);
+    }
+    
+    @Test
+    public void lockOrientation_toLandscapeWhenLandscape_shouldRemainTheSame() throws Exception {
+        testResources.getConfiguration().orientation = Configuration.ORIENTATION_LANDSCAPE;
+        MoPubShadowDisplay.setStaticRotation(Surface.ROTATION_90);
+
+        DeviceUtils.lockOrientation(testActivity, CreativeOrientation.LANDSCAPE);
+        assertThat(testActivity.getRequestedOrientation()).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
+    }
+
+    @Test
+    public void lockOrientation_toLandscapeWhenReverseLandscape_shouldBeReverseLandscape() {
+
+        testResources.getConfiguration().orientation = Configuration.ORIENTATION_LANDSCAPE;
+        MoPubShadowDisplay.setStaticRotation(Surface.ROTATION_180);  // Reverse landscape
+
+        DeviceUtils.lockOrientation(testActivity, CreativeOrientation.LANDSCAPE);
+        assertThat(testActivity.getRequestedOrientation()).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE);
+    }
+
+    @Test
+    public void lockOrientation_toLandscapeWhenPortrait_shouldBeLandscape() {
+        testResources.getConfiguration().orientation = Configuration.ORIENTATION_PORTRAIT;
+        MoPubShadowDisplay.setStaticRotation(Surface.ROTATION_180);  // Reverse portrait
+
+        DeviceUtils.lockOrientation(testActivity, CreativeOrientation.LANDSCAPE);
+        assertThat(testActivity.getRequestedOrientation()).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
+    }
+
+    @Test
+    public void lockOrientation_toPortraitWhenPortrait_shouldRemainPortrait() {
+
+        testResources.getConfiguration().orientation = Configuration.ORIENTATION_PORTRAIT;
+        MoPubShadowDisplay.setStaticRotation(Surface.ROTATION_0);
+
+        DeviceUtils.lockOrientation(testActivity, CreativeOrientation.PORTRAIT);
+        assertThat(testActivity.getRequestedOrientation()).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+    }
+
+    @Test
+    public void lockOrientation_toPortraitWhenReversePortrait_shouldRemainReversePortrait() {
+        testResources.getConfiguration().orientation = Configuration.ORIENTATION_PORTRAIT;
+        MoPubShadowDisplay.setStaticRotation(Surface.ROTATION_180);
+
+        DeviceUtils.lockOrientation(testActivity, CreativeOrientation.PORTRAIT);
+        assertThat(testActivity.getRequestedOrientation()).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT);
+    }
+
+    @Test
+    public void lockOrientation_toPortraitWhenLandscape_shouldBeLandscape() {
+        testResources.getConfiguration().orientation = Configuration.ORIENTATION_LANDSCAPE;
+        MoPubShadowDisplay.setStaticRotation(Surface.ROTATION_0);  // Reverse landscape
+
+        DeviceUtils.lockOrientation(testActivity, CreativeOrientation.PORTRAIT);
+        assertThat(testActivity.getRequestedOrientation()).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/DipsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/DipsTest.java
new file mode 100644
index 00000000..c0d46973
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/DipsTest.java
@@ -0,0 +1,42 @@
+package com.mopub.common.util;
+
+import android.app.Activity;
+import android.content.res.Resources;
+import android.util.DisplayMetrics;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class DipsTest {
+
+    @Mock private Activity activity;
+    @Mock private Resources resources;
+
+    @Before
+    public void setUp() {
+        DisplayMetrics displayMetrics = new DisplayMetrics();
+        displayMetrics.widthPixels = 480;
+        displayMetrics.heightPixels = 800;
+        displayMetrics.density = 2;
+        when(activity.getResources()).thenReturn(resources);
+        when(resources.getDisplayMetrics()).thenReturn(displayMetrics);
+    }
+
+    @Test
+    public void screenWidthAsIntDips_shouldReturnTheWidthAsDips() throws Exception {
+        assertThat(Dips.screenWidthAsIntDips(activity)).isEqualTo(240);
+    }
+
+    @Test
+    public void screenHeightAsIntDips_shouldReturnTheHeightAsDips() throws Exception {
+        assertThat(Dips.screenHeightAsIntDips(activity)).isEqualTo(400);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/IntentsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/IntentsTest.java
index ee879eae..94aa1180 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/util/IntentsTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/IntentsTest.java
@@ -121,31 +121,85 @@ public void deviceCanHandleIntent_whenActivityCanNotResolveIntent_shouldReturnFa
     public void intentForNativeBrowserScheme_shouldProperlyHandleEncodedUrls() throws UrlParseException {
         Intent intent;
 
-        intent = Intents.intentForNativeBrowserScheme("mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.example.com");
+        intent = Intents.intentForNativeBrowserScheme(Uri.parse("mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.example.com"));
         assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
         assertThat(intent.getDataString()).isEqualTo("http://www.example.com");
 
-        intent = Intents.intentForNativeBrowserScheme("mopubnativebrowser://navigate?url=http://www.example.com/?query=1&two=2");
+        intent = Intents.intentForNativeBrowserScheme(Uri.parse("mopubnativebrowser://navigate?url=http://www.example.com/?query=1&two=2"));
         assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
         assertThat(intent.getDataString()).isEqualTo("http://www.example.com/?query=1");
 
-        intent = Intents.intentForNativeBrowserScheme("mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.example.com%2F%3Fquery%3D1%26two%3D2");
+        intent = Intents.intentForNativeBrowserScheme(Uri.parse("mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.example.com%2F%3Fquery%3D1%26two%3D2"));
         assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
         assertThat(intent.getDataString()).isEqualTo("http://www.example.com/?query=1&two=2");
     }
 
     @Test(expected = UrlParseException.class)
     public void intentForNativeBrowserScheme_whenNotMoPubNativeBrowser_shouldThrowException() throws UrlParseException {
-        Intents.intentForNativeBrowserScheme("mailto://navigate?url=http://www.example.com");
+        Intents.intentForNativeBrowserScheme(Uri.parse("mailto://navigate?url=http://www.example.com"));
     }
 
     @Test(expected = UrlParseException.class)
     public void intentForNativeBrowserScheme_whenNotNavigate_shouldThrowException() throws UrlParseException {
-        Intents.intentForNativeBrowserScheme("mopubnativebrowser://getout?url=http://www.example.com");
+        Intents.intentForNativeBrowserScheme(Uri.parse("mopubnativebrowser://getout?url=http://www.example.com"));
     }
 
     @Test(expected = UrlParseException.class)
     public void intentForNativeBrowserScheme_whenUrlParameterMissing_shouldThrowException() throws UrlParseException {
-        Intents.intentForNativeBrowserScheme("mopubnativebrowser://navigate");
+        Intents.intentForNativeBrowserScheme(Uri.parse("mopubnativebrowser://navigate"));
+    }
+
+    @Test
+    public void intentForShareTweetScheme_whenValidUri_shouldReturnShareTweetIntent() throws UrlParseException {
+        Intent intent;
+        final String shareMessage = "Check out @SpaceX's Tweet: https://twitter.com/SpaceX/status/596026229536460802";
+
+        intent = Intents.intentForShareTweet(Uri.parse("mopubshare://tweet?screen_name=SpaceX&tweet_id=596026229536460802"));
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_SEND);
+        assertThat(intent.getType()).isEqualTo("text/plain");
+        assertThat(intent.getStringExtra(Intent.EXTRA_SUBJECT)).isEqualTo(shareMessage);
+        assertThat(intent.getStringExtra(Intent.EXTRA_TEXT)).isEqualTo(shareMessage);
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForShareTweetScheme_whenWrongScheme_shouldThrowException() throws UrlParseException {
+        Intents.intentForShareTweet(Uri.parse("mailto://tweet?screen_name=SpaceX&tweet_id=596026229536460802"));
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForShareTweetScheme_whenWrongHost_shouldThrowException() throws UrlParseException {
+        Intents.intentForShareTweet(Uri.parse("mopubshare://twat?screen_name=SpaceX&tweet_id=596026229536460802"));
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForShareTweetScheme_whenScreenNameParameterMissing_shouldThrowException() throws UrlParseException {
+        Intents.intentForShareTweet(Uri.parse("mopubshare://tweet?foo=SpaceX&tweet_id=596026229536460802"));
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForShareTweetScheme_whenScreenNameParameterIsEmpty_shouldThrowException() throws UrlParseException {
+        Intents.intentForShareTweet(Uri.parse("mopubshare://tweet?screen_name=&tweet_id=596026229536460802"));
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForShareTweetScheme_whenTweetIdParameterMissing_shouldThrowException() throws UrlParseException {
+        Intents.intentForShareTweet(Uri.parse("mopubshare://tweet?screen_name=SpaceX&bar=596026229536460802"));
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForShareTweetScheme_whenTweetIdParameterIsEmpty_shouldThrowException() throws UrlParseException {
+        Intents.intentForShareTweet(Uri.parse("mopubshare://tweet?screen_name=SpaceX&tweet_id="));
+    }
+
+    @Test
+    public void launchIntentForUserClick_shouldStartActivity() throws Exception {
+        Context context = Robolectric.buildActivity(Activity.class).create().get()
+                .getApplicationContext();
+        Intent intent = mock(Intent.class);
+
+        Intents.launchIntentForUserClick(context, intent, null);
+        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+
+        assertThat(startedActivity).isNotNull();
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/ManifestUtilsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/ManifestUtilsTest.java
index 99a9c3f8..9bfa41ec 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/util/ManifestUtilsTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/ManifestUtilsTest.java
@@ -48,7 +48,7 @@
 
     @Before
     public void setUp() throws Exception {
-        context = spy(new Activity());
+        context = spy(Robolectric.buildActivity(Activity.class).create().get());
 
         requiredWebViewSdkActivities = ManifestUtils.getRequiredWebViewSdkActivities();
         requiredNativeSdkActivities = ManifestUtils.getRequiredNativeSdkActivities();
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/ReflectionTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/ReflectionTest.java
index bf0ddd79..b36ae026 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/util/ReflectionTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/ReflectionTest.java
@@ -6,6 +6,7 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
 
 import static com.mopub.common.util.Reflection.MethodBuilder;
@@ -22,7 +23,7 @@
 
     @Before
     public void setup(){
-        activity = new Activity();
+        activity = Robolectric.buildActivity(Activity.class).create().get();
         view = new View(activity);
         string = "goat";
     }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/ViewsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/ViewsTest.java
index 7f09ebcc..48fa3198 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/util/ViewsTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/ViewsTest.java
@@ -2,6 +2,7 @@
 
 import android.app.Activity;
 import android.content.Context;
+import android.content.res.Resources;
 import android.view.View;
 import android.widget.RelativeLayout;
 import android.widget.TextView;
@@ -9,6 +10,7 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
 
 import static org.fest.assertions.api.Assertions.assertThat;
@@ -18,12 +20,15 @@
     private Context context;
     private View subject;
     private RelativeLayout parent;
+    private Activity testActivity;
+    private Resources testResources;
 
     @Before
     public void setup() {
-        context = new Activity();
+        context = Robolectric.buildActivity(Activity.class).create().get();
         subject = new View(context);
         parent = new RelativeLayout(context);
+
     }
 
     @Test
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertReporterTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertReporterTest.java
index 89cf32d8..d199d9f8 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertReporterTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertReporterTest.java
@@ -67,7 +67,7 @@ public void constructor_shouldCreateSendToIntentWithEmailAddress() throws Except
 
         assertThat(emailIntent.getAction()).isEqualTo(Intent.ACTION_SEND_MULTIPLE);
         assertThat(emailIntent.getType()).isEqualTo("plain/text");
-        assertThat(emailIntent.getDataString()).isEqualTo("mailto:");
+        assertThat(emailIntent.getData().toString()).isEqualTo("mailto:");
         assertThat(emailIntent.getStringArrayExtra(Intent.EXTRA_EMAIL)[0]).isEqualTo(EMAIL_ADDRESS);
     }
 
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdTypeTranslatorTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdTypeTranslatorTest.java
index 1461d2c8..2d782a64 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/AdTypeTranslatorTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/AdTypeTranslatorTest.java
@@ -11,6 +11,7 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 
 import java.util.HashMap;
 
@@ -23,7 +24,6 @@
     private String customEventName;
     private MoPubView moPubView;
     private MoPubInterstitial.MoPubInterstitialView moPubInterstitialView;
-    private Context context;
     HashMap<String, String> headers;
 
     @Before
@@ -31,7 +31,7 @@ public void setUp() throws Exception {
         moPubView = mock(MoPubView.class);
         moPubInterstitialView = mock(MoPubInterstitial.MoPubInterstitialView.class);
 
-        context = new Activity();
+        Context context = Robolectric.buildActivity(Activity.class).create().get();
         stub(moPubView.getContext()).toReturn(context);
         stub(moPubInterstitialView.getContext()).toReturn(context);
 
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdViewControllerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdViewControllerTest.java
index 20be1827..aad6cc28 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/AdViewControllerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/AdViewControllerTest.java
@@ -1,5 +1,6 @@
 package com.mopub.mobileads;
 
+import android.Manifest;
 import android.app.Activity;
 import android.content.Context;
 import android.net.ConnectivityManager;
@@ -14,9 +15,13 @@
 import com.mopub.mobileads.test.support.ThreadUtils;
 import com.mopub.network.AdRequest;
 import com.mopub.network.AdResponse;
+import com.mopub.network.MoPubNetworkError;
+import com.mopub.network.MoPubRequestQueue;
 import com.mopub.network.Networking;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.NoConnectionError;
 import com.mopub.volley.Request;
-import com.mopub.volley.RequestQueue;
+import com.mopub.volley.VolleyError;
 
 import org.junit.After;
 import org.junit.Before;
@@ -26,7 +31,7 @@
 import org.mockito.Mock;
 import org.robolectric.Robolectric;
 
-import edu.emory.mathcs.backport.java.util.Collections;
+import java.util.Collections;
 
 import static com.mopub.common.VolleyRequestMatcher.isUrl;
 import static org.fest.assertions.api.Assertions.assertThat;
@@ -37,6 +42,7 @@
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyZeroInteractions;
 import static org.mockito.Mockito.when;
@@ -44,25 +50,30 @@
 
 @RunWith(SdkTestRunner.class)
 public class AdViewControllerTest {
+
+    private static final int[] HTML_ERROR_CODES = new int[]{400, 401, 402, 403, 404, 405, 407, 408,
+            409, 410, 411, 412, 413, 414, 415, 416, 417, 500, 501, 502, 503, 504, 505};
+
     private AdViewController subject;
     @Mock
     private MoPubView mockMoPubView;
     @Mock
-    private RequestQueue mockRequestQueue;
+    private MoPubRequestQueue mockRequestQueue;
     private Reflection.MethodBuilder methodBuilder;
-    private Activity context;
+
     private AdResponse response;
+    private Activity activity;
 
     @Before
     public void setup() {
-        context = Robolectric.buildActivity(Activity.class).create().get();
-        shadowOf(context).grantPermissions(android.Manifest.permission.ACCESS_NETWORK_STATE);
+        activity = Robolectric.buildActivity(Activity.class).create().get();
+        shadowOf(activity).grantPermissions(android.Manifest.permission.ACCESS_NETWORK_STATE);
 
         when(mockMoPubView.getAdFormat()).thenReturn(AdFormat.BANNER);
-        when(mockMoPubView.getContext()).thenReturn(context);
+        when(mockMoPubView.getContext()).thenReturn(activity);
         Networking.setRequestQueueForTesting(mockRequestQueue);
 
-        subject = new AdViewController(context, mockMoPubView);
+        subject = new AdViewController(activity, mockMoPubView);
 
         methodBuilder = TestMethodBuilderFactory.getSingletonMock();
         reset(methodBuilder);
@@ -76,7 +87,7 @@ public void setup() {
                 .setAdType("html")
                 .setFailoverUrl("failUrl")
                 .setResponseBody("testResponseBody")
-                .setServerExtras(Collections.emptyMap())
+                .setServerExtras(Collections.<String, String>emptyMap())
                 .build();
     }
 
@@ -85,6 +96,14 @@ public void tearDown() throws Exception {
         reset(methodBuilder);
     }
 
+    @Test
+    public void cleanup_shouldNotHoldViewOrUrlGenerator() {
+        subject.cleanup();
+
+        assertThat(subject.getMoPubView()).isNull();
+        assertThat(subject.generateAdUrl()).isNull();
+    }
+
     @Test
     public void adDidFail_shouldScheduleRefreshTimer_shouldCallMoPubViewAdFailed() throws Exception {
         Robolectric.pauseMainLooper();
@@ -109,6 +128,7 @@ public void adDidFail_withNullMoPubView_shouldNotScheduleRefreshTimer_shouldNotC
         verify(mockMoPubView, never()).adFailed(any(MoPubErrorCode.class));
     }
 
+
     @Test
     public void scheduleRefreshTimer_shouldNotScheduleIfRefreshTimeIsNull() throws Exception {
         response = response.toBuilder().setRefreshTimeMilliseconds(null).build();
@@ -459,4 +479,158 @@ public void setAdContentView_whenNotServerDimensions_shouldWrapAndCenterView() t
         assertThat(layoutParams.height).isEqualTo(FrameLayout.LayoutParams.WRAP_CONTENT);
         assertThat(layoutParams.gravity).isEqualTo(Gravity.CENTER);
     }
+
+    @Test
+    public void onAdLoadSuccess_withResponseContainingRefreshTime_shouldSetNewRefreshTime() {
+        assertThat(subject.getRefreshTimeMillis()).isEqualTo(60000);
+
+        response = response.toBuilder().setRefreshTimeMilliseconds(100000).build();
+        subject.onAdLoadSuccess(response);
+
+        assertThat(subject.getRefreshTimeMillis()).isEqualTo(100000);
+    }
+
+    @Test
+    public void onAdLoadSuccess_withResponseNotContainingRefreshTime_shoulSetRefreshTimeToNull() {
+        response = response.toBuilder().setRefreshTimeMilliseconds(null).build();
+        subject.onAdLoadSuccess(response);
+
+        assertThat(subject.getRefreshTimeMillis()).isNull();
+    }
+
+    @Test
+    public void onAdLoadError_withMoPubNetworkErrorIncludingRefreshTime_shouldSetNewRefreshTime() {
+        subject.setRefreshTimeMillis(54321);
+
+        subject.onAdLoadError(
+                new MoPubNetworkError(
+                        "network error with specified refresh time",
+                        MoPubNetworkError.Reason.NO_FILL,
+                        1000)
+        );
+
+        assertThat(subject.getRefreshTimeMillis()).isEqualTo(1000);
+    }
+
+    @Test
+    public void onAdLoadError_withMoPubNetworkErrorNotIncludingRefreshTime_shouldNotModifyRefreshTime() {
+        subject.setRefreshTimeMillis(12345);
+
+        subject.onAdLoadError(
+                new MoPubNetworkError(
+                        "network error that does not specify refresh time",
+                        MoPubNetworkError.Reason.UNSPECIFIED)
+        );
+
+        assertThat(subject.getRefreshTimeMillis()).isEqualTo(12345);
+    }
+
+    @Test
+    public void onAdLoadError_withVolleyErrorThatIsNotAnInstanceOfMoPubNetworkError_shouldNotModifyRefreshTime() {
+        subject.onAdLoadError(new VolleyError("message"));
+
+        assertThat(subject.getRefreshTimeMillis()).isEqualTo(60000);
+    }
+
+    @Test
+    public void onAdLoadError_withErrorReasonWarmingUp_shouldReturnErrorCodeWarmup_shouldCallMoPubViewAdFailed() {
+        final VolleyError expectedInternalError = new MoPubNetworkError(
+                MoPubNetworkError.Reason.WARMING_UP);
+
+        subject.onAdLoadError(expectedInternalError);
+
+        verify(mockMoPubView).adFailed(MoPubErrorCode.WARMUP);
+    }
+
+    @Test
+    public void onAdLoadError_whenNoNetworkConnection_shouldReturnErrorCodeNoConnection_shouldCallMoPubViewAdFailed() {
+        subject.onAdLoadError(new NoConnectionError());
+
+        // DeviceUtils#isNetworkAvailable conveniently returns false due to
+        // not having the network permission.
+        verify(mockMoPubView).adFailed(MoPubErrorCode.NO_CONNECTION);
+    }
+
+    @Test
+    public void onAdLoadError_withInvalidServerResponse_shouldReturnErrorCodeServerError_shouldCallMoPubViewAdFailed_shouldIncrementBackoffPower() {
+        for (int htmlErrorCode : HTML_ERROR_CODES) {
+            final int oldBackoffPower = subject.mBackoffPower;
+            final NetworkResponse errorNetworkResponse = new NetworkResponse(htmlErrorCode, null,
+                    null, true, 0);
+            final VolleyError volleyError = new VolleyError(errorNetworkResponse);
+
+            subject.onAdLoadError(volleyError);
+
+            assertThat(subject.mBackoffPower).isEqualTo(oldBackoffPower + 1);
+        }
+        verify(mockMoPubView, times(HTML_ERROR_CODES.length)).adFailed(MoPubErrorCode.SERVER_ERROR);
+    }
+
+    @Test
+    public void getErrorCodeFromVolleyError_whenNoConnection_shouldReturnErrorCodeNoConnection() {
+        final VolleyError noConnectionError = new NoConnectionError();
+
+        // DeviceUtils#isNetworkAvailable conveniently returns false due to
+        // not having the internet permission.
+        final MoPubErrorCode errorCode = AdViewController.getErrorCodeFromVolleyError(
+                noConnectionError, activity);
+
+        assertThat(errorCode).isEqualTo(MoPubErrorCode.NO_CONNECTION);
+    }
+
+    @Test
+    public void getErrorCodeFromVolleyError_withNullResponse_whenConnectionValid_shouldReturnErrorCodeUnspecified() {
+        final VolleyError noConnectionError = new NoConnectionError();
+
+        shadowOf(activity).grantPermissions(Manifest.permission.INTERNET);
+        final MoPubErrorCode errorCode = AdViewController.getErrorCodeFromVolleyError(
+                noConnectionError, activity);
+
+        assertThat(errorCode).isEqualTo(MoPubErrorCode.UNSPECIFIED);
+    }
+
+    @Test
+    public void getErrorCodeFromVolleyError_withInvalidServerResponse_shouldReturnErrorCodeServerError() {
+        for (int htmlErrorCode : HTML_ERROR_CODES) {
+            final NetworkResponse errorNetworkResponse = new NetworkResponse(htmlErrorCode, null,
+                    null, true, 0);
+            final VolleyError volleyError = new VolleyError(errorNetworkResponse);
+
+            final MoPubErrorCode errorCode = AdViewController.getErrorCodeFromVolleyError(
+                    volleyError, activity);
+
+            assertThat(errorCode).isEqualTo(MoPubErrorCode.SERVER_ERROR);
+        }
+    }
+
+    @Test
+    public void getErrorCodeFromVolleyError_withErrorReasonWarmingUp_shouldReturnErrorCodeWarmingUp() {
+        final VolleyError networkError = new MoPubNetworkError(MoPubNetworkError.Reason.WARMING_UP);
+
+        final MoPubErrorCode errorCode = AdViewController.getErrorCodeFromVolleyError(
+                networkError, activity);
+
+        assertThat(errorCode).isEqualTo(MoPubErrorCode.WARMUP);
+    }
+
+    @Test
+    public void getErrorCodeFromVolleyError_withErrorReasonNoFill_shouldReturnErrorCodeNoFill() {
+        final VolleyError networkError = new MoPubNetworkError(MoPubNetworkError.Reason.NO_FILL);
+
+        final MoPubErrorCode errorCode = AdViewController.getErrorCodeFromVolleyError(
+                networkError, activity);
+
+        assertThat(errorCode).isEqualTo(MoPubErrorCode.NO_FILL);
+    }
+
+    @Test
+    public void getErrorCodeFromVolleyError_withErrorReasonBadHeaderData_shouldReturnErrorCodeUnspecified() {
+        final VolleyError networkError = new MoPubNetworkError(
+                MoPubNetworkError.Reason.BAD_HEADER_DATA);
+
+        final MoPubErrorCode errorCode = AdViewController.getErrorCodeFromVolleyError(
+                networkError, activity);
+
+        assertThat(errorCode).isEqualTo(MoPubErrorCode.UNSPECIFIED);
+    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseInterstitialActivityTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseInterstitialActivityTest.java
index 0154afd5..f5eefa09 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseInterstitialActivityTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseInterstitialActivityTest.java
@@ -16,8 +16,6 @@
 
 import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
 import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.stub;
 
 @RunWith(SdkTestRunner.class)
 public class BaseInterstitialActivityTest {
@@ -52,8 +50,7 @@ public void onCreate_shouldCreateView() throws Exception {
 
     @Test
     public void onDestroy_shouldCleanUpContentView() throws Exception {
-        subject = Robolectric.buildActivity(
-                TestInterstitialActivity.class).create().destroy().get();
+        subject = Robolectric.buildActivity(TestInterstitialActivity.class).create().destroy().get();
 
         assertThat(getContentView(subject).getChildCount()).isEqualTo(0);
     }
@@ -86,11 +83,4 @@ public void getBroadcastIdentifier_withMissingBroadCastId_shouldReturnNull() thr
     protected FrameLayout getContentView(BaseInterstitialActivity subject) {
         return (FrameLayout) ((ViewGroup) subject.findViewById(android.R.id.content)).getChildAt(0);
     }
-
-    protected void resetMockedView(View view) {
-        reset(view);
-        stub(view.getLayoutParams()).toReturn(
-                new FrameLayout.LayoutParams(FrameLayout.LayoutParams.WRAP_CONTENT,
-                        FrameLayout.LayoutParams.WRAP_CONTENT));
-    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseVideoPlayerActivityTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseVideoPlayerActivityTest.java
index bd7a88b1..f0017117 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseVideoPlayerActivityTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseVideoPlayerActivityTest.java
@@ -35,13 +35,13 @@ public void setup() throws Exception {
 
     @Test
     public void startMraid_shouldStartMraidVideoPlayerActivity() throws Exception {
-        startMraid(new Activity(), MRAID_VIDEO_URL);
+        startMraid(Robolectric.buildActivity(Activity.class).create().get(), MRAID_VIDEO_URL);
         assertMraidVideoPlayerActivityStarted(MraidVideoPlayerActivity.class, MRAID_VIDEO_URL);
     }
 
     @Test
     public void startVast_shouldStartMraidVideoPlayerActivity() throws Exception {
-        startVast(new Activity(), vastVideoConfiguration, testBroadcastIdentifier);
+        startVast(Robolectric.buildActivity(Activity.class).create().get(), vastVideoConfiguration, testBroadcastIdentifier);
         assertVastVideoPlayerActivityStarted(MraidVideoPlayerActivity.class, vastVideoConfiguration, testBroadcastIdentifier);
     }
 
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseWebViewTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseWebViewTest.java
index 4865c737..d9415f2d 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseWebViewTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseWebViewTest.java
@@ -11,6 +11,7 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowWebView;
 
@@ -27,7 +28,7 @@
 
     @Before
     public void setup() {
-        context = new Activity();
+        context = Robolectric.buildActivity(Activity.class).create().get();
     }
 
     @Config(reportSdk = VERSION_CODES.JELLY_BEAN_MR1)
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventBannerAdapterTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventBannerAdapterTest.java
index 6067d6df..ed91f90b 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventBannerAdapterTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventBannerAdapterTest.java
@@ -46,6 +46,7 @@
     private static final long BROADCAST_IDENTIFIER = 123;
     private Map<String, String> serverExtras;
     private CustomEventBanner banner;
+    private Map<String,Object> localExtras;
     private Map<String,Object> expectedLocalExtras;
     private HashMap<String,String> expectedServerExtras;
 
@@ -53,6 +54,12 @@
     public void setUp() throws Exception {
 
         when(moPubView.getAdTimeoutDelay()).thenReturn(null);
+        when(moPubView.getAdWidth()).thenReturn(320);
+        when(moPubView.getAdHeight()).thenReturn(50);
+
+        localExtras = new HashMap<String, Object>();
+        when(moPubView.getLocalExtras()).thenReturn(localExtras);
+
         serverExtras = new HashMap<String, String>();
         serverExtras.put("key", "value");
         serverExtras.put("another_key", "another_value");
@@ -61,11 +68,20 @@ public void setUp() throws Exception {
         expectedLocalExtras = new HashMap<String, Object>();
         expectedLocalExtras.put(DataKeys.AD_REPORT_KEY, mockAdReport);
         expectedLocalExtras.put("broadcastIdentifier", BROADCAST_IDENTIFIER);
+        expectedLocalExtras.put(DataKeys.AD_WIDTH, 320);
+        expectedLocalExtras.put(DataKeys.AD_HEIGHT, 50);
+
         expectedServerExtras = new HashMap<String, String>();
 
         banner = CustomEventBannerFactory.create(CLASS_NAME);
     }
 
+    @Test
+    public void constructor_shouldPopulateLocalExtrasWithAdWidthAndHeight() throws Exception {
+        assertThat(localExtras.get("com_mopub_ad_width")).isEqualTo(320);
+        assertThat(localExtras.get("com_mopub_ad_height")).isEqualTo(50);
+    }
+
     @Test
     public void timeout_shouldSignalFailureAndInvalidateWithDefaultDelay() throws Exception {
         subject.loadAd();
@@ -221,7 +237,7 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
 
     @Test
     public void onBannerLoaded_shouldSignalMoPubView() throws Exception {
-        View view = new View(new Activity());
+        View view = new View(Robolectric.buildActivity(Activity.class).create().get());
         subject.onBannerLoaded(view);
 
         verify(moPubView).nativeAdLoaded();
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlWebViewClientTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlWebViewClientTest.java
index 69e8a19b..d2db93fd 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlWebViewClientTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlWebViewClientTest.java
@@ -26,13 +26,14 @@
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.stub;
-import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
 public class HtmlWebViewClientTest {
 
+    private static final String CLICKTHROUGH_URL = "http://clickthrough";
+
     private HtmlWebViewClient subject;
     private HtmlWebViewListener htmlWebViewListener;
     private BaseHtmlWebView htmlWebView;
@@ -44,7 +45,8 @@ public void setUp() throws Exception {
         htmlWebView = mock(BaseHtmlWebView.class);
         context = Robolectric.buildActivity(Activity.class).create().get().getApplicationContext();
         when(htmlWebView.getContext()).thenReturn(context);
-        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, "clickthrough", "redirect");
+        when(htmlWebView.wasClicked()).thenReturn(true);
+        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, CLICKTHROUGH_URL, "redirect");
     }
 
     @Test
@@ -71,60 +73,6 @@ public void shouldOverrideUrlLoading_withMoPubFailLoad_shouldCallLoadFailUrl() t
         verify(htmlWebViewListener).onFailed(UNSPECIFIED);
     }
 
-    @Test
-    public void shouldOverrideUrlLoading_withMoPubCustom_withUserClick_shouldStartCustomIntent() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(true);
-
-        boolean didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, "mopub://custom?fnc=myFnc&data=myData");
-
-        assertThat(didOverrideUrl).isTrue();
-        verify(htmlWebViewListener).onClicked();
-        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedActivity).isNotNull();
-        assertThat(startedActivity.getAction()).isEqualTo("myFnc");
-        assertThat(startedActivity.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
-        assertThat(startedActivity.getStringExtra(HtmlBannerWebView.EXTRA_AD_CLICK_DATA)).isEqualTo("myData");
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withMoPubCustom_withoutUserClick_shouldNotStartActivity() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(false);
-
-        boolean didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, "mopub://custom?fnc=myFnc&data=myData");
-
-        assertThat(didOverrideUrl).isTrue();
-        verify(htmlWebViewListener, never()).onClicked();
-        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedActivity).isNull();
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withMoPubCustomAndNullData_withUserClick_shouldStartCustomIntent() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(true);
-
-        boolean didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, "mopub://custom?fnc=myFnc");
-
-        assertThat(didOverrideUrl).isTrue();
-        verify(htmlWebViewListener).onClicked();
-        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedActivity).isNotNull();
-        assertThat(startedActivity.getAction()).isEqualTo("myFnc");
-        assertThat(startedActivity.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
-        assertThat(startedActivity.getStringExtra(HtmlBannerWebView.EXTRA_AD_CLICK_DATA)).isNull();
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withMoPubCustomAndNullData_withoutUserClick_shouldNotStartCustomIntent() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(false);
-
-        boolean didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, "mopub://custom?fnc=myFnc");
-
-        assertThat(didOverrideUrl).isTrue();
-        verify(htmlWebViewListener, never()).onClicked();
-        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedActivity).isNull();
-    }
-
     @Test
     public void shouldOverrideUrlLoading_withPhoneIntent_shouldStartDefaultIntent() throws Exception {
         assertPhoneUrlStartedCorrectIntent("tel:");
@@ -160,11 +108,12 @@ public void shouldOverrideUrlLoading_withCustomApplicationIntent_withoutUserClic
 
         assertThat(didOverrideUrl).isTrue();
         verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
         assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
     }
 
     @Test
-    public void shouldOverrideUrlLoading_withCustomApplicationIntent_withUserClick_butCanNotHandleCustomIntent_shouldDefaultToMoPubBrowser() throws Exception {
+    public void shouldOverrideUrlLoading_withCustomApplicationIntent_withUserClick_butCanNotHandleCustomIntent_shouldFailSilently() throws Exception {
         String customUrl = "myintent://something";
         stub(htmlWebView.wasClicked()).toReturn(true);
         subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
@@ -172,10 +121,10 @@ public void shouldOverrideUrlLoading_withCustomApplicationIntent_withUserClick_b
         boolean didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, customUrl);
 
         assertThat(didOverrideUrl).isTrue();
-        verify(htmlWebViewListener).onClicked();
+        verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
         Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedIntent).isNotNull();
-        assertThat(startedIntent.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
+        assertThat(startedIntent).isNull();
     }
 
     @Test
@@ -203,7 +152,7 @@ public void shouldOverrideUrlLoading_withHttpUrl_withoutUserClick_shouldNotOpenB
 
         assertThat(didOverrideUrl).isTrue();
         verify(htmlWebViewListener, never()).onClicked();
-
+        verify(htmlWebView, never()).onResetUserClick();
         assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
     }
 
@@ -229,16 +178,14 @@ public void shouldOverrideUrlLoading_withClickTrackingRedirect_withoutUserClick_
     }
 
     @Test
-    public void shouldOverrideUrlLoading_withEmptyUrl_withUserClick_shouldLoadAboutBlank() throws Exception {
+    public void shouldOverrideUrlLoading_withEmptyUrl_withUserClick_shouldFailSilently() throws Exception {
         stub(htmlWebView.wasClicked()).toReturn(true);
         subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
 
         subject.shouldOverrideUrlLoading(htmlWebView, "");
 
         Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedActivity.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
-        assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo("about:blank");
-        assertThat(startedActivity.getData()).isNull();
+        assertThat(startedActivity).isNull();
     }
 
     @Test
@@ -261,6 +208,7 @@ public void shouldOverrideUrlLoading_withNativeBrowserScheme_withUserClick_shoul
 
         assertThat(shouldOverrideUrl).isTrue();
         verify(htmlWebViewListener).onClicked();
+        verify(htmlWebView).onResetUserClick();
         Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(startedActivity.getAction()).isEqualTo("android.intent.action.VIEW");
         assertThat(startedActivity.getData().toString()).isEqualTo("http://www.mopub.com");
@@ -276,6 +224,7 @@ public void shouldOverrideUrlLoading_withNativeBrowserScheme_withoutUserClick_sh
 
         assertThat(shouldOverrideUrl).isTrue();
         verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
         assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
     }
 
@@ -288,11 +237,10 @@ public void shouldOverrideUrlLoading_withNativeBrowserScheme_butOpaqueUri_withUs
         boolean shouldOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, opaqueNativeBrowserUriString);
 
         assertThat(shouldOverrideUrl).isTrue();
-        verify(htmlWebViewListener).onClicked();
+        verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
         Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedActivity.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
-        assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(opaqueNativeBrowserUriString);
-        assertThat(startedActivity.getData()).isNull();
+        assertThat(startedActivity).isNull();
     }
 
     @Test
@@ -305,11 +253,13 @@ public void shouldOverrideUrlLoading_withNativeBrowserScheme_butOpaqueUri_withou
 
         assertThat(shouldOverrideUrl).isTrue();
         verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
+
         assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
     }
 
     @Test
-    public void shouldOverrideUrlLoading_withNativeBrowserScheme_withInvalidHostSchemeUrl_withUserClick_shouldNotInvokeNativeBrowser() throws Exception {
+    public void shouldOverrideUrlLoading_withNativeBrowserScheme_withInvalidHostSchemeUrl_withUserClick_shouldFailSilently() throws Exception {
         stub(htmlWebView.wasClicked()).toReturn(true);
         subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
 
@@ -317,8 +267,10 @@ public void shouldOverrideUrlLoading_withNativeBrowserScheme_withInvalidHostSche
 
         assertThat(shouldOverrideUrl).isTrue();
         Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedActivity.getAction()).isNotEqualTo("android.intent.action.VIEW");
-        verify(htmlWebViewListener).onClicked();
+        assertThat(startedActivity).isNull();
+
+        verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
     }
 
     @Test
@@ -330,7 +282,64 @@ public void shouldOverrideUrlLoading_withNativeBrowserScheme_withInvalidHostSche
 
         assertThat(shouldOverrideUrl).isTrue();
         verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withAboutBlankUrl_shouldFailSilently() {
+        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
+
+        subject.shouldOverrideUrlLoading(htmlWebView, "about:blank");
+
         assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+        verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withMoPubFinishLoad_withoutUserClick_shouldDoNothing() throws Exception {
+        assertNothingHappensWithoutClick("mopub://finishLoad");
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withMoPubClose_withoutUserClick_shouldDoNothing() throws Exception {
+        assertNothingHappensWithoutClick("mopub://close");
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withMoPubFailLoad_withoutUserClick_shouldDoNothing() throws Exception {
+        assertNothingHappensWithoutClick("mopub://fail");
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withAboutScheme_withoutUserClick_shouldDoNothing() throws Exception {
+        assertNothingHappensWithoutClick("about:blank");
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withPhoneScheme_withoutUserClick_shouldDoNothing() throws Exception {
+        assertNothingHappensWithoutClick("tel:");
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withMarketUrl_withoutUserClick_shouldDoNothing() throws Exception {
+        assertNothingHappensWithoutClick("http://play.google.com/");
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withNativeBrowserUrl_withoutUserClick_shouldDoNothing() throws Exception {
+        assertNothingHappensWithoutClick("mopubnativebrowser://");
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withInAppBrowserUrl_withoutUserClick_shouldDoNothing() throws Exception {
+        assertNothingHappensWithoutClick("http://twitter.com");
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withDeepLinkUrl_withoutUserClick_shouldDoNothing() throws Exception {
+        assertNothingHappensWithoutClick("myapp://view");
     }
 
     @Test
@@ -379,7 +388,7 @@ public void onPageStarted_whenLoadedUrlStartsWithRedirectAndHasClickthrough_with
 
     @Test
     public void onPageStarted_whenLoadedUrlStartsWithRedirectAndHasClickthrough_withoutUserClick_shouldNotOpenInBrowser() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(false);
+        when(htmlWebView.wasClicked()).thenReturn(false);
         String url = "redirectUrlToLoad";
         WebView view = mock(WebView.class);
         subject.onPageStarted(view, url, null);
@@ -390,7 +399,7 @@ public void onPageStarted_whenLoadedUrlStartsWithRedirectAndHasClickthrough_with
     }
 
     @Test
-    public void onPageStarted_whenLoadedUrlStartsWithRedirectAndHasClickthrough_withUserClick_whenMoPubBrowserCannotHandleIntent_shouldOpenInNativeBrowser() throws Exception {
+    public void onPageStarted_whenLoadedUrlStartsWithRedirectAndHasClickthrough_withUserClick_whenMoPubBrowserCannotHandleIntent_shouldFailSilently() throws Exception {
         Context mockContext = mock(Context.class);
         stub(htmlWebView.wasClicked()).toReturn(true);
         stub(htmlWebView.getContext()).toReturn(mockContext);
@@ -401,17 +410,16 @@ public void onPageStarted_whenLoadedUrlStartsWithRedirectAndHasClickthrough_with
                 .doNothing()
                 .when(mockContext).startActivity(any(Intent.class));
 
-        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, "clickthrough", "redirect");
+        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, CLICKTHROUGH_URL, "redirect");
         subject.onPageStarted(htmlWebView, url, null);
 
         ArgumentCaptor<Intent> intentArgumentCaptor = ArgumentCaptor.forClass(Intent.class);
-        verify(mockContext, times(2)).startActivity(intentArgumentCaptor.capture());
+        verify(mockContext).startActivity(intentArgumentCaptor.capture());
 
-        Intent intent = intentArgumentCaptor.getAllValues().get(1);
-        assertThat(intent.getAction()).isEqualTo("android.intent.action.VIEW");
-        assertThat(intent.getData().toString()).isEqualTo("about:blank");
-        assertThat(intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
-        verify(htmlWebViewListener, times(1)).onClicked();
+        Intent intent = intentArgumentCaptor.getValue();
+        assertThat(intent.getData()).isNull();
+        verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
     }
 
     @Test
@@ -424,60 +432,6 @@ public void onPageStarted_whenLoadedUrlDoesntStartWithRedirect_shouldDoNothing()
         assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
     }
 
-    @Test
-    public void launchIntentForUserClick_shouldStartActivityAndResetClickStatusAndReturnTrue() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(true);
-        Context context = mock(Context.class);
-        Intent intent = mock(Intent.class);
-
-        boolean result = subject.launchIntentForUserClick(context, intent, null);
-
-        verify(context).startActivity(eq(intent));
-        verify(htmlWebView).onResetUserClick();
-        assertThat(result).isTrue();
-    }
-
-    @Test
-    public void launchIntentForUserClick_whenUserHasNotClicked_shouldNotStartActivityAndReturnFalse() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(false);
-        Context context = mock(Context.class);
-        Intent intent = mock(Intent.class);
-
-        boolean result = subject.launchIntentForUserClick(context, intent, null);
-
-        verify(context, never()).startActivity(any(Intent.class));
-        verify(htmlWebView, never()).onResetUserClick();
-        assertThat(result).isFalse();
-    }
-
-    @Test
-    public void launchIntentForUserClick_whenNoMatchingActivity_shouldNotStartActivityAndReturnFalse() throws Exception {
-        Context context = mock(Context.class);
-        Intent intent = mock(Intent.class);
-
-        stub(htmlWebView.wasClicked()).toReturn(true);
-        doThrow(new ActivityNotFoundException()).when(context).startActivity(any(Intent.class));
-
-        boolean result = subject.launchIntentForUserClick(context, intent, null);
-
-        verify(htmlWebView, never()).onResetUserClick();
-        assertThat(result).isFalse();
-
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
-    }
-
-    @Test
-    public void launchIntentForUserClick_whenContextIsNull_shouldNotStartActivityAndReturnFalse() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(true);
-        Intent intent = new Intent();
-
-        boolean result = subject.launchIntentForUserClick(null, intent, null);
-
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
-        verify(htmlWebView, never()).onResetUserClick();
-        assertThat(result).isFalse();
-    }
-
     private void assertPhoneUrlStartedCorrectIntent(String url) {
         boolean didOverrideUrl;
 
@@ -488,13 +442,28 @@ private void assertPhoneUrlStartedCorrectIntent(String url) {
         assertThat(startedActivity.getData().toString()).isEqualTo(url);
         assertThat(didOverrideUrl).isTrue();
         verify(htmlWebViewListener).onClicked();
+        verify(htmlWebView).onResetUserClick();
         reset(htmlWebViewListener);
+        reset(htmlWebView);
 
         stub(htmlWebView.wasClicked()).toReturn(false);
         didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, url);
         assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
         assertThat(didOverrideUrl).isTrue();
         verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
         reset(htmlWebViewListener);
+        reset(htmlWebView);
+    }
+
+    private void assertNothingHappensWithoutClick(final String url) {
+        stub(htmlWebView.wasClicked()).toReturn(false);
+
+        subject.shouldOverrideUrlLoading(htmlWebView, url);
+
+        verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
+        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(startedActivity).isNull();
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubActivityTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubActivityTest.java
index 78c49a34..4dd42595 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubActivityTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubActivityTest.java
@@ -4,12 +4,14 @@
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
+import android.content.pm.ActivityInfo;
 import android.view.View;
 import android.view.ViewGroup;
 import android.webkit.WebViewClient;
 import android.widget.FrameLayout;
 
 import com.mopub.common.AdReport;
+import com.mopub.common.CreativeOrientation;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.mobileads.test.support.TestHtmlInterstitialWebViewFactory;
 
@@ -20,7 +22,13 @@
 import org.mockito.Mock;
 import org.robolectric.Robolectric;
 import org.robolectric.shadows.ShadowLocalBroadcastManager;
+import org.robolectric.util.ActivityController;
 
+import static com.mopub.common.DataKeys.CLICKTHROUGH_URL_KEY;
+import static com.mopub.common.DataKeys.CREATIVE_ORIENTATION_KEY;
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
+import static com.mopub.common.DataKeys.REDIRECT_URL_KEY;
+import static com.mopub.common.DataKeys.SCROLLABLE_KEY;
 import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_CLICK;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
@@ -28,10 +36,6 @@
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.getHtmlInterstitialIntentFilter;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiverTest.getIntentForActionAndIdentifier;
-import static com.mopub.common.DataKeys.CLICKTHROUGH_URL_KEY;
-import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
-import static com.mopub.common.DataKeys.REDIRECT_URL_KEY;
-import static com.mopub.common.DataKeys.SCROLLABLE_KEY;
 import static com.mopub.mobileads.MoPubErrorCode.UNSPECIFIED;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
@@ -50,6 +54,7 @@
     @Mock private AdReport mockAdReport;
     private static final String EXPECTED_REDIRECT_URL = "redirectUrl";
     private static final String EXPECTED_CLICKTHROUGH_URL = "http://expected_url";
+    private static final CreativeOrientation EXPECTED_ORIENTATION = CreativeOrientation.PORTRAIT;
 
     @Mock private BroadcastReceiver broadcastReceiver;
     private long testBroadcastIdentifier = 2222;
@@ -68,12 +73,21 @@ public void setUp() throws Exception {
         Intent moPubActivityIntent = MoPubActivity.createIntent(context,
                 EXPECTED_HTML_DATA, mockAdReport, EXPECTED_IS_SCROLLABLE,
                 EXPECTED_REDIRECT_URL,
-                EXPECTED_CLICKTHROUGH_URL, testBroadcastIdentifier);
+                EXPECTED_CLICKTHROUGH_URL, EXPECTED_ORIENTATION, testBroadcastIdentifier);
+
+        final ActivityController<MoPubActivity> subjectController = Robolectric.buildActivity(MoPubActivity.class).withIntent(moPubActivityIntent);
+        subject = subjectController.get();
+        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
+        subjectController.create();
 
-        subject = Robolectric.buildActivity(MoPubActivity.class).withIntent(moPubActivityIntent).create().get();
         customEventInterstitialListener = mock(CustomEventInterstitialListener.class);
+    }
 
-        resetMockedView(htmlInterstitialWebView);
+    @Test
+    public void onCreate_shouldHaveLockedOrientation() {
+        // Since robolectric doesn't set a requested orientation, verifying that we have a value tells us that one was set.
+        assertThat(subject.getRequestedOrientation()).isIn(ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT,
+                ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
     }
 
     @Test
@@ -115,14 +129,14 @@ public void preRenderHtml_shouldHaveAWebViewClientThatForwardsFailLoad() throws
 
     @Test
     public void onCreate_shouldSetContentView() throws Exception {
-        subject.onCreate(null);
+        // onCreate is called above in #setup
 
         assertThat(getContentView().getChildCount()).isEqualTo(1);
     }
 
     @Test
     public void onCreate_shouldLayoutWebView() throws Exception {
-        subject.onCreate(null);
+        // onCreate is called in #setup
 
         ArgumentCaptor<FrameLayout.LayoutParams> captor = ArgumentCaptor.forClass(FrameLayout.LayoutParams.class);
         verify(htmlInterstitialWebView).setLayoutParams(captor.capture());
@@ -134,6 +148,8 @@ public void onCreate_shouldLayoutWebView() throws Exception {
 
     @Test
     public void getAdView_shouldReturnPopulatedHtmlWebView() throws Exception {
+        // This is needed because we preload in onCreate and the mock gets triggered.
+        resetMockedView(htmlInterstitialWebView);
         View adView = subject.getAdView();
 
         assertThat(adView).isSameAs(htmlInterstitialWebView);
@@ -146,7 +162,7 @@ public void getAdView_shouldReturnPopulatedHtmlWebView() throws Exception {
 
     @Test
     public void onDestroy_shouldDestroyMoPubView() throws Exception {
-        subject.onCreate(null);
+        // onCreate is called in #setup
         subject.onDestroy();
 
         verify(htmlInterstitialWebView).destroy();
@@ -155,7 +171,7 @@ public void onDestroy_shouldDestroyMoPubView() throws Exception {
 
     @Test
     public void onDestroy_shouldFireJavascriptWebviewDidClose() throws Exception {
-        subject.onCreate(null);
+        // onCreate is called in #setup
         subject.onDestroy();
 
         verify(htmlInterstitialWebView).loadUrl(eq("javascript:webviewDidClose();"));
@@ -163,19 +179,22 @@ public void onDestroy_shouldFireJavascriptWebviewDidClose() throws Exception {
 
     @Test
     public void start_shouldStartMoPubActivityWithCorrectParameters() throws Exception {
-        MoPubActivity.start(subject, "expectedResponse", mockAdReport, true, "redirectUrl", "clickthroughUrl", testBroadcastIdentifier);
+        MoPubActivity.start(subject, "expectedResponse", mockAdReport, true, "redirectUrl", "clickthroughUrl", CreativeOrientation.PORTRAIT, testBroadcastIdentifier);
 
         Intent nextStartedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(nextStartedActivity.getStringExtra(HTML_RESPONSE_BODY_KEY)).isEqualTo("expectedResponse");
         assertThat(nextStartedActivity.getBooleanExtra(SCROLLABLE_KEY, false)).isTrue();
         assertThat(nextStartedActivity.getStringExtra(REDIRECT_URL_KEY)).isEqualTo("redirectUrl");
         assertThat(nextStartedActivity.getStringExtra(CLICKTHROUGH_URL_KEY)).isEqualTo("clickthroughUrl");
+        assertThat(nextStartedActivity.getSerializableExtra(CREATIVE_ORIENTATION_KEY)).isEqualTo(CreativeOrientation.PORTRAIT);
         assertThat(nextStartedActivity.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
         assertThat(nextStartedActivity.getComponent().getClassName()).isEqualTo("com.mopub.mobileads.MoPubActivity");
     }
 
     @Test
     public void getAdView_shouldCreateHtmlInterstitialWebViewAndLoadResponse() throws Exception {
+        // This is needed because we preload in onCreate and the mock gets triggered.
+        resetMockedView(htmlInterstitialWebView);
         subject.getAdView();
 
         assertThat(TestHtmlInterstitialWebViewFactory.getLatestListener()).isNotNull();
@@ -227,7 +246,6 @@ public void broadcastingInterstitialListener_onInterstitialLoaded_shouldCallJava
     @Test
     public void broadcastingInterstitialListener_onInterstitialFailed_shouldBroadcastFailAndFinish() throws Exception {
         Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_FAIL, testBroadcastIdentifier);
-        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
 
         MoPubActivity.BroadcastingInterstitialListener broadcastingInterstitialListener = ((MoPubActivity) subject).new BroadcastingInterstitialListener();
         broadcastingInterstitialListener.onInterstitialFailed(null);
@@ -239,7 +257,6 @@ public void broadcastingInterstitialListener_onInterstitialFailed_shouldBroadcas
     @Test
     public void broadcastingInterstitialListener_onInterstitialClicked_shouldBroadcastClick() throws Exception {
         Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_CLICK, testBroadcastIdentifier);
-        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
 
         MoPubActivity.BroadcastingInterstitialListener broadcastingInterstitialListener = ((MoPubActivity) subject).new BroadcastingInterstitialListener();
         broadcastingInterstitialListener.onInterstitialClicked();
@@ -250,9 +267,6 @@ public void broadcastingInterstitialListener_onInterstitialClicked_shouldBroadca
     @Test
     public void onCreate_shouldBroadcastInterstitialShow() throws Exception {
         Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_SHOW, testBroadcastIdentifier);
-        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
-
-        subject.onCreate(null);
 
         verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
     }
@@ -260,9 +274,7 @@ public void onCreate_shouldBroadcastInterstitialShow() throws Exception {
     @Test
     public void onDestroy_shouldBroadcastInterstitialDismiss() throws Exception {
         Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_DISMISS, testBroadcastIdentifier);
-        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
 
-        subject.onCreate(null);
         subject.onDestroy();
 
         verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubConversionTrackerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubConversionTrackerTest.java
index f00385a4..6052109a 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubConversionTrackerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubConversionTrackerTest.java
@@ -3,6 +3,7 @@
 import android.app.Activity;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.network.MoPubRequestQueue;
 import com.mopub.network.Networking;
 import com.mopub.network.TrackingRequest;
 import com.mopub.volley.RequestQueue;
@@ -25,7 +26,7 @@
     private MoPubConversionTracker subject;
     private Activity context;
     @Mock
-    RequestQueue mockRequestQueue;
+    MoPubRequestQueue mockRequestQueue;
     @Captor
     ArgumentCaptor<TrackingRequest> requestCaptor;
 
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubInterstitialTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubInterstitialTest.java
index f1ae01ae..67e4752b 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubInterstitialTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubInterstitialTest.java
@@ -12,6 +12,7 @@
 import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 
 import java.math.BigDecimal;
 import java.util.HashMap;
@@ -47,7 +48,7 @@
 
     @Before
     public void setUp() throws Exception {
-        activity = new Activity();
+        activity = Robolectric.buildActivity(Activity.class).create().get();
         subject = new MoPubInterstitial(activity, AD_UNIT_ID_VALUE);
         interstitialAdListener = mock(MoPubInterstitial.InterstitialAdListener.class);
         subject.setInterstitialAdListener(interstitialAdListener);
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubRewardedVideoManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubRewardedVideoManagerTest.java
index 3de193f4..9ffe543d 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubRewardedVideoManagerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubRewardedVideoManagerTest.java
@@ -6,13 +6,15 @@
 
 import com.mopub.common.AdType;
 import com.mopub.common.LifecycleListener;
+import com.mopub.common.MoPubReward;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.network.AdRequest;
 import com.mopub.network.AdResponse;
+import com.mopub.network.MoPubRequestQueue;
 import com.mopub.network.Networking;
-import com.mopub.volley.RequestQueue;
 import com.mopub.volley.VolleyError;
 
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -32,20 +34,22 @@
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
-public class MoPubRewardedVideoManagerTest {
+public class
+        MoPubRewardedVideoManagerTest {
 
     @Mock
-    RequestQueue mockRequestQueue;
+    MoPubRequestQueue mockRequestQueue;
     @Mock
     MoPubRewardedVideoListener mockVideoListener;
 
     AdRequest.Listener requestListener;
     private AdRequest request;
-    private boolean mLoaded;
+    private Activity mActivity;
 
     @Before
     public void setup() {
-        MoPubRewardedVideoManager.init(Robolectric.buildActivity(Activity.class).create().get());
+        mActivity = Robolectric.buildActivity(Activity.class).create().get();
+        MoPubRewardedVideoManager.init(mActivity);
         MoPubRewardedVideoManager.setVideoListener(mockVideoListener);
 
         when(mockRequestQueue.add(any(AdRequest.class))).then(new Answer<Object>() {
@@ -60,6 +64,60 @@ public Object answer(final InvocationOnMock invocationOnMock) throws Throwable {
         Networking.setRequestQueueForTesting(mockRequestQueue);
     }
 
+    @After
+    public void tearDown() {
+        // Unpause the main looper in case a test terminated while the looper was paused.
+        Robolectric.unPauseMainLooper();
+    }
+
+    @Test
+    public void callbackMethods_withNullListener_shouldNotError() {
+        // Clients can set RVM null.
+        MoPubRewardedVideoManager.setVideoListener(null);
+
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName("com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        Robolectric.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit");
+        // Triggers a call to MoPubRewardedVideoManager.onRewardedVideoLoadSuccess
+        requestListener.onSuccess(testResponse);
+
+        Robolectric.unPauseMainLooper();
+
+        MoPubRewardedVideoManager.onRewardedVideoClicked(TestCustomEvent.class, "id!");
+        MoPubRewardedVideoManager.onRewardedVideoStarted(TestCustomEvent.class, "id!");
+        MoPubRewardedVideoManager.onRewardedVideoClosed(TestCustomEvent.class, "id!");
+        MoPubRewardedVideoManager.onRewardedVideoCompleted(TestCustomEvent.class, "id!", MoPubReward.success("test", 111));
+
+        // The test passed because none of the above calls thew an exception even though the listener is null.
+    }
+
+    @Test
+    public void onAdSuccess_noActivityFound_shouldNotCallFailUrl() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setAdType(AdType.CUSTOM)
+                .setCustomEventClassName(
+                        "com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setFailoverUrl("fail.url")
+                .build();
+
+        MoPubRewardedVideoManager.updateActivity(null);
+        MoPubRewardedVideoManager.loadVideo("testAdUnit");
+        requestListener.onSuccess(testResponse);
+
+        verify(mockRequestQueue).add(any(AdRequest.class));
+        verifyNoMoreInteractions(mockRequestQueue);
+
+        // Clean up the static state we screwed up:
+        MoPubRewardedVideoManager.updateActivity(mActivity);
+    }
+
     @Test
     public void onAdSuccess_noCEFound_shouldCallFailCallback() throws Exception {
         AdResponse testResponse = new AdResponse.Builder()
@@ -83,8 +141,6 @@ public void onAdSuccess_noCEFound_shouldLoadFailUrl() {
                 .setFailoverUrl("fail.url")
                 .build();
 
-
-
         MoPubRewardedVideoManager.loadVideo("testAdUnit");
 
         assertThat(request.getUrl()).contains("testAdUnit");
@@ -101,10 +157,18 @@ public void onAdSuccess_shouldInstantiateCustomEvent_andLoad() {
                 .setAdType(AdType.CUSTOM)
                 .build();
 
-        MoPubRewardedVideoManager.loadVideo("testAdUnit");
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        Robolectric.pauseMainLooper();
 
+        MoPubRewardedVideoManager.loadVideo("testAdUnit");
         requestListener.onSuccess(testResponse);
+
+        Robolectric.unPauseMainLooper();
+
         assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isTrue();
+        verify(mockVideoListener).onRewardedVideoLoadSuccess(eq("testAdUnit"));
+        verifyNoMoreInteractions(mockVideoListener);
     }
 
     @Test
@@ -114,12 +178,20 @@ public void playVideo_shouldSetHasVideoFalse() {
                 .setAdType(AdType.CUSTOM)
                 .build();
 
-        MoPubRewardedVideoManager.loadVideo("testAdUnit");
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        Robolectric.pauseMainLooper();
 
+        MoPubRewardedVideoManager.loadVideo("testAdUnit");
         requestListener.onSuccess(testResponse);
+
+        Robolectric.unPauseMainLooper();
+
         assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isTrue();
         MoPubRewardedVideoManager.showVideo("testAdUnit");
+        verify(mockVideoListener).onRewardedVideoLoadSuccess(eq("testAdUnit"));
         assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isFalse();
+        verify(mockVideoListener).onRewardedVideoStarted(eq("testAdUnit"));
     }
     
     @Test
@@ -129,9 +201,17 @@ public void playVideo_whenNotHasVideo_shouldFail() {
                 .setAdType(AdType.CUSTOM)
                 .build();
 
-        MoPubRewardedVideoManager.loadVideo("testAdUnit");
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        Robolectric.pauseMainLooper();
 
+        MoPubRewardedVideoManager.loadVideo("testAdUnit");
         requestListener.onSuccess(testResponse);
+
+        Robolectric.unPauseMainLooper();
+
+        verify(mockVideoListener).onRewardedVideoLoadFailure(eq("testAdUnit"), eq(MoPubErrorCode.NETWORK_NO_FILL));
+
         assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isFalse();
         MoPubRewardedVideoManager.showVideo("testAdUnit");
         verify(mockVideoListener).onRewardedVideoLoadFailure(eq("testAdUnit"), eq(MoPubErrorCode.VIDEO_NOT_AVAILABLE));
@@ -188,6 +268,7 @@ protected void loadWithSdkInitialized(@NonNull final Activity activity,
                 @NonNull final Map<String, String> serverExtras) throws Exception {
             // Do nothing because robolectric handlers execute immediately.
             mPlayable = true;
+            MoPubRewardedVideoManager.onRewardedVideoLoadSuccess(TestCustomEvent.class, "id!");
         }
 
         @Override
@@ -207,6 +288,7 @@ protected void loadWithSdkInitialized(@NonNull final Activity activity,
                 @NonNull final Map<String, Object> localExtras,
                 @NonNull final Map<String, String> serverExtras) throws Exception {
             mPlayable = false;
+            MoPubRewardedVideoManager.onRewardedVideoLoadFailure(NoVideoCustomEvent.class, "id!", MoPubErrorCode.NETWORK_NO_FILL);
         }
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubViewTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubViewTest.java
index cffcf3dc..4bab198e 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubViewTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubViewTest.java
@@ -38,7 +38,7 @@
 
     @Before
     public void setup() {
-        context = new Activity();
+        context = Robolectric.buildActivity(Activity.class).create().get();
         subject = new MoPubView(context);
         customEventBannerAdapter = TestCustomEventBannerAdapterFactory.getSingletonMock();
         reset(customEventBannerAdapter);
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidActivityTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidActivityTest.java
index 26c495aa..84737b46 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidActivityTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidActivityTest.java
@@ -27,14 +27,15 @@
 import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowLocalBroadcastManager;
+import org.robolectric.util.ActivityController;
 
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_CLICK;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
-import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.getHtmlInterstitialIntentFilter;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiverTest.getIntentForActionAndIdentifier;
-import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
@@ -56,6 +57,7 @@
 
     long testBroadcastIdentifier = 2222;
 
+    ActivityController<TestMraidActivity> activityController;
     TestMraidActivity subject;
 
     // Make a concrete version of the abstract class for testing purposes.
@@ -70,9 +72,10 @@ public View getAdView() {
 
     @Before
     public void setUp() throws Exception {
-        subject = Robolectric.buildActivity(TestMraidActivity.class).get();
+        activityController = Robolectric.buildActivity(TestMraidActivity.class).start();
+        subject = activityController.get();
         subject.mraidWebView = mraidWebView;
-        Robolectric.shadowOf(subject).callOnCreate(null);
+        activityController.create();
     }
 
     @Ignore("Mraid 2.0")
@@ -297,7 +300,7 @@ public void getAdView_shouldSetupOnCloseListener() throws Exception {
     @Ignore("Mraid 2.0")
     @Test
     public void onPause_shouldOnPauseMraidView() throws Exception {
-        Robolectric.shadowOf(subject).callOnPause();
+        activityController.pause();
 
         verify(mraidWebView).onPause();
     }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidVideoPlayerActivityTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidVideoPlayerActivityTest.java
index 05bc9bc7..4d9e765a 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidVideoPlayerActivityTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidVideoPlayerActivityTest.java
@@ -40,7 +40,7 @@
 
     @Before
     public void setup() {
-        context = new Activity();
+        context = Robolectric.buildActivity(Activity.class).create().get();
         intent = new Intent(context, MraidVideoPlayerActivity.class);
 
         testBroadcastIdentifier = 1001;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/RepeatingHandlerRunnableTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/RepeatingHandlerRunnableTest.java
new file mode 100644
index 00000000..3c51f6f7
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/RepeatingHandlerRunnableTest.java
@@ -0,0 +1,88 @@
+package com.mopub.mobileads;
+
+import android.os.Handler;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyZeroInteractions;
+
+@RunWith(SdkTestRunner.class)
+public class RepeatingHandlerRunnableTest {
+
+    @Mock Handler mockHandler;
+    RepeatingHandlerRunnable subject;
+
+    @Before
+    public void setup() {
+      subject = new NoopRepeatingHandlerRunnable(mockHandler);
+    }
+
+    @Test
+    public void startTracking_whenRunning_shouldScheduleSelf() {
+        subject.startRepeating(100);
+        reset(mockHandler);
+        subject.run();
+
+        verify(mockHandler).postDelayed(eq(subject), eq(100l));
+    }
+
+    @Test
+    public void start_whenRunning_shouldNotScheduleAndRunShouldScheduleWithNewInterval() {
+        subject.startRepeating(100l);
+        reset(mockHandler);
+
+        subject.startRepeating(200l);
+
+        verifyZeroInteractions(mockHandler);
+
+        subject.run();
+
+        verify(mockHandler).postDelayed(eq(subject), eq(200l));
+    }
+
+    @Test
+    public void run_whenNotRunning_shouldNotSchedule() {
+        subject.stop();
+        reset(mockHandler);
+
+        subject.run();
+
+        verifyZeroInteractions(mockHandler);
+    }
+
+    @Test
+    public void stopTracking_whenRunning_shouldPreventNextScheduling() {
+        subject.startRepeating(100l);
+        verify(mockHandler).post(eq(subject));
+
+        subject.run();
+        verify(mockHandler).postDelayed(eq(subject), eq(100l));
+
+        reset(mockHandler);
+        subject.stop();
+
+        subject.run();
+        verifyZeroInteractions(mockHandler);
+    }
+
+    private static class NoopRepeatingHandlerRunnable extends RepeatingHandlerRunnable {
+
+        NoopRepeatingHandlerRunnable(@NonNull final Handler handler) {
+            super(handler);
+        }
+
+        @Override
+        public void doWork() {
+            // pass
+        }
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/TaskTrackerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/TaskTrackerTest.java
deleted file mode 100644
index 604fed40..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/TaskTrackerTest.java
+++ /dev/null
@@ -1,66 +0,0 @@
-package com.mopub.mobileads;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-
-public class TaskTrackerTest {
-
-    private TaskTracker taskTracker;
-
-    @Before
-    public void setUp() throws Exception {
-        taskTracker = new TaskTracker();
-    }
-
-    @Test
-    public void newTaskStarted_shouldIncrementIdsFromNegativeOne() throws Exception {
-        assertThat(taskTracker.getCurrentTaskId()).isEqualTo(-1);
-
-        taskTracker.newTaskStarted();
-
-        assertThat(taskTracker.getCurrentTaskId()).isEqualTo(0);
-    }
-
-    @Test
-    public void isMostCurrentTask_onFirstTask_whenSecondTaskIsCompleted_shouldBeFalse() throws Exception {
-        taskTracker.newTaskStarted();
-        taskTracker.newTaskStarted();
-        taskTracker.markTaskCompleted(taskTracker.getCurrentTaskId());
-
-        assertThat(taskTracker.isMostCurrentTask(0)).isFalse();
-    }
-
-    @Test
-    public void isMostCurrentTask_onFirstTask_whenSecondTaskIsNotCompleted_shouldBeTrue() throws Exception {
-        taskTracker.newTaskStarted();
-        taskTracker.newTaskStarted();
-
-        assertThat(taskTracker.isMostCurrentTask(0)).isTrue();
-    }
-
-    @Test
-    public void mostCurrentTaskIsLastCompletedTaskOrLater() throws Exception {
-        taskTracker.newTaskStarted();
-        taskTracker.newTaskStarted();
-        taskTracker.newTaskStarted();
-        taskTracker.markTaskCompleted(1);
-
-        assertThat(taskTracker.isMostCurrentTask(0)).isFalse();
-        assertThat(taskTracker.isMostCurrentTask(1)).isTrue();
-        assertThat(taskTracker.isMostCurrentTask(2)).isTrue();
-    }
-
-    @Test
-    public void markTaskCompleted_shouldKeepTrackOfMostCurrentTaskRegardlessOfCompletionOrder() throws Exception {
-        taskTracker.newTaskStarted();
-        taskTracker.newTaskStarted();
-        taskTracker.newTaskStarted();
-        taskTracker.markTaskCompleted(1);
-        taskTracker.markTaskCompleted(0);
-
-        assertThat(taskTracker.isMostCurrentTask(0)).isFalse();
-        assertThat(taskTracker.isMostCurrentTask(1)).isTrue();
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/ToolbarWidgetTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/ToolbarWidgetTest.java
new file mode 100644
index 00000000..bee3c2d1
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/ToolbarWidgetTest.java
@@ -0,0 +1,118 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.view.View;
+import android.widget.ImageView;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.resource.CloseButtonDrawable;
+import com.mopub.network.MaxWidthImageLoader;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.volley.VolleyError;
+import com.mopub.volley.toolbox.ImageLoader;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Captor;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+
+import static android.view.Gravity.CENTER_VERTICAL;
+import static android.view.Gravity.RIGHT;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class ToolbarWidgetTest {
+    private Context context;
+    private ToolbarWidget subject;
+
+    private static final String ICON_IMAGE_URL = "iconimageurl";
+
+    @Mock
+    MoPubRequestQueue mockRequestQueue;
+    @Mock
+    private MaxWidthImageLoader mockImageLoader;
+    @Mock
+    private ImageLoader.ImageContainer mockImageContainer;
+    @Mock
+    private Bitmap mockBitmap;
+    @Captor
+    private ArgumentCaptor<ImageLoader.ImageListener> imageCaptor;
+
+    @Before
+    public void setUp() throws Exception {
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+        Networking.setImageLoaderForTesting(mockImageLoader);
+        context = Robolectric.buildActivity(Activity.class).create().get();
+    }
+
+    private void initializeSubject() {
+        subject = new ToolbarWidget.Builder(context)
+                .weight(1f)
+                .widgetGravity(CENTER_VERTICAL | RIGHT)
+                .defaultText("Close")
+                .drawable(new CloseButtonDrawable())
+                .visibility(View.GONE)
+                .build();
+    }
+
+    @Test
+    public void updateImage_imageListenerOnResponse_shouldUseImageBitmap() throws Exception {
+        initializeSubject();
+
+        when(mockImageContainer.getBitmap()).thenReturn(mockBitmap);
+
+        subject.updateImage(ICON_IMAGE_URL);
+
+        verify(mockImageLoader).get(eq(ICON_IMAGE_URL), imageCaptor.capture());
+        ImageLoader.ImageListener listener = imageCaptor.getValue();
+        listener.onResponse(mockImageContainer, true);
+        assertThat(((BitmapDrawable) subject.getImageViewDrawable()).getBitmap()).isEqualTo(mockBitmap);
+    }
+
+    @Test
+    public void updateImage_imageListenerOnResponseWhenReturnedBitMapIsNull_shouldUseDefaultCloseButtonDrawable() throws Exception {
+        initializeSubject();
+
+        final ImageView imageViewSpy = spy(subject.getImageView());
+        subject.setImageView(imageViewSpy);
+
+        when(mockImageContainer.getBitmap()).thenReturn(null);
+
+        subject.updateImage(ICON_IMAGE_URL);
+
+        verify(mockImageLoader).get(eq(ICON_IMAGE_URL), imageCaptor.capture());
+        ImageLoader.ImageListener listener = imageCaptor.getValue();
+        listener.onResponse(mockImageContainer, true);
+        verify(imageViewSpy, never()).setImageBitmap(any(Bitmap.class));
+        assertThat(subject.getImageViewDrawable()).isInstanceOf(CloseButtonDrawable.class);
+    }
+
+    @Test
+    public void updateImage_imageListenerOnErrorResponse_shouldUseDefaultCloseButtonDrawable() throws Exception {
+        initializeSubject();
+
+        final ImageView imageViewSpy = spy(subject.getImageView());
+        subject.setImageView(imageViewSpy);
+
+        subject.updateImage(ICON_IMAGE_URL);
+
+        verify(mockImageLoader).get(eq(ICON_IMAGE_URL), imageCaptor.capture());
+        ImageLoader.ImageListener listener = imageCaptor.getValue();
+        listener.onErrorResponse(new VolleyError());
+        verify(imageViewSpy, never()).setImageBitmap(any(Bitmap.class));
+        assertThat(subject.getImageViewDrawable()).isInstanceOf(CloseButtonDrawable.class);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoInterstitialTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoInterstitialTest.java
index 0b820fb3..9c9ad74e 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoInterstitialTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoInterstitialTest.java
@@ -145,10 +145,10 @@ public void showInterstitial_shouldStartVideoPlayerActivityWithAllValidTrackers(
         VastCompanionAd vastCompanionAd = mock(VastCompanionAd.class, withSettings().serializable());
         VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
         vastVideoConfiguration.setNetworkMediaFileUrl(videoUrl);
-        vastVideoConfiguration.addStartTrackers(Arrays.asList("start"));
-        vastVideoConfiguration.addFirstQuartileTrackers(Arrays.asList("first"));
-        vastVideoConfiguration.addMidpointTrackers(Arrays.asList("mid"));
-        vastVideoConfiguration.addThirdQuartileTrackers(Arrays.asList("third"));
+        vastVideoConfiguration.addAbsoluteTrackers(Arrays.asList(new VastAbsoluteProgressTracker("start", 2000)));
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("first", 0.25f),
+                new VastFractionalProgressTracker("mid", 0.5f),
+                new VastFractionalProgressTracker("third", 0.75f)));
         vastVideoConfiguration.addCompleteTrackers(Arrays.asList("complete"));
         vastVideoConfiguration.addImpressionTrackers(Arrays.asList("imp"));
         vastVideoConfiguration.setClickThroughUrl("clickThrough");
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoToolbarTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoToolbarTest.java
index f29f0a54..79bd874c 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoToolbarTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoToolbarTest.java
@@ -2,6 +2,7 @@
 
 import android.app.Activity;
 import android.content.Context;
+import android.graphics.drawable.Drawable;
 import android.view.View;
 import android.widget.TextView;
 
@@ -11,6 +12,7 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
@@ -26,7 +28,7 @@
 
     @Before
     public void setUp() throws Exception {
-        context = new Activity();
+        context = Robolectric.buildActivity(Activity.class).create().get();
         subject = new VastVideoToolbar(context);
 
         onTouchListener = mock(View.OnTouchListener.class);
@@ -49,7 +51,7 @@ public void constructor_shouldAddWidgetsToToolbar() throws Exception {
         assertThat(subject.getCountdownWidget().getParent()).isEqualTo(subject);
         assertThat(subject.getCloseButtonWidget().getParent()).isEqualTo(subject);
     }
-    
+
     @Test
     public void constructor_shouldOnlyStartWithDurationWidgetsVisible() throws Exception {
         assertThat(subject.getDurationWidget().getVisibility()).isEqualTo(View.VISIBLE);
@@ -83,21 +85,44 @@ public void setLearnButtonOnTouchListener_shouldPropagateToLearnButtonWidget() t
     }
 
     @Test
-    public void getDisplaySeconds_shouldReturnLongMillisecondsAsRoundedUpStringSeconds() throws Exception {
-        assertThat(subject.getDisplaySeconds(0)).isEqualTo("0");
+    public void convertMillisecondsToSecondsRoundedUp_shouldReturnLongMillisecondsAsRoundedUpLongSeconds() throws Exception {
+        assertThat(subject.convertMillisecondsToSecondsRoundedUp(0)).isEqualTo(0);
 
-        assertThat(subject.getDisplaySeconds(1)).isEqualTo("1");
-        assertThat(subject.getDisplaySeconds(999)).isEqualTo("1");
-        assertThat(subject.getDisplaySeconds(1000)).isEqualTo("1");
+        assertThat(subject.convertMillisecondsToSecondsRoundedUp(1)).isEqualTo(1);
+        assertThat(subject.convertMillisecondsToSecondsRoundedUp(999)).isEqualTo(1);
+        assertThat(subject.convertMillisecondsToSecondsRoundedUp(1000)).isEqualTo(1);
 
-        assertThat(subject.getDisplaySeconds(1001)).isEqualTo("2");
-        assertThat(subject.getDisplaySeconds(100000)).isEqualTo("100");
+        assertThat(subject.convertMillisecondsToSecondsRoundedUp(1001)).isEqualTo(2);
+        assertThat(subject.convertMillisecondsToSecondsRoundedUp(100000)).isEqualTo(100);
     }
-    
+
+    @Test
+    public void formatTime_shouldReturnLongMillisecondsAsFormattedString() {
+        assertThat(subject.formatTime(-8999)).isEqualTo("-8 seconds");
+        assertThat(subject.formatTime(-9000)).isEqualTo("-9 seconds");
+        assertThat(subject.formatTime(-9001)).isEqualTo("-9 seconds");
+        assertThat(subject.formatTime(0)).isEqualTo("0 seconds");
+
+        assertThat(subject.formatTime(1)).isEqualTo("1 second");
+        assertThat(subject.formatTime(1000)).isEqualTo("1 second");
+        assertThat(subject.formatTime(1005)).isEqualTo("2 seconds");
+
+        assertThat(subject.formatTime(59999)).isEqualTo("60 seconds");
+        assertThat(subject.formatTime(60000)).isEqualTo("60 seconds");
+        assertThat(subject.formatTime(60001)).isEqualTo("61 seconds");
+        assertThat(subject.formatTime(853437)).isEqualTo("854 seconds");
+
+        assertThat(subject.formatTime(3599999)).isEqualTo("3600 seconds");
+        assertThat(subject.formatTime(3600000)).isEqualTo("3600 seconds");
+        assertThat(subject.formatTime(3600001)).isEqualTo("3601 seconds");
+        assertThat(subject.formatTime(3660001)).isEqualTo("3661 seconds");
+        assertThat(subject.formatTime(65784693)).isEqualTo("65785 seconds");
+    }
+
     @Test
     public void updateCountdownWidget_shouldUpdateTextDrawablesDisplayNumber() throws Exception {
-        final TextDrawable countdownImageSpy = spy(subject.getCountdownWidget().getImageViewDrawable());
-        subject.getCountdownWidget().setImageViewDrawable(countdownImageSpy);
+        final TextDrawable countdownImageSpy = spy((TextDrawable) subject.getCountdownWidget().getImageViewDrawable());
+        subject.getCountdownWidget().setImageViewDrawable((Drawable) countdownImageSpy);
 
         subject.updateCountdownWidget(1002);
 
@@ -154,7 +179,7 @@ public void updateDurationWidget_whenBelowThresholdForHidingVideoDuration_should
         // 200ms of remaining video is the cut off for switching to "Thanks for watching"
         subject.updateDurationWidget(200);
 
-        assertThat(durationWidgetTextView.getText()).isEqualTo("Ends in 1 seconds");
+        assertThat(durationWidgetTextView.getText()).isEqualTo("Ends in 1 second");
 
         subject.updateDurationWidget(199);
 
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewControllerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewControllerTest.java
index 296fe5ab..b36fcaf5 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewControllerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewControllerTest.java
@@ -5,6 +5,7 @@
 import android.content.Intent;
 import android.graphics.Color;
 import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
 import android.graphics.drawable.GradientDrawable;
 import android.graphics.drawable.LayerDrawable;
 import android.media.MediaPlayer;
@@ -18,20 +19,21 @@
 
 import com.mopub.common.MoPubBrowser;
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.DeviceUtils.ForceOrientation;
 import com.mopub.common.util.Dips;
 import com.mopub.common.util.Drawables;
+import com.mopub.mobileads.resource.CloseButtonDrawable;
 import com.mopub.mobileads.test.support.GestureUtils;
 import com.mopub.mobileads.util.vast.VastCompanionAd;
 import com.mopub.mobileads.util.vast.VastVideoConfiguration;
+import com.mopub.network.MaxWidthImageLoader;
+import com.mopub.network.MoPubRequestQueue;
 import com.mopub.network.Networking;
-import com.mopub.volley.Request;
-import com.mopub.volley.RequestQueue;
 
 import org.apache.http.HttpRequest;
 import org.apache.maven.artifact.ant.shaded.ReflectionUtils;
 import org.junit.After;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
@@ -46,7 +48,10 @@
 import java.io.File;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.List;
 
+import static android.content.pm.ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
+import static android.content.pm.ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
 import static android.view.ViewGroup.LayoutParams.MATCH_PARENT;
 import static com.mopub.common.MoPubBrowser.DESTINATION_URL_KEY;
 import static com.mopub.common.VolleyRequestMatcher.isUrl;
@@ -61,23 +66,33 @@
 import static com.mopub.mobileads.VastVideoViewController.DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON;
 import static com.mopub.mobileads.VastVideoViewController.MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON;
 import static com.mopub.mobileads.VastVideoViewController.VAST_VIDEO_CONFIGURATION;
+import static com.mopub.volley.toolbox.ImageLoader.ImageListener;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.anyLong;
 import static org.mockito.Matchers.argThat;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.stub;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.Mockito.verifyZeroInteractions;
+import static org.mockito.Mockito.when;
 import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(SdkTestRunner.class)
 public class VastVideoViewControllerTest {
-    public static final int NETWORK_DELAY = 500;
+    public static final int NETWORK_DELAY = 100;
+
+    private static final String COMPANION_IMAGE_URL = "companion_image_url";
+    private static final String COMPANION_CLICK_TRACKING_URL_1 = "companion_click_tracking_url_1";
+    private static final String COMPANION_CLICK_TRACKING_URL_2 = "companion_click_tracking_url_2";
+    private static final String COMPANION_CLICK_DESTINATION_URL = "http://companion_click_destination_url";
+    private static final String CLICKTHROUGH_URL = "http://clickthrough_url";
 
     private Context context;
     private Bundle bundle;
@@ -89,14 +104,22 @@
     private String expectedUserAgent;
 
     @Mock
-    RequestQueue mockRequestQueue;
+    MoPubRequestQueue mockRequestQueue;
+    @Mock
+    MaxWidthImageLoader mockImageLoader;
     @Mock
-    private MediaPlayer mockMediaPlayer;
+    private VideoView mockVideoView;
+
+    private VastVideoViewCountdownRunnable spyCountdownRunnable;
+    private VastVideoViewProgressRunnable spyProgressRunnable;
+    private VideoView spyVideoView;
+
 
     @Before
     public void setUp() throws Exception {
         Networking.setRequestQueueForTesting(mockRequestQueue);
-        context = new Activity();
+        Networking.setImageLoaderForTesting(mockImageLoader);
+        context = Robolectric.buildActivity(Activity.class).create().get();
         bundle = new Bundle();
         testBroadcastIdentifier = 1111;
         broadcastReceiver = mock(EventForwardingBroadcastReceiver.class);
@@ -105,21 +128,22 @@ public void setUp() throws Exception {
         VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
         vastVideoConfiguration.setNetworkMediaFileUrl("video_url");
         vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addStartTrackers(Arrays.asList("start"));
-        vastVideoConfiguration.addFirstQuartileTrackers(Arrays.asList("first"));
-        vastVideoConfiguration.addMidpointTrackers(Arrays.asList("mid"));
-        vastVideoConfiguration.addThirdQuartileTrackers(Arrays.asList("third"));
+        vastVideoConfiguration.addAbsoluteTrackers(Arrays.asList(new VastAbsoluteProgressTracker("start", 2000)));
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("first", 0.25f),
+                new VastFractionalProgressTracker("mid", 0.5f), new VastFractionalProgressTracker("third", 0.75f)));
         vastVideoConfiguration.addCompleteTrackers(Arrays.asList("complete"));
+        vastVideoConfiguration.addCloseTrackers(Arrays.asList("close"));
+        vastVideoConfiguration.addSkipTrackers(Arrays.asList("skip"));
         vastVideoConfiguration.addImpressionTrackers(Arrays.asList("imp"));
-        vastVideoConfiguration.setClickThroughUrl("clickThrough");
+        vastVideoConfiguration.setClickThroughUrl(CLICKTHROUGH_URL);
         vastVideoConfiguration.addClickTrackers(Arrays.asList("click_1", "click_2"));
 
         VastCompanionAd vastCompanionAd = new VastCompanionAd(
                 300,
                 250,
-                "companion_image_url",
-                "companion_click_destination_url",
-                new ArrayList<String>(Arrays.asList("companion_click_tracking_url_1", "companion_click_tracking_url_2"))
+                COMPANION_IMAGE_URL,
+                COMPANION_CLICK_DESTINATION_URL,
+                new ArrayList<String>(Arrays.asList(COMPANION_CLICK_TRACKING_URL_1, COMPANION_CLICK_TRACKING_URL_2))
         );
         vastVideoConfiguration.setVastCompanionAd(vastCompanionAd);
 
@@ -200,7 +224,7 @@ public void constructor_shouldAddThatchedBackgroundWithGradientToLayout() throws
                         new int[]{Color.argb(0, 0, 0, 0), Color.argb(255, 0, 0, 0)})
         );
     }
-    
+
     @Test
     public void constructor_withMissingVastVideoConfiguration_shouldThrowIllegalStateException() throws Exception {
         bundle.clear();
@@ -223,6 +247,78 @@ public void constructor_withNullVastVideoConfigurationDiskMediaFileUrl_shouldThr
         }
     }
 
+    @Test
+    public void constructor_whenCustomCtaTextNotSpecified_shouldUseDefaultCtaText() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+
+        assertThat(getVastVideoToolbar().getLearnMoreWidget().getTextViewText()).isEqualTo("Learn More");
+    }
+
+    @Test
+    public void constructor_whenCustomCtaTextSpecified_shouldUseCustomCtaText() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setCustomCtaText("custom CTA text");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+
+        assertThat(getVastVideoToolbar().getLearnMoreWidget().getTextViewText()).isEqualTo("custom CTA text");
+    }
+
+    @Test
+    public void constructor_whenCustomSkipTextNotSpecified_shouldUseDefaultSkipText() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+
+        assertThat(getVastVideoToolbar().getCloseButtonWidget().getTextViewText()).isEqualTo("Close");
+    }
+
+    @Test
+    public void constructor_whenCustomSkipTextSpecified_shouldUseCustomSkipText() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setCustomSkipText("custom skip text");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+
+        assertThat(getVastVideoToolbar().getCloseButtonWidget().getTextViewText()).isEqualTo("custom skip text");
+    }
+
+    @Test
+    public void constructor_whenCustomCloseIconNotSpecified_shouldUseDefaultCloseIcon() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+
+        Drawable imageViewDrawable = getVastVideoToolbar().getCloseButtonWidget().getImageViewDrawable();
+
+        // Default close icon is an instance of CloseButtonDrawable
+        assertThat(imageViewDrawable).isInstanceOf(CloseButtonDrawable.class);
+    }
+
+    @Test
+    public void constructor_whenCustomCloseIconSpecified_shouldUseCustomCloseIcon() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setCustomCloseIconUrl("http://ton.twitter.com/exchange-media/images/v4/star_icon_3x_1.png");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+
+        verify(mockImageLoader).get(eq("http://ton.twitter.com/exchange-media/images/v4/star_icon_3x_1.png"), any(ImageListener.class));
+    }
+
     @Test
     public void onCreate_withCompanionAd_shouldDownloadCompanionAd() throws Exception {
         initializeSubject();
@@ -257,6 +353,57 @@ public void onCreate_shouldBroadcastInterstitialShow() throws Exception {
         verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
     }
 
+    @Test
+    public void onCreate_whenCustomForceOrientationNotSpecified_shouldForceLandscapeOrientation() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        subject.onCreate();
+
+        verify(baseVideoViewControllerListener).onSetRequestedOrientation(SCREEN_ORIENTATION_LANDSCAPE);
+    }
+
+    @Test
+    public void onCreate_whenCustomForceOrientationIsDeviceOrientation_shouldNotForceLandscapeOrientation() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setCustomForceOrientation(ForceOrientation.DEVICE_ORIENTATION);
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        subject.onCreate();
+
+        verify(baseVideoViewControllerListener, never()).onSetRequestedOrientation(anyInt());
+    }
+
+    @Test
+    public void onCreate_whenCustomForceOrientationIsPortraitOrientation_shouldForcePortraitOrientation() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setCustomForceOrientation(ForceOrientation.FORCE_PORTRAIT);
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        subject.onCreate();
+
+        verify(baseVideoViewControllerListener).onSetRequestedOrientation(SCREEN_ORIENTATION_PORTRAIT);
+    }
+
+    @Test
+    public void onCreate_whenCustomForceOrientationIsLandscapeOrientation_shouldForceLandscapeOrientation() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setCustomForceOrientation(ForceOrientation.FORCE_LANDSCAPE);
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        subject.onCreate();
+
+        verify(baseVideoViewControllerListener).onSetRequestedOrientation(SCREEN_ORIENTATION_LANDSCAPE);
+    }
+
     @Test
     public void onComplete_withNullDownloadResponse_shouldNotSetCompanionAdImageBitmap() throws Exception {
         initializeSubject();
@@ -284,10 +431,10 @@ public void onClick_withCompanionAd_shouldFireCompanionAdClickTrackersAndStartMo
         assertThat(imageView.performClick()).isTrue();
 
         // This request is still made by the older http stack.
-        assertHttpRequestsMade(expectedUserAgent, "companion_image_url");
+        assertHttpRequestsMade(expectedUserAgent, COMPANION_IMAGE_URL);
 
-        verify(mockRequestQueue).add(argThat(isUrl("companion_click_tracking_url_1")));
-        verify(mockRequestQueue).add(argThat(isUrl("companion_click_tracking_url_2")));
+        verify(mockRequestQueue).add(argThat(isUrl(COMPANION_CLICK_TRACKING_URL_1)));
+        verify(mockRequestQueue).add(argThat(isUrl(COMPANION_CLICK_TRACKING_URL_2)));
 
         ArgumentCaptor<Bundle> bundleCaptor = ArgumentCaptor.forClass(Bundle.class);
         verify(baseVideoViewControllerListener).onStartActivityForResult(
@@ -296,7 +443,7 @@ public void onClick_withCompanionAd_shouldFireCompanionAdClickTrackersAndStartMo
                 bundleCaptor.capture()
         );
 
-        assertThat(bundleCaptor.getValue().get(DESTINATION_URL_KEY)).isEqualTo("companion_click_destination_url");
+        assertThat(bundleCaptor.getValue().get(DESTINATION_URL_KEY)).isEqualTo(COMPANION_CLICK_DESTINATION_URL);
     }
 
     @Test
@@ -347,11 +494,10 @@ public void onActivityResult_withIncorrectResultCode_shouldNotCallFinish() throw
 
     @Test
     public void onTouch_withTouchUp_whenVideoLessThan16Seconds_andClickBeforeEnd_shouldDoNothing() throws Exception {
-        stub(mockMediaPlayer.getDuration()).toReturn(15999);
-        stub(mockMediaPlayer.getCurrentPosition()).toReturn(15990);
-
         initializeSubject();
-        setMockMediaPlayer(mockMediaPlayer);
+        spyOnVideoView();
+        setVideoViewParams(15990, 15999);
+
         getShadowVideoView().getOnPreparedListener().onPrepared(null);
 
         Robolectric.getUiThreadScheduler().unPause();
@@ -364,13 +510,11 @@ public void onTouch_withTouchUp_whenVideoLessThan16Seconds_andClickBeforeEnd_sho
 
     @Test
     public void onTouch_withTouchUp_whenVideoLessThan16Seconds_andClickAfterEnd_shouldStartMoPubBrowser() throws Exception {
-        stub(mockMediaPlayer.getDuration()).toReturn(15999);
-        stub(mockMediaPlayer.getCurrentPosition()).toReturn(16000);
-
         initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(15999, 15999);
         subject.onResume();
 
-        setMockMediaPlayer(mockMediaPlayer);
         getShadowVideoView().getOnPreparedListener().onPrepared(null);
 
         Robolectric.getUiThreadScheduler().unPause();
@@ -384,18 +528,16 @@ public void onTouch_withTouchUp_whenVideoLessThan16Seconds_andClickAfterEnd_shou
                 bundleCaptor.capture()
         );
 
-        assertThat(bundleCaptor.getValue().get(DESTINATION_URL_KEY)).isEqualTo("clickThrough");
+        assertThat(bundleCaptor.getValue().get(DESTINATION_URL_KEY)).isEqualTo(CLICKTHROUGH_URL);
     }
 
     @Test
     public void onTouch_withTouchUp_whenVideoLongerThan16Seconds_andClickBefore5Seconds_shouldDoNothing() throws Exception {
-        stub(mockMediaPlayer.getDuration()).toReturn(100000);
-        stub(mockMediaPlayer.getCurrentPosition()).toReturn(4999);
-
         initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(4999, 100000);
         subject.onResume();
 
-        setMockMediaPlayer(mockMediaPlayer);
         getShadowVideoView().getOnPreparedListener().onPrepared(null);
 
         Robolectric.getUiThreadScheduler().unPause();
@@ -408,13 +550,11 @@ public void onTouch_withTouchUp_whenVideoLongerThan16Seconds_andClickBefore5Seco
 
     @Test
     public void onTouch_withTouchUp_whenVideoLongerThan16Seconds_andClickAfter5Seconds_shouldStartMoPubBrowser() throws Exception {
-        stub(mockMediaPlayer.getDuration()).toReturn(100000);
-        stub(mockMediaPlayer.getCurrentPosition()).toReturn(5001);
-
         initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(5001, 100000);
         subject.onResume();
 
-        setMockMediaPlayer(mockMediaPlayer);
         getShadowVideoView().getOnPreparedListener().onPrepared(null);
 
         Robolectric.getUiThreadScheduler().unPause();
@@ -428,7 +568,7 @@ public void onTouch_withTouchUp_whenVideoLongerThan16Seconds_andClickAfter5Secon
                 bundleCaptor.capture()
         );
 
-        assertThat(bundleCaptor.getValue().get(DESTINATION_URL_KEY)).isEqualTo("clickThrough");
+        assertThat(bundleCaptor.getValue().get(DESTINATION_URL_KEY)).isEqualTo(CLICKTHROUGH_URL);
     }
 
     @Test
@@ -485,9 +625,8 @@ public void onTouch_withActionTouchDown_shouldConsumeMotionEvent() throws Except
     @Test
     public void onPrepared_whenDurationIsLessThanMaxVideoDurationForCloseButton_shouldSetShowCloseButtonDelayToDuration() throws Exception {
         initializeSubject();
-
-        stub(mockMediaPlayer.getDuration()).toReturn(1000);
-        setMockMediaPlayer(mockMediaPlayer);
+        spyOnVideoView();
+        setVideoViewParams(0, 1000);
 
         getShadowVideoView().getOnPreparedListener().onPrepared(null);
 
@@ -497,13 +636,199 @@ public void onPrepared_whenDurationIsLessThanMaxVideoDurationForCloseButton_shou
     @Test
     public void onPrepared_whenDurationIsGreaterThanMaxVideoDurationForCloseButton_shouldNotSetShowCloseButtonDelay() throws Exception {
         initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
 
-        stub(mockMediaPlayer.getDuration()).toReturn(MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
-        setMockMediaPlayer(mockMediaPlayer);
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
+    }
+
+    @Test
+    public void onPrepared_whenPercentSkipOffsetSpecified_shouldSetShowCloseButtonDelayToSkipOffset() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("25%");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, 10000);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(2500);
+        assertThat(subject.getHasSkipOffset()).isTrue();
+    }
+
+    @Test
+    public void onPrepared_whenAbsoluteSkipOffsetSpecified_shouldSetShowCloseButtonDelayToSkipOffset() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("00:00:03");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, 10000);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(3000);
+        assertThat(subject.getHasSkipOffset()).isTrue();
+    }
+
+    @Test
+    public void onPrepared_whenAbsoluteSkipOffsetWithMillisecondsSpecified_shouldSetShowCloseButtonDelayToSkipOffset() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("00:00:03.141");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, 10000);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(3141);
+        assertThat(subject.getHasSkipOffset()).isTrue();
+    }
+
+    @Test
+    public void onPrepared_whenSkipOffsetIsNull_shouldNotSetShowCloseButtonDelay() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset(null);
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
+        assertThat(subject.getHasSkipOffset()).isFalse();
+    }
+
+    @Test
+    public void onPrepared_whenSkipOffsetHasInvalidAbsoluteFormat_shouldNotSetShowCloseButtonDelay() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("123:4:56.7");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
 
         getShadowVideoView().getOnPreparedListener().onPrepared(null);
 
         assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
+        assertThat(subject.getHasSkipOffset()).isFalse();
+    }
+
+    @Test
+    public void onPrepared_whenSkipOffsetHasInvalidPercentFormat_shouldNotSetShowCloseButtonDelay() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("101%");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
+        assertThat(subject.getHasSkipOffset()).isFalse();
+    }
+
+    @Test
+    public void onPrepared_whenSkipOffsetHasInvalidFractionalPercentFormat_shouldNotSetShowCloseButtonDelay() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("3.14%");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
+        assertThat(subject.getHasSkipOffset()).isFalse();
+    }
+
+    @Test
+    public void onPrepared_whenSkipOffsetIsNegative_shouldNotSetShowCloseButtonDelay() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("-00:00:03");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
+        assertThat(subject.getHasSkipOffset()).isFalse();
+    }
+
+    @Test
+    public void onPrepared_whenSkipOffsetIsZero_shouldSetShowCloseButtonDelayToZero() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("00:00:00");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(0);
+        assertThat(subject.getHasSkipOffset()).isTrue();
+    }
+
+    @Test
+    public void onPrepared_whenSkipOffsetIsLongerThanDurationForShortVideo_shouldNotSetShowCloseButtonDelay() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("00:00:11");   // 11s
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, 10000);    // 10s: short video
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(10 * 1000);
+        assertThat(subject.getHasSkipOffset()).isFalse();
+    }
+
+    @Test
+    public void onPrepared_whenSkipOffsetIsLongerThanDurationForLongVideo_shouldNotSetShowCloseButtonDelay() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("00:00:21");   // 21s
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, 20000);    // 20s: long video
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
+        assertThat(subject.getHasSkipOffset()).isFalse();
     }
 
     @Test
@@ -516,14 +841,16 @@ public void onCompletion_shouldMarkVideoAsFinished() throws Exception {
     }
 
     @Test
-    public void onCompletion_whenFinalMarkHit_whenNoPlaybackErrors_shouldPingCompletionTrackersOnlyOnce() throws Exception {
+    public void onCompletion_whenAllTrackersTracked_whenNoPlaybackErrors_shouldPingCompletionTrackersOnlyOnce() throws Exception {
         VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
         vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        VastAbsoluteProgressTracker testTracker = new VastAbsoluteProgressTracker("testUrl", 123);
+        vastVideoConfiguration.addAbsoluteTrackers(Arrays.asList(testTracker));
         vastVideoConfiguration.addCompleteTrackers(Arrays.asList("complete_1", "complete_2"));
         bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
 
         initializeSubject();
-        subject.setFinalMarkHit();
+        testTracker.setTracked();
 
         getShadowVideoView().getOnCompletionListener().onCompletion(null);
         verify(mockRequestQueue).add(argThat(isUrl("complete_1")));
@@ -536,14 +863,16 @@ public void onCompletion_whenFinalMarkHit_whenNoPlaybackErrors_shouldPingComplet
     }
 
     @Test
-    public void onCompletion_whenFinalMarkNotHit_shouldNotPingCompletionTrackers() throws Exception {
+    public void onCompletion_whenSomeTrackersRemain_shouldNotPingCompletionTrackers() throws Exception {
         VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
         vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
         vastVideoConfiguration.addCompleteTrackers(Arrays.asList("complete_1", "complete_2"));
+        VastAbsoluteProgressTracker testTracker = new VastAbsoluteProgressTracker("testUrl", 123);
+        // Never track the testTracker, so completion trackers should not be fired.
+        vastVideoConfiguration.addAbsoluteTrackers(Arrays.asList(testTracker));
         bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
 
         initializeSubject();
-        // explicitly do not call subject.setFinalMarkHit();
 
         getShadowVideoView().getOnCompletionListener().onCompletion(null);
         verify(mockRequestQueue, never()).add(argThat(isUrl("complete_1")));
@@ -577,15 +906,16 @@ public void onCompletion_shouldPreventOnResumeFromStartingVideo() throws Excepti
     }
 
     @Test
-    public void onCompletion_shouldStopProgressChecker() throws Exception {
+    public void onCompletion_shouldStopProgressCheckerAndCountdown() throws Exception {
         initializeSubject();
         subject.onResume();
 
-        assertThat(subject.getIsVideoProgressShouldBeChecked()).isTrue();
+        reset(spyCountdownRunnable, spyCountdownRunnable);
 
         getShadowVideoView().getOnCompletionListener().onCompletion(null);
 
-        assertThat(subject.getIsVideoProgressShouldBeChecked()).isFalse();
+        verify(spyCountdownRunnable).stop();
+        verify(spyProgressRunnable).stop();
     }
 
     @Test
@@ -643,11 +973,13 @@ public void onError_shouldStopProgressChecker() throws Exception {
         initializeSubject();
         subject.onResume();
 
-        assertThat(subject.getIsVideoProgressShouldBeChecked()).isTrue();
-
+        verify(spyProgressRunnable).startRepeating(anyLong());
+        verify(spyCountdownRunnable).startRepeating(anyLong());
+        reset(spyProgressRunnable, spyCountdownRunnable);
         getShadowVideoView().getOnErrorListener().onError(null, 0, 0);
 
-        assertThat(subject.getIsVideoProgressShouldBeChecked()).isFalse();
+        verify(spyProgressRunnable).stop();
+        verify(spyCountdownRunnable).stop();
     }
 
     @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH_MR1)
@@ -736,7 +1068,7 @@ public void retryMediaPlayer_withOtherVideoError_shouldReturnFalse() throws Exce
     @Test
     public void retryMediaPlayer_withExceptionThrown_shouldReturnFalseAndIncrementRetryCount() throws Exception {
         File file = new File("disk_video_path");
-        if (file.exists()){
+        if (file.exists()) {
             assertThat(file.delete()).isTrue();
         }
 
@@ -748,24 +1080,24 @@ public void retryMediaPlayer_withExceptionThrown_shouldReturnFalseAndIncrementRe
     }
 
     @Test
-    public void handleClick_shouldMakeRequestsToClickTrackingUrls() {
+    public void handleClick_shouldMakeRequestsToClickTrackingUrls() throws Exception {
         initializeSubject();
-        subject.handleClick(Arrays.asList("clicktracker1", "clicktracker2"), "clickthrough");
+        subject.handleClick(Arrays.asList("clicktracker1", "clicktracker2"), CLICKTHROUGH_URL);
 
         verify(mockRequestQueue).add(argThat(isUrl("clicktracker1")));
         verify(mockRequestQueue).add(argThat(isUrl("clicktracker2")));
     }
 
     @Test
-    public void handleClick_withNullClickTrackers_shouldNotThrowAnException() {
+    public void handleClick_withNullClickTrackers_shouldNotThrowAnException() throws Exception {
         initializeSubject();
-        subject.handleClick(null, "clickthrough");
+        subject.handleClick(null, CLICKTHROUGH_URL);
 
         // pass
     }
 
     @Test
-    public void handleClick_withNullClickThroughUrl_shouldNotBroadcastClickOrOpenNewActivity() {
+    public void handleClick_withNullClickThroughUrl_shouldNotBroadcastClickOrOpenNewActivity() throws Exception {
         Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_CLICK, testBroadcastIdentifier);
 
         initializeSubject();
@@ -777,7 +1109,7 @@ public void handleClick_withNullClickThroughUrl_shouldNotBroadcastClickOrOpenNew
     }
 
     @Test
-    public void handleClick_withMoPubNativeBrowserClickThroughUrl_shouldOpenExternalBrowser() {
+    public void handleClick_withMoPubNativeBrowserClickThroughUrl_shouldOpenExternalBrowser() throws Exception {
         initializeSubject();
 
         subject.handleClick(Arrays.asList("clicktracker"),
@@ -789,7 +1121,7 @@ public void handleClick_withMoPubNativeBrowserClickThroughUrl_shouldOpenExternal
     }
 
     @Test
-    public void handleClick_withMalformedMoPubNativeBrowserClickThroughUrl_shouldNotOpenANewActivity() {
+    public void handleClick_withMalformedMoPubNativeBrowserClickThroughUrl_shouldNotOpenANewActivity() throws Exception {
         initializeSubject();
 
         // url2 is an invalid query parameter
@@ -800,22 +1132,30 @@ public void handleClick_withMalformedMoPubNativeBrowserClickThroughUrl_shouldNot
     }
 
     @Test
-    public void videoProgressCheckerRunnableRun_shouldFireOffAllProgressTrackers() throws Exception {
-        stub(mockMediaPlayer.getDuration()).toReturn(9001);
-        stub(mockMediaPlayer.getCurrentPosition()).toReturn(9002);
+    public void handleClick_withAboutBlankClickThroughUrl_shouldFailSilently() throws Exception {
+        initializeSubject();
 
+        subject.handleClick(Arrays.asList("clicktracker"), "about:blank");
+
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+    }
+
+    @Test
+    public void videoRunnablesRun_shouldFireOffAllProgressTrackers() throws Exception {
         VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
         vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addFirstQuartileTrackers(Arrays.asList("first"));
-        vastVideoConfiguration.addMidpointTrackers(Arrays.asList("second"));
-        vastVideoConfiguration.addThirdQuartileTrackers(Arrays.asList("third"));
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("first", 0.25f),
+                new VastFractionalProgressTracker("second", 0.5f),
+                new VastFractionalProgressTracker("third", 0.75f)));
+
         bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
 
         initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(9002, 9002);
         subject.onResume();
-        setMockMediaPlayer(mockMediaPlayer);
 
-        // this runs the videoProgressChecker
+        // this runs the videoProgressChecker and countdown runnable
         Robolectric.getUiThreadScheduler().unPause();
 
         verify(mockRequestQueue).add(argThat(isUrl("first")));
@@ -824,147 +1164,205 @@ public void videoProgressCheckerRunnableRun_shouldFireOffAllProgressTrackers() t
     }
 
     @Test
-    public void videoProgressCheckerRunnableRun_whenDurationIsInvalid_shouldNotMakeAnyNetworkCalls() throws Exception {
-        stub(mockMediaPlayer.getDuration()).toReturn(0);
-        stub(mockMediaPlayer.getCurrentPosition()).toReturn(100);
+    public void getUntriggeredTrackersBefore_endOfVideo_shouldReturnAllTrackers() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("first", 0.25f),
+                new VastFractionalProgressTracker("second", 0.5f),
+                new VastFractionalProgressTracker("third", 0.75f)));
+        vastVideoConfiguration.addAbsoluteTrackers(Arrays.asList(new VastAbsoluteProgressTracker("1secs", 1000), new VastAbsoluteProgressTracker("10secs", 10000)));
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(11000, 11000);
+
+        final List<VastTracker> untriggeredTrackers = subject.getUntriggeredTrackersBefore(11000, 11000);
+        assertThat(untriggeredTrackers).hasSize(5);
+
+        // Sorted absolute trackers, followed by sorted fractional trackers
+        final VastTracker tracker0 = untriggeredTrackers.get(0);
+        assertThat(tracker0).isExactlyInstanceOf(VastAbsoluteProgressTracker.class);
+        assertThat(((VastAbsoluteProgressTracker) tracker0).getTrackingMilliseconds()).isEqualTo(1000);
+
+        final VastTracker tracker1 = untriggeredTrackers.get(1);
+        assertThat(tracker1).isExactlyInstanceOf(VastAbsoluteProgressTracker.class);
+        assertThat(((VastAbsoluteProgressTracker) tracker1).getTrackingMilliseconds()).isEqualTo(10000);
+
 
+        final VastTracker tracker2 = untriggeredTrackers.get(2);
+        assertThat(tracker2).isExactlyInstanceOf(VastFractionalProgressTracker.class);
+        assertThat(((VastFractionalProgressTracker) tracker2).trackingFraction()).isEqualTo(0.25f);
+
+        final VastTracker tracker3 = untriggeredTrackers.get(3);
+        assertThat(tracker3).isExactlyInstanceOf(VastFractionalProgressTracker.class);
+        assertThat(((VastFractionalProgressTracker) tracker3).trackingFraction()).isEqualTo(0.5f);
+
+        final VastTracker tracker4 = untriggeredTrackers.get(4);
+        assertThat(tracker4).isExactlyInstanceOf(VastFractionalProgressTracker.class);
+        assertThat(((VastFractionalProgressTracker) tracker4).trackingFraction()).isEqualTo(0.75f);
+    }
+
+    @Test
+    public void getUntriggeredTrackersBefore_withTriggeredTrackers_shouldNotReturnTriggered() throws Exception {
         VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
         vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("first", 0.25f),
+                new VastFractionalProgressTracker("second", 0.5f),
+                new VastFractionalProgressTracker("third", 0.75f)));
+        vastVideoConfiguration.addAbsoluteTrackers(Arrays.asList(new VastAbsoluteProgressTracker("5secs", 5000), new VastAbsoluteProgressTracker("10secs", 10000)));
         bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
 
         initializeSubject();
-        setMockMediaPlayer(mockMediaPlayer);
+        spyOnVideoView();
+        setVideoViewParams(11000, 11000);
+
+        final List<VastTracker> untriggeredTrackers = subject.getUntriggeredTrackersBefore(11000, 11000);
+        assertThat(untriggeredTrackers).hasSize(5);
+        untriggeredTrackers.get(0).setTracked();
+
+        final List<VastTracker> secondTrackersList = subject.getUntriggeredTrackersBefore(11000, 11000);
+        assertThat(secondTrackersList).hasSize(4);
+    }
+
+    @Test
+    public void videoRunnablesRun_whenDurationIsInvalid_shouldNotMakeAnyNetworkCalls() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, 100);
+
         subject.onResume();
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
 
-        Robolectric.getUiThreadScheduler().runOneTask();
+        Robolectric.getUiThreadScheduler().runTasks(2);
         // make sure the repeated task hasn't run yet
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
         verifyZeroInteractions(mockRequestQueue);
     }
 
     @Test
-    public void videoProgressCheckerRunnableRun_whenCurrentTimeLessThanTwoSeconds_shouldNotFireStartTracker() throws Exception {
+    public void videoRunnablesRun_whenCurrentTimeLessThanTwoSeconds_shouldNotFireStartTracker() throws Exception {
         VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
         vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addStartTrackers(Arrays.asList("start"));
+        vastVideoConfiguration.addAbsoluteTrackers(Arrays.asList(new VastAbsoluteProgressTracker("start", 2000)));
         bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
 
-        stub(mockMediaPlayer.getDuration()).toReturn(100000);
-        stub(mockMediaPlayer.getCurrentPosition()).toReturn(1999);
-
         initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(1999, 100000);
         subject.onResume();
-        setMockMediaPlayer(mockMediaPlayer);
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
 
-        Robolectric.getUiThreadScheduler().runOneTask();
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
+
+        Robolectric.getUiThreadScheduler().runTasks(2);
         // make sure the repeated task hasn't run yet
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
 
         // Since it has not yet been a second, we expect that the start tracker has not been fired
         verifyZeroInteractions(mockRequestQueue);
 
         // run checker another time
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
-        Robolectric.getUiThreadScheduler().runOneTask();
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
+        Robolectric.getUiThreadScheduler().runTasks(2);
 
         verifyZeroInteractions(mockRequestQueue);
     }
 
     @Test
-    public void videoProgressCheckerRunnableRun_whenCurrentTimeGreaterThanTwoSeconds_shouldFireStartTracker() throws Exception {
+    public void videoRunnablesRun_whenCurrentTimeGreaterThanTwoSeconds_shouldFireStartTracker() throws Exception {
         VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
         vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addStartTrackers(Arrays.asList("start"));
+        vastVideoConfiguration.addAbsoluteTrackers(Arrays.asList(new VastAbsoluteProgressTracker("start", 2000)));
+        vastVideoConfiguration.addAbsoluteTrackers(Arrays.asList(new VastAbsoluteProgressTracker("later", 3000)));
         bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
 
-        stub(mockMediaPlayer.getDuration()).toReturn(100000);
-        stub(mockMediaPlayer.getCurrentPosition()).toReturn(2000);
-
         initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(2000, 100000);
         subject.onResume();
-        setMockMediaPlayer(mockMediaPlayer);
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
 
         Robolectric.getUiThreadScheduler().unPause();
 
         verify(mockRequestQueue).add(argThat(isUrl("start")));
 
         // run checker another time
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
-        Robolectric.getUiThreadScheduler().runOneTask();
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
+        Robolectric.getUiThreadScheduler().runTasks(2);
 
         verifyNoMoreInteractions(mockRequestQueue);
     }
 
     @Test
-    public void videoProgressCheckerRunnableRun_whenProgressIsPastFirstQuartile_shouldOnlyPingFirstQuartileTrackersOnce() throws Exception {
-        stub(mockMediaPlayer.getDuration()).toReturn(100);
-        stub(mockMediaPlayer.getCurrentPosition()).toReturn(26);
-
+    public void videoRunnablesRun_whenProgressIsPastFirstQuartile_shouldOnlyPingFirstQuartileTrackersOnce() throws Exception {
         VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
         vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addFirstQuartileTrackers(Arrays.asList("first"));
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("first", 0.25f)));
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("don't call", 0.28f)));
         bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
 
         initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(26, 100);
         subject.onResume();
-        setMockMediaPlayer(mockMediaPlayer);
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
 
         Robolectric.getUiThreadScheduler().unPause();
 
         verify(mockRequestQueue).add(argThat(isUrl("first")));
 
         // run checker another time
-        Robolectric.getUiThreadScheduler().runOneTask();
+        Robolectric.getUiThreadScheduler().runTasks(2);
 
         verifyNoMoreInteractions(mockRequestQueue);
     }
 
     @Test
-    public void videoProgressCheckerRunnableRun_whenProgressIsPastMidQuartile_shouldPingFirstQuartileTrackers_andMidQuartileTrackersBothOnlyOnce() throws Exception {
-        stub(mockMediaPlayer.getDuration()).toReturn(100);
-        stub(mockMediaPlayer.getCurrentPosition()).toReturn(51);
+    public void videoRunnablesRun_whenProgressIsPastMidQuartile_shouldPingFirstQuartileTrackers_andMidQuartileTrackersBothOnlyOnce() throws Exception {
 
         VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
         vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addFirstQuartileTrackers(Arrays.asList("first"));
-        vastVideoConfiguration.addMidpointTrackers(Arrays.asList("second"));
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("first", 0.25f)));
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("second", 0.5f)));
         bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
 
         initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(51, 100);
+
         subject.onResume();
-        setMockMediaPlayer(mockMediaPlayer);
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
 
         Robolectric.getUiThreadScheduler().unPause();
 
         verify(mockRequestQueue).add(argThat(isUrl("first")));
         verify(mockRequestQueue).add(argThat(isUrl("second")));
 
-        Robolectric.getUiThreadScheduler().runOneTask();
+        Robolectric.getUiThreadScheduler().runTasks(2);
 
         verifyNoMoreInteractions(mockRequestQueue);
     }
 
     @Test
-    public void videoProgressCheckerRunnableRun_whenProgressIsPastThirdQuartile_shouldPingFirstQuartileTrackers_andMidQuartileTrackers_andThirdQuartileTrackersAllOnlyOnce() throws Exception {
-        stub(mockMediaPlayer.getDuration()).toReturn(100);
-        stub(mockMediaPlayer.getCurrentPosition()).toReturn(76);
-
+    public void videoRunnablesRun_whenProgressIsPastThirdQuartile_shouldPingFirstQuartileTrackers_andMidQuartileTrackers_andThirdQuartileTrackersAllOnlyOnce() throws Exception {
         VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
         vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addFirstQuartileTrackers(Arrays.asList("first"));
-        vastVideoConfiguration.addMidpointTrackers(Arrays.asList("second"));
-        vastVideoConfiguration.addThirdQuartileTrackers(Arrays.asList("third"));
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("first", 0.25f)));
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("second", 0.5f)));
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("third", 0.75f)));
         bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
 
         initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(76, 100);
+
         subject.onResume();
-        setMockMediaPlayer(mockMediaPlayer);
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
 
         Robolectric.getUiThreadScheduler().unPause();
 
@@ -972,58 +1370,67 @@ public void videoProgressCheckerRunnableRun_whenProgressIsPastThirdQuartile_shou
         verify(mockRequestQueue).add(argThat(isUrl("second")));
         verify(mockRequestQueue).add(argThat(isUrl("third")));
 
-        Robolectric.getUiThreadScheduler().runOneTask();
+        Robolectric.getUiThreadScheduler().runTasks(2);
 
         verifyNoMoreInteractions(mockRequestQueue);
     }
 
     @Test
-    public void videoProgressCheckerRunnableRun_asVideoPlays_shouldPingAllThreeTrackersIndividuallyOnce() throws Exception {
-        stub(mockMediaPlayer.getDuration()).toReturn(100);
+    public void videoRunnablesRun_asVideoPlays_shouldPingAllThreeTrackersIndividuallyOnce() throws Exception {
+        //stub(mockMediaPlayer.getDuration()).toReturn(100);
 
         VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
         vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addFirstQuartileTrackers(Arrays.asList("first"));
-        vastVideoConfiguration.addMidpointTrackers(Arrays.asList("second"));
-        vastVideoConfiguration.addThirdQuartileTrackers(Arrays.asList("third"));
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("first", 0.25f)));
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("second", 0.5f)));
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("third", 0.75f)));
         bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
 
         initializeSubject();
+        spyOnVideoView();
+        when(spyVideoView.getDuration()).thenReturn(100);
         subject.onResume();
-        setMockMediaPlayer(mockMediaPlayer);
 
         // before any trackers are fired
-        fastForwardMediaPlayerAndAssertRequestMade(1);
+        seekToAndAssertRequestsMade(1);
 
-        fastForwardMediaPlayerAndAssertRequestMade(24);
+        seekToAndAssertRequestsMade(24);
 
         // after it hits first tracker
-        fastForwardMediaPlayerAndAssertRequestMade(26, "first");
+        seekToAndAssertRequestsMade(26, "first");
 
         // before mid quartile is hit
-        fastForwardMediaPlayerAndAssertRequestMade(49);
+        seekToAndAssertRequestsMade(49);
 
         // after it hits mid trackers
-        fastForwardMediaPlayerAndAssertRequestMade(51, "second");
+        seekToAndAssertRequestsMade(51, "second");
 
         // before third quartile is hit
-        fastForwardMediaPlayerAndAssertRequestMade(74);
+        seekToAndAssertRequestsMade(74);
 
         // after third quartile is hit
-        fastForwardMediaPlayerAndAssertRequestMade(76, "third");
+        seekToAndAssertRequestsMade(76, "third");
 
         // way after third quartile is hit
-        fastForwardMediaPlayerAndAssertRequestMade(99);
+        seekToAndAssertRequestsMade(99);
+    }
+
+    private void seekToAndAssertRequestsMade(int position, String... trackingUrls) {
+        when(spyVideoView.getCurrentPosition()).thenReturn(position);
+
+        for (String url : trackingUrls) {
+            Robolectric.getUiThreadScheduler().unPause();
+            verify(mockRequestQueue).add(argThat(isUrl(url)));
+        }
     }
 
     @Test
-    public void videoProgressCheckerRunnableRun_whenCurrentPositionIsGreaterThanShowCloseButtonDelay_shouldShowCloseButton() throws Exception {
-        stub(mockMediaPlayer.getDuration()).toReturn(5002);
-        stub(mockMediaPlayer.getCurrentPosition()).toReturn(5001);
+    public void videoRunnablesRun_whenCurrentPositionIsGreaterThanShowCloseButtonDelay_shouldShowCloseButton() throws Exception {
 
         initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(5001, 5002);
         subject.onResume();
-        setMockMediaPlayer(mockMediaPlayer);
 
         assertThat(subject.isShowCloseButtonEventFired()).isFalse();
         Robolectric.getUiThreadScheduler().unPause();
@@ -1032,34 +1439,76 @@ public void videoProgressCheckerRunnableRun_whenCurrentPositionIsGreaterThanShow
     }
 
     @Test
-    public void onPause_shouldStopProgressChecker() throws Exception {
+    public void videoRunnablesRun_whenCurrentPositionIsGreaterThanSkipOffset_shouldShowCloseButton() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("25%");    // skipoffset is at 2.5s
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
         initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(2501, 10000); // duration is 10s, current position is 1ms after skipoffset
+        subject.onResume();
+
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(2500);
+        assertThat(subject.getHasSkipOffset()).isTrue();
+
+        assertThat(subject.isShowCloseButtonEventFired()).isFalse();
+        Robolectric.getUiThreadScheduler().unPause();
 
+        assertThat(subject.isShowCloseButtonEventFired()).isTrue();
+    }
+
+    @Test
+    public void videoRunnablesRun_whenCurrentPositionIsLessThanSkipOffset_shouldNotShowCloseButton() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("00:00:03");   // skipoffset is at 3s
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(2999, 10000); // duration is 10s, current position is 1ms before skipoffset
         subject.onResume();
-        assertThat(subject.getIsVideoProgressShouldBeChecked()).isTrue();
 
-        subject.onPause();
-        assertThat(subject.getIsVideoProgressShouldBeChecked()).isFalse();
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
 
-        subject.onPause();
-        assertThat(subject.getIsVideoProgressShouldBeChecked()).isFalse();
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(3000);
+        assertThat(subject.getHasSkipOffset()).isTrue();
+
+        assertThat(subject.isShowCloseButtonEventFired()).isFalse();
+        Robolectric.getUiThreadScheduler().unPause();
+
+        assertThat(subject.isShowCloseButtonEventFired()).isFalse();
     }
 
     @Test
-    public void onResume_shouldStartVideoProgressCheckerOnce() throws Exception {
+    public void onPause_shouldStopRunnables() throws Exception {
         initializeSubject();
 
         subject.onResume();
-        assertThat(subject.getIsVideoProgressShouldBeChecked()).isTrue();
+        verify(spyCountdownRunnable).startRepeating(anyLong());
+        verify(spyProgressRunnable).startRepeating(anyLong());
 
         subject.onPause();
-        assertThat(subject.getIsVideoProgressShouldBeChecked()).isFalse();
+        verify(spyCountdownRunnable).stop();
+        verify(spyProgressRunnable).stop();
+    }
 
-        subject.onResume();
-        assertThat(subject.getIsVideoProgressShouldBeChecked()).isTrue();
+    @Test
+    public void onResume_shouldStartRunnables() throws Exception {
+        initializeSubject();
+
+        subject.onPause();
+        verify(spyCountdownRunnable).stop();
+        verify(spyProgressRunnable).stop();
 
         subject.onResume();
-        assertThat(subject.getIsVideoProgressShouldBeChecked()).isTrue();
+        verify(spyCountdownRunnable).startRepeating(anyLong());
+        verify(spyProgressRunnable).startRepeating(anyLong());
     }
 
     @Test
@@ -1089,22 +1538,18 @@ public void onResume_shouldResetVideoRetryCountToZero() throws Exception {
         file.delete();
     }
 
-    @Ignore("pending")
     @Test
     public void onResume_shouldSeekToPrePausedPosition() throws Exception {
-        stub(mockMediaPlayer.getDuration()).toReturn(10000);
-        stub(mockMediaPlayer.getCurrentPosition()).toReturn(7000);
-
         initializeSubject();
-        setMockMediaPlayer(mockMediaPlayer);
-        final VideoView videoView = spy(subject.getVideoView());
+        spyOnVideoView();
+        setVideoViewParams(7000, 10000);
 
         subject.onPause();
 
-        stub(mockMediaPlayer.getCurrentPosition()).toReturn(1000);
+        setVideoViewParams(1000, 10000);
 
         subject.onResume();
-        verify(videoView).seekTo(eq(7000));
+        verify(spyVideoView).seekTo(eq(7000));
     }
 
     @Test
@@ -1123,30 +1568,46 @@ public void backButtonEnabled_whenCloseButtonIsVisible_shouldReturnTrue() throws
         assertThat(subject.backButtonEnabled()).isTrue();
     }
 
-    private void initializeSubject() {
-        subject = new VastVideoViewController(context, bundle, testBroadcastIdentifier, baseVideoViewControllerListener);
-    }
+    @Test
+    public void onClickCloseButton_whenCloseButtonIsVisible_shouldFireCloseTrackers() throws Exception {
+        initializeSubject();
 
-    private void setMockMediaPlayer(final MediaPlayer mockMediaPlayer) throws IllegalAccessException {
-        final VideoView videoView = subject.getVideoView();
-        ReflectionUtils.setVariableValueInObject(videoView, "mMediaPlayer", mockMediaPlayer);
+        subject.setCloseButtonVisible(true);
 
-        int state = (Integer) ReflectionUtils.getValueIncludingSuperclasses("STATE_PLAYING", videoView);
+        // We don't have direct access to the CloseButtonWidget's close event, so we manually
+        // invoke its onTouchListener's onTouch callback with a fake MotionEvent.ACTION_UP action.
+        View.OnTouchListener closeButtonOnTouchListener =
+                shadowOf(getVastVideoToolbar().getCloseButtonWidget()).getOnTouchListener();
+        closeButtonOnTouchListener.onTouch(null, GestureUtils.createActionUp(0, 0));
 
-        ReflectionUtils.setVariableValueInObject(videoView, "mCurrentState", state);
+        verify(mockRequestQueue).add(argThat(isUrl("close")));
+        verify(mockRequestQueue).add(argThat(isUrl("skip")));
     }
 
-    private void fastForwardMediaPlayerAndAssertRequestMade(int time, String... urls) throws Exception {
-        stub(mockMediaPlayer.getCurrentPosition()).toReturn(time);
-        Robolectric.getUiThreadScheduler().unPause();
-        Robolectric.getBackgroundScheduler().unPause();
-        Thread.sleep(NETWORK_DELAY);
+    private void initializeSubject() throws IllegalAccessException {
+        subject = new VastVideoViewController(context, bundle, testBroadcastIdentifier, baseVideoViewControllerListener);
+        spyOnRunnables();
+    }
 
-        for (String url : urls) {
-            verify(mockRequestQueue).add(argThat(isUrl(url)));
-        }
+    private void spyOnVideoView() throws IllegalAccessException {
+        spyVideoView = spy(subject.getVideoView());
+        ReflectionUtils.setVariableValueInObject(subject, "mVideoView", spyVideoView);
+    }
+
+    private void spyOnRunnables() throws IllegalAccessException {
+        final VastVideoViewProgressRunnable progressCheckerRunnable = (VastVideoViewProgressRunnable) ReflectionUtils.getValueIncludingSuperclasses("mProgressCheckerRunnable", subject);
+        spyProgressRunnable = spy(progressCheckerRunnable);
+
+        final VastVideoViewCountdownRunnable countdownRunnable = (VastVideoViewCountdownRunnable) ReflectionUtils.getValueIncludingSuperclasses("mCountdownRunnable", subject);
+        spyCountdownRunnable = spy(countdownRunnable);
+
+        ReflectionUtils.setVariableValueInObject(subject, "mProgressCheckerRunnable", spyProgressRunnable);
+        ReflectionUtils.setVariableValueInObject(subject, "mCountdownRunnable", spyCountdownRunnable);
+    }
 
-        Robolectric.getFakeHttpLayer().clearRequestInfos();
+    private void setVideoViewParams(int currentPosition, int duration) throws IllegalAccessException {
+        when(spyVideoView.getCurrentPosition()).thenReturn(currentPosition);
+        when(spyVideoView.getDuration()).thenReturn(duration);
     }
 
     private VastVideoToolbar getVastVideoToolbar() {
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewCountdownRunnableTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewCountdownRunnableTest.java
new file mode 100644
index 00000000..41c78e61
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewCountdownRunnableTest.java
@@ -0,0 +1,68 @@
+package com.mopub.mobileads;
+
+import android.os.Handler;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class VastVideoViewCountdownRunnableTest {
+
+    @Mock VastVideoViewController mockVideoViewController;
+    @Mock Handler mockHandler;
+
+    VastVideoViewCountdownRunnable subject;
+
+    @Before
+    public void setup() {
+        subject = new VastVideoViewCountdownRunnable(mockVideoViewController, mockHandler);
+    }
+
+    @Test
+    public void doWork_whenShouldBeInteractable_shouldCallMakeVideoInteractable() {
+        when(mockVideoViewController.shouldBeInteractable()).thenReturn(true);
+
+        subject.doWork();
+
+        verify(mockVideoViewController).makeVideoInteractable();
+        verify(mockVideoViewController).updateDuration();
+    }
+
+    @Test
+    public void doWork_whenShouldNotBeInteractable_shouldNotCallMakeVideoInteractable() {
+        when(mockVideoViewController.shouldBeInteractable()).thenReturn(false);
+
+        subject.doWork();
+
+        verify(mockVideoViewController, never()).makeVideoInteractable();
+        verify(mockVideoViewController).updateDuration();
+    }
+
+    @Test
+    public void doWork_whenShouldShowCountdown_shouldCallUpdateCountdown() {
+        when(mockVideoViewController.shouldShowCountdown()).thenReturn(true);
+
+        subject.doWork();
+
+        verify(mockVideoViewController).updateCountdown();
+        verify(mockVideoViewController).updateDuration();
+    }
+
+    @Test
+    public void run_whenShouldNotShowCountdown_shouldNotCallUpdateCountdown() {
+        when(mockVideoViewController.shouldShowCountdown()).thenReturn(false);
+
+        subject.doWork();
+
+        verify(mockVideoViewController, never()).updateCountdown();
+        verify(mockVideoViewController).updateDuration();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewProgressRunnableTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewProgressRunnableTest.java
new file mode 100644
index 00000000..b926db3c
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewProgressRunnableTest.java
@@ -0,0 +1,92 @@
+package com.mopub.mobileads;
+
+import android.content.Context;
+import android.os.Handler;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.network.TrackingRequest;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Captor;
+import org.mockito.Mock;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class VastVideoViewProgressRunnableTest {
+    @Mock VastVideoViewController mockVastVideoViewController;
+    @Mock Context mockContext;
+    @Mock Handler mockHandler;
+    @Mock MoPubRequestQueue mockRequestQueue;
+    @Captor ArgumentCaptor<TrackingRequest> requestCaptor;
+    VastVideoViewProgressRunnable subject;
+
+    @Before
+    public void setup() {
+        subject = new VastVideoViewProgressRunnable(mockVastVideoViewController, mockHandler);
+
+        // Request Queue needed to verify tracking requests made.
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+    }
+
+    @Test
+    public void doWork_whenTrackersReturned_shouldMakeTrackingRequests() {
+        List<VastTracker> testTrackers = new ArrayList<VastTracker>();
+        testTrackers.add(new VastAbsoluteProgressTracker("http://example.com/", 1999));
+        testTrackers.add(new VastAbsoluteProgressTracker("http://example1.com/", 2000));
+
+        when(mockVastVideoViewController.getUntriggeredTrackersBefore(eq(3000), eq(4000)))
+                .thenReturn(testTrackers);
+        when(mockVastVideoViewController.getCurrentPosition()).thenReturn(3000);
+        when(mockVastVideoViewController.getDuration()).thenReturn(4000);
+        when(mockVastVideoViewController.getContext()).thenReturn(mockContext);
+
+        subject.doWork();
+
+        verify(mockVastVideoViewController).getUntriggeredTrackersBefore(eq(3000), eq(4000));
+        verify(mockVastVideoViewController).getCurrentPosition();
+        verify(mockVastVideoViewController).getDuration();
+        verify(mockVastVideoViewController).getContext();
+
+        // Capture request queue - should get two different trackers.
+        verify(mockRequestQueue, times(2)).add(requestCaptor.capture());
+        final List<TrackingRequest> allValues = requestCaptor.getAllValues();
+        assertThat(allValues).hasSize(2);
+        assertThat(allValues.get(0).getUrl()).isEqualTo("http://example.com/");
+        assertThat(allValues.get(1).getUrl()).isEqualTo("http://example1.com/");
+
+        verifyNoMoreInteractions(mockVastVideoViewController, mockRequestQueue);
+    }
+
+    @Test
+    public void doWork_whenNoTrackersReturned_shouldNotMakeTrackingRequests() {
+        List<VastTracker> testTrackers = new ArrayList<VastTracker>();
+
+        when(mockVastVideoViewController.getUntriggeredTrackersBefore(eq(3000), eq(4000)))
+                .thenReturn(testTrackers);
+        when(mockVastVideoViewController.getCurrentPosition()).thenReturn(3000);
+        when(mockVastVideoViewController.getDuration()).thenReturn(4000);
+        when(mockVastVideoViewController.getContext()).thenReturn(mockContext);
+
+        subject.doWork();
+
+        verify(mockVastVideoViewController).getUntriggeredTrackersBefore(eq(3000), eq(4000));
+        verify(mockVastVideoViewController).getCurrentPosition();
+        verify(mockVastVideoViewController).getDuration();
+
+        verifyNoMoreInteractions(mockVastVideoViewController, mockRequestQueue);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/WebViewAdUrlGeneratorTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/WebViewAdUrlGeneratorTest.java
index c5cdd9fd..04a32c07 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/WebViewAdUrlGeneratorTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/WebViewAdUrlGeneratorTest.java
@@ -3,6 +3,8 @@
 import android.app.Activity;
 import android.content.Context;
 import android.content.res.Configuration;
+import android.content.res.Resources;
+import android.graphics.Point;
 import android.location.Location;
 import android.location.LocationManager;
 import android.net.ConnectivityManager;
@@ -12,8 +14,10 @@
 import android.provider.Settings;
 import android.telephony.TelephonyManager;
 import android.text.TextUtils;
+import android.util.DisplayMetrics;
+import android.view.Display;
+import android.view.WindowManager;
 
-import com.mopub.common.AdUrlGenerator;
 import com.mopub.common.ClientMetadata;
 import com.mopub.common.GpsHelper;
 import com.mopub.common.GpsHelperTest;
@@ -24,13 +28,15 @@
 import com.mopub.common.util.test.support.TestMethodBuilderFactory;
 import com.mopub.mobileads.test.support.MoPubShadowTelephonyManager;
 import com.mopub.mraid.MraidNativeCommandHandler;
+import com.mopub.network.Networking;
 import com.mopub.network.PlayServicesUrlRewriter;
 
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.mockito.Mockito;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowConnectivityManager;
@@ -50,8 +56,10 @@
 import static com.mopub.common.ClientMetadata.MoPubNetworkType;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.when;
 import static org.robolectric.Robolectric.application;
 import static org.robolectric.Robolectric.shadowOf;
@@ -60,8 +68,12 @@
 @Config(shadows = {MoPubShadowTelephonyManager.class})
 public class WebViewAdUrlGeneratorTest {
 
-    private WebViewAdUrlGenerator subject;
     private static final String TEST_UDID = "20b013c721c";
+    private static final int TEST_SCREEN_WIDTH = 42;
+    private static final int TEST_SCREEN_HEIGHT = 1337;
+    private static final float TEST_DENSITY = 1.0f;
+
+    private WebViewAdUrlGenerator subject;
     private String expectedUdid;
     private Configuration configuration;
     private MoPubShadowTelephonyManager shadowTelephonyManager;
@@ -71,8 +83,39 @@
 
     @Before
     public void setup() {
-        context = new Activity();
+        context = spy(Robolectric.buildActivity(Activity.class).create().get());
         shadowOf(context).grantPermissions(ACCESS_NETWORK_STATE);
+
+        // Set the expected screen dimensions to arbitrary numbers
+        final Resources spyResources = spy(context.getResources());
+        final DisplayMetrics mockDisplayMetrics = mock(DisplayMetrics.class);
+        mockDisplayMetrics.widthPixels = TEST_SCREEN_WIDTH;
+        mockDisplayMetrics.heightPixels = TEST_SCREEN_HEIGHT;
+        mockDisplayMetrics.density = TEST_DENSITY;
+        when(spyResources.getDisplayMetrics()).thenReturn(mockDisplayMetrics);
+        when(context.getResources()).thenReturn(spyResources);
+        when(context.getPackageName()).thenReturn("testBundle");
+
+        // Only do this on Android 17+ because getRealSize doesn't exist before then.
+        // This is the default pathway.
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
+            final WindowManager mockWindowManager = mock(WindowManager.class);
+            final Display mockDisplay = mock(Display.class);
+            doAnswer(new Answer() {
+                @Override
+                public Object answer(final InvocationOnMock invocationOnMock) throws Throwable {
+                    final Point point = (Point) invocationOnMock.getArguments()[0];
+                    point.x = TEST_SCREEN_WIDTH;
+                    point.y = TEST_SCREEN_HEIGHT;
+                    return null;
+                }
+            }).when(mockDisplay).getRealSize(any(Point.class));
+            when(mockWindowManager.getDefaultDisplay()).thenReturn(mockDisplay);
+            final Context spyApplicationContext = spy(context.getApplicationContext());
+            when(spyApplicationContext.getSystemService(Context.WINDOW_SERVICE)).thenReturn(mockWindowManager);
+            when(context.getApplicationContext()).thenReturn(spyApplicationContext);
+        }
+
         subject = new WebViewAdUrlGenerator(context,
                 new MraidNativeCommandHandler().isStorePictureSupported(context));
         Settings.Secure.putString(application.getContentResolver(), Settings.Secure.ANDROID_ID, TEST_UDID);
@@ -81,6 +124,7 @@ public void setup() {
         shadowTelephonyManager = (MoPubShadowTelephonyManager) shadowOf((TelephonyManager) application.getSystemService(Context.TELEPHONY_SERVICE));
         shadowConnectivityManager = shadowOf((ConnectivityManager) application.getSystemService(Context.CONNECTIVITY_SERVICE));
         methodBuilder = TestMethodBuilderFactory.getSingletonMock();
+        Networking.useHttps(false);
     }
 
     @After
@@ -97,6 +141,13 @@ public void generateAdUrl_shouldIncludeMinimumFields() throws Exception {
         assertThat(adUrl).isEqualTo(expectedAdUrl);
     }
 
+    @Test
+    public void generateAdUrl_withHttpsScheme() throws Exception {
+        Networking.useHttps(true);
+        String adUrl = generateMinimumUrlString();
+        assertThat(adUrl).startsWith("https://");
+    }
+
     @Test
     public void generateAdUrl_shouldRunMultipleTimes() throws Exception {
         String expectedAdUrl = new AdUrlBuilder(expectedUdid).build();
@@ -112,7 +163,7 @@ public void generateAdUrl_shouldIncludeAllFields() throws Exception {
         final String expectedAdUrl = new AdUrlBuilder(expectedUdid)
                 .withAdUnitId("adUnitId")
                 .withQuery("key%3Avalue")
-                .withLatLon("20.1%2C30.0", "1")
+                .withLatLon("20.1%2C30.0", "1", "101325")
                 .withMcc("123")
                 .withMnc("456")
                 .withCountryIso("expected%20country")
@@ -128,6 +179,7 @@ public void generateAdUrl_shouldIncludeAllFields() throws Exception {
         location.setLatitude(20.1);
         location.setLongitude(30.0);
         location.setAccuracy(1.23f); // should get rounded to "1"
+        location.setTime(System.currentTimeMillis() - 101325);
 
         String adUrl = subject
                 .withAdUnitId("adUnitId")
@@ -135,6 +187,9 @@ public void generateAdUrl_shouldIncludeAllFields() throws Exception {
                 .withLocation(location)
                 .generateUrlString("ads.mopub.com");
 
+        // Only compare the seconds since millis can be off
+        adUrl = adUrl.replaceFirst("llf=101[0-9]{3}", "llf=101325");
+
         assertThat(adUrl).isEqualTo(expectedAdUrl);
     }
 
@@ -295,6 +350,8 @@ public void generateAdUrl_shouldTolerateNullActiveNetwork() throws Exception {
         assertThat(adUrl).isEqualTo(urlBuilder.withNetworkType(MoPubNetworkType.UNKNOWN).build());
     }
 
+
+
     @Test
     public void generateAdUrl_whenGooglePlayServicesIsLinkedAndAdInfoIsCached_shouldUseAdInfoParams() throws Exception {
         GpsHelper.setClassNamesForTesting();
@@ -393,6 +450,17 @@ public void generateAdUrl_whenLocationServiceNetworkProviderHasMostRecentLocatio
         assertThat(getParameterFromRequestUrl(adUrl, "llsdk")).isEqualTo("1");
     }
 
+    @Test
+    public void generateAdUrl_withNullPackageName_withEmptyPackageName_shouldNotIncludeBundleKey() {
+        when(context.getPackageName()).thenReturn(null).thenReturn("");
+
+        final String adUrlNullPackageName = generateMinimumUrlString();
+        final String adUrlEmptyPackageName = generateMinimumUrlString();
+
+        assertThat(adUrlNullPackageName).doesNotContain("&bundle=");
+        assertThat(adUrlEmptyPackageName).doesNotContain("&bundle=");
+    }
+
     @Test
     public void enableLocationTracking_shouldIncludeLocationInUrl() {
         MoPub.setLocationAwareness(MoPub.LocationAwareness.NORMAL);
@@ -452,6 +520,7 @@ private String generateMinimumUrlString() {
         private String query = "";
         private String latLon = "";
         private String locationAccuracy = "";
+        private String latLonLastUpdated = "";
         private String mnc = "";
         private String mcc = "";
         private String countryIso = "";
@@ -472,23 +541,28 @@ public String build() {
                     "&dn=" + Build.MANUFACTURER +
                     "%2C" + Build.MODEL +
                     "%2C" + Build.PRODUCT +
-
+                    "&bundle=" + "testBundle" +
                     paramIfNotEmpty("q", query) +
-                    (TextUtils.isEmpty(latLon) ? "" : "&ll=" + latLon + "&lla=" + locationAccuracy) +
+                    (TextUtils.isEmpty(latLon) ? "" :
+                            "&ll=" + latLon + "&lla=" + locationAccuracy + "&llf=" + latLonLastUpdated) +
                     "&z=-0700" +
                     "&o=u" +
+                    "&w=" + TEST_SCREEN_WIDTH +
+                    "&h=" + TEST_SCREEN_HEIGHT +
                     "&sc_a=1.0" +
-                    "&mr=1" +
                     paramIfNotEmpty("mcc", mcc) +
                     paramIfNotEmpty("mnc", mnc) +
                     paramIfNotEmpty("iso", countryIso) +
                     paramIfNotEmpty("cn", carrierName) +
                     "&ct=" + networkType +
+                    // Maven version
                     "&av=1.0" +
-                    "&android_perms_ext_storage=" + externalStoragePermission +
+                    // Gradle Version
+                    //"&av=" + BuildConfig.VERSION_NAME +
                     "&udid=" + PlayServicesUrlRewriter.UDID_TEMPLATE +
-                    "&dnt=" + PlayServicesUrlRewriter.DO_NOT_TRACK_TEMPLATE;
-
+                    "&dnt=" + PlayServicesUrlRewriter.DO_NOT_TRACK_TEMPLATE +
+                    "&mr=1" +
+                    "&android_perms_ext_storage=" + externalStoragePermission;
         }
 
         public AdUrlBuilder withAdUnitId(String adUnitId) {
@@ -501,9 +575,11 @@ public AdUrlBuilder withQuery(String query) {
             return this;
         }
 
-        public AdUrlBuilder withLatLon(String latLon, String locationAccuracy) {
+        public AdUrlBuilder withLatLon(String latLon, String locationAccuracy,
+                String latLonLastUpdated) {
             this.latLon = latLon;
             this.locationAccuracy = locationAccuracy;
+            this.latLonLastUpdated = latLonLastUpdated;
             return this;
         }
 
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastManagerTest.java
index 44a25723..e13e5a5d 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastManagerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastManagerTest.java
@@ -7,8 +7,8 @@
 
 import com.mopub.common.CacheService;
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.DeviceUtils;
 
-import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -31,8 +31,9 @@
 
 @RunWith(SdkTestRunner.class)
 public class VastManagerTest {
-    static final String TEST_VAST_XML_STRING = "<VAST version='2.0'><Ad id='62833'><Wrapper><AdSystem>Tapad</AdSystem><VASTAdTagURI>http://dsp.x-team.staging.mopub.com/xml</VASTAdTagURI><Impression>http://myTrackingURL/wrapper/impression1</Impression><Impression>http://myTrackingURL/wrapper/impression2</Impression><Creatives><Creative AdID='62833'><Linear><TrackingEvents><Tracking event='creativeView'>http://myTrackingURL/wrapper/creativeView</Tracking><Tracking event='start'>http://myTrackingURL/wrapper/start</Tracking><Tracking event='midpoint'>http://myTrackingURL/wrapper/midpoint</Tracking><Tracking event='firstQuartile'>http://myTrackingURL/wrapper/firstQuartile</Tracking><Tracking event='thirdQuartile'>http://myTrackingURL/wrapper/thirdQuartile</Tracking><Tracking event='complete'>http://myTrackingURL/wrapper/complete</Tracking><Tracking event='mute'>http://myTrackingURL/wrapper/mute</Tracking><Tracking event='unmute'>http://myTrackingURL/wrapper/unmute</Tracking><Tracking event='pause'>http://myTrackingURL/wrapper/pause</Tracking><Tracking event='resume'>http://myTrackingURL/wrapper/resume</Tracking><Tracking event='fullscreen'>http://myTrackingURL/wrapper/fullscreen</Tracking></TrackingEvents><VideoClicks><ClickTracking>http://myTrackingURL/wrapper/click</ClickTracking></VideoClicks><MediaFiles><MediaFile delivery='progressive' bitrate='416' width='300' height='250' type='video/mp4'><![CDATA[https://s3.amazonaws.com/mopub-vast/tapad-video1.mp4]]></MediaFile></MediaFiles></Linear></Creative><Creative AdID=\"601364-Companion\"> <CompanionAds><Companion width=\"9000\"></Companion> </CompanionAds></Creative></Creatives></Wrapper></Ad></VAST><MP_TRACKING_URLS><MP_TRACKING_URL>http://www.mopub.com/imp1</MP_TRACKING_URL><MP_TRACKING_URL>http://www.mopub.com/imp2</MP_TRACKING_URL></MP_TRACKING_URLS>";
-    static final String TEST_NESTED_VAST_XML_STRING = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><VAST version='2.0'><Ad id='57722'><InLine><AdSystem version='1.0'>Tapad</AdSystem><AdTitle><![CDATA[PKW6T_LIV_DSN_Audience_TAPAD_3rd Party Audience Targeting_Action Movi]]></AdTitle><Description/><Impression><![CDATA[http://rtb-test.dev.tapad.com:8080/creative/imp.png?ts=1374099035457&svid=1&creative_id=30731&ctx_type=InApp&ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&liverail_cp=1]]></Impression><Creatives><Creative sequence='1' id='57722'><Linear><Duration>00:00:15</Duration><VideoClicks><ClickThrough><![CDATA[http://rtb-test.dev.tapad.com:8080/click?ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&crid=30731&ta_action_id=click&ts=1374099035458&redirect=http%3A%2F%2Ftapad.com]]></ClickThrough></VideoClicks><MediaFiles><MediaFile delivery='progressive' bitrate='416' width='800' height='480' type='video/mp4'><![CDATA[https://s3.amazonaws.com/mopub-vast/tapad-video.mp4]]></MediaFile></MediaFiles></Linear></Creative><Creative AdID=\"601364-Companion\"><CompanionAds><Companion id=\"valid\" height=\"250\" width=\"300\"><StaticResource creativeType=\"image/jpeg\">http://demo.tremormedia.com/proddev/vast/Blistex1.jpg</StaticResource><TrackingEvents><Tracking event=\"creativeView\">http://myTrackingURL/firstCompanionCreativeView</Tracking><Tracking event=\"creativeView\">http://myTrackingURL/secondCompanionCreativeView</Tracking></TrackingEvents><CompanionClickThrough>http://www.tremormedia.com</CompanionClickThrough></Companion></CompanionAds></Creative></Creatives></InLine></Ad></VAST>";
+    static final String EXTENSIONS_SNIPPET_PLACEHOLDER = "<![CDATA[EXTENSIONS_SNIPPET]]>";
+    static final String TEST_VAST_XML_STRING = "<VAST version='2.0'><Ad id='62833'><Wrapper><AdSystem>Tapad</AdSystem><VASTAdTagURI>http://dsp.x-team.staging.mopub.com/xml</VASTAdTagURI><Impression>http://myTrackingURL/wrapper/impression1</Impression><Impression>http://myTrackingURL/wrapper/impression2</Impression><Creatives><Creative AdID='62833'><Linear><TrackingEvents><Tracking event='creativeView'>http://myTrackingURL/wrapper/creativeView</Tracking><Tracking event='start'>http://myTrackingURL/wrapper/start</Tracking><Tracking event='midpoint'>http://myTrackingURL/wrapper/midpoint</Tracking><Tracking event='progress' offset='00:00:03.100'>http://myTrackingURL/wrapper/progress</Tracking><Tracking event='firstQuartile'>http://myTrackingURL/wrapper/firstQuartile</Tracking><Tracking event='thirdQuartile'>http://myTrackingURL/wrapper/thirdQuartile</Tracking><Tracking event='complete'>http://myTrackingURL/wrapper/complete</Tracking><Tracking event='close'>http://myTrackingURL/wrapper/close</Tracking><Tracking event='skip'>http://myTrackingURL/wrapper/skip</Tracking><Tracking event='mute'>http://myTrackingURL/wrapper/mute</Tracking><Tracking event='unmute'>http://myTrackingURL/wrapper/unmute</Tracking><Tracking event='pause'>http://myTrackingURL/wrapper/pause</Tracking><Tracking event='resume'>http://myTrackingURL/wrapper/resume</Tracking><Tracking event='fullscreen'>http://myTrackingURL/wrapper/fullscreen</Tracking></TrackingEvents><VideoClicks><ClickTracking>http://myTrackingURL/wrapper/click</ClickTracking></VideoClicks><MediaFiles><MediaFile delivery='progressive' bitrate='416' width='300' height='250' type='video/mp4'><![CDATA[https://s3.amazonaws.com/mopub-vast/tapad-video1.mp4]]></MediaFile></MediaFiles></Linear></Creative><Creative AdID=\"601364-Companion\"> <CompanionAds><Companion width=\"9000\"></Companion> </CompanionAds></Creative></Creatives><![CDATA[EXTENSIONS_SNIPPET]]></Wrapper></Ad></VAST><MP_TRACKING_URLS><MP_TRACKING_URL>http://www.mopub.com/imp1</MP_TRACKING_URL><MP_TRACKING_URL>http://www.mopub.com/imp2</MP_TRACKING_URL></MP_TRACKING_URLS>";
+    static final String TEST_NESTED_VAST_XML_STRING = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><VAST version='2.0'><Ad id='57722'><InLine><AdSystem version='1.0'>Tapad</AdSystem><AdTitle><![CDATA[PKW6T_LIV_DSN_Audience_TAPAD_3rd Party Audience Targeting_Action Movi]]></AdTitle><Description/><Impression><![CDATA[http://rtb-test.dev.tapad.com:8080/creative/imp.png?ts=1374099035457&svid=1&creative_id=30731&ctx_type=InApp&ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&liverail_cp=1]]></Impression><Creatives><Creative sequence='1' id='57722'><Linear><TrackingEvents><Tracking event='close'>http://myTrackingURL/wrapper/nested_close</Tracking><Tracking event='skip'>http://myTrackingURL/wrapper/nested_skip</Tracking></TrackingEvents><Duration>00:00:15</Duration><VideoClicks><ClickThrough><![CDATA[http://rtb-test.dev.tapad.com:8080/click?ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&crid=30731&ta_action_id=click&ts=1374099035458&redirect=http%3A%2F%2Ftapad.com]]></ClickThrough></VideoClicks><MediaFiles><MediaFile delivery='progressive' bitrate='416' width='800' height='480' type='video/mp4'><![CDATA[https://s3.amazonaws.com/mopub-vast/tapad-video.mp4]]></MediaFile></MediaFiles></Linear></Creative><Creative AdID=\"601364-Companion\"><CompanionAds><Companion id=\"valid\" height=\"250\" width=\"300\"><StaticResource creativeType=\"image/jpeg\">http://demo.tremormedia.com/proddev/vast/Blistex1.jpg</StaticResource><TrackingEvents><Tracking event=\"creativeView\">http://myTrackingURL/firstCompanionCreativeView</Tracking><Tracking event=\"creativeView\">http://myTrackingURL/secondCompanionCreativeView</Tracking></TrackingEvents><CompanionClickThrough>http://www.tremormedia.com</CompanionClickThrough></Companion></CompanionAds></Creative></Creatives><![CDATA[EXTENSIONS_SNIPPET]]></InLine></Ad></VAST>";
     static final String TEST_VAST_BAD_NEST_URL_XML_STRING = "<VAST version='2.0'><Ad id='62833'><Wrapper><AdSystem>Tapad</AdSystem><VASTAdTagURI>http://dsp.x-team.staging.mopub.com/xml\"$|||</VASTAdTagURI><Impression>http://myTrackingURL/wrapper/impression1</Impression><Impression>http://myTrackingURL/wrapper/impression2</Impression><Creatives><Creative AdID='62833'><Linear><TrackingEvents><Tracking event='creativeView'>http://myTrackingURL/wrapper/creativeView</Tracking><Tracking event='start'>http://myTrackingURL/wrapper/start</Tracking><Tracking event='midpoint'>http://myTrackingURL/wrapper/midpoint</Tracking><Tracking event='firstQuartile'>http://myTrackingURL/wrapper/firstQuartile</Tracking><Tracking event='thirdQuartile'>http://myTrackingURL/wrapper/thirdQuartile</Tracking><Tracking event='complete'>http://myTrackingURL/wrapper/complete</Tracking><Tracking event='mute'>http://myTrackingURL/wrapper/mute</Tracking><Tracking event='unmute'>http://myTrackingURL/wrapper/unmute</Tracking><Tracking event='pause'>http://myTrackingURL/wrapper/pause</Tracking><Tracking event='resume'>http://myTrackingURL/wrapper/resume</Tracking><Tracking event='fullscreen'>http://myTrackingURL/wrapper/fullscreen</Tracking></TrackingEvents><VideoClicks><ClickTracking>http://myTrackingURL/wrapper/click</ClickTracking></VideoClicks></Linear></Creative></Creatives></Wrapper></Ad></VAST><MP_TRACKING_URLS><MP_TRACKING_URL>http://www.mopub.com/imp1</MP_TRACKING_URL><MP_TRACKING_URL>http://www.mopub.com/imp2</MP_TRACKING_URL></MP_TRACKING_URLS>";
 
     private VastManager subject;
@@ -44,7 +45,7 @@
 
     @Before
     public void setup() {
-        context = new Activity();
+        context = Robolectric.buildActivity(Activity.class).create().get();
         CacheService.initializeDiskCache(context);
         subject = new VastManager(context);
         mFakeHttpLayer = Robolectric.getFakeHttpLayer();
@@ -87,11 +88,24 @@ public void prepareVastVideoConfiguration_shouldNotifyTheListenerAndContainTheCo
 
         assertThat(vastVideoConfiguration.getClickThroughUrl()).isEqualTo("http://rtb-test.dev.tapad.com:8080/click?ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&crid=30731&ta_action_id=click&ts=1374099035458&redirect=http%3A%2F%2Ftapad.com");
         assertThat(vastVideoConfiguration.getImpressionTrackers().size()).isEqualTo(5);
-        assertThat(vastVideoConfiguration.getStartTrackers().size()).isEqualTo(1);
-        assertThat(vastVideoConfiguration.getFirstQuartileTrackers().size()).isEqualTo(1);
-        assertThat(vastVideoConfiguration.getMidpointTrackers().size()).isEqualTo(1);
-        assertThat(vastVideoConfiguration.getThirdQuartileTrackers().size()).isEqualTo(1);
+
+        // Verify quartile trackers
+        assertThat(vastVideoConfiguration.getFractionalTrackers().size()).isEqualTo(3);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(0).trackingFraction()).isEqualTo(0.25f);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(1).trackingFraction()).isEqualTo(0.5f);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(2).trackingFraction()).isEqualTo(0.75f);
+
+        // Verify start tracker.
+        assertThat(vastVideoConfiguration.getAbsoluteTrackers().size()).isEqualTo(2);
+        assertThat(vastVideoConfiguration.getAbsoluteTrackers().get(0).getTrackingMilliseconds()).isEqualTo(2000);
+        assertThat(vastVideoConfiguration.getAbsoluteTrackers().get(1).getTrackingMilliseconds()).isEqualTo(3100);
+
         assertThat(vastVideoConfiguration.getCompleteTrackers().size()).isEqualTo(1);
+
+        // We specifically added a close tracker and a skip tracker to the nested vast test case as well,
+        // therefore there are two expected trackers total for each type.
+        assertThat(vastVideoConfiguration.getCloseTrackers().size()).isEqualTo(2);
+        assertThat(vastVideoConfiguration.getSkipTrackers().size()).isEqualTo(2);
         assertThat(vastVideoConfiguration.getClickTrackers().size()).isEqualTo(1);
 
         final VastCompanionAd vastCompanionAd = vastVideoConfiguration.getVastCompanionAd();
@@ -123,11 +137,30 @@ public void prepareVastVideoConfiguration_shouldHandleMultipleRedirects() throws
 
         assertThat(vastVideoConfiguration.getClickThroughUrl()).isEqualTo("http://rtb-test.dev.tapad.com:8080/click?ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&crid=30731&ta_action_id=click&ts=1374099035458&redirect=http%3A%2F%2Ftapad.com");
         assertThat(vastVideoConfiguration.getImpressionTrackers().size()).isEqualTo(13);
-        assertThat(vastVideoConfiguration.getStartTrackers().size()).isEqualTo(3);
-        assertThat(vastVideoConfiguration.getFirstQuartileTrackers().size()).isEqualTo(3);
-        assertThat(vastVideoConfiguration.getMidpointTrackers().size()).isEqualTo(3);
-        assertThat(vastVideoConfiguration.getThirdQuartileTrackers().size()).isEqualTo(3);
+
+        assertThat(vastVideoConfiguration.getAbsoluteTrackers().size()).isEqualTo(6);
+        assertThat(vastVideoConfiguration.getAbsoluteTrackers().get(0).getTrackingMilliseconds()).isEqualTo(2000);
+        assertThat(vastVideoConfiguration.getAbsoluteTrackers().get(1).getTrackingMilliseconds()).isEqualTo(2000);
+        assertThat(vastVideoConfiguration.getAbsoluteTrackers().get(2).getTrackingMilliseconds()).isEqualTo(2000);
+        assertThat(vastVideoConfiguration.getAbsoluteTrackers().get(3).getTrackingMilliseconds()).isEqualTo(3100);
+        assertThat(vastVideoConfiguration.getAbsoluteTrackers().get(4).getTrackingMilliseconds()).isEqualTo(3100);
+        assertThat(vastVideoConfiguration.getAbsoluteTrackers().get(5).getTrackingMilliseconds()).isEqualTo(3100);
+
+
+        assertThat(vastVideoConfiguration.getFractionalTrackers().size()).isEqualTo(9);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(0).trackingFraction()).isEqualTo(0.25f);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(1).trackingFraction()).isEqualTo(0.25f);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(2).trackingFraction()).isEqualTo(0.25f);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(3).trackingFraction()).isEqualTo(0.5f);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(4).trackingFraction()).isEqualTo(0.5f);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(5).trackingFraction()).isEqualTo(0.5f);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(6).trackingFraction()).isEqualTo(0.75f);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(7).trackingFraction()).isEqualTo(0.75f);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(8).trackingFraction()).isEqualTo(0.75f);
+
         assertThat(vastVideoConfiguration.getCompleteTrackers().size()).isEqualTo(3);
+        assertThat(vastVideoConfiguration.getCloseTrackers().size()).isEqualTo(4);
+        assertThat(vastVideoConfiguration.getSkipTrackers().size()).isEqualTo(4);
         assertThat(vastVideoConfiguration.getClickTrackers().size()).isEqualTo(3);
 
         final VastCompanionAd vastCompanionAd = vastVideoConfiguration.getVastCompanionAd();
@@ -139,7 +172,6 @@ public void prepareVastVideoConfiguration_shouldHandleMultipleRedirects() throws
                 .containsOnly("http://myTrackingURL/firstCompanionCreativeView", "http://myTrackingURL/secondCompanionCreativeView");
     }
 
-
     @Test
     public void prepareVastVideoConfiguration_shouldReturnCorrectVastValuesWhenAVastRedirectFails() throws Exception {
         // Vast redirect response
@@ -158,7 +190,309 @@ public void prepareVastVideoConfiguration_shouldReturnCorrectVastValuesWhenAVast
 
         assertThat(vastVideoConfiguration.getClickThroughUrl()).isEqualTo(null);
         assertThat(vastVideoConfiguration.getImpressionTrackers().size()).isEqualTo(4);
-        assertThat(vastVideoConfiguration.getFirstQuartileTrackers().size()).isEqualTo(1);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().size()).isEqualTo(3);
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withNoExtensions_shouldContainTheCorrectDefaultExtensionValues() throws Exception {
+        // Vast redirect response to XML without VAST extensions
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+
+        assertThat(vastVideoConfiguration.getCustomCtaText()).isNull();
+        assertThat(vastVideoConfiguration.getCustomSkipText()).isNull();
+        assertThat(vastVideoConfiguration.getCustomCloseIconUrl()).isNull();
+        assertThat(vastVideoConfiguration.getCustomForceOrientation()).isEqualTo(DeviceUtils.ForceOrientation.FORCE_LANDSCAPE);
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withExtensionsUnderWrapper_shouldContainTheCorrectCustomExtensionValues() throws Exception {
+        // Vast redirect response to XML without extensions
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        // Add extensions under Wrapper element in TEST_VAST_XML_STRING
+        subject.prepareVastVideoConfiguration(
+                TEST_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubCtaText>custom CTA text</MoPubCtaText>" +
+                                "<MoPubSkipText>skip</MoPubSkipText>" +
+                                "<MoPubCloseIcon>http://ton.twitter.com/exchange-media/images/v4/star_icon_3x.png</MoPubCloseIcon>" +
+                                "<MoPubForceOrientation>device</MoPubForceOrientation>" +
+                            "</Extension>" +
+                        "</Extensions>"),
+                vastManagerListener);
+
+        Robolectric.runBackgroundTasks();
+        Robolectric.runUiThreadTasks();
+        semaphore.acquire();
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+
+        // Verify custom extensions
+        assertThat(vastVideoConfiguration.getCustomCtaText()).isEqualTo("custom CTA text");
+        assertThat(vastVideoConfiguration.getCustomSkipText()).isEqualTo("skip");
+        assertThat(vastVideoConfiguration.getCustomCloseIconUrl()).isEqualTo("http://ton.twitter.com/exchange-media/images/v4/star_icon_3x.png");
+        assertThat(vastVideoConfiguration.getCustomForceOrientation()).isEqualTo(DeviceUtils.ForceOrientation.DEVICE_ORIENTATION);
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withExtensionsUnderInline_shouldContainTheCorrectCustomExtensionValues() throws Exception {
+        // Vast redirect response to XML with extensions under Inline element
+        mFakeHttpLayer.addPendingHttpResponse(200,
+                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubCtaText>custom CTA text</MoPubCtaText>" +
+                                "<MoPubSkipText>skip</MoPubSkipText>" +
+                                "<MoPubCloseIcon>http://ton.twitter.com/exchange-media/images/v4/star_icon_3x.png</MoPubCloseIcon>" +
+                                "<MoPubForceOrientation>device</MoPubForceOrientation>" +
+                            "</Extension>" +
+                        "</Extensions>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+
+        // Verify custom extensions
+        assertThat(vastVideoConfiguration.getCustomCtaText()).isEqualTo("custom CTA text");
+        assertThat(vastVideoConfiguration.getCustomSkipText()).isEqualTo("skip");
+        assertThat(vastVideoConfiguration.getCustomCloseIconUrl()).isEqualTo("http://ton.twitter.com/exchange-media/images/v4/star_icon_3x.png");
+        assertThat(vastVideoConfiguration.getCustomForceOrientation()).isEqualTo(DeviceUtils.ForceOrientation.DEVICE_ORIENTATION);
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withExtensionsUnderBothWrapperAndInline_shouldContainLastParsedCustomExtensionValues() throws Exception {
+        // Vast redirect response to XML with extensions under Inline element in TEST_NESTED_VAST_XML_STRING, will be parsed last
+        mFakeHttpLayer.addPendingHttpResponse(200,
+                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubCtaText>CTA 2</MoPubCtaText>" +
+                                "<MoPubSkipText>skip 2</MoPubSkipText>" +
+                                "<MoPubCloseIcon>http://ton.twitter.com/exchange-media/images/v4/star_icon_3x_2.png</MoPubCloseIcon>" +
+                                "<MoPubForceOrientation>landscape</MoPubForceOrientation>" +
+                            "</Extension>" +
+                        "</Extensions>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        // Also add extensions under Wrapper element in TEST_VAST_XML_STRING
+        subject.prepareVastVideoConfiguration(
+                TEST_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubCtaText>CTA 1</MoPubCtaText>" +
+                                "<MoPubSkipText>skip 1</MoPubSkipText>" +
+                                "<MoPubCloseIcon>http://ton.twitter.com/exchange-media/images/v4/star_icon_3x_1.png</MoPubCloseIcon>" +
+                                "<MoPubForceOrientation>device orientation</MoPubForceOrientation>" +
+                            "</Extension>" +
+                        "</Extensions>"),
+                vastManagerListener);
+
+        Robolectric.runBackgroundTasks();
+        Robolectric.runUiThreadTasks();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+
+        // Verify custom extension values are the ones last parsed in TEST_NESTED_VAST_XML_STRING
+        assertThat(vastVideoConfiguration.getCustomCtaText()).isEqualTo("CTA 2");
+        assertThat(vastVideoConfiguration.getCustomSkipText()).isEqualTo("skip 2");
+        assertThat(vastVideoConfiguration.getCustomCloseIconUrl()).isEqualTo("http://ton.twitter.com/exchange-media/images/v4/star_icon_3x_2.png");
+        assertThat(vastVideoConfiguration.getCustomForceOrientation()).isEqualTo(DeviceUtils.ForceOrientation.FORCE_LANDSCAPE);
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withCustomCtaTextAsSingleSpace_shouldReturnEmptyString() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200,
+                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubCtaText> </MoPubCtaText>" +     // single space, i.e. no text
+                            "</Extension>" +
+                        "</Extensions>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+        assertThat(vastVideoConfiguration.getCustomCtaText()).isEmpty();
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withCustomCtaTextLongerThan15Chars_shouldReturnNull() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200,
+                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubCtaText>1234567890123456</MoPubCtaText>" +     // 16 chars
+                            "</Extension>" +
+                        "</Extensions>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+        assertThat(vastVideoConfiguration.getCustomCtaText()).isNull();
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withCustomSkipTextLongerThan8Chars_shouldReturnNull() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200,
+                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubSkipText>123456789</MoPubSkipText>" +     // 9 chars
+                            "</Extension>" +
+                        "</Extensions>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+        assertThat(vastVideoConfiguration.getCustomSkipText()).isNull();
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withInvalidCustomForceOrientation_shouldReturnDefaultForceLandscapeOrientation() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200,
+                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubForceOrientation>abcd</MoPubForceOrientation>" +   // invalid value
+                            "</Extension>" +
+                        "</Extensions>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+        assertThat(vastVideoConfiguration.getCustomForceOrientation()).isEqualTo(DeviceUtils.ForceOrientation.FORCE_LANDSCAPE);
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withCustomForceOrientationInMixedCaseAndUntrimmed_shouldReturnCustomForceOrientation() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200,
+                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubForceOrientation> PortRAIT  </MoPubForceOrientation>" +
+                            "</Extension>" +
+                        "</Extensions>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+        assertThat(vastVideoConfiguration.getCustomForceOrientation()).isEqualTo(DeviceUtils.ForceOrientation.FORCE_PORTRAIT);
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withValidPercentSkipOffset_shouldReturnCorrectValue() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset='25%'>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+
+        assertThat(vastVideoConfiguration.getSkipOffset()).isEqualTo("25%");
+    }
+
+
+    @Test
+    public void prepareVastVideoConfiguration_withValidAbsoluteSkipOffset_shouldReturnCorrectValue() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset='  00:03:14 '>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+
+        assertThat(vastVideoConfiguration.getSkipOffset()).isEqualTo("00:03:14");
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withValidAbsoluteSkipOffsetWithExtraSpace_shouldReturnCorrectTrimmedValue() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset='  00:03:14.159 '>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+
+        assertThat(vastVideoConfiguration.getSkipOffset()).isEqualTo("00:03:14.159");
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withSkipOffsets_shouldReturnLastParsedValue() throws Exception {
+        // Vast redirect response with skipoffset in percent format
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset='25%'>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        // Also add a skipoffset in absolute format
+        subject.prepareVastVideoConfiguration(
+                TEST_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset='00:03:14'>"),
+                vastManagerListener);
+
+        Robolectric.runBackgroundTasks();
+        Robolectric.runUiThreadTasks();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+
+        // Verify that the last parsed skipoffset value is returned
+        assertThat(vastVideoConfiguration.getSkipOffset()).isEqualTo("25%");
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withEmptySkipOffset_shouldReturnNull() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset=' '>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+
+        assertThat(vastVideoConfiguration.getSkipOffset()).isNull();
     }
 
     @Test
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastVideoConfigurationTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastVideoConfigurationTest.java
new file mode 100644
index 00000000..6f78a9a0
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastVideoConfigurationTest.java
@@ -0,0 +1,53 @@
+package com.mopub.mobileads.util.vast;
+
+import com.mopub.mobileads.VastAbsoluteProgressTracker;
+import com.mopub.mobileads.VastFractionalProgressTracker;
+
+import org.junit.Test;
+
+import java.util.ArrayList;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+public class VastVideoConfigurationTest {
+
+    @Test
+    public void testAddFractionalTrackers_multipleTimes_shouldBeSorted() throws Exception {
+        ArrayList<VastFractionalProgressTracker> testSet1 = new ArrayList<VastFractionalProgressTracker>();
+        testSet1.add(new VastFractionalProgressTracker("test1a", 0.24f));
+        testSet1.add(new VastFractionalProgressTracker("test1b", 0.5f));
+        testSet1.add(new VastFractionalProgressTracker("test1c", 0.91f));
+
+        ArrayList<VastFractionalProgressTracker> testSet2 = new ArrayList<VastFractionalProgressTracker>();
+        testSet2.add(new VastFractionalProgressTracker("test2a", 0.14f));
+        testSet2.add(new VastFractionalProgressTracker("test2b", 0.6f));
+        testSet2.add(new VastFractionalProgressTracker("test2c", 0.71f));
+
+        VastVideoConfiguration subject = new VastVideoConfiguration();
+
+        subject.addFractionalTrackers(testSet1);
+        subject.addFractionalTrackers(testSet2);
+
+        assertThat(subject.getFractionalTrackers()).isSorted();
+    }
+
+    @Test
+    public void testAddAbsoluteTrackers_multipleTimes_shouldBesSorted() throws Exception {
+        ArrayList<VastAbsoluteProgressTracker> testSet1 = new ArrayList<VastAbsoluteProgressTracker>();
+        testSet1.add(new VastAbsoluteProgressTracker("test1a", 1000));
+        testSet1.add(new VastAbsoluteProgressTracker("test1b", 10000));
+        testSet1.add(new VastAbsoluteProgressTracker("test1c", 50000));
+
+        ArrayList<VastAbsoluteProgressTracker> testSet2 = new ArrayList<VastAbsoluteProgressTracker>();
+        testSet2.add(new VastAbsoluteProgressTracker("test2a", 1100));
+        testSet2.add(new VastAbsoluteProgressTracker("test2b", 9000));
+        testSet2.add(new VastAbsoluteProgressTracker("test2c", 62000));
+
+        VastVideoConfiguration subject = new VastVideoConfiguration();
+
+        subject.addAbsoluteTrackers(testSet1);
+        subject.addAbsoluteTrackers(testSet2);
+
+        assertThat(subject.getAbsoluteTrackers()).isSorted();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastXmlManagerAggregatorTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastXmlManagerAggregatorTest.java
index f7ddc3f2..bcdb76eb 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastXmlManagerAggregatorTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastXmlManagerAggregatorTest.java
@@ -65,7 +65,7 @@ public void processVast_shouldNotFollowRedirectsOnceTheLimitHasBeenReached() thr
         assertThat(vastXmlManagers.get(0).getMediaFileUrl()).isEqualTo("https://s3.amazonaws.com/mopub-vast/tapad-video1.mp4");
         assertThat(vastXmlManagers.get(0).getClickThroughUrl()).isEqualTo(null);
         assertThat(vastXmlManagers.get(0).getImpressionTrackers().size()).isEqualTo(4);
-        assertThat(vastXmlManagers.get(0).getVideoFirstQuartileTrackers().size()).isEqualTo(1);
+        assertThat(vastXmlManagers.get(0).getFractionalProgressTrackers().size()).isEqualTo(3);
     }
 
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastXmlManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastXmlManagerTest.java
index dd7bb02b..c71d444f 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastXmlManagerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastXmlManagerTest.java
@@ -1,6 +1,9 @@
 package com.mopub.mobileads.util.vast;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.DeviceUtils.ForceOrientation;
+import com.mopub.mobileads.VastAbsoluteProgressTracker;
+import com.mopub.mobileads.VastFractionalProgressTracker;
 
 import org.junit.Before;
 import org.junit.Test;
@@ -37,7 +40,7 @@
             "                    <VASTAdTagURI><![CDATA[ http://0.dsp.dev1.mopub.com/xml ]]></VASTAdTagURI>" +
             "                    <Creatives>" +
             "                        <Creative sequence=\"1\" AdID=\"\">" +
-            "                            <Linear>" +
+            "                            <Linear skipoffset=\"25%\">" +
             "                                <Duration>00:00:58</Duration>" +
             "                                <TrackingEvents>" +
             "                                    <Tracking event=\"start\">" +
@@ -45,6 +48,40 @@
             "                                        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
             "                                        ]]>" +
             "                                    </Tracking>" +
+            "                                    <Tracking event=\"progress\" offset=\"13%\">" +
+            "                                        <![CDATA[" +
+            "                                        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
+            "                                        ]]>" +
+            "                                    </Tracking>" +
+            "                                    <Tracking event=\"progress\" offset=\"01:01:10.300\">" +
+            "                                        <![CDATA[" +
+            "                                        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
+            "                                        ]]>" +
+            "                                    </Tracking>" +
+            // Invalid tracking due to ambiguous offset.
+            "                                    <Tracking event=\"progress\" offset=\"01:01\">" +
+            "                                        <![CDATA[" +
+            "                                        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
+            "                                        ]]>" +
+            "                                    </Tracking>" +
+            // Invalid tracking due to a too-high percentage offset.
+            "                                    <Tracking event=\"progress\" offset=\"113%\">" +
+            "                                        <![CDATA[" +
+            "                                        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
+            "                                        ]]>" +
+            "                                    </Tracking>" +
+            // Invalid tracking due to a negative percentage offset.
+            "                                    <Tracking event=\"progress\" offset=\"-113%\">" +
+            "                                        <![CDATA[" +
+            "                                        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
+            "                                        ]]>" +
+            "                                    </Tracking>" +
+            // Invalid tracking due to a non-number offset
+            "                                    <Tracking event=\"progress\" offset=\"ten seconds\">" +
+            "                                        <![CDATA[" +
+            "                                        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
+            "                                        ]]>" +
+            "                                    </Tracking>" +
             "                                    <Tracking event=\"midpoint\">" +
             "                                        <![CDATA[" +
             "                                        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=18;ecn1=1;etm1=0;" +
@@ -85,6 +122,26 @@
             "                                        http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.5;sz=1x1;ord=2922389?" +
             "                                        ]]>" +
             "                                    </Tracking>" +
+            "                                    <Tracking event=\"close\">" +
+            "                                        <![CDATA[" +
+            "                                        http://www.mopub.com/close?q=ignatius" +
+            "                                        ]]>" +
+            "                                    </Tracking>" +
+            "                                    <Tracking event=\"close\">" +
+            "                                        <![CDATA[" +
+            "                                        http://www.mopub.com/close?q=j3" +
+            "                                        ]]>" +
+            "                                    </Tracking>" +
+            "                                    <Tracking event=\"skip\">" +
+            "                                        <![CDATA[" +
+            "                                        http://www.mopub.com/skip?q=ignatius" +
+            "                                        ]]>" +
+            "                                    </Tracking>" +
+            "                                    <Tracking event=\"skip\">" +
+            "                                        <![CDATA[" +
+            "                                        http://www.mopub.com/skip?q=j3" +
+            "                                        ]]>" +
+            "                                    </Tracking>" +
             "                                    <Tracking event=\"mute\">" +
             "                                        <![CDATA[" +
             "                                        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=16;ecn1=1;etm1=0;" +
@@ -236,6 +293,12 @@
             "                                </DeliveryData>" +
             "                            </AdServingData>" +
             "                        </Extension>" +
+            "                        <Extension type=\"MoPub\">" +
+            "                           <MoPubCtaText>custom CTA text</MoPubCtaText>" +
+            "                           <MoPubSkipText>skip</MoPubSkipText>" +
+            "                           <MoPubCloseIcon>http://ton.twitter.com/exchange-media/images/v4/star_icon_3x.png</MoPubCloseIcon>" +
+            "                           <MoPubForceOrientation>device</MoPubForceOrientation>" +
+            "                        </Extension>" +
             "                    </Extensions>" +
             "                </InLine>" +
             "            </Ad>" +
@@ -298,66 +361,80 @@ public void getImpressionTrackers_shouldReturnTheCorrectValue() {
     }
 
     @Test
-    public void getVideoStartTrackers_shouldReturnTheCorrectValue() {
-        List<String> trackers = mXmlManager.getVideoStartTrackers();
+    public void getAbsoluteTrackers_shouldReturnCorrectValues() {
+        List<VastAbsoluteProgressTracker> trackers = mXmlManager.getAbsoluteProgressTrackers();
 
-        assertThat(trackers.size()).isEqualTo(1);
+        assertThat(trackers.size()).isEqualTo(2);
 
-        String tracker1 = trackers.get(0);
+        VastAbsoluteProgressTracker tracker0 = trackers.get(0);
+        assertThat(tracker0.getTrackingMilliseconds()).isEqualTo(2000);
+        assertThat(tracker0.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;");
 
-        assertThat(tracker1).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;");
+        VastAbsoluteProgressTracker tracker1 = trackers.get(1);
+        assertThat(tracker1.getTrackingMilliseconds()).isEqualTo(3670300);
+        assertThat(tracker1.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;");
     }
 
     @Test
-    public void getVideoFirstQuartileTrackers_shouldReturnTheCorrectValue() {
-        List<String> trackers = mXmlManager.getVideoFirstQuartileTrackers();
+    public void getFractionalTrackers_shouldReturnCorrectValues() {
+        List<VastFractionalProgressTracker> trackers = mXmlManager.getFractionalProgressTrackers();
 
-        assertThat(trackers.size()).isEqualTo(2);
+        assertThat(trackers.size()).isEqualTo(7);
 
-        String tracker1 = trackers.get(0);
-        String tracker2 = trackers.get(1);
+        VastFractionalProgressTracker tracker0 = trackers.get(0);
+        assertThat(tracker0.trackingFraction()).isEqualTo(0.13f);
+        assertThat(tracker0.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;");
 
-        assertThat(tracker1).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=26;ecn1=1;etm1=0;");
-        assertThat(tracker2).isEqualTo("http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.2;sz=1x1;ord=2922389?");
-    }
+        VastFractionalProgressTracker tracker1 = trackers.get(1);
+        assertThat(tracker1.trackingFraction()).isEqualTo(0.25f);
+        assertThat(tracker1.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=26;ecn1=1;etm1=0;");
 
-    @Test
-    public void getVideoMidpointTrackers_shouldReturnTheCorrectValue() {
-        List<String> trackers = mXmlManager.getVideoMidpointTrackers();
+        VastFractionalProgressTracker tracker2 = trackers.get(2);
+        assertThat(tracker2.trackingFraction()).isEqualTo(0.25f);
+        assertThat(tracker2.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.2;sz=1x1;ord=2922389?");
 
-        assertThat(trackers.size()).isEqualTo(2);
+        VastFractionalProgressTracker tracker3 = trackers.get(3);
+        assertThat(tracker3.trackingFraction()).isEqualTo(0.5f);
+        assertThat(tracker3.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=18;ecn1=1;etm1=0;");
 
-        String tracker1 = trackers.get(0);
-        String tracker2 = trackers.get(1);
+        VastFractionalProgressTracker tracker4 = trackers.get(4);
+        assertThat(tracker4.trackingFraction()).isEqualTo(0.5f);
+        assertThat(tracker4.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.3;sz=1x1;ord=2922389?");
+
+        VastFractionalProgressTracker tracker5 = trackers.get(5);
+        assertThat(tracker5.trackingFraction()).isEqualTo(0.75f);
+        assertThat(tracker5.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=27;ecn1=1;etm1=0;");
 
-        assertThat(tracker1).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=18;ecn1=1;etm1=0;");
-        assertThat(tracker2).isEqualTo("http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.3;sz=1x1;ord=2922389?");
+        VastFractionalProgressTracker tracker6 = trackers.get(6);
+        assertThat(tracker6.trackingFraction()).isEqualTo(0.75f);
+        assertThat(tracker6.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.4;sz=1x1;ord=2922389?");
     }
 
     @Test
-    public void getVideoThirdQuartileTrackers_shouldReturnTheCorrectValue() {
-        List<String> trackers = mXmlManager.getVideoThirdQuartileTrackers();
+    public void getVideoCompleteTrackers_shouldReturnTheCorrectValue() {
+        List<String> trackers = mXmlManager.getVideoCompleteTrackers();
 
         assertThat(trackers.size()).isEqualTo(2);
 
         String tracker1 = trackers.get(0);
         String tracker2 = trackers.get(1);
 
-        assertThat(tracker1).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=27;ecn1=1;etm1=0;");
-        assertThat(tracker2).isEqualTo("http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.4;sz=1x1;ord=2922389?");
+        assertThat(tracker1).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=13;ecn1=1;etm1=0;");
+        assertThat(tracker2).isEqualTo("http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.5;sz=1x1;ord=2922389?");
     }
 
     @Test
-    public void getVideoCompleteTrackers_shouldReturnTheCorrectValue() {
-        List<String> trackers = mXmlManager.getVideoCompleteTrackers();
+    public void getVideoCloseTrackers_shouldReturnTheCorrectValue() {
+        List<String> trackers = mXmlManager.getVideoCloseTrackers();
 
-        assertThat(trackers.size()).isEqualTo(2);
+        assertThat(trackers).containsExactly("http://www.mopub.com/close?q=ignatius", "http://www.mopub.com/close?q=j3");
+    }
 
-        String tracker1 = trackers.get(0);
-        String tracker2 = trackers.get(1);
+    @Test
+    public void getVideoSkipTrackers_shouldReturnTheCorrectValue() {
+        List<String> trackers = mXmlManager.getVideoSkipTrackers();
 
-        assertThat(tracker1).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=13;ecn1=1;etm1=0;");
-        assertThat(tracker2).isEqualTo("http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.5;sz=1x1;ord=2922389?");
+        assertThat(trackers).containsExactly("http://www.mopub.com/skip?q=ignatius", "http://www.mopub.com/skip?q=j3");
     }
 
     @Test
@@ -444,6 +521,41 @@ public void getMediaFileUrl_shouldReturnTheCorrectValue() {
         assertThat(url).isEqualTo("http://s3.amazonaws.com/uploads.hipchat.com/10627/429509/t8hqeqf98nvtir7/big_buck_bunny.mp4");
     }
 
+    @Test
+    public void getCustomCtaText_shouldReturnTheCorrectValue() {
+        String customCtaText = mXmlManager.getCustomCtaText();
+
+        assertThat(customCtaText).isEqualTo("custom CTA text");
+    }
+
+    @Test
+    public void getCustomSkipText_shouldReturnTheCorrectValue() {
+        String customSkipText = mXmlManager.getCustomSkipText();
+
+        assertThat(customSkipText).isEqualTo("skip");
+    }
+
+    @Test
+    public void getCustomCloseIconUrl_shouldReturnTheCorrectValue() {
+        String customCloseIconUrl = mXmlManager.getCustomCloseIconUrl();
+
+        assertThat(customCloseIconUrl).isEqualTo("http://ton.twitter.com/exchange-media/images/v4/star_icon_3x.png");
+    }
+
+    @Test
+    public void getCustomForceOrientation_shouldReturnTheCorrectValue() {
+        ForceOrientation customForceOrientation = mXmlManager.getCustomForceOrientation();
+
+        assertThat(customForceOrientation).isEqualTo(ForceOrientation.DEVICE_ORIENTATION);
+    }
+
+    @Test
+    public void getSkipOffset_shouldReturnTheCorrectValue() {
+        String skipOffset = mXmlManager.getSkipOffset();
+
+        assertThat(skipOffset).isEqualTo("25%");
+    }
+
     @Test
     public void getVastAdTagURI_shouldReturnTheCorrectValue() {
         String url = mXmlManager.getVastAdTagURI();
@@ -487,11 +599,11 @@ public void parsingVastWithMalformedNodes_shouldNotCauseProblems() {
         }
 
         assertThat(badManager.getMediaFileUrl()).isEqualTo(null);
-        assertThat(badManager.getVideoMidpointTrackers().size()).isEqualTo(0);
+        assertThat(badManager.getFractionalProgressTrackers().size()).isEqualTo(0);
         assertThat(badManager.getImpressionTrackers().size()).isEqualTo(0);
 
-        List<String> startTrackers = badManager.getVideoStartTrackers();
+        List<VastAbsoluteProgressTracker> startTrackers = badManager.getAbsoluteProgressTrackers();
         assertThat(startTrackers.size()).isEqualTo(1);
-        assertThat(startTrackers.get(0)).isEqualTo("good");
+        assertThat(startTrackers.get(0).getTrackingUrl()).isEqualTo("good");
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/XmlUtilsTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/XmlUtilsTest.java
new file mode 100644
index 00000000..af68ea88
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/XmlUtilsTest.java
@@ -0,0 +1,238 @@
+package com.mopub.mobileads.util.vast;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.w3c.dom.Document;
+import org.w3c.dom.Node;
+import org.xml.sax.InputSource;
+
+import java.io.StringReader;
+import java.text.DateFormat;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+import java.util.Locale;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+public class XmlUtilsTest {
+
+    // From Microsoft's sample xml documents page: https://msdn.microsoft.com/en-us/library/bb387026.aspx
+    private String testXml = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n" +
+            "<aw:PurchaseOrders xmlns:aw=\"http://www.adventure-works.com\">\n" +
+            "  <aw:PurchaseOrder aw:PurchaseOrderNumber=\"99503\" aw:OrderDate=\"1999-10-20\">\n" +
+            "    <aw:Address aw:Type=\"Shipping\">\n" +
+            "      <aw:Name>Ellen Adams</aw:Name>\n" +
+            "      <aw:Street>123 Maple Street</aw:Street>\n" +
+            "      <aw:City>Mill Valley</aw:City>\n" +
+            "      <aw:State>CA</aw:State>\n" +
+            "      <aw:Zip>10999</aw:Zip>\n" +
+            "      <aw:Country>USA</aw:Country>\n" +
+            "    </aw:Address>\n" +
+            "    <aw:Address aw:Type=\"Billing\">\n" +
+            "      <aw:Name>Tai Yee</aw:Name>\n" +
+            "      <aw:Street>8 Oak Avenue</aw:Street>\n" +
+            "      <aw:City>Old Town</aw:City>\n" +
+            "      <aw:State>PA</aw:State>\n" +
+            "      <aw:Zip>95819</aw:Zip>\n" +
+            "      <aw:Country>USA</aw:Country>\n" +
+            "    </aw:Address>\n" +
+            "    <aw:DeliveryNotes>Please leave packages in shed by driveway.</aw:DeliveryNotes>\n" +
+            "    <aw:Items>\n" +
+            "      <aw:Item aw:PartNumber=\"898-AZ\">\n" +
+            "        <aw:ProductName>Lawnmower</aw:ProductName>\n" +
+            "        <aw:Quantity>1</aw:Quantity>\n" +
+            "        <aw:USPrice>148.95</aw:USPrice>\n" +
+            "        <aw:Comment>Confirm this is electric</aw:Comment>\n" +
+            "      </aw:Item>\n" +
+            "      <aw:Item aw:PartNumber=\"926-AA\">\n" +
+            "        <aw:ProductName>Baby Monitor</aw:ProductName>\n" +
+            "        <aw:Quantity>2</aw:Quantity>\n" +
+            "        <aw:USPrice>39.98</aw:USPrice>\n" +
+            "        <aw:ShipDate>1999-05-21</aw:ShipDate>\n" +
+            "      </aw:Item>\n" +
+            "    </aw:Items>\n" +
+            "  </aw:PurchaseOrder>\n" +
+            "  <aw:PurchaseOrder aw:PurchaseOrderNumber=\"99505\" aw:OrderDate=\"1999-10-22\">\n" +
+            "    <aw:Address aw:Type=\"Shipping\">\n" +
+            "      <aw:Name>Cristian Osorio</aw:Name>\n" +
+            "      <aw:Street>456 Main Street</aw:Street>\n" +
+            "      <aw:City>Buffalo</aw:City>\n" +
+            "      <aw:State>NY</aw:State>\n" +
+            "      <aw:Zip>98112</aw:Zip>\n" +
+            "      <aw:Country>USA</aw:Country>\n" +
+            "    </aw:Address>\n" +
+            "    <aw:Address aw:Type=\"Billing\">\n" +
+            "      <aw:Name>Cristian Osorio</aw:Name>\n" +
+            "      <aw:Street>456 Main Street</aw:Street>\n" +
+            "      <aw:City>Buffalo</aw:City>\n" +
+            "      <aw:State>NY</aw:State>\n" +
+            "      <aw:Zip>98112</aw:Zip>\n" +
+            "      <aw:Country>USA</aw:Country>\n" +
+            "    </aw:Address>\n" +
+            "    <aw:DeliveryNotes>Please notify me before shipping.</aw:DeliveryNotes>\n" +
+            "    <aw:Items>\n" +
+            "      <aw:Item aw:PartNumber=\"456-NM\">\n" +
+            "        <aw:ProductName>Power Supply</aw:ProductName>\n" +
+            "        <aw:Quantity>1</aw:Quantity>\n" +
+            "        <aw:USPrice>45.99</aw:USPrice>\n" +
+            "      </aw:Item>\n" +
+            "    </aw:Items>\n" +
+            "  </aw:PurchaseOrder>\n" +
+            "  <aw:PurchaseOrder aw:PurchaseOrderNumber=\"99504\" aw:OrderDate=\"1999-10-22\">\n" +
+            "    <aw:Address aw:Type=\"Shipping\">\n" +
+            "      <aw:Name>Jessica Arnold</aw:Name>\n" +
+            "      <aw:Street>4055 Madison Ave</aw:Street>\n" +
+            "      <aw:City>Seattle</aw:City>\n" +
+            "      <aw:State>WA</aw:State>\n" +
+            "      <aw:Zip>98112</aw:Zip>\n" +
+            "      <aw:Country>USA</aw:Country>\n" +
+            "    </aw:Address>\n" +
+            "    <aw:Address aw:Type=\"Billing\">\n" +
+            "      <aw:Name>Jessica Arnold</aw:Name>\n" +
+            "      <aw:Street>4055 Madison Ave</aw:Street>\n" +
+            "      <aw:City>Buffalo</aw:City>\n" +
+            "      <aw:State>NY</aw:State>\n" +
+            "      <aw:Zip>98112</aw:Zip>\n" +
+            "      <aw:Country>USA</aw:Country>\n" +
+            "    </aw:Address>\n" +
+            "    <aw:Items>\n" +
+            "      <aw:Item aw:PartNumber=\"898-AZ\">\n" +
+            "        <aw:ProductName>Computer Keyboard</aw:ProductName>\n" +
+            "        <aw:Quantity>1</aw:Quantity>\n" +
+            "        <aw:USPrice>29.99</aw:USPrice>\n" +
+            "        <aw:Comment>this thing breaks all the time</aw:Comment>\n" +
+            "      </aw:Item>\n" +
+            "      <aw:Item aw:PartNumber=\"898-AM\">\n" +
+            "        <aw:ProductName>Wireless Mouse</aw:ProductName>\n" +
+            "        <aw:Quantity>1</aw:Quantity>\n" +
+            "        <aw:USPrice>14.99</aw:USPrice>\n" +
+            "      </aw:Item>\n" +
+            "    </aw:Items>\n" +
+            "  </aw:PurchaseOrder>\n" +
+            "</aw:PurchaseOrders>";
+    private Document testDoc;
+    private Node purchaseOrderNode;
+
+
+    @Before
+    public void setUp() throws Exception {
+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
+        documentBuilderFactory.setCoalescing(true);
+        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
+        testDoc = documentBuilder.parse(new InputSource(new StringReader(testXml)));
+        purchaseOrderNode = testDoc.getFirstChild();
+    }
+
+    @Test
+    public void getFirstMatchingNode_shouldReturnValue() {
+        Node resultNode = XmlUtils.getFirstMatchingChildNode(purchaseOrderNode, "aw:PurchaseOrder");
+        assertThat(resultNode).isNotNull();
+    }
+
+    @Test
+    public void getFirstMatchingChildNode_shouldFindNode() throws Exception {
+        ArrayList<String> testList = new ArrayList<String>();
+        testList.add("1999-10-22");
+        Node resultNode = XmlUtils.getFirstMatchingChildNode(purchaseOrderNode, "aw:PurchaseOrder", "aw:OrderDate", testList);
+        assertThat(resultNode).isNotNull();
+        assertThat(resultNode.getNodeName()).isEqualTo("aw:PurchaseOrder");
+        assertThat(resultNode.getAttributes().getNamedItem("aw:OrderDate").getNodeValue()).isEqualTo("1999-10-22");
+    }
+
+    @Test
+    public void getFirstMatchingChildNode_withUnmatchedAttribute_shouldNotFindNode() throws Exception {
+        ArrayList<String> testList = new ArrayList<String>();
+        testList.add("1999-10-");
+        Node resultNode = XmlUtils.getFirstMatchingChildNode(purchaseOrderNode, "aw:PurchaseOrder", "aw:OrderDate", testList);
+        assertThat(resultNode).isNull();
+    }
+
+    @Test
+    public void getMatchingChildNodes_withNullAttributeValues_shouldReturnMultiple() throws Exception {
+        List<Node> results = XmlUtils.getMatchingChildNodes(purchaseOrderNode, "aw:PurchaseOrder", "aw:OrderDate", null);
+        assertThat(results.size()).isEqualTo(3);
+    }
+
+    @Test
+    public void getMatchingChildNodes_withEmptyAttributeValues_shouldReturnNone() {
+        List<Node> results = XmlUtils.getMatchingChildNodes(purchaseOrderNode, "aw:PurchaseOrder", "aw:OrderDate", new ArrayList<String>());
+        assertThat(results).isEmpty();
+    }
+
+    @Test
+    public void testGetListFromDocument() throws Exception {
+        // Get all the "aw:PurchaseOrder" nodes. If any of them have an "aw:OrderDate" attribute, extract a Date.
+        List<Date> orderDates = XmlUtils.getListFromDocument(testDoc, "aw:PurchaseOrder", "aw:OrderDate", null, new XmlUtils.NodeProcessor<Date>() {
+            DateFormat formatter = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
+
+            @Override
+            public Date process(final Node node) {
+                try {
+                    return formatter.parse(node.getAttributes().getNamedItem("aw:OrderDate").getNodeValue());
+                } catch (ParseException e) {
+                    return null;
+                }
+            }
+        });
+
+        assertThat(orderDates.size()).isEqualTo(3);
+        assertThat(orderDates.get(0).getYear()).isEqualTo(99);
+        assertThat(orderDates.get(0).getMonth()).isEqualTo(9);
+        assertThat(orderDates.get(0).getDate()).isEqualTo(20);
+
+        assertThat(orderDates.get(1).getYear()).isEqualTo(99);
+        assertThat(orderDates.get(1).getMonth()).isEqualTo(9);
+        assertThat(orderDates.get(1).getDate()).isEqualTo(22);
+
+        assertThat(orderDates.get(2).getYear()).isEqualTo(99);
+        assertThat(orderDates.get(2).getMonth()).isEqualTo(9);
+        assertThat(orderDates.get(2).getDate()).isEqualTo(22);
+    }
+
+    @Test
+    public void testGetFirstMatchFromDocument() throws Exception {
+        // Get the first "aw:PurchaseOrder" nodes. If it has an "aw:OrderDate" attribute, extract a Date.
+        Date orderDate = XmlUtils.getFirstMatchFromDocument(testDoc, "aw:PurchaseOrder", "aw:OrderDate", null, new XmlUtils.NodeProcessor<Date>() {
+            DateFormat formatter = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
+
+            @Override
+            public Date process(final Node node) {
+                try {
+                    return formatter.parse(node.getAttributes().getNamedItem("aw:OrderDate").getNodeValue());
+                } catch (ParseException e) {
+                    return null;
+                }
+            }
+        });
+
+        assertThat(orderDate).isNotNull();
+        assertThat(orderDate.getYear()).isEqualTo(99);
+        assertThat(orderDate.getMonth()).isEqualTo(9);
+        assertThat(orderDate.getDate()).isEqualTo(20);
+    }
+
+    @Test
+    public void testGetStringDataAsList_shouldFindDeepNested() throws Exception {
+        final List<String> strings = XmlUtils.getStringDataAsList(testDoc, "aw:Comment", null, null);
+        assertThat(strings.size()).isEqualTo(2);
+        assertThat(strings.get(0)).isEqualTo("Confirm this is electric");
+        assertThat(strings.get(1)).isEqualTo("this thing breaks all the time");
+    }
+
+    @Test
+    public void testGetFirstMatchingStringData_shouldFindFirstMatch() throws Exception {
+        final String firstMatch = XmlUtils.getFirstMatchingStringData(testDoc, "aw:Comment", null, null);
+        assertThat(firstMatch).isNotNull();
+        assertThat(firstMatch).isEqualTo("Confirm this is electric");
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mraid/MraidControllerTest.java b/mopub-sdk/src/test/java/com/mopub/mraid/MraidControllerTest.java
index 5ae97df5..bc6fce11 100644
--- a/mopub-sdk/src/test/java/com/mopub/mraid/MraidControllerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mraid/MraidControllerTest.java
@@ -13,8 +13,8 @@
 
 import com.mopub.common.AdReport;
 import com.mopub.common.CloseableLayout.ClosePosition;
-import com.mopub.common.MoPubBrowser;
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.Utils;
 import com.mopub.mobileads.BaseVideoPlayerActivityTest;
 import com.mopub.mobileads.MraidVideoPlayerActivity;
 import com.mopub.mraid.MraidBridge.MraidBridgeListener;
@@ -284,7 +284,8 @@ public void handleResize_allowOffscreen_largeOffset_closeButtonBottomLeft_should
         subject.handlePageLoad();
         subject.setRootViewSize(100, 1000);
 
-        subject.handleResize(100, 100, 25, 25, ClosePosition.BOTTOM_LEFT, /* allowOffscreen */ true);
+        subject.handleResize(100, 100, 25, 25, ClosePosition.BOTTOM_LEFT, /* allowOffscreen */
+                true);
         assertThat(subject.getViewState()).isEqualTo(ViewState.RESIZED);
     }
 
@@ -292,14 +293,16 @@ public void handleResize_allowOffscreen_largeOffset_closeButtonBottomLeft_should
     public void handleResize_heightSmallerThan50Dips_shouldFail() throws MraidCommandException {
         subject.handlePageLoad();
         subject.setRootViewSize(100, 100);
-        subject.handleResize(100, 49, 25, 25, ClosePosition.BOTTOM_LEFT, /* allowOffscreen */ false);
+        subject.handleResize(100, 49, 25, 25, ClosePosition.BOTTOM_LEFT, /* allowOffscreen */
+                false);
     }
 
     @Test(expected = MraidCommandException.class)
     public void handleResize_widthSmallerThan50Dips_shouldFail() throws MraidCommandException {
         subject.handlePageLoad();
         subject.setRootViewSize(100, 100);
-        subject.handleResize(49, 100, 25, 25, ClosePosition.BOTTOM_LEFT, /* allowOffscreen */ false);
+        subject.handleResize(49, 100, 25, 25, ClosePosition.BOTTOM_LEFT, /* allowOffscreen */
+                false);
     }
 
     @Test
@@ -503,8 +506,9 @@ public void handleOpen_withApplicationUrl_shouldStartNewIntent() {
 
         Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(startedIntent).isNotNull();
-        // Since we are using an Activity context, we do not need FLAG_ACTIVITY_NEW_TASK
-        assertThat(startedIntent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isEqualTo(0);
+        // Since we are not using an Activity context, we should have FLAG_ACTIVITY_NEW_TASK
+        assertThat(Utils.bitMaskContainsFlag(startedIntent.getFlags(),
+                Intent.FLAG_ACTIVITY_NEW_TASK)).isTrue();
         assertThat(startedIntent.getComponent()).isNull();
 
         verify(mockMraidListener).onOpen();
@@ -518,8 +522,9 @@ public void handleOpen_withHttpApplicationUrl_shouldStartMoPubBrowser() {
 
         Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(startedIntent).isNotNull();
-        // Since we are using an Activity context, we do not need FLAG_ACTIVITY_NEW_TASK
-        assertThat(startedIntent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isEqualTo(0);
+        // Since we are not using an Activity context, we should have FLAG_ACTIVITY_NEW_TASK
+        assertThat(Utils.bitMaskContainsFlag(startedIntent.getFlags(),
+                Intent.FLAG_ACTIVITY_NEW_TASK)).isTrue();
         assertThat(startedIntent.getComponent().getClassName())
                 .isEqualTo("com.mopub.common.MoPubBrowser");
 
@@ -534,17 +539,20 @@ public void handleOpen_withApplicationUrlThatCantBeHandled_shouldDefaultToMoPubB
         subject.handleOpen(applicationUrl);
 
         Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedIntent).isNotNull();
-        // Since we are using an Activity context, we do not need FLAG_ACTIVITY_NEW_TASK
-        assertThat(startedIntent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isEqualTo(0);
-        assertThat(startedIntent.getComponent().getClassName())
-                .isEqualTo("com.mopub.common.MoPubBrowser");
-        assertThat(startedIntent.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY))
-                .isEqualTo(applicationUrl);
+        assertThat(startedIntent).isNull();
 
         verify(mockMraidListener).onOpen();
     }
 
+    @Test
+    public void handleOpen_withAboutBlankUrl_shouldFailSilently() {
+        final String url = "about:blank";
+
+        subject.handleOpen(url);
+
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+    }
+
     @Test
     public void orientationBroadcastReceiver_whenUnregistered_shouldIgnoreOnReceive() {
         Intent intent = mock(Intent.class);
@@ -576,7 +584,7 @@ public void handleSetOrientationProperties_withForcedOrientation_shouldUpdatePro
         assertThat(subject.getAllowOrientationChange()).isFalse();
         assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.LANDSCAPE);
     }
-    
+
     @Test
     public void handleSetOrientationProperties_withOrientationNone_withApplicationContext_shouldUpdateProperties() throws MraidCommandException, PackageManager.NameNotFoundException {
         setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
@@ -591,7 +599,7 @@ public void handleSetOrientationProperties_withOrientationNone_withApplicationCo
         assertThat(subject.getAllowOrientationChange()).isFalse();
         assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.NONE);
     }
-    
+
     @Test
     public void handleSetOrientationProperties_withForcedOrientation_withApplicationContext_shouldThrowMraidCommandExceptionAndNotUpdateProperties() throws PackageManager.NameNotFoundException {
         setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
@@ -674,7 +682,8 @@ public void handleSetOrientationProperties_withForcedOrientation_withMissingConf
     @Config(reportSdk = Build.VERSION_CODES.HONEYCOMB_MR1)
     @Test
     public void handleSetOrientationProperties_beforeHoneycombMr2_withMissingConfigChangeScreenSize_shouldUpdateProperties() throws Exception {
-        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED, ActivityInfo.CONFIG_ORIENTATION);
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION);
 
         subject.handleSetOrientationProperties(false, MraidOrientation.LANDSCAPE);
 
@@ -685,7 +694,8 @@ public void handleSetOrientationProperties_beforeHoneycombMr2_withMissingConfigC
     @Config(reportSdk = Build.VERSION_CODES.HONEYCOMB_MR2)
     @Test
     public void handleSetOrientationProperties_atLeastHoneycombMr2_withMissingConfigChangeScreenSize_shouldThrowMraidCommandException() throws Exception {
-        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED, ActivityInfo.CONFIG_ORIENTATION);
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION);
 
         try {
             subject.handleSetOrientationProperties(false, MraidOrientation.LANDSCAPE);
@@ -830,7 +840,7 @@ public void lockOrientation_subsequentTimes_shouldNotModifyOriginalActivityOrien
         assertThat(subject.getOriginalActivityOrientation())
                 .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
     }
-    
+
     @Test
     public void applyOrientation_withLockedOrientation_withForceOrientationNone_withAllowOrientationChangeTrue_shouldResetOrientation() throws MraidCommandException, PackageManager.NameNotFoundException {
         setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
diff --git a/mopub-sdk/src/test/java/com/mopub/mraid/MraidVideoViewControllerTest.java b/mopub-sdk/src/test/java/com/mopub/mraid/MraidVideoViewControllerTest.java
index fb0620b4..a7385242 100644
--- a/mopub-sdk/src/test/java/com/mopub/mraid/MraidVideoViewControllerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mraid/MraidVideoViewControllerTest.java
@@ -14,7 +14,6 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
-import org.robolectric.shadows.ShadowImageButton;
 import org.robolectric.shadows.ShadowLocalBroadcastManager;
 import org.robolectric.shadows.ShadowVideoView;
 import org.robolectric.tester.org.apache.http.RequestMatcher;
@@ -41,7 +40,7 @@
 
     @Before
     public void setUp() throws Exception {
-        context = new Activity();
+        context = Robolectric.buildActivity(Activity.class).create().get();
         bundle = new Bundle();
         baseVideoViewControllerListener = mock(BaseVideoViewControllerListener.class);
 
@@ -89,7 +88,7 @@ public void onCreate_shouldCreateAndHideCloseButton() throws Exception {
         ImageButton closeButton = getCloseButton();
 
         assertThat(closeButton).isNotNull();
-        assertThat(getShadowImageButton(closeButton).getOnClickListener()).isNotNull();
+        assertThat(shadowOf(closeButton).getOnClickListener()).isNotNull();
         assertThat(closeButton.getVisibility()).isEqualTo(GONE);
     }
 
@@ -105,9 +104,7 @@ public void closeButton_onClick_shouldCallBaseVideoControllerListenerOnFinish()
         initializeSubject();
         subject.onCreate();
 
-        ImageButton closeButton = getCloseButton();
-
-        getShadowImageButton(closeButton).getOnClickListener().onClick(null);
+        getCloseButton().performClick();
         verify(baseVideoViewControllerListener).onFinish();
     }
 
@@ -166,8 +163,4 @@ private ShadowVideoView getShadowVideoView() {
     ImageButton getCloseButton() {
         return (ImageButton) subject.getLayout().getChildAt(1);
     }
-
-    private ShadowImageButton getShadowImageButton(ImageButton imageButton) {
-        return (ShadowImageButton) shadowOf(imageButton);
-    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/AdapterHelperTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/AdapterHelperTest.java
index c8199d78..a2f85dbd 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/AdapterHelperTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/AdapterHelperTest.java
@@ -8,6 +8,7 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
@@ -22,7 +23,7 @@
 
     @Before
     public void setUp() {
-        context = new Activity();
+        context = Robolectric.buildActivity(Activity.class).create().get();
         start = 1;
         interval = 2;
         subject = new AdapterHelper(context, start, interval);
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/ClickDestinationResolutionListenerTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/ClickDestinationResolutionListenerTest.java
index 42b94285..2cd79b4c 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/ClickDestinationResolutionListenerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/ClickDestinationResolutionListenerTest.java
@@ -34,6 +34,7 @@
     public void setUp() throws Exception {
         context = spy(Robolectric.buildActivity(Activity.class).create().get());
         when(context.getApplicationContext()).thenReturn(context);
+        when(context.getPackageName()).thenReturn("testPackageName");
         mockIterator = mock(Iterator.class);
         mockSpinningProgressView = mock(SpinningProgressView.class);
 
@@ -87,7 +88,7 @@ public void onSuccess_withDeepLinkThatIsUnresolvable_shouldNotStartNewIntent_sho
 
     @Test
     public void onSuccess_withAppStoreUrl_shouldStartAppStoreIntent_shouldRemoveSpinningProgressView() {
-        String appStoreUrl = "play.google.com";
+        final String appStoreUrl = "play.google.com/";
         Robolectric.packageManager.addResolveInfoForIntent(new Intent(Intent.ACTION_VIEW,
                 Uri.parse(appStoreUrl)), new ResolveInfo());
 
@@ -95,7 +96,7 @@ public void onSuccess_withAppStoreUrl_shouldStartAppStoreIntent_shouldRemoveSpin
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
-        assertThat(intent.getDataString()).isEqualTo("play.google.com");
+        assertThat(intent.getDataString()).isEqualTo(appStoreUrl);
         verify(mockSpinningProgressView).removeFromRoot();
     }
 
@@ -110,7 +111,7 @@ public void onSuccess_withHttpUrl_showOpenInMoPubBrowser_shouldRemoveSpinningPro
 
         Intent intent = intentCaptor.getValue();
 
-        assertThat(intent.getComponent().getPackageName()).isEqualTo("com.mopub.mobileads");
+        assertThat(intent.getComponent().getPackageName()).isEqualTo("testPackageName");
         assertThat(intent.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
         assertThat(intent.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(httpUrl);
         verify(mockSpinningProgressView).removeFromRoot();
@@ -127,9 +128,19 @@ public void onSuccess_withHttpsUrl_showOpenInMoPubBrowser_shouldRemoveSpinningPr
 
         Intent intent = intentCaptor.getValue();
 
-        assertThat(intent.getComponent().getPackageName()).isEqualTo("com.mopub.mobileads");
+        assertThat(intent.getComponent().getPackageName()).isEqualTo("testPackageName");
         assertThat(intent.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
         assertThat(intent.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(httpsUrl);
         verify(mockSpinningProgressView).removeFromRoot();
     }
+
+    @Test
+    public void onSuccess_withAboutBlankUrl_shouldFailSilently_shouldRemoveSpinningProgressView() {
+        String url = "about:blank";
+
+        subject.onSuccess(url);
+
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+        verify(mockSpinningProgressView).removeFromRoot();
+    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubAdAdapterTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubAdAdapterTest.java
index 34fc4be5..a81aed19 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubAdAdapterTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubAdAdapterTest.java
@@ -21,7 +21,6 @@
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
-import org.robolectric.annotation.Config;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
@@ -33,7 +32,6 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-@Config(manifest=Config.NONE)
 @RunWith(SdkTestRunner.class)
 public class MoPubAdAdapterTest {
     private static final int AD_POSITION = 1;
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubClientPositioningTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubClientPositioningTest.java
index cce90d4e..1f117225 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubClientPositioningTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubClientPositioningTest.java
@@ -1,19 +1,17 @@
 package com.mopub.nativeads;
 
 import com.mopub.common.Preconditions.NoThrow;
-import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
 
 import org.fest.util.Lists;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.Config;
 
 import static com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning.NO_REPEAT;
 import static org.fest.assertions.api.Assertions.assertThat;
 
-@Config(manifest=Config.NONE)
 @RunWith(SdkTestRunner.class)
 public class MoPubClientPositioningTest {
 
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubForwardingNativeAdTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubForwardingNativeAdTest.java
index b868229a..668842d0 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubForwardingNativeAdTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubForwardingNativeAdTest.java
@@ -7,8 +7,8 @@
 import com.mopub.nativeads.test.support.MoPubShadowBitmap;
 import com.mopub.nativeads.test.support.MoPubShadowDisplay;
 import com.mopub.network.MaxWidthImageLoader;
+import com.mopub.network.MoPubRequestQueue;
 import com.mopub.network.Networking;
-import com.mopub.volley.RequestQueue;
 import com.mopub.volley.VolleyError;
 import com.mopub.volley.toolbox.ImageLoader;
 
@@ -53,7 +53,7 @@
     @Mock
     private CustomEventNative.CustomEventNativeListener mockCustomEventNativeListener;
     @Mock
-    private RequestQueue mockRequestQueue;
+    private MoPubRequestQueue mockRequestQueue;
     @Mock
     private MaxWidthImageLoader mockImageLoader;
     @Mock
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeAdRendererTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeAdRendererTest.java
index ff855e7e..17f7dc4c 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeAdRendererTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeAdRendererTest.java
@@ -16,6 +16,7 @@
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
@@ -23,11 +24,9 @@
 @RunWith(SdkTestRunner.class)
 public class MoPubNativeAdRendererTest {
     private MoPubNativeAdRenderer subject;
-    private Activity context;
     private RelativeLayout relativeLayout;
     private ViewGroup viewGroup;
     private NativeResponse nativeResponse;
-    private BaseForwardingNativeAd mNativeAd;
     private ViewBinder viewBinder;
     private TextView titleView;
     private TextView textView;
@@ -38,21 +37,21 @@
 
     @Before
     public void setUp() throws Exception {
-        context = new Activity();
+        Activity context = Robolectric.buildActivity(Activity.class).create().get();
         relativeLayout = new RelativeLayout(context);
         relativeLayout.setId((int) Utils.generateUniqueId());
         viewGroup = new LinearLayout(context);
 
-        mNativeAd = new BaseForwardingNativeAd() {};
-        mNativeAd.setTitle("test title");
-        mNativeAd.setText("test text");
-        mNativeAd.setCallToAction("test call to action");
-        mNativeAd.setClickDestinationUrl("destinationUrl");
+        BaseForwardingNativeAd baseForwardingNativeAd = new BaseForwardingNativeAd() {};
+        baseForwardingNativeAd.setTitle("test title");
+        baseForwardingNativeAd.setText("test text");
+        baseForwardingNativeAd.setCallToAction("test call to action");
+        baseForwardingNativeAd.setClickDestinationUrl("destinationUrl");
 
         nativeResponse = new NativeResponse(context,
                 "impressionTrackerUrl",
                 "clickTrackerUrl",
-                "test ID", mNativeAd,
+                "test ID", baseForwardingNativeAd,
                 mock(MoPubNative.MoPubNativeListener.class));
 
         titleView = new TextView(context);
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeTest.java
index fd3efed5..e04b9023 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeTest.java
@@ -5,12 +5,14 @@
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.common.util.test.support.ShadowAsyncTasks;
 import com.mopub.common.util.test.support.TestMethodBuilderFactory;
+import com.mopub.mobileads.MoPubErrorCode;
 import com.mopub.nativeads.MoPubNative.MoPubNativeEventListener;
 import com.mopub.nativeads.MoPubNative.MoPubNativeNetworkListener;
 import com.mopub.network.MoPubNetworkError;
+import com.mopub.network.MoPubRequestQueue;
 import com.mopub.network.Networking;
+import com.mopub.volley.NoConnectionError;
 import com.mopub.volley.Request;
-import com.mopub.volley.RequestQueue;
 import com.mopub.volley.VolleyError;
 
 import org.junit.After;
@@ -22,9 +24,13 @@
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLog;
 
 import java.net.MalformedURLException;
+import java.util.List;
 import java.util.concurrent.Semaphore;
+import java.util.logging.Level;
+import java.util.logging.LogManager;
 
 import static android.Manifest.permission.ACCESS_NETWORK_STATE;
 import static android.Manifest.permission.INTERNET;
@@ -50,16 +56,16 @@
     private Activity context;
     private Semaphore semaphore;
     private static final String adUnitId = "test_adunit_id";
-    
+
     @Mock private MoPubNativeEventListener mockEventListener;
 
     @Mock private MoPubNativeNetworkListener mockNetworkListener;
-    @Mock private RequestQueue mockRequestQueue;
+    @Mock private MoPubRequestQueue mockRequestQueue;
 
 
     @Before
     public void setup() {
-        context = new Activity();
+        context = Robolectric.buildActivity(Activity.class).create().get();
         shadowOf(context).grantPermissions(ACCESS_NETWORK_STATE);
         shadowOf(context).grantPermissions(INTERNET);
         subject = new MoPubNative(context, adUnitId, mockNetworkListener);
@@ -155,4 +161,33 @@ public void onAdError_whenNotMoPubError_shouldNotifyListener() {
 
         verify(mockNetworkListener).onNativeFail(eq(NativeErrorCode.UNSPECIFIED));
     }
+
+    @Test
+    public void onAdError_withVolleyErrorWarmingUp_shouldLogMoPubErrorCodeWarmup_shouldNotifyListener() {
+        LogManager.getLogManager().getLogger("com.mopub").setLevel(Level.ALL);
+
+        subject.onAdError(new MoPubNetworkError(MoPubNetworkError.Reason.WARMING_UP));
+
+        final List<ShadowLog.LogItem> allLogMessages = ShadowLog.getLogs();
+        final ShadowLog.LogItem latestLogMessage = allLogMessages.get(allLogMessages.size() - 1);
+
+        // All log messages end with a newline character.
+        assertThat(latestLogMessage.msg.trim()).isEqualTo(MoPubErrorCode.WARMUP.toString());
+        verify(mockNetworkListener).onNativeFail(eq(NativeErrorCode.EMPTY_AD_RESPONSE));
+    }
+
+    @Test
+    public void onAdError_withNoConnection_shouldLogMoPubErrorCodeNoConnection_shouldNotifyListener() {
+        LogManager.getLogManager().getLogger("com.mopub").setLevel(Level.ALL);
+        shadowOf(context).denyPermissions(INTERNET);
+
+        subject.onAdError(new NoConnectionError());
+
+        final List<ShadowLog.LogItem> allLogMessages = ShadowLog.getLogs();
+        final ShadowLog.LogItem latestLogMessage = allLogMessages.get(allLogMessages.size() - 1);
+
+        // All log messages end with a newline character.
+        assertThat(latestLogMessage.msg.trim()).isEqualTo(MoPubErrorCode.NO_CONNECTION.toString());
+        verify(mockNetworkListener).onNativeFail(eq(NativeErrorCode.CONNECTION_ERROR));
+    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubStreamAdPlacerTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubStreamAdPlacerTest.java
index ac6f2be1..2e772506 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubStreamAdPlacerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubStreamAdPlacerTest.java
@@ -55,7 +55,7 @@
 
     @Before
     public void setup() {
-        context = new Activity();
+        context = Robolectric.buildActivity(Activity.class).create().get();
         positioning = MoPubNativeAdPositioning.clientPositioning()
                 .enableRepeatingPositions(2);
 
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdViewHelperTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdViewHelperTest.java
index d9b1ad7c..2443a4d4 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdViewHelperTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdViewHelperTest.java
@@ -15,6 +15,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
+import org.robolectric.Robolectric;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
@@ -40,7 +41,7 @@
 
     @Before
     public void setUp() throws Exception {
-        context = new Activity();
+        context = Robolectric.buildActivity(Activity.class).create().get();
         relativeLayout = new RelativeLayout(context);
         relativeLayout.setId((int) Utils.generateUniqueId());
         viewGroup = new LinearLayout(context);
@@ -60,6 +61,7 @@ public void setUp() throws Exception {
         relativeLayout.addView(titleView);
         relativeLayout.addView(textView);
         relativeLayout.addView(callToActionView);
+        relativeLayout.setTag(NativeAdViewHelper.ViewType.AD);
 
         viewBinder = new ViewBinder.Builder(relativeLayout.getId())
                 .titleId(titleView.getId())
@@ -82,19 +84,21 @@ public void getAdView_shouldReturnPopulatedView() throws Exception {
         assertThat(((TextView)view.findViewById(titleView.getId())).getText()).isEqualTo("test title");
         assertThat(((TextView)view.findViewById(textView.getId())).getText()).isEqualTo("test text");
         assertThat(((TextView)view.findViewById(callToActionView.getId())).getText()).isEqualTo("test call to action");
+        assertThat(view.getTag()).isEqualTo(NativeAdViewHelper.ViewType.AD);
 
         // not testing images due to testing complexity
     }
 
     @Test
-    public void getAdView_withDestroyedNativeResponse_shouldReturnGONEConvertView() throws Exception {
+    public void getAdView_withDestroyedNativeResponse_shouldReturnEmptyAndGoneConvertView() throws Exception {
         when(mockNativeResponse1.isDestroyed()).thenReturn(true);
         View view = NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse1, viewBinder);
 
-        assertThat(view).isEqualTo(relativeLayout);
+        assertThat(view).isNotEqualTo(relativeLayout);
+        assertThat(view.getTag()).isEqualTo(NativeAdViewHelper.ViewType.EMPTY);
         assertThat(view.getVisibility()).isEqualTo(View.GONE);
     }
-    
+
     @Test
     public void getAdView_shouldRemoveViewFromImpressionTracker_shouldClearPreviousNativeResponse() throws Exception {
         NativeAdViewHelper.sImpressionTrackerMap.put(context, mockImpressionTracker);
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeResponseTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeResponseTest.java
index 9f8f8f40..3ebefbe8 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeResponseTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeResponseTest.java
@@ -10,15 +10,16 @@
 
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.common.util.Utils;
+import com.mopub.network.MoPubRequestQueue;
 import com.mopub.network.Networking;
 import com.mopub.volley.Request;
-import com.mopub.volley.RequestQueue;
 
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
+import org.robolectric.Robolectric;
 
 import java.util.List;
 import java.util.Map;
@@ -47,12 +48,12 @@
     private boolean baseNativeAdRecordedImpression;
     private boolean baseNativeAdIsClicked;
     @Mock
-    private RequestQueue mockRequestQueue;
+    private MoPubRequestQueue mockRequestQueue;
 
 
     @Before
     public void setUp() throws Exception {
-        context = new Activity();
+        context = Robolectric.buildActivity(Activity.class).create().get();
         mNativeAd = new BaseForwardingNativeAd() {
             @Override
             public void recordImpression() {
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeUrlGeneratorTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeUrlGeneratorTest.java
index 7d7f96bb..7cd08ac5 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeUrlGeneratorTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeUrlGeneratorTest.java
@@ -2,19 +2,27 @@
 
 import android.app.Activity;
 import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Point;
 import android.location.Location;
 import android.location.LocationManager;
 import android.net.Uri;
+import android.os.Build;
 import android.telephony.TelephonyManager;
 import android.text.TextUtils;
+import android.util.DisplayMetrics;
+import android.view.Display;
+import android.view.WindowManager;
 
 import com.mopub.common.MoPub;
-import com.mopub.mobileads.test.support.MoPubShadowTelephonyManager;
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.test.support.MoPubShadowTelephonyManager;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowLocationManager;
@@ -26,6 +34,11 @@
 
 import static android.Manifest.permission.ACCESS_NETWORK_STATE;
 import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
 import static org.robolectric.Robolectric.application;
 import static org.robolectric.Robolectric.shadowOf;
 
@@ -33,20 +46,53 @@
 @Config(shadows = {MoPubShadowTelephonyManager.class})
 public class NativeUrlGeneratorTest {
     public static final String AD_UNIT_ID = "1234";
+    private static final int TEST_SCREEN_WIDTH = 999;
+    private static final int TEST_SCREEN_HEIGHT = 888;
+    private static final float TEST_DENSITY = 1.0f;
     private Activity context;
     private NativeUrlGenerator subject;
     private MoPubShadowTelephonyManager shadowTelephonyManager;
 
     @Before
     public void setup() {
-        context = new Activity();
+        context = spy(Robolectric.buildActivity(Activity.class).create().get());
         shadowOf(context).grantPermissions(ACCESS_NETWORK_STATE);
+        when(context.getPackageName()).thenReturn("testBundle");
         shadowTelephonyManager = (MoPubShadowTelephonyManager)
                 shadowOf((TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE));
+
+        // Set the expected screen dimensions to arbitrary numbers
+        final Resources spyResources = spy(context.getResources());
+        final DisplayMetrics mockDisplayMetrics = mock(DisplayMetrics.class);
+        mockDisplayMetrics.widthPixels = TEST_SCREEN_WIDTH;
+        mockDisplayMetrics.heightPixels = TEST_SCREEN_HEIGHT;
+        mockDisplayMetrics.density = TEST_DENSITY;
+        when(spyResources.getDisplayMetrics()).thenReturn(mockDisplayMetrics);
+        when(context.getResources()).thenReturn(spyResources);
+
+        // Only do this on Android 17+ because getRealSize doesn't exist before then.
+        // This is the default pathway.
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
+            final WindowManager mockWindowManager = mock(WindowManager.class);
+            final Display mockDisplay = mock(Display.class);
+            doAnswer(new Answer() {
+                @Override
+                public Object answer(final InvocationOnMock invocationOnMock) throws Throwable {
+                    final Point point = (Point) invocationOnMock.getArguments()[0];
+                    point.x = TEST_SCREEN_WIDTH;
+                    point.y = TEST_SCREEN_HEIGHT;
+                    return null;
+                }
+            }).when(mockDisplay).getRealSize(any(Point.class));
+            when(mockWindowManager.getDefaultDisplay()).thenReturn(mockDisplay);
+            final Context spyApplicationContext = spy(context.getApplicationContext());
+            when(spyApplicationContext.getSystemService(Context.WINDOW_SERVICE)).thenReturn(mockWindowManager);
+            when(context.getApplicationContext()).thenReturn(spyApplicationContext);
+        }
     }
 
     @Test
-    public void generateNativeAdUrl_shouldIncludeDesiredAssetIfSet() throws Exception {
+    public void generateUrlString_shouldIncludeDesiredAssetIfSet() throws Exception {
         EnumSet<RequestParameters.NativeAdAsset> assetsSet = EnumSet.of(RequestParameters.NativeAdAsset.TITLE);
         RequestParameters requestParameters = new RequestParameters.Builder().desiredAssets(assetsSet).build();
 
@@ -60,7 +106,7 @@ public void generateNativeAdUrl_shouldIncludeDesiredAssetIfSet() throws Exceptio
     }
 
     @Test
-    public void generateNativeAdUrl_shouldIncludeDesiredAssetsIfSet() throws Exception {
+    public void generateUrlString_shouldIncludeDesiredAssetsIfSet() throws Exception {
         EnumSet<RequestParameters.NativeAdAsset> assetsSet = EnumSet.of(RequestParameters.NativeAdAsset.TITLE, RequestParameters.NativeAdAsset.TEXT, RequestParameters.NativeAdAsset.ICON_IMAGE);
         RequestParameters requestParameters = new RequestParameters.Builder().desiredAssets(assetsSet).build();
 
@@ -74,7 +120,7 @@ public void generateNativeAdUrl_shouldIncludeDesiredAssetsIfSet() throws Excepti
     }
 
     @Test
-    public void generateNativeAdUrl_shouldNotIncludeDesiredAssetsIfNotSet() throws Exception {
+    public void generateUrlString_shouldNotIncludeDesiredAssetsIfNotSet() throws Exception {
         subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
 
         String requestString = generateMinimumUrlString();
@@ -84,7 +130,7 @@ public void generateNativeAdUrl_shouldNotIncludeDesiredAssetsIfNotSet() throws E
     }
 
     @Test
-    public void generateNativeAdUrl_shouldNotIncludeDesiredAssetsIfNoAssetsAreSet() throws Exception {
+    public void generateUrlString_shouldNotIncludeDesiredAssetsIfNoAssetsAreSet() throws Exception {
         EnumSet<RequestParameters.NativeAdAsset> assetsSet = EnumSet.noneOf(RequestParameters.NativeAdAsset.class);
         RequestParameters requestParameters = new RequestParameters.Builder().desiredAssets(assetsSet).build();
 
@@ -97,7 +143,7 @@ public void generateNativeAdUrl_shouldNotIncludeDesiredAssetsIfNoAssetsAreSet()
     }
 
     @Test
-    public void generateNativeAdUrl_needsButDoesNotHaveReadPhoneState_shouldNotContainOperatorName() {
+    public void generateUrlString_needsButDoesNotHaveReadPhoneState_shouldNotContainOperatorName() {
         shadowTelephonyManager.setNeedsReadPhoneState(true);
         shadowTelephonyManager.setReadPhoneStatePermission(false);
         shadowTelephonyManager.setNetworkOperatorName("TEST_CARRIER");
@@ -107,9 +153,9 @@ public void generateNativeAdUrl_needsButDoesNotHaveReadPhoneState_shouldNotConta
 
         assertThat(getNetworkOperatorNameFromRequestUrl(requestString)).isNullOrEmpty();
     }
-    
+
     @Test
-    public void generateNativeAdUrl_needsAndHasReadPhoneState_shouldContainOperatorName() {
+    public void generateUrlString_needsAndHasReadPhoneState_shouldContainOperatorName() {
         shadowTelephonyManager.setNeedsReadPhoneState(true);
         shadowTelephonyManager.setReadPhoneStatePermission(true);
         shadowTelephonyManager.setNetworkOperatorName("TEST_CARRIER");
@@ -121,7 +167,7 @@ public void generateNativeAdUrl_needsAndHasReadPhoneState_shouldContainOperatorN
     }
 
     @Test
-    public void generateNativeAdUrl_doesNotNeedReadPhoneState_shouldContainOperatorName() {
+    public void generateUrlString_doesNotNeedReadPhoneState_shouldContainOperatorName() {
         shadowTelephonyManager.setNeedsReadPhoneState(false);
         shadowTelephonyManager.setReadPhoneStatePermission(false);
         shadowTelephonyManager.setNetworkOperatorName("TEST_CARRIER");
@@ -133,7 +179,7 @@ public void generateNativeAdUrl_doesNotNeedReadPhoneState_shouldContainOperatorN
     }
 
     @Test
-    public void generateAdUrl_whenLocationServiceGpsProviderHasMostRecentLocation_shouldUseLocationServiceValue() {
+    public void generateUrlString_whenLocationServiceGpsProviderHasMostRecentLocation_shouldUseLocationServiceValue() {
         Location locationFromDeveloper = new Location("");
         locationFromDeveloper.setLatitude(42);
         locationFromDeveloper.setLongitude(-42);
@@ -148,7 +194,7 @@ public void generateAdUrl_whenLocationServiceGpsProviderHasMostRecentLocation_sh
         locationFromSdk.setLatitude(37);
         locationFromSdk.setLongitude(-122);
         locationFromSdk.setAccuracy(5.0f);
-        locationFromSdk.setTime(2000);
+        locationFromSdk.setTime(System.currentTimeMillis() - 555555);
         shadowLocationManager.setLastKnownLocation(LocationManager.GPS_PROVIDER, locationFromSdk);
 
         RequestParameters requestParameters = new RequestParameters.Builder()
@@ -160,15 +206,18 @@ public void generateAdUrl_whenLocationServiceGpsProviderHasMostRecentLocation_sh
         assertThat(getParameterFromRequestUrl(adUrl, "ll")).isEqualTo("37.0,-122.0");
         assertThat(getParameterFromRequestUrl(adUrl, "lla")).isEqualTo("5");
         assertThat(getParameterFromRequestUrl(adUrl, "llsdk")).isEqualTo("1");
+        // Only test to the full second (as there may be small differences)
+        assertThat(getParameterFromRequestUrl(adUrl, "llf")).startsWith("555");
+        assertThat(getParameterFromRequestUrl(adUrl, "llf").length()).isEqualTo(6);
     }
 
     @Test
-    public void generateAdUrl_whenDeveloperSuppliesMoreRecentLocationThanLocationService_shouldUseDeveloperSuppliedLocation() {
+    public void generateUrlString_whenDeveloperSuppliesMoreRecentLocationThanLocationService_shouldUseDeveloperSuppliedLocation() {
         Location locationFromDeveloper = new Location("");
         locationFromDeveloper.setLatitude(42);
         locationFromDeveloper.setLongitude(-42);
         locationFromDeveloper.setAccuracy(3.5f);
-        locationFromDeveloper.setTime(1000);
+        locationFromDeveloper.setTime(System.currentTimeMillis() - 777777);
 
         ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
                 (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
@@ -179,7 +228,7 @@ public void generateAdUrl_whenDeveloperSuppliesMoreRecentLocationThanLocationSer
         olderLocation.setLatitude(40);
         olderLocation.setLongitude(-105);
         olderLocation.setAccuracy(8.0f);
-        olderLocation.setTime(500);
+        olderLocation.setTime(System.currentTimeMillis() - 888888);
         shadowLocationManager.setLastKnownLocation(LocationManager.GPS_PROVIDER, olderLocation);
 
         RequestParameters requestParameters = new RequestParameters.Builder()
@@ -191,10 +240,13 @@ public void generateAdUrl_whenDeveloperSuppliesMoreRecentLocationThanLocationSer
         assertThat(getParameterFromRequestUrl(adUrl, "ll")).isEqualTo("42.0,-42.0");
         assertThat(getParameterFromRequestUrl(adUrl, "lla")).isEqualTo("3");
         assertThat(getParameterFromRequestUrl(adUrl, "llsdk")).isEmpty();
+        // Only test to the full second (as there may be small differences)
+        assertThat(getParameterFromRequestUrl(adUrl, "llf")).startsWith("777");
+        assertThat(getParameterFromRequestUrl(adUrl, "llf").length()).isEqualTo(6);
     }
 
     @Test
-    public void generateAdUrl_whenLocationServiceNetworkProviderHasMostRecentLocation_shouldUseLocationServiceValue() {
+    public void generateUrlString_whenLocationServiceNetworkProviderHasMostRecentLocation_shouldUseLocationServiceValue() {
         Location locationFromDeveloper = new Location("");
         locationFromDeveloper.setLatitude(42);
         locationFromDeveloper.setLongitude(-42);
@@ -209,7 +261,7 @@ public void generateAdUrl_whenLocationServiceNetworkProviderHasMostRecentLocatio
         locationFromSdk.setLatitude(38);
         locationFromSdk.setLongitude(-123);
         locationFromSdk.setAccuracy(5.0f);
-        locationFromSdk.setTime(2000);
+        locationFromSdk.setTime(System.currentTimeMillis() - 123456);
         shadowLocationManager.setLastKnownLocation(LocationManager.NETWORK_PROVIDER,
                 locationFromSdk);
 
@@ -222,6 +274,35 @@ public void generateAdUrl_whenLocationServiceNetworkProviderHasMostRecentLocatio
         assertThat(getParameterFromRequestUrl(adUrl, "ll")).isEqualTo("38.0,-123.0");
         assertThat(getParameterFromRequestUrl(adUrl, "lla")).isEqualTo("5");
         assertThat(getParameterFromRequestUrl(adUrl, "llsdk")).isEqualTo("1");
+        // Only test to the full second (as there may be small differences)
+        assertThat(getParameterFromRequestUrl(adUrl, "llf")).startsWith("123");
+        assertThat(getParameterFromRequestUrl(adUrl, "llf").length()).isEqualTo(6);
+    }
+
+    @Test
+    public void generateUrlString_withOnlyAdUnitSet_shouldReturnMinimumUrl() {
+        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
+        final String adUrl = generateMinimumUrlString();
+
+        assertThat(adUrl).isEqualTo(
+                "http://ads.mopub.com/m/ad?id=" +
+                        AD_UNIT_ID +
+                        "&nsv=" + MoPub.SDK_VERSION + 
+                        "&dn=unknown%2Cunknown%2Cunknown" +
+                        "&bundle=testBundle" +
+                        "&z=-0700" +
+                        "&o=u" +
+                        "&w=" +
+                        TEST_SCREEN_WIDTH +
+                        "&h=" +
+                        TEST_SCREEN_HEIGHT +
+                        "&sc_a=" +
+                        TEST_DENSITY +
+                        // maven version
+                        "&ct=3&av=1.0" +
+                        // Gradle version
+                        //"&ct=3&av=" + BuildConfig.VERSION_NAME +
+                        "&udid=mp_tmpl_advertising_id&dnt=mp_tmpl_do_not_track");
     }
 
     @Test
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeViewHolderTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeViewHolderTest.java
index af5c0dca..fdeb2107 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeViewHolderTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeViewHolderTest.java
@@ -15,8 +15,8 @@
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.common.util.Utils;
 import com.mopub.network.MaxWidthImageLoader;
+import com.mopub.network.MoPubRequestQueue;
 import com.mopub.network.Networking;
-import com.mopub.volley.RequestQueue;
 import com.mopub.volley.toolbox.ImageLoader;
 
 import org.junit.Before;
@@ -25,6 +25,7 @@
 import org.mockito.ArgumentCaptor;
 import org.mockito.Captor;
 import org.mockito.Mock;
+import org.robolectric.Robolectric;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.eq;
@@ -64,7 +65,7 @@
     private static final String AD_UNIT_ID = "http://blah.org";
 
     @Mock
-    private RequestQueue mockRequestQueue;
+    private MoPubRequestQueue mockRequestQueue;
     @Mock
     private MaxWidthImageLoader mockImageLoader;
     @Mock
@@ -83,7 +84,7 @@ public void setUp() throws Exception {
 
         Networking.setRequestQueueForTesting(mockRequestQueue);
         Networking.setImageLoaderForTesting(mockImageLoader);
-        context = new Activity();
+        context = Robolectric.buildActivity(Activity.class).create().get();
         relativeLayout = new RelativeLayout(context);
         relativeLayout.setId((int) Utils.generateUniqueId());
         viewGroup = new LinearLayout(context);
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/PlacementDataTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/PlacementDataTest.java
index 75de2550..bcab2a25 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/PlacementDataTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/PlacementDataTest.java
@@ -20,7 +20,6 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-@Config(manifest=Config.NONE)
 @RunWith(SdkTestRunner.class)
 public class PlacementDataTest {
     private PlacementData noAds;
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/ServerPositioningSourceTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/ServerPositioningSourceTest.java
index e0e3e524..49ce986e 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/ServerPositioningSourceTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/ServerPositioningSourceTest.java
@@ -5,11 +5,13 @@
 
 import com.mopub.common.DownloadResponse;
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.MoPubErrorCode;
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
 import com.mopub.nativeads.PositioningSource.PositioningListener;
+import com.mopub.network.MoPubRequestQueue;
 import com.mopub.network.Networking;
+import com.mopub.volley.NoConnectionError;
 import com.mopub.volley.Request;
-import com.mopub.volley.RequestQueue;
 import com.mopub.volley.VolleyError;
 
 import org.apache.http.HttpStatus;
@@ -21,7 +23,13 @@
 import org.mockito.Mock;
 import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLog;
 
+import java.util.List;
+import java.util.logging.Level;
+import java.util.logging.LogManager;
+
+import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.never;
@@ -40,7 +48,7 @@
     @Mock DownloadResponse mockWarmingUpJsonResponse;
 
     @Mock
-    RequestQueue mockRequestQueue;
+    MoPubRequestQueue mockRequestQueue;
 
     @Captor ArgumentCaptor<MoPubClientPositioning> positioningCaptor;
 
@@ -145,4 +153,20 @@ public void loadPositions_thenFailAfterMaxRetryTime_shouldCallFailureHandler() {
         positionRequestCaptor.getValue().deliverError(new VolleyError("test error"));
         verify(mockPositioningListener).onFailed();
     }
+
+    @Test
+    public void loadPositions_withNoConnection_shouldLogMoPubErrorCodeNoConnection_shouldCallFailureHandler() {
+        LogManager.getLogManager().getLogger("com.mopub").setLevel(Level.ALL);
+
+        subject.loadPositions("test_ad_unit", mockPositioningListener);
+
+        verify(mockRequestQueue).add(positionRequestCaptor.capture());
+        positionRequestCaptor.getValue().deliverError(new NoConnectionError());
+        verify(mockPositioningListener).onFailed();
+
+        final List<ShadowLog.LogItem> allLogMessages = ShadowLog.getLogs();
+        final ShadowLog.LogItem latestLogMessage = allLogMessages.get(allLogMessages.size() - 2);
+        // All log messages end with a newline character.
+        assertThat(latestLogMessage.msg.trim()).isEqualTo(MoPubErrorCode.NO_CONNECTION.toString());
+    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/VisibilityTrackerTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/VisibilityTrackerTest.java
index 488c1ae7..bee7ae9e 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/VisibilityTrackerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/VisibilityTrackerTest.java
@@ -9,8 +9,8 @@
 import android.view.ViewTreeObserver;
 import android.view.Window;
 
-import com.mopub.nativeads.VisibilityTracker.TrackingInfo;
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.nativeads.VisibilityTracker.TrackingInfo;
 
 import org.fest.util.Lists;
 import org.junit.Before;
@@ -20,6 +20,7 @@
 import org.mockito.Mock;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
 import org.robolectric.shadows.ShadowSystemClock;
 
 import java.util.ArrayList;
@@ -56,7 +57,7 @@
     public void setUp() throws Exception {
         trackedViews = new WeakHashMap<View, TrackingInfo>();
         visibilityChecker = new VisibilityChecker();
-        activity = new Activity();
+        activity = Robolectric.buildActivity(Activity.class).create().get();
         view = createViewMock(View.VISIBLE, 100, 100, 100, 100, true, true);
         view2 = createViewMock(View.VISIBLE, 100, 100, 100, 100, true, true);
 
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/test/support/MoPubShadowDisplay.java b/mopub-sdk/src/test/java/com/mopub/nativeads/test/support/MoPubShadowDisplay.java
index 9b38d956..47ab9573 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/test/support/MoPubShadowDisplay.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/test/support/MoPubShadowDisplay.java
@@ -2,7 +2,9 @@
 
 import android.graphics.Point;
 import android.view.Display;
+import android.view.Surface;
 
+import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.shadows.ShadowDisplay;
 
@@ -13,4 +15,15 @@
     public void getSize(Point size) {
         size.set(getWidth(), getHeight());
     }
+
+    private static int sRotation = Surface.ROTATION_0;
+
+    @Implementation
+    public int getRotation() {
+        return sRotation;
+    }
+
+    public static void setStaticRotation(int rotation) {
+        sRotation = rotation;
+    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/network/AdRequestTest.java b/mopub-sdk/src/test/java/com/mopub/network/AdRequestTest.java
index c9eaea73..08b25a5a 100644
--- a/mopub-sdk/src/test/java/com/mopub/network/AdRequestTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/network/AdRequestTest.java
@@ -1,41 +1,61 @@
 package com.mopub.network;
 
+import android.app.Activity;
+import android.location.Location;
+
 import com.mopub.common.AdFormat;
 import com.mopub.common.AdType;
 import com.mopub.common.DataKeys;
+import com.mopub.common.event.BaseEvent;
+import com.mopub.common.event.EventDispatcher;
+import com.mopub.common.event.MoPubEvents;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.common.util.ResponseHeader;
 import com.mopub.volley.NetworkResponse;
 import com.mopub.volley.Response;
 
 import org.json.JSONException;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
 
 import java.nio.charset.Charset;
+import java.util.Collections;
 import java.util.HashMap;
+import java.util.Locale;
 import java.util.Map;
+import java.util.TreeMap;
 
 import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
 public class AdRequestTest {
 
-    @Mock
-    private AdRequest.Listener mockListener;
-    @Mock
-    private AdResponse mockAdResponse;
+    @Mock private AdRequest.Listener mockListener;
+    @Mock private AdResponse mockAdResponse;
+    @Mock private EventDispatcher mockEventDispatcher;
 
     private AdRequest subject;
     private HashMap<String, String> defaultHeaders;
-
+    private Activity activity;
+    private String adUnitId;
 
     @Before
     public void setup() {
-        subject = new AdRequest("testUrl", AdFormat.NATIVE, "testAdUnitId", mockListener);
+        activity = Robolectric.buildActivity(Activity.class).create().get();
+        adUnitId = "testAdUnitId";
+        subject = new AdRequest("testUrl", AdFormat.NATIVE, adUnitId, activity, mockListener);
         defaultHeaders = new HashMap<String, String>();
         defaultHeaders.put(ResponseHeader.SCROLLABLE.getKey(), "0");
         defaultHeaders.put(ResponseHeader.REDIRECT_URL.getKey(), "redirect");
@@ -43,6 +63,13 @@ public void setup() {
         defaultHeaders.put(ResponseHeader.IMPRESSION_URL.getKey(), "impression");
         defaultHeaders.put(ResponseHeader.FAIL_URL.getKey(), "fail_url");
         defaultHeaders.put(ResponseHeader.REFRESH_TIME.getKey(), "30");
+
+        MoPubEvents.setEventDispatcher(mockEventDispatcher);
+    }
+
+    @After
+    public void teardown() {
+        MoPubEvents.setEventDispatcher(null);
     }
 
     @Test
@@ -56,6 +83,17 @@ public void parseNetworkResponse_stringBody_shouldSucceed() throws Exception {
         assertThat(response.result.getStringBody()).isEqualTo("abc");
     }
 
+    @Test
+    public void parseNetworkResponse_withStringBody_shouldLogScribeEvent() throws Exception {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.HTML);
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        subject.parseNetworkResponse(testResponse);
+
+        verify(mockEventDispatcher).dispatch(any(BaseEvent.class));
+    }
+
     @Test
     public void parseNetworkResponse_withServerExtrasInResponseBody_shouldSucceed() throws Exception {
         defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.HTML);
@@ -86,6 +124,17 @@ public void parseNetworkResponse_nonJsonStringBodyForNative_jsonParseShouldFail(
         assertThat(((MoPubNetworkError) response.error).getReason()).isEqualTo(MoPubNetworkError.Reason.BAD_BODY);
     }
 
+    @Test
+    public void parseNetworkResponse_nonJsonStringBodyForNative_shouldNotLogScribeEvent() {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.NATIVE);
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        subject.parseNetworkResponse(testResponse);
+
+        verify(mockEventDispatcher, never()).dispatch(any(BaseEvent.class));
+    }
+
     @Test
     public void parseNetworkResponse_withWarmupHeaderTrue_shouldError() {
         defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.NATIVE);
@@ -100,7 +149,39 @@ public void parseNetworkResponse_withWarmupHeaderTrue_shouldError() {
     }
 
     @Test
-    public void parseNetworkResponse_withClearAdType_shouldError() {
+    public void parseNetworkResponse_withWarmupHeaderTrue_shouldNotLogScribeEvent() {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.NATIVE);
+        defaultHeaders.put(ResponseHeader.WARMUP.getKey(), "1");
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        subject.parseNetworkResponse(testResponse);
+
+        verify(mockEventDispatcher, never()).dispatch(any(BaseEvent.class));
+    }
+
+    @Test
+    public void parseNetworkResponse_withRefreshTime_shouldIncludeRefreshTimeInResult() {
+        defaultHeaders.put(ResponseHeader.REFRESH_TIME.getKey(), "13");
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+        assertThat(response.result.getRefreshTimeMillis()).isEqualTo(13000);
+    }
+
+    @Test
+    public void parseNetworkResponse_withoutRefreshTime_shouldNotIncludeRefreshTime() {
+        defaultHeaders.remove(ResponseHeader.REFRESH_TIME.getKey());
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+        assertThat(response.result.getRefreshTimeMillis()).isNull();
+    }
+    
+    @Test
+    public void parseNetworkResponse_withClearAdType_withRefreshTimeHeader_shouldErrorAndIncludeRefreshTime() {
         defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.CLEAR);
 
         NetworkResponse testResponse =
@@ -109,13 +190,36 @@ public void parseNetworkResponse_withClearAdType_shouldError() {
 
         assertThat(response.error).isNotNull();
         assertThat(response.error).isInstanceOf(MoPubNetworkError.class);
-        assertThat(((MoPubNetworkError) response.error).getReason()).isEqualTo(MoPubNetworkError.Reason.NO_FILL);
+        final MoPubNetworkError moPubNetworkError = (MoPubNetworkError) response.error;
+        assertThat(moPubNetworkError.getReason()).isEqualTo(MoPubNetworkError.Reason.NO_FILL);
+        assertThat(moPubNetworkError.getRefreshTimeMillis()).isEqualTo(30000);
     }
 
     @Test
-    public void deliverResponse_shouldCallListenerOnSuccess() throws Exception {
-        subject.deliverResponse(mockAdResponse);
-        verify(mockListener).onSuccess(mockAdResponse);
+    public void parseNetworkResponse_withClearAdType_withNoRefreshTimeHeader_shouldErrorAndNotIncludeRefreshTime() {
+        defaultHeaders.remove(ResponseHeader.REFRESH_TIME.getKey());
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.CLEAR);
+
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        assertThat(response.error).isNotNull();
+        assertThat(response.error).isInstanceOf(MoPubNetworkError.class);
+        final MoPubNetworkError moPubNetworkError = (MoPubNetworkError) response.error;
+        assertThat(moPubNetworkError.getReason()).isEqualTo(MoPubNetworkError.Reason.NO_FILL);
+        assertThat(moPubNetworkError.getRefreshTimeMillis()).isNull();
+    }
+
+    @Test
+    public void parseNetworkResponse_withClearAdType_shouldLogScribeEvent() {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.CLEAR);
+
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+        subject.parseNetworkResponse(testResponse);
+
+        verify(mockEventDispatcher).dispatch(any(BaseEvent.class));
     }
 
     @Test
@@ -124,11 +228,135 @@ public void parseNetworkResponse_withBadJSON_shouldReturnError() {
         NetworkResponse badNativeNetworkResponse = new NetworkResponse(200,
                 "{[abc}".getBytes(Charset.defaultCharset()),
                 defaultHeaders, false);
-        subject = new AdRequest("testUrl", AdFormat.NATIVE, "testAdUnitId", mockListener);
+        subject = new AdRequest("testUrl", AdFormat.NATIVE, "testAdUnitId", activity, mockListener);
 
         final Response<AdResponse> response = subject.parseNetworkResponse(badNativeNetworkResponse);
 
         assertThat(response.error).isNotNull();
         assertThat(response.error.getCause()).isExactlyInstanceOf(JSONException.class);
     }
+
+    @Test
+    public void deliverResponse_shouldCallListenerOnSuccess() throws Exception {
+        subject.deliverResponse(mockAdResponse);
+        verify(mockListener).onSuccess(mockAdResponse);
+    }
+
+    @Test
+    public void getRequestId_shouldParseAndReturnRequestIdFromFailUrl() throws Exception {
+        String requestId = subject.getRequestId("http://ads.mopub.com/m/ad?id=8cf00598d3664adaaeccd800e46afaca&exclude=043fde1fe2f9470c9aa67fec262a0596&request_id=7fd6dd3bf1c84f87876b4740c1dd7baa&fail=1");
+
+        assertThat(requestId).isEqualTo("7fd6dd3bf1c84f87876b4740c1dd7baa");
+    }
+
+    @Test
+    public void getRequestId_withNullFailUrl_shouldReturnNull() throws Exception {
+        assertThat(subject.getRequestId(null)).isNull();
+    }
+
+    @Test
+    public void getRequestId_withUrlWithNoRequestIdParam_shouldReturnNull() throws Exception {
+        assertThat(subject.getRequestId("http://ads.mopub.com/m/ad?id=8cf00598d3664adaaeccd800e46afaca")).isNull();
+    }
+
+    @Test
+    public void getHeaders_withDefaultLocale_shouldReturnDefaultLanguageCode() throws Exception {
+        Map<String, String> expectedHeaders = new TreeMap<String, String>();
+        expectedHeaders.put(ResponseHeader.ACCEPT_LANGUAGE.getKey(), "en");
+
+        assertThat(subject.getHeaders()).isEqualTo(expectedHeaders);
+    }
+
+    @Test
+    public void getHeaders_withUserPreferredLocale_shouldReturnUserPreferredLanguageCode() throws Exception {
+        Map<String, String> expectedHeaders = new TreeMap<String, String>();
+        expectedHeaders.put(ResponseHeader.ACCEPT_LANGUAGE.getKey(), "fr");
+
+        // Assume user-preferred locale is fr_CA
+        activity.getResources().getConfiguration().locale = Locale.CANADA_FRENCH;
+
+        assertThat(subject.getHeaders()).isEqualTo(expectedHeaders);
+    }
+
+    @Test
+    public void getHeaders_withUserPreferredLocaleAsNull_shouldReturnDefaultLanguageCode() throws Exception {
+        Map<String, String> expectedHeaders = new TreeMap<String, String>();
+        expectedHeaders.put(ResponseHeader.ACCEPT_LANGUAGE.getKey(), "en");
+
+        // Assume user-preferred locale is null
+        activity.getResources().getConfiguration().locale = null;
+
+        assertThat(subject.getHeaders()).isEqualTo(expectedHeaders);
+    }
+
+    @Test
+    public void getHeaders_withUserPreferredLanguageAsEmptyString_shouldReturnDefaultLanguageCode() throws Exception {
+        Map<String, String> expectedHeaders = new TreeMap<String, String>();
+        expectedHeaders.put(ResponseHeader.ACCEPT_LANGUAGE.getKey(), "en");
+
+        // Assume user-preferred locale's language code is empty string after trimming
+        activity.getResources().getConfiguration().locale = new Locale(" ");
+
+        assertThat(subject.getHeaders()).isEqualTo(expectedHeaders);
+    }
+
+    @Test
+    public void getHeaders_withLocaleLanguageAsEmptyString_shouldNotAddLanguageHeader() throws Exception {
+        Map<String, String> expectedHeaders = Collections.emptyMap();
+
+        // Assume default locale's language code is empty string
+        Locale.setDefault(new Locale(""));
+
+        // Assume user-preferred locale's language code is empty string after trimming
+        activity.getResources().getConfiguration().locale = new Locale(" ");
+
+        assertThat(subject.getHeaders()).isEqualTo(expectedHeaders);
+    }
+
+    @Test
+    public void logScribeEvent_shouldLogEvent() throws Exception {
+        AdResponse mockAdResponse = mock(AdResponse.class);
+        when(mockAdResponse.getDspCreativeId()).thenReturn("dsp_creative_id");
+        when(mockAdResponse.getAdType()).thenReturn("html");
+        when(mockAdResponse.getNetworkType()).thenReturn("network_type");
+        when(mockAdResponse.getWidth()).thenReturn(320);
+        when(mockAdResponse.getHeight()).thenReturn(50);
+        when(mockAdResponse.getRequestId()).thenReturn("ac298c522b0e412b85ff81e4b9b51f03");
+
+        NetworkResponse networkResponse = new NetworkResponse(200, null, null, false, 300);
+
+        Location mockLocation = mock(Location.class);
+        when(mockLocation.getLatitude()).thenReturn(37.7833);
+        when(mockLocation.getLongitude()).thenReturn(-122.4167);
+        when(mockLocation.getAccuracy()).thenReturn((float) 2000.0);
+
+        doAnswer(new Answer() {
+            @Override
+            public Object answer(InvocationOnMock invocation) throws Throwable {
+                Object[] args = invocation.getArguments();
+                BaseEvent baseEvent = (BaseEvent) args[0];
+                assertThat(baseEvent.getName()).isEqualTo(BaseEvent.Name.AD_REQUEST);
+                assertThat(baseEvent.getCategory()).isEqualTo(BaseEvent.Category.REQUESTS);
+                assertThat(baseEvent.getSamplingRate()).isEqualTo(0.1);
+                assertThat(baseEvent.getAdUnitId()).isEqualTo(adUnitId);
+                assertThat(baseEvent.getAdCreativeId()).isEqualTo("dsp_creative_id");
+                assertThat(baseEvent.getAdType()).isEqualTo("html");
+                assertThat(baseEvent.getAdNetworkType()).isEqualTo("network_type");
+                assertThat(baseEvent.getAdWidthPx()).isEqualTo(320);
+                assertThat(baseEvent.getAdHeightPx()).isEqualTo(50);
+                assertThat(baseEvent.getGeoLat()).isEqualTo(37.7833);
+                assertThat(baseEvent.getGeoLon()).isEqualTo(-122.4167);
+                assertThat(baseEvent.getGeoAccuracy()).isEqualTo(2000.0);
+                assertThat(baseEvent.getPerformanceDurationMs()).isEqualTo(300);
+                assertThat(baseEvent.getRequestId()).isEqualTo("ac298c522b0e412b85ff81e4b9b51f03");
+                assertThat(baseEvent.getRequestStatusCode()).isEqualTo(200);
+                assertThat(baseEvent.getRequestUri()).isEqualTo("testUrl");
+                return null;
+            }
+        }).when(mockEventDispatcher).dispatch(any(BaseEvent.class));
+
+        subject.logScribeEvent(mockAdResponse, networkResponse, mockLocation);
+
+        verify(mockEventDispatcher).dispatch(any(BaseEvent.class));
+    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/network/MoPubRequestQueueTest.java b/mopub-sdk/src/test/java/com/mopub/network/MoPubRequestQueueTest.java
new file mode 100644
index 00000000..441ed4c2
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/network/MoPubRequestQueueTest.java
@@ -0,0 +1,203 @@
+package com.mopub.network;
+
+import android.app.Activity;
+import android.os.Handler;
+
+import com.mopub.common.ClientMetadata;
+import com.mopub.common.Constants;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.DeviceUtils;
+import com.mopub.volley.Cache;
+import com.mopub.volley.Network;
+import com.mopub.volley.Request;
+import com.mopub.volley.RequestQueue;
+import com.mopub.volley.toolbox.BasicNetwork;
+import com.mopub.volley.toolbox.DiskBasedCache;
+import com.mopub.volley.toolbox.HttpStack;
+import com.mopub.volley.toolbox.HurlStack;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+
+import java.io.File;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class MoPubRequestQueueTest {
+
+    private MoPubRequestQueue subject;
+    private MoPubRequestQueue.DelayedRequestHelper delayedRequestHelper;
+    @Mock private ScribeRequest mockScribeRequest;
+    @Mock private MoPubRequestQueue.DelayedRequestHelper mockDelayedRequestHelper;
+    @Mock private Handler mockHandler;
+
+    @Before
+    public void setUp() {
+        // NOTE: It's possible to start a new test with a queue set from a previous test suite
+        // Make sure we get a fresh one
+        Networking.setRequestQueueForTesting(null);
+
+        Activity activity = Robolectric.buildActivity(Activity.class).create().get();
+
+        // Construct our dependencies & build the object
+        final ClientMetadata clientMetadata = ClientMetadata.getInstance(activity);
+        final HurlStack.UrlRewriter urlRewriter = new PlayServicesUrlRewriter(clientMetadata.getDeviceId(), activity);
+        // No Custom SSL Factory
+
+        final String userAgent = Networking.getUserAgent(activity.getApplicationContext());
+        HttpStack httpStack = new RequestQueueHttpStack(userAgent, urlRewriter);
+
+        Network network = new BasicNetwork(httpStack);
+        File volleyCacheDir = new File(activity.getCacheDir().getPath() + File.separator
+                + Networking.CACHE_DIRECTORY_NAME);
+        Cache cache = new DiskBasedCache(volleyCacheDir, (int) DeviceUtils.diskCacheSizeBytes(volleyCacheDir, Constants.TEN_MB));
+        subject = new MoPubRequestQueue(cache, network);
+        subject.start();
+
+        delayedRequestHelper = subject.new DelayedRequestHelper(mockScribeRequest, 100, mockHandler);
+    }
+
+    @After
+    public void tearDown() {
+        // NOTE: Make sure that we clear the queue after the last test in the test suite runs so
+        // that the next test suite starts fresh
+        Networking.setRequestQueueForTesting(null);
+    }
+
+    @Test
+    public void addDelayedRequest_shouldStartDelayedRequestHelper_shouldPutRequestInMap() throws Exception {
+        subject.addDelayedRequest(mockScribeRequest, mockDelayedRequestHelper);
+
+        verify(mockDelayedRequestHelper).start();
+        assertThat(subject.getDelayedRequests().get(mockScribeRequest)).isEqualTo(mockDelayedRequestHelper);
+        assertThat(subject.getDelayedRequests().entrySet()).hasSize(1);
+    }
+
+    @Test
+    public void addDelayedRequest_shouldCancelPreexistingRequest() throws Exception {
+        subject.addDelayedRequest(mockScribeRequest, mockDelayedRequestHelper);
+
+        verify(mockDelayedRequestHelper, never()).cancel();
+        verify(mockScribeRequest, never()).cancel();
+
+        subject.addDelayedRequest(mockScribeRequest, mockDelayedRequestHelper);
+
+        verify(mockDelayedRequestHelper).cancel();
+        verify(mockScribeRequest).cancel();
+    }
+
+    @Test
+    public void addDelayedRequest_withUniqueRequest_shouldNotCancelOtherRequests() throws Exception {
+        ScribeRequest mockScribeRequest2 = mock(ScribeRequest.class);
+        MoPubRequestQueue.DelayedRequestHelper mockDelayedRequestHelper2 = mock(MoPubRequestQueue.DelayedRequestHelper.class);
+        subject.addDelayedRequest(mockScribeRequest, mockDelayedRequestHelper);
+        subject.addDelayedRequest(mockScribeRequest2, mockDelayedRequestHelper2);
+
+        verify(mockDelayedRequestHelper, never()).cancel();
+        verify(mockScribeRequest, never()).cancel();
+
+        verify(mockDelayedRequestHelper2).start();
+        assertThat(subject.getDelayedRequests().get(mockScribeRequest)).isEqualTo(mockDelayedRequestHelper);
+        assertThat(subject.getDelayedRequests().get(mockScribeRequest2)).isEqualTo(mockDelayedRequestHelper2);
+        assertThat(subject.getDelayedRequests().entrySet()).hasSize(2);
+    }
+
+    @Test
+    public void cancelAll_shouldCancelAllRequestsInTheDelayedRequestMapThatPassTheFilter() throws Exception {
+        ScribeRequest mockScribeRequest2 = mock(ScribeRequest.class);
+        MoPubRequestQueue.DelayedRequestHelper mockDelayedRequestHelper2 = mock(MoPubRequestQueue.DelayedRequestHelper.class);
+        subject.addDelayedRequest(mockScribeRequest, mockDelayedRequestHelper);
+        subject.addDelayedRequest(mockScribeRequest2, mockDelayedRequestHelper2);
+
+
+        subject.cancelAll(new RequestQueue.RequestFilter() {
+            @Override
+            public boolean apply(Request<?> request) {
+                return request == mockScribeRequest;
+            }
+        });
+
+        verify(mockDelayedRequestHelper).cancel();
+        verify(mockScribeRequest).cancel();
+
+        verify(mockDelayedRequestHelper2, never()).cancel();
+        verify(mockScribeRequest2, never()).cancel();
+
+        assertThat(subject.getDelayedRequests().entrySet()).hasSize(1);
+        assertThat(subject.getDelayedRequests().get(mockScribeRequest2)).isEqualTo(mockDelayedRequestHelper2);
+    }
+
+    @Test
+    public void cancelAll_shouldCancelAllRequestsWithMatchingObjectTag() throws Exception {
+        ScribeRequest mockScribeRequest2 = mock(ScribeRequest.class);
+        MoPubRequestQueue.DelayedRequestHelper mockDelayedRequestHelper2 = mock(MoPubRequestQueue.DelayedRequestHelper.class);
+        subject.addDelayedRequest(mockScribeRequest, mockDelayedRequestHelper);
+        subject.addDelayedRequest(mockScribeRequest2, mockDelayedRequestHelper2);
+
+        when(mockScribeRequest.getTag()).thenReturn(1);
+        when(mockScribeRequest2.getTag()).thenReturn(2);
+
+        subject.cancelAll(1);
+
+        verify(mockDelayedRequestHelper).cancel();
+        verify(mockScribeRequest).cancel();
+
+        verify(mockDelayedRequestHelper2, never()).cancel();
+        verify(mockScribeRequest2, never()).cancel();
+
+        assertThat(subject.getDelayedRequests().entrySet()).hasSize(1);
+        assertThat(subject.getDelayedRequests().get(mockScribeRequest2)).isEqualTo(mockDelayedRequestHelper2);
+    }
+
+    @Test
+    public void cancel_shouldCancelMatchingRequest() throws Exception {
+        ScribeRequest mockScribeRequest2 = mock(ScribeRequest.class);
+        MoPubRequestQueue.DelayedRequestHelper mockDelayedRequestHelper2 = mock(MoPubRequestQueue.DelayedRequestHelper.class);
+        subject.addDelayedRequest(mockScribeRequest, mockDelayedRequestHelper);
+        subject.addDelayedRequest(mockScribeRequest2, mockDelayedRequestHelper2);
+
+        subject.cancel(mockScribeRequest);
+
+        verify(mockDelayedRequestHelper).cancel();
+        verify(mockScribeRequest).cancel();
+
+        verify(mockDelayedRequestHelper2, never()).cancel();
+        verify(mockScribeRequest2, never()).cancel();
+
+        assertThat(subject.getDelayedRequests().entrySet()).hasSize(1);
+        assertThat(subject.getDelayedRequests().get(mockScribeRequest2)).isEqualTo(mockDelayedRequestHelper2);
+    }
+    
+    @Test
+    public void DelayedRequestHelper_start_shouldPostDelayedRunnable() throws Exception {
+        delayedRequestHelper.start();
+        verify(mockHandler).postDelayed(delayedRequestHelper.mDelayedRunnable, 100);
+    }
+
+    @Test
+    public void DelayedRequestHelper_cancel_shouldCancelDelayedRunnable() throws Exception {
+        delayedRequestHelper.cancel();
+        verify(mockHandler).removeCallbacks(delayedRequestHelper.mDelayedRunnable);
+    }
+
+    @Test
+    public void DelayedRequestHelper_Runnable_run_shouldRemoveRequestFromDelayedRequestsMap_shouldAddRequestToQueue() throws Exception {
+        subject.addDelayedRequest(mockScribeRequest, 100);
+        assertThat(subject.getDelayedRequests().entrySet().size()).isEqualTo(1);
+        MoPubRequestQueue.DelayedRequestHelper delayedRequestHelper = subject.getDelayedRequests().get(mockScribeRequest);
+
+        delayedRequestHelper.mDelayedRunnable.run();
+
+        assertThat(subject.getDelayedRequests().entrySet()).isEmpty();
+        verify(mockScribeRequest).setRequestQueue(subject);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/network/RequestManagerTest.java b/mopub-sdk/src/test/java/com/mopub/network/RequestManagerTest.java
new file mode 100644
index 00000000..8cadcfaf
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/network/RequestManagerTest.java
@@ -0,0 +1,138 @@
+package com.mopub.network;
+
+import android.os.Looper;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.volley.Request;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class RequestManagerTest {
+
+    private ScribeRequestManager subject;
+    @Mock private ScribeRequest.ScribeRequestFactory mockScribeRequestFactory;
+    @Mock private ScribeBackoffPolicy mockScribeBackoffPolicy;
+    @Mock private ScribeRequest mockScribeRequest;
+    @Mock private MoPubRequestQueue mockRequestQueue;
+
+    @Before
+    public void setUp() {
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+
+        subject = new ScribeRequestManager(Looper.getMainLooper());
+        when(mockScribeRequestFactory.createRequest(subject)).thenReturn(mockScribeRequest);
+    }
+
+    @Test
+    public void makeRequest_shouldAddRequestToQueue() throws Exception {
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+
+        verify(mockRequestQueue).add(mockScribeRequest);
+    }
+
+
+    @Test
+    public void makeRequest_shouldCancelTheCurrentRequest() throws Exception {
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+        Request<?> request = subject.getCurrentRequest();
+
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+
+        verify(mockRequestQueue).cancel(request);
+    }
+
+    @Test
+    public void cancelRequest_shouldCancelRequestInQueue_shouldClearRequest() throws Exception {
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+        subject.cancelRequest();
+
+        verify(mockRequestQueue).cancel(mockScribeRequest);
+        assertThat(subject.getCurrentRequest()).isNull();
+    }
+
+    @Test
+    public void cancelRequest_withNullRequestQueue_shouldOnlyClearCurrentRequest() throws Exception {
+        Networking.setRequestQueueForTesting(null);
+
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+        subject.cancelRequest();
+
+        verify(mockRequestQueue, never()).cancel(mockScribeRequest);
+        assertThat(subject.getCurrentRequest()).isNull();
+    }
+
+    @Test
+    public void cancelRequest_withNullCurrentRequest_shouldOnlyClearCurrentRequest() throws Exception {
+        subject.cancelRequest();
+
+        verify(mockRequestQueue, never()).cancel(mockScribeRequest);
+        assertThat(subject.getCurrentRequest()).isNull();
+    }
+
+    @Test
+    public void makeRequestInternal_shouldAddNewRequestToQueue() throws Exception {
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+        reset(mockRequestQueue);
+
+        ScribeRequest previousRequest = (ScribeRequest) subject.getCurrentRequest();
+        ScribeRequest nextRequest = mock(ScribeRequest.class);
+        when(mockScribeRequestFactory.createRequest(subject)).thenReturn(nextRequest);
+
+        subject.makeRequestInternal();
+
+        verify(mockRequestQueue).add(nextRequest);
+        verify(mockRequestQueue, never()).addDelayedRequest(any(Request.class), anyInt());
+        assertThat(previousRequest).isNotEqualTo(nextRequest);
+    }
+
+    @Test
+    public void makeRequestInternal_withRetryCountGreaterThan0_shouldAddNewDelayedRequestToQueue() throws Exception {
+        when(mockScribeBackoffPolicy.getRetryCount()).thenReturn(1);
+        when(mockScribeBackoffPolicy.getBackoffMs()).thenReturn(100);
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+        reset(mockRequestQueue);
+
+        ScribeRequest previousRequest = (ScribeRequest) subject.getCurrentRequest();
+        ScribeRequest nextRequest = mock(ScribeRequest.class);
+        when(mockScribeRequestFactory.createRequest(subject)).thenReturn(nextRequest);
+
+        subject.makeRequestInternal();
+
+        verify(mockRequestQueue).addDelayedRequest(nextRequest, 100);
+        verify(mockRequestQueue, never()).add(any(Request.class));
+        assertThat(previousRequest).isNotEqualTo(nextRequest);
+    }
+
+    @Test
+    public void makeRequestInternal_withNullRequestQueue_shouldClearCurrentRequest_shouldNotAddRequestToQueue() throws Exception {
+        Networking.setRequestQueueForTesting(null);
+
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+
+        verify(mockRequestQueue, never()).add(any(Request.class));
+        verify(mockRequestQueue, never()).addDelayedRequest(any(Request.class), anyInt());
+        assertThat(subject.getCurrentRequest()).isNull();
+    }
+
+    @Test
+    public void clearRequest_shouldSetCurrentRequestToNull() throws Exception {
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+        assertThat(subject.getCurrentRequest()).isNotNull();
+        subject.clearRequest();
+        assertThat(subject.getCurrentRequest()).isNull();
+    }
+}
+
diff --git a/mopub-sdk/src/test/java/com/mopub/network/ScribeBackoffPolicyTest.java b/mopub-sdk/src/test/java/com/mopub/network/ScribeBackoffPolicyTest.java
new file mode 100644
index 00000000..56a07c86
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/network/ScribeBackoffPolicyTest.java
@@ -0,0 +1,129 @@
+package com.mopub.network;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.NoConnectionError;
+import com.mopub.volley.VolleyError;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.fest.assertions.api.Assertions.fail;
+
+@RunWith(SdkTestRunner.class)
+public class ScribeBackoffPolicyTest {
+
+    private ScribeBackoffPolicy subject;
+
+    @Before
+    public void setUp() {
+        subject = new ScribeBackoffPolicy();
+    }
+
+    @Test
+    public void backoff_with503Error_shouldUpdateBackoffTime() throws Exception {
+        NetworkResponse networkResponse = new NetworkResponse(503, null, null, false);
+        VolleyError volleyError = new VolleyError(networkResponse);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(0);
+        assertThat(subject.getRetryCount()).isEqualTo(0);
+
+        subject.backoff(volleyError);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(60000);
+        assertThat(subject.getRetryCount()).isEqualTo(1);
+    }
+
+    @Test
+    public void backoff_with504Error_shouldUpdateBackoffTime() throws Exception {
+        NetworkResponse networkResponse = new NetworkResponse(504, null, null, false);
+        VolleyError volleyError = new VolleyError(networkResponse);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(0);
+        assertThat(subject.getRetryCount()).isEqualTo(0);
+
+        subject.backoff(volleyError);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(60000);
+        assertThat(subject.getRetryCount()).isEqualTo(1);
+    }
+
+    @Test
+    public void backoff_withNoConnectionError_shouldUpdateBackoffTime() throws Exception {
+        VolleyError volleyError = new NoConnectionError();
+
+        assertThat(subject.getBackoffMs()).isEqualTo(0);
+        assertThat(subject.getRetryCount()).isEqualTo(0);
+
+        subject.backoff(volleyError);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(60000);
+        assertThat(subject.getRetryCount()).isEqualTo(1);
+    }
+
+    @Test(expected = VolleyError.class)
+    public void backoff_withOtherErrorType_shouldRethrowException() throws Exception {
+        NetworkResponse networkResponse = new NetworkResponse(500, null, null, false);
+        VolleyError volleyError = new VolleyError(networkResponse);
+
+        subject.backoff(volleyError);
+    }
+
+    @Test
+    public void backoff_shouldUpdateBackoffTime5TimesMax() throws Exception {
+        VolleyError volleyError = new NoConnectionError();
+
+        assertThat(subject.getBackoffMs()).isEqualTo(0);
+        assertThat(subject.getRetryCount()).isEqualTo(0);
+        assertThat(subject.hasAttemptRemaining()).isTrue();
+
+        subject.backoff(volleyError);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(60000);
+        assertThat(subject.getRetryCount()).isEqualTo(1);
+        assertThat(subject.hasAttemptRemaining()).isTrue();
+
+        subject.backoff(volleyError);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(120000);
+        assertThat(subject.getRetryCount()).isEqualTo(2);
+        assertThat(subject.hasAttemptRemaining()).isTrue();
+
+        subject.backoff(volleyError);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(240000);
+        assertThat(subject.getRetryCount()).isEqualTo(3);
+        assertThat(subject.hasAttemptRemaining()).isTrue();
+
+        subject.backoff(volleyError);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(480000);
+        assertThat(subject.getRetryCount()).isEqualTo(4);
+        assertThat(subject.hasAttemptRemaining()).isTrue();
+
+        subject.backoff(volleyError);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(960000);
+        assertThat(subject.getRetryCount()).isEqualTo(5);
+        assertThat(subject.hasAttemptRemaining()).isFalse();
+    }
+
+    @Test(expected = NoConnectionError.class)
+    public void backoff_withNoAttemptsRemaining_shouldRethrowVolleyException() throws Exception {
+        VolleyError volleyError = new NoConnectionError();
+
+        try {
+            subject.backoff(volleyError);
+            subject.backoff(volleyError);
+            subject.backoff(volleyError);
+            subject.backoff(volleyError);
+            subject.backoff(volleyError);
+        } catch (Exception e) {
+            fail("Exception should not be thrown from above backoffs.");
+        }
+
+        subject.backoff(volleyError);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/network/ScribeRequestManagerTest.java b/mopub-sdk/src/test/java/com/mopub/network/ScribeRequestManagerTest.java
new file mode 100644
index 00000000..854b26a8
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/network/ScribeRequestManagerTest.java
@@ -0,0 +1,77 @@
+package com.mopub.network;
+
+import android.os.Looper;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.volley.NoConnectionError;
+import com.mopub.volley.Request;
+import com.mopub.volley.VolleyError;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class ScribeRequestManagerTest {
+
+    private ScribeRequestManager subject;
+    @Mock private ScribeRequest.ScribeRequestFactory mockScribeRequestFactory;
+    @Mock private ScribeBackoffPolicy mockScribeBackoffPolicy;
+    @Mock private ScribeRequest mockScribeRequest;
+    @Mock private MoPubRequestQueue mockRequestQueue;
+
+    @Before
+    public void setUp() {
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+
+        subject = new ScribeRequestManager(Looper.getMainLooper());
+        when(mockScribeRequestFactory.createRequest(subject)).thenReturn(mockScribeRequest);
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+    }
+
+    @Test
+    public void createRequest_shouldCreateNewScribeRequest() throws Exception {
+        Request request = subject.createRequest();
+        assertThat(request).isEqualTo(mockScribeRequest);
+    }
+
+    @Test
+    public void onResponse_shouldClearRequest() throws Exception {
+        subject.onResponse();
+        assertThat(subject.getCurrentRequest()).isNull();
+    }
+
+    @Test
+    public void onErrorResponse_withBackoffApplied_shouldCallBackoff_shouldMakeDelayedRequest() throws Exception {
+        when(mockScribeBackoffPolicy.getRetryCount()).thenReturn(1);
+        when(mockScribeBackoffPolicy.getBackoffMs()).thenReturn(100);
+
+        VolleyError volleyError = new NoConnectionError();
+        subject.onErrorResponse(volleyError);
+
+        verify(mockScribeBackoffPolicy).backoff(volleyError);
+        verify(mockRequestQueue).addDelayedRequest(mockScribeRequest, 100);
+    }
+
+    @Test
+    public void onErrorResponse_withBackoffNotApplied_shouldClearRequest() throws Exception {
+        reset(mockRequestQueue);
+
+        VolleyError volleyError = new NoConnectionError();
+        doThrow(new VolleyError()).when(mockScribeBackoffPolicy).backoff(volleyError);
+
+        subject.onErrorResponse(volleyError);
+
+        verify(mockScribeBackoffPolicy).backoff(volleyError);
+        verify(mockRequestQueue, never()).add(mockScribeRequest);
+        assertThat(subject.getCurrentRequest()).isNull();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/network/ScribeRequestTest.java b/mopub-sdk/src/test/java/com/mopub/network/ScribeRequestTest.java
new file mode 100644
index 00000000..7bf2d5bb
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/network/ScribeRequestTest.java
@@ -0,0 +1,83 @@
+package com.mopub.network;
+
+import android.app.Activity;
+
+import com.mopub.common.event.BaseEvent;
+import com.mopub.common.event.EventSerializer;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.volley.DefaultRetryPolicy;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.Response;
+
+import org.json.JSONArray;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+
+import java.nio.charset.Charset;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class ScribeRequestTest {
+
+    private ScribeRequest subject;
+    @Mock private List<BaseEvent> mockEvents;
+    @Mock private EventSerializer mockEventSerializer;
+    @Mock private ScribeRequest.Listener mockListener;
+
+    @Before
+    public void setUp() {
+        Activity activity = Robolectric.buildActivity(Activity.class).create().get();
+        Networking.getRequestQueue(activity);
+
+        subject = new ScribeRequest("url", mockEvents, mockEventSerializer, mockListener);
+    }
+
+    @Test
+    public void constructor_shouldSetShouldCacheToFalse() throws Exception {
+        assertThat(subject.shouldCache()).isFalse();
+    }
+
+    @Test
+    public void constructor_shouldSetRetryPolicyToDefaultRetryPolicy() throws Exception {
+        assertThat(subject.getRetryPolicy()).isExactlyInstanceOf(DefaultRetryPolicy.class);
+    }
+
+    @Test
+    public void getParams_returnJsonSerializedEventsInMap() throws Exception {
+        JSONArray mockJsonArray = mock(JSONArray.class);
+        when(mockJsonArray.toString()).thenReturn("jsonArrayToString");
+        when(mockEventSerializer.serializeAsJson(mockEvents)).thenReturn(mockJsonArray);
+
+        Map<String, String> params = subject.getParams();
+
+        verify(mockEventSerializer).serializeAsJson(mockEvents);
+        assertThat(params.keySet().size()).isEqualTo(1);
+        assertThat(params.get("log")).isEqualTo("jsonArrayToString");
+    }
+    
+    @Test
+    public void parseNetworkResponse_shouldReturnSuccessResponse() throws Exception {
+        NetworkResponse networkResponse = new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), new HashMap<String, String>(), false);
+
+        Response<Void> response = subject.parseNetworkResponse(networkResponse);
+
+        assertThat(response.isSuccess()).isTrue();
+    }
+
+    @Test
+    public void deliverResponse_shouldNotifyListener() throws Exception {
+        subject.deliverResponse(null);
+
+        verify(mockListener).onResponse();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/network/TrackingRequestTest.java b/mopub-sdk/src/test/java/com/mopub/network/TrackingRequestTest.java
index 20ac8c36..eb601572 100644
--- a/mopub-sdk/src/test/java/com/mopub/network/TrackingRequestTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/network/TrackingRequestTest.java
@@ -4,7 +4,6 @@
 import android.content.Context;
 
 import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.volley.RequestQueue;
 
 import org.junit.Before;
 import org.junit.Test;
@@ -20,7 +19,7 @@
 public class TrackingRequestTest {
 
     @Mock
-    private RequestQueue mockRequestQueue;
+    private MoPubRequestQueue mockRequestQueue;
     private Context context;
     private String url;
 
diff --git a/pom.xml b/pom.xml
index 8889a0d3..be233e50 100644
--- a/pom.xml
+++ b/pom.xml
@@ -38,7 +38,5 @@
     <modules>
         <module>mopub-sdk</module>
         <module>mopub-sample</module>
-        <module>robotium-sample</module>
-        <module>robotium-tests</module>
     </modules>
-</project>
\ No newline at end of file
+</project>
diff --git a/robotium-sample/pom.xml b/robotium-sample/pom.xml
index 3481483f..468cbf9b 100644
--- a/robotium-sample/pom.xml
+++ b/robotium-sample/pom.xml
@@ -22,7 +22,7 @@
             <groupId>com.mopub.mobileads</groupId>
             <artifactId>mopub-sdk</artifactId>
             <version>1.0.0-SNAPSHOT</version>
-            <type>jar</type>
+            <type>aar</type>
         </dependency>
 
 
@@ -86,13 +86,15 @@
                 </configuration>
             </plugin>
             <plugin>
-                <groupId>com.jayway.maven.plugins.android.generation2</groupId>
+                <groupId>com.simpligility.maven.plugins</groupId>
                 <artifactId>android-maven-plugin</artifactId>
-                <version>3.8.2</version>
+                <version>4.2.0</version>
                 <configuration>
+                    <androidManifestFile>AndroidManifest.xml</androidManifestFile>
+                    <resourceDirectory>res</resourceDirectory>
                     <sdk>
                         <!-- platform or api level (api level 4 = platform 1.6)-->
-                        <platform>19</platform>
+                        <platform>22</platform>
                     </sdk>
                     <undeployBeforeDeploy>true</undeployBeforeDeploy>
                 </configuration>
diff --git a/robotium-tests/pom.xml b/robotium-tests/pom.xml
index c3710758..99a113ce 100644
--- a/robotium-tests/pom.xml
+++ b/robotium-tests/pom.xml
@@ -27,8 +27,8 @@
 
         <dependency>
             <groupId>com.google.android.gms</groupId>
-            <artifactId>play-services</artifactId>
-            <version>5.0.89</version>
+            <artifactId>play-services-ads</artifactId>
+            <version>7.0.0</version>
             <type>aar</type>
         </dependency>
 
@@ -62,17 +62,16 @@
                 </configuration>
             </plugin>
             <plugin>
-                <groupId>com.jayway.maven.plugins.android.generation2</groupId>
+                <groupId>com.simpligility.maven.plugins</groupId>
                 <artifactId>android-maven-plugin</artifactId>
-                <version>3.8.2</version>
+                <version>4.2.0</version>
                 <configuration>
+                    <androidManifestFile>AndroidManifest.xml</androidManifestFile>
+                    <resourceDirectory>res</resourceDirectory>
                     <sdk>
                         <!-- platform or api level (api level 4 = platform 1.6)-->
-                        <platform>19</platform>
+                        <platform>22</platform>
                     </sdk>
-                    <test>
-                        <skip>true</skip>
-                    </test>
                     <undeployBeforeDeploy>true</undeployBeforeDeploy>
                 </configuration>
                 <extensions>true</extensions>
