diff --git a/CHANGELOG.md b/CHANGELOG.md
index a7979dd3..4f044652 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,19 @@
+## Version 4.15.0 (June 19, 2017)
+- The SDK now sends Advertising ID on Amazon devices when appropriate.
+- Fixed issue with Charles proxy in sample app for API 24+.
+- Bug fixes.
+
+## Version 4.14.0 (May 10, 2017)
+- Rewarded Ad reward callback `onRewardedVideoCompleted(Set<String>, MoPubReward)` is also triggered now on the client for server-side rewarding.
+- Added click callback for Rewarded Ads.
+  - Any implementors of `MoPubRewardedVideoListener` will now need to also implement `MoPubRewardedVideoListener#onRewardedVideoClicked(String)`.
+- MoPub Ads now expire after 4 hours of being unused.
+  - Interstitial and Rewarded ads served by MoPub will expire 4 hours after successfully loading, triggering a load failure with the new `EXPIRED` `MoPubErrorCode`.
+  - Cached Native Ad Placer ads now also expire in 4 hours.
+- Improved logging when attempting to show an ad that is not ready.
+- Updated build tools version to 25.0.2.
+- Bug fixes.
+
 ## Version 4.13.0 (March 23, 2017)
 
 - Updated AdColony Custom Events.
diff --git a/README.md b/README.md
index a64f9262..0f827bbe 100644
--- a/README.md
+++ b/README.md
@@ -27,7 +27,7 @@ The MoPub SDK is available via:
     }
 
     dependencies {
-        compile('com.mopub:mopub-sdk:4.13.0@aar') {
+        compile('com.mopub:mopub-sdk:4.15.0@aar') {
             transitive = true
         }
     }
@@ -48,27 +48,27 @@ The MoPub SDK is available via:
         // ... other project dependencies
 
         // For banners
-        compile('com.mopub:mopub-sdk-banner:4.13.0@aar') {
+        compile('com.mopub:mopub-sdk-banner:4.15.0@aar') {
             transitive = true
         }
         
         // For interstitials
-        compile('com.mopub:mopub-sdk-interstitial:4.13.0@aar') {
+        compile('com.mopub:mopub-sdk-interstitial:4.15.0@aar') {
             transitive = true
         }
 
         // For rewarded videos. This will automatically also include interstitials
-        compile('com.mopub:mopub-sdk-rewardedvideo:4.13.0@aar') {
+        compile('com.mopub:mopub-sdk-rewardedvideo:4.15.0@aar') {
             transitive = true
         }
 
         // For native static (images).
-        compile('com.mopub:mopub-sdk-native-static:4.13.0@aar') {
+        compile('com.mopub:mopub-sdk-native-static:4.15.0@aar') {
             transitive = true
         }
 
         // For native video. This will automatically also include native static
-        compile('com.mopub:mopub-sdk-native-video:4.13.0@aar') {
+        compile('com.mopub:mopub-sdk-native-video:4.15.0@aar') {
             transitive = true
         }
     }
@@ -96,11 +96,8 @@ The MoPub SDK is available via:
 ## New in this Version
 Please view the [changelog](https://github.com/mopub/mopub-android-sdk/blob/master/CHANGELOG.md) for a complete list of additions, fixes, and enhancements in the latest release.
 
-- Updated AdColony Custom Events.
-- Updated Unity Custom Events.
-- Added AdMob Custom Events:
-  - Native: `GooglePlayServicesAdRenderer` and `GooglePlayServicesNative`
-  - Rewarded Video: `GooglePlayServicesRewardedVideo`
+- The SDK now sends Advertising ID on Amazon devices when appropriate.
+- Fixed issue with Charles proxy in sample app for API 24+.
 - Bug fixes.
 
 ## Requirements
diff --git a/build.gradle b/build.gradle
index 97625136..66b99228 100644
--- a/build.gradle
+++ b/build.gradle
@@ -4,8 +4,8 @@ buildscript {
 	}
 
 	dependencies {
-		classpath 'com.novoda:bintray-release:0.3.4'
 		classpath 'com.android.tools.build:gradle:2.3.3'
+		classpath 'com.novoda:bintray-release:0.4.0'
 	}
 }
 
diff --git a/extras/src/com/mopub/mobileads/ChartboostInterstitial.java b/extras/src/com/mopub/mobileads/ChartboostInterstitial.java
index ace44241..82747718 100644
--- a/extras/src/com/mopub/mobileads/ChartboostInterstitial.java
+++ b/extras/src/com/mopub/mobileads/ChartboostInterstitial.java
@@ -14,7 +14,7 @@
 /**
  * A custom event for showing Chartboost interstitial ads.
  *
- * Certified with Chartboost 6.4.1
+ * Certified with Chartboost 6.6.3
  */
 class ChartboostInterstitial extends CustomEventInterstitial {
 
diff --git a/extras/src/com/mopub/mobileads/ChartboostRewardedVideo.java b/extras/src/com/mopub/mobileads/ChartboostRewardedVideo.java
index 08f90ca8..b41dd113 100644
--- a/extras/src/com/mopub/mobileads/ChartboostRewardedVideo.java
+++ b/extras/src/com/mopub/mobileads/ChartboostRewardedVideo.java
@@ -16,7 +16,7 @@
 /**
  * A custom event for showing Chartboost rewarded videos.
  *
- * Certified with Chartboost 6.4.1
+ * Certified with Chartboost 6.6.3
  */
 public class ChartboostRewardedVideo extends CustomEventRewardedVideo {
     @NonNull private static final LifecycleListener sLifecycleListener =
diff --git a/extras/src/com/mopub/mobileads/ChartboostShared.java b/extras/src/com/mopub/mobileads/ChartboostShared.java
index cc722c38..f9e958f6 100644
--- a/extras/src/com/mopub/mobileads/ChartboostShared.java
+++ b/extras/src/com/mopub/mobileads/ChartboostShared.java
@@ -27,7 +27,7 @@
 /**
  * Shared infrastructure for initializing the Chartboost SDK when mediated by MoPub
  *
- * Certified with Chartboost 6.4.1
+ * Certified with Chartboost 6.6.3
  */
 public class ChartboostShared {
     private static volatile ChartboostSingletonDelegate sDelegate = new ChartboostSingletonDelegate();
diff --git a/extras/src/com/mopub/mobileads/FacebookBanner.java b/extras/src/com/mopub/mobileads/FacebookBanner.java
index b1954853..4d60a635 100644
--- a/extras/src/com/mopub/mobileads/FacebookBanner.java
+++ b/extras/src/com/mopub/mobileads/FacebookBanner.java
@@ -16,7 +16,8 @@
 import java.util.Map;
 
 /**
- * Tested with Facebook SDK 4.15.0.
+ * Please reference the Supported Mediation Partner page at http://bit.ly/2mqsuFH for the
+ * latest version and ad format certifications.
  */
 public class FacebookBanner extends CustomEventBanner implements AdListener {
     public static final String PLACEMENT_ID_KEY = "placement_id";
@@ -102,6 +103,11 @@ public void onAdClicked(Ad ad) {
         mBannerListener.onBannerClicked();
     }
 
+    @Override
+    public void onLoggingImpression(Ad ad) {
+        Log.d("MoPub", "Facebook banner ad logged impression.");
+    }
+
     private boolean serverExtrasAreValid(final Map<String, String> serverExtras) {
         final String placementId = serverExtras.get(PLACEMENT_ID_KEY);
         return (placementId != null && placementId.length() > 0);
diff --git a/extras/src/com/mopub/mobileads/FacebookInterstitial.java b/extras/src/com/mopub/mobileads/FacebookInterstitial.java
index 06d4b11f..34fc4ad7 100644
--- a/extras/src/com/mopub/mobileads/FacebookInterstitial.java
+++ b/extras/src/com/mopub/mobileads/FacebookInterstitial.java
@@ -11,7 +11,8 @@
 import java.util.Map;
 
 /**
- * Tested with Facebook SDK 4.15.0.
+ * Please reference the Supported Mediation Partner page at http://bit.ly/2mqsuFH for the
+ * latest version and ad format certifications.
  */
 public class FacebookInterstitial extends CustomEventInterstitial implements InterstitialAdListener {
     public static final String PLACEMENT_ID_KEY = "placement_id";
@@ -99,6 +100,11 @@ public void onAdClicked(final Ad ad) {
         mInterstitialListener.onInterstitialClicked();
     }
 
+    @Override
+    public void onLoggingImpression(Ad ad) {
+        Log.d("MoPub", "Facebook interstitial ad logged impression.");
+    }
+
     @Override
     public void onInterstitialDismissed(final Ad ad) {
         Log.d("MoPub", "Facebook interstitial ad dismissed.");
diff --git a/extras/src/com/mopub/mobileads/FlurryAgentWrapper.java b/extras/src/com/mopub/mobileads/FlurryAgentWrapper.java
index 421a7248..dabecdf1 100644
--- a/extras/src/com/mopub/mobileads/FlurryAgentWrapper.java
+++ b/extras/src/com/mopub/mobileads/FlurryAgentWrapper.java
@@ -11,7 +11,7 @@
 import com.flurry.android.FlurryAgentListener;
 
 /**
- * Tested with Flurry 6.5.0
+ * Certified with Flurry 7.0.0
  */
 public final class FlurryAgentWrapper {
     public static final String PARAM_API_KEY = "apiKey";
diff --git a/extras/src/com/mopub/mobileads/FlurryCustomEventBanner.java b/extras/src/com/mopub/mobileads/FlurryCustomEventBanner.java
index 61397ac4..56646085 100644
--- a/extras/src/com/mopub/mobileads/FlurryCustomEventBanner.java
+++ b/extras/src/com/mopub/mobileads/FlurryCustomEventBanner.java
@@ -18,7 +18,7 @@
 import static com.mopub.mobileads.MoPubErrorCode.UNSPECIFIED;
 
 /**
- * Tested with Flurry 6.5.0
+ * Certified with Flurry 7.0.0
  */
 class FlurryCustomEventBanner extends com.mopub.mobileads.CustomEventBanner {
     private static final String LOG_TAG = FlurryCustomEventBanner.class.getSimpleName();
@@ -96,7 +96,9 @@ protected void onInvalidate() {
     }
 
     private boolean validateExtras(final Map<String, String> serverExtras) {
-        if (serverExtras == null) { return false; }
+        if (serverExtras == null) {
+            return false;
+        }
 
         final String flurryApiKey = serverExtras.get(FlurryAgentWrapper.PARAM_API_KEY);
         final String flurryAdSpace = serverExtras.get(FlurryAgentWrapper.PARAM_AD_SPACE_NAME);
@@ -150,10 +152,6 @@ public void onCloseFullscreen(FlurryAdBanner adBanner) {
         @Override
         public void onAppExit(FlurryAdBanner adBanner) {
             Log.d(LOG_TAG, "onAppExit: Flurry banner ad exited app");
-
-            if (mListener != null) {
-                mListener.onLeaveApplication();
-            }
         }
 
         @Override
@@ -179,7 +177,7 @@ public void onError(FlurryAdBanner adBanner, FlurryAdErrorType adErrorType,
                     "Error type: %s. Error code: %s", adErrorType.toString(), errorCode));
 
             if (mListener != null) {
-                switch(adErrorType) {
+                switch (adErrorType) {
                     case FETCH:
                         mListener.onBannerFailed(NETWORK_NO_FILL);
                         return;
diff --git a/extras/src/com/mopub/mobileads/FlurryCustomEventInterstitial.java b/extras/src/com/mopub/mobileads/FlurryCustomEventInterstitial.java
index d2923675..51f7d54d 100644
--- a/extras/src/com/mopub/mobileads/FlurryCustomEventInterstitial.java
+++ b/extras/src/com/mopub/mobileads/FlurryCustomEventInterstitial.java
@@ -17,7 +17,7 @@
 import static com.mopub.mobileads.MoPubErrorCode.UNSPECIFIED;
 
 /**
- * Tested with Flurry 6.5.0
+ * Certified with Flurry 7.0.0
  */
 class FlurryCustomEventInterstitial extends com.mopub.mobileads.CustomEventInterstitial {
     private static final String LOG_TAG = FlurryCustomEventInterstitial.class.getSimpleName();
@@ -102,7 +102,9 @@ protected void showInterstitial() {
     }
 
     private boolean validateExtras(final Map<String, String> serverExtras) {
-        if (serverExtras == null) { return false; }
+        if (serverExtras == null) {
+            return false;
+        }
 
         final String flurryApiKey = serverExtras.get(FlurryAgentWrapper.PARAM_API_KEY);
         final String flurryAdSpace = serverExtras.get(FlurryAgentWrapper.PARAM_AD_SPACE_NAME);
@@ -154,10 +156,6 @@ public void onClose(FlurryAdInterstitial adInterstitial) {
         @Override
         public void onAppExit(FlurryAdInterstitial adInterstitial) {
             Log.d(LOG_TAG, "onAppExit: Flurry interstitial ad exited app");
-
-            if (mListener != null) {
-                mListener.onLeaveApplication();
-            }
         }
 
         @Override
@@ -183,7 +181,7 @@ public void onError(FlurryAdInterstitial adInterstitial, FlurryAdErrorType adErr
                     "Error type: %s. Error code: %s", adErrorType.toString(), errorCode));
 
             if (mListener != null) {
-                switch(adErrorType) {
+                switch (adErrorType) {
                     case FETCH:
                         mListener.onInterstitialFailed(NETWORK_NO_FILL);
                         return;
diff --git a/extras/src/com/mopub/mobileads/UnityRewardedVideo.java b/extras/src/com/mopub/mobileads/UnityRewardedVideo.java
index feaea2cf..ecc76e2b 100644
--- a/extras/src/com/mopub/mobileads/UnityRewardedVideo.java
+++ b/extras/src/com/mopub/mobileads/UnityRewardedVideo.java
@@ -16,6 +16,9 @@
 
 /**
  * A custom event for showing Unity rewarded videos.
+ *
+ * Please reference the Supported Mediation Partner page at http://bit.ly/2mqsuFH for the
+ * latest version and ad format certifications.
  */
 public class UnityRewardedVideo extends CustomEventRewardedVideo {
     private static final String GAME_ID_KEY = "gameId";
@@ -145,6 +148,7 @@ public void onUnityAdsStart(String placementId) {
 
         @Override
         public void onUnityAdsFinish(String placementId, UnityAds.FinishState finishState) {
+            MoPubLog.d("Unity rewarded video finished with finish state " + finishState);
             if (finishState == UnityAds.FinishState.ERROR) {
                 MoPubRewardedVideoManager.onRewardedVideoPlaybackError(
                         UnityRewardedVideo.class,
@@ -157,12 +161,8 @@ public void onUnityAdsFinish(String placementId, UnityAds.FinishState finishStat
                         sPlacementId,
                         MoPubReward.success(MoPubReward.NO_REWARD_LABEL, MoPubReward.NO_REWARD_AMOUNT));
                 MoPubLog.d("Unity rewarded video completed for placement " + placementId);
-            } else {
-                MoPubRewardedVideoManager.onRewardedVideoCompleted(
-                        UnityRewardedVideo.class,
-                        placementId,
-                        MoPubReward.failure());
-                MoPubLog.d("Unity rewarded video skipped for placement " + placementId);
+            } else if (finishState == UnityAds.FinishState.SKIPPED) {
+                MoPubLog.d("Unity rewarded video was skipped; no reward will be given");
             }
             MoPubRewardedVideoManager.onRewardedVideoClosed(UnityRewardedVideo.class, sPlacementId);
             UnityAds.setListener(null);
diff --git a/extras/src/com/mopub/nativeads/FacebookAdRenderer.java b/extras/src/com/mopub/nativeads/FacebookAdRenderer.java
index c054c9a9..5a345081 100644
--- a/extras/src/com/mopub/nativeads/FacebookAdRenderer.java
+++ b/extras/src/com/mopub/nativeads/FacebookAdRenderer.java
@@ -19,6 +19,8 @@
  * Include this class if you want to use Facebook native video ads. This renderer handles Facebook
  * static and video native ads. This will automatically replace the main image view with the
  * Facebook MediaView that handles showing the main asset.
+ * Please reference the Supported Mediation Partner page at http://bit.ly/2mqsuFH for the
+ * latest version and ad format certifications.
  */
 public class FacebookAdRenderer implements MoPubAdRenderer<FacebookNative.FacebookVideoEnabledNativeAd> {
     private final ViewBinder mViewBinder;
@@ -206,4 +208,3 @@ public boolean isMainImageViewInRelativeView() {
         }
     }
 }
-
diff --git a/extras/src/com/mopub/nativeads/FacebookNative.java b/extras/src/com/mopub/nativeads/FacebookNative.java
index c6b1ee58..c15bc2eb 100644
--- a/extras/src/com/mopub/nativeads/FacebookNative.java
+++ b/extras/src/com/mopub/nativeads/FacebookNative.java
@@ -6,7 +6,6 @@
 import com.facebook.ads.Ad;
 import com.facebook.ads.AdError;
 import com.facebook.ads.AdListener;
-import com.facebook.ads.ImpressionListener;
 import com.facebook.ads.MediaView;
 import com.facebook.ads.NativeAd;
 import com.facebook.ads.NativeAd.Rating;
@@ -21,10 +20,12 @@
 import static com.mopub.nativeads.NativeImageHelper.preCacheImages;
 
 /**
- * Tested with Facebook SDK 4.15.0. FacebookAdRenderer is also necessary in order to show video ads.
+ * FacebookAdRenderer is also necessary in order to show video ads.
  * Video ads will only be shown if VIDEO_ENABLED is set to true or a server configuration
  * "video_enabled" flag is set to true. The server configuration will override the local
  * configuration.
+ * Please reference the Supported Mediation Partner page at http://bit.ly/2mqsuFH for the
+ * latest version and ad format certifications.
  */
 public class FacebookNative extends CustomEventNative {
     private static final String PLACEMENT_ID_KEY = "placement_id";
@@ -126,7 +127,7 @@ private boolean extrasAreValid(final Map<String, String> serverExtras) {
         return (placementId != null && placementId.length() > 0);
     }
 
-    static class FacebookStaticNativeAd extends StaticNativeAd implements AdListener, ImpressionListener {
+    static class FacebookStaticNativeAd extends StaticNativeAd implements AdListener {
         private static final String SOCIAL_CONTEXT_FOR_AD = "socialContextForAd";
 
         private final Context mContext;
@@ -143,7 +144,6 @@ private boolean extrasAreValid(final Map<String, String> serverExtras) {
 
         void loadAd() {
             mNativeAd.setAdListener(this);
-            mNativeAd.setImpressionListener(this);
             mNativeAd.loadAd();
         }
 
@@ -221,7 +221,6 @@ public void onAdClicked(final Ad ad) {
             notifyAdClicked();
         }
 
-        // ImpressionListener
         @Override
         public void onLoggingImpression(final Ad ad) {
             notifyAdImpressed();
@@ -253,7 +252,7 @@ private Double getDoubleRating(final Rating rating) {
     }
 
 
-    static class FacebookVideoEnabledNativeAd extends BaseNativeAd implements AdListener, ImpressionListener {
+    static class FacebookVideoEnabledNativeAd extends BaseNativeAd implements AdListener {
         private static final String SOCIAL_CONTEXT_FOR_AD = "socialContextForAd";
 
         static final double MIN_STAR_RATING = 0;
@@ -278,7 +277,6 @@ private Double getDoubleRating(final Rating rating) {
 
         void loadAd() {
             mNativeAd.setAdListener(this);
-            mNativeAd.setImpressionListener(this);
             mNativeAd.loadAd();
         }
 
@@ -407,7 +405,6 @@ public void onAdClicked(final Ad ad) {
             notifyAdClicked();
         }
 
-        // ImpressionListener
         @Override
         public void onLoggingImpression(final Ad ad) {
             notifyAdImpressed();
@@ -450,7 +447,7 @@ final public Object getExtra(final String key) {
             return new HashMap<String, Object>(mExtras);
         }
 
-        final public void addExtra( final String key, final Object value) {
+        final public void addExtra(final String key, final Object value) {
             if (!Preconditions.NoThrow.checkNotNull(key, "addExtra key is not allowed to be null")) {
                 return;
             }
diff --git a/extras/src/com/mopub/nativeads/FlurryBaseNativeAd.java b/extras/src/com/mopub/nativeads/FlurryBaseNativeAd.java
index 3fe494e1..371042d1 100644
--- a/extras/src/com/mopub/nativeads/FlurryBaseNativeAd.java
+++ b/extras/src/com/mopub/nativeads/FlurryBaseNativeAd.java
@@ -7,7 +7,7 @@
 import java.util.Map;
 
 /**
- * Tested with Flurry 6.5.0
+ * Certified with Flurry 7.0.0
  */
 public interface FlurryBaseNativeAd {
 
diff --git a/extras/src/com/mopub/nativeads/FlurryCustomEventNative.java b/extras/src/com/mopub/nativeads/FlurryCustomEventNative.java
index ddcc9639..20ad9646 100644
--- a/extras/src/com/mopub/nativeads/FlurryCustomEventNative.java
+++ b/extras/src/com/mopub/nativeads/FlurryCustomEventNative.java
@@ -22,7 +22,7 @@
 import java.util.Map;
 
 /**
- * Tested with Flurry 6.5.0
+ * Certified with Flurry 7.0.0
  */
 public final class FlurryCustomEventNative extends CustomEventNative {
 
diff --git a/extras/src/com/mopub/nativeads/FlurryNativeAdRenderer.java b/extras/src/com/mopub/nativeads/FlurryNativeAdRenderer.java
index c73e4e6e..149725f9 100644
--- a/extras/src/com/mopub/nativeads/FlurryNativeAdRenderer.java
+++ b/extras/src/com/mopub/nativeads/FlurryNativeAdRenderer.java
@@ -14,7 +14,7 @@
  * specified in the FlurryNativeViewHolder.videoView to show a video. If a video is not available,
  * this will still use the mainImageView.
  *
- * Tested with Flurry 6.5.0
+ * Certified with Flurry 7.0.0
  */
 public class FlurryNativeAdRenderer implements
         MoPubAdRenderer<FlurryCustomEventNative.FlurryVideoEnabledNativeAd> {
diff --git a/extras/src/com/mopub/nativeads/FlurryViewBinder.java b/extras/src/com/mopub/nativeads/FlurryViewBinder.java
index 0699f418..c86082cf 100644
--- a/extras/src/com/mopub/nativeads/FlurryViewBinder.java
+++ b/extras/src/com/mopub/nativeads/FlurryViewBinder.java
@@ -3,7 +3,7 @@
 import android.support.annotation.NonNull;
 
 /**
- * Tested with Flurry 6.5.0
+ * Certified with Flurry 7.0.0
  */
 public class FlurryViewBinder {
     ViewBinder staticViewBinder;
diff --git a/mopub-sample/AndroidManifest.xml b/mopub-sample/AndroidManifest.xml
index e29019b9..4773efcd 100644
--- a/mopub-sample/AndroidManifest.xml
+++ b/mopub-sample/AndroidManifest.xml
@@ -1,10 +1,10 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
       package="com.mopub.simpleadsdemo"
-      android:versionCode="50"
-      android:versionName="4.13.0">
+      android:versionCode="52"
+      android:versionName="4.15.0">
     <uses-sdk android:minSdkVersion="16"
-              android:targetSdkVersion="23"/>
+              android:targetSdkVersion="24"/>
 
     <uses-permission android:name="android.permission.INTERNET" />
     <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
@@ -13,7 +13,8 @@
     <!-- For MRAID 2 -->
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
 
-    <application android:icon="@drawable/icon" android:label="@string/app_name">
+    <application android:icon="@drawable/icon" android:label="@string/app_name"
+                 android:networkSecurityConfig="@xml/network_security_config">
 	    <activity android:name="com.mopub.simpleadsdemo.MoPubSampleActivity"
 	            android:label="@string/app_name"
                 android:configChanges="orientation|screenSize">
diff --git a/mopub-sample/build.gradle b/mopub-sample/build.gradle
index 3524a58a..516d5d2e 100644
--- a/mopub-sample/build.gradle
+++ b/mopub-sample/build.gradle
@@ -9,18 +9,18 @@ apply plugin: 'com.android.application'
 
 project.group = 'com.mopub'
 project.description = '''MoPub Sample App'''
-project.version = '4.13.0'
+project.version = '4.15.0'
 
 android {
-    compileSdkVersion 23
-    buildToolsVersion '23.0.2'
+    compileSdkVersion 24
+    buildToolsVersion '25.0.2'
     lintOptions { abortOnError false }
 
     defaultConfig {
-        versionCode 50
+        versionCode 52
         versionName version
         minSdkVersion 16
-        targetSdkVersion 23
+        targetSdkVersion 24
     }
 
     buildTypes {
@@ -55,8 +55,8 @@ android {
 }
 
 dependencies {
-    compile 'com.android.support:support-v4:23.1.1'
+    compile 'com.android.support:support-v4:24.0.0'
     compile 'com.google.android.gms:play-services-ads:9.4.0'
-    compile 'com.android.support:recyclerview-v7:23.1.1'
+    compile 'com.android.support:recyclerview-v7:24.0.0'
     compile project(':mopub-sdk')
 }
diff --git a/mopub-sample/res/xml/network_security_config.xml b/mopub-sample/res/xml/network_security_config.xml
new file mode 100644
index 00000000..ed36e236
--- /dev/null
+++ b/mopub-sample/res/xml/network_security_config.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<network-security-config>
+    <base-config>
+        <trust-anchors>
+            <certificates src="system"/>
+        </trust-anchors>
+    </base-config>
+    <debug-overrides>
+        <trust-anchors>
+            <certificates src="user"/>
+        </trust-anchors>
+    </debug-overrides>
+</network-security-config>
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/InterstitialDetailFragment.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/InterstitialDetailFragment.java
index ff1337ac..8c2fb463 100644
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/InterstitialDetailFragment.java
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/InterstitialDetailFragment.java
@@ -74,6 +74,7 @@ public void onInterstitialLoaded(MoPubInterstitial interstitial) {
 
     @Override
     public void onInterstitialFailed(MoPubInterstitial interstitial, MoPubErrorCode errorCode) {
+        mShowButton.setEnabled(false);
         final String errorMessage = (errorCode != null) ? errorCode.toString() : "";
         logToast(getActivity(), "Interstitial failed to load: " + errorMessage);
     }
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/RewardedVideoDetailFragment.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/RewardedVideoDetailFragment.java
index fc637371..2e9ddebf 100644
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/RewardedVideoDetailFragment.java
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/RewardedVideoDetailFragment.java
@@ -159,6 +159,13 @@ public void onRewardedVideoPlaybackError(@NonNull final String adUnitId, @NonNul
         }
     }
 
+    @Override
+    public void onRewardedVideoClicked(@NonNull final String adUnitId) {
+        if (adUnitId.equals(mAdUnitId)) {
+            logToast(getActivity(), "Rewarded video clicked.");
+        }
+    }
+
     @Override
     public void onRewardedVideoClosed(@NonNull final String adUnitId) {
         if (adUnitId.equals(mAdUnitId)) {
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/ClientMetadata.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/ClientMetadata.java
index d6c76b92..1317ab36 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/ClientMetadata.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/ClientMetadata.java
@@ -1,5 +1,6 @@
 package com.mopub.common;
 
+import android.content.ContentResolver;
 import android.content.Context;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageInfo;
@@ -11,6 +12,7 @@
 import android.os.Build;
 import android.provider.Settings;
 import android.telephony.TelephonyManager;
+import android.text.TextUtils;
 
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.util.DeviceUtils;
@@ -36,6 +38,7 @@
     private static final String IFA_PREFIX = "ifa:";
     private static final String SHA_PREFIX = "sha:";
     private static final int UNKNOWN_NETWORK = -1;
+    private static final int MISSING_VALUE = -1;
 
     private String mNetworkOperatorForUrl;
     private final String mNetworkOperator;
@@ -184,8 +187,28 @@ public ClientMetadata(Context context) {
             mSimOperatorName = null;
         }
 
-        // Get the device ID. This will be replaced later when the Play Services callbacks complete.
-        mUdid = getDeviceIdFromContext(mContext);
+        setAmazonAdvertisingInfo();
+        if (!mAdvertisingInfoSet) {
+            // Amazon ad info is not supported on this device, so get the device ID.
+            // This will be replaced later when the Play Services callbacks complete.
+            mUdid = getDeviceIdFromContext(mContext);
+        }
+
+    }
+
+    // For Amazon tablets running Fire OS 5.1+ and TV devices running Fire OS 5.2.1.1+, the
+    // advertising info is available as System Settings.
+    // See https://developer.amazon.com/public/solutions/devices/fire-tv/docs/fire-tv-advertising-id
+    @VisibleForTesting
+    protected void setAmazonAdvertisingInfo() {
+        ContentResolver resolver = mContext.getContentResolver();
+        int limitAdTracking = Settings.Secure.getInt(resolver, "limit_ad_tracking", MISSING_VALUE);
+        String advertisingId = Settings.Secure.getString(resolver, "advertising_id");
+
+        if (limitAdTracking != MISSING_VALUE && !TextUtils.isEmpty(advertisingId)) {
+            boolean doNotTrack = limitAdTracking != 0;
+            setAdvertisingInfo(advertisingId, doNotTrack);
+        }
     }
 
     private static String getAppVersionFromContext(Context context) {
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/Constants.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/Constants.java
index 543ea89b..b654dc42 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/Constants.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/Constants.java
@@ -19,6 +19,9 @@ private Constants() {}
     public static final int SIX_SECONDS_MILLIS = 6 * 1000;
     public static final int TEN_SECONDS_MILLIS = 10 * 1000;
     public static final int THIRTY_SECONDS_MILLIS = 30 * 1000;
+    public static final int FOUR_HOURS_MILLIS = 4 * 60 * 60 * 1000;
+
+    public static final int AD_EXPIRATION_DELAY = FOUR_HOURS_MILLIS;
 
     public static final int TEN_MB = 10 * 1024 * 1024;
 
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/MoPub.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/MoPub.java
index f9025f68..9be4cd82 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/MoPub.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/MoPub.java
@@ -11,10 +11,41 @@
 import java.lang.reflect.Method;
 
 public class MoPub {
-    public static final String SDK_VERSION = "4.13.0";
+    public static final String SDK_VERSION = "4.15.0";
 
     public enum LocationAwareness { NORMAL, TRUNCATED, DISABLED }
 
+    /**
+     * Browser agent to handle URIs with scheme HTTP or HTTPS
+     */
+    public enum BrowserAgent {
+        /**
+         * MoPub's in-app browser
+         */
+        IN_APP,
+
+        /**
+         * Default browser application on device
+         */
+        NATIVE;
+
+        /**
+         * Maps header value from MoPub's AdServer to browser agent:
+         * 0 is MoPub's in-app browser (IN_APP), and 1 is device's default browser (NATIVE).
+         * For null or all other undefined values, returns default browser agent IN_APP.
+         * @param browserAgent Integer header value from MoPub's AdServer.
+         * @return IN_APP for 0, NATIVE for 1, and IN_APP for null or all other undefined values.
+         */
+        @NonNull
+        public static BrowserAgent fromHeader(@Nullable final Integer browserAgent) {
+            if (browserAgent == null) {
+                return IN_APP;
+            }
+
+            return browserAgent == 1 ? NATIVE : IN_APP;
+        }
+    }
+
     private static final String MOPUB_REWARDED_VIDEOS =
             "com.mopub.mobileads.MoPubRewardedVideos";
     private static final String MOPUB_REWARDED_VIDEO_MANAGER =
@@ -26,18 +57,26 @@
 
     private static final int DEFAULT_LOCATION_PRECISION = 6;
     private static final long DEFAULT_LOCATION_REFRESH_TIME_MILLIS = 60 * 1000;
-    private static volatile LocationAwareness sLocationLocationAwareness = LocationAwareness.NORMAL;
+
+    @NonNull private static volatile LocationAwareness sLocationAwareness = LocationAwareness.NORMAL;
     private static volatile int sLocationPrecision = DEFAULT_LOCATION_PRECISION;
     private static volatile long sMinimumLocationRefreshTimeMillis = DEFAULT_LOCATION_REFRESH_TIME_MILLIS;
+    @NonNull private static volatile BrowserAgent sBrowserAgent = BrowserAgent.IN_APP;
+    private static volatile boolean sIsBrowserAgentOverriddenByClient = false;
     private static boolean sSearchedForUpdateActivityMethod = false;
     @Nullable private static Method sUpdateActivityMethod;
 
+    @NonNull
     public static LocationAwareness getLocationAwareness() {
-        return sLocationLocationAwareness;
+        Preconditions.checkNotNull(sLocationAwareness);
+
+        return sLocationAwareness;
     }
 
-    public static void setLocationAwareness(LocationAwareness locationAwareness) {
-        sLocationLocationAwareness = locationAwareness;
+    public static void setLocationAwareness(@NonNull final LocationAwareness locationAwareness) {
+        Preconditions.checkNotNull(locationAwareness);
+
+        sLocationAwareness = locationAwareness;
     }
 
     public static int getLocationPrecision() {
@@ -61,6 +100,42 @@ public static long getMinimumLocationRefreshTimeMillis() {
         return sMinimumLocationRefreshTimeMillis;
     }
 
+    public static void setBrowserAgent(@NonNull final BrowserAgent browserAgent) {
+        Preconditions.checkNotNull(browserAgent);
+
+        sBrowserAgent = browserAgent;
+        sIsBrowserAgentOverriddenByClient = true;
+    }
+
+    public static void setBrowserAgentFromAdServer(
+            @NonNull final BrowserAgent adServerBrowserAgent) {
+        Preconditions.checkNotNull(adServerBrowserAgent);
+
+        if (sIsBrowserAgentOverriddenByClient) {
+            MoPubLog.w("Browser agent already overridden by client with value " + sBrowserAgent);
+        } else {
+            sBrowserAgent = adServerBrowserAgent;
+        }
+    }
+
+    @NonNull
+    public static BrowserAgent getBrowserAgent() {
+        Preconditions.checkNotNull(sBrowserAgent);
+
+        return sBrowserAgent;
+    }
+
+    @VisibleForTesting
+    static boolean isBrowserAgentOverriddenByClient() {
+        return sIsBrowserAgentOverriddenByClient;
+    }
+
+    @VisibleForTesting
+    @Deprecated
+    public static void resetBrowserAgent() {
+        sBrowserAgent = BrowserAgent.IN_APP;
+        sIsBrowserAgentOverriddenByClient = false;
+    }
 
     //////// MoPub LifecycleListener messages ////////
 
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/MoPubBrowser.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/MoPubBrowser.java
index 55b24452..303f9539 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/MoPubBrowser.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/MoPubBrowser.java
@@ -200,6 +200,7 @@ protected void onDestroy() {
                 .build());
     }
 
+    @SuppressWarnings("ResourceType") // Using XML resources causes issues in Unity
     private View getMoPubBrowserView() {
         LinearLayout moPubBrowserView = new LinearLayout(this);
         LinearLayout.LayoutParams browserLayoutParams = new LinearLayout.LayoutParams(MATCH_PARENT, MATCH_PARENT);
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/UrlAction.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/UrlAction.java
index 7bd4c068..565239a8 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/UrlAction.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/UrlAction.java
@@ -7,6 +7,7 @@
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
 
+import com.mopub.common.MoPub.BrowserAgent;
 import com.mopub.common.event.BaseEvent;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.util.Intents;
@@ -18,6 +19,7 @@
 
 import static com.mopub.common.Constants.HTTP;
 import static com.mopub.common.Constants.HTTPS;
+import static com.mopub.common.MoPub.getBrowserAgent;
 import static com.mopub.network.TrackingRequest.makeTrackingHttpRequest;
 
 /**
@@ -102,7 +104,13 @@ protected void performAction(
     /* 3 */ OPEN_NATIVE_BROWSER(true) {
         @Override
         public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
-            return "mopubnativebrowser".equalsIgnoreCase(uri.getScheme());
+            final String scheme = uri.getScheme();
+
+            if (HTTP.equalsIgnoreCase(scheme) || HTTPS.equalsIgnoreCase(scheme)) {
+                return getBrowserAgent() == BrowserAgent.NATIVE;
+            }
+
+            return "mopubnativebrowser".equalsIgnoreCase(scheme);
         }
 
         @Override
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/logging/MoPubLog.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/logging/MoPubLog.java
index fa140548..0eac6314 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/logging/MoPubLog.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/logging/MoPubLog.java
@@ -127,7 +127,7 @@ private static void addHandler(@NonNull final Logger logger,
         }
 
         @Override
-        @SuppressLint("LogTagMismatch")
+        @SuppressWarnings({"LogTagMismatch", "WrongConstant"})
         public void publish(final LogRecord logRecord) {
             if (isLoggable(logRecord)) {
                 final int priority;
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/Intents.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/Intents.java
index 3f175b00..f9a1b58d 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/Intents.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/Intents.java
@@ -14,6 +14,7 @@
 import android.text.TextUtils;
 
 import com.mopub.common.Constants;
+import com.mopub.common.MoPub.BrowserAgent;
 import com.mopub.common.MoPubBrowser;
 import com.mopub.common.Preconditions;
 import com.mopub.common.UrlAction;
@@ -24,6 +25,7 @@
 import java.util.List;
 
 import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
+import static com.mopub.common.MoPub.getBrowserAgent;
 
 public class Intents {
 
@@ -90,17 +92,38 @@ public static boolean deviceCanHandleIntent(@NonNull final Context context,
      *
      * @param uri The Native Browser Scheme URL to open in the external browser.
      * @return An Intent that will open an app-external browser taking the user to a page specified
-     * in the query parameter of the passed-in url
-     * @throws UrlParseException if the provided url has an invalid format or is non-hierarchical
+     * in the query parameter of the passed-in url.
+     * @throws UrlParseException if the provided url has an invalid format or is non-hierarchical.
      */
     public static Intent intentForNativeBrowserScheme(@NonNull final Uri uri)
             throws UrlParseException {
         Preconditions.checkNotNull(uri);
 
         if (!UrlAction.OPEN_NATIVE_BROWSER.shouldTryHandlingUrl(uri)) {
-            throw new UrlParseException("URL does not have mopubnativebrowser:// scheme.");
+            String supportedSchemes = "mopubnativebrowser://";
+            if (getBrowserAgent() == BrowserAgent.NATIVE) {
+                supportedSchemes += ", http://, or https://";
+            }
+            throw new UrlParseException("URI does not have " + supportedSchemes + " scheme.");
+        }
+
+        if ("mopubnativebrowser".equalsIgnoreCase(uri.getScheme())) {
+            final Uri intentUri = parseMoPubNativeBrowserUri(uri);
+            return new Intent(Intent.ACTION_VIEW, intentUri);
+        }
+
+        if (getBrowserAgent() == BrowserAgent.NATIVE) {
+            return new Intent(Intent.ACTION_VIEW, uri);
         }
 
+        // Should never get here
+        throw new UrlParseException("Invalid URI: " + uri.toString());
+    }
+
+    private static Uri parseMoPubNativeBrowserUri(@NonNull final Uri uri)
+            throws UrlParseException {
+        Preconditions.checkNotNull(uri);
+
         if (!"navigate".equals(uri.getHost())) {
             throw new UrlParseException("URL missing 'navigate' host parameter.");
         }
@@ -119,8 +142,7 @@ public static Intent intentForNativeBrowserScheme(@NonNull final Uri uri)
             throw new UrlParseException("URL missing 'url' query parameter.");
         }
 
-        final Uri intentUri = Uri.parse(urlToOpenInNativeBrowser);
-        return new Intent(Intent.ACTION_VIEW, intentUri);
+        return Uri.parse(urlToOpenInNativeBrowser);
     }
 
     /**
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/ResponseHeader.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/ResponseHeader.java
index d8aded62..fddc88a8 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/ResponseHeader.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/ResponseHeader.java
@@ -25,6 +25,7 @@
     LOCATION("Location"),
     USER_AGENT("User-Agent"),
     ACCEPT_LANGUAGE("Accept-Language"),
+    BROWSER_AGENT("X-Browser-Agent"),
 
     // Native Video fields
     PLAY_VISIBLE_PERCENT("X-Play-Visible-Percent"),
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/AdTypeTranslator.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/AdTypeTranslator.java
index 8a827f7b..025571bb 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/AdTypeTranslator.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/AdTypeTranslator.java
@@ -14,33 +14,50 @@
 public class AdTypeTranslator {
     public enum CustomEventType {
         // "Special" custom events that we let people choose in the UI.
-        GOOGLE_PLAY_SERVICES_BANNER("admob_native_banner", "com.mopub.mobileads.GooglePlayServicesBanner"),
-        GOOGLE_PLAY_SERVICES_INTERSTITIAL("admob_full_interstitial", "com.mopub.mobileads.GooglePlayServicesInterstitial"),
-        MILLENNIAL_BANNER("millennial_native_banner", "com.mopub.mobileads.MillennialBanner"),
-        MILLENNIAL_INTERSTITIAL("millennial_full_interstitial", "com.mopub.mobileads.MillennialInterstitial"),
+        GOOGLE_PLAY_SERVICES_BANNER("admob_native_banner",
+                "com.mopub.mobileads.GooglePlayServicesBanner", false),
+        GOOGLE_PLAY_SERVICES_INTERSTITIAL("admob_full_interstitial",
+                "com.mopub.mobileads.GooglePlayServicesInterstitial", false),
+        MILLENNIAL_BANNER("millennial_native_banner",
+                "com.mopub.mobileads.MillennialBanner", false),
+        MILLENNIAL_INTERSTITIAL("millennial_full_interstitial",
+                "com.mopub.mobileads.MillennialInterstitial", false),
 
         // MoPub-specific custom events.
-        MRAID_BANNER("mraid_banner", "com.mopub.mraid.MraidBanner"),
-        MRAID_INTERSTITIAL("mraid_interstitial", "com.mopub.mraid.MraidInterstitial"),
-        HTML_BANNER("html_banner", "com.mopub.mobileads.HtmlBanner"),
-        HTML_INTERSTITIAL("html_interstitial", "com.mopub.mobileads.HtmlInterstitial"),
-        VAST_VIDEO_INTERSTITIAL("vast_interstitial", "com.mopub.mobileads.VastVideoInterstitial"),
-        MOPUB_NATIVE("mopub_native", "com.mopub.nativeads.MoPubCustomEventNative"),
-        MOPUB_VIDEO_NATIVE("mopub_video_native", "com.mopub.nativeads.MoPubCustomEventVideoNative"),
-        MOPUB_REWARDED_VIDEO("rewarded_video", "com.mopub.mobileads.MoPubRewardedVideo"),
-        MOPUB_REWARDED_PLAYABLE("rewarded_playable", "com.mopub.mobileads.MoPubRewardedPlayable"),
-
-        UNSPECIFIED("", null);
+        MRAID_BANNER("mraid_banner",
+                "com.mopub.mraid.MraidBanner", true),
+        MRAID_INTERSTITIAL("mraid_interstitial",
+                "com.mopub.mraid.MraidInterstitial", true),
+        HTML_BANNER("html_banner",
+                "com.mopub.mobileads.HtmlBanner", true),
+        HTML_INTERSTITIAL("html_interstitial",
+                "com.mopub.mobileads.HtmlInterstitial", true),
+        VAST_VIDEO_INTERSTITIAL("vast_interstitial",
+                "com.mopub.mobileads.VastVideoInterstitial", true),
+        MOPUB_NATIVE("mopub_native",
+                "com.mopub.nativeads.MoPubCustomEventNative", true),
+        MOPUB_VIDEO_NATIVE("mopub_video_native",
+                "com.mopub.nativeads.MoPubCustomEventVideoNative", true),
+        MOPUB_REWARDED_VIDEO("rewarded_video",
+                "com.mopub.mobileads.MoPubRewardedVideo", true),
+        MOPUB_REWARDED_PLAYABLE("rewarded_playable",
+                "com.mopub.mobileads.MoPubRewardedPlayable", true),
 
+        UNSPECIFIED("", null, false);
+
+        @NonNull
         private final String mKey;
+        @Nullable
         private final String mClassName;
+        private final boolean mIsMoPubSpecific;
 
-        private CustomEventType(String key, String className) {
+        private CustomEventType(String key, String className, boolean isMoPubSpecific) {
             mKey = key;
             mClassName = className;
+            mIsMoPubSpecific = isMoPubSpecific;
         }
 
-        private static CustomEventType fromString(String key) {
+        private static CustomEventType fromString(@Nullable final String key) {
             for (CustomEventType customEventType : values()) {
                 if (customEventType.mKey.equals(key)) {
                     return customEventType;
@@ -50,10 +67,25 @@ private static CustomEventType fromString(String key) {
             return UNSPECIFIED;
         }
 
+        private static CustomEventType fromClassName(@Nullable final String className) {
+            for (CustomEventType customEventType : values()) {
+                if (customEventType.mClassName != null
+                        && customEventType.mClassName.equals(className)) {
+                    return customEventType;
+                }
+            }
+
+            return UNSPECIFIED;
+        }
+
         @Override
         public String toString() {
             return mClassName;
         }
+
+        public static boolean isMoPubSpecific(@Nullable final String className) {
+            return fromClassName(className).mIsMoPubSpecific;
+        }
     }
 
     public static final String BANNER_SUFFIX = "_banner";
@@ -70,7 +102,7 @@ public static String getCustomEventName(@NonNull AdFormat adFormat,
             @NonNull Map<String, String> headers) {
         if (AdType.CUSTOM.equalsIgnoreCase(adType)) {
             return extractHeader(headers, ResponseHeader.CUSTOM_EVENT_NAME);
-        } else if (AdType.STATIC_NATIVE.equalsIgnoreCase(adType)){
+        } else if (AdType.STATIC_NATIVE.equalsIgnoreCase(adType)) {
             return CustomEventType.MOPUB_NATIVE.toString();
         } else if (AdType.VIDEO_NATIVE.equalsIgnoreCase(adType)) {
             return CustomEventType.MOPUB_VIDEO_NATIVE.toString();
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/AdViewController.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/AdViewController.java
index c8999d4d..8d2f7e59 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/AdViewController.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/AdViewController.java
@@ -67,6 +67,7 @@
 	@Nullable private WebViewAdUrlGenerator mUrlGenerator;
 	
 	@Nullable private AdResponse mAdResponse;
+	@Nullable private String mCustomEventClassName;
 	private final Runnable mRefreshRunnable;
 	@NonNull private final AdRequest.Listener mAdListener;
 	
@@ -140,6 +141,7 @@ public void run() {
 	void onAdLoadSuccess(@NonNull final AdResponse adResponse) {
 		mBackoffPower = 1;
 		mAdResponse = adResponse;
+		mCustomEventClassName = adResponse.getCustomEventClassName();
 		// Do other ad loading setup. See AdFetcher & AdLoadTask.
 		mTimeoutMilliseconds = mAdResponse.getAdTimeoutMillis() == null
 				? mTimeoutMilliseconds
@@ -334,6 +336,11 @@ public String getAdUnitId() {
 		return mAdUnitId;
 	}
 	
+	    @Nullable
+     public String getCustomEventClassName() {
+         return mCustomEventClassName;
+     }
+	
 	public void setAdUnitId(@NonNull String adUnitId) {
 		mAdUnitId = adUnitId;
 	}
@@ -598,6 +605,7 @@ public void run() {
 		}
 	}
 	
+	@Nullable
 	public AdResponse getAdResponse() {
 		return mAdResponse;
 	}
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/MoPubErrorCode.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/MoPubErrorCode.java
index 6ba5602f..608526fc 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/MoPubErrorCode.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/MoPubErrorCode.java
@@ -8,6 +8,9 @@
     CANCELLED("Ad request was cancelled."),
     NO_CONNECTION("No internet connection detected."),
 
+    /** see {@link com.mopub.common.Constants#AD_EXPIRATION_DELAY } */
+    EXPIRED("Ad expired since it was not shown within 4 hours."),
+
     ADAPTER_NOT_FOUND("Unable to find Native Network or Custom Event adapter."),
     ADAPTER_BANNED("Native Network or Custom Event adapter was banned."),
     ADAPTER_CONFIGURATION_ERROR("Native Network or Custom Event adapter was configured incorrectly."),
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/resource/BaseWidgetDrawable.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/resource/BaseWidgetDrawable.java
index d12bf8e1..dbe95757 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/resource/BaseWidgetDrawable.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/resource/BaseWidgetDrawable.java
@@ -3,6 +3,7 @@
 import android.graphics.Canvas;
 import android.graphics.ColorFilter;
 import android.graphics.Paint;
+import android.graphics.PixelFormat;
 import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
 import android.support.annotation.NonNull;
@@ -29,6 +30,6 @@ public void setColorFilter(ColorFilter colorFilter) {
 
     @Override
     public int getOpacity() {
-        return 0;
+        return PixelFormat.UNKNOWN;
     }
 }
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/resource/DrawableConstants.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/resource/DrawableConstants.java
index b3dd1bff..68f20059 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/resource/DrawableConstants.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/resource/DrawableConstants.java
@@ -66,10 +66,10 @@
     }
     
     public static class CloseButton {
-        public static final int WIDGET_HEIGHT_DIPS = 46;
-        public static final int EDGE_PADDING = 16;
-        public static final int IMAGE_PADDING_DIPS = 5;
-        public static final int TEXT_RIGHT_MARGIN_DIPS = 7;
+        public static final int WIDGET_HEIGHT_DIPS = 56;
+        public static final int EDGE_PADDING = 6;
+        public static final int IMAGE_PADDING_DIPS = 15;
+        public static final int TEXT_RIGHT_MARGIN_DIPS = 0;
         public static final float TEXT_SIZE_SP = 20f;
 
         public static final int STROKE_COLOR = Color.WHITE;
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/AdRequest.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/AdRequest.java
index 1285cc62..a5b423e2 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/AdRequest.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/AdRequest.java
@@ -13,6 +13,7 @@
 import com.mopub.common.FullAdType;
 import com.mopub.common.LocationService;
 import com.mopub.common.MoPub;
+import com.mopub.common.MoPub.BrowserAgent;
 import com.mopub.common.Preconditions;
 import com.mopub.common.VisibleForTesting;
 import com.mopub.common.event.BaseEvent;
@@ -198,6 +199,12 @@ public Listener getListener() {
                 fullAdTypeString, headers);
         builder.setCustomEventClassName(customEventClassName);
 
+        // Default browser agent from X-Browser-Agent header
+        BrowserAgent browserAgent = BrowserAgent.fromHeader(
+                extractIntegerHeader(headers, ResponseHeader.BROWSER_AGENT));
+        MoPub.setBrowserAgentFromAdServer(browserAgent);
+        builder.setBrowserAgent(browserAgent);
+
         // Process server extras if they are present:
         String customEventData = extractHeader(headers, ResponseHeader.CUSTOM_EVENT_DATA);
 
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/AdResponse.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/AdResponse.java
index f601a06e..18fa4946 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/AdResponse.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/AdResponse.java
@@ -5,6 +5,7 @@
 import android.text.TextUtils;
 
 import com.mopub.common.DataKeys;
+import com.mopub.common.MoPub.BrowserAgent;
 import com.mopub.common.event.EventDetails;
 import com.mopub.common.util.DateAndTime;
 
@@ -82,6 +83,8 @@
 
     @Nullable
     private final String mCustomEventClassName;
+    @Nullable
+    private final BrowserAgent mBrowserAgent;
     @NonNull
     private final Map<String, String> mServerExtras;
 
@@ -122,6 +125,7 @@ private AdResponse(@NonNull Builder builder) {
         mJsonBody = builder.jsonBody;
         mEventDetails = builder.eventDetails;
         mCustomEventClassName = builder.customEventClassName;
+        mBrowserAgent = builder.mBrowserAgent;
         mServerExtras = builder.serverExtras;
         mTimestamp = DateAndTime.now().getTime();
 
@@ -289,6 +293,9 @@ public String getCustomEventClassName() {
         return mCustomEventClassName;
     }
 
+    @Nullable
+    public BrowserAgent getBrowserAgent() { return mBrowserAgent; }
+
     @NonNull
     public Map<String, String> getServerExtras() {
         // Strings are immutable, so this works as a "deep" copy.
@@ -332,6 +339,7 @@ public Builder toBuilder() {
                 .setJsonBody(mJsonBody)
                 .setEventDetails(mEventDetails)
                 .setCustomEventClassName(mCustomEventClassName)
+                .setBrowserAgent(mBrowserAgent)
                 .setServerExtras(mServerExtras);
     }
 
@@ -368,6 +376,7 @@ public Builder toBuilder() {
         private EventDetails eventDetails;
 
         private String customEventClassName;
+        private BrowserAgent mBrowserAgent;
         private Map<String, String> serverExtras = new TreeMap<String, String>();
 
         public Builder setAdType(@Nullable final String adType) {
@@ -495,6 +504,11 @@ public Builder setCustomEventClassName(@Nullable final String customEventClassNa
             return this;
         }
 
+        public Builder setBrowserAgent(@Nullable final BrowserAgent browserAgent) {
+            this.mBrowserAgent = browserAgent;
+            return this;
+        }
+
         public Builder setServerExtras(@Nullable final Map<String, String> serverExtras) {
             if (serverExtras == null) {
                 this.serverExtras = new TreeMap<String, String>();
diff --git a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/MoPubInterstitial.java b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/MoPubInterstitial.java
index 38de8ba8..fe5a4a0a 100644
--- a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/MoPubInterstitial.java
+++ b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/MoPubInterstitial.java
@@ -3,6 +3,7 @@
 import android.app.Activity;
 import android.content.Context;
 import android.location.Location;
+import android.os.Handler;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
@@ -15,12 +16,14 @@
 
 import java.util.Map;
 
+import static com.mopub.common.Constants.AD_EXPIRATION_DELAY;
 import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
+import static com.mopub.mobileads.MoPubErrorCode.EXPIRED;
+import static com.mopub.mobileads.MoPubInterstitial.InterstitialState.DESTROYED;
 import static com.mopub.mobileads.MoPubInterstitial.InterstitialState.IDLE;
 import static com.mopub.mobileads.MoPubInterstitial.InterstitialState.LOADING;
 import static com.mopub.mobileads.MoPubInterstitial.InterstitialState.READY;
 import static com.mopub.mobileads.MoPubInterstitial.InterstitialState.SHOWING;
-import static com.mopub.mobileads.MoPubInterstitial.InterstitialState.DESTROYED;
 
 public class MoPubInterstitial implements CustomEventInterstitialAdapter.CustomEventInterstitialAdapterListener {
     @VisibleForTesting
@@ -55,6 +58,8 @@
     @Nullable private CustomEventInterstitialAdapter mCustomEventInterstitialAdapter;
     @Nullable private InterstitialAdListener mInterstitialAdListener;
     @NonNull private Activity mActivity;
+    @NonNull private Handler mHandler;
+    @NonNull private final Runnable mAdExpiration;
     @NonNull private volatile InterstitialState mCurrentInterstitialState;
 
     public interface InterstitialAdListener {
@@ -72,6 +77,21 @@ public MoPubInterstitial(@NonNull final Activity activity, @NonNull final String
         mInterstitialView.setAdUnitId(adUnitId);
 
         mCurrentInterstitialState = IDLE;
+
+        mHandler = new Handler();
+        mAdExpiration = new Runnable() {
+            @Override
+            public void run() {
+                MoPubLog.d("Expiring unused Interstitial ad.");
+                attemptStateTransition(IDLE, true);
+                if (!SHOWING.equals(mCurrentInterstitialState) &&
+                        !DESTROYED.equals(mCurrentInterstitialState)) {
+                    // double-check the state in case the runnable fires right after the state
+                    // transition but before it's cancelled
+                    mInterstitialView.adFailed(EXPIRED);
+                }
+            }
+        };
     }
 
     private boolean attemptStateTransition(@NonNull final InterstitialState endState) {
@@ -83,14 +103,14 @@ private boolean attemptStateTransition(@NonNull final InterstitialState endState
      * Other methods should not be modifying mCurrentInterstitialState.
      *
      * @param endState     The desired end state.
-     * @param forceRefresh Whether or not this is part of a forceRefresh transition. Force
-     *                     refresh can happen from IDLE, LOADING, or READY. It will ignore
+     * @param force Whether or not this is part of a force transition. Force transitions
+     *                     can happen from IDLE, LOADING, or READY. It will ignore
      *                     the currently loading or loaded ad and attempt to load another.
      * @return {@code true} if a state change happened, {@code false} if no state change happened.
      */
     @VisibleForTesting
     synchronized boolean attemptStateTransition(@NonNull final InterstitialState endState,
-            boolean forceRefresh) {
+            boolean force) {
         Preconditions.checkNotNull(endState);
 
         final InterstitialState startState = mCurrentInterstitialState;
@@ -110,7 +130,7 @@ synchronized boolean attemptStateTransition(@NonNull final InterstitialState end
                         // Going from IDLE to LOADING is the usual load case
                         invalidateInterstitialAdapter();
                         mCurrentInterstitialState = LOADING;
-                        if (forceRefresh) {
+                        if (force) {
                             // Force-load means a pub-initiated force refresh.
                             mInterstitialView.forceRefresh();
                         } else {
@@ -137,7 +157,7 @@ synchronized boolean attemptStateTransition(@NonNull final InterstitialState end
                         mCurrentInterstitialState = IDLE;
                         return true;
                     case LOADING:
-                        if (!forceRefresh) {
+                        if (!force) {
                             // Cannot load more than one interstitial at a time
                             MoPubLog.d("Already loading an interstitial.");
                         }
@@ -145,6 +165,11 @@ synchronized boolean attemptStateTransition(@NonNull final InterstitialState end
                     case READY:
                         // This is the usual load finished transition
                         mCurrentInterstitialState = READY;
+                        // Expire MoPub ads to synchronize with MoPub Ad Server tracking window
+                        if (AdTypeTranslator.CustomEventType
+                                .isMoPubSpecific(mInterstitialView.getCustomEventClassName())) {
+                            mHandler.postDelayed(mAdExpiration, AD_EXPIRATION_DELAY);
+                        }
                         return true;
                     case SHOWING:
                         MoPubLog.d("Interstitial is not ready to be shown yet.");
@@ -158,8 +183,8 @@ synchronized boolean attemptStateTransition(@NonNull final InterstitialState end
             case READY:
                 switch (endState) {
                     case IDLE:
-                        if (forceRefresh) {
-                            // This happens on a force refresh
+                        if (force) {
+                            // This happens on a force refresh or an ad expiration
                             invalidateInterstitialAdapter();
                             mCurrentInterstitialState = IDLE;
                             return true;
@@ -177,6 +202,7 @@ synchronized boolean attemptStateTransition(@NonNull final InterstitialState end
                         // This is the usual transition from ready to showing
                         showCustomEventInterstitial();
                         mCurrentInterstitialState = SHOWING;
+                        mHandler.removeCallbacks(mAdExpiration);
                         return true;
                     case DESTROYED:
                         setInterstitialStateDestroyed();
@@ -187,7 +213,7 @@ synchronized boolean attemptStateTransition(@NonNull final InterstitialState end
             case SHOWING:
                 switch(endState) {
                     case IDLE:
-                        if (forceRefresh) {
+                        if (force) {
                             MoPubLog.d("Cannot force refresh while showing an interstitial.");
                             return false;
                         }
@@ -196,7 +222,7 @@ synchronized boolean attemptStateTransition(@NonNull final InterstitialState end
                         mCurrentInterstitialState = IDLE;
                         return true;
                     case LOADING:
-                        if (!forceRefresh) {
+                        if (!force) {
                             MoPubLog.d("Interstitial already showing. Not loading another.");
                         }
                         return false;
@@ -225,6 +251,7 @@ private void setInterstitialStateDestroyed() {
         invalidateInterstitialAdapter();
         mInterstitialView.setBannerAdListener(null);
         mInterstitialView.destroy();
+        mHandler.removeCallbacks(mAdExpiration);
         mCurrentInterstitialState = DESTROYED;
     }
 
@@ -398,6 +425,10 @@ public MoPubInterstitialView(Context context) {
             setAutorefreshEnabled(false);
         }
 
+        @Nullable String getCustomEventClassName() {
+            return mAdViewController.getCustomEventClassName();
+        }
+
         @Override
         public AdFormat getAdFormat() {
             return AdFormat.INTERSTITIAL;
@@ -445,6 +476,12 @@ protected void adFailed(MoPubErrorCode errorCode) {
         }
     }
 
+    @VisibleForTesting
+    @Deprecated
+    void setHandler(@NonNull final Handler handler) {
+        mHandler = handler;
+    }
+
     @VisibleForTesting
     @Deprecated
     void setInterstitialView(@NonNull MoPubInterstitialView interstitialView) {
diff --git a/mopub-sdk/mopub-sdk-native-static/src/main/java/com/mopub/nativeads/NativeAdSource.java b/mopub-sdk/mopub-sdk-native-static/src/main/java/com/mopub/nativeads/NativeAdSource.java
index 5fa421e9..f7061135 100644
--- a/mopub-sdk/mopub-sdk-native-static/src/main/java/com/mopub/nativeads/NativeAdSource.java
+++ b/mopub-sdk/mopub-sdk-native-static/src/main/java/com/mopub/nativeads/NativeAdSource.java
@@ -14,6 +14,7 @@
 import java.util.List;
 import java.util.Set;
 
+import static com.mopub.common.Constants.AD_EXPIRATION_DELAY;
 import static com.mopub.nativeads.MoPubNative.MoPubNativeNetworkListener;
 
 /**
@@ -38,7 +39,7 @@
      */
     private static final int CACHE_LIMIT = 1;
 
-    private static final int EXPIRATION_TIME_MILLISECONDS = 15 * 60 * 1000; // 15 minutes
+    private static final int EXPIRATION_TIME_MILLISECONDS = AD_EXPIRATION_DELAY;
     private static final int MAXIMUM_RETRY_TIME_MILLISECONDS = 5 * 60 * 1000; // 5 minutes.
     @VisibleForTesting static final int[] RETRY_TIME_ARRAY_MILLISECONDS = new int[]{1000, 3000, 5000, 25000, 60000, MAXIMUM_RETRY_TIME_MILLISECONDS};
 
diff --git a/mopub-sdk/mopub-sdk-native-video/src/main/java/com/mopub/nativeads/MoPubCustomEventVideoNative.java b/mopub-sdk/mopub-sdk-native-video/src/main/java/com/mopub/nativeads/MoPubCustomEventVideoNative.java
index c85dd567..72f92a18 100644
--- a/mopub-sdk/mopub-sdk-native-video/src/main/java/com/mopub/nativeads/MoPubCustomEventVideoNative.java
+++ b/mopub-sdk/mopub-sdk-native-video/src/main/java/com/mopub/nativeads/MoPubCustomEventVideoNative.java
@@ -306,6 +306,19 @@ public void onVastVideoConfigurationPrepared(@Nullable VastVideoConfig vastVideo
                     mVideoResponseHeaders.getImpressionVisibleMs();
             visibilityTrackingEvents.add(visibilityTrackingEvent);
 
+            // VAST impression trackers
+            for (final VastTracker vastTracker : vastVideoConfig.getImpressionTrackers()) {
+                final VisibilityTrackingEvent vastImpressionTrackingEvent =
+                        new VisibilityTrackingEvent();
+                vastImpressionTrackingEvent.strategy = new PayloadVisibilityStrategy(mContext,
+                        vastTracker.getTrackingUrl());
+                vastImpressionTrackingEvent.minimumPercentageVisible =
+                        mVideoResponseHeaders.getImpressionMinVisiblePercent();
+                vastImpressionTrackingEvent.totalRequiredPlayTimeMs =
+                        mVideoResponseHeaders.getImpressionVisibleMs();
+                visibilityTrackingEvents.add(vastImpressionTrackingEvent);
+            }
+
             // Visibility tracking event from http response Vast payload
             mVastVideoConfig = vastVideoConfig;
             final VideoViewabilityTracker vastVideoViewabilityTracker =
diff --git a/mopub-sdk/mopub-sdk-native-video/src/main/java/com/mopub/nativeads/NativeFullScreenVideoView.java b/mopub-sdk/mopub-sdk-native-video/src/main/java/com/mopub/nativeads/NativeFullScreenVideoView.java
index 2f551fb9..0b7c6d0b 100644
--- a/mopub-sdk/mopub-sdk-native-video/src/main/java/com/mopub/nativeads/NativeFullScreenVideoView.java
+++ b/mopub-sdk/mopub-sdk-native-video/src/main/java/com/mopub/nativeads/NativeFullScreenVideoView.java
@@ -7,6 +7,7 @@
 import android.graphics.Color;
 import android.graphics.ColorFilter;
 import android.graphics.Paint;
+import android.graphics.PixelFormat;
 import android.graphics.RectF;
 import android.graphics.SurfaceTexture;
 import android.graphics.drawable.Drawable;
@@ -419,7 +420,7 @@ public void setColorFilter(ColorFilter cf) { }
 
         @Override
         public int getOpacity() {
-            return 0;
+            return PixelFormat.UNKNOWN;
         }
     };
 
diff --git a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedAd.java b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedAd.java
index d0129295..ba372b23 100644
--- a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedAd.java
+++ b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedAd.java
@@ -1,6 +1,7 @@
 package com.mopub.mobileads;
 
 import android.app.Activity;
+import android.os.Handler;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 
@@ -13,6 +14,9 @@
 
 import java.util.Map;
 
+import static com.mopub.common.Constants.AD_EXPIRATION_DELAY;
+import static com.mopub.mobileads.MoPubErrorCode.EXPIRED;
+
 /**
  * Contains the common logic for rewarded ads.
  */
@@ -96,22 +100,40 @@ protected boolean isReady() {
 
         @NonNull final Class<? extends MoPubRewardedAd>  mCustomEventClass;
 
+        @NonNull private final Runnable mAdExpiration;
+        @NonNull private Handler mHandler;
+
         public MoPubRewardedAdListener(@NonNull final Class<? extends MoPubRewardedAd>
                 customEventClass) {
             Preconditions.checkNotNull(customEventClass);
 
             mCustomEventClass = customEventClass;
+
+            mHandler = new Handler();
+            mAdExpiration = new Runnable() {
+                @Override
+                public void run() {
+                    MoPubLog.d("Expiring unused Rewarded ad.");
+                    onInterstitialFailed(EXPIRED);
+                }
+            };
+
         }
 
         @Override
         public void onInterstitialLoaded() {
             mIsLoaded = true;
+            // Expire MoPub ads to synchronize with MoPub Ad Server tracking window
+            if (AdTypeTranslator.CustomEventType.isMoPubSpecific(mCustomEventClass.getName())) {
+                mHandler.postDelayed(mAdExpiration, AD_EXPIRATION_DELAY);
+            }
             MoPubRewardedVideoManager.onRewardedVideoLoadSuccess(mCustomEventClass,
                     getAdNetworkId());
         }
 
         @Override
         public void onInterstitialFailed(final MoPubErrorCode errorCode) {
+            mHandler.removeCallbacks(mAdExpiration);
             switch (errorCode) {
                 case VIDEO_PLAYBACK_ERROR:
                     MoPubRewardedVideoManager.onRewardedVideoPlaybackError(mCustomEventClass,
@@ -125,6 +147,7 @@ public void onInterstitialFailed(final MoPubErrorCode errorCode) {
 
         @Override
         public void onInterstitialShown() {
+            mHandler.removeCallbacks(mAdExpiration);
             MoPubRewardedVideoManager.onRewardedVideoStarted(mCustomEventClass, getAdNetworkId());
         }
 
@@ -141,6 +164,12 @@ public void onLeaveApplication() {
         public void onInterstitialDismissed() {
             MoPubRewardedVideoManager.onRewardedVideoClosed(mCustomEventClass, getAdNetworkId());
         }
+
+        @Deprecated
+        @VisibleForTesting
+        void setHandler(@NonNull final Handler handler) {
+            mHandler = handler;
+        }
     }
 
     @Nullable
@@ -158,4 +187,11 @@ void setIsLoaded(final boolean isLoaded) {
         mIsLoaded = isLoaded;
     }
 
+    @Deprecated
+    @VisibleForTesting
+    MoPubRewardedAdListener createListener(@NonNull final Class<? extends MoPubRewardedAd>
+            customEventClass) {
+        return new MoPubRewardedAdListener(customEventClass);
+    }
+
 }
diff --git a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedVideoListener.java b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedVideoListener.java
index ff9361f1..bf5a12f8 100644
--- a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedVideoListener.java
+++ b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedVideoListener.java
@@ -34,6 +34,11 @@
      */
     public void onRewardedVideoPlaybackError(@NonNull String adUnitId, @NonNull MoPubErrorCode errorCode);
 
+    /**
+     * Called when a rewarded video is clicked.
+     */
+    public void onRewardedVideoClicked(@NonNull String adUnitId);
+
     /**
      * Called when a rewarded video is closed. At this point your application should resume.
      */
diff --git a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedVideoManager.java b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedVideoManager.java
index 2867c02d..e533accb 100644
--- a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedVideoManager.java
+++ b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedVideoManager.java
@@ -44,6 +44,8 @@
 import java.util.Set;
 import java.util.TreeMap;
 
+import static com.mopub.mobileads.MoPubErrorCode.EXPIRED;
+
 /**
  * Handles requesting Rewarded ads and mapping Rewarded Ad SDK settings to the CustomEvent
  * that is being loaded.
@@ -231,6 +233,8 @@ public static void setVideoListener(@Nullable MoPubRewardedVideoListener listene
     public static void loadVideo(@NonNull final String adUnitId,
             @Nullable final RequestParameters requestParameters,
             @Nullable final MediationSettings... mediationSettings) {
+        Preconditions.checkNotNull(adUnitId);
+
         if (sInstance == null) {
             logErrorNotInitialized();
             return;
@@ -238,7 +242,7 @@ public static void loadVideo(@NonNull final String adUnitId,
 
         final String currentlyShowingAdUnitId =
                 sInstance.mRewardedAdData.getCurrentlyShowingAdUnitId();
-        if (!TextUtils.isEmpty(currentlyShowingAdUnitId)) {
+        if (adUnitId.equals(currentlyShowingAdUnitId)) {
             MoPubLog.d(String.format(Locale.US, "Did not queue rewarded ad request for ad " +
                     "unit %s. The ad is already showing.", adUnitId));
             return;
@@ -335,6 +339,12 @@ public static void showVideo(@NonNull String adUnitId) {
                 sInstance.mAdRequestStatus.markPlayed(adUnitId);
                 customEvent.show();
             } else {
+                if (sInstance.mAdRequestStatus.isLoading(adUnitId)) {
+                    MoPubLog.d("Rewarded ad is not ready to be shown yet.");
+                } else {
+                    MoPubLog.d("No rewarded ad loading or loaded.");
+                }
+
                 sInstance.failover(adUnitId, MoPubErrorCode.VIDEO_NOT_AVAILABLE);
             }
         } else {
@@ -552,10 +562,13 @@ private void parseMultiCurrencyJson(@NonNull String adUnitId,
     }
 
     private void failover(@NonNull final String adUnitId, @NonNull final MoPubErrorCode errorCode) {
+        Preconditions.checkNotNull(adUnitId);
+        Preconditions.checkNotNull(errorCode);
+
         final String failoverUrl = mAdRequestStatus.getFailoverUrl(adUnitId);
         mAdRequestStatus.markFail(adUnitId);
 
-        if (failoverUrl != null) {
+        if (failoverUrl != null && !errorCode.equals(EXPIRED)) {
             loadVideo(adUnitId, failoverUrl);
         } else if (sInstance.mVideoListener != null) {
             sInstance.mVideoListener.onRewardedVideoLoadFailure(adUnitId, errorCode);
@@ -688,6 +701,11 @@ public void run() {
 
     private static void onRewardedVideoClickedAction(@NonNull final String adUnitId) {
         Preconditions.checkNotNull(adUnitId);
+
+        if (sInstance.mVideoListener != null) {
+            sInstance.mVideoListener.onRewardedVideoClicked(adUnitId);
+        }
+
         TrackingRequest.makeTrackingHttpRequest(
                 sInstance.mAdRequestStatus.getClickTrackerUrlString(adUnitId),
                 sInstance.mContext);
@@ -724,38 +742,21 @@ private static void onRewardedVideoClosedAction(@NonNull final String adUnitId)
     }
 
     public static <T extends CustomEventRewardedAd>
-    void onRewardedVideoCompleted(@NonNull final Class<T> customEventClass, final String thirdPartyId, @NonNull final MoPubReward moPubReward) {
-        // Unlike other callbacks in this class, only call the listener once with all the MoPubIds in the matching set.
+    void onRewardedVideoCompleted(@NonNull final Class<T> customEventClass,
+            final String thirdPartyId, @NonNull final MoPubReward moPubReward) {
+        // Unlike other callbacks in this class, only call the listener once with all the MoPubIds
+        // in the matching set.
         final String currentlyShowingAdUnitId =
                 sInstance.mRewardedAdData.getCurrentlyShowingAdUnitId();
+
+        rewardOnClient(customEventClass, thirdPartyId, moPubReward, currentlyShowingAdUnitId);
+        rewardOnServer(currentlyShowingAdUnitId);
+    }
+
+    private static void rewardOnServer(final String currentlyShowingAdUnitId) {
         final String serverCompletionUrl = sInstance.mRewardedAdData.getServerCompletionUrl(
                 currentlyShowingAdUnitId);
-        if (TextUtils.isEmpty(serverCompletionUrl)) {
-            postToInstance(new Runnable() {
-                @Override
-                public void run() {
-                    final MoPubReward chosenReward = chooseReward(
-                            sInstance.mRewardedAdData.getLastShownMoPubReward(customEventClass),
-                            moPubReward);
-
-                    Set<String> rewardedIds = new HashSet<String>();
-                    if (TextUtils.isEmpty(currentlyShowingAdUnitId)) {
-                        final Set<String> moPubIds = sInstance.mRewardedAdData.getMoPubIdsForAdNetwork(
-                                customEventClass, thirdPartyId);
-                        rewardedIds.addAll(moPubIds);
-                    } else {
-                        // If we know which ad unit is showing, only reward the currently showing
-                        // ad unit.
-                        rewardedIds.add(currentlyShowingAdUnitId);
-                    }
-
-                    if (sInstance.mVideoListener != null) {
-                        sInstance.mVideoListener.onRewardedVideoCompleted(rewardedIds,
-                                chosenReward);
-                    }
-                }
-            });
-        } else {
+        if (!TextUtils.isEmpty(serverCompletionUrl)) {
             postToInstance(new Runnable() {
                 @Override
                 public void run() {
@@ -780,6 +781,35 @@ public void run() {
         }
     }
 
+    private static <T extends CustomEventRewardedAd> void rewardOnClient(
+            @NonNull final Class<T> customEventClass, final String thirdPartyId,
+            @NonNull final MoPubReward moPubReward, final String currentlyShowingAdUnitId) {
+        postToInstance(new Runnable() {
+            @Override
+            public void run() {
+                final MoPubReward chosenReward = chooseReward(
+                        sInstance.mRewardedAdData.getLastShownMoPubReward(customEventClass),
+                        moPubReward);
+
+                Set<String> rewardedIds = new HashSet<String>();
+                if (TextUtils.isEmpty(currentlyShowingAdUnitId)) {
+                    final Set<String> moPubIds = sInstance.mRewardedAdData.getMoPubIdsForAdNetwork(
+                            customEventClass, thirdPartyId);
+                    rewardedIds.addAll(moPubIds);
+                } else {
+                    // If we know which ad unit is showing, only reward the currently showing
+                    // ad unit.
+                    rewardedIds.add(currentlyShowingAdUnitId);
+                }
+
+                if (sInstance.mVideoListener != null) {
+                    sInstance.mVideoListener.onRewardedVideoCompleted(rewardedIds,
+                            chosenReward);
+                }
+            }
+        });
+    }
+
     @VisibleForTesting
     static MoPubReward chooseReward(@Nullable final MoPubReward moPubReward, @NonNull final MoPubReward networkReward) {
         if (!networkReward.isSuccessful()) {
diff --git a/mopub-sdk/shared-build.gradle b/mopub-sdk/shared-build.gradle
index 673445a1..17577176 100644
--- a/mopub-sdk/shared-build.gradle
+++ b/mopub-sdk/shared-build.gradle
@@ -8,7 +8,7 @@ repositories {
 }
 
 project.group = 'com.mopub'
-project.version = '4.13.0'
+project.version = '4.15.0'
 
 android {
 	compileSdkVersion 24
@@ -17,11 +17,11 @@ android {
 	useLibrary 'org.apache.http.legacy'
 
 	defaultConfig {
-		versionCode 50
+		versionCode 52
 		versionName version
 		minSdkVersion 16
 		targetSdkVersion 24
-		consumerProguardFiles '../proguard.txt'
+		consumerProguardFiles project(':mopub-sdk').file('proguard.txt')
 	}
 
 	sourceSets {
@@ -73,6 +73,6 @@ android {
 }
 
 dependencies {
-	compile 'com.android.support:support-v4:25.3.1'
-	compile 'com.android.support:support-annotations:25.3.1'
+	compile 'com.android.support:support-v4:25.4.0'
+	compile 'com.android.support:support-annotations:25.4.0'
 }
diff --git a/mopub-sdk/src/main/resources/fabric/com.mopub.sdk.android.mopub.properties b/mopub-sdk/src/main/resources/fabric/com.mopub.sdk.android.mopub.properties
index 12bcf2e5..a561a950 100644
--- a/mopub-sdk/src/main/resources/fabric/com.mopub.sdk.android.mopub.properties
+++ b/mopub-sdk/src/main/resources/fabric/com.mopub.sdk.android.mopub.properties
@@ -1,3 +1,3 @@
 fabric-identifier=com.mopub.sdk.android:mopub
-fabric-version=4.13.0+kit
+fabric-version=4.15.0+kit
 fabric-build-type=source
diff --git a/mopub-sdk/src/test/java/com/mopub/common/ClientMetadataTest.java b/mopub-sdk/src/test/java/com/mopub/common/ClientMetadataTest.java
new file mode 100644
index 00000000..9f1ef0b6
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/ClientMetadataTest.java
@@ -0,0 +1,144 @@
+package com.mopub.common;
+
+import android.app.Activity;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.provider.Settings;
+import android.telephony.TelephonyManager;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
+import com.mopub.mobileads.test.support.MoPubShadowTelephonyManager;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.Shadows;
+import org.robolectric.annotation.Config;
+
+import static android.Manifest.permission.ACCESS_NETWORK_STATE;
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class,
+        shadows = {MoPubShadowTelephonyManager.class})
+public class ClientMetadataTest {
+
+    public Activity activityContext;
+    private MoPubShadowTelephonyManager shadowTelephonyManager;
+
+    @Before
+    public void setUp() throws Exception {
+        activityContext = Robolectric.buildActivity(Activity.class).create().get();
+        Shadows.shadowOf(activityContext).grantPermissions(ACCESS_NETWORK_STATE);
+        shadowTelephonyManager = (MoPubShadowTelephonyManager)
+                Shadows.shadowOf((TelephonyManager) activityContext.getSystemService(Context.TELEPHONY_SERVICE));
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        ContentResolver resolver = RuntimeEnvironment.application.getContentResolver();
+        Settings.Secure.putString(resolver, "limit_ad_tracking", null);
+        Settings.Secure.putString(resolver, "advertising_id", null);
+    }
+
+    // This has to be first or the singleton will be initialized by an earlier test. We should
+    // destroy the application between tests to get around this.
+    @Test
+    public void getWithoutContext_shouldReturnNull() {
+        final ClientMetadata clientMetadata = ClientMetadata.getInstance();
+        assertThat(clientMetadata).isNull();
+    }
+
+    @Test
+    public void getWithContext_shouldReturnInstance() {
+        final ClientMetadata clientMetadata = ClientMetadata.getInstance(activityContext);
+        assertThat(clientMetadata).isNotNull();
+    }
+
+    @Test
+    public void getWithoutContextAfterInit_shouldReturnInstance() {
+        ClientMetadata.getInstance(activityContext);
+        final ClientMetadata clientMetadata = ClientMetadata.getInstance();
+        assertThat(clientMetadata).isNotNull();
+    }
+
+    @Test
+    public void testCachedData_shouldBeAvailable() {
+        shadowTelephonyManager.setNetworkOperatorName("testNetworkOperatorName");
+        shadowTelephonyManager.setNetworkOperator("testNetworkOperator");
+        shadowTelephonyManager.setNetworkCountryIso("1");
+        shadowTelephonyManager.setSimCountryIso("1");
+
+        final ClientMetadata clientMetadata = ClientMetadata.getInstance(activityContext);
+        // Telephony manager data.
+        assertThat(clientMetadata.getNetworkOperatorForUrl()).isEqualTo("testNetworkOperator");
+        assertThat(clientMetadata.getNetworkOperatorName()).isEqualTo("testNetworkOperatorName");
+        assertThat(clientMetadata.getIsoCountryCode()).isEqualTo("1");
+
+        // Other cached data.
+        assertThat(clientMetadata.getDeviceId()).isNotNull().isNotEmpty();
+    }
+
+    @Test
+    public void constructor_onAmazonDevice_shouldSetAmazonAdvertisingInfo() {
+        ContentResolver resolver = RuntimeEnvironment.application.getContentResolver();
+        Settings.Secure.putInt(resolver, "limit_ad_tracking", 1);
+        Settings.Secure.putString(resolver, "advertising_id", "this-is-an-ifa");
+
+        final ClientMetadata clientMetadata = ClientMetadata.getInstance(activityContext);
+
+        assertThat(clientMetadata.getDeviceId()).isEqualTo("ifa:this-is-an-ifa");
+        assertThat(clientMetadata.isDoNotTrackSet()).isTrue();
+        assertThat(clientMetadata.isAdvertisingInfoSet()).isTrue();
+    }
+
+    @Test
+    public void constructor_onNonAmazonDevice_shouldSetSha() {
+        final ClientMetadata clientMetadata = ClientMetadata.getInstance(activityContext);
+
+        assertThat(clientMetadata.getDeviceId()).startsWith("sha:");
+        assertThat(clientMetadata.isDoNotTrackSet()).isFalse();
+        assertThat(clientMetadata.isAdvertisingInfoSet()).isFalse();
+    }
+
+    @Test
+    public void constructor_onAmazonDevice_withoutLimitAdTracking_shouldSetSha() {
+        ContentResolver resolver = RuntimeEnvironment.application.getContentResolver();
+        Settings.Secure.putString(resolver, "advertising_id", "this-is-an-ifa");
+
+        final ClientMetadata clientMetadata = ClientMetadata.getInstance(activityContext);
+
+        assertThat(clientMetadata.getDeviceId()).startsWith("sha:");
+        assertThat(clientMetadata.isDoNotTrackSet()).isFalse();
+        assertThat(clientMetadata.isAdvertisingInfoSet()).isFalse();
+    }
+
+    @Test
+    public void constructor_onAmazonDevice_withoutAdvertisingId_shouldSetSha() {
+        ContentResolver resolver = RuntimeEnvironment.application.getContentResolver();
+        Settings.Secure.putInt(resolver, "limit_ad_tracking", 1);
+
+        final ClientMetadata clientMetadata = ClientMetadata.getInstance(activityContext);
+
+        assertThat(clientMetadata.getDeviceId()).startsWith("sha:");
+        assertThat(clientMetadata.isDoNotTrackSet()).isFalse();
+        assertThat(clientMetadata.isAdvertisingInfoSet()).isFalse();
+    }
+
+    @Test
+    public void constructor_onAmazonDevice_withEmptyAdvertisingId_shouldSetSha() {
+        ContentResolver resolver = RuntimeEnvironment.application.getContentResolver();
+        Settings.Secure.putInt(resolver, "limit_ad_tracking", 1);
+        Settings.Secure.putString(resolver, "advertising_id", "");
+
+        final ClientMetadata clientMetadata = ClientMetadata.getInstance(activityContext);
+
+        assertThat(clientMetadata.getDeviceId()).startsWith("sha:");
+        assertThat(clientMetadata.isDoNotTrackSet()).isFalse();
+        assertThat(clientMetadata.isAdvertisingInfoSet()).isFalse();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/MoPubTest.java b/mopub-sdk/src/test/java/com/mopub/common/MoPubTest.java
index b54eb796..27a9597a 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/MoPubTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/MoPubTest.java
@@ -2,6 +2,7 @@
 
 import android.app.Activity;
 
+import com.mopub.common.MoPub.BrowserAgent;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.common.util.Reflection;
 import com.mopub.mobileads.BuildConfig;
@@ -53,6 +54,47 @@ public void setup() {
         mockRequestParameters = mock(MoPubRewardedVideoManager.RequestParameters.class);
 
         mockStatic(MoPubRewardedVideoManager.class);
+
+        MoPub.resetBrowserAgent();
+    }
+
+    @Test
+    public void setBrowserAgent_withDefaultValue_shouldNotChangeBrowserAgent_shouldSetOverriddenFlag() {
+        MoPub.setBrowserAgent(BrowserAgent.IN_APP);
+        assertThat(MoPub.getBrowserAgent()).isEqualTo(BrowserAgent.IN_APP);
+        assertThat(MoPub.isBrowserAgentOverriddenByClient()).isTrue();
+    }
+
+    @Test
+    public void setBrowserAgent_withNonDefaultValue_shouldChangeBrowserAgent_shouldSetOverriddenFlag() {
+        MoPub.setBrowserAgent(BrowserAgent.NATIVE);
+        assertThat(MoPub.getBrowserAgent()).isEqualTo(BrowserAgent.NATIVE);
+        assertThat(MoPub.isBrowserAgentOverriddenByClient()).isTrue();
+    }
+
+    @Test
+    public void setBrowserAgentFromAdServer_whenNotAlreadyOverriddenByClient_shouldSetBrowserAgentFromAdServer() {
+        MoPub.setBrowserAgentFromAdServer(BrowserAgent.NATIVE);
+        assertThat(MoPub.getBrowserAgent()).isEqualTo(BrowserAgent.NATIVE);
+        assertThat(MoPub.isBrowserAgentOverriddenByClient()).isFalse();
+    }
+
+    @Test
+    public void setBrowserAgentFromAdServer_whenAlreadyOverriddenByClient_shouldNotChangeBrowserAgent() {
+        MoPub.setBrowserAgent(BrowserAgent.NATIVE);
+        MoPub.setBrowserAgentFromAdServer(BrowserAgent.IN_APP);
+        assertThat(MoPub.getBrowserAgent()).isEqualTo(BrowserAgent.NATIVE);
+        assertThat(MoPub.isBrowserAgentOverriddenByClient()).isTrue();
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void setBrowserAgent_withNullValue_shouldThrowException() {
+        MoPub.setBrowserAgent(null);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void setBrowserAgentFromAdServer_withNullValue_shouldThrowException() {
+        MoPub.setBrowserAgentFromAdServer(null);
     }
 
     @Test
diff --git a/mopub-sdk/src/test/java/com/mopub/common/UrlActionTest.java b/mopub-sdk/src/test/java/com/mopub/common/UrlActionTest.java
new file mode 100644
index 00000000..dadf0efa
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/UrlActionTest.java
@@ -0,0 +1,155 @@
+package com.mopub.common;
+
+import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.MoPub.BrowserAgent;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+
+import static com.mopub.common.UrlAction.FOLLOW_DEEP_LINK;
+import static com.mopub.common.UrlAction.FOLLOW_DEEP_LINK_WITH_FALLBACK;
+import static com.mopub.common.UrlAction.HANDLE_MOPUB_SCHEME;
+import static com.mopub.common.UrlAction.HANDLE_PHONE_SCHEME;
+import static com.mopub.common.UrlAction.HANDLE_SHARE_TWEET;
+import static com.mopub.common.UrlAction.IGNORE_ABOUT_SCHEME;
+import static com.mopub.common.UrlAction.OPEN_APP_MARKET;
+import static com.mopub.common.UrlAction.OPEN_IN_APP_BROWSER;
+import static com.mopub.common.UrlAction.OPEN_NATIVE_BROWSER;
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class UrlActionTest {
+
+    @Before
+    public void setUp() {
+        MoPub.resetBrowserAgent();
+    }
+
+    @Test
+    public void handleMopubScheme_shouldBeCaseInsensitive() throws Exception {
+        assertUrlActionMatching(HANDLE_MOPUB_SCHEME, "mopub:", true);
+        assertUrlActionMatching(HANDLE_MOPUB_SCHEME, "MoPuB:", true);
+    }
+
+    @Test
+    public void ignoreAboutScheme_shouldBeCaseInsensitive() throws Exception {
+        assertUrlActionMatching(IGNORE_ABOUT_SCHEME, "about:", true);
+        assertUrlActionMatching(IGNORE_ABOUT_SCHEME, "AbOuT:", true);
+    }
+
+    @Test
+    public void handlePhoneScheme_shouldBeCaseInsensitive() throws Exception {
+        assertUrlActionMatching(HANDLE_PHONE_SCHEME, "tel:", true);
+        assertUrlActionMatching(HANDLE_PHONE_SCHEME, "TeL:", true);
+        assertUrlActionMatching(HANDLE_PHONE_SCHEME, "voicemail:", true);
+        assertUrlActionMatching(HANDLE_PHONE_SCHEME, "VoIcEmAiL:", true);
+        assertUrlActionMatching(HANDLE_PHONE_SCHEME, "sms:", true);
+        assertUrlActionMatching(HANDLE_PHONE_SCHEME, "SmS:", true);
+        assertUrlActionMatching(HANDLE_PHONE_SCHEME, "mailto:", true);
+        assertUrlActionMatching(HANDLE_PHONE_SCHEME, "MaIlTo:", true);
+        assertUrlActionMatching(HANDLE_PHONE_SCHEME, "geo:", true);
+        assertUrlActionMatching(HANDLE_PHONE_SCHEME, "GeO:", true);
+        assertUrlActionMatching(HANDLE_PHONE_SCHEME, "google.streetview:", true);
+        assertUrlActionMatching(HANDLE_PHONE_SCHEME, "GoOgLe.StReEtViEw:", true);
+                
+    }
+
+    @Test
+    public void openNativeBrowser_shouldBeCaseInsensitive() throws Exception {
+        assertUrlActionMatching(OPEN_NATIVE_BROWSER, "mopubnativebrowser:", true);
+        assertUrlActionMatching(OPEN_NATIVE_BROWSER, "MoPuBnAtIvEbRoWsEr:", true);
+        assertUrlActionMatching(OPEN_NATIVE_BROWSER, "http:", false);
+        assertUrlActionMatching(OPEN_NATIVE_BROWSER, "HtTp:", false);
+        assertUrlActionMatching(OPEN_NATIVE_BROWSER, "https:", false);
+        assertUrlActionMatching(OPEN_NATIVE_BROWSER, "HtTpS:", false);
+    }
+
+    @Test
+    public void openNativeBrowser_withNativeBrowserAgent_shouldAlsoMatchHttpSchemes() throws Exception {
+        MoPub.setBrowserAgent(BrowserAgent.NATIVE);
+        assertUrlActionMatching(OPEN_NATIVE_BROWSER, "mopubnativebrowser:", true);
+        assertUrlActionMatching(OPEN_NATIVE_BROWSER, "MoPuBnAtIvEbRoWsEr:", true);
+        assertUrlActionMatching(OPEN_NATIVE_BROWSER, "http:", true);
+        assertUrlActionMatching(OPEN_NATIVE_BROWSER, "HtTp:", true);
+        assertUrlActionMatching(OPEN_NATIVE_BROWSER, "https:", true);
+        assertUrlActionMatching(OPEN_NATIVE_BROWSER, "HtTpS:", true);
+    }
+
+    @Test
+    public void openAppMarket_shouldBeCaseInsensitive() throws Exception {
+        assertUrlActionMatching(OPEN_APP_MARKET, "https://play.google.com", true);
+        assertUrlActionMatching(OPEN_APP_MARKET, "https://PlAy.GoOgLe.CoM", true);
+        assertUrlActionMatching(OPEN_APP_MARKET, "https://market.android.com", true);
+        assertUrlActionMatching(OPEN_APP_MARKET, "https://MaRkEt.AnDrOiD.CoM", true);
+        assertUrlActionMatching(OPEN_APP_MARKET, "market:", true);
+        assertUrlActionMatching(OPEN_APP_MARKET, "MaRkEt:", true);
+        assertUrlActionMatching(OPEN_APP_MARKET, "play.google.com/", true);
+        assertUrlActionMatching(OPEN_APP_MARKET, "PlAy.GoOgLe.CoM/", true);
+        assertUrlActionMatching(OPEN_APP_MARKET, "market.android.com/", true);
+        assertUrlActionMatching(OPEN_APP_MARKET, "MaRkEt.AnDrOiD.CoM/", true);
+    }
+
+    @Test
+    public void openInAppBrowser_shouldBeCaseInsensitive() throws Exception {
+        assertUrlActionMatching(OPEN_IN_APP_BROWSER, "http:", true);
+        assertUrlActionMatching(OPEN_IN_APP_BROWSER, "HtTp:", true);
+        assertUrlActionMatching(OPEN_IN_APP_BROWSER, "https:", true);
+        assertUrlActionMatching(OPEN_IN_APP_BROWSER, "HtTpS:", true);
+    }
+
+    @Test
+    public void handleShareTweet_shouldBeCaseInsensitive() throws Exception {
+        assertUrlActionMatching(HANDLE_SHARE_TWEET, "mopubshare://tweet", true);
+        assertUrlActionMatching(HANDLE_SHARE_TWEET, "MoPuBsHaRe://tweet", true);
+        assertUrlActionMatching(HANDLE_SHARE_TWEET, "mopubshare://TwEeT", true);
+    }
+
+    @Test
+    public void followDeepLinkWithFallback_shouldBeCaseInsensitive() throws Exception {
+        assertUrlActionMatching(FOLLOW_DEEP_LINK_WITH_FALLBACK, "deeplink+:", true);
+        assertUrlActionMatching(FOLLOW_DEEP_LINK_WITH_FALLBACK, "DeEpLiNk+:", true);
+    }
+
+    @Test
+    public void followDeepLink_shouldBeCaseInsensitive() throws Exception {
+        assertUrlActionMatching(FOLLOW_DEEP_LINK, "myapp://", true);
+        assertUrlActionMatching(FOLLOW_DEEP_LINK, "MyApP://", true);
+        assertUrlActionMatching(FOLLOW_DEEP_LINK, "myapp://myview", true);
+        assertUrlActionMatching(FOLLOW_DEEP_LINK, "myapp://MyView", true);
+    }
+
+    @Test
+    public void followDeepLink_withEmptyScheme_shouldNotMatch() throws Exception {
+        assertUrlActionMatching(FOLLOW_DEEP_LINK, "://myview", false);
+    }
+
+    @Test
+    public void followDeepLink_withEmptyHost_shouldMatch() throws Exception {
+        assertUrlActionMatching(FOLLOW_DEEP_LINK, "myapp://", true);
+    }
+
+    @Test
+    public void followDeepLink_withIntentScheme_withEmptyHost_shouldMatch() throws Exception {
+        assertUrlActionMatching(FOLLOW_DEEP_LINK, "intent://", true);
+        assertUrlActionMatching(FOLLOW_DEEP_LINK, "InTeNt://", true);
+    }
+
+    @Test
+    public void followDeepLink_withIntentScheme_withHost_shouldMatch() throws Exception {
+        assertUrlActionMatching(FOLLOW_DEEP_LINK, "intent://host", true);
+        assertUrlActionMatching(FOLLOW_DEEP_LINK, "InTeNt://HoSt", true);
+    }
+
+    private void assertUrlActionMatching(@NonNull final UrlAction action,
+            @Nullable final String url, final boolean shouldMatch) {
+        assertThat(action.shouldTryHandlingUrl(Uri.parse(url))).isEqualTo(shouldMatch);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/IntentsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/IntentsTest.java
new file mode 100644
index 00000000..dd4a3ea5
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/IntentsTest.java
@@ -0,0 +1,299 @@
+package com.mopub.common.util;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.net.Uri;
+import android.os.Bundle;
+
+import com.mopub.common.MoPub;
+import com.mopub.common.MoPub.BrowserAgent;
+import com.mopub.common.MoPubBrowser;
+import com.mopub.exceptions.IntentNotResolvableException;
+import com.mopub.exceptions.UrlParseException;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.shadows.ShadowApplication;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.stub;
+
+@RunWith(RobolectricTestRunner.class)
+public class IntentsTest {
+    private Activity activityContext;
+    private Context applicationContext;
+
+    @Before
+    public void setUp() {
+        activityContext = Robolectric.buildActivity(Activity.class).create().get();
+        applicationContext = activityContext.getApplicationContext();
+        MoPub.resetBrowserAgent();
+    }
+
+    @Test
+    public void startActivity_withActivityContext_shouldStartActivityWithNoNewFlags() throws IntentNotResolvableException {
+        Intents.startActivity(activityContext, new Intent());
+
+        final Intent intent = ShadowApplication.getInstance().peekNextStartedActivity();
+        assertThat(Utils.bitMaskContainsFlag(intent.getFlags(), FLAG_ACTIVITY_NEW_TASK)).isFalse();
+    }
+
+    @Test
+    public void getStartActivityIntent_withActivityContext_shouldReturnIntentWithoutNewTaskFlag() throws Exception {
+        Context context = new Activity();
+
+        final Intent intent = Intents.getStartActivityIntent(context, MoPubBrowser.class, null);
+
+        assertThat(intent.getComponent().getClassName()).isEqualTo(MoPubBrowser.class.getName());
+        assertThat(Utils.bitMaskContainsFlag(intent.getFlags(), FLAG_ACTIVITY_NEW_TASK)).isFalse();
+        assertThat(intent.getExtras()).isNull();
+    }
+
+    @Test
+    public void getStartActivityIntent_withApplicationContext_shouldReturnIntentWithNewTaskFlag() throws Exception {
+        Context context = new Activity().getApplicationContext();
+
+        final Intent intent = Intents.getStartActivityIntent(context, MoPubBrowser.class, null);
+
+        assertThat(intent.getComponent().getClassName()).isEqualTo(MoPubBrowser.class.getName());
+        assertThat(Utils.bitMaskContainsFlag(intent.getFlags(), FLAG_ACTIVITY_NEW_TASK)).isTrue();
+        assertThat(intent.getExtras()).isNull();
+    }
+
+    @Test
+    public void getStartActivityIntent_withBundle_shouldReturnIntentWithExtras() throws Exception {
+        Context context = new Activity();
+        Bundle bundle = new Bundle();
+        bundle.putString("arbitrary key", "even more arbitrary value");
+
+        final Intent intent = Intents.getStartActivityIntent(context, MoPubBrowser.class, bundle);
+
+        assertThat(intent.getComponent().getClassName()).isEqualTo(MoPubBrowser.class.getName());
+        assertThat(Utils.bitMaskContainsFlag(intent.getFlags(), FLAG_ACTIVITY_NEW_TASK)).isFalse();
+        assertThat(intent.getExtras()).isEqualTo(bundle);
+    }
+
+    @Test
+    public void deviceCanHandleIntent_whenActivityCanResolveIntent_shouldReturnTrue() throws Exception {
+        Context context = mock(Context.class);
+        PackageManager packageManager = mock(PackageManager.class);
+
+        List<ResolveInfo> resolveInfos = new ArrayList<ResolveInfo>();
+        resolveInfos.add(new ResolveInfo());
+
+        stub(context.getPackageManager()).toReturn(packageManager);
+        Intent specificIntent = new Intent();
+        specificIntent.setData(Uri.parse("specificIntent:"));
+
+        stub(packageManager.queryIntentActivities(eq(specificIntent), eq(0))).toReturn(resolveInfos);
+
+        assertThat(Intents.deviceCanHandleIntent(context, specificIntent)).isTrue();
+    }
+
+    @Test
+    public void deviceCanHandleIntent_whenActivityCanNotResolveIntent_shouldReturnFalse() throws Exception {
+        Context context = mock(Context.class);
+        PackageManager packageManager = mock(PackageManager.class);
+
+        List<ResolveInfo> resolveInfos = new ArrayList<ResolveInfo>();
+        resolveInfos.add(new ResolveInfo());
+
+        stub(context.getPackageManager()).toReturn(packageManager);
+        Intent specificIntent = new Intent();
+        specificIntent.setData(Uri.parse("specificIntent:"));
+
+        Intent otherIntent = new Intent();
+        otherIntent.setData(Uri.parse("other:"));
+        stub(packageManager.queryIntentActivities(eq(specificIntent), eq(0))).toReturn(resolveInfos);
+
+        assertThat(Intents.deviceCanHandleIntent(context, otherIntent)).isFalse();
+    }
+
+    @Test
+    public void intentForNativeBrowserScheme_shouldProperlyHandleEncodedUrls() throws UrlParseException {
+        Intent intent;
+
+        intent = Intents.intentForNativeBrowserScheme(Uri.parse("mopubnativebrowser://navigate?url=https%3A%2F%2Fwww.example.com"));
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        assertThat(intent.getDataString()).isEqualTo("https://www.example.com");
+
+        intent = Intents.intentForNativeBrowserScheme(Uri.parse("mopubnativebrowser://navigate?url=https://www.example.com/?query=1&two=2"));
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        assertThat(intent.getDataString()).isEqualTo("https://www.example.com/?query=1");
+
+        intent = Intents.intentForNativeBrowserScheme(Uri.parse("mopubnativebrowser://navigate?url=https%3A%2F%2Fwww.example.com%2F%3Fquery%3D1%26two%3D2"));
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        assertThat(intent.getDataString()).isEqualTo("https://www.example.com/?query=1&two=2");
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForNativeBrowserScheme_whenNotMoPubNativeBrowser_shouldThrowException() throws UrlParseException {
+        Intents.intentForNativeBrowserScheme(Uri.parse("mailto://navigate?url=https://www.example.com"));
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForNativeBrowserScheme_whenNotNavigate_shouldThrowException() throws UrlParseException {
+        Intents.intentForNativeBrowserScheme(Uri.parse("mopubnativebrowser://getout?url=https://www.example.com"));
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForNativeBrowserScheme_whenUrlParameterMissing_shouldThrowException() throws UrlParseException {
+        Intents.intentForNativeBrowserScheme(Uri.parse("mopubnativebrowser://navigate"));
+    }
+
+    @Test
+    public void intentForNativeBrowserScheme_whenBrowserAgentSetToNative_whenSchemeIsMoPubNativeBrowser_shouldProperlyHandleEncodedUrls() throws UrlParseException {
+        MoPub.setBrowserAgent(BrowserAgent.NATIVE);
+
+        intentForNativeBrowserScheme_shouldProperlyHandleEncodedUrls();
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForNativeBrowserScheme_whenBrowserAgentSetToNative_whenSchemeIsMoPubNativeBrowser_whenHostIsNotNavigate_shouldThrowException() throws UrlParseException {
+        MoPub.setBrowserAgent(BrowserAgent.NATIVE);
+
+        intentForNativeBrowserScheme_whenNotNavigate_shouldThrowException();
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForNativeBrowserScheme_whenBrowserAgentSetToNative_whenSchemeIsMoPubNativeBrowserButUrlParameterMissing_shouldThrowException() throws UrlParseException {
+        MoPub.setBrowserAgent(BrowserAgent.NATIVE);
+
+        intentForNativeBrowserScheme_whenUrlParameterMissing_shouldThrowException();
+    }
+
+    @Test
+    public void intentForNativeBrowserScheme_whenBrowserAgentSetToNative_whenSchemeIsHttpOrHttps_shouldProperlyHandleEncodedUrls() throws UrlParseException {
+        MoPub.setBrowserAgent(BrowserAgent.NATIVE);
+
+        Intent intent;
+
+        intent = Intents.intentForNativeBrowserScheme(Uri.parse("http://www.example.com"));
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        assertThat(intent.getDataString()).isEqualTo("http://www.example.com");
+
+        intent = Intents.intentForNativeBrowserScheme(Uri.parse("https://www.example.com/?query=1&two=2"));
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        assertThat(intent.getDataString()).isEqualTo("https://www.example.com/?query=1&two=2");
+
+        intent = Intents.intentForNativeBrowserScheme(Uri.parse("https://www.example.com/?query=1%26two%3D2"));
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        assertThat(intent.getDataString()).isEqualTo("https://www.example.com/?query=1%26two%3D2");
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForNativeBrowserScheme_whenBrowserAgentSetToNative_whenSchemeNotMoPubNativeBrowserOrHttpOrHttps_shouldThrowException() throws UrlParseException {
+        MoPub.setBrowserAgent(BrowserAgent.NATIVE);
+
+        Intents.intentForNativeBrowserScheme(Uri.parse("foo://www.example.com"));
+    }
+
+    @Test
+    public void intentForShareTweetScheme_whenValidUri_shouldReturnShareTweetIntent() throws UrlParseException {
+        Intent intent;
+        final String shareMessage = "Check out @SpaceX's Tweet: https://twitter.com/SpaceX/status/596026229536460802";
+
+        intent = Intents.intentForShareTweet(Uri.parse("mopubshare://tweet?screen_name=SpaceX&tweet_id=596026229536460802"));
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_SEND);
+        assertThat(intent.getType()).isEqualTo("text/plain");
+        assertThat(intent.getStringExtra(Intent.EXTRA_SUBJECT)).isEqualTo(shareMessage);
+        assertThat(intent.getStringExtra(Intent.EXTRA_TEXT)).isEqualTo(shareMessage);
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForShareTweetScheme_whenWrongScheme_shouldThrowException() throws UrlParseException {
+        Intents.intentForShareTweet(Uri.parse("mailto://tweet?screen_name=SpaceX&tweet_id=596026229536460802"));
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForShareTweetScheme_whenWrongHost_shouldThrowException() throws UrlParseException {
+        Intents.intentForShareTweet(Uri.parse("mopubshare://twat?screen_name=SpaceX&tweet_id=596026229536460802"));
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForShareTweetScheme_whenScreenNameParameterMissing_shouldThrowException() throws UrlParseException {
+        Intents.intentForShareTweet(Uri.parse("mopubshare://tweet?foo=SpaceX&tweet_id=596026229536460802"));
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForShareTweetScheme_whenScreenNameParameterIsEmpty_shouldThrowException() throws UrlParseException {
+        Intents.intentForShareTweet(Uri.parse("mopubshare://tweet?screen_name=&tweet_id=596026229536460802"));
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForShareTweetScheme_whenTweetIdParameterMissing_shouldThrowException() throws UrlParseException {
+        Intents.intentForShareTweet(Uri.parse("mopubshare://tweet?screen_name=SpaceX&bar=596026229536460802"));
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForShareTweetScheme_whenTweetIdParameterIsEmpty_shouldThrowException() throws UrlParseException {
+        Intents.intentForShareTweet(Uri.parse("mopubshare://tweet?screen_name=SpaceX&tweet_id="));
+    }
+
+    @Test
+    public void launchIntentForUserClick_shouldStartActivity() throws Exception {
+        Intent intent = mock(Intent.class);
+
+        Intents.launchIntentForUserClick(applicationContext, intent, null);
+        final Intent startedActivity = ShadowApplication.getInstance().peekNextStartedActivity();
+
+        assertThat(startedActivity).isNotNull();
+    }
+
+    @Test
+    public void launchApplicationUrl_withResolvableUrl_shouldOpenActivity() throws Exception {
+        final String url = "url_to_installed_app";
+        makeUrlResolvable(url);
+
+        Intents.launchApplicationUrl(activityContext, Uri.parse(url));
+        final Intent startedActivity = ShadowApplication.getInstance().peekNextStartedActivity();
+
+        assertThat(startedActivity).isNotNull();
+    }
+
+    @Test(expected = IntentNotResolvableException.class)
+    public void launchApplicationUrl_withUnresolvableUrl_shouldThrowIntentNotResolvableException() throws Exception {
+        final String url = "url_to_installed_app";
+
+        Intents.launchApplicationUrl(activityContext, Uri.parse(url));
+        final Intent startedActivity = ShadowApplication.getInstance().peekNextStartedActivity();
+
+        assertThat(startedActivity).isNull();
+    }
+
+    @Test
+    public void getPlayStoreUri_shouldBuildUriFromIntentPackage() throws Exception {
+        final Intent intent = new Intent();
+        final String appPackage = "com.mopub.test";
+        intent.setPackage(appPackage);
+
+        assertThat(Intents.getPlayStoreUri(intent).toString()).isEqualTo("market://details?id="
+                + appPackage);
+    }
+
+    @Test
+    public void getPlayStoreUri_shouldNotBlowUpWithEmptyPackage() throws Exception {
+        final Intent intent = new Intent();
+
+        assertThat(Intents.getPlayStoreUri(intent).toString())
+                .isEqualTo("market://details?id=null");
+    }
+
+    private void makeUrlResolvable(String url) {
+        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(
+                new Intent(Intent.ACTION_VIEW, Uri.parse(url)), new ResolveInfo());
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdTypeTranslatorTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdTypeTranslatorTest.java
new file mode 100644
index 00000000..b28dc1c4
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/AdTypeTranslatorTest.java
@@ -0,0 +1,178 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.Context;
+
+import com.mopub.common.AdFormat;
+import com.mopub.common.AdType;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.ResponseHeader;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+
+import java.util.HashMap;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.stub;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class AdTypeTranslatorTest {
+    private String customEventName;
+    private MoPubView moPubView;
+    private MoPubInterstitial.MoPubInterstitialView moPubInterstitialView;
+    HashMap<String, String> headers;
+
+    @Before
+    public void setUp() throws Exception {
+        moPubView = mock(MoPubView.class);
+        moPubInterstitialView = mock(MoPubInterstitial.MoPubInterstitialView.class);
+
+        Context context = Robolectric.buildActivity(Activity.class).create().get();
+        stub(moPubView.getContext()).toReturn(context);
+        stub(moPubInterstitialView.getContext()).toReturn(context);
+
+        headers = new HashMap<String, String>();
+    }
+
+    @Test
+    public void getCustomEventName_shouldBeGoogleBanner() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, "admob_native", null, headers);
+
+        assertThat(customEventName).isEqualTo("com.mopub.mobileads.GooglePlayServicesBanner");
+    }
+
+    @Test
+    public void getCustomEventName_shouldBeGoogleInterstitial() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, "interstitial", "admob_full", headers);
+
+        assertThat(customEventName).isEqualTo("com.mopub.mobileads.GooglePlayServicesInterstitial");
+    }
+
+    @Test
+    public void getCustomEventName_shouldBeMillenialBanner() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, "millennial_native", null, headers);
+
+        assertThat(customEventName).isEqualTo("com.mopub.mobileads.MillennialBanner");
+    }
+
+    @Test
+    public void getCustomEventName_shouldBeMillennialIntersitial() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.INTERSTITIAL, "interstitial", "millennial_full", headers);
+
+        assertThat(customEventName).isEqualTo("com.mopub.mobileads.MillennialInterstitial");
+    }
+
+    @Test
+    public void getCustomEventName_shouldBeMraidBanner() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, AdType.MRAID, null, headers);
+
+        assertThat(customEventName).isEqualTo("com.mopub.mraid.MraidBanner");
+    }
+
+    @Test
+    public void getCustomEventName_shouldBeMraidInterstitial() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.INTERSTITIAL, AdType.MRAID, null, headers);
+
+        assertThat(customEventName).isEqualTo("com.mopub.mraid.MraidInterstitial");
+    }
+
+    @Test
+    public void getCustomEventName_shouldBeHtmlBanner() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, "html", null, headers);
+
+        assertThat(customEventName).isEqualTo("com.mopub.mobileads.HtmlBanner");
+    }
+
+    @Test
+    public void getCustomEventName_shouldBeHtmlInterstitial() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.INTERSTITIAL, "html", null, headers);
+
+        assertThat(customEventName).isEqualTo("com.mopub.mobileads.HtmlInterstitial");
+    }
+
+    @Test
+    public void getCustomEventName_shouldBeVastInterstitial() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.INTERSTITIAL, "interstitial", "vast", headers);
+
+        assertThat(customEventName).isEqualTo("com.mopub.mobileads.VastVideoInterstitial");
+    }
+
+    @Test
+    public void getCustomEventName_shouldBeCustomClassName() {
+        headers.put(ResponseHeader.CUSTOM_EVENT_NAME.getKey(), "com.example.CustomClass");
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, AdType.CUSTOM, null, headers);
+
+        assertThat(customEventName).isEqualTo("com.example.CustomClass");
+    }
+
+    @Test
+    public void getCustomEventName_whenNameNotInHeaders_shouldBeNull() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, AdType.CUSTOM, null, headers);
+
+        assertThat(customEventName).isNull();
+    }
+
+    @Test
+    public void getCustomEventName_withNativeFormat_shouldBeMoPubNative() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.NATIVE, AdType.STATIC_NATIVE, null, headers);
+
+        assertThat(customEventName).isEqualTo("com.mopub.nativeads.MoPubCustomEventNative");
+    }
+
+    @Test
+    public void getCustomEventName_whenInvalidAdTypeAndInvalidFullAdType_shouldReturnNull() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, "garbage", "garbage",
+                headers);
+        assertThat(customEventName).isNull();
+    }
+
+    @Test
+    public void getCustomEventName_withRewardedVideoFormat_shouldBeMoPubRewardedVideo() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.REWARDED_VIDEO,
+                AdType.REWARDED_VIDEO, null, headers);
+
+        assertThat(customEventName).isEqualTo("com.mopub.mobileads.MoPubRewardedVideo");
+    }
+
+    @Test
+    public void getCustomEventName_withRewardedPlayableFormat_shouldBeMoPubRewardedPlayable() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.INTERSTITIAL,
+                AdType.REWARDED_PLAYABLE, null, headers);
+
+        assertThat(customEventName).isEqualTo("com.mopub.mobileads.MoPubRewardedPlayable");
+    }
+
+    @Test
+    public void isMoPubSpecific_withMoPubInterstitialClassNames_shouldBeTrue() {
+        assertThat(AdTypeTranslator.CustomEventType
+                .isMoPubSpecific("com.mopub.mraid.MraidInterstitial")).isTrue();
+        assertThat(AdTypeTranslator.CustomEventType
+                .isMoPubSpecific("com.mopub.mobileads.HtmlInterstitial")).isTrue();
+        assertThat(AdTypeTranslator.CustomEventType
+                .isMoPubSpecific("com.mopub.mobileads.VastVideoInterstitial")).isTrue();
+    }
+
+    @Test
+    public void isMoPubSpecific_withMoPubRewardedClassNames_shouldBeTrue() {
+        assertThat(AdTypeTranslator.CustomEventType
+                .isMoPubSpecific("com.mopub.mobileads.MoPubRewardedVideo")).isTrue();
+        assertThat(AdTypeTranslator.CustomEventType
+                .isMoPubSpecific("com.mopub.mobileads.MoPubRewardedPlayable")).isTrue();
+    }
+
+    @Test
+    public void isMoPubSpecific_withNonMoPubClassNames_shouldBeFalse() {
+        assertThat(AdTypeTranslator.CustomEventType
+                .isMoPubSpecific("com.mopub.mobileads.GooglePlayServicesBanner")).isFalse();
+        assertThat(AdTypeTranslator.CustomEventType
+                .isMoPubSpecific("com.whatever.ads.SomeRandomAdFormat")).isFalse();
+        assertThat(AdTypeTranslator.CustomEventType
+                .isMoPubSpecific(null)).isFalse();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubInterstitialTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubInterstitialTest.java
index c81d7166..201321c3 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubInterstitialTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubInterstitialTest.java
@@ -1,6 +1,7 @@
 package com.mopub.mobileads;
 
 import android.app.Activity;
+import android.os.Handler;
 import android.support.annotation.NonNull;
 
 import com.mopub.common.test.support.SdkTestRunner;
@@ -11,6 +12,7 @@
 import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
 import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 
@@ -18,6 +20,7 @@
 import java.util.HashMap;
 import java.util.Map;
 
+import static com.mopub.common.Constants.FOUR_HOURS_MILLIS;
 import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_DATA;
 import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
 import static com.mopub.mobileads.MoPubErrorCode.CANCELLED;
@@ -29,12 +32,15 @@
 import static com.mopub.mobileads.MoPubInterstitial.InterstitialState.READY;
 import static com.mopub.mobileads.MoPubInterstitial.InterstitialState.SHOWING;
 import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyZeroInteractions;
+import static org.mockito.Mockito.when;
+
 @RunWith(SdkTestRunner.class)
 @Config(constants = BuildConfig.class)
 public class MoPubInterstitialTest {
@@ -51,6 +57,7 @@
     private MoPubInterstitial.MoPubInterstitialView interstitialView;
     private AdViewController adViewController;
     private String customEventClassName;
+    @Mock private Handler mockHandler;
 
     @Before
     public void setUp() throws Exception {
@@ -58,6 +65,7 @@ public void setUp() throws Exception {
         subject = new MoPubInterstitial(activity, AD_UNIT_ID_VALUE);
         interstitialAdListener = mock(MoPubInterstitial.InterstitialAdListener.class);
         subject.setInterstitialAdListener(interstitialAdListener);
+        subject.setHandler(mockHandler);
 
         interstitialView = mock(MoPubInterstitial.MoPubInterstitialView.class);
 
@@ -422,6 +430,7 @@ public void attemptStateTransition_withLoadingStartState() {
 
         subject.setCustomEventInterstitialAdapter(customEventInterstitialAdapter);
         subject.setCurrentInterstitialState(LOADING);
+        subject.setInterstitialView(interstitialView);
         boolean stateDidChange = subject.attemptStateTransition(IDLE, false);
         assertThat(stateDidChange).isTrue();
         assertThat(subject.getCurrentInterstitialState()).isEqualTo(IDLE);
@@ -446,10 +455,13 @@ public void attemptStateTransition_withLoadingStartState() {
         verifyZeroInteractions(customEventInterstitialAdapter);
 
         resetMoPubInterstitial(LOADING);
+        when(interstitialView.getCustomEventClassName())
+                .thenReturn(AdTypeTranslator.CustomEventType.HTML_INTERSTITIAL.toString());
         stateDidChange = subject.attemptStateTransition(READY, false);
         assertThat(stateDidChange).isTrue();
         assertThat(subject.getCurrentInterstitialState()).isEqualTo(READY);
         verifyZeroInteractions(customEventInterstitialAdapter);
+        verify(mockHandler).postDelayed(any(Runnable.class), eq((long) FOUR_HOURS_MILLIS));
 
         resetMoPubInterstitial(LOADING);
         stateDidChange = subject.attemptStateTransition(READY, true);
@@ -533,18 +545,23 @@ public void attemptStateTransition_withReadyStartState() {
         assertThat(stateDidChange).isTrue();
         assertThat(subject.getCurrentInterstitialState()).isEqualTo(SHOWING);
         verify(customEventInterstitialAdapter).showInterstitial();
+        verify(mockHandler).removeCallbacks(any(Runnable.class));
+        reset(mockHandler);
 
         resetMoPubInterstitial(READY);
         stateDidChange = subject.attemptStateTransition(SHOWING, true);
         assertThat(stateDidChange).isTrue();
         assertThat(subject.getCurrentInterstitialState()).isEqualTo(SHOWING);
         verify(customEventInterstitialAdapter).showInterstitial();
+        verify(mockHandler).removeCallbacks(any(Runnable.class));
+        reset(mockHandler);
 
         resetMoPubInterstitial(READY);
         stateDidChange = subject.attemptStateTransition(DESTROYED, false);
         assertThat(stateDidChange).isTrue();
         assertThat(subject.getCurrentInterstitialState()).isEqualTo(DESTROYED);
         verify(customEventInterstitialAdapter).invalidate();
+        verify(mockHandler).removeCallbacks(any(Runnable.class));
 
         resetMoPubInterstitial(READY);
         stateDidChange = subject.attemptStateTransition(DESTROYED, true);
@@ -685,6 +702,43 @@ public void attemptStateTransition_withDestroyedStartState() {
         assertThat(subject.getCurrentInterstitialState()).isEqualTo(DESTROYED);
     }
 
+    @Test
+    public void attemptStateTransition_withLoadingStartState_withReadyEndState_withMoPubCustomEvent_shouldExpireAd() {
+        subject.setCustomEventInterstitialAdapter(customEventInterstitialAdapter);
+        subject.setCurrentInterstitialState(LOADING);
+        subject.setInterstitialView(interstitialView);
+
+        when(interstitialView.getCustomEventClassName())
+                .thenReturn(AdTypeTranslator.CustomEventType.MRAID_INTERSTITIAL.toString());
+        subject.attemptStateTransition(READY, false);
+        verify(mockHandler).postDelayed(any(Runnable.class), eq((long) FOUR_HOURS_MILLIS));
+        reset(mockHandler);
+
+        resetMoPubInterstitial(LOADING);
+        when(interstitialView.getCustomEventClassName())
+                .thenReturn(AdTypeTranslator.CustomEventType.HTML_INTERSTITIAL.toString());
+        subject.attemptStateTransition(READY, false);
+        verify(mockHandler).postDelayed(any(Runnable.class), eq((long) FOUR_HOURS_MILLIS));
+        reset(mockHandler);
+
+        resetMoPubInterstitial(LOADING);
+        when(interstitialView.getCustomEventClassName())
+                .thenReturn(AdTypeTranslator.CustomEventType.VAST_VIDEO_INTERSTITIAL.toString());
+        subject.attemptStateTransition(READY, false);
+        verify(mockHandler).postDelayed(any(Runnable.class), eq((long) FOUR_HOURS_MILLIS));
+    }
+
+    @Test
+    public void attemptStateTransition_withLoadingStartState_withReadyEndState_withNonMoPubCustomEvent_shouldNotExpireAd() {
+        subject.setCustomEventInterstitialAdapter(customEventInterstitialAdapter);
+        subject.setCurrentInterstitialState(LOADING);
+        subject.setInterstitialView(interstitialView);
+
+        when(interstitialView.getCustomEventClassName()).thenReturn("thirdPartyAd");
+        subject.attemptStateTransition(READY, false);
+        verifyZeroInteractions(mockHandler);
+    }
+
     private void loadCustomEvent() {
         MoPubInterstitial.MoPubInterstitialView moPubInterstitialView = subject.new MoPubInterstitialView(activity);
 
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubRewardedVideoManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubRewardedVideoManagerTest.java
new file mode 100644
index 00000000..a379840c
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubRewardedVideoManagerTest.java
@@ -0,0 +1,1025 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.AdType;
+import com.mopub.common.DataKeys;
+import com.mopub.common.LifecycleListener;
+import com.mopub.common.MoPubReward;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.network.AdRequest;
+import com.mopub.network.AdResponse;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.volley.Request;
+import com.mopub.volley.VolleyError;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.ArgumentMatcher;
+import org.mockito.Mock;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLooper;
+
+import java.util.Map;
+import java.util.Set;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Matchers.argThat;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.verifyZeroInteractions;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class
+        MoPubRewardedVideoManagerTest {
+
+    public static final String MOPUB_REWARD = "mopub_reward";
+    public static final String REWARDED_CURRENCY_NAME = "Coins";
+    public static final String REWARDED_CURRENCY_AMOUNT_STR = "15";
+    public static final String SINGLE_REWARDED_CURRENCY_JSON =
+            "{\"rewards\": [ { \"name\": \"Coins\", \"amount\": 25 } ] }";
+    public static final String MULTI_REWARDED_CURRENCIES_JSON =
+            "{\n" +
+                    "  \"rewards\": [\n" +
+                    "    { \"name\": \"Coins\", \"amount\": 8 },\n" +
+                    "    { \"name\": \"Diamonds\", \"amount\": 1 },\n" +
+                    "    { \"name\": \"Diamonds\", \"amount\": 10 },\n" +
+                    "    { \"name\": \"Energy\", \"amount\": 20 }\n" +
+                    "  ]\n" +
+                    "}\n";
+
+    @Mock
+    MoPubRequestQueue mockRequestQueue;
+    @Mock
+    MoPubRewardedVideoListener mockVideoListener;
+
+    private AdRequest.Listener requestListener;
+    private AdRequest request;
+    private RewardedVideoCompletionRequest rewardedVideoCompletionRequest;
+    private Activity mActivity;
+
+    @Before
+    public void setup() {
+        mActivity = Robolectric.buildActivity(Activity.class).create().get();
+        MoPubRewardedVideoManager.init(mActivity);
+        MoPubRewardedVideoManager.setVideoListener(mockVideoListener);
+
+        when(mockRequestQueue.add(any(Request.class))).then(new Answer<Object>() {
+            @Override
+            public Object answer(final InvocationOnMock invocationOnMock) throws Throwable {
+                Request req = ((Request) invocationOnMock.getArguments()[0]);
+                if (req.getClass().equals(AdRequest.class)) {
+                    request = (AdRequest) req;
+                    requestListener = request.getListener();
+                    return null;
+                } else if (req.getClass().equals(RewardedVideoCompletionRequest.class)) {
+                    rewardedVideoCompletionRequest = (RewardedVideoCompletionRequest) req;
+                    return null;
+                } else {
+                    throw new Exception(String.format("Request object added to RequestQueue can " +
+                            "only be of type AdRequest or RewardedVideoCompletionRequest, " +
+                            "saw %s instead.", req.getClass()));
+                }
+            }
+        });
+
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+    }
+
+    @After
+    public void tearDown() {
+        // Unpause the main looper in case a test terminated while the looper was paused.
+        ShadowLooper.unPauseMainLooper();
+        MoPubRewardedVideoManager.getRewardedAdData().clear();
+        MoPubRewardedVideoManager.getAdRequestStatusMapping().clearMapping();
+    }
+
+    @Test
+    public void loadVideo_withRequestParameters_shouldGenerateUrlWithKeywords() {
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", new MoPubRewardedVideoManager.RequestParameters("nonsense;garbage;keywords"));
+
+        verify(mockRequestQueue).add(argThat(new RequestUrlContains(Uri.encode("nonsense;garbage;keywords"))));
+
+        // Finish the request
+        requestListener.onErrorResponse(new VolleyError("end test"));
+        ShadowLooper.unPauseMainLooper();
+    }
+
+    @Test
+    public void loadVideo_withCustomerIdInRequestParameters_shouldSetCustomerId() {
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", new MoPubRewardedVideoManager.RequestParameters("keywords", null, "testCustomerId"));
+
+        assertThat(MoPubRewardedVideoManager.getRewardedAdData().getCustomerId()).isEqualTo("testCustomerId");
+
+        // Finish the request
+        requestListener.onErrorResponse(new VolleyError("end test"));
+        ShadowLooper.unPauseMainLooper();
+    }
+
+    @Test
+    public void loadVideo_withVideoAlreadyShowing_shouldNotLoadVideo() {
+        // To simulate that a video is showing
+        MoPubRewardedVideoManager.getRewardedAdData().setCurrentlyShowingAdUnitId("testAdUnit");
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+
+        ShadowLooper.unPauseMainLooper();
+
+        verifyZeroInteractions(mockRequestQueue);
+    }
+
+    @Test
+    public void loadVideo_withDifferentVideoAlreadyShowing_shouldLoadVideo() {
+        // To simulate that a video is showing
+        MoPubRewardedVideoManager.getRewardedAdData().setCurrentlyShowingAdUnitId("testAdUnit");
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("anotherTestAdUnit", null);
+
+        ShadowLooper.unPauseMainLooper();
+
+        verify(mockRequestQueue).add(any(AdRequest.class));
+    }
+
+    @Test
+    public void callbackMethods_withNullListener_shouldNotError() {
+        // Clients can set RVM null.
+        MoPubRewardedVideoManager.setVideoListener(null);
+
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName("com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+        // Triggers a call to MoPubRewardedVideoManager.onRewardedVideoLoadSuccess
+        requestListener.onSuccess(testResponse);
+
+        ShadowLooper.unPauseMainLooper();
+
+        MoPubRewardedVideoManager.onRewardedVideoClicked(TestCustomEvent.class,
+                TestCustomEvent.AD_NETWORK_ID);
+        MoPubRewardedVideoManager.onRewardedVideoStarted(TestCustomEvent.class,
+                TestCustomEvent.AD_NETWORK_ID);
+        MoPubRewardedVideoManager.onRewardedVideoClosed(TestCustomEvent.class,
+                TestCustomEvent.AD_NETWORK_ID);
+        MoPubRewardedVideoManager.onRewardedVideoCompleted(TestCustomEvent.class,
+                TestCustomEvent.AD_NETWORK_ID,
+                MoPubReward.success("test", 111));
+
+        // The test passed because none of the above calls threw an exception even though the listener is null.
+    }
+
+    @Test
+    public void onAdSuccess_noActivityFound_shouldNotCallFailUrl() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setAdType(AdType.CUSTOM)
+                .setCustomEventClassName(
+                        "com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setFailoverUrl("fail.url")
+                .build();
+
+        MoPubRewardedVideoManager.updateActivity(null);
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+        requestListener.onSuccess(testResponse);
+
+        verify(mockRequestQueue).add(any(AdRequest.class));
+        verifyNoMoreInteractions(mockRequestQueue);
+
+        // Clean up the static state we screwed up:
+        MoPubRewardedVideoManager.updateActivity(mActivity);
+    }
+
+    @Test
+    public void onAdSuccess_noCEFound_shouldCallFailCallback() throws Exception {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setAdType(AdType.CUSTOM)
+                .setCustomEventClassName("doesn't_Exist")
+                .build();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+
+        requestListener.onSuccess(testResponse);
+
+        verify(mockVideoListener).onRewardedVideoLoadFailure(eq("testAdUnit"),
+                eq(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR));
+        verifyNoMoreInteractions(mockVideoListener);
+    }
+
+    @Test
+    public void onAdSuccess_noCEFound_shouldLoadFailUrl() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setAdType(AdType.CUSTOM)
+                .setCustomEventClassName("doesn't_Exist")
+                .setFailoverUrl("fail.url")
+                .build();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+
+        assertThat(request.getUrl()).contains("testAdUnit");
+        requestListener.onSuccess(testResponse);
+        assertThat(request.getUrl()).isEqualTo("fail.url");
+        // Clear up the static state :(
+        requestListener.onErrorResponse(new VolleyError("reset"));
+    }
+
+    @Test
+    public void onAdSuccess_shouldInstantiateCustomEvent_shouldLoad() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName(
+                        "com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+        requestListener.onSuccess(testResponse);
+
+        ShadowLooper.unPauseMainLooper();
+
+        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isTrue();
+        verify(mockVideoListener).onRewardedVideoLoadSuccess(eq("testAdUnit"));
+        verifyNoMoreInteractions(mockVideoListener);
+    }
+
+    @Test
+    public void onAdSuccess_withLegacyRewardedCurrencyHeaders_shouldMapAdUnitIdToReward_shouldLoad() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName(
+                        "com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .setRewardedVideoCurrencyName(REWARDED_CURRENCY_NAME)
+                .setRewardedVideoCurrencyAmount(REWARDED_CURRENCY_AMOUNT_STR)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+        requestListener.onSuccess(testResponse);
+
+        ShadowLooper.unPauseMainLooper();
+
+        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isTrue();
+        verify(mockVideoListener).onRewardedVideoLoadSuccess(eq("testAdUnit"));
+        verifyNoMoreInteractions(mockVideoListener);
+
+        // Verify that the reward is mapped to the adunit
+        RewardedAdData rewardedVideoData = MoPubRewardedVideoManager.getRewardedAdData();
+        assertThat(rewardedVideoData.getMoPubReward("testAdUnit")).isNotNull();
+        assertThat(rewardedVideoData.getMoPubReward("testAdUnit").getLabel()).isEqualTo(REWARDED_CURRENCY_NAME);
+        assertThat(rewardedVideoData.getMoPubReward("testAdUnit").getAmount()).isEqualTo(Integer.parseInt(REWARDED_CURRENCY_AMOUNT_STR));
+        assertThat(rewardedVideoData.getAvailableRewards("testAdUnit")).isEmpty();
+    }
+
+    @Test
+    public void onAdSuccess_withMultiRewardedCurrenciesJsonHeader_shouldMapAdUnitToAvailableRewards_shouldLoad() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName(
+                        "com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .setRewardedCurrencies(MULTI_REWARDED_CURRENCIES_JSON)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+        requestListener.onSuccess(testResponse);
+
+        ShadowLooper.unPauseMainLooper();
+
+        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isTrue();
+        verify(mockVideoListener).onRewardedVideoLoadSuccess(eq("testAdUnit"));
+        verifyNoMoreInteractions(mockVideoListener);
+
+        // Verify that only available rewards are updated, not the final reward mapped to the adunit
+        RewardedAdData rewardedVideoData = MoPubRewardedVideoManager.getRewardedAdData();
+        assertThat(rewardedVideoData.getMoPubReward("testAdUnit")).isNull();
+        assertThat(rewardedVideoData.getAvailableRewards("testAdUnit").size()).isEqualTo(4);
+        assertThat(rewardedVideoData.existsInAvailableRewards("testAdUnit", "Coins", 8)).isTrue();
+        assertThat(rewardedVideoData.existsInAvailableRewards("testAdUnit", "Diamonds", 1)).isTrue();
+        assertThat(rewardedVideoData.existsInAvailableRewards("testAdUnit", "Diamonds", 10)).isTrue();
+        assertThat(rewardedVideoData.existsInAvailableRewards("testAdUnit", "Energy", 20)).isTrue();
+    }
+
+    @Test
+    public void onAdSuccess_withSingleRewardedCurrencyJsonHeader_shouldMapAdUnitToRewardAndUpdateAvailableRewards_shouldLoad() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName(
+                        "com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .setRewardedCurrencies(SINGLE_REWARDED_CURRENCY_JSON)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+        requestListener.onSuccess(testResponse);
+
+        ShadowLooper.unPauseMainLooper();
+
+        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isTrue();
+        verify(mockVideoListener).onRewardedVideoLoadSuccess(eq("testAdUnit"));
+        verifyNoMoreInteractions(mockVideoListener);
+
+        // Verify that the single reward is mapped to the adunit, and it's the only available reward
+        RewardedAdData rewardedVideoData = MoPubRewardedVideoManager.getRewardedAdData();
+        assertThat(rewardedVideoData.getMoPubReward("testAdUnit")).isNotNull();
+        assertThat(rewardedVideoData.getMoPubReward("testAdUnit").getLabel()).isEqualTo("Coins");
+        assertThat(rewardedVideoData.getMoPubReward("testAdUnit").getAmount()).isEqualTo(25);
+        assertThat(rewardedVideoData.getAvailableRewards("testAdUnit").size()).isEqualTo(1);
+        assertThat(rewardedVideoData.existsInAvailableRewards("testAdUnit", "Coins", 25)).isTrue();
+    }
+
+    @Test
+    public void onAdSuccess_withBothLegacyAndJsonHeaders_shouldIgnoreLegacyHeaders_shouldLoad() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName(
+                        "com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .setRewardedVideoCurrencyName(REWARDED_CURRENCY_NAME)
+                .setRewardedVideoCurrencyAmount(REWARDED_CURRENCY_AMOUNT_STR)
+                .setRewardedCurrencies(MULTI_REWARDED_CURRENCIES_JSON)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+        requestListener.onSuccess(testResponse);
+
+        ShadowLooper.unPauseMainLooper();
+
+        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isTrue();
+        verify(mockVideoListener).onRewardedVideoLoadSuccess(eq("testAdUnit"));
+        verifyNoMoreInteractions(mockVideoListener);
+
+        // Verify that the legacy headers are ignored, and available rewards are updated from the JSON header
+        RewardedAdData rewardedVideoData = MoPubRewardedVideoManager.getRewardedAdData();
+        assertThat(rewardedVideoData.getMoPubReward("testAdUnit")).isNull();
+        assertThat(rewardedVideoData.getAvailableRewards("testAdUnit").size()).isEqualTo(4);
+        assertThat(rewardedVideoData.existsInAvailableRewards("testAdUnit", "Coins", 8)).isTrue();
+        assertThat(rewardedVideoData.existsInAvailableRewards("testAdUnit", "Diamonds", 1)).isTrue();
+        assertThat(rewardedVideoData.existsInAvailableRewards("testAdUnit", "Diamonds", 10)).isTrue();
+        assertThat(rewardedVideoData.existsInAvailableRewards("testAdUnit", "Energy", 20)).isTrue();
+    }
+
+    @Test
+    public void onAdSuccess_withMalformedRewardedCurrenciesJsonHeader_shouldNotUpdateRewardMappings_andNotLoad() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName(
+                        "com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .setRewardedCurrencies("not json")
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+        requestListener.onSuccess(testResponse);
+
+        ShadowLooper.unPauseMainLooper();
+
+        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isFalse();
+        verify(mockVideoListener).onRewardedVideoLoadFailure(eq("testAdUnit"),
+                eq(MoPubErrorCode.REWARDED_CURRENCIES_PARSING_ERROR));
+        verifyNoMoreInteractions(mockVideoListener);
+
+        // Verify that no reward mappings are updated
+        RewardedAdData rewardedVideoData = MoPubRewardedVideoManager.getRewardedAdData();
+        assertThat(rewardedVideoData.getMoPubReward("testAdUnit")).isNull();
+        assertThat(rewardedVideoData.getAvailableRewards("testAdUnit").isEmpty());
+    }
+
+    @Test
+    public void loadVideo_withCustomEventAlreadyLoaded_shouldNotLoadAnotherVideo() throws Exception {
+        final CustomEventRewardedVideo mockCustomEvent = mock(CustomEventRewardedVideo.class);
+        MoPubRewardedVideoManager.getRewardedAdData().updateAdUnitCustomEventMapping(
+                "testAdUnit", mockCustomEvent, TestCustomEvent.AD_NETWORK_ID);
+
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName(
+                        "com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        ShadowLooper.pauseMainLooper();
+
+        // Load the first custom event
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+        requestListener.onSuccess(testResponse);
+
+        ShadowLooper.unPauseMainLooper();
+
+        // Verify the first custom event
+        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isTrue();
+        verify(mockVideoListener).onRewardedVideoLoadSuccess(eq("testAdUnit"));
+        verifyNoMoreInteractions(mockVideoListener);
+        verify(mockRequestQueue).add(any(Request.class));
+        reset(mockVideoListener);
+
+        ShadowLooper.pauseMainLooper();
+
+        // Load the second custom event
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+
+        ShadowLooper.unPauseMainLooper();
+
+        // Verify the first custom event is still available
+        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isTrue();
+        verify(mockVideoListener).onRewardedVideoLoadSuccess(eq("testAdUnit"));
+        verifyNoMoreInteractions(mockVideoListener);
+        // Make sure the second load does not attempt to load another ad
+        verifyNoMoreInteractions(mockRequestQueue);
+    }
+
+    @Test
+    public void onAdSuccess_shouldHaveUniqueBroadcastIdsSetForEachCustomEvent() throws Exception {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName(
+                        "com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        ShadowLooper.pauseMainLooper();
+
+        // Load the first custom event
+        MoPubRewardedVideoManager.loadVideo("testAdUnit1", null);
+        requestListener.onSuccess(testResponse);
+
+        ShadowLooper.unPauseMainLooper();
+
+        // Get the first custom event's broadcast id
+        TestCustomEvent testCustomEvent1 = (TestCustomEvent)
+                MoPubRewardedVideoManager.getRewardedAdData().getCustomEvent("testAdUnit1");
+        Long broadcastId1 = (Long) testCustomEvent1.getLocalExtras().get(
+                DataKeys.BROADCAST_IDENTIFIER_KEY);
+        assertThat(broadcastId1).isNotNull();
+
+        ShadowLooper.pauseMainLooper();
+
+        // Load the second custom event
+        MoPubRewardedVideoManager.loadVideo("testAdUnit2", null);
+        requestListener.onSuccess(testResponse);
+
+        ShadowLooper.unPauseMainLooper();
+
+        // Get the second custom event's broadcast id
+        TestCustomEvent testCustomEvent2 = (TestCustomEvent)
+                MoPubRewardedVideoManager.getRewardedAdData().getCustomEvent("testAdUnit2");
+        Long broadcastId2 = (Long) testCustomEvent2.getLocalExtras().get(
+                DataKeys.BROADCAST_IDENTIFIER_KEY);
+        assertThat(broadcastId2).isNotNull();
+
+        // Make sure they're different
+        assertThat(broadcastId1).isNotEqualTo(broadcastId2);
+    }
+
+    @Test
+    public void onAdSuccess_shouldUpdateAdUnitRewardMapping() throws Exception {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName(
+                        "com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .setRewardedVideoCurrencyName("currency_name")
+                .setRewardedVideoCurrencyAmount("123")
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+        requestListener.onSuccess(testResponse);
+
+        ShadowLooper.unPauseMainLooper();
+
+        MoPubReward moPubReward =
+                MoPubRewardedVideoManager.getRewardedAdData().getMoPubReward("testAdUnit");
+        assertThat(moPubReward.getAmount()).isEqualTo(123);
+        assertThat(moPubReward.getLabel()).isEqualTo("currency_name");
+    }
+    
+    @Test
+    public void playVideo_shouldSetHasVideoFalse() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName("com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+        requestListener.onSuccess(testResponse);
+
+        ShadowLooper.unPauseMainLooper();
+
+        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isTrue();
+        MoPubRewardedVideoManager.showVideo("testAdUnit");
+        verify(mockVideoListener).onRewardedVideoLoadSuccess(eq("testAdUnit"));
+        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isFalse();
+        verify(mockVideoListener).onRewardedVideoStarted(eq("testAdUnit"));
+    }
+    
+    @Test
+    public void playVideo_whenNotHasVideo_shouldFail() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName("com.mopub.mobileads.MoPubRewardedVideoManagerTest$NoVideoCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+        requestListener.onSuccess(testResponse);
+
+        ShadowLooper.unPauseMainLooper();
+
+        verify(mockVideoListener).onRewardedVideoLoadFailure(eq("testAdUnit"), eq(MoPubErrorCode.NETWORK_NO_FILL));
+
+        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isFalse();
+        MoPubRewardedVideoManager.showVideo("testAdUnit");
+        verify(mockVideoListener).onRewardedVideoLoadFailure(eq("testAdUnit"), eq(MoPubErrorCode.VIDEO_NOT_AVAILABLE));
+    }
+
+    @Test
+    public void playVideo_withMultiRewardedCurrenciesJsonHeader_whenRewardNotSelected_shouldFail() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName("com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .setRewardedCurrencies(MULTI_REWARDED_CURRENCIES_JSON)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+        requestListener.onSuccess(testResponse);
+
+        ShadowLooper.unPauseMainLooper();
+
+        // Multiple rewards are available, but a reward is not selected before showing video
+        MoPubRewardedVideoManager.showVideo("testAdUnit");
+        verify(mockVideoListener).onRewardedVideoLoadFailure(eq("testAdUnit"), eq(MoPubErrorCode.REWARD_NOT_SELECTED));
+    }
+
+    @Test
+    public void playVideo_withMultiRewardedCurrenciesJsonHeader_whenValidRewardIsSelected_shouldUpdateRewardMappings() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName("com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .setRewardedCurrencies(MULTI_REWARDED_CURRENCIES_JSON)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+        requestListener.onSuccess(testResponse);
+
+        Set<MoPubReward> availableRewards = MoPubRewardedVideoManager.getAvailableRewards("testAdUnit");
+        assertThat(availableRewards.size()).isEqualTo(4);
+
+        // Select the 10 Diamonds reward
+        for (MoPubReward reward : availableRewards) {
+            if (reward.getLabel().equals("Diamonds") && reward.getAmount() == 10) {
+                MoPubRewardedVideoManager.selectReward("testAdUnit", reward);
+                break;
+            }
+        }
+
+        // AdUnit to MoPubReward mapping
+        RewardedAdData rewardedVideoData = MoPubRewardedVideoManager.getRewardedAdData();
+        MoPubReward moPubReward = rewardedVideoData.getMoPubReward("testAdUnit");
+        assertThat(moPubReward.getLabel()).isEqualTo("Diamonds");
+        assertThat(moPubReward.getAmount()).isEqualTo(10);
+
+        ShadowLooper.unPauseMainLooper();
+
+        MoPubRewardedVideoManager.showVideo("testAdUnit");
+
+        // CustomEventRewardedAd class to MoPubReward mapping
+        moPubReward = rewardedVideoData.getLastShownMoPubReward(TestCustomEvent.class);
+        assertThat(moPubReward.getLabel()).isEqualTo("Diamonds");
+        assertThat(moPubReward.getAmount()).isEqualTo(10);
+    }
+
+    @Test
+    public void playVideo_withMultiRewardedCurrenciesJsonHeader_whenSelectRewardWithWrongAdUnit_shouldFail() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName("com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .setRewardedCurrencies(MULTI_REWARDED_CURRENCIES_JSON)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+        requestListener.onSuccess(testResponse);
+
+        Set<MoPubReward> availableRewards = MoPubRewardedVideoManager.getAvailableRewards("testAdUnit");
+        assertThat(availableRewards.size()).isEqualTo(4);
+
+        // Select the 10 Diamonds reward, but to a wrong AdUnit
+        for (MoPubReward reward : availableRewards) {
+            if (reward.getLabel().equals("Diamonds") && reward.getAmount() == 10) {
+                MoPubRewardedVideoManager.selectReward("wrongAdUnit", reward);
+                break;
+            }
+        }
+
+        // No selected reward is mapped to AdUnit
+        assertThat(MoPubRewardedVideoManager.getRewardedAdData().getMoPubReward("testAdUnit")).isNull();
+
+        ShadowLooper.unPauseMainLooper();
+
+        MoPubRewardedVideoManager.showVideo("testAdUnit");
+        verify(mockVideoListener).onRewardedVideoLoadFailure(eq("testAdUnit"), eq(MoPubErrorCode.REWARD_NOT_SELECTED));
+    }
+
+    @Test
+    public void playVideo_withMultiRewardedCurrenciesJsonHeader_whenSelectedRewardIsNotAvailable_shouldFail() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName("com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .setRewardedCurrencies(MULTI_REWARDED_CURRENCIES_JSON)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+        requestListener.onSuccess(testResponse);
+
+        Set<MoPubReward> availableRewards = MoPubRewardedVideoManager.getAvailableRewards("testAdUnit");
+        assertThat(availableRewards.size()).isEqualTo(4);
+
+        // Select a reward that's not in the returned set of available rewards
+        MoPubRewardedVideoManager.selectReward("testAdUnit", MoPubReward.success("fake reward", 99));
+
+        // No selected reward is mapped to AdUnit
+        assertThat(MoPubRewardedVideoManager.getRewardedAdData().getMoPubReward("testAdUnit")).isNull();
+
+        ShadowLooper.unPauseMainLooper();
+
+        MoPubRewardedVideoManager.showVideo("testAdUnit");
+        verify(mockVideoListener).onRewardedVideoLoadFailure(eq("testAdUnit"), eq(MoPubErrorCode.REWARD_NOT_SELECTED));
+    }
+
+    @Test
+    public void playVideo_withSingleRewardedCurrencyJsonHeader_whenRewardNotSelected_shouldSelectOnlyRewardAutomatically() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName("com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .setRewardedCurrencies(SINGLE_REWARDED_CURRENCY_JSON)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+        requestListener.onSuccess(testResponse);
+
+        // There's only one reward in the set of available rewards for this AdUnit
+        assertThat(MoPubRewardedVideoManager.getAvailableRewards("testAdUnit").size()).isEqualTo(1);
+
+        // The only reward is automatically mapped to this AdUnit
+        RewardedAdData rewardedVideoData = MoPubRewardedVideoManager.getRewardedAdData();
+        MoPubReward moPubReward = rewardedVideoData.getMoPubReward("testAdUnit");
+        assertThat(moPubReward.getLabel()).isEqualTo("Coins");
+        assertThat(moPubReward.getAmount()).isEqualTo(25);
+
+        ShadowLooper.unPauseMainLooper();
+
+        MoPubRewardedVideoManager.showVideo("testAdUnit");
+
+        // CustomEventRewardedAd class to MoPubReward mapping
+        moPubReward = rewardedVideoData.getLastShownMoPubReward(TestCustomEvent.class);
+        assertThat(moPubReward.getLabel()).isEqualTo("Coins");
+        assertThat(moPubReward.getAmount()).isEqualTo(25);
+    }
+
+    @Test
+    public void playVideo_withLegacyRewardedCurrencyHeaders_shouldUpdateLastShownCustomEventRewardMapping() throws Exception {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName(
+                        "com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .setRewardedVideoCurrencyName("currency_name")
+                .setRewardedVideoCurrencyAmount("123")
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+        requestListener.onSuccess(testResponse);
+
+        ShadowLooper.unPauseMainLooper();
+
+        MoPubRewardedVideoManager.showVideo("testAdUnit");
+
+        MoPubReward moPubReward =
+                MoPubRewardedVideoManager.getRewardedAdData().getLastShownMoPubReward(TestCustomEvent.class);
+        assertThat(moPubReward.getAmount()).isEqualTo(123);
+        assertThat(moPubReward.getLabel()).isEqualTo("currency_name");
+    }
+
+    @Test
+    public void onAdFailure_shouldCallFailCallback() {
+        VolleyError e = new VolleyError("testError!");
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+
+        assertThat(request.getUrl()).contains("testAdUnit");
+        requestListener.onErrorResponse(e);
+        verify(mockVideoListener).onRewardedVideoLoadFailure(anyString(), any(MoPubErrorCode.class));
+        verifyNoMoreInteractions(mockVideoListener);
+    }
+
+    @Test
+    public void chooseReward_shouldReturnMoPubRewardOverNetworkReward() throws Exception {
+        MoPubReward moPubReward = MoPubReward.success(MOPUB_REWARD, 123);
+        MoPubReward networkReward = MoPubReward.success("network_reward", 456);
+
+        MoPubReward chosenReward =
+                MoPubRewardedVideoManager.chooseReward(moPubReward, networkReward);
+        assertThat(chosenReward).isEqualTo(moPubReward);
+    }
+
+    @Test
+    public void chooseReward_withNetworkRewardNotSuccessful_shouldReturnNetworkReward() throws Exception {
+        MoPubReward moPubReward = MoPubReward.success(MOPUB_REWARD, 123);
+        MoPubReward networkReward = MoPubReward.failure();
+
+        MoPubReward chosenReward =
+                MoPubRewardedVideoManager.chooseReward(moPubReward, networkReward);
+        assertThat(chosenReward).isEqualTo(networkReward);
+    }
+    
+    @Test
+    public void onRewardedVideoCompleted_withEmptyServerCompletionUrl_withCurrentlyShowingAdUnitId_shouldNotifyRewardedVideoCompletedForOneAdUnitId() {
+        MoPubReward moPubReward = MoPubReward.success(MOPUB_REWARD, 123);
+        RewardedAdData rewardedVideoData = MoPubRewardedVideoManager.getRewardedAdData();
+        rewardedVideoData.setCurrentlyShowingAdUnitId("testAdUnit1");
+        rewardedVideoData.updateAdUnitCustomEventMapping("testAdUnit1", new TestCustomEvent(),
+                TestCustomEvent.AD_NETWORK_ID);
+        rewardedVideoData.updateAdUnitCustomEventMapping("testAdUnit2", new TestCustomEvent(),
+                TestCustomEvent.AD_NETWORK_ID);
+        // Server completion url empty and custom event has no server reward set
+
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.onRewardedVideoCompleted(TestCustomEvent.class, TestCustomEvent.AD_NETWORK_ID,
+                moPubReward);
+        
+        ShadowLooper.unPauseMainLooper();
+
+        ArgumentCaptor<Set<String>> rewardedIdsCaptor = ArgumentCaptor.forClass((Class) Set.class);
+        verify(mockVideoListener).onRewardedVideoCompleted(rewardedIdsCaptor.capture(),
+                eq(moPubReward));
+        assertThat(rewardedIdsCaptor.getValue()).containsOnly("testAdUnit1");
+    }
+
+    @Test
+    public void onRewardedVideoCompleted_withEmptyServerCompletionUrl_withNoCurrentlyShowingAdUnitId_shouldNotifyRewardedVideoCompletedForAllAdUnitIds() {
+        MoPubReward moPubReward = MoPubReward.success(MOPUB_REWARD, 123);
+        RewardedAdData rewardedVideoData = MoPubRewardedVideoManager.getRewardedAdData();
+        rewardedVideoData.setCurrentlyShowingAdUnitId(null);
+        rewardedVideoData.updateAdUnitCustomEventMapping("testAdUnit1", new TestCustomEvent(),
+                TestCustomEvent.AD_NETWORK_ID);
+        rewardedVideoData.updateAdUnitCustomEventMapping("testAdUnit2", new TestCustomEvent(),
+                TestCustomEvent.AD_NETWORK_ID);
+        rewardedVideoData.updateAdUnitCustomEventMapping("testAdUnit3", new TestCustomEvent(),
+                TestCustomEvent.AD_NETWORK_ID);
+        // Server completion url empty and custom event has no server reward set
+
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.onRewardedVideoCompleted(TestCustomEvent.class, TestCustomEvent.AD_NETWORK_ID,
+                moPubReward);
+
+        ShadowLooper.unPauseMainLooper();
+
+        ArgumentCaptor<Set<String>> rewardedIdsCaptor = ArgumentCaptor.forClass((Class) Set.class);
+        verify(mockVideoListener).onRewardedVideoCompleted(rewardedIdsCaptor.capture(),
+                eq(moPubReward));
+        assertThat(rewardedIdsCaptor.getValue()).containsOnly("testAdUnit1", "testAdUnit2",
+                "testAdUnit3");
+    }
+
+    @Test
+    public void onRewardedVideoCompleted_withServerCompletionUrl_shouldMakeRewardedVideoCompletionRequest_shouldNotifyRewardedVideoCompleted() {
+        MoPubReward moPubReward = MoPubReward.success(MOPUB_REWARD, 123);
+        RewardedAdData rewardedVideoData = MoPubRewardedVideoManager.getRewardedAdData();
+        rewardedVideoData.setCurrentlyShowingAdUnitId("testAdUnit1");
+
+        // Set server-side reward, different from moPubReward, and corresponding server completion URL
+        rewardedVideoData.updateAdUnitRewardMapping("testAdUnit1", "server-side currency", "777");
+        rewardedVideoData.updateAdUnitToServerCompletionUrlMapping("testAdUnit1", "testUrl");
+
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.onRewardedVideoCompleted(TestCustomEvent.class, TestCustomEvent.AD_NETWORK_ID,
+                moPubReward);
+
+        ShadowLooper.unPauseMainLooper();
+
+        verify(mockRequestQueue).add(any(RewardedVideoCompletionRequest.class));
+        assertThat(rewardedVideoCompletionRequest.getUrl()).contains("testUrl");
+        assertThat(rewardedVideoCompletionRequest.getUrl()).contains("&rcn=server-side%20currency");
+        assertThat(rewardedVideoCompletionRequest.getUrl()).contains("&rca=777");
+        ArgumentCaptor<Set<String>> rewardedIdsCaptor = ArgumentCaptor.forClass((Class) Set.class);
+        verify(mockVideoListener).onRewardedVideoCompleted(rewardedIdsCaptor.capture(),
+                eq(moPubReward));
+        assertThat(rewardedIdsCaptor.getValue()).containsOnly("testAdUnit1");
+    }
+
+    @Test
+    public void onRewardedVideoCompleted_withServerCompletionUrl_withNullRewardForCurrentlyShowingAdUnitId_shouldMakeRewardedVideoCompletionRequestWithDefaultRewardValues() {
+        MoPubReward moPubReward = MoPubReward.success(MOPUB_REWARD, 123);
+        RewardedAdData rewardedVideoData = MoPubRewardedVideoManager.getRewardedAdData();
+        rewardedVideoData.setCurrentlyShowingAdUnitId("testAdUnit1");
+
+        // Set reward fields to nulls
+        rewardedVideoData.updateAdUnitRewardMapping("testAdUnit1", null, null);
+        rewardedVideoData.updateAdUnitToServerCompletionUrlMapping("testAdUnit1", "testUrl");
+
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.onRewardedVideoCompleted(TestCustomEvent.class, TestCustomEvent.AD_NETWORK_ID,
+                moPubReward);
+
+        ShadowLooper.unPauseMainLooper();
+
+        verify(mockRequestQueue).add(any(RewardedVideoCompletionRequest.class));
+        assertThat(rewardedVideoCompletionRequest.getUrl()).contains("testUrl");
+        // Default reward values
+        assertThat(rewardedVideoCompletionRequest.getUrl()).contains("&rcn=&rca=0");
+    }
+
+    @Test
+    public void onRewardedVideoLoadFailure_withExpirationErrorCode_shouldCallFailCallback_shouldNotLoadFailUrl() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setAdType(AdType.CUSTOM)
+                .setCustomEventClassName(
+                        "com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setFailoverUrl("fail.url")
+                .build();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+        requestListener.onSuccess(testResponse);
+        MoPubRewardedVideoManager.onRewardedVideoLoadFailure(TestCustomEvent.class,
+                TestCustomEvent.AD_NETWORK_ID, MoPubErrorCode.EXPIRED);
+
+        verify(mockVideoListener).onRewardedVideoLoadFailure(eq("testAdUnit"),
+                eq(MoPubErrorCode.EXPIRED));
+        verifyNoMoreInteractions(mockVideoListener);
+        verify(mockRequestQueue).add(any(AdRequest.class));
+        verifyNoMoreInteractions(mockRequestQueue);
+    }
+
+    public static class TestCustomEvent extends CustomEventRewardedVideo {
+        public static final String AD_NETWORK_ID = "id!";
+
+        boolean mPlayable = false;
+        private Map<String, Object> mLocalExtras;
+
+        @Nullable
+        @Override
+        protected LifecycleListener getLifecycleListener() {
+            return null;
+        }
+
+        @NonNull
+        @Override
+        protected String getAdNetworkId() {
+            return AD_NETWORK_ID;
+        }
+
+        @Override
+        protected void onInvalidate() {
+            mPlayable = false;
+        }
+
+        @Override
+        protected boolean checkAndInitializeSdk(@NonNull final Activity launcherActivity,
+                @NonNull final Map<String, Object> localExtras,
+                @NonNull final Map<String, String> serverExtras) throws Exception {
+            return false;
+        }
+
+        @Override
+        protected void loadWithSdkInitialized(@NonNull final Activity activity,
+                @NonNull final Map<String, Object> localExtras,
+                @NonNull final Map<String, String> serverExtras) throws Exception {
+            // Do nothing because robolectric handlers execute immediately.
+            mPlayable = true;
+            MoPubRewardedVideoManager.onRewardedVideoLoadSuccess(TestCustomEvent.class,
+                    TestCustomEvent.AD_NETWORK_ID);
+            mLocalExtras = localExtras;
+        }
+
+        @Override
+        protected boolean hasVideoAvailable() {
+            return mPlayable;
+        }
+
+        @Override
+        protected void showVideo() {
+            MoPubRewardedVideoManager.onRewardedVideoStarted(TestCustomEvent.class, TestCustomEvent.AD_NETWORK_ID);
+        }
+
+        @Nullable
+        Map<String, Object> getLocalExtras() {
+            return mLocalExtras;
+        }
+    }
+
+    public static class NoVideoCustomEvent extends TestCustomEvent {
+        @Override
+        protected void loadWithSdkInitialized(@NonNull final Activity activity,
+                @NonNull final Map<String, Object> localExtras,
+                @NonNull final Map<String, String> serverExtras) throws Exception {
+            mPlayable = false;
+            MoPubRewardedVideoManager.onRewardedVideoLoadFailure(NoVideoCustomEvent.class, TestCustomEvent.AD_NETWORK_ID, MoPubErrorCode.NETWORK_NO_FILL);
+        }
+    }
+
+    private static class RequestUrlContains extends ArgumentMatcher<Request> {
+
+        private final String mMustContain;
+
+        RequestUrlContains(String stringToFind) {
+            mMustContain = stringToFind;
+        }
+
+        @Override
+        public boolean matches(final Object argument) {
+            return argument instanceof Request
+                    && ((Request) argument).getUrl().contains(mMustContain);
+        }
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubRewardedVideoTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubRewardedVideoTest.java
new file mode 100644
index 00000000..7bfbf0a2
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubRewardedVideoTest.java
@@ -0,0 +1,260 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.os.Handler;
+
+import com.mopub.common.DataKeys;
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.TreeMap;
+
+import static com.mopub.common.Constants.FOUR_HOURS_MILLIS;
+import static com.mopub.mobileads.MoPubErrorCode.EXPIRED;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.verifyZeroInteractions;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class MoPubRewardedVideoTest {
+
+    private Activity activity;
+    private MoPubRewardedVideo subject;
+    private MoPubRewardedAd.MoPubRewardedAdListener listener;
+
+    @Mock private RewardedVastVideoInterstitial mockRewardedVastVideoInterstitial;
+    @Mock private Handler mockHandler;
+
+    @Before
+    public void setup() {
+        activity = Robolectric.buildActivity(Activity.class).create().get();
+        MoPubRewardedVideoManager.init(activity);
+
+        subject = new MoPubRewardedVideo();
+    }
+
+    @Test
+    public void onInvalidate_withVastVideoInterstitial_shouldInvalidateVastVideoInterstitial() {
+        subject.setRewardedVastVideoInterstitial(mockRewardedVastVideoInterstitial);
+
+        subject.onInvalidate();
+
+        verify(mockRewardedVastVideoInterstitial).onInvalidate();
+        verifyNoMoreInteractions(mockRewardedVastVideoInterstitial);
+    }
+
+    @Test
+    public void onInvalidate_withNullVastVideoInterstitial_shouldNotInvalidateVastVideoInterstitial() {
+        subject.onInvalidate();
+
+        verifyZeroInteractions(mockRewardedVastVideoInterstitial);
+    }
+
+    @Test
+    public void loadWithSdkInitialized_withLocalExtrasIncomplete_shouldLoadVastVideoInterstitial() throws Exception {
+        subject.setRewardedVastVideoInterstitial(mockRewardedVastVideoInterstitial);
+        subject.loadWithSdkInitialized(activity, new TreeMap<String, Object>(),
+                new HashMap<String, String>());
+
+        verify(mockRewardedVastVideoInterstitial).loadInterstitial(eq(activity), any(
+                        CustomEventInterstitial.CustomEventInterstitialListener.class),
+                eq(new TreeMap<String, Object>()),
+                eq(new HashMap<String, String>()));
+        verifyNoMoreInteractions(mockRewardedVastVideoInterstitial);
+        assertThat(subject.getRewardedAdCurrencyName()).isEqualTo("");
+        assertThat(subject.getRewardedAdCurrencyAmount()).isEqualTo(0);
+    }
+
+    @Test
+    public void loadWithSdkInitialized_withRewardedVideoCurrencyNameIncorrectType_shouldLoadVastVideoInterstitial_shouldSetCurrencyNameToEmptyString() throws Exception {
+        subject.setRewardedVastVideoInterstitial(mockRewardedVastVideoInterstitial);
+        final Map<String, Object> localExtras = new TreeMap<String, Object>();
+        localExtras.put(DataKeys.REWARDED_AD_CURRENCY_NAME_KEY, new Object());
+        localExtras.put(DataKeys.REWARDED_AD_CURRENCY_AMOUNT_STRING_KEY, "10");
+
+        subject.loadWithSdkInitialized(activity, localExtras, new HashMap<String, String>());
+
+        verify(mockRewardedVastVideoInterstitial).loadInterstitial(eq(activity), any(
+                        CustomEventInterstitial.CustomEventInterstitialListener.class),
+                eq(localExtras),
+                eq(new HashMap<String, String>()));
+        verifyNoMoreInteractions(mockRewardedVastVideoInterstitial);
+        assertThat(subject.getRewardedAdCurrencyName()).isEqualTo("");
+        assertThat(subject.getRewardedAdCurrencyAmount()).isEqualTo(10);
+    }
+
+    @Test
+    public void loadWithSdkInitialized_withRewardedVideoCurrencyAmountIncorrectType_shouldLoadVastVideoInterstitial_shouldSetCurrencyAmountToZero() throws Exception {
+        subject.setRewardedVastVideoInterstitial(mockRewardedVastVideoInterstitial);
+        final Map<String, Object> localExtras = new TreeMap<String, Object>();
+        localExtras.put(DataKeys.REWARDED_AD_CURRENCY_NAME_KEY, "currencyName");
+        localExtras.put(DataKeys.REWARDED_AD_CURRENCY_AMOUNT_STRING_KEY, new Object());
+
+        subject.loadWithSdkInitialized(activity, localExtras, new HashMap<String, String>());
+
+        verify(mockRewardedVastVideoInterstitial).loadInterstitial(eq(activity), any(
+                        CustomEventInterstitial.CustomEventInterstitialListener.class),
+                eq(localExtras),
+                eq(new HashMap<String, String>()));
+        verifyNoMoreInteractions(mockRewardedVastVideoInterstitial);
+        assertThat(subject.getRewardedAdCurrencyName()).isEqualTo("currencyName");
+        assertThat(subject.getRewardedAdCurrencyAmount()).isEqualTo(0);
+    }
+
+    @Test
+    public void loadWithSdkInitialized_withRewardedVideoCurrencyAmountNotInteger_shouldLoadVastVideoInterstitial_shouldSetCurrencyAmountToZero() throws Exception {
+        subject.setRewardedVastVideoInterstitial(mockRewardedVastVideoInterstitial);
+        final Map<String, Object> localExtras = new TreeMap<String, Object>();
+        localExtras.put(DataKeys.REWARDED_AD_CURRENCY_NAME_KEY, "currencyName");
+        localExtras.put(DataKeys.REWARDED_AD_CURRENCY_AMOUNT_STRING_KEY, "foo");
+
+        subject.loadWithSdkInitialized(activity, localExtras, new HashMap<String, String>());
+
+        verify(mockRewardedVastVideoInterstitial).loadInterstitial(eq(activity), any(
+                        CustomEventInterstitial.CustomEventInterstitialListener.class),
+                eq(localExtras),
+                eq(new HashMap<String, String>()));
+        verifyNoMoreInteractions(mockRewardedVastVideoInterstitial);
+        assertThat(subject.getRewardedAdCurrencyName()).isEqualTo("currencyName");
+        assertThat(subject.getRewardedAdCurrencyAmount()).isEqualTo(0);
+    }
+
+    @Test
+    public void loadWithSdkInitialized_withRewardedVideoCurrencyAmountNegative_shouldLoadVastVideoInterstitial_shouldSetCurrencyAmountToZero() throws Exception {
+        subject.setRewardedVastVideoInterstitial(mockRewardedVastVideoInterstitial);
+        final Map<String, Object> localExtras = new TreeMap<String, Object>();
+        localExtras.put(DataKeys.REWARDED_AD_CURRENCY_NAME_KEY, "currencyName");
+        localExtras.put(DataKeys.REWARDED_AD_CURRENCY_AMOUNT_STRING_KEY, "-42");
+
+        subject.loadWithSdkInitialized(activity, localExtras, new HashMap<String, String>());
+
+        verify(mockRewardedVastVideoInterstitial).loadInterstitial(eq(activity), any(
+                        CustomEventInterstitial.CustomEventInterstitialListener.class),
+                eq(localExtras),
+                eq(new HashMap<String, String>()));
+        verifyNoMoreInteractions(mockRewardedVastVideoInterstitial);
+        assertThat(subject.getRewardedAdCurrencyName()).isEqualTo("currencyName");
+        assertThat(subject.getRewardedAdCurrencyAmount()).isEqualTo(0);
+    }
+
+    @Test
+    public void loadWithSdkInitialized_withCorrectLocalExtras_shouldLoadVastVideoInterstitial() throws Exception {
+        subject.setRewardedVastVideoInterstitial(mockRewardedVastVideoInterstitial);
+        final Map<String, Object> localExtras = new TreeMap<String, Object>();
+        final Map<String, String> serverExtras = new HashMap<String, String>();
+        localExtras.put(DataKeys.REWARDED_AD_CURRENCY_NAME_KEY, "currencyName");
+        localExtras.put(DataKeys.REWARDED_AD_CURRENCY_AMOUNT_STRING_KEY, "10");
+
+        subject.loadWithSdkInitialized(activity, localExtras, serverExtras);
+
+        verify(mockRewardedVastVideoInterstitial).loadInterstitial(eq(activity),
+                any(CustomEventInterstitial.CustomEventInterstitialListener.class), eq(localExtras),
+                eq(serverExtras));
+        verifyNoMoreInteractions(mockRewardedVastVideoInterstitial);
+        assertThat(subject.getRewardedAdCurrencyName()).isEqualTo("currencyName");
+        assertThat(subject.getRewardedAdCurrencyAmount()).isEqualTo(10);
+    }
+
+    @Test
+    public void loadWithSdkInitialized_withEmptyCurrencyName_withNegativeCurrencyAmount_shouldLoadVastVideoInterstitial_shouldNotChangeCurrencyName_shouldSetCurrencyAmountToZero() throws Exception {
+        // We pass whatever was sent to this custom event to the app as long as it exists, but
+        // if the currency value is negative, set it to 0
+        subject.setRewardedVastVideoInterstitial(mockRewardedVastVideoInterstitial);
+        final Map<String, Object> localExtras = new TreeMap<String, Object>();
+        final Map<String, String> serverExtras = new HashMap<String, String>();
+        localExtras.put(DataKeys.REWARDED_AD_CURRENCY_NAME_KEY, "");
+        localExtras.put(DataKeys.REWARDED_AD_CURRENCY_AMOUNT_STRING_KEY, "-10");
+
+        subject.loadWithSdkInitialized(activity, localExtras, serverExtras);
+
+        verify(mockRewardedVastVideoInterstitial).loadInterstitial(eq(activity),
+                any(CustomEventInterstitial.CustomEventInterstitialListener.class), eq(localExtras),
+                eq(serverExtras));
+        verifyNoMoreInteractions(mockRewardedVastVideoInterstitial);
+        assertThat(subject.getRewardedAdCurrencyName()).isEqualTo("");
+        assertThat(subject.getRewardedAdCurrencyAmount()).isEqualTo(0);
+    }
+
+    @Test
+    public void showVideo_withVideoLoaded_shouldShowVastVideoInterstitial() {
+        subject.setRewardedVastVideoInterstitial(mockRewardedVastVideoInterstitial);
+        subject.setIsLoaded(true);
+
+        subject.show();
+
+        verify(mockRewardedVastVideoInterstitial).showInterstitial();
+        verifyNoMoreInteractions(mockRewardedVastVideoInterstitial);
+    }
+
+    @Test
+    public void showVideo_withVideoNotLoaded_shouldDoNothing() {
+        subject.setRewardedVastVideoInterstitial(mockRewardedVastVideoInterstitial);
+        subject.setIsLoaded(false);
+
+        subject.show();
+
+        verifyZeroInteractions(mockRewardedVastVideoInterstitial);
+    }
+
+    @Test
+    public void moPubRewardedAdListener_onInterstitialLoaded_withMoPubRewardedVideo_shouldPostExpirationRunnable() {
+        listener = subject.createListener(MoPubRewardedVideo.class);
+        listener.setHandler(mockHandler);
+
+        listener.onInterstitialLoaded();
+
+        verify(mockHandler).postDelayed(any(Runnable.class), eq((long) FOUR_HOURS_MILLIS));
+    }
+
+    @Test
+    public void moPubRewardedAdListener_onInterstitialLoaded_withMoPubRewardedPlayable_shouldPostExpirationRunnable() {
+        listener = subject.createListener(MoPubRewardedPlayable.class);
+        listener.setHandler(mockHandler);
+
+        listener.onInterstitialLoaded();
+
+        verify(mockHandler).postDelayed(any(Runnable.class), eq((long) FOUR_HOURS_MILLIS));
+    }
+
+    @Test
+    public void moPubRewardedAdListener_onInterstitialLoaded_withOtherCustomEvents_shouldNotPostExpirationRunnable() {
+        listener = subject.createListener(MoPubRewardedAd.class);
+        listener.setHandler(mockHandler);
+
+        listener.onInterstitialLoaded();
+
+        verifyNoMoreInteractions(mockHandler);
+    }
+
+    @Test
+    public void moPubRewardedAdListener_onInterstitialFailed_shouldRemoveExpirationRunnable() {
+        listener = subject.createListener(MoPubRewardedVideo.class);
+        listener.setHandler(mockHandler);
+
+        listener.onInterstitialFailed(EXPIRED);
+
+        verify(mockHandler).removeCallbacks(any(Runnable.class));
+    }
+
+    @Test
+    public void moPubRewardedAdListener_onInterstitialShown_shouldRemoveExpirationRunnable() {
+        listener = subject.createListener(MoPubRewardedVideo.class);
+        listener.setHandler(mockHandler);
+
+        listener.onInterstitialShown();
+
+        verify(mockHandler).removeCallbacks(any(Runnable.class));
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubVideoNativeAdTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubVideoNativeAdTest.java
new file mode 100644
index 00000000..80ad306f
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubVideoNativeAdTest.java
@@ -0,0 +1,939 @@
+package com.mopub.nativeads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.graphics.Bitmap;
+import android.graphics.SurfaceTexture;
+import android.graphics.drawable.Drawable;
+import android.media.AudioManager;
+import android.view.TextureView;
+import android.view.TextureView.SurfaceTextureListener;
+import android.view.View;
+
+import com.mopub.common.Constants;
+import com.mopub.common.event.EventDetails;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BaseVideoPlayerActivity;
+import com.mopub.mobileads.BuildConfig;
+import com.mopub.mobileads.MraidVideoPlayerActivity;
+import com.mopub.mobileads.VastManager;
+import com.mopub.mobileads.VastTracker;
+import com.mopub.mobileads.VastVideoConfig;
+import com.mopub.mobileads.VideoViewabilityTracker;
+import com.mopub.nativeads.BaseNativeAd.NativeEventListener;
+import com.mopub.nativeads.CustomEventNative.CustomEventNativeListener;
+import com.mopub.nativeads.MoPubCustomEventVideoNative.HeaderVisibilityStrategy;
+import com.mopub.nativeads.MoPubCustomEventVideoNative.MoPubVideoNativeAd;
+import com.mopub.nativeads.MoPubCustomEventVideoNative.MoPubVideoNativeAd.VideoState;
+import com.mopub.nativeads.MoPubCustomEventVideoNative.NativeVideoControllerFactory;
+import com.mopub.nativeads.MoPubCustomEventVideoNative.PayloadVisibilityStrategy;
+import com.mopub.nativeads.MoPubCustomEventVideoNative.VideoResponseHeaders;
+import com.mopub.nativeads.NativeVideoController.VisibilityTrackingEvent;
+import com.mopub.network.MaxWidthImageLoader;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.volley.toolbox.ImageLoader;
+import com.mopub.volley.toolbox.ImageLoader.ImageListener;
+
+import org.json.JSONArray;
+import org.json.JSONObject;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowApplication;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import static com.mopub.common.VolleyRequestMatcher.isUrl;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyBoolean;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Matchers.argThat;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.stub;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class MoPubVideoNativeAdTest {
+
+    private MoPubVideoNativeAd subject;
+    private Activity activity;
+    private JSONObject jsonObject;
+    private Map<String, String> serverExtras;
+    private VideoResponseHeaders videoResponseHeaders;
+
+    @Mock private CustomEventNativeListener mockCustomEventNativeListener;
+    @Mock private VastVideoConfig mockVastVideoConfig;
+    @Mock private MaxWidthImageLoader mockImageLoader;
+    @Mock private ImageLoader.ImageContainer mockImageContainer;
+    @Mock private NativeVideoController mockNativeVideoController;
+    @Mock private VisibilityTracker mockVisibilityTracker;
+    @Mock private NativeVideoControllerFactory mockNativeVideoControllerFactory;
+    @Mock private MediaLayout mockMediaLayout;
+    @Mock private View mockRootView;
+    @Mock private SurfaceTexture mockSurfaceTexture;
+    @Mock private TextureView mockTextureView;
+    @Mock private Drawable mockDrawable;
+    @Mock private MoPubRequestQueue mockRequestQueue;
+    @Mock private NativeEventListener mockNativeEventListener;
+    @Mock private VastManager mockVastManager;
+
+    @Before
+    public void setUp() throws Exception {
+        activity = Robolectric.buildActivity(Activity.class).create().get();
+
+        jsonObject = new JSONObject();
+        jsonObject.put("imptracker", new JSONArray("[\"url1\", \"url2\"]"));
+        jsonObject.put("clktracker", "json click tracker");
+        jsonObject.put("title", "title");
+        jsonObject.put("text", "text");
+        jsonObject.put("mainimage", "mainimageurl");
+        jsonObject.put("iconimage", "iconimageurl");
+        jsonObject.put("clk", "clk");
+        jsonObject.put("fallback", "fallback");
+        jsonObject.put("ctatext", "ctatext");
+        jsonObject.put("video", "video");
+        jsonObject.put("extraimage", "extraimageurl");
+
+        serverExtras = new HashMap<String, String>();
+        serverExtras.put("Play-Visible-Percent", "10");
+        serverExtras.put("Pause-Visible-Percent", "5");
+        serverExtras.put("Impression-Min-Visible-Percent", "15");
+        serverExtras.put("Impression-Visible-Ms", "100");
+        serverExtras.put("Max-Buffer-Ms", "20");
+        videoResponseHeaders = new VideoResponseHeaders(serverExtras);
+
+        when(mockVastVideoConfig.getVideoViewabilityTracker())
+                .thenReturn(new VideoViewabilityTracker(98, 76, "viewabilityTracker"));
+
+        List<VastTracker> vastTrackers = new ArrayList<VastTracker>();
+        vastTrackers.add(new VastTracker("vastimpression1"));
+        vastTrackers.add(new VastTracker("vastimpression2"));
+
+        when(mockVastVideoConfig.getImpressionTrackers()).thenReturn(vastTrackers);
+
+        subject = new MoPubVideoNativeAd(
+                activity, jsonObject, mockCustomEventNativeListener, videoResponseHeaders,
+                mockVisibilityTracker, mockNativeVideoControllerFactory, null,
+                "header click tracker", mockVastManager);
+        subject.setNativeEventListener(mockNativeEventListener);
+        // noinspection unchecked
+        when(mockNativeVideoControllerFactory
+                .createForId(anyInt(), any(Context.class), any(List.class), eq(mockVastVideoConfig),
+                        any(EventDetails.class)))
+                .thenReturn(mockNativeVideoController);
+
+        when(mockImageLoader.get(anyString(), any(ImageListener.class)))
+                .then(new Answer<Void>() {
+                    @Override
+                    public Void answer(final InvocationOnMock invocationOnMock) throws Throwable {
+                        ImageListener listener = ((ImageListener) invocationOnMock.getArguments()[1]);
+                        listener.onResponse(mockImageContainer, false);
+                        return null;
+                    }
+                });
+        when(mockMediaLayout.getTextureView()).thenReturn(mockTextureView);
+
+        stub(mockImageContainer.getBitmap()).toReturn(mock(Bitmap.class));
+        Networking.setImageLoaderForTesting(mockImageLoader);
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+    }
+
+    @After
+    public void tearDown() {
+        Networking.setImageLoaderForTesting(null);
+        Networking.setRequestQueueForTesting(null);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void loadAd_withoutImpTrackerRequiredKey_shouldThrowIllegalArgumentException() {
+        jsonObject.remove("imptracker");
+        subject.loadAd();
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void loadAd_withoutClkTrackerRequiredKey_shouldThrowIllegalArgumentException() {
+        jsonObject.remove("clktracker");
+        subject.loadAd();
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void loadAd_withInvalidValueForRequiredKey_shouldThrowIllegalArgumentException() throws Exception {
+        jsonObject.put("imptracker", 123);
+        subject.loadAd();
+    }
+
+    @Test
+    public void loadAd_withInvalidValueForOptionalKey_shouldNotThrowExcpetion() throws Exception {
+        jsonObject.put("title", 123);
+        subject.loadAd();
+    }
+
+    @Test
+    public void loadAd_shouldInitializeAssetValues() {
+        subject.loadAd();
+
+        assertThat(subject.getImpressionTrackers()).containsOnly("url1", "url2");
+        assertThat(subject.getTitle()).isEqualTo("title");
+        assertThat(subject.getText()).isEqualTo("text");
+        assertThat(subject.getMainImageUrl()).isEqualTo("mainimageurl");
+        assertThat(subject.getIconImageUrl()).isEqualTo("iconimageurl");
+        assertThat(subject.getClickDestinationUrl()).isEqualTo("clk");
+        assertThat(subject.getCallToAction()).isEqualTo("ctatext");
+        assertThat(subject.getPrivacyInformationIconClickThroughUrl()).isEqualTo(
+                "https://www.mopub.com/optout/");
+        assertThat(subject.getVastVideo()).isEqualTo("video");
+        assertThat(subject.getExtra("extraimage")).isEqualTo("extraimageurl");
+        assertThat(subject.getExtras()).hasSize(1);
+    }
+
+    @Test
+    public void loadAd_shouldPrecacheImages_andLoadVastXml() {
+        subject.loadAd();
+
+        verify(mockImageLoader).get(eq("mainimageurl"), any(ImageListener.class));
+        verify(mockImageLoader).get(eq("iconimageurl"), any(ImageListener.class));
+        verify(mockImageLoader).get(eq("extraimageurl"), any(ImageListener.class));
+        verify(mockVastManager).prepareVastVideoConfiguration(eq("video"),
+                any(VastManager.VastManagerListener.class), anyString(), any(Context.class));
+    }
+
+    @Test
+    public void onVastVideoConfigurationPrepared_withNullVastVideoConfig_shouldNotifyListenerFailed() {
+        subject.onVastVideoConfigurationPrepared(null);
+        verify(mockCustomEventNativeListener).onNativeAdFailed(NativeErrorCode.INVALID_RESPONSE);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void onVastVideoConfigurationPrepared_shouldConstructNativeVideoController_shouldNotifyListenerOfAdLoaded() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+
+        ArgumentCaptor<List> argumentCaptor = ArgumentCaptor.forClass(List.class);
+        verify(mockNativeVideoControllerFactory).createForId(anyInt(),
+                eq(activity.getApplicationContext()),
+                argumentCaptor.capture(),
+                eq(mockVastVideoConfig),
+                any(EventDetails.class));
+
+        List<VisibilityTrackingEvent> visibilityTrackingEvents = (List<VisibilityTrackingEvent>) argumentCaptor.getValue();
+        assertThat(visibilityTrackingEvents.get(0).strategy).isInstanceOf(HeaderVisibilityStrategy.class);
+        assertThat(visibilityTrackingEvents.get(0).minimumPercentageVisible).isEqualTo(15);
+        assertThat(visibilityTrackingEvents.get(0).totalRequiredPlayTimeMs).isEqualTo(100);
+
+        assertThat(visibilityTrackingEvents.get(1).strategy).isInstanceOf(PayloadVisibilityStrategy.class);
+        assertThat(visibilityTrackingEvents.get(1).minimumPercentageVisible).isEqualTo(15);
+        assertThat(visibilityTrackingEvents.get(1).totalRequiredPlayTimeMs).isEqualTo(100);
+
+        assertThat(visibilityTrackingEvents.get(2).strategy).isInstanceOf(PayloadVisibilityStrategy.class);
+        assertThat(visibilityTrackingEvents.get(2).minimumPercentageVisible).isEqualTo(15);
+        assertThat(visibilityTrackingEvents.get(2).totalRequiredPlayTimeMs).isEqualTo(100);
+
+        assertThat(visibilityTrackingEvents.get(3).strategy).isInstanceOf(PayloadVisibilityStrategy.class);
+        assertThat(visibilityTrackingEvents.get(3).minimumPercentageVisible).isEqualTo(76);
+        assertThat(visibilityTrackingEvents.get(3).totalRequiredPlayTimeMs).isEqualTo(98);
+
+        verify(mockVastVideoConfig).getImpressionTrackers();
+        verify(mockVastVideoConfig).addClickTrackers(any(List.class));
+        verify(mockVastVideoConfig).setClickThroughUrl("clk");
+        verify(mockCustomEventNativeListener).onNativeAdLoaded(subject);
+    }
+
+    @Ignore("This test is broken")
+    @SuppressWarnings("unchecked")
+    @Test
+    public void onVastVideoConfigurationPrepared_shouldMergeHeaderAndJsonClickTrackers() {
+        final ArgumentCaptor<List> argumentCaptor = ArgumentCaptor.forClass(List.class);
+
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+
+        verify(mockVastVideoConfig).addClickTrackers(argumentCaptor.capture());
+        final List<VastTracker> actualClickTrackers = (List<VastTracker>) argumentCaptor.getValue();
+        assertThat(actualClickTrackers.size()).isEqualTo(2);
+        final VastTracker headerClickTracker = actualClickTrackers.get(0);
+        final VastTracker jsonClickTracker = actualClickTrackers.get(1);
+        assertThat(headerClickTracker.getTrackingUrl()).isEqualTo("header click tracker");
+        assertThat(headerClickTracker.isRepeatable()).isFalse();
+        assertThat(jsonClickTracker.getTrackingUrl()).isEqualTo("json click tracker");
+        assertThat(jsonClickTracker.isRepeatable()).isFalse();
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void onVastVideoConfigurationPrepared_shouldDedupeHeaderAndJsonClickTrackers() throws Exception {
+        jsonObject.remove("clktracker");
+        jsonObject.put("clktracker", "header click tracker");
+        final ArgumentCaptor<List> argumentCaptor = ArgumentCaptor.forClass(List.class);
+
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+
+        verify(mockVastVideoConfig).addClickTrackers(argumentCaptor.capture());
+        final List<VastTracker> actualClickTrackers = (List<VastTracker>) argumentCaptor.getValue();
+        assertThat(actualClickTrackers.size()).isEqualTo(1);
+        final VastTracker clickTracker = actualClickTrackers.get(0);
+        assertThat(clickTracker.getTrackingUrl()).isEqualTo("header click tracker");
+        assertThat(clickTracker.isRepeatable()).isFalse();
+    }
+
+    @Ignore("This test is broken")
+    @SuppressWarnings("unchecked")
+    @Test
+    public void onVastVideoConfigurationPrepared_shouldAcceptJsonArrayClickTrackers() throws Exception {
+        jsonObject.remove("clktracker");
+        jsonObject.put("clktracker",
+                new JSONArray("[\"json click tracker 1\", \"json click tracker 2\"]"));
+        final ArgumentCaptor<List> argumentCaptor = ArgumentCaptor.forClass(List.class);
+
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+
+        verify(mockVastVideoConfig).addClickTrackers(argumentCaptor.capture());
+        final List<VastTracker> actualClickTrackers = (List<VastTracker>) argumentCaptor.getValue();
+        assertThat(actualClickTrackers.size()).isEqualTo(3);
+        final VastTracker jsonClickTracker1 = actualClickTrackers.get(0);
+        final VastTracker jsonClickTracker2 = actualClickTrackers.get(1);
+        final VastTracker headerClickTracker = actualClickTrackers.get(2);
+        assertThat(jsonClickTracker1.getTrackingUrl()).isEqualTo("json click tracker 1");
+        assertThat(jsonClickTracker1.isRepeatable()).isFalse();
+        assertThat(jsonClickTracker2.getTrackingUrl()).isEqualTo("json click tracker 2");
+        assertThat(jsonClickTracker2.isRepeatable()).isFalse();
+        assertThat(headerClickTracker.getTrackingUrl()).isEqualTo("header click tracker");
+        assertThat(headerClickTracker.isRepeatable()).isFalse();
+    }
+
+    @Ignore("This test is broken")
+    @SuppressWarnings("unchecked")
+    @Test
+    public void onVastVideoConfigurationPrepared_shouldDedupeJsonArrayClickTrackers() throws Exception {
+        jsonObject.remove("clktracker");
+        jsonObject.put("clktracker",
+                new JSONArray("[\"json click tracker\", \"header click tracker\"]"));
+        final ArgumentCaptor<List> argumentCaptor = ArgumentCaptor.forClass(List.class);
+
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+
+        verify(mockVastVideoConfig).addClickTrackers(argumentCaptor.capture());
+        final List<VastTracker> actualClickTrackers = (List<VastTracker>) argumentCaptor.getValue();
+        assertThat(actualClickTrackers.size()).isEqualTo(2);
+        final VastTracker headerClickTracker = actualClickTrackers.get(0);
+        final VastTracker jsonClickTracker = actualClickTrackers.get(1);
+        assertThat(headerClickTracker.getTrackingUrl()).isEqualTo("header click tracker");
+        assertThat(headerClickTracker.isRepeatable()).isFalse();
+        assertThat(jsonClickTracker.getTrackingUrl()).isEqualTo("json click tracker");
+        assertThat(jsonClickTracker.isRepeatable()).isFalse();
+    }
+
+    @Test
+    public void render_shouldAddViewToVisibilityTracker() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        verify(mockVisibilityTracker).addView(mockRootView, mockMediaLayout, 10, 5);
+    }
+
+    @Test
+    public void render_shouldSetupMediaLayout() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        verify(mockMediaLayout).setSurfaceTextureListener(any(SurfaceTextureListener.class));
+        verify(mockMediaLayout).setPlayButtonClickListener(any(View.OnClickListener.class));
+        verify(mockMediaLayout).setMuteControlClickListener(any(View.OnClickListener.class));
+        verify(mockMediaLayout).setOnClickListener(any(View.OnClickListener.class));
+    }
+
+    @Test
+    public void render_shouldApplyStatePaused() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        verify(mockMediaLayout).setMode(MediaLayout.Mode.PAUSED);
+    }
+
+    @Test
+    public void render_withPlaybackStateCleared_shouldPrepareNativeVideoController() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        when(mockNativeVideoController.getPlaybackState()).thenReturn(NativeVideoController
+                .STATE_CLEARED);
+        subject.render(mockMediaLayout);
+
+        verify(mockNativeVideoController).prepare(subject);
+    }
+
+    @Test
+    public void MediaLayout_surfaceTextureListener_onSurfaceTextureAvailable_shouldSetupNativeVideoController_shouldResetMediaLayoutProgress() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        ArgumentCaptor<SurfaceTextureListener> argumentCaptor =
+                ArgumentCaptor.forClass(SurfaceTextureListener.class);
+        verify(mockMediaLayout).setSurfaceTextureListener(argumentCaptor.capture());
+        SurfaceTextureListener surfaceTextureListener = argumentCaptor.getValue();
+
+        surfaceTextureListener.onSurfaceTextureAvailable(mockSurfaceTexture, 0, 0);
+
+        verify(mockNativeVideoController).setListener(subject);
+        verify(mockNativeVideoController).setOnAudioFocusChangeListener(subject);
+        verify(mockNativeVideoController).setProgressListener(subject);
+        verify(mockNativeVideoController).setTextureView(mockMediaLayout.getTextureView());
+        verify(mockMediaLayout).resetProgress();
+    }
+
+    @Test
+    public void MediaLayout_surfaceTextureListener_onSurfaceTextureAvailable_withCurrentPositionWithinThreshhold_withStateEnded_shouldSetFinalFrameAsMainImage() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        ArgumentCaptor<SurfaceTextureListener> argumentCaptor =
+                ArgumentCaptor.forClass(SurfaceTextureListener.class);
+        verify(mockMediaLayout).setSurfaceTextureListener(argumentCaptor.capture());
+        SurfaceTextureListener surfaceTextureListener = argumentCaptor.getValue();
+
+        when(mockNativeVideoController.getPlaybackState())
+                .thenReturn(NativeVideoController.STATE_ENDED);
+        when(mockNativeVideoController.getCurrentPosition()).thenReturn(9L);
+        when(mockNativeVideoController.getDuration()).thenReturn(10L);
+        when(mockNativeVideoController.hasFinalFrame()).thenReturn(true);
+        when(mockNativeVideoController.getFinalFrame()).thenReturn(mockDrawable);
+
+        surfaceTextureListener.onSurfaceTextureAvailable(mockSurfaceTexture, 0, 0);
+
+        verify(mockMediaLayout).setMainImageDrawable(mockNativeVideoController.getFinalFrame());
+    }
+
+    @Test
+    public void MediaLayout_surfaceTextureListener_onSurfaceTextureAvailable_withNeedsPrepare_shouldPrepareNativeVideoController() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.render(mockMediaLayout);
+
+        ArgumentCaptor<SurfaceTextureListener> argumentCaptor =
+                ArgumentCaptor.forClass(SurfaceTextureListener.class);
+        verify(mockMediaLayout).setSurfaceTextureListener(argumentCaptor.capture());
+        SurfaceTextureListener surfaceTextureListener = argumentCaptor.getValue();
+
+        surfaceTextureListener.onSurfaceTextureAvailable(mockSurfaceTexture, 0, 0);
+
+        verify(mockNativeVideoController).prepare(subject);
+    }
+
+    @Test
+    public void MediaLayout_surfaceTextureListener_onSurfaceTextureDestroyed_shouldSetNeedsPrepareTrue_shouldReleaseMoPubNativeVideoAd_shouldApplyStatePaused() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        ArgumentCaptor<SurfaceTextureListener> argumentCaptor =
+                ArgumentCaptor.forClass(SurfaceTextureListener.class);
+        verify(mockMediaLayout).setSurfaceTextureListener(argumentCaptor.capture());
+        SurfaceTextureListener surfaceTextureListener = argumentCaptor.getValue();
+
+        surfaceTextureListener.onSurfaceTextureDestroyed(mockSurfaceTexture);
+
+        assertThat(subject.needsPrepare()).isTrue();
+        verify(mockNativeVideoController).release(subject);
+        verify(mockMediaLayout).setMode(MediaLayout.Mode.PAUSED);
+    }
+
+    @Test
+    public void MediaLayout_playButtonClickListener_shouldResetMediaLayoutProgress_shouldSeekTo0_shouldSetEndedFalse_shouldSetNeedsSeekFalse() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        ArgumentCaptor<View.OnClickListener> argumentCaptor =
+                ArgumentCaptor.forClass(View.OnClickListener.class);
+        verify(mockMediaLayout).setPlayButtonClickListener(argumentCaptor.capture());
+
+        View.OnClickListener onClickListener = argumentCaptor.getValue();
+        onClickListener.onClick(null);
+
+        verify(mockMediaLayout).resetProgress();
+        verify(mockNativeVideoController).seekTo(0);
+        assertThat(subject.hasEnded()).isEqualTo(false);
+        assertThat(subject.needsSeek()).isEqualTo(false);
+    }
+
+    @Test
+    public void MediaLayout_muteButtonClickListener_withStateReady_shouldToggleMutedState() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        ArgumentCaptor<View.OnClickListener> argumentCaptor =
+                ArgumentCaptor.forClass(View.OnClickListener.class);
+        verify(mockMediaLayout).setMuteControlClickListener(argumentCaptor.capture());
+
+        View.OnClickListener onClickListener = argumentCaptor.getValue();
+        onClickListener.onClick(null);
+        assertThat(subject.isMuted()).isFalse();
+
+        onClickListener.onClick(null);
+        assertThat(subject.isMuted()).isTrue();
+    }
+
+    @Test
+    public void MediaLayout_clickListener_shouldPrepareToLeaveView_shouldTriggerImpressionTracker_shouldNotDisableAppAudio_shouldStartFullScreenVideoActivity() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        ArgumentCaptor<View.OnClickListener> argumentCaptor =
+                ArgumentCaptor.forClass(View.OnClickListener.class);
+        verify(mockMediaLayout).setOnClickListener(argumentCaptor.capture());
+
+        reset(mockNativeVideoController);
+        View.OnClickListener onClickListener = argumentCaptor.getValue();
+        onClickListener.onClick(null);
+
+        assertThat(subject.needsSeek()).isTrue();
+        assertThat(subject.needsPrepare()).isTrue();
+        assertThat(subject.needsPrepare()).isTrue();
+        verify(mockNativeVideoController).setListener(null);
+        verify(mockNativeVideoController).setOnAudioFocusChangeListener(null);
+        verify(mockNativeVideoController).setProgressListener(null);
+        verify(mockNativeVideoController).clear();
+        verify(mockNativeVideoController).triggerImpressionTrackers();
+        verify(mockMediaLayout).setMode(MediaLayout.Mode.PAUSED);
+        verify(mockNativeVideoController, never()).setAppAudioEnabled(anyBoolean());
+
+        final Intent startedActivity = ShadowApplication.getInstance().peekNextStartedActivity();
+        assertThat(startedActivity.getComponent().getClassName())
+                .isEqualTo(MraidVideoPlayerActivity.class.getName());
+        assertThat(startedActivity.getStringExtra(BaseVideoPlayerActivity.VIDEO_CLASS_EXTRAS_KEY))
+                .isEqualTo("native");
+        assertThat(startedActivity.getLongExtra(Constants.NATIVE_VIDEO_ID, 0L))
+                .isGreaterThan(0L);
+        assertThat(startedActivity.getSerializableExtra(Constants
+                .NATIVE_VAST_VIDEO_CONFIG))
+                .isEqualTo(mockVastVideoConfig);
+    }
+
+    @Test
+    public void prepare_shouldSetOnClickListenerOnView() {
+        subject.prepare(mockRootView);
+        verify(mockRootView).setOnClickListener(any(View.OnClickListener.class));
+    }
+
+    @Test
+    public void RootView_onClickListener_onClick_shouldPrepareToLeaveView_shouldNotDisableAppAudio_shouldNotNotifyAdClicked_shouldTriggerImpressionTrackers_shouldshouldHandleCtaClick() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        ArgumentCaptor<View.OnClickListener> argumentCaptor =
+                ArgumentCaptor.forClass(View.OnClickListener.class);
+        verify(mockRootView).setOnClickListener(argumentCaptor.capture());
+
+        View.OnClickListener onClickListener = argumentCaptor.getValue();
+        reset(mockNativeVideoController);
+        onClickListener.onClick(null);
+
+        assertThat(subject.needsSeek()).isTrue();
+        assertThat(subject.needsPrepare()).isTrue();
+        assertThat(subject.needsPrepare()).isTrue();
+        verify(mockNativeVideoController).setListener(null);
+        verify(mockNativeVideoController).setOnAudioFocusChangeListener(null);
+        verify(mockNativeVideoController).setProgressListener(null);
+        verify(mockNativeVideoController).clear();
+        verify(mockMediaLayout).setMode(MediaLayout.Mode.PAUSED);
+        verify(mockNativeVideoController).handleCtaClick(activity.getApplicationContext());
+        verify(mockNativeEventListener, never()).onAdClicked();
+        verify(mockNativeVideoController).triggerImpressionTrackers();
+        verify(mockNativeVideoController, never()).setAppAudioEnabled(anyBoolean());
+    }
+
+    @Test
+    public void clear_shouldClearNativeVideoController_shouldSetMediaLayoutModeImage_shouldSetMediaLayoutNull_shouldSetMediaLayoutListenersToNull_shouldRemoveMediaLayoutFromVisibilityTracker() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+        subject.clear(mockRootView);
+
+        verify(mockNativeVideoController).clear();
+        verify(mockMediaLayout).setMode(MediaLayout.Mode.IMAGE);
+        verify(mockMediaLayout).setSurfaceTextureListener(null);
+        verify(mockMediaLayout).setPlayButtonClickListener(null);
+        verify(mockMediaLayout).setMuteControlClickListener(null);
+        verify(mockMediaLayout).setOnClickListener(null);
+        verify(mockVisibilityTracker).removeView(mockMediaLayout);
+        assertThat(subject.getMediaLayout()).isNull();
+    }
+
+    @Test
+    public void destroy_shouldSetPlayWhenReadyFalse_shouldReleaseNativeVideoController_shouldRemoveNativeVideoController_shouldDestroyVisibilityTracker() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        reset(mockNativeVideoController);
+        subject.destroy();
+
+        verify(mockMediaLayout).setMode(MediaLayout.Mode.IMAGE);
+        verify(mockMediaLayout).setSurfaceTextureListener(null);
+        verify(mockMediaLayout).setPlayButtonClickListener(null);
+        verify(mockMediaLayout).setMuteControlClickListener(null);
+        verify(mockMediaLayout).setOnClickListener(null);
+        verify(mockVisibilityTracker).removeView(mockMediaLayout);
+
+        assertThat(subject.getMediaLayout()).isNull();
+        verify(mockNativeVideoController).setPlayWhenReady(false);
+        verify(mockNativeVideoController).release(subject);
+        assertThat(NativeVideoController.getForId(subject.getId())).isNull();
+        verify(mockVisibilityTracker).destroy();
+    }
+
+    @Test
+    public void onStateChanged_shouldAppropriatelySetVideoState() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        subject.onStateChanged(true, NativeVideoController.STATE_PREPARING);
+        assertThat(subject.getVideoState()).isEqualTo(VideoState.LOADING);
+
+        subject.onStateChanged(true, NativeVideoController.STATE_IDLE);
+        assertThat(subject.getVideoState()).isEqualTo(VideoState.LOADING);
+
+        subject.onStateChanged(true, NativeVideoController.STATE_BUFFERING);
+        assertThat(subject.getVideoState()).isEqualTo(VideoState.BUFFERING);
+
+        subject.onStateChanged(true, NativeVideoController.STATE_READY);
+        assertThat(subject.getVideoState()).isEqualTo(VideoState.PAUSED);
+
+        subject.setLatestVisibility(true);
+        subject.onStateChanged(true, NativeVideoController.STATE_READY);
+        assertThat(subject.getVideoState()).isEqualTo(VideoState.PLAYING_MUTED);
+
+        subject.setMuted(false);
+        subject.onStateChanged(true, NativeVideoController.STATE_READY);
+        assertThat(subject.getVideoState()).isEqualTo(VideoState.PLAYING);
+
+        subject.onStateChanged(true, NativeVideoController.STATE_ENDED);
+        assertThat(subject.getVideoState()).isEqualTo(VideoState.ENDED);
+        assertThat(subject.hasEnded()).isTrue();
+    }
+
+    @Test
+    public void onError_shouldSetVideoStateError() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        subject.onError(new Exception());
+
+        assertThat(subject.getVideoState()).isEqualTo(VideoState.FAILED_LOAD);
+    }
+
+    @Test
+    public void updateProgress_shouldUpdateMediaLayoutProgress() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        subject.updateProgress(312);
+
+        verify(mockMediaLayout).updateProgress(312);
+    }
+
+    @Test
+    public void onAudioFocusChange_withFocusChangeAudioFocusLossOrAudioFocusLossTransient_shouldMuteTheVideo() throws Exception {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        subject.setMuted(false);
+        subject.onAudioFocusChange(AudioManager.AUDIOFOCUS_LOSS);
+
+        assertThat(subject.isMuted()).isTrue();
+
+        subject.setMuted(false);
+        subject.onAudioFocusChange(AudioManager.AUDIOFOCUS_LOSS_TRANSIENT);
+
+        assertThat(subject.isMuted()).isTrue();
+    }
+
+    @Test
+    public void onAudioFocusChange_withFocusChangeAudioFocusLossTransientCanDuck_shouldLowerVolume() throws Exception {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        subject.onAudioFocusChange(AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK);
+
+        verify(mockNativeVideoController).setAudioVolume(0.3f);
+    }
+
+    @Test
+    public void onAudioFocusChange_withFocusChangeAudioFocusGain_shouldRaiseVolume() throws Exception {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        subject.onAudioFocusChange(AudioManager.AUDIOFOCUS_GAIN);
+
+        verify(mockNativeVideoController).setAudioVolume(1.0f);
+    }
+
+    @Test
+    public void applyState_shouldHandleError_shouldSetAppAudioEnabledFalse_shouldSetMediaLayoutModeImage() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        reset(mockNativeVideoController);
+        subject.applyState(VideoState.FAILED_LOAD);
+
+        verify(mockVastVideoConfig).handleError(activity.getApplicationContext(), null, 0);
+        verify(mockNativeVideoController).setAppAudioEnabled(false);
+        verify(mockMediaLayout).setMode(MediaLayout.Mode.IMAGE);
+    }
+
+    @Test
+    public void applyState_withVideoStateCreatedOrLoading_shouldSetPlayWhenReadyTrue_shouldSetMediaLayoutModeLoading() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        subject.applyState(VideoState.CREATED);
+
+        verify(mockNativeVideoController).setPlayWhenReady(true);
+        verify(mockMediaLayout).setMode(MediaLayout.Mode.LOADING);
+
+        reset(mockNativeVideoController);
+        reset(mockMediaLayout);
+        subject.applyState(VideoState.LOADING);
+
+        verify(mockNativeVideoController).setPlayWhenReady(true);
+        verify(mockMediaLayout).setMode(MediaLayout.Mode.LOADING);
+    }
+
+    @Test
+    public void applyState_withVideoStateBuffering_shouldSetPlayWhenReadyTrue_shouldSetMediaLayoutModeBuffering() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        subject.applyState(VideoState.BUFFERING);
+
+        verify(mockNativeVideoController).setPlayWhenReady(true);
+        verify(mockMediaLayout).setMode(MediaLayout.Mode.BUFFERING);
+    }
+
+    @Test
+    public void applyState_withVideoStatePaused_withTransitionToFullScreenFalse_shouldSetAppAudioEnabledFalse_shouldSetPlayWhenReadyFalse_shouldSetMediaLayoutModePaused() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        subject.applyState(VideoState.PAUSED);
+
+        verify(mockNativeVideoController).setAppAudioEnabled(false);
+        verify(mockNativeVideoController).setPlayWhenReady(false);
+        verify(mockMediaLayout).setMode(MediaLayout.Mode.PAUSED);
+    }
+
+    @Test
+    public void applyState_withVideoStatePlaying_shouldSetPlayWhenReadyTrue_shouldSetAudioEnabledTrue_shouldSetAppAudioEnabledTrue_shouldSetMediaLayoutModePlaying_shouldSetMuteStateUnmuted() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        reset(mockNativeVideoController);
+        subject.applyState(VideoState.PLAYING);
+
+        verify(mockNativeVideoController).setPlayWhenReady(true);
+        verify(mockNativeVideoController).setAudioEnabled(true);
+        verify(mockNativeVideoController).setAppAudioEnabled(true);
+        verify(mockMediaLayout).setMode(MediaLayout.Mode.PLAYING);
+        verify(mockMediaLayout).setMuteState(MediaLayout.MuteState.UNMUTED);
+    }
+
+    @Test
+    public void applyState_withVideoStatePlaying_withNeedsSeek_shouldSeekToCurrentPosition() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        assertThat(subject.needsSeek()).isTrue();
+        when(mockNativeVideoController.getCurrentPosition()).thenReturn(543L);
+        subject.applyState(VideoState.PLAYING);
+
+        verify(mockNativeVideoController).seekTo(mockNativeVideoController.getCurrentPosition());
+    }
+
+    @Test
+    public void applyState_withVideoStatePlayingMuted_shouldSetPlayWhenReadyTrue_shouldSetAudioEnabledFalse_shouldSetAppAudioEnabledTrue_shouldSetMediaLayoutModePlaying_shouldSetMuteStateMuted() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        reset(mockNativeVideoController);
+        subject.applyState(VideoState.PLAYING_MUTED);
+
+        verify(mockNativeVideoController).setPlayWhenReady(true);
+        verify(mockNativeVideoController).setAudioEnabled(false);
+        verify(mockNativeVideoController).setAppAudioEnabled(false);
+        verify(mockMediaLayout).setMode(MediaLayout.Mode.PLAYING);
+        verify(mockMediaLayout).setMuteState(MediaLayout.MuteState.MUTED);
+    }
+
+    @Test
+    public void applyState_withVideoStatePlayingMuted_withNeedsSeek_shouldSeekToCurrentPosition() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        assertThat(subject.needsSeek()).isTrue();
+        when(mockNativeVideoController.getCurrentPosition()).thenReturn(543L);
+        subject.applyState(VideoState.PLAYING_MUTED);
+
+        verify(mockNativeVideoController).seekTo(mockNativeVideoController.getCurrentPosition());
+    }
+
+    @Test
+    public void applyState_withVideoStatePlayingEnded_shouldHandleComplete_shouldSetAppAudioEnabledTrue_shouldSetMediaLayoutModeFinished_shouldUpdateMediaLayoutProgress1000() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        reset(mockNativeVideoController);
+        subject.applyState(VideoState.ENDED);
+
+        verify(mockVastVideoConfig).handleComplete(activity.getApplicationContext(), 0);
+        verify(mockNativeVideoController).setAppAudioEnabled(false);
+        verify(mockMediaLayout).setMode(MediaLayout.Mode.FINISHED);
+        verify(mockMediaLayout).updateProgress(1000);
+
+        verify(mockMediaLayout, never()).setMainImageDrawable(any(Drawable.class));
+    }
+
+    @Test
+    public void applyState_withVideoStatePlayingEnded_withFinalFrame_shouldSetMainImageDrawableOfMediaLayout() {
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        when(mockNativeVideoController.hasFinalFrame()).thenReturn(true);
+        when(mockNativeVideoController.getFinalFrame()).thenReturn(mockDrawable);
+        subject.applyState(VideoState.ENDED);
+
+        verify(mockMediaLayout).setMainImageDrawable(mockNativeVideoController.getFinalFrame());
+    }
+
+    @Test
+    public void applyState_withVideoStatePause_afterVideoStatePlayingMuted_shouldFirePauseTrackers() {
+        final ArrayList<VastTracker> testList = new ArrayList<VastTracker>();
+        testList.add(new VastTracker("testUrl", true));
+
+        when(mockVastVideoConfig.getPauseTrackers()).thenReturn(testList);
+
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        subject.applyState(VideoState.PLAYING_MUTED);
+        subject.applyState(VideoState.PAUSED);
+
+        verify(mockVastVideoConfig).getPauseTrackers();
+        verify(mockRequestQueue).add(argThat(isUrl("testUrl")));
+    }
+
+    @Test
+    public void applyState_withVideoStatePlayingMuted_afterPaused_afterPlaying_shouldFireResumeTrackers() {
+        final ArrayList<VastTracker> testList = new ArrayList<VastTracker>();
+        testList.add(new VastTracker("testResumeUrl", true));
+
+        when(mockVastVideoConfig.getResumeTrackers()).thenReturn(testList);
+
+        subject.loadAd();
+        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
+        subject.prepare(mockRootView);
+        subject.render(mockMediaLayout);
+
+        subject.applyState(VideoState.PLAYING_MUTED);
+        subject.applyState(VideoState.PAUSED);
+        subject.applyState(VideoState.BUFFERING);
+        subject.applyState(VideoState.PLAYING_MUTED);
+
+        verify(mockVastVideoConfig).getPauseTrackers();
+        verify(mockRequestQueue).add(argThat(isUrl("testResumeUrl")));
+    }
+
+    @Test
+    public void HeaderVisibilityStrategy_execute_shouldNotifyAdImpressed() throws Exception {
+        HeaderVisibilityStrategy headerVisibilityStrategy
+                = new HeaderVisibilityStrategy(subject);
+        headerVisibilityStrategy.execute();
+
+        verify(mockNativeEventListener).onAdImpressed();
+    }
+
+    @Test
+    public void PayloadVisibilityStrategy_execute_shouldMakeTrackingRequest() throws Exception {
+        PayloadVisibilityStrategy payloadVisibilityStrategy
+                = new PayloadVisibilityStrategy(activity, "payloadUrl");
+        payloadVisibilityStrategy.execute();
+
+        verify(mockRequestQueue).add(argThat(isUrl("payloadUrl")));
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdSourceTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdSourceTest.java
new file mode 100644
index 00000000..413ef327
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdSourceTest.java
@@ -0,0 +1,384 @@
+package com.mopub.nativeads;
+
+import android.os.Handler;
+import android.os.SystemClock;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowSystemClock;
+
+import java.util.ArrayList;
+
+import static com.mopub.nativeads.NativeAdSource.AdSourceListener;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyLong;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class NativeAdSourceTest {
+    private NativeAdSource subject;
+    private ArrayList<TimestampWrapper<NativeAd>> nativeAdCache;
+    private RequestParameters requestParameters;
+    private int defaultRetryTime;
+    private int maxRetryTime;
+    private int maxRetries;
+
+    @Mock private AdSourceListener mockAdSourceListener;
+    @Mock private MoPubNative mockMoPubNative;
+    @Mock private NativeAd mMockNativeAd;
+    @Mock private Handler mockReplenishCacheHandler;
+    @Mock private AdRendererRegistry mockAdRendererRegistry;
+    @Mock private MoPubStaticNativeAdRenderer mockRenderer;
+
+    @Before
+    public void setUp() {
+        nativeAdCache = new ArrayList<TimestampWrapper<NativeAd>>(2);
+        subject = new NativeAdSource(nativeAdCache, mockReplenishCacheHandler, mockAdRendererRegistry);
+        subject.setAdSourceListener(mockAdSourceListener);
+
+        requestParameters = new RequestParameters.Builder().build();
+
+        defaultRetryTime = 1000;
+        maxRetryTime = 5*60*1000;
+        maxRetries = 5;
+
+        // XXX We need this to ensure that our SystemClock starts
+        ShadowSystemClock.uptimeMillis();
+
+        ArrayList<MoPubAdRenderer> moPubAdRenderers = new ArrayList<MoPubAdRenderer>();
+        moPubAdRenderers.add(mockRenderer);
+        when(mockAdRendererRegistry.getRendererIterable()).thenReturn(moPubAdRenderers);
+    }
+
+    @Test
+    public void constructor_shouldInitializeCorrectly() {
+        assertThat(subject.mRequestInFlight).isFalse();
+        assertThat(subject.mSequenceNumber).isEqualTo(0);
+        assertThat(subject.getRetryTime()).isEqualTo(defaultRetryTime);
+    }
+
+    @Test
+    public void getAdRendererCount_shouldCallAdRendererRegistryGetAdRendererCount() throws Exception {
+        when(mockAdRendererRegistry.getAdRendererCount()).thenReturn(123);
+
+        assertThat(subject.getAdRendererCount()).isEqualTo(123);
+
+        verify(mockAdRendererRegistry).getAdRendererCount();
+    }
+
+    @Test
+    public void getViewTypeForAd_shouldCallAdRendererRegistryGetViewTypeForAd() throws Exception {
+        NativeAd nativeAd = mock(NativeAd.class);
+        when(mockAdRendererRegistry.getViewTypeForAd(nativeAd)).thenReturn(123);
+
+        assertThat(subject.getViewTypeForAd(nativeAd)).isEqualTo(123);
+
+        verify(mockAdRendererRegistry).getViewTypeForAd(nativeAd);
+    }
+
+    @Test
+    public void registerAdRenderer_shouldRegisterAdRendererWithRegistryAndMoPubNative() throws Exception {
+        subject.setMoPubNative(mockMoPubNative);
+        subject.registerAdRenderer(mockRenderer);
+
+        verify(mockAdRendererRegistry).registerAdRenderer(mockRenderer);
+        verify(mockMoPubNative).registerAdRenderer(mockRenderer);
+    }
+
+    @Test
+    public void getAdRendererForViewType_shouldCallAdRendererRegistryGetRendererForViewType() throws Exception {
+        when(mockAdRendererRegistry.getRendererForViewType(123)).thenReturn(mockRenderer);
+
+        assertThat(subject.getAdRendererForViewType(123)).isEqualTo(mockRenderer);
+
+        verify(mockAdRendererRegistry).getRendererForViewType(123);
+    }
+
+    @Test
+    public void loadAds_shouldReplenishCache() {
+        subject.loadAds(requestParameters, mockMoPubNative);
+        assertThat(subject.mRequestInFlight).isTrue();
+        verify(mockMoPubNative).makeRequest(requestParameters, 0);
+    }
+
+    @Test
+    public void loadAds_shouldReregisterAdRenderersWithNewMoPubNative() throws Exception {
+        subject.loadAds(mock(RequestParameters.class), mockMoPubNative);
+
+        verify(mockMoPubNative).registerAdRenderer(mockRenderer);
+    }
+
+    @Test
+    public void loadAds_shouldClearNativeAdSource() {
+        subject.setMoPubNative(mockMoPubNative);
+        TimestampWrapper<NativeAd> timestampWrapper =
+                new TimestampWrapper<NativeAd>(mock(NativeAd.class));
+        nativeAdCache.add(timestampWrapper);
+        subject.mRequestInFlight = true;
+        subject.mSequenceNumber = 5;
+        subject.mCurrentRetries = maxRetries;
+
+        subject.loadAds(requestParameters, mockMoPubNative);
+
+        verify(timestampWrapper.mInstance).destroy();
+        assertThat(nativeAdCache).isEmpty();
+        verify(mockMoPubNative).destroy();
+        verify(mockReplenishCacheHandler).removeMessages(0);
+        assertThat(subject.mSequenceNumber).isEqualTo(0);
+        assertThat(subject.mCurrentRetries).isEqualTo(0);
+        assertThat(subject.getRetryTime()).isEqualTo(defaultRetryTime);
+
+        // new request has been kicked off
+        assertThat(subject.mRequestInFlight).isTrue();
+    }
+
+    @Test
+    public void loadAds_shouldDestroyPreviousMoPubNativeInstance() {
+        subject.loadAds(requestParameters, mockMoPubNative);
+        verify(mockMoPubNative, never()).destroy();
+
+        subject.loadAds(requestParameters, mockMoPubNative);
+        verify(mockMoPubNative).destroy();
+    }
+
+    @Test
+    public void clear_shouldDestroyMoPubNative_shouldClearNativeAdCache_shouldRemovePollHandlerMessages_shouldResetSequenceNumber_shouldResetRequestInFlight_shouldResetRetryTime() {
+        subject.setMoPubNative(mockMoPubNative);
+        TimestampWrapper<NativeAd> timestampWrapper = new TimestampWrapper<NativeAd>(mock(NativeAd.class));
+        nativeAdCache.add(timestampWrapper);
+        subject.mRequestInFlight = true;
+        subject.mSequenceNumber = 5;
+        subject.mCurrentRetries = maxRetries;
+
+        subject.clear();
+
+        verify(timestampWrapper.mInstance).destroy();
+        assertThat(nativeAdCache).isEmpty();
+        verify(mockMoPubNative).destroy();
+        verify(mockReplenishCacheHandler).removeMessages(0);
+        assertThat(subject.mRequestInFlight).isFalse();
+        assertThat(subject.mSequenceNumber).isEqualTo(0);
+        assertThat(subject.getRetryTime()).isEqualTo(defaultRetryTime);
+    }
+
+    @Test
+    public void dequeueAd_withNonStaleAd_shouldReturnNativeAd() {
+        subject.setMoPubNative(mockMoPubNative);
+        nativeAdCache.add(new TimestampWrapper<NativeAd>(mMockNativeAd));
+
+        assertThat(subject.dequeueAd()).isEqualTo(mMockNativeAd);
+        assertThat(nativeAdCache).isEmpty();
+    }
+
+    @Test
+    public void dequeueAd_withStaleAd_shouldReturnNativeAd() {
+        subject.setMoPubNative(mockMoPubNative);
+
+        TimestampWrapper<NativeAd> timestampWrapper = new TimestampWrapper<NativeAd>(
+                mMockNativeAd);
+        timestampWrapper.mCreatedTimestamp = SystemClock.uptimeMillis() - (4*60*60*1000+1);
+        nativeAdCache.add(timestampWrapper);
+
+        assertThat(subject.dequeueAd()).isNull();
+        assertThat(nativeAdCache).isEmpty();
+    }
+
+    @Test
+    public void dequeueAd_noRequestInFlight_shouldReplenishCache() {
+        subject.setMoPubNative(mockMoPubNative);
+
+        nativeAdCache.add(new TimestampWrapper<NativeAd>(mMockNativeAd));
+
+        assertThat(subject.dequeueAd()).isEqualTo(mMockNativeAd);
+
+        assertThat(nativeAdCache).isEmpty();
+        verify(mockReplenishCacheHandler).post(any(Runnable.class));
+    }
+
+    @Test
+    public void dequeueAd_requestInFlight_shouldNotReplenishCache() {
+        subject.setMoPubNative(mockMoPubNative);
+
+        nativeAdCache.add(new TimestampWrapper<NativeAd>(mMockNativeAd));
+
+        subject.mRequestInFlight = true;
+        assertThat(subject.dequeueAd()).isEqualTo(mMockNativeAd);
+
+        assertThat(nativeAdCache).isEmpty();
+        verify(mockReplenishCacheHandler, never()).post(any(Runnable.class));
+    }
+
+    @Test
+    public void updateRetryTime_shouldUpdateRetryTimeUntilAt10Minutes() {
+        int retryTime = 0;
+        while (subject.mCurrentRetries < maxRetries) {
+            subject.updateRetryTime();
+            retryTime = subject.getRetryTime();
+        }
+
+        assertThat(retryTime).isEqualTo(maxRetryTime);
+
+        // assert it won't change anymore
+        subject.updateRetryTime();
+        assertThat(retryTime).isEqualTo(subject.getRetryTime());
+    }
+
+    @Test
+    public void resetRetryTime_shouldSetRetryTimeTo1Second() {
+        assertThat(subject.getRetryTime()).isEqualTo(defaultRetryTime);
+
+        subject.updateRetryTime();
+        assertThat(subject.getRetryTime()).isGreaterThan(defaultRetryTime);
+
+        subject.resetRetryTime();
+        assertThat(subject.getRetryTime()).isEqualTo(defaultRetryTime);
+    }
+
+    @Test
+    public void replenishCache_shouldLoadNativeAd_shouldMarkRequestInFlight() {
+        subject.setMoPubNative(mockMoPubNative);
+
+        subject.replenishCache();
+
+        verify(mockMoPubNative).makeRequest(any(RequestParameters.class), eq(0));
+        assertThat(subject.mRequestInFlight).isTrue();
+    }
+
+    @Test
+    public void replenishCache_withRequestInFlight_shouldNotLoadNativeAd() {
+        subject.mRequestInFlight = true;
+        subject.setMoPubNative(mockMoPubNative);
+
+        subject.replenishCache();
+
+        verify(mockMoPubNative, never()).makeRequest(requestParameters, 0);
+        assertThat(subject.mRequestInFlight).isTrue();
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void replenishCache_withCacheSizeAtLimit_shouldNotLoadNativeAd() {
+        // Default cache size may change in the future and this test will have to be updated
+        nativeAdCache.add(mock(TimestampWrapper.class));
+        nativeAdCache.add(mock(TimestampWrapper.class));
+        nativeAdCache.add(mock(TimestampWrapper.class));
+
+        subject.setMoPubNative(mockMoPubNative);
+
+        subject.replenishCache();
+
+        verify(mockMoPubNative, never()).makeRequest(any(RequestParameters.class), any(Integer.class));
+        assertThat(subject.mRequestInFlight).isFalse();
+    }
+
+    @Test
+    public void moPubNativeNetworkListener_onNativeLoad_shouldAddToCache() {
+        subject.setMoPubNative(mockMoPubNative);
+        subject.getMoPubNativeNetworkListener().onNativeLoad(mMockNativeAd);
+
+        assertThat(nativeAdCache).hasSize(1);
+        assertThat(nativeAdCache.get(0).mInstance).isEqualTo(mMockNativeAd);
+    }
+
+    @Test
+    public void moPubNativeNetworkListener_onNativeLoad_withEmptyCache_shouldCallOnAdsAvailable() {
+        subject.setMoPubNative(mockMoPubNative);
+
+        assertThat(nativeAdCache).isEmpty();
+        subject.getMoPubNativeNetworkListener().onNativeLoad(mMockNativeAd);
+
+        assertThat(nativeAdCache).hasSize(1);
+        verify(mockAdSourceListener).onAdsAvailable();
+    }
+
+    @Test
+    public void moPubNativeNetworkListener_onNativeLoad_withNonEmptyCache_shouldNotCallOnAdsAvailable() {
+        subject.setMoPubNative(mockMoPubNative);
+
+        nativeAdCache.add(mock(TimestampWrapper.class));
+        subject.getMoPubNativeNetworkListener().onNativeLoad(mMockNativeAd);
+
+        assertThat(nativeAdCache).hasSize(2);
+        verify(mockAdSourceListener, never()).onAdsAvailable();
+    }
+
+    @Test
+    public void moPubNativeNetworkListener_onNativeLoad_shouldIncrementSequenceNumber_shouldResetRetryTime() {
+        subject.setMoPubNative(mockMoPubNative);
+
+        subject.mCurrentRetries = maxRetries;
+        subject.mSequenceNumber = 5;
+
+        subject.getMoPubNativeNetworkListener().onNativeLoad(mMockNativeAd);
+
+        assertThat(subject.getRetryTime()).isEqualTo(defaultRetryTime);
+        assertThat(subject.mSequenceNumber).isEqualTo(6);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void moPubNativeNetworkListener_onNativeLoad_withFullCache_shouldResetRequestInFlight() {
+        subject.setMoPubNative(mockMoPubNative);
+
+        subject.mRequestInFlight = true;
+
+        // fill cache
+        nativeAdCache.add(mock(TimestampWrapper.class));
+        nativeAdCache.add(mock(TimestampWrapper.class));
+        nativeAdCache.add(mock(TimestampWrapper.class));
+
+        subject.getMoPubNativeNetworkListener().onNativeLoad(mMockNativeAd);
+
+        assertThat(subject.mRequestInFlight).isEqualTo(false);
+    }
+
+    @Test
+    public void moPubNativeNetworkListener_onNativeLoad_withCacheFilled_shouldNotReplenishCache() {
+        subject.setMoPubNative(mockMoPubNative);
+
+        subject.mRequestInFlight = true;
+
+        subject.getMoPubNativeNetworkListener().onNativeLoad(mMockNativeAd);
+
+        assertThat(subject.mRequestInFlight).isEqualTo(false);
+    }
+
+    @Test
+    public void
+    moPubNativeNetworkListener_onNativeFail_shouldResetInFlight_shouldUpdateRetryTime_shouldPostDelayedRunnable() {
+        subject.mRequestInFlight = true;
+
+        subject.getMoPubNativeNetworkListener().onNativeFail(NativeErrorCode.UNSPECIFIED);
+
+        assertThat(subject.mRequestInFlight).isEqualTo(false);
+        assertThat(subject.mRetryInFlight).isEqualTo(true);
+        assertThat(subject.getRetryTime()).isGreaterThan(defaultRetryTime);
+        verify(mockReplenishCacheHandler).postDelayed(any(Runnable.class), eq((long)subject.getRetryTime()));
+    }
+
+    @Test
+    public void
+    moPubNativeNetworkListener_onNativeFail_maxRetryTime_shouldResetInflight_shouldResetRetryTime_shouldNotPostDelayedRunnable() {
+        subject.mRequestInFlight = true;
+        subject.mCurrentRetries = maxRetries;
+
+        subject.getMoPubNativeNetworkListener().onNativeFail(NativeErrorCode.UNSPECIFIED);
+
+        assertThat(subject.mRequestInFlight).isEqualTo(false);
+        assertThat(subject.mRetryInFlight).isEqualTo(false);
+        assertThat(subject.getRetryTime()).isEqualTo(defaultRetryTime);
+        verify(mockReplenishCacheHandler, never()).postDelayed(any(Runnable.class), anyLong());
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/ServerPositioningSourceTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/ServerPositioningSourceTest.java
new file mode 100644
index 00000000..75f71afe
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/ServerPositioningSourceTest.java
@@ -0,0 +1,217 @@
+package com.mopub.nativeads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.pm.PackageManager;
+
+import com.mopub.common.ClientMetadata;
+import com.mopub.common.DownloadResponse;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
+import com.mopub.mobileads.MoPubErrorCode;
+import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
+import com.mopub.nativeads.PositioningSource.PositioningListener;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.volley.NoConnectionError;
+import com.mopub.volley.Request;
+import com.mopub.volley.VolleyError;
+
+import org.apache.http.HttpStatus;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Captor;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLog;
+
+import java.util.HashSet;
+import java.util.List;
+import java.util.logging.Level;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class ServerPositioningSourceTest {
+    @Mock PositioningListener mockPositioningListener;
+    @Captor ArgumentCaptor<PositioningRequest> positionRequestCaptor;
+    @Mock DownloadResponse mockValidResponse;
+    @Mock DownloadResponse mockNotFoundResponse;
+    @Mock DownloadResponse mockInvalidJsonResponse;
+    @Mock DownloadResponse mockWarmingUpJsonResponse;
+    @Mock Context mockContext;
+    @Mock ClientMetadata mockClientMetaData;
+    @Mock MoPubRequestQueue mockRequestQueue;
+
+    @Captor ArgumentCaptor<MoPubClientPositioning> positioningCaptor;
+
+    ServerPositioningSource subject;
+    private Activity spyActivity;
+
+    @Before
+    public void setUp() {
+        Activity activity = Robolectric.buildActivity(Activity.class).create().get();
+        spyActivity = spy(activity);
+
+        subject = new ServerPositioningSource(spyActivity);
+        setupClientMetadata();
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+
+        when(mockValidResponse.getStatusCode()).thenReturn(HttpStatus.SC_OK);
+        when(mockValidResponse.getByteArray()).thenReturn("{fixed: []}".getBytes());
+
+        when(mockInvalidJsonResponse.getStatusCode()).thenReturn(HttpStatus.SC_OK);
+        when(mockInvalidJsonResponse.getByteArray()).thenReturn("blah blah".getBytes());
+
+        when(mockWarmingUpJsonResponse.getStatusCode()).thenReturn(HttpStatus.SC_OK);
+        when(mockWarmingUpJsonResponse.getByteArray()).thenReturn(
+                "{\"error\":\"WARMING_UP\"}".getBytes());
+
+        when(mockNotFoundResponse.getStatusCode()).thenReturn(HttpStatus.SC_NOT_FOUND);
+    }
+
+    private void setupClientMetadata() {
+        when(mockClientMetaData.getSdkVersion()).thenReturn("sdk_version");
+        when(mockClientMetaData.getAppName()).thenReturn("app_name");
+        when(mockClientMetaData.getAppPackageName()).thenReturn("app_package_name");
+        when(mockClientMetaData.getAppVersion()).thenReturn("app_version");
+        when(mockClientMetaData.getDeviceId()).thenReturn("client_device_id");
+        when(mockClientMetaData.isDoNotTrackSet()).thenReturn(true);
+        when(mockClientMetaData.getDeviceManufacturer()).thenReturn("device_manufacturer");
+        when(mockClientMetaData.getDeviceModel()).thenReturn("device_model");
+        when(mockClientMetaData.getDeviceProduct()).thenReturn("device_product");
+        when(mockClientMetaData.getDeviceOsVersion()).thenReturn("device_os_version");
+        when(mockClientMetaData.getDeviceScreenWidthDip()).thenReturn(1337);
+        when(mockClientMetaData.getDeviceScreenHeightDip()).thenReturn(70707);
+        when(mockClientMetaData.getActiveNetworkType()).thenReturn(ClientMetadata.MoPubNetworkType.WIFI);
+        when(mockClientMetaData.getNetworkOperator()).thenReturn("network_operator");
+        when(mockClientMetaData.getNetworkOperatorName()).thenReturn("network_operator_name");
+        when(mockClientMetaData.getIsoCountryCode()).thenReturn("network_iso_country_code");
+        when(mockClientMetaData.getSimOperator()).thenReturn("network_sim_operator");
+        when(mockClientMetaData.getSimOperatorName()).thenReturn("network_sim_operator_name");
+        when(mockClientMetaData.getSimIsoCountryCode()).thenReturn("network_sim_iso_country_code");
+        ClientMetadata.setInstance(mockClientMetaData);
+    }
+
+    @Test
+    public void loadPositions_shouldAddToRequestQueue() {
+        subject.loadPositions("test_ad_unit", mockPositioningListener);
+        verify(mockRequestQueue).add(any(Request.class));
+    }
+
+    @Test
+    public void loadPositionsTwice_shouldCancelPreviousRequest_shouldNotCallListener() {
+        subject.loadPositions("test_ad_unit", mockPositioningListener);
+        subject.loadPositions("test_ad_unit", mockPositioningListener);
+        verify(mockRequestQueue, times(2)).add(any(Request.class));
+
+        verify(mockPositioningListener, never()).onFailed();
+        verify(mockPositioningListener, never()).onLoad(any(MoPubClientPositioning.class));
+    }
+
+    @Test
+    public void loadPositionsTwice_afterSuccess_shouldNotCancelPreviousRequest() {
+        subject.loadPositions("test_ad_unit", mockPositioningListener);
+        verify(mockRequestQueue).add(positionRequestCaptor.capture());
+        reset(mockRequestQueue);
+
+        subject.loadPositions("test_ad_unit", mockPositioningListener);
+        verify(mockRequestQueue).add(any(Request.class));
+    }
+
+    @Test
+    public void loadPositions_thenComplete_withValidResponse_shouldCallOnLoadListener() {
+        subject.loadPositions("test_ad_unit", mockPositioningListener);
+
+        verify(mockRequestQueue).add(positionRequestCaptor.capture());
+
+        final PositioningRequest value = positionRequestCaptor.getValue();
+        final MoPubClientPositioning response = new MoPubClientPositioning().enableRepeatingPositions(3);
+        value.deliverResponse(response);
+
+        verify(mockPositioningListener).onLoad(eq(response));
+    }
+
+    @Test
+    public void loadPositions_thenComplete_withErrorResponse_shouldRetry() throws Exception {
+        subject.loadPositions("test_ad_unit", mockPositioningListener);
+
+        verify(mockRequestQueue).add(positionRequestCaptor.capture());
+        reset(mockRequestQueue);
+
+        // We get VolleyErrors for invalid JSON, 404s, 5xx, and {"error": "WARMING_UP"}
+        positionRequestCaptor.getValue().deliverError(new VolleyError("Some test error"));
+
+        Robolectric.getForegroundThreadScheduler().advanceToLastPostedRunnable();
+        verify(mockRequestQueue).add(any(Request.class));
+    }
+
+
+    @Test
+    public void loadPositions_withPendingRetry_shouldNotRetry() {
+        subject.loadPositions("test_ad_unit", mockPositioningListener);
+
+        verify(mockRequestQueue).add(positionRequestCaptor.capture());
+        reset(mockRequestQueue);
+        positionRequestCaptor.getValue().deliverError(new VolleyError("testError"));
+
+        subject.loadPositions("test_ad_unit", mockPositioningListener);
+        Robolectric.getForegroundThreadScheduler().advanceToLastPostedRunnable();
+        // If a retry happened, we'd have two here.
+        verify(mockRequestQueue).add(any(Request.class));
+    }
+
+    @Test
+    public void loadPositions_thenFailAfterMaxRetryTime_shouldCallFailureHandler() {
+        subject.loadPositions("test_ad_unit", mockPositioningListener);
+        // Simulate failure after max time.
+        subject.setMaximumRetryTimeMilliseconds(999);
+
+        verify(mockRequestQueue).add(positionRequestCaptor.capture());
+        positionRequestCaptor.getValue().deliverError(new VolleyError("test error"));
+        verify(mockPositioningListener).onFailed();
+    }
+
+    @Test
+    public void loadPositions_withNoConnection_shouldLogMoPubErrorCodeNoConnection_shouldCallFailureHandler() {
+        MoPubLog.setSdkHandlerLevel(Level.ALL);
+
+        when(mockContext.checkCallingOrSelfPermission(anyString()))
+                .thenReturn(PackageManager.PERMISSION_DENIED);
+        when(spyActivity.getApplicationContext()).thenReturn(mockContext);
+        // Reinit the subject so we get our mocked context.
+        subject = new ServerPositioningSource(spyActivity);
+
+        // Simulate failure after max time.
+        subject.setMaximumRetryTimeMilliseconds(999);
+        subject.loadPositions("test_ad_unit", mockPositioningListener);
+
+        verify(mockRequestQueue).add(positionRequestCaptor.capture());
+        positionRequestCaptor.getValue().deliverError(new NoConnectionError());
+
+        verify(mockPositioningListener).onFailed();
+
+        final List<ShadowLog.LogItem> allLogItems = ShadowLog.getLogs();
+        HashSet<String> allLogMessages = new HashSet<>(allLogItems.size());
+
+        for (ShadowLog.LogItem logItem : allLogItems) {
+            allLogMessages.add(logItem.msg.trim());
+        }
+
+        assertThat(allLogMessages).contains(MoPubErrorCode.NO_CONNECTION.toString());
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/network/AdRequestTest.java b/mopub-sdk/src/test/java/com/mopub/network/AdRequestTest.java
new file mode 100644
index 00000000..646c2dc4
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/network/AdRequestTest.java
@@ -0,0 +1,527 @@
+package com.mopub.network;
+
+import android.app.Activity;
+import android.location.Location;
+
+import com.mopub.common.AdFormat;
+import com.mopub.common.AdType;
+import com.mopub.common.DataKeys;
+import com.mopub.common.MoPub.BrowserAgent;
+import com.mopub.common.event.BaseEvent;
+import com.mopub.common.event.EventDispatcher;
+import com.mopub.common.event.MoPubEvents;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.ResponseHeader;
+import com.mopub.mobileads.BuildConfig;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.Response;
+
+import org.json.JSONException;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+
+import java.nio.charset.Charset;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
+import java.util.TreeMap;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class AdRequestTest {
+
+    @Mock private AdRequest.Listener mockListener;
+    @Mock private AdResponse mockAdResponse;
+    @Mock private EventDispatcher mockEventDispatcher;
+
+    private AdRequest subject;
+    private HashMap<String, String> defaultHeaders;
+    private Activity activity;
+    private String adUnitId;
+
+    @Before
+    public void setup() {
+        activity = Robolectric.buildActivity(Activity.class).create().get();
+        adUnitId = "testAdUnitId";
+        subject = new AdRequest("testUrl", AdFormat.NATIVE, adUnitId, activity, mockListener);
+        defaultHeaders = new HashMap<String, String>();
+        defaultHeaders.put(ResponseHeader.SCROLLABLE.getKey(), "0");
+        defaultHeaders.put(ResponseHeader.REDIRECT_URL.getKey(), "redirect");
+        defaultHeaders.put(ResponseHeader.CLICK_TRACKING_URL.getKey(), "click_tracking");
+        defaultHeaders.put(ResponseHeader.IMPRESSION_URL.getKey(), "impression");
+        defaultHeaders.put(ResponseHeader.FAIL_URL.getKey(), "fail_url");
+        defaultHeaders.put(ResponseHeader.REFRESH_TIME.getKey(), "30");
+        defaultHeaders.put(ResponseHeader.PLAY_VISIBLE_PERCENT.getKey(), "50%");
+        defaultHeaders.put(ResponseHeader.PAUSE_VISIBLE_PERCENT.getKey(), "25");
+        defaultHeaders.put(ResponseHeader.IMPRESSION_MIN_VISIBLE_PERCENT.getKey(), "33%");
+        defaultHeaders.put(ResponseHeader.IMPRESSION_VISIBLE_MS.getKey(), "2000");
+        defaultHeaders.put(ResponseHeader.MAX_BUFFER_MS.getKey(), "1000");
+
+        MoPubEvents.setEventDispatcher(mockEventDispatcher);
+    }
+
+    @After
+    public void teardown() {
+        // Reset our locale for other tests.
+        Locale.setDefault(Locale.US);
+        MoPubEvents.setEventDispatcher(null);
+    }
+
+    @Test
+    public void parseNetworkResponse_stringBody_shouldSucceed() throws Exception {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.HTML);
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        assertThat(response.result).isNotNull();
+        assertThat(response.result.getStringBody()).isEqualTo("abc");
+    }
+
+    @Test
+    public void parseNetworkResponse_withStringBody_shouldLogScribeEvent() throws Exception {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.HTML);
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        subject.parseNetworkResponse(testResponse);
+
+        verify(mockEventDispatcher).dispatch(any(BaseEvent.class));
+    }
+
+    @Test
+    public void parseNetworkResponse_withServerExtrasInResponseBody_shouldSucceed_shouldCombineServerExtras() throws Exception {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.HTML);
+        defaultHeaders.put(ResponseHeader.FULL_AD_TYPE.getKey(), "anything");
+        defaultHeaders.put(ResponseHeader.CUSTOM_EVENT_NAME.getKey(), "class name");
+        defaultHeaders.put(ResponseHeader.CUSTOM_EVENT_DATA.getKey(),
+                "{customEventKey1: value1, customEventKey2: value2}");
+
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        // Check the server extras
+        final Map<String, String> serverExtras = response.result.getServerExtras();
+        assertThat(serverExtras).isNotNull();
+        assertThat(serverExtras).isNotEmpty();
+        assertThat(serverExtras.get(DataKeys.SCROLLABLE_KEY)).isEqualToIgnoringCase("false");
+        assertThat(serverExtras.get(DataKeys.REDIRECT_URL_KEY)).isEqualToIgnoringCase("redirect");
+        assertThat(serverExtras.get(DataKeys.CLICKTHROUGH_URL_KEY)).isEqualToIgnoringCase("click_tracking");
+
+        assertThat(serverExtras.get("customEventKey1")).isEqualTo("value1");
+        assertThat(serverExtras.get("customEventKey2")).isEqualTo("value2");
+    }
+
+    @Test
+    public void parseNetworkResponse_nonJsonStringBodyForNative_jsonParseShouldFail() {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.STATIC_NATIVE);
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        assertThat(response.error).isNotNull();
+        assertThat(response.error).isExactlyInstanceOf(MoPubNetworkError.class);
+        assertThat(((MoPubNetworkError) response.error).getReason()).isEqualTo(MoPubNetworkError.Reason.BAD_BODY);
+    }
+
+    @Test
+    public void parseNetworkResponse_nonJsonStringBodyForNative_shouldNotLogScribeEvent() {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.STATIC_NATIVE);
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        subject.parseNetworkResponse(testResponse);
+
+        verify(mockEventDispatcher, never()).dispatch(any(BaseEvent.class));
+    }
+
+    @Test
+    public void parseNetworkResponse_forNativeVideo_shouldSucceed() throws Exception {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.VIDEO_NATIVE);
+        NetworkResponse testResponse = new NetworkResponse(200,
+                "{\"abc\": \"def\"}".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        // Check the server extras
+        final Map<String, String> serverExtras = response.result.getServerExtras();
+        assertThat(serverExtras).isNotNull();
+        assertThat(serverExtras).isNotEmpty();
+        assertThat(serverExtras.get(DataKeys.PLAY_VISIBLE_PERCENT)).isEqualTo("50");
+        assertThat(serverExtras.get(DataKeys.PAUSE_VISIBLE_PERCENT)).isEqualTo("25");
+        assertThat(serverExtras.get(DataKeys.IMPRESSION_MIN_VISIBLE_PERCENT)).isEqualTo("33");
+        assertThat(serverExtras.get(DataKeys.IMPRESSION_VISIBLE_MS)).isEqualTo("2000");
+        assertThat(serverExtras.get(DataKeys.MAX_BUFFER_MS)).isEqualTo("1000");
+    }
+
+    @Test
+    public void parseNetworkResponse_forNativeVideo_shouldCombineServerExtrasAndEventData() throws Exception {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.VIDEO_NATIVE);
+        defaultHeaders.put(ResponseHeader.CUSTOM_EVENT_NAME.getKey(), "class name");
+        defaultHeaders.put(ResponseHeader.CUSTOM_EVENT_DATA.getKey(),
+                "{customEventKey1: value1, customEventKey2: value2}");
+        NetworkResponse testResponse = new NetworkResponse(200,
+                "{\"abc\": \"def\"}".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        // Check the server extras
+        final Map<String, String> serverExtras = response.result.getServerExtras();
+        assertThat(serverExtras).isNotNull();
+        assertThat(serverExtras).isNotEmpty();
+
+        assertThat(serverExtras.get(DataKeys.PLAY_VISIBLE_PERCENT)).isEqualTo("50");
+        assertThat(serverExtras.get(DataKeys.PAUSE_VISIBLE_PERCENT)).isEqualTo("25");
+        assertThat(serverExtras.get(DataKeys.IMPRESSION_MIN_VISIBLE_PERCENT)).isEqualTo("33");
+        assertThat(serverExtras.get(DataKeys.IMPRESSION_VISIBLE_MS)).isEqualTo("2000");
+        assertThat(serverExtras.get(DataKeys.MAX_BUFFER_MS)).isEqualTo("1000");
+
+        assertThat(serverExtras.get("customEventKey1")).isEqualTo("value1");
+        assertThat(serverExtras.get("customEventKey2")).isEqualTo("value2");
+    }
+
+    @Test
+    public void parseNetworkResponse_forNativeVideo_withInvalidValues_shouldSucceed_shouldParseNull() throws Exception {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.VIDEO_NATIVE);
+        defaultHeaders.put(ResponseHeader.PLAY_VISIBLE_PERCENT.getKey(), "-1");
+        defaultHeaders.put(ResponseHeader.PAUSE_VISIBLE_PERCENT.getKey(), "101%");
+        defaultHeaders.put(ResponseHeader.IMPRESSION_MIN_VISIBLE_PERCENT.getKey(), "XX%");
+        NetworkResponse testResponse = new NetworkResponse(200,
+                "{\"abc\": \"def\"}".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        // Check the server extras
+        final Map<String, String> serverExtras = response.result.getServerExtras();
+        assertThat(serverExtras).isNotNull();
+        assertThat(serverExtras).isNotEmpty();
+        assertThat(serverExtras.get(DataKeys.PLAY_VISIBLE_PERCENT)).isNull();
+        assertThat(serverExtras.get(DataKeys.PAUSE_VISIBLE_PERCENT)).isNull();
+        assertThat(serverExtras.get(DataKeys.IMPRESSION_MIN_VISIBLE_PERCENT)).isNull();
+        assertThat(serverExtras.get(DataKeys.IMPRESSION_VISIBLE_MS)).isEqualTo("2000");
+        assertThat(serverExtras.get(DataKeys.MAX_BUFFER_MS)).isEqualTo("1000");
+    }
+
+
+    @Test
+    public void parseNetworkResponse_withWarmupHeaderTrue_shouldError() {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.STATIC_NATIVE);
+        defaultHeaders.put(ResponseHeader.WARMUP.getKey(), "1");
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        assertThat(response.error).isNotNull();
+        assertThat(response.error).isInstanceOf(MoPubNetworkError.class);
+        assertThat(((MoPubNetworkError) response.error).getReason()).isEqualTo(MoPubNetworkError.Reason.WARMING_UP);
+    }
+
+    @Test
+    public void parseNetworkResponse_withWarmupHeaderTrue_shouldNotLogScribeEvent() {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.STATIC_NATIVE);
+        defaultHeaders.put(ResponseHeader.WARMUP.getKey(), "1");
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        subject.parseNetworkResponse(testResponse);
+
+        verify(mockEventDispatcher, never()).dispatch(any(BaseEvent.class));
+    }
+
+    @Test
+    public void parseNetworkResponse_withRefreshTime_shouldIncludeRefreshTimeInResult() {
+        defaultHeaders.put(ResponseHeader.REFRESH_TIME.getKey(), "13");
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+        assertThat(response.result.getRefreshTimeMillis()).isEqualTo(13000);
+    }
+
+    @Test
+    public void parseNetworkResponse_withoutRefreshTime_shouldNotIncludeRefreshTime() {
+        defaultHeaders.remove(ResponseHeader.REFRESH_TIME.getKey());
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+        assertThat(response.result.getRefreshTimeMillis()).isNull();
+    }
+    
+    @Test
+    public void parseNetworkResponse_withClearAdType_withRefreshTimeHeader_shouldErrorAndIncludeRefreshTime() {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.CLEAR);
+
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        assertThat(response.error).isNotNull();
+        assertThat(response.error).isInstanceOf(MoPubNetworkError.class);
+        final MoPubNetworkError moPubNetworkError = (MoPubNetworkError) response.error;
+        assertThat(moPubNetworkError.getReason()).isEqualTo(MoPubNetworkError.Reason.NO_FILL);
+        assertThat(moPubNetworkError.getRefreshTimeMillis()).isEqualTo(30000);
+    }
+
+    @Test
+    public void parseNetworkResponse_withClearAdType_withNoRefreshTimeHeader_shouldErrorAndNotIncludeRefreshTime() {
+        defaultHeaders.remove(ResponseHeader.REFRESH_TIME.getKey());
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.CLEAR);
+
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        assertThat(response.error).isNotNull();
+        assertThat(response.error).isInstanceOf(MoPubNetworkError.class);
+        final MoPubNetworkError moPubNetworkError = (MoPubNetworkError) response.error;
+        assertThat(moPubNetworkError.getReason()).isEqualTo(MoPubNetworkError.Reason.NO_FILL);
+        assertThat(moPubNetworkError.getRefreshTimeMillis()).isNull();
+    }
+
+    @Test
+    public void parseNetworkResponse_withClearAdType_shouldLogScribeEvent() {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.CLEAR);
+
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+        subject.parseNetworkResponse(testResponse);
+
+        verify(mockEventDispatcher).dispatch(any(BaseEvent.class));
+    }
+
+    @Test
+    public void parseNetworkResponse_withBadJSON_shouldReturnError() {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.STATIC_NATIVE);
+        NetworkResponse badNativeNetworkResponse = new NetworkResponse(200,
+                "{[abc}".getBytes(Charset.defaultCharset()),
+                defaultHeaders, false);
+        subject = new AdRequest("testUrl", AdFormat.NATIVE, "testAdUnitId", activity, mockListener);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(badNativeNetworkResponse);
+
+        assertThat(response.error).isNotNull();
+        assertThat(response.error.getCause()).isExactlyInstanceOf(JSONException.class);
+    }
+
+    @Test
+    public void parseNetworkResponse_forRewardedAds_shouldSucceed() {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.REWARDED_VIDEO);
+        defaultHeaders.put(ResponseHeader.REWARDED_VIDEO_CURRENCY_NAME.getKey(), "currencyName");
+        defaultHeaders.put(ResponseHeader.REWARDED_VIDEO_CURRENCY_AMOUNT.getKey(), "25");
+
+        final String rewardedCurrenciesJson = "{\"rewards\": ["
+                + "{\"name\": \"Coins\", \"amount\": 8},"
+                + "{\"name\": \"Diamonds\", \"amount\": 1},"
+                + "{\"name\": \"Diamonds\", \"amount\": 10 },"
+                + "{\"name\": \"Energy\", \"amount\": 20}"
+                + "]}";
+        defaultHeaders.put(ResponseHeader.REWARDED_CURRENCIES.getKey(), rewardedCurrenciesJson);
+
+        defaultHeaders.put(ResponseHeader.REWARDED_VIDEO_COMPLETION_URL.getKey(),
+                "http://completionUrl");
+        defaultHeaders.put(ResponseHeader.REWARDED_DURATION.getKey(), "15000");
+        defaultHeaders.put(ResponseHeader.SHOULD_REWARD_ON_CLICK.getKey(), "1");
+        NetworkResponse testResponse = new NetworkResponse(200,
+                "{\"abc\": \"def\"}".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        assertThat(response.result.getAdType()).isEqualTo(AdType.REWARDED_VIDEO);
+        assertThat(response.result.getRewardedVideoCurrencyName()).isEqualTo("currencyName");
+        assertThat(response.result.getRewardedVideoCurrencyAmount()).isEqualTo("25");
+        assertThat(response.result.getRewardedCurrencies()).isEqualTo(rewardedCurrenciesJson);
+        assertThat(response.result.getRewardedVideoCompletionUrl()).isEqualTo(
+                "http://completionUrl");
+        assertThat(response.result.getRewardedDuration()).isEqualTo(15000);
+        assertThat(response.result.shouldRewardOnClick()).isTrue();
+    }
+
+    @Test
+    public void parseNetworkResponse_withInAppBrowserAgent_shouldSucceed() {
+        defaultHeaders.put(ResponseHeader.BROWSER_AGENT.getKey(), "0");
+
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+        assertThat(response.result.getBrowserAgent()).isEqualTo(BrowserAgent.IN_APP);
+    }
+
+    @Test
+    public void parseNetworkResponse_withNativeBrowserAgent_shouldSucceed() {
+        defaultHeaders.put(ResponseHeader.BROWSER_AGENT.getKey(), "1");
+
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+        assertThat(response.result.getBrowserAgent()).isEqualTo(BrowserAgent.NATIVE);
+    }
+
+    @Test
+    public void parseNetworkResponse_withNullBrowserAgent_shouldDefaultToInApp() {
+        defaultHeaders.put(ResponseHeader.BROWSER_AGENT.getKey(), null);
+
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+        assertThat(response.result.getBrowserAgent()).isEqualTo(BrowserAgent.IN_APP);
+    }
+
+    @Test
+    public void parseNetworkResponse_withUndefinedBrowserAgent_shouldDefaultToInApp() {
+        defaultHeaders.put(ResponseHeader.BROWSER_AGENT.getKey(), "foo");
+
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+        assertThat(response.result.getBrowserAgent()).isEqualTo(BrowserAgent.IN_APP);
+    }
+
+    @Test
+    public void deliverResponse_shouldCallListenerOnSuccess() throws Exception {
+        subject.deliverResponse(mockAdResponse);
+        verify(mockListener).onSuccess(mockAdResponse);
+    }
+
+    @Test
+    public void getRequestId_shouldParseAndReturnRequestIdFromFailUrl() throws Exception {
+        String requestId = subject.getRequestId("https://ads.mopub.com/m/ad?id=8cf00598d3664adaaeccd800e46afaca&exclude=043fde1fe2f9470c9aa67fec262a0596&request_id=7fd6dd3bf1c84f87876b4740c1dd7baa&fail=1");
+
+        assertThat(requestId).isEqualTo("7fd6dd3bf1c84f87876b4740c1dd7baa");
+    }
+
+    @Test
+    public void getRequestId_withNullFailUrl_shouldReturnNull() throws Exception {
+        assertThat(subject.getRequestId(null)).isNull();
+    }
+
+    @Test
+    public void getRequestId_withUrlWithNoRequestIdParam_shouldReturnNull() throws Exception {
+        assertThat(subject.getRequestId("https://ads.mopub.com/m/ad?id=8cf00598d3664adaaeccd800e46afaca")).isNull();
+    }
+
+    @Test
+    public void getHeaders_withDefaultLocale_shouldReturnDefaultLanguageCode() throws Exception {
+        Map<String, String> expectedHeaders = new TreeMap<String, String>();
+        expectedHeaders.put(ResponseHeader.ACCEPT_LANGUAGE.getKey(), "en");
+
+        assertThat(subject.getHeaders()).isEqualTo(expectedHeaders);
+    }
+
+    @Test
+    public void getHeaders_withUserPreferredLocale_shouldReturnUserPreferredLanguageCode() throws Exception {
+        Map<String, String> expectedHeaders = new TreeMap<String, String>();
+        expectedHeaders.put(ResponseHeader.ACCEPT_LANGUAGE.getKey(), "fr");
+
+        // Assume user-preferred locale is fr_CA
+        activity.getResources().getConfiguration().locale = Locale.CANADA_FRENCH;
+
+        assertThat(subject.getHeaders()).isEqualTo(expectedHeaders);
+    }
+
+    @Test
+    public void getHeaders_withUserPreferredLocaleAsNull_shouldReturnDefaultLanguageCode() throws Exception {
+        Map<String, String> expectedHeaders = new TreeMap<String, String>();
+        expectedHeaders.put(ResponseHeader.ACCEPT_LANGUAGE.getKey(), "en");
+
+        // Assume user-preferred locale is null
+        activity.getResources().getConfiguration().locale = null;
+
+        assertThat(subject.getHeaders()).isEqualTo(expectedHeaders);
+    }
+
+    @Test
+    public void getHeaders_withUserPreferredLanguageAsEmptyString_shouldReturnDefaultLanguageCode() throws Exception {
+        Map<String, String> expectedHeaders = new TreeMap<String, String>();
+        expectedHeaders.put(ResponseHeader.ACCEPT_LANGUAGE.getKey(), "en");
+
+        // Assume user-preferred locale's language code is empty string after trimming
+        activity.getResources().getConfiguration().locale = new Locale(" ");
+
+        assertThat(subject.getHeaders()).isEqualTo(expectedHeaders);
+    }
+
+    @Test
+    public void getHeaders_withLocaleLanguageAsEmptyString_shouldNotAddLanguageHeader() throws Exception {
+        Map<String, String> expectedHeaders = Collections.emptyMap();
+
+        // Assume default locale's language code is empty string
+        Locale.setDefault(new Locale(""));
+
+        // Assume user-preferred locale's language code is empty string after trimming
+        activity.getResources().getConfiguration().locale = new Locale(" ");
+
+        assertThat(subject.getHeaders()).isEqualTo(expectedHeaders);
+
+
+    }
+
+    @Test
+    public void logScribeEvent_shouldLogEvent() throws Exception {
+        AdResponse mockAdResponse = mock(AdResponse.class);
+        when(mockAdResponse.getDspCreativeId()).thenReturn("dsp_creative_id");
+        when(mockAdResponse.getAdType()).thenReturn("html");
+        when(mockAdResponse.getNetworkType()).thenReturn("network_type");
+        when(mockAdResponse.getWidth()).thenReturn(320);
+        when(mockAdResponse.getHeight()).thenReturn(50);
+        when(mockAdResponse.getRequestId()).thenReturn("ac298c522b0e412b85ff81e4b9b51f03");
+
+        NetworkResponse networkResponse = new NetworkResponse(200, null, null, false, 300);
+
+        Location mockLocation = mock(Location.class);
+        when(mockLocation.getLatitude()).thenReturn(37.7833);
+        when(mockLocation.getLongitude()).thenReturn(-122.4167);
+        when(mockLocation.getAccuracy()).thenReturn((float) 2000.0);
+
+        doAnswer(new Answer() {
+            @Override
+            public Object answer(InvocationOnMock invocation) throws Throwable {
+                Object[] args = invocation.getArguments();
+                BaseEvent baseEvent = (BaseEvent) args[0];
+                assertThat(baseEvent.getName()).isEqualTo(BaseEvent.Name.AD_REQUEST);
+                assertThat(baseEvent.getCategory()).isEqualTo(BaseEvent.Category.REQUESTS);
+                assertThat(baseEvent.getSamplingRate()).isEqualTo(0.1);
+                assertThat(baseEvent.getAdUnitId()).isEqualTo(adUnitId);
+                assertThat(baseEvent.getDspCreativeId()).isEqualTo("dsp_creative_id");
+                assertThat(baseEvent.getAdType()).isEqualTo("html");
+                assertThat(baseEvent.getAdNetworkType()).isEqualTo("network_type");
+                assertThat(baseEvent.getAdWidthPx()).isEqualTo(320);
+                assertThat(baseEvent.getAdHeightPx()).isEqualTo(50);
+                assertThat(baseEvent.getGeoLat()).isEqualTo(37.7833);
+                assertThat(baseEvent.getGeoLon()).isEqualTo(-122.4167);
+                assertThat(baseEvent.getGeoAccuracy()).isEqualTo(2000.0);
+                assertThat(baseEvent.getPerformanceDurationMs()).isEqualTo(300);
+                assertThat(baseEvent.getRequestId()).isEqualTo("ac298c522b0e412b85ff81e4b9b51f03");
+                assertThat(baseEvent.getRequestStatusCode()).isEqualTo(200);
+                assertThat(baseEvent.getRequestUri()).isEqualTo("testUrl");
+                return null;
+            }
+        }).when(mockEventDispatcher).dispatch(any(BaseEvent.class));
+
+        subject.logScribeEvent(mockAdResponse, networkResponse, mockLocation);
+
+        verify(mockEventDispatcher).dispatch(any(BaseEvent.class));
+    }
+}
