diff --git a/CHANGELOG.md b/CHANGELOG.md
index 8a52bb2e..a7979dd3 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,12 @@
+## Version 4.13.0 (March 23, 2017)
+
+- Updated AdColony Custom Events.
+- Updated Unity Custom Events.
+- Added AdMob Custom Events:
+  - Native: `GooglePlayServicesAdRenderer` and `GooglePlayServicesNative`
+  - Rewarded Video: `GooglePlayServicesRewardedVideo`
+- Bug fixes.
+
 ## Version 4.12.0 (February 9, 2017)
 
 - Updated minimum supported Android API version to 16+ (Jelly Bean).
@@ -6,7 +15,7 @@
 ```
 <activity android:name="com.mopub.mobileads.RewardedMraidActivity"
           android:configChanges="keyboardHidden|orientation|screenSize"/>
- ```
+```
 - Added support for **rich media in rewarded video** inventory.
 - Bug fixes:
     - Fixed incorrectly forwarded lifecycle events `onStop()` and `onDestroy()` in `MoPubLifeCycleManager` for rewarded rich media ads.
diff --git a/README.md b/README.md
index d87d8d7c..a64f9262 100644
--- a/README.md
+++ b/README.md
@@ -27,7 +27,7 @@ The MoPub SDK is available via:
     }
 
     dependencies {
-        compile('com.mopub:mopub-sdk:4.12.0@aar') {
+        compile('com.mopub:mopub-sdk:4.13.0@aar') {
             transitive = true
         }
     }
@@ -48,27 +48,27 @@ The MoPub SDK is available via:
         // ... other project dependencies
 
         // For banners
-        compile('com.mopub:mopub-sdk-banner:4.12.0@aar') {
+        compile('com.mopub:mopub-sdk-banner:4.13.0@aar') {
             transitive = true
         }
         
         // For interstitials
-        compile('com.mopub:mopub-sdk-interstitial:4.12.0@aar') {
+        compile('com.mopub:mopub-sdk-interstitial:4.13.0@aar') {
             transitive = true
         }
 
         // For rewarded videos. This will automatically also include interstitials
-        compile('com.mopub:mopub-sdk-rewardedvideo:4.12.0@aar') {
+        compile('com.mopub:mopub-sdk-rewardedvideo:4.13.0@aar') {
             transitive = true
         }
 
         // For native static (images).
-        compile('com.mopub:mopub-sdk-native-static:4.12.0@aar') {
+        compile('com.mopub:mopub-sdk-native-static:4.13.0@aar') {
             transitive = true
         }
 
         // For native video. This will automatically also include native static
-        compile('com.mopub:mopub-sdk-native-video:4.12.0@aar') {
+        compile('com.mopub:mopub-sdk-native-video:4.13.0@aar') {
             transitive = true
         }
     }
@@ -96,14 +96,11 @@ The MoPub SDK is available via:
 ## New in this Version
 Please view the [changelog](https://github.com/mopub/mopub-android-sdk/blob/master/CHANGELOG.md) for a complete list of additions, fixes, and enhancements in the latest release.
 
-- Updated minimum supported Android API version to 16+ (Jelly Bean).
-- New required Activity declaration in `AndroidManifest`, please add:
-
-   ```
-<activity android:name="com.mopub.mobileads.RewardedMraidActivity"
-          android:configChanges="keyboardHidden|orientation|screenSize"/>
-    ```
-- Added support for **rich media in rewarded video** inventory.
+- Updated AdColony Custom Events.
+- Updated Unity Custom Events.
+- Added AdMob Custom Events:
+  - Native: `GooglePlayServicesAdRenderer` and `GooglePlayServicesNative`
+  - Rewarded Video: `GooglePlayServicesRewardedVideo`
 - Bug fixes.
 
 ## Requirements
diff --git a/extras/src/com/mopub/mobileads/GooglePlayServicesRewardedVideo.java b/extras/src/com/mopub/mobileads/GooglePlayServicesRewardedVideo.java
new file mode 100644
index 00000000..0f678d67
--- /dev/null
+++ b/extras/src/com/mopub/mobileads/GooglePlayServicesRewardedVideo.java
@@ -0,0 +1,261 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.google.android.gms.ads.AdRequest;
+import com.google.android.gms.ads.MobileAds;
+import com.google.android.gms.ads.reward.RewardItem;
+import com.google.android.gms.ads.reward.RewardedVideoAd;
+import com.google.android.gms.ads.reward.RewardedVideoAdListener;
+import com.mopub.common.BaseLifecycleListener;
+import com.mopub.common.LifecycleListener;
+import com.mopub.common.MoPubReward;
+
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+/**
+ * A {@link CustomEventRewardedVideo} used to load rewarded video Google rewarded video ads.
+ */
+public class GooglePlayServicesRewardedVideo extends CustomEventRewardedVideo implements
+        RewardedVideoAdListener {
+    private static final String TAG = "MoPubToAdMobRewarded";
+
+    /**
+     * The current version of the adapter.
+     */
+    private static final String ADAPTER_VERSION = "0.1.0";
+
+    /**
+     * Key to obtain AdMob application ID from the server extras provided by MoPub.
+     */
+    private static final String KEY_EXTRA_APPLICATION_ID = "appid";
+
+    /**
+     * Key to obtain AdMob ad unit ID from the extras provided by MoPub.
+     */
+    private static final String KEY_EXTRA_AD_UNIT_ID = "adunit";
+
+    /**
+     * Flag to determine whether or not the adapter has been initialized.
+     */
+    private static AtomicBoolean sIsInitialized;
+
+    /**
+     * Google Mobile Ads rewarded video ad unit ID.
+     */
+    private String mAdUnitId;
+
+    /**
+     * The Google Rewarded Video Ad instance.
+     */
+    private RewardedVideoAd mRewardedVideoAd;
+
+    /**
+     * A {@link LifecycleListener} used to forward the activity lifecycle events from MoPub SDK to
+     * Google Mobile Ads SDK.
+     */
+    private LifecycleListener mLifecycleListener = new BaseLifecycleListener() {
+        @Override
+        public void onPause(@NonNull Activity activity) {
+            super.onPause(activity);
+            if (mRewardedVideoAd != null) {
+                mRewardedVideoAd.pause(activity);
+            }
+        }
+
+        @Override
+        public void onResume(@NonNull Activity activity) {
+            super.onResume(activity);
+            if (mRewardedVideoAd != null) {
+                mRewardedVideoAd.resume(activity);
+            }
+        }
+    };
+
+    public GooglePlayServicesRewardedVideo() {
+        sIsInitialized = new AtomicBoolean(false);
+    }
+
+    @Nullable
+    @Override
+    protected LifecycleListener getLifecycleListener() {
+        return mLifecycleListener;
+    }
+
+    @NonNull
+    @Override
+    protected String getAdNetworkId() {
+        // Google rewarded videos do not have a unique identifier for each ad; using ad unit ID as
+        // an identifier for all ads.
+        return mAdUnitId;
+    }
+
+    @Override
+    protected void onInvalidate() {
+        if (mRewardedVideoAd != null) {
+            mRewardedVideoAd.setRewardedVideoAdListener(null);
+            mRewardedVideoAd = null;
+        }
+    }
+
+    @Override
+    protected boolean checkAndInitializeSdk(@NonNull Activity launcherActivity,
+                                            @NonNull Map<String, Object> localExtras,
+                                            @NonNull Map<String, String> serverExtras)
+            throws Exception {
+        if (!sIsInitialized.getAndSet(true)) {
+            Log.i(TAG, "Adapter version - " + ADAPTER_VERSION);
+
+            if (TextUtils.isEmpty(serverExtras.get(KEY_EXTRA_APPLICATION_ID))) {
+                MobileAds.initialize(launcherActivity);
+            } else {
+                MobileAds.initialize(launcherActivity, serverExtras.get(KEY_EXTRA_APPLICATION_ID));
+            }
+
+            if (TextUtils.isEmpty(serverExtras.get(KEY_EXTRA_AD_UNIT_ID))) {
+                // Using class name as the network ID for this callback since the ad unit ID is
+                // invalid.
+                MoPubRewardedVideoManager.onRewardedVideoLoadFailure(
+                        GooglePlayServicesRewardedVideo.class,
+                        GooglePlayServicesRewardedVideo.class.getSimpleName(),
+                        MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
+                return false;
+            }
+
+            mAdUnitId = serverExtras.get(KEY_EXTRA_AD_UNIT_ID);
+
+            mRewardedVideoAd = MobileAds.getRewardedVideoAdInstance(launcherActivity);
+            mRewardedVideoAd.setRewardedVideoAdListener(GooglePlayServicesRewardedVideo.this);
+            return true;
+        }
+
+        return false;
+    }
+
+    @Override
+    protected void loadWithSdkInitialized(@NonNull Activity activity,
+                                          @NonNull Map<String, Object> localExtras,
+                                          @NonNull Map<String, String> serverExtras)
+            throws Exception {
+        if (TextUtils.isEmpty(serverExtras.get(KEY_EXTRA_AD_UNIT_ID))) {
+            // Using class name as the network ID for this callback since the ad unit ID is
+            // invalid.
+            MoPubRewardedVideoManager.onRewardedVideoLoadFailure(
+                    GooglePlayServicesRewardedVideo.class,
+                    GooglePlayServicesRewardedVideo.class.getSimpleName(),
+                    MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
+            return;
+        }
+        mAdUnitId = serverExtras.get(KEY_EXTRA_AD_UNIT_ID);
+
+        if (mRewardedVideoAd == null) {
+            mRewardedVideoAd = MobileAds.getRewardedVideoAdInstance(activity);
+            mRewardedVideoAd.setRewardedVideoAdListener(GooglePlayServicesRewardedVideo.this);
+        }
+
+        if (mRewardedVideoAd.isLoaded()) {
+            MoPubRewardedVideoManager
+                    .onRewardedVideoLoadSuccess(GooglePlayServicesRewardedVideo.class, mAdUnitId);
+        } else {
+            mRewardedVideoAd
+                    .loadAd(mAdUnitId, new AdRequest.Builder().setRequestAgent("MoPub").build());
+        }
+    }
+
+    @Override
+    protected boolean hasVideoAvailable() {
+        return mRewardedVideoAd != null && mRewardedVideoAd.isLoaded();
+    }
+
+    @Override
+    protected void showVideo() {
+        if (hasVideoAvailable()) {
+            mRewardedVideoAd.show();
+        } else {
+            MoPubRewardedVideoManager.onRewardedVideoPlaybackError(
+                    GooglePlayServicesRewardedVideo.class,
+                    mAdUnitId,
+                    getMoPubErrorCode(AdRequest.ERROR_CODE_INTERNAL_ERROR));
+        }
+    }
+
+    @Override
+    public void onRewardedVideoAdLoaded() {
+        MoPubRewardedVideoManager.onRewardedVideoLoadSuccess(
+                GooglePlayServicesRewardedVideo.class,
+                mAdUnitId);
+    }
+
+    @Override
+    public void onRewardedVideoAdOpened() {
+        // MoPub SDK does not have an equivalent callback for an ad opened event. Do nothing.
+    }
+
+    @Override
+    public void onRewardedVideoStarted() {
+        MoPubRewardedVideoManager.onRewardedVideoStarted(
+                GooglePlayServicesRewardedVideo.class,
+                mAdUnitId);
+    }
+
+    @Override
+    public void onRewardedVideoAdClosed() {
+        MoPubRewardedVideoManager.onRewardedVideoClosed(
+                GooglePlayServicesRewardedVideo.class,
+                mAdUnitId);
+    }
+
+    @Override
+    public void onRewarded(RewardItem rewardItem) {
+        MoPubRewardedVideoManager.onRewardedVideoCompleted(
+                GooglePlayServicesRewardedVideo.class,
+                mAdUnitId,
+                MoPubReward.success(rewardItem.getType(), rewardItem.getAmount()));
+    }
+
+    @Override
+    public void onRewardedVideoAdLeftApplication() {
+        MoPubRewardedVideoManager.onRewardedVideoClicked(
+                GooglePlayServicesRewardedVideo.class,
+                mAdUnitId);
+    }
+
+    @Override
+    public void onRewardedVideoAdFailedToLoad(int error) {
+        MoPubRewardedVideoManager.onRewardedVideoLoadFailure(
+                GooglePlayServicesRewardedVideo.class,
+                mAdUnitId,
+                getMoPubErrorCode(error));
+    }
+
+    /**
+     * Converts a given Google Mobile Ads SDK error code into {@link MoPubErrorCode}.
+     *
+     * @param error Google Mobile Ads SDK error code.
+     * @return an equivalent MoPub SDK error code for the given Google Mobile Ads SDK error
+     * code.
+     */
+    private MoPubErrorCode getMoPubErrorCode(int error) {
+        MoPubErrorCode errorCode;
+        switch (error) {
+            case AdRequest.ERROR_CODE_INTERNAL_ERROR:
+                errorCode = MoPubErrorCode.INTERNAL_ERROR;
+                break;
+            case AdRequest.ERROR_CODE_INVALID_REQUEST:
+                errorCode = MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR;
+                break;
+            case AdRequest.ERROR_CODE_NETWORK_ERROR:
+                errorCode = MoPubErrorCode.NO_CONNECTION;
+                break;
+            case AdRequest.ERROR_CODE_NO_FILL:
+            default:
+                errorCode = MoPubErrorCode.UNSPECIFIED;
+        }
+        return errorCode;
+    }
+}
diff --git a/extras/src/com/mopub/nativeads/GooglePlayServicesAdRenderer.java b/extras/src/com/mopub/nativeads/GooglePlayServicesAdRenderer.java
new file mode 100644
index 00000000..9798ec95
--- /dev/null
+++ b/extras/src/com/mopub/nativeads/GooglePlayServicesAdRenderer.java
@@ -0,0 +1,402 @@
+package com.mopub.nativeads;
+
+import android.content.Context;
+import android.support.annotation.IdRes;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.FrameLayout;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import com.google.android.gms.ads.formats.AdChoicesView;
+import com.google.android.gms.ads.formats.NativeAdView;
+import com.google.android.gms.ads.formats.NativeAppInstallAdView;
+import com.google.android.gms.ads.formats.NativeContentAdView;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.nativeads.GooglePlayServicesNative.GooglePlayServicesNativeAd;
+
+import java.util.Locale;
+import java.util.Map;
+import java.util.WeakHashMap;
+
+/**
+ * The {@link GooglePlayServicesAdRenderer} class is used to render
+ * GooglePlayServicesStaticNativeAds.
+ */
+public class GooglePlayServicesAdRenderer implements MoPubAdRenderer<GooglePlayServicesNativeAd> {
+
+    /**
+     * Key to set and get star rating text view as an extra in the view binder.
+     */
+    public static final String VIEW_BINDER_KEY_STAR_RATING = "key_star_rating";
+
+    /**
+     * Key to set and get advertiser text view as an extra in the view binder.
+     */
+    public static final String VIEW_BINDER_KEY_ADVERTISER = "key_advertiser";
+
+    /**
+     * Key to set and get store text view as an extra in the view binder.
+     */
+    public static final String VIEW_BINDER_KEY_STORE = "key_store";
+
+    /**
+     * Key to set and get price text view as an extra in the view binder.
+     */
+    public static final String VIEW_BINDER_KEY_PRICE = "key_price";
+
+    /**
+     * Key to set and get the AdChoices icon view as an extra in the view binder.
+     */
+    public static final String VIEW_BINDER_KEY_AD_CHOICES_ICON_CONTAINER = "ad_choices_container";
+
+    /**
+     * ID for the frame layout that wraps the Google ad view.
+     */
+    @IdRes
+    private static final int ID_WRAPPING_FRAME = 1001;
+
+    /**
+     * ID for the Google native ad view.
+     */
+    @IdRes
+    private static final int ID_GOOGLE_NATIVE_VIEW = 1002;
+
+    /**
+     * A view binder containing the layout resource and views to be rendered by the renderer.
+     */
+    private final ViewBinder mViewBinder;
+
+    /**
+     * A weak hash map used to keep track of view holder so that the views can be properly recycled.
+     */
+    private final WeakHashMap<View, GoogleStaticNativeViewHolder> mViewHolderMap;
+
+    public GooglePlayServicesAdRenderer(ViewBinder viewBinder) {
+        this.mViewBinder = viewBinder;
+        this.mViewHolderMap = new WeakHashMap<>();
+    }
+
+    @NonNull
+    @Override
+    public View createAdView(@NonNull Context context, @Nullable ViewGroup parent) {
+        View view = LayoutInflater.from(context).inflate(mViewBinder.layoutId, parent, false);
+        // Create a frame layout and add the inflated view as a child. This will allow us to add
+        // the Google native ad view into the view hierarchy at render time.
+        FrameLayout wrappingView = new FrameLayout(context);
+        wrappingView.setId(ID_WRAPPING_FRAME);
+        wrappingView.addView(view);
+        Log.i(GooglePlayServicesNative.TAG, "Ad view created.");
+        return wrappingView;
+    }
+
+    @Override
+    public void renderAdView(@NonNull View view,
+                             @NonNull GooglePlayServicesNativeAd nativeAd) {
+        GoogleStaticNativeViewHolder viewHolder = mViewHolderMap.get(view);
+        if (viewHolder == null) {
+            viewHolder = GoogleStaticNativeViewHolder.fromViewBinder(view, mViewBinder);
+            mViewHolderMap.put(view, viewHolder);
+        }
+
+        removeGoogleNativeAdView(view, nativeAd.shouldSwapMargins());
+
+        NativeAdView nativeAdView = null;
+        if (nativeAd.isNativeAppInstallAd()) {
+            nativeAdView = new NativeAppInstallAdView(view.getContext());
+            updateAppInstallAdView(nativeAd, viewHolder, (NativeAppInstallAdView) nativeAdView);
+        } else if (nativeAd.isNativeContentAd()) {
+            nativeAdView = new NativeContentAdView(view.getContext());
+            updateContentAdView(nativeAd, viewHolder, (NativeContentAdView) nativeAdView);
+        }
+
+        if (nativeAdView != null) {
+            insertGoogleNativeAdView(nativeAdView, view, nativeAd.shouldSwapMargins());
+        } else {
+            Log.w(GooglePlayServicesNative.TAG,
+                    "Couldn't add Google native ad view. NativeAdView is null.");
+        }
+    }
+
+    /**
+     * This method will add the given Google native ad view into the view hierarchy of the given
+     * MoPub native ad view.
+     *
+     * @param googleNativeAdView Google's native ad view to be added as a parent to the MoPub's
+     *                           view.
+     * @param moPubNativeAdView  MoPub's native ad view created by this renderer.
+     * @param swapMargins        {@code true} if the margins need to be swapped, {@code false}
+     *                           otherwise.
+     */
+    private static void insertGoogleNativeAdView(NativeAdView googleNativeAdView,
+                                                 View moPubNativeAdView,
+                                                 boolean swapMargins) {
+        if (moPubNativeAdView instanceof FrameLayout
+                && moPubNativeAdView.getId() == ID_WRAPPING_FRAME) {
+            googleNativeAdView.setId(ID_GOOGLE_NATIVE_VIEW);
+            FrameLayout outerFrame = (FrameLayout) moPubNativeAdView;
+            View actualView = outerFrame.getChildAt(0);
+
+            if (swapMargins) {
+                // Google native ad view renders the AdChoices icon in one of the four corners of
+                // its view. If a margin is specified on the actual ad view, the AdChoices view
+                // might be rendered outside the actual ad view. Moving the margins from the
+                // actual ad view to Google native ad view will make sure that the AdChoices icon
+                // is being rendered within the bounds of the actual ad view.
+                FrameLayout.LayoutParams googleNativeAdViewParams = new FrameLayout.LayoutParams(
+                        ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);
+                FrameLayout.LayoutParams actualViewParams =
+                        (FrameLayout.LayoutParams) actualView.getLayoutParams();
+                googleNativeAdViewParams.setMargins(actualViewParams.leftMargin,
+                        actualViewParams.topMargin,
+                        actualViewParams.rightMargin,
+                        actualViewParams.bottomMargin);
+                googleNativeAdView.setLayoutParams(googleNativeAdViewParams);
+                actualViewParams.setMargins(0, 0, 0, 0);
+            } else {
+                googleNativeAdView.setLayoutParams(new ViewGroup.LayoutParams(
+                        ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));
+            }
+
+            outerFrame.removeView(actualView);
+            googleNativeAdView.addView(actualView);
+            outerFrame.addView(googleNativeAdView);
+        } else {
+            Log.w(GooglePlayServicesNative.TAG,
+                    "Couldn't add Google native ad view. Wrapping view not found.");
+        }
+    }
+
+    /**
+     * This method will remove the Google native ad view from the view hierarchy if one is present.
+     *
+     * @param view        the view from which to remove the Google native ad view.
+     * @param swapMargins {@code true} if the margins need to be swapped before removing the
+     *                    Google native ad view, {@code false} otherwise.
+     */
+    protected static void removeGoogleNativeAdView(@NonNull View view, boolean swapMargins) {
+        if (view instanceof FrameLayout && view.getId() == ID_WRAPPING_FRAME) {
+            View adView = view.findViewById(ID_GOOGLE_NATIVE_VIEW);
+            if (adView != null) {
+                ViewGroup outerView = (ViewGroup) view;
+                int index = outerView.indexOfChild(adView);
+                outerView.removeView(adView);
+                View actualNativeView = ((ViewGroup) adView).getChildAt(0);
+                if (actualNativeView != null) {
+                    if (swapMargins) {
+                        FrameLayout.LayoutParams actualViewParams =
+                                (FrameLayout.LayoutParams) actualNativeView.getLayoutParams();
+                        FrameLayout.LayoutParams googleNativeViewParams =
+                                (FrameLayout.LayoutParams) adView.getLayoutParams();
+                        actualViewParams.setMargins(
+                                googleNativeViewParams.leftMargin,
+                                googleNativeViewParams.topMargin,
+                                googleNativeViewParams.rightMargin,
+                                googleNativeViewParams.bottomMargin);
+                    }
+                    ((ViewGroup) adView).removeView(actualNativeView);
+                    outerView.addView(actualNativeView, index);
+                }
+            }
+        }
+    }
+
+    /**
+     * This method will render the given native ad view using the native ad and set the views to
+     * Google's native content ad view.
+     *
+     * @param staticNativeAd         a static native ad object containing the required assets to
+     *                               set to the native ad view.
+     * @param staticNativeViewHolder a static native view holder object containing the mapped
+     *                               views from the view binder.
+     * @param contentAdView          the Google native content ad view in the view hierarchy.
+     */
+    private void updateContentAdView(GooglePlayServicesNativeAd staticNativeAd,
+                                     GoogleStaticNativeViewHolder staticNativeViewHolder,
+                                     NativeContentAdView contentAdView) {
+        NativeRendererHelper.addTextView(
+                staticNativeViewHolder.mTitleView, staticNativeAd.getTitle());
+        contentAdView.setHeadlineView(staticNativeViewHolder.mTitleView);
+        NativeRendererHelper.addTextView(
+                staticNativeViewHolder.mTextView, staticNativeAd.getText());
+        contentAdView.setBodyView(staticNativeViewHolder.mTextView);
+        NativeRendererHelper.addTextView(staticNativeViewHolder.mCallToActionView,
+                staticNativeAd.getCallToAction());
+        contentAdView.setCallToActionView(staticNativeViewHolder.mCallToActionView);
+        NativeImageHelper.loadImageView(staticNativeAd.getMainImageUrl(),
+                staticNativeViewHolder.mMainImageView);
+        contentAdView.setImageView(staticNativeViewHolder.mMainImageView);
+        NativeImageHelper.loadImageView(staticNativeAd.getIconImageUrl(),
+                staticNativeViewHolder.mIconImageView);
+        contentAdView.setLogoView(staticNativeViewHolder.mIconImageView);
+        if (staticNativeAd.getAdvertiser() != null) {
+            NativeRendererHelper.addTextView(
+                    staticNativeViewHolder.mAdvertiserTextView, staticNativeAd.getAdvertiser());
+            contentAdView.setAdvertiserView(staticNativeViewHolder.mAdvertiserTextView);
+        }
+
+        // Add the AdChoices icon to the container if one is provided by the publisher.
+        if (staticNativeViewHolder.mAdChoicesIconContainer != null) {
+            AdChoicesView adChoicesView = new AdChoicesView(contentAdView.getContext());
+            staticNativeViewHolder.mAdChoicesIconContainer.removeAllViews();
+            staticNativeViewHolder.mAdChoicesIconContainer.addView(adChoicesView);
+            contentAdView.setAdChoicesView(adChoicesView);
+        }
+
+        // Set the privacy information icon to null as the Google Mobile Ads SDK automatically
+        // renders the AdChoices icon.
+        NativeRendererHelper.addPrivacyInformationIcon(
+                staticNativeViewHolder.mPrivacyInformationIconImageView, null, null);
+
+        contentAdView.setNativeAd(staticNativeAd.getContentAd());
+    }
+
+    /**
+     * This method will render the given native ad view using the native ad and set the views to
+     * Google's native app install ad view.
+     *
+     * @param staticNativeAd         a static native ad object containing the required assets to set
+     *                               to the native ad view.
+     * @param staticNativeViewHolder a static native view holder object containing the mapped
+     *                               views from the view binder.
+     * @param appInstallAdView       the Google native app install ad view in the view hierarchy.
+     */
+    private void updateAppInstallAdView(GooglePlayServicesNativeAd staticNativeAd,
+                                        GoogleStaticNativeViewHolder staticNativeViewHolder,
+                                        NativeAppInstallAdView appInstallAdView) {
+
+        NativeRendererHelper.addTextView(
+                staticNativeViewHolder.mTitleView, staticNativeAd.getTitle());
+        appInstallAdView.setHeadlineView(staticNativeViewHolder.mTitleView);
+        NativeRendererHelper.addTextView(
+                staticNativeViewHolder.mTextView, staticNativeAd.getText());
+        appInstallAdView.setBodyView(staticNativeViewHolder.mTextView);
+        NativeRendererHelper.addTextView(
+                staticNativeViewHolder.mCallToActionView, staticNativeAd.getCallToAction());
+        appInstallAdView.setCallToActionView(staticNativeViewHolder.mCallToActionView);
+        NativeImageHelper.loadImageView(
+                staticNativeAd.getMainImageUrl(), staticNativeViewHolder.mMainImageView);
+        appInstallAdView.setImageView(staticNativeViewHolder.mMainImageView);
+        NativeImageHelper.loadImageView(
+                staticNativeAd.getIconImageUrl(), staticNativeViewHolder.mIconImageView);
+        appInstallAdView.setIconView(staticNativeViewHolder.mIconImageView);
+        if (staticNativeAd.getStarRating() != null) {
+            NativeRendererHelper.addTextView(staticNativeViewHolder.mStarRatingTextView,
+                    String.format(
+                            Locale.getDefault(), "%.1f/5 Stars", staticNativeAd.getStarRating()));
+            appInstallAdView.setStarRatingView(staticNativeViewHolder.mStarRatingTextView);
+        }
+        if (staticNativeAd.getPrice() != null) {
+            NativeRendererHelper.addTextView(
+                    staticNativeViewHolder.mPriceTextView, staticNativeAd.getPrice());
+            appInstallAdView.setPriceView(staticNativeViewHolder.mPriceTextView);
+        }
+        if (staticNativeAd.getStore() != null) {
+            NativeRendererHelper.addTextView(
+                    staticNativeViewHolder.mStoreTextView, staticNativeAd.getStore());
+            appInstallAdView.setStoreView(staticNativeViewHolder.mStoreTextView);
+        }
+
+        // Set the privacy information icon to null as the Google Mobile Ads SDK automatically
+        // renders the AdChoices icon.
+        NativeRendererHelper.addPrivacyInformationIcon(
+                staticNativeViewHolder.mPrivacyInformationIconImageView, null, null);
+
+        // Add the AdChoices icon to the container if one is provided by the publisher.
+        if (staticNativeViewHolder.mAdChoicesIconContainer != null) {
+            AdChoicesView adChoicesView = new AdChoicesView(appInstallAdView.getContext());
+            staticNativeViewHolder.mAdChoicesIconContainer.removeAllViews();
+            staticNativeViewHolder.mAdChoicesIconContainer.addView(adChoicesView);
+            appInstallAdView.setAdChoicesView(adChoicesView);
+        }
+
+        appInstallAdView.setNativeAd(staticNativeAd.getAppInstallAd());
+    }
+
+    @Override
+    public boolean supports(@NonNull BaseNativeAd nativeAd) {
+        return nativeAd instanceof GooglePlayServicesNativeAd;
+    }
+
+    private static class GoogleStaticNativeViewHolder {
+        @Nullable
+        View mMainView;
+        @Nullable
+        TextView mTitleView;
+        @Nullable
+        TextView mTextView;
+        @Nullable
+        TextView mCallToActionView;
+        @Nullable
+        ImageView mMainImageView;
+        @Nullable
+        ImageView mIconImageView;
+        @Nullable
+        ImageView mPrivacyInformationIconImageView;
+        @Nullable
+        TextView mStarRatingTextView;
+        @Nullable
+        TextView mAdvertiserTextView;
+        @Nullable
+        TextView mStoreTextView;
+        @Nullable
+        TextView mPriceTextView;
+        @Nullable
+        FrameLayout mAdChoicesIconContainer;
+
+        private static final GoogleStaticNativeViewHolder EMPTY_VIEW_HOLDER =
+                new GoogleStaticNativeViewHolder();
+
+        @NonNull
+        public static GoogleStaticNativeViewHolder fromViewBinder(@NonNull View view,
+                                                                  @NonNull ViewBinder viewBinder) {
+            final GoogleStaticNativeViewHolder viewHolder = new GoogleStaticNativeViewHolder();
+            viewHolder.mMainView = view;
+            try {
+                viewHolder.mTitleView = (TextView) view.findViewById(viewBinder.titleId);
+                viewHolder.mTextView = (TextView) view.findViewById(viewBinder.textId);
+                viewHolder.mCallToActionView =
+                        (TextView) view.findViewById(viewBinder.callToActionId);
+                viewHolder.mMainImageView =
+                        (ImageView) view.findViewById(viewBinder.mainImageId);
+                viewHolder.mIconImageView =
+                        (ImageView) view.findViewById(viewBinder.iconImageId);
+                viewHolder.mPrivacyInformationIconImageView =
+                        (ImageView) view.findViewById(viewBinder.privacyInformationIconImageId);
+                Map<String, Integer> extraViews = viewBinder.extras;
+                Integer starRatingTextViewId = extraViews.get(VIEW_BINDER_KEY_STAR_RATING);
+                if (starRatingTextViewId != null) {
+                    viewHolder.mStarRatingTextView =
+                            (TextView) view.findViewById(starRatingTextViewId);
+                }
+                Integer advertiserTextViewId = extraViews.get(VIEW_BINDER_KEY_ADVERTISER);
+                if (advertiserTextViewId != null) {
+                    viewHolder.mAdvertiserTextView =
+                            (TextView) view.findViewById(advertiserTextViewId);
+                }
+                Integer storeTextViewId = extraViews.get(VIEW_BINDER_KEY_STORE);
+                if (storeTextViewId != null) {
+                    viewHolder.mStoreTextView = (TextView) view.findViewById(storeTextViewId);
+                }
+                Integer priceTextViewId = extraViews.get(VIEW_BINDER_KEY_PRICE);
+                if (priceTextViewId != null) {
+                    viewHolder.mPriceTextView = (TextView) view.findViewById(priceTextViewId);
+                }
+                Integer adChoicesIconViewId =
+                        extraViews.get(VIEW_BINDER_KEY_AD_CHOICES_ICON_CONTAINER);
+                if (adChoicesIconViewId != null) {
+                    viewHolder.mAdChoicesIconContainer =
+                            (FrameLayout) view.findViewById(adChoicesIconViewId);
+                }
+                return viewHolder;
+            } catch (ClassCastException exception) {
+                MoPubLog.w("Could not cast from id in ViewBinder to expected View type", exception);
+                return EMPTY_VIEW_HOLDER;
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/extras/src/com/mopub/nativeads/GooglePlayServicesNative.java b/extras/src/com/mopub/nativeads/GooglePlayServicesNative.java
new file mode 100644
index 00000000..15932aa8
--- /dev/null
+++ b/extras/src/com/mopub/nativeads/GooglePlayServicesNative.java
@@ -0,0 +1,599 @@
+package com.mopub.nativeads;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.text.TextUtils;
+import android.util.Log;
+import android.view.View;
+
+import com.google.android.gms.ads.AdListener;
+import com.google.android.gms.ads.AdLoader;
+import com.google.android.gms.ads.AdRequest;
+import com.google.android.gms.ads.MobileAds;
+import com.google.android.gms.ads.formats.NativeAdOptions;
+import com.google.android.gms.ads.formats.NativeAppInstallAd;
+import com.google.android.gms.ads.formats.NativeContentAd;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+/**
+ * The {@link GooglePlayServicesNative} class is used to load native Google mobile ads.
+ */
+public class GooglePlayServicesNative extends CustomEventNative {
+    protected static final String TAG = "MoPubToAdMobNative";
+
+    /**
+     * The current version of the adapter.
+     */
+    private static final String ADAPTER_VERSION = "0.3.1";
+
+    /**
+     * Key to obtain AdMob application ID from the server extras provided by MoPub.
+     */
+    private static final String KEY_EXTRA_APPLICATION_ID = "appid";
+
+    /**
+     * Key to obtain AdMob ad unit ID from the extras provided by MoPub.
+     */
+    private static final String KEY_EXTRA_AD_UNIT_ID = "adunit";
+
+    /**
+     * Key to set and obtain the image orientation preference.
+     */
+    public static final String KEY_EXTRA_ORIENTATION_PREFERENCE = "orientation_preference";
+
+    /**
+     * Key to set and obtain the AdChoices icon placement preference.
+     */
+    public static final String KEY_EXTRA_AD_CHOICES_PLACEMENT = "ad_choices_placement";
+
+    /**
+     * Key to set and obtain the experimental swap margins flag.
+     */
+    public static final String KEY_EXPERIMENTAL_EXTRA_SWAP_MARGINS = "swap_margins";
+
+    /**
+     * Flag to determine whether or not the adapter has been initialized.
+     */
+    private static AtomicBoolean sIsInitialized = new AtomicBoolean(false);
+
+    @Override
+    protected void loadNativeAd(@NonNull final Context context,
+                                @NonNull final CustomEventNativeListener customEventNativeListener,
+                                @NonNull Map<String, Object> localExtras,
+                                @NonNull Map<String, String> serverExtras) {
+        if (!sIsInitialized.getAndSet(true)) {
+            Log.i(TAG, "Adapter version - " + ADAPTER_VERSION);
+            if (serverExtras.containsKey(KEY_EXTRA_APPLICATION_ID)
+                    && !TextUtils.isEmpty(serverExtras.get(KEY_EXTRA_APPLICATION_ID))) {
+                MobileAds.initialize(context, serverExtras.get(KEY_EXTRA_APPLICATION_ID));
+            } else {
+                MobileAds.initialize(context);
+            }
+        }
+
+        String adUnitId = serverExtras.get(KEY_EXTRA_AD_UNIT_ID);
+        if (TextUtils.isEmpty(adUnitId)) {
+            customEventNativeListener.onNativeAdFailed(NativeErrorCode.NETWORK_INVALID_REQUEST);
+            return;
+        }
+        GooglePlayServicesNativeAd nativeAd =
+                new GooglePlayServicesNativeAd(customEventNativeListener);
+        nativeAd.loadAd(context, adUnitId, localExtras);
+    }
+
+    /**
+     * The {@link GooglePlayServicesNativeAd} class is used to load and map Google native
+     * ads to MoPub native ads.
+     */
+    static class GooglePlayServicesNativeAd extends BaseNativeAd {
+
+        // Native ad assets.
+        private String mTitle;
+        private String mText;
+        private String mMainImageUrl;
+        private String mIconImageUrl;
+        private String mCallToAction;
+        private Double mStarRating;
+        private String mAdvertiser;
+        private String mStore;
+        private String mPrice;
+
+        /**
+         * Flag to determine whether or not to swap margins from actual ad view to Google native ad
+         * view.
+         */
+        private boolean mSwapMargins;
+
+        /**
+         * A custom event native listener used to forward Google Mobile Ads SDK events to MoPub.
+         */
+        private CustomEventNativeListener mCustomEventNativeListener;
+
+        /**
+         * A Google native ad of type content.
+         */
+        private NativeContentAd mNativeContentAd;
+
+        /**
+         * A Google native ad of type app install.
+         */
+        private NativeAppInstallAd mNativeAppInstallAd;
+
+        public GooglePlayServicesNativeAd(
+                CustomEventNativeListener customEventNativeListener) {
+            this.mCustomEventNativeListener = customEventNativeListener;
+        }
+
+        /**
+         * @return the title string associated with this native ad.
+         */
+        public String getTitle() {
+            return mTitle;
+        }
+
+        /**
+         * @return the text/body string associated with the native ad.
+         */
+        public String getText() {
+            return mText;
+        }
+
+        /**
+         * @return the main image URL associated with the native ad.
+         */
+        public String getMainImageUrl() {
+            return mMainImageUrl;
+        }
+
+        /**
+         * @return the icon image URL associated with the native ad.
+         */
+        public String getIconImageUrl() {
+            return mIconImageUrl;
+        }
+
+        /**
+         * @return the call to action string associated with the native ad.
+         */
+        public String getCallToAction() {
+            return mCallToAction;
+        }
+
+        /**
+         * @return the star rating associated with the native ad.
+         */
+        public Double getStarRating() {
+            return mStarRating;
+        }
+
+        /**
+         * @return the advertiser string associated with the native ad.
+         */
+        public String getAdvertiser() {
+            return mAdvertiser;
+        }
+
+        /**
+         * @return the store string associated with the native ad.
+         */
+        public String getStore() {
+            return mStore;
+        }
+
+        /**
+         * @return the price string associated with the native ad.
+         */
+        public String getPrice() {
+            return mPrice;
+        }
+
+        /**
+         * @param title the title to be set.
+         */
+        public void setTitle(String title) {
+            this.mTitle = title;
+        }
+
+        /**
+         * @param text the text/body to be set.
+         */
+        public void setText(String text) {
+            this.mText = text;
+        }
+
+        /**
+         * @param mainImageUrl the main image URL to be set.
+         */
+        public void setMainImageUrl(String mainImageUrl) {
+            this.mMainImageUrl = mainImageUrl;
+        }
+
+        /**
+         * @param iconImageUrl the icon image URL to be set.
+         */
+        public void setIconImageUrl(String iconImageUrl) {
+            this.mIconImageUrl = iconImageUrl;
+        }
+
+        /**
+         * @param callToAction the call to action string to be set.
+         */
+        public void setCallToAction(String callToAction) {
+            this.mCallToAction = callToAction;
+        }
+
+        /**
+         * @param starRating the star rating value to be set.
+         */
+        public void setStarRating(Double starRating) {
+            this.mStarRating = starRating;
+        }
+
+        /**
+         * @param advertiser the advertiser string to be set.
+         */
+        public void setAdvertiser(String advertiser) {
+            this.mAdvertiser = advertiser;
+        }
+
+        /**
+         * @param store the store string to be set.
+         */
+        public void setStore(String store) {
+            this.mStore = store;
+        }
+
+        /**
+         * @param price the price string to be set.
+         */
+        public void setPrice(String price) {
+            this.mPrice = price;
+        }
+
+        /**
+         * @return whether or not this ad is native content ad.
+         */
+        public boolean isNativeContentAd() {
+            return mNativeContentAd != null;
+        }
+
+        /**
+         * @return whether or not to swap margins when rendering the ad.
+         */
+        public boolean shouldSwapMargins() {
+            return this.mSwapMargins;
+        }
+
+        /**
+         * @return whether or not this ad is native app install ad.
+         */
+        public boolean isNativeAppInstallAd() {
+            return mNativeAppInstallAd != null;
+        }
+
+        /**
+         * @return {@link #mNativeContentAd}.
+         */
+        public NativeContentAd getContentAd() {
+            return mNativeContentAd;
+        }
+
+        /**
+         * @return {@link #mNativeAppInstallAd}.
+         */
+        public NativeAppInstallAd getAppInstallAd() {
+            return mNativeAppInstallAd;
+        }
+
+        /**
+         * This method will load native ads from Google for the given ad unit ID.
+         *
+         * @param context  required to request a Google native ad.
+         * @param adUnitId Google's AdMob Ad Unit ID.
+         */
+        public void loadAd(final Context context, String adUnitId,
+                           Map<String, Object> localExtras) {
+            AdLoader.Builder builder = new AdLoader.Builder(context, adUnitId);
+
+            // Get the experimental swap margins extra.
+            if (localExtras.containsKey(KEY_EXPERIMENTAL_EXTRA_SWAP_MARGINS)) {
+                Object swapMarginExtra = localExtras.get(KEY_EXPERIMENTAL_EXTRA_SWAP_MARGINS);
+                if (swapMarginExtra instanceof Boolean) {
+                    mSwapMargins = (boolean) swapMarginExtra;
+                }
+            }
+
+            NativeAdOptions.Builder optionsBuilder = new NativeAdOptions.Builder();
+
+            // MoPub requires the images to be pre-cached using their APIs, so we do not want
+            // Google to download the image assets.
+            optionsBuilder.setReturnUrlsForImageAssets(true);
+
+            // MoPub allows for only one image, so only request for one image.
+            optionsBuilder.setRequestMultipleImages(false);
+
+            // Get the preferred image orientation from the local extras.
+            if (localExtras.containsKey(KEY_EXTRA_ORIENTATION_PREFERENCE)
+                    && isValidOrientationExtra(localExtras.get(KEY_EXTRA_ORIENTATION_PREFERENCE))) {
+                optionsBuilder.setImageOrientation(
+                        (int) localExtras.get(KEY_EXTRA_ORIENTATION_PREFERENCE));
+            }
+
+            // Get the preferred AdChoices icon placement from the local extras.
+            if (localExtras.containsKey(KEY_EXTRA_AD_CHOICES_PLACEMENT)
+                    && isValidAdChoicesPlacementExtra(
+                    localExtras.get(KEY_EXTRA_AD_CHOICES_PLACEMENT))) {
+                optionsBuilder.setAdChoicesPlacement(
+                        (int) localExtras.get(KEY_EXTRA_AD_CHOICES_PLACEMENT));
+            }
+            NativeAdOptions adOptions = optionsBuilder.build();
+
+            AdLoader adLoader =
+                    builder.forContentAd(new NativeContentAd.OnContentAdLoadedListener() {
+                        @Override
+                        public void onContentAdLoaded(final NativeContentAd nativeContentAd) {
+                            if (!isValidContentAd(nativeContentAd)) {
+                                Log.i(TAG, "The Google native content ad is missing one or more "
+                                        + "required assets, failing request.");
+                                mCustomEventNativeListener.onNativeAdFailed(
+                                        NativeErrorCode.INVALID_RESPONSE);
+                                return;
+                            }
+
+                            mNativeContentAd = nativeContentAd;
+                            List<com.google.android.gms.ads.formats.NativeAd.Image> images =
+                                    nativeContentAd.getImages();
+                            List<String> imageUrls = new ArrayList<>();
+                            // Only one image should be in the the list as we turned off request
+                            // for multiple images.
+                            com.google.android.gms.ads.formats.NativeAd.Image mainImage =
+                                    images.get(0);
+                            // Assuming that the URI provided is an URL.
+                            imageUrls.add(mainImage.getUri().toString());
+
+                            com.google.android.gms.ads.formats.NativeAd.Image logoImage =
+                                    nativeContentAd.getLogo();
+                            // Assuming that the URI provided is an URL.
+                            imageUrls.add(logoImage.getUri().toString());
+                            preCacheImages(context, imageUrls);
+                        }
+                    }).forAppInstallAd(new NativeAppInstallAd.OnAppInstallAdLoadedListener() {
+                        @Override
+                        public void onAppInstallAdLoaded(
+                                final NativeAppInstallAd nativeAppInstallAd) {
+                            if (!isValidAppInstallAd(nativeAppInstallAd)) {
+                                Log.i(TAG, "The Google native app install ad is missing one or "
+                                        + "more required assets, failing request.");
+                                mCustomEventNativeListener.onNativeAdFailed(
+                                        NativeErrorCode.INVALID_RESPONSE);
+                                return;
+                            }
+                            mNativeAppInstallAd = nativeAppInstallAd;
+                            List<com.google.android.gms.ads.formats.NativeAd.Image> images =
+                                    nativeAppInstallAd.getImages();
+                            List<String> imageUrls = new ArrayList<>();
+                            // Only one image should be in the the list as we turned off request
+                            // for multiple images.
+                            com.google.android.gms.ads.formats.NativeAd.Image mainImage =
+                                    images.get(0);
+                            // Assuming that the URI provided is an URL.
+                            imageUrls.add(mainImage.getUri().toString());
+
+                            com.google.android.gms.ads.formats.NativeAd.Image iconImage =
+                                    nativeAppInstallAd.getIcon();
+                            // Assuming that the URI provided is an URL.
+                            imageUrls.add(iconImage.getUri().toString());
+                            preCacheImages(context, imageUrls);
+                        }
+                    }).withAdListener(new AdListener() {
+                        @Override
+                        public void onAdFailedToLoad(int errorCode) {
+                            super.onAdFailedToLoad(errorCode);
+                            switch (errorCode) {
+                                case AdRequest.ERROR_CODE_INTERNAL_ERROR:
+                                    mCustomEventNativeListener.onNativeAdFailed(
+                                            NativeErrorCode.NATIVE_ADAPTER_CONFIGURATION_ERROR);
+                                    break;
+                                case AdRequest.ERROR_CODE_INVALID_REQUEST:
+                                    mCustomEventNativeListener.onNativeAdFailed(
+                                            NativeErrorCode.NETWORK_INVALID_REQUEST);
+                                    break;
+                                case AdRequest.ERROR_CODE_NETWORK_ERROR:
+                                    mCustomEventNativeListener.onNativeAdFailed(
+                                            NativeErrorCode.CONNECTION_ERROR);
+                                    break;
+                                case AdRequest.ERROR_CODE_NO_FILL:
+                                    mCustomEventNativeListener.onNativeAdFailed(
+                                            NativeErrorCode.NETWORK_NO_FILL);
+                                    break;
+                                default:
+                                    mCustomEventNativeListener.onNativeAdFailed(
+                                            NativeErrorCode.UNSPECIFIED);
+                            }
+                        }
+                    }).withNativeAdOptions(adOptions).build();
+            adLoader.loadAd(new AdRequest.Builder().setRequestAgent("MoPub").build());
+        }
+
+        /**
+         * This method will check whether or not the provided extra value can be mapped to
+         * NativeAdOptions' orientation constants.
+         *
+         * @param extra to be checked if it is valid.
+         * @return {@code true} if the extra can be mapped to one of {@link NativeAdOptions}
+         * orientation constants, {@code false} otherwise.
+         */
+        private boolean isValidOrientationExtra(Object extra) {
+            if (extra == null || !(extra instanceof Integer)) {
+                return false;
+            }
+            Integer preference = (Integer) extra;
+            return (preference == NativeAdOptions.ORIENTATION_ANY
+                    || preference == NativeAdOptions.ORIENTATION_LANDSCAPE
+                    || preference == NativeAdOptions.ORIENTATION_PORTRAIT);
+        }
+
+        /**
+         * Checks whether or not the provided extra value can be mapped to NativeAdOptions'
+         * AdChoices icon placement constants.
+         *
+         * @param extra to be checked if it is valid.
+         * @return {@code true} if the extra can be mapped to one of {@link NativeAdOptions}
+         * AdChoices icon placement constants, {@code false} otherwise.
+         */
+        private boolean isValidAdChoicesPlacementExtra(Object extra) {
+            if (extra == null || !(extra instanceof Integer)) {
+                return false;
+            }
+            Integer placement = (Integer) extra;
+            return (placement == NativeAdOptions.ADCHOICES_TOP_LEFT
+                    || placement == NativeAdOptions.ADCHOICES_TOP_RIGHT
+                    || placement == NativeAdOptions.ADCHOICES_BOTTOM_LEFT
+                    || placement == NativeAdOptions.ADCHOICES_BOTTOM_RIGHT);
+        }
+
+        /**
+         * This method will check whether or not the given content ad has all the required assets
+         * (title, text, main image url, icon url and call to action) for it to be correctly
+         * mapped to a {@link GooglePlayServicesNativeAd}.
+         *
+         * @param contentAd to be checked if it is valid.
+         * @return {@code true} if the given native content ad has all the necessary assets to
+         * create a {@link GooglePlayServicesNativeAd}, {@code false} otherwise.
+         */
+        private boolean isValidContentAd(NativeContentAd contentAd) {
+            return (contentAd.getHeadline() != null && contentAd.getBody() != null
+                    && contentAd.getImages() != null && contentAd.getImages().get(0) != null
+                    && contentAd.getLogo() != null && contentAd.getCallToAction() != null);
+        }
+
+        /**
+         * This method will check whether or not the given native app install ad has all the
+         * required assets (title, text, main image url, icon url and call to action) for it to
+         * be correctly mapped to a {@link GooglePlayServicesNativeAd}.
+         *
+         * @param appInstallAd to checked if it is valid.
+         * @return {@code true} if the given native app install ad has all the necessary assets to
+         * to create a {@link GooglePlayServicesNativeAd}, {@code false} otherwise.
+         */
+        private boolean isValidAppInstallAd(NativeAppInstallAd appInstallAd) {
+            return (appInstallAd.getHeadline() != null && appInstallAd.getBody() != null
+                    && appInstallAd.getImages() != null && appInstallAd.getImages().get(0) != null
+                    && appInstallAd.getIcon() != null && appInstallAd.getCallToAction() != null);
+        }
+
+        @Override
+        public void prepare(@NonNull View view) {
+            // Adding click and impression trackers is handled by the GooglePlayServicesRenderer,
+            // do nothing here.
+        }
+
+        @Override
+        public void clear(@NonNull View view) {
+            // Called when an ad is no longer displayed to a user.
+            GooglePlayServicesAdRenderer.removeGoogleNativeAdView(view, shouldSwapMargins());
+        }
+
+        @Override
+        public void destroy() {
+            // Called when the ad will never be displayed again.
+            if (mNativeContentAd != null) {
+                mNativeContentAd.destroy();
+            }
+            if (mNativeAppInstallAd != null) {
+                mNativeAppInstallAd.destroy();
+            }
+        }
+
+        /**
+         * This method will try to cache images and send success/failure callbacks based on
+         * whether or not the image caching succeeded.
+         *
+         * @param context   required to pre-cache images.
+         * @param imageUrls the urls of images that need to be cached.
+         */
+        private void preCacheImages(Context context, List<String> imageUrls) {
+            NativeImageHelper.preCacheImages(context, imageUrls,
+                    new NativeImageHelper.ImageListener() {
+                        @Override
+                        public void onImagesCached() {
+                            if (mNativeContentAd != null) {
+                                prepareNativeContentAd(mNativeContentAd);
+                                mCustomEventNativeListener.onNativeAdLoaded(
+                                        GooglePlayServicesNativeAd.this);
+                            } else if (mNativeAppInstallAd != null) {
+                                prepareNativeAppInstallAd(mNativeAppInstallAd);
+                                mCustomEventNativeListener.onNativeAdLoaded(
+                                        GooglePlayServicesNativeAd.this);
+                            }
+                        }
+
+                        @Override
+                        public void onImagesFailedToCache(NativeErrorCode errorCode) {
+                            mCustomEventNativeListener.onNativeAdFailed(errorCode);
+                        }
+                    });
+        }
+
+        /**
+         * This method will map the Google native content ad loaded to this
+         * {@link GooglePlayServicesNativeAd}.
+         *
+         * @param contentAd that needs to be mapped to this native ad.
+         */
+        private void prepareNativeContentAd(NativeContentAd contentAd) {
+            List<com.google.android.gms.ads.formats.NativeAd.Image> images = contentAd.getImages();
+            setMainImageUrl(images.get(0).getUri().toString());
+
+            com.google.android.gms.ads.formats.NativeAd.Image logo = contentAd.getLogo();
+            setIconImageUrl(logo.getUri().toString());
+
+            setCallToAction(contentAd.getCallToAction().toString());
+
+            setTitle(contentAd.getHeadline().toString());
+
+            setText(contentAd.getBody().toString());
+
+            setAdvertiser(contentAd.getAdvertiser().toString());
+        }
+
+        /**
+         * This method will map the Google native app install ad loaded to this
+         * {@link GooglePlayServicesNativeAd}.
+         *
+         * @param appInstallAd that needs to be mapped to this native ad.
+         */
+        private void prepareNativeAppInstallAd(NativeAppInstallAd appInstallAd) {
+            List<com.google.android.gms.ads.formats.NativeAd.Image> images =
+                    appInstallAd.getImages();
+            setMainImageUrl(images.get(0).getUri().toString());
+
+            com.google.android.gms.ads.formats.NativeAd.Image icon = appInstallAd.getIcon();
+            setIconImageUrl(icon.getUri().toString());
+
+            setCallToAction(appInstallAd.getCallToAction().toString());
+
+            setTitle(appInstallAd.getHeadline().toString());
+
+            setText(appInstallAd.getBody().toString());
+
+            if (appInstallAd.getStarRating() != null) {
+                setStarRating(appInstallAd.getStarRating());
+            }
+
+            // Add store asset if available.
+            if (appInstallAd.getStore() != null) {
+                setStore(appInstallAd.getStore().toString());
+            }
+
+            // Add price asset if available.
+            if (appInstallAd.getPrice() != null) {
+                setPrice(appInstallAd.getPrice().toString());
+            }
+        }
+    }
+}
diff --git a/mopub-sample/AndroidManifest.xml b/mopub-sample/AndroidManifest.xml
index d8267f4d..e29019b9 100644
--- a/mopub-sample/AndroidManifest.xml
+++ b/mopub-sample/AndroidManifest.xml
@@ -1,8 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
       package="com.mopub.simpleadsdemo"
-      android:versionCode="49"
-      android:versionName="4.12.0">
+      android:versionCode="50"
+      android:versionName="4.13.0">
     <uses-sdk android:minSdkVersion="16"
               android:targetSdkVersion="23"/>
 
diff --git a/mopub-sample/build.gradle b/mopub-sample/build.gradle
index f79c9d0a..3524a58a 100644
--- a/mopub-sample/build.gradle
+++ b/mopub-sample/build.gradle
@@ -9,7 +9,7 @@ apply plugin: 'com.android.application'
 
 project.group = 'com.mopub'
 project.description = '''MoPub Sample App'''
-project.version = '4.12.0'
+project.version = '4.13.0'
 
 android {
     compileSdkVersion 23
@@ -17,7 +17,7 @@ android {
     lintOptions { abortOnError false }
 
     defaultConfig {
-        versionCode 49
+        versionCode 50
         versionName version
         minSdkVersion 16
         targetSdkVersion 23
diff --git a/mopub-sample/proguard.cfg b/mopub-sample/proguard.cfg
index 7cb03eb0..bff255cd 100644
--- a/mopub-sample/proguard.cfg
+++ b/mopub-sample/proguard.cfg
@@ -11,6 +11,7 @@
 -keep class * extends com.mopub.mobileads.CustomEventBanner {}
 -keep class * extends com.mopub.mobileads.CustomEventInterstitial {}
 -keep class * extends com.mopub.nativeads.CustomEventNative {}
+-keep class * extends com.mopub.nativeads.CustomEventRewardedAd {}
 
 # Keep methods that are accessed via reflection
 -keepclassmembers class ** { @com.mopub.common.util.ReflectionTarget *; }
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/RewardedVideoDetailFragment.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/RewardedVideoDetailFragment.java
index 80961a4a..fc637371 100644
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/RewardedVideoDetailFragment.java
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/RewardedVideoDetailFragment.java
@@ -1,8 +1,12 @@
 package com.mopub.simpleadsdemo;
 
+import android.app.AlertDialog;
+import android.app.Dialog;
+import android.content.DialogInterface;
 import android.os.Bundle;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.v4.app.DialogFragment;
 import android.support.v4.app.Fragment;
 import android.view.LayoutInflater;
 import android.view.View;
@@ -15,7 +19,9 @@
 import com.mopub.mobileads.MoPubRewardedVideoManager.RequestParameters;
 import com.mopub.mobileads.MoPubRewardedVideos;
 
+import java.util.HashMap;
 import java.util.Locale;
+import java.util.Map;
 import java.util.Set;
 
 import static com.mopub.simpleadsdemo.Utils.hideSoftKeyboard;
@@ -27,6 +33,8 @@
 
     @Nullable private Button mShowButton;
     @Nullable private String mAdUnitId;
+    @Nullable private Map<String, MoPubReward> mMoPubRewardsMap;
+    @Nullable private MoPubReward mSelectedReward;
 
     @Override
     public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
@@ -44,6 +52,8 @@ public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle sa
         MoPubRewardedVideos.setRewardedVideoListener(this);
 
         mAdUnitId = adConfiguration.getAdUnitId();
+        mMoPubRewardsMap = new HashMap<>();
+
         views.mDescriptionView.setText(adConfiguration.getDescription());
         views.mAdUnitIdView.setText(mAdUnitId);
         views.mLoadButton.setOnClickListener(new View.OnClickListener() {
@@ -88,6 +98,32 @@ public void onRewardedVideoLoadSuccess(@NonNull final String adUnitId) {
                 mShowButton.setEnabled(true);
             }
             logToast(getActivity(), "Rewarded video loaded.");
+
+            Set<MoPubReward> availableRewards = MoPubRewardedVideos.getAvailableRewards(mAdUnitId);
+
+            // If there are more than one reward available, pop up alert dialog for reward selection
+            if (availableRewards.size() > 1) {
+                final SelectRewardDialogFragment selectRewardDialogFragment
+                        = SelectRewardDialogFragment.newInstance();
+
+                // The user must select a reward from the dialog
+                selectRewardDialogFragment.setCancelable(false);
+
+                // Reset rewards mapping and selected reward
+                mMoPubRewardsMap.clear();
+                mSelectedReward = null;
+
+                // Initialize mapping between reward string and reward instance
+                for (MoPubReward reward : availableRewards) {
+                    mMoPubRewardsMap.put(reward.getAmount() + " " + reward.getLabel(), reward);
+                }
+
+                selectRewardDialogFragment.loadRewards(mMoPubRewardsMap.keySet()
+                        .toArray(new String[mMoPubRewardsMap.size()]));
+                selectRewardDialogFragment.setTargetFragment(this, 0);
+                selectRewardDialogFragment.show(getActivity().getSupportFragmentManager(),
+                        "selectReward");
+            }
         }
     }
 
@@ -144,4 +180,57 @@ public void onRewardedVideoCompleted(@NonNull final Set<String> adUnitIds,
                             reward.getLabel()));
         }
     }
+
+    public void selectReward(@NonNull String selectedReward) {
+        mSelectedReward = mMoPubRewardsMap.get(selectedReward);
+        MoPubRewardedVideos.selectReward(mAdUnitId, mSelectedReward);
+    }
+
+    public static class SelectRewardDialogFragment extends DialogFragment {
+        @NonNull private String[] mRewards;
+        @NonNull private String mSelectedReward;
+
+        public static SelectRewardDialogFragment newInstance() {
+            return new SelectRewardDialogFragment();
+        }
+
+        public void loadRewards(@NonNull String[] rewards) {
+            mRewards = rewards;
+        }
+
+        @Override
+        public Dialog onCreateDialog(Bundle savedInstanceState) {
+            AlertDialog dialog = new AlertDialog.Builder(getActivity())
+                    .setTitle("Select a reward")
+                    .setSingleChoiceItems(mRewards, -1, new DialogInterface.OnClickListener() {
+                        public void onClick(DialogInterface dialog, int which) {
+                            mSelectedReward = mRewards[which];
+                        }
+                    })
+                    .setPositiveButton("Select", null)
+                    .create();
+
+            // Overriding onShow() of dialog's OnShowListener() and onClick() of the Select button's
+            // OnClickListener() to prevent the dialog from dismissing upon any button click without
+            // selecting an item first.
+            dialog.setOnShowListener(new DialogInterface.OnShowListener() {
+                @Override
+                public void onShow(DialogInterface dialog) {
+                    Button selectButton = ((AlertDialog) dialog).getButton(AlertDialog.BUTTON_POSITIVE);
+                    selectButton.setOnClickListener(new View.OnClickListener() {
+                        @Override
+                        public void onClick(View v) {
+                            if (mSelectedReward != null) {
+                                ((RewardedVideoDetailFragment) getTargetFragment())
+                                        .selectReward(mSelectedReward);
+                                dismiss();
+                            }
+                        }
+                    });
+                }
+            });
+
+            return dialog;
+        }
+    }
 }
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/LocationService.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/LocationService.java
index 77e44feb..8e6e5471 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/LocationService.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/LocationService.java
@@ -3,6 +3,7 @@
 import android.content.Context;
 import android.location.Location;
 import android.location.LocationManager;
+import android.os.SystemClock;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 
@@ -47,6 +48,29 @@
         }
     }
 
+    private static volatile LocationService sInstance;
+    @VisibleForTesting @Nullable Location mLastKnownLocation;
+    @VisibleForTesting long mLocationLastUpdatedMillis;
+
+    private LocationService() {
+    }
+
+    @VisibleForTesting
+    @NonNull
+    static LocationService getInstance() {
+        LocationService locationService = sInstance;
+        if (locationService == null) {
+            synchronized (LocationService.class) {
+                locationService = sInstance;
+                if (locationService == null) {
+                    locationService = new LocationService();
+                    sInstance = locationService;
+                }
+            }
+        }
+        return locationService;
+    }
+
     public enum ValidLocationProvider {
         NETWORK(LocationManager.NETWORK_PROVIDER),
         GPS(LocationManager.GPS_PROVIDER);
@@ -75,12 +99,17 @@ private boolean hasRequiredPermissions(@NonNull final Context context) {
         }
     }
 
-    /*
+    /**
      * Returns the last known location of the device using its GPS and network location providers.
-     * May be null if:
-     * - Location permissions are not requested in the Android manifest file
-     * - The location providers don't exist
-     * - Location awareness is disabled in the parent MoPubView
+     * This only checks Android location providers as often as
+     * {@link MoPub#getMinimumLocationRefreshTimeMillis()} says to, in milliseconds.
+     * <p>
+     * May be {@code null} if:
+     * <ul>
+     * <li> Location permissions are not requested in the Android manifest file
+     * <li> The location providers don't exist
+     * <li> Location awareness is disabled in the parent MoPubView
+     * </ul>
      */
     @Nullable
     public static Location getLastKnownLocation(@NonNull final Context context,
@@ -93,6 +122,12 @@ public static Location getLastKnownLocation(@NonNull final Context context,
             return null;
         }
 
+        final LocationService locationService = getInstance();
+
+        if (isLocationFreshEnough()) {
+            return locationService.mLastKnownLocation;
+        }
+
         final Location gpsLocation = getLocationFromProvider(context, ValidLocationProvider.GPS);
         final Location networkLocation = getLocationFromProvider(context, ValidLocationProvider.NETWORK);
         final Location result = getMostRecentValidLocation(gpsLocation, networkLocation);
@@ -102,6 +137,8 @@ public static Location getLastKnownLocation(@NonNull final Context context,
             truncateLocationLatLon(result, locationPrecision);
         }
 
+        locationService.mLastKnownLocation = result;
+        locationService.mLocationLastUpdatedMillis = SystemClock.elapsedRealtime();
         return result;
     }
 
@@ -151,7 +188,6 @@ static Location getMostRecentValidLocation(@Nullable final Location a, @Nullable
     }
 
     @VisibleForTesting
-    @Nullable
     static void truncateLocationLatLon(@Nullable final Location location,
             final int precision) {
         if (location == null || precision < 0) {
@@ -170,4 +206,19 @@ static void truncateLocationLatLon(@Nullable final Location location,
                 .doubleValue();
         location.setLongitude(truncatedLon);
     }
+
+    private static boolean isLocationFreshEnough() {
+        final LocationService locationService = LocationService.getInstance();
+        if (locationService.mLastKnownLocation == null) {
+            return false;
+        }
+        return SystemClock.elapsedRealtime() - locationService.mLocationLastUpdatedMillis <=
+                MoPub.getMinimumLocationRefreshTimeMillis();
+    }
+
+    @Deprecated
+    @VisibleForTesting
+    public static void clearLastKnownLocation() {
+        getInstance().mLastKnownLocation = null;
+    }
 }
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/MoPub.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/MoPub.java
index 2ed25204..f9025f68 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/MoPub.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/MoPub.java
@@ -11,7 +11,7 @@
 import java.lang.reflect.Method;
 
 public class MoPub {
-    public static final String SDK_VERSION = "4.12.0";
+    public static final String SDK_VERSION = "4.13.0";
 
     public enum LocationAwareness { NORMAL, TRUNCATED, DISABLED }
 
@@ -25,8 +25,10 @@
             "com.mopub.mobileads.MoPubRewardedVideoManager$RequestParameters";
 
     private static final int DEFAULT_LOCATION_PRECISION = 6;
+    private static final long DEFAULT_LOCATION_REFRESH_TIME_MILLIS = 60 * 1000;
     private static volatile LocationAwareness sLocationLocationAwareness = LocationAwareness.NORMAL;
     private static volatile int sLocationPrecision = DEFAULT_LOCATION_PRECISION;
+    private static volatile long sMinimumLocationRefreshTimeMillis = DEFAULT_LOCATION_REFRESH_TIME_MILLIS;
     private static boolean sSearchedForUpdateActivityMethod = false;
     @Nullable private static Method sUpdateActivityMethod;
 
@@ -50,6 +52,15 @@ public static void setLocationPrecision(int precision) {
         sLocationPrecision = Math.min(Math.max(0, precision), DEFAULT_LOCATION_PRECISION);
     }
 
+    public static void setMinimumLocationRefreshTimeMillis(
+            final long minimumLocationRefreshTimeMillis) {
+        sMinimumLocationRefreshTimeMillis = minimumLocationRefreshTimeMillis;
+    }
+
+    public static long getMinimumLocationRefreshTimeMillis() {
+        return sMinimumLocationRefreshTimeMillis;
+    }
+
 
     //////// MoPub LifecycleListener messages ////////
 
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/ResponseHeader.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/ResponseHeader.java
index 3eb82b64..d8aded62 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/ResponseHeader.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/ResponseHeader.java
@@ -36,6 +36,7 @@
     // Rewarded Ad fields
     REWARDED_VIDEO_CURRENCY_NAME("X-Rewarded-Video-Currency-Name"),
     REWARDED_VIDEO_CURRENCY_AMOUNT("X-Rewarded-Video-Currency-Amount"),
+    REWARDED_CURRENCIES("X-Rewarded-Currencies"),
     REWARDED_VIDEO_COMPLETION_URL("X-Rewarded-Video-Completion-Url"),
     REWARDED_DURATION("X-Rewarded-Duration"),
     SHOULD_REWARD_ON_CLICK("X-Should-Reward-On-Click"),
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/AdViewController.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/AdViewController.java
index 98f3d52f..09bcce0f 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/AdViewController.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/AdViewController.java
@@ -71,8 +71,20 @@
     int mBackoffPower = 1;
 
     private Map<String, Object> mLocalExtras = new HashMap<String, Object>();
-    private boolean mAutoRefreshEnabled = true;
-    private boolean mPreviousAutoRefreshSetting = true;
+
+    /**
+     * This is the current auto refresh status. If this is true, then ads will attempt to refresh.
+     * If mRefreshTimeMillis is null or not greater than 0, the auto refresh runnable will not
+     * be called.
+     */
+    private boolean mCurrentAutoRefreshStatus = true;
+
+    /**
+     * This is the publisher-specified auto refresh flag. AdViewController will only attempt to
+     * refresh ads when this is true. Setting this to false will block refreshing.
+     */
+    private boolean mShouldAllowAutoRefresh = true;
+
     private String mKeywords;
     private Location mLocation;
     private boolean mIsTesting;
@@ -333,35 +345,45 @@ public int getAdHeight() {
         return 0;
     }
 
+    /**
+     * This has been renamed to {@link #getCurrentAutoRefreshStatus()}.
+     */
+    @Deprecated
     public boolean getAutorefreshEnabled() {
-        return mAutoRefreshEnabled;
+        return getCurrentAutoRefreshStatus();
+    }
+
+    public boolean getCurrentAutoRefreshStatus() {
+        return mCurrentAutoRefreshStatus;
     }
 
     void pauseRefresh() {
-        mPreviousAutoRefreshSetting = mAutoRefreshEnabled;
-        setAutorefreshEnabled(false);
+        setAutoRefreshStatus(false);
     }
 
-    void unpauseRefresh() {
-        setAutorefreshEnabled(mPreviousAutoRefreshSetting);
+    void resumeRefresh() {
+        if (mShouldAllowAutoRefresh) {
+            setAutoRefreshStatus(true);
+        }
     }
 
-    void forceSetAutorefreshEnabled(boolean enabled) {
-        mPreviousAutoRefreshSetting = enabled;
-        setAutorefreshEnabled(enabled);
+    void setShouldAllowAutoRefresh(final boolean shouldAllowAutoRefresh) {
+        mShouldAllowAutoRefresh = shouldAllowAutoRefresh;
+        setAutoRefreshStatus(shouldAllowAutoRefresh);
     }
 
-    private void setAutorefreshEnabled(boolean enabled) {
-        final boolean autorefreshChanged = mAdWasLoaded && (mAutoRefreshEnabled != enabled);
-        if (autorefreshChanged) {
-            final String enabledString = (enabled) ? "enabled" : "disabled";
+    private void setAutoRefreshStatus(final boolean newAutoRefreshStatus) {
+        final boolean autoRefreshStatusChanged = mAdWasLoaded &&
+                (mCurrentAutoRefreshStatus != newAutoRefreshStatus);
+        if (autoRefreshStatusChanged) {
+            final String enabledString = (newAutoRefreshStatus) ? "enabled" : "disabled";
             MoPubLog.d("Refresh " + enabledString + " for ad unit (" + mAdUnitId + ").");
         }
 
-        mAutoRefreshEnabled = enabled;
-        if (mAdWasLoaded && mAutoRefreshEnabled) {
+        mCurrentAutoRefreshStatus = newAutoRefreshStatus;
+        if (mAdWasLoaded && mCurrentAutoRefreshStatus) {
             scheduleRefreshTimerIfEnabled();
-        } else if (!mAutoRefreshEnabled) {
+        } else if (!mCurrentAutoRefreshStatus) {
             cancelRefreshTimer();
         }
     }
@@ -399,7 +421,7 @@ void cleanup() {
             mActiveRequest = null;
         }
 
-        setAutorefreshEnabled(false);
+        setAutoRefreshStatus(false);
         cancelRefreshTimer();
 
         // WebView subclasses are not garbage-collected in a timely fashion on Froyo and below,
@@ -480,7 +502,7 @@ void adDidFail(MoPubErrorCode errorCode) {
 
     void scheduleRefreshTimerIfEnabled() {
         cancelRefreshTimer();
-        if (mAutoRefreshEnabled && mRefreshTimeMillis != null && mRefreshTimeMillis > 0) {
+        if (mCurrentAutoRefreshStatus && mRefreshTimeMillis != null && mRefreshTimeMillis > 0) {
 
             mHandler.postDelayed(mRefreshRunnable,
                     Math.min(MAX_REFRESH_TIME_MILLISECONDS,
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/MoPubErrorCode.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/MoPubErrorCode.java
index d3322c04..20bc63a2 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/MoPubErrorCode.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/MoPubErrorCode.java
@@ -20,6 +20,9 @@
     VIDEO_NOT_AVAILABLE("No video loaded for ad unit."),
     VIDEO_PLAYBACK_ERROR("Error playing a video."),
 
+    REWARDED_CURRENCIES_PARSING_ERROR("Error parsing rewarded currencies JSON header."),
+    REWARD_NOT_SELECTED("Reward not selected for rewarded ad."),
+
     UNSPECIFIED("Unspecified error.");
 
     private final String message;
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/MoPubView.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/MoPubView.java
index f6ff9a07..4b26ded7 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/MoPubView.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/MoPubView.java
@@ -233,7 +233,7 @@ private void setAdVisibility(final int visibility) {
         }
 
         if (Visibility.isScreenVisible(visibility)) {
-            mAdViewController.unpauseRefresh();
+            mAdViewController.resumeRefresh();
         } else {
             mAdViewController.pauseRefresh();
         }
@@ -335,12 +335,12 @@ public void setLocalExtras(Map<String, Object> localExtras) {
 
     public void setAutorefreshEnabled(boolean enabled) {
         if (mAdViewController != null) {
-            mAdViewController.forceSetAutorefreshEnabled(enabled);
+            mAdViewController.setShouldAllowAutoRefresh(enabled);
         }
     }
 
     public boolean getAutorefreshEnabled() {
-        if (mAdViewController != null) return mAdViewController.getAutorefreshEnabled();
+        if (mAdViewController != null) return mAdViewController.getCurrentAutoRefreshStatus();
         else {
             MoPubLog.d("Can't get autorefresh status for destroyed MoPubView. " +
                     "Returning false.");
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/resource/MraidJavascript.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/resource/MraidJavascript.java
index 7071ffa0..cc0791a9 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/resource/MraidJavascript.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/resource/MraidJavascript.java
@@ -884,5 +884,5 @@
             "      }\n" +
             "    }\n" +
             "  };\n" +
-            "}());\n";
+            "}());\n".replaceAll("(?m)^\\s+", "").replaceAll("(?m)^//.*(?=\\n)", "");
 }
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mraid/MraidBridge.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mraid/MraidBridge.java
index 897b22a0..00ccf7bd 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mraid/MraidBridge.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mraid/MraidBridge.java
@@ -27,7 +27,6 @@
 import com.mopub.mobileads.BaseWebView;
 import com.mopub.mobileads.ViewGestureDetector;
 import com.mopub.mobileads.ViewGestureDetector.UserClickListener;
-import com.mopub.mobileads.resource.MraidJavascript;
 import com.mopub.mraid.MraidBridge.MraidWebView.OnVisibilityChangedListener;
 import com.mopub.mraid.MraidNativeCommandHandler.MraidCommandFailureListener;
 import com.mopub.network.Networking;
@@ -73,10 +72,6 @@ void onSetOrientationProperties(boolean allowOrientationChange, MraidOrientation
         void onPlayVideo(URI uri);
     }
 
-    private final String FILTERED_JAVASCRIPT_SOURCE = MraidJavascript.JAVASCRIPT_SOURCE
-            .replaceAll("(?m)^\\s+", "")
-            .replaceAll("(?m)^//.*(?=\\n)", "");
-
     @NonNull private final PlacementType mPlacementType;
 
     @NonNull private final MraidNativeCommandHandler mMraidNativeCommandHandler;
@@ -115,7 +110,6 @@ void attachView(@NonNull MraidWebView mraidWebView) {
             }
         }
 
-        mMraidWebView.loadUrl("javascript:" + FILTERED_JAVASCRIPT_SOURCE);
         mMraidWebView.setScrollContainer(false);
         mMraidWebView.setVerticalScrollBarEnabled(false);
         mMraidWebView.setHorizontalScrollBarEnabled(false);
@@ -274,13 +268,7 @@ public boolean isVisible() {
         }
     }
 
-    private final WebViewClient mMraidWebViewClient = new WebViewClient() {
-        @Override
-        public void onReceivedError(WebView view, int errorCode, String description, String failingUrl) {
-            MoPubLog.d("Error: " + description);
-            super.onReceivedError(view, errorCode, description, failingUrl);
-        }
-
+    private final WebViewClient mMraidWebViewClient = new MraidWebViewClient() {
         @Override
         public boolean shouldOverrideUrlLoading(@NonNull WebView view, @NonNull String url) {
             return handleShouldOverrideUrl(url);
@@ -290,6 +278,13 @@ public boolean shouldOverrideUrlLoading(@NonNull WebView view, @NonNull String u
         public void onPageFinished(@NonNull WebView view, @NonNull String url) {
             handlePageFinished();
         }
+
+        @Override
+        public void onReceivedError(@NonNull WebView view, int errorCode,
+                @NonNull String description, @NonNull String failingUrl) {
+            MoPubLog.d("Error: " + description);
+            super.onReceivedError(view, errorCode, description, failingUrl);
+        }
     };
 
     @VisibleForTesting
@@ -587,7 +582,7 @@ public void notifyScreenMetrics(@NonNull final MraidScreenMetrics screenMetrics)
                 + stringifyRect(screenMetrics.getDefaultAdRectDips())
                 + ")");
         injectJavaScript("mraidbridge.notifySizeChangeEvent("
-                + stringifySize(screenMetrics.getCurrentAdRect())
+                + stringifySize(screenMetrics.getCurrentAdRectDips())
                 + ")");
     }
 
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mraid/MraidWebViewClient.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mraid/MraidWebViewClient.java
new file mode 100644
index 00000000..b2864ed4
--- /dev/null
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mraid/MraidWebViewClient.java
@@ -0,0 +1,46 @@
+package com.mopub.mraid;
+
+import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
+import android.webkit.WebResourceResponse;
+import android.webkit.WebView;
+import android.webkit.WebViewClient;
+
+import com.mopub.mobileads.resource.MraidJavascript;
+
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.util.Locale;
+
+/**
+ * Handles injecting the MRAID javascript when encountering mraid.js urls
+ */
+public class MraidWebViewClient extends WebViewClient {
+
+    private static final String MRAID_JS = "mraid.js";
+    private static final String MRAID_INJECTION_JAVASCRIPT = "javascript:"
+            + MraidJavascript.JAVASCRIPT_SOURCE;
+
+    @SuppressWarnings("deprecation") // new method will simply call this one
+    @Override
+    public WebResourceResponse shouldInterceptRequest(@NonNull final WebView view,
+            @NonNull final String url) {
+        if (matchesInjectionUrl(url)) {
+            return createMraidInjectionResponse();
+        } else {
+            return super.shouldInterceptRequest(view, url);
+        }
+    }
+
+    @VisibleForTesting
+    boolean matchesInjectionUrl(@NonNull final String url) {
+        final Uri uri = Uri.parse(url.toLowerCase(Locale.US));
+        return MRAID_JS.equals(uri.getLastPathSegment());
+    }
+
+    private WebResourceResponse createMraidInjectionResponse() {
+        InputStream data = new ByteArrayInputStream(MRAID_INJECTION_JAVASCRIPT.getBytes());
+        return new WebResourceResponse("text/javascript", "UTF-8", data);
+    }
+}
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/AdRequest.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/AdRequest.java
index 47852706..1285cc62 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/AdRequest.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/AdRequest.java
@@ -274,6 +274,8 @@ public Listener getListener() {
                     ResponseHeader.REWARDED_VIDEO_CURRENCY_NAME);
             final String rewardedVideoCurrencyAmount = extractHeader(headers,
                     ResponseHeader.REWARDED_VIDEO_CURRENCY_AMOUNT);
+            final String rewardedCurrencies = extractHeader(headers,
+                    ResponseHeader.REWARDED_CURRENCIES);
             final String rewardedVideoCompletionUrl = extractHeader(headers,
                     ResponseHeader.REWARDED_VIDEO_COMPLETION_URL);
             final Integer rewardedDuration = extractIntegerHeader(headers,
@@ -282,6 +284,7 @@ public Listener getListener() {
                     ResponseHeader.SHOULD_REWARD_ON_CLICK, false);
             builder.setRewardedVideoCurrencyName(rewardedVideoCurrencyName);
             builder.setRewardedVideoCurrencyAmount(rewardedVideoCurrencyAmount);
+            builder.setRewardedCurrencies(rewardedCurrencies);
             builder.setRewardedVideoCompletionUrl(rewardedVideoCompletionUrl);
             builder.setRewardedDuration(rewardedDuration);
             builder.setShouldRewardOnClick(shouldRewardOnClick);
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/AdResponse.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/AdResponse.java
index ae157562..5a28175b 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/AdResponse.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/AdResponse.java
@@ -31,6 +31,8 @@
     @Nullable
     private final String mRewardedVideoCurrencyAmount;
     @Nullable
+    private final String mRewardedCurrencies;
+    @Nullable
     private final String mRewardedVideoCompletionUrl;
     @Nullable
     private final Integer mRewardedDuration;
@@ -84,6 +86,7 @@ private AdResponse(@NonNull Builder builder) {
 
         mRewardedVideoCurrencyName = builder.rewardedVideoCurrencyName;
         mRewardedVideoCurrencyAmount = builder.rewardedVideoCurrencyAmount;
+        mRewardedCurrencies = builder.rewardedCurrencies;
         mRewardedVideoCompletionUrl = builder.rewardedVideoCompletionUrl;
         mRewardedDuration = builder.rewardedDuration;
         mShouldRewardOnClick = builder.shouldRewardOnClick;
@@ -156,6 +159,11 @@ public String getRewardedVideoCurrencyAmount() {
         return mRewardedVideoCurrencyAmount;
     }
 
+    @Nullable
+    public String getRewardedCurrencies() {
+        return mRewardedCurrencies;
+    }
+
     @Nullable
     public String getRewardedVideoCompletionUrl() {
         return mRewardedVideoCompletionUrl;
@@ -245,6 +253,7 @@ public Builder toBuilder() {
                 .setNetworkType(mNetworkType)
                 .setRewardedVideoCurrencyName(mRewardedVideoCurrencyName)
                 .setRewardedVideoCurrencyAmount(mRewardedVideoCurrencyAmount)
+                .setRewardedCurrencies(mRewardedCurrencies)
                 .setRewardedVideoCompletionUrl(mRewardedVideoCompletionUrl)
                 .setRewardedDuration(mRewardedDuration)
                 .setShouldRewardOnClick(mShouldRewardOnClick)
@@ -272,6 +281,7 @@ public Builder toBuilder() {
 
         private String rewardedVideoCurrencyName;
         private String rewardedVideoCurrencyAmount;
+        private String rewardedCurrencies;
         private String rewardedVideoCompletionUrl;
         private Integer rewardedDuration;
         private boolean shouldRewardOnClick;
@@ -330,6 +340,11 @@ public Builder setRewardedVideoCurrencyAmount(
             return this;
         }
 
+        public Builder setRewardedCurrencies(@Nullable final String rewardedCurrencies) {
+            this.rewardedCurrencies = rewardedCurrencies;
+            return this;
+        }
+
         public Builder setRewardedVideoCompletionUrl(
                 @Nullable final String rewardedVideoCompletionUrl) {
             this.rewardedVideoCompletionUrl = rewardedVideoCompletionUrl;
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/HeaderUtils.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/HeaderUtils.java
index 3010a77e..55fba8cc 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/HeaderUtils.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/HeaderUtils.java
@@ -68,6 +68,14 @@ private static boolean formatBooleanHeader(@Nullable String headerValue, boolean
     }
 
     private static Integer formatIntHeader(String headerValue) {
+        try {
+            return Integer.parseInt(headerValue);
+        } catch (Exception e) {
+            // Continue below if we can't parse it quickly
+        }
+
+        // The number format way of parsing integers is way slower than Integer.parseInt, but
+        // for numbers like 3.14, we would like to return 3, not null.
         NumberFormat numberFormat = NumberFormat.getInstance(Locale.US);
         numberFormat.setParseIntegerOnly(true);
 
diff --git a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/MraidActivity.java b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/MraidActivity.java
index a5aa5f80..e2f86bd6 100644
--- a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/MraidActivity.java
+++ b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/MraidActivity.java
@@ -10,7 +10,6 @@
 import android.view.View;
 import android.view.WindowManager;
 import android.webkit.WebView;
-import android.webkit.WebViewClient;
 
 import com.mopub.common.AdReport;
 import com.mopub.common.Constants;
@@ -20,6 +19,7 @@
 import com.mopub.mraid.MraidController;
 import com.mopub.mraid.MraidController.MraidListener;
 import com.mopub.mraid.MraidController.UseCustomCloseListener;
+import com.mopub.mraid.MraidWebViewClient;
 import com.mopub.mraid.MraidWebViewDebugListener;
 import com.mopub.mraid.PlacementType;
 import com.mopub.network.Networking;
@@ -52,15 +52,20 @@ static void preRenderHtml(
         dummyWebView.enablePlugins(false);
         dummyWebView.enableJavascriptCaching();
 
-        dummyWebView.setWebViewClient(new WebViewClient() {
+        dummyWebView.setWebViewClient(new MraidWebViewClient() {
             @Override
-            public void onPageFinished(final WebView view, final String url) {
-                customEventInterstitialListener.onInterstitialLoaded();
+            public boolean shouldOverrideUrlLoading(WebView view, String url) {
+                return true;
             }
 
             @Override
-            public boolean shouldOverrideUrlLoading(WebView view, String url) {
-                return true;
+            public void onPageFinished(final WebView view, final String url) {
+                customEventInterstitialListener.onInterstitialLoaded();
+
+                // can't reuse MraidBridge methods because MraidController is not initialized yet
+                dummyWebView.loadUrl("javascript:mraidbridge.setState('default');");
+                dummyWebView.loadUrl("javascript:mraidbridge.notifyReadyEvent();");
+
             }
 
             @Override
diff --git a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/common/MoPubReward.java b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/common/MoPubReward.java
index 0c2b0ce3..60014242 100644
--- a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/common/MoPubReward.java
+++ b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/common/MoPubReward.java
@@ -35,7 +35,7 @@ private MoPubReward(boolean success, @NonNull String label, int amount) {
 
     @NonNull
     public static MoPubReward failure() {
-        return new MoPubReward(false, NO_REWARD_LABEL, 0);
+        return new MoPubReward(false, NO_REWARD_LABEL, DEFAULT_REWARD_AMOUNT);
     }
 
     @NonNull
diff --git a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedVideoManager.java b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedVideoManager.java
index f41d6961..2867c02d 100644
--- a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedVideoManager.java
+++ b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedVideoManager.java
@@ -20,6 +20,7 @@
 import com.mopub.common.Preconditions;
 import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Json;
 import com.mopub.common.util.MoPubCollections;
 import com.mopub.common.util.Reflection;
 import com.mopub.common.util.ReflectionTarget;
@@ -32,7 +33,10 @@
 import com.mopub.volley.RequestQueue;
 import com.mopub.volley.VolleyError;
 
+import org.json.JSONException;
+
 import java.lang.ref.WeakReference;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Locale;
@@ -47,6 +51,9 @@
 public class MoPubRewardedVideoManager {
     private static MoPubRewardedVideoManager sInstance;
     private static final int DEFAULT_LOAD_TIMEOUT = Constants.THIRTY_SECONDS_MILLIS;
+    private static final String CURRENCIES_JSON_REWARDS_MAP_KEY = "rewards";
+    private static final String CURRENCIES_JSON_REWARD_NAME_KEY = "name";
+    private static final String CURRENCIES_JSON_REWARD_AMOUNT_KEY = "amount";
 
     /**
      * This must an integer because the backend only supports int types for api version.
@@ -296,6 +303,8 @@ private static void loadVideo(@NonNull String adUnitId, @NonNull String adUrlStr
         final RequestQueue requestQueue = Networking.getRequestQueue(sInstance.mContext);
         requestQueue.add(request);
         sInstance.mAdRequestStatus.markLoading(adUnitId);
+        MoPubLog.d(String.format(Locale.US,
+                "Loading rewarded ad request for ad unit %s with URL %s", adUnitId, adUrlString));
     }
 
     public static boolean hasVideo(@NonNull String adUnitId) {
@@ -312,6 +321,13 @@ public static void showVideo(@NonNull String adUnitId) {
         if (sInstance != null) {
             final CustomEventRewardedAd customEvent = sInstance.mRewardedAdData.getCustomEvent(adUnitId);
             if (isPlayable(adUnitId, customEvent)) {
+                // If there are rewards available but no reward is selected, fail over.
+                if (!sInstance.mRewardedAdData.getAvailableRewards(adUnitId).isEmpty()
+                        && sInstance.mRewardedAdData.getMoPubReward(adUnitId) == null) {
+                    sInstance.failover(adUnitId, MoPubErrorCode.REWARD_NOT_SELECTED);
+                    return;
+                }
+
                 sInstance.mRewardedAdData.updateCustomEventLastShownRewardMapping(
                         customEvent.getClass(),
                         sInstance.mRewardedAdData.getMoPubReward(adUnitId));
@@ -333,6 +349,36 @@ private static boolean isPlayable(String adUnitId, @Nullable CustomEventRewarded
                 && customEvent.isReady());
     }
 
+    /**
+     * Retrieves the set of available {@link MoPubReward} instance(s) for this AdUnit.
+     * @param adUnitId MoPub adUnitId String
+     * @return a set of {@link MoPubReward} instance(s) if available, else an empty set.
+     */
+    @NonNull
+    public static Set<MoPubReward> getAvailableRewards(@NonNull String adUnitId) {
+        if (sInstance != null) {
+            return sInstance.mRewardedAdData.getAvailableRewards(adUnitId);
+        } else {
+            logErrorNotInitialized();
+            return Collections.<MoPubReward>emptySet();
+        }
+    }
+
+    /**
+     * Selects the reward for this AdUnit from available {@link MoPubReward} instances.
+     * If this AdUnit does not have any rewards, or if the selected reward is not available
+     * for this AdUnit, then no reward will be selected for this AdUnit.
+     * @param adUnitId MoPub adUnitId String
+     * @param selectedReward selected {@link MoPubReward}
+     */
+    public static void selectReward(@NonNull String adUnitId, @NonNull MoPubReward selectedReward) {
+        if (sInstance != null) {
+            sInstance.mRewardedAdData.selectReward(adUnitId, selectedReward);
+        } else {
+            logErrorNotInitialized();
+        }
+    }
+
     ///// Ad Request / Response methods /////
     private void onAdSuccess(AdResponse adResponse, String adUnitId) {
         mAdRequestStatus.markLoaded(adUnitId,
@@ -385,9 +431,29 @@ private void onAdSuccess(AdResponse adResponse, String adUnitId) {
 
             localExtras.put(DataKeys.REWARDED_AD_CUSTOMER_ID_KEY,
                     mRewardedAdData.getCustomerId());
-            mRewardedAdData.updateAdUnitRewardMapping(adUnitId,
-                    adResponse.getRewardedVideoCurrencyName(),
-                    adResponse.getRewardedVideoCurrencyAmount());
+
+            // Check for new multi-currency header X-Rewarded-Currencies.
+            final String rewardedCurrencies = adResponse.getRewardedCurrencies();
+
+            // Clear any available rewards for this AdUnit.
+            mRewardedAdData.resetAvailableRewards(adUnitId);
+
+            // If the new multi-currency header doesn't exist, fallback to parsing legacy headers
+            // X-Rewarded-Video-Currency-Name and X-Rewarded-Video-Currency-Amount.
+            if (TextUtils.isEmpty(rewardedCurrencies)) {
+                mRewardedAdData.updateAdUnitRewardMapping(adUnitId,
+                        adResponse.getRewardedVideoCurrencyName(),
+                        adResponse.getRewardedVideoCurrencyAmount());
+            } else {
+                try {
+                    parseMultiCurrencyJson(adUnitId, rewardedCurrencies);
+                } catch (Exception e) {
+                    MoPubLog.e("Error parsing rewarded currencies JSON header: " + rewardedCurrencies);
+                    failover(adUnitId, MoPubErrorCode.REWARDED_CURRENCIES_PARSING_ERROR);
+                    return;
+                }
+            }
+
             mRewardedAdData.updateAdUnitToServerCompletionUrlMapping(adUnitId,
                     adResponse.getRewardedVideoCompletionUrl());
 
@@ -416,6 +482,8 @@ public void run() {
             mTimeoutMap.put(adUnitId, timeout);
 
             // Load custom event
+            MoPubLog.d(String.format(Locale.US,
+                    "Loading custom event with class name %s", customEventClassName));
             customEvent.loadCustomEvent(mainActivity, localExtras, adResponse.getServerExtras());
 
             final String adNetworkId = customEvent.getAdNetworkId();
@@ -447,14 +515,50 @@ private void onAdError(@NonNull VolleyError volleyError, @NonNull String adUnitI
         failover(adUnitId, errorCode);
     }
 
+    private void parseMultiCurrencyJson(@NonNull String adUnitId,
+            @NonNull String rewardedCurrencies) throws JSONException {
+        /* Parse multi-currency JSON string, an example below:
+            {
+                "rewards": [
+                    { "name": "Coins", "amount": 8 },
+                    { "name": "Diamonds", "amount": 1 },
+                    { "name": "Diamonds", "amount": 10 },
+                    { "name": "Energy", "amount": 20 }
+                ]
+            }
+         */
+
+        final Map<String, String> rewardsMap = Json.jsonStringToMap(rewardedCurrencies);
+        final String[] rewardsArray =
+                Json.jsonArrayToStringArray(rewardsMap.get(CURRENCIES_JSON_REWARDS_MAP_KEY));
+
+        // If there's only one reward, update adunit-to-reward mapping now
+        if (rewardsArray.length == 1) {
+            Map<String, String> rewardData = Json.jsonStringToMap(rewardsArray[0]);
+            mRewardedAdData.updateAdUnitRewardMapping(
+                    adUnitId,
+                    rewardData.get(CURRENCIES_JSON_REWARD_NAME_KEY),
+                    rewardData.get(CURRENCIES_JSON_REWARD_AMOUNT_KEY));
+        }
+
+        // Loop through awards array and create a set of available reward(s) for this adunit
+        for (String rewardDataStr : rewardsArray) {
+            Map<String, String> rewardData = Json.jsonStringToMap(rewardDataStr);
+            mRewardedAdData.addAvailableReward(
+                    adUnitId,
+                    rewardData.get(CURRENCIES_JSON_REWARD_NAME_KEY),
+                    rewardData.get(CURRENCIES_JSON_REWARD_AMOUNT_KEY));
+        }
+    }
+
     private void failover(@NonNull final String adUnitId, @NonNull final MoPubErrorCode errorCode) {
         final String failoverUrl = mAdRequestStatus.getFailoverUrl(adUnitId);
         mAdRequestStatus.markFail(adUnitId);
 
         if (failoverUrl != null) {
             loadVideo(adUnitId, failoverUrl);
-        } else if (mVideoListener != null) {
-            mVideoListener.onRewardedVideoLoadFailure(adUnitId, errorCode);
+        } else if (sInstance.mVideoListener != null) {
+            sInstance.mVideoListener.onRewardedVideoLoadFailure(adUnitId, errorCode);
         }
     }
 
@@ -655,10 +759,22 @@ public void run() {
             postToInstance(new Runnable() {
                 @Override
                 public void run() {
+                    final MoPubReward reward
+                            = sInstance.mRewardedAdData.getMoPubReward(currentlyShowingAdUnitId);
+
+                    final String rewardName = (reward == null)
+                            ? MoPubReward.NO_REWARD_LABEL
+                            : reward.getLabel();
+                    final String rewardAmount = (reward == null)
+                            ? Integer.toString(MoPubReward.DEFAULT_REWARD_AMOUNT)
+                            : Integer.toString(reward.getAmount());
+
                     RewardedVideoCompletionRequestHandler.makeRewardedVideoCompletionRequest(
                             sInstance.mContext,
                             serverCompletionUrl,
-                            sInstance.mRewardedAdData.getCustomerId());
+                            sInstance.mRewardedAdData.getCustomerId(),
+                            rewardName,
+                            rewardAmount);
                 }
             });
         }
diff --git a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedVideos.java b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedVideos.java
index 3fd9c37b..9e7577c3 100644
--- a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedVideos.java
+++ b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedVideos.java
@@ -5,9 +5,12 @@
 import android.support.annotation.Nullable;
 
 import com.mopub.common.MediationSettings;
+import com.mopub.common.MoPubReward;
 import com.mopub.common.Preconditions;
 import com.mopub.common.util.ReflectionTarget;
 
+import java.util.Set;
+
 /**
  * MoPubRewardedVideos is a utility class that holds controller methods for other MoPub rewarded
  * video classes.
@@ -57,4 +60,19 @@ public static void showRewardedVideo(@NonNull String adUnitId) {
 
         MoPubRewardedVideoManager.showVideo(adUnitId);
     }
+
+    @ReflectionTarget
+    public static Set<MoPubReward> getAvailableRewards(@NonNull String adUnitId) {
+        Preconditions.checkNotNull(adUnitId);
+
+        return MoPubRewardedVideoManager.getAvailableRewards(adUnitId);
+    }
+
+    @ReflectionTarget
+    public static void selectReward(@NonNull String adUnitId, @NonNull MoPubReward selectedReward) {
+        Preconditions.checkNotNull(adUnitId);
+        Preconditions.checkNotNull(selectedReward);
+
+        MoPubRewardedVideoManager.selectReward(adUnitId, selectedReward);
+    }
 }
diff --git a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/RewardedAdData.java b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/RewardedAdData.java
index f4ee6548..f67a6f48 100644
--- a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/RewardedAdData.java
+++ b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/RewardedAdData.java
@@ -8,11 +8,13 @@
 import com.mopub.common.MoPubReward;
 import com.mopub.common.Preconditions;
 import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
 
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 import java.util.TreeMap;
@@ -26,6 +28,8 @@
     @NonNull
     private final Map<String, MoPubReward> mAdUnitToRewardMap;
     @NonNull
+    private final Map<String, Set<MoPubReward>> mAdUnitToAvailableRewardsMap;
+    @NonNull
     private final Map<String, String> mAdUnitToServerCompletionUrlMap;
     @NonNull
     private final Map<Class<? extends CustomEventRewardedAd>, MoPubReward> mCustomEventToRewardMap;
@@ -40,6 +44,7 @@
     RewardedAdData() {
         mAdUnitToCustomEventMap = new TreeMap<String, CustomEventRewardedAd>();
         mAdUnitToRewardMap = new TreeMap<String, MoPubReward>();
+        mAdUnitToAvailableRewardsMap = new TreeMap<String, Set<MoPubReward>>();
         mAdUnitToServerCompletionUrlMap = new TreeMap<String, String>();
         mCustomEventToRewardMap = new HashMap<Class<? extends CustomEventRewardedAd>, MoPubReward>();
         mCustomEventToMoPubIdMap = new HashMap<TwoPartKey, Set<String>>();
@@ -55,6 +60,78 @@ MoPubReward getMoPubReward(@Nullable String moPubId) {
         return mAdUnitToRewardMap.get(moPubId);
     }
 
+    void addAvailableReward(
+            @NonNull String moPubId,
+            @Nullable String currencyName,
+            @Nullable String currencyAmount) {
+        Preconditions.checkNotNull(moPubId);
+        if (currencyName == null || currencyAmount == null) {
+            MoPubLog.e(String.format(Locale.US, "Currency name and amount cannot be null: " +
+                    "name = %s, amount = %s", currencyName, currencyAmount));
+            return;
+        }
+
+        int intCurrencyAmount;
+        try {
+            intCurrencyAmount = Integer.parseInt(currencyAmount);
+        } catch(NumberFormatException e) {
+            MoPubLog.e(String.format(Locale.US, "Currency amount must be an integer: %s",
+                    currencyAmount));
+            return;
+        }
+
+        if (intCurrencyAmount < 0) {
+            MoPubLog.e(String.format(Locale.US, "Currency amount cannot be negative: %s",
+                    currencyAmount));
+            return;
+        }
+
+        if (mAdUnitToAvailableRewardsMap.containsKey(moPubId)) {
+            mAdUnitToAvailableRewardsMap.get(moPubId)
+                    .add(MoPubReward.success(currencyName, intCurrencyAmount));
+        } else {
+            HashSet<MoPubReward> availableRewards = new HashSet<>();
+            availableRewards.add(MoPubReward.success(currencyName, intCurrencyAmount));
+            mAdUnitToAvailableRewardsMap.put(moPubId, availableRewards);
+        }
+    }
+
+    @NonNull
+    Set<MoPubReward> getAvailableRewards(@NonNull String moPubId) {
+        Preconditions.checkNotNull(moPubId);
+        Set<MoPubReward> availableRewards = mAdUnitToAvailableRewardsMap.get(moPubId);
+        return (availableRewards == null) ? Collections.<MoPubReward>emptySet() : availableRewards;
+    }
+
+    void selectReward(@NonNull String moPubId, @NonNull MoPubReward selectedReward) {
+        Preconditions.checkNotNull(moPubId);
+        Preconditions.checkNotNull(selectedReward);
+
+        Set<MoPubReward> availableRewards = mAdUnitToAvailableRewardsMap.get(moPubId);
+        if (availableRewards == null || availableRewards.isEmpty()) {
+            MoPubLog.e(String.format(
+                    Locale.US, "AdUnit %s does not have any rewards.", moPubId));
+            return;
+        }
+
+        if (!availableRewards.contains(selectedReward)) {
+            MoPubLog.e(String.format(
+                    Locale.US, "Selected reward is invalid for AdUnit %s.", moPubId));
+            return;
+        }
+
+        updateAdUnitRewardMapping(moPubId, selectedReward.getLabel(),
+                Integer.toString(selectedReward.getAmount()));
+    }
+
+    void resetAvailableRewards(@NonNull String moPubId) {
+        Preconditions.checkNotNull(moPubId);
+        Set<MoPubReward> availableRewards = mAdUnitToAvailableRewardsMap.get(moPubId);
+        if (availableRewards != null && !availableRewards.isEmpty()) {
+            availableRewards.clear();
+        }
+    }
+
     @Nullable
     String getServerCompletionUrl(@Nullable final String moPubId) {
         if (TextUtils.isEmpty(moPubId)) {
@@ -112,10 +189,14 @@ void updateAdUnitRewardMapping(
         try {
             intCurrencyAmount = Integer.parseInt(currencyAmount);
         } catch(NumberFormatException e) {
+            MoPubLog.e(String.format(Locale.US, "Currency amount must be an integer: %s",
+                    currencyAmount));
             return;
         }
 
         if (intCurrencyAmount < 0) {
+            MoPubLog.e(String.format(Locale.US, "Currency amount cannot be negative: %s",
+                    currencyAmount));
             return;
         }
 
@@ -135,7 +216,7 @@ void updateAdUnitToServerCompletionUrlMapping(@NonNull final String moPubId,
      * is shown.
      *
      * @param customEventClass the rewarded ad custom event class
-     * @param moPubReward the reward from teh MoPub ad server returned in HTTP headers
+     * @param moPubReward the reward from the MoPub ad server returned in HTTP headers
      */
     void updateCustomEventLastShownRewardMapping(
             @NonNull final Class<? extends CustomEventRewardedAd> customEventClass,
@@ -202,6 +283,7 @@ String getCustomerId() {
     void clear() {
         mAdUnitToCustomEventMap.clear();
         mAdUnitToRewardMap.clear();
+        mAdUnitToAvailableRewardsMap.clear();
         mAdUnitToServerCompletionUrlMap.clear();
         mCustomEventToRewardMap.clear();
         mCustomEventToMoPubIdMap.clear();
@@ -209,6 +291,28 @@ void clear() {
         mCustomerId = null;
     }
 
+    @VisibleForTesting
+    @Deprecated
+    /**
+     * This method is purely used as a helper method in unit tests. Note that calling
+     * {@link MoPubReward#success(String, int)} creates a new instance, even with the same reward
+     * label and amount as an existing reward. Therefore, existence of a reward cannot be asserted
+     * simply by comparing objects in the unit tests.
+     */
+    boolean existsInAvailableRewards(@NonNull String moPubId, @NonNull String currencyName,
+            int currencyAmount) {
+        Preconditions.checkNotNull(moPubId);
+        Preconditions.checkNotNull(currencyName);
+
+        for (MoPubReward reward : getAvailableRewards(moPubId)) {
+            if (reward.getLabel().equals(currencyName) && reward.getAmount() == currencyAmount) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
     private static class TwoPartKey extends Pair<Class<? extends CustomEventRewardedAd>, String> {
         @NonNull
         final Class<? extends CustomEventRewardedAd> customEventClass;
diff --git a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/RewardedVideoCompletionRequestHandler.java b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/RewardedVideoCompletionRequestHandler.java
index 5e37c66b..0cb0c34d 100644
--- a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/RewardedVideoCompletionRequestHandler.java
+++ b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/RewardedVideoCompletionRequestHandler.java
@@ -38,6 +38,8 @@
     private static final String CUSTOMER_ID_KEY = "&customer_id=";
     private static final String SDK_VERSION_KEY = "&nv=";
     private static final String API_VERSION_KEY = "&v=";
+    private static final String REWARD_NAME_KEY = "&rcn=";
+    private static final String REWARD_AMOUNT_KEY = "&rca=";
 
     @NonNull private final String mUrl;
     @NonNull private final Handler mHandler;
@@ -46,17 +48,26 @@
     private volatile boolean mShouldStop;
 
     RewardedVideoCompletionRequestHandler(@NonNull final Context context,
-            @NonNull final String url, @Nullable final String customerId) {
-        this(context, url, customerId, new Handler());
+            @NonNull final String url,
+            @Nullable final String customerId,
+            @NonNull final String rewardName,
+            @NonNull final String rewardAmount) {
+        this(context, url, customerId, rewardName, rewardAmount, new Handler());
     }
 
     RewardedVideoCompletionRequestHandler(@NonNull final Context context,
             @NonNull final String url,
             @Nullable final String customerId,
+            @NonNull final String rewardName,
+            @NonNull final String rewardAmount,
             @NonNull final Handler handler) {
         Preconditions.checkNotNull(context);
         Preconditions.checkNotNull(url);
-        mUrl = appendParameters(url, customerId);
+        Preconditions.checkNotNull(rewardName);
+        Preconditions.checkNotNull(rewardAmount);
+        Preconditions.checkNotNull(handler);
+
+        mUrl = appendParameters(url, customerId, rewardName, rewardAmount);
         mRetryCount = 0;
         mHandler = handler;
         mRequestQueue = Networking.getRequestQueue(context);
@@ -109,13 +120,15 @@ public void onErrorResponse(final VolleyError volleyError) {
 
     public static void makeRewardedVideoCompletionRequest(@Nullable final Context context,
             @Nullable final String url,
-            @Nullable final String customerId) {
-        if (TextUtils.isEmpty(url) || context == null) {
+            @Nullable final String customerId,
+            @NonNull final String rewardName,
+            @NonNull final String rewardAmount) {
+        if (context == null || TextUtils.isEmpty(url) || rewardName == null || rewardAmount == null) {
             return;
         }
 
-        new RewardedVideoCompletionRequestHandler(context,
-                url, customerId).makeRewardedVideoCompletionRequest();
+        new RewardedVideoCompletionRequestHandler(context, url, customerId, rewardName,
+                rewardAmount).makeRewardedVideoCompletionRequest();
     }
 
     static int getTimeout(int retryCount) {
@@ -127,11 +140,17 @@ static int getTimeout(int retryCount) {
     }
 
     private static String appendParameters(@NonNull final String url,
-            @Nullable final String customerId) {
+            @Nullable final String customerId,
+            @NonNull final String rewardName,
+            @NonNull final String rewardAmount) {
         Preconditions.checkNotNull(url);
+        Preconditions.checkNotNull(rewardName);
+        Preconditions.checkNotNull(rewardAmount);
 
         return url +
                 CUSTOMER_ID_KEY + (customerId == null ? "" : Uri.encode(customerId)) +
+                REWARD_NAME_KEY + Uri.encode(rewardName) +
+                REWARD_AMOUNT_KEY + Uri.encode(rewardAmount) +
                 SDK_VERSION_KEY + Uri.encode(MoPub.SDK_VERSION) +
                 API_VERSION_KEY + MoPubRewardedVideoManager.API_VERSION;
     }
diff --git a/mopub-sdk/proguard.txt b/mopub-sdk/proguard.txt
index 3ad22097..bff255cd 100644
--- a/mopub-sdk/proguard.txt
+++ b/mopub-sdk/proguard.txt
@@ -5,19 +5,37 @@
 # Keep public classes and methods.
 -keepclassmembers class com.mopub.** { public *; }
 -keep public class com.mopub.**
+-keep public class android.webkit.JavascriptInterface {}
 
 # Explicitly keep any custom event classes in any package.
 -keep class * extends com.mopub.mobileads.CustomEventBanner {}
 -keep class * extends com.mopub.mobileads.CustomEventInterstitial {}
 -keep class * extends com.mopub.nativeads.CustomEventNative {}
--keep class * extends com.mopub.mobileads.CustomEventRewardedVideo {}
+-keep class * extends com.mopub.nativeads.CustomEventRewardedAd {}
+
+# Keep methods that are accessed via reflection
+-keepclassmembers class ** { @com.mopub.common.util.ReflectionTarget *; }
 
 # Support for Android Advertiser ID.
 -keep class com.google.android.gms.common.GooglePlayServicesUtil {*;}
 -keep class com.google.android.gms.ads.identifier.AdvertisingIdClient {*;}
 -keep class com.google.android.gms.ads.identifier.AdvertisingIdClient$Info {*;}
--dontwarn com.google.android.gms.**
 
-# Filter out warnings that refer to legacy Code.
--dontwarn org.apache.http.**
--dontwarn com.mopub.volley.toolbox.**
+# Support for Google Play Services
+# http://developer.android.com/google/play-services/setup.html
+-keep class * extends java.util.ListResourceBundle {
+    protected Object[][] getContents();
+}
+
+-keep public class com.google.android.gms.common.internal.safeparcel.SafeParcelable {
+    public static final *** NULL;
+}
+
+-keepnames @com.google.android.gms.common.annotation.KeepName class *
+-keepclassmembernames class * {
+    @com.google.android.gms.common.annotation.KeepName *;
+}
+
+-keepnames class * implements android.os.Parcelable {
+    public static final ** CREATOR;
+}
diff --git a/mopub-sdk/shared-build.gradle b/mopub-sdk/shared-build.gradle
index 21382d5d..443b27e2 100644
--- a/mopub-sdk/shared-build.gradle
+++ b/mopub-sdk/shared-build.gradle
@@ -9,7 +9,7 @@ repositories {
 }
 
 project.group = 'com.mopub'
-project.version = '4.12.0'
+project.version = '4.13.0'
 
 android {
     compileSdkVersion 23
@@ -18,7 +18,7 @@ android {
     useLibrary 'org.apache.http.legacy'
 
     defaultConfig {
-        versionCode 49
+        versionCode 50
         versionName version
         minSdkVersion 16
         targetSdkVersion 23
diff --git a/mopub-sdk/src/main/resources/fabric/com.mopub.sdk.android.mopub.properties b/mopub-sdk/src/main/resources/fabric/com.mopub.sdk.android.mopub.properties
index 4a3fb421..12bcf2e5 100644
--- a/mopub-sdk/src/main/resources/fabric/com.mopub.sdk.android.mopub.properties
+++ b/mopub-sdk/src/main/resources/fabric/com.mopub.sdk.android.mopub.properties
@@ -1,3 +1,3 @@
 fabric-identifier=com.mopub.sdk.android:mopub
-fabric-version=4.12.0+kit
+fabric-version=4.13.0+kit
 fabric-build-type=source
diff --git a/mopub-sdk/src/test/java/com/mopub/common/LocationServiceTest.java b/mopub-sdk/src/test/java/com/mopub/common/LocationServiceTest.java
index 70c7ec4b..498bac8b 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/LocationServiceTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/LocationServiceTest.java
@@ -4,10 +4,12 @@
 import android.content.Context;
 import android.location.Location;
 import android.location.LocationManager;
+import android.os.SystemClock;
 
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.mobileads.BuildConfig;
 
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -28,12 +30,15 @@
     private Activity activity;
     private Location networkLocation;
     private Location gpsLocation;
+    private Location cachedLocation;
     private ShadowLocationManager shadowLocationManager;
 
     @Before
     public void setUp() {
         activity = Robolectric.buildActivity(Activity.class).create().get();
 
+        LocationService.clearLastKnownLocation();
+
         networkLocation = new Location("networkLocation");
         networkLocation.setLatitude(3.1415926535);
         networkLocation.setLongitude(-27.18281828459);
@@ -46,12 +51,22 @@ public void setUp() {
         gpsLocation.setAccuracy(1000);
         gpsLocation.setTime(200);
 
+        cachedLocation = new Location("cachedLocation");
+        cachedLocation.setLatitude(37.776822);
+        cachedLocation.setLongitude(-122.416604);
+        cachedLocation.setAccuracy(25);
+
         shadowLocationManager = shadowOf(
                 (LocationManager) RuntimeEnvironment.application.getSystemService(Context.LOCATION_SERVICE));
         shadowLocationManager.setLastKnownLocation(LocationManager.NETWORK_PROVIDER, networkLocation);
         shadowLocationManager.setLastKnownLocation(LocationManager.GPS_PROVIDER, gpsLocation);
     }
 
+    @After
+    public void tearDown() {
+        LocationService.clearLastKnownLocation();
+    }
+
     @Test
     public void getLastKnownLocation_withFinePermission_shouldReturnMoreRecentLocation() {
         Shadows.shadowOf(activity).grantPermissions(ACCESS_FINE_LOCATION);
@@ -120,6 +135,36 @@ public void getLastKnownLocation_withLocationAwarenessDisabled_shouldReturnNull(
         assertThat(result).isNull();
     }
 
+    @Test
+    public void getLastKnownLocation_withFreshPreviousKnownLocation_shouldReturnPreviousKnownLocation() {
+        LocationService locationService = LocationService.getInstance();
+        locationService.mLastKnownLocation = cachedLocation;
+        // Setting the location updated time to be more recent than minimum location refresh time,
+        // in milliseconds.
+        locationService.mLocationLastUpdatedMillis = SystemClock.elapsedRealtime() -
+                MoPub.getMinimumLocationRefreshTimeMillis() / 2;
+
+        final Location result = LocationService.getLastKnownLocation(activity, 10,
+                MoPub.LocationAwareness.NORMAL);
+
+        assertThat(result).isEqualTo(cachedLocation);
+    }
+
+    @Test
+    public void getLastKnownLocation_withStalePreviousKnownLocation_shouldReturnNull() {
+        LocationService locationService = LocationService.getInstance();
+        locationService.mLastKnownLocation = cachedLocation;
+        // Setting the location updated time to be older than minimum location refresh time,
+        // in milliseconds.
+        locationService.mLocationLastUpdatedMillis = SystemClock.elapsedRealtime() -
+                MoPub.getMinimumLocationRefreshTimeMillis() * 2;
+
+        final Location result = LocationService.getLastKnownLocation(activity, 10,
+                MoPub.LocationAwareness.NORMAL);
+
+        assertThat(result).isNull();
+    }
+
     @Test
     public void getLocationFromProvider_withNetworkProvider_withCoarsePermission_shouldReturnNetworkLocation() {
         Shadows.shadowOf(activity).grantPermissions(ACCESS_COARSE_LOCATION);
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdViewControllerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdViewControllerTest.java
index 9728aa1b..2cd5ee27 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/AdViewControllerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/AdViewControllerTest.java
@@ -176,14 +176,14 @@ public void scheduleRefreshTimerIfEnabled_shouldCancelOldRefreshAndScheduleANewO
     }
 
     @Test
-    public void scheduleRefreshTimer_shouldNotScheduleRefreshIfAutorefreshIsOff() throws Exception {
+    public void scheduleRefreshTimer_shouldNotScheduleRefreshIfAutoRefreshIsOff() throws Exception {
         response = response.toBuilder().setRefreshTimeMilliseconds(30).build();
         subject.onAdLoadSuccess(response);
 
         ShadowLooper.pauseMainLooper();
         assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(1);
 
-        subject.forceSetAutorefreshEnabled(false);
+        subject.setShouldAllowAutoRefresh(false);
 
         subject.scheduleRefreshTimerIfEnabled();
 
@@ -206,42 +206,53 @@ public void scheduleRefreshTimer_whenAdViewControllerNotConfiguredByResponse_sho
     }
 
     @Test
-    public void forceSetAutoRefreshEnabled_shouldSetAutoRefreshSetting() throws Exception {
-        assertThat(subject.getAutorefreshEnabled()).isTrue();
+    public void setShouldAllowAutoRefresh_shouldSetCurrentAutoRefreshStatus() throws Exception {
+        assertThat(subject.getCurrentAutoRefreshStatus()).isTrue();
 
-        subject.forceSetAutorefreshEnabled(false);
-        assertThat(subject.getAutorefreshEnabled()).isFalse();
+        subject.setShouldAllowAutoRefresh(false);
+        assertThat(subject.getCurrentAutoRefreshStatus()).isFalse();
 
-        subject.forceSetAutorefreshEnabled(true);
-        assertThat(subject.getAutorefreshEnabled()).isTrue();
+        subject.setShouldAllowAutoRefresh(true);
+        assertThat(subject.getCurrentAutoRefreshStatus()).isTrue();
     }
 
     @Test
-    public void pauseRefresh_shouldDisableAutorefresh() throws Exception {
-        assertThat(subject.getAutorefreshEnabled()).isTrue();
+    public void pauseRefresh_shouldDisableAutoRefresh() throws Exception {
+        assertThat(subject.getCurrentAutoRefreshStatus()).isTrue();
 
         subject.pauseRefresh();
-        assertThat(subject.getAutorefreshEnabled()).isFalse();
+        assertThat(subject.getCurrentAutoRefreshStatus()).isFalse();
     }
 
     @Test
-    public void unpauseRefresh_afterUnpauseRefresh_shouldEnableRefresh() throws Exception {
+    public void resumeRefresh_afterPauseRefresh_shouldEnableRefresh() throws Exception {
         subject.pauseRefresh();
 
-        subject.unpauseRefresh();
-        assertThat(subject.getAutorefreshEnabled()).isTrue();
+        subject.resumeRefresh();
+        assertThat(subject.getCurrentAutoRefreshStatus()).isTrue();
     }
 
     @Test
-    public void pauseAndUnpauseRefresh_withRefreshForceDisabled_shouldAlwaysHaveRefreshFalse() throws Exception {
-        subject.forceSetAutorefreshEnabled(false);
-        assertThat(subject.getAutorefreshEnabled()).isFalse();
+    public void pauseAndResumeRefresh_withShouldAllowAutoRefreshFalse_shouldAlwaysHaveRefreshFalse() throws Exception {
+        subject.setShouldAllowAutoRefresh(false);
+        assertThat(subject.getCurrentAutoRefreshStatus()).isFalse();
 
         subject.pauseRefresh();
-        assertThat(subject.getAutorefreshEnabled()).isFalse();
+        assertThat(subject.getCurrentAutoRefreshStatus()).isFalse();
 
-        subject.unpauseRefresh();
-        assertThat(subject.getAutorefreshEnabled()).isFalse();
+        subject.resumeRefresh();
+        assertThat(subject.getCurrentAutoRefreshStatus()).isFalse();
+    }
+
+    @Test
+    public void multiplePausesBeforeResumeRefresh_shouldEnableAutoRefresh() {
+        assertThat(subject.getCurrentAutoRefreshStatus()).isTrue();
+
+        subject.pauseRefresh();
+        subject.pauseRefresh();
+        subject.resumeRefresh();
+
+        assertThat(subject.getCurrentAutoRefreshStatus()).isTrue();
     }
 
     @Test
@@ -250,7 +261,7 @@ public void enablingAutoRefresh_afterLoadAd_shouldScheduleNewRefreshTimer() thro
         final AdViewController adViewControllerSpy = spy(subject);
 
         adViewControllerSpy.loadAd();
-        adViewControllerSpy.forceSetAutorefreshEnabled(true);
+        adViewControllerSpy.setShouldAllowAutoRefresh(true);
         verify(adViewControllerSpy).scheduleRefreshTimerIfEnabled();
     }
 
@@ -258,7 +269,7 @@ public void enablingAutoRefresh_afterLoadAd_shouldScheduleNewRefreshTimer() thro
     public void enablingAutoRefresh_withoutCallingLoadAd_shouldNotScheduleNewRefreshTimer() throws Exception {
         final AdViewController adViewControllerSpy = spy(subject);
 
-        adViewControllerSpy.forceSetAutorefreshEnabled(true);
+        adViewControllerSpy.setShouldAllowAutoRefresh(true);
         verify(adViewControllerSpy, never()).scheduleRefreshTimerIfEnabled();
     }
 
@@ -269,10 +280,10 @@ public void disablingAutoRefresh_shouldCancelRefreshTimers() throws Exception {
         ShadowLooper.pauseMainLooper();
 
         subject.loadAd();
-        subject.forceSetAutorefreshEnabled(true);
+        subject.setShouldAllowAutoRefresh(true);
         assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(1);
 
-        subject.forceSetAutorefreshEnabled(false);
+        subject.setShouldAllowAutoRefresh(false);
         assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(0);
     }
 
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubRewardedVideoManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubRewardedVideoManagerTest.java
index 05b8c9fe..f0e94132 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubRewardedVideoManagerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubRewardedVideoManagerTest.java
@@ -51,14 +51,28 @@
         MoPubRewardedVideoManagerTest {
 
     public static final String MOPUB_REWARD = "mopub_reward";
+    public static final String REWARDED_CURRENCY_NAME = "Coins";
+    public static final String REWARDED_CURRENCY_AMOUNT_STR = "15";
+    public static final String SINGLE_REWARDED_CURRENCY_JSON =
+            "{\"rewards\": [ { \"name\": \"Coins\", \"amount\": 25 } ] }";
+    public static final String MULTI_REWARDED_CURRENCIES_JSON =
+            "{\n" +
+                    "  \"rewards\": [\n" +
+                    "    { \"name\": \"Coins\", \"amount\": 8 },\n" +
+                    "    { \"name\": \"Diamonds\", \"amount\": 1 },\n" +
+                    "    { \"name\": \"Diamonds\", \"amount\": 10 },\n" +
+                    "    { \"name\": \"Energy\", \"amount\": 20 }\n" +
+                    "  ]\n" +
+                    "}\n";
 
     @Mock
     MoPubRequestQueue mockRequestQueue;
     @Mock
     MoPubRewardedVideoListener mockVideoListener;
 
-    AdRequest.Listener requestListener;
+    private AdRequest.Listener requestListener;
     private AdRequest request;
+    private RewardedVideoCompletionRequest rewardedVideoCompletionRequest;
     private Activity mActivity;
 
     @Before
@@ -67,12 +81,22 @@ public void setup() {
         MoPubRewardedVideoManager.init(mActivity);
         MoPubRewardedVideoManager.setVideoListener(mockVideoListener);
 
-        when(mockRequestQueue.add(any(AdRequest.class))).then(new Answer<Object>() {
+        when(mockRequestQueue.add(any(Request.class))).then(new Answer<Object>() {
             @Override
             public Object answer(final InvocationOnMock invocationOnMock) throws Throwable {
-                request = ((AdRequest) invocationOnMock.getArguments()[0]);
-                requestListener = request.getListener();
-                return null;
+                Request req = ((Request) invocationOnMock.getArguments()[0]);
+                if (req.getClass().equals(AdRequest.class)) {
+                    request = (AdRequest) req;
+                    requestListener = request.getListener();
+                    return null;
+                } else if (req.getClass().equals(RewardedVideoCompletionRequest.class)) {
+                    rewardedVideoCompletionRequest = (RewardedVideoCompletionRequest) req;
+                    return null;
+                } else {
+                    throw new Exception(String.format("Request object added to RequestQueue can " +
+                            "only be of type AdRequest or RewardedVideoCompletionRequest, " +
+                            "saw %s instead.", req.getClass()));
+                }
             }
         });
 
@@ -163,7 +187,7 @@ public void callbackMethods_withNullListener_shouldNotError() {
                 TestCustomEvent.AD_NETWORK_ID,
                 MoPubReward.success("test", 111));
 
-        // The test passed because none of the above calls thew an exception even though the listener is null.
+        // The test passed because none of the above calls threw an exception even though the listener is null.
     }
 
     @Test
@@ -220,7 +244,7 @@ public void onAdSuccess_noCEFound_shouldLoadFailUrl() {
     }
 
     @Test
-    public void onAdSuccess_shouldInstantiateCustomEvent_andLoad() {
+    public void onAdSuccess_shouldInstantiateCustomEvent_shouldLoad() {
         AdResponse testResponse = new AdResponse.Builder()
                 .setCustomEventClassName(
                         "com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
@@ -241,6 +265,163 @@ public void onAdSuccess_shouldInstantiateCustomEvent_andLoad() {
         verifyNoMoreInteractions(mockVideoListener);
     }
 
+    @Test
+    public void onAdSuccess_withLegacyRewardedCurrencyHeaders_shouldMapAdUnitIdToReward_shouldLoad() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName(
+                        "com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .setRewardedVideoCurrencyName(REWARDED_CURRENCY_NAME)
+                .setRewardedVideoCurrencyAmount(REWARDED_CURRENCY_AMOUNT_STR)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+        requestListener.onSuccess(testResponse);
+
+        ShadowLooper.unPauseMainLooper();
+
+        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isTrue();
+        verify(mockVideoListener).onRewardedVideoLoadSuccess(eq("testAdUnit"));
+        verifyNoMoreInteractions(mockVideoListener);
+
+        // Verify that the reward is mapped to the adunit
+        RewardedAdData rewardedVideoData = MoPubRewardedVideoManager.getRewardedAdData();
+        assertThat(rewardedVideoData.getMoPubReward("testAdUnit")).isNotNull();
+        assertThat(rewardedVideoData.getMoPubReward("testAdUnit").getLabel()).isEqualTo(REWARDED_CURRENCY_NAME);
+        assertThat(rewardedVideoData.getMoPubReward("testAdUnit").getAmount()).isEqualTo(Integer.parseInt(REWARDED_CURRENCY_AMOUNT_STR));
+        assertThat(rewardedVideoData.getAvailableRewards("testAdUnit")).isEmpty();
+    }
+
+    @Test
+    public void onAdSuccess_withMultiRewardedCurrenciesJsonHeader_shouldMapAdUnitToAvailableRewards_shouldLoad() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName(
+                        "com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .setRewardedCurrencies(MULTI_REWARDED_CURRENCIES_JSON)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+        requestListener.onSuccess(testResponse);
+
+        ShadowLooper.unPauseMainLooper();
+
+        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isTrue();
+        verify(mockVideoListener).onRewardedVideoLoadSuccess(eq("testAdUnit"));
+        verifyNoMoreInteractions(mockVideoListener);
+
+        // Verify that only available rewards are updated, not the final reward mapped to the adunit
+        RewardedAdData rewardedVideoData = MoPubRewardedVideoManager.getRewardedAdData();
+        assertThat(rewardedVideoData.getMoPubReward("testAdUnit")).isNull();
+        assertThat(rewardedVideoData.getAvailableRewards("testAdUnit").size()).isEqualTo(4);
+        assertThat(rewardedVideoData.existsInAvailableRewards("testAdUnit", "Coins", 8)).isTrue();
+        assertThat(rewardedVideoData.existsInAvailableRewards("testAdUnit", "Diamonds", 1)).isTrue();
+        assertThat(rewardedVideoData.existsInAvailableRewards("testAdUnit", "Diamonds", 10)).isTrue();
+        assertThat(rewardedVideoData.existsInAvailableRewards("testAdUnit", "Energy", 20)).isTrue();
+    }
+
+    @Test
+    public void onAdSuccess_withSingleRewardedCurrencyJsonHeader_shouldMapAdUnitToRewardAndUpdateAvailableRewards_shouldLoad() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName(
+                        "com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .setRewardedCurrencies(SINGLE_REWARDED_CURRENCY_JSON)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+        requestListener.onSuccess(testResponse);
+
+        ShadowLooper.unPauseMainLooper();
+
+        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isTrue();
+        verify(mockVideoListener).onRewardedVideoLoadSuccess(eq("testAdUnit"));
+        verifyNoMoreInteractions(mockVideoListener);
+
+        // Verify that the single reward is mapped to the adunit, and it's the only available reward
+        RewardedAdData rewardedVideoData = MoPubRewardedVideoManager.getRewardedAdData();
+        assertThat(rewardedVideoData.getMoPubReward("testAdUnit")).isNotNull();
+        assertThat(rewardedVideoData.getMoPubReward("testAdUnit").getLabel()).isEqualTo("Coins");
+        assertThat(rewardedVideoData.getMoPubReward("testAdUnit").getAmount()).isEqualTo(25);
+        assertThat(rewardedVideoData.getAvailableRewards("testAdUnit").size()).isEqualTo(1);
+        assertThat(rewardedVideoData.existsInAvailableRewards("testAdUnit", "Coins", 25)).isTrue();
+    }
+
+    @Test
+    public void onAdSuccess_withBothLegacyAndJsonHeaders_shouldIgnoreLegacyHeaders_shouldLoad() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName(
+                        "com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .setRewardedVideoCurrencyName(REWARDED_CURRENCY_NAME)
+                .setRewardedVideoCurrencyAmount(REWARDED_CURRENCY_AMOUNT_STR)
+                .setRewardedCurrencies(MULTI_REWARDED_CURRENCIES_JSON)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+        requestListener.onSuccess(testResponse);
+
+        ShadowLooper.unPauseMainLooper();
+
+        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isTrue();
+        verify(mockVideoListener).onRewardedVideoLoadSuccess(eq("testAdUnit"));
+        verifyNoMoreInteractions(mockVideoListener);
+
+        // Verify that the legacy headers are ignored, and available rewards are updated from the JSON header
+        RewardedAdData rewardedVideoData = MoPubRewardedVideoManager.getRewardedAdData();
+        assertThat(rewardedVideoData.getMoPubReward("testAdUnit")).isNull();
+        assertThat(rewardedVideoData.getAvailableRewards("testAdUnit").size()).isEqualTo(4);
+        assertThat(rewardedVideoData.existsInAvailableRewards("testAdUnit", "Coins", 8)).isTrue();
+        assertThat(rewardedVideoData.existsInAvailableRewards("testAdUnit", "Diamonds", 1)).isTrue();
+        assertThat(rewardedVideoData.existsInAvailableRewards("testAdUnit", "Diamonds", 10)).isTrue();
+        assertThat(rewardedVideoData.existsInAvailableRewards("testAdUnit", "Energy", 20)).isTrue();
+    }
+
+    @Test
+    public void onAdSuccess_withMalformedRewardedCurrenciesJsonHeader_shouldNotUpdateRewardMappings_andNotLoad() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName(
+                        "com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .setRewardedCurrencies("not json")
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+        requestListener.onSuccess(testResponse);
+
+        ShadowLooper.unPauseMainLooper();
+
+        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isFalse();
+        verify(mockVideoListener).onRewardedVideoLoadFailure(eq("testAdUnit"),
+                eq(MoPubErrorCode.REWARDED_CURRENCIES_PARSING_ERROR));
+        verifyNoMoreInteractions(mockVideoListener);
+
+        // Verify that no reward mappings are updated
+        RewardedAdData rewardedVideoData = MoPubRewardedVideoManager.getRewardedAdData();
+        assertThat(rewardedVideoData.getMoPubReward("testAdUnit")).isNull();
+        assertThat(rewardedVideoData.getAvailableRewards("testAdUnit").isEmpty());
+    }
+
     @Test
     public void loadVideo_withCustomEventAlreadyLoaded_shouldNotLoadAnotherVideo() throws Exception {
         final CustomEventRewardedVideo mockCustomEvent = mock(CustomEventRewardedVideo.class);
@@ -353,7 +534,7 @@ public void onAdSuccess_shouldUpdateAdUnitRewardMapping() throws Exception {
         assertThat(moPubReward.getAmount()).isEqualTo(123);
         assertThat(moPubReward.getLabel()).isEqualTo("currency_name");
     }
-
+    
     @Test
     public void playVideo_shouldSetHasVideoFalse() {
         AdResponse testResponse = new AdResponse.Builder()
@@ -401,7 +582,170 @@ public void playVideo_whenNotHasVideo_shouldFail() {
     }
 
     @Test
-    public void playVideo_shouldUpdateLastShownCustomEventRewardMapping() throws Exception {
+    public void playVideo_withMultiRewardedCurrenciesJsonHeader_whenRewardNotSelected_shouldFail() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName("com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .setRewardedCurrencies(MULTI_REWARDED_CURRENCIES_JSON)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+        requestListener.onSuccess(testResponse);
+
+        ShadowLooper.unPauseMainLooper();
+
+        // Multiple rewards are available, but a reward is not selected before showing video
+        MoPubRewardedVideoManager.showVideo("testAdUnit");
+        verify(mockVideoListener).onRewardedVideoLoadFailure(eq("testAdUnit"), eq(MoPubErrorCode.REWARD_NOT_SELECTED));
+    }
+
+    @Test
+    public void playVideo_withMultiRewardedCurrenciesJsonHeader_whenValidRewardIsSelected_shouldUpdateRewardMappings() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName("com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .setRewardedCurrencies(MULTI_REWARDED_CURRENCIES_JSON)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+        requestListener.onSuccess(testResponse);
+
+        Set<MoPubReward> availableRewards = MoPubRewardedVideoManager.getAvailableRewards("testAdUnit");
+        assertThat(availableRewards.size()).isEqualTo(4);
+
+        // Select the 10 Diamonds reward
+        for (MoPubReward reward : availableRewards) {
+            if (reward.getLabel().equals("Diamonds") && reward.getAmount() == 10) {
+                MoPubRewardedVideoManager.selectReward("testAdUnit", reward);
+                break;
+            }
+        }
+
+        // AdUnit to MoPubReward mapping
+        RewardedAdData rewardedVideoData = MoPubRewardedVideoManager.getRewardedAdData();
+        MoPubReward moPubReward = rewardedVideoData.getMoPubReward("testAdUnit");
+        assertThat(moPubReward.getLabel()).isEqualTo("Diamonds");
+        assertThat(moPubReward.getAmount()).isEqualTo(10);
+
+        ShadowLooper.unPauseMainLooper();
+
+        MoPubRewardedVideoManager.showVideo("testAdUnit");
+
+        // CustomEventRewardedAd class to MoPubReward mapping
+        moPubReward = rewardedVideoData.getLastShownMoPubReward(TestCustomEvent.class);
+        assertThat(moPubReward.getLabel()).isEqualTo("Diamonds");
+        assertThat(moPubReward.getAmount()).isEqualTo(10);
+    }
+
+    @Test
+    public void playVideo_withMultiRewardedCurrenciesJsonHeader_whenSelectRewardWithWrongAdUnit_shouldFail() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName("com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .setRewardedCurrencies(MULTI_REWARDED_CURRENCIES_JSON)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+        requestListener.onSuccess(testResponse);
+
+        Set<MoPubReward> availableRewards = MoPubRewardedVideoManager.getAvailableRewards("testAdUnit");
+        assertThat(availableRewards.size()).isEqualTo(4);
+
+        // Select the 10 Diamonds reward, but to a wrong AdUnit
+        for (MoPubReward reward : availableRewards) {
+            if (reward.getLabel().equals("Diamonds") && reward.getAmount() == 10) {
+                MoPubRewardedVideoManager.selectReward("wrongAdUnit", reward);
+                break;
+            }
+        }
+
+        // No selected reward is mapped to AdUnit
+        assertThat(MoPubRewardedVideoManager.getRewardedAdData().getMoPubReward("testAdUnit")).isNull();
+
+        ShadowLooper.unPauseMainLooper();
+
+        MoPubRewardedVideoManager.showVideo("testAdUnit");
+        verify(mockVideoListener).onRewardedVideoLoadFailure(eq("testAdUnit"), eq(MoPubErrorCode.REWARD_NOT_SELECTED));
+    }
+
+    @Test
+    public void playVideo_withMultiRewardedCurrenciesJsonHeader_whenSelectedRewardIsNotAvailable_shouldFail() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName("com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .setRewardedCurrencies(MULTI_REWARDED_CURRENCIES_JSON)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+        requestListener.onSuccess(testResponse);
+
+        Set<MoPubReward> availableRewards = MoPubRewardedVideoManager.getAvailableRewards("testAdUnit");
+        assertThat(availableRewards.size()).isEqualTo(4);
+
+        // Select a reward that's not in the returned set of available rewards
+        MoPubRewardedVideoManager.selectReward("testAdUnit", MoPubReward.success("fake reward", 99));
+
+        // No selected reward is mapped to AdUnit
+        assertThat(MoPubRewardedVideoManager.getRewardedAdData().getMoPubReward("testAdUnit")).isNull();
+
+        ShadowLooper.unPauseMainLooper();
+
+        MoPubRewardedVideoManager.showVideo("testAdUnit");
+        verify(mockVideoListener).onRewardedVideoLoadFailure(eq("testAdUnit"), eq(MoPubErrorCode.REWARD_NOT_SELECTED));
+    }
+
+    @Test
+    public void playVideo_withSingleRewardedCurrencyJsonHeader_whenRewardNotSelected_shouldSelectOnlyRewardAutomatically() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName("com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .setRewardedCurrencies(SINGLE_REWARDED_CURRENCY_JSON)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
+        requestListener.onSuccess(testResponse);
+
+        // There's only one reward in the set of available rewards for this AdUnit
+        assertThat(MoPubRewardedVideoManager.getAvailableRewards("testAdUnit").size()).isEqualTo(1);
+
+        // The only reward is automatically mapped to this AdUnit
+        RewardedAdData rewardedVideoData = MoPubRewardedVideoManager.getRewardedAdData();
+        MoPubReward moPubReward = rewardedVideoData.getMoPubReward("testAdUnit");
+        assertThat(moPubReward.getLabel()).isEqualTo("Coins");
+        assertThat(moPubReward.getAmount()).isEqualTo(25);
+
+        ShadowLooper.unPauseMainLooper();
+
+        MoPubRewardedVideoManager.showVideo("testAdUnit");
+
+        // CustomEventRewardedAd class to MoPubReward mapping
+        moPubReward = rewardedVideoData.getLastShownMoPubReward(TestCustomEvent.class);
+        assertThat(moPubReward.getLabel()).isEqualTo("Coins");
+        assertThat(moPubReward.getAmount()).isEqualTo(25);
+    }
+
+    @Test
+    public void playVideo_withLegacyRewardedCurrencyHeaders_shouldUpdateLastShownCustomEventRewardMapping() throws Exception {
         AdResponse testResponse = new AdResponse.Builder()
                 .setCustomEventClassName(
                         "com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
@@ -510,6 +854,52 @@ public void onRewardedVideoCompleted_withEmptyServerCompletionUrl_withNoCurrentl
                 "testAdUnit3");
     }
 
+    @Test
+    public void onRewardedVideoCompleted_withServerCompletionUrl_shouldMakeRewardedVideoCompletionRequest() {
+        MoPubReward moPubReward = MoPubReward.success(MOPUB_REWARD, 123);
+        RewardedAdData rewardedVideoData = MoPubRewardedVideoManager.getRewardedAdData();
+        rewardedVideoData.setCurrentlyShowingAdUnitId("testAdUnit1");
+
+        // Set server-side reward, different from moPubReward, and corresponding server completion URL
+        rewardedVideoData.updateAdUnitRewardMapping("testAdUnit1", "server-side currency", "777");
+        rewardedVideoData.updateAdUnitToServerCompletionUrlMapping("testAdUnit1", "testUrl");
+
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.onRewardedVideoCompleted(TestCustomEvent.class, TestCustomEvent.AD_NETWORK_ID,
+                moPubReward);
+
+        ShadowLooper.unPauseMainLooper();
+
+        verify(mockRequestQueue).add(any(RewardedVideoCompletionRequest.class));
+        assertThat(rewardedVideoCompletionRequest.getUrl()).contains("testUrl");
+        assertThat(rewardedVideoCompletionRequest.getUrl()).contains("&rcn=server-side%20currency");
+        assertThat(rewardedVideoCompletionRequest.getUrl()).contains("&rca=777");
+    }
+
+    @Test
+    public void onRewardedVideoCompleted_withServerCompletionUrl_withNullRewardForCurrentlyShowingAdUnitId_shouldMakeRewardedVideoCompletionRequestWithDefaultRewardValues() {
+        MoPubReward moPubReward = MoPubReward.success(MOPUB_REWARD, 123);
+        RewardedAdData rewardedVideoData = MoPubRewardedVideoManager.getRewardedAdData();
+        rewardedVideoData.setCurrentlyShowingAdUnitId("testAdUnit1");
+
+        // Set reward fields to nulls
+        rewardedVideoData.updateAdUnitRewardMapping("testAdUnit1", null, null);
+        rewardedVideoData.updateAdUnitToServerCompletionUrlMapping("testAdUnit1", "testUrl");
+
+        ShadowLooper.pauseMainLooper();
+
+        MoPubRewardedVideoManager.onRewardedVideoCompleted(TestCustomEvent.class, TestCustomEvent.AD_NETWORK_ID,
+                moPubReward);
+
+        ShadowLooper.unPauseMainLooper();
+
+        verify(mockRequestQueue).add(any(RewardedVideoCompletionRequest.class));
+        assertThat(rewardedVideoCompletionRequest.getUrl()).contains("testUrl");
+        // Default reward values
+        assertThat(rewardedVideoCompletionRequest.getUrl()).contains("&rcn=&rca=0");
+    }
+
     public static class TestCustomEvent extends CustomEventRewardedVideo {
         public static final String AD_NETWORK_ID = "id!";
 
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubViewTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubViewTest.java
index 0b440d17..58aba1f1 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubViewTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubViewTest.java
@@ -57,7 +57,7 @@ public void tearDown() {
     public void screenStateBroadcastReceiver_withActionUserPresent_shouldUnpauseRefresh() throws Exception {
         broadcastIntent(new Intent(Intent.ACTION_USER_PRESENT));
 
-        verify(adViewController).unpauseRefresh();
+        verify(adViewController).resumeRefresh();
     }
 
     @Test
@@ -72,7 +72,7 @@ public void screenStateBroadcastReceiver_withNullIntent_shouldDoNothing() throws
         broadcastIntent(null);
 
         verify(adViewController, never()).pauseRefresh();
-        verify(adViewController, never()).unpauseRefresh();
+        verify(adViewController, never()).resumeRefresh();
     }
 
     @Test
@@ -80,7 +80,7 @@ public void screenStateBroadcastReceiver_withRandomIntent_shouldDoNothing() thro
         broadcastIntent(new Intent(Intent.ACTION_BATTERY_LOW));
 
         verify(adViewController, never()).pauseRefresh();
-        verify(adViewController, never()).unpauseRefresh();
+        verify(adViewController, never()).resumeRefresh();
     }
 
     @Test
@@ -89,7 +89,7 @@ public void screenStateBroadcastReceiver_whenAdInBackground_shouldDoNothing() th
         reset(adViewController);
 
         broadcastIntent(new Intent(Intent.ACTION_USER_PRESENT));
-        verify(adViewController, never()).unpauseRefresh();
+        verify(adViewController, never()).resumeRefresh();
 
         broadcastIntent(new Intent(Intent.ACTION_SCREEN_OFF));
         verify(adViewController, never()).pauseRefresh();
@@ -100,7 +100,7 @@ public void screenStateBroadcastReceiver_afterOnDestroy_shouldDoNothing() throws
         subject.destroy();
 
         broadcastIntent(new Intent(Intent.ACTION_USER_PRESENT));
-        verify(adViewController, never()).unpauseRefresh();
+        verify(adViewController, never()).resumeRefresh();
 
         broadcastIntent(new Intent(Intent.ACTION_SCREEN_OFF));
         verify(adViewController, never()).pauseRefresh();
@@ -112,7 +112,7 @@ public void onWindowVisibilityChanged_fromVisibleToInvisible_shouldPauseRefresh(
         subject.onWindowVisibilityChanged(View.INVISIBLE);
 
         verify(adViewController).pauseRefresh();
-        verify(adViewController, never()).unpauseRefresh();
+        verify(adViewController, never()).resumeRefresh();
     }
 
 
@@ -124,7 +124,7 @@ public void onWindowVisibilityChanged_fromInvisibleToVisible_shouldUnpauseRefres
         subject.onWindowVisibilityChanged(View.VISIBLE);
 
         verify(adViewController, never()).pauseRefresh();
-        verify(adViewController).unpauseRefresh();
+        verify(adViewController).resumeRefresh();
     }
 
     @Test
@@ -133,7 +133,7 @@ public void onWindowVisibilityChanged_fromVisibleToVisible_shouldDoNothing() thr
         subject.onWindowVisibilityChanged(View.VISIBLE);
 
         verify(adViewController, never()).pauseRefresh();
-        verify(adViewController, never()).unpauseRefresh();
+        verify(adViewController, never()).resumeRefresh();
     }
 
     @Test
@@ -144,7 +144,7 @@ public void onWindowVisibilityChanged_fromInvisibleToGone_shouldDoNothing() thro
         subject.onWindowVisibilityChanged(View.GONE);
 
         verify(adViewController, never()).pauseRefresh();
-        verify(adViewController, never()).unpauseRefresh();
+        verify(adViewController, never()).resumeRefresh();
     }
 
     @Test
@@ -155,21 +155,21 @@ public void onWindowVisibilityChanged_fromGoneToInvisible_shouldDoNothing() thro
         subject.onWindowVisibilityChanged(View.INVISIBLE);
 
         verify(adViewController, never()).pauseRefresh();
-        verify(adViewController, never()).unpauseRefresh();
+        verify(adViewController, never()).resumeRefresh();
     }
 
     @Test
     public void setAutorefreshEnabled_withRefreshTrue_shouldForwardToAdViewController() throws Exception {
         subject.setAutorefreshEnabled(true);
 
-        verify(adViewController).forceSetAutorefreshEnabled(true);
+        verify(adViewController).setShouldAllowAutoRefresh(true);
     }
 
     @Test
     public void setAutorefreshEnabled_withRefreshFalse_shouldForwardToAdViewController() throws Exception {
         subject.setAutorefreshEnabled(false);
 
-        verify(adViewController).forceSetAutorefreshEnabled(false);
+        verify(adViewController).setShouldAllowAutoRefresh(false);
     }
     
     @Test
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/RewardedAdDataTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/RewardedAdDataTest.java
index be5dfd6f..2fb332c2 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/RewardedAdDataTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/RewardedAdDataTest.java
@@ -8,6 +8,8 @@
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
 
+import java.util.Set;
+
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(SdkTestRunner.class)
@@ -70,4 +72,134 @@ public void updateAdUnitRewardMapping_withCurrencyAmountLessThanZero_shouldNotMa
         subject.updateAdUnitRewardMapping("mopub_id", "currency_name", "-1");
         assertThat(subject.getMoPubReward("mopub_id")).isNull();
     }
+
+    @Test
+    public void addAvailableReward_shouldAddRewardToSetOfAvailableRewards() throws Exception {
+        subject.addAvailableReward("mopub_id", "currency1", "123");
+        Set<MoPubReward> availableRewards = subject.getAvailableRewards("mopub_id");
+        assertThat(availableRewards.size()).isEqualTo(1);
+        assertThat(subject.existsInAvailableRewards("mopub_id", "currency1", 123)).isTrue();
+
+        // add another reward for the same adunit
+        subject.addAvailableReward("mopub_id", "currency2", "321");
+        assertThat(availableRewards.size()).isEqualTo(2);
+        assertThat(subject.existsInAvailableRewards("mopub_id", "currency1", 123)).isTrue();
+        assertThat(subject.existsInAvailableRewards("mopub_id", "currency2", 321)).isTrue();
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void addAvailableReward_withNullAdUnitId_shouldThrowNPE() throws Exception {
+        subject.addAvailableReward(null, "currency_name", "123");
+    }
+
+    @Test
+    public void addAvailableReward_withNullCurrencyName_shouldNotAddRewardToSetOfAvailableRewards() throws Exception {
+        subject.addAvailableReward("mopub_id", null, "123");
+        assertThat(subject.getAvailableRewards("mopub_id")).isEmpty();
+    }
+
+    @Test
+    public void addAvailableReward_withNullCurrencyAmount_shouldNotAddRewardToSetOfAvailableRewards() throws Exception {
+        subject.addAvailableReward("mopub_id", "currency_name", null);
+        assertThat(subject.getAvailableRewards("mopub_id")).isEmpty();
+    }
+
+    @Test
+    public void addAvailableReward_withNonNumberCurrencyAmount_shouldNotAddRewardToSetOfAvailableRewards() throws Exception {
+        subject.addAvailableReward("mopub_id", "currency_name", "abc");
+        assertThat(subject.getAvailableRewards("mopub_id")).isEmpty();
+    }
+
+    @Test
+    public void addAvailableReward_withCurrencyAmountLessThanZero_shouldNotAddRewardToSetOfAvailableRewards() throws Exception {
+        subject.addAvailableReward("mopub_id", "currency_name", "-1");
+        assertThat(subject.getAvailableRewards("mopub_id")).isEmpty();
+    }
+
+    @Test
+    public void getAvailableRewards_shouldReturnSetOfAvailableRewards() throws Exception {
+        subject.addAvailableReward("mopub_id_A", "currency1", "123");
+        subject.addAvailableReward("mopub_id_A", "currency2", "321");
+        subject.addAvailableReward("mopub_id_B", "currency3", "456");
+
+        assertThat(subject.getAvailableRewards("mopub_id_A").size()).isEqualTo(2);
+        assertThat(subject.getAvailableRewards("mopub_id_B").size()).isEqualTo(1);
+
+        assertThat(subject.existsInAvailableRewards("mopub_id_A", "currency1", 123)).isTrue();
+        assertThat(subject.existsInAvailableRewards("mopub_id_A", "currency1", 123)).isTrue();
+        assertThat(subject.existsInAvailableRewards("mopub_id_B", "currency3", 456)).isTrue();
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void getAvailableRewards_withNullAdUnitId_shouldThrowNPE() throws Exception {
+        subject.addAvailableReward("mopub_id", "currency_name", "123");
+        subject.getAvailableRewards(null);
+    }
+
+    @Test
+    public void getAvailableRewards_whenAdUnitDoesNotHaveAvailableRewards_shouldReturnEmptySet() throws Exception {
+        subject.addAvailableReward("mopub_id", "currency_name", "123");
+        assertThat(subject.getAvailableRewards("foo_id")).isEmpty();
+    }
+
+    @Test
+    public void selectReward_shouldMapAdUnitIdToReward() throws Exception {
+        subject.addAvailableReward("mopub_id", "currency1", "123");
+        subject.addAvailableReward("mopub_id", "currency2", "321");
+
+        // Select the currency2 reward
+        for (MoPubReward reward : subject.getAvailableRewards("mopub_id")) {
+            if (reward.getLabel().equals("currency2") && reward.getAmount() == 321) {
+                subject.selectReward("mopub_id", reward);
+                break;
+            }
+        }
+
+        MoPubReward selectedReward = subject.getMoPubReward("mopub_id");
+        assertThat(selectedReward.getLabel()).isEqualTo("currency2");
+        assertThat(selectedReward.getAmount()).isEqualTo(321);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void selectReward_withNullAdUnitId_shouldThrowNPE() throws Exception {
+        subject.selectReward(null, MoPubReward.success("currency_name", 123));
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void selectReward_withNullSelectedReward_shouldThrowNPE() throws Exception {
+        subject.selectReward("mopub_id", null);
+    }
+
+    @Test
+    public void selectReward_whenAdUnitDoesNotHaveAvailableRewards_shouldNotSelectReward() throws Exception {
+        subject.addAvailableReward("mopub_id", "currency1", "123");
+        MoPubReward reward = subject.getAvailableRewards("mopub_id").toArray(new MoPubReward[1])[0];
+        subject.selectReward("foo_id", reward);
+
+        assertThat(subject.getMoPubReward("mopub_id")).isNull();
+        assertThat(subject.getMoPubReward("foo_id")).isNull();
+    }
+
+    @Test
+    public void selectReward_whenSelectedRewardNotAmongAvailableRewards_shouldNotSelectReward() throws Exception {
+        subject.addAvailableReward("mopub_id", "currency1", "123");
+        subject.selectReward("mopub_id", MoPubReward.success("currency2", 321));
+
+        assertThat(subject.getMoPubReward("mopub_id")).isNull();
+    }
+
+    @Test
+    public void resetAvailableRewards_shouldClearAvailableRewardsMap() {
+        subject.addAvailableReward("mopub_id", "currency1", "123");
+        subject.addAvailableReward("mopub_id", "currency2", "321");
+        assertThat(subject.getAvailableRewards("mopub_id").size()).isEqualTo(2);
+
+        subject.resetAvailableRewards("mopub_id");
+        assertThat(subject.getAvailableRewards("mopub_id")).isEmpty();
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void resetAvailableRewards_withNullAdUnitId_shouldThrowNPE() throws Exception {
+        subject.resetAvailableRewards(null);
+    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/RewardedVideoCompletionRequestHandlerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/RewardedVideoCompletionRequestHandlerTest.java
index d73f8bd8..ae2873c5 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/RewardedVideoCompletionRequestHandlerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/RewardedVideoCompletionRequestHandlerTest.java
@@ -35,23 +35,64 @@
     private MoPubRequestQueue mockRequestQueue;
     private Context context;
     private String url;
+    private String customerId;
+    private String rewardName;
+    private String rewardAmount;
 
     @Before
     public void setup() {
         context = Robolectric.buildActivity(Activity.class).create().get();
         url = "testUrl";
+        customerId = "customer id";
+        rewardName = "gold coins";
+        rewardAmount = "25";
         Networking.setRequestQueueForTesting(mockRequestQueue);
     }
 
     @Test
     public void makeRewardedVideoCompletionRequest_shouldAddMacros_shouldMakeVideoCompletionRequest() throws Exception {
         RewardedVideoCompletionRequestHandler.makeRewardedVideoCompletionRequest(context, url,
-                "customer id");
+                customerId, rewardName, rewardAmount);
 
         verify(mockRequestQueue).add(argThat(isUrl(
-                "testUrl&customer_id=customer%20id&nv=" +
-                        Uri.encode(MoPub.SDK_VERSION) + "&v=" +
-                        MoPubRewardedVideoManager.API_VERSION)));
+                "testUrl&customer_id=customer%20id&rcn=gold%20coins&rca=25"
+                        + "&nv=" + Uri.encode(MoPub.SDK_VERSION)
+                        + "&v=" + MoPubRewardedVideoManager.API_VERSION)));
+    }
+
+    @Test
+    public void makeRewardedVideoCompletionRequest_withNullContext_shouldNotMakeVideoCompletionRequest() throws Exception {
+        RewardedVideoCompletionRequestHandler.makeRewardedVideoCompletionRequest(null, url,
+                customerId, rewardName, rewardAmount);
+        verifyZeroInteractions(mockRequestQueue);
+    }
+
+    @Test
+    public void makeRewardedVideoCompletionRequest_withNullUrl_shouldNotMakeVideoCompletionRequest() throws Exception {
+        RewardedVideoCompletionRequestHandler.makeRewardedVideoCompletionRequest(context, null,
+                customerId, rewardName, rewardAmount);
+        verifyZeroInteractions(mockRequestQueue);
+    }
+
+    @Test
+    public void makeRewardedVideoCompletionRequest_withEmptyUrl_shouldNotMakeVideoCompletionRequest() throws Exception {
+        RewardedVideoCompletionRequestHandler.makeRewardedVideoCompletionRequest(context, "",
+                customerId, rewardName, rewardAmount);
+        verifyZeroInteractions(mockRequestQueue);
+    }
+
+    @Test
+    public void makeRewardedVideoCompletionRequest_withNullRewardName_shouldNotMakeVideoCompletionRequest() throws Exception {
+        RewardedVideoCompletionRequestHandler.makeRewardedVideoCompletionRequest(context, url,
+                customerId, null, rewardAmount);
+        verifyZeroInteractions(mockRequestQueue);
+    }
+
+    @Test
+    public void makeRewardedVideoCompletionRequest_withNullRewardAmount_shouldNotMakeVideoCompletionRequest() throws Exception {
+        RewardedVideoCompletionRequestHandler.makeRewardedVideoCompletionRequest(context, url,
+                customerId, rewardName, null);
+        verifyZeroInteractions(mockRequestQueue);
     }
 
     @Test
@@ -82,30 +123,30 @@ public void retryTimes_shouldAllBeGreaterThanRequestTimeoutDelay() {
     @Test
     public void onErrorResponse_shouldSetShouldStopToTrueWhenResponseNot500To599() {
         RewardedVideoCompletionRequestHandler subject =
-                new RewardedVideoCompletionRequestHandler(context, "url", "customer_id");
+                new RewardedVideoCompletionRequestHandler(context, url, customerId, rewardName, rewardAmount);
 
         assertThat(subject.getShouldStop()).isEqualTo(false);
 
         subject.onErrorResponse(new VolleyError(new NetworkResponse(500, null, null, true)));
         assertThat(subject.getShouldStop()).isEqualTo(false);
 
-        subject = new RewardedVideoCompletionRequestHandler(context, "url", "customer_id");
+        subject = new RewardedVideoCompletionRequestHandler(context, url, customerId, rewardName, rewardAmount);
         subject.onErrorResponse(new VolleyError(new NetworkResponse(501, null, null, true)));
         assertThat(subject.getShouldStop()).isEqualTo(false);
 
-        subject = new RewardedVideoCompletionRequestHandler(context, "url", "customer_id");
+        subject = new RewardedVideoCompletionRequestHandler(context, url, customerId, rewardName, rewardAmount);
         subject.onErrorResponse(new VolleyError(new NetworkResponse(599, null, null, true)));
         assertThat(subject.getShouldStop()).isEqualTo(false);
 
-        subject = new RewardedVideoCompletionRequestHandler(context, "url", "customer_id");
+        subject = new RewardedVideoCompletionRequestHandler(context, url, customerId, rewardName, rewardAmount);
         subject.onErrorResponse(new VolleyError(new NetworkResponse(200, null, null, true)));
         assertThat(subject.getShouldStop()).isEqualTo(true);
 
-        subject = new RewardedVideoCompletionRequestHandler(context, "url", "customer_id");
+        subject = new RewardedVideoCompletionRequestHandler(context, url, customerId, rewardName, rewardAmount);
         subject.onErrorResponse(new VolleyError(new NetworkResponse(499, null, null, true)));
         assertThat(subject.getShouldStop()).isEqualTo(true);
 
-        subject = new RewardedVideoCompletionRequestHandler(context, "url", "customer_id");
+        subject = new RewardedVideoCompletionRequestHandler(context, url, customerId, rewardName, rewardAmount);
         subject.onErrorResponse(new VolleyError(new NetworkResponse(600, null, null, true)));
         assertThat(subject.getShouldStop()).isEqualTo(true);
     }
@@ -113,30 +154,30 @@ public void onErrorResponse_shouldSetShouldStopToTrueWhenResponseNot500To599() {
     @Test
     public void onResponse_shouldSetShouldStopToTrueWhenResponseNot500To599() {
         RewardedVideoCompletionRequestHandler subject =
-                new RewardedVideoCompletionRequestHandler(context, "url", "customer_id");
+                new RewardedVideoCompletionRequestHandler(context, url, customerId, rewardName, rewardAmount);
 
         assertThat(subject.getShouldStop()).isEqualTo(false);
 
         subject.onResponse(500);
         assertThat(subject.getShouldStop()).isEqualTo(false);
 
-        subject = new RewardedVideoCompletionRequestHandler(context, "url", "customer_id");
+        subject = new RewardedVideoCompletionRequestHandler(context, url, customerId, rewardName, rewardAmount);
         subject.onResponse(501);
         assertThat(subject.getShouldStop()).isEqualTo(false);
 
-        subject = new RewardedVideoCompletionRequestHandler(context, "url", "customer_id");
+        subject = new RewardedVideoCompletionRequestHandler(context, url, customerId, rewardName, rewardAmount);
         subject.onResponse(599);
         assertThat(subject.getShouldStop()).isEqualTo(false);
 
-        subject = new RewardedVideoCompletionRequestHandler(context, "url", "customer_id");
+        subject = new RewardedVideoCompletionRequestHandler(context, url, customerId, rewardName, rewardAmount);
         subject.onResponse(200);
         assertThat(subject.getShouldStop()).isEqualTo(true);
 
-        subject = new RewardedVideoCompletionRequestHandler(context, "url", "customer_id");
+        subject = new RewardedVideoCompletionRequestHandler(context, url, customerId, rewardName, rewardAmount);
         subject.onResponse(499);
         assertThat(subject.getShouldStop()).isEqualTo(true);
 
-        subject = new RewardedVideoCompletionRequestHandler(context, "url", "customer_id");
+        subject = new RewardedVideoCompletionRequestHandler(context, url, customerId, rewardName, rewardAmount);
         subject.onResponse(600);
         assertThat(subject.getShouldStop()).isEqualTo(true);
     }
@@ -145,8 +186,7 @@ public void onResponse_shouldSetShouldStopToTrueWhenResponseNot500To599() {
     public void makeRewardedVideoCompletionRequest_shouldRetry() {
         Handler mockHandler = mock(Handler.class);
         RewardedVideoCompletionRequestHandler subject =
-                new RewardedVideoCompletionRequestHandler(context, "url", "customer_id",
-                        mockHandler);
+                new RewardedVideoCompletionRequestHandler(context, url, customerId, rewardName, rewardAmount, mockHandler);
 
         subject.makeRewardedVideoCompletionRequest();
 
@@ -159,8 +199,7 @@ public void makeRewardedVideoCompletionRequest_shouldRetry() {
     public void makeRewardedVideoCompletionRequest_shouldNotRetryIfShouldStopIsSetToTrue() {
         Handler mockHandler = mock(Handler.class);
         RewardedVideoCompletionRequestHandler subject =
-                new RewardedVideoCompletionRequestHandler(context, "url", "customer_id",
-                        mockHandler);
+                new RewardedVideoCompletionRequestHandler(context, url, customerId, rewardName, rewardAmount, mockHandler);
         // This should set shouldStop to true.
         subject.onResponse(200);
 
@@ -174,8 +213,7 @@ public void makeRewardedVideoCompletionRequest_shouldNotRetryIfShouldStopIsSetTo
     public void makeRewardedVideoCompletionRequest_shouldNotRetryIfMaxRetriesReached() {
         Handler mockHandler = mock(Handler.class);
         RewardedVideoCompletionRequestHandler subject =
-                new RewardedVideoCompletionRequestHandler(context, "url", "customer_id",
-                        mockHandler);
+                new RewardedVideoCompletionRequestHandler(context, url, customerId, rewardName, rewardAmount, mockHandler);
         subject.setRetryCount(RewardedVideoCompletionRequestHandler.MAX_RETRIES);
 
         subject.makeRewardedVideoCompletionRequest();
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/WebViewAdUrlGeneratorTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/WebViewAdUrlGeneratorTest.java
index af013817..dd316ae0 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/WebViewAdUrlGeneratorTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/WebViewAdUrlGeneratorTest.java
@@ -21,6 +21,7 @@
 import com.mopub.common.ClientMetadata;
 import com.mopub.common.GpsHelper;
 import com.mopub.common.GpsHelperTest;
+import com.mopub.common.LocationService;
 import com.mopub.common.MoPub;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.common.util.Reflection.MethodBuilder;
@@ -127,6 +128,8 @@ public Object answer(final InvocationOnMock invocationOnMock) throws Throwable {
         shadowTelephonyManager = (MoPubShadowTelephonyManager) Shadows.shadowOf((TelephonyManager) RuntimeEnvironment.application.getSystemService(Context.TELEPHONY_SERVICE));
         shadowConnectivityManager = Shadows.shadowOf((ConnectivityManager) RuntimeEnvironment.application.getSystemService(Context.CONNECTIVITY_SERVICE));
         methodBuilder = TestMethodBuilderFactory.getSingletonMock();
+
+        LocationService.clearLastKnownLocation();
     }
 
     @After
diff --git a/mopub-sdk/src/test/java/com/mopub/mraid/MraidWebViewClientTest.java b/mopub-sdk/src/test/java/com/mopub/mraid/MraidWebViewClientTest.java
new file mode 100644
index 00000000..b69bf424
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mraid/MraidWebViewClientTest.java
@@ -0,0 +1,65 @@
+package com.mopub.mraid;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class MraidWebViewClientTest {
+
+    private MraidWebViewClient subject;
+
+    @Before
+    public void setUp() throws  Exception {
+        subject = new MraidWebViewClient();
+    }
+
+    @Test
+    public void matchesInjectionUrl_withMopubMraidJsUrls_shouldMatch() throws Exception {
+        assertThat(subject.matchesInjectionUrl("http://ads.mopub.com/mraid.js")).isTrue();
+        assertThat(subject.matchesInjectionUrl("https://ads.mopub.com/mraid.js")).isTrue();
+    }
+
+    @Test
+    public void matchesInjectionUrl_withOtherMraidJsUrls_shouldMatch() throws Exception {
+        assertThat(subject.matchesInjectionUrl("http://mraid.iab.net/compliance/mraid.js"))
+                .isTrue();
+        assertThat(subject.matchesInjectionUrl("https://mraid.iab.net/compliance/mraid.js"))
+                .isTrue();
+    }
+
+    @Test
+    public void matchesInjectionUrl_withRelativeMraidJsUrl_shouldMatch() throws Exception {
+        assertThat(subject.matchesInjectionUrl("mraid.js")).isTrue();
+    }
+
+    @Test
+    public void matchesInjectionUrl_withCasedMraidJsUrl_shouldMatch() throws Exception {
+        assertThat(subject.matchesInjectionUrl("mrAid.Js")).isTrue();
+    }
+
+    @Test
+    public void matchesInjectionUrl_withMraidJsUrl_withQueryParams_shouldMatch() throws Exception {
+        assertThat(subject.matchesInjectionUrl("mraid.js?foo=bar")).isTrue();
+    }
+
+    @Test
+    public void matchesInjectionUrl_withoutMraidJs_shouldNotMatch() throws Exception {
+        assertThat(subject.matchesInjectionUrl("mmraid.js")).isFalse();
+        assertThat(subject.matchesInjectionUrl("maid.js")).isFalse();
+        assertThat(subject.matchesInjectionUrl("mraidjs")).isFalse();
+        assertThat(subject.matchesInjectionUrl("mraid.jsS")).isFalse();
+    }
+
+    @Test
+    public void matchesInjectionUrl_withOpaqueUri_shouldNotMatch() throws Exception {
+        assertThat(subject.matchesInjectionUrl("mailto:mraid.js@js.com")).isFalse();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeUrlGeneratorTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeUrlGeneratorTest.java
index b7f167b6..076e4ff1 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeUrlGeneratorTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeUrlGeneratorTest.java
@@ -14,6 +14,7 @@
 import android.view.Display;
 import android.view.WindowManager;
 
+import com.mopub.common.LocationService;
 import com.mopub.common.MoPub;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.mobileads.BuildConfig;
@@ -92,6 +93,8 @@ public Object answer(final InvocationOnMock invocationOnMock) throws Throwable {
             when(spyApplicationContext.getSystemService(Context.WINDOW_SERVICE)).thenReturn(mockWindowManager);
             when(context.getApplicationContext()).thenReturn(spyApplicationContext);
         }
+
+        LocationService.clearLastKnownLocation();
     }
 
     @Test
diff --git a/mopub-sdk/src/test/java/com/mopub/network/AdRequestTest.java b/mopub-sdk/src/test/java/com/mopub/network/AdRequestTest.java
index bb85c2ed..aab1955f 100644
--- a/mopub-sdk/src/test/java/com/mopub/network/AdRequestTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/network/AdRequestTest.java
@@ -326,6 +326,15 @@ public void parseNetworkResponse_forRewardedAds_shouldSucceed() {
         defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.REWARDED_VIDEO);
         defaultHeaders.put(ResponseHeader.REWARDED_VIDEO_CURRENCY_NAME.getKey(), "currencyName");
         defaultHeaders.put(ResponseHeader.REWARDED_VIDEO_CURRENCY_AMOUNT.getKey(), "25");
+
+        final String rewardedCurrenciesJson = "{\"rewards\": ["
+                + "{\"name\": \"Coins\", \"amount\": 8},"
+                + "{\"name\": \"Diamonds\", \"amount\": 1},"
+                + "{\"name\": \"Diamonds\", \"amount\": 10 },"
+                + "{\"name\": \"Energy\", \"amount\": 20}"
+                + "]}";
+        defaultHeaders.put(ResponseHeader.REWARDED_CURRENCIES.getKey(), rewardedCurrenciesJson);
+
         defaultHeaders.put(ResponseHeader.REWARDED_VIDEO_COMPLETION_URL.getKey(),
                 "http://completionUrl");
         defaultHeaders.put(ResponseHeader.REWARDED_DURATION.getKey(), "15000");
@@ -338,6 +347,7 @@ public void parseNetworkResponse_forRewardedAds_shouldSucceed() {
         assertThat(response.result.getAdType()).isEqualTo(AdType.REWARDED_VIDEO);
         assertThat(response.result.getRewardedVideoCurrencyName()).isEqualTo("currencyName");
         assertThat(response.result.getRewardedVideoCurrencyAmount()).isEqualTo("25");
+        assertThat(response.result.getRewardedCurrencies()).isEqualTo(rewardedCurrenciesJson);
         assertThat(response.result.getRewardedVideoCompletionUrl()).isEqualTo(
                 "http://completionUrl");
         assertThat(response.result.getRewardedDuration()).isEqualTo(15000);
