diff --git a/CHANGELOG.md b/CHANGELOG.md
index c8540340..0d18323e 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,356 +1,361 @@
-## Version 3.7.0 (April 30, 2015)
-
-- Updated GooglePlayServices custom events to depend on the Google Play Services `play-services-ads 7.0.0` API.
-- Vungle support updated to SDK 3.3.3.
-- Updated InMobi and Greystripe custom events to accept application IDs from the MoPub UI.
-    - For InMobi: `{"app_id" : "YOUR_INMOBI_APP_ID"}`
-    - For Greystripe: `{"GUID" : "YOUR GREYSTRIPE_GUID"}`
-- Added toasts to the MoPub Sample App for ad load failures due to no connection.
-- Fixed a crash related to dismissing `MoPubBrowser` when zoom controls are visible; Fixes [issue #158](https://github.com/mopub/mopub-android-sdk/issues/158).
-- Fixed a bug in processing VAST progress trackers in a VAST wrapper tag.
-- Fixed a bug where ad refresh times could be incorrect when an ad request was not filled.
-- Updated the following dependencies:
-    - support-v4 AAR to 22.0.0
-    - support-annotations JAR to 22.0.0
-    - Android Maven Plugin to 4.2.0
-
-#### Version 3.6.1 (April 6, 2015)
-
- - **Bug Fix** Fixed a compile error in FacebookBanner.java
-
-## Version 3.6.0 (April 3, 2015)
-
- - **Facebook Update** Updated supported Facebook Audience Network version to 3.23.1
- - **Bug fix** Fixed a bug where interstitials could leak memory; Fixes [issue #153](https://github.com/mopub/mopub-android-sdk/issues/153)
- - **VAST Video** Updated the VAST video player to support Progress events.
- - Updated **Volley** version to 1.1.0.
-
-## Version 3.5.0 (March 10, 2015)
-
- - Dependency changes in Maven and Gradle. No new dependencies have been added, but your build script will need to change slightly to include JCenter. See our [Getting Started Guide](https://github.com/mopub/mopub-android-sdk/wiki/Getting-Started#adding-the-support-libraries-to-your-project) for complete instructions.
- - Security Improvement: removed the @JavascriptInterface annotation for WebViews.
- - Fixed a bug where video playback would sometimes fail to stop when an ad was dismissed.
- - Fixed a bug where it was not possible to disable ad refresh; Fixes [issue #148](https://github.com/mopub/mopub-android-sdk/issues/148)
- - Fixed a null pointer exception in AdViewController; Fixes [issue #150](https://github.com/mopub/mopub-android-sdk/issues/150)
-
-## Version 3.4.0 (January 30, 2015)
-
-  - **Volley networking stack** MoPub for Android now uses Google's Volley library for HTTP requests. You will need to add our bundled Volley JAR (available at `mopub-sdk/libs/mopub-volley-1.0.0.jar`) as a compile-time dependency. See instructions in our [integration page](https://dev.twitter.com/mopub/android/getting-started).
-  - **Updated Vungle Support** Certified the `VungleInterstitial` custom event against Vungle SDK 3.2.2
-  - **VAST Video Bug Fixes**
-    - Fixed inability to parse VAST tags referencing URLs that contain 3rd party macros
-    - VAST videos no longer fire completion trackers upon video playback error
-  - Added support for the `mopubnativebrowser://` click-destination scheme for Native, MRAID, and VAST ads (it was already supported for HTML ads). Links of this type (e.g. `mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.mopub.com`) will open the specified URL in the device's default browser, rather than in MoPub's in-app browser.
-
-## Version 3.3.0 (December 8, 2014)
-
-  - **MRAID 2.0 Support** - The MoPub SDK is now compliant with the MRAID 2.0 specification to enable rich media ads in banners and interstitial ad units. Learn more about MRAID from the [IAB](http://www.iab.net/MRAID#MRAID).
-  - **Location Polling Updates** - Changed the interaction between application- and device-provided location data: more recent location data is now always used (in the past, application-provided location data was always preferred).
-
-    As before, you may still disable MoPub SDK's location polling by calling `MoPub.setLocationAwareness(LocationAwareness.DISABLED)`.
-  - **Updated Chartboost SDK** Updated the `ChartboostInterstitial` custom event to support Chartboost SDK 5.0.4
-  - **Android Support Annotations** Introduced a dependency on android-support-annotations.jar to support code analysis of `@Nullable` and `@NonNull` annotations.
-
-#### Version 3.2.2 (October 29, 2014)
-  - **Bug Fix** Fixes a bug in fetching the Google Advertising ID from Google Play Services.
-
-#### Version 3.2.1 (October 21, 2014)
-  - **Bug Fix** Fixes a bug in processing certain HTTP headers for Native Ads.
-
-## Version 3.2.0 (October 17, 2014)
-
-  - **Updated SDK License** Visit [http://www.mopub.com/legal/sdk-license-agreement/](http://www.mopub.com/legal/sdk-license-agreement/) for details.
-  - **Bug Fixes**
-
-## Version 3.1.0 (October 9, 2014)
-
-  - **Updated Facebook SDK Compatibility to 3.18.1**
-  Provided Custom Events for Facebook Banners, Interstitials and Native Ads (included
-  in the extras/ folder) are now compatible with the latest SDK release from Facebook (3.18.1).
-  - **Updated API for Native Ads Custom Event writers**
-  If you are mediating Facebook or InMobi native ads, this change requires you to copy
-  FacebookNative.java and InMobiNative.java custom events from the extras/ folder to
-  com.mopub.nativeads package for compatibility.
-
-## Version 3.0.0 (September 30, 2014)
-
-  - **Location Settings are now SDK-wide**
-    - Calls to `MoPubView#setLocationAwareness` and `MoPubInterstial#setLocationAwareness` are
-    deprecated in favor of `MoPub#setLocationAwareness`
-    - Calls to `MoPubView#setLocationPrecision` and `MoPubInterstitial#setLocationPrecision` are
-    deprecated in favor of `MoPub#setLocationPrecision`
-    - Calls to any of these methods have the effect of setting location awareness and precision
-    globally for the SDK
-  - **Build target SDK is now API Level 19.** If you are building the MoPub SDK from source,
-  modify your dependencies to reference Android 4.4.2, API Level 19. This does not affect the
-  minimum device API level, which remains at API Level 9.
-  - **Source-level support for Gradle projects.** The SDK source now includes a build.gradle file you can use to build source as part of your Gradle project.
-  - **The SDK now uses Play Services 5.0.89**
-  - **Bug fixes:**
-    - Millennial Interstitial caching now properly handles request failures
-    - Fixed bug preventing native ads from loading after a request failure
-
-## Version 2.4.0 (August 28, 2014)
-
-  - **Minimum Android version now at API Level 9.** To use the new SDK, your app must run on Android 2.3.1 (Version 9, Gingerbread) or higher.
-  - **Simplified APIs for inserting native ads.** See [Native Ads Integration](https://github.com/mopub/mopub-android-sdk/wiki/Native-Ads-Integration) for details.
-  - **Automatic ad caching for smooth scrolling.** For native ads, the SDK will now automatically pre-load ads, resulting in smoother scrolling.
-  - **Performance improvements** The SDK now makes more efficient use of memory for image caching and avoids allocating temporary objects while scrolling, resulting in fewer garbage collections.
-  - **Sample app improvements.** An improved sample app allows saving ad unit IDs for testing.
-  - **Bug fixes:**
-    - Banner auto-refresh is now properly re-enabled when resuming your app.
-
-## Version 2.3 (July 17, 2014)
-
-  - **Improved impression tracking for Native Ads** Impression tracking for native ads is now more accurate and more efficient.
-  - **Streamlined Maven Build and Dependencies** MoPub's Android SDK now depends on the Android v4 Support Library shipped with the Android Build tools. The MoPub Sample App also depends on Google Play Services to use the Android Advertising ID. We recommend building against Play Services in your app as well. For integration instructions, see the [wiki](https://github.com/mopub/mopub-android-sdk/wiki/Getting-Started).
-  - **Removed AdMob Custom Events and JAR** AdMob's SDK is deprecated by Google and the APIs have been moved to Google Play Services. Existing AdMob adunits will now invoke the appropriate Google Play Services custom event. Developers must update their integration to use the Google Play Services custom events located in the extras folder by August 1.
-  - **Updated Third-Party Network Compatibility** MoPub's provided Custom Events (included in the extras/ folder) are now compatible with the latest SDK releases from Millennial Media (5.3.0), Vungle (3.1.0), InMobi (4.4.1) and Google Play Services (5.0.77).
-  - Fixed intermittent NullPointerException in MoPubNative#requestNativeAd; fixes [Github issue #97] (https://github.com/mopub/mopub-android-sdk/issues/97)
-  - Fixed an issue where MRAID interstitials could be not be closed.
-
-## Version 2.2 (June 19, 2014)
-
-  - **Native ads mediation** release; integration instructions and documentation are available on the [GitHub wiki](https://github.com/mopub/mopub-android-sdk/wiki/Integrating-Native-Third-Party-Ad-Networks). Added custom event native implementations to the native extras directory of the SDK (`/extras/src/com/mopub/nativeads`), with initial support for the following networks:
-  	- Facebook Audience Network (`FacebookNative.java`)
-  	- InMobi Native Ads (`InMobiNative.java`)
-  - **Native ads content filtering**: Added the ability to specify which native ad elements you want to receive from the MoPub Marketplace to optimize bandwidth use and download only required assets, via `RequestParameters.Builder#desiredAssets(…)`. This feature only works for the six standard Marketplace assets, found in `RequestParameters.NativeAdAsset`. Any additional elements added in direct sold ads will always be sent down in the extras.
-  - Added star rating information to the `NativeResponse` object, via `NativeResponse#getStarRating()`. This method returns a `Double` corresponding to an app's rating on a 5-star scale.
-  - VAST video quartile and completion trackers now always include the user-agent
-  - Ensured that banners never autorefresh until they have been loaded at least once
-
-## Version 2.1 (May 15, 2014)
-
-  - Added custom events for Facebook ads. `FacebookBanner` and `FacebookInterstitial` can be found in the extras directory of the SDK (`/extras/src/com/mopub/mobileads`). For more information, please see the [help page for Facebook custom events](http://help.mopub.com/customer/portal/articles/1552301-how-to-integrate-facebook-audience-network-using-custom-events).
-  - Significant improvements to video ads
-    - Added overlay including a "Learn More" button, video length, and time left until the video may be skipped
-    - Added support for companion banners (shown upon video completion)
-  - Added Logcat warnings (and Toasts for debug builds) in cases where all necessary Activity permissions haven't been added to the `AndroidManifest`
-
-#### Version 2.0.1 (April 30, 2014)
-
-  - Fixed cases where VAST Video Interstitials were failing to fire `InterstitialAdListener` callbacks; fixes [GitHub issue #78](https://github.com/mopub/mopub-android-sdk/issues/78)
-  - Simplified click tracking logic for HTML ads
-
-## Version 2.0 (April 22, 2014)
-
-  - **Native Ads** public release; integration instructions and documentation available on the [GitHub wiki](https://github.com/mopub/mopub-android-sdk/wiki/Native-Ads-Integration)
-  - Changed minimum supported Android version to Froyo (Android 2.2, API level 8)
-  - Added support for Google Play Services advertising identifier
-  - Renamed the `com.mopub.mobileads.MraidBrowser` Activity to `com.mopub.common.MoPubBrowser`.
-      - **Important Note:** This change requires a modification to the `AndroidManifest`. The updated set of requisite activity permissions are as follows:
-
-      	```
-    <activity android:name="com.mopub.common.MoPubBrowser"
-				android:configChanges="keyboardHidden|orientation"/>
-    <activity android:name="com.mopub.mobileads.MoPubActivity"
-                android:configChanges="keyboardHidden|orientation"/>
-    <activity android:name="com.mopub.mobileads.MraidActivity"
-                android:configChanges="keyboardHidden|orientation"/>
-	<activity android:name="com.mopub.mobileads.MraidVideoPlayerActivity"
-                android:configChanges="keyboardHidden|orientation"/>
-		```
-  - Upgraded the bundled `android-support-v4` library to r19.1.
-      - **Note for Maven users:** Newer versions of the `android-support-v4` artifact are unavailable on Maven central, so we have included a small script to update the version in your local artifact repository. Please navigate to the `mopub-sdk` directory, and run `scripts/mavenize_support_library`.
-
-#### Version 1.17.3.1 (March 24, 2014)
-
-  - Restricted use of methods and fields that require API 4+ (`WebView#removeJavascriptInterface` and `ConnectivityManager`'s connection types)
-
-## Version 1.17.3 (March 19, 2014)
-
-  - Added safeguards to prevent two different `MoPubInterstitial` objects from listening in on one other's lifecycle callbacks
-  - Disabled Javascript loading into `destroy()`ed `WebView`s; fixes [GitHub issue #62](https://github.com/mopub/mopub-android-sdk/issues/62)
-  - Fixed an `IllegalArgumentException` resulting from VAST videos with malformed redirect tags
-  - MRAID ads that utilize `mraid.open()` now correctly record a click event
-  - Added missing `FLAG_ACTIVITY_NEW_TASK` to `VastVideoView`'s intent creation; fixes part of [GitHub issue #56](https://github.com/mopub/mopub-android-sdk/issues/56)
-
-## Version 1.17.2 (February 20, 2014)
-
-  - Updated InMobi custom events to support InMobi SDK 4.0.3+ only
-  - MRAID viewable property now correctly updates on viewability change
-  - `MraidView` properly handles null schemes; fixes [GitHub issue #63](https://github.com/mopub/mopub-android-sdk/pull/63)
-  - Internal disk LRU cache correctly hashes keys when checking for existing files
-
-#### Version 1.17.1.1 (February 5, 2014)
-  - Fixed bug that caused clicks to not be recorded in the MoPub UI (introduced in 1.17.1)
-
-## Version 1.17.1 (January 23, 2014)
-
-  - Added custom events for Google Play Services. `GooglePlayServicesBanner` and `GooglePlayServicesInterstitial` can be found in the extras directory of the SDK (`/extras/src/com/mopub/mobileads`)
-  - Resolved issues with missing annotations on `addJavascriptInterface` when `targetSdkVersion` is set to API level 17 or above
-  - Updated MoPub sample application to allow in-app text entry of ad unit IDs
-
-## Version 1.17 (Nov 20, 2013)
-
-  - Support for VAST 2.0 video playback via MoPub Marketplace
-    - Short videos (less than 15 seconds) autoplay and and are unskippable
-    - Longer videos autoplay and are skippable after 5 seconds
-    - **Note:** The video cache can use up to 100 MB of internal storage. For developers sensitive to storage constraints, this value may be changed in `VastVideoInterstitial.CACHE_MAX_SIZE`.
-  - Updated InMobi custom event support to 4.0.0
-  - Added custom events for video ad network mediation, which can be found in the extras directory of the SDK (`/extras/src/com/mopub/mobileads/`)
-    - Added the `AdColonyInterstitial` custom event
-    - Added the `VungleInterstitial` custom event
-    - **Note:** Virtual currency callbacks (v4vc) are not supported for the above ad networks
-  - Enabled deeplinking via custom URIs in ad creatives
-  - All `WebView`s are removed from their parents before `destroy()`; fixes [GitHub issue #38](https://github.com/mopub/mopub-android-sdk/issues/38)
-  - Removed previously-deprecated `HTML5AdView`
-
-## Version 1.16 (October 16, 2013)
-
-  - Improved creative controls
-    - Creative flagging
-      - Allows users to report certain inappropriate ad experiences directly to MoPub with a special gesture
-      - User must swipe back and forth at least four times in the ad view to flag a creative
-      - Swipes must cover more than 1/3 of the ad width and should be completely horizontal
-      - Only enabled for direct sold, Marketplace, and server-to-server networks ads
-    - Creatives that attempt to auto-redirect are now blocked; ads cannot redirect without user interaction
-    - Javascript alert, confirm, and prompt dialogs are blocked
-  - Improved responsiveness of `showInterstitial()` for `HtmlInterstitial`s and `MraidInterstitial`s by pre-rendering HTML content
-  - Simplified internal construction and handling of `WebView`s by removing `WebViewPool` and its subclasses
-  - Updated mraid.getVersion() to return 2.0
-
-#### Version 1.15.2.2 (September 20, 2013)
-  - Removed `WebSettings.setPluginsEnabled()` so the SDK builds against Android API 18; fixes [GitHub issue #28](https://github.com/mopub/mopub-android-sdk/issues/28)
-  - AdMob banners are now removed from the view hierarchy before they are destroyed; fixes the reopened [GitHub issue #23](https://github.com/mopub/mopub-android-sdk/issues/23)
-  - Prevent ads from launching system features, such as a browser view, until the user has interacted with the ad.
-
-#### Version 1.15.2.1 (September 13, 2013)
-  - Made the SDK more resilient to creatives that improperly use the `mopubnativebrowser://` scheme; fixes [GitHub issue #36](https://github.com/mopub/mopub-android-sdk/issues/36)
-
-## Version 1.15.2 (September 11, 2013)
-  - Allowed Facebook Support to be disabled optionally with `setFacebookSupported(false)`:
-  	- Use `MoPubInterstitial.setFacebookSupported(false);` for interstitials
-  	- Use `MoPubView.setFacebookSupported(false);` for banners
-  	- Note: the `setFacebookSupported(false)` method call must come __before__ `loadAd()`
-  	- Note: facebook support is on by default
-  - Changed banner refresh default to be 60 seconds when requests timed out
-  - Fixed edge case in Millennial Media ad fetch failure when there is no inventory; fixes [GitHub issue #18](https://github.com/mopub/mopub-android-sdk/issues/18)
-  - Fixed a bug where redirect URLs were malformed, causing the native browser to not render ads
-  - Updated Millennial Media jar to 5.1.0
-  - Updated Greystripe custom event support to 2.3.0
-  - Fixed MRAID 2.0 `storePicture` command's messaging when a picture either fails to download or fails to save to device
-  - Expanded MRAID 2.0 `createCalendarEvent` command to support both minute- and second-level granularity
-
-#### Version 1.15.1.1 (September 4, 2013)
-  - Made the SDK more resilient to unexpected Flash creatives
-
-## Version 1.15.1 (August 27, 2013)
-  - Updated documentation to remove the requirement for certain AndroidManifest permissions
-  - Fixed minor bug with MRAID 2.0 `storePicture` command where the user sees a false download completed message
-
-## Version 1.15 (August 21, 2013)
-
-Includes support for ads in the MRAID 2.0 format. MRAID 2.0 allows advertisers to create ads with rich media functionality, including adding calendar events, storing pictures and playing videos in the native video player. To learn more about MRAID 2.0, read our [help article](http://j.mp/16MKSci).
-
-  - Added the following MRAID 2.0 features: `createCalendarEvent` (Android 4.0 and above), `playVideo`, `storePicture`, and `supports`
-  - Hardware Acceleration is now enabled by default for `MraidInterstitial`s on Android 4.0 and above
-  - Ensured that Cursors in `FacebookKeywordProvider` are always closed properly; fixes [GitHub issue #8](https://github.com/mopub/mopub-android-sdk/issues/8)
-  - Added tracking parameter to InMobi ad requests; fixes [GitHub issue #15](https://github.com/mopub/mopub-android-sdk/issues/15)
-  - Banner WebViews are now removed from the view hierarchy before they are destroyed; fixes [GitHub issue #23](https://github.com/mopub/mopub-android-sdk/issues/23)
-
-To correctly display ads that ask the user to save a picture (storePicture ads), you need to make the following change to AndroidManifest.xml:
-* Add the`WRITE_EXTERNAL_STORAGE` permission. Note: **Adding the permission is optional**. If the permission is not added, we will not deliver any store picture ads to the users' devices. All other features will remain functional without the new permission.
-
-To allow users to play videos using the native video player:
-* Declare activity `com.mopub.mobileads.MraidVideoPlayerActivity`. This activity is required to support playing videos in the native player and we strongly recommend adding it.
-
-## Version 1.14.1 (June 21, 2013)
-  - Wait until after loaded interstitials are shown to report an impression
-  - Remove phantom impression tracking from interstitials
-  - Remove extra whitespace from Millennial banner ads
-  - Added `onInterstitialClicked()` notification to `InterstitialAdListener`
-  - Provide default implementations for `BannerAdListener` and `InterstitialAdListener`
-
-## Version 1.14 (May 28, 2013)
-
-  - Provided improved support for Android Unity by moving all project resources (including layouts, javascript, images, and values) into source
-  - Removed reference to TYPE_DUMMY in AdUrlGenerator because it is not available in earlier versions of Android; fixes [GitHub issue #3](https://github.com/mopub/mopub-android-sdk/issues/3)
-  - Fixed NPE in AdUrlGenerator when WiFi is off and Airplane mode is on; fixes [GitHub issue #5](https://github.com/mopub/mopub-android-sdk/issues/5)
-  - `MraidInterstitial`s now properly notify `InterstitialAdListener` when they are shown and dismissed
-
-## Version 1.13.1 (May 21, 2013)
-  - Updated Millennial support to Millennial Media SDK version 5.0.1
-
-#### Version 1.13.0.2 (May 17, 2013)
-
-  - Relaxed access modifiers for `CustomEventBanner` and `CustomEventInterstitial`
-
-#### Version 1.13.0.1 (May 15, 2013)
-
-  - Removed extraneous display call in `MillennialInterstitial` custom event
-  - Fixed potential NPE in `AdView`'s loadUrl()
-  - Deprecated `HTML5AdView` after fixing some compilation issues
-
-## Version 1.13 (May 9, 2013)
-  - Moved all Android code and documentation to its own repository: [mopub-android-sdk](https://github.com/mopub/mopub-android-sdk)
-  - Updated Millennial support to Millennial Media SDK version 5.0
-      - Support for Millennial Media SDK 5.0.1 is ready and will be released when the new Milllennial SDK becomes available
-  - Added `GoogleAdMobBanner`, `GoogleAdMobInterstitial`, `MillennialBanner`, and `MillennialInterstitial` custom event classes
-  - Removed obsolete native network adapters
-  - Added timeout for third-party networks (10 seconds for banners and 30 seconds for interstitials)
-  - Added more data signals (application version, connection type, and location accuracy)
-
-## Version 1.12 (April 26, 2013)
-  - Chartboost custom event now automatically parses server data
-  - Added support for Millennial Media SDK 5.0
-  - Initial support for data signals (connectivity and carrier)
-
-## Version 1.11 (March 13, 2013)
-  - Deprecated multiple `MoPubView` event listener interfaces in favor of a unified `MoPubView.BannerAdListener` interface
-  - Deprecated `MoPubInterstitial` listener interface in favor of a new `MoPubInterstitial.InterstitialAdListener` interface
-  - Added "shown" and "dismissed" listener methods to `MoPubInterstitial.InterstitialAdListener` interface
-  - Fixed a NullPointerException in `MoPubInterstitial` for waterfalls containing multiple custom events
-  - Fixed a NullPointerException when tracking impressions for native network SDKs
-  - Fixed issue causing `MoPubView` to left-align HTML banners
-  - Fixed issue causing incorrect return value for `isReady` when using `MoPubInterstitial` and custom events
-
-## Version 1.10 (February 13, 2013)
-  - Introduced custom event classes
-  - Improved error logging during `AdFetch`
-  - Fixed view resource ID conflicts in `MraidDisplayController`
-  - Fixed issue in which un-implemented custom events could disrupt the mediation waterfall
-  - Added ability to force refresh ad units
-  - Added testing accessors to `MoPubView` and `MoPubInterstitial`
-  - Updated to correctly reflect MRAID capabilities in ad request
-  - Updated to perform `HttpClient` shutdown on background thread
-
-## Version 1.9 (September 27, 2012)
-  - Added support for the Facebook ads test program
-  - Updated the Millennial adapters to support SDK version 4.6.0
-
-## Version 1.8 (September 6, 2012)
-  - Fixed a crash resulting from following market:// links when Google Play is not installed
-  - Added in-app browser support for more Google Play redirect styles
-  - Added exponential backoff on ad server failure
-  - Included new ad unit IDs for sample ads in SimpleAdsDemo
-  - Removed extraneous image files
-
-## Version 1.7 (August 2, 2012)
-  - Added support for Millennial Media leaderboard ads
-
-## Version 1.6 (June 29, 2012)
-  - Improved click experience by directing clicks to an in-app browser
-  - Fixed errors loading mraid.js from disk on Android 4.0+
-  - Added `ThreadPoolExecutor` for AsyncTasks on Android 4.0+
-  - Fixed incorrect failover behavior for Custom Native Network banners
-
-## Version 1.5 (May 10, 2012)
-  - Added support for Millennial Media SDK 4.5.5
-  - Fixed ANR relating to synchronization in `LoadUrlTask`
-  - Fixed IllegalArgumentExceptions when creating HttpGet objects with malformed URLs
-
-## Version 1.4 (March 28, 2012)
-  - Fixed some NullPointerExceptions in the AdMob and Millennial native adapters
-  - Fixed issues in which third-party adapters might not properly fail over
-  - Fixed a crash caused by unregistering non-existent broadcast receivers
-
-## Version 1.3 (March 14, 2012)
-  - Fixed handling of potential SecurityExceptions from network connectivity checks
-  - Exposed keyword APIs for interstitials
-  - Fixed click-tracking for custom:// and other non-http intents
-
-## Version 1.2 (February 29, 2012)
-  - Added support for custom events
-  - Added network connectivity check before loading an ad
-  - Added `OnAdPresentedOverlay` listener methods
+## Version 3.8.0 (June 1, 2015)
+
+- Updated Chartboost support to 5.3.0. This introduces a new shared class called ChartboostShared. If you are using Chartboost Custom Native Networks you will need to include this class in your build along with ChartboostInterstitial.
+
+## Version 3.7.0 (April 30, 2015)
+
+- Updated GooglePlayServices custom events to depend on the Google Play Services `play-services-ads 7.0.0` API.
+- Vungle support updated to SDK 3.3.3.
+- Updated InMobi and Greystripe custom events to accept application IDs from the MoPub UI.
+  - For InMobi: `{"app_id" : "YOUR_INMOBI_APP_ID"}`
+  - For Greystripe: `{"GUID" : "YOUR GREYSTRIPE_GUID"}`
+
+- Added toasts to the MoPub Sample App for ad load failures due to no connection.
+- Fixed a bug in processing VAST progress trackers in a VAST wrapper tag.
+- Fixed a bug where ad refresh times could be incorrect when an ad request was not filled.
+
+- Updated the following dependencies:
+	- support-v4 AAR to 22.0.0
+	- support-annotations JAR to 22.0.0
+	- Android Maven Plugin to 4.2.0
+
+#### Version 3.6.1 (April 6, 2015)
+
+ - **Bug Fix** Fixed a compile error in FacebookBanner.java
+
+## Version 3.6.0 (April 3, 2015)
+
+ - **Facebook Update** Updated supported Facebook Audience Network version to 3.23.1
+ - **Bug fix** Fixed a bug where interstitials could leak memory; Fixes [issue #153](https://github.com/mopub/mopub-android-sdk/issues/153)
+ - **VAST Video** Updated the VAST video player to support Progress events.
+ - Updated **Volley** version to 1.1.0.
+
+## Version 3.5.0 (March 10, 2015)
+
+ - Dependency changes in Maven and Gradle. No new dependencies have been added, but your build script will need to change slightly to include JCenter. See our [Getting Started Guide](https://github.com/mopub/mopub-android-sdk/wiki/Getting-Started#adding-the-support-libraries-to-your-project) for complete instructions.
+ - Security Improvement: removed the @JavascriptInterface annotation for WebViews.
+ - Fixed a bug where video playback would sometimes fail to stop when an ad was dismissed.
+ - Fixed a bug where it was not possible to disable ad refresh; Fixes [issue #148](https://github.com/mopub/mopub-android-sdk/issues/148)
+ - Fixed a null pointer exception in AdViewController; Fixes [issue #150](https://github.com/mopub/mopub-android-sdk/issues/150)
+
+## Version 3.4.0 (January 30, 2015)
+
+  - **Volley networking stack** MoPub for Android now uses Google's Volley library for HTTP requests. You will need to add our bundled Volley JAR (available at `mopub-sdk/libs/mopub-volley-1.0.0.jar`) as a compile-time dependency. See instructions in our [integration page](https://dev.twitter.com/mopub/android/getting-started).
+  - **Updated Vungle Support** Certified the `VungleInterstitial` custom event against Vungle SDK 3.2.2
+  - **VAST Video Bug Fixes**
+    - Fixed inability to parse VAST tags referencing URLs that contain 3rd party macros
+    - VAST videos no longer fire completion trackers upon video playback error
+  - Added support for the `mopubnativebrowser://` click-destination scheme for Native, MRAID, and VAST ads (it was already supported for HTML ads). Links of this type (e.g. `mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.mopub.com`) will open the specified URL in the device's default browser, rather than in MoPub's in-app browser.
+
+## Version 3.3.0 (December 8, 2014)
+
+  - **MRAID 2.0 Support** - The MoPub SDK is now compliant with the MRAID 2.0 specification to enable rich media ads in banners and interstitial ad units. Learn more about MRAID from the [IAB](http://www.iab.net/MRAID#MRAID).
+  - **Location Polling Updates** - Changed the interaction between application- and device-provided location data: more recent location data is now always used (in the past, application-provided location data was always preferred).
+
+    As before, you may still disable MoPub SDK's location polling by calling `MoPub.setLocationAwareness(LocationAwareness.DISABLED)`.
+  - **Updated Chartboost SDK** Updated the `ChartboostInterstitial` custom event to support Chartboost SDK 5.0.4
+  - **Android Support Annotations** Introduced a dependency on android-support-annotations.jar to support code analysis of `@Nullable` and `@NonNull` annotations.
+
+#### Version 3.2.2 (October 29, 2014)
+  - **Bug Fix** Fixes a bug in fetching the Google Advertising ID from Google Play Services.
+
+#### Version 3.2.1 (October 21, 2014)
+  - **Bug Fix** Fixes a bug in processing certain HTTP headers for Native Ads.
+
+## Version 3.2.0 (October 17, 2014)
+
+  - **Updated SDK License** Visit [http://www.mopub.com/legal/sdk-license-agreement/](http://www.mopub.com/legal/sdk-license-agreement/) for details.
+  - **Bug Fixes**
+
+## Version 3.1.0 (October 9, 2014)
+
+  - **Updated Facebook SDK Compatibility to 3.18.1**
+  Provided Custom Events for Facebook Banners, Interstitials and Native Ads (included
+  in the extras/ folder) are now compatible with the latest SDK release from Facebook (3.18.1).
+  - **Updated API for Native Ads Custom Event writers**
+  If you are mediating Facebook or InMobi native ads, this change requires you to copy
+  FacebookNative.java and InMobiNative.java custom events from the extras/ folder to
+  com.mopub.nativeads package for compatibility.
+
+## Version 3.0.0 (September 30, 2014)
+
+  - **Location Settings are now SDK-wide**
+    - Calls to `MoPubView#setLocationAwareness` and `MoPubInterstial#setLocationAwareness` are
+    deprecated in favor of `MoPub#setLocationAwareness`
+    - Calls to `MoPubView#setLocationPrecision` and `MoPubInterstitial#setLocationPrecision` are
+    deprecated in favor of `MoPub#setLocationPrecision`
+    - Calls to any of these methods have the effect of setting location awareness and precision
+    globally for the SDK
+  - **Build target SDK is now API Level 19.** If you are building the MoPub SDK from source,
+  modify your dependencies to reference Android 4.4.2, API Level 19. This does not affect the
+  minimum device API level, which remains at API Level 9.
+  - **Source-level support for Gradle projects.** The SDK source now includes a build.gradle file you can use to build source as part of your Gradle project.
+  - **The SDK now uses Play Services 5.0.89**
+  - **Bug fixes:**
+    - Millennial Interstitial caching now properly handles request failures
+    - Fixed bug preventing native ads from loading after a request failure
+
+## Version 2.4.0 (August 28, 2014)
+
+  - **Minimum Android version now at API Level 9.** To use the new SDK, your app must run on Android 2.3.1 (Version 9, Gingerbread) or higher.
+  - **Simplified APIs for inserting native ads.** See [Native Ads Integration](https://github.com/mopub/mopub-android-sdk/wiki/Native-Ads-Integration) for details.
+  - **Automatic ad caching for smooth scrolling.** For native ads, the SDK will now automatically pre-load ads, resulting in smoother scrolling.
+  - **Performance improvements** The SDK now makes more efficient use of memory for image caching and avoids allocating temporary objects while scrolling, resulting in fewer garbage collections.
+  - **Sample app improvements.** An improved sample app allows saving ad unit IDs for testing.
+  - **Bug fixes:**
+    - Banner auto-refresh is now properly re-enabled when resuming your app.
+
+## Version 2.3 (July 17, 2014)
+
+  - **Improved impression tracking for Native Ads** Impression tracking for native ads is now more accurate and more efficient.
+  - **Streamlined Maven Build and Dependencies** MoPub's Android SDK now depends on the Android v4 Support Library shipped with the Android Build tools. The MoPub Sample App also depends on Google Play Services to use the Android Advertising ID. We recommend building against Play Services in your app as well. For integration instructions, see the [wiki](https://github.com/mopub/mopub-android-sdk/wiki/Getting-Started).
+  - **Removed AdMob Custom Events and JAR** AdMob's SDK is deprecated by Google and the APIs have been moved to Google Play Services. Existing AdMob adunits will now invoke the appropriate Google Play Services custom event. Developers must update their integration to use the Google Play Services custom events located in the extras folder by August 1.
+  - **Updated Third-Party Network Compatibility** MoPub's provided Custom Events (included in the extras/ folder) are now compatible with the latest SDK releases from Millennial Media (5.3.0), Vungle (3.1.0), InMobi (4.4.1) and Google Play Services (5.0.77).
+  - Fixed intermittent NullPointerException in MoPubNative#requestNativeAd; fixes [Github issue #97] (https://github.com/mopub/mopub-android-sdk/issues/97)
+  - Fixed an issue where MRAID interstitials could be not be closed.
+
+## Version 2.2 (June 19, 2014)
+
+  - **Native ads mediation** release; integration instructions and documentation are available on the [GitHub wiki](https://github.com/mopub/mopub-android-sdk/wiki/Integrating-Native-Third-Party-Ad-Networks). Added custom event native implementations to the native extras directory of the SDK (`/extras/src/com/mopub/nativeads`), with initial support for the following networks:
+  	- Facebook Audience Network (`FacebookNative.java`)
+  	- InMobi Native Ads (`InMobiNative.java`)
+  - **Native ads content filtering**: Added the ability to specify which native ad elements you want to receive from the MoPub Marketplace to optimize bandwidth use and download only required assets, via `RequestParameters.Builder#desiredAssets(…)`. This feature only works for the six standard Marketplace assets, found in `RequestParameters.NativeAdAsset`. Any additional elements added in direct sold ads will always be sent down in the extras.
+  - Added star rating information to the `NativeResponse` object, via `NativeResponse#getStarRating()`. This method returns a `Double` corresponding to an app's rating on a 5-star scale.
+  - VAST video quartile and completion trackers now always include the user-agent
+  - Ensured that banners never autorefresh until they have been loaded at least once
+
+## Version 2.1 (May 15, 2014)
+
+  - Added custom events for Facebook ads. `FacebookBanner` and `FacebookInterstitial` can be found in the extras directory of the SDK (`/extras/src/com/mopub/mobileads`). For more information, please see the [help page for Facebook custom events](http://help.mopub.com/customer/portal/articles/1552301-how-to-integrate-facebook-audience-network-using-custom-events).
+  - Significant improvements to video ads
+    - Added overlay including a "Learn More" button, video length, and time left until the video may be skipped
+    - Added support for companion banners (shown upon video completion)
+  - Added Logcat warnings (and Toasts for debug builds) in cases where all necessary Activity permissions haven't been added to the `AndroidManifest`
+
+#### Version 2.0.1 (April 30, 2014)
+
+  - Fixed cases where VAST Video Interstitials were failing to fire `InterstitialAdListener` callbacks; fixes [GitHub issue #78](https://github.com/mopub/mopub-android-sdk/issues/78)
+  - Simplified click tracking logic for HTML ads
+
+## Version 2.0 (April 22, 2014)
+
+  - **Native Ads** public release; integration instructions and documentation available on the [GitHub wiki](https://github.com/mopub/mopub-android-sdk/wiki/Native-Ads-Integration)
+  - Changed minimum supported Android version to Froyo (Android 2.2, API level 8)
+  - Added support for Google Play Services advertising identifier
+  - Renamed the `com.mopub.mobileads.MraidBrowser` Activity to `com.mopub.common.MoPubBrowser`.
+      - **Important Note:** This change requires a modification to the `AndroidManifest`. The updated set of requisite activity permissions are as follows:
+
+      	```
+    <activity android:name="com.mopub.common.MoPubBrowser"
+				android:configChanges="keyboardHidden|orientation"/>
+    <activity android:name="com.mopub.mobileads.MoPubActivity"
+                android:configChanges="keyboardHidden|orientation"/>
+    <activity android:name="com.mopub.mobileads.MraidActivity"
+                android:configChanges="keyboardHidden|orientation"/>
+	<activity android:name="com.mopub.mobileads.MraidVideoPlayerActivity"
+                android:configChanges="keyboardHidden|orientation"/>
+		```
+  - Upgraded the bundled `android-support-v4` library to r19.1.
+      - **Note for Maven users:** Newer versions of the `android-support-v4` artifact are unavailable on Maven central, so we have included a small script to update the version in your local artifact repository. Please navigate to the `mopub-sdk` directory, and run `scripts/mavenize_support_library`.
+
+#### Version 1.17.3.1 (March 24, 2014)
+
+  - Restricted use of methods and fields that require API 4+ (`WebView#removeJavascriptInterface` and `ConnectivityManager`'s connection types)
+
+## Version 1.17.3 (March 19, 2014)
+
+  - Added safeguards to prevent two different `MoPubInterstitial` objects from listening in on one other's lifecycle callbacks
+  - Disabled Javascript loading into `destroy()`ed `WebView`s; fixes [GitHub issue #62](https://github.com/mopub/mopub-android-sdk/issues/62)
+  - Fixed an `IllegalArgumentException` resulting from VAST videos with malformed redirect tags
+  - MRAID ads that utilize `mraid.open()` now correctly record a click event
+  - Added missing `FLAG_ACTIVITY_NEW_TASK` to `VastVideoView`'s intent creation; fixes part of [GitHub issue #56](https://github.com/mopub/mopub-android-sdk/issues/56)
+
+## Version 1.17.2 (February 20, 2014)
+
+  - Updated InMobi custom events to support InMobi SDK 4.0.3+ only
+  - MRAID viewable property now correctly updates on viewability change
+  - `MraidView` properly handles null schemes; fixes [GitHub issue #63](https://github.com/mopub/mopub-android-sdk/pull/63)
+  - Internal disk LRU cache correctly hashes keys when checking for existing files
+
+#### Version 1.17.1.1 (February 5, 2014)
+  - Fixed bug that caused clicks to not be recorded in the MoPub UI (introduced in 1.17.1)
+
+## Version 1.17.1 (January 23, 2014)
+
+  - Added custom events for Google Play Services. `GooglePlayServicesBanner` and `GooglePlayServicesInterstitial` can be found in the extras directory of the SDK (`/extras/src/com/mopub/mobileads`)
+  - Resolved issues with missing annotations on `addJavascriptInterface` when `targetSdkVersion` is set to API level 17 or above
+  - Updated MoPub sample application to allow in-app text entry of ad unit IDs
+
+## Version 1.17 (Nov 20, 2013)
+
+  - Support for VAST 2.0 video playback via MoPub Marketplace
+    - Short videos (less than 15 seconds) autoplay and and are unskippable
+    - Longer videos autoplay and are skippable after 5 seconds
+    - **Note:** The video cache can use up to 100 MB of internal storage. For developers sensitive to storage constraints, this value may be changed in `VastVideoInterstitial.CACHE_MAX_SIZE`.
+  - Updated InMobi custom event support to 4.0.0
+  - Added custom events for video ad network mediation, which can be found in the extras directory of the SDK (`/extras/src/com/mopub/mobileads/`)
+    - Added the `AdColonyInterstitial` custom event
+    - Added the `VungleInterstitial` custom event
+    - **Note:** Virtual currency callbacks (v4vc) are not supported for the above ad networks
+  - Enabled deeplinking via custom URIs in ad creatives
+  - All `WebView`s are removed from their parents before `destroy()`; fixes [GitHub issue #38](https://github.com/mopub/mopub-android-sdk/issues/38)
+  - Removed previously-deprecated `HTML5AdView`
+
+## Version 1.16 (October 16, 2013)
+
+  - Improved creative controls
+    - Creative flagging
+      - Allows users to report certain inappropriate ad experiences directly to MoPub with a special gesture
+      - User must swipe back and forth at least four times in the ad view to flag a creative
+      - Swipes must cover more than 1/3 of the ad width and should be completely horizontal
+      - Only enabled for direct sold, Marketplace, and server-to-server networks ads
+    - Creatives that attempt to auto-redirect are now blocked; ads cannot redirect without user interaction
+    - Javascript alert, confirm, and prompt dialogs are blocked
+  - Improved responsiveness of `showInterstitial()` for `HtmlInterstitial`s and `MraidInterstitial`s by pre-rendering HTML content
+  - Simplified internal construction and handling of `WebView`s by removing `WebViewPool` and its subclasses
+  - Updated mraid.getVersion() to return 2.0
+
+#### Version 1.15.2.2 (September 20, 2013)
+  - Removed `WebSettings.setPluginsEnabled()` so the SDK builds against Android API 18; fixes [GitHub issue #28](https://github.com/mopub/mopub-android-sdk/issues/28)
+  - AdMob banners are now removed from the view hierarchy before they are destroyed; fixes the reopened [GitHub issue #23](https://github.com/mopub/mopub-android-sdk/issues/23)
+  - Prevent ads from launching system features, such as a browser view, until the user has interacted with the ad.
+
+#### Version 1.15.2.1 (September 13, 2013)
+  - Made the SDK more resilient to creatives that improperly use the `mopubnativebrowser://` scheme; fixes [GitHub issue #36](https://github.com/mopub/mopub-android-sdk/issues/36)
+
+## Version 1.15.2 (September 11, 2013)
+  - Allowed Facebook Support to be disabled optionally with `setFacebookSupported(false)`:
+  	- Use `MoPubInterstitial.setFacebookSupported(false);` for interstitials
+  	- Use `MoPubView.setFacebookSupported(false);` for banners
+  	- Note: the `setFacebookSupported(false)` method call must come __before__ `loadAd()`
+  	- Note: facebook support is on by default
+  - Changed banner refresh default to be 60 seconds when requests timed out
+  - Fixed edge case in Millennial Media ad fetch failure when there is no inventory; fixes [GitHub issue #18](https://github.com/mopub/mopub-android-sdk/issues/18)
+  - Fixed a bug where redirect URLs were malformed, causing the native browser to not render ads
+  - Updated Millennial Media jar to 5.1.0
+  - Updated Greystripe custom event support to 2.3.0
+  - Fixed MRAID 2.0 `storePicture` command's messaging when a picture either fails to download or fails to save to device
+  - Expanded MRAID 2.0 `createCalendarEvent` command to support both minute- and second-level granularity
+
+#### Version 1.15.1.1 (September 4, 2013)
+  - Made the SDK more resilient to unexpected Flash creatives
+
+## Version 1.15.1 (August 27, 2013)
+  - Updated documentation to remove the requirement for certain AndroidManifest permissions
+  - Fixed minor bug with MRAID 2.0 `storePicture` command where the user sees a false download completed message
+
+## Version 1.15 (August 21, 2013)
+
+Includes support for ads in the MRAID 2.0 format. MRAID 2.0 allows advertisers to create ads with rich media functionality, including adding calendar events, storing pictures and playing videos in the native video player. To learn more about MRAID 2.0, read our [help article](http://j.mp/16MKSci).
+
+  - Added the following MRAID 2.0 features: `createCalendarEvent` (Android 4.0 and above), `playVideo`, `storePicture`, and `supports`
+  - Hardware Acceleration is now enabled by default for `MraidInterstitial`s on Android 4.0 and above
+  - Ensured that Cursors in `FacebookKeywordProvider` are always closed properly; fixes [GitHub issue #8](https://github.com/mopub/mopub-android-sdk/issues/8)
+  - Added tracking parameter to InMobi ad requests; fixes [GitHub issue #15](https://github.com/mopub/mopub-android-sdk/issues/15)
+  - Banner WebViews are now removed from the view hierarchy before they are destroyed; fixes [GitHub issue #23](https://github.com/mopub/mopub-android-sdk/issues/23)
+
+To correctly display ads that ask the user to save a picture (storePicture ads), you need to make the following change to AndroidManifest.xml:
+* Add the`WRITE_EXTERNAL_STORAGE` permission. Note: **Adding the permission is optional**. If the permission is not added, we will not deliver any store picture ads to the users' devices. All other features will remain functional without the new permission.
+
+To allow users to play videos using the native video player:
+* Declare activity `com.mopub.mobileads.MraidVideoPlayerActivity`. This activity is required to support playing videos in the native player and we strongly recommend adding it.
+
+## Version 1.14.1 (June 21, 2013)
+  - Wait until after loaded interstitials are shown to report an impression
+  - Remove phantom impression tracking from interstitials
+  - Remove extra whitespace from Millennial banner ads
+  - Added `onInterstitialClicked()` notification to `InterstitialAdListener`
+  - Provide default implementations for `BannerAdListener` and `InterstitialAdListener`
+
+## Version 1.14 (May 28, 2013)
+
+  - Provided improved support for Android Unity by moving all project resources (including layouts, javascript, images, and values) into source
+  - Removed reference to TYPE_DUMMY in AdUrlGenerator because it is not available in earlier versions of Android; fixes [GitHub issue #3](https://github.com/mopub/mopub-android-sdk/issues/3)
+  - Fixed NPE in AdUrlGenerator when WiFi is off and Airplane mode is on; fixes [GitHub issue #5](https://github.com/mopub/mopub-android-sdk/issues/5)
+  - `MraidInterstitial`s now properly notify `InterstitialAdListener` when they are shown and dismissed
+
+## Version 1.13.1 (May 21, 2013)
+  - Updated Millennial support to Millennial Media SDK version 5.0.1
+
+#### Version 1.13.0.2 (May 17, 2013)
+
+  - Relaxed access modifiers for `CustomEventBanner` and `CustomEventInterstitial`
+
+#### Version 1.13.0.1 (May 15, 2013)
+
+  - Removed extraneous display call in `MillennialInterstitial` custom event
+  - Fixed potential NPE in `AdView`'s loadUrl()
+  - Deprecated `HTML5AdView` after fixing some compilation issues
+
+## Version 1.13 (May 9, 2013)
+  - Moved all Android code and documentation to its own repository: [mopub-android-sdk](https://github.com/mopub/mopub-android-sdk)
+  - Updated Millennial support to Millennial Media SDK version 5.0
+      - Support for Millennial Media SDK 5.0.1 is ready and will be released when the new Milllennial SDK becomes available
+  - Added `GoogleAdMobBanner`, `GoogleAdMobInterstitial`, `MillennialBanner`, and `MillennialInterstitial` custom event classes
+  - Removed obsolete native network adapters
+  - Added timeout for third-party networks (10 seconds for banners and 30 seconds for interstitials)
+  - Added more data signals (application version, connection type, and location accuracy)
+
+## Version 1.12 (April 26, 2013)
+  - Chartboost custom event now automatically parses server data
+  - Added support for Millennial Media SDK 5.0
+  - Initial support for data signals (connectivity and carrier)
+
+## Version 1.11 (March 13, 2013)
+  - Deprecated multiple `MoPubView` event listener interfaces in favor of a unified `MoPubView.BannerAdListener` interface
+  - Deprecated `MoPubInterstitial` listener interface in favor of a new `MoPubInterstitial.InterstitialAdListener` interface
+  - Added "shown" and "dismissed" listener methods to `MoPubInterstitial.InterstitialAdListener` interface
+  - Fixed a NullPointerException in `MoPubInterstitial` for waterfalls containing multiple custom events
+  - Fixed a NullPointerException when tracking impressions for native network SDKs
+  - Fixed issue causing `MoPubView` to left-align HTML banners
+  - Fixed issue causing incorrect return value for `isReady` when using `MoPubInterstitial` and custom events
+
+## Version 1.10 (February 13, 2013)
+  - Introduced custom event classes
+  - Improved error logging during `AdFetch`
+  - Fixed view resource ID conflicts in `MraidDisplayController`
+  - Fixed issue in which un-implemented custom events could disrupt the mediation waterfall
+  - Added ability to force refresh ad units
+  - Added testing accessors to `MoPubView` and `MoPubInterstitial`
+  - Updated to correctly reflect MRAID capabilities in ad request
+  - Updated to perform `HttpClient` shutdown on background thread
+
+## Version 1.9 (September 27, 2012)
+  - Added support for the Facebook ads test program
+  - Updated the Millennial adapters to support SDK version 4.6.0
+
+## Version 1.8 (September 6, 2012)
+  - Fixed a crash resulting from following market:// links when Google Play is not installed
+  - Added in-app browser support for more Google Play redirect styles
+  - Added exponential backoff on ad server failure
+  - Included new ad unit IDs for sample ads in SimpleAdsDemo
+  - Removed extraneous image files
+
+## Version 1.7 (August 2, 2012)
+  - Added support for Millennial Media leaderboard ads
+
+## Version 1.6 (June 29, 2012)
+  - Improved click experience by directing clicks to an in-app browser
+  - Fixed errors loading mraid.js from disk on Android 4.0+
+  - Added `ThreadPoolExecutor` for AsyncTasks on Android 4.0+
+  - Fixed incorrect failover behavior for Custom Native Network banners
+
+## Version 1.5 (May 10, 2012)
+  - Added support for Millennial Media SDK 4.5.5
+  - Fixed ANR relating to synchronization in `LoadUrlTask`
+  - Fixed IllegalArgumentExceptions when creating HttpGet objects with malformed URLs
+
+## Version 1.4 (March 28, 2012)
+  - Fixed some NullPointerExceptions in the AdMob and Millennial native adapters
+  - Fixed issues in which third-party adapters might not properly fail over
+  - Fixed a crash caused by unregistering non-existent broadcast receivers
+
+## Version 1.3 (March 14, 2012)
+  - Fixed handling of potential SecurityExceptions from network connectivity checks
+  - Exposed keyword APIs for interstitials
+  - Fixed click-tracking for custom:// and other non-http intents
+
+## Version 1.2 (February 29, 2012)
+  - Added support for custom events
+  - Added network connectivity check before loading an ad
+  - Added `OnAdPresentedOverlay` listener methods
diff --git a/README.md b/README.md
index bc022213..e8517fe9 100644
--- a/README.md
+++ b/README.md
@@ -1,63 +1,52 @@
-# MoPub Android SDK
-
-Thanks for taking a look at MoPub! We take pride in having an easy-to-use, flexible monetization solution that works across multiple platforms.
-
-Sign up for an account at [http://app.mopub.com/](http://app.mopub.com/).
-
-## Need Help?
-
-You can find integration documentation on our [wiki](https://github.com/mopub/mopub-android-sdk/wiki/Getting-Started) and
-additional help documentation on our [developer help site](http://dev.twitter.com/mopub). 
-
-To file an issue with our team visit the [MoPub Forum](https://twittercommunity.com/c/fabric/mopub). 
-
-**Note: We will be deprecating the use of GitHub issues in the near future and migrating all issues to the forum to provide a faster response time.**
-
-## Download
-
-The MoPub SDK is distributed as source code that you can include in your application.  MoPub provides two prepackaged archives of source code:
-
-- **[MoPub Android Full SDK.zip](http://bit.ly/YUdU9v)**
-
-  Includes everything you need to serve HTML and MRAID MoPub advertisiments *and* built-in support for Millennial Media third party ad network - [Millennial Media](http://www.millennialmedia.com/) - including the required third party binaries.
-
-- **[MoPub Android Base SDK.zip](http://bit.ly/YUdWhH)**
-
-  Includes everything you need to serve HTML and MRAID MoPub advertisements.  No third party ad networks are included.
-
-## Integrate
-
-Integration instructions are available on the [wiki](https://github.com/mopub/mopub-android-sdk/wiki/Getting-Started).
-
-
-## New in this Version
-
-Please view the [changelog](https://github.com/mopub/mopub-android-sdk/blob/master/CHANGELOG.md) for details.
-
-- Updated GooglePlayServices custom events to depend on the Google Play Services `play-services-ads 7.0.0` API.
-- Vungle support updated to SDK 3.3.3.
-- Updated InMobi and Greystripe custom events to accept application IDs from the MoPub UI.
-  - For InMobi: `{"app_id" : "YOUR_INMOBI_APP_ID"}`
-  - For Greystripe: `{"GUID" : "YOUR GREYSTRIPE_GUID"}`
-
-- Updated the following dependencies:
-	- support-v4 AAR to 22.0.0
-	- support-annotations JAR to 22.0.0
-	- Android Maven Plugin to 4.2.0
-	
-- Bug Fixes
-
-## Requirements
-
-- Android 2.3.1 (API Version 9) and up
-- android-support-v4.jar, r22 (**Updated in 3.7.0**)
-- android-support-annotations.jar, r22 (**Updated in 3.7.0**)
-- MoPub Volley Library (mopub-volley-1.1.0.jar - available on JCenter) (**Updated in 3.6.0**)
-- **Recommended** Google Play Services 7.0.0
-
-## Upgrading from 3.2.0 and Prior
-In 3.3.0 a dependency on android-support-annotations.jar was added. If you are using Maven or Gradle to include the MoPub SDK, this dependency is included in the build scripts. For instructions on adding dependencies for Eclipse projects, see our [Getting Started Guide](https://github.com/mopub/mopub-android-sdk/wiki/Getting-Started#adding-the-support-libraries-to-your-project)
-
-## License
-
-We have launched a new license as of version 3.2.0. To view the full license, visit [http://www.mopub.com/legal/sdk-license-agreement/](http://www.mopub.com/legal/sdk-license-agreement/).
+# MoPub Android SDK
+
+Thanks for taking a look at MoPub! We take pride in having an easy-to-use, flexible monetization solution that works across multiple platforms.
+
+Sign up for an account at [http://app.mopub.com/](http://app.mopub.com/).
+
+## Need Help?
+
+You can find integration documentation on our [wiki](https://github.com/mopub/mopub-android-sdk/wiki/Getting-Started) and
+additional help documentation on our [developer help site](http://dev.twitter.com/mopub). 
+
+To file an issue with our team visit the [MoPub Forum](https://twittercommunity.com/c/fabric/mopub). 
+
+**Note: We will be deprecating the use of GitHub issues in the near future and migrating all issues to the forum to provide a faster response time.**
+
+## Download
+
+The MoPub SDK is distributed as source code that you can include in your application.  MoPub provides two prepackaged archives of source code:
+
+- **[MoPub Android Full SDK.zip](http://bit.ly/YUdU9v)**
+
+  Includes everything you need to serve HTML and MRAID MoPub advertisiments *and* built-in support for Millennial Media third party ad network - [Millennial Media](http://www.millennialmedia.com/) - including the required third party binaries.
+
+- **[MoPub Android Base SDK.zip](http://bit.ly/YUdWhH)**
+
+  Includes everything you need to serve HTML and MRAID MoPub advertisements.  No third party ad networks are included.
+
+## Integrate
+
+Integration instructions are available on the [wiki](https://github.com/mopub/mopub-android-sdk/wiki/Getting-Started).
+
+
+## New in this Version
+
+Please view the [changelog](https://github.com/mopub/mopub-android-sdk/blob/master/CHANGELOG.md) for details.
+
+- Updated Chartboost support to 5.3.0. This introduces a new shared class called ChartboostShared. If you are using Chartboost Custom Native Networks you will need to include this class in your build along with ChartboostInterstitial.
+
+## Requirements
+
+- Android 2.3.1 (API Version 9) and up
+- android-support-v4.jar, r22 (**Updated in 3.7.0**)
+- android-support-annotations.jar, r22 (**Updated in 3.7.0**)
+- MoPub Volley Library (mopub-volley-1.1.0.jar - available on JCenter) (**Updated in 3.6.0**)
+- **Recommended** Google Play Services 7.0.0
+
+## Upgrading from 3.2.0 and Prior
+In 3.3.0 a dependency on android-support-annotations.jar was added. If you are using Maven or Gradle to include the MoPub SDK, this dependency is included in the build scripts. For instructions on adding dependencies for Eclipse projects, see our [Getting Started Guide](https://github.com/mopub/mopub-android-sdk/wiki/Getting-Started#adding-the-support-libraries-to-your-project)
+
+## License
+
+We have launched a new license as of version 3.2.0. To view the full license, visit [http://www.mopub.com/legal/sdk-license-agreement/](http://www.mopub.com/legal/sdk-license-agreement/).
diff --git a/build.gradle b/build.gradle
index 3867c3f6..4d45b8be 100644
--- a/build.gradle
+++ b/build.gradle
@@ -7,8 +7,8 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:1.2.1'
-        classpath 'com.github.ben-manes:gradle-versions-plugin:0.9'
+        classpath 'com.android.tools.build:gradle:1.3.0-beta2'
+        classpath 'com.github.ben-manes:gradle-versions-plugin:0.10.1'
     }
 }
 
diff --git a/extras/src/com/mopub/mobileads/ChartboostInterstitial.java b/extras/src/com/mopub/mobileads/ChartboostInterstitial.java
index 136ffbac..2862ebcf 100644
--- a/extras/src/com/mopub/mobileads/ChartboostInterstitial.java
+++ b/extras/src/com/mopub/mobileads/ChartboostInterstitial.java
@@ -1,234 +1,91 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.content.Context;
-import android.util.Log;
-
-import com.chartboost.sdk.Chartboost;
-import com.chartboost.sdk.ChartboostDelegate;
-import com.mopub.common.VisibleForTesting;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import static com.chartboost.sdk.Model.CBError.CBImpressionError;
-
-/*
- * Tested with Chartboost SDK 5.0.4.
- */
-class ChartboostInterstitial extends CustomEventInterstitial {
-    /*
-     * These keys are intended for MoPub internal use. Do not modify.
-     */
-    public static final String APP_ID_KEY = "appId";
-    public static final String APP_SIGNATURE_KEY = "appSignature";
-    public static final String LOCATION_KEY = "location";
-    public static final String LOCATION_DEFAULT = "Default";
-
-    private String appId;
-    private String appSignature;
-    private String location;
-
-    /*
-     * Note: Chartboost recommends implementing their specific Activity lifecycle callbacks in your
-     * Activity's onStart(), onStop(), onBackPressed() methods for proper results. Please see their
-     * documentation for more information.
-     */
-
-    ChartboostInterstitial() {
-        location = LOCATION_DEFAULT;
-    }
-
-    static SingletonChartboostDelegate getDelegate() {
-        return SingletonChartboostDelegate.instance;
-    }
-
-    /*
-     * Abstract methods from CustomEventInterstitial
-     */
-    @Override
-    protected void loadInterstitial(Context context, CustomEventInterstitialListener interstitialListener,
-                                    Map<String, Object> localExtras, Map<String, String> serverExtras) {
-        if (!(context instanceof Activity)) {
-            interstitialListener.onInterstitialFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
-            return;
-        }
-
-        if (extrasAreValid(serverExtras)) {
-            setAppId(serverExtras.get(APP_ID_KEY));
-            setAppSignature(serverExtras.get(APP_SIGNATURE_KEY));
-            setLocation(
-                    serverExtras.containsKey(LOCATION_KEY)
-                            ? serverExtras.get(LOCATION_KEY)
-                            : LOCATION_DEFAULT);
-        } else {
-            interstitialListener.onInterstitialFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
-            return;
-        }
-
-        Activity activity = (Activity) context;
-        Chartboost.startWithAppId(activity, appId, appSignature);
-
-        if (getDelegate().hasLocation(location) &&
-                getDelegate().getListener(location) != interstitialListener) {
-            interstitialListener.onInterstitialFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
-            return;
-        }
-
-        getDelegate().registerListener(location, interstitialListener);
-        Chartboost.setDelegate(getDelegate());
-        Chartboost.setAutoCacheAds(false);
-        Chartboost.setShouldRequestInterstitialsInFirstSession(true);
-        Chartboost.setShouldDisplayLoadingViewForMoreApps(false);
-        Chartboost.onCreate(activity);
-        Chartboost.onStart(activity);
-        Chartboost.cacheInterstitial(location);
-    }
-
-    @Override
-    protected void showInterstitial() {
-        Log.d("MoPub", "Showing Chartboost interstitial ad.");
-        Chartboost.showInterstitial(location);
-    }
-
-    @Override
-    protected void onInvalidate() {
-        getDelegate().unregisterListener(location);
-    }
-
-    private void setAppId(String appId) {
-        this.appId = appId;
-    }
-
-    private void setAppSignature(String appSignature) {
-        this.appSignature = appSignature;
-    }
-
-    private void setLocation(String location) {
-        this.location = location;
-    }
-
-    private boolean extrasAreValid(Map<String, String> serverExtras) {
-        return serverExtras.containsKey(APP_ID_KEY) && serverExtras.containsKey(APP_SIGNATURE_KEY);
-    }
-
-    @VisibleForTesting
-    static class SingletonChartboostDelegate extends ChartboostDelegate {
-        private static final CustomEventInterstitialListener NULL_LISTENER = new CustomEventInterstitialListener() {
-            @Override public void onInterstitialLoaded() { }
-            @Override public void onInterstitialFailed(MoPubErrorCode errorCode) { }
-            @Override public void onInterstitialShown() { }
-            @Override public void onInterstitialClicked() { }
-            @Override public void onLeaveApplication() { }
-            @Override public void onInterstitialDismissed() { }
-        };
-        static SingletonChartboostDelegate instance = new SingletonChartboostDelegate();
-        private Map<String, CustomEventInterstitialListener> listenerForLocation =
-                new HashMap<String, CustomEventInterstitialListener>();
-
-        public void registerListener(String location, CustomEventInterstitialListener interstitialListener) {
-            listenerForLocation.put(location, interstitialListener);
-        }
-
-        public void unregisterListener(String location) {
-            listenerForLocation.remove(location);
-        }
-
-        public boolean hasLocation(String location) {
-            return listenerForLocation.containsKey(location);
-        }
-
-        /*
-         * Interstitial delegate methods
-         */
-        @Override
-        public boolean shouldDisplayInterstitial(String location) {
-            return true;
-        }
-
-        @Override
-        public boolean shouldRequestInterstitial(String location) {
-            return true;
-        }
-
-        @Override
-        public void didCacheInterstitial(String location) {
-            Log.d("MoPub", "Chartboost interstitial loaded successfully.");
-            getListener(location).onInterstitialLoaded();
-        }
-
-        @Override
-        public void didFailToLoadInterstitial(String location, CBImpressionError error) {
-            Log.d("MoPub", "Chartboost interstitial ad failed to load. Error: " + error.name());
-            getListener(location).onInterstitialFailed(MoPubErrorCode.NETWORK_NO_FILL);
-        }
-
-        @Override
-        public void didDismissInterstitial(String location) {
-            // Note that this method is fired before didCloseInterstitial and didClickInterstitial.
-            Log.d("MoPub", "Chartboost interstitial ad dismissed.");
-            getListener(location).onInterstitialDismissed();
-        }
-
-        @Override
-        public void didCloseInterstitial(String location) {
-        }
-
-        @Override
-        public void didClickInterstitial(String location) {
-            Log.d("MoPub", "Chartboost interstitial ad clicked.");
-            getListener(location).onInterstitialClicked();
-        }
-
-        @Override
-        public void didDisplayInterstitial(String location) {
-            Log.d("MoPub", "Chartboost interstitial ad shown.");
-            getListener(location).onInterstitialShown();
-        }
-
-        /*
-         * More Apps delegate methods
-         */
-        @Override
-        public boolean shouldRequestMoreApps(String location) {
-            return false;
-        }
-
-        @Override
-        public boolean shouldDisplayMoreApps(String location) {
-            return false;
-        }
-
-        @Override
-        public void didFailToLoadMoreApps(String location, CBImpressionError error) {
-        }
-
-        @Override
-        public void didCacheMoreApps(String location) {
-        }
-
-        @Override
-        public void didDismissMoreApps(String location) {
-        }
-
-        @Override
-        public void didCloseMoreApps(String location) {
-        }
-
-        @Override
-        public void didClickMoreApps(String location) {
-        }
-
-        CustomEventInterstitialListener getListener(String location) {
-            CustomEventInterstitialListener listener = listenerForLocation.get(location);
-            return listener != null ? listener : NULL_LISTENER;
-        }
-    }
-
-    @VisibleForTesting
-    @Deprecated
-    public static void resetDelegate() {
-        SingletonChartboostDelegate.instance = new SingletonChartboostDelegate();
-    }
-
-}
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.chartboost.sdk.Chartboost;
+import com.mopub.common.Preconditions;
+
+import java.util.Map;
+
+/**
+ * A custom event for showing Chartboost interstitial ads.
+ *
+ * Certified with Chartboost 5.3.0
+ */
+class ChartboostInterstitial extends CustomEventInterstitial {
+
+    @NonNull
+    private String mLocation = ChartboostShared.LOCATION_DEFAULT;
+
+    /*
+     * Note: Chartboost recommends implementing their specific Activity lifecycle callbacks in your
+     * Activity's onStart(), onStop(), onBackPressed() methods for proper results. Please see their
+     * documentation for more information.
+     */
+
+    /*
+     * Abstract methods from CustomEventInterstitial
+     */
+    @Override
+    protected void loadInterstitial(@NonNull Context context,
+            @NonNull CustomEventInterstitialListener interstitialListener,
+            @NonNull Map<String, Object> localExtras, @NonNull Map<String, String> serverExtras) {
+        Preconditions.checkNotNull(context);
+        Preconditions.checkNotNull(interstitialListener);
+        Preconditions.checkNotNull(localExtras);
+        Preconditions.checkNotNull(serverExtras);
+
+        if (!(context instanceof Activity)) {
+            interstitialListener.onInterstitialFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
+            return;
+        }
+
+        if (serverExtras.containsKey(ChartboostShared.LOCATION_KEY)) {
+            String location = serverExtras.get(ChartboostShared.LOCATION_KEY);
+            mLocation = TextUtils.isEmpty(location) ? mLocation : location;
+        }
+
+        // If there's already a listener for this location, then another instance of
+        // CustomEventInterstitial is still active and we should fail.
+        if (ChartboostShared.getDelegate().hasInterstitialLocation(mLocation) &&
+                ChartboostShared.getDelegate().getInterstitialListener(mLocation) != interstitialListener) {
+            interstitialListener.onInterstitialFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
+            return;
+        }
+
+        Activity activity = (Activity) context;
+        try {
+            ChartboostShared.initializeSdk(activity, serverExtras);
+            ChartboostShared.getDelegate().registerInterstitialListener(mLocation, interstitialListener);
+        } catch (NullPointerException e) {
+            interstitialListener.onInterstitialFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
+            return;
+        } catch (IllegalStateException e) {
+            interstitialListener.onInterstitialFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
+            return;
+        }
+
+        Chartboost.onCreate(activity);
+        Chartboost.onStart(activity);
+        if (Chartboost.hasInterstitial(mLocation)) {
+            ChartboostShared.getDelegate().didCacheInterstitial(mLocation);
+        } else {
+            Chartboost.cacheInterstitial(mLocation);
+        }
+    }
+
+    @Override
+    protected void showInterstitial() {
+        Log.d("MoPub", "Showing Chartboost interstitial ad.");
+        Chartboost.showInterstitial(mLocation);
+    }
+
+    @Override
+    protected void onInvalidate() {
+        ChartboostShared.getDelegate().unregisterInterstitialListener(mLocation);
+    }
+}
diff --git a/extras/src/com/mopub/mobileads/ChartboostRewardedVideo.java b/extras/src/com/mopub/mobileads/ChartboostRewardedVideo.java
index d3fad390..619271b8 100644
--- a/extras/src/com/mopub/mobileads/ChartboostRewardedVideo.java
+++ b/extras/src/com/mopub/mobileads/ChartboostRewardedVideo.java
@@ -1,278 +1,176 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.os.Handler;
-import android.support.annotation.NonNull;
-import com.chartboost.sdk.Chartboost;
-import com.chartboost.sdk.ChartboostDelegate;
-import com.chartboost.sdk.Model.CBError;
-import com.mopub.common.DataKeys;
-import com.mopub.common.LifecycleListener;
-import com.mopub.common.MediationSettings;
-import com.mopub.common.MoPubReward;
-import com.mopub.common.VisibleForTesting;
-import com.mopub.common.logging.MoPubLog;
-
-import java.util.*;
-
-import static com.mopub.mobileads.MoPubErrorCode.VIDEO_DOWNLOAD_ERROR;
-
-/**
- * A custom event for showing Chartboost rewarded videos.
- *
- * Certified with Chartboost 5.0.4
- */
-public class ChartboostRewardedVideo extends CustomEventRewardedVideo {
-    public static final String APP_ID_KEY = "appId";
-    public static final String APP_SIGNATURE_KEY = "appSignature";
-    public static final String LOCATION_KEY = "location";
-    public static final String LOCATION_DEFAULT = "Default";
-
-    @NonNull private static final SingletonChartboostDelegate sSingletonChartboostDelegate =
-            new SingletonChartboostDelegate();
-    @NonNull private static final LifecycleListener sLifecycleListener =
-            new ChartboostLifecycleListener();
-    private static boolean sInitialized = false;
-
-    @NonNull private String mLocation = LOCATION_DEFAULT;
-    @NonNull private final Handler mHandler;
-
-    public ChartboostRewardedVideo() {
-        mHandler = new Handler();
-    }
-
-    @Override
-    @NonNull
-    public CustomEventRewardedVideoListener getVideoListenerForSdk() {
-        return sSingletonChartboostDelegate;
-    }
-
-    @Override
-    @NonNull
-    public LifecycleListener getLifecycleListener() {
-        return sLifecycleListener;
-    }
-
-    @Override
-    @NonNull
-    public String getAdNetworkId() {
-        return mLocation;
-    }
-
-    @Override
-    public boolean checkAndInitializeSdk(@NonNull Activity launcherActivity,
-            @NonNull Map<String, Object> localExtras,
-            @NonNull Map<String, String> serverExtras) throws Exception {
-        synchronized (ChartboostRewardedVideo.class) {
-            if (sInitialized) {
-                return false;
-            }
-
-            if (!serverExtras.containsKey(APP_ID_KEY)) {
-                throw new IllegalStateException("Chartboost rewarded video initialization" +
-                        " failed due to missing application ID.");
-            }
-
-            if (!serverExtras.containsKey(APP_SIGNATURE_KEY)) {
-                throw new IllegalStateException("Chartboost rewarded video initialization" +
-                        " failed due to missing application signature.");
-            }
-
-            final String appId = serverExtras.get(APP_ID_KEY);
-            final String appSignature = serverExtras.get(APP_SIGNATURE_KEY);
-
-            Chartboost.startWithAppId(launcherActivity, appId, appSignature);
-            Chartboost.setDelegate(sSingletonChartboostDelegate);
-
-            sInitialized = true;
-            return true;
-        }
-    }
-
-    @Override
-    protected void loadWithSdkInitialized(@NonNull Activity activity,
-            @NonNull Map<String, Object> localExtras, @NonNull Map<String, String> serverExtras)
-            throws Exception {
-        if (serverExtras.containsKey(LOCATION_KEY)) {
-            mLocation = serverExtras.get(LOCATION_KEY);
-        } else {
-            mLocation = LOCATION_DEFAULT;
-        }
-
-        sSingletonChartboostDelegate.mLocationsToLoad.add(mLocation);
-        setUpMediationSettingsForRequest((String) localExtras.get(DataKeys.AD_UNIT_ID_KEY));
-
-        // We do this to ensure that the custom event manager has a chance to get the listener
-        // and ad unit ID before and delegate callbacks are made.
-        mHandler.post(new Runnable() {
-            public void run() {
-                Chartboost.cacheRewardedVideo(mLocation);
-            }
-        });
-    }
-
-    private void setUpMediationSettingsForRequest(String moPubId) {
-        final ChartboostMediationSettings globalSettings =
-                MoPubRewardedVideoManager.getGlobalMediationSettings(ChartboostMediationSettings.class);
-        final ChartboostMediationSettings instanceSettings =
-                MoPubRewardedVideoManager.getInstanceMediationSettings(ChartboostMediationSettings.class, moPubId);
-
-        // Instance settings override global settings.
-        if (instanceSettings != null) {
-            Chartboost.setCustomId(instanceSettings.getCustomId());
-        } else if (globalSettings != null) {
-            Chartboost.setCustomId(globalSettings.getCustomId());
-        }
-    }
-
-    @Override
-    public boolean hasVideoAvailable() {
-        return Chartboost.hasRewardedVideo(mLocation);
-    }
-
-    @Override
-    public void showVideo() {
-        if (hasVideoAvailable()) {
-            Chartboost.showRewardedVideo(mLocation);
-        } else {
-            MoPubLog.d("Attempted to show Chartboost rewarded video before it was available.");
-        }
-    }
-
-    @Override
-    protected void onInvalidate() {
-        // This prevents sending didCache or didFailToCache callbacks.
-        sSingletonChartboostDelegate.mLocationsToLoad.remove(mLocation);
-    }
-
-    private static final class SingletonChartboostDelegate extends ChartboostDelegate
-            implements CustomEventRewardedVideoListener {
-
-        private Set<String> mLocationsToLoad = Collections.synchronizedSet(new TreeSet<String>());
-
-        @Override
-        public boolean shouldDisplayRewardedVideo(String location) {
-            return super.shouldDisplayRewardedVideo(location);
-        }
-
-        @Override
-        public void didCacheRewardedVideo(String location) {
-            super.didCacheRewardedVideo(location);
-
-            if (mLocationsToLoad.contains(location)) {
-                MoPubLog.d("Chartboost rewarded video cached for location " + location + ".");
-                MoPubRewardedVideoManager.onRewardedVideoLoadSuccess(ChartboostRewardedVideo.class, location);
-                mLocationsToLoad.remove(location);
-            }
-        }
-
-        @Override
-        public void didFailToLoadRewardedVideo(String location, CBError.CBImpressionError error) {
-            super.didFailToLoadRewardedVideo(location, error);
-
-            if (mLocationsToLoad.contains(location)) {
-                MoPubLog.d("Chartboost rewarded video cache failed for location " + location + ".");
-                MoPubRewardedVideoManager.onRewardedVideoLoadFailure(ChartboostRewardedVideo.class, location, VIDEO_DOWNLOAD_ERROR);
-                mLocationsToLoad.remove(location);
-            }
-        }
-
-        @Override
-        public void didDismissRewardedVideo(String location) {
-            // This is called before didCloseRewardedVideo and didClickRewardedVideo
-            super.didDismissRewardedVideo(location);
-            MoPubRewardedVideoManager.onRewardedVideoClosed(ChartboostRewardedVideo.class, location);
-            MoPubLog.d("Chartboost rewarded video dismissed for location " + location + ".");
-        }
-
-        @Override
-        public void didCloseRewardedVideo(String location) {
-            super.didCloseRewardedVideo(location);
-            MoPubLog.d("Chartboost rewarded video closed for location " + location + ".");
-        }
-
-        @Override
-        public void didClickRewardedVideo(String location) {
-            super.didClickRewardedVideo(location);
-            MoPubRewardedVideoManager.onRewardedVideoClicked(ChartboostRewardedVideo.class, location);
-            MoPubLog.d("Chartboost rewarded video clicked for location " + location + ".");
-        }
-
-        @Override
-        public void didCompleteRewardedVideo(String location, int reward) {
-            super.didCompleteRewardedVideo(location, reward);
-            MoPubLog.d("Chartboost rewarded video completed for location " + location + " with "
-                    + "reward amount " + reward);
-            MoPubRewardedVideoManager.onRewardedVideoCompleted(
-                    ChartboostRewardedVideo.class,
-                    location,
-                    MoPubReward.success(MoPubReward.NO_REWARD_LABEL, reward));
-        }
-
-        @Override
-        public void didDisplayRewardedVideo(String location) {
-            super.didDisplayRewardedVideo(location);
-            MoPubLog.d("Chartboost rewarded video displayed for location " + location + ".");
-            MoPubRewardedVideoManager.onRewardedVideoStarted(ChartboostRewardedVideo.class, location);
-        }
-    }
-
-    private static final class ChartboostLifecycleListener implements LifecycleListener {
-        @Override
-        public void onCreate(@NonNull Activity activity) {
-            Chartboost.onCreate(activity);
-        }
-
-        @Override
-        public void onStart(@NonNull Activity activity) {
-            Chartboost.onStart(activity);
-        }
-
-        @Override
-        public void onPause(@NonNull Activity activity) {
-            Chartboost.onPause(activity);
-        }
-
-        @Override
-        public void onResume(@NonNull Activity activity) {
-            Chartboost.onResume(activity);
-        }
-
-        @Override
-        public void onRestart(@NonNull Activity activity) {
-        }
-
-        @Override
-        public void onStop(@NonNull Activity activity) {
-            Chartboost.onStop(activity);
-        }
-
-        @Override
-        public void onDestroy(@NonNull Activity activity) {
-            Chartboost.onDestroy(activity);
-        }
-
-        @Override
-        public void onBackPressed(@NonNull Activity activity) {
-            Chartboost.onBackPressed();
-        }
-    }
-
-    public static final class ChartboostMediationSettings implements MediationSettings {
-        @NonNull private final String mCustomId;
-
-        public ChartboostMediationSettings(@NonNull final String customId) {
-            mCustomId = customId;
-        }
-
-        @NonNull public String getCustomId() {
-            return mCustomId;
-        }
-    }
-
-    @Deprecated // for testing
-    @VisibleForTesting
-    static void resetInitialization() {
-        sInitialized = false;
-    }
-}
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.os.Handler;
+import android.support.annotation.NonNull;
+import android.text.TextUtils;
+
+import com.chartboost.sdk.Chartboost;
+import com.mopub.common.DataKeys;
+import com.mopub.common.LifecycleListener;
+import com.mopub.common.MediationSettings;
+import com.mopub.common.logging.MoPubLog;
+
+import java.util.Map;
+
+/**
+ * A custom event for showing Chartboost rewarded videos.
+ *
+ * Certified with Chartboost 5.3.0
+ */
+public class ChartboostRewardedVideo extends CustomEventRewardedVideo {
+    @NonNull private static final LifecycleListener sLifecycleListener =
+            new ChartboostLifecycleListener();
+
+    @NonNull private String mLocation = ChartboostShared.LOCATION_DEFAULT;
+    @NonNull private final Handler mHandler;
+
+    public ChartboostRewardedVideo() {
+        mHandler = new Handler();
+    }
+
+    @Override
+    @NonNull
+    public CustomEventRewardedVideoListener getVideoListenerForSdk() {
+        return ChartboostShared.getDelegate();
+    }
+
+    @Override
+    @NonNull
+    public LifecycleListener getLifecycleListener() {
+        return sLifecycleListener;
+    }
+
+    @Override
+    @NonNull
+    public String getAdNetworkId() {
+        return mLocation;
+    }
+
+    @Override
+    public boolean checkAndInitializeSdk(@NonNull Activity launcherActivity,
+            @NonNull Map<String, Object> localExtras,
+            @NonNull Map<String, String> serverExtras) throws Exception {
+        // We need to attempt to reinitialize Chartboost on each request, in case an interstitial has been
+        // loaded and used since then.
+        ChartboostShared.initializeSdk(launcherActivity, serverExtras);  // throws IllegalStateException
+
+        // Always return true so that the lifecycle listener is registered even if an interstitial
+        // did the initialization.
+        return true;
+    }
+
+    @Override
+    protected void loadWithSdkInitialized(@NonNull Activity activity,
+            @NonNull Map<String, Object> localExtras, @NonNull Map<String, String> serverExtras)
+            throws Exception {
+
+        if (serverExtras.containsKey(ChartboostShared.LOCATION_KEY)) {
+            String location = serverExtras.get(ChartboostShared.LOCATION_KEY);
+            mLocation = TextUtils.isEmpty(location) ? mLocation : location;
+        }
+
+        ChartboostShared.getDelegate().registerRewardedVideoLocation(mLocation);
+        setUpMediationSettingsForRequest((String) localExtras.get(DataKeys.AD_UNIT_ID_KEY));
+
+        // We do this to ensure that the custom event manager has a chance to get the listener
+        // and ad unit ID before any delegate callbacks are made.
+        mHandler.post(new Runnable() {
+            public void run() {
+                if (Chartboost.hasRewardedVideo(mLocation)) {
+                    ChartboostShared.getDelegate().didCacheRewardedVideo(mLocation);
+                } else {
+                    Chartboost.cacheRewardedVideo(mLocation);
+                }
+            }
+        });
+    }
+
+    private void setUpMediationSettingsForRequest(String moPubId) {
+        final ChartboostMediationSettings globalSettings =
+                MoPubRewardedVideoManager.getGlobalMediationSettings(ChartboostMediationSettings.class);
+        final ChartboostMediationSettings instanceSettings =
+                MoPubRewardedVideoManager.getInstanceMediationSettings(ChartboostMediationSettings.class, moPubId);
+
+        // Instance settings override global settings.
+        if (instanceSettings != null) {
+            Chartboost.setCustomId(instanceSettings.getCustomId());
+        } else if (globalSettings != null) {
+            Chartboost.setCustomId(globalSettings.getCustomId());
+        }
+    }
+
+    @Override
+    public boolean hasVideoAvailable() {
+        return Chartboost.hasRewardedVideo(mLocation);
+    }
+
+    @Override
+    public void showVideo() {
+        if (hasVideoAvailable()) {
+            Chartboost.showRewardedVideo(mLocation);
+        } else {
+            MoPubLog.d("Attempted to show Chartboost rewarded video before it was available.");
+        }
+    }
+
+    @Override
+    protected void onInvalidate() {
+        // This prevents sending didCache or didFailToCache callbacks.
+        ChartboostShared.getDelegate().unregisterRewardedVideoLocation(mLocation);
+    }
+
+    private static final class ChartboostLifecycleListener implements LifecycleListener {
+        @Override
+        public void onCreate(@NonNull Activity activity) {
+            Chartboost.onCreate(activity);
+        }
+
+        @Override
+        public void onStart(@NonNull Activity activity) {
+            Chartboost.onStart(activity);
+        }
+
+        @Override
+        public void onPause(@NonNull Activity activity) {
+            Chartboost.onPause(activity);
+        }
+
+        @Override
+        public void onResume(@NonNull Activity activity) {
+            Chartboost.onResume(activity);
+        }
+
+        @Override
+        public void onRestart(@NonNull Activity activity) {
+        }
+
+        @Override
+        public void onStop(@NonNull Activity activity) {
+            Chartboost.onStop(activity);
+        }
+
+        @Override
+        public void onDestroy(@NonNull Activity activity) {
+            Chartboost.onDestroy(activity);
+        }
+
+        @Override
+        public void onBackPressed(@NonNull Activity activity) {
+            Chartboost.onBackPressed();
+        }
+    }
+
+    public static final class ChartboostMediationSettings implements MediationSettings {
+        @NonNull private final String mCustomId;
+
+        public ChartboostMediationSettings(@NonNull final String customId) {
+            mCustomId = customId;
+        }
+
+        @NonNull
+        public String getCustomId() {
+            return mCustomId;
+        }
+    }
+}
diff --git a/extras/src/com/mopub/mobileads/ChartboostShared.java b/extras/src/com/mopub/mobileads/ChartboostShared.java
new file mode 100644
index 00000000..e146f15a
--- /dev/null
+++ b/extras/src/com/mopub/mobileads/ChartboostShared.java
@@ -0,0 +1,296 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.Log;
+
+import com.chartboost.sdk.Chartboost;
+import com.chartboost.sdk.ChartboostDelegate;
+import com.chartboost.sdk.Model.CBError;
+import com.mopub.common.MoPubReward;
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
+
+import java.util.Collections;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeMap;
+import java.util.TreeSet;
+
+import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR;
+import static com.mopub.mobileads.MoPubErrorCode.VIDEO_DOWNLOAD_ERROR;
+
+/**
+ * Shared infrastructure for initializing the Chartboost SDK when mediated by MoPub
+ *
+ * Certified with Chartboost 5.3.0
+ */
+public class ChartboostShared {
+    private static volatile ChartboostSingletonDelegate sDelegate = new ChartboostSingletonDelegate();
+
+    /*
+     * These keys are intended for MoPub internal use. Do not modify.
+     */
+    public static final String APP_ID_KEY = "appId";
+    public static final String APP_SIGNATURE_KEY = "appSignature";
+    public static final String LOCATION_KEY = "location";
+    public static final String LOCATION_DEFAULT = "Default";
+
+    @Nullable private static String mAppId;
+    @Nullable private static String mAppSignature;
+
+    /**
+     * Initialize the Chartboost SDK for the provided application id and app signature.
+     */
+    public static synchronized boolean initializeSdk(@NonNull Activity launcherActivity,
+            @NonNull Map<String, String> serverExtras) {
+        Preconditions.checkNotNull(launcherActivity);
+        Preconditions.checkNotNull(serverExtras);
+
+        // Validate Chartboost args
+        if (!serverExtras.containsKey(APP_ID_KEY)) {
+            throw new IllegalStateException("Chartboost rewarded video initialization" +
+                    " failed due to missing application ID.");
+        }
+
+        if (!serverExtras.containsKey(APP_SIGNATURE_KEY)) {
+            throw new IllegalStateException("Chartboost rewarded video initialization" +
+                    " failed due to missing application signature.");
+        }
+
+        final String appId = serverExtras.get(APP_ID_KEY);
+        final String appSignature = serverExtras.get(APP_SIGNATURE_KEY);
+
+        if (appId.equals(mAppId) && appSignature.equals(mAppSignature)) {
+            // We don't need to reinitialize.
+            return false;
+        }
+
+        mAppId = appId;
+        mAppSignature = appSignature;
+
+        // Perform all the common SDK initialization steps including startAppWithId
+        Chartboost.startWithAppId(launcherActivity, mAppId, mAppSignature);
+        Chartboost.setImpressionsUseActivities(false);
+        Chartboost.setFramework(Chartboost.CBFramework.CBFrameworkMoPub);
+        Chartboost.setDelegate(sDelegate);
+        Chartboost.setShouldRequestInterstitialsInFirstSession(true);
+        Chartboost.setAutoCacheAds(false);
+        Chartboost.setShouldDisplayLoadingViewForMoreApps(false);
+
+        // Callers of this method need to call onCreate & onStart themselves.
+        return true;
+    }
+
+    @NonNull
+    public static ChartboostSingletonDelegate getDelegate() {
+        return sDelegate;
+    }
+
+    /**
+     * A {@link ChartboostDelegate} that can forward events for Chartboost interstitials
+     * and rewarded videos to the appropriate listener based on the Chartboost location used.
+     */
+    public static class ChartboostSingletonDelegate extends ChartboostDelegate
+            implements CustomEventRewardedVideo.CustomEventRewardedVideoListener {
+        private static final CustomEventInterstitialListener NULL_LISTENER =
+                new CustomEventInterstitialListener() {
+                    @Override
+                    public void onInterstitialLoaded() { }
+
+                    @Override
+                    public void onInterstitialFailed(MoPubErrorCode errorCode) { }
+
+                    @Override
+                    public void onInterstitialShown() { }
+
+                    @Override
+                    public void onInterstitialClicked() { }
+
+                    @Override
+                    public void onLeaveApplication() { }
+
+                    @Override
+                    public void onInterstitialDismissed() { }
+                };
+
+        //***************
+        // Chartboost Location Management for interstitials and rewarded videos
+        //***************
+
+        private Map<String, CustomEventInterstitialListener> mInterstitialListenersForLocation
+                = Collections.synchronizedMap(new TreeMap<String, CustomEventInterstitialListener>());
+
+        private Set<String> mRewardedVideoLocationsToLoad = Collections.synchronizedSet(new TreeSet<String>());
+
+        public void registerInterstitialListener(@NonNull String location,
+                @NonNull CustomEventInterstitialListener interstitialListener) {
+            Preconditions.checkNotNull(location);
+            Preconditions.checkNotNull(interstitialListener);
+            mInterstitialListenersForLocation.put(location, interstitialListener);
+        }
+
+        public void unregisterInterstitialListener(@NonNull String location) {
+            Preconditions.checkNotNull(location);
+            mInterstitialListenersForLocation.remove(location);
+        }
+
+        public void registerRewardedVideoLocation(@NonNull String location) {
+            Preconditions.checkNotNull(location);
+            mRewardedVideoLocationsToLoad.add(location);
+        }
+
+        public void unregisterRewardedVideoLocation(@NonNull String location) {
+            Preconditions.checkNotNull(location);
+            mRewardedVideoLocationsToLoad.remove(location);
+        }
+
+        @NonNull
+        public CustomEventInterstitialListener getInterstitialListener(@NonNull String location) {
+            final CustomEventInterstitialListener listener = mInterstitialListenersForLocation.get(location);
+            return listener != null ? listener : NULL_LISTENER;
+        }
+
+        public boolean hasInterstitialLocation(@NonNull String location) {
+            return mInterstitialListenersForLocation.containsKey(location);
+        }
+
+        //******************
+        // Chartboost Delegate methods.
+        //******************
+
+        //******************
+        // Interstitials
+        //******************
+        @Override
+        public void didCacheInterstitial(String location) {
+            MoPubLog.d("Chartboost interstitial loaded successfully.");
+            getInterstitialListener(location).onInterstitialLoaded();
+        }
+
+        @Override
+        public void didFailToLoadInterstitial(String location, CBError.CBImpressionError error) {
+            String suffix = error != null ? "Error: " + error.name() : "";
+            Log.d("MoPub", "Chartboost interstitial ad failed to load." + suffix);
+            getInterstitialListener(location).onInterstitialFailed(MoPubErrorCode.NETWORK_NO_FILL);
+        }
+
+        @Override
+        public void didDismissInterstitial(String location) {
+            // Note that this method is fired before didCloseInterstitial and didClickInterstitial.
+            MoPubLog.d("Chartboost interstitial ad dismissed.");
+            getInterstitialListener(location).onInterstitialDismissed();
+        }
+
+        @Override
+        public void didCloseInterstitial(String location) {
+            MoPubLog.d("Chartboost interstitial ad closed.");
+        }
+
+        @Override
+        public void didClickInterstitial(String location) {
+            MoPubLog.d("Chartboost interstitial ad clicked.");
+            getInterstitialListener(location).onInterstitialClicked();
+        }
+
+        @Override
+        public void didDisplayInterstitial(String location) {
+            MoPubLog.d("Chartboost interstitial ad shown.");
+            getInterstitialListener(location).onInterstitialShown();
+        }
+
+        //******************
+        // Rewarded Videos
+        //******************
+        @Override
+        public void didCacheRewardedVideo(String location) {
+            super.didCacheRewardedVideo(location);
+
+            if (mRewardedVideoLocationsToLoad.contains(location)) {
+                MoPubLog.d("Chartboost rewarded video cached for location " + location + ".");
+                MoPubRewardedVideoManager.onRewardedVideoLoadSuccess(ChartboostRewardedVideo.class, location);
+                mRewardedVideoLocationsToLoad.remove(location);
+            }
+        }
+
+        @Override
+        public void didFailToLoadRewardedVideo(String location, CBError.CBImpressionError error) {
+            super.didFailToLoadRewardedVideo(location, error);
+            String suffix = error != null ? " with error: " + error.name() : "";
+            if (mRewardedVideoLocationsToLoad.contains(location)) {
+                MoPubErrorCode errorCode = VIDEO_DOWNLOAD_ERROR;
+                MoPubLog.d("Chartboost rewarded video cache failed for location " + location + suffix);
+                if (CBError.CBImpressionError.INVALID_LOCATION.equals(error)) {
+                    errorCode = ADAPTER_CONFIGURATION_ERROR;
+                }
+                MoPubRewardedVideoManager.onRewardedVideoLoadFailure(ChartboostRewardedVideo.class, location, errorCode);
+                mRewardedVideoLocationsToLoad.remove(location);
+            }
+        }
+
+        @Override
+        public void didDismissRewardedVideo(String location) {
+            // This is called before didCloseRewardedVideo and didClickRewardedVideo
+            super.didDismissRewardedVideo(location);
+            MoPubRewardedVideoManager.onRewardedVideoClosed(ChartboostRewardedVideo.class, location);
+            MoPubLog.d("Chartboost rewarded video dismissed for location " + location + ".");
+        }
+
+        @Override
+        public void didCloseRewardedVideo(String location) {
+            super.didCloseRewardedVideo(location);
+            MoPubLog.d("Chartboost rewarded video closed for location " + location + ".");
+        }
+
+        @Override
+        public void didClickRewardedVideo(String location) {
+            super.didClickRewardedVideo(location);
+            MoPubRewardedVideoManager.onRewardedVideoClicked(ChartboostRewardedVideo.class, location);
+            MoPubLog.d("Chartboost rewarded video clicked for location " + location + ".");
+        }
+
+        @Override
+        public void didCompleteRewardedVideo(String location, int reward) {
+            super.didCompleteRewardedVideo(location, reward);
+            MoPubLog.d("Chartboost rewarded video completed for location " + location + " with "
+                    + "reward amount " + reward);
+            MoPubRewardedVideoManager.onRewardedVideoCompleted(
+                    ChartboostRewardedVideo.class,
+                    location,
+                    MoPubReward.success(MoPubReward.NO_REWARD_LABEL, reward));
+        }
+
+        @Override
+        public void didDisplayRewardedVideo(String location) {
+            super.didDisplayRewardedVideo(location);
+            MoPubLog.d("Chartboost rewarded video displayed for location " + location + ".");
+            MoPubRewardedVideoManager.onRewardedVideoStarted(ChartboostRewardedVideo.class, location);
+        }
+
+        //******************
+        // More Apps
+        //******************
+        @Override
+        public boolean shouldRequestMoreApps(String location) {
+            return false;
+        }
+
+        @Override
+        public boolean shouldDisplayMoreApps(final String location) {
+            return false;
+        }
+    }
+
+
+    @VisibleForTesting
+    @Deprecated
+    static void reset() {
+        // Clears all the locations to load and other state.
+        sDelegate = new ChartboostSingletonDelegate();
+        mAppId = null;
+        mAppSignature = null;
+    }
+}
diff --git a/mopub-sample/AndroidManifest.xml b/mopub-sample/AndroidManifest.xml
index b178216a..0c23ce4c 100644
--- a/mopub-sample/AndroidManifest.xml
+++ b/mopub-sample/AndroidManifest.xml
@@ -1,39 +1,39 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-      package="com.mopub.simpleadsdemo"
-      android:versionCode="24"
-      android:versionName="3.7.0">
-    <uses-sdk android:minSdkVersion="9"
-              android:targetSdkVersion="22"/>
-
-    <uses-permission android:name="android.permission.INTERNET" />
-    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
-    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
-
-
-    <!-- For MRAID 2 -->
-    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
-
-    <application android:icon="@drawable/icon" android:label="@string/app_name">
-	    <activity android:name="com.mopub.simpleadsdemo.MoPubSampleActivity"
-	            android:label="@string/app_name"
-                android:configChanges="orientation|screenSize">
-	        <intent-filter>
-	            <action android:name="android.intent.action.MAIN" />
-	            <category android:name="android.intent.category.LAUNCHER" />
-	        </intent-filter>
-	    </activity>
-        <activity android:name="com.mopub.mobileads.MoPubActivity"
-                android:configChanges="keyboardHidden|orientation|screenSize"/>
-        <activity android:name="com.mopub.mobileads.MraidActivity"
-                android:configChanges="keyboardHidden|orientation|screenSize"/>
-        <activity android:name="com.mopub.common.MoPubBrowser"
-                android:configChanges="keyboardHidden|orientation|screenSize"/>
-        <activity android:name="com.mopub.mobileads.MraidVideoPlayerActivity"
-                android:configChanges="keyboardHidden|orientation|screenSize"/>
-
-        <meta-data android:name="com.google.android.gms.version"
-                   android:value="@integer/google_play_services_version" />
-    </application>
-
-</manifest>
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+      package="com.mopub.simpleadsdemo"
+      android:versionCode="25"
+      android:versionName="3.8.0">
+    <uses-sdk android:minSdkVersion="9" 
+              android:targetSdkVersion="22"/>
+
+    <uses-permission android:name="android.permission.INTERNET" />
+    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
+
+
+    <!-- For MRAID 2 -->
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
+
+    <application android:icon="@drawable/icon" android:label="@string/app_name">
+	    <activity android:name="com.mopub.simpleadsdemo.MoPubSampleActivity"
+	            android:label="@string/app_name"
+                android:configChanges="orientation|screenSize">
+	        <intent-filter>
+	            <action android:name="android.intent.action.MAIN" />
+	            <category android:name="android.intent.category.LAUNCHER" />
+	        </intent-filter>
+	    </activity>
+        <activity android:name="com.mopub.mobileads.MoPubActivity"
+                android:configChanges="keyboardHidden|orientation|screenSize"/>
+        <activity android:name="com.mopub.mobileads.MraidActivity"
+                android:configChanges="keyboardHidden|orientation|screenSize"/>
+        <activity android:name="com.mopub.common.MoPubBrowser"
+                android:configChanges="keyboardHidden|orientation|screenSize"/>
+        <activity android:name="com.mopub.mobileads.MraidVideoPlayerActivity"
+                android:configChanges="keyboardHidden|orientation|screenSize"/>
+
+        <meta-data android:name="com.google.android.gms.version"
+                   android:value="@integer/google_play_services_version" />
+    </application>
+
+</manifest>
diff --git a/mopub-sample/build.gradle b/mopub-sample/build.gradle
index d5520551..c9bb0ed9 100644
--- a/mopub-sample/build.gradle
+++ b/mopub-sample/build.gradle
@@ -1,57 +1,57 @@
-repositories {
-    jcenter()
-}
-
-apply plugin: 'com.android.application'
-
-group = 'com.mopub'
-
-description = '''MoPub SDK'''
-
-android {
-    compileSdkVersion 22
-    buildToolsVersion '22.0.1'
-
-    defaultConfig {
-        versionCode 24
-        versionName "3.7.0"
-        minSdkVersion 9
-        targetSdkVersion 22
-    }
-
-    buildTypes {
-      release {
-        minifyEnabled true
-        proguardFiles = [getDefaultProguardFile('proguard-android.txt'), 'proguard.cfg']
-      }
-      debug {
-        minifyEnabled true
-        proguardFiles = [getDefaultProguardFile('proguard-android.txt'), 'proguard.cfg']
-      }
-    }
-
-    sourceSets {
-        main {
-            manifest.srcFile 'AndroidManifest.xml'
-            java.srcDirs = ['src/main']
-            resources.srcDirs = ['src/main']
-            aidl.srcDirs = ['src/main']
-            renderscript.srcDirs = ['src/main']
-            res.srcDirs = ['res']
-            assets.srcDirs = ['assets']
-        }
-
-        androidTest.setRoot('src/test')
-    }
-
-    // Note: You will also need a local.properties file to set the location of the SDK in the same 
-    // way that the existing SDK requires, using the sdk.dir property.
-    // Alternatively, you can set an environment variable called ANDROID_HOME. There is no 
-    // difference between the two methods, you can use the one you prefer.
-}
-
-dependencies {
-    compile 'com.android.support:support-v4:22.1.1'
-    compile 'com.google.android.gms:play-services-ads:7.3.0'
-    compile project(':mopub-sdk')
-}
+repositories {
+    jcenter()
+}
+
+apply plugin: 'com.android.application'
+
+group = 'com.mopub'
+
+description = '''MoPub SDK'''
+
+android {
+    compileSdkVersion 22
+    buildToolsVersion '22.0.1'
+
+    defaultConfig {
+        versionCode 25
+        versionName "3.8.0"
+        minSdkVersion 9
+        targetSdkVersion 22
+    }
+
+    buildTypes {
+      release {
+        minifyEnabled true
+        proguardFiles = [getDefaultProguardFile('proguard-android.txt'), 'proguard.cfg']
+      }
+      debug {
+        minifyEnabled true
+        proguardFiles = [getDefaultProguardFile('proguard-android.txt'), 'proguard.cfg']
+      }
+    }
+
+    sourceSets {
+        main {
+            manifest.srcFile 'AndroidManifest.xml'
+            java.srcDirs = ['src/main']
+            resources.srcDirs = ['src/main']
+            aidl.srcDirs = ['src/main']
+            renderscript.srcDirs = ['src/main']
+            res.srcDirs = ['res']
+            assets.srcDirs = ['assets']
+        }
+
+        androidTest.setRoot('src/test')
+    }
+
+    // Note: You will also need a local.properties file to set the location of the SDK in the same 
+    // way that the existing SDK requires, using the sdk.dir property.
+    // Alternatively, you can set an environment variable called ANDROID_HOME. There is no 
+    // difference between the two methods, you can use the one you prefer.
+}
+
+dependencies {
+    compile 'com.android.support:support-v4:22.1.1'
+    compile 'com.google.android.gms:play-services-ads:7.3.0'
+    compile project(':mopub-sdk')
+}
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSQLiteHelper.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSQLiteHelper.java
index 72ec4a81..40b417fb 100644
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSQLiteHelper.java
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSQLiteHelper.java
@@ -1,116 +1,116 @@
-package com.mopub.simpleadsdemo;
-
-import android.content.ContentValues;
-import android.content.Context;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteOpenHelper;
-import android.util.Log;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import static com.mopub.simpleadsdemo.MoPubSampleAdUnit.AdType.BANNER;
-import static com.mopub.simpleadsdemo.MoPubSampleAdUnit.AdType.CUSTOM_NATIVE;
-import static com.mopub.simpleadsdemo.MoPubSampleAdUnit.AdType.INTERSTITIAL;
-import static com.mopub.simpleadsdemo.MoPubSampleAdUnit.AdType.LIST_VIEW;
-import static com.mopub.simpleadsdemo.MoPubSampleAdUnit.AdType.MRECT;
-
-class MoPubSQLiteHelper extends SQLiteOpenHelper {
-    public static final String TABLE_AD_CONFIGURATIONS = "adConfigurations";
-    public static final String COLUMN_ID = "_id";
-    public static final String COLUMN_AD_UNIT_ID = "adUnitId";
-    public static final String COLUMN_DESCRIPTION = "description";
-    public static final String COLUMN_USER_GENERATED = "userGenerated";
-    public static final String COLUMN_AD_TYPE = "adType";
-
-    private static final String DATABASE_NAME = "savedConfigurations.db";
-    private static final int DATABASE_VERSION = 1;
-
-    private static final String DATABASE_CREATE = "create table " + TABLE_AD_CONFIGURATIONS
-            + " ("
-            + COLUMN_ID + " integer primary key autoincrement, "
-            + COLUMN_AD_UNIT_ID + " text not null, "
-            + COLUMN_DESCRIPTION + " text not null, "
-            + COLUMN_USER_GENERATED + " integer not null, "
-            + COLUMN_AD_TYPE + " text not null"
-            + ");";
-
-    private final Context mContext;
-
-    public MoPubSQLiteHelper(final Context context) {
-        super(context, DATABASE_NAME, null, DATABASE_VERSION);
-        mContext = context.getApplicationContext();
-    }
-
-    @Override
-    public void onCreate(SQLiteDatabase sqLiteDatabase) {
-        // Built-in sample ad units.
-        final List<MoPubSampleAdUnit> adUnitList = new ArrayList<MoPubSampleAdUnit>();
-        adUnitList.add(
-                new MoPubSampleAdUnit
-                        .Builder(mContext.getString(R.string.ad_unit_id_banner), BANNER)
-                        .description("MoPub Banner Sample")
-                        .build());
-
-        adUnitList.add(
-                new MoPubSampleAdUnit
-                        .Builder(mContext.getString(R.string.ad_unit_id_mrect), MRECT)
-                        .description("MoPub Mrect Sample")
-                        .build());
-
-        adUnitList.add(
-                new MoPubSampleAdUnit
-                        .Builder(mContext.getString(R.string.ad_unit_id_interstitial), INTERSTITIAL)
-                        .description("MoPub Interstitial Sample")
-                        .build());
-
-        adUnitList.add(
-                new MoPubSampleAdUnit
-                        .Builder(mContext.getString(R.string.ad_unit_id_native), LIST_VIEW)
-                        .description("MoPub Ad Placer Sample")
-                        .build());
-        adUnitList.add(
-                new MoPubSampleAdUnit
-                        .Builder(mContext.getString(R.string.ad_unit_id_native), CUSTOM_NATIVE)
-                        .description("MoPub View Pager Sample")
-                        .build());
-        sqLiteDatabase.execSQL(DATABASE_CREATE);
-        sqLiteDatabase.beginTransaction();
-
-        // Populate the MoPub built-in samples.
-        for (final MoPubSampleAdUnit adUnit : adUnitList) {
-            final ContentValues values = new ContentValues();
-            values.put(COLUMN_AD_UNIT_ID, adUnit.getAdUnitId());
-            values.put(COLUMN_DESCRIPTION, adUnit.getDescription());
-            values.put(COLUMN_USER_GENERATED, 0);
-            values.put(COLUMN_AD_TYPE, adUnit.getFragmentClassName());
-
-            sqLiteDatabase.insert(TABLE_AD_CONFIGURATIONS, null, values);
-        }
-        sqLiteDatabase.setTransactionSuccessful();
-        sqLiteDatabase.endTransaction();
-    }
-
-    @Override
-    public void onDowngrade(SQLiteDatabase database, int oldVersion, int newVersion) {
-        Log.w(MoPubSQLiteHelper.class.getName(),
-                "Downgrading database from version " + oldVersion + " to "
-                        + newVersion + ", which will destroy all old data"
-        );
-        recreateDb(database);
-    }
-
-    @Override
-    public void onUpgrade(SQLiteDatabase database, int oldVersion, int newVersion) {
-        Log.w(MoPubSQLiteHelper.class.getName(),
-                "Upgrading database from version " + oldVersion + " to "
-                        + newVersion + ", which will destroy all old data"
-        );
-        recreateDb(database);
-    }
-
-    private void recreateDb(SQLiteDatabase database) {
-        database.execSQL("DROP TABLE IF EXISTS " + TABLE_AD_CONFIGURATIONS);
-        onCreate(database);
-    }
-}
+package com.mopub.simpleadsdemo;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static com.mopub.simpleadsdemo.MoPubSampleAdUnit.AdType.BANNER;
+import static com.mopub.simpleadsdemo.MoPubSampleAdUnit.AdType.CUSTOM_NATIVE;
+import static com.mopub.simpleadsdemo.MoPubSampleAdUnit.AdType.INTERSTITIAL;
+import static com.mopub.simpleadsdemo.MoPubSampleAdUnit.AdType.LIST_VIEW;
+import static com.mopub.simpleadsdemo.MoPubSampleAdUnit.AdType.MRECT;
+
+class MoPubSQLiteHelper extends SQLiteOpenHelper {
+    public static final String TABLE_AD_CONFIGURATIONS = "adConfigurations";
+    public static final String COLUMN_ID = "_id";
+    public static final String COLUMN_AD_UNIT_ID = "adUnitId";
+    public static final String COLUMN_DESCRIPTION = "description";
+    public static final String COLUMN_USER_GENERATED = "userGenerated";
+    public static final String COLUMN_AD_TYPE = "adType";
+
+    private static final String DATABASE_NAME = "savedConfigurations.db";
+    private static final int DATABASE_VERSION = 2;
+
+    private static final String DATABASE_CREATE = "create table " + TABLE_AD_CONFIGURATIONS
+            + " ("
+            + COLUMN_ID + " integer primary key autoincrement, "
+            + COLUMN_AD_UNIT_ID + " text not null, "
+            + COLUMN_DESCRIPTION + " text not null, "
+            + COLUMN_USER_GENERATED + " integer not null, "
+            + COLUMN_AD_TYPE + " text not null"
+            + ");";
+
+    private final Context mContext;
+
+    public MoPubSQLiteHelper(final Context context) {
+        super(context, DATABASE_NAME, null, DATABASE_VERSION);
+        mContext = context.getApplicationContext();
+    }
+
+    @Override
+    public void onCreate(SQLiteDatabase sqLiteDatabase) {
+        // Built-in sample ad units.
+        final List<MoPubSampleAdUnit> adUnitList = new ArrayList<MoPubSampleAdUnit>();
+        adUnitList.add(
+                new MoPubSampleAdUnit
+                        .Builder(mContext.getString(R.string.ad_unit_id_banner), BANNER)
+                        .description("MoPub Banner Sample")
+                        .build());
+
+        adUnitList.add(
+                new MoPubSampleAdUnit
+                        .Builder(mContext.getString(R.string.ad_unit_id_mrect), MRECT)
+                        .description("MoPub Mrect Sample")
+                        .build());
+
+        adUnitList.add(
+                new MoPubSampleAdUnit
+                        .Builder(mContext.getString(R.string.ad_unit_id_interstitial), INTERSTITIAL)
+                        .description("MoPub Interstitial Sample")
+                        .build());
+
+        adUnitList.add(
+                new MoPubSampleAdUnit
+                        .Builder(mContext.getString(R.string.ad_unit_id_native), LIST_VIEW)
+                        .description("MoPub Ad Placer Sample")
+                        .build());
+        adUnitList.add(
+                new MoPubSampleAdUnit
+                        .Builder(mContext.getString(R.string.ad_unit_id_native), CUSTOM_NATIVE)
+                        .description("MoPub View Pager Sample")
+                        .build());
+        sqLiteDatabase.execSQL(DATABASE_CREATE);
+        sqLiteDatabase.beginTransaction();
+
+        // Populate the MoPub built-in samples.
+        for (final MoPubSampleAdUnit adUnit : adUnitList) {
+            final ContentValues values = new ContentValues();
+            values.put(COLUMN_AD_UNIT_ID, adUnit.getAdUnitId());
+            values.put(COLUMN_DESCRIPTION, adUnit.getDescription());
+            values.put(COLUMN_USER_GENERATED, 0);
+            values.put(COLUMN_AD_TYPE, adUnit.getFragmentClassName());
+
+            sqLiteDatabase.insert(TABLE_AD_CONFIGURATIONS, null, values);
+        }
+        sqLiteDatabase.setTransactionSuccessful();
+        sqLiteDatabase.endTransaction();
+    }
+
+    @Override
+    public void onDowngrade(SQLiteDatabase database, int oldVersion, int newVersion) {
+        Log.w(MoPubSQLiteHelper.class.getName(),
+                "Downgrading database from version " + oldVersion + " to "
+                        + newVersion + ", which will destroy all old data"
+        );
+        recreateDb(database);
+    }
+
+    @Override
+    public void onUpgrade(SQLiteDatabase database, int oldVersion, int newVersion) {
+        Log.w(MoPubSQLiteHelper.class.getName(),
+                "Upgrading database from version " + oldVersion + " to "
+                        + newVersion + ", which will destroy all old data"
+        );
+        recreateDb(database);
+    }
+
+    private void recreateDb(SQLiteDatabase database) {
+        database.execSQL("DROP TABLE IF EXISTS " + TABLE_AD_CONFIGURATIONS);
+        onCreate(database);
+    }
+}
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleAdUnit.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleAdUnit.java
index 3725de40..3e2b7dac 100644
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleAdUnit.java
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleAdUnit.java
@@ -1,201 +1,202 @@
-package com.mopub.simpleadsdemo;
-
-import android.os.Bundle;
-import android.support.annotation.NonNull;
-import android.support.v4.app.Fragment;
-
-import java.util.Comparator;
-
-class MoPubSampleAdUnit implements Comparable<MoPubSampleAdUnit> {
-
-    public static final String AD_UNIT_ID = "adUnitId";
-    public static final String DESCRIPTION = "description";
-    public static final String AD_TYPE = "adType";
-    public static final String IS_USER_DEFINED = "isCustom";
-    public static final String ID = "id";
-
-    // Note that entries are also sorted in this order
-    enum AdType {
-        BANNER("Banner", BannerDetailFragment.class),
-        MRECT("Mrect", MrectDetailFragment.class),
-        INTERSTITIAL("Interstitial", InterstitialDetailFragment.class),
-        LIST_VIEW("Native List View", NativeListViewFragment.class),
-        CUSTOM_NATIVE("Native Gallery (Custom Stream)", NativeGalleryFragment.class);
-
-        String getName() {
-            return name;
-        }
-
-        private final String name;
-        private final Class<? extends Fragment> fragmentClass;
-
-        private AdType(final String name, final Class<? extends Fragment> fragmentClass) {
-            this.name = name;
-            this.fragmentClass = fragmentClass;
-        }
-
-        private Class<? extends Fragment> getFragmentClass() {
-            return fragmentClass;
-        }
-
-        static AdType fromFragmentClassName(final String fragmentClassName) {
-            for (final AdType adType : values()) {
-                if (adType.fragmentClass.getName().equals(fragmentClassName)) {
-                    return adType;
-                }
-            }
-
-            return null;
-        }
-    }
-
-    static final Comparator<MoPubSampleAdUnit> COMPARATOR =
-            new Comparator<MoPubSampleAdUnit>() {
-                @Override
-                public int compare(MoPubSampleAdUnit a, MoPubSampleAdUnit b) {
-                    return a.compareTo(b);
-                }
-            };
-
-    static class Builder {
-        private final String mAdUnitId;
-        private final AdType mAdType;
-
-        private String mDescription;
-        private boolean mIsUserDefined;
-        private long mId;
-
-        Builder(final String adUnitId, final AdType adType) {
-            mAdUnitId = adUnitId;
-            mAdType = adType;
-            mId = -1;
-        }
-
-        Builder description(final String description) {
-            mDescription = description;
-            return this;
-        }
-
-        Builder isUserDefined(boolean userDefined) {
-            mIsUserDefined = userDefined;
-            return this;
-        }
-
-        Builder id(final long id) {
-            mId = id;
-            return this;
-        }
-
-        MoPubSampleAdUnit build() {
-            return new MoPubSampleAdUnit(this);
-        }
-    }
-
-    private final String mAdUnitId;
-    private final AdType mAdType;
-    private final String mDescription;
-    private final boolean mIsUserDefined;
-    private final long mId;
-
-    private MoPubSampleAdUnit(final Builder builder) {
-        mAdUnitId = builder.mAdUnitId;
-        mAdType = builder.mAdType;
-        mDescription = builder.mDescription;
-        mIsUserDefined = builder.mIsUserDefined;
-        mId = builder.mId;
-    }
-
-    Class<? extends Fragment> getFragmentClass() {
-        return mAdType.getFragmentClass();
-    }
-
-    String getAdUnitId() {
-        return mAdUnitId;
-    }
-
-    String getDescription() {
-        return mDescription;
-    }
-
-    String getFragmentClassName() {
-        return mAdType.getFragmentClass().getName();
-    }
-
-    String getHeaderName() {
-        return mAdType.name;
-    }
-
-    long getId() {
-        return mId;
-    }
-
-    boolean isUserDefined() {
-        return mIsUserDefined;
-    }
-
-    Bundle toBundle() {
-        final Bundle bundle = new Bundle();
-        bundle.putLong(ID, mId);
-        bundle.putString(AD_UNIT_ID, mAdUnitId);
-        bundle.putString(DESCRIPTION, mDescription);
-        bundle.putSerializable(AD_TYPE, mAdType);
-        bundle.putBoolean(IS_USER_DEFINED, mIsUserDefined);
-
-        return bundle;
-    }
-
-    static MoPubSampleAdUnit fromBundle(final Bundle bundle) {
-        final Long id = bundle.getLong(ID, -1L);
-        final String adUnitId = bundle.getString(AD_UNIT_ID);
-        final AdType adType = (AdType) bundle.getSerializable(AD_TYPE);
-        final String description = bundle.getString(DESCRIPTION);
-        final boolean isUserDefined = bundle.getBoolean(IS_USER_DEFINED, false);
-        final Builder builder = new MoPubSampleAdUnit.Builder(adUnitId, adType);
-        builder.description(description);
-        builder.id(id);
-        builder.isUserDefined(isUserDefined);
-
-        return builder.build();
-    }
-
-    @Override
-    public int compareTo(@NonNull MoPubSampleAdUnit that) {
-        if (mAdType != that.mAdType) {
-            return mAdType.ordinal() - that.mAdType.ordinal();
-        }
-
-        return mDescription.compareTo(that.mDescription);
-    }
-
-    @Override
-    public int hashCode() {
-        int result = 11;
-        result = 31 * result + mAdType.ordinal();
-        result = 31 * result + (mIsUserDefined ? 1 : 0);
-        result = 31 * result + mDescription.hashCode();
-        result = 31 * result + mAdUnitId.hashCode();
-        return result;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (o == null) {
-            return false;
-        }
-
-        if (this == o) {
-            return true;
-        }
-
-        if (!(o instanceof MoPubSampleAdUnit)) {
-            return false;
-        }
-
-        final MoPubSampleAdUnit that = (MoPubSampleAdUnit) o;
-
-        return that.mAdType.equals(this.mAdType) &&
-                that.mIsUserDefined == this.mIsUserDefined &&
-                that.mDescription.equals(this.mDescription) &&
-                that.mAdUnitId.equals(this.mAdUnitId);
-    }
-}
+package com.mopub.simpleadsdemo;
+
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.v4.app.Fragment;
+
+import java.util.Comparator;
+
+class MoPubSampleAdUnit implements Comparable<MoPubSampleAdUnit> {
+
+    public static final String AD_UNIT_ID = "adUnitId";
+    public static final String DESCRIPTION = "description";
+    public static final String AD_TYPE = "adType";
+    public static final String IS_USER_DEFINED = "isCustom";
+    public static final String ID = "id";
+
+    // Note that entries are also sorted in this order
+    enum AdType {
+        BANNER("Banner", BannerDetailFragment.class),
+        MRECT("Mrect", MrectDetailFragment.class),
+        INTERSTITIAL("Interstitial", InterstitialDetailFragment.class),
+        REWARDED_VIDEO("Rewarded Video", RewardedVideoDetailFragment.class),
+        LIST_VIEW("Native List View", NativeListViewFragment.class),
+        CUSTOM_NATIVE("Native Gallery (Custom Stream)", NativeGalleryFragment.class);
+
+        String getName() {
+            return name;
+        }
+
+        private final String name;
+        private final Class<? extends Fragment> fragmentClass;
+
+        private AdType(final String name, final Class<? extends Fragment> fragmentClass) {
+            this.name = name;
+            this.fragmentClass = fragmentClass;
+        }
+
+        private Class<? extends Fragment> getFragmentClass() {
+            return fragmentClass;
+        }
+
+        static AdType fromFragmentClassName(final String fragmentClassName) {
+            for (final AdType adType : values()) {
+                if (adType.fragmentClass.getName().equals(fragmentClassName)) {
+                    return adType;
+                }
+            }
+
+            return null;
+        }
+    }
+
+    static final Comparator<MoPubSampleAdUnit> COMPARATOR =
+            new Comparator<MoPubSampleAdUnit>() {
+                @Override
+                public int compare(MoPubSampleAdUnit a, MoPubSampleAdUnit b) {
+                    return a.compareTo(b);
+                }
+            };
+
+    static class Builder {
+        private final String mAdUnitId;
+        private final AdType mAdType;
+
+        private String mDescription;
+        private boolean mIsUserDefined;
+        private long mId;
+
+        Builder(final String adUnitId, final AdType adType) {
+            mAdUnitId = adUnitId;
+            mAdType = adType;
+            mId = -1;
+        }
+
+        Builder description(final String description) {
+            mDescription = description;
+            return this;
+        }
+
+        Builder isUserDefined(boolean userDefined) {
+            mIsUserDefined = userDefined;
+            return this;
+        }
+
+        Builder id(final long id) {
+            mId = id;
+            return this;
+        }
+
+        MoPubSampleAdUnit build() {
+            return new MoPubSampleAdUnit(this);
+        }
+    }
+
+    private final String mAdUnitId;
+    private final AdType mAdType;
+    private final String mDescription;
+    private final boolean mIsUserDefined;
+    private final long mId;
+
+    private MoPubSampleAdUnit(final Builder builder) {
+        mAdUnitId = builder.mAdUnitId;
+        mAdType = builder.mAdType;
+        mDescription = builder.mDescription;
+        mIsUserDefined = builder.mIsUserDefined;
+        mId = builder.mId;
+    }
+
+    Class<? extends Fragment> getFragmentClass() {
+        return mAdType.getFragmentClass();
+    }
+
+    String getAdUnitId() {
+        return mAdUnitId;
+    }
+
+    String getDescription() {
+        return mDescription;
+    }
+
+    String getFragmentClassName() {
+        return mAdType.getFragmentClass().getName();
+    }
+
+    String getHeaderName() {
+        return mAdType.name;
+    }
+
+    long getId() {
+        return mId;
+    }
+
+    boolean isUserDefined() {
+        return mIsUserDefined;
+    }
+
+    Bundle toBundle() {
+        final Bundle bundle = new Bundle();
+        bundle.putLong(ID, mId);
+        bundle.putString(AD_UNIT_ID, mAdUnitId);
+        bundle.putString(DESCRIPTION, mDescription);
+        bundle.putSerializable(AD_TYPE, mAdType);
+        bundle.putBoolean(IS_USER_DEFINED, mIsUserDefined);
+
+        return bundle;
+    }
+
+    static MoPubSampleAdUnit fromBundle(final Bundle bundle) {
+        final Long id = bundle.getLong(ID, -1L);
+        final String adUnitId = bundle.getString(AD_UNIT_ID);
+        final AdType adType = (AdType) bundle.getSerializable(AD_TYPE);
+        final String description = bundle.getString(DESCRIPTION);
+        final boolean isUserDefined = bundle.getBoolean(IS_USER_DEFINED, false);
+        final Builder builder = new MoPubSampleAdUnit.Builder(adUnitId, adType);
+        builder.description(description);
+        builder.id(id);
+        builder.isUserDefined(isUserDefined);
+
+        return builder.build();
+    }
+
+    @Override
+    public int compareTo(@NonNull MoPubSampleAdUnit that) {
+        if (mAdType != that.mAdType) {
+            return mAdType.ordinal() - that.mAdType.ordinal();
+        }
+
+        return mDescription.compareTo(that.mDescription);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = 11;
+        result = 31 * result + mAdType.ordinal();
+        result = 31 * result + (mIsUserDefined ? 1 : 0);
+        result = 31 * result + mDescription.hashCode();
+        result = 31 * result + mAdUnitId.hashCode();
+        return result;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (o == null) {
+            return false;
+        }
+
+        if (this == o) {
+            return true;
+        }
+
+        if (!(o instanceof MoPubSampleAdUnit)) {
+            return false;
+        }
+
+        final MoPubSampleAdUnit that = (MoPubSampleAdUnit) o;
+
+        return that.mAdType.equals(this.mAdType) &&
+                that.mIsUserDefined == this.mIsUserDefined &&
+                that.mDescription.equals(this.mDescription) &&
+                that.mAdUnitId.equals(this.mAdUnitId);
+    }
+}
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/RewardedVideoDetailFragment.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/RewardedVideoDetailFragment.java
new file mode 100644
index 00000000..16eaed98
--- /dev/null
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/RewardedVideoDetailFragment.java
@@ -0,0 +1,107 @@
+package com.mopub.simpleadsdemo;
+
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.v4.app.Fragment;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.Button;
+
+import com.mopub.common.MoPub;
+import com.mopub.common.MoPubReward;
+import com.mopub.mobileads.MoPubErrorCode;
+import com.mopub.mobileads.MoPubRewardedVideoListener;
+
+import java.util.Locale;
+import java.util.Set;
+
+import static com.mopub.simpleadsdemo.Utils.hideSoftKeyboard;
+import static com.mopub.simpleadsdemo.Utils.logToast;
+
+public class RewardedVideoDetailFragment extends Fragment implements MoPubRewardedVideoListener {
+
+    private Button mShowButton;
+    private static boolean rewardedVideoInitialized;
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        super.onCreateView(inflater, container, savedInstanceState);
+        final MoPubSampleAdUnit adConfiguration =
+                MoPubSampleAdUnit.fromBundle(getArguments());
+        final View view = inflater.inflate(R.layout.interstitial_detail_fragment, container, false);
+        final DetailFragmentViewHolder views = DetailFragmentViewHolder.fromView(view);
+        hideSoftKeyboard(views.mKeywordsField);
+
+        if (!rewardedVideoInitialized) {
+            MoPub.initializeRewardedVideo(getActivity());
+            rewardedVideoInitialized = true;
+        }
+        MoPub.setRewardedVideoListener(this);
+
+        final String adUnitId = adConfiguration.getAdUnitId();
+        views.mDescriptionView.setText(adConfiguration.getDescription());
+        views.mAdUnitIdView.setText(adUnitId);
+        views.mLoadButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                MoPub.loadRewardedVideo(adUnitId);
+                mShowButton.setEnabled(false);
+            }
+        });
+        mShowButton = (Button) view.findViewById(R.id.interstitial_show_button);
+        mShowButton.setEnabled(false);
+        mShowButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                MoPub.showRewardedVideo(adUnitId);
+            }
+        });
+
+        return view;
+    }
+
+    @Override
+    public void onDestroyView() {
+        super.onDestroyView();
+    }
+
+    // MoPubRewardedVideoListener implementation
+    @Override
+    public void onRewardedVideoLoadSuccess(@NonNull final String adUnitId) {
+        mShowButton.setEnabled(true);
+        logToast(getActivity(), "Rewarded video loaded.");
+    }
+
+    @Override
+    public void onRewardedVideoLoadFailure(@NonNull final String adUnitId, @NonNull final MoPubErrorCode errorCode) {
+        mShowButton.setEnabled(false);
+        logToast(getActivity(), String.format(Locale.US, "Rewarded video failed to load: %s", errorCode.toString()));
+    }
+
+    @Override
+    public void onRewardedVideoStarted(@NonNull final String adUnitId) {
+        logToast(getActivity(), "Rewarded video started.");
+        mShowButton.setEnabled(false);
+    }
+
+    @Override
+    public void onRewardedVideoPlaybackError(@NonNull final String adUnitId, @NonNull final MoPubErrorCode errorCode) {
+        logToast(getActivity(), String.format(Locale.US, "Rewarded video playback error: %s", errorCode.toString()));
+        mShowButton.setEnabled(false);
+    }
+
+    @Override
+    public void onRewardedVideoClosed(@NonNull final String adUnitId) {
+        logToast(getActivity(), "Rewarded video closed.");
+        mShowButton.setEnabled(false);
+    }
+
+    @Override
+    public void onRewardedVideoCompleted(@NonNull final Set<String> adUnitIds, @NonNull final MoPubReward reward) {
+        logToast(getActivity(),
+                String.format(Locale.US,
+                        "Rewarded video completed with reward  \"%d %s\"",
+                        reward.getAmount(),
+                        reward.getLabel()));
+    }
+}
diff --git a/mopub-sdk/build.gradle b/mopub-sdk/build.gradle
index 6caf1a1e..fcf8b868 100644
--- a/mopub-sdk/build.gradle
+++ b/mopub-sdk/build.gradle
@@ -1,58 +1,64 @@
-apply plugin: 'com.android.library'
-
-repositories {
-    jcenter()
-}
-
-android {
-    compileSdkVersion 22
-    buildToolsVersion '22.0.1'
-
-    defaultConfig {
-        versionCode 24
-        versionName "3.7.0"
-        minSdkVersion 9
-        targetSdkVersion 22
-        consumerProguardFiles 'proguard.txt'
-    }
-
-    sourceSets {
-        main {
-            manifest.srcFile 'AndroidManifest.xml'
-            java.srcDirs = ['src/main/java']
-            resources.srcDirs = ['src/main/java']
-            aidl.srcDirs = ['src/main']
-            renderscript.srcDirs = ['src/main']
-            res.srcDirs = ['res']
-            assets.srcDirs = ['assets']
-        }
-    }
-
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), file('proguard.txt')
-        }
-    }
-
-    // Note: You will also need a local.properties file to set the location of the SDK in the same 
-    // way that the existing SDK requires, using the sdk.dir property.
-    // Alternatively, you can set an environment variable called ANDROID_HOME. There is no 
-    // difference between the two methods, you can use the one you prefer.
-}
-
-dependencies {
-    compile 'com.android.support:support-v4:22.1.1'
-    compile 'com.android.support:support-annotations:22.1.'
-    compile 'com.mopub.volley:mopub-volley:1.1.0'
-}
-
-apply plugin: 'maven'
-
-// Don't run the Robolectric Unit Tests.
-check.dependsOn.remove("test")
-check.dependsOn.remove("unitTest")
-check.dependsOn.remove("testDebug")
-check.dependsOn.remove("unitTestDebug")
-
-apply from: 'https://raw.githubusercontent.com/robbypond/gradle-mvn-push/master/gradle-mvn-push.gradle'
+// This buildscript will assemble the MoPub SDK into an AAR.
+
+repositories {
+    jcenter()
+}
+
+apply plugin: 'com.android.library'
+
+group = 'com.mopub'
+
+description = '''MoPub SDK'''
+
+android {
+    compileSdkVersion 22
+    buildToolsVersion '22.0.1'
+
+    defaultConfig {
+        versionCode 25
+        versionName "3.8.0"
+        minSdkVersion 9
+        targetSdkVersion 22
+        consumerProguardFiles 'proguard.txt'
+    }
+
+    sourceSets {
+        main {
+            manifest.srcFile 'AndroidManifest.xml'
+            java.srcDirs = ['src/main/java']
+            resources.srcDirs = ['src/main/java']
+            aidl.srcDirs = ['src/main']
+            renderscript.srcDirs = ['src/main']
+            res.srcDirs = ['res']
+            assets.srcDirs = ['assets']
+        }
+    }
+
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), file('proguard.txt')
+        }
+    }
+
+    // Note: You will also need a local.properties file to set the location of the SDK in the same 
+    // way that the existing SDK requires, using the sdk.dir property.
+    // Alternatively, you can set an environment variable called ANDROID_HOME. There is no 
+    // difference between the two methods, you can use the one you prefer.
+}
+
+dependencies {
+    compile 'com.android.support:support-v4:22.2.0'
+    compile 'com.android.support:support-annotations:22.2.0'
+    compile 'com.mopub.volley:mopub-volley:1.1.0'
+}
+
+apply plugin: 'maven'
+
+// Don't run the Robolectric Unit Tests.
+check.dependsOn.remove("test")
+check.dependsOn.remove("unitTest")
+check.dependsOn.remove("testDebug")
+check.dependsOn.remove("unitTestDebug")
+
+apply from: 'https://raw.githubusercontent.com/robbypond/gradle-mvn-push/master/gradle-mvn-push.gradle'
diff --git a/mopub-sdk/src/main/java/com/mopub/common/MoPub.java b/mopub-sdk/src/main/java/com/mopub/common/MoPub.java
index 8d7446e9..12e2921d 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/MoPub.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/MoPub.java
@@ -1,102 +1,102 @@
-package com.mopub.common;
-
-import android.app.Activity;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-
-import com.mopub.mobileads.MoPubRewardedVideoListener;
-import com.mopub.mobileads.MoPubRewardedVideoManager;
-
-public class MoPub {
-    public static final String SDK_VERSION = "3.7.0";
-
-    public static enum LocationAwareness { NORMAL, TRUNCATED, DISABLED }
-
-    private static final int DEFAULT_LOCATION_PRECISION = 6;
-    private static volatile LocationAwareness sLocationLocationAwareness = LocationAwareness.NORMAL;
-    private static volatile int sLocationPrecision = DEFAULT_LOCATION_PRECISION;
-
-    public static LocationAwareness getLocationAwareness() {
-        return sLocationLocationAwareness;
-    }
-
-    public static void setLocationAwareness(LocationAwareness locationAwareness) {
-        sLocationLocationAwareness = locationAwareness;
-    }
-
-    public static int getLocationPrecision() {
-        return sLocationPrecision;
-    }
-
-    /**
-     * Sets the precision to use when the SDK's location awareness is set
-     * to {@link com.mopub.common.MoPub.LocationAwareness#TRUNCATED}.
-     */
-    public static void setLocationPrecision(int precision) {
-        sLocationPrecision = Math.min(Math.max(0, precision), DEFAULT_LOCATION_PRECISION);
-    }
-
-
-    //////// MoPub LifecycleListener messages ////////
-
-    public static void onCreate(@NonNull final Activity activity) {
-        MoPubLifecycleManager.getInstance(activity).onCreate(activity);
-        updateActivity(activity);
-    }
-
-    public static void onStart(@NonNull final Activity activity) {
-        MoPubLifecycleManager.getInstance(activity).onStart(activity);
-        updateActivity(activity);
-    }
-
-    public static void onPause(@NonNull final Activity activity) {
-        MoPubLifecycleManager.getInstance(activity).onPause(activity);
-    }
-
-    public static void onResume(@NonNull final Activity activity) {
-        MoPubLifecycleManager.getInstance(activity).onResume(activity);
-        updateActivity(activity);
-    }
-
-    public static void onRestart(@NonNull final Activity activity) {
-        MoPubLifecycleManager.getInstance(activity).onRestart(activity);
-        updateActivity(activity);
-    }
-
-    public static void onStop(@NonNull final Activity activity) {
-        MoPubLifecycleManager.getInstance(activity).onStop(activity);
-    }
-
-    public static void onDestroy(@NonNull final Activity activity) {
-        MoPubLifecycleManager.getInstance(activity).onDestroy(activity);
-    }
-
-    public static void onBackPressed(@NonNull final Activity activity) {
-        MoPubLifecycleManager.getInstance(activity).onBackPressed(activity);
-    }
-
-    ////////// MoPub RewardedVideoControl methods //////////
-    public static void initializeRewardedVideo(@NonNull Activity activity, MediationSettings... mediationSettings) {
-        MoPubRewardedVideoManager.init(activity, mediationSettings);
-    }
-
-    private static void updateActivity(@NonNull Activity activity) {
-        MoPubRewardedVideoManager.updateActivity(activity);
-    }
-
-    public static void setRewardedVideoListener(@Nullable MoPubRewardedVideoListener listener) {
-        MoPubRewardedVideoManager.setVideoListener(listener);
-    }
-
-    public static void loadRewardedVideo(@NonNull String adUnitId, @Nullable MediationSettings... mediationSettings) {
-        MoPubRewardedVideoManager.loadVideo(adUnitId, mediationSettings);
-    }
-
-    public static boolean hasRewardedVideo(@NonNull String adUnitId) {
-        return MoPubRewardedVideoManager.hasVideo(adUnitId);
-    }
-
-    public static void showRewardedVideo(@NonNull String adUnitId) {
-        MoPubRewardedVideoManager.showVideo(adUnitId);
-    }
-}
+package com.mopub.common;
+
+import android.app.Activity;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.mobileads.MoPubRewardedVideoListener;
+import com.mopub.mobileads.MoPubRewardedVideoManager;
+
+public class MoPub {
+    public static final String SDK_VERSION = "3.8.0";
+
+    public static enum LocationAwareness { NORMAL, TRUNCATED, DISABLED }
+
+    private static final int DEFAULT_LOCATION_PRECISION = 6;
+    private static volatile LocationAwareness sLocationLocationAwareness = LocationAwareness.NORMAL;
+    private static volatile int sLocationPrecision = DEFAULT_LOCATION_PRECISION;
+
+    public static LocationAwareness getLocationAwareness() {
+        return sLocationLocationAwareness;
+    }
+
+    public static void setLocationAwareness(LocationAwareness locationAwareness) {
+        sLocationLocationAwareness = locationAwareness;
+    }
+
+    public static int getLocationPrecision() {
+        return sLocationPrecision;
+    }
+
+    /**
+     * Sets the precision to use when the SDK's location awareness is set
+     * to {@link com.mopub.common.MoPub.LocationAwareness#TRUNCATED}.
+     */
+    public static void setLocationPrecision(int precision) {
+        sLocationPrecision = Math.min(Math.max(0, precision), DEFAULT_LOCATION_PRECISION);
+    }
+
+
+    //////// MoPub LifecycleListener messages ////////
+
+    public static void onCreate(@NonNull final Activity activity) {
+        MoPubLifecycleManager.getInstance(activity).onCreate(activity);
+        updateActivity(activity);
+    }
+
+    public static void onStart(@NonNull final Activity activity) {
+        MoPubLifecycleManager.getInstance(activity).onStart(activity);
+        updateActivity(activity);
+    }
+
+    public static void onPause(@NonNull final Activity activity) {
+        MoPubLifecycleManager.getInstance(activity).onPause(activity);
+    }
+
+    public static void onResume(@NonNull final Activity activity) {
+        MoPubLifecycleManager.getInstance(activity).onResume(activity);
+        updateActivity(activity);
+    }
+
+    public static void onRestart(@NonNull final Activity activity) {
+        MoPubLifecycleManager.getInstance(activity).onRestart(activity);
+        updateActivity(activity);
+    }
+
+    public static void onStop(@NonNull final Activity activity) {
+        MoPubLifecycleManager.getInstance(activity).onStop(activity);
+    }
+
+    public static void onDestroy(@NonNull final Activity activity) {
+        MoPubLifecycleManager.getInstance(activity).onDestroy(activity);
+    }
+
+    public static void onBackPressed(@NonNull final Activity activity) {
+        MoPubLifecycleManager.getInstance(activity).onBackPressed(activity);
+    }
+
+    ////////// MoPub RewardedVideoControl methods //////////
+    public static void initializeRewardedVideo(@NonNull Activity activity, MediationSettings... mediationSettings) {
+        MoPubRewardedVideoManager.init(activity, mediationSettings);
+    }
+
+    private static void updateActivity(@NonNull Activity activity) {
+        MoPubRewardedVideoManager.updateActivity(activity);
+    }
+
+    public static void setRewardedVideoListener(@Nullable MoPubRewardedVideoListener listener) {
+        MoPubRewardedVideoManager.setVideoListener(listener);
+    }
+
+    public static void loadRewardedVideo(@NonNull String adUnitId, @Nullable MediationSettings... mediationSettings) {
+        MoPubRewardedVideoManager.loadVideo(adUnitId, mediationSettings);
+    }
+
+    public static boolean hasRewardedVideo(@NonNull String adUnitId) {
+        return MoPubRewardedVideoManager.hasVideo(adUnitId);
+    }
+
+    public static void showRewardedVideo(@NonNull String adUnitId) {
+        MoPubRewardedVideoManager.showVideo(adUnitId);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/MoPubBrowser.java b/mopub-sdk/src/main/java/com/mopub/common/MoPubBrowser.java
index 77e59867..b4e88938 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/MoPubBrowser.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/MoPubBrowser.java
@@ -1,270 +1,269 @@
-package com.mopub.common;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.graphics.Bitmap;
-import android.graphics.Color;
-import android.graphics.drawable.Drawable;
-import android.net.Uri;
-import android.os.Bundle;
-import android.view.Gravity;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.Window;
-import android.webkit.CookieSyncManager;
-import android.webkit.WebChromeClient;
-import android.webkit.WebSettings;
-import android.webkit.WebView;
-import android.webkit.WebViewClient;
-import android.widget.ImageButton;
-import android.widget.LinearLayout;
-import android.widget.RelativeLayout;
-
-import com.mopub.common.logging.MoPubLog;
-import com.mopub.mobileads.BaseWebView;
-import com.mopub.mobileads.util.WebViews;
-
-import static android.view.ViewGroup.LayoutParams.MATCH_PARENT;
-import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;
-import static com.mopub.common.util.Drawables.BACKGROUND;
-import static com.mopub.common.util.Drawables.CLOSE;
-import static com.mopub.common.util.Drawables.LEFT_ARROW;
-import static com.mopub.common.util.Drawables.REFRESH;
-import static com.mopub.common.util.Drawables.RIGHT_ARROW;
-import static com.mopub.common.util.Drawables.UNLEFT_ARROW;
-import static com.mopub.common.util.Drawables.UNRIGHT_ARROW;
-import static com.mopub.common.util.Intents.deviceCanHandleIntent;
-import static com.mopub.common.util.Intents.isDeepLink;
-
-public class MoPubBrowser extends Activity {
-    public static final String DESTINATION_URL_KEY = "URL";
-    private static final int INNER_LAYOUT_ID = 1;
-
-    private WebView mWebView;
-    private ImageButton mBackButton;
-    private ImageButton mForwardButton;
-    private ImageButton mRefreshButton;
-    private ImageButton mCloseButton;
-
-    public static void open(final Context context, final String url) {
-        MoPubLog.d("Opening url in MoPubBrowser: " + url);
-        final Intent intent = new Intent(context, MoPubBrowser.class);
-        intent.putExtra(DESTINATION_URL_KEY, url);
-        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-        context.startActivity(intent);
-    }
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        setResult(Activity.RESULT_OK);
-
-        getWindow().requestFeature(Window.FEATURE_PROGRESS);
-        getWindow().setFeatureInt(Window.FEATURE_PROGRESS, Window.PROGRESS_VISIBILITY_ON);
-
-        setContentView(getMoPubBrowserView());
-
-        initializeWebView();
-        initializeButtons();
-        enableCookies();
-    }
-
-    private void initializeWebView() {
-        WebSettings webSettings = mWebView.getSettings();
-
-        webSettings.setJavaScriptEnabled(true);
-
-        /**
-         * Pinch to zoom is apparently not enabled by default on all devices, so
-         * declare zoom support explicitly.
-         * http://stackoverflow.com/questions/5125851/enable-disable-zoom-in-android-webview
-         */
-        webSettings.setSupportZoom(true);
-        webSettings.setBuiltInZoomControls(true);
-        webSettings.setUseWideViewPort(true);
-
-        mWebView.loadUrl(getIntent().getStringExtra(DESTINATION_URL_KEY));
-        mWebView.setWebViewClient(new WebViewClient() {
-            @Override
-            public void onReceivedError(WebView view, int errorCode, String description,
-                    String failingUrl) {
-                MoPubLog.d("MoPubBrowser error: " + description);
-            }
-
-            @Override
-            public boolean shouldOverrideUrlLoading(WebView view, String url) {
-                if (url == null) {
-                    return false;
-                }
-
-                final Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
-                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-                if (isDeepLink(url) && deviceCanHandleIntent(MoPubBrowser.this, intent)) {
-                    startActivity(intent);
-                    finish();
-                    return true;
-                } else {
-                    return false;
-                }
-            }
-
-            @Override
-            public void onPageStarted(WebView view, String url, Bitmap favicon) {
-                super.onPageStarted(view, url, favicon);
-                mForwardButton.setImageDrawable(UNRIGHT_ARROW.createDrawable(MoPubBrowser.this));
-            }
-
-            @Override
-            public void onPageFinished(WebView view, String url) {
-                super.onPageFinished(view, url);
-
-                Drawable backImageDrawable = view.canGoBack()
-                        ? LEFT_ARROW.createDrawable(MoPubBrowser.this)
-                        : UNLEFT_ARROW.createDrawable(MoPubBrowser.this);
-                mBackButton.setImageDrawable(backImageDrawable);
-
-                Drawable forwardImageDrawable = view.canGoForward()
-                        ? RIGHT_ARROW.createDrawable(MoPubBrowser.this)
-                        : UNRIGHT_ARROW.createDrawable(MoPubBrowser.this);
-                mForwardButton.setImageDrawable(forwardImageDrawable);
-            }
-        });
-
-        mWebView.setWebChromeClient(new WebChromeClient() {
-            public void onProgressChanged(WebView webView, int progress) {
-                setTitle("Loading...");
-                setProgress(progress * 100);
-                if (progress == 100) {
-                    setTitle(webView.getUrl());
-                }
-            }
-        });
-    }
-
-    private void initializeButtons() {
-        mBackButton.setBackgroundColor(Color.TRANSPARENT);
-        mBackButton.setOnClickListener(new View.OnClickListener() {
-            public void onClick(View v) {
-                if (mWebView.canGoBack()) {
-                    mWebView.goBack();
-                }
-            }
-        });
-
-        mForwardButton.setBackgroundColor(Color.TRANSPARENT);
-        mForwardButton.setOnClickListener(new View.OnClickListener() {
-            public void onClick(View v) {
-                if (mWebView.canGoForward()) {
-                    mWebView.goForward();
-                }
-            }
-        });
-
-        mRefreshButton.setBackgroundColor(Color.TRANSPARENT);
-        mRefreshButton.setOnClickListener(new View.OnClickListener() {
-            public void onClick(View v) {
-                mWebView.reload();
-            }
-        });
-
-        mCloseButton.setBackgroundColor(Color.TRANSPARENT);
-        mCloseButton.setOnClickListener(new View.OnClickListener() {
-            public void onClick(View v) {
-                MoPubBrowser.this.finish();
-            }
-        });
-    }
-
-    private void enableCookies() {
-        CookieSyncManager.createInstance(this);
-        CookieSyncManager.getInstance().startSync();
-    }
-
-    @Override
-    protected void onPause() {
-        super.onPause();
-        CookieSyncManager.getInstance().stopSync();
-        WebViews.onPause(mWebView, isFinishing());
-    }
-
-    @Override
-    protected void onResume() {
-        super.onResume();
-        CookieSyncManager.getInstance().startSync();
-        WebViews.onResume(mWebView);
-    }
-
-    @Override
-    public void finish() {
-        // ZoomButtonController adds buttons to the window's decorview. If they're still visible
-        // when finish() is called, they need to be removed or a Window object will be leaked.
-        ViewGroup decorView = (ViewGroup) getWindow().getDecorView();
-        decorView.removeAllViews();
-        super.finish();
-    }
-
-    @Override
-    protected void onDestroy() {
-        super.onDestroy();
-        mWebView.destroy();
-        mWebView = null;
-    }
-
-    private View getMoPubBrowserView() {
-        LinearLayout moPubBrowserView = new LinearLayout(this);
-        LinearLayout.LayoutParams browserLayoutParams = new LinearLayout.LayoutParams(MATCH_PARENT, MATCH_PARENT);
-        moPubBrowserView.setLayoutParams(browserLayoutParams);
-        moPubBrowserView.setOrientation(LinearLayout.VERTICAL);
-
-        RelativeLayout outerLayout = new RelativeLayout(this);
-        LinearLayout.LayoutParams outerLayoutParams = new LinearLayout.LayoutParams(MATCH_PARENT, WRAP_CONTENT);
-        outerLayout.setLayoutParams(outerLayoutParams);
-        moPubBrowserView.addView(outerLayout);
-
-        LinearLayout innerLayout = new LinearLayout(this);
-        innerLayout.setId(INNER_LAYOUT_ID);
-        RelativeLayout.LayoutParams innerLayoutParams = new RelativeLayout.LayoutParams(MATCH_PARENT, WRAP_CONTENT);
-        innerLayoutParams.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM);
-        innerLayout.setLayoutParams(innerLayoutParams);
-        innerLayout.setBackgroundDrawable(BACKGROUND.createDrawable(this));
-        outerLayout.addView(innerLayout);
-
-        mBackButton = getButton(LEFT_ARROW.createDrawable(this));
-        mForwardButton = getButton(RIGHT_ARROW.createDrawable(this));
-        mRefreshButton = getButton(REFRESH.createDrawable(this));
-        mCloseButton = getButton(CLOSE.createDrawable(this));
-
-        innerLayout.addView(mBackButton);
-        innerLayout.addView(mForwardButton);
-        innerLayout.addView(mRefreshButton);
-        innerLayout.addView(mCloseButton);
-
-        mWebView = new BaseWebView(this);
-        RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(MATCH_PARENT, MATCH_PARENT);
-        layoutParams.addRule(RelativeLayout.ABOVE, INNER_LAYOUT_ID);
-        mWebView.setLayoutParams(layoutParams);
-        outerLayout.addView(mWebView);
-
-        return moPubBrowserView;
-    }
-
-    private ImageButton getButton(final Drawable drawable) {
-        ImageButton imageButton = new ImageButton(this);
-
-        LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(WRAP_CONTENT, WRAP_CONTENT, 1f);
-        layoutParams.gravity = Gravity.CENTER_VERTICAL;
-        imageButton.setLayoutParams(layoutParams);
-
-        imageButton.setImageDrawable(drawable);
-
-        return imageButton;
-    }
-
-    @Deprecated
-    @VisibleForTesting
-    void setWebView(WebView webView) {
-        mWebView = webView;
-    }
-}
+package com.mopub.common;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.graphics.Bitmap;
+import android.graphics.Color;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.os.Bundle;
+import android.view.Gravity;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.Window;
+import android.webkit.CookieSyncManager;
+import android.webkit.WebChromeClient;
+import android.webkit.WebSettings;
+import android.webkit.WebView;
+import android.webkit.WebViewClient;
+import android.widget.ImageButton;
+import android.widget.LinearLayout;
+import android.widget.RelativeLayout;
+
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.mobileads.BaseWebView;
+import com.mopub.mobileads.util.WebViews;
+
+import static android.view.ViewGroup.LayoutParams.MATCH_PARENT;
+import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;
+import static com.mopub.common.util.Drawables.BACKGROUND;
+import static com.mopub.common.util.Drawables.CLOSE;
+import static com.mopub.common.util.Drawables.LEFT_ARROW;
+import static com.mopub.common.util.Drawables.REFRESH;
+import static com.mopub.common.util.Drawables.RIGHT_ARROW;
+import static com.mopub.common.util.Drawables.UNLEFT_ARROW;
+import static com.mopub.common.util.Drawables.UNRIGHT_ARROW;
+import static com.mopub.common.util.Intents.deviceCanHandleIntent;
+
+public class MoPubBrowser extends Activity {
+    public static final String DESTINATION_URL_KEY = "URL";
+    private static final int INNER_LAYOUT_ID = 1;
+
+    private WebView mWebView;
+    private ImageButton mBackButton;
+    private ImageButton mForwardButton;
+    private ImageButton mRefreshButton;
+    private ImageButton mCloseButton;
+
+    public static void open(final Context context, final String url) {
+        MoPubLog.d("Opening url in MoPubBrowser: " + url);
+        final Intent intent = new Intent(context, MoPubBrowser.class);
+        intent.putExtra(DESTINATION_URL_KEY, url);
+        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        context.startActivity(intent);
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        setResult(Activity.RESULT_OK);
+
+        getWindow().requestFeature(Window.FEATURE_PROGRESS);
+        getWindow().setFeatureInt(Window.FEATURE_PROGRESS, Window.PROGRESS_VISIBILITY_ON);
+
+        setContentView(getMoPubBrowserView());
+
+        initializeWebView();
+        initializeButtons();
+        enableCookies();
+    }
+
+    private void initializeWebView() {
+        WebSettings webSettings = mWebView.getSettings();
+
+        webSettings.setJavaScriptEnabled(true);
+
+        /**
+         * Pinch to zoom is apparently not enabled by default on all devices, so
+         * declare zoom support explicitly.
+         * http://stackoverflow.com/questions/5125851/enable-disable-zoom-in-android-webview
+         */
+        webSettings.setSupportZoom(true);
+        webSettings.setBuiltInZoomControls(true);
+        webSettings.setUseWideViewPort(true);
+
+        mWebView.loadUrl(getIntent().getStringExtra(DESTINATION_URL_KEY));
+        mWebView.setWebViewClient(new WebViewClient() {
+            @Override
+            public void onReceivedError(WebView view, int errorCode, String description,
+                    String failingUrl) {
+                MoPubLog.d("MoPubBrowser error: " + description);
+            }
+
+            @Override
+            public boolean shouldOverrideUrlLoading(WebView view, String url) {
+                if (url == null) {
+                    return false;
+                }
+
+                final Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
+                if (UrlAction.FOLLOW_DEEP_LINK.shouldTryHandlingUrl(Uri.parse(url))
+                        && deviceCanHandleIntent(MoPubBrowser.this, intent)) {
+                    startActivity(intent);
+                    finish();
+                    return true;
+                } else {
+                    return false;
+                }
+            }
+
+            @Override
+            public void onPageStarted(WebView view, String url, Bitmap favicon) {
+                super.onPageStarted(view, url, favicon);
+                mForwardButton.setImageDrawable(UNRIGHT_ARROW.createDrawable(MoPubBrowser.this));
+            }
+
+            @Override
+            public void onPageFinished(WebView view, String url) {
+                super.onPageFinished(view, url);
+
+                Drawable backImageDrawable = view.canGoBack()
+                        ? LEFT_ARROW.createDrawable(MoPubBrowser.this)
+                        : UNLEFT_ARROW.createDrawable(MoPubBrowser.this);
+                mBackButton.setImageDrawable(backImageDrawable);
+
+                Drawable forwardImageDrawable = view.canGoForward()
+                        ? RIGHT_ARROW.createDrawable(MoPubBrowser.this)
+                        : UNRIGHT_ARROW.createDrawable(MoPubBrowser.this);
+                mForwardButton.setImageDrawable(forwardImageDrawable);
+            }
+        });
+
+        mWebView.setWebChromeClient(new WebChromeClient() {
+            public void onProgressChanged(WebView webView, int progress) {
+                setTitle("Loading...");
+                setProgress(progress * 100);
+                if (progress == 100) {
+                    setTitle(webView.getUrl());
+                }
+            }
+        });
+    }
+
+    private void initializeButtons() {
+        mBackButton.setBackgroundColor(Color.TRANSPARENT);
+        mBackButton.setOnClickListener(new View.OnClickListener() {
+            public void onClick(View v) {
+                if (mWebView.canGoBack()) {
+                    mWebView.goBack();
+                }
+            }
+        });
+
+        mForwardButton.setBackgroundColor(Color.TRANSPARENT);
+        mForwardButton.setOnClickListener(new View.OnClickListener() {
+            public void onClick(View v) {
+                if (mWebView.canGoForward()) {
+                    mWebView.goForward();
+                }
+            }
+        });
+
+        mRefreshButton.setBackgroundColor(Color.TRANSPARENT);
+        mRefreshButton.setOnClickListener(new View.OnClickListener() {
+            public void onClick(View v) {
+                mWebView.reload();
+            }
+        });
+
+        mCloseButton.setBackgroundColor(Color.TRANSPARENT);
+        mCloseButton.setOnClickListener(new View.OnClickListener() {
+            public void onClick(View v) {
+                MoPubBrowser.this.finish();
+            }
+        });
+    }
+
+    private void enableCookies() {
+        CookieSyncManager.createInstance(this);
+        CookieSyncManager.getInstance().startSync();
+    }
+
+    @Override
+    protected void onPause() {
+        super.onPause();
+        CookieSyncManager.getInstance().stopSync();
+        WebViews.onPause(mWebView, isFinishing());
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        CookieSyncManager.getInstance().startSync();
+        WebViews.onResume(mWebView);
+    }
+
+    @Override
+    public void finish() {
+        // ZoomButtonController adds buttons to the window's decorview. If they're still visible
+        // when finish() is called, they need to be removed or a Window object will be leaked.
+        ViewGroup decorView = (ViewGroup) getWindow().getDecorView();
+        decorView.removeAllViews();
+        super.finish();
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        mWebView.destroy();
+        mWebView = null;
+    }
+
+    private View getMoPubBrowserView() {
+        LinearLayout moPubBrowserView = new LinearLayout(this);
+        LinearLayout.LayoutParams browserLayoutParams = new LinearLayout.LayoutParams(MATCH_PARENT, MATCH_PARENT);
+        moPubBrowserView.setLayoutParams(browserLayoutParams);
+        moPubBrowserView.setOrientation(LinearLayout.VERTICAL);
+
+        RelativeLayout outerLayout = new RelativeLayout(this);
+        LinearLayout.LayoutParams outerLayoutParams = new LinearLayout.LayoutParams(MATCH_PARENT, WRAP_CONTENT);
+        outerLayout.setLayoutParams(outerLayoutParams);
+        moPubBrowserView.addView(outerLayout);
+
+        LinearLayout innerLayout = new LinearLayout(this);
+        innerLayout.setId(INNER_LAYOUT_ID);
+        RelativeLayout.LayoutParams innerLayoutParams = new RelativeLayout.LayoutParams(MATCH_PARENT, WRAP_CONTENT);
+        innerLayoutParams.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM);
+        innerLayout.setLayoutParams(innerLayoutParams);
+        innerLayout.setBackgroundDrawable(BACKGROUND.createDrawable(this));
+        outerLayout.addView(innerLayout);
+
+        mBackButton = getButton(LEFT_ARROW.createDrawable(this));
+        mForwardButton = getButton(RIGHT_ARROW.createDrawable(this));
+        mRefreshButton = getButton(REFRESH.createDrawable(this));
+        mCloseButton = getButton(CLOSE.createDrawable(this));
+
+        innerLayout.addView(mBackButton);
+        innerLayout.addView(mForwardButton);
+        innerLayout.addView(mRefreshButton);
+        innerLayout.addView(mCloseButton);
+
+        mWebView = new BaseWebView(this);
+        RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(MATCH_PARENT, MATCH_PARENT);
+        layoutParams.addRule(RelativeLayout.ABOVE, INNER_LAYOUT_ID);
+        mWebView.setLayoutParams(layoutParams);
+        outerLayout.addView(mWebView);
+
+        return moPubBrowserView;
+    }
+
+    private ImageButton getButton(final Drawable drawable) {
+        ImageButton imageButton = new ImageButton(this);
+
+        LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(WRAP_CONTENT, WRAP_CONTENT, 1f);
+        layoutParams.gravity = Gravity.CENTER_VERTICAL;
+        imageButton.setLayoutParams(layoutParams);
+
+        imageButton.setImageDrawable(drawable);
+
+        return imageButton;
+    }
+
+    @Deprecated
+    @VisibleForTesting
+    void setWebView(WebView webView) {
+        mWebView = webView;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/UrlAction.java b/mopub-sdk/src/main/java/com/mopub/common/UrlAction.java
new file mode 100644
index 00000000..d8fd9c92
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/UrlAction.java
@@ -0,0 +1,246 @@
+package com.mopub.common;
+
+import android.content.Context;
+import android.content.Intent;
+import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Intents;
+import com.mopub.exceptions.IntentNotResolvableException;
+import com.mopub.exceptions.UrlParseException;
+
+import static com.mopub.common.Constants.HTTP;
+import static com.mopub.common.Constants.HTTPS;
+import static com.mopub.common.UrlHandler.MoPubSchemeListener;
+
+/**
+ * {@code UrlAction} describes the different kinds of actions for URLs that {@link UrlHandler} can
+ * potentially perform and how to match against each URL.
+ */
+public enum UrlAction {
+    /**
+     * NOTE: The order in which these are defined determines the priority when matching URLs!
+     * If a URL matches multiple Url Actions, it will be handled by the one that appears first in
+     * this enum (see {@link UrlHandler#handleUrl(Context, String)}).
+     *
+     * Each UrlAction includes its ordinal in a comment as a reminder of this fact.
+     */
+
+    /* 0 */ HANDLE_MOPUB_SCHEME(false) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            return "mopub".equals(uri.getScheme());
+        }
+
+        @Override
+        protected void performAction(@NonNull final Context context, @NonNull final Uri uri,
+                final boolean skipShowMoPubBrowser,
+                @Nullable final MoPubSchemeListener moPubSchemeListener)
+                throws IntentNotResolvableException {
+            final String host = uri.getHost();
+
+            if ("finishLoad".equals(host)) {
+                moPubSchemeListener.onFinishLoad();
+            } else if ("close".equals(host)) {
+                moPubSchemeListener.onClose();
+            } else if ("failLoad".equals(host)) {
+                moPubSchemeListener.onFailLoad();
+            } else {
+                throw new IntentNotResolvableException("Could not handle MoPub Scheme url: " + uri);
+            }
+        }
+    },
+
+    /* 1 */ IGNORE_ABOUT_SCHEME(false) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            return "about".equals(uri.getScheme());
+        }
+
+        @Override
+        protected void performAction(@NonNull final Context context, @NonNull final Uri uri,
+                final boolean skipShowMoPubBrowser,
+                @Nullable final MoPubSchemeListener moPubSchemeListener)
+                throws IntentNotResolvableException {
+            MoPubLog.d("Link to about page ignored.");
+        }
+    },
+
+    /* 2 */ HANDLE_PHONE_SCHEME(true) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            final String scheme = uri.getScheme();
+            return "tel".equals(scheme) || "voicemail".equals(scheme)
+                    || "sms".equals(scheme) || "mailto".equals(scheme)
+                    || "geo".equals(scheme)
+                    || "google.streetview".equals(scheme);
+        }
+
+        @Override
+        protected void performAction(@NonNull final Context context, @NonNull final Uri uri,
+                final boolean skipShowMoPubBrowser,
+                @Nullable final MoPubSchemeListener moPubSchemeListener)
+                throws IntentNotResolvableException {
+            final String errorMessage = "Could not handle intent with URI: " + uri + "\n\tIs " +
+                    "this intent supported on your phone?";
+            Intents.launchActionViewIntent(context, uri, errorMessage);
+        }
+    },
+
+    /* 3 */ OPEN_NATIVE_BROWSER(true) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            return "mopubnativebrowser".equals(uri.getScheme());
+        }
+
+        @Override
+        protected void performAction(@NonNull final Context context, @NonNull final Uri uri,
+                final boolean skipShowMoPubBrowser,
+                @Nullable final MoPubSchemeListener moPubSchemeListener)
+                throws IntentNotResolvableException {
+            final String errorMessage = "Unable to load mopub native browser url: " + uri;
+            try {
+                final Intent intent = Intents.intentForNativeBrowserScheme(uri);
+                Intents.launchIntentForUserClick(context, intent, errorMessage);
+            } catch (UrlParseException e) {
+                throw new IntentNotResolvableException(errorMessage + "\n\t" + e.getMessage());
+            }
+        }
+    },
+
+    /* 4 */ OPEN_APP_MARKET(true) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            final String scheme = uri.getScheme();
+            final String host = uri.getHost();
+
+            return "play.google.com".equals(host) || "market.android.com".equals(host)
+                    || "market".equals(scheme)
+                    || uri.toString().startsWith("play.google.com/")
+                    || uri.toString().startsWith("market.android.com/");
+        }
+
+        @Override
+        protected void performAction(@NonNull final Context context, @NonNull final Uri uri,
+                final boolean skipShowMoPubBrowser,
+                @Nullable final MoPubSchemeListener moPubSchemeListener)
+                throws IntentNotResolvableException {
+            Intents.launchApplicationUrl(context, uri);
+        }
+    },
+
+    /* 5 */ OPEN_IN_APP_BROWSER(true) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            final String scheme = uri.getScheme();
+            return (HTTP.equals(scheme) || HTTPS.equals(scheme));
+        }
+
+        @Override
+        protected void performAction(@NonNull final Context context, @NonNull final Uri uri,
+                final boolean skipShowMoPubBrowser,
+                @Nullable final MoPubSchemeListener moPubSchemeListener)
+                throws IntentNotResolvableException {
+            if (!skipShowMoPubBrowser) {
+                Intents.showMoPubBrowserForUrl(context, uri);
+            }
+        }
+    },
+
+    /**
+     * This handles tweet sharing via the chooser dialog.
+     * See {@link Intents#intentForShareTweet(Uri)} for more details.
+     */
+    /* 6 */ HANDLE_SHARE_TWEET(true) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            Preconditions.checkNotNull(uri);
+            return "mopubshare".equals(uri.getScheme()) && "tweet".equals(uri.getHost());
+        }
+
+        @Override
+        protected void performAction(@NonNull final Context context, @NonNull final Uri uri,
+                final boolean skipShowMoPubBrowser,
+                @Nullable final MoPubSchemeListener moPubSchemeListener)
+                throws IntentNotResolvableException {
+            Preconditions.checkNotNull(context);
+            Preconditions.checkNotNull(uri);
+
+            final String chooserText = "Share via";
+            final String errorMessage = "Could not handle share tweet intent with URI " + uri;
+            try {
+                final Intent shareTweetIntent = Intents.intentForShareTweet(uri);
+                final Intent chooserIntent = Intent.createChooser(shareTweetIntent, chooserText);
+                Intents.launchIntentForUserClick(context, chooserIntent, errorMessage);
+            } catch (UrlParseException e) {
+                throw new IntentNotResolvableException(errorMessage + "\n\t" + e.getMessage());
+            }
+        }
+    },
+
+    /* 7 */ FOLLOW_DEEP_LINK(true) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            final String scheme = uri.getScheme();
+            final String host = uri.getHost();
+            return !TextUtils.isEmpty(scheme) && !TextUtils.isEmpty(host);
+        }
+
+        @Override
+        protected void performAction(@NonNull final Context context, @NonNull final Uri uri,
+                final boolean skipShowMoPubBrowser,
+                @Nullable final MoPubSchemeListener moPubSchemeListener)
+                throws IntentNotResolvableException {
+            Intents.launchApplicationUrl(context, uri);
+        }
+    },
+
+    /* This is essentially an "unspecified" value for UrlAction. */
+    NOOP(false) {
+        @Override
+        public boolean shouldTryHandlingUrl(@NonNull final Uri uri) {
+            return false;
+        }
+
+        @Override
+        protected void performAction(@NonNull final Context context, @NonNull final Uri uri,
+                final boolean skipShowMoPubBrowser,
+                @Nullable final MoPubSchemeListener moPubSchemeListener)
+                throws IntentNotResolvableException { }
+    };
+
+    public void handleUrl(
+            @NonNull final Context context,
+            @NonNull final Uri destinationUri,
+            final boolean fromUserInteraction,
+            final boolean skipShowMoPubBrowser,
+            @Nullable final MoPubSchemeListener moPubSchemeListener)
+            throws IntentNotResolvableException {
+        MoPubLog.d("Ad event URL: " + destinationUri);
+        if (mRequiresUserInteraction && !fromUserInteraction) {
+            throw new IntentNotResolvableException("Attempted to handle action without user " +
+                    "interaction.");
+        } else {
+            performAction(context, destinationUri, skipShowMoPubBrowser,
+                    moPubSchemeListener);
+        }
+    }
+
+    private final boolean mRequiresUserInteraction;
+
+    UrlAction(boolean requiresUserInteraction) {
+        mRequiresUserInteraction = requiresUserInteraction;
+    }
+
+    public abstract boolean shouldTryHandlingUrl(@NonNull final Uri uri);
+
+    protected abstract void performAction(
+            @NonNull final Context context,
+            @NonNull final Uri uri,
+            final boolean skipShowMoPubBrowser,
+            @Nullable final MoPubSchemeListener moPubSchemeListener)
+            throws IntentNotResolvableException;
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/UrlHandler.java b/mopub-sdk/src/main/java/com/mopub/common/UrlHandler.java
new file mode 100644
index 00000000..9d62edc1
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/UrlHandler.java
@@ -0,0 +1,224 @@
+package com.mopub.common;
+
+import android.content.Context;
+import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Intents;
+import com.mopub.exceptions.IntentNotResolvableException;
+
+import java.util.EnumSet;
+
+
+/**
+ * {@code UrlHandler} facilitates handling user clicks on different URLs, allowing configuration
+ * for which kinds of URLs to handle and then responding accordingly for a given URL.
+ *
+ * This class is designed to be instantiated for a single use by immediately calling its {@link
+ * #handleUrl(Context, String)} method upon constructing it.
+ */
+public class UrlHandler {
+
+    /**
+     * {@code ClickListener} defines the methods that {@link UrlHandler} calls when handling a
+     * certain click succeeds or fails.
+     */
+    public interface ResultActions {
+        /**
+         * Called if the URL matched a supported {@link UrlAction} and was resolvable. Will be
+         * called at most 1 times and is mutually exclusive with
+         * {@link ResultActions#urlHandlingFailed(String, UrlAction)}.
+         */
+        void urlHandlingSucceeded(@NonNull final String url, @NonNull final UrlAction urlAction);
+
+        /**
+         * Called with {@link UrlAction#NOOP} if the URL did not match any supported
+         * {@link UrlAction}s; or, called with the last matching {@link UrlAction} if URL was
+         * unresolvable. Will be called at most 1 times and is mutually exclusive with
+         * {@link ResultActions#urlHandlingSucceeded(String, UrlAction)}.
+         */
+        void urlHandlingFailed(@NonNull final String url,
+                @NonNull final UrlAction lastFailedUrlAction);
+    }
+
+    /**
+     * {@code MoPubSchemeListener} defines the methods that {@link UrlHandler} calls when handling
+     * {@code HANDLE_MOPUB_SCHEME} URLs.
+     */
+    public interface MoPubSchemeListener {
+        void onFinishLoad();
+        void onClose();
+        void onFailLoad();
+    }
+
+    /**
+     * {@code Builder} provides an API to configure an immutable {@link UrlHandler} and create it.
+     */
+    public static class Builder {
+        @NonNull
+        private EnumSet<UrlAction> supportedUrlActions = EnumSet.of(UrlAction.NOOP);
+        @NonNull
+        private ResultActions resultActions = EMPTY_CLICK_LISTENER;
+        @NonNull
+        private MoPubSchemeListener moPubSchemeListener = EMPTY_MOPUB_SCHEME_LISTENER;
+        private boolean skipShowMoPubBrowser = false;
+
+        /**
+         * Sets the {@link UrlAction}s to support in the {@code UrlHandler} to build.
+         *
+         * @param first A {@code UrlAction} for the {@code UrlHandler} to support.
+         * @param others An arbitrary number of {@code UrlAction}s for the {@code UrlHandler} to
+         * support.
+         * @return A {@link com.mopub.common.UrlHandler.Builder} with the desired supported
+         * {@code UrlAction}s added.
+         */
+        public Builder withSupportedUrlActions(@NonNull final UrlAction first,
+                @Nullable final UrlAction... others) {
+            this.supportedUrlActions = EnumSet.of(first, others);
+            return this;
+        }
+
+        /**
+         * Sets the {@link ResultActions} for the {@code UrlHandler} to
+         * build.
+         *
+         * @param resultActions A {@code ClickListener} for the {@code UrlHandler}.
+         * @return A {@link com.mopub.common.UrlHandler.Builder} with the desired
+         * {@code ClickListener} added.
+         */
+        public Builder withResultActions(@NonNull final ResultActions resultActions) {
+            this.resultActions = resultActions;
+            return this;
+        }
+
+        /**
+         * Sets the {@link com.mopub.common.UrlHandler.MoPubSchemeListener} for the
+         * {@code UrlHandler} to build.
+         *
+         * @param moPubSchemeListener A {@code MoPubSchemeListener} for the {@code UrlHandler}.
+         * @return A {@link com.mopub.common.UrlHandler.Builder} with the desired
+         * {@code MoPubSchemeListener} added.
+         */
+        public Builder withMoPubSchemeListener(
+                @NonNull final MoPubSchemeListener moPubSchemeListener) {
+            this.moPubSchemeListener = moPubSchemeListener;
+            return this;
+        }
+
+        /**
+         * If called, will avoid starting a {@link MoPubBrowser} activity where applicable.
+         * (see {@link Intents#showMoPubBrowserForUrl(Context, Uri)})
+         *
+         * @return A {@link com.mopub.common.UrlHandler.Builder} that will skip starting a
+         * {@code MoPubBrowser}.
+         */
+        public Builder withoutMoPubBrowser() {
+            this.skipShowMoPubBrowser = true;
+            return this;
+        }
+
+        /**
+         * Creates an immutable {@link UrlHandler} with the desired configuration, according to the
+         * other {@link com.mopub.common.UrlHandler.Builder} methods called before.
+         *
+         * @return An immutable {@code UrlHandler} with the desired configuration.
+         */
+        public UrlHandler build() {
+            return new UrlHandler(supportedUrlActions, resultActions, moPubSchemeListener,
+                    skipShowMoPubBrowser);
+        }
+    }
+
+    private static final ResultActions EMPTY_CLICK_LISTENER = new ResultActions() {
+        @Override
+        public void urlHandlingSucceeded(@NonNull String url, @NonNull UrlAction urlAction) { }
+        @Override
+        public void urlHandlingFailed(@NonNull String url, @NonNull UrlAction lastFailedUrlAction) { }
+    };
+
+    private static final MoPubSchemeListener EMPTY_MOPUB_SCHEME_LISTENER =
+            new MoPubSchemeListener() {
+        @Override public void onFinishLoad() { }
+
+        @Override public void onClose() { }
+
+        @Override public void onFailLoad() { }
+    };
+
+    @NonNull
+    private EnumSet<UrlAction> mSupportedUrlActions;
+    @NonNull
+    private ResultActions mResultActions;
+    @NonNull
+    private MoPubSchemeListener mMoPubSchemeListener;
+    private boolean mSkipShowMoPubBrowser;
+
+    /**
+     * Do not instantiate UrlHandler directly; use {@link com.mopub.common.UrlHandler.Builder}
+     * instead.
+     */
+    private UrlHandler(
+            @NonNull final EnumSet<UrlAction> supportedUrlActions,
+            @NonNull final ResultActions resultActions,
+            @NonNull final MoPubSchemeListener moPubSchemeListener,
+            final boolean skipShowMoPubBrowser) {
+        mResultActions = resultActions;
+        mMoPubSchemeListener = moPubSchemeListener;
+        mSkipShowMoPubBrowser = skipShowMoPubBrowser;
+        mSupportedUrlActions = supportedUrlActions;
+    }
+
+    /**
+     * Performs the actual click handling by verifying that the {@code destinationUrl} is one of
+     * the configured supported {@link UrlAction}s and then handling it accordingly.
+     *
+     * @param context The activity context.
+     * @param destinationUrl The URL to handle.
+     */
+    public void handleUrl(@NonNull final Context context, @NonNull final String destinationUrl) {
+        handleUrl(context, destinationUrl, true);
+    }
+
+    /**
+     * Performs the actual click handling by verifying that the {@code destinationUrl} is one of
+     * the configured supported {@link UrlAction}s and then handling it accordingly.
+     *
+     * @param context The activity context.
+     * @param destinationUrl The URL to handle.
+     * @param fromUserInteraction Whether this handling was triggered from a user interaction.
+     */
+    public void handleUrl(@NonNull final Context context, @NonNull final String destinationUrl,
+            final boolean fromUserInteraction) {
+        UrlAction lastFailedUrlAction = UrlAction.NOOP;
+
+        if (TextUtils.isEmpty(destinationUrl)) {
+            MoPubLog.d("Attempted to handle empty url.");
+        } else {
+            final Uri destinationUri = Uri.parse(destinationUrl);
+            for (final UrlAction urlAction : mSupportedUrlActions) {
+                if (urlAction.shouldTryHandlingUrl(destinationUri)) {
+                    try {
+                        urlAction.handleUrl(context, destinationUri, fromUserInteraction,
+                                mSkipShowMoPubBrowser, mMoPubSchemeListener);
+                        if (!UrlAction.IGNORE_ABOUT_SCHEME.equals(urlAction) &&
+                                !UrlAction.HANDLE_MOPUB_SCHEME.equals(urlAction)) {
+                            mResultActions.urlHandlingSucceeded(destinationUri.toString(),
+                                    urlAction);
+                        }
+                        return;
+                    } catch (IntentNotResolvableException e) {
+                        MoPubLog.d(e.getMessage(), e);
+                        lastFailedUrlAction = urlAction;
+                        // continue trying to match...
+                    }
+                }
+            }
+            MoPubLog.d("Link ignored. Unable to handle url: " + destinationUrl);
+        }
+
+        mResultActions.urlHandlingFailed(destinationUrl, lastFailedUrlAction);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/Intents.java b/mopub-sdk/src/main/java/com/mopub/common/util/Intents.java
index 94feced3..1af522f5 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/Intents.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Intents.java
@@ -1,182 +1,257 @@
-package com.mopub.common.util;
-
-import android.app.Activity;
-import android.content.ActivityNotFoundException;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.content.pm.ResolveInfo;
-import android.net.Uri;
-import android.os.Bundle;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-
-import com.mopub.common.Preconditions;
-import com.mopub.common.logging.MoPubLog;
-import com.mopub.exceptions.IntentNotResolvableException;
-import com.mopub.exceptions.UrlParseException;
-
-import java.util.List;
-
-import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
-import static com.mopub.common.Constants.HTTP;
-import static com.mopub.common.Constants.HTTPS;
-
-public class Intents {
-    private static final String PLAY_GOOGLE_COM = "play.google.com";
-    private static final String MARKET_ANDROID_COM = "market.android.com";
-    private static final String MARKET = "market";
-
-    private Intents() {}
-
-    public static void startActivity(@NonNull final Context context, @NonNull final Intent intent)
-            throws IntentNotResolvableException {
-        Preconditions.checkNotNull(context);
-        Preconditions.checkNotNull(intent);
-
-        if (!(context instanceof Activity)) {
-            intent.addFlags(FLAG_ACTIVITY_NEW_TASK);
-        }
-
-        try {
-            context.startActivity(intent);
-        } catch (ActivityNotFoundException e) {
-            throw new IntentNotResolvableException(e);
-        }
-    }
-
-    /**
-     * Adding FLAG_ACTIVITY_NEW_TASK with startActivityForResult will always result in a
-     * RESULT_CANCELED, so don't use it for Activity contexts.
-     */
-    public static Intent getStartActivityIntent(@NonNull final Context context,
-            @NonNull final Class clazz, @Nullable final Bundle extras) {
-        final Intent intent = new Intent(context, clazz);
-
-        if (!(context instanceof Activity)) {
-            intent.addFlags(FLAG_ACTIVITY_NEW_TASK);
-        }
-
-        if (extras != null) {
-            intent.putExtras(extras);
-        }
-
-        return intent;
-    }
-
-    public static boolean deviceCanHandleIntent(@NonNull final Context context,
-            @NonNull final Intent intent) {
-        try {
-            final PackageManager packageManager = context.getPackageManager();
-            final List<ResolveInfo> activities = packageManager.queryIntentActivities(intent, 0);
-            return !activities.isEmpty();
-        } catch (NullPointerException e) {
-            return false;
-        }
-    }
-
-    public static boolean isHttpUrl(final String url) {
-        if (url == null) {
-            return false;
-        }
-
-        final String scheme = Uri.parse(url).getScheme();
-        return (HTTP.equals(scheme) || HTTPS.equals(scheme));
-    }
-
-    private static boolean isAppStoreUrl(final String url) {
-        if (url == null) {
-            return false;
-        }
-
-        final Uri uri = Uri.parse(url);
-        final String scheme = uri.getScheme();
-        final String host = uri.getHost();
-
-        if (PLAY_GOOGLE_COM.equals(host) || MARKET_ANDROID_COM.equals(host)) {
-            return true;
-        }
-
-        if (MARKET.equals(scheme)) {
-            return true;
-        }
-
-        return false;
-    }
-
-    public static boolean isDeepLink(final String url) {
-        return isAppStoreUrl(url) || !isHttpUrl(url);
-    }
-
-    public static boolean canHandleApplicationUrl(final Context context, final String url) {
-        return canHandleApplicationUrl(context, url, true);
-    }
-
-    public static boolean canHandleApplicationUrl(final Context context, final String url,
-            final boolean logError) {
-        // Determine which activities can handle the intent
-        final Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
-
-        // If there are no relevant activities, don't follow the link
-        if (!Intents.deviceCanHandleIntent(context, intent)) {
-            if (logError) {
-                MoPubLog.w("Could not handle application specific action: " + url + ". " +
-                        "You may be running in the emulator or another device which does not " +
-                        "have the required application.");
-            }
-            return false;
-        }
-
-        return true;
-    }
-
-    public static boolean isNativeBrowserScheme(@NonNull final String url) {
-        return url.startsWith("mopubnativebrowser://");
-    }
-
-    public static boolean isAboutScheme(@NonNull final String url) {
-        return "about".equals(Uri.parse(url).getScheme());
-    }
-
-    /**
-     * Native Browser Scheme URLs provide a means for advertisers to include links that click out to
-     * an external browser, rather than the MoPub in-app browser. Properly formatted native browser
-     * URLs take the form of "mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.mopub.com".
-     *
-     * @param url
-     * @return An Intent that will open an app-external browser taking the user to a page specified
-     * in the query parameter of the passed-in url
-     * @throws UrlParseException if the provided url has an invalid format or is non-hierarchical
-     */
-    public static Intent intentForNativeBrowserScheme(@NonNull final String url)
-            throws UrlParseException {
-        Preconditions.checkNotNull(url);
-
-        if (!isNativeBrowserScheme(url)) {
-            throw new UrlParseException("URL does not have mopubnativebrowser:// scheme.");
-        }
-
-        final Uri uri = Uri.parse(url);
-
-        if (!"navigate".equals(uri.getHost())) {
-            throw new UrlParseException("URL missing 'navigate' host parameter.");
-        }
-
-        final String urlToOpenInNativeBrowser;
-        try {
-            urlToOpenInNativeBrowser = uri.getQueryParameter("url");
-        } catch (UnsupportedOperationException e) {
-            // Accessing query parameters only makes sense for hierarchical URIs as per:
-            // http://developer.android.com/reference/android/net/Uri.html#getQueryParameter(java.lang.String)
-            MoPubLog.w("Could not handle url: " + url);
-            throw new UrlParseException("Passed-in URL did not create a hierarchical URI.");
-        }
-
-        if (urlToOpenInNativeBrowser == null) {
-            throw new UrlParseException("URL missing 'url' query parameter.");
-        }
-
-        final Uri intentUri = Uri.parse(urlToOpenInNativeBrowser);
-        return new Intent(Intent.ACTION_VIEW, intentUri);
-    }
-}
+package com.mopub.common.util;
+
+import android.app.Activity;
+import android.content.ActivityNotFoundException;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.net.Uri;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import com.mopub.common.MoPubBrowser;
+import com.mopub.common.Preconditions;
+import com.mopub.common.UrlAction;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.exceptions.IntentNotResolvableException;
+import com.mopub.exceptions.UrlParseException;
+
+import java.util.List;
+
+import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
+
+public class Intents {
+
+    private Intents() {}
+
+    public static void startActivity(@NonNull final Context context, @NonNull final Intent intent)
+            throws IntentNotResolvableException {
+        Preconditions.checkNotNull(context);
+        Preconditions.checkNotNull(intent);
+
+        if (!(context instanceof Activity)) {
+            intent.addFlags(FLAG_ACTIVITY_NEW_TASK);
+        }
+
+        try {
+            context.startActivity(intent);
+        } catch (ActivityNotFoundException e) {
+            throw new IntentNotResolvableException(e);
+        }
+    }
+
+    /**
+     * Adding FLAG_ACTIVITY_NEW_TASK with startActivityForResult will always result in a
+     * RESULT_CANCELED, so don't use it for Activity contexts.
+     */
+    public static Intent getStartActivityIntent(@NonNull final Context context,
+            @NonNull final Class clazz, @Nullable final Bundle extras) {
+        final Intent intent = new Intent(context, clazz);
+
+        if (!(context instanceof Activity)) {
+            intent.addFlags(FLAG_ACTIVITY_NEW_TASK);
+        }
+
+        if (extras != null) {
+            intent.putExtras(extras);
+        }
+
+        return intent;
+    }
+
+    public static boolean deviceCanHandleIntent(@NonNull final Context context,
+            @NonNull final Intent intent) {
+        try {
+            final PackageManager packageManager = context.getPackageManager();
+            final List<ResolveInfo> activities = packageManager.queryIntentActivities(intent, 0);
+            return !activities.isEmpty();
+        } catch (NullPointerException e) {
+            return false;
+        }
+    }
+
+    public static boolean canHandleApplicationUrl(final Context context, final Uri uri) {
+        return canHandleApplicationUrl(context, uri, true);
+    }
+
+    public static boolean canHandleApplicationUrl(final Context context, final Uri uri,
+            final boolean logError) {
+        // Determine which activities can handle the intent
+        final Intent intent = new Intent(Intent.ACTION_VIEW, uri);
+
+        // If there are no relevant activities, don't follow the link
+        if (!Intents.deviceCanHandleIntent(context, intent)) {
+            if (logError) {
+                MoPubLog.w("Could not handle application specific action: " + uri + ". " +
+                        "You may be running in the emulator or another device which does not " +
+                        "have the required application.");
+            }
+            return false;
+        }
+
+        return true;
+    }
+
+    /**
+     * Native Browser Scheme URLs provide a means for advertisers to include links that click out to
+     * an external browser, rather than the MoPub in-app browser. Properly formatted native browser
+     * URLs take the form of "mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.mopub.com".
+     *
+     * @param uri The Native Browser Scheme URL to open in the external browser.
+     * @return An Intent that will open an app-external browser taking the user to a page specified
+     * in the query parameter of the passed-in url
+     * @throws UrlParseException if the provided url has an invalid format or is non-hierarchical
+     */
+    public static Intent intentForNativeBrowserScheme(@NonNull final Uri uri)
+            throws UrlParseException {
+        Preconditions.checkNotNull(uri);
+
+        if (!UrlAction.OPEN_NATIVE_BROWSER.shouldTryHandlingUrl(uri)) {
+            throw new UrlParseException("URL does not have mopubnativebrowser:// scheme.");
+        }
+
+        if (!"navigate".equals(uri.getHost())) {
+            throw new UrlParseException("URL missing 'navigate' host parameter.");
+        }
+
+        final String urlToOpenInNativeBrowser;
+        try {
+            urlToOpenInNativeBrowser = uri.getQueryParameter("url");
+        } catch (UnsupportedOperationException e) {
+            // Accessing query parameters only makes sense for hierarchical URIs as per:
+            // http://developer.android.com/reference/android/net/Uri.html#getQueryParameter(java.lang.String)
+            MoPubLog.w("Could not handle url: " + uri);
+            throw new UrlParseException("Passed-in URL did not create a hierarchical URI.");
+        }
+
+        if (urlToOpenInNativeBrowser == null) {
+            throw new UrlParseException("URL missing 'url' query parameter.");
+        }
+
+        final Uri intentUri = Uri.parse(urlToOpenInNativeBrowser);
+        return new Intent(Intent.ACTION_VIEW, intentUri);
+    }
+
+    /**
+     * Share Tweet URLs provide a means for advertisers on Twitter to include tweet links
+     * promoting their products that can be shared via supporting apps on the device.  Any
+     * app with a filter that matches ACTION_SEND and MIME type text/plain is capable of sharing
+     * the tweet link.
+     *
+     * Properly formatted share tweet URLs take the form of
+     * "mopubshare://tweet?screen_name=<SCREEN_NAME>&tweet_id=<TWEET_ID>"
+     *
+     * Both screen_name and tweet_id are required query parameters.  This method does not verify
+     * that their values are existent and valid on Twitter, but UrlParseException would be thrown
+     * if either is missing or empty.
+     *
+     * Example user flow:
+     * Upon clicking "mopubshare://tweet?screen_name=SpaceX&tweet_id=596026229536460802" in an ad,
+     * a chooser dialog with message "Share via" pops up listing existing apps on the device
+     * capable of sharing this tweet link.  After the user chooses an app to share the tweet,
+     * the message “Check out @SpaceX's Tweet: https://twitter.com/SpaceX/status/596026229536460802”
+     * is ready to be shared in the chosen app.
+     *
+     * @param uri The Share Tweet URL indicating the tweet to share
+     * @return An ACTION_SEND intent that will be wrapped in a chooser intent
+     * @throws UrlParseException if the provided url has an invalid format or is non-hierarchical
+     */
+    public static Intent intentForShareTweet(@NonNull final Uri uri)
+            throws UrlParseException {
+        if (!UrlAction.HANDLE_SHARE_TWEET.shouldTryHandlingUrl(uri)) {
+            throw new UrlParseException("URL does not have mopubshare://tweet? format.");
+        }
+
+        final String screenName;
+        final String tweetId;
+
+        try {
+            screenName = uri.getQueryParameter("screen_name");
+            tweetId = uri.getQueryParameter("tweet_id");
+        } catch (UnsupportedOperationException e) {
+            // Accessing query parameters only makes sense for hierarchical URIs as per:
+            // http://developer.android.com/reference/android/net/Uri.html#getQueryParameter(java.lang.String)
+            MoPubLog.w("Could not handle url: " + uri);
+            throw new UrlParseException("Passed-in URL did not create a hierarchical URI.");
+        }
+
+        // If either query parameter is null or empty, throw UrlParseException
+        if (TextUtils.isEmpty(screenName)) {
+            throw new UrlParseException("URL missing non-empty 'screen_name' query parameter.");
+        }
+        if (TextUtils.isEmpty(tweetId)) {
+            throw new UrlParseException("URL missing non-empty 'tweet_id' query parameter.");
+        }
+
+        // Derive the tweet link on Twitter
+        final String tweetUrl = String.format("https://twitter.com/%s/status/%s", screenName, tweetId);
+
+        // Compose the share message
+        final String shareMessage = String.format("Check out @%s's Tweet: %s", screenName, tweetUrl);
+
+        // Construct share intent with the shareMessage in subject and text
+        Intent shareTweetIntent = new Intent(Intent.ACTION_SEND);
+        shareTweetIntent.setType("text/plain");
+        shareTweetIntent.putExtra(Intent.EXTRA_SUBJECT, shareMessage);
+        shareTweetIntent.putExtra(Intent.EXTRA_TEXT, shareMessage);
+
+        return shareTweetIntent;
+    }
+
+    /**
+     * Launches a {@link MoPubBrowser} activity with the desired URL.
+     *  @param context The activity context.
+     * @param uri The URL to load in the started {@link MoPubBrowser} activity.
+     */
+    public static void showMoPubBrowserForUrl(@NonNull final Context context,
+            @NonNull Uri uri) throws IntentNotResolvableException {
+        MoPubLog.d("Final URI to show in browser: " + uri);
+
+        final Bundle extras = new Bundle();
+        extras.putString(MoPubBrowser.DESTINATION_URL_KEY, uri.toString());
+        Intent intent = getStartActivityIntent(context, MoPubBrowser.class, extras);
+
+        String errorMessage = "Could not show MoPubBrowser for url: " + uri + "\n\tPerhaps you " +
+                "forgot to declare com.mopub.common.MoPubBrowser in your Android manifest file.";
+
+        launchIntentForUserClick(context, intent, errorMessage);
+    }
+
+    public static void launchActionViewIntent(Context context, @NonNull final Uri uri,
+            @NonNull final String errorMessage) throws IntentNotResolvableException {
+        final Intent intent = new Intent(Intent.ACTION_VIEW, uri);
+        if (!(context instanceof Activity)) {
+            intent.addFlags(FLAG_ACTIVITY_NEW_TASK);
+        }
+
+        launchIntentForUserClick(context, intent, errorMessage);
+    }
+
+    public static void launchIntentForUserClick(@NonNull final Context context,
+            @NonNull final Intent intent, @Nullable final String errorMessage)
+            throws IntentNotResolvableException {
+        Preconditions.NoThrow.checkNotNull(context);
+        Preconditions.NoThrow.checkNotNull(intent);
+
+        try {
+            Intents.startActivity(context, intent);
+        } catch (IntentNotResolvableException e) {
+            throw new IntentNotResolvableException(errorMessage + "\n" + e.getMessage());
+        }
+    }
+
+    public static void launchApplicationUrl(@NonNull final Context context,
+            @NonNull final Uri uri) throws IntentNotResolvableException {
+        if (Intents.canHandleApplicationUrl(context, uri)) {
+            final String errorMessage = "Unable to open intent for: " + uri;
+            Intents.launchActionViewIntent(context, uri, errorMessage);
+        } else {
+            throw new IntentNotResolvableException("Could not handle application specific " +
+                    "action: " + uri + "\n\tYou may be running in the emulator or another " +
+                    "device which does not have the required application.");
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/exceptions/IntentNotResolvableException.java b/mopub-sdk/src/main/java/com/mopub/exceptions/IntentNotResolvableException.java
index c486bb15..4eb87f6f 100644
--- a/mopub-sdk/src/main/java/com/mopub/exceptions/IntentNotResolvableException.java
+++ b/mopub-sdk/src/main/java/com/mopub/exceptions/IntentNotResolvableException.java
@@ -1,7 +1,11 @@
-package com.mopub.exceptions;
-
-public class IntentNotResolvableException extends Exception {
-    public IntentNotResolvableException(Throwable throwable) {
-        super(throwable);
-    }
-}
+package com.mopub.exceptions;
+
+public class IntentNotResolvableException extends Exception {
+    public IntentNotResolvableException(Throwable throwable) {
+        super(throwable);
+    }
+
+    public IntentNotResolvableException(String message) {
+        super(message);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertReporter.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertReporter.java
index 96a03dc3..ca5087ce 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertReporter.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertReporter.java
@@ -1,196 +1,196 @@
-package com.mopub.mobileads;
-
-import android.content.Context;
-import android.content.Intent;
-import android.graphics.Bitmap;
-import android.net.Uri;
-import android.support.annotation.Nullable;
-import android.util.Base64;
-import android.view.View;
-
-import com.mopub.common.AdReport;
-import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.DateAndTime;
-import com.mopub.common.util.Streams;
-
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Locale;
-
-public class AdAlertReporter {
-    private static final String EMAIL_RECIPIENT = "creative-review@mopub.com";
-    private static final String EMAIL_SCHEME = "mailto:";
-    private static final String SCREEN_SHOT_FILENAME = "mp_adalert_screenshot.png";
-    private static final String PARAMETERS_FILENAME = "mp_adalert_parameters.txt";
-    private static final String MARKUP_FILENAME = "mp_adalert_markup.html";
-    private static final String DATE_FORMAT_PATTERN = "M/d/yy hh:mm:ss a z";
-    private static final int IMAGE_QUALITY = 25;
-    private static final String BODY_SEPARATOR = "\n=================\n";
-
-    private final String mDateString;
-
-    private final View mView;
-    private final Context mContext;
-    private Intent mEmailIntent;
-    private ArrayList<Uri> mEmailAttachments;
-    private String mParameters;
-    private String mResponse;
-
-    public AdAlertReporter(final Context context, final View view, @Nullable final AdReport adReport) {
-        mView = view;
-        mContext = context;
-
-        mEmailAttachments = new ArrayList<Uri>();
-
-        SimpleDateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT_PATTERN, Locale.US);
-        mDateString = dateFormat.format(DateAndTime.now());
-
-        initEmailIntent();
-        Bitmap screenShot = takeScreenShot();
-        String screenShotString = convertBitmapInWEBPToBase64EncodedString(screenShot);
-        mParameters = "";
-        mResponse = "";
-        if (adReport != null) {
-            mParameters = adReport.toString();
-            mResponse = adReport.getResponseString();
-        }
-
-        addEmailSubject();
-        addEmailBody(mParameters, mResponse, screenShotString);
-        addTextAttachment(PARAMETERS_FILENAME, mParameters);
-        addTextAttachment(MARKUP_FILENAME, mResponse);
-        addImageAttachment(SCREEN_SHOT_FILENAME, screenShot);
-    }
-
-    public void send() {
-        mEmailIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, mEmailAttachments);
-
-        Intent chooserIntent = Intent.createChooser(mEmailIntent, "Send Email...");
-        chooserIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-        mContext.startActivity(chooserIntent);
-    }
-
-    private void initEmailIntent() {
-        Uri emailScheme = Uri.parse(EMAIL_SCHEME);
-        mEmailIntent = new Intent(Intent.ACTION_SEND_MULTIPLE, emailScheme);
-        mEmailIntent.setType("plain/text");
-        mEmailIntent.putExtra(Intent.EXTRA_EMAIL, new String[]{EMAIL_RECIPIENT});
-    }
-
-    private Bitmap takeScreenShot() {
-        if (mView == null || mView.getRootView() == null) {
-            return null;
-        }
-
-        View rootView = mView.getRootView();
-        boolean wasDrawingCacheEnabled = rootView.isDrawingCacheEnabled();
-        rootView.setDrawingCacheEnabled(true);
-
-        Bitmap drawingCache = rootView.getDrawingCache();
-        if (drawingCache == null) {
-            return null;
-        }
-
-        Bitmap bitmap = Bitmap.createBitmap(drawingCache);
-        rootView.setDrawingCacheEnabled(wasDrawingCacheEnabled);
-
-        return bitmap;
-    }
-
-    private String convertBitmapInWEBPToBase64EncodedString(Bitmap bitmap) {
-        String result = null;
-        if (bitmap != null) {
-            try {
-                ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
-                bitmap.compress(Bitmap.CompressFormat.JPEG, IMAGE_QUALITY, byteArrayOutputStream);
-                byte[] bytes = byteArrayOutputStream.toByteArray();
-                result = Base64.encodeToString(bytes, Base64.DEFAULT);
-            } catch (Exception e) {
-                // should we log something here?
-            }
-        }
-        return result;
-    }
-
-    private void addEmailSubject() {
-        mEmailIntent.putExtra(Intent.EXTRA_SUBJECT, "New creative violation report - " + mDateString);
-    }
-
-    private void addEmailBody(String... data) {
-        StringBuilder body = new StringBuilder();
-        int i = 0;
-        while (i<data.length) {
-            body.append(data[i]);
-            if (i!=data.length-1) {
-                body.append(BODY_SEPARATOR);
-            }
-            i++;
-        }
-        mEmailIntent.putExtra(Intent.EXTRA_TEXT, body.toString());
-    }
-
-    private void addImageAttachment(String fileName, Bitmap bitmap) {
-        FileOutputStream fileOutputStream = null;
-
-        if (fileName == null || bitmap == null) {
-            return;
-        }
-
-        try {
-            fileOutputStream = mContext.openFileOutput(fileName, Context.MODE_WORLD_READABLE);
-            // image quality is okay to be 0 here, since PNG is lossless and will ignore compression quality
-            bitmap.compress(Bitmap.CompressFormat.PNG, IMAGE_QUALITY, fileOutputStream);
-
-            Uri fileUri = Uri.fromFile(new File(mContext.getFilesDir() + File.separator + fileName));
-            mEmailAttachments.add(fileUri);
-        } catch (Exception exception) {
-            MoPubLog.d("Unable to write text attachment to file: " + fileName);
-        } finally {
-            Streams.closeStream(fileOutputStream);
-        }
-    }
-
-    private void addTextAttachment(String fileName, String body) {
-        FileOutputStream fileOutputStream = null;
-
-        if (fileName == null || body == null) {
-            return;
-        }
-
-        try {
-            fileOutputStream = mContext.openFileOutput(fileName, Context.MODE_WORLD_READABLE);
-            fileOutputStream.write(body.getBytes());
-
-            Uri fileUri = Uri.fromFile(new File(mContext.getFilesDir() + File.separator + fileName));
-            mEmailAttachments.add(fileUri);
-        } catch (Exception exception) {
-            MoPubLog.d("Unable to write text attachment to file: " + fileName);
-        } finally {
-            Streams.closeStream(fileOutputStream);
-        }
-    }
-
-    @Deprecated // for testing
-    Intent getEmailIntent() {
-        return mEmailIntent;
-    }
-
-    @Deprecated // for testing
-    ArrayList<Uri> getEmailAttachments() {
-        return mEmailAttachments;
-    }
-
-    @Deprecated // for testing
-    String getParameters() {
-        return mParameters;
-    }
-
-    @Deprecated
-    String getResponse(){
-        return mResponse;
-    }
-}
-
+package com.mopub.mobileads;
+
+import android.content.Context;
+import android.content.Intent;
+import android.graphics.Bitmap;
+import android.net.Uri;
+import android.support.annotation.Nullable;
+import android.util.Base64;
+import android.view.View;
+
+import com.mopub.common.AdReport;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.DateAndTime;
+import com.mopub.common.util.Streams;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Locale;
+
+public class AdAlertReporter {
+    private static final String EMAIL_RECIPIENT = "creative-review@mopub.com";
+    private static final String EMAIL_SCHEME = "mailto:";
+    private static final String SCREEN_SHOT_FILENAME = "mp_adalert_screenshot.png";
+    private static final String PARAMETERS_FILENAME = "mp_adalert_parameters.txt";
+    private static final String MARKUP_FILENAME = "mp_adalert_markup.html";
+    private static final String DATE_FORMAT_PATTERN = "M/d/yy hh:mm:ss a z";
+    private static final int IMAGE_QUALITY = 25;
+    private static final String BODY_SEPARATOR = "\n=================\n";
+
+    private final String mDateString;
+
+    private final View mView;
+    private final Context mContext;
+    private Intent mEmailIntent;
+    private ArrayList<Uri> mEmailAttachments;
+    private String mParameters;
+    private String mResponse;
+
+    public AdAlertReporter(final Context context, final View view, @Nullable final AdReport adReport) {
+        mView = view;
+        mContext = context;
+
+        mEmailAttachments = new ArrayList<Uri>();
+
+        SimpleDateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT_PATTERN, Locale.US);
+        mDateString = dateFormat.format(DateAndTime.now());
+
+        initEmailIntent();
+        Bitmap screenShot = takeScreenShot();
+        String screenShotString = convertBitmapInWEBPToBase64EncodedString(screenShot);
+        mParameters = "";
+        mResponse = "";
+        if (adReport != null) {
+            mParameters = adReport.toString();
+            mResponse = adReport.getResponseString();
+        }
+
+        addEmailSubject();
+        addEmailBody(mParameters, mResponse, screenShotString);
+        addTextAttachment(PARAMETERS_FILENAME, mParameters);
+        addTextAttachment(MARKUP_FILENAME, mResponse);
+        addImageAttachment(SCREEN_SHOT_FILENAME, screenShot);
+    }
+
+    public void send() {
+        mEmailIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, mEmailAttachments);
+
+        Intent chooserIntent = Intent.createChooser(mEmailIntent, "Send Email...");
+        chooserIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        mContext.startActivity(chooserIntent);
+    }
+
+    private void initEmailIntent() {
+        Uri emailScheme = Uri.parse(EMAIL_SCHEME);
+        mEmailIntent = new Intent(Intent.ACTION_SEND_MULTIPLE);
+        mEmailIntent.setDataAndType(emailScheme, "plain/text");
+        mEmailIntent.putExtra(Intent.EXTRA_EMAIL, new String[]{EMAIL_RECIPIENT});
+    }
+
+    private Bitmap takeScreenShot() {
+        if (mView == null || mView.getRootView() == null) {
+            return null;
+        }
+
+        View rootView = mView.getRootView();
+        boolean wasDrawingCacheEnabled = rootView.isDrawingCacheEnabled();
+        rootView.setDrawingCacheEnabled(true);
+
+        Bitmap drawingCache = rootView.getDrawingCache();
+        if (drawingCache == null) {
+            return null;
+        }
+
+        Bitmap bitmap = Bitmap.createBitmap(drawingCache);
+        rootView.setDrawingCacheEnabled(wasDrawingCacheEnabled);
+
+        return bitmap;
+    }
+
+    private String convertBitmapInWEBPToBase64EncodedString(Bitmap bitmap) {
+        String result = null;
+        if (bitmap != null) {
+            try {
+                ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
+                bitmap.compress(Bitmap.CompressFormat.JPEG, IMAGE_QUALITY, byteArrayOutputStream);
+                byte[] bytes = byteArrayOutputStream.toByteArray();
+                result = Base64.encodeToString(bytes, Base64.DEFAULT);
+            } catch (Exception e) {
+                // should we log something here?
+            }
+        }
+        return result;
+    }
+
+    private void addEmailSubject() {
+        mEmailIntent.putExtra(Intent.EXTRA_SUBJECT, "New creative violation report - " + mDateString);
+    }
+
+    private void addEmailBody(String... data) {
+        StringBuilder body = new StringBuilder();
+        int i = 0;
+        while (i<data.length) {
+            body.append(data[i]);
+            if (i!=data.length-1) {
+                body.append(BODY_SEPARATOR);
+            }
+            i++;
+        }
+        mEmailIntent.putExtra(Intent.EXTRA_TEXT, body.toString());
+    }
+
+    private void addImageAttachment(String fileName, Bitmap bitmap) {
+        FileOutputStream fileOutputStream = null;
+
+        if (fileName == null || bitmap == null) {
+            return;
+        }
+
+        try {
+            fileOutputStream = mContext.openFileOutput(fileName, Context.MODE_WORLD_READABLE);
+            // image quality is okay to be 0 here, since PNG is lossless and will ignore compression quality
+            bitmap.compress(Bitmap.CompressFormat.PNG, IMAGE_QUALITY, fileOutputStream);
+
+            Uri fileUri = Uri.fromFile(new File(mContext.getFilesDir() + File.separator + fileName));
+            mEmailAttachments.add(fileUri);
+        } catch (Exception exception) {
+            MoPubLog.d("Unable to write text attachment to file: " + fileName);
+        } finally {
+            Streams.closeStream(fileOutputStream);
+        }
+    }
+
+    private void addTextAttachment(String fileName, String body) {
+        FileOutputStream fileOutputStream = null;
+
+        if (fileName == null || body == null) {
+            return;
+        }
+
+        try {
+            fileOutputStream = mContext.openFileOutput(fileName, Context.MODE_WORLD_READABLE);
+            fileOutputStream.write(body.getBytes());
+
+            Uri fileUri = Uri.fromFile(new File(mContext.getFilesDir() + File.separator + fileName));
+            mEmailAttachments.add(fileUri);
+        } catch (Exception exception) {
+            MoPubLog.d("Unable to write text attachment to file: " + fileName);
+        } finally {
+            Streams.closeStream(fileOutputStream);
+        }
+    }
+
+    @Deprecated // for testing
+    Intent getEmailIntent() {
+        return mEmailIntent;
+    }
+
+    @Deprecated // for testing
+    ArrayList<Uri> getEmailAttachments() {
+        return mEmailAttachments;
+    }
+
+    @Deprecated // for testing
+    String getParameters() {
+        return mParameters;
+    }
+
+    @Deprecated
+    String getResponse(){
+        return mResponse;
+    }
+}
+
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventRewardedVideo.java b/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventRewardedVideo.java
index f619f853..ec9edbb4 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventRewardedVideo.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventRewardedVideo.java
@@ -1,124 +1,124 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-
-import com.mopub.common.LifecycleListener;
-import com.mopub.common.MoPubLifecycleManager;
-import com.mopub.common.VisibleForTesting;
-import com.mopub.common.logging.MoPubLog;
-
-import java.util.Map;
-
-/**
- *
- */
-public abstract class CustomEventRewardedVideo {
-    /**
-     * This marker interface is used to indicate that an object is a listener for a 3rd party SDKs
-     * rewarded video system.
-     */
-    @VisibleForTesting
-    protected static interface CustomEventRewardedVideoListener {}
-
-    /**
-     * Called by the {@link MoPubRewardedVideoManager} after loading the custom event.
-     */
-    @Nullable
-    @VisibleForTesting
-    protected abstract CustomEventRewardedVideoListener getVideoListenerForSdk();
-
-    /**
-     * Provides a {@link LifecycleListener} if the custom event's ad network wishes to be notified of
-     * activity lifecycle events in the application.
-     *
-     * @return a LifecycleListener. May be null.
-     */
-    @Nullable
-    @VisibleForTesting
-    protected abstract LifecycleListener getLifecycleListener();
-
-    /**
-     * Called by the {@link MoPubRewardedVideoManager} after loading the custom event.
-     * This should return the "ad unit id", "zone id" or similar identifier for the network.
-     * May be empty if the network does not have anything more specific than an application ID.
-     *
-     * @return the id string for this ad unit with the ad network.
-     */
-    @NonNull
-    protected abstract String getAdNetworkId();
-
-    /**
-     * Called to when the custom event is no longer used. Implementers should cancel any
-     * pending requests. The initialized SDK may be reused by another CustomEvent instance
-     * and should not be shut down or cleaned up.
-     */
-    protected abstract void onInvalidate();
-
-    /**
-     * The MoPub ad loading system calls this after MoPub indicates that this custom event should
-     * be loaded.
-     *
-     * @param launcherActivity the "main activity" of the app. Useful for initializing sdks.
-     * @param localExtras
-     * @param serverExtras
-     */
-    final void loadCustomEvent(@NonNull Activity launcherActivity,
-            @NonNull Map<String, Object> localExtras,
-            @NonNull Map<String, String> serverExtras) {
-        try {
-            if (checkAndInitializeSdk(launcherActivity, localExtras, serverExtras)) {
-                MoPubLifecycleManager.getInstance(launcherActivity).addLifecycleListener(getLifecycleListener());
-            }
-            loadWithSdkInitialized(launcherActivity, localExtras, serverExtras);
-        } catch (Exception e) {
-            MoPubLog.e(e.getMessage());
-        }
-    }
-
-    /**
-     * Sets up the 3rd party ads SDK if it needs configuration. Extenders should use this
-     * to do any static initialization the first time this method is run by any class instance.
-     * From then on, the SDK should be reused without initialization.
-     *
-     * @return true if the SDK performed initialization.
-     */
-    protected abstract boolean checkAndInitializeSdk(@NonNull Activity launcherActivity,
-            @NonNull Map<String, Object> localExtras,
-            @NonNull Map<String, String> serverExtras)
-            throws Exception;
-
-    /**
-     * Runs the ad-loading logic for the 3rd party SDK. localExtras & serverExtras should together
-     * contain all the data needed to load an ad.
-     *
-     * Implementers should also use this method (or checkAndInitializeSdk)
-     * to register a listener for their SDK, wrap it in a
-     * {@link com.mopub.mobileads.CustomEventRewardedVideo.CustomEventRewardedVideoListener}
-     *
-     * This method should not call any {@link MoPubRewardedVideoManager} event methods directly
-     * (onAdLoadSuccess, etc). Instead the SDK delegate/listener should call these methods.
-     *
-     * @param activity the "main activity" of the app. Useful for initializing sdks.
-     * @param localExtras
-     * @param serverExtras
-     */
-    protected abstract void loadWithSdkInitialized(@NonNull Activity activity,
-            @NonNull Map<String, Object> localExtras,
-            @NonNull Map<String, String> serverExtras)
-            throws Exception;
-
-    /**
-     * Implementers should query the 3rd party SDK for whether there is a video available for the
-     * 3rd party SDK & ID represented by the custom event.
-     *
-     * @return true iff a video is available to play.
-     */
-    protected abstract boolean hasVideoAvailable();
-
-    /**
-     * Implementers should now play the rewarded video for this custom event.
-     */
-    protected abstract void showVideo();
-}
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.LifecycleListener;
+import com.mopub.common.MoPubLifecycleManager;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+
+import java.util.Map;
+
+/**
+ *
+ */
+public abstract class CustomEventRewardedVideo {
+    /**
+     * This marker interface is used to indicate that an object is a listener for a 3rd party SDKs
+     * rewarded video system.
+     */
+    @VisibleForTesting
+    protected static interface CustomEventRewardedVideoListener {}
+
+    /**
+     * Called by the {@link MoPubRewardedVideoManager} after loading the custom event.
+     */
+    @Nullable
+    @VisibleForTesting
+    protected abstract CustomEventRewardedVideoListener getVideoListenerForSdk();
+
+    /**
+     * Provides a {@link LifecycleListener} if the custom event's ad network wishes to be notified of
+     * activity lifecycle events in the application.
+     *
+     * @return a LifecycleListener. May be null.
+     */
+    @Nullable
+    @VisibleForTesting
+    protected abstract LifecycleListener getLifecycleListener();
+
+    /**
+     * Called by the {@link MoPubRewardedVideoManager} after loading the custom event.
+     * This should return the "ad unit id", "zone id" or similar identifier for the network.
+     * May be empty if the network does not have anything more specific than an application ID.
+     *
+     * @return the id string for this ad unit with the ad network.
+     */
+    @NonNull
+    protected abstract String getAdNetworkId();
+
+    /**
+     * Called to when the custom event is no longer used. Implementers should cancel any
+     * pending requests. The initialized SDK may be reused by another CustomEvent instance
+     * and should not be shut down or cleaned up.
+     */
+    protected abstract void onInvalidate();
+
+    /**
+     * The MoPub ad loading system calls this after MoPub indicates that this custom event should
+     * be loaded.
+     *
+     * @param launcherActivity the "main activity" of the app. Useful for initializing sdks.
+     * @param localExtras
+     * @param serverExtras
+     */
+    final void loadCustomEvent(@NonNull Activity launcherActivity,
+            @NonNull Map<String, Object> localExtras,
+            @NonNull Map<String, String> serverExtras) {
+        try {
+            if (checkAndInitializeSdk(launcherActivity, localExtras, serverExtras)) {
+                MoPubLifecycleManager.getInstance(launcherActivity).addLifecycleListener(getLifecycleListener());
+            }
+            loadWithSdkInitialized(launcherActivity, localExtras, serverExtras);
+        } catch (Exception e) {
+            MoPubLog.e(e.getMessage());
+        }
+    }
+
+    /**
+     * Sets up the 3rd party ads SDK if it needs configuration. Extenders should use this
+     * to do any static initialization the first time this method is run by any class instance.
+     * From then on, the SDK should be reused without initialization.
+     *
+     * @return true if the SDK performed initialization, false if the SDK was already initialized.
+     */
+    protected abstract boolean checkAndInitializeSdk(@NonNull Activity launcherActivity,
+            @NonNull Map<String, Object> localExtras,
+            @NonNull Map<String, String> serverExtras)
+            throws Exception;
+
+    /**
+     * Runs the ad-loading logic for the 3rd party SDK. localExtras & serverExtras should together
+     * contain all the data needed to load an ad.
+     *
+     * Implementers should also use this method (or checkAndInitializeSdk)
+     * to register a listener for their SDK, wrap it in a
+     * {@link com.mopub.mobileads.CustomEventRewardedVideo.CustomEventRewardedVideoListener}
+     *
+     * This method should not call any {@link MoPubRewardedVideoManager} event methods directly
+     * (onAdLoadSuccess, etc). Instead the SDK delegate/listener should call these methods.
+     *
+     * @param activity the "main activity" of the app. Useful for initializing sdks.
+     * @param localExtras
+     * @param serverExtras
+     */
+    protected abstract void loadWithSdkInitialized(@NonNull Activity activity,
+            @NonNull Map<String, Object> localExtras,
+            @NonNull Map<String, String> serverExtras)
+            throws Exception;
+
+    /**
+     * Implementers should query the 3rd party SDK for whether there is a video available for the
+     * 3rd party SDK & ID represented by the custom event.
+     *
+     * @return true iff a video is available to play.
+     */
+    protected abstract boolean hasVideoAvailable();
+
+    /**
+     * Implementers should now play the rewarded video for this custom event.
+     */
+    protected abstract void showVideo();
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlWebViewClient.java b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlWebViewClient.java
index e1db2eac..b581bb8b 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlWebViewClient.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlWebViewClient.java
@@ -1,214 +1,100 @@
-package com.mopub.mobileads;
-
-import android.content.Context;
-import android.content.Intent;
-import android.graphics.Bitmap;
-import android.net.Uri;
-import android.os.Bundle;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.webkit.WebView;
-import android.webkit.WebViewClient;
-
-import com.mopub.common.MoPubBrowser;
-import com.mopub.common.Preconditions;
-import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.Intents;
-import com.mopub.exceptions.IntentNotResolvableException;
-import com.mopub.exceptions.UrlParseException;
-
-import static com.mopub.mobileads.MoPubErrorCode.UNSPECIFIED;
-
-class HtmlWebViewClient extends WebViewClient {
-    static final String MOPUB_FINISH_LOAD = "mopub://finishLoad";
-    static final String MOPUB_FAIL_LOAD = "mopub://failLoad";
-
-    private final Context mContext;
-    private HtmlWebViewListener mHtmlWebViewListener;
-    private BaseHtmlWebView mHtmlWebView;
-    private final String mClickthroughUrl;
-    private final String mRedirectUrl;
-
-    HtmlWebViewClient(HtmlWebViewListener htmlWebViewListener, BaseHtmlWebView htmlWebView, String clickthrough, String redirect) {
-        mHtmlWebViewListener = htmlWebViewListener;
-        mHtmlWebView = htmlWebView;
-        mClickthroughUrl = clickthrough;
-        mRedirectUrl = redirect;
-        mContext = htmlWebView.getContext();
-    }
-
-    /**
-     * Called upon user click, when the WebView attempts to load a new URL. Attempts to handle mopub
-     * and phone-specific schemes, open mopubnativebrowser links in the device browser, deep-links
-     * in the corresponding application, and all other links in the MoPub in-app browser.
-     */
-    @Override
-    public boolean shouldOverrideUrlLoading(final WebView view, final String url) {
-        MoPubLog.d("Ad event URL: " + url);
-
-        if (handleSpecialMoPubScheme(url)) {
-            return true;
-        }
-
-        if (Intents.isAboutScheme(url)) {
-            MoPubLog.d("Link to about page ignored.");
-            return true;
-        }
-
-        if (handlePhoneScheme(url)) {
-            return true;
-        }
-
-        // MoPubNativeBrowser URLs
-        if (Intents.isNativeBrowserScheme(url)) {
-            final String errorMessage = "Unable to load mopub native browser url: " + url;
-            try {
-                final Intent intent = Intents.intentForNativeBrowserScheme(url);
-                launchIntentForUserClick(mContext, intent, errorMessage);
-            } catch (UrlParseException e) {
-                MoPubLog.d(errorMessage + ". " + e.getMessage());
-            }
-
-            return true;
-        }
-
-        if (Intents.isHttpUrl(url)) {
-            showMoPubBrowserForUrl(url);
-            return true;
-        }
-
-        // Non-http(s) URLs like app deep links
-        if (Intents.canHandleApplicationUrl(mContext, url)) {
-            launchApplicationUrl(url);
-            return true;
-        }
-
-        MoPubLog.d("Link ignored. Unable to handle url: " + url);
-        return true;
-    }
-
-    @Override
-    public void onPageStarted(WebView view, String url, Bitmap favicon) {
-        // If the URL being loaded shares the redirectUrl prefix, open it in the browser.
-        if (mRedirectUrl != null && url.startsWith(mRedirectUrl)) {
-            view.stopLoading();
-            showMoPubBrowserForUrl(url);
-        }
-    }
-
-    private boolean isSpecialMoPubScheme(String url) {
-        return url.startsWith("mopub://");
-    }
-
-    private boolean handleSpecialMoPubScheme(String url) {
-        if (!isSpecialMoPubScheme(url)) {
-            return false;
-        }
-        Uri uri = Uri.parse(url);
-        String host = uri.getHost();
-
-        if ("finishLoad".equals(host)) {
-            mHtmlWebViewListener.onLoaded(mHtmlWebView);
-        } else if ("close".equals(host)) {
-            mHtmlWebViewListener.onCollapsed();
-        } else if ("failLoad".equals(host)) {
-            mHtmlWebViewListener.onFailed(UNSPECIFIED);
-        } else if ("custom".equals(host)) {
-            handleCustomIntentFromUri(uri);
-        }
-
-        return true;
-    }
-
-    private boolean isPhoneScheme(String url) {
-        return url.startsWith("tel:") || url.startsWith("voicemail:") ||
-                url.startsWith("sms:") || url.startsWith("mailto:") ||
-                url.startsWith("geo:") || url.startsWith("google.streetview:");
-    }
-
-    private boolean handlePhoneScheme(String url) {
-        if (!isPhoneScheme(url)) {
-            return false;
-        }
-        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
-        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-
-        String errorMessage = "Could not handle intent with URI: " + url
-                + ". Is this intent supported on your phone?";
-
-        launchIntentForUserClick(mContext, intent, errorMessage);
-
-        return true;
-    }
-
-    private boolean launchApplicationUrl(String url) {
-        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
-        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-
-        String errorMessage = "Unable to open intent.";
-
-        return launchIntentForUserClick(mContext, intent, errorMessage);
-    }
-
-    private void showMoPubBrowserForUrl(String url) {
-        if (url == null || url.equals("")) {
-            url = "about:blank";
-        }
-        MoPubLog.d("Final URI to show in browser: " + url);
-
-        final Bundle extras = new Bundle();
-        extras.putString(MoPubBrowser.DESTINATION_URL_KEY, url);
-        Intent intent = Intents.getStartActivityIntent(mContext, MoPubBrowser.class, extras);
-
-        String errorMessage = "Could not handle intent action. "
-                + ". Perhaps you forgot to declare com.mopub.common.MoPubBrowser"
-                + " in your Android manifest file.";
-
-        launchIntentForUserClick(mContext, intent, errorMessage);
-    }
-
-    private void handleCustomIntentFromUri(Uri uri) {
-        String action;
-        String adData;
-        try {
-            action = uri.getQueryParameter("fnc");
-            adData = uri.getQueryParameter("data");
-        } catch (UnsupportedOperationException e) {
-            MoPubLog.w("Could not handle custom intent with uri: " + uri);
-            return;
-        }
-
-        Intent customIntent = new Intent(action);
-        customIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-        customIntent.putExtra(HtmlBannerWebView.EXTRA_AD_CLICK_DATA, adData);
-
-        String errorMessage = "Could not handle custom intent: " + action
-                + ". Is your intent spelled correctly?";
-
-        launchIntentForUserClick(mContext, customIntent, errorMessage);
-    }
-
-    boolean launchIntentForUserClick(@Nullable final Context context, @NonNull final Intent intent,
-            @Nullable final String errorMessage) {
-        Preconditions.NoThrow.checkNotNull(intent);
-
-        if (context == null) {
-            MoPubLog.d(errorMessage);
-            return false;
-        }
-
-        if (!mHtmlWebView.wasClicked()) {
-            return false;
-        }
-
-        try {
-            Intents.startActivity(context, intent);
-            mHtmlWebViewListener.onClicked();
-            mHtmlWebView.onResetUserClick();
-            return true;
-        } catch (IntentNotResolvableException e) {
-            MoPubLog.d(errorMessage);
-            return false;
-        }
-    }
-}
+package com.mopub.mobileads;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.webkit.WebView;
+import android.webkit.WebViewClient;
+
+import com.mopub.common.UrlHandler;
+import com.mopub.common.UrlAction;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Intents;
+import com.mopub.exceptions.IntentNotResolvableException;
+
+import static com.mopub.mobileads.MoPubErrorCode.UNSPECIFIED;
+
+class HtmlWebViewClient extends WebViewClient {
+    static final String MOPUB_FINISH_LOAD = "mopub://finishLoad";
+    static final String MOPUB_FAIL_LOAD = "mopub://failLoad";
+
+    private final Context mContext;
+    private HtmlWebViewListener mHtmlWebViewListener;
+    private BaseHtmlWebView mHtmlWebView;
+    private final String mClickthroughUrl;
+    private final String mRedirectUrl;
+
+    HtmlWebViewClient(HtmlWebViewListener htmlWebViewListener, BaseHtmlWebView htmlWebView, String clickthrough, String redirect) {
+        mHtmlWebViewListener = htmlWebViewListener;
+        mHtmlWebView = htmlWebView;
+        mClickthroughUrl = clickthrough;
+        mRedirectUrl = redirect;
+        mContext = htmlWebView.getContext();
+    }
+
+    @Override
+    public boolean shouldOverrideUrlLoading(final WebView view, final String url) {
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(
+                        UrlAction.HANDLE_MOPUB_SCHEME,
+                        UrlAction.IGNORE_ABOUT_SCHEME,
+                        UrlAction.HANDLE_PHONE_SCHEME,
+                        UrlAction.OPEN_APP_MARKET,
+                        UrlAction.OPEN_NATIVE_BROWSER,
+                        UrlAction.OPEN_IN_APP_BROWSER,
+                        UrlAction.HANDLE_SHARE_TWEET,
+                        UrlAction.FOLLOW_DEEP_LINK)
+                .withResultActions(new UrlHandler.ResultActions() {
+                    @Override
+                    public void urlHandlingSucceeded(@NonNull String url,
+                            @NonNull UrlAction urlAction) {
+                        if (mHtmlWebView.wasClicked()) {
+                            mHtmlWebViewListener.onClicked();
+                            mHtmlWebView.onResetUserClick();
+                        }
+                    }
+
+                    @Override
+                    public void urlHandlingFailed(@NonNull String url,
+                            @NonNull UrlAction lastFailedUrlAction) {
+                    }
+                })
+                .withMoPubSchemeListener(new UrlHandler.MoPubSchemeListener() {
+                    @Override
+                    public void onFinishLoad() {
+                        mHtmlWebViewListener.onLoaded(mHtmlWebView);
+                    }
+
+                    @Override
+                    public void onClose() {
+                        mHtmlWebViewListener.onCollapsed();
+                    }
+
+                    @Override
+                    public void onFailLoad() {
+                        mHtmlWebViewListener.onFailed(UNSPECIFIED);
+                    }
+                })
+                .build().handleUrl(mContext, url, mHtmlWebView.wasClicked());
+        return true;
+    }
+
+    @Override
+    public void onPageStarted(WebView view, String url, Bitmap favicon) {
+        // If the URL being loaded shares the redirectUrl prefix, open it in the browser.
+        if (mRedirectUrl != null && url.startsWith(mRedirectUrl)) {
+            view.stopLoading();
+            if (mHtmlWebView.wasClicked()) {
+                try {
+                    Intents.showMoPubBrowserForUrl(mContext, Uri.parse(url));
+                } catch (IntentNotResolvableException e) {
+                    MoPubLog.d(e.getMessage());
+                }
+            } else {
+                MoPubLog.d("Attempted to redirect without user interaction");
+            }
+        }
+    }
+
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoListener.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoListener.java
index 560fe4d5..ff9361f1 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoListener.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoListener.java
@@ -1,45 +1,46 @@
-package com.mopub.mobileads;
-
-import android.support.annotation.NonNull;
-
-import com.mopub.common.MoPubReward;
-
-import java.util.Set;
-
-/**
- * Listener for rewarded video events. Implementers of this interface should be long-lived.
- */
-public interface MoPubRewardedVideoListener {
-
-    /**
-     * Called when the adUnitId has loaded. At this point you should be able to call
-     * {@link com.mopub.common.MoPub#showRewardedVideo(String)} to show the video.
-     */
-    public void onRewardedVideoLoadSuccess(@NonNull String adUnitId);
-
-    /**
-     * Called when a video fails to load for the given ad unit id. The provided error code will
-     * give more insight into the reason for the failure to load.
-     */
-    public void onRewardedVideoLoadFailure(@NonNull String adUnitId, @NonNull MoPubErrorCode errorCode);
-
-    /**
-     * Called when a rewarded video starts playing.
-     */
-    public void onRewardedVideoStarted(@NonNull String adUnitId);
-
-    /**
-     * Called when there is an error during video playback.
-     */
-    public void onRewardedVideoPlaybackError(@NonNull String adUnitId, @NonNull MoPubErrorCode errorCode);
-
-    /**
-     * Called when a rewarded video is closed. At this point your application should resume.
-     */
-    public void onRewardedVideoClosed(@NonNull String adUnitId);
-
-    /**
-     * Called when a rewarded video is completed and the user should be rewarded.
-     */
-    public void onRewardedVideoCompleted(@NonNull Set<String> adUnitIds, @NonNull MoPubReward reward);
-}
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+
+import com.mopub.common.MoPubReward;
+
+import java.util.Set;
+
+/**
+ * Listener for rewarded video events. Implementers of this interface will receive events for all
+ * rewarded video ad units in the app.:
+ */
+public interface MoPubRewardedVideoListener {
+
+    /**
+     * Called when the adUnitId has loaded. At this point you should be able to call
+     * {@link com.mopub.common.MoPub#showRewardedVideo(String)} to show the video.
+     */
+    public void onRewardedVideoLoadSuccess(@NonNull String adUnitId);
+
+    /**
+     * Called when a video fails to load for the given ad unit id. The provided error code will
+     * give more insight into the reason for the failure to load.
+     */
+    public void onRewardedVideoLoadFailure(@NonNull String adUnitId, @NonNull MoPubErrorCode errorCode);
+
+    /**
+     * Called when a rewarded video starts playing.
+     */
+    public void onRewardedVideoStarted(@NonNull String adUnitId);
+
+    /**
+     * Called when there is an error during video playback.
+     */
+    public void onRewardedVideoPlaybackError(@NonNull String adUnitId, @NonNull MoPubErrorCode errorCode);
+
+    /**
+     * Called when a rewarded video is closed. At this point your application should resume.
+     */
+    public void onRewardedVideoClosed(@NonNull String adUnitId);
+
+    /**
+     * Called when a rewarded video is completed and the user should be rewarded.
+     */
+    public void onRewardedVideoCompleted(@NonNull Set<String> adUnitIds, @NonNull MoPubReward reward);
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoManager.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoManager.java
index 40041359..cc285b42 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoManager.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoManager.java
@@ -1,507 +1,523 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.content.Context;
-import android.os.Handler;
-import android.os.Looper;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-
-import com.mopub.common.AdFormat;
-import com.mopub.common.AdUrlGenerator;
-import com.mopub.common.Constants;
-import com.mopub.common.DataKeys;
-import com.mopub.common.LocationService;
-import com.mopub.common.MediationSettings;
-import com.mopub.common.MoPub;
-import com.mopub.common.MoPubReward;
-import com.mopub.common.Preconditions;
-import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.MoPubCollections;
-import com.mopub.common.util.Reflection;
-import com.mopub.network.AdRequest;
-import com.mopub.network.AdResponse;
-import com.mopub.network.MoPubNetworkError;
-import com.mopub.network.Networking;
-import com.mopub.network.TrackingRequest;
-import com.mopub.volley.RequestQueue;
-import com.mopub.volley.VolleyError;
-
-import java.lang.ref.WeakReference;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Locale;
-import java.util.Map;
-import java.util.Set;
-import java.util.TreeMap;
-
-public class MoPubRewardedVideoManager {
-    private static MoPubRewardedVideoManager sInstance;
-    private static final int DEFAULT_LOAD_TIMEOUT = Constants.THIRTY_SECONDS_MILLIS;
-
-    @NonNull private final Handler mCallbackHandler;
-    @NonNull private WeakReference<Activity> mMainActivity;
-    @NonNull private final Context mContext;
-    @NonNull private final AdRequestStatusMapping mAdRequestStatus;
-    @NonNull private final RewardedVideoData mRewardedVideoData;
-    @Nullable private MoPubRewardedVideoListener mVideoListener;
-    
-    @NonNull private final Set<MediationSettings> mGlobalMediationSettings;
-    @NonNull private final Map<String, Set<MediationSettings>> mInstanceMediationSettings;
-
-    @NonNull private final Handler mCustomEventTimeoutHandler;
-    @NonNull private final Map<String, Runnable> mTimeoutMap;
-
-    public static class RewardedVideoRequestListener implements AdRequest.Listener {
-        public final String adUnitId;
-        private final MoPubRewardedVideoManager mVideoManager;
-
-        public RewardedVideoRequestListener(MoPubRewardedVideoManager videoManager, String adUnitId) {
-            this.adUnitId = adUnitId;
-            this.mVideoManager = videoManager;
-        }
-
-        @Override
-        public void onSuccess(final AdResponse response) {
-            mVideoManager.onAdSuccess(response, adUnitId);
-        }
-
-        @Override
-        public void onErrorResponse(final VolleyError volleyError) {
-            mVideoManager.onAdError(volleyError, adUnitId);
-        }
-    }
-
-    private MoPubRewardedVideoManager(@NonNull Activity mainActivity, MediationSettings... mediationSettings) {
-        mMainActivity = new WeakReference<Activity>(mainActivity);
-        mContext = mainActivity.getApplicationContext();
-        mRewardedVideoData = new RewardedVideoData();
-        mCallbackHandler = new Handler(Looper.getMainLooper());
-        mGlobalMediationSettings = new HashSet<MediationSettings>();
-        MoPubCollections.addAllNonNull(mGlobalMediationSettings, mediationSettings);
-        mInstanceMediationSettings = new HashMap<String, Set<MediationSettings>>();
-        mCustomEventTimeoutHandler = new Handler();
-        mTimeoutMap = new HashMap<String, Runnable>();
-        
-        mAdRequestStatus = new AdRequestStatusMapping();
-    }
-
-    public static synchronized void init(@NonNull Activity mainActivity, MediationSettings... mediationSettings) {
-        if (sInstance == null) {
-            sInstance = new MoPubRewardedVideoManager(mainActivity, mediationSettings);
-        } else {
-            MoPubLog.e("Tried to call initializeRewardedVideo more than once. Only the first " +
-                    "initialization call has any effect.");
-        }
-    }
-
-    public static void updateActivity(@NonNull Activity activity) {
-        if (sInstance != null) {
-            sInstance.mMainActivity = new WeakReference<Activity>(activity);
-        } else {
-            logErrorNotInitialized();
-        }
-    }
-
-    /**
-     * Returns a global {@link MediationSettings} object of the type 'clazz', if one is registered.
-     * This method will only return an object if its type is identical to 'clazz', not if it is a
-     * subtype.
-     *
-     * @param clazz the exact Class of the {@link MediationSettings} instance to retrieve
-     * @return an instance of Class<T> or null if none is registered.
-     */
-    @Nullable
-    public static <T extends MediationSettings> T getGlobalMediationSettings(@NonNull final Class<T> clazz) {
-        if (sInstance == null) {
-            logErrorNotInitialized();
-            return null;
-        }
-
-        for (final MediationSettings mediationSettings : sInstance.mGlobalMediationSettings) {
-            // The two classes must be of exactly equal types
-            if (clazz.equals(mediationSettings.getClass())) {
-                return clazz.cast(mediationSettings);
-            }
-        }
-
-        return null;
-    }
-
-    /**
-     * Returns an instance {@link MediationSettings} object of the type 'clazz', if one is
-     * registered. This method will only return an object if its type is identical to 'clazz', not
-     * if it is a subtype.
-     *
-     * @param clazz the exact Class of the {@link MediationSettings} instance to retrieve
-     * @param adUnitId String identifier used to obtain the appropriate instance MediationSettings
-     * @return an instance of Class<T> or null if none is registered.
-     */
-    @Nullable
-    public static <T extends MediationSettings> T getInstanceMediationSettings(
-            @NonNull final Class<T> clazz, @NonNull final String adUnitId) {
-        if (sInstance == null) {
-            logErrorNotInitialized();
-            return null;
-        }
-
-        final Set<MediationSettings> instanceMediationSettings =
-                sInstance.mInstanceMediationSettings.get(adUnitId);
-        if (instanceMediationSettings == null) {
-            return null;
-        }
-
-        for (final MediationSettings mediationSettings : instanceMediationSettings) {
-            // The two classes must be of exactly equal types
-            if (clazz.equals(mediationSettings.getClass())) {
-                return clazz.cast(mediationSettings);
-            }
-        }
-
-        return null;
-    }
-
-    /**
-     * Sets the {@link MoPubRewardedVideoListener} that will receive events from the
-     * rewarded video system. Set this to null to stop receiving event callbacks.
-     */
-    public static void setVideoListener(@Nullable MoPubRewardedVideoListener listener) {
-        if (sInstance != null) {
-            sInstance.mVideoListener = listener;
-        } else {
-            logErrorNotInitialized();
-        }
-    }
-
-    /**
-     * Builds an AdRequest for the given adUnitId and adds it to the singleton RequestQueue. This
-     * method will not make a new request if there is already a video loading for this adUnitId.
-     *
-     * @param adUnitId MoPub adUnitId String
-     * @param mediationSettings Optional instance-level MediationSettings to associate with the
-     *                          above adUnitId.
-     */
-    public static void loadVideo(@NonNull String adUnitId, @Nullable final MediationSettings... mediationSettings) {
-        if (sInstance == null) {
-            logErrorNotInitialized();
-            return;
-        }
-
-        // If any instance MediationSettings have been specified, update the internal map.
-        // Note: This always clears the MediationSettings for the ad unit, whether or not any
-        // MediationSettings have been provided.
-        final Set<MediationSettings> newInstanceMediationSettings = new HashSet<MediationSettings>();
-        MoPubCollections.addAllNonNull(newInstanceMediationSettings, mediationSettings);
-        sInstance.mInstanceMediationSettings.put(adUnitId, newInstanceMediationSettings);
-
-        final AdUrlGenerator urlGenerator = new WebViewAdUrlGenerator(sInstance.mContext, false);
-        final String adUrlString = urlGenerator.withAdUnitId(adUnitId)
-                .withLocation(
-                        LocationService.getLastKnownLocation(
-                                sInstance.mContext,
-                                MoPub.getLocationPrecision(),
-                                MoPub.getLocationAwareness()
-                        )
-                )
-                .generateUrlString(Constants.HOST);
-
-        loadVideo(adUnitId, adUrlString);
-    }
-
-    private static void loadVideo(@NonNull String adUnitId, @NonNull String adUrlString) {
-        if (sInstance == null) {
-            logErrorNotInitialized();
-            return;
-        }
-
-        if (sInstance.mAdRequestStatus.isLoading(adUnitId)) {
-            MoPubLog.d(String.format(Locale.US, "Did not queue rewarded video request for ad " +
-                    "unit %s. A request is already pending.", adUnitId));
-            return;
-        }
-
-        // Issue MoPub request
-        final AdRequest request = new AdRequest(
-                adUrlString,
-                AdFormat.REWARDED_VIDEO,
-                adUnitId,
-                sInstance.mContext,
-                new RewardedVideoRequestListener(sInstance, adUnitId)
-        );
-        final RequestQueue requestQueue = Networking.getRequestQueue(sInstance.mContext);
-        requestQueue.add(request);
-        sInstance.mAdRequestStatus.markLoading(adUnitId);
-    }
-
-    public static boolean hasVideo(@NonNull String adUnitId) {
-        if (sInstance != null) {
-            final CustomEventRewardedVideo customEvent = sInstance.mRewardedVideoData.getCustomEvent(adUnitId);
-            return isPlayable(adUnitId, customEvent);
-        } else {
-            logErrorNotInitialized();
-            return false;
-        }
-    }
-
-    public static void showVideo(@NonNull String adUnitId) {
-        if (sInstance != null) {
-            final CustomEventRewardedVideo customEvent = sInstance.mRewardedVideoData.getCustomEvent(adUnitId);
-            if (isPlayable(adUnitId, customEvent)) {
-                sInstance.mAdRequestStatus.markPlayed(adUnitId);
-                customEvent.showVideo();
-            } else {
-                sInstance.failover(adUnitId, MoPubErrorCode.VIDEO_NOT_AVAILABLE);
-            }
-        } else {
-            logErrorNotInitialized();
-        }
-    }
-
-    private static boolean isPlayable(String adUnitId, @Nullable CustomEventRewardedVideo customEvent) {
-        return (sInstance != null
-                && sInstance.mAdRequestStatus.canPlay(adUnitId)
-                && customEvent != null
-                && customEvent.hasVideoAvailable());
-    }
-
-    ///// Ad Request / Response methods /////
-    private void onAdSuccess(AdResponse adResponse, String adUnitId) {
-        mAdRequestStatus.markLoaded(adUnitId,
-                adResponse.getFailoverUrl(),
-                adResponse.getImpressionTrackingUrl(),
-                adResponse.getClickTrackingUrl());
-
-        Integer timeoutMillis = adResponse.getAdTimeoutMillis();
-        if (timeoutMillis == null || timeoutMillis <= 0) {
-            timeoutMillis = DEFAULT_LOAD_TIMEOUT;
-        }
-
-        final String customEventClassName = adResponse.getCustomEventClassName();
-        if (customEventClassName == null) {
-            MoPubLog.e("Couldn't create custom event, class name was null.");
-            failover(adUnitId, MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
-            return;
-        }
-
-        try {
-            // Instantiate a custom event
-            final CustomEventRewardedVideo customEvent =
-                    Reflection.instantiateClassWithEmptyConstructor(
-                            customEventClassName,
-                            CustomEventRewardedVideo.class);
-
-            // Put important data into localExtras...
-            final Map<String, Object> localExtras = new TreeMap<String, Object>();
-            localExtras.put(DataKeys.AD_UNIT_ID_KEY, adUnitId);
-
-            // Set up timeout calls.
-            Runnable timeout = new Runnable() {
-                @Override
-                public void run() {
-                    MoPubLog.d("Custom Event failed to load rewarded video in a timely fashion.");
-                    onRewardedVideoLoadFailure(customEvent.getClass(), customEvent.getAdNetworkId(), MoPubErrorCode.NETWORK_TIMEOUT);
-                    customEvent.onInvalidate();
-                }
-            };
-            mCustomEventTimeoutHandler.postDelayed(timeout, timeoutMillis);
-            mTimeoutMap.put(adUnitId, timeout);
-
-            // Load custom event - need an activity reference!
-            customEvent.loadCustomEvent(mMainActivity.get(), localExtras, adResponse.getServerExtras());
-
-            final CustomEventRewardedVideo.CustomEventRewardedVideoListener listener =
-                    customEvent.getVideoListenerForSdk();
-            final String adNetworkId = customEvent.getAdNetworkId();
-            mRewardedVideoData.updateAdUnitCustomEventMapping(adUnitId, customEvent, listener, adNetworkId);
-
-        } catch (Exception e) {
-            MoPubLog.e(String.format(Locale.US, "Couldn't create custom event with class name %s", customEventClassName));
-            failover(adUnitId, MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
-        }
-    }
-
-    private void onAdError(@NonNull VolleyError volleyError, @NonNull String adUnitId) {
-        MoPubErrorCode errorCode = MoPubErrorCode.INTERNAL_ERROR;
-        if (volleyError instanceof MoPubNetworkError) {
-            MoPubNetworkError err = (MoPubNetworkError) volleyError;
-            switch (err.getReason()) {
-                case NO_FILL:
-                case WARMING_UP:
-                    errorCode = MoPubErrorCode.NO_FILL;
-                    break;
-                case BAD_BODY:
-                case BAD_HEADER_DATA:
-                default:
-                    errorCode = MoPubErrorCode.INTERNAL_ERROR;
-            }
-        }
-        failover(adUnitId, errorCode);
-    }
-
-    private void failover(@NonNull final String adUnitId, @NonNull final MoPubErrorCode errorCode) {
-        final String failoverUrl = mAdRequestStatus.getFailoverUrl(adUnitId);
-        mAdRequestStatus.markFail(adUnitId);
-
-        if (failoverUrl != null) {
-            loadVideo(adUnitId, failoverUrl);
-        } else if (mVideoListener != null) {
-            mVideoListener.onRewardedVideoLoadFailure(adUnitId, errorCode);
-        }
-    }
-
-    private void cancelTimeouts(@NonNull String moPubId) {
-        final Runnable runnable = mTimeoutMap.remove(moPubId);
-        if (runnable != null) {  // We can't pass null or all callbacks will be removed.
-            mCustomEventTimeoutHandler.removeCallbacks(runnable);
-        }
-    }
-
-    //////// Listener methods that should be called by third-party SDKs. //////////
-
-    /**
-     * Notify the manager that a rewarded video loaded successfully.
-     *
-     * @param customEventClass - the Class of the third-party custom event object.
-     * @param thirdPartyId - the ad id of the third party SDK. This may be an empty String if the
-     *                     SDK does not use ad ids, zone ids, or a analogous concept.
-     * @param <T> - a class that extends {@link CustomEventRewardedVideo}. Only rewarded video
-     *           custom events should use these methods.
-     */
-    public static <T extends CustomEventRewardedVideo>
-    void onRewardedVideoLoadSuccess(@NonNull final Class<T> customEventClass, @NonNull final String thirdPartyId) {
-        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
-            @Override
-            protected void forEach(@NonNull final String moPubId) {
-                sInstance.cancelTimeouts(moPubId);
-                if (sInstance.mVideoListener != null) {
-                    sInstance.mVideoListener.onRewardedVideoLoadSuccess(moPubId);
-                }
-            }
-        });
-    }
-
-    public static <T extends CustomEventRewardedVideo>
-    void onRewardedVideoLoadFailure(@NonNull final Class<T> customEventClass, final String thirdPartyId, final MoPubErrorCode errorCode) {
-        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
-            @Override
-            protected void forEach(@NonNull final String moPubId) {
-                   sInstance.cancelTimeouts(moPubId);
-                   sInstance.failover(moPubId, errorCode);
-            }
-        });
-    }
-
-    public static <T extends CustomEventRewardedVideo>
-    void onRewardedVideoStarted(@NonNull final Class<T> customEventClass, final String thirdPartyId) {
-        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
-            @Override
-            protected void forEach(@NonNull final String moPubId) {
-                if (sInstance.mVideoListener != null) {
-                    sInstance.mVideoListener.onRewardedVideoStarted(moPubId);
-                }
-                TrackingRequest.makeTrackingHttpRequest(
-                        sInstance.mAdRequestStatus.getImpressionTrackerUrlString(moPubId),
-                        sInstance.mContext);
-                sInstance.mAdRequestStatus.clearImpressionUrl(moPubId);
-            }
-        });
-    }
-
-    public static <T extends CustomEventRewardedVideo>
-    void onRewardedVideoPlaybackError(@NonNull final Class<T> customEventClass, final String thirdPartyId, final MoPubErrorCode errorCode) {
-        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
-            @Override
-            protected void forEach(@NonNull final String moPubId) {
-                if (sInstance.mVideoListener != null) {
-                    sInstance.mVideoListener.onRewardedVideoPlaybackError(moPubId, errorCode);
-                }
-            }
-        });
-
-    }
-
-    public static <T extends CustomEventRewardedVideo>
-    void onRewardedVideoClicked(@NonNull final Class<T> customEventClass, final String thirdPartyId) {
-        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
-            @Override
-            protected void forEach(@NonNull final String moPubId) {
-                TrackingRequest.makeTrackingHttpRequest(
-                        sInstance.mAdRequestStatus.getClickTrackerUrlString(moPubId),
-                        sInstance.mContext);
-                sInstance.mAdRequestStatus.clearClickUrl(moPubId);
-            }
-        });
-    }
-
-    public static <T extends CustomEventRewardedVideo>
-    void onRewardedVideoClosed(@NonNull final Class<T> customEventClass, final String thirdPartyId) {
-        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
-            @Override
-            protected void forEach(@NonNull final String moPubId) {
-                if (sInstance.mVideoListener != null) {
-                    sInstance.mVideoListener.onRewardedVideoClosed(moPubId);
-                }
-            }
-        });
-    }
-
-    public static <T extends CustomEventRewardedVideo>
-    void onRewardedVideoCompleted(@NonNull final Class<T> customEventClass, final String thirdPartyId, @NonNull final MoPubReward moPubReward) {
-        // Unlike other callbacks in this class, only call the listener once with all the MoPubIds in the matching set.
-        postToInstance(new Runnable() {
-            @Override
-            public void run() {
-                final Set<String> moPubIds = sInstance.mRewardedVideoData.getMoPubIdsForAdNetwork(customEventClass, thirdPartyId);
-                Set<String> rewarded = new HashSet<String>(moPubIds);
-                if (sInstance.mVideoListener != null) {
-                    sInstance.mVideoListener.onRewardedVideoCompleted(rewarded, moPubReward);
-                }
-            }
-        });
-    }
-
-    /**
-     * Posts the runnable to the static instance's handler. Does nothing if sInstance is null.
-     * Useful for ensuring that all event callbacks run on the main thread.
-     * The {@link Runnable} can assume that sInstance is non-null.
-     */
-    private static void postToInstance(@NonNull Runnable runnable) {
-        if (sInstance != null) {
-            sInstance.mCallbackHandler.post(runnable);
-        }
-    }
-
-    private static void logErrorNotInitialized() {
-        MoPubLog.e("MoPub rewarded video was not initialized. You must call " +
-                "MoPub.initializeRewardedVideo() before loading or attempting " +
-                "to play video ads.");
-    }
-
-    /**
-     * A runnable that calls forEach on each member of the rewarded video data passed to the runnable.
-     */
-    private static abstract class ForEachMoPubIdRunnable implements Runnable {
-
-        @NonNull private final Class<? extends CustomEventRewardedVideo> mCustomEventClass;
-        @NonNull private final String mThirdPartyId;
-
-        ForEachMoPubIdRunnable(@NonNull final Class<? extends CustomEventRewardedVideo> customEventClass,
-                @NonNull final String thirdPartyId) {
-            Preconditions.checkNotNull(customEventClass);
-            Preconditions.checkNotNull(thirdPartyId);
-            mCustomEventClass = customEventClass;
-            mThirdPartyId = thirdPartyId;
-        }
-
-        protected abstract void forEach(@NonNull final String moPubId);
-
-        @Override
-        public void run() {
-            final Set<String> moPubIds = sInstance.mRewardedVideoData
-                    .getMoPubIdsForAdNetwork(mCustomEventClass, mThirdPartyId);
-            for (String moPubId : moPubIds) {
-                forEach(moPubId);
-            }
-        }
-    }
-}
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.os.Handler;
+import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.AdFormat;
+import com.mopub.common.AdUrlGenerator;
+import com.mopub.common.Constants;
+import com.mopub.common.DataKeys;
+import com.mopub.common.LocationService;
+import com.mopub.common.MediationSettings;
+import com.mopub.common.MoPub;
+import com.mopub.common.MoPubReward;
+import com.mopub.common.Preconditions;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.MoPubCollections;
+import com.mopub.common.util.Reflection;
+import com.mopub.network.AdRequest;
+import com.mopub.network.AdResponse;
+import com.mopub.network.MoPubNetworkError;
+import com.mopub.network.Networking;
+import com.mopub.network.TrackingRequest;
+import com.mopub.volley.RequestQueue;
+import com.mopub.volley.VolleyError;
+
+import java.lang.ref.WeakReference;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeMap;
+
+/**
+ */
+public class MoPubRewardedVideoManager {
+    private static MoPubRewardedVideoManager sInstance;
+    private static final int DEFAULT_LOAD_TIMEOUT = Constants.THIRTY_SECONDS_MILLIS;
+
+    @NonNull private final Handler mCallbackHandler;
+    @NonNull private WeakReference<Activity> mMainActivity;
+    @NonNull private final Context mContext;
+    @NonNull private final AdRequestStatusMapping mAdRequestStatus;
+    @NonNull private final RewardedVideoData mRewardedVideoData;
+    @Nullable private MoPubRewardedVideoListener mVideoListener;
+    
+    @NonNull private final Set<MediationSettings> mGlobalMediationSettings;
+    @NonNull private final Map<String, Set<MediationSettings>> mInstanceMediationSettings;
+
+    @NonNull private final Handler mCustomEventTimeoutHandler;
+    @NonNull private final Map<String, Runnable> mTimeoutMap;
+
+    public static class RewardedVideoRequestListener implements AdRequest.Listener {
+        public final String adUnitId;
+        private final MoPubRewardedVideoManager mVideoManager;
+
+        public RewardedVideoRequestListener(MoPubRewardedVideoManager videoManager, String adUnitId) {
+            this.adUnitId = adUnitId;
+            this.mVideoManager = videoManager;
+        }
+
+        @Override
+        public void onSuccess(final AdResponse response) {
+            mVideoManager.onAdSuccess(response, adUnitId);
+        }
+
+        @Override
+        public void onErrorResponse(final VolleyError volleyError) {
+            mVideoManager.onAdError(volleyError, adUnitId);
+        }
+    }
+
+    private MoPubRewardedVideoManager(@NonNull Activity mainActivity, MediationSettings... mediationSettings) {
+        mMainActivity = new WeakReference<Activity>(mainActivity);
+        mContext = mainActivity.getApplicationContext();
+        mRewardedVideoData = new RewardedVideoData();
+        mCallbackHandler = new Handler(Looper.getMainLooper());
+        mGlobalMediationSettings = new HashSet<MediationSettings>();
+        MoPubCollections.addAllNonNull(mGlobalMediationSettings, mediationSettings);
+        mInstanceMediationSettings = new HashMap<String, Set<MediationSettings>>();
+        mCustomEventTimeoutHandler = new Handler();
+        mTimeoutMap = new HashMap<String, Runnable>();
+        
+        mAdRequestStatus = new AdRequestStatusMapping();
+    }
+
+    public static synchronized void init(@NonNull Activity mainActivity, MediationSettings... mediationSettings) {
+        if (sInstance == null) {
+            sInstance = new MoPubRewardedVideoManager(mainActivity, mediationSettings);
+        } else {
+            MoPubLog.e("Tried to call initializeRewardedVideo more than once. Only the first " +
+                    "initialization call has any effect.");
+        }
+    }
+
+    public static void updateActivity(@NonNull Activity activity) {
+        if (sInstance != null) {
+            sInstance.mMainActivity = new WeakReference<Activity>(activity);
+        } else {
+            logErrorNotInitialized();
+        }
+    }
+
+    /**
+     * Returns a global {@link MediationSettings} object of the type 'clazz', if one is registered.
+     * This method will only return an object if its type is identical to 'clazz', not if it is a
+     * subtype.
+     *
+     * @param clazz the exact Class of the {@link MediationSettings} instance to retrieve
+     * @return an instance of Class<T> or null if none is registered.
+     */
+    @Nullable
+    public static <T extends MediationSettings> T getGlobalMediationSettings(@NonNull final Class<T> clazz) {
+        if (sInstance == null) {
+            logErrorNotInitialized();
+            return null;
+        }
+
+        for (final MediationSettings mediationSettings : sInstance.mGlobalMediationSettings) {
+            // The two classes must be of exactly equal types
+            if (clazz.equals(mediationSettings.getClass())) {
+                return clazz.cast(mediationSettings);
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * Returns an instance {@link MediationSettings} object of the type 'clazz', if one is
+     * registered. This method will only return an object if its type is identical to 'clazz', not
+     * if it is a subtype.
+     *
+     * @param clazz the exact Class of the {@link MediationSettings} instance to retrieve
+     * @param adUnitId String identifier used to obtain the appropriate instance MediationSettings
+     * @return an instance of Class<T> or null if none is registered.
+     */
+    @Nullable
+    public static <T extends MediationSettings> T getInstanceMediationSettings(
+            @NonNull final Class<T> clazz, @NonNull final String adUnitId) {
+        if (sInstance == null) {
+            logErrorNotInitialized();
+            return null;
+        }
+
+        final Set<MediationSettings> instanceMediationSettings =
+                sInstance.mInstanceMediationSettings.get(adUnitId);
+        if (instanceMediationSettings == null) {
+            return null;
+        }
+
+        for (final MediationSettings mediationSettings : instanceMediationSettings) {
+            // The two classes must be of exactly equal types
+            if (clazz.equals(mediationSettings.getClass())) {
+                return clazz.cast(mediationSettings);
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * Sets the {@link MoPubRewardedVideoListener} that will receive events from the
+     * rewarded video system. Set this to null to stop receiving event callbacks.
+     */
+    public static void setVideoListener(@Nullable MoPubRewardedVideoListener listener) {
+        if (sInstance != null) {
+            sInstance.mVideoListener = listener;
+        } else {
+            logErrorNotInitialized();
+        }
+    }
+
+    /**
+     * Builds an AdRequest for the given adUnitId and adds it to the singleton RequestQueue. This
+     * method will not make a new request if there is already a video loading for this adUnitId.
+     *
+     * @param adUnitId MoPub adUnitId String
+     * @param mediationSettings Optional instance-level MediationSettings to associate with the
+     *                          above adUnitId.
+     */
+    public static void loadVideo(@NonNull String adUnitId, @Nullable final MediationSettings... mediationSettings) {
+        if (sInstance == null) {
+            logErrorNotInitialized();
+            return;
+        }
+
+        // If any instance MediationSettings have been specified, update the internal map.
+        // Note: This always clears the MediationSettings for the ad unit, whether or not any
+        // MediationSettings have been provided.
+        final Set<MediationSettings> newInstanceMediationSettings = new HashSet<MediationSettings>();
+        MoPubCollections.addAllNonNull(newInstanceMediationSettings, mediationSettings);
+        sInstance.mInstanceMediationSettings.put(adUnitId, newInstanceMediationSettings);
+
+        final AdUrlGenerator urlGenerator = new WebViewAdUrlGenerator(sInstance.mContext, false);
+        final String adUrlString = urlGenerator.withAdUnitId(adUnitId)
+                .withLocation(
+                        LocationService.getLastKnownLocation(
+                                sInstance.mContext,
+                                MoPub.getLocationPrecision(),
+                                MoPub.getLocationAwareness()
+                        )
+                )
+                .generateUrlString(Constants.HOST);
+
+        loadVideo(adUnitId, adUrlString);
+    }
+
+    private static void loadVideo(@NonNull String adUnitId, @NonNull String adUrlString) {
+        if (sInstance == null) {
+            logErrorNotInitialized();
+            return;
+        }
+
+        if (sInstance.mAdRequestStatus.isLoading(adUnitId)) {
+            MoPubLog.d(String.format(Locale.US, "Did not queue rewarded video request for ad " +
+                    "unit %s. A request is already pending.", adUnitId));
+            return;
+        }
+
+        // Issue MoPub request
+        final AdRequest request = new AdRequest(
+                adUrlString,
+                AdFormat.REWARDED_VIDEO,
+                adUnitId,
+                sInstance.mContext,
+                new RewardedVideoRequestListener(sInstance, adUnitId)
+        );
+        final RequestQueue requestQueue = Networking.getRequestQueue(sInstance.mContext);
+        requestQueue.add(request);
+        sInstance.mAdRequestStatus.markLoading(adUnitId);
+    }
+
+    public static boolean hasVideo(@NonNull String adUnitId) {
+        if (sInstance != null) {
+            final CustomEventRewardedVideo customEvent = sInstance.mRewardedVideoData.getCustomEvent(adUnitId);
+            return isPlayable(adUnitId, customEvent);
+        } else {
+            logErrorNotInitialized();
+            return false;
+        }
+    }
+
+    public static void showVideo(@NonNull String adUnitId) {
+        if (sInstance != null) {
+            final CustomEventRewardedVideo customEvent = sInstance.mRewardedVideoData.getCustomEvent(adUnitId);
+            if (isPlayable(adUnitId, customEvent)) {
+                sInstance.mAdRequestStatus.markPlayed(adUnitId);
+                customEvent.showVideo();
+            } else {
+                sInstance.failover(adUnitId, MoPubErrorCode.VIDEO_NOT_AVAILABLE);
+            }
+        } else {
+            logErrorNotInitialized();
+        }
+    }
+
+    private static boolean isPlayable(String adUnitId, @Nullable CustomEventRewardedVideo customEvent) {
+        return (sInstance != null
+                && sInstance.mAdRequestStatus.canPlay(adUnitId)
+                && customEvent != null
+                && customEvent.hasVideoAvailable());
+    }
+
+    ///// Ad Request / Response methods /////
+    private void onAdSuccess(AdResponse adResponse, String adUnitId) {
+        mAdRequestStatus.markLoaded(adUnitId,
+                adResponse.getFailoverUrl(),
+                adResponse.getImpressionTrackingUrl(),
+                adResponse.getClickTrackingUrl());
+
+        Integer timeoutMillis = adResponse.getAdTimeoutMillis();
+        if (timeoutMillis == null || timeoutMillis <= 0) {
+            timeoutMillis = DEFAULT_LOAD_TIMEOUT;
+        }
+
+        final String customEventClassName = adResponse.getCustomEventClassName();
+        if (customEventClassName == null) {
+            MoPubLog.e("Couldn't create custom event, class name was null.");
+            failover(adUnitId, MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
+            return;
+        }
+
+        try {
+            // Instantiate a custom event
+            final CustomEventRewardedVideo customEvent =
+                    Reflection.instantiateClassWithEmptyConstructor(
+                            customEventClassName,
+                            CustomEventRewardedVideo.class);
+
+            // Put important data into localExtras...
+            final Map<String, Object> localExtras = new TreeMap<String, Object>();
+            localExtras.put(DataKeys.AD_UNIT_ID_KEY, adUnitId);
+
+            Activity mainActivity = mMainActivity.get();
+            if (mainActivity == null) {
+                MoPubLog.d("Could not load custom event because Activity reference was null. Call" +
+                        " MoPub#updateActivity before requesting more rewarded videos.");
+
+                // Don't go through the ordinary failover process since we have
+                // no activity for the failover to use.
+                mAdRequestStatus.markFail(adUnitId);
+                return;
+            }
+
+            // Set up timeout calls.
+            Runnable timeout = new Runnable() {
+                @Override
+                public void run() {
+                    MoPubLog.d("Custom Event failed to load rewarded video in a timely fashion.");
+                    onRewardedVideoLoadFailure(customEvent.getClass(), customEvent.getAdNetworkId(),
+                            MoPubErrorCode.NETWORK_TIMEOUT);
+                    customEvent.onInvalidate();
+                }
+            };
+            mCustomEventTimeoutHandler.postDelayed(timeout, timeoutMillis);
+            mTimeoutMap.put(adUnitId, timeout);
+
+            // Load custom event
+            customEvent.loadCustomEvent(mainActivity, localExtras, adResponse.getServerExtras());
+
+            final CustomEventRewardedVideo.CustomEventRewardedVideoListener listener =
+                    customEvent.getVideoListenerForSdk();
+            final String adNetworkId = customEvent.getAdNetworkId();
+            mRewardedVideoData.updateAdUnitCustomEventMapping(adUnitId, customEvent, listener, adNetworkId);
+        } catch (Exception e) {
+            MoPubLog.e(String.format(Locale.US, "Couldn't create custom event with class name %s", customEventClassName));
+            failover(adUnitId, MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
+        }
+    }
+
+    private void onAdError(@NonNull VolleyError volleyError, @NonNull String adUnitId) {
+        MoPubErrorCode errorCode = MoPubErrorCode.INTERNAL_ERROR;
+        if (volleyError instanceof MoPubNetworkError) {
+            MoPubNetworkError err = (MoPubNetworkError) volleyError;
+            switch (err.getReason()) {
+                case NO_FILL:
+                case WARMING_UP:
+                    errorCode = MoPubErrorCode.NO_FILL;
+                    break;
+                case BAD_BODY:
+                case BAD_HEADER_DATA:
+                default:
+                    errorCode = MoPubErrorCode.INTERNAL_ERROR;
+            }
+        }
+        if (volleyError instanceof com.mopub.volley.NoConnectionError) {
+            errorCode = MoPubErrorCode.NO_CONNECTION;
+        }
+        failover(adUnitId, errorCode);
+    }
+
+    private void failover(@NonNull final String adUnitId, @NonNull final MoPubErrorCode errorCode) {
+        final String failoverUrl = mAdRequestStatus.getFailoverUrl(adUnitId);
+        mAdRequestStatus.markFail(adUnitId);
+
+        if (failoverUrl != null) {
+            loadVideo(adUnitId, failoverUrl);
+        } else if (mVideoListener != null) {
+            mVideoListener.onRewardedVideoLoadFailure(adUnitId, errorCode);
+        }
+    }
+
+    private void cancelTimeouts(@NonNull String moPubId) {
+        final Runnable runnable = mTimeoutMap.remove(moPubId);
+        if (runnable != null) {  // We can't pass null or all callbacks will be removed.
+            mCustomEventTimeoutHandler.removeCallbacks(runnable);
+        }
+    }
+
+    //////// Listener methods that should be called by third-party SDKs. //////////
+
+    /**
+     * Notify the manager that a rewarded video loaded successfully.
+     *
+     * @param customEventClass - the Class of the third-party custom event object.
+     * @param thirdPartyId - the ad id of the third party SDK. This may be an empty String if the
+     *                     SDK does not use ad ids, zone ids, or a analogous concept.
+     * @param <T> - a class that extends {@link CustomEventRewardedVideo}. Only rewarded video
+     *           custom events should use these methods.
+     */
+    public static <T extends CustomEventRewardedVideo>
+    void onRewardedVideoLoadSuccess(@NonNull final Class<T> customEventClass, @NonNull final String thirdPartyId) {
+        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
+            @Override
+            protected void forEach(@NonNull final String moPubId) {
+                sInstance.cancelTimeouts(moPubId);
+                if (sInstance.mVideoListener != null) {
+                    sInstance.mVideoListener.onRewardedVideoLoadSuccess(moPubId);
+                }
+            }
+        });
+    }
+
+    public static <T extends CustomEventRewardedVideo>
+    void onRewardedVideoLoadFailure(@NonNull final Class<T> customEventClass, final String thirdPartyId, final MoPubErrorCode errorCode) {
+        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
+            @Override
+            protected void forEach(@NonNull final String moPubId) {
+                   sInstance.cancelTimeouts(moPubId);
+                   sInstance.failover(moPubId, errorCode);
+            }
+        });
+    }
+
+    public static <T extends CustomEventRewardedVideo>
+    void onRewardedVideoStarted(@NonNull final Class<T> customEventClass, final String thirdPartyId) {
+        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
+            @Override
+            protected void forEach(@NonNull final String moPubId) {
+                if (sInstance.mVideoListener != null) {
+                    sInstance.mVideoListener.onRewardedVideoStarted(moPubId);
+                }
+                TrackingRequest.makeTrackingHttpRequest(
+                        sInstance.mAdRequestStatus.getImpressionTrackerUrlString(moPubId),
+                        sInstance.mContext);
+                sInstance.mAdRequestStatus.clearImpressionUrl(moPubId);
+            }
+        });
+    }
+
+    public static <T extends CustomEventRewardedVideo>
+    void onRewardedVideoPlaybackError(@NonNull final Class<T> customEventClass, final String thirdPartyId, final MoPubErrorCode errorCode) {
+        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
+            @Override
+            protected void forEach(@NonNull final String moPubId) {
+                if (sInstance.mVideoListener != null) {
+                    sInstance.mVideoListener.onRewardedVideoPlaybackError(moPubId, errorCode);
+                }
+            }
+        });
+
+    }
+
+    public static <T extends CustomEventRewardedVideo>
+    void onRewardedVideoClicked(@NonNull final Class<T> customEventClass, final String thirdPartyId) {
+        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
+            @Override
+            protected void forEach(@NonNull final String moPubId) {
+                TrackingRequest.makeTrackingHttpRequest(
+                        sInstance.mAdRequestStatus.getClickTrackerUrlString(moPubId),
+                        sInstance.mContext);
+                sInstance.mAdRequestStatus.clearClickUrl(moPubId);
+            }
+        });
+    }
+
+    public static <T extends CustomEventRewardedVideo>
+    void onRewardedVideoClosed(@NonNull final Class<T> customEventClass, final String thirdPartyId) {
+        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
+            @Override
+            protected void forEach(@NonNull final String moPubId) {
+                if (sInstance.mVideoListener != null) {
+                    sInstance.mVideoListener.onRewardedVideoClosed(moPubId);
+                }
+            }
+        });
+    }
+
+    public static <T extends CustomEventRewardedVideo>
+    void onRewardedVideoCompleted(@NonNull final Class<T> customEventClass, final String thirdPartyId, @NonNull final MoPubReward moPubReward) {
+        // Unlike other callbacks in this class, only call the listener once with all the MoPubIds in the matching set.
+        postToInstance(new Runnable() {
+            @Override
+            public void run() {
+                final Set<String> moPubIds = sInstance.mRewardedVideoData.getMoPubIdsForAdNetwork(customEventClass, thirdPartyId);
+                Set<String> rewarded = new HashSet<String>(moPubIds);
+                if (sInstance.mVideoListener != null) {
+                    sInstance.mVideoListener.onRewardedVideoCompleted(rewarded, moPubReward);
+                }
+            }
+        });
+    }
+
+    /**
+     * Posts the runnable to the static instance's handler. Does nothing if sInstance is null.
+     * Useful for ensuring that all event callbacks run on the main thread.
+     * The {@link Runnable} can assume that sInstance is non-null.
+     */
+    private static void postToInstance(@NonNull Runnable runnable) {
+        if (sInstance != null) {
+            sInstance.mCallbackHandler.post(runnable);
+        }
+    }
+
+    private static void logErrorNotInitialized() {
+        MoPubLog.e("MoPub rewarded video was not initialized. You must call " +
+                "MoPub.initializeRewardedVideo() before loading or attempting " +
+                "to play video ads.");
+    }
+
+    /**
+     * A runnable that calls forEach on each member of the rewarded video data passed to the runnable.
+     */
+    private static abstract class ForEachMoPubIdRunnable implements Runnable {
+
+        @NonNull private final Class<? extends CustomEventRewardedVideo> mCustomEventClass;
+        @NonNull private final String mThirdPartyId;
+
+        ForEachMoPubIdRunnable(@NonNull final Class<? extends CustomEventRewardedVideo> customEventClass,
+                @NonNull final String thirdPartyId) {
+            Preconditions.checkNotNull(customEventClass);
+            Preconditions.checkNotNull(thirdPartyId);
+            mCustomEventClass = customEventClass;
+            mThirdPartyId = thirdPartyId;
+        }
+
+        protected abstract void forEach(@NonNull final String moPubId);
+
+        @Override
+        public void run() {
+            final Set<String> moPubIds = sInstance.mRewardedVideoData
+                    .getMoPubIdsForAdNetwork(mCustomEventClass, mThirdPartyId);
+            for (String moPubId : moPubIds) {
+                forEach(moPubId);
+            }
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/RepeatingHandlerRunnable.java b/mopub-sdk/src/main/java/com/mopub/mobileads/RepeatingHandlerRunnable.java
new file mode 100644
index 00000000..2c26fa69
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/RepeatingHandlerRunnable.java
@@ -0,0 +1,57 @@
+package com.mopub.mobileads;
+
+import android.os.Handler;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+
+/**
+ * A generic runnable that handles scheduling itself periodically on a Handler and stops when
+ * requested.
+ */
+public abstract class RepeatingHandlerRunnable implements Runnable {
+    @NonNull protected final Handler mHandler;
+    private volatile boolean mIsRunning;
+    private volatile long mUpdateIntervalMillis;
+
+    RepeatingHandlerRunnable(@NonNull final Handler handler) {
+        Preconditions.checkNotNull(handler);
+        mHandler = handler;
+    }
+
+    @Override
+    public void run() {
+        if (mIsRunning) {
+            doWork();
+            mHandler.postDelayed(this, mUpdateIntervalMillis);
+        }
+    }
+
+    public abstract void doWork();
+
+    /**
+     * Start this runnable immediately, repeating at the provided interval.
+     */
+    public void startRepeating(long intervalMillis) {
+        Preconditions.checkArgument(intervalMillis > 0, "intervalMillis must be greater than 0. " +
+                "Saw: %d", intervalMillis);
+        mUpdateIntervalMillis = intervalMillis;
+        if (!mIsRunning) {
+            mIsRunning = true;
+            mHandler.post(this);
+        }
+    }
+
+    /**
+     * Stop this repeating runnable.
+     */
+    public void stop() {
+        mIsRunning = false;
+    }
+
+    @VisibleForTesting
+    boolean shouldBeRunning() {
+        return mIsRunning;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewController.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewController.java
index ca361c8f..0125daa1 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewController.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewController.java
@@ -1,698 +1,677 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.graphics.Bitmap;
-import android.graphics.Color;
-import android.graphics.drawable.Drawable;
-import android.graphics.drawable.GradientDrawable;
-import android.graphics.drawable.LayerDrawable;
-import android.media.MediaPlayer;
-import android.os.Bundle;
-import android.os.Handler;
-import android.support.annotation.NonNull;
-import android.text.TextUtils;
-import android.view.Gravity;
-import android.view.MotionEvent;
-import android.view.View;
-import android.widget.ImageView;
-import android.widget.RelativeLayout;
-import android.widget.VideoView;
-
-import com.mopub.common.DownloadResponse;
-import com.mopub.common.DownloadTask;
-import com.mopub.common.HttpResponses;
-import com.mopub.common.MoPubBrowser;
-import com.mopub.common.Preconditions;
-import com.mopub.common.VisibleForTesting;
-import com.mopub.common.event.BaseEvent;
-import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.AsyncTasks;
-import com.mopub.common.util.Dips;
-import com.mopub.common.util.Drawables;
-import com.mopub.common.util.Intents;
-import com.mopub.common.util.Streams;
-import com.mopub.common.util.Strings;
-import com.mopub.common.util.VersionCode;
-import com.mopub.exceptions.IntentNotResolvableException;
-import com.mopub.exceptions.UrlParseException;
-import com.mopub.mobileads.util.vast.VastCompanionAd;
-import com.mopub.mobileads.util.vast.VastVideoConfiguration;
-import com.mopub.network.TrackingRequest;
-
-import org.apache.http.HttpStatus;
-import org.apache.http.client.methods.HttpGet;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-import static android.content.pm.ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
-import static android.content.pm.ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
-import static com.mopub.common.HttpClient.initializeHttpGet;
-import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_CLICK;
-import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
-import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
-import static com.mopub.network.TrackingRequest.makeTrackingHttpRequest;
-
-public class VastVideoViewController extends BaseVideoViewController implements DownloadTask.DownloadTaskListener {
-    static final String VAST_VIDEO_CONFIGURATION = "vast_video_configuration";
-
-    private static final long VIDEO_PROGRESS_TIMER_CHECKER_DELAY = 50;
-    private static final int MOPUB_BROWSER_REQUEST_CODE = 1;
-    private static final int MAX_VIDEO_RETRIES = 1;
-    private static final int VIDEO_VIEW_FILE_PERMISSION_ERROR = Integer.MIN_VALUE;
-
-    static final int DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON = 5 * 1000;
-    static final int MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON = 16 * 1000;
-
-    private final VastVideoConfiguration mVastVideoConfiguration;
-    private final VastCompanionAd mVastCompanionAd;
-    private final VastVideoToolbar mVastVideoToolbar;
-    private final VideoView mVideoView;
-    private final ImageView mCompanionAdImageView;
-    private final View.OnTouchListener mClickThroughListener;
-
-    private final Handler mHandler;
-    private final Runnable mVideoProgressCheckerRunnable;
-    private boolean mIsVideoProgressShouldBeChecked;
-    private int mShowCloseButtonDelay = DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON;
-
-    private boolean mShowCloseButtonEventFired;
-
-    private int mSeekerPositionOnPause;
-    private boolean mIsVideoFinishedPlaying;
-    private int mVideoRetries;
-
-    private boolean mVideoError;
-    private boolean mCompletionTrackerFired;
-
-    private boolean mHasSkipOffset = false;
-
-    VastVideoViewController(final Context context,
-            final Bundle bundle,
-            final long broadcastIdentifier,
-            final BaseVideoViewControllerListener baseVideoViewControllerListener)
-            throws IllegalStateException {
-        super(context, broadcastIdentifier, baseVideoViewControllerListener);
-        mHandler = new Handler();
-        mIsVideoProgressShouldBeChecked = false;
-        mSeekerPositionOnPause = -1;
-        mVideoRetries = 0;
-
-        Serializable serializable = bundle.getSerializable(VAST_VIDEO_CONFIGURATION);
-        if (serializable != null && serializable instanceof VastVideoConfiguration) {
-            mVastVideoConfiguration = (VastVideoConfiguration) serializable;
-        } else {
-            throw new IllegalStateException("VastVideoConfiguration is invalid");
-        }
-
-        if (mVastVideoConfiguration.getDiskMediaFileUrl() == null) {
-            throw new IllegalStateException("VastVideoConfiguration does not have a video disk path");
-        }
-
-        mVastCompanionAd = mVastVideoConfiguration.getVastCompanionAd();
-
-        mClickThroughListener = new View.OnTouchListener() {
-            @Override
-            public boolean onTouch(View view, MotionEvent motionEvent) {
-                if (motionEvent.getAction() == MotionEvent.ACTION_UP && shouldAllowClickThrough()) {
-                    handleClick(
-                            mVastVideoConfiguration.getClickTrackers(),
-                            mVastVideoConfiguration.getClickThroughUrl()
-                    );
-                }
-                return true;
-            }
-        };
-
-        createVideoBackground(context);
-
-        mVideoView = createVideoView(context);
-        mVideoView.requestFocus();
-
-        mVastVideoToolbar = createVastVideoToolBar(context);
-        getLayout().addView(mVastVideoToolbar);
-
-        mCompanionAdImageView = createCompanionAdImageView(context);
-        mVideoProgressCheckerRunnable = createVideoProgressCheckerRunnable();
-    }
-
-    @Override
-    protected VideoView getVideoView() {
-        return mVideoView;
-    }
-
-    @Override
-    protected void onCreate() {
-        super.onCreate();
-
-        switch (mVastVideoConfiguration.getCustomForceOrientation()) {
-            case FORCE_PORTRAIT:
-                getBaseVideoViewControllerListener().onSetRequestedOrientation(SCREEN_ORIENTATION_PORTRAIT);
-                break;
-            case FORCE_LANDSCAPE:
-                getBaseVideoViewControllerListener().onSetRequestedOrientation(SCREEN_ORIENTATION_LANDSCAPE);
-                break;
-            case DEVICE_ORIENTATION:
-                break;  // don't do anything
-            case UNDEFINED:
-                break;  // don't do anything
-            default:
-                break;
-        }
-
-        downloadCompanionAd();
-
-        makeTrackingHttpRequest(
-                mVastVideoConfiguration.getImpressionTrackers(),
-                getContext(),
-                BaseEvent.Name.IMPRESSION_REQUEST
-        );
-        broadcastAction(ACTION_INTERSTITIAL_SHOW);
-    }
-
-    @Override
-    protected void onResume() {
-        // When resuming, VideoView needs to reinitialize its MediaPlayer with the video path
-        // and therefore reset the count to zero, to let it retry on error
-        mVideoRetries = 0;
-        startProgressChecker();
-
-        mVideoView.seekTo(mSeekerPositionOnPause);
-        if (!mIsVideoFinishedPlaying) {
-            mVideoView.start();
-        }
-    }
-
-    @Override
-    protected void onPause() {
-        stopProgressChecker();
-        mSeekerPositionOnPause = mVideoView.getCurrentPosition();
-        mVideoView.pause();
-    }
-
-    @Override
-    protected void onDestroy() {
-        stopProgressChecker();
-        broadcastAction(ACTION_INTERSTITIAL_DISMISS);
-    }
-
-    // Enable the device's back button when the video close button has been displayed
-    @Override
-    public boolean backButtonEnabled() {
-        return mShowCloseButtonEventFired;
-    }
-
-    @Override
-    void onActivityResult(final int requestCode, final int resultCode, final Intent data) {
-        if (requestCode == MOPUB_BROWSER_REQUEST_CODE && resultCode == Activity.RESULT_OK) {
-            getBaseVideoViewControllerListener().onFinish();
-        }
-    }
-
-    // DownloadTaskListener
-    @Override
-    public void onComplete(String url, DownloadResponse downloadResponse) {
-        if (downloadResponse != null && downloadResponse.getStatusCode() == HttpStatus.SC_OK) {
-            final Bitmap companionAdBitmap = HttpResponses.asBitmap(downloadResponse);
-            if (companionAdBitmap != null) {
-                // If Bitmap fits in ImageView, then don't use MATCH_PARENT
-                final int width = Dips.dipsToIntPixels(companionAdBitmap.getWidth(), getContext());
-                final int height = Dips.dipsToIntPixels(companionAdBitmap.getHeight(), getContext());
-                final int imageViewWidth = mCompanionAdImageView.getMeasuredWidth();
-                final int imageViewHeight = mCompanionAdImageView.getMeasuredHeight();
-                if (width < imageViewWidth && height < imageViewHeight) {
-                    mCompanionAdImageView.getLayoutParams().width = width;
-                    mCompanionAdImageView.getLayoutParams().height = height;
-                }
-                mCompanionAdImageView.setImageBitmap(companionAdBitmap);
-                mCompanionAdImageView.setOnClickListener(new View.OnClickListener() {
-                    @Override
-                    public void onClick(View view) {
-                        if (mVastCompanionAd != null) {
-                            handleClick(
-                                    mVastCompanionAd.getClickTrackers(),
-                                    mVastCompanionAd.getClickThroughUrl()
-                            );
-                        }
-                    }
-                });
-            }
-        }
-    }
-
-    private void downloadCompanionAd() {
-        if (mVastCompanionAd != null) {
-            try {
-                final HttpGet httpGet = initializeHttpGet(mVastCompanionAd.getImageUrl(), getContext());
-                final DownloadTask downloadTask = new DownloadTask(this);
-                AsyncTasks.safeExecuteOnExecutor(downloadTask, httpGet);
-            } catch (Exception e) {
-                MoPubLog.d("Failed to download companion ad", e);
-            }
-        }
-    }
-
-    private void adjustSkipOffset() {
-        int videoDuration = mVideoView.getDuration();
-
-        // Default behavior: video is non-skippable if duration < 16 seconds
-        if (videoDuration < MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON) {
-            mShowCloseButtonDelay = videoDuration;
-        }
-
-        // Override if skipoffset attribute is specified in VAST
-        String skipOffsetString = mVastVideoConfiguration.getSkipOffset();
-        if (skipOffsetString != null) {
-            try {
-                if (Strings.isAbsoluteTracker(skipOffsetString)) {
-                    Integer skipOffsetMilliseconds = Strings.parseAbsoluteOffset(skipOffsetString);
-                    if (skipOffsetMilliseconds != null && skipOffsetMilliseconds < videoDuration) {
-                        mShowCloseButtonDelay = skipOffsetMilliseconds;
-                        mHasSkipOffset = true;
-                    }
-                } else if (Strings.isPercentageTracker(skipOffsetString)) {
-                    float percentage = Float.parseFloat(skipOffsetString.replace("%", "")) / 100f;
-                    int skipOffsetMillisecondsRounded = Math.round(videoDuration * percentage);
-                    if (skipOffsetMillisecondsRounded < videoDuration) {
-                        mShowCloseButtonDelay = skipOffsetMillisecondsRounded;
-                        mHasSkipOffset = true;
-                    }
-                } else {
-                    MoPubLog.d(String.format("Invalid VAST skipoffset format: %s", skipOffsetString));
-                }
-            } catch (NumberFormatException e) {
-                MoPubLog.d(String.format("Failed to parse skipoffset %s", skipOffsetString));
-            }
-        }
-    }
-
-    @NonNull
-    private Runnable createVideoProgressCheckerRunnable() {
-        // This Runnable must only be run from the main thread due to accessing
-        // class instance variables
-        return new Runnable() {
-            @Override
-            public void run() {
-                int videoLength = mVideoView.getDuration();
-                int currentPosition = mVideoView.getCurrentPosition();
-
-                if (videoLength > 0) {
-                    final List<VastTracker> trackersToTrack =
-                            getUntriggeredTrackersBefore(currentPosition, videoLength);
-                    if (!trackersToTrack.isEmpty()) {
-                        final List<String> trackUrls = new ArrayList<String>();
-                        for (VastTracker tracker : trackersToTrack) {
-                            trackUrls.add(tracker.getTrackingUrl());
-                            tracker.setTracked();
-                        }
-                        TrackingRequest.makeTrackingHttpRequest(trackUrls, getContext());
-                    }
-
-                    // show countdown if any of the following conditions is satisfied:
-                    // 1) long video
-                    // 2) skipoffset is specified in VAST and is less than video duration
-                    if (isLongVideo(mVideoView.getDuration()) ||
-                            (mHasSkipOffset && mShowCloseButtonDelay < mVideoView.getDuration())) {
-                        mVastVideoToolbar.updateCountdownWidget(mShowCloseButtonDelay - mVideoView.getCurrentPosition());
-                    }
-
-                    if (shouldBeInteractable()) {
-                        makeVideoInteractable();
-                    }
-                }
-
-                mVastVideoToolbar.updateDurationWidget(mVideoView.getDuration() - mVideoView.getCurrentPosition());
-
-                if (mIsVideoProgressShouldBeChecked) {
-                    mHandler.postDelayed(mVideoProgressCheckerRunnable, VIDEO_PROGRESS_TIMER_CHECKER_DELAY);
-                }
-            }
-        };
-    }
-
-    /**
-     * Returns untriggered VAST progress trackers with a progress before the provided position.
-     *
-     * @param currentPositionMillis the current video position in milliseconds.
-     * @param videoLengthMillis the total video length.
-     */
-    @NonNull
-    private List<VastTracker> getUntriggeredTrackersBefore(int currentPositionMillis, int videoLengthMillis) {
-        if (Preconditions.NoThrow.checkArgument(videoLengthMillis > 0)) {
-            float progressFraction = currentPositionMillis / (float) (videoLengthMillis);
-            List<VastTracker> untriggeredTrackers = new ArrayList<VastTracker>();
-
-            final ArrayList<VastAbsoluteProgressTracker> absoluteTrackers = mVastVideoConfiguration.getAbsoluteTrackers();
-            VastAbsoluteProgressTracker absoluteTest = new VastAbsoluteProgressTracker("", currentPositionMillis);
-            int absoluteTrackerCount = absoluteTrackers.size();
-            for (int i = 0; i < absoluteTrackerCount; i++) {
-                VastAbsoluteProgressTracker tracker = absoluteTrackers.get(i);
-                if (tracker.compareTo(absoluteTest) > 0) {
-                    break;
-                }
-                if (!tracker.isTracked()) {
-                    untriggeredTrackers.add(tracker);
-                }
-            }
-
-            final ArrayList<VastFractionalProgressTracker> fractionalTrackers = mVastVideoConfiguration.getFractionalTrackers();
-            final VastFractionalProgressTracker fractionalTest = new VastFractionalProgressTracker("", progressFraction);
-            int fractionalTrackerCount = fractionalTrackers.size();
-            for (int i = 0; i < fractionalTrackerCount; i++) {
-                VastFractionalProgressTracker tracker = fractionalTrackers.get(i);
-                if (tracker.compareTo(fractionalTest) > 0) {
-                    break;
-                }
-                if (!tracker.isTracked()) {
-                    untriggeredTrackers.add(tracker);
-                }
-            }
-
-            return untriggeredTrackers;
-        } else {
-            return Collections.emptyList();
-        }
-    }
-
-    private int remainingProgressTrackerCount() {
-        return getUntriggeredTrackersBefore(Integer.MAX_VALUE, Integer.MAX_VALUE).size();
-    }
-
-    private void createVideoBackground(final Context context) {
-        GradientDrawable gradientDrawable = new GradientDrawable(
-                GradientDrawable.Orientation.TOP_BOTTOM,
-                new int[] {Color.argb(0,0,0,0), Color.argb(255,0,0,0)}
-        );
-        Drawable[] layers = new Drawable[2];
-        layers[0] = Drawables.THATCHED_BACKGROUND.createDrawable(context);
-        layers[1] = gradientDrawable;
-        LayerDrawable layerList = new LayerDrawable(layers);
-        getLayout().setBackgroundDrawable(layerList);
-    }
-
-    private VastVideoToolbar createVastVideoToolBar(final Context context) {
-        final VastVideoToolbar vastVideoToolbar = new VastVideoToolbar(context);
-        vastVideoToolbar.setCloseButtonOnTouchListener(new View.OnTouchListener() {
-            @Override
-            public boolean onTouch(View view, MotionEvent motionEvent) {
-                if (motionEvent.getAction() == MotionEvent.ACTION_UP) {
-                    TrackingRequest.makeTrackingHttpRequest(
-                            mVastVideoConfiguration.getCloseTrackers(), context);
-                    TrackingRequest.makeTrackingHttpRequest(
-                            mVastVideoConfiguration.getSkipTrackers(), context);
-                    getBaseVideoViewControllerListener().onFinish();
-                }
-                return true;
-            }
-        });
-        vastVideoToolbar.setLearnMoreButtonOnTouchListener(mClickThroughListener);
-
-        // update custom CTA text if specified in VAST extension
-        String customCtaText = mVastVideoConfiguration.getCustomCtaText();
-        if (customCtaText != null) {
-            vastVideoToolbar.updateLearnMoreButtonText(customCtaText);
-        }
-
-        // update custom skip text if specified in VAST extensions
-        String customSkipText = mVastVideoConfiguration.getCustomSkipText();
-        if (customSkipText != null) {
-            vastVideoToolbar.updateCloseButtonText(customSkipText);
-        }
-
-        // update custom close icon if specified in VAST extensions
-        String customCloseIconUrl = mVastVideoConfiguration.getCustomCloseIconUrl();
-        if (customCloseIconUrl != null) {
-            vastVideoToolbar.updateCloseButtonIcon(customCloseIconUrl);
-        }
-
-        return vastVideoToolbar;
-    }
-
-    private VideoView createVideoView(final Context context) {
-        final VideoView videoView = new VideoView(context);
-        videoView.setOnPreparedListener(new MediaPlayer.OnPreparedListener() {
-            @Override
-            public void onPrepared(MediaPlayer mp) {
-                // Called when media source is ready for playback
-                adjustSkipOffset();
-            }
-        });
-        videoView.setOnTouchListener(mClickThroughListener);
-
-        videoView.setOnCompletionListener(new MediaPlayer.OnCompletionListener() {
-            @Override
-            public void onCompletion(MediaPlayer mp) {
-                stopProgressChecker();
-                makeVideoInteractable();
-
-                videoCompleted(false);
-                mIsVideoFinishedPlaying = true;
-
-                // Only fire the completion tracker if we hit all the progress marks. Some Android implementations
-                // fire the completion event even if the whole video isn't watched.
-                if (!mVideoError && remainingProgressTrackerCount() == 0 && !mCompletionTrackerFired) {
-                    makeTrackingHttpRequest(mVastVideoConfiguration.getCompleteTrackers(), context);
-                    mCompletionTrackerFired = true;
-                }
-
-                videoView.setVisibility(View.GONE);
-                // check the drawable to see if the image view was populated with content
-                if (mCompanionAdImageView.getDrawable() != null) {
-                    mCompanionAdImageView.setVisibility(View.VISIBLE);
-                }
-            }
-        });
-
-        videoView.setOnErrorListener(new MediaPlayer.OnErrorListener() {
-            @Override
-            public boolean onError(final MediaPlayer mediaPlayer, final int what, final int extra) {
-                if (retryMediaPlayer(mediaPlayer, what, extra)) {
-                    return true;
-                } else {
-                    stopProgressChecker();
-                    makeVideoInteractable();
-                    videoError(false);
-                    mVideoError = true;
-                    return false;
-                }
-            }
-        });
-
-        videoView.setVideoPath(mVastVideoConfiguration.getDiskMediaFileUrl());
-
-        return videoView;
-    }
-
-    boolean retryMediaPlayer(final MediaPlayer mediaPlayer, final int what, final int extra) {
-        // XXX
-        // VideoView has a bug in versions lower than Jelly Bean, Api Level 16, Android 4.1
-        // For api < 16, VideoView is not able to read files written to disk since it reads them in
-        // a Context different from the Application and therefore does not have correct permission.
-        // To solve this problem we obtain the video file descriptor ourselves with valid permissions
-        // and pass it to the underlying MediaPlayer in VideoView.
-        if (VersionCode.currentApiLevel().isBelow(VersionCode.JELLY_BEAN)
-                && what == MediaPlayer.MEDIA_ERROR_UNKNOWN
-                && extra == VIDEO_VIEW_FILE_PERMISSION_ERROR
-                && mVideoRetries < MAX_VIDEO_RETRIES) {
-
-            FileInputStream inputStream = null;
-            try {
-                mediaPlayer.reset();
-                final File file = new File(mVastVideoConfiguration.getDiskMediaFileUrl());
-                inputStream = new FileInputStream(file);
-                mediaPlayer.setDataSource(inputStream.getFD());
-
-                // XXX
-                // VideoView has a callback registered with the MediaPlayer to set a flag when the
-                // media file has been prepared. Start also sets a flag in VideoView indicating the
-                // desired state is to play the video. Therefore, whichever method finishes last
-                // will check both flags and begin playing the video.
-                mediaPlayer.prepareAsync();
-                mVideoView.start();
-                return true;
-            } catch (Exception e) {
-                return false;
-            } finally {
-                Streams.closeStream(inputStream);
-                mVideoRetries++;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Called upon user click. Attempts open mopubnativebrowser links in the device browser and all
-     * other links in the MoPub in-app browser.
-     */
-    @VisibleForTesting
-    void handleClick(final List<String> clickThroughTrackers, final String clickThroughUrl) {
-        makeTrackingHttpRequest(clickThroughTrackers, getContext(), BaseEvent.Name.CLICK_REQUEST);
-
-        if (TextUtils.isEmpty(clickThroughUrl)) {
-            return;
-        }
-
-        broadcastAction(ACTION_INTERSTITIAL_CLICK);
-
-        if (Intents.isAboutScheme(clickThroughUrl)) {
-            MoPubLog.d("Link to about page ignored.");
-            return;
-        }
-
-        if (Intents.isNativeBrowserScheme(clickThroughUrl)) {
-            try {
-                final Intent intent = Intents.intentForNativeBrowserScheme(clickThroughUrl);
-                Intents.startActivity(getContext(), intent);
-                return;
-            } catch (UrlParseException e) {
-                MoPubLog.d(e.getMessage());
-            } catch (IntentNotResolvableException e) {
-                MoPubLog.d("Could not handle intent for URI: " + clickThroughUrl + ". "
-                        + e.getMessage());
-            }
-
-            return;
-        }
-
-        if (Intents.isHttpUrl(clickThroughUrl)) {
-            Bundle bundle = new Bundle();
-            bundle.putString(MoPubBrowser.DESTINATION_URL_KEY, clickThroughUrl);
-
-            getBaseVideoViewControllerListener().onStartActivityForResult(MoPubBrowser.class,
-                    MOPUB_BROWSER_REQUEST_CODE, bundle);
-            return;
-        }
-
-        MoPubLog.d("Link ignored. Unable to handle url: " + clickThroughUrl);
-    }
-
-    private ImageView createCompanionAdImageView(final Context context) {
-        RelativeLayout relativeLayout = new RelativeLayout(context);
-        relativeLayout.setGravity(Gravity.CENTER);
-        RelativeLayout.LayoutParams layoutParams =
-                new RelativeLayout.LayoutParams(
-                        RelativeLayout.LayoutParams.MATCH_PARENT,
-                        RelativeLayout.LayoutParams.MATCH_PARENT);
-        layoutParams.addRule(RelativeLayout.BELOW, mVastVideoToolbar.getId());
-        getLayout().addView(relativeLayout, layoutParams);
-
-        ImageView imageView = new ImageView(context);
-        // Set to invisible to have it be drawn to calculate size
-        imageView.setVisibility(View.INVISIBLE);
-
-        final RelativeLayout.LayoutParams companionAdLayout = new RelativeLayout.LayoutParams(
-                RelativeLayout.LayoutParams.MATCH_PARENT,
-                RelativeLayout.LayoutParams.MATCH_PARENT
-        );
-
-        relativeLayout.addView(imageView, companionAdLayout);
-        return imageView;
-    }
-
-    private boolean isLongVideo(final int duration) {
-        return (duration >= MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON);
-    }
-
-    private void makeVideoInteractable() {
-        mShowCloseButtonEventFired = true;
-        mVastVideoToolbar.makeInteractable();
-    }
-
-    private boolean shouldBeInteractable() {
-        return !mShowCloseButtonEventFired && mVideoView.getCurrentPosition() >= mShowCloseButtonDelay;
-    }
-
-    private boolean shouldAllowClickThrough() {
-        return mShowCloseButtonEventFired;
-    }
-
-    private void startProgressChecker() {
-        if (!mIsVideoProgressShouldBeChecked) {
-            mIsVideoProgressShouldBeChecked = true;
-            mHandler.post(mVideoProgressCheckerRunnable);
-        }
-    }
-
-    private void stopProgressChecker() {
-        if (mIsVideoProgressShouldBeChecked) {
-            mIsVideoProgressShouldBeChecked = false;
-            mHandler.removeCallbacks(mVideoProgressCheckerRunnable);
-        }
-    }
-
-    // for testing
-    @Deprecated
-    @VisibleForTesting
-    boolean getIsVideoProgressShouldBeChecked() {
-        return mIsVideoProgressShouldBeChecked;
-    }
-
-    // for testing
-    @Deprecated
-    @VisibleForTesting
-    int getVideoRetries() {
-        return mVideoRetries;
-    }
-
-    // for testing
-    @Deprecated
-    @VisibleForTesting
-    boolean getHasSkipOffset() {
-        return mHasSkipOffset;
-    }
-
-    // for testing
-    @Deprecated
-    @VisibleForTesting
-    int getShowCloseButtonDelay() {
-        return mShowCloseButtonDelay;
-    }
-
-    // for testing
-    @Deprecated
-    @VisibleForTesting
-    boolean isShowCloseButtonEventFired() {
-        return mShowCloseButtonEventFired;
-    }
-
-    // for testing
-    @Deprecated
-    @VisibleForTesting
-    void setCloseButtonVisible(boolean visible) {
-        mShowCloseButtonEventFired = visible;
-    }
-
-    // for testing
-    @Deprecated
-    @VisibleForTesting
-    boolean isVideoFinishedPlaying() {
-        return mIsVideoFinishedPlaying;
-    }
-
-    // for testing
-    @Deprecated
-    @VisibleForTesting
-    ImageView getCompanionAdImageView() {
-        return mCompanionAdImageView;
-    }
-
-    // for testing
-    @Deprecated
-    @VisibleForTesting
-    void setVideoError() {
-        mVideoError = true;
-    }
-
-    // for testing
-    @Deprecated
-    @VisibleForTesting
-    boolean getVideoError() {
-        return mVideoError;
-    }
-}
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.graphics.Bitmap;
+import android.graphics.Color;
+import android.graphics.drawable.Drawable;
+import android.graphics.drawable.GradientDrawable;
+import android.graphics.drawable.LayerDrawable;
+import android.media.MediaPlayer;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.text.TextUtils;
+import android.view.Gravity;
+import android.view.MotionEvent;
+import android.view.View;
+import android.widget.ImageView;
+import android.widget.RelativeLayout;
+import android.widget.VideoView;
+
+import com.mopub.common.DownloadResponse;
+import com.mopub.common.DownloadTask;
+import com.mopub.common.HttpResponses;
+import com.mopub.common.MoPubBrowser;
+import com.mopub.common.Preconditions;
+import com.mopub.common.UrlAction;
+import com.mopub.common.UrlHandler;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.event.BaseEvent;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.AsyncTasks;
+import com.mopub.common.util.Dips;
+import com.mopub.common.util.Drawables;
+import com.mopub.common.util.Streams;
+import com.mopub.common.util.Strings;
+import com.mopub.common.util.VersionCode;
+import com.mopub.mobileads.util.vast.VastCompanionAd;
+import com.mopub.mobileads.util.vast.VastVideoConfiguration;
+import com.mopub.network.TrackingRequest;
+
+import org.apache.http.HttpStatus;
+import org.apache.http.client.methods.HttpGet;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import static android.content.pm.ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
+import static android.content.pm.ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
+import static com.mopub.common.HttpClient.initializeHttpGet;
+import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_CLICK;
+import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
+import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
+import static com.mopub.network.TrackingRequest.makeTrackingHttpRequest;
+
+public class VastVideoViewController extends BaseVideoViewController implements DownloadTask.DownloadTaskListener {
+    static final String VAST_VIDEO_CONFIGURATION = "vast_video_configuration";
+
+    private static final long VIDEO_PROGRESS_TIMER_CHECKER_DELAY = 50;
+    private static final long VIDEO_COUNTDOWN_UPDATE_INTERVAL = 250;
+    private static final int MOPUB_BROWSER_REQUEST_CODE = 1;
+    private static final int MAX_VIDEO_RETRIES = 1;
+    private static final int VIDEO_VIEW_FILE_PERMISSION_ERROR = Integer.MIN_VALUE;
+
+    static final int DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON = 5 * 1000;
+    static final int MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON = 16 * 1000;
+
+    private final VastVideoConfiguration mVastVideoConfiguration;
+    private final VastCompanionAd mVastCompanionAd;
+    private final VastVideoToolbar mVastVideoToolbar;
+    private final VideoView mVideoView;
+    private final ImageView mCompanionAdImageView;
+    private final View.OnTouchListener mClickThroughListener;
+
+    private final VastVideoViewProgressRunnable mProgressCheckerRunnable;
+    private final VastVideoViewCountdownRunnable mCountdownRunnable;
+    private int mShowCloseButtonDelay = DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON;
+
+    private boolean mShowCloseButtonEventFired;
+
+    private int mSeekerPositionOnPause;
+    private boolean mIsVideoFinishedPlaying;
+    private int mVideoRetries;
+
+    private boolean mVideoError;
+    private boolean mCompletionTrackerFired;
+
+    private boolean mHasSkipOffset = false;
+
+    VastVideoViewController(final Context context,
+            final Bundle bundle,
+            final long broadcastIdentifier,
+            final BaseVideoViewControllerListener baseVideoViewControllerListener)
+            throws IllegalStateException {
+        super(context, broadcastIdentifier, baseVideoViewControllerListener);
+        mSeekerPositionOnPause = -1;
+        mVideoRetries = 0;
+
+        Serializable serializable = bundle.getSerializable(VAST_VIDEO_CONFIGURATION);
+        if (serializable != null && serializable instanceof VastVideoConfiguration) {
+            mVastVideoConfiguration = (VastVideoConfiguration) serializable;
+        } else {
+            throw new IllegalStateException("VastVideoConfiguration is invalid");
+        }
+
+        if (mVastVideoConfiguration.getDiskMediaFileUrl() == null) {
+            throw new IllegalStateException("VastVideoConfiguration does not have a video disk path");
+        }
+
+        mVastCompanionAd = mVastVideoConfiguration.getVastCompanionAd();
+
+        mClickThroughListener = new View.OnTouchListener() {
+            @Override
+            public boolean onTouch(View view, MotionEvent motionEvent) {
+                if (motionEvent.getAction() == MotionEvent.ACTION_UP && shouldAllowClickThrough()) {
+                    handleClick(
+                            mVastVideoConfiguration.getClickTrackers(),
+                            mVastVideoConfiguration.getClickThroughUrl()
+                    );
+                }
+                return true;
+            }
+        };
+
+        createVideoBackground(context);
+
+        mVideoView = createVideoView(context);
+        mVideoView.requestFocus();
+
+        mVastVideoToolbar = createVastVideoToolBar(context);
+        getLayout().addView(mVastVideoToolbar);
+
+        mCompanionAdImageView = createCompanionAdImageView(context);
+
+        Handler mainHandler = new Handler(Looper.getMainLooper());
+        mProgressCheckerRunnable = new VastVideoViewProgressRunnable(this, mainHandler);
+        mCountdownRunnable = new VastVideoViewCountdownRunnable(this, mainHandler);
+    }
+
+    @Override
+    protected VideoView getVideoView() {
+        return mVideoView;
+    }
+
+    @Override
+    protected void onCreate() {
+        super.onCreate();
+
+        switch (mVastVideoConfiguration.getCustomForceOrientation()) {
+            case FORCE_PORTRAIT:
+                getBaseVideoViewControllerListener().onSetRequestedOrientation(SCREEN_ORIENTATION_PORTRAIT);
+                break;
+            case FORCE_LANDSCAPE:
+                getBaseVideoViewControllerListener().onSetRequestedOrientation(SCREEN_ORIENTATION_LANDSCAPE);
+                break;
+            case DEVICE_ORIENTATION:
+                break;  // don't do anything
+            case UNDEFINED:
+                break;  // don't do anything
+            default:
+                break;
+        }
+
+        downloadCompanionAd();
+
+        makeTrackingHttpRequest(
+                mVastVideoConfiguration.getImpressionTrackers(),
+                getContext(),
+                BaseEvent.Name.IMPRESSION_REQUEST
+        );
+        broadcastAction(ACTION_INTERSTITIAL_SHOW);
+    }
+
+    @Override
+    protected void onResume() {
+        // When resuming, VideoView needs to reinitialize its MediaPlayer with the video path
+        // and therefore reset the count to zero, to let it retry on error
+        mVideoRetries = 0;
+        startRunnables();
+
+        mVideoView.seekTo(mSeekerPositionOnPause);
+        if (!mIsVideoFinishedPlaying) {
+            mVideoView.start();
+        }
+    }
+
+    @Override
+    protected void onPause() {
+        stopRunnables();
+        mSeekerPositionOnPause = getCurrentPosition();
+        mVideoView.pause();
+    }
+
+    @Override
+    protected void onDestroy() {
+        stopRunnables();
+        broadcastAction(ACTION_INTERSTITIAL_DISMISS);
+    }
+
+    // Enable the device's back button when the video close button has been displayed
+    @Override
+    public boolean backButtonEnabled() {
+        return mShowCloseButtonEventFired;
+    }
+
+    @Override
+    void onActivityResult(final int requestCode, final int resultCode, final Intent data) {
+        if (requestCode == MOPUB_BROWSER_REQUEST_CODE && resultCode == Activity.RESULT_OK) {
+            getBaseVideoViewControllerListener().onFinish();
+        }
+    }
+
+    // DownloadTaskListener
+    @Override
+    public void onComplete(String url, DownloadResponse downloadResponse) {
+        if (downloadResponse != null && downloadResponse.getStatusCode() == HttpStatus.SC_OK) {
+            final Bitmap companionAdBitmap = HttpResponses.asBitmap(downloadResponse);
+            if (companionAdBitmap != null) {
+                // If Bitmap fits in ImageView, then don't use MATCH_PARENT
+                final int width = Dips.dipsToIntPixels(companionAdBitmap.getWidth(), getContext());
+                final int height = Dips.dipsToIntPixels(companionAdBitmap.getHeight(), getContext());
+                final int imageViewWidth = mCompanionAdImageView.getMeasuredWidth();
+                final int imageViewHeight = mCompanionAdImageView.getMeasuredHeight();
+                if (width < imageViewWidth && height < imageViewHeight) {
+                    mCompanionAdImageView.getLayoutParams().width = width;
+                    mCompanionAdImageView.getLayoutParams().height = height;
+                }
+                mCompanionAdImageView.setImageBitmap(companionAdBitmap);
+                mCompanionAdImageView.setOnClickListener(new View.OnClickListener() {
+                    @Override
+                    public void onClick(View view) {
+                        if (mVastCompanionAd != null) {
+                            handleClick(
+                                    mVastCompanionAd.getClickTrackers(),
+                                    mVastCompanionAd.getClickThroughUrl()
+                            );
+                        }
+                    }
+                });
+            }
+        }
+    }
+
+    private void downloadCompanionAd() {
+        if (mVastCompanionAd != null) {
+            try {
+                final HttpGet httpGet = initializeHttpGet(mVastCompanionAd.getImageUrl(), getContext());
+                final DownloadTask downloadTask = new DownloadTask(this);
+                AsyncTasks.safeExecuteOnExecutor(downloadTask, httpGet);
+            } catch (Exception e) {
+                MoPubLog.d("Failed to download companion ad", e);
+            }
+        }
+    }
+
+    private void adjustSkipOffset() {
+        int videoDuration = getDuration();
+
+        // Default behavior: video is non-skippable if duration < 16 seconds
+        if (videoDuration < MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON) {
+            mShowCloseButtonDelay = videoDuration;
+        }
+
+        // Override if skipoffset attribute is specified in VAST
+        String skipOffsetString = mVastVideoConfiguration.getSkipOffset();
+        if (skipOffsetString != null) {
+            try {
+                if (Strings.isAbsoluteTracker(skipOffsetString)) {
+                    Integer skipOffsetMilliseconds = Strings.parseAbsoluteOffset(skipOffsetString);
+                    if (skipOffsetMilliseconds != null && skipOffsetMilliseconds < videoDuration) {
+                        mShowCloseButtonDelay = skipOffsetMilliseconds;
+                        mHasSkipOffset = true;
+                    }
+                } else if (Strings.isPercentageTracker(skipOffsetString)) {
+                    float percentage = Float.parseFloat(skipOffsetString.replace("%", "")) / 100f;
+                    int skipOffsetMillisecondsRounded = Math.round(videoDuration * percentage);
+                    if (skipOffsetMillisecondsRounded < videoDuration) {
+                        mShowCloseButtonDelay = skipOffsetMillisecondsRounded;
+                        mHasSkipOffset = true;
+                    }
+                } else {
+                    MoPubLog.d(String.format("Invalid VAST skipoffset format: %s", skipOffsetString));
+                }
+            } catch (NumberFormatException e) {
+                MoPubLog.d(String.format("Failed to parse skipoffset %s", skipOffsetString));
+            }
+        }
+    }
+
+    /**
+     * Returns untriggered VAST progress trackers with a progress before the provided position.
+     *
+     * @param currentPositionMillis the current video position in milliseconds.
+     * @param videoLengthMillis the total video length.
+     */
+    @NonNull
+    List<VastTracker> getUntriggeredTrackersBefore(int currentPositionMillis, int videoLengthMillis) {
+        if (Preconditions.NoThrow.checkArgument(videoLengthMillis > 0)) {
+            float progressFraction = currentPositionMillis / (float) (videoLengthMillis);
+            List<VastTracker> untriggeredTrackers = new ArrayList<VastTracker>();
+
+            final ArrayList<VastAbsoluteProgressTracker> absoluteTrackers = mVastVideoConfiguration.getAbsoluteTrackers();
+            VastAbsoluteProgressTracker absoluteTest = new VastAbsoluteProgressTracker("", currentPositionMillis);
+            int absoluteTrackerCount = absoluteTrackers.size();
+            for (int i = 0; i < absoluteTrackerCount; i++) {
+                VastAbsoluteProgressTracker tracker = absoluteTrackers.get(i);
+                if (tracker.compareTo(absoluteTest) > 0) {
+                    break;
+                }
+                if (!tracker.isTracked()) {
+                    untriggeredTrackers.add(tracker);
+                }
+            }
+
+            final ArrayList<VastFractionalProgressTracker> fractionalTrackers = mVastVideoConfiguration.getFractionalTrackers();
+            final VastFractionalProgressTracker fractionalTest = new VastFractionalProgressTracker("", progressFraction);
+            int fractionalTrackerCount = fractionalTrackers.size();
+            for (int i = 0; i < fractionalTrackerCount; i++) {
+                VastFractionalProgressTracker tracker = fractionalTrackers.get(i);
+                if (tracker.compareTo(fractionalTest) > 0) {
+                    break;
+                }
+                if (!tracker.isTracked()) {
+                    untriggeredTrackers.add(tracker);
+                }
+            }
+
+            return untriggeredTrackers;
+        } else {
+            return Collections.emptyList();
+        }
+    }
+
+    private int remainingProgressTrackerCount() {
+        return getUntriggeredTrackersBefore(Integer.MAX_VALUE, Integer.MAX_VALUE).size();
+    }
+
+    private void createVideoBackground(final Context context) {
+        GradientDrawable gradientDrawable = new GradientDrawable(
+                GradientDrawable.Orientation.TOP_BOTTOM,
+                new int[]{Color.argb(0, 0, 0, 0), Color.argb(255, 0, 0, 0)}
+        );
+        Drawable[] layers = new Drawable[2];
+        layers[0] = Drawables.THATCHED_BACKGROUND.createDrawable(context);
+        layers[1] = gradientDrawable;
+        LayerDrawable layerList = new LayerDrawable(layers);
+        getLayout().setBackgroundDrawable(layerList);
+    }
+
+    private VastVideoToolbar createVastVideoToolBar(final Context context) {
+        final VastVideoToolbar vastVideoToolbar = new VastVideoToolbar(context);
+        vastVideoToolbar.setCloseButtonOnTouchListener(new View.OnTouchListener() {
+            @Override
+            public boolean onTouch(View view, MotionEvent motionEvent) {
+                if (motionEvent.getAction() == MotionEvent.ACTION_UP) {
+                    TrackingRequest.makeTrackingHttpRequest(
+                            mVastVideoConfiguration.getCloseTrackers(), context);
+                    TrackingRequest.makeTrackingHttpRequest(
+                            mVastVideoConfiguration.getSkipTrackers(), context);
+                    getBaseVideoViewControllerListener().onFinish();
+                }
+                return true;
+            }
+        });
+        vastVideoToolbar.setLearnMoreButtonOnTouchListener(mClickThroughListener);
+
+        // update custom CTA text if specified in VAST extension
+        String customCtaText = mVastVideoConfiguration.getCustomCtaText();
+        if (customCtaText != null) {
+            vastVideoToolbar.updateLearnMoreButtonText(customCtaText);
+        }
+
+        // update custom skip text if specified in VAST extensions
+        String customSkipText = mVastVideoConfiguration.getCustomSkipText();
+        if (customSkipText != null) {
+            vastVideoToolbar.updateCloseButtonText(customSkipText);
+        }
+
+        // update custom close icon if specified in VAST extensions
+        String customCloseIconUrl = mVastVideoConfiguration.getCustomCloseIconUrl();
+        if (customCloseIconUrl != null) {
+            vastVideoToolbar.updateCloseButtonIcon(customCloseIconUrl);
+        }
+
+        return vastVideoToolbar;
+    }
+
+    private VideoView createVideoView(final Context context) {
+        final VideoView videoView = new VideoView(context);
+        videoView.setOnPreparedListener(new MediaPlayer.OnPreparedListener() {
+            @Override
+            public void onPrepared(MediaPlayer mp) {
+                // Called when media source is ready for playback
+                adjustSkipOffset();
+            }
+        });
+        videoView.setOnTouchListener(mClickThroughListener);
+
+        videoView.setOnCompletionListener(new MediaPlayer.OnCompletionListener() {
+            @Override
+            public void onCompletion(MediaPlayer mp) {
+                stopRunnables();
+                makeVideoInteractable();
+
+                videoCompleted(false);
+                mIsVideoFinishedPlaying = true;
+
+                // Only fire the completion tracker if we hit all the progress marks. Some Android implementations
+                // fire the completion event even if the whole video isn't watched.
+                if (!mVideoError && remainingProgressTrackerCount() == 0 && !mCompletionTrackerFired) {
+                    makeTrackingHttpRequest(mVastVideoConfiguration.getCompleteTrackers(), context);
+                    mCompletionTrackerFired = true;
+                }
+
+                videoView.setVisibility(View.GONE);
+                // check the drawable to see if the image view was populated with content
+                if (mCompanionAdImageView.getDrawable() != null) {
+                    mCompanionAdImageView.setVisibility(View.VISIBLE);
+                }
+            }
+        });
+
+        videoView.setOnErrorListener(new MediaPlayer.OnErrorListener() {
+            @Override
+            public boolean onError(final MediaPlayer mediaPlayer, final int what, final int extra) {
+                if (retryMediaPlayer(mediaPlayer, what, extra)) {
+                    return true;
+                } else {
+                    stopRunnables();
+                    makeVideoInteractable();
+                    videoError(false);
+                    mVideoError = true;
+                    return false;
+                }
+            }
+        });
+
+        videoView.setVideoPath(mVastVideoConfiguration.getDiskMediaFileUrl());
+
+        return videoView;
+    }
+
+    boolean retryMediaPlayer(final MediaPlayer mediaPlayer, final int what, final int extra) {
+        // XXX
+        // VideoView has a bug in versions lower than Jelly Bean, Api Level 16, Android 4.1
+        // For api < 16, VideoView is not able to read files written to disk since it reads them in
+        // a Context different from the Application and therefore does not have correct permission.
+        // To solve this problem we obtain the video file descriptor ourselves with valid permissions
+        // and pass it to the underlying MediaPlayer in VideoView.
+        if (VersionCode.currentApiLevel().isBelow(VersionCode.JELLY_BEAN)
+                && what == MediaPlayer.MEDIA_ERROR_UNKNOWN
+                && extra == VIDEO_VIEW_FILE_PERMISSION_ERROR
+                && mVideoRetries < MAX_VIDEO_RETRIES) {
+
+            FileInputStream inputStream = null;
+            try {
+                mediaPlayer.reset();
+                final File file = new File(mVastVideoConfiguration.getDiskMediaFileUrl());
+                inputStream = new FileInputStream(file);
+                mediaPlayer.setDataSource(inputStream.getFD());
+
+                // XXX
+                // VideoView has a callback registered with the MediaPlayer to set a flag when the
+                // media file has been prepared. Start also sets a flag in VideoView indicating the
+                // desired state is to play the video. Therefore, whichever method finishes last
+                // will check both flags and begin playing the video.
+                mediaPlayer.prepareAsync();
+                mVideoView.start();
+                return true;
+            } catch (Exception e) {
+                return false;
+            } finally {
+                Streams.closeStream(inputStream);
+                mVideoRetries++;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Called upon user click. Attempts open mopubnativebrowser links in the device browser and all
+     * other links in the MoPub in-app browser.
+     */
+    @VisibleForTesting
+    void handleClick(final List<String> clickThroughTrackers, final String clickThroughUrl) {
+        makeTrackingHttpRequest(clickThroughTrackers, getContext(), BaseEvent.Name.CLICK_REQUEST);
+
+        if (TextUtils.isEmpty(clickThroughUrl)) {
+            return;
+        }
+
+        broadcastAction(ACTION_INTERSTITIAL_CLICK);
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(
+                        UrlAction.IGNORE_ABOUT_SCHEME,
+                        UrlAction.OPEN_NATIVE_BROWSER,
+                        UrlAction.OPEN_IN_APP_BROWSER,
+                        UrlAction.HANDLE_SHARE_TWEET)
+                .withResultActions(new UrlHandler.ResultActions() {
+                    @Override
+                    public void urlHandlingSucceeded(@NonNull String url,
+                            @NonNull UrlAction urlAction) {
+                        if (urlAction == UrlAction.OPEN_IN_APP_BROWSER) {
+                            Bundle bundle = new Bundle();
+                            bundle.putString(MoPubBrowser.DESTINATION_URL_KEY, clickThroughUrl);
+
+                            getBaseVideoViewControllerListener().onStartActivityForResult(
+                                    MoPubBrowser.class, MOPUB_BROWSER_REQUEST_CODE, bundle);
+                        }
+                    }
+
+                    @Override
+                    public void urlHandlingFailed(@NonNull String url,
+                            @NonNull UrlAction lastFailedUrlAction) {
+                    }
+                })
+                .withoutMoPubBrowser()
+                .build().handleUrl(getContext(), clickThroughUrl);
+    }
+
+    private ImageView createCompanionAdImageView(final Context context) {
+        RelativeLayout relativeLayout = new RelativeLayout(context);
+        relativeLayout.setGravity(Gravity.CENTER);
+        RelativeLayout.LayoutParams layoutParams =
+                new RelativeLayout.LayoutParams(
+                        RelativeLayout.LayoutParams.MATCH_PARENT,
+                        RelativeLayout.LayoutParams.MATCH_PARENT);
+        layoutParams.addRule(RelativeLayout.BELOW, mVastVideoToolbar.getId());
+        getLayout().addView(relativeLayout, layoutParams);
+
+        ImageView imageView = new ImageView(context);
+        // Set to invisible to have it be drawn to calculate size
+        imageView.setVisibility(View.INVISIBLE);
+
+        final RelativeLayout.LayoutParams companionAdLayout = new RelativeLayout.LayoutParams(
+                RelativeLayout.LayoutParams.MATCH_PARENT,
+                RelativeLayout.LayoutParams.MATCH_PARENT
+        );
+
+        relativeLayout.addView(imageView, companionAdLayout);
+        return imageView;
+    }
+
+    int getDuration() {
+        return mVideoView.getDuration();
+    }
+
+    int getCurrentPosition() {
+        return mVideoView.getCurrentPosition();
+    }
+
+    boolean isLongVideo(final int duration) {
+        return (duration >= MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON);
+    }
+
+    void makeVideoInteractable() {
+        mShowCloseButtonEventFired = true;
+        mVastVideoToolbar.makeInteractable();
+    }
+
+    boolean shouldBeInteractable() {
+        return !mShowCloseButtonEventFired && getCurrentPosition() >= mShowCloseButtonDelay;
+    }
+
+    boolean shouldShowCountdown() {
+        // show countdown if any of the following conditions is satisfied:
+        // 1) long video
+        // 2) skipoffset is specified in VAST and is less than video duration
+        final int duration = getDuration();
+        return isLongVideo(duration) || (mHasSkipOffset && mShowCloseButtonDelay < duration);
+    }
+
+    void updateCountdown() {
+        mVastVideoToolbar.updateCountdownWidget(mShowCloseButtonDelay - getCurrentPosition());
+    }
+
+    void updateDuration() {
+        mVastVideoToolbar.updateDurationWidget(getDuration() - getCurrentPosition());
+    }
+
+    private boolean shouldAllowClickThrough() {
+        return mShowCloseButtonEventFired;
+    }
+
+    private void startRunnables() {
+        mProgressCheckerRunnable.startRepeating(VIDEO_PROGRESS_TIMER_CHECKER_DELAY);
+        mCountdownRunnable.startRepeating(VIDEO_COUNTDOWN_UPDATE_INTERVAL);
+    }
+
+    private void stopRunnables() {
+        mProgressCheckerRunnable.stop();
+        mCountdownRunnable.stop();
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    VastVideoViewProgressRunnable getProgressCheckerRunnable() {
+        return mProgressCheckerRunnable;
+    }
+
+    @Deprecated
+    @VisibleForTesting
+    VastVideoViewCountdownRunnable getCountdownRunnable() {
+        return mCountdownRunnable;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    int getVideoRetries() {
+        return mVideoRetries;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    boolean getHasSkipOffset() {
+        return mHasSkipOffset;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    int getShowCloseButtonDelay() {
+        return mShowCloseButtonDelay;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    boolean isShowCloseButtonEventFired() {
+        return mShowCloseButtonEventFired;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    void setCloseButtonVisible(boolean visible) {
+        mShowCloseButtonEventFired = visible;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    boolean isVideoFinishedPlaying() {
+        return mIsVideoFinishedPlaying;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    ImageView getCompanionAdImageView() {
+        return mCompanionAdImageView;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    void setVideoError() {
+        mVideoError = true;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    boolean getVideoError() {
+        return mVideoError;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewCountdownRunnable.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewCountdownRunnable.java
new file mode 100644
index 00000000..14323626
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewCountdownRunnable.java
@@ -0,0 +1,39 @@
+package com.mopub.mobileads;
+
+import android.os.Handler;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+
+/**
+ * This class is used to update a {@link VastVideoViewController}'s countdown display according to rules
+ * contained in the {@link VastVideoViewController}
+ */
+public class VastVideoViewCountdownRunnable extends RepeatingHandlerRunnable {
+
+    @NonNull private final VastVideoViewController mVideoViewController;
+
+    public VastVideoViewCountdownRunnable(@NonNull VastVideoViewController videoViewController,
+            @NonNull Handler handler) {
+        super(handler);
+        Preconditions.checkNotNull(handler);
+        Preconditions.checkNotNull(videoViewController);
+
+
+        mVideoViewController = videoViewController;
+    }
+
+    @Override
+    public void doWork() {
+        // Countdown and interactable are mutually exclusive. Should we refactor to collapse them?
+        if (mVideoViewController.shouldShowCountdown()) {
+            mVideoViewController.updateCountdown();
+        }
+
+        if (mVideoViewController.shouldBeInteractable()) {
+            mVideoViewController.makeVideoInteractable();
+        }
+
+        mVideoViewController.updateDuration();
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewProgressRunnable.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewProgressRunnable.java
new file mode 100644
index 00000000..1936ada0
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewProgressRunnable.java
@@ -0,0 +1,46 @@
+package com.mopub.mobileads;
+
+import android.os.Handler;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+import com.mopub.network.TrackingRequest;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * A runnable that is used to measure video progress and track video progress events for video ads.
+ *
+ */
+public class VastVideoViewProgressRunnable extends RepeatingHandlerRunnable {
+
+    @NonNull private final VastVideoViewController mVideoViewController;
+    public VastVideoViewProgressRunnable(@NonNull VastVideoViewController videoViewController,
+            @NonNull Handler handler) {
+        super(handler);
+
+        Preconditions.checkNotNull(videoViewController);
+        mVideoViewController = videoViewController;
+    }
+
+    @Override
+    public void doWork() {
+        int videoLength = mVideoViewController.getDuration();
+        int currentPosition = mVideoViewController.getCurrentPosition();
+
+        if (videoLength > 0) {
+            final List<VastTracker> trackersToTrack =
+                    mVideoViewController.getUntriggeredTrackersBefore(currentPosition, videoLength);
+            if (!trackersToTrack.isEmpty()) {
+                final List<String> trackUrls = new ArrayList<String>();
+                for (VastTracker tracker : trackersToTrack) {
+                    trackUrls.add(tracker.getTrackingUrl());
+                    tracker.setTracked();
+                }
+                TrackingRequest.makeTrackingHttpRequest(trackUrls, mVideoViewController.getContext());
+            }
+
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidController.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidController.java
index 758be57e..cfb4bcf9 100644
--- a/mopub-sdk/src/main/java/com/mopub/mraid/MraidController.java
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidController.java
@@ -1,1162 +1,1116 @@
-package com.mopub.mraid;
-
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.content.BroadcastReceiver;
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.content.pm.ActivityInfo;
-import android.content.pm.PackageManager;
-import android.graphics.Rect;
-import android.net.Uri;
-import android.os.Build.VERSION;
-import android.os.Build.VERSION_CODES;
-import android.os.Bundle;
-import android.os.Handler;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.util.DisplayMetrics;
-import android.view.MotionEvent;
-import android.view.View;
-import android.view.View.OnTouchListener;
-import android.view.ViewGroup;
-import android.view.ViewTreeObserver.OnPreDrawListener;
-import android.view.WindowManager;
-import android.webkit.ConsoleMessage;
-import android.webkit.JsResult;
-import android.widget.FrameLayout;
-import android.widget.FrameLayout.LayoutParams;
-
-import com.mopub.common.AdReport;
-import com.mopub.common.CloseableLayout;
-import com.mopub.common.CloseableLayout.ClosePosition;
-import com.mopub.common.CloseableLayout.OnCloseListener;
-import com.mopub.common.MoPubBrowser;
-import com.mopub.common.Preconditions;
-import com.mopub.common.VisibleForTesting;
-import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.DeviceUtils;
-import com.mopub.common.util.Dips;
-import com.mopub.common.util.Intents;
-import com.mopub.common.util.Views;
-import com.mopub.exceptions.IntentNotResolvableException;
-import com.mopub.exceptions.UrlParseException;
-import com.mopub.mobileads.MraidVideoPlayerActivity;
-import com.mopub.mobileads.util.WebViews;
-import com.mopub.mraid.MraidBridge.MraidBridgeListener;
-import com.mopub.mraid.MraidBridge.MraidWebView;
-
-import java.lang.ref.WeakReference;
-import java.net.URI;
-
-import static android.content.pm.ActivityInfo.CONFIG_ORIENTATION;
-import static android.content.pm.ActivityInfo.CONFIG_SCREEN_SIZE;
-import static com.mopub.common.util.Utils.bitMaskContainsFlag;
-
-public class MraidController {
-    private final AdReport mAdReport;
-
-    public interface MraidListener {
-        public void onLoaded(View view);
-        public void onFailedToLoad();
-        public void onExpand();
-        public void onOpen();
-        public void onClose();
-    }
-
-    public interface UseCustomCloseListener {
-        public void useCustomCloseChanged(boolean useCustomClose);
-    }
-
-    /**
-     * Holds a weak reference to the activity if the context that is passed in is an activity.
-     * While this field is never null, the reference could become null. This reference starts out
-     * null if the passed-in context is not an activity.
-     */
-    @NonNull private final WeakReference<Activity> mWeakActivity;
-    @NonNull private final Context mContext;
-    @NonNull private final PlacementType mPlacementType;
-
-    // An ad container, which contains the ad web view in default state, but is empty when expanded.
-    @NonNull private final FrameLayout mDefaultAdContainer;
-
-    // Ad ad container which contains the ad view in expanded state.
-    @NonNull private final CloseableLayout mCloseableAdContainer;
-
-    // Root view, where we'll add the expanded ad
-    @Nullable private ViewGroup mRootView;
-
-    // Helper classes for updating screen values
-    @NonNull private final ScreenMetricsWaiter mScreenMetricsWaiter;
-    @NonNull private final MraidScreenMetrics mScreenMetrics;
-
-    // Current view state
-    @NonNull private ViewState mViewState = ViewState.LOADING;
-
-    // Listeners
-    @Nullable private MraidListener mMraidListener;
-    @Nullable private UseCustomCloseListener mOnCloseButtonListener;
-    @Nullable private MraidWebViewDebugListener mDebugListener;
-
-    // The WebView which will display the ad. "Two part" creatives, loaded via handleExpand(URL)
-    // are shown in a separate web view
-    @Nullable private MraidWebView mMraidWebView;
-    @Nullable private MraidWebView mTwoPartWebView;
-
-    // A bridge to handle all interactions with the WebView HTML and Javascript.
-    @NonNull private final MraidBridge mMraidBridge;
-    @NonNull private final MraidBridge mTwoPartBridge;
-
-    @NonNull private OrientationBroadcastReceiver mOrientationBroadcastReceiver =
-            new OrientationBroadcastReceiver();
-
-    // Stores the requested orientation for the Activity to which this controller's view belongs.
-    // This is needed to restore the Activity's requested orientation in the event that the view
-    // itself requires an orientation lock.
-    @Nullable private Integer mOriginalActivityOrientation;
-
-    private boolean mAllowOrientationChange = true;
-    private MraidOrientation mForceOrientation = MraidOrientation.NONE;
-
-    private final MraidNativeCommandHandler mMraidNativeCommandHandler;
-
-    private boolean mIsPaused;
-
-    public MraidController(@NonNull Context context, @Nullable AdReport adReport,
-            @NonNull PlacementType placementType) {
-        this(context, adReport, placementType,
-                new MraidBridge(adReport, placementType),
-                new MraidBridge(adReport, PlacementType.INTERSTITIAL),
-                new ScreenMetricsWaiter());
-    }
-
-    @VisibleForTesting
-    MraidController(@NonNull Context context, @Nullable AdReport adReport,
-            @NonNull PlacementType placementType,
-            @NonNull MraidBridge bridge, @NonNull MraidBridge twoPartBridge,
-            @NonNull ScreenMetricsWaiter screenMetricsWaiter) {
-        mContext = context.getApplicationContext();
-        Preconditions.checkNotNull(mContext);
-        mAdReport = adReport;
-        if (context instanceof Activity) {
-            mWeakActivity = new WeakReference<Activity>((Activity) context);
-        } else {
-            // Make sure mWeakActivity itself is never null, though the reference
-            // it's pointing to could be null.
-            mWeakActivity = new WeakReference<Activity>(null);
-        }
-
-        mPlacementType = placementType;
-        mMraidBridge = bridge;
-        mTwoPartBridge = twoPartBridge;
-        mScreenMetricsWaiter = screenMetricsWaiter;
-
-        mViewState = ViewState.LOADING;
-
-        DisplayMetrics displayMetrics = mContext.getResources().getDisplayMetrics();
-        mScreenMetrics = new MraidScreenMetrics(mContext, displayMetrics.density);
-        mDefaultAdContainer = new FrameLayout(mContext);
-        mCloseableAdContainer = new CloseableLayout(mContext);
-        mCloseableAdContainer.setOnCloseListener(new OnCloseListener() {
-            @Override
-            public void onClose() {
-                handleClose();
-            }
-        });
-
-        View dimmingView = new View(mContext);
-        dimmingView.setOnTouchListener(new OnTouchListener() {
-            public boolean onTouch(View v, MotionEvent event) {
-                return true;
-            }
-        });
-        mCloseableAdContainer.addView(dimmingView,
-                new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
-
-        mOrientationBroadcastReceiver.register(mContext);
-
-        mMraidBridge.setMraidBridgeListener(mMraidBridgeListener);
-        mTwoPartBridge.setMraidBridgeListener(mTwoPartBridgeListener);
-        mMraidNativeCommandHandler = new MraidNativeCommandHandler();
-    }
-
-    @SuppressWarnings("FieldCanBeLocal")
-    private final MraidBridgeListener mMraidBridgeListener = new MraidBridgeListener() {
-        @Override
-        public void onPageLoaded() {
-            handlePageLoad();
-        }
-
-        @Override
-        public void onPageFailedToLoad() {
-            if (mMraidListener != null) {
-                mMraidListener.onFailedToLoad();
-            }
-        }
-
-        @Override
-        public void onVisibilityChanged(final boolean isVisible) {
-            // The bridge only receives visibility events if there is no 2 part covering it
-            if (!mTwoPartBridge.isAttached()) {
-                mMraidBridge.notifyViewability(isVisible);
-            }
-        }
-
-        @Override
-        public boolean onJsAlert(@NonNull final String message, @NonNull final JsResult result) {
-            return handleJsAlert(message, result);
-        }
-
-        @Override
-        public boolean onConsoleMessage(@NonNull final ConsoleMessage consoleMessage) {
-            return handleConsoleMessage(consoleMessage);
-        }
-
-        @Override
-        public void onClose() {
-            handleClose();
-        }
-
-        @Override
-        public void onResize(final int width, final int height, final int offsetX,
-                final int offsetY, @NonNull final ClosePosition closePosition,
-                final boolean allowOffscreen) throws MraidCommandException {
-            handleResize(width, height, offsetX, offsetY, closePosition, allowOffscreen);
-        }
-
-        public void onExpand(@Nullable final URI uri, final boolean shouldUseCustomClose)
-                throws MraidCommandException {
-            handleExpand(uri, shouldUseCustomClose);
-        }
-
-        @Override
-        public void onUseCustomClose(final boolean shouldUseCustomClose) {
-            handleCustomClose(shouldUseCustomClose);
-        }
-
-        @Override
-        public void onSetOrientationProperties(final boolean allowOrientationChange,
-                final MraidOrientation forceOrientation) throws MraidCommandException {
-            handleSetOrientationProperties(allowOrientationChange, forceOrientation);
-        }
-
-        @Override
-        public void onOpen(@NonNull final URI uri) {
-            handleOpen(uri.toString());
-        }
-
-        @Override
-        public void onPlayVideo(@NonNull final URI uri) {
-            handleShowVideo(uri.toString());
-        }
-    };
-
-    @SuppressWarnings("FieldCanBeLocal")
-    private final MraidBridgeListener mTwoPartBridgeListener = new MraidBridgeListener() {
-        @Override
-        public void onPageLoaded() {
-            handleTwoPartPageLoad();
-        }
-
-        @Override
-        public void onPageFailedToLoad() {
-            // no-op for two-part expandables. An expandable failing to load should not trigger failover.
-        }
-
-        @Override
-        public void onVisibilityChanged(final boolean isVisible) {
-            // The original web view must see the 2-part bridges visibility
-            mMraidBridge.notifyViewability(isVisible);
-            mTwoPartBridge.notifyViewability(isVisible);
-        }
-
-        @Override
-        public boolean onJsAlert(@NonNull final String message, @NonNull final JsResult result) {
-            return handleJsAlert(message, result);
-        }
-
-        @Override
-        public boolean onConsoleMessage(@NonNull final ConsoleMessage consoleMessage) {
-            return handleConsoleMessage(consoleMessage);
-        }
-
-        @Override
-        public void onResize(final int width, final int height, final int offsetX,
-                final int offsetY, @NonNull final ClosePosition closePosition,
-                final boolean allowOffscreen) throws MraidCommandException {
-            throw new MraidCommandException("Not allowed to resize from an expanded state");
-        }
-
-        @Override
-        public void onExpand(@Nullable final URI uri, final boolean shouldUseCustomClose) {
-            // The MRAID spec dictates that this is ignored rather than firing an error
-        }
-
-        @Override
-        public void onClose() {
-            handleClose();
-        }
-
-        @Override
-        public void onUseCustomClose(final boolean shouldUseCustomClose) {
-            handleCustomClose(shouldUseCustomClose);
-        }
-
-        @Override
-        public void onSetOrientationProperties(final boolean allowOrientationChange,
-                final MraidOrientation forceOrientation) throws MraidCommandException {
-            handleSetOrientationProperties(allowOrientationChange, forceOrientation);
-        }
-
-        @Override
-        public void onOpen(final URI uri) {
-            handleOpen(uri.toString());
-        }
-
-        @Override
-        public void onPlayVideo(@NonNull final URI uri) {
-            handleShowVideo(uri.toString());
-        }
-    };
-
-    public void setMraidListener(@Nullable MraidListener mraidListener) {
-        mMraidListener = mraidListener;
-    }
-
-    public void setUseCustomCloseListener(@Nullable UseCustomCloseListener listener) {
-        mOnCloseButtonListener = listener;
-    }
-
-    public void setDebugListener(@Nullable MraidWebViewDebugListener debugListener) {
-        mDebugListener = debugListener;
-    }
-
-    public void loadContent(@NonNull String htmlData) {
-        Preconditions.checkState(mMraidWebView == null, "loadContent should only be called once");
-
-        mMraidWebView = new MraidWebView(mContext);
-        mMraidBridge.attachView(mMraidWebView);
-        mDefaultAdContainer.addView(mMraidWebView,
-                new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
-
-        // onPageLoaded gets fired once the html is loaded into the webView
-        mMraidBridge.setContentHtml(htmlData);
-    }
-
-    // onPageLoaded gets fired once the html is loaded into the webView.
-    private int getDisplayRotation() {
-        WindowManager wm = (WindowManager) mContext
-                .getSystemService(Context.WINDOW_SERVICE);
-        return wm.getDefaultDisplay().getRotation();
-    }
-
-    @VisibleForTesting
-    boolean handleConsoleMessage(@NonNull final ConsoleMessage consoleMessage) {
-        //noinspection SimplifiableIfStatement
-        if (mDebugListener != null) {
-            return mDebugListener.onConsoleMessage(consoleMessage);
-        }
-        return true;
-    }
-
-    @VisibleForTesting
-    boolean handleJsAlert(@NonNull final String message, @NonNull final JsResult result) {
-        if (mDebugListener != null) {
-            return mDebugListener.onJsAlert(message, result);
-        }
-        result.confirm();
-        return true;
-    }
-
-    @VisibleForTesting
-    static class ScreenMetricsWaiter {
-        static class WaitRequest {
-            @NonNull private final View[] mViews;
-            @NonNull private final Handler mHandler;
-            @Nullable private Runnable mSuccessRunnable;
-            int mWaitCount;
-
-            private WaitRequest(@NonNull Handler handler, @NonNull final View[] views) {
-                mHandler = handler;
-                mViews = views;
-            }
-
-            private void countDown() {
-                mWaitCount--;
-                if (mWaitCount == 0 && mSuccessRunnable != null) {
-                    mSuccessRunnable.run();
-                    mSuccessRunnable = null;
-                }
-            }
-
-            private final Runnable mWaitingRunnable = new Runnable() {
-                @Override
-                public void run() {
-                    for (final View view : mViews) {
-                        // Immediately count down for any views that already have a size
-                        if (view.getHeight() > 0 || view.getWidth() > 0) {
-                            countDown();
-                            continue;
-                        }
-
-                        // For views that didn't have a size, listen (once) for a preDraw. Note
-                        // that this doesn't leak because the ViewTreeObserver gets detached when
-                        // the view is no longer part of the view hierarchy.
-                        view.getViewTreeObserver().addOnPreDrawListener(new OnPreDrawListener() {
-                            @Override
-                            public boolean onPreDraw() {
-                                view.getViewTreeObserver().removeOnPreDrawListener(this);
-                                countDown();
-                                return true;
-                            }
-                        });
-                    }
-                }
-            };
-
-            void start(@NonNull Runnable successRunnable) {
-                mSuccessRunnable = successRunnable;
-                mWaitCount = mViews.length;
-                mHandler.post(mWaitingRunnable);
-            }
-
-            void cancel() {
-                mHandler.removeCallbacks(mWaitingRunnable);
-                mSuccessRunnable = null;
-            }
-        }
-
-        @NonNull private final Handler mHandler = new Handler();
-        @Nullable private WaitRequest mLastWaitRequest;
-
-        WaitRequest waitFor(@NonNull View... views) {
-            mLastWaitRequest = new WaitRequest(mHandler, views);
-            return mLastWaitRequest;
-        }
-
-        void cancelLastRequest() {
-            if (mLastWaitRequest != null) {
-                mLastWaitRequest.cancel();
-                mLastWaitRequest = null;
-            }
-        }
-    }
-
-    @Nullable
-    private View getCurrentWebView() {
-        return mTwoPartBridge.isAttached() ? mTwoPartWebView : mMraidWebView;
-    }
-
-    private boolean isInlineVideoAvailable() {
-        //noinspection SimplifiableIfStatement
-        final Activity activity = mWeakActivity.get();
-        if (activity == null || getCurrentWebView() == null) {
-            return false;
-        }
-
-        return mMraidNativeCommandHandler.isInlineVideoAvailable(activity, getCurrentWebView());
-    }
-
-    @VisibleForTesting
-    void handlePageLoad() {
-        setViewState(ViewState.DEFAULT, new Runnable() {
-            @Override
-            public void run() {
-                mMraidBridge.notifySupports(
-                        mMraidNativeCommandHandler.isSmsAvailable(mContext),
-                        mMraidNativeCommandHandler.isTelAvailable(mContext),
-                        MraidNativeCommandHandler.isCalendarAvailable(mContext),
-                        MraidNativeCommandHandler.isStorePictureSupported(mContext),
-                        isInlineVideoAvailable());
-                mMraidBridge.notifyPlacementType(mPlacementType);
-                mMraidBridge.notifyViewability(mMraidBridge.isVisible());
-                mMraidBridge.notifyReady();
-            }
-        });
-
-        // Call onLoaded immediately. This causes the container to get added to the view hierarchy
-        if (mMraidListener != null) {
-            mMraidListener.onLoaded(mDefaultAdContainer);
-        }
-    }
-
-    @VisibleForTesting
-    void handleTwoPartPageLoad() {
-        updateScreenMetricsAsync(new Runnable() {
-            @Override
-            public void run() {
-                mTwoPartBridge.notifySupports(
-                        mMraidNativeCommandHandler.isSmsAvailable(mContext),
-                        mMraidNativeCommandHandler.isTelAvailable(mContext),
-                        mMraidNativeCommandHandler.isCalendarAvailable(mContext),
-                        mMraidNativeCommandHandler.isStorePictureSupported(mContext),
-                        isInlineVideoAvailable());
-                mTwoPartBridge.notifyViewState(mViewState);
-                mTwoPartBridge.notifyPlacementType(mPlacementType);
-                mTwoPartBridge.notifyViewability(mTwoPartBridge.isVisible());
-                mTwoPartBridge.notifyReady();
-            }
-        });
-    }
-
-    /**
-     * Updates screen metrics, calling the successRunnable once they are available. The
-     * successRunnable will always be called asynchronously, ie on the next main thread loop.
-     */
-    private void updateScreenMetricsAsync(@Nullable final Runnable successRunnable) {
-        // Don't allow multiple metrics wait requests at once
-        mScreenMetricsWaiter.cancelLastRequest();
-
-        // Determine which web view should be used for the current ad position
-        final View currentWebView = getCurrentWebView();
-        if (currentWebView == null) {
-            return;
-        }
-
-        // Wait for the next draw pass on the default ad container and current web view
-        mScreenMetricsWaiter.waitFor(mDefaultAdContainer, currentWebView).start(
-                new Runnable() {
-                    @Override
-                    public void run() {
-                        DisplayMetrics displayMetrics = mContext.getResources().getDisplayMetrics();
-                        mScreenMetrics.setScreenSize(
-                                displayMetrics.widthPixels, displayMetrics.heightPixels);
-
-                        int[] location = new int[2];
-                        View rootView = getRootView();
-                        rootView.getLocationOnScreen(location);
-                        mScreenMetrics.setRootViewPosition(location[0], location[1],
-                                rootView.getWidth(),
-                                rootView.getHeight());
-
-                        mDefaultAdContainer.getLocationOnScreen(location);
-                        mScreenMetrics.setDefaultAdPosition(location[0], location[1],
-                                mDefaultAdContainer.getWidth(),
-                                mDefaultAdContainer.getHeight());
-
-                        currentWebView.getLocationOnScreen(location);
-                        mScreenMetrics.setCurrentAdPosition(location[0], location[1],
-                                currentWebView.getWidth(),
-                                currentWebView.getHeight());
-
-                        // Always notify both bridges of the new metrics
-                        mMraidBridge.notifyScreenMetrics(mScreenMetrics);
-                        if (mTwoPartBridge.isAttached()) {
-                            mTwoPartBridge.notifyScreenMetrics(mScreenMetrics);
-                        }
-
-                        if (successRunnable != null) {
-                            successRunnable.run();
-                        }
-                    }
-                });
-    }
-
-    void handleOrientationChange(int currentRotation) {
-        updateScreenMetricsAsync(null);
-    }
-
-    public void pause(boolean isFinishing) {
-        mIsPaused = true;
-
-        // This causes an inline video to pause if there is one playing
-        if (mMraidWebView != null) {
-            WebViews.onPause(mMraidWebView, isFinishing);
-        }
-        if (mTwoPartWebView != null) {
-            WebViews.onPause(mTwoPartWebView, isFinishing);
-        }
-    }
-
-    public void resume() {
-        mIsPaused = false;
-
-        // This causes an inline video to resume if it was playing previously
-        if (mMraidWebView != null) {
-            WebViews.onResume(mMraidWebView);
-        }
-        if (mTwoPartWebView != null) {
-            WebViews.onResume(mTwoPartWebView);
-        }
-    }
-
-    public void destroy() {
-        mScreenMetricsWaiter.cancelLastRequest();
-
-        try {
-            mOrientationBroadcastReceiver.unregister();
-        } catch (IllegalArgumentException e) {
-            if (!e.getMessage().contains("Receiver not registered")) {
-                throw e;
-            } // Else ignore this exception.
-        }
-
-        // Pause the controller to make sure the video gets stopped.
-        if (!mIsPaused) {
-            pause(true);
-        }
-
-        // Remove the closeable ad container from the view hierarchy, if necessary
-        Views.removeFromParent(mCloseableAdContainer);
-
-        // Calling destroy eliminates a memory leak on Gingerbread devices
-        mMraidBridge.detach();
-        if (mMraidWebView != null) {
-            mMraidWebView.destroy();
-            mMraidWebView = null;
-        }
-        mTwoPartBridge.detach();
-        if (mTwoPartWebView != null) {
-            mTwoPartWebView.destroy();
-            mTwoPartWebView = null;
-        }
-    }
-
-    private void setViewState(@NonNull ViewState viewState) {
-        setViewState(viewState, null);
-    }
-
-    private void setViewState(@NonNull ViewState viewState, @Nullable Runnable successRunnable) {
-        // Make sure this is a valid transition.
-        MoPubLog.d("MRAID state set to " + viewState);
-        mViewState = viewState;
-        mMraidBridge.notifyViewState(viewState);
-
-        // Changing state notifies the two part view, but only if it's loaded
-        if (mTwoPartBridge.isLoaded()) {
-            mTwoPartBridge.notifyViewState(viewState);
-        }
-
-        if (mMraidListener != null) {
-            if (viewState == ViewState.EXPANDED) {
-                mMraidListener.onExpand();
-            } else if (viewState == ViewState.HIDDEN) {
-                mMraidListener.onClose();
-            }
-        }
-
-        updateScreenMetricsAsync(successRunnable);
-    }
-
-    int clampInt(int min, int target, int max) {
-        return Math.max(min, Math.min(target, max));
-    }
-
-    @VisibleForTesting
-    void handleResize(final int widthDips, final int heightDips, final int offsetXDips,
-            final int offsetYDips, @NonNull final ClosePosition closePosition,
-            final boolean allowOffscreen)
-            throws MraidCommandException {
-        if (mMraidWebView == null) {
-            throw new MraidCommandException("Unable to resize after the WebView is destroyed");
-        }
-
-        // The spec says that there is no effect calling resize from loaded or hidden, but that
-        // calling it from expanded should raise an error.
-        if (mViewState == ViewState.LOADING
-                || mViewState == ViewState.HIDDEN) {
-            return;
-        } else if (mViewState == ViewState.EXPANDED) {
-            throw new MraidCommandException("Not allowed to resize from an already expanded ad");
-        }
-
-        if (mPlacementType == PlacementType.INTERSTITIAL) {
-            throw new MraidCommandException("Not allowed to resize from an interstitial ad");
-        }
-
-        // Translate coordinates to px and get the resize rect
-        int width = Dips.dipsToIntPixels(widthDips, mContext);
-        int height = Dips.dipsToIntPixels(heightDips, mContext);
-        int offsetX = Dips.dipsToIntPixels(offsetXDips, mContext);
-        int offsetY = Dips.dipsToIntPixels(offsetYDips, mContext);
-        int left = mScreenMetrics.getDefaultAdRect().left + offsetX;
-        int top = mScreenMetrics.getDefaultAdRect().top + offsetY;
-        Rect resizeRect = new Rect(left, top, left + width, top + height);
-
-        if (!allowOffscreen) {
-            // Require the entire ad to be on-screen.
-            Rect bounds = mScreenMetrics.getRootViewRect();
-            if (resizeRect.width() > bounds.width() || resizeRect.height() > bounds.height()) {
-                throw new MraidCommandException("resizeProperties specified a size ("
-                        + widthDips + ", " + heightDips + ") and offset ("
-                        + offsetXDips + ", " + offsetYDips + ") that doesn't allow the ad to"
-                        + " appear within the max allowed size ("
-                        + mScreenMetrics.getRootViewRectDips().width() + ", "
-                        + mScreenMetrics.getRootViewRectDips().height() + ")");
-            }
-
-            // Offset the resize rect so that it displays on the screen
-            int newLeft = clampInt(bounds.left, resizeRect.left, bounds.right - resizeRect.width());
-            int newTop = clampInt(bounds.top, resizeRect.top, bounds.bottom - resizeRect.height());
-            resizeRect.offsetTo(newLeft, newTop);
-        }
-
-        // The entire close region must always be visible.
-        Rect closeRect = new Rect();
-        mCloseableAdContainer.applyCloseRegionBounds(closePosition, resizeRect, closeRect);
-        if (!mScreenMetrics.getRootViewRect().contains(closeRect)) {
-            throw new MraidCommandException("resizeProperties specified a size ("
-                    + widthDips + ", " + heightDips + ") and offset ("
-                    + offsetXDips + ", " + offsetYDips + ") that doesn't allow the close"
-                    + " region to appear within the max allowed size ("
-                    + mScreenMetrics.getRootViewRectDips().width() + ", "
-                    + mScreenMetrics.getRootViewRectDips().height() + ")");
-        }
-
-        if (!resizeRect.contains(closeRect)) {
-            throw new MraidCommandException("resizeProperties specified a size ("
-                    + widthDips + ", " + height + ") and offset ("
-                    + offsetXDips + ", " + offsetYDips + ") that don't allow the close region to appear "
-                    + "within the resized ad.");
-        }
-
-        // Resized ads always rely on the creative's close button (as if useCustomClose were true)
-        mCloseableAdContainer.setCloseVisible(false);
-        mCloseableAdContainer.setClosePosition(closePosition);
-
-        // Put the ad in the closeable container and resize it
-        LayoutParams layoutParams = new LayoutParams(resizeRect.width(), resizeRect.height());
-        layoutParams.leftMargin = resizeRect.left - mScreenMetrics.getRootViewRect().left;
-        layoutParams.topMargin = resizeRect.top - mScreenMetrics.getRootViewRect().top;
-        if (mViewState == ViewState.DEFAULT) {
-            mDefaultAdContainer.removeView(mMraidWebView);
-            mDefaultAdContainer.setVisibility(View.INVISIBLE);
-            mCloseableAdContainer.addView(mMraidWebView,
-                    new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
-            getRootView().addView(mCloseableAdContainer, layoutParams);
-        } else if (mViewState == ViewState.RESIZED) {
-            mCloseableAdContainer.setLayoutParams(layoutParams);
-        }
-        mCloseableAdContainer.setClosePosition(closePosition);
-
-        setViewState(ViewState.RESIZED);
-    }
-
-    void handleExpand(@Nullable URI uri, boolean shouldUseCustomClose)
-            throws MraidCommandException {
-        if (mMraidWebView == null) {
-            throw new MraidCommandException("Unable to expand after the WebView is destroyed");
-        }
-
-        if (mPlacementType == PlacementType.INTERSTITIAL) {
-            return;
-        }
-
-        if (mViewState != ViewState.DEFAULT && mViewState != ViewState.RESIZED) {
-            return;
-        }
-
-        applyOrientation();
-
-        // For two part expands, create a new web view
-        boolean isTwoPart = (uri != null);
-        if (isTwoPart) {
-            // Of note: the two part ad will start off with its view state as LOADING, and will
-            // transition to EXPANDED once the page is fully loaded
-            mTwoPartWebView = new MraidWebView(mContext);
-            mTwoPartBridge.attachView(mTwoPartWebView);
-
-            // onPageLoaded gets fired once the html is loaded into the two part webView
-            mTwoPartBridge.setContentUrl(uri.toString());
-        }
-
-        // Make sure the correct webView is in the closeable  container and make it full screen
-        LayoutParams layoutParams = new LayoutParams(
-                LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
-        if (mViewState == ViewState.DEFAULT) {
-            if (isTwoPart) {
-                mCloseableAdContainer.addView(mTwoPartWebView, layoutParams);
-            } else {
-                mDefaultAdContainer.removeView(mMraidWebView);
-                mDefaultAdContainer.setVisibility(View.INVISIBLE);
-                mCloseableAdContainer.addView(mMraidWebView, layoutParams);
-            }
-            getRootView().addView(mCloseableAdContainer,
-                    new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
-        } else if (mViewState == ViewState.RESIZED) {
-            if (isTwoPart) {
-                // Move the ad back to the original container so that when we close the
-                // resized ad, it will be in the correct place
-                mCloseableAdContainer.removeView(mMraidWebView);
-                mDefaultAdContainer.addView(mMraidWebView, layoutParams);
-                mDefaultAdContainer.setVisibility(View.INVISIBLE);
-                mCloseableAdContainer.addView(mTwoPartWebView, layoutParams);
-            }
-            // If we were resized and not 2 part, nothing to do.
-        }
-        mCloseableAdContainer.setLayoutParams(layoutParams);
-        handleCustomClose(shouldUseCustomClose);
-
-        // Update to expanded once we have new screen metrics. This won't update the two-part ad,
-        // because it is not yet loaded.
-        setViewState(ViewState.EXPANDED);
-    }
-
-    @VisibleForTesting
-    void handleClose() {
-        if (mMraidWebView == null) {
-            // Doesn't throw an exception because the ad has been destroyed
-            return;
-        }
-
-        if (mViewState == ViewState.LOADING || mViewState == ViewState.HIDDEN) {
-            return;
-        }
-
-        // Unlock the orientation before changing the view hierarchy.
-        if (mViewState == ViewState.EXPANDED || mPlacementType == PlacementType.INTERSTITIAL) {
-            unApplyOrientation();
-        }
-
-        if (mViewState == ViewState.RESIZED || mViewState == ViewState.EXPANDED) {
-            if (mTwoPartBridge.isAttached() && mTwoPartWebView != null) {
-                // If we have a two part web view, simply remove it from the closeable container
-                mCloseableAdContainer.removeView(mTwoPartWebView);
-                mTwoPartBridge.detach();
-            } else {
-                // Move the web view from the closeable container back to the default container
-                mCloseableAdContainer.removeView(mMraidWebView);
-                mDefaultAdContainer.addView(mMraidWebView, new LayoutParams(
-                        LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
-                mDefaultAdContainer.setVisibility(View.VISIBLE);
-            }
-            getRootView().removeView(mCloseableAdContainer);
-
-            // Set the view state to default
-            setViewState(ViewState.DEFAULT);
-        } else if (mViewState == ViewState.DEFAULT) {
-            mDefaultAdContainer.setVisibility(View.INVISIBLE);
-            setViewState(ViewState.HIDDEN);
-        }
-    }
-
-    @NonNull
-    @TargetApi(VERSION_CODES.KITKAT)
-    private ViewGroup getRootView() {
-        if (mRootView == null) {
-            // This method should never be called this method before the container is ready, ie before
-            // handlePageLoad.
-            if (VERSION.SDK_INT >= VERSION_CODES.KITKAT) {
-                Preconditions.checkState(mDefaultAdContainer.isAttachedToWindow());
-            }
-
-            mRootView = (ViewGroup) mDefaultAdContainer.getRootView().findViewById(
-                    android.R.id.content);
-        }
-
-        return mRootView;
-    }
-
-    @VisibleForTesting
-    void handleShowVideo(@NonNull String videoUrl) {
-        MraidVideoPlayerActivity.startMraid(mContext, videoUrl);
-    }
-
-    @VisibleForTesting
-    void lockOrientation(final int screenOrientation) throws MraidCommandException {
-        final Activity activity = mWeakActivity.get();
-        if (activity == null || !shouldAllowForceOrientation(mForceOrientation)) {
-            throw new MraidCommandException("Attempted to lock orientation to unsupported value: " +
-                    mForceOrientation.name());
-        }
-
-        if (mOriginalActivityOrientation == null) {
-            mOriginalActivityOrientation = activity.getRequestedOrientation();
-        }
-
-        activity.setRequestedOrientation(screenOrientation);
-    }
-
-    @VisibleForTesting
-    void applyOrientation() throws MraidCommandException {
-        if (mForceOrientation == MraidOrientation.NONE) {
-            if (mAllowOrientationChange) {
-                // If screen orientation can be changed, an orientation of NONE means that any
-                // orientation lock should be removed
-                unApplyOrientation();
-            } else {
-                final Activity activity = mWeakActivity.get();
-                if (activity == null) {
-                    throw new MraidCommandException("Unable to set MRAID expand orientation to " +
-                            "'none'; expected passed in Activity Context.");
-                }
-
-                // If screen orientation cannot be changed and we can obtain the current
-                // screen orientation, locking it to the current orientation is a best effort
-                lockOrientation(DeviceUtils.getScreenOrientation(activity));
-            }
-        } else {
-            // Otherwise, we have a valid, non-NONE orientation. Lock the screen based on this value
-            lockOrientation(mForceOrientation.getActivityInfoOrientation());
-        }
-    }
-
-    @VisibleForTesting
-    void unApplyOrientation() {
-        final Activity activity = mWeakActivity.get();
-        if (activity != null && mOriginalActivityOrientation != null) {
-            activity.setRequestedOrientation(mOriginalActivityOrientation);
-        }
-        mOriginalActivityOrientation = null;
-    }
-
-    @TargetApi(VERSION_CODES.HONEYCOMB_MR2)
-    @VisibleForTesting
-    boolean shouldAllowForceOrientation(final MraidOrientation newOrientation) {
-        // NONE is the default and always allowed
-        if (newOrientation == MraidOrientation.NONE) {
-            return true;
-        }
-
-        final Activity activity = mWeakActivity.get();
-        // If we can't obtain an Activity, return false
-        if (activity == null) {
-            return false;
-        }
-
-        final ActivityInfo activityInfo;
-        try {
-            activityInfo = activity.getPackageManager().getActivityInfo(
-                    new ComponentName(activity, activity.getClass()), 0);
-        } catch (PackageManager.NameNotFoundException e) {
-            return false;
-        }
-
-        // If an orientation is explicitly declared in the manifest, allow forcing this orientation
-        final int activityOrientation = activityInfo.screenOrientation;
-        if (activityOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
-            return activityOrientation == newOrientation.getActivityInfoOrientation();
-        }
-
-        // Make sure the config changes won't tear down the activity when moving to this orientation
-        // The necessary configChanges must always include "orientation"
-        boolean containsNecessaryConfigChanges =
-                bitMaskContainsFlag(activityInfo.configChanges, CONFIG_ORIENTATION);
-
-        // And on API 13+, configChanges must also include "screenSize"
-        if (VERSION.SDK_INT >= VERSION_CODES.HONEYCOMB_MR2) {
-            containsNecessaryConfigChanges = containsNecessaryConfigChanges
-                    && bitMaskContainsFlag(activityInfo.configChanges, CONFIG_SCREEN_SIZE);
-        }
-
-        return containsNecessaryConfigChanges;
-    }
-
-    @VisibleForTesting
-    void handleCustomClose(boolean useCustomClose) {
-        boolean wasUsingCustomClose = !mCloseableAdContainer.isCloseVisible();
-        if (useCustomClose == wasUsingCustomClose) {
-            return;
-        }
-
-        mCloseableAdContainer.setCloseVisible(!useCustomClose);
-        if (mOnCloseButtonListener != null) {
-            mOnCloseButtonListener.useCustomCloseChanged(useCustomClose);
-        }
-    }
-
-    @NonNull
-    public FrameLayout getAdContainer() {
-        return mDefaultAdContainer;
-    }
-
-    /**
-     * Loads a javascript URL. Useful for running callbacks, such as javascript:webviewDidClose()
-     */
-    public void loadJavascript(@NonNull String javascript) {
-        mMraidBridge.injectJavaScript(javascript);
-    }
-
-    @VisibleForTesting
-    class OrientationBroadcastReceiver extends BroadcastReceiver {
-        @Nullable private Context mContext;
-
-        // -1 until this gets set at least once
-        private int mLastRotation = -1;
-
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            if (mContext == null) {
-                return;
-            }
-
-            if (Intent.ACTION_CONFIGURATION_CHANGED.equals(intent.getAction())) {
-                int orientation = getDisplayRotation();
-
-                if (orientation != mLastRotation) {
-                    mLastRotation = orientation;
-                    handleOrientationChange(mLastRotation);
-                }
-            }
-        }
-
-        public void register(@NonNull final Context context) {
-            Preconditions.checkNotNull(context);
-            mContext = context.getApplicationContext();
-            if (mContext != null) {
-                mContext.registerReceiver(this,
-                        new IntentFilter(Intent.ACTION_CONFIGURATION_CHANGED));
-            }
-        }
-
-        public void unregister() {
-            if (mContext != null) {
-                mContext.unregisterReceiver(this);
-                mContext = null;
-            }
-        }
-    }
-
-    @NonNull
-    public Context getContext() {
-        return mContext;
-    }
-
-    @VisibleForTesting
-    void handleSetOrientationProperties(final boolean allowOrientationChange,
-            final MraidOrientation forceOrientation) throws MraidCommandException {
-        if (!shouldAllowForceOrientation(forceOrientation)) {
-            throw new MraidCommandException(
-                    "Unable to force orientation to " + forceOrientation);
-        }
-
-        mAllowOrientationChange = allowOrientationChange;
-        mForceOrientation = forceOrientation;
-
-        if (mViewState == ViewState.EXPANDED || mPlacementType == PlacementType.INTERSTITIAL) {
-            applyOrientation();
-        }
-    }
-
-    /**
-     * Attempts to handle mopubnativebrowser links in the device browser, deep-links in the
-     * corresponding application, and all other links in the MoPub in-app browser.
-     */
-    @VisibleForTesting
-    void handleOpen(@NonNull final String url) {
-        MoPubLog.d("Opening url: " + url);
-
-        if (mMraidListener != null) {
-            mMraidListener.onOpen();
-        }
-
-        if (Intents.isAboutScheme(url)) {
-            MoPubLog.d("Link to about page ignored.");
-            return;
-        }
-
-        // MoPubNativeBrowser URLs
-        if (Intents.isNativeBrowserScheme(url)) {
-            try {
-                final Intent intent = Intents.intentForNativeBrowserScheme(url);
-                Intents.startActivity(mContext, intent);
-            } catch (UrlParseException e) {
-                MoPubLog.d("Unable to load mopub native browser url: " + url + ". "
-                        + e.getMessage());
-            } catch (IntentNotResolvableException e) {
-                MoPubLog.d("Unable to load mopub native browser url: " + url + ". "
-                        + e.getMessage());
-            }
-
-            return;
-        }
-
-        if (Intents.isHttpUrl(url)) {
-            final Bundle extras = new Bundle();
-            extras.putString(MoPubBrowser.DESTINATION_URL_KEY, url);
-
-            final Intent intent = Intents.getStartActivityIntent(mContext, MoPubBrowser.class,
-                    extras);
-            try {
-                Intents.startActivity(mContext, intent);
-            } catch (IntentNotResolvableException e) {
-                MoPubLog.d("Unable to launch intent for URL: " + url + ".");
-            }
-            return;
-        }
-
-        // Non-http(s) URLs like app deep links
-        if (Intents.canHandleApplicationUrl(mContext, url)) {
-            final Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
-
-            try {
-                Intents.startActivity(mContext, intent);
-            } catch (IntentNotResolvableException e) {
-                MoPubLog.d("Unable to resolve application url: " + url);
-            }
-            return;
-        }
-
-        MoPubLog.d("Link ignored. Unable to handle url: " + url);
-    }
-
-    @VisibleForTesting
-    @Deprecated // for testing
-    @NonNull
-    ViewState getViewState() {
-        return mViewState;
-    }
-
-    @VisibleForTesting
-    @Deprecated // for testing
-    void setViewStateForTesting(@NonNull ViewState viewState) {
-        mViewState = viewState;
-    }
-
-    @VisibleForTesting
-    @Deprecated // for testing
-    @NonNull
-    CloseableLayout getExpandedAdContainer() {
-        return mCloseableAdContainer;
-    }
-
-    @VisibleForTesting
-    @Deprecated // for testing
-    void setRootView(FrameLayout rootView) {
-        mRootView = rootView;
-    }
-
-    @VisibleForTesting
-    @Deprecated // for testing
-    void setRootViewSize(int width, int height) {
-        mScreenMetrics.setRootViewPosition(0, 0, width, height);
-    }
-
-    @VisibleForTesting
-    @Deprecated // for testing
-    Integer getOriginalActivityOrientation() {
-        return mOriginalActivityOrientation;
-    }
-
-    @VisibleForTesting
-    @Deprecated // for testing
-    boolean getAllowOrientationChange() {
-        return mAllowOrientationChange;
-    }
-
-    @VisibleForTesting
-    @Deprecated // for testing
-    MraidOrientation getForceOrientation() {
-        return mForceOrientation;
-    }
-
-    @VisibleForTesting
-    @Deprecated // for testing
-    void setOrientationBroadcastReceiver(OrientationBroadcastReceiver receiver) {
-        mOrientationBroadcastReceiver = receiver;
-    }
-
-    @VisibleForTesting
-    @Deprecated // for testing
-    MraidWebView getMraidWebView() {
-        return mMraidWebView;
-    }
-
-    @VisibleForTesting
-    @Deprecated // for testing
-    MraidWebView getTwoPartWebView() {
-        return mTwoPartWebView;
-    }
-}
+package com.mopub.mraid;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.ActivityInfo;
+import android.content.pm.PackageManager;
+import android.graphics.Rect;
+import android.os.Build.VERSION;
+import android.os.Build.VERSION_CODES;
+import android.os.Handler;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.DisplayMetrics;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.View.OnTouchListener;
+import android.view.ViewGroup;
+import android.view.ViewTreeObserver.OnPreDrawListener;
+import android.view.WindowManager;
+import android.webkit.ConsoleMessage;
+import android.webkit.JsResult;
+import android.widget.FrameLayout;
+import android.widget.FrameLayout.LayoutParams;
+
+import com.mopub.common.AdReport;
+import com.mopub.common.UrlHandler;
+import com.mopub.common.CloseableLayout;
+import com.mopub.common.CloseableLayout.ClosePosition;
+import com.mopub.common.CloseableLayout.OnCloseListener;
+import com.mopub.common.Preconditions;
+import com.mopub.common.UrlAction;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.DeviceUtils;
+import com.mopub.common.util.Dips;
+import com.mopub.common.util.Views;
+import com.mopub.mobileads.MraidVideoPlayerActivity;
+import com.mopub.mobileads.util.WebViews;
+import com.mopub.mraid.MraidBridge.MraidBridgeListener;
+import com.mopub.mraid.MraidBridge.MraidWebView;
+
+import java.lang.ref.WeakReference;
+import java.net.URI;
+
+import static android.content.pm.ActivityInfo.CONFIG_ORIENTATION;
+import static android.content.pm.ActivityInfo.CONFIG_SCREEN_SIZE;
+import static com.mopub.common.util.Utils.bitMaskContainsFlag;
+
+public class MraidController {
+    private final AdReport mAdReport;
+
+    public interface MraidListener {
+        public void onLoaded(View view);
+        public void onFailedToLoad();
+        public void onExpand();
+        public void onOpen();
+        public void onClose();
+    }
+
+    public interface UseCustomCloseListener {
+        public void useCustomCloseChanged(boolean useCustomClose);
+    }
+
+    /**
+     * Holds a weak reference to the activity if the context that is passed in is an activity.
+     * While this field is never null, the reference could become null. This reference starts out
+     * null if the passed-in context is not an activity.
+     */
+    @NonNull private final WeakReference<Activity> mWeakActivity;
+    @NonNull private final Context mContext;
+    @NonNull private final PlacementType mPlacementType;
+
+    // An ad container, which contains the ad web view in default state, but is empty when expanded.
+    @NonNull private final FrameLayout mDefaultAdContainer;
+
+    // Ad ad container which contains the ad view in expanded state.
+    @NonNull private final CloseableLayout mCloseableAdContainer;
+
+    // Root view, where we'll add the expanded ad
+    @Nullable private ViewGroup mRootView;
+
+    // Helper classes for updating screen values
+    @NonNull private final ScreenMetricsWaiter mScreenMetricsWaiter;
+    @NonNull private final MraidScreenMetrics mScreenMetrics;
+
+    // Current view state
+    @NonNull private ViewState mViewState = ViewState.LOADING;
+
+    // Listeners
+    @Nullable private MraidListener mMraidListener;
+    @Nullable private UseCustomCloseListener mOnCloseButtonListener;
+    @Nullable private MraidWebViewDebugListener mDebugListener;
+
+    // The WebView which will display the ad. "Two part" creatives, loaded via handleExpand(URL)
+    // are shown in a separate web view
+    @Nullable private MraidWebView mMraidWebView;
+    @Nullable private MraidWebView mTwoPartWebView;
+
+    // A bridge to handle all interactions with the WebView HTML and Javascript.
+    @NonNull private final MraidBridge mMraidBridge;
+    @NonNull private final MraidBridge mTwoPartBridge;
+
+    @NonNull private OrientationBroadcastReceiver mOrientationBroadcastReceiver =
+            new OrientationBroadcastReceiver();
+
+    // Stores the requested orientation for the Activity to which this controller's view belongs.
+    // This is needed to restore the Activity's requested orientation in the event that the view
+    // itself requires an orientation lock.
+    @Nullable private Integer mOriginalActivityOrientation;
+
+    private boolean mAllowOrientationChange = true;
+    private MraidOrientation mForceOrientation = MraidOrientation.NONE;
+
+    private final MraidNativeCommandHandler mMraidNativeCommandHandler;
+
+    private boolean mIsPaused;
+
+    public MraidController(@NonNull Context context, @Nullable AdReport adReport,
+            @NonNull PlacementType placementType) {
+        this(context, adReport, placementType,
+                new MraidBridge(adReport, placementType),
+                new MraidBridge(adReport, PlacementType.INTERSTITIAL),
+                new ScreenMetricsWaiter());
+    }
+
+    @VisibleForTesting
+    MraidController(@NonNull Context context, @Nullable AdReport adReport,
+            @NonNull PlacementType placementType,
+            @NonNull MraidBridge bridge, @NonNull MraidBridge twoPartBridge,
+            @NonNull ScreenMetricsWaiter screenMetricsWaiter) {
+        mContext = context.getApplicationContext();
+        Preconditions.checkNotNull(mContext);
+        mAdReport = adReport;
+        if (context instanceof Activity) {
+            mWeakActivity = new WeakReference<Activity>((Activity) context);
+        } else {
+            // Make sure mWeakActivity itself is never null, though the reference
+            // it's pointing to could be null.
+            mWeakActivity = new WeakReference<Activity>(null);
+        }
+
+        mPlacementType = placementType;
+        mMraidBridge = bridge;
+        mTwoPartBridge = twoPartBridge;
+        mScreenMetricsWaiter = screenMetricsWaiter;
+
+        mViewState = ViewState.LOADING;
+
+        DisplayMetrics displayMetrics = mContext.getResources().getDisplayMetrics();
+        mScreenMetrics = new MraidScreenMetrics(mContext, displayMetrics.density);
+        mDefaultAdContainer = new FrameLayout(mContext);
+        mCloseableAdContainer = new CloseableLayout(mContext);
+        mCloseableAdContainer.setOnCloseListener(new OnCloseListener() {
+            @Override
+            public void onClose() {
+                handleClose();
+            }
+        });
+
+        View dimmingView = new View(mContext);
+        dimmingView.setOnTouchListener(new OnTouchListener() {
+            public boolean onTouch(View v, MotionEvent event) {
+                return true;
+            }
+        });
+        mCloseableAdContainer.addView(dimmingView,
+                new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
+
+        mOrientationBroadcastReceiver.register(mContext);
+
+        mMraidBridge.setMraidBridgeListener(mMraidBridgeListener);
+        mTwoPartBridge.setMraidBridgeListener(mTwoPartBridgeListener);
+        mMraidNativeCommandHandler = new MraidNativeCommandHandler();
+    }
+
+    @SuppressWarnings("FieldCanBeLocal")
+    private final MraidBridgeListener mMraidBridgeListener = new MraidBridgeListener() {
+        @Override
+        public void onPageLoaded() {
+            handlePageLoad();
+        }
+
+        @Override
+        public void onPageFailedToLoad() {
+            if (mMraidListener != null) {
+                mMraidListener.onFailedToLoad();
+            }
+        }
+
+        @Override
+        public void onVisibilityChanged(final boolean isVisible) {
+            // The bridge only receives visibility events if there is no 2 part covering it
+            if (!mTwoPartBridge.isAttached()) {
+                mMraidBridge.notifyViewability(isVisible);
+            }
+        }
+
+        @Override
+        public boolean onJsAlert(@NonNull final String message, @NonNull final JsResult result) {
+            return handleJsAlert(message, result);
+        }
+
+        @Override
+        public boolean onConsoleMessage(@NonNull final ConsoleMessage consoleMessage) {
+            return handleConsoleMessage(consoleMessage);
+        }
+
+        @Override
+        public void onClose() {
+            handleClose();
+        }
+
+        @Override
+        public void onResize(final int width, final int height, final int offsetX,
+                final int offsetY, @NonNull final ClosePosition closePosition,
+                final boolean allowOffscreen) throws MraidCommandException {
+            handleResize(width, height, offsetX, offsetY, closePosition, allowOffscreen);
+        }
+
+        public void onExpand(@Nullable final URI uri, final boolean shouldUseCustomClose)
+                throws MraidCommandException {
+            handleExpand(uri, shouldUseCustomClose);
+        }
+
+        @Override
+        public void onUseCustomClose(final boolean shouldUseCustomClose) {
+            handleCustomClose(shouldUseCustomClose);
+        }
+
+        @Override
+        public void onSetOrientationProperties(final boolean allowOrientationChange,
+                final MraidOrientation forceOrientation) throws MraidCommandException {
+            handleSetOrientationProperties(allowOrientationChange, forceOrientation);
+        }
+
+        @Override
+        public void onOpen(@NonNull final URI uri) {
+            handleOpen(uri.toString());
+        }
+
+        @Override
+        public void onPlayVideo(@NonNull final URI uri) {
+            handleShowVideo(uri.toString());
+        }
+    };
+
+    @SuppressWarnings("FieldCanBeLocal")
+    private final MraidBridgeListener mTwoPartBridgeListener = new MraidBridgeListener() {
+        @Override
+        public void onPageLoaded() {
+            handleTwoPartPageLoad();
+        }
+
+        @Override
+        public void onPageFailedToLoad() {
+            // no-op for two-part expandables. An expandable failing to load should not trigger failover.
+        }
+
+        @Override
+        public void onVisibilityChanged(final boolean isVisible) {
+            // The original web view must see the 2-part bridges visibility
+            mMraidBridge.notifyViewability(isVisible);
+            mTwoPartBridge.notifyViewability(isVisible);
+        }
+
+        @Override
+        public boolean onJsAlert(@NonNull final String message, @NonNull final JsResult result) {
+            return handleJsAlert(message, result);
+        }
+
+        @Override
+        public boolean onConsoleMessage(@NonNull final ConsoleMessage consoleMessage) {
+            return handleConsoleMessage(consoleMessage);
+        }
+
+        @Override
+        public void onResize(final int width, final int height, final int offsetX,
+                final int offsetY, @NonNull final ClosePosition closePosition,
+                final boolean allowOffscreen) throws MraidCommandException {
+            throw new MraidCommandException("Not allowed to resize from an expanded state");
+        }
+
+        @Override
+        public void onExpand(@Nullable final URI uri, final boolean shouldUseCustomClose) {
+            // The MRAID spec dictates that this is ignored rather than firing an error
+        }
+
+        @Override
+        public void onClose() {
+            handleClose();
+        }
+
+        @Override
+        public void onUseCustomClose(final boolean shouldUseCustomClose) {
+            handleCustomClose(shouldUseCustomClose);
+        }
+
+        @Override
+        public void onSetOrientationProperties(final boolean allowOrientationChange,
+                final MraidOrientation forceOrientation) throws MraidCommandException {
+            handleSetOrientationProperties(allowOrientationChange, forceOrientation);
+        }
+
+        @Override
+        public void onOpen(final URI uri) {
+            handleOpen(uri.toString());
+        }
+
+        @Override
+        public void onPlayVideo(@NonNull final URI uri) {
+            handleShowVideo(uri.toString());
+        }
+    };
+
+    public void setMraidListener(@Nullable MraidListener mraidListener) {
+        mMraidListener = mraidListener;
+    }
+
+    public void setUseCustomCloseListener(@Nullable UseCustomCloseListener listener) {
+        mOnCloseButtonListener = listener;
+    }
+
+    public void setDebugListener(@Nullable MraidWebViewDebugListener debugListener) {
+        mDebugListener = debugListener;
+    }
+
+    public void loadContent(@NonNull String htmlData) {
+        Preconditions.checkState(mMraidWebView == null, "loadContent should only be called once");
+
+        mMraidWebView = new MraidWebView(mContext);
+        mMraidBridge.attachView(mMraidWebView);
+        mDefaultAdContainer.addView(mMraidWebView,
+                new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
+
+        // onPageLoaded gets fired once the html is loaded into the webView
+        mMraidBridge.setContentHtml(htmlData);
+    }
+
+    // onPageLoaded gets fired once the html is loaded into the webView.
+    private int getDisplayRotation() {
+        WindowManager wm = (WindowManager) mContext
+                .getSystemService(Context.WINDOW_SERVICE);
+        return wm.getDefaultDisplay().getRotation();
+    }
+
+    @VisibleForTesting
+    boolean handleConsoleMessage(@NonNull final ConsoleMessage consoleMessage) {
+        //noinspection SimplifiableIfStatement
+        if (mDebugListener != null) {
+            return mDebugListener.onConsoleMessage(consoleMessage);
+        }
+        return true;
+    }
+
+    @VisibleForTesting
+    boolean handleJsAlert(@NonNull final String message, @NonNull final JsResult result) {
+        if (mDebugListener != null) {
+            return mDebugListener.onJsAlert(message, result);
+        }
+        result.confirm();
+        return true;
+    }
+
+    @VisibleForTesting
+    static class ScreenMetricsWaiter {
+        static class WaitRequest {
+            @NonNull private final View[] mViews;
+            @NonNull private final Handler mHandler;
+            @Nullable private Runnable mSuccessRunnable;
+            int mWaitCount;
+
+            private WaitRequest(@NonNull Handler handler, @NonNull final View[] views) {
+                mHandler = handler;
+                mViews = views;
+            }
+
+            private void countDown() {
+                mWaitCount--;
+                if (mWaitCount == 0 && mSuccessRunnable != null) {
+                    mSuccessRunnable.run();
+                    mSuccessRunnable = null;
+                }
+            }
+
+            private final Runnable mWaitingRunnable = new Runnable() {
+                @Override
+                public void run() {
+                    for (final View view : mViews) {
+                        // Immediately count down for any views that already have a size
+                        if (view.getHeight() > 0 || view.getWidth() > 0) {
+                            countDown();
+                            continue;
+                        }
+
+                        // For views that didn't have a size, listen (once) for a preDraw. Note
+                        // that this doesn't leak because the ViewTreeObserver gets detached when
+                        // the view is no longer part of the view hierarchy.
+                        view.getViewTreeObserver().addOnPreDrawListener(new OnPreDrawListener() {
+                            @Override
+                            public boolean onPreDraw() {
+                                view.getViewTreeObserver().removeOnPreDrawListener(this);
+                                countDown();
+                                return true;
+                            }
+                        });
+                    }
+                }
+            };
+
+            void start(@NonNull Runnable successRunnable) {
+                mSuccessRunnable = successRunnable;
+                mWaitCount = mViews.length;
+                mHandler.post(mWaitingRunnable);
+            }
+
+            void cancel() {
+                mHandler.removeCallbacks(mWaitingRunnable);
+                mSuccessRunnable = null;
+            }
+        }
+
+        @NonNull private final Handler mHandler = new Handler();
+        @Nullable private WaitRequest mLastWaitRequest;
+
+        WaitRequest waitFor(@NonNull View... views) {
+            mLastWaitRequest = new WaitRequest(mHandler, views);
+            return mLastWaitRequest;
+        }
+
+        void cancelLastRequest() {
+            if (mLastWaitRequest != null) {
+                mLastWaitRequest.cancel();
+                mLastWaitRequest = null;
+            }
+        }
+    }
+
+    @Nullable
+    private View getCurrentWebView() {
+        return mTwoPartBridge.isAttached() ? mTwoPartWebView : mMraidWebView;
+    }
+
+    private boolean isInlineVideoAvailable() {
+        //noinspection SimplifiableIfStatement
+        final Activity activity = mWeakActivity.get();
+        if (activity == null || getCurrentWebView() == null) {
+            return false;
+        }
+
+        return mMraidNativeCommandHandler.isInlineVideoAvailable(activity, getCurrentWebView());
+    }
+
+    @VisibleForTesting
+    void handlePageLoad() {
+        setViewState(ViewState.DEFAULT, new Runnable() {
+            @Override
+            public void run() {
+                mMraidBridge.notifySupports(
+                        mMraidNativeCommandHandler.isSmsAvailable(mContext),
+                        mMraidNativeCommandHandler.isTelAvailable(mContext),
+                        MraidNativeCommandHandler.isCalendarAvailable(mContext),
+                        MraidNativeCommandHandler.isStorePictureSupported(mContext),
+                        isInlineVideoAvailable());
+                mMraidBridge.notifyPlacementType(mPlacementType);
+                mMraidBridge.notifyViewability(mMraidBridge.isVisible());
+                mMraidBridge.notifyReady();
+            }
+        });
+
+        // Call onLoaded immediately. This causes the container to get added to the view hierarchy
+        if (mMraidListener != null) {
+            mMraidListener.onLoaded(mDefaultAdContainer);
+        }
+    }
+
+    @VisibleForTesting
+    void handleTwoPartPageLoad() {
+        updateScreenMetricsAsync(new Runnable() {
+            @Override
+            public void run() {
+                mTwoPartBridge.notifySupports(
+                        mMraidNativeCommandHandler.isSmsAvailable(mContext),
+                        mMraidNativeCommandHandler.isTelAvailable(mContext),
+                        mMraidNativeCommandHandler.isCalendarAvailable(mContext),
+                        mMraidNativeCommandHandler.isStorePictureSupported(mContext),
+                        isInlineVideoAvailable());
+                mTwoPartBridge.notifyViewState(mViewState);
+                mTwoPartBridge.notifyPlacementType(mPlacementType);
+                mTwoPartBridge.notifyViewability(mTwoPartBridge.isVisible());
+                mTwoPartBridge.notifyReady();
+            }
+        });
+    }
+
+    /**
+     * Updates screen metrics, calling the successRunnable once they are available. The
+     * successRunnable will always be called asynchronously, ie on the next main thread loop.
+     */
+    private void updateScreenMetricsAsync(@Nullable final Runnable successRunnable) {
+        // Don't allow multiple metrics wait requests at once
+        mScreenMetricsWaiter.cancelLastRequest();
+
+        // Determine which web view should be used for the current ad position
+        final View currentWebView = getCurrentWebView();
+        if (currentWebView == null) {
+            return;
+        }
+
+        // Wait for the next draw pass on the default ad container and current web view
+        mScreenMetricsWaiter.waitFor(mDefaultAdContainer, currentWebView).start(
+                new Runnable() {
+                    @Override
+                    public void run() {
+                        DisplayMetrics displayMetrics = mContext.getResources().getDisplayMetrics();
+                        mScreenMetrics.setScreenSize(
+                                displayMetrics.widthPixels, displayMetrics.heightPixels);
+
+                        int[] location = new int[2];
+                        View rootView = getRootView();
+                        rootView.getLocationOnScreen(location);
+                        mScreenMetrics.setRootViewPosition(location[0], location[1],
+                                rootView.getWidth(),
+                                rootView.getHeight());
+
+                        mDefaultAdContainer.getLocationOnScreen(location);
+                        mScreenMetrics.setDefaultAdPosition(location[0], location[1],
+                                mDefaultAdContainer.getWidth(),
+                                mDefaultAdContainer.getHeight());
+
+                        currentWebView.getLocationOnScreen(location);
+                        mScreenMetrics.setCurrentAdPosition(location[0], location[1],
+                                currentWebView.getWidth(),
+                                currentWebView.getHeight());
+
+                        // Always notify both bridges of the new metrics
+                        mMraidBridge.notifyScreenMetrics(mScreenMetrics);
+                        if (mTwoPartBridge.isAttached()) {
+                            mTwoPartBridge.notifyScreenMetrics(mScreenMetrics);
+                        }
+
+                        if (successRunnable != null) {
+                            successRunnable.run();
+                        }
+                    }
+                });
+    }
+
+    void handleOrientationChange(int currentRotation) {
+        updateScreenMetricsAsync(null);
+    }
+
+    public void pause(boolean isFinishing) {
+        mIsPaused = true;
+
+        // This causes an inline video to pause if there is one playing
+        if (mMraidWebView != null) {
+            WebViews.onPause(mMraidWebView, isFinishing);
+        }
+        if (mTwoPartWebView != null) {
+            WebViews.onPause(mTwoPartWebView, isFinishing);
+        }
+    }
+
+    public void resume() {
+        mIsPaused = false;
+
+        // This causes an inline video to resume if it was playing previously
+        if (mMraidWebView != null) {
+            WebViews.onResume(mMraidWebView);
+        }
+        if (mTwoPartWebView != null) {
+            WebViews.onResume(mTwoPartWebView);
+        }
+    }
+
+    public void destroy() {
+        mScreenMetricsWaiter.cancelLastRequest();
+
+        try {
+            mOrientationBroadcastReceiver.unregister();
+        } catch (IllegalArgumentException e) {
+            if (!e.getMessage().contains("Receiver not registered")) {
+                throw e;
+            } // Else ignore this exception.
+        }
+
+        // Pause the controller to make sure the video gets stopped.
+        if (!mIsPaused) {
+            pause(true);
+        }
+
+        // Remove the closeable ad container from the view hierarchy, if necessary
+        Views.removeFromParent(mCloseableAdContainer);
+
+        // Calling destroy eliminates a memory leak on Gingerbread devices
+        mMraidBridge.detach();
+        if (mMraidWebView != null) {
+            mMraidWebView.destroy();
+            mMraidWebView = null;
+        }
+        mTwoPartBridge.detach();
+        if (mTwoPartWebView != null) {
+            mTwoPartWebView.destroy();
+            mTwoPartWebView = null;
+        }
+    }
+
+    private void setViewState(@NonNull ViewState viewState) {
+        setViewState(viewState, null);
+    }
+
+    private void setViewState(@NonNull ViewState viewState, @Nullable Runnable successRunnable) {
+        // Make sure this is a valid transition.
+        MoPubLog.d("MRAID state set to " + viewState);
+        mViewState = viewState;
+        mMraidBridge.notifyViewState(viewState);
+
+        // Changing state notifies the two part view, but only if it's loaded
+        if (mTwoPartBridge.isLoaded()) {
+            mTwoPartBridge.notifyViewState(viewState);
+        }
+
+        if (mMraidListener != null) {
+            if (viewState == ViewState.EXPANDED) {
+                mMraidListener.onExpand();
+            } else if (viewState == ViewState.HIDDEN) {
+                mMraidListener.onClose();
+            }
+        }
+
+        updateScreenMetricsAsync(successRunnable);
+    }
+
+    int clampInt(int min, int target, int max) {
+        return Math.max(min, Math.min(target, max));
+    }
+
+    @VisibleForTesting
+    void handleResize(final int widthDips, final int heightDips, final int offsetXDips,
+            final int offsetYDips, @NonNull final ClosePosition closePosition,
+            final boolean allowOffscreen)
+            throws MraidCommandException {
+        if (mMraidWebView == null) {
+            throw new MraidCommandException("Unable to resize after the WebView is destroyed");
+        }
+
+        // The spec says that there is no effect calling resize from loaded or hidden, but that
+        // calling it from expanded should raise an error.
+        if (mViewState == ViewState.LOADING
+                || mViewState == ViewState.HIDDEN) {
+            return;
+        } else if (mViewState == ViewState.EXPANDED) {
+            throw new MraidCommandException("Not allowed to resize from an already expanded ad");
+        }
+
+        if (mPlacementType == PlacementType.INTERSTITIAL) {
+            throw new MraidCommandException("Not allowed to resize from an interstitial ad");
+        }
+
+        // Translate coordinates to px and get the resize rect
+        int width = Dips.dipsToIntPixels(widthDips, mContext);
+        int height = Dips.dipsToIntPixels(heightDips, mContext);
+        int offsetX = Dips.dipsToIntPixels(offsetXDips, mContext);
+        int offsetY = Dips.dipsToIntPixels(offsetYDips, mContext);
+        int left = mScreenMetrics.getDefaultAdRect().left + offsetX;
+        int top = mScreenMetrics.getDefaultAdRect().top + offsetY;
+        Rect resizeRect = new Rect(left, top, left + width, top + height);
+
+        if (!allowOffscreen) {
+            // Require the entire ad to be on-screen.
+            Rect bounds = mScreenMetrics.getRootViewRect();
+            if (resizeRect.width() > bounds.width() || resizeRect.height() > bounds.height()) {
+                throw new MraidCommandException("resizeProperties specified a size ("
+                        + widthDips + ", " + heightDips + ") and offset ("
+                        + offsetXDips + ", " + offsetYDips + ") that doesn't allow the ad to"
+                        + " appear within the max allowed size ("
+                        + mScreenMetrics.getRootViewRectDips().width() + ", "
+                        + mScreenMetrics.getRootViewRectDips().height() + ")");
+            }
+
+            // Offset the resize rect so that it displays on the screen
+            int newLeft = clampInt(bounds.left, resizeRect.left, bounds.right - resizeRect.width());
+            int newTop = clampInt(bounds.top, resizeRect.top, bounds.bottom - resizeRect.height());
+            resizeRect.offsetTo(newLeft, newTop);
+        }
+
+        // The entire close region must always be visible.
+        Rect closeRect = new Rect();
+        mCloseableAdContainer.applyCloseRegionBounds(closePosition, resizeRect, closeRect);
+        if (!mScreenMetrics.getRootViewRect().contains(closeRect)) {
+            throw new MraidCommandException("resizeProperties specified a size ("
+                    + widthDips + ", " + heightDips + ") and offset ("
+                    + offsetXDips + ", " + offsetYDips + ") that doesn't allow the close"
+                    + " region to appear within the max allowed size ("
+                    + mScreenMetrics.getRootViewRectDips().width() + ", "
+                    + mScreenMetrics.getRootViewRectDips().height() + ")");
+        }
+
+        if (!resizeRect.contains(closeRect)) {
+            throw new MraidCommandException("resizeProperties specified a size ("
+                    + widthDips + ", " + height + ") and offset ("
+                    + offsetXDips + ", " + offsetYDips + ") that don't allow the close region to appear "
+                    + "within the resized ad.");
+        }
+
+        // Resized ads always rely on the creative's close button (as if useCustomClose were true)
+        mCloseableAdContainer.setCloseVisible(false);
+        mCloseableAdContainer.setClosePosition(closePosition);
+
+        // Put the ad in the closeable container and resize it
+        LayoutParams layoutParams = new LayoutParams(resizeRect.width(), resizeRect.height());
+        layoutParams.leftMargin = resizeRect.left - mScreenMetrics.getRootViewRect().left;
+        layoutParams.topMargin = resizeRect.top - mScreenMetrics.getRootViewRect().top;
+        if (mViewState == ViewState.DEFAULT) {
+            mDefaultAdContainer.removeView(mMraidWebView);
+            mDefaultAdContainer.setVisibility(View.INVISIBLE);
+            mCloseableAdContainer.addView(mMraidWebView,
+                    new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
+            getRootView().addView(mCloseableAdContainer, layoutParams);
+        } else if (mViewState == ViewState.RESIZED) {
+            mCloseableAdContainer.setLayoutParams(layoutParams);
+        }
+        mCloseableAdContainer.setClosePosition(closePosition);
+
+        setViewState(ViewState.RESIZED);
+    }
+
+    void handleExpand(@Nullable URI uri, boolean shouldUseCustomClose)
+            throws MraidCommandException {
+        if (mMraidWebView == null) {
+            throw new MraidCommandException("Unable to expand after the WebView is destroyed");
+        }
+
+        if (mPlacementType == PlacementType.INTERSTITIAL) {
+            return;
+        }
+
+        if (mViewState != ViewState.DEFAULT && mViewState != ViewState.RESIZED) {
+            return;
+        }
+
+        applyOrientation();
+
+        // For two part expands, create a new web view
+        boolean isTwoPart = (uri != null);
+        if (isTwoPart) {
+            // Of note: the two part ad will start off with its view state as LOADING, and will
+            // transition to EXPANDED once the page is fully loaded
+            mTwoPartWebView = new MraidWebView(mContext);
+            mTwoPartBridge.attachView(mTwoPartWebView);
+
+            // onPageLoaded gets fired once the html is loaded into the two part webView
+            mTwoPartBridge.setContentUrl(uri.toString());
+        }
+
+        // Make sure the correct webView is in the closeable  container and make it full screen
+        LayoutParams layoutParams = new LayoutParams(
+                LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
+        if (mViewState == ViewState.DEFAULT) {
+            if (isTwoPart) {
+                mCloseableAdContainer.addView(mTwoPartWebView, layoutParams);
+            } else {
+                mDefaultAdContainer.removeView(mMraidWebView);
+                mDefaultAdContainer.setVisibility(View.INVISIBLE);
+                mCloseableAdContainer.addView(mMraidWebView, layoutParams);
+            }
+            getRootView().addView(mCloseableAdContainer,
+                    new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
+        } else if (mViewState == ViewState.RESIZED) {
+            if (isTwoPart) {
+                // Move the ad back to the original container so that when we close the
+                // resized ad, it will be in the correct place
+                mCloseableAdContainer.removeView(mMraidWebView);
+                mDefaultAdContainer.addView(mMraidWebView, layoutParams);
+                mDefaultAdContainer.setVisibility(View.INVISIBLE);
+                mCloseableAdContainer.addView(mTwoPartWebView, layoutParams);
+            }
+            // If we were resized and not 2 part, nothing to do.
+        }
+        mCloseableAdContainer.setLayoutParams(layoutParams);
+        handleCustomClose(shouldUseCustomClose);
+
+        // Update to expanded once we have new screen metrics. This won't update the two-part ad,
+        // because it is not yet loaded.
+        setViewState(ViewState.EXPANDED);
+    }
+
+    @VisibleForTesting
+    void handleClose() {
+        if (mMraidWebView == null) {
+            // Doesn't throw an exception because the ad has been destroyed
+            return;
+        }
+
+        if (mViewState == ViewState.LOADING || mViewState == ViewState.HIDDEN) {
+            return;
+        }
+
+        // Unlock the orientation before changing the view hierarchy.
+        if (mViewState == ViewState.EXPANDED || mPlacementType == PlacementType.INTERSTITIAL) {
+            unApplyOrientation();
+        }
+
+        if (mViewState == ViewState.RESIZED || mViewState == ViewState.EXPANDED) {
+            if (mTwoPartBridge.isAttached() && mTwoPartWebView != null) {
+                // If we have a two part web view, simply remove it from the closeable container
+                mCloseableAdContainer.removeView(mTwoPartWebView);
+                mTwoPartBridge.detach();
+            } else {
+                // Move the web view from the closeable container back to the default container
+                mCloseableAdContainer.removeView(mMraidWebView);
+                mDefaultAdContainer.addView(mMraidWebView, new LayoutParams(
+                        LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
+                mDefaultAdContainer.setVisibility(View.VISIBLE);
+            }
+            getRootView().removeView(mCloseableAdContainer);
+
+            // Set the view state to default
+            setViewState(ViewState.DEFAULT);
+        } else if (mViewState == ViewState.DEFAULT) {
+            mDefaultAdContainer.setVisibility(View.INVISIBLE);
+            setViewState(ViewState.HIDDEN);
+        }
+    }
+
+    @NonNull
+    @TargetApi(VERSION_CODES.KITKAT)
+    private ViewGroup getRootView() {
+        if (mRootView == null) {
+            // This method should never be called this method before the container is ready, ie before
+            // handlePageLoad.
+            if (VERSION.SDK_INT >= VERSION_CODES.KITKAT) {
+                Preconditions.checkState(mDefaultAdContainer.isAttachedToWindow());
+            }
+
+            mRootView = (ViewGroup) mDefaultAdContainer.getRootView().findViewById(
+                    android.R.id.content);
+        }
+
+        return mRootView;
+    }
+
+    @VisibleForTesting
+    void handleShowVideo(@NonNull String videoUrl) {
+        MraidVideoPlayerActivity.startMraid(mContext, videoUrl);
+    }
+
+    @VisibleForTesting
+    void lockOrientation(final int screenOrientation) throws MraidCommandException {
+        final Activity activity = mWeakActivity.get();
+        if (activity == null || !shouldAllowForceOrientation(mForceOrientation)) {
+            throw new MraidCommandException("Attempted to lock orientation to unsupported value: " +
+                    mForceOrientation.name());
+        }
+
+        if (mOriginalActivityOrientation == null) {
+            mOriginalActivityOrientation = activity.getRequestedOrientation();
+        }
+
+        activity.setRequestedOrientation(screenOrientation);
+    }
+
+    @VisibleForTesting
+    void applyOrientation() throws MraidCommandException {
+        if (mForceOrientation == MraidOrientation.NONE) {
+            if (mAllowOrientationChange) {
+                // If screen orientation can be changed, an orientation of NONE means that any
+                // orientation lock should be removed
+                unApplyOrientation();
+            } else {
+                final Activity activity = mWeakActivity.get();
+                if (activity == null) {
+                    throw new MraidCommandException("Unable to set MRAID expand orientation to " +
+                            "'none'; expected passed in Activity Context.");
+                }
+
+                // If screen orientation cannot be changed and we can obtain the current
+                // screen orientation, locking it to the current orientation is a best effort
+                lockOrientation(DeviceUtils.getScreenOrientation(activity));
+            }
+        } else {
+            // Otherwise, we have a valid, non-NONE orientation. Lock the screen based on this value
+            lockOrientation(mForceOrientation.getActivityInfoOrientation());
+        }
+    }
+
+    @VisibleForTesting
+    void unApplyOrientation() {
+        final Activity activity = mWeakActivity.get();
+        if (activity != null && mOriginalActivityOrientation != null) {
+            activity.setRequestedOrientation(mOriginalActivityOrientation);
+        }
+        mOriginalActivityOrientation = null;
+    }
+
+    @TargetApi(VERSION_CODES.HONEYCOMB_MR2)
+    @VisibleForTesting
+    boolean shouldAllowForceOrientation(final MraidOrientation newOrientation) {
+        // NONE is the default and always allowed
+        if (newOrientation == MraidOrientation.NONE) {
+            return true;
+        }
+
+        final Activity activity = mWeakActivity.get();
+        // If we can't obtain an Activity, return false
+        if (activity == null) {
+            return false;
+        }
+
+        final ActivityInfo activityInfo;
+        try {
+            activityInfo = activity.getPackageManager().getActivityInfo(
+                    new ComponentName(activity, activity.getClass()), 0);
+        } catch (PackageManager.NameNotFoundException e) {
+            return false;
+        }
+
+        // If an orientation is explicitly declared in the manifest, allow forcing this orientation
+        final int activityOrientation = activityInfo.screenOrientation;
+        if (activityOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
+            return activityOrientation == newOrientation.getActivityInfoOrientation();
+        }
+
+        // Make sure the config changes won't tear down the activity when moving to this orientation
+        // The necessary configChanges must always include "orientation"
+        boolean containsNecessaryConfigChanges =
+                bitMaskContainsFlag(activityInfo.configChanges, CONFIG_ORIENTATION);
+
+        // And on API 13+, configChanges must also include "screenSize"
+        if (VERSION.SDK_INT >= VERSION_CODES.HONEYCOMB_MR2) {
+            containsNecessaryConfigChanges = containsNecessaryConfigChanges
+                    && bitMaskContainsFlag(activityInfo.configChanges, CONFIG_SCREEN_SIZE);
+        }
+
+        return containsNecessaryConfigChanges;
+    }
+
+    @VisibleForTesting
+    void handleCustomClose(boolean useCustomClose) {
+        boolean wasUsingCustomClose = !mCloseableAdContainer.isCloseVisible();
+        if (useCustomClose == wasUsingCustomClose) {
+            return;
+        }
+
+        mCloseableAdContainer.setCloseVisible(!useCustomClose);
+        if (mOnCloseButtonListener != null) {
+            mOnCloseButtonListener.useCustomCloseChanged(useCustomClose);
+        }
+    }
+
+    @NonNull
+    public FrameLayout getAdContainer() {
+        return mDefaultAdContainer;
+    }
+
+    /**
+     * Loads a javascript URL. Useful for running callbacks, such as javascript:webviewDidClose()
+     */
+    public void loadJavascript(@NonNull String javascript) {
+        mMraidBridge.injectJavaScript(javascript);
+    }
+
+    @VisibleForTesting
+    class OrientationBroadcastReceiver extends BroadcastReceiver {
+        @Nullable private Context mContext;
+
+        // -1 until this gets set at least once
+        private int mLastRotation = -1;
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (mContext == null) {
+                return;
+            }
+
+            if (Intent.ACTION_CONFIGURATION_CHANGED.equals(intent.getAction())) {
+                int orientation = getDisplayRotation();
+
+                if (orientation != mLastRotation) {
+                    mLastRotation = orientation;
+                    handleOrientationChange(mLastRotation);
+                }
+            }
+        }
+
+        public void register(@NonNull final Context context) {
+            Preconditions.checkNotNull(context);
+            mContext = context.getApplicationContext();
+            if (mContext != null) {
+                mContext.registerReceiver(this,
+                        new IntentFilter(Intent.ACTION_CONFIGURATION_CHANGED));
+            }
+        }
+
+        public void unregister() {
+            if (mContext != null) {
+                mContext.unregisterReceiver(this);
+                mContext = null;
+            }
+        }
+    }
+
+    @NonNull
+    public Context getContext() {
+        return mContext;
+    }
+
+    @VisibleForTesting
+    void handleSetOrientationProperties(final boolean allowOrientationChange,
+            final MraidOrientation forceOrientation) throws MraidCommandException {
+        if (!shouldAllowForceOrientation(forceOrientation)) {
+            throw new MraidCommandException(
+                    "Unable to force orientation to " + forceOrientation);
+        }
+
+        mAllowOrientationChange = allowOrientationChange;
+        mForceOrientation = forceOrientation;
+
+        if (mViewState == ViewState.EXPANDED || mPlacementType == PlacementType.INTERSTITIAL) {
+            applyOrientation();
+        }
+    }
+
+    /**
+     * Attempts to handle mopubnativebrowser links in the device browser, deep-links in the
+     * corresponding application, and all other links in the MoPub in-app browser.
+     */
+    @VisibleForTesting
+    void handleOpen(@NonNull final String url) {
+        if (mMraidListener != null) {
+            mMraidListener.onOpen();
+        }
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(
+                        UrlAction.IGNORE_ABOUT_SCHEME,
+                        UrlAction.OPEN_NATIVE_BROWSER,
+                        UrlAction.OPEN_IN_APP_BROWSER,
+                        UrlAction.HANDLE_SHARE_TWEET,
+                        UrlAction.FOLLOW_DEEP_LINK)
+                .build().handleUrl(mContext, url);
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    @NonNull
+    ViewState getViewState() {
+        return mViewState;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    void setViewStateForTesting(@NonNull ViewState viewState) {
+        mViewState = viewState;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    @NonNull
+    CloseableLayout getExpandedAdContainer() {
+        return mCloseableAdContainer;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    void setRootView(FrameLayout rootView) {
+        mRootView = rootView;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    void setRootViewSize(int width, int height) {
+        mScreenMetrics.setRootViewPosition(0, 0, width, height);
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    Integer getOriginalActivityOrientation() {
+        return mOriginalActivityOrientation;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    boolean getAllowOrientationChange() {
+        return mAllowOrientationChange;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    MraidOrientation getForceOrientation() {
+        return mForceOrientation;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    void setOrientationBroadcastReceiver(OrientationBroadcastReceiver receiver) {
+        mOrientationBroadcastReceiver = receiver;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    MraidWebView getMraidWebView() {
+        return mMraidWebView;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    MraidWebView getTwoPartWebView() {
+        return mTwoPartWebView;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ClickDestinationResolutionListener.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ClickDestinationResolutionListener.java
index 4d3345f9..8c5961c1 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/ClickDestinationResolutionListener.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/ClickDestinationResolutionListener.java
@@ -1,112 +1,74 @@
-package com.mopub.nativeads;
-
-import android.content.Context;
-import android.content.Intent;
-import android.net.Uri;
-import android.support.annotation.NonNull;
-
-import com.mopub.common.MoPubBrowser;
-import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.Intents;
-import com.mopub.exceptions.IntentNotResolvableException;
-import com.mopub.exceptions.UrlParseException;
-
-import java.lang.ref.WeakReference;
-import java.util.Iterator;
-
-class ClickDestinationResolutionListener implements UrlResolutionTask.UrlResolutionListener {
-    private final Context mContext;
-    private final Iterator<String> mUrlIterator;
-    private final WeakReference<SpinningProgressView> mSpinningProgressView;
-
-    public ClickDestinationResolutionListener(@NonNull final Context context,
-            @NonNull final Iterator<String> urlIterator,
-            @NonNull final SpinningProgressView spinningProgressView) {
-        mContext = context.getApplicationContext();
-        mUrlIterator = urlIterator;
-        mSpinningProgressView = new WeakReference<SpinningProgressView>(spinningProgressView);
-    }
-
-    /**
-     * Called upon user click, after the corresponding UrlResolutionTask has followed all redirects
-     * successfully. Attempts to open mopubnativebrowser links in the device browser, deep-links in
-     * the corresponding application, and all other links in the MoPub in-app browser. In the first
-     * two cases, malformed URLs will try to fallback to the next entry in mUrlIterator, and failing
-     * that, will no-op.
-     */
-    @Override
-    public void onSuccess(@NonNull final String resolvedUrl) {
-
-        if (Intents.isAboutScheme(resolvedUrl)) {
-            MoPubLog.d("Link to about page ignored.");
-            removeSpinningProgressView();
-            return;
-        }
-
-        // Handle MoPubNativeBrowser schemes
-        if (Intents.isNativeBrowserScheme(resolvedUrl)) {
-            try {
-                final Intent intent = Intents.intentForNativeBrowserScheme(resolvedUrl);
-                Intents.startActivity(mContext, intent);
-                removeSpinningProgressView();
-                return;
-            } catch (UrlParseException e) {
-                MoPubLog.d(e.getMessage());
-            } catch (IntentNotResolvableException e) {
-                MoPubLog.d("Could not handle intent for URI: " + resolvedUrl);
-            }
-
-            if (mUrlIterator.hasNext()) {
-                UrlResolutionTask.getResolvedUrl(mUrlIterator.next(), this);
-            } else {
-                removeSpinningProgressView();
-            }
-            return;
-        }
-
-        // Handle Android deeplinks
-        if (Intents.isDeepLink(resolvedUrl)) {
-            final Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(resolvedUrl));
-
-            // Open another Android app from the deep link
-            if (Intents.deviceCanHandleIntent(mContext, intent)) {
-                try {
-                    Intents.startActivity(mContext, intent);
-                    return;
-                } catch (IntentNotResolvableException e) {
-                    MoPubLog.d("Could not handle intent with URI: " + resolvedUrl);
-                } finally {
-                    removeSpinningProgressView();
-                }
-            }
-
-            if (mUrlIterator.hasNext()) {
-                UrlResolutionTask.getResolvedUrl(mUrlIterator.next(), this);
-            } else {
-                removeSpinningProgressView();
-            }
-            return;
-        }
-
-        removeSpinningProgressView();
-        if (Intents.isHttpUrl(resolvedUrl)) {
-            MoPubBrowser.open(mContext, resolvedUrl);
-            return;
-        }
-
-        MoPubLog.d("Link ignored. Unable to handle url: " + resolvedUrl);
-    }
-
-    @Override
-    public void onFailure() {
-        MoPubLog.d("Failed to resolve URL for click.");
-        removeSpinningProgressView();
-    }
-
-    private void removeSpinningProgressView() {
-        final SpinningProgressView spinningProgressView = mSpinningProgressView.get();
-        if (spinningProgressView != null) {
-            spinningProgressView.removeFromRoot();
-        }
-    }
-}
+package com.mopub.nativeads;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.UrlHandler;
+import com.mopub.common.UrlAction;
+import com.mopub.common.logging.MoPubLog;
+
+import java.lang.ref.WeakReference;
+import java.util.Iterator;
+
+class ClickDestinationResolutionListener implements UrlResolutionTask.UrlResolutionListener {
+    private final Context mContext;
+    private final Iterator<String> mUrlIterator;
+    private final WeakReference<SpinningProgressView> mSpinningProgressView;
+
+    public ClickDestinationResolutionListener(@NonNull final Context context,
+            @NonNull final Iterator<String> urlIterator,
+            @NonNull final SpinningProgressView spinningProgressView) {
+        mContext = context.getApplicationContext();
+        mUrlIterator = urlIterator;
+        mSpinningProgressView = new WeakReference<SpinningProgressView>(spinningProgressView);
+    }
+
+    /**
+     * Called upon user click, after the corresponding UrlResolutionTask has followed all redirects
+     * successfully. Attempts to open mopubnativebrowser links in the device browser, deep-links in
+     * the corresponding application, and all other links in the MoPub in-app browser. In the first
+     * two cases, malformed URLs will try to fallback to the next entry in mUrlIterator, and failing
+     * that, will no-op.
+     */
+    @Override
+    public void onSuccess(@NonNull final String resolvedUrl) {
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(
+                        UrlAction.IGNORE_ABOUT_SCHEME,
+                        UrlAction.OPEN_NATIVE_BROWSER,
+                        UrlAction.OPEN_APP_MARKET,
+                        UrlAction.OPEN_IN_APP_BROWSER,
+                        UrlAction.HANDLE_SHARE_TWEET,
+                        UrlAction.FOLLOW_DEEP_LINK)
+                .withResultActions(new UrlHandler.ResultActions() {
+                    @Override
+                    public void urlHandlingSucceeded(@NonNull String url,
+                            @NonNull UrlAction urlAction) {
+                    }
+
+                    @Override
+                    public void urlHandlingFailed(@NonNull String url,
+                            @NonNull UrlAction lastFailedUrlAction) {
+                        if (mUrlIterator.hasNext()) {
+                            UrlResolutionTask.getResolvedUrl(mUrlIterator.next(),
+                                    ClickDestinationResolutionListener.this);
+                        }
+                    }
+                })
+                .build().handleUrl(mContext, resolvedUrl);
+        removeSpinningProgressView();
+    }
+
+    @Override
+    public void onFailure() {
+        MoPubLog.d("Failed to resolve URL for click.");
+        removeSpinningProgressView();
+    }
+
+    private void removeSpinningProgressView() {
+        final SpinningProgressView spinningProgressView = mSpinningProgressView.get();
+        if (spinningProgressView != null) {
+            spinningProgressView.removeFromRoot();
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/UrlResolutionTask.java b/mopub-sdk/src/main/java/com/mopub/nativeads/UrlResolutionTask.java
index b6720cc0..369653a8 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/UrlResolutionTask.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/UrlResolutionTask.java
@@ -1,115 +1,116 @@
-package com.mopub.nativeads;
-
-import android.os.AsyncTask;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-
-import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.AsyncTasks;
-import com.mopub.common.util.Intents;
-
-import java.io.IOException;
-import java.net.HttpURLConnection;
-import java.net.URL;
-
-class UrlResolutionTask extends AsyncTask<String, Void, String> {
-    private static final int REDIRECT_LIMIT = 10;
-
-    interface UrlResolutionListener {
-        void onSuccess(@NonNull String resolvedUrl);
-        void onFailure();
-    }
-
-    @NonNull private final UrlResolutionListener mListener;
-
-    public static void getResolvedUrl(@NonNull final String urlString,
-            @NonNull final UrlResolutionListener listener) {
-        final UrlResolutionTask urlResolutionTask = new UrlResolutionTask(listener);
-
-        try {
-            AsyncTasks.safeExecuteOnExecutor(urlResolutionTask, urlString);
-        } catch (Exception e) {
-            MoPubLog.d("Failed to resolve url", e);
-
-            listener.onFailure();
-        }
-    }
-
-    UrlResolutionTask(@NonNull UrlResolutionListener listener) {
-        mListener = listener;
-    }
-
-    @Nullable
-    @Override
-    protected String doInBackground(@Nullable String... urls) {
-        if (urls == null || urls.length == 0) {
-            return null;
-        }
-
-        String previousUrl = null;
-        try {
-            String locationUrl = urls[0];
-
-            int redirectCount = 0;
-            while (locationUrl != null && redirectCount < REDIRECT_LIMIT) {
-                // if location url is not http(s), assume it's an Android deep link
-                // this scheme will fail URL validation so we have to check early
-                if (!Intents.isHttpUrl(locationUrl)) {
-                    return locationUrl;
-                }
-
-                previousUrl = locationUrl;
-                locationUrl = getRedirectLocation(locationUrl);
-                redirectCount++;
-            }
-
-        } catch (IOException e) {
-            return null;
-        }
-
-        return previousUrl;
-    }
-
-    @Nullable
-    private String getRedirectLocation(@NonNull final String urlString) throws IOException {
-        final URL url = new URL(urlString);
-
-        HttpURLConnection httpUrlConnection = null;
-        try {
-            httpUrlConnection = (HttpURLConnection) url.openConnection();
-            httpUrlConnection.setInstanceFollowRedirects(false);
-
-            int responseCode = httpUrlConnection.getResponseCode();
-
-            if (responseCode >= 300 && responseCode < 400) {
-                return httpUrlConnection.getHeaderField("Location");
-            } else {
-                return null;
-            }
-        } finally {
-            if (httpUrlConnection != null) {
-                httpUrlConnection.disconnect();
-            }
-        }
-    }
-
-    @Override
-    protected void onPostExecute(@Nullable final String resolvedUrl) {
-        super.onPostExecute(resolvedUrl);
-
-        if (isCancelled() || resolvedUrl == null) {
-            onCancelled();
-        } else {
-            mListener.onSuccess(resolvedUrl);
-        }
-    }
-
-    @Override
-    protected void onCancelled() {
-        super.onCancelled();
-
-        mListener.onFailure();
-    }
-}
-
-
+package com.mopub.nativeads;
+
+import android.net.Uri;
+import android.os.AsyncTask;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.UrlAction;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.AsyncTasks;
+
+import java.io.IOException;
+import java.net.HttpURLConnection;
+import java.net.URL;
+
+class UrlResolutionTask extends AsyncTask<String, Void, String> {
+    private static final int REDIRECT_LIMIT = 10;
+
+    interface UrlResolutionListener {
+        void onSuccess(@NonNull String resolvedUrl);
+        void onFailure();
+    }
+
+    @NonNull private final UrlResolutionListener mListener;
+
+    public static void getResolvedUrl(@NonNull final String urlString,
+            @NonNull final UrlResolutionListener listener) {
+        final UrlResolutionTask urlResolutionTask = new UrlResolutionTask(listener);
+
+        try {
+            AsyncTasks.safeExecuteOnExecutor(urlResolutionTask, urlString);
+        } catch (Exception e) {
+            MoPubLog.d("Failed to resolve url", e);
+
+            listener.onFailure();
+        }
+    }
+
+    UrlResolutionTask(@NonNull UrlResolutionListener listener) {
+        mListener = listener;
+    }
+
+    @Nullable
+    @Override
+    protected String doInBackground(@Nullable String... urls) {
+        if (urls == null || urls.length == 0) {
+            return null;
+        }
+
+        String previousUrl = null;
+        try {
+            String locationUrl = urls[0];
+
+            int redirectCount = 0;
+            while (locationUrl != null && redirectCount < REDIRECT_LIMIT) {
+                // if location url is not http(s), assume it's an Android deep link
+                // this scheme will fail URL validation so we have to check early
+                if (!UrlAction.OPEN_IN_APP_BROWSER.shouldTryHandlingUrl(Uri.parse(locationUrl))) {
+                    return locationUrl;
+                }
+
+                previousUrl = locationUrl;
+                locationUrl = getRedirectLocation(locationUrl);
+                redirectCount++;
+            }
+
+        } catch (IOException e) {
+            return null;
+        }
+
+        return previousUrl;
+    }
+
+    @Nullable
+    private String getRedirectLocation(@NonNull final String urlString) throws IOException {
+        final URL url = new URL(urlString);
+
+        HttpURLConnection httpUrlConnection = null;
+        try {
+            httpUrlConnection = (HttpURLConnection) url.openConnection();
+            httpUrlConnection.setInstanceFollowRedirects(false);
+
+            int responseCode = httpUrlConnection.getResponseCode();
+
+            if (responseCode >= 300 && responseCode < 400) {
+                return httpUrlConnection.getHeaderField("Location");
+            } else {
+                return null;
+            }
+        } finally {
+            if (httpUrlConnection != null) {
+                httpUrlConnection.disconnect();
+            }
+        }
+    }
+
+    @Override
+    protected void onPostExecute(@Nullable final String resolvedUrl) {
+        super.onPostExecute(resolvedUrl);
+
+        if (isCancelled() || resolvedUrl == null) {
+            onCancelled();
+        } else {
+            mListener.onSuccess(resolvedUrl);
+        }
+    }
+
+    @Override
+    protected void onCancelled() {
+        super.onCancelled();
+
+        mListener.onFailure();
+    }
+}
+
+
diff --git a/mopub-sdk/src/test/java/com/mopub/common/CacheServiceTest.java b/mopub-sdk/src/test/java/com/mopub/common/CacheServiceTest.java
index 5b652dcc..16b35e0e 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/CacheServiceTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/CacheServiceTest.java
@@ -1,157 +1,158 @@
-package com.mopub.common;
-
-import android.app.Activity;
-
-import com.mopub.common.test.support.SdkTestRunner;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.InputStream;
-import java.util.concurrent.Semaphore;
-
-import static com.mopub.common.CacheService.DiskLruCacheGetListener;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
-
-@RunWith(SdkTestRunner.class)
-public class CacheServiceTest {
-
-    private Activity context;
-    private String key1;
-    private String data1;
-    private String getKey;
-    private byte[] getBytes;
-    private DiskLruCacheGetListener diskCacheGetListener;
-    private Semaphore semaphore;
-
-    @Before
-    public void setUp() throws Exception {
-        context = new Activity();
-        key1 = "http://www.mopub.com/";
-        data1 = "image_data_1";
-
-        semaphore = new Semaphore(0);
-        diskCacheGetListener = mock(DiskLruCacheGetListener.class);
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                Object[] args = invocationOnMock.getArguments();
-                CacheServiceTest.this.getKey = (String)args[0];
-                CacheServiceTest.this.getBytes = (byte[])args[1];
-                semaphore.release();
-                return null;
-            }
-        }).when(diskCacheGetListener).onComplete(anyString(), any(byte[].class));
-    }
-
-    @Test
-    public void initializeCache_withValidContext_shouldCreateNewCachesIdempotently() throws Exception {
-        assertThat(CacheService.getDiskLruCache()).isNull();
-
-        CacheService.initialize(context);
-        DiskLruCache diskLruCache = CacheService.getDiskLruCache();
-        assertThat(diskLruCache).isNotNull();
-
-        CacheService.initialize(context);
-        assertThat(diskLruCache).isEqualTo(CacheService.getDiskLruCache());
-    }
-    
-    @Test
-    public void getDiskLruCacheDirectory_shouldReturnValidCacheDirectory() throws Exception {
-        File file = CacheService.getDiskCacheDirectory(context);
-        String expectedPath = context.getCacheDir().toString() + "/mopub-cache";
-        assertThat(file.getAbsolutePath()).isEqualTo(expectedPath);
-    }
-
-    @Test
-    public void diskLruCacheGet_whenPopulated_shouldReturnValue() throws Exception {
-        CacheService.initialize(context);
-        CacheService.putToDiskCache(key1, data1.getBytes());
-        assertThat(CacheService.getFromDiskCache(key1)).isEqualTo(data1.getBytes());
-    }
-
-    @Test
-    public void diskLruCacheGet_whenEmpty_shouldReturnNull() throws Exception {
-        CacheService.initialize(context);
-        assertCachesAreEmpty();
-        assertThat(CacheService.getFromDiskCache(key1)).isNull();
-    }
-
-    @Test
-    public void diskLruCacheAsyncGet_whenPopulated_shouldReturnValue() throws Exception {
-        CacheService.initialize(context);
-        assertCachesAreEmpty();
-        CacheService.putToDiskCache(key1, data1.getBytes());
-        CacheService.getFromDiskCacheAsync(key1, diskCacheGetListener);
-        semaphore.acquire();
-        assertThat(getKey).isEqualTo(key1);
-        assertThat(getBytes).isEqualTo(data1.getBytes());
-    }
-
-    @Test
-    public void diskLruCacheAsyncGet_whenEmpty_shouldReturnNull() throws Exception {
-        CacheService.initialize(context);
-        CacheService.getFromDiskCacheAsync(key1, diskCacheGetListener);
-        semaphore.acquire();
-        assertThat(getKey).isEqualTo(key1);
-        assertThat(getBytes).isNull();
-    }
-
-    @Test
-    public void diskLruCachePut_withEmptyStringKey_shouldPutCorrectly() throws Exception {
-        // this works because an empty string sha1 hashes to a valid key
-        CacheService.initialize(context);
-        CacheService.putToDiskCache("", data1.getBytes());
-        assertThat(CacheService.getFromDiskCache("")).isEqualTo(data1.getBytes());
-    }
-
-    @Test
-    public void diskLruCachePut_withNullKey_shouldNotPut() throws Exception {
-        // null value produces empty string key which is invalid for disk lru cache
-        CacheService.initialize(context);
-        assertCachesAreEmpty();
-        CacheService.putToDiskCache(null, data1.getBytes());
-        assertCachesAreEmpty();
-    }
-
-    @Test
-    public void createValidDiskLruCacheKey_withNullValue_shouldReturnEmptyString() throws Exception {
-        CacheService.initialize(context);
-        assertThat(CacheService.createValidDiskCacheKey(null)).isEqualTo("");
-    }
-
-    @Test
-    public void diskLruCacheAsyncPut_whenEmpty_shouldReturnNull() throws Exception {
-        CacheService.initialize(context);
-        CacheService.putToDiskCacheAsync(key1, data1.getBytes());
-        Thread.sleep(500);
-        assertThat(CacheService.getFromDiskCache(key1)).isEqualTo(data1.getBytes());
-    }
-
-    private static InputStream getInputStreamFromString(final String string) {
-        return spy(new ByteArrayInputStream(string.getBytes()));
-    }
-
-    public static void assertDiskCacheIsUninitialized() {
-        assertThat(CacheService.getDiskLruCache()).isNull();
-    }
-
-    public static void assertDiskCacheIsEmpty() {
-        assertThat(CacheService.getDiskLruCache()).isNotNull();
-        assertThat(CacheService.getDiskLruCache().size()).isEqualTo(0);
-    }
-
-    public static void assertCachesAreEmpty() {
-        assertDiskCacheIsEmpty();
-    }
-}
+package com.mopub.common;
+
+import android.app.Activity;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
+
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.InputStream;
+import java.util.concurrent.Semaphore;
+
+import static com.mopub.common.CacheService.DiskLruCacheGetListener;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+
+@RunWith(SdkTestRunner.class)
+public class CacheServiceTest {
+
+    private Activity context;
+    private String key1;
+    private String data1;
+    private String getKey;
+    private byte[] getBytes;
+    private DiskLruCacheGetListener diskCacheGetListener;
+    private Semaphore semaphore;
+
+    @Before
+    public void setUp() throws Exception {
+        context = Robolectric.buildActivity(Activity.class).create().get();
+        key1 = "http://www.mopub.com/";
+        data1 = "image_data_1";
+
+        semaphore = new Semaphore(0);
+        diskCacheGetListener = mock(DiskLruCacheGetListener.class);
+        doAnswer(new Answer() {
+            @Override
+            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+                Object[] args = invocationOnMock.getArguments();
+                CacheServiceTest.this.getKey = (String)args[0];
+                CacheServiceTest.this.getBytes = (byte[])args[1];
+                semaphore.release();
+                return null;
+            }
+        }).when(diskCacheGetListener).onComplete(anyString(), any(byte[].class));
+    }
+
+    @Test
+    public void initializeCache_withValidContext_shouldCreateNewCachesIdempotently() throws Exception {
+        assertThat(CacheService.getDiskLruCache()).isNull();
+
+        CacheService.initialize(context);
+        DiskLruCache diskLruCache = CacheService.getDiskLruCache();
+        assertThat(diskLruCache).isNotNull();
+
+        CacheService.initialize(context);
+        assertThat(diskLruCache).isEqualTo(CacheService.getDiskLruCache());
+    }
+    
+    @Test
+    public void getDiskLruCacheDirectory_shouldReturnValidCacheDirectory() throws Exception {
+        File file = CacheService.getDiskCacheDirectory(context);
+        String expectedPath = context.getCacheDir().toString() + "/mopub-cache";
+        assertThat(file.getAbsolutePath()).isEqualTo(expectedPath);
+    }
+
+    @Test
+    public void diskLruCacheGet_whenPopulated_shouldReturnValue() throws Exception {
+        CacheService.initialize(context);
+        CacheService.putToDiskCache(key1, data1.getBytes());
+        assertThat(CacheService.getFromDiskCache(key1)).isEqualTo(data1.getBytes());
+    }
+
+    @Test
+    public void diskLruCacheGet_whenEmpty_shouldReturnNull() throws Exception {
+        CacheService.initialize(context);
+        assertCachesAreEmpty();
+        assertThat(CacheService.getFromDiskCache(key1)).isNull();
+    }
+
+    @Test
+    public void diskLruCacheAsyncGet_whenPopulated_shouldReturnValue() throws Exception {
+        CacheService.initialize(context);
+        assertCachesAreEmpty();
+        CacheService.putToDiskCache(key1, data1.getBytes());
+        CacheService.getFromDiskCacheAsync(key1, diskCacheGetListener);
+        semaphore.acquire();
+        assertThat(getKey).isEqualTo(key1);
+        assertThat(getBytes).isEqualTo(data1.getBytes());
+    }
+
+    @Test
+    public void diskLruCacheAsyncGet_whenEmpty_shouldReturnNull() throws Exception {
+        CacheService.initialize(context);
+        CacheService.getFromDiskCacheAsync(key1, diskCacheGetListener);
+        semaphore.acquire();
+        assertThat(getKey).isEqualTo(key1);
+        assertThat(getBytes).isNull();
+    }
+
+    @Test
+    public void diskLruCachePut_withEmptyStringKey_shouldPutCorrectly() throws Exception {
+        // this works because an empty string sha1 hashes to a valid key
+        CacheService.initialize(context);
+        CacheService.putToDiskCache("", data1.getBytes());
+        assertThat(CacheService.getFromDiskCache("")).isEqualTo(data1.getBytes());
+    }
+
+    @Test
+    public void diskLruCachePut_withNullKey_shouldNotPut() throws Exception {
+        // null value produces empty string key which is invalid for disk lru cache
+        CacheService.initialize(context);
+        assertCachesAreEmpty();
+        CacheService.putToDiskCache(null, data1.getBytes());
+        assertCachesAreEmpty();
+    }
+
+    @Test
+    public void createValidDiskLruCacheKey_withNullValue_shouldReturnEmptyString() throws Exception {
+        CacheService.initialize(context);
+        assertThat(CacheService.createValidDiskCacheKey(null)).isEqualTo("");
+    }
+
+    @Test
+    public void diskLruCacheAsyncPut_whenEmpty_shouldReturnNull() throws Exception {
+        CacheService.initialize(context);
+        CacheService.putToDiskCacheAsync(key1, data1.getBytes());
+        Thread.sleep(500);
+        assertThat(CacheService.getFromDiskCache(key1)).isEqualTo(data1.getBytes());
+    }
+
+    private static InputStream getInputStreamFromString(final String string) {
+        return spy(new ByteArrayInputStream(string.getBytes()));
+    }
+
+    public static void assertDiskCacheIsUninitialized() {
+        assertThat(CacheService.getDiskLruCache()).isNull();
+    }
+
+    public static void assertDiskCacheIsEmpty() {
+        assertThat(CacheService.getDiskLruCache()).isNotNull();
+        assertThat(CacheService.getDiskLruCache().size()).isEqualTo(0);
+    }
+
+    public static void assertCachesAreEmpty() {
+        assertDiskCacheIsEmpty();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/GpsHelperTest.java b/mopub-sdk/src/test/java/com/mopub/common/GpsHelperTest.java
index 83cfd145..25ce4ba3 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/GpsHelperTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/GpsHelperTest.java
@@ -1,312 +1,312 @@
-package com.mopub.common;
-
-import android.app.Activity;
-import android.content.Context;
-import android.os.Looper;
-
-import com.mopub.common.factories.MethodBuilderFactory;
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.test.support.TestMethodBuilderFactory;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-
-import java.util.concurrent.Semaphore;
-
-import static com.mopub.common.util.Reflection.MethodBuilder;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-@RunWith(SdkTestRunner.class)
-public class GpsHelperTest {
-    private MethodBuilder methodBuilder;
-    private Activity context;
-    private TestAdInfo adInfo;
-    private Semaphore semaphore;
-    private GpsHelper.GpsHelperListener semaphoreGpsHelperListener;
-    private Looper gpsHelperListenerCallbackLooper;
-
-    // This class emulates the AdInfo class returned from the Google Play Services
-    // AdvertisingIdClient.getAdvertisingIdInfo method; need to implement getters for reflection calls
-    public static final class TestAdInfo {
-        public static final String ADVERTISING_ID = "38400000-8cf0-11bd-b23e-10b96e40000d";
-        public static final boolean LIMIT_AD_TRACKING_ENABLED = true;
-
-        public String mAdId = ADVERTISING_ID;
-        public boolean mLimitAdTrackingEnabled = LIMIT_AD_TRACKING_ENABLED;
-
-        public String getId() {
-            return mAdId;
-        }
-
-        public boolean isLimitAdTrackingEnabled() {
-            return mLimitAdTrackingEnabled;
-        }
-    }
-
-    @Before
-    public void setup() {
-    	context = new Activity();
-        adInfo = new TestAdInfo();
-
-        methodBuilder = TestMethodBuilderFactory.getSingletonMock();
-        when(methodBuilder.setStatic(any(Class.class))).thenReturn(methodBuilder);
-        when(methodBuilder.addParam(any(Class.class), any())).thenReturn(methodBuilder);
-
-        semaphore = new Semaphore(0);
-        semaphoreGpsHelperListener = new GpsHelper.GpsHelperListener() {
-            @Override
-            public void onFetchAdInfoCompleted() {
-                gpsHelperListenerCallbackLooper = Looper.myLooper();
-                semaphore.release();
-            }
-        };
-    }
-
-    @After
-    public void tearDown() throws Exception {
-        reset(methodBuilder);
-    }
-
-    @Test
-    public void isPlayServicesAvailable_whenGooglePlayServicesIsLinked_shouldReturnTrue() throws Exception {
-        GpsHelper.setClassNamesForTesting();
-        when(methodBuilder.execute()).thenReturn(GpsHelper.GOOGLE_PLAY_SUCCESS_CODE);
-        assertThat(GpsHelper.isPlayServicesAvailable(context)).isTrue();
-    }
-
-    @Test
-    public void isPlayServicesAvailable_whenGooglePlayServicesReturnsNonSuccessCode_shouldReturnFalse() throws Exception {
-        GpsHelper.setClassNamesForTesting();
-        when(methodBuilder.execute()).thenReturn(GpsHelper.GOOGLE_PLAY_SUCCESS_CODE + 1);
-        assertThat(GpsHelper.isPlayServicesAvailable(context)).isFalse();
-    }
-
-    @Test
-    public void isPlayServicesAvailable_whenGooglePlayServicesReturnsNull_shouldReturnFalse() throws Exception {
-        GpsHelper.setClassNamesForTesting();
-        when(methodBuilder.execute()).thenReturn(null);
-        assertThat(GpsHelper.isPlayServicesAvailable(context)).isFalse();
-    }
-
-    @Test
-    public void isPlayServicesAvailable_whenGooglePlayServicesIsNotLinked_shouldReturnFalse() throws Exception {
-        assertThat(GpsHelper.isPlayServicesAvailable(context)).isFalse();
-    }
-
-    @Test
-    public void fetchAdvertisingInfoAsync_whenGooglePlayServicesIsLinked_shouldInvokeCallbackOnMainLooper() throws Exception {
-        GpsHelper.setClassNamesForTesting();
-        when(methodBuilder.execute()).thenReturn(
-                adInfo,
-                adInfo.mAdId,
-                adInfo.mLimitAdTrackingEnabled
-        );
-
-        GpsHelper.fetchAdvertisingInfoAsync(context, semaphoreGpsHelperListener);
-        safeAcquireSemaphore();
-        assertThat(gpsHelperListenerCallbackLooper).isEqualTo(Looper.getMainLooper());
-    }
-
-    @Test
-    public void fetchAdvertisingInfoAsync_whenGooglePlayServicesIsLinked_shouldPopulateClientMetadata() throws Exception {
-        verifyCleanClientMetadata(context);
-        GpsHelper.setClassNamesForTesting();
-        when(methodBuilder.execute()).thenReturn(
-                GpsHelper.GOOGLE_PLAY_SUCCESS_CODE,
-                adInfo,
-                adInfo.mAdId,
-                adInfo.mLimitAdTrackingEnabled
-        );
-
-        GpsHelper.fetchAdvertisingInfoAsync(context, semaphoreGpsHelperListener);
-        safeAcquireSemaphore();
-        verifyClientMetadata(context, adInfo);
-    }
-
-    @Test
-    public void fetchAdvertisingInfoAsync_whenReflectedMethodCallThrows_shouldNotPopulateClientMetadata() throws Exception {
-        verifyCleanClientMetadata(context);
-        GpsHelper.setClassNamesForTesting();
-        when(methodBuilder.execute()).thenThrow(new Exception());
-
-        GpsHelper.fetchAdvertisingInfoAsync(context, semaphoreGpsHelperListener);
-        safeAcquireSemaphore();
-        verifyCleanClientMetadata(context);
-    }
-
-    @Test
-    public void fetchAdvertisingInfoAsync_whenReflectedMethodCallReturnsNull_shouldNotPopulateClientMetadata() throws Exception {
-        verifyCleanClientMetadata(context);
-        GpsHelper.setClassNamesForTesting();
-        when(methodBuilder.execute()).thenReturn(null);
-
-        GpsHelper.fetchAdvertisingInfoAsync(context, semaphoreGpsHelperListener);
-        safeAcquireSemaphore();
-        verifyCleanClientMetadata(context);
-    }
-
-    @Test
-    public void fetchAdvertisingInfoAsync_whenGooglePlayServicesIsLinkedAndClientMetadataIsClean_shouldPopulateClientMetadata() throws Exception {
-        verifyCleanClientMetadata(context);
-        GpsHelper.setClassNamesForTesting();
-        when(methodBuilder.execute()).thenReturn(
-                GpsHelper.GOOGLE_PLAY_SUCCESS_CODE,
-                adInfo,
-                adInfo.mAdId,
-                adInfo.mLimitAdTrackingEnabled
-        );
-
-        GpsHelper.fetchAdvertisingInfoAsync(context, semaphoreGpsHelperListener);
-        safeAcquireSemaphore();
-        verifyClientMetadata(context, adInfo);
-    }
-
-    @Test
-    public void fetchAdvertisingInfoAsync_whenGooglePlayServicesLinkedAndClientMetadataIsPopulated_shouldRePopulateClientMetadata() throws Exception {
-        verifyCleanClientMetadata(context);
-        populateAndVerifyClientMetadata(context, adInfo);
-        adInfo.mLimitAdTrackingEnabled = false;
-        GpsHelper.setClassNamesForTesting();
-        when(methodBuilder.execute()).thenReturn(
-                GpsHelper.GOOGLE_PLAY_SUCCESS_CODE,
-                adInfo,
-                adInfo.mAdId,
-                adInfo.mLimitAdTrackingEnabled
-        );
-
-        GpsHelper.fetchAdvertisingInfoAsync(context, semaphoreGpsHelperListener);
-        safeAcquireSemaphore();
-        verifyClientMetadata(context, adInfo);
-    }
-
-    @Test
-    public void fetchAdvertisingInfoAsync_whenGooglePlayServicesIsNotLinked_shouldNotPopulateClientMetadata() throws Exception {
-        verifyCleanClientMetadata(context);
-        GpsHelper.setClassNamesForTesting();
-        when(methodBuilder.execute()).thenReturn(
-                GpsHelper.GOOGLE_PLAY_SUCCESS_CODE + 1
-        );
-
-        GpsHelper.fetchAdvertisingInfoAsync(context, semaphoreGpsHelperListener);
-        safeAcquireSemaphore();
-        verifyCleanClientMetadata(context);
-    }
-
-    @Test
-    public void isClientMetadataPopulated_whenContainsAdvertisingIdKeyAndIsLimitAdTrackingEnabledKey_shouldReturnTrue() throws Exception {
-        verifyCleanClientMetadata(context);
-        populateAndVerifyClientMetadata(context, adInfo);
-        assertThat(GpsHelper.isClientMetadataPopulated(context)).isTrue();
-    }
-
-    @Test
-    public void isClientMetadataPopulated_whenClean_shouldReturnFalse() throws Exception {
-        verifyCleanClientMetadata(context);
-        assertThat(GpsHelper.isClientMetadataPopulated(context)).isFalse();
-    }
-
-    @Test
-    public void updateClientMetadata_whenPassingInValidAdInfoObject_shouldUpdateClientMetadata() throws Exception {
-        // Use the real MethodBuilderFactory for this test, not the mock one
-        // Most mocks are set by default in SdkTestRunner setup
-        MethodBuilderFactory.setInstance(new MethodBuilderFactory());
-        verifyCleanClientMetadata(context);
-        GpsHelper.updateClientMetadata(context, adInfo);
-        verifyClientMetadata(context, adInfo);
-    }
-
-    @Test
-    public void reflectedGetIsLimitAdTrackingEnabled_whenIsLimitAdTrackingEnabledIsSet_shouldReturnIsLimitAdTrackingEnabled() throws Exception {
-        MethodBuilderFactory.setInstance(new MethodBuilderFactory());
-        assertThat(GpsHelper.reflectedIsLimitAdTrackingEnabled(adInfo, false)).isEqualTo(adInfo.LIMIT_AD_TRACKING_ENABLED);
-    }
-
-    @Test
-    public void reflectedGetIsLimitAdTrackingEnabled_whenReflectedMethodCallThrows_shouldReturnDefaultValue() throws Exception {
-        when(methodBuilder.execute()).thenThrow(new Exception());
-        assertThat(GpsHelper.reflectedIsLimitAdTrackingEnabled(new Object(), false)).isFalse();
-        verify(methodBuilder).execute();
-        assertThat(GpsHelper.reflectedIsLimitAdTrackingEnabled(new Object(), true)).isTrue();
-        verify(methodBuilder, times(2)).execute();
-    }
-
-    @Test
-    public void reflectedGetIsLimitAdTrackingEnabled_whenReflectedMethodCallReturnsNull_shouldReturnDefaultValue() throws Exception {
-        when(methodBuilder.execute()).thenReturn(null);
-        assertThat(GpsHelper.reflectedIsLimitAdTrackingEnabled(new Object(), false)).isFalse();
-        verify(methodBuilder).execute();
-        assertThat(GpsHelper.reflectedIsLimitAdTrackingEnabled(new Object(), true)).isTrue();
-        verify(methodBuilder, times(2)).execute();
-    }
-
-    @Test
-    public void reflectedGetAdvertisingId_whenAdvertisingIdIsSet_shouldReturnAdvertisingId() throws Exception {
-        MethodBuilderFactory.setInstance(new MethodBuilderFactory());
-        assertThat(GpsHelper.reflectedGetAdvertisingId(adInfo, null)).isEqualTo(adInfo.ADVERTISING_ID);
-    }
-
-    @Test
-    public void reflectedGetAdvertisingId_whenReflectedMethodCallThrows_shouldReturnDefaultValue() throws Exception {
-        when(methodBuilder.execute()).thenThrow(new Exception());
-        assertThat(GpsHelper.reflectedGetAdvertisingId(new Object(), null)).isNull();
-        verify(methodBuilder).execute();
-        String defaultAdId = "TEST_DEFAULT";
-        assertThat(GpsHelper.reflectedGetAdvertisingId(new Object(), defaultAdId)).isEqualTo(defaultAdId);
-        verify(methodBuilder, times(2)).execute();
-    }
-
-    @Test
-    public void isLimitAdTrackingEnabled_whenGooglePlayServicesIsLinkedAndLimitAdTrackingIsCached_shouldReturnLimitAdTracking() throws Exception {
-        GpsHelper.setClassNamesForTesting();
-        when(methodBuilder.execute()).thenReturn(GpsHelper.GOOGLE_PLAY_SUCCESS_CODE);
-        SharedPreferencesHelper.getSharedPreferences(context)
-                .edit()
-                .putBoolean(GpsHelper.IS_LIMIT_AD_TRACKING_ENABLED_KEY, adInfo.LIMIT_AD_TRACKING_ENABLED)
-                .commit();
-        assertThat(GpsHelper.isLimitAdTrackingEnabled(context)).isEqualTo(adInfo.LIMIT_AD_TRACKING_ENABLED);
-    }
-
-    @Test
-    public void isLimitAdTrackingEnabled_whenGooglePlayServicesIsLinkedAndAdInfoIsNotCached_shouldReturnFalse() throws Exception {
-        GpsHelper.setClassNamesForTesting();
-        when(methodBuilder.execute()).thenReturn(GpsHelper.GOOGLE_PLAY_SUCCESS_CODE);
-        assertThat(GpsHelper.isLimitAdTrackingEnabled(context)).isFalse();
-    }
-
-    @Test
-    public void isLimitAdTrackingEnabled_whenGooglePlayServicesIsNotLinked_shouldReturnFalse() throws Exception {
-        assertThat(GpsHelper.isLimitAdTrackingEnabled(context)).isFalse();
-    }
-
-    static public void populateAndVerifyClientMetadata(Context context, TestAdInfo adInfo) {
-        ClientMetadata clientMetadata = ClientMetadata.getInstance(context);
-        clientMetadata.setAdvertisingInfo(adInfo.getId(), adInfo.isLimitAdTrackingEnabled());
-        verifyClientMetadata(context, adInfo);
-    }
-
-    private void safeAcquireSemaphore() throws Exception {
-        Robolectric.runBackgroundTasks();
-        Robolectric.runUiThreadTasks();
-        semaphore.acquire();
-    }
-
-    static public void verifyClientMetadata(Context context, TestAdInfo adInfo) {
-        ClientMetadata clientMetadata = ClientMetadata.getInstance(context);
-        assertThat(clientMetadata.getDeviceId()).isEqualTo("ifa:" + adInfo.getId());
-        assertThat(clientMetadata.isDoNotTrackSet()).isEqualTo(adInfo.isLimitAdTrackingEnabled());
-    }
-
-    static public void verifyCleanClientMetadata(Context context) {
-        ClientMetadata clientMetadata = ClientMetadata.getInstance(context);
-        assertThat(clientMetadata.isAdvertisingInfoSet()).isFalse();
-    }
-}
-
+package com.mopub.common;
+
+import android.app.Activity;
+import android.content.Context;
+import android.os.Looper;
+
+import com.mopub.common.factories.MethodBuilderFactory;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.test.support.TestMethodBuilderFactory;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+
+import java.util.concurrent.Semaphore;
+
+import static com.mopub.common.util.Reflection.MethodBuilder;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class GpsHelperTest {
+    private MethodBuilder methodBuilder;
+    private Activity context;
+    private TestAdInfo adInfo;
+    private Semaphore semaphore;
+    private GpsHelper.GpsHelperListener semaphoreGpsHelperListener;
+    private Looper gpsHelperListenerCallbackLooper;
+
+    // This class emulates the AdInfo class returned from the Google Play Services
+    // AdvertisingIdClient.getAdvertisingIdInfo method; need to implement getters for reflection calls
+    public static final class TestAdInfo {
+        public static final String ADVERTISING_ID = "38400000-8cf0-11bd-b23e-10b96e40000d";
+        public static final boolean LIMIT_AD_TRACKING_ENABLED = true;
+
+        public String mAdId = ADVERTISING_ID;
+        public boolean mLimitAdTrackingEnabled = LIMIT_AD_TRACKING_ENABLED;
+
+        public String getId() {
+            return mAdId;
+        }
+
+        public boolean isLimitAdTrackingEnabled() {
+            return mLimitAdTrackingEnabled;
+        }
+    }
+
+    @Before
+    public void setup() {
+    	context = Robolectric.buildActivity(Activity.class).create().get();
+        adInfo = new TestAdInfo();
+
+        methodBuilder = TestMethodBuilderFactory.getSingletonMock();
+        when(methodBuilder.setStatic(any(Class.class))).thenReturn(methodBuilder);
+        when(methodBuilder.addParam(any(Class.class), any())).thenReturn(methodBuilder);
+
+        semaphore = new Semaphore(0);
+        semaphoreGpsHelperListener = new GpsHelper.GpsHelperListener() {
+            @Override
+            public void onFetchAdInfoCompleted() {
+                gpsHelperListenerCallbackLooper = Looper.myLooper();
+                semaphore.release();
+            }
+        };
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        reset(methodBuilder);
+    }
+
+    @Test
+    public void isPlayServicesAvailable_whenGooglePlayServicesIsLinked_shouldReturnTrue() throws Exception {
+        GpsHelper.setClassNamesForTesting();
+        when(methodBuilder.execute()).thenReturn(GpsHelper.GOOGLE_PLAY_SUCCESS_CODE);
+        assertThat(GpsHelper.isPlayServicesAvailable(context)).isTrue();
+    }
+
+    @Test
+    public void isPlayServicesAvailable_whenGooglePlayServicesReturnsNonSuccessCode_shouldReturnFalse() throws Exception {
+        GpsHelper.setClassNamesForTesting();
+        when(methodBuilder.execute()).thenReturn(GpsHelper.GOOGLE_PLAY_SUCCESS_CODE + 1);
+        assertThat(GpsHelper.isPlayServicesAvailable(context)).isFalse();
+    }
+
+    @Test
+    public void isPlayServicesAvailable_whenGooglePlayServicesReturnsNull_shouldReturnFalse() throws Exception {
+        GpsHelper.setClassNamesForTesting();
+        when(methodBuilder.execute()).thenReturn(null);
+        assertThat(GpsHelper.isPlayServicesAvailable(context)).isFalse();
+    }
+
+    @Test
+    public void isPlayServicesAvailable_whenGooglePlayServicesIsNotLinked_shouldReturnFalse() throws Exception {
+        assertThat(GpsHelper.isPlayServicesAvailable(context)).isFalse();
+    }
+
+    @Test
+    public void fetchAdvertisingInfoAsync_whenGooglePlayServicesIsLinked_shouldInvokeCallbackOnMainLooper() throws Exception {
+        GpsHelper.setClassNamesForTesting();
+        when(methodBuilder.execute()).thenReturn(
+                adInfo,
+                adInfo.mAdId,
+                adInfo.mLimitAdTrackingEnabled
+        );
+
+        GpsHelper.fetchAdvertisingInfoAsync(context, semaphoreGpsHelperListener);
+        safeAcquireSemaphore();
+        assertThat(gpsHelperListenerCallbackLooper).isEqualTo(Looper.getMainLooper());
+    }
+
+    @Test
+    public void fetchAdvertisingInfoAsync_whenGooglePlayServicesIsLinked_shouldPopulateClientMetadata() throws Exception {
+        verifyCleanClientMetadata(context);
+        GpsHelper.setClassNamesForTesting();
+        when(methodBuilder.execute()).thenReturn(
+                GpsHelper.GOOGLE_PLAY_SUCCESS_CODE,
+                adInfo,
+                adInfo.mAdId,
+                adInfo.mLimitAdTrackingEnabled
+        );
+
+        GpsHelper.fetchAdvertisingInfoAsync(context, semaphoreGpsHelperListener);
+        safeAcquireSemaphore();
+        verifyClientMetadata(context, adInfo);
+    }
+
+    @Test
+    public void fetchAdvertisingInfoAsync_whenReflectedMethodCallThrows_shouldNotPopulateClientMetadata() throws Exception {
+        verifyCleanClientMetadata(context);
+        GpsHelper.setClassNamesForTesting();
+        when(methodBuilder.execute()).thenThrow(new Exception());
+
+        GpsHelper.fetchAdvertisingInfoAsync(context, semaphoreGpsHelperListener);
+        safeAcquireSemaphore();
+        verifyCleanClientMetadata(context);
+    }
+
+    @Test
+    public void fetchAdvertisingInfoAsync_whenReflectedMethodCallReturnsNull_shouldNotPopulateClientMetadata() throws Exception {
+        verifyCleanClientMetadata(context);
+        GpsHelper.setClassNamesForTesting();
+        when(methodBuilder.execute()).thenReturn(null);
+
+        GpsHelper.fetchAdvertisingInfoAsync(context, semaphoreGpsHelperListener);
+        safeAcquireSemaphore();
+        verifyCleanClientMetadata(context);
+    }
+
+    @Test
+    public void fetchAdvertisingInfoAsync_whenGooglePlayServicesIsLinkedAndClientMetadataIsClean_shouldPopulateClientMetadata() throws Exception {
+        verifyCleanClientMetadata(context);
+        GpsHelper.setClassNamesForTesting();
+        when(methodBuilder.execute()).thenReturn(
+                GpsHelper.GOOGLE_PLAY_SUCCESS_CODE,
+                adInfo,
+                adInfo.mAdId,
+                adInfo.mLimitAdTrackingEnabled
+        );
+
+        GpsHelper.fetchAdvertisingInfoAsync(context, semaphoreGpsHelperListener);
+        safeAcquireSemaphore();
+        verifyClientMetadata(context, adInfo);
+    }
+
+    @Test
+    public void fetchAdvertisingInfoAsync_whenGooglePlayServicesLinkedAndClientMetadataIsPopulated_shouldRePopulateClientMetadata() throws Exception {
+        verifyCleanClientMetadata(context);
+        populateAndVerifyClientMetadata(context, adInfo);
+        adInfo.mLimitAdTrackingEnabled = false;
+        GpsHelper.setClassNamesForTesting();
+        when(methodBuilder.execute()).thenReturn(
+                GpsHelper.GOOGLE_PLAY_SUCCESS_CODE,
+                adInfo,
+                adInfo.mAdId,
+                adInfo.mLimitAdTrackingEnabled
+        );
+
+        GpsHelper.fetchAdvertisingInfoAsync(context, semaphoreGpsHelperListener);
+        safeAcquireSemaphore();
+        verifyClientMetadata(context, adInfo);
+    }
+
+    @Test
+    public void fetchAdvertisingInfoAsync_whenGooglePlayServicesIsNotLinked_shouldNotPopulateClientMetadata() throws Exception {
+        verifyCleanClientMetadata(context);
+        GpsHelper.setClassNamesForTesting();
+        when(methodBuilder.execute()).thenReturn(
+                GpsHelper.GOOGLE_PLAY_SUCCESS_CODE + 1
+        );
+
+        GpsHelper.fetchAdvertisingInfoAsync(context, semaphoreGpsHelperListener);
+        safeAcquireSemaphore();
+        verifyCleanClientMetadata(context);
+    }
+
+    @Test
+    public void isClientMetadataPopulated_whenContainsAdvertisingIdKeyAndIsLimitAdTrackingEnabledKey_shouldReturnTrue() throws Exception {
+        verifyCleanClientMetadata(context);
+        populateAndVerifyClientMetadata(context, adInfo);
+        assertThat(GpsHelper.isClientMetadataPopulated(context)).isTrue();
+    }
+
+    @Test
+    public void isClientMetadataPopulated_whenClean_shouldReturnFalse() throws Exception {
+        verifyCleanClientMetadata(context);
+        assertThat(GpsHelper.isClientMetadataPopulated(context)).isFalse();
+    }
+
+    @Test
+    public void updateClientMetadata_whenPassingInValidAdInfoObject_shouldUpdateClientMetadata() throws Exception {
+        // Use the real MethodBuilderFactory for this test, not the mock one
+        // Most mocks are set by default in SdkTestRunner setup
+        MethodBuilderFactory.setInstance(new MethodBuilderFactory());
+        verifyCleanClientMetadata(context);
+        GpsHelper.updateClientMetadata(context, adInfo);
+        verifyClientMetadata(context, adInfo);
+    }
+
+    @Test
+    public void reflectedGetIsLimitAdTrackingEnabled_whenIsLimitAdTrackingEnabledIsSet_shouldReturnIsLimitAdTrackingEnabled() throws Exception {
+        MethodBuilderFactory.setInstance(new MethodBuilderFactory());
+        assertThat(GpsHelper.reflectedIsLimitAdTrackingEnabled(adInfo, false)).isEqualTo(adInfo.LIMIT_AD_TRACKING_ENABLED);
+    }
+
+    @Test
+    public void reflectedGetIsLimitAdTrackingEnabled_whenReflectedMethodCallThrows_shouldReturnDefaultValue() throws Exception {
+        when(methodBuilder.execute()).thenThrow(new Exception());
+        assertThat(GpsHelper.reflectedIsLimitAdTrackingEnabled(new Object(), false)).isFalse();
+        verify(methodBuilder).execute();
+        assertThat(GpsHelper.reflectedIsLimitAdTrackingEnabled(new Object(), true)).isTrue();
+        verify(methodBuilder, times(2)).execute();
+    }
+
+    @Test
+    public void reflectedGetIsLimitAdTrackingEnabled_whenReflectedMethodCallReturnsNull_shouldReturnDefaultValue() throws Exception {
+        when(methodBuilder.execute()).thenReturn(null);
+        assertThat(GpsHelper.reflectedIsLimitAdTrackingEnabled(new Object(), false)).isFalse();
+        verify(methodBuilder).execute();
+        assertThat(GpsHelper.reflectedIsLimitAdTrackingEnabled(new Object(), true)).isTrue();
+        verify(methodBuilder, times(2)).execute();
+    }
+
+    @Test
+    public void reflectedGetAdvertisingId_whenAdvertisingIdIsSet_shouldReturnAdvertisingId() throws Exception {
+        MethodBuilderFactory.setInstance(new MethodBuilderFactory());
+        assertThat(GpsHelper.reflectedGetAdvertisingId(adInfo, null)).isEqualTo(adInfo.ADVERTISING_ID);
+    }
+
+    @Test
+    public void reflectedGetAdvertisingId_whenReflectedMethodCallThrows_shouldReturnDefaultValue() throws Exception {
+        when(methodBuilder.execute()).thenThrow(new Exception());
+        assertThat(GpsHelper.reflectedGetAdvertisingId(new Object(), null)).isNull();
+        verify(methodBuilder).execute();
+        String defaultAdId = "TEST_DEFAULT";
+        assertThat(GpsHelper.reflectedGetAdvertisingId(new Object(), defaultAdId)).isEqualTo(defaultAdId);
+        verify(methodBuilder, times(2)).execute();
+    }
+
+    @Test
+    public void isLimitAdTrackingEnabled_whenGooglePlayServicesIsLinkedAndLimitAdTrackingIsCached_shouldReturnLimitAdTracking() throws Exception {
+        GpsHelper.setClassNamesForTesting();
+        when(methodBuilder.execute()).thenReturn(GpsHelper.GOOGLE_PLAY_SUCCESS_CODE);
+        SharedPreferencesHelper.getSharedPreferences(context)
+                .edit()
+                .putBoolean(GpsHelper.IS_LIMIT_AD_TRACKING_ENABLED_KEY, adInfo.LIMIT_AD_TRACKING_ENABLED)
+                .commit();
+        assertThat(GpsHelper.isLimitAdTrackingEnabled(context)).isEqualTo(adInfo.LIMIT_AD_TRACKING_ENABLED);
+    }
+
+    @Test
+    public void isLimitAdTrackingEnabled_whenGooglePlayServicesIsLinkedAndAdInfoIsNotCached_shouldReturnFalse() throws Exception {
+        GpsHelper.setClassNamesForTesting();
+        when(methodBuilder.execute()).thenReturn(GpsHelper.GOOGLE_PLAY_SUCCESS_CODE);
+        assertThat(GpsHelper.isLimitAdTrackingEnabled(context)).isFalse();
+    }
+
+    @Test
+    public void isLimitAdTrackingEnabled_whenGooglePlayServicesIsNotLinked_shouldReturnFalse() throws Exception {
+        assertThat(GpsHelper.isLimitAdTrackingEnabled(context)).isFalse();
+    }
+
+    static public void populateAndVerifyClientMetadata(Context context, TestAdInfo adInfo) {
+        ClientMetadata clientMetadata = ClientMetadata.getInstance(context);
+        clientMetadata.setAdvertisingInfo(adInfo.getId(), adInfo.isLimitAdTrackingEnabled());
+        verifyClientMetadata(context, adInfo);
+    }
+
+    private void safeAcquireSemaphore() throws Exception {
+        Robolectric.runBackgroundTasks();
+        Robolectric.runUiThreadTasks();
+        semaphore.acquire();
+    }
+
+    static public void verifyClientMetadata(Context context, TestAdInfo adInfo) {
+        ClientMetadata clientMetadata = ClientMetadata.getInstance(context);
+        assertThat(clientMetadata.getDeviceId()).isEqualTo("ifa:" + adInfo.getId());
+        assertThat(clientMetadata.isDoNotTrackSet()).isEqualTo(adInfo.isLimitAdTrackingEnabled());
+    }
+
+    static public void verifyCleanClientMetadata(Context context) {
+        ClientMetadata clientMetadata = ClientMetadata.getInstance(context);
+        assertThat(clientMetadata.isAdvertisingInfoSet()).isFalse();
+    }
+}
+
diff --git a/mopub-sdk/src/test/java/com/mopub/common/MoPubBrowserTest.java b/mopub-sdk/src/test/java/com/mopub/common/MoPubBrowserTest.java
index e869fbb0..e5228497 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/MoPubBrowserTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/MoPubBrowserTest.java
@@ -1,71 +1,72 @@
-package com.mopub.common;
-
-import android.annotation.TargetApi;
-import android.os.Build;
-import android.webkit.CookieSyncManager;
-import android.webkit.WebView;
-
-import com.mopub.common.test.support.SdkTestRunner;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-
-@RunWith(SdkTestRunner.class)
-public class MoPubBrowserTest {
-
-    private MoPubBrowser subject;
-    private WebView mockWebView;
-
-    @Before
-    public void setUp() {
-        subject = new MoPubBrowser();
-        CookieSyncManager.createInstance(subject);
-
-        mockWebView = mock(WebView.class);
-        subject.setWebView(mockWebView);
-    }
-
-    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
-    @Test
-    public void onPause_withIsFinishingTrue_shouldStopLoading_shouldLoadBlankUrl_shouldPauseWebView() throws Exception {
-        // We have to manually call #onPause here after #finish since the activity is not being managed by Android
-        // Even if the activity was being managed by Android we would likely have to call onPause since the test would
-        // complete before the UI thread had a chance to invoke the lifecycle events
-        subject.finish();
-        subject.onPause();
-
-        verify(mockWebView).stopLoading();
-        verify(mockWebView).loadUrl("");
-        verify(mockWebView).onPause();
-    }
-
-    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
-    @Test
-    public void onPause_withIsFinishingFalse_shouldPauseWebView() throws Exception {
-        subject.onPause();
-
-        verify(mockWebView, never()).stopLoading();
-        verify(mockWebView, never()).loadUrl("");
-        verify(mockWebView).onPause();
-    }
-
-    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
-    @Test
-    public void onResume_shouldResumeWebView() throws Exception {
-        subject.onResume();
-
-        verify(mockWebView).onResume();
-    }
-
-    @Test
-    public void onDestroy_shouldDestroyWebView() throws Exception {
-        subject.onDestroy();
-
-        verify(mockWebView).destroy();
-    }
-}
+package com.mopub.common;
+
+import android.annotation.TargetApi;
+import android.os.Build;
+import android.webkit.CookieSyncManager;
+import android.webkit.WebView;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+@RunWith(SdkTestRunner.class)
+public class MoPubBrowserTest {
+
+    private MoPubBrowser subject;
+    private WebView mockWebView;
+
+    @Before
+    public void setUp() {
+        subject = new MoPubBrowser();
+        CookieSyncManager.createInstance(subject);
+
+        mockWebView = mock(WebView.class);
+        subject.setWebView(mockWebView);
+        // In the Gradle testing regime we will change these to build MoPubBrowser as an activity using Robolectric.
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
+    @Test
+    public void onPause_withIsFinishingTrue_shouldStopLoading_shouldLoadBlankUrl_shouldPauseWebView() throws Exception {
+        // We have to manually call #onPause here after #finish since the activity is not being managed by Android
+        // Even if the activity was being managed by Android we would likely have to call onPause since the test would
+        // complete before the UI thread had a chance to invoke the lifecycle events
+        subject.finish();
+        subject.onPause();
+
+        verify(mockWebView).stopLoading();
+        verify(mockWebView).loadUrl("");
+        verify(mockWebView).onPause();
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
+    @Test
+    public void onPause_withIsFinishingFalse_shouldPauseWebView() throws Exception {
+        subject.onPause();
+
+        verify(mockWebView, never()).stopLoading();
+        verify(mockWebView, never()).loadUrl("");
+        verify(mockWebView).onPause();
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
+    @Test
+    public void onResume_shouldResumeWebView() throws Exception {
+        subject.onResume();
+
+        verify(mockWebView).onResume();
+    }
+
+    @Test
+    public void onDestroy_shouldDestroyWebView() throws Exception {
+        subject.onDestroy();
+
+        verify(mockWebView).destroy();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/UrlHandlerTest.java b/mopub-sdk/src/test/java/com/mopub/common/UrlHandlerTest.java
new file mode 100644
index 00000000..6002c333
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/UrlHandlerTest.java
@@ -0,0 +1,625 @@
+package com.mopub.common;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.ResolveInfo;
+import android.net.Uri;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+
+import static com.mopub.common.UrlAction.FOLLOW_DEEP_LINK;
+import static com.mopub.common.UrlAction.HANDLE_MOPUB_SCHEME;
+import static com.mopub.common.UrlAction.HANDLE_PHONE_SCHEME;
+import static com.mopub.common.UrlAction.HANDLE_SHARE_TWEET;
+import static com.mopub.common.UrlAction.IGNORE_ABOUT_SCHEME;
+import static com.mopub.common.UrlAction.NOOP;
+import static com.mopub.common.UrlAction.OPEN_IN_APP_BROWSER;
+import static com.mopub.common.UrlAction.OPEN_NATIVE_BROWSER;
+import static com.mopub.common.UrlAction.OPEN_APP_MARKET;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+
+@RunWith(SdkTestRunner.class)
+public class UrlHandlerTest {
+    private Context context;
+    @Mock private UrlHandler.ResultActions mockResultActions;
+    @Mock private UrlHandler.MoPubSchemeListener mockMoPubSchemeListener;
+
+    @Before
+    public void setUp() throws Exception {
+        context = Robolectric.buildActivity(Activity.class).create().get().getApplicationContext();
+    }
+
+    @Test
+    public void urlHandler_withoutMoPubBrowser_shouldCallOnClickSuccessButNotStartActivity() {
+        final String url = "http://some_url";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(OPEN_IN_APP_BROWSER)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .withoutMoPubBrowser()
+                .build().handleUrl(context, url);
+
+        verify(mockResultActions).urlHandlingSucceeded(url, OPEN_IN_APP_BROWSER);
+        verifyNoMoreCallbacks();
+        final Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(startedActivity).isNull();
+    }
+
+    @Test
+    public void urlHandler_withMatchingMoPubSchemeFinishLoad_shouldCallOnFinishLoad() {
+        final String url = "mopub://finishLoad";
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_MOPUB_SCHEME)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+
+        verify(mockMoPubSchemeListener).onFinishLoad();
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withMatchingMoPubSchemeClose_shouldCallOnClose() {
+        final String url = "mopub://close";
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_MOPUB_SCHEME)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+
+        verify(mockMoPubSchemeListener).onClose();
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withMatchingMoPubSchemeFailLoad_shouldCallOnFailLoad() {
+        final String url = "mopub://failLoad";
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_MOPUB_SCHEME)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+
+        verify(mockMoPubSchemeListener).onFailLoad();
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withMatchingAboutSchemeUrl_shouldIgnoreClick() {
+        final String url = "about:blank";
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(
+                        HANDLE_MOPUB_SCHEME,
+                        IGNORE_ABOUT_SCHEME,
+                        HANDLE_PHONE_SCHEME)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+
+        verifyNoMoreCallbacks();
+        verifyNoStartedActivity();
+    }
+
+    @Test
+    public void urlHandler_withMatchingPhoneSchemeTelUrl_shouldCallOnClickSuccess() {
+        assertPhoneSchemeCallback("tel:");
+    }
+
+    @Test
+    public void urlHandler_withMatchingPhoneSchemeVoicemailUrl_shouldCallOnClickSuccess() {
+        assertPhoneSchemeCallback("voicemail:");
+    }
+
+    @Test
+    public void urlHandler_withMatchingPhoneSchemeSMSUrl_shouldCallOnClickSuccess() {
+        assertPhoneSchemeCallback("sms:");
+    }
+
+    @Test
+    public void urlHandler_withMatchingPhoneSchemeMailToUrl_shouldCallOnClickSuccess() {
+        assertPhoneSchemeCallback("mailto:");
+    }
+
+    @Test
+    public void urlHandler_withMatchingPhoneSchemeGeoUrl_shouldCallOnClickSuccess() {
+        assertPhoneSchemeCallback("geo:");
+    }
+
+    @Test
+    public void urlHandler_withMatchingPhoneSchemeStreetViewUrl_shouldCallOnClickSuccess() {
+        assertPhoneSchemeCallback("google.streetview:");
+    }
+
+    @Test
+    public void urlHandler_withMatchingPhoneSchemeUrl_shouldStartActivity() {
+        final String url = "tel:1234567890";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(IGNORE_ABOUT_SCHEME, HANDLE_MOPUB_SCHEME, FOLLOW_DEEP_LINK,
+                        OPEN_IN_APP_BROWSER, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER, HANDLE_SHARE_TWEET)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+
+        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+        assertThat(startedActivity.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        assertThat(startedActivity.getData()).isEqualTo(Uri.parse(url));
+    }
+
+    @Test
+    public void urlHandler_withValidNativeBrowserUrl_shouldCallOnClickSuccess_shouldStartActivity() {
+        final String urlToLoad = "some_url";
+        final String url = "mopubnativebrowser://navigate?url=" + urlToLoad;
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(IGNORE_ABOUT_SCHEME, HANDLE_MOPUB_SCHEME, FOLLOW_DEEP_LINK,
+                        OPEN_IN_APP_BROWSER, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER, HANDLE_SHARE_TWEET)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+
+        verify(mockResultActions).urlHandlingSucceeded(url, OPEN_NATIVE_BROWSER);
+        verifyNoMoreCallbacks();
+        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+        assertThat(startedActivity.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        assertThat(startedActivity.getData()).isEqualTo(Uri.parse(urlToLoad));
+    }
+
+    @Test
+    public void urlHandler_withMatchingInAppBrowserHttpUrl_shouldCallOnClickSuccess_shouldStartActivity() {
+        final String url = "http://some_url";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(IGNORE_ABOUT_SCHEME, HANDLE_MOPUB_SCHEME, FOLLOW_DEEP_LINK,
+                        OPEN_IN_APP_BROWSER, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER, HANDLE_SHARE_TWEET)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+
+        verify(mockResultActions).urlHandlingSucceeded(url, OPEN_IN_APP_BROWSER);
+        verifyNoMoreCallbacks();
+        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+        assertThat(startedActivity.getComponent().getClassName())
+                .isEqualTo(MoPubBrowser.class.getName());
+        assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(url);
+    }
+
+    @Test
+    public void urlHandler_withMatchingInAppBrowserHttpsUrl_shouldCallOnClickSuccess_shouldStartActivity() {
+        final String url = "https://some_url";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(IGNORE_ABOUT_SCHEME, HANDLE_MOPUB_SCHEME, FOLLOW_DEEP_LINK,
+                        OPEN_IN_APP_BROWSER, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER, HANDLE_SHARE_TWEET)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+
+        verify(mockResultActions).urlHandlingSucceeded(url, OPEN_IN_APP_BROWSER);
+        verifyNoMoreCallbacks();
+        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+        assertThat(startedActivity.getComponent().getClassName())
+                .isEqualTo(MoPubBrowser.class.getName());
+        assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(url);
+    }
+
+    @Test
+    public void urlHandler_withMatchingShareUrl_shouldCallOnClickSuccess_shouldStartActivity() {
+        final String shareTweetUrl = "mopubshare://tweet?screen_name=SpaceX&tweet_id=596026229536460802";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_SHARE_TWEET)
+                .withResultActions(mockResultActions)
+                .build().handleUrl(context, shareTweetUrl);
+
+        verify(mockResultActions).urlHandlingSucceeded(shareTweetUrl, HANDLE_SHARE_TWEET);
+        verifyNoMoreCallbacks();
+        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+        assertThat(startedActivity.getAction()).isEqualTo(Intent.ACTION_CHOOSER);
+    }
+
+    @Test
+    public void urlHandler_withMatchingDeepLinkUrl_shouldCallOnClickSuccess_shouldStartActivity() {
+        final String deepLinkUrl = "appscheme://host";
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(Intent.ACTION_VIEW,
+                Uri.parse(deepLinkUrl)), new ResolveInfo());
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(FOLLOW_DEEP_LINK)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, deepLinkUrl);
+
+        verify(mockResultActions).urlHandlingSucceeded(deepLinkUrl, FOLLOW_DEEP_LINK);
+        verifyNoMoreCallbacks();
+        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+        assertThat(startedActivity.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        assertThat(startedActivity.getData()).isEqualTo(Uri.parse(deepLinkUrl));
+    }
+
+    @Test
+    public void urlHandler_withDualMatchingUnresolvableUrlActions_shouldCallOnClickFailOnLastMatchedAction() {
+        final String url = "mopub://invalid";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_MOPUB_SCHEME, FOLLOW_DEEP_LINK)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+
+        verify(mockResultActions).urlHandlingFailed(url, FOLLOW_DEEP_LINK);
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withShareTweetAndDeepLink_shouldCallOnClickFailOnLastMatchedDeepLink() {
+        final String url = "mopubshare://invalid";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_SHARE_TWEET, FOLLOW_DEEP_LINK)
+                .withResultActions(mockResultActions)
+                .build().handleUrl(context, url);
+
+        verify(mockResultActions).urlHandlingFailed(url, FOLLOW_DEEP_LINK);
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withNoConfiguration_shouldDoNothing() {
+        new UrlHandler.Builder().build().handleUrl(context, "");
+
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withoutDestinationUrl_shouldNotError() {
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(IGNORE_ABOUT_SCHEME)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, "");
+
+        verify(mockResultActions).urlHandlingFailed("", NOOP);
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withoutSupportedUrlActions_shouldNotError() {
+        new UrlHandler.Builder()
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, "about:blank");
+
+        verify(mockResultActions).urlHandlingFailed("about:blank", NOOP);
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withoutClickListener_shouldNotError() {
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(IGNORE_ABOUT_SCHEME)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, "about:blank");
+
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withoutMoPubSchemeListener_shouldNotError() {
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(IGNORE_ABOUT_SCHEME)
+                .withResultActions(mockResultActions)
+                .build().handleUrl(context, "about:blank");
+
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withoutMoPubBrowser_shouldNotError() {
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(IGNORE_ABOUT_SCHEME)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .withoutMoPubBrowser()
+                .build().handleUrl(context, "about:blank");
+
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingAboutSchemeUrl_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingUrl(IGNORE_ABOUT_SCHEME);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingMoPubSchemeUrl_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingUrl(HANDLE_MOPUB_SCHEME);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingDeepLinkUrl_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingUrl(FOLLOW_DEEP_LINK);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingInAppBrowserUrl_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingUrl(OPEN_IN_APP_BROWSER);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingPhoneSchemeUrl_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingUrl(HANDLE_PHONE_SCHEME);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingNativeBrowserUrl_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingUrl(OPEN_NATIVE_BROWSER);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingShareTweetUrl_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingUrl(HANDLE_SHARE_TWEET);
+    }
+
+    /**
+     * For the next few unit tests urlHandler_withoutMatching[some]UrlAction_shouldCallOnClickFail,
+     * do not include FOLLOW_DEEP_LINK, since it would be a catch-all and trigger urlHandlingSucceeded.
+     */
+
+    @Test
+    public void urlHandler_withoutMatchingAboutSchemeUrlAction_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingSupportedUrlAction("about:blank", HANDLE_MOPUB_SCHEME,
+                OPEN_IN_APP_BROWSER, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER, HANDLE_SHARE_TWEET);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingMoPubSchemeUrlAction_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingSupportedUrlAction("mopub://close", IGNORE_ABOUT_SCHEME,
+                OPEN_IN_APP_BROWSER, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER, HANDLE_SHARE_TWEET);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingDeepLinkUrlAction_shouldCallUrlHandlingFailed() {
+        final String deepLinkUrl = "appscheme://host";
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(Intent.ACTION_VIEW,
+                Uri.parse(deepLinkUrl)), new ResolveInfo());
+        assertCallbackWithoutMatchingSupportedUrlAction(deepLinkUrl, IGNORE_ABOUT_SCHEME,
+                HANDLE_MOPUB_SCHEME, OPEN_IN_APP_BROWSER, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER,
+                HANDLE_SHARE_TWEET);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingInAppBrowserUrlAction_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingSupportedUrlAction("https://some_url", IGNORE_ABOUT_SCHEME,
+                HANDLE_MOPUB_SCHEME, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER, HANDLE_SHARE_TWEET);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingPhoneSchemeUrlAction_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingSupportedUrlAction("tel:1234567890", IGNORE_ABOUT_SCHEME,
+                HANDLE_MOPUB_SCHEME, OPEN_IN_APP_BROWSER, OPEN_NATIVE_BROWSER, HANDLE_SHARE_TWEET);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingNativeBrowserUrlAction_shouldCallUrlHandlingFailed() {
+        assertCallbackWithoutMatchingSupportedUrlAction("mopubnativebrowser://navigate?url=some_url",
+                IGNORE_ABOUT_SCHEME, HANDLE_MOPUB_SCHEME, OPEN_IN_APP_BROWSER, HANDLE_PHONE_SCHEME,
+                HANDLE_SHARE_TWEET);
+    }
+
+    @Test
+    public void urlHandler_withoutMatchingShareTweetUrlAction_shouldCallUrlHandlingFailed() {
+        final String shareTweetUrl = "mopubshare://tweet?screen_name=SpaceX&tweet_id=596026229536460802";
+        assertCallbackWithoutMatchingSupportedUrlAction(shareTweetUrl, HANDLE_MOPUB_SCHEME,
+                IGNORE_ABOUT_SCHEME, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER, OPEN_APP_MARKET,
+                OPEN_IN_APP_BROWSER);
+    }
+
+    @Test
+    public void urlHandler_withNullDestinationURL_shouldDoNothing() {
+        final String nullUrl = null;
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(IGNORE_ABOUT_SCHEME, HANDLE_MOPUB_SCHEME, FOLLOW_DEEP_LINK,
+                        OPEN_IN_APP_BROWSER, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER, HANDLE_SHARE_TWEET)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, nullUrl);
+
+        verify(mockResultActions).urlHandlingFailed(nullUrl, NOOP);
+        verifyNoMoreCallbacks();
+        verifyNoStartedActivity();
+    }
+
+    @Test
+    public void urlHandler_withEmptyDestinationURL_shouldDoNothing() {
+        final String emptyUrl = "";
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(IGNORE_ABOUT_SCHEME, HANDLE_MOPUB_SCHEME, FOLLOW_DEEP_LINK,
+                        OPEN_IN_APP_BROWSER, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER, HANDLE_SHARE_TWEET)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, emptyUrl);
+
+        verify(mockResultActions).urlHandlingFailed(emptyUrl, NOOP);
+        verifyNoMoreCallbacks();
+        verifyNoStartedActivity();
+    }
+
+    @Test
+    public void urlHandler_withInvalidDestinationURL_shouldDoNothing() {
+        final String invalidUrl = "some_invalid_url";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(IGNORE_ABOUT_SCHEME, HANDLE_MOPUB_SCHEME, FOLLOW_DEEP_LINK,
+                        OPEN_IN_APP_BROWSER, HANDLE_PHONE_SCHEME, OPEN_NATIVE_BROWSER, HANDLE_SHARE_TWEET)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, invalidUrl);
+
+        verify(mockResultActions).urlHandlingFailed(invalidUrl, NOOP);
+        verifyNoMoreCallbacks();
+        verifyNoStartedActivity();
+    }
+
+    @Test
+    public void urlHandler_withMatchingMoPubSchemeWithoutMoPubSchemeListener_shouldDoNothing() {
+        final String url = "mopub://finishLoad";
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_MOPUB_SCHEME)
+                .withResultActions(mockResultActions)
+                .build().handleUrl(context, url);
+
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withInvalidMoPubSchemeCustom_shouldNotError() {
+        final String url = "mopub://custom?INVALID";
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_MOPUB_SCHEME)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+
+        verify(mockResultActions).urlHandlingFailed(url, HANDLE_MOPUB_SCHEME);
+        verifyNoMoreCallbacks();
+    }
+
+    @Test
+    public void urlHandler_withInvalidNativeBrowserUrl_shouldCallUrlHandlingFailed() {
+        final String url = "mopubnativebrowser://INVALID";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(OPEN_NATIVE_BROWSER)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+
+        verify(mockResultActions).urlHandlingFailed(url, OPEN_NATIVE_BROWSER);
+        verifyNoMoreCallbacks();
+        verifyNoStartedActivity();
+    }
+
+    @Test
+    public void urlHandler_withInvalidHostInShareTweetUrl_shouldCallUrlHandlingFailed() {
+        final String url = "mopubshare://invalid";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_SHARE_TWEET)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+
+        verify(mockResultActions).urlHandlingFailed(url, NOOP);
+        verifyNoMoreCallbacks();
+        verifyNoStartedActivity();
+    }
+
+    @Test
+    public void urlHandler_withMissingQueryParametersInShareTweetUrl_shouldCallUrlHandlingFailed() {
+        final String url = "mopubshare://tweet?x=1&y=2";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_SHARE_TWEET)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+
+        verify(mockResultActions).urlHandlingFailed(url, HANDLE_SHARE_TWEET);
+        verifyNoMoreCallbacks();
+        verifyNoStartedActivity();
+    }
+
+    @Test
+    public void urlHandler_withEmptyQueryParametersInShareTweetUrl_shouldCallUrlHandlingFailed() {
+        final String url = "mopubshare://tweet?screen_name=&tweet_id=";
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_SHARE_TWEET)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+
+        verify(mockResultActions).urlHandlingFailed(url, HANDLE_SHARE_TWEET);
+        verifyNoMoreCallbacks();
+        verifyNoStartedActivity();
+    }
+
+    @Test
+    public void urlHandler_withMatchingUnresolvableDeepLinkUrl_shouldCallUrlHandlingFailed() {
+        final String deepLinkUrl = "appscheme://host";
+        // The following code would make this url resolvable, so avoiding it to test for an
+        // unresolvable url (yet included for documentation purposes).
+        //  Robolectric.packageManager.addResolveInfoForIntent(new Intent(Intent.ACTION_VIEW,
+        //          Uri.parse(deepLinkUrl)), new ResolveInfo());
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(FOLLOW_DEEP_LINK)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, deepLinkUrl);
+
+        verify(mockResultActions).urlHandlingFailed(deepLinkUrl, FOLLOW_DEEP_LINK);
+        verifyNoMoreCallbacks();
+        verifyNoStartedActivity();
+    }
+
+    private void assertPhoneSchemeCallback(@NonNull final String url) {
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(HANDLE_PHONE_SCHEME)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+
+        verify(mockResultActions).urlHandlingSucceeded(url, HANDLE_PHONE_SCHEME);
+        verifyNoMoreCallbacks();
+    }
+
+    private void assertCallbackWithoutMatchingUrl(@NonNull final UrlAction urlAction) {
+        final String url = "non://matching_url";
+        UrlAction expectedFailUrlAction = NOOP;
+
+        if (urlAction.equals(FOLLOW_DEEP_LINK)) {
+            expectedFailUrlAction = FOLLOW_DEEP_LINK;
+        }
+
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(urlAction)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+        verify(mockResultActions).urlHandlingFailed(url, expectedFailUrlAction);
+        verifyNoMoreCallbacks();
+    }
+
+    private void assertCallbackWithoutMatchingSupportedUrlAction(@NonNull final String url,
+            @NonNull final UrlAction... otherTypes) {
+        new UrlHandler.Builder()
+                .withSupportedUrlActions(UrlAction.NOOP, otherTypes)
+                .withResultActions(mockResultActions)
+                .withMoPubSchemeListener(mockMoPubSchemeListener)
+                .build().handleUrl(context, url);
+        verify(mockResultActions).urlHandlingFailed(url, NOOP);
+        verifyNoMoreCallbacks();
+    }
+
+    private void verifyNoMoreCallbacks() {
+        verifyNoMoreInteractions(mockResultActions);
+        verifyNoMoreInteractions(mockMoPubSchemeListener);
+    }
+
+    private void verifyNoStartedActivity() {
+        assertThat(Robolectric.getShadowApplication().peekNextStartedActivity()).isNull();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/IntentsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/IntentsTest.java
index 274e9543..94aa1180 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/util/IntentsTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/IntentsTest.java
@@ -1,151 +1,205 @@
-package com.mopub.common.util;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.content.pm.ResolveInfo;
-import android.net.Uri;
-import android.os.Bundle;
-
-import com.mopub.common.MoPubBrowser;
-import com.mopub.exceptions.IntentNotResolvableException;
-import com.mopub.exceptions.UrlParseException;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.stub;
-
-@RunWith(RobolectricTestRunner.class)
-public class IntentsTest {
-    private Activity activityContext;
-    private Context applicationContext;
-
-    @Before
-    public void setUp() {
-        activityContext = Robolectric.buildActivity(Activity.class).create().get();
-        applicationContext = activityContext.getApplicationContext();
-    }
-
-    @Test
-    public void startActivity_withActivityContext_shouldStartActivityWithNoNewFlags() throws IntentNotResolvableException {
-        Intents.startActivity(activityContext, new Intent());
-
-        final Intent intent = Robolectric.getShadowApplication().peekNextStartedActivity();
-        assertThat(Utils.bitMaskContainsFlag(intent.getFlags(), FLAG_ACTIVITY_NEW_TASK)).isFalse();
-    }
-
-    @Test
-    public void getStartActivityIntent_withActivityContext_shouldReturnIntentWithoutNewTaskFlag() throws Exception {
-        Context context = new Activity();
-
-        final Intent intent = Intents.getStartActivityIntent(context, MoPubBrowser.class, null);
-
-        assertThat(intent.getComponent().getClassName()).isEqualTo(MoPubBrowser.class.getName());
-        assertThat(Utils.bitMaskContainsFlag(intent.getFlags(), FLAG_ACTIVITY_NEW_TASK)).isFalse();
-        assertThat(intent.getExtras()).isNull();
-    }
-
-    @Test
-    public void getStartActivityIntent_withApplicationContext_shouldReturnIntentWithNewTaskFlag() throws Exception {
-        Context context = new Activity().getApplicationContext();
-
-        final Intent intent = Intents.getStartActivityIntent(context, MoPubBrowser.class, null);
-
-        assertThat(intent.getComponent().getClassName()).isEqualTo(MoPubBrowser.class.getName());
-        assertThat(Utils.bitMaskContainsFlag(intent.getFlags(), FLAG_ACTIVITY_NEW_TASK)).isTrue();
-        assertThat(intent.getExtras()).isNull();
-    }
-
-    @Test
-    public void getStartActivityIntent_withBundle_shouldReturnIntentWithExtras() throws Exception {
-        Context context = new Activity();
-        Bundle bundle = new Bundle();
-        bundle.putString("arbitrary key", "even more arbitrary value");
-
-        final Intent intent = Intents.getStartActivityIntent(context, MoPubBrowser.class, bundle);
-
-        assertThat(intent.getComponent().getClassName()).isEqualTo(MoPubBrowser.class.getName());
-        assertThat(Utils.bitMaskContainsFlag(intent.getFlags(), FLAG_ACTIVITY_NEW_TASK)).isFalse();
-        assertThat(intent.getExtras()).isEqualTo(bundle);
-    }
-
-    @Test
-    public void deviceCanHandleIntent_whenActivityCanResolveIntent_shouldReturnTrue() throws Exception {
-        Context context = mock(Context.class);
-        PackageManager packageManager = mock(PackageManager.class);
-
-        List<ResolveInfo> resolveInfos = new ArrayList<ResolveInfo>();
-        resolveInfos.add(new ResolveInfo());
-
-        stub(context.getPackageManager()).toReturn(packageManager);
-        Intent specificIntent = new Intent();
-        specificIntent.setData(Uri.parse("specificIntent:"));
-
-        stub(packageManager.queryIntentActivities(eq(specificIntent), eq(0))).toReturn(resolveInfos);
-
-        assertThat(Intents.deviceCanHandleIntent(context, specificIntent)).isTrue();
-    }
-
-    @Test
-    public void deviceCanHandleIntent_whenActivityCanNotResolveIntent_shouldReturnFalse() throws Exception {
-        Context context = mock(Context.class);
-        PackageManager packageManager = mock(PackageManager.class);
-
-        List<ResolveInfo> resolveInfos = new ArrayList<ResolveInfo>();
-        resolveInfos.add(new ResolveInfo());
-
-        stub(context.getPackageManager()).toReturn(packageManager);
-        Intent specificIntent = new Intent();
-        specificIntent.setData(Uri.parse("specificIntent:"));
-
-        Intent otherIntent = new Intent();
-        otherIntent.setData(Uri.parse("other:"));
-        stub(packageManager.queryIntentActivities(eq(specificIntent), eq(0))).toReturn(resolveInfos);
-
-        assertThat(Intents.deviceCanHandleIntent(context, otherIntent)).isFalse();
-    }
-
-    @Test
-    public void intentForNativeBrowserScheme_shouldProperlyHandleEncodedUrls() throws UrlParseException {
-        Intent intent;
-
-        intent = Intents.intentForNativeBrowserScheme("mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.example.com");
-        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
-        assertThat(intent.getDataString()).isEqualTo("http://www.example.com");
-
-        intent = Intents.intentForNativeBrowserScheme("mopubnativebrowser://navigate?url=http://www.example.com/?query=1&two=2");
-        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
-        assertThat(intent.getDataString()).isEqualTo("http://www.example.com/?query=1");
-
-        intent = Intents.intentForNativeBrowserScheme("mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.example.com%2F%3Fquery%3D1%26two%3D2");
-        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
-        assertThat(intent.getDataString()).isEqualTo("http://www.example.com/?query=1&two=2");
-    }
-
-    @Test(expected = UrlParseException.class)
-    public void intentForNativeBrowserScheme_whenNotMoPubNativeBrowser_shouldThrowException() throws UrlParseException {
-        Intents.intentForNativeBrowserScheme("mailto://navigate?url=http://www.example.com");
-    }
-
-    @Test(expected = UrlParseException.class)
-    public void intentForNativeBrowserScheme_whenNotNavigate_shouldThrowException() throws UrlParseException {
-        Intents.intentForNativeBrowserScheme("mopubnativebrowser://getout?url=http://www.example.com");
-    }
-
-    @Test(expected = UrlParseException.class)
-    public void intentForNativeBrowserScheme_whenUrlParameterMissing_shouldThrowException() throws UrlParseException {
-        Intents.intentForNativeBrowserScheme("mopubnativebrowser://navigate");
-    }
-}
+package com.mopub.common.util;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.net.Uri;
+import android.os.Bundle;
+
+import com.mopub.common.MoPubBrowser;
+import com.mopub.exceptions.IntentNotResolvableException;
+import com.mopub.exceptions.UrlParseException;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.stub;
+
+@RunWith(RobolectricTestRunner.class)
+public class IntentsTest {
+    private Activity activityContext;
+    private Context applicationContext;
+
+    @Before
+    public void setUp() {
+        activityContext = Robolectric.buildActivity(Activity.class).create().get();
+        applicationContext = activityContext.getApplicationContext();
+    }
+
+    @Test
+    public void startActivity_withActivityContext_shouldStartActivityWithNoNewFlags() throws IntentNotResolvableException {
+        Intents.startActivity(activityContext, new Intent());
+
+        final Intent intent = Robolectric.getShadowApplication().peekNextStartedActivity();
+        assertThat(Utils.bitMaskContainsFlag(intent.getFlags(), FLAG_ACTIVITY_NEW_TASK)).isFalse();
+    }
+
+    @Test
+    public void getStartActivityIntent_withActivityContext_shouldReturnIntentWithoutNewTaskFlag() throws Exception {
+        Context context = new Activity();
+
+        final Intent intent = Intents.getStartActivityIntent(context, MoPubBrowser.class, null);
+
+        assertThat(intent.getComponent().getClassName()).isEqualTo(MoPubBrowser.class.getName());
+        assertThat(Utils.bitMaskContainsFlag(intent.getFlags(), FLAG_ACTIVITY_NEW_TASK)).isFalse();
+        assertThat(intent.getExtras()).isNull();
+    }
+
+    @Test
+    public void getStartActivityIntent_withApplicationContext_shouldReturnIntentWithNewTaskFlag() throws Exception {
+        Context context = new Activity().getApplicationContext();
+
+        final Intent intent = Intents.getStartActivityIntent(context, MoPubBrowser.class, null);
+
+        assertThat(intent.getComponent().getClassName()).isEqualTo(MoPubBrowser.class.getName());
+        assertThat(Utils.bitMaskContainsFlag(intent.getFlags(), FLAG_ACTIVITY_NEW_TASK)).isTrue();
+        assertThat(intent.getExtras()).isNull();
+    }
+
+    @Test
+    public void getStartActivityIntent_withBundle_shouldReturnIntentWithExtras() throws Exception {
+        Context context = new Activity();
+        Bundle bundle = new Bundle();
+        bundle.putString("arbitrary key", "even more arbitrary value");
+
+        final Intent intent = Intents.getStartActivityIntent(context, MoPubBrowser.class, bundle);
+
+        assertThat(intent.getComponent().getClassName()).isEqualTo(MoPubBrowser.class.getName());
+        assertThat(Utils.bitMaskContainsFlag(intent.getFlags(), FLAG_ACTIVITY_NEW_TASK)).isFalse();
+        assertThat(intent.getExtras()).isEqualTo(bundle);
+    }
+
+    @Test
+    public void deviceCanHandleIntent_whenActivityCanResolveIntent_shouldReturnTrue() throws Exception {
+        Context context = mock(Context.class);
+        PackageManager packageManager = mock(PackageManager.class);
+
+        List<ResolveInfo> resolveInfos = new ArrayList<ResolveInfo>();
+        resolveInfos.add(new ResolveInfo());
+
+        stub(context.getPackageManager()).toReturn(packageManager);
+        Intent specificIntent = new Intent();
+        specificIntent.setData(Uri.parse("specificIntent:"));
+
+        stub(packageManager.queryIntentActivities(eq(specificIntent), eq(0))).toReturn(resolveInfos);
+
+        assertThat(Intents.deviceCanHandleIntent(context, specificIntent)).isTrue();
+    }
+
+    @Test
+    public void deviceCanHandleIntent_whenActivityCanNotResolveIntent_shouldReturnFalse() throws Exception {
+        Context context = mock(Context.class);
+        PackageManager packageManager = mock(PackageManager.class);
+
+        List<ResolveInfo> resolveInfos = new ArrayList<ResolveInfo>();
+        resolveInfos.add(new ResolveInfo());
+
+        stub(context.getPackageManager()).toReturn(packageManager);
+        Intent specificIntent = new Intent();
+        specificIntent.setData(Uri.parse("specificIntent:"));
+
+        Intent otherIntent = new Intent();
+        otherIntent.setData(Uri.parse("other:"));
+        stub(packageManager.queryIntentActivities(eq(specificIntent), eq(0))).toReturn(resolveInfos);
+
+        assertThat(Intents.deviceCanHandleIntent(context, otherIntent)).isFalse();
+    }
+
+    @Test
+    public void intentForNativeBrowserScheme_shouldProperlyHandleEncodedUrls() throws UrlParseException {
+        Intent intent;
+
+        intent = Intents.intentForNativeBrowserScheme(Uri.parse("mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.example.com"));
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        assertThat(intent.getDataString()).isEqualTo("http://www.example.com");
+
+        intent = Intents.intentForNativeBrowserScheme(Uri.parse("mopubnativebrowser://navigate?url=http://www.example.com/?query=1&two=2"));
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        assertThat(intent.getDataString()).isEqualTo("http://www.example.com/?query=1");
+
+        intent = Intents.intentForNativeBrowserScheme(Uri.parse("mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.example.com%2F%3Fquery%3D1%26two%3D2"));
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        assertThat(intent.getDataString()).isEqualTo("http://www.example.com/?query=1&two=2");
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForNativeBrowserScheme_whenNotMoPubNativeBrowser_shouldThrowException() throws UrlParseException {
+        Intents.intentForNativeBrowserScheme(Uri.parse("mailto://navigate?url=http://www.example.com"));
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForNativeBrowserScheme_whenNotNavigate_shouldThrowException() throws UrlParseException {
+        Intents.intentForNativeBrowserScheme(Uri.parse("mopubnativebrowser://getout?url=http://www.example.com"));
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForNativeBrowserScheme_whenUrlParameterMissing_shouldThrowException() throws UrlParseException {
+        Intents.intentForNativeBrowserScheme(Uri.parse("mopubnativebrowser://navigate"));
+    }
+
+    @Test
+    public void intentForShareTweetScheme_whenValidUri_shouldReturnShareTweetIntent() throws UrlParseException {
+        Intent intent;
+        final String shareMessage = "Check out @SpaceX's Tweet: https://twitter.com/SpaceX/status/596026229536460802";
+
+        intent = Intents.intentForShareTweet(Uri.parse("mopubshare://tweet?screen_name=SpaceX&tweet_id=596026229536460802"));
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_SEND);
+        assertThat(intent.getType()).isEqualTo("text/plain");
+        assertThat(intent.getStringExtra(Intent.EXTRA_SUBJECT)).isEqualTo(shareMessage);
+        assertThat(intent.getStringExtra(Intent.EXTRA_TEXT)).isEqualTo(shareMessage);
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForShareTweetScheme_whenWrongScheme_shouldThrowException() throws UrlParseException {
+        Intents.intentForShareTweet(Uri.parse("mailto://tweet?screen_name=SpaceX&tweet_id=596026229536460802"));
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForShareTweetScheme_whenWrongHost_shouldThrowException() throws UrlParseException {
+        Intents.intentForShareTweet(Uri.parse("mopubshare://twat?screen_name=SpaceX&tweet_id=596026229536460802"));
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForShareTweetScheme_whenScreenNameParameterMissing_shouldThrowException() throws UrlParseException {
+        Intents.intentForShareTweet(Uri.parse("mopubshare://tweet?foo=SpaceX&tweet_id=596026229536460802"));
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForShareTweetScheme_whenScreenNameParameterIsEmpty_shouldThrowException() throws UrlParseException {
+        Intents.intentForShareTweet(Uri.parse("mopubshare://tweet?screen_name=&tweet_id=596026229536460802"));
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForShareTweetScheme_whenTweetIdParameterMissing_shouldThrowException() throws UrlParseException {
+        Intents.intentForShareTweet(Uri.parse("mopubshare://tweet?screen_name=SpaceX&bar=596026229536460802"));
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForShareTweetScheme_whenTweetIdParameterIsEmpty_shouldThrowException() throws UrlParseException {
+        Intents.intentForShareTweet(Uri.parse("mopubshare://tweet?screen_name=SpaceX&tweet_id="));
+    }
+
+    @Test
+    public void launchIntentForUserClick_shouldStartActivity() throws Exception {
+        Context context = Robolectric.buildActivity(Activity.class).create().get()
+                .getApplicationContext();
+        Intent intent = mock(Intent.class);
+
+        Intents.launchIntentForUserClick(context, intent, null);
+        final Intent startedActivity = Robolectric.getShadowApplication().peekNextStartedActivity();
+
+        assertThat(startedActivity).isNotNull();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/ManifestUtilsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/ManifestUtilsTest.java
index 0db1bd5d..9bfa41ec 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/util/ManifestUtilsTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/ManifestUtilsTest.java
@@ -1,397 +1,397 @@
-package com.mopub.common.util;
-
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.ActivityInfo;
-import android.content.pm.ApplicationInfo;
-import android.content.pm.ResolveInfo;
-import android.os.Build;
-
-import com.mopub.common.MoPubBrowser;
-import com.mopub.mobileads.MoPubActivity;
-import com.mopub.mobileads.MraidActivity;
-import com.mopub.mobileads.MraidVideoPlayerActivity;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-import org.robolectric.shadows.ShadowLog;
-import org.robolectric.shadows.ShadowToast;
-
-import java.util.List;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.when;
-
-@RunWith(RobolectricTestRunner.class)
-public class ManifestUtilsTest {
-    private Context context;
-    private List<Class<? extends Activity>> requiredWebViewSdkActivities;
-    private List<Class<? extends Activity>> requiredNativeSdkActivities;
-
-    @Mock private ResolveInfo mockResolveInfo;
-
-    @Before
-    public void setUp() throws Exception {
-        context = spy(new Activity());
-
-        requiredWebViewSdkActivities = ManifestUtils.getRequiredWebViewSdkActivities();
-        requiredNativeSdkActivities = ManifestUtils.getRequiredNativeSdkActivities();
-
-        setDebugMode(false);
-    }
-
-    @After
-    public void tearDown() throws Exception {
-        setDebugMode(false);
-        // This may have been set to a mock during testing. Reset this class back to normal
-        ManifestUtils.setFlagCheckUtil(new ManifestUtils.FlagCheckUtil());
-    }
-
-    @Test
-    public void checkWebViewSdkActivitiesDeclared_shouldIncludeFourActivityDeclarations() throws Exception {
-        ShadowLog.setupLogging();
-
-        ManifestUtils.checkWebViewActivitiesDeclared(context);
-
-        assertLogIncludes(
-                "com.mopub.mobileads.MoPubActivity",
-                "com.mopub.mobileads.MraidActivity",
-                "com.mopub.mobileads.MraidVideoPlayerActivity",
-                "com.mopub.common.MoPubBrowser"
-        );
-    }
-
-    @Test
-    public void checkNativeSdkActivitiesDeclared_shouldIncludeOneActivityDeclaration() throws Exception {
-        ShadowLog.setupLogging();
-
-        ManifestUtils.checkNativeActivitiesDeclared(context);
-
-        assertLogIncludes("com.mopub.common.MoPubBrowser");
-        assertLogDoesntInclude(
-                "com.mopub.mobileads.MoPubActivity",
-                "com.mopub.mobileads.MraidActivity",
-                "com.mopub.mobileads.MraidVideoPlayerActivity"
-        );
-    }
-
-    @Test
-    public void displayWarningForMissingActivities_withAllActivitiesDeclared_shouldNotShowLogOrToast() throws Exception {
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidActivity.class), mockResolveInfo);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidVideoPlayerActivity.class), mockResolveInfo);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubBrowser.class), mockResolveInfo);
-
-        ShadowLog.setupLogging();
-        setDebugMode(true);
-
-        ManifestUtils.displayWarningForMissingActivities(context, requiredWebViewSdkActivities);
-
-        assertThat(ShadowToast.getLatestToast()).isNull();
-        assertThat(ShadowLog.getLogs()).isEmpty();
-    }
-
-    @Test
-     public void displayWarningForMissingActivities_withOneMissingActivity_shouldLogOnlyThatOne() throws Exception {
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidActivity.class), mockResolveInfo);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidVideoPlayerActivity.class), mockResolveInfo);
-        // Here, we leave out MoPubBrowser on purpose
-
-        ShadowLog.setupLogging();
-
-        ManifestUtils.displayWarningForMissingActivities(context, requiredWebViewSdkActivities);
-
-        assertLogIncludes("com.mopub.common.MoPubBrowser");
-        assertLogDoesntInclude(
-                "com.mopub.mobileads.MoPubActivity",
-                "com.mopub.mobileads.MraidActivity",
-                "com.mopub.mobileads.MraidVideoPlayerActivity"
-        );
-    }
-
-    @Test
-    public void displayWarningForMissingActivities_withAllMissingActivities_shouldLogMessage() throws Exception {
-        setDebugMode(true);
-        ShadowLog.setupLogging();
-
-        ManifestUtils.displayWarningForMissingActivities(context, requiredWebViewSdkActivities);
-
-        final List<ShadowLog.LogItem> logs = ShadowLog.getLogs();
-
-        assertLogIncludes(
-                "com.mopub.mobileads.MoPubActivity",
-                "com.mopub.mobileads.MraidActivity",
-                "com.mopub.mobileads.MraidVideoPlayerActivity",
-                "com.mopub.common.MoPubBrowser"
-        );
-    }
-
-    @Test
-    public void displayWarningForMissingActivities_withMissingActivities_withDebugTrue_shouldShowToast() throws Exception {
-        setDebugMode(true);
-
-        ManifestUtils.displayWarningForMissingActivities(context, requiredWebViewSdkActivities);
-
-        assertThat(ShadowToast.getLatestToast()).isNotNull();
-        final String toastText = ShadowToast.getTextOfLatestToast();
-        assertThat(toastText).isEqualTo("ERROR: YOUR MOPUB INTEGRATION IS INCOMPLETE.\nCheck logcat and update your AndroidManifest.xml with the correct activities and configuration.");
-    }
-
-    @Test
-    public void displayWarningForMissingActivities_withMissingActivities_withDebugFalse_shouldNotShowToast() throws Exception {
-        setDebugMode(false);
-
-        ManifestUtils.displayWarningForMissingActivities(context, requiredWebViewSdkActivities);
-
-        assertThat(ShadowToast.getLatestToast()).isNull();
-    }
-
-    @SuppressWarnings("unchecked")
-    @TargetApi(13)
-    @Test
-    public void displayWarningForMisconfiguredActivities_withAllActivitiesConfigured_shouldNotLogOrShowToast() throws Exception {
-        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN))).thenReturn(true);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(true);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(true);
-        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
-
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidActivity.class), mockResolveInfo);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidVideoPlayerActivity.class), mockResolveInfo);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubBrowser.class), mockResolveInfo);
-
-        ShadowLog.setupLogging();
-        setDebugMode(true);
-
-        ManifestUtils.displayWarningForMisconfiguredActivities(context, requiredWebViewSdkActivities);
-
-        assertThat(ShadowToast.getLatestToast()).isNull();
-        assertThat(ShadowLog.getLogs()).isEmpty();
-    }
-
-    @SuppressWarnings("unchecked")
-    @TargetApi(13)
-    @Test
-    public void displayWarningForMisconfiguredActivities_withOneMisconfiguredActivity_shouldLogOnlyThatOne() throws Exception {
-        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
-
-        // Misconfigure the first activity; only return false if the activity is MoPubActivity
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                Object[] args = invocationOnMock.getArguments();
-                return MoPubActivity.class != args[0];
-            }
-        }).when(mockActivitiyConfigCheck).hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN));
-
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(true);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(true);
-        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
-
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidActivity.class), mockResolveInfo);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidVideoPlayerActivity.class), mockResolveInfo);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubBrowser.class), mockResolveInfo);
-
-        ShadowLog.setupLogging();
-
-        ManifestUtils.displayWarningForMisconfiguredActivities(context, requiredWebViewSdkActivities);
-
-        assertLogIncludes("com.mopub.mobileads.MoPubActivity");
-        assertLogIncludes("The android:configChanges param for activity " + MoPubActivity.class.getName() + " must include keyboardHidden.");
-        assertLogDoesntInclude(
-                "com.mopub.mobileads.MraidActivity",
-                "com.mopub.mobileads.MraidVideoPlayerActivity",
-                "com.mopub.common.MoPubBrowser"
-        );
-        assertLogDoesntInclude("The android:configChanges param for activity " + MoPubActivity.class.getName() + " must include orientation.");
-        assertLogDoesntInclude("The android:configChanges param for activity " + MoPubActivity.class.getName() + " must include screenSize.");
-    }
-
-    @SuppressWarnings("unchecked")
-    @TargetApi(13)
-    @Test
-    public void displayWarningForMisconfiguredActivities_withOneMisconfiguredActivity_withMissingAllConfigChangesValues_shouldLogAllConfigChangesValues() throws Exception {
-        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
-
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN))).thenReturn(false);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(false);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(false);
-        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
-
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
-
-        ShadowLog.setupLogging();
-
-        ManifestUtils.displayWarningForMisconfiguredActivities(context, requiredWebViewSdkActivities);
-
-        assertLogIncludes("The android:configChanges param for activity " + MoPubActivity.class.getName() + " must include keyboardHidden.");
-        assertLogIncludes("The android:configChanges param for activity " + MoPubActivity.class.getName() + " must include orientation.");
-        assertLogIncludes("The android:configChanges param for activity " + MoPubActivity.class.getName() + " must include screenSize.");
-    }
-
-    @SuppressWarnings("unchecked")
-    @Config(reportSdk = Build.VERSION_CODES.HONEYCOMB_MR1)
-    @TargetApi(13)
-    @Test
-    public void displayWarningForMisconfiguredActivities_withMissingScreenSize_withApiLessThan13_shouldNotLogOrShowToast() throws Exception {
-        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN))).thenReturn(true);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(true);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(false);
-        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
-
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
-
-        ShadowLog.setupLogging();
-        setDebugMode(true);
-
-        ManifestUtils.displayWarningForMisconfiguredActivities(context, requiredWebViewSdkActivities);
-
-        assertThat(ShadowToast.getLatestToast()).isNull();
-        assertThat(ShadowLog.getLogs()).isEmpty();
-    }
-
-    @SuppressWarnings("unchecked")
-    @TargetApi(13)
-    @Test
-    public void displayWarningForMisconfiguredActivities_withMissingScreenSize_withTargetApiLessThan13_shouldNotLogOrShowToast() throws Exception {
-        // Set target API to < 13
-        ApplicationInfo applicationInfo = context.getApplicationInfo();
-        applicationInfo.targetSdkVersion = Build.VERSION_CODES.HONEYCOMB_MR1;
-        when(context.getApplicationInfo()).thenReturn(applicationInfo);
-
-        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN))).thenReturn(true);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(true);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(false);
-        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
-
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
-
-        ShadowLog.setupLogging();
-        setDebugMode(true);
-
-        ManifestUtils.displayWarningForMisconfiguredActivities(context, requiredWebViewSdkActivities);
-
-        assertThat(ShadowToast.getLatestToast()).isNull();
-        assertThat(ShadowLog.getLogs()).isEmpty();
-    }
-
-    @SuppressWarnings("unchecked")
-    @TargetApi(13)
-    @Test
-    public void displayWarningForMisconfiguredActivities_withMisconfiguredActivities_withDebugTrue_shouldShowToast() throws Exception {
-        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN))).thenReturn(false);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(false);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(false);
-        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
-
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
-
-        setDebugMode(true);
-
-        ManifestUtils.displayWarningForMisconfiguredActivities(context, requiredWebViewSdkActivities);
-
-        assertThat(ShadowToast.getLatestToast()).isNotNull();
-        final String toastText = ShadowToast.getTextOfLatestToast();
-        assertThat(toastText).isEqualTo("ERROR: YOUR MOPUB INTEGRATION IS INCOMPLETE.\nCheck logcat and update your AndroidManifest.xml with the correct activities and configuration.");
-    }
-
-    @SuppressWarnings("unchecked")
-    @TargetApi(13)
-    @Test
-    public void displayWarningForMisconfiguredActivities_withMisconfiguredActivities_withDebugFalse_shouldNotShowToast() throws Exception {
-        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN))).thenReturn(false);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(false);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(false);
-        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
-
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
-
-        setDebugMode(false);
-
-        ManifestUtils.displayWarningForMissingActivities(context, requiredWebViewSdkActivities);
-
-        assertThat(ShadowToast.getLatestToast()).isNull();
-    }
-
-    @Test
-    public void isDebuggable_whenApplicationIsDebuggable_shouldReturnTrue() throws Exception {
-        setDebugMode(true);
-
-        assertThat(ManifestUtils.isDebuggable(context)).isTrue();
-    }
-
-    @Test
-    public void isDebuggable_whenApplicationIsNotDebuggable_shouldReturnFalse() throws Exception {
-        setDebugMode(false);
-
-        assertThat(ManifestUtils.isDebuggable(context)).isFalse();
-    }
-
-    @SuppressWarnings("unchecked")
-    @Test
-    public void getRequiredWebViewSdkActivities_shouldIncludeRequiredActivities() throws Exception {
-        assertThat(requiredWebViewSdkActivities).containsOnly(
-                MoPubActivity.class,
-                MraidActivity.class,
-                MraidVideoPlayerActivity.class,
-                MoPubBrowser.class
-        );
-    }
-
-    @SuppressWarnings("unchecked")
-    @Test
-    public void getRequiredNativeSdkActivities_shouldIncludeRequiredActivities() throws Exception {
-        assertThat(requiredNativeSdkActivities).containsOnly(
-                MoPubBrowser.class
-        );
-    }
-
-    private void setDebugMode(boolean enabled) {
-        final ApplicationInfo applicationInfo = context.getApplicationInfo();
-
-        if (enabled) {
-            applicationInfo.flags |= ApplicationInfo.FLAG_DEBUGGABLE;
-        } else {
-            applicationInfo.flags &= ~ApplicationInfo.FLAG_DEBUGGABLE;
-        }
-
-        when(context.getApplicationInfo()).thenReturn(applicationInfo);
-    }
-
-    private void assertLogIncludes(final String... messages) {
-        final String logText = ShadowLog.getLogs().get(0).msg;
-        for (final String message : messages) {
-            assertThat(logText).containsOnlyOnce(message);
-        }
-    }
-
-    private void assertLogDoesntInclude(final String... messages) {
-        final String logText = ShadowLog.getLogs().get(0).msg;
-        for (final String message : messages) {
-            assertThat(logText).doesNotContain(message);
-        }
-    }
-}
+package com.mopub.common.util;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.ActivityInfo;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.ResolveInfo;
+import android.os.Build;
+
+import com.mopub.common.MoPubBrowser;
+import com.mopub.mobileads.MoPubActivity;
+import com.mopub.mobileads.MraidActivity;
+import com.mopub.mobileads.MraidVideoPlayerActivity;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLog;
+import org.robolectric.shadows.ShadowToast;
+
+import java.util.List;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
+
+@RunWith(RobolectricTestRunner.class)
+public class ManifestUtilsTest {
+    private Context context;
+    private List<Class<? extends Activity>> requiredWebViewSdkActivities;
+    private List<Class<? extends Activity>> requiredNativeSdkActivities;
+
+    @Mock private ResolveInfo mockResolveInfo;
+
+    @Before
+    public void setUp() throws Exception {
+        context = spy(Robolectric.buildActivity(Activity.class).create().get());
+
+        requiredWebViewSdkActivities = ManifestUtils.getRequiredWebViewSdkActivities();
+        requiredNativeSdkActivities = ManifestUtils.getRequiredNativeSdkActivities();
+
+        setDebugMode(false);
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        setDebugMode(false);
+        // This may have been set to a mock during testing. Reset this class back to normal
+        ManifestUtils.setFlagCheckUtil(new ManifestUtils.FlagCheckUtil());
+    }
+
+    @Test
+    public void checkWebViewSdkActivitiesDeclared_shouldIncludeFourActivityDeclarations() throws Exception {
+        ShadowLog.setupLogging();
+
+        ManifestUtils.checkWebViewActivitiesDeclared(context);
+
+        assertLogIncludes(
+                "com.mopub.mobileads.MoPubActivity",
+                "com.mopub.mobileads.MraidActivity",
+                "com.mopub.mobileads.MraidVideoPlayerActivity",
+                "com.mopub.common.MoPubBrowser"
+        );
+    }
+
+    @Test
+    public void checkNativeSdkActivitiesDeclared_shouldIncludeOneActivityDeclaration() throws Exception {
+        ShadowLog.setupLogging();
+
+        ManifestUtils.checkNativeActivitiesDeclared(context);
+
+        assertLogIncludes("com.mopub.common.MoPubBrowser");
+        assertLogDoesntInclude(
+                "com.mopub.mobileads.MoPubActivity",
+                "com.mopub.mobileads.MraidActivity",
+                "com.mopub.mobileads.MraidVideoPlayerActivity"
+        );
+    }
+
+    @Test
+    public void displayWarningForMissingActivities_withAllActivitiesDeclared_shouldNotShowLogOrToast() throws Exception {
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidActivity.class), mockResolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidVideoPlayerActivity.class), mockResolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubBrowser.class), mockResolveInfo);
+
+        ShadowLog.setupLogging();
+        setDebugMode(true);
+
+        ManifestUtils.displayWarningForMissingActivities(context, requiredWebViewSdkActivities);
+
+        assertThat(ShadowToast.getLatestToast()).isNull();
+        assertThat(ShadowLog.getLogs()).isEmpty();
+    }
+
+    @Test
+     public void displayWarningForMissingActivities_withOneMissingActivity_shouldLogOnlyThatOne() throws Exception {
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidActivity.class), mockResolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidVideoPlayerActivity.class), mockResolveInfo);
+        // Here, we leave out MoPubBrowser on purpose
+
+        ShadowLog.setupLogging();
+
+        ManifestUtils.displayWarningForMissingActivities(context, requiredWebViewSdkActivities);
+
+        assertLogIncludes("com.mopub.common.MoPubBrowser");
+        assertLogDoesntInclude(
+                "com.mopub.mobileads.MoPubActivity",
+                "com.mopub.mobileads.MraidActivity",
+                "com.mopub.mobileads.MraidVideoPlayerActivity"
+        );
+    }
+
+    @Test
+    public void displayWarningForMissingActivities_withAllMissingActivities_shouldLogMessage() throws Exception {
+        setDebugMode(true);
+        ShadowLog.setupLogging();
+
+        ManifestUtils.displayWarningForMissingActivities(context, requiredWebViewSdkActivities);
+
+        final List<ShadowLog.LogItem> logs = ShadowLog.getLogs();
+
+        assertLogIncludes(
+                "com.mopub.mobileads.MoPubActivity",
+                "com.mopub.mobileads.MraidActivity",
+                "com.mopub.mobileads.MraidVideoPlayerActivity",
+                "com.mopub.common.MoPubBrowser"
+        );
+    }
+
+    @Test
+    public void displayWarningForMissingActivities_withMissingActivities_withDebugTrue_shouldShowToast() throws Exception {
+        setDebugMode(true);
+
+        ManifestUtils.displayWarningForMissingActivities(context, requiredWebViewSdkActivities);
+
+        assertThat(ShadowToast.getLatestToast()).isNotNull();
+        final String toastText = ShadowToast.getTextOfLatestToast();
+        assertThat(toastText).isEqualTo("ERROR: YOUR MOPUB INTEGRATION IS INCOMPLETE.\nCheck logcat and update your AndroidManifest.xml with the correct activities and configuration.");
+    }
+
+    @Test
+    public void displayWarningForMissingActivities_withMissingActivities_withDebugFalse_shouldNotShowToast() throws Exception {
+        setDebugMode(false);
+
+        ManifestUtils.displayWarningForMissingActivities(context, requiredWebViewSdkActivities);
+
+        assertThat(ShadowToast.getLatestToast()).isNull();
+    }
+
+    @SuppressWarnings("unchecked")
+    @TargetApi(13)
+    @Test
+    public void displayWarningForMisconfiguredActivities_withAllActivitiesConfigured_shouldNotLogOrShowToast() throws Exception {
+        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN))).thenReturn(true);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(true);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(true);
+        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
+
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidActivity.class), mockResolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidVideoPlayerActivity.class), mockResolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubBrowser.class), mockResolveInfo);
+
+        ShadowLog.setupLogging();
+        setDebugMode(true);
+
+        ManifestUtils.displayWarningForMisconfiguredActivities(context, requiredWebViewSdkActivities);
+
+        assertThat(ShadowToast.getLatestToast()).isNull();
+        assertThat(ShadowLog.getLogs()).isEmpty();
+    }
+
+    @SuppressWarnings("unchecked")
+    @TargetApi(13)
+    @Test
+    public void displayWarningForMisconfiguredActivities_withOneMisconfiguredActivity_shouldLogOnlyThatOne() throws Exception {
+        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
+
+        // Misconfigure the first activity; only return false if the activity is MoPubActivity
+        doAnswer(new Answer() {
+            @Override
+            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+                Object[] args = invocationOnMock.getArguments();
+                return MoPubActivity.class != args[0];
+            }
+        }).when(mockActivitiyConfigCheck).hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN));
+
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(true);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(true);
+        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
+
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidActivity.class), mockResolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidVideoPlayerActivity.class), mockResolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubBrowser.class), mockResolveInfo);
+
+        ShadowLog.setupLogging();
+
+        ManifestUtils.displayWarningForMisconfiguredActivities(context, requiredWebViewSdkActivities);
+
+        assertLogIncludes("com.mopub.mobileads.MoPubActivity");
+        assertLogIncludes("The android:configChanges param for activity " + MoPubActivity.class.getName() + " must include keyboardHidden.");
+        assertLogDoesntInclude(
+                "com.mopub.mobileads.MraidActivity",
+                "com.mopub.mobileads.MraidVideoPlayerActivity",
+                "com.mopub.common.MoPubBrowser"
+        );
+        assertLogDoesntInclude("The android:configChanges param for activity " + MoPubActivity.class.getName() + " must include orientation.");
+        assertLogDoesntInclude("The android:configChanges param for activity " + MoPubActivity.class.getName() + " must include screenSize.");
+    }
+
+    @SuppressWarnings("unchecked")
+    @TargetApi(13)
+    @Test
+    public void displayWarningForMisconfiguredActivities_withOneMisconfiguredActivity_withMissingAllConfigChangesValues_shouldLogAllConfigChangesValues() throws Exception {
+        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
+
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN))).thenReturn(false);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(false);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(false);
+        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
+
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+
+        ShadowLog.setupLogging();
+
+        ManifestUtils.displayWarningForMisconfiguredActivities(context, requiredWebViewSdkActivities);
+
+        assertLogIncludes("The android:configChanges param for activity " + MoPubActivity.class.getName() + " must include keyboardHidden.");
+        assertLogIncludes("The android:configChanges param for activity " + MoPubActivity.class.getName() + " must include orientation.");
+        assertLogIncludes("The android:configChanges param for activity " + MoPubActivity.class.getName() + " must include screenSize.");
+    }
+
+    @SuppressWarnings("unchecked")
+    @Config(reportSdk = Build.VERSION_CODES.HONEYCOMB_MR1)
+    @TargetApi(13)
+    @Test
+    public void displayWarningForMisconfiguredActivities_withMissingScreenSize_withApiLessThan13_shouldNotLogOrShowToast() throws Exception {
+        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN))).thenReturn(true);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(true);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(false);
+        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
+
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+
+        ShadowLog.setupLogging();
+        setDebugMode(true);
+
+        ManifestUtils.displayWarningForMisconfiguredActivities(context, requiredWebViewSdkActivities);
+
+        assertThat(ShadowToast.getLatestToast()).isNull();
+        assertThat(ShadowLog.getLogs()).isEmpty();
+    }
+
+    @SuppressWarnings("unchecked")
+    @TargetApi(13)
+    @Test
+    public void displayWarningForMisconfiguredActivities_withMissingScreenSize_withTargetApiLessThan13_shouldNotLogOrShowToast() throws Exception {
+        // Set target API to < 13
+        ApplicationInfo applicationInfo = context.getApplicationInfo();
+        applicationInfo.targetSdkVersion = Build.VERSION_CODES.HONEYCOMB_MR1;
+        when(context.getApplicationInfo()).thenReturn(applicationInfo);
+
+        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN))).thenReturn(true);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(true);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(false);
+        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
+
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+
+        ShadowLog.setupLogging();
+        setDebugMode(true);
+
+        ManifestUtils.displayWarningForMisconfiguredActivities(context, requiredWebViewSdkActivities);
+
+        assertThat(ShadowToast.getLatestToast()).isNull();
+        assertThat(ShadowLog.getLogs()).isEmpty();
+    }
+
+    @SuppressWarnings("unchecked")
+    @TargetApi(13)
+    @Test
+    public void displayWarningForMisconfiguredActivities_withMisconfiguredActivities_withDebugTrue_shouldShowToast() throws Exception {
+        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN))).thenReturn(false);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(false);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(false);
+        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
+
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+
+        setDebugMode(true);
+
+        ManifestUtils.displayWarningForMisconfiguredActivities(context, requiredWebViewSdkActivities);
+
+        assertThat(ShadowToast.getLatestToast()).isNotNull();
+        final String toastText = ShadowToast.getTextOfLatestToast();
+        assertThat(toastText).isEqualTo("ERROR: YOUR MOPUB INTEGRATION IS INCOMPLETE.\nCheck logcat and update your AndroidManifest.xml with the correct activities and configuration.");
+    }
+
+    @SuppressWarnings("unchecked")
+    @TargetApi(13)
+    @Test
+    public void displayWarningForMisconfiguredActivities_withMisconfiguredActivities_withDebugFalse_shouldNotShowToast() throws Exception {
+        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN))).thenReturn(false);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(false);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(false);
+        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
+
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+
+        setDebugMode(false);
+
+        ManifestUtils.displayWarningForMissingActivities(context, requiredWebViewSdkActivities);
+
+        assertThat(ShadowToast.getLatestToast()).isNull();
+    }
+
+    @Test
+    public void isDebuggable_whenApplicationIsDebuggable_shouldReturnTrue() throws Exception {
+        setDebugMode(true);
+
+        assertThat(ManifestUtils.isDebuggable(context)).isTrue();
+    }
+
+    @Test
+    public void isDebuggable_whenApplicationIsNotDebuggable_shouldReturnFalse() throws Exception {
+        setDebugMode(false);
+
+        assertThat(ManifestUtils.isDebuggable(context)).isFalse();
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void getRequiredWebViewSdkActivities_shouldIncludeRequiredActivities() throws Exception {
+        assertThat(requiredWebViewSdkActivities).containsOnly(
+                MoPubActivity.class,
+                MraidActivity.class,
+                MraidVideoPlayerActivity.class,
+                MoPubBrowser.class
+        );
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void getRequiredNativeSdkActivities_shouldIncludeRequiredActivities() throws Exception {
+        assertThat(requiredNativeSdkActivities).containsOnly(
+                MoPubBrowser.class
+        );
+    }
+
+    private void setDebugMode(boolean enabled) {
+        final ApplicationInfo applicationInfo = context.getApplicationInfo();
+
+        if (enabled) {
+            applicationInfo.flags |= ApplicationInfo.FLAG_DEBUGGABLE;
+        } else {
+            applicationInfo.flags &= ~ApplicationInfo.FLAG_DEBUGGABLE;
+        }
+
+        when(context.getApplicationInfo()).thenReturn(applicationInfo);
+    }
+
+    private void assertLogIncludes(final String... messages) {
+        final String logText = ShadowLog.getLogs().get(0).msg;
+        for (final String message : messages) {
+            assertThat(logText).containsOnlyOnce(message);
+        }
+    }
+
+    private void assertLogDoesntInclude(final String... messages) {
+        final String logText = ShadowLog.getLogs().get(0).msg;
+        for (final String message : messages) {
+            assertThat(logText).doesNotContain(message);
+        }
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/ReflectionTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/ReflectionTest.java
index 77337dcd..b36ae026 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/util/ReflectionTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/ReflectionTest.java
@@ -1,160 +1,161 @@
-package com.mopub.common.util;
-
-import android.app.Activity;
-import android.view.View;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-
-import static com.mopub.common.util.Reflection.MethodBuilder;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.fest.assertions.api.Assertions.fail;
-
-
-@RunWith(RobolectricTestRunner.class)
-public class ReflectionTest {
-    private Activity activity;
-    private View view;
-    private String string;
-    private MethodBuilder methodBuilder;
-
-    @Before
-    public void setup(){
-        activity = new Activity();
-        view = new View(activity);
-        string = "goat";
-    }
-
-    @Test
-    public void execute_withCorrectVoidMethodThatHasNoParameters_shouldPass() throws Exception {
-        methodBuilder = new MethodBuilder(activity, "finish");
-
-        methodBuilder.execute();
-
-        // pass
-    }
-
-    @Test
-    public void execute_withCorrectNonVoidMethodThatHasNoParameters_shouldPass() throws Exception {
-        methodBuilder = new MethodBuilder(string, "length");
-
-        int result = (Integer)methodBuilder.execute();
-
-        assertThat(result).isEqualTo(4);
-    }
-
-    @Test
-    public void execute_withCorrectVoidMethodThatHasParameters_shouldPass() throws Exception {
-        methodBuilder = new MethodBuilder(view, "buildDrawingCache");
-        methodBuilder.addParam(boolean.class, true);
-
-        methodBuilder.execute();
-
-        // pass
-    }
-
-    @Test
-    public void execute_withCorrectNonVoidMethodThatHasParameters_shouldPass() throws Exception {
-        methodBuilder = new MethodBuilder(string, "charAt");
-        methodBuilder.addParam(int.class, 2);
-
-        Object result = methodBuilder.execute();
-
-        assertThat(result).isEqualTo('a');
-    }
-
-    @Test
-    public void execute_withNoSuchMethod_shouldThrowException() throws Exception {
-        methodBuilder = new MethodBuilder(activity, "noSuchMethod");
-
-        try {
-            methodBuilder.execute();
-            fail("Should fail because method did not exist");
-        } catch (Exception e) {
-            // pass
-        }
-    }
-
-    @Test
-    public void execute_withCorrectVoidMethodThatHasParameters_withMissingParameters_shouldThrowException() throws Exception {
-        methodBuilder = new MethodBuilder(activity, "finishActivity");
-        // forget to add int requestCode parameter
-
-        try {
-            methodBuilder.execute();
-            fail("Should fail because we did not supply all the parameters");
-        } catch (Exception e) {
-            // pass
-        }
-    }
-
-    @Test
-    public void execute_withExistingMethodButIncorrectParameterTypes_shouldThrowException() throws Exception {
-        methodBuilder = new MethodBuilder(string, "concat");
-        methodBuilder.addParam(Object.class, "other");
-
-        try {
-            methodBuilder.execute();
-            fail("Should fail because there is no string.concat(Object) method");
-        } catch (Exception e) {
-            // pass
-        }
-    }
-
-    @Test
-    public void execute_withExistingMethodButSubclassedParameter_shouldPass() throws Exception {
-        methodBuilder = new MethodBuilder(string, "equals");
-        methodBuilder.addParam(Object.class, "cheese");
-
-        boolean result = (Boolean) methodBuilder.execute();
-
-        assertThat(result).isFalse();
-    }
-
-    @Test
-    public void execute_withCorrectMethodThatHasParameters_withIncorrectOrderingOfParameters_shouldThrowException() throws Exception {
-        methodBuilder = new MethodBuilder(string, "indexOf");
-        methodBuilder.addParam(int.class, 2);
-        methodBuilder.addParam(String.class, "g");
-
-        try {
-            methodBuilder.execute();
-            fail("Should fail because we expected string.indexOf(String, int) instead of string.indexOf(int, String)");
-        } catch (Exception e) {
-            // pass
-        }
-    }
-
-    @Test
-    public void execute_withNullInstanceOnInstanceMethod_shouldThrowException() throws Exception {
-        methodBuilder = new MethodBuilder(null, "length");
-
-        try {
-            methodBuilder.execute();
-            fail("Should fail because we are giving a null instance");
-        } catch (Exception e) {
-            // pass
-        }
-    }
-
-    @Test
-    public void execute_withStaticMethod_shouldPass() throws Exception {
-        methodBuilder = new MethodBuilder(null, "valueOf").setStatic(String.class).addParam(int.class, 20);
-
-        assertThat(methodBuilder.execute()).isEqualTo("20");
-    }
-
-    @Test
-    public void execute_withAccessibility_shouldRunPrivateMethods() throws Exception {
-        methodBuilder = new MethodBuilder(string, "indexOfSupplementary");
-        methodBuilder.addParam(int.class, (int)'a');
-        methodBuilder.addParam(int.class, 0);
-        methodBuilder.setAccessible();
-
-        int result = (Integer) methodBuilder.execute();
-
-        assertThat(result).isEqualTo(-1);
-    }
-}
+package com.mopub.common.util;
+
+import android.app.Activity;
+import android.view.View;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+
+import static com.mopub.common.util.Reflection.MethodBuilder;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.fest.assertions.api.Assertions.fail;
+
+
+@RunWith(RobolectricTestRunner.class)
+public class ReflectionTest {
+    private Activity activity;
+    private View view;
+    private String string;
+    private MethodBuilder methodBuilder;
+
+    @Before
+    public void setup(){
+        activity = Robolectric.buildActivity(Activity.class).create().get();
+        view = new View(activity);
+        string = "goat";
+    }
+
+    @Test
+    public void execute_withCorrectVoidMethodThatHasNoParameters_shouldPass() throws Exception {
+        methodBuilder = new MethodBuilder(activity, "finish");
+
+        methodBuilder.execute();
+
+        // pass
+    }
+
+    @Test
+    public void execute_withCorrectNonVoidMethodThatHasNoParameters_shouldPass() throws Exception {
+        methodBuilder = new MethodBuilder(string, "length");
+
+        int result = (Integer)methodBuilder.execute();
+
+        assertThat(result).isEqualTo(4);
+    }
+
+    @Test
+    public void execute_withCorrectVoidMethodThatHasParameters_shouldPass() throws Exception {
+        methodBuilder = new MethodBuilder(view, "buildDrawingCache");
+        methodBuilder.addParam(boolean.class, true);
+
+        methodBuilder.execute();
+
+        // pass
+    }
+
+    @Test
+    public void execute_withCorrectNonVoidMethodThatHasParameters_shouldPass() throws Exception {
+        methodBuilder = new MethodBuilder(string, "charAt");
+        methodBuilder.addParam(int.class, 2);
+
+        Object result = methodBuilder.execute();
+
+        assertThat(result).isEqualTo('a');
+    }
+
+    @Test
+    public void execute_withNoSuchMethod_shouldThrowException() throws Exception {
+        methodBuilder = new MethodBuilder(activity, "noSuchMethod");
+
+        try {
+            methodBuilder.execute();
+            fail("Should fail because method did not exist");
+        } catch (Exception e) {
+            // pass
+        }
+    }
+
+    @Test
+    public void execute_withCorrectVoidMethodThatHasParameters_withMissingParameters_shouldThrowException() throws Exception {
+        methodBuilder = new MethodBuilder(activity, "finishActivity");
+        // forget to add int requestCode parameter
+
+        try {
+            methodBuilder.execute();
+            fail("Should fail because we did not supply all the parameters");
+        } catch (Exception e) {
+            // pass
+        }
+    }
+
+    @Test
+    public void execute_withExistingMethodButIncorrectParameterTypes_shouldThrowException() throws Exception {
+        methodBuilder = new MethodBuilder(string, "concat");
+        methodBuilder.addParam(Object.class, "other");
+
+        try {
+            methodBuilder.execute();
+            fail("Should fail because there is no string.concat(Object) method");
+        } catch (Exception e) {
+            // pass
+        }
+    }
+
+    @Test
+    public void execute_withExistingMethodButSubclassedParameter_shouldPass() throws Exception {
+        methodBuilder = new MethodBuilder(string, "equals");
+        methodBuilder.addParam(Object.class, "cheese");
+
+        boolean result = (Boolean) methodBuilder.execute();
+
+        assertThat(result).isFalse();
+    }
+
+    @Test
+    public void execute_withCorrectMethodThatHasParameters_withIncorrectOrderingOfParameters_shouldThrowException() throws Exception {
+        methodBuilder = new MethodBuilder(string, "indexOf");
+        methodBuilder.addParam(int.class, 2);
+        methodBuilder.addParam(String.class, "g");
+
+        try {
+            methodBuilder.execute();
+            fail("Should fail because we expected string.indexOf(String, int) instead of string.indexOf(int, String)");
+        } catch (Exception e) {
+            // pass
+        }
+    }
+
+    @Test
+    public void execute_withNullInstanceOnInstanceMethod_shouldThrowException() throws Exception {
+        methodBuilder = new MethodBuilder(null, "length");
+
+        try {
+            methodBuilder.execute();
+            fail("Should fail because we are giving a null instance");
+        } catch (Exception e) {
+            // pass
+        }
+    }
+
+    @Test
+    public void execute_withStaticMethod_shouldPass() throws Exception {
+        methodBuilder = new MethodBuilder(null, "valueOf").setStatic(String.class).addParam(int.class, 20);
+
+        assertThat(methodBuilder.execute()).isEqualTo("20");
+    }
+
+    @Test
+    public void execute_withAccessibility_shouldRunPrivateMethods() throws Exception {
+        methodBuilder = new MethodBuilder(string, "indexOfSupplementary");
+        methodBuilder.addParam(int.class, (int)'a');
+        methodBuilder.addParam(int.class, 0);
+        methodBuilder.setAccessible();
+
+        int result = (Integer) methodBuilder.execute();
+
+        assertThat(result).isEqualTo(-1);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/ViewsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/ViewsTest.java
index 13c32626..48fa3198 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/util/ViewsTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/ViewsTest.java
@@ -1,78 +1,79 @@
-package com.mopub.common.util;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.res.Resources;
-import android.view.View;
-import android.widget.RelativeLayout;
-import android.widget.TextView;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-
-@RunWith(RobolectricTestRunner.class)
-public class ViewsTest {
-    private Context context;
-    private View subject;
-    private RelativeLayout parent;
-    private Activity testActivity;
-    private Resources testResources;
-
-    @Before
-    public void setup() {
-        context = new Activity();
-        subject = new View(context);
-        parent = new RelativeLayout(context);
-
-    }
-
-    @Test
-    public void removeFromParent_shouldRemoveViewFromParent() throws Exception {
-        assertThat(parent.getChildCount()).isEqualTo(0);
-
-        parent.addView(subject);
-        assertThat(parent.getChildCount()).isEqualTo(1);
-        assertThat(subject.getParent()).isEqualTo(parent);
-
-        Views.removeFromParent(subject);
-
-        assertThat(parent.getChildCount()).isEqualTo(0);
-        assertThat(subject.getParent()).isNull();
-    }
-
-    @Test
-    public void removeFromParent_withMultipleChildren_shouldRemoveCorrectChild() throws Exception {
-        parent.addView(new TextView(context));
-
-        assertThat(parent.getChildCount()).isEqualTo(1);
-
-        parent.addView(subject);
-
-        assertThat(parent.getChildCount()).isEqualTo(2);
-
-        Views.removeFromParent(subject);
-        assertThat(parent.getChildCount()).isEqualTo(1);
-
-        assertThat(parent.getChildAt(0)).isInstanceOf(TextView.class);
-    }
-
-    @Test
-    public void removeFromParent_whenViewIsNull_shouldPass() throws Exception {
-        Views.removeFromParent(null);
-
-        // pass
-    }
-
-    @Test
-    public void removeFromParent_whenViewsParentIsNull_shouldPass() throws Exception {
-        assertThat(subject.getParent()).isNull();
-
-        Views.removeFromParent(subject);
-
-        // pass
-    }
-}
+package com.mopub.common.util;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.res.Resources;
+import android.view.View;
+import android.widget.RelativeLayout;
+import android.widget.TextView;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(RobolectricTestRunner.class)
+public class ViewsTest {
+    private Context context;
+    private View subject;
+    private RelativeLayout parent;
+    private Activity testActivity;
+    private Resources testResources;
+
+    @Before
+    public void setup() {
+        context = Robolectric.buildActivity(Activity.class).create().get();
+        subject = new View(context);
+        parent = new RelativeLayout(context);
+
+    }
+
+    @Test
+    public void removeFromParent_shouldRemoveViewFromParent() throws Exception {
+        assertThat(parent.getChildCount()).isEqualTo(0);
+
+        parent.addView(subject);
+        assertThat(parent.getChildCount()).isEqualTo(1);
+        assertThat(subject.getParent()).isEqualTo(parent);
+
+        Views.removeFromParent(subject);
+
+        assertThat(parent.getChildCount()).isEqualTo(0);
+        assertThat(subject.getParent()).isNull();
+    }
+
+    @Test
+    public void removeFromParent_withMultipleChildren_shouldRemoveCorrectChild() throws Exception {
+        parent.addView(new TextView(context));
+
+        assertThat(parent.getChildCount()).isEqualTo(1);
+
+        parent.addView(subject);
+
+        assertThat(parent.getChildCount()).isEqualTo(2);
+
+        Views.removeFromParent(subject);
+        assertThat(parent.getChildCount()).isEqualTo(1);
+
+        assertThat(parent.getChildAt(0)).isInstanceOf(TextView.class);
+    }
+
+    @Test
+    public void removeFromParent_whenViewIsNull_shouldPass() throws Exception {
+        Views.removeFromParent(null);
+
+        // pass
+    }
+
+    @Test
+    public void removeFromParent_whenViewsParentIsNull_shouldPass() throws Exception {
+        assertThat(subject.getParent()).isNull();
+
+        Views.removeFromParent(subject);
+
+        // pass
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertReporterTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertReporterTest.java
index 0770739c..d199d9f8 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertReporterTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertReporterTest.java
@@ -1,250 +1,250 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.graphics.Bitmap;
-import android.net.Uri;
-import android.view.View;
-import android.widget.TextView;
-
-import com.mopub.common.AdReport;
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.test.support.TestDateAndTime;
-
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.robolectric.Robolectric;
-
-import java.io.File;
-import java.io.FileOutputStream;
-import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.Locale;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.stub;
-import static org.mockito.Mockito.verify;
-
-@RunWith(SdkTestRunner.class)
-public class AdAlertReporterTest {
-    private final static String EMAIL_ADDRESS = "creative-review@mopub.com";
-    private AdAlertReporter subject;
-    @Mock
-    private AdReport mockAdReport;
-    @Mock
-    private Context mockContext;
-    @Mock
-    private View mockView;
-    private Intent emailIntent;
-    private Bitmap bitmap;
-    private ArrayList<Uri> emailAttachments;
-    private Date now;
-
-    @Before
-    public void setup() {
-        bitmap = Bitmap.createBitmap(10, 10, Bitmap.Config.ARGB_8888);
-
-        stub(mockView.getRootView()).toReturn(mockView);
-        stub(mockView.getDrawingCache()).toReturn(bitmap);
-
-        now = new Date();
-        TestDateAndTime.getInstance().setNow(now);
-    }
-
-    @Test
-    public void constructor_shouldCreateSendToIntentWithEmailAddress() throws Exception {
-        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
-        emailIntent = subject.getEmailIntent();
-
-        assertThat(emailIntent.getAction()).isEqualTo(Intent.ACTION_SEND_MULTIPLE);
-        assertThat(emailIntent.getType()).isEqualTo("plain/text");
-        assertThat(emailIntent.getDataString()).isEqualTo("mailto:");
-        assertThat(emailIntent.getStringArrayExtra(Intent.EXTRA_EMAIL)[0]).isEqualTo(EMAIL_ADDRESS);
-    }
-
-    @Test
-    public void constructor_shouldCreateIntentWithDatestampInSubject() throws Exception {
-        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
-        emailIntent = subject.getEmailIntent();
-
-        String emailSubject = emailIntent.getStringExtra(Intent.EXTRA_SUBJECT);
-        String subjectParts[] = emailSubject.split(" - ");
-
-        String title = subjectParts[0];
-        assertThat(title).isEqualTo("New creative violation report");
-
-        String dateTimeString = subjectParts[1];
-        SimpleDateFormat dateFormat = new SimpleDateFormat("M/d/yy hh:mm:ss a z", Locale.US);
-
-        Date date = dateFormat.parse(dateTimeString);
-
-        assertThat(date.getTime() - now.getTime()).isLessThan(10000);
-    }
-
-    @Test
-    public void constructor_shouldCreateIntentWithImageStringAndParametersAndResponseInBody() throws Exception {
-        TextView textView = mock(TextView.class);
-        Bitmap sampleBitmap = Bitmap.createBitmap(10, 10, Bitmap.Config.ALPHA_8);
-        stub(textView.getDrawingCache()).toReturn(sampleBitmap);
-        stub(mockView.getRootView()).toReturn(textView);
-
-        stub(mockAdReport.toString()).toReturn("Ad Report data - this is a long list of newlined params.");
-        stub(mockAdReport.getResponseString()).toReturn("Test ad string.");
-        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
-
-        emailIntent = subject.getEmailIntent();
-        String emailSubject = emailIntent.getStringExtra(Intent.EXTRA_TEXT);
-        String bodyParts[] = emailSubject.split("\n=================\n");
-        String parameters = bodyParts[0];
-        String response = bodyParts[1];
-        String imageString = bodyParts[2];
-
-        assertThat(bodyParts.length).isEqualTo(3);
-        //this string is the JPEG encoded version
-        assertThat(parameters).isEqualTo(subject.getParameters());
-        assertThat(response).isEqualTo(subject.getResponse());
-        assertThat(imageString).isEqualTo("Qml0bWFwICgxMCB4IDEwKSBjcmVhdGVkIGZyb20gQml0bWFwIG9iamVjdCBjb21wcmVzc2VkIGFz\nIEpQRUcgd2l0aCBxdWFsaXR5IDI1\n");
-    }
-
-    @Test
-    public void constructor_shouldAddBitmapToAttachmentArray() throws Exception {
-        stub(mockContext.getFilesDir()).toReturn(new File("filesDir"));
-        stub(mockContext.openFileOutput(any(String.class), any(int.class))).toReturn(mock(FileOutputStream.class));
-        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
-
-        emailAttachments = subject.getEmailAttachments();
-        Uri fileUri = Uri.fromFile(new File("filesDir/mp_adalert_screenshot.png"));
-
-        assertThat(emailAttachments).contains(fileUri);
-    }
-
-    @Test
-    public void constructor_shouldAddParametersTextFileToAttachmentArray() throws Exception {
-        stub(mockContext.getFilesDir()).toReturn(new File("filesDir"));
-        stub(mockContext.openFileOutput(any(String.class), any(int.class))).toReturn(mock(FileOutputStream.class));
-        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
-
-        emailAttachments = subject.getEmailAttachments();
-        Uri fileUri = Uri.fromFile(new File("filesDir/mp_adalert_parameters.txt"));
-
-        assertThat(emailAttachments).contains(fileUri);
-    }
-
-    @Test
-    public void constructor_whenAdReportIsNull_shouldReturnEmptyString() throws Exception {
-        subject = new AdAlertReporter(mockContext, mockView, null);
-
-        assertThat(subject.getParameters()).isEmpty();
-        assertThat(subject.getResponse()).isEmpty();
-    }
-
-    @Test
-    public void constructor_shouldSetCorrectResponseString() throws Exception {
-        String expectedResponse = "response";
-
-        stub(mockAdReport.getResponseString()).toReturn(expectedResponse);
-        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
-
-        assertThat(subject.getResponse()).isEqualTo(expectedResponse);
-    }
-
-    @Test
-    public void constructor_shouldAddMarkupTextFileToAttachmentArray() throws Exception {
-        stub(mockAdReport.getResponseString()).toReturn("anything!");
-        stub(mockContext.getFilesDir()).toReturn(new File("filesDir"));
-        stub(mockContext.openFileOutput(any(String.class), any(int.class))).toReturn(mock(FileOutputStream.class));
-        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
-
-        emailAttachments = subject.getEmailAttachments();
-        Uri fileUri = Uri.fromFile(new File("filesDir/mp_adalert_markup.html"));
-
-        assertThat(emailAttachments).contains(fileUri);
-    }
-
-    @Test
-    public void send_shouldAddAttachmentsToIntent() throws Exception {
-        stub(mockContext.getFilesDir()).toReturn(new File("filesDir"));
-        stub(mockContext.openFileOutput(any(String.class), any(int.class))).toReturn(mock(FileOutputStream.class));
-        stub(mockAdReport.getResponseString()).toReturn("anything!");
-        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
-        subject.send();
-
-        emailIntent = subject.getEmailIntent();
-        ArrayList<Uri> attachments = emailIntent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);
-
-        assertThat(attachments.size()).isEqualTo(3);
-        assertThat(attachments).contains(Uri.fromFile(new File("filesDir/mp_adalert_screenshot.png")));
-        assertThat(attachments).contains(Uri.fromFile(new File("filesDir/mp_adalert_parameters.txt")));
-        assertThat(attachments).contains(Uri.fromFile(new File("filesDir/mp_adalert_markup.html")));
-    }
-
-    @Test
-    public void send_shouldCreateEmailChooserIntent() throws Exception {
-
-        subject = new AdAlertReporter(Robolectric.buildActivity(Activity.class).create().get(), mockView, mockAdReport);
-        subject.send();
-
-        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_CHOOSER);
-        assertThat(intent.getStringExtra(Intent.EXTRA_TITLE)).isEqualTo("Send Email...");
-        assertThat(intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
-    }
-
-    @Ignore("pending")
-    @Test
-    public void getScreenshot_whenIsDrawingCacheEnabled_shouldKeepDrawingCacheEnabled() throws Exception {
-        reset(mockView);
-        stub(mockView.getRootView()).toReturn(mockView);
-        stub(mockView.isDrawingCacheEnabled()).toReturn(true);
-
-        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
-
-        verify(mockView, never()).setDrawingCacheEnabled(false);
-    }
-
-    @Ignore("pending")
-    @Test
-    public void getScreenshot_whenIsDrawingCacheDisabled_shouldKeepDrawingCacheDisabled() throws Exception {
-        reset(mockView);
-        stub(mockView.getRootView()).toReturn(mockView);
-        stub(mockView.isDrawingCacheEnabled()).toReturn(false);
-
-        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
-
-        verify(mockView).setDrawingCacheEnabled(false);
-    }
-
-    @Test
-    public void getScreenshot_whenViewIsNull_shouldPass() throws Exception {
-        subject = new AdAlertReporter(mockContext, null, mockAdReport);
-
-        // pass
-    }
-
-    @Test
-    public void getScreenshot_whenRootViewIsNull_shouldPass() throws Exception {
-        stub(mockView.getRootView()).toReturn(null);
-
-        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
-
-        // pass
-    }
-
-    @Test
-    public void getScreenshot_whenRootViewDrawingCacheIsNull_shouldPass() throws Exception {
-        stub(mockView.getDrawingCache()).toReturn(null);
-
-        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
-
-        // pass
-    }
-}
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.graphics.Bitmap;
+import android.net.Uri;
+import android.view.View;
+import android.widget.TextView;
+
+import com.mopub.common.AdReport;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.test.support.TestDateAndTime;
+
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.Locale;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.stub;
+import static org.mockito.Mockito.verify;
+
+@RunWith(SdkTestRunner.class)
+public class AdAlertReporterTest {
+    private final static String EMAIL_ADDRESS = "creative-review@mopub.com";
+    private AdAlertReporter subject;
+    @Mock
+    private AdReport mockAdReport;
+    @Mock
+    private Context mockContext;
+    @Mock
+    private View mockView;
+    private Intent emailIntent;
+    private Bitmap bitmap;
+    private ArrayList<Uri> emailAttachments;
+    private Date now;
+
+    @Before
+    public void setup() {
+        bitmap = Bitmap.createBitmap(10, 10, Bitmap.Config.ARGB_8888);
+
+        stub(mockView.getRootView()).toReturn(mockView);
+        stub(mockView.getDrawingCache()).toReturn(bitmap);
+
+        now = new Date();
+        TestDateAndTime.getInstance().setNow(now);
+    }
+
+    @Test
+    public void constructor_shouldCreateSendToIntentWithEmailAddress() throws Exception {
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
+        emailIntent = subject.getEmailIntent();
+
+        assertThat(emailIntent.getAction()).isEqualTo(Intent.ACTION_SEND_MULTIPLE);
+        assertThat(emailIntent.getType()).isEqualTo("plain/text");
+        assertThat(emailIntent.getData().toString()).isEqualTo("mailto:");
+        assertThat(emailIntent.getStringArrayExtra(Intent.EXTRA_EMAIL)[0]).isEqualTo(EMAIL_ADDRESS);
+    }
+
+    @Test
+    public void constructor_shouldCreateIntentWithDatestampInSubject() throws Exception {
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
+        emailIntent = subject.getEmailIntent();
+
+        String emailSubject = emailIntent.getStringExtra(Intent.EXTRA_SUBJECT);
+        String subjectParts[] = emailSubject.split(" - ");
+
+        String title = subjectParts[0];
+        assertThat(title).isEqualTo("New creative violation report");
+
+        String dateTimeString = subjectParts[1];
+        SimpleDateFormat dateFormat = new SimpleDateFormat("M/d/yy hh:mm:ss a z", Locale.US);
+
+        Date date = dateFormat.parse(dateTimeString);
+
+        assertThat(date.getTime() - now.getTime()).isLessThan(10000);
+    }
+
+    @Test
+    public void constructor_shouldCreateIntentWithImageStringAndParametersAndResponseInBody() throws Exception {
+        TextView textView = mock(TextView.class);
+        Bitmap sampleBitmap = Bitmap.createBitmap(10, 10, Bitmap.Config.ALPHA_8);
+        stub(textView.getDrawingCache()).toReturn(sampleBitmap);
+        stub(mockView.getRootView()).toReturn(textView);
+
+        stub(mockAdReport.toString()).toReturn("Ad Report data - this is a long list of newlined params.");
+        stub(mockAdReport.getResponseString()).toReturn("Test ad string.");
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
+
+        emailIntent = subject.getEmailIntent();
+        String emailSubject = emailIntent.getStringExtra(Intent.EXTRA_TEXT);
+        String bodyParts[] = emailSubject.split("\n=================\n");
+        String parameters = bodyParts[0];
+        String response = bodyParts[1];
+        String imageString = bodyParts[2];
+
+        assertThat(bodyParts.length).isEqualTo(3);
+        //this string is the JPEG encoded version
+        assertThat(parameters).isEqualTo(subject.getParameters());
+        assertThat(response).isEqualTo(subject.getResponse());
+        assertThat(imageString).isEqualTo("Qml0bWFwICgxMCB4IDEwKSBjcmVhdGVkIGZyb20gQml0bWFwIG9iamVjdCBjb21wcmVzc2VkIGFz\nIEpQRUcgd2l0aCBxdWFsaXR5IDI1\n");
+    }
+
+    @Test
+    public void constructor_shouldAddBitmapToAttachmentArray() throws Exception {
+        stub(mockContext.getFilesDir()).toReturn(new File("filesDir"));
+        stub(mockContext.openFileOutput(any(String.class), any(int.class))).toReturn(mock(FileOutputStream.class));
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
+
+        emailAttachments = subject.getEmailAttachments();
+        Uri fileUri = Uri.fromFile(new File("filesDir/mp_adalert_screenshot.png"));
+
+        assertThat(emailAttachments).contains(fileUri);
+    }
+
+    @Test
+    public void constructor_shouldAddParametersTextFileToAttachmentArray() throws Exception {
+        stub(mockContext.getFilesDir()).toReturn(new File("filesDir"));
+        stub(mockContext.openFileOutput(any(String.class), any(int.class))).toReturn(mock(FileOutputStream.class));
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
+
+        emailAttachments = subject.getEmailAttachments();
+        Uri fileUri = Uri.fromFile(new File("filesDir/mp_adalert_parameters.txt"));
+
+        assertThat(emailAttachments).contains(fileUri);
+    }
+
+    @Test
+    public void constructor_whenAdReportIsNull_shouldReturnEmptyString() throws Exception {
+        subject = new AdAlertReporter(mockContext, mockView, null);
+
+        assertThat(subject.getParameters()).isEmpty();
+        assertThat(subject.getResponse()).isEmpty();
+    }
+
+    @Test
+    public void constructor_shouldSetCorrectResponseString() throws Exception {
+        String expectedResponse = "response";
+
+        stub(mockAdReport.getResponseString()).toReturn(expectedResponse);
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
+
+        assertThat(subject.getResponse()).isEqualTo(expectedResponse);
+    }
+
+    @Test
+    public void constructor_shouldAddMarkupTextFileToAttachmentArray() throws Exception {
+        stub(mockAdReport.getResponseString()).toReturn("anything!");
+        stub(mockContext.getFilesDir()).toReturn(new File("filesDir"));
+        stub(mockContext.openFileOutput(any(String.class), any(int.class))).toReturn(mock(FileOutputStream.class));
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
+
+        emailAttachments = subject.getEmailAttachments();
+        Uri fileUri = Uri.fromFile(new File("filesDir/mp_adalert_markup.html"));
+
+        assertThat(emailAttachments).contains(fileUri);
+    }
+
+    @Test
+    public void send_shouldAddAttachmentsToIntent() throws Exception {
+        stub(mockContext.getFilesDir()).toReturn(new File("filesDir"));
+        stub(mockContext.openFileOutput(any(String.class), any(int.class))).toReturn(mock(FileOutputStream.class));
+        stub(mockAdReport.getResponseString()).toReturn("anything!");
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
+        subject.send();
+
+        emailIntent = subject.getEmailIntent();
+        ArrayList<Uri> attachments = emailIntent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);
+
+        assertThat(attachments.size()).isEqualTo(3);
+        assertThat(attachments).contains(Uri.fromFile(new File("filesDir/mp_adalert_screenshot.png")));
+        assertThat(attachments).contains(Uri.fromFile(new File("filesDir/mp_adalert_parameters.txt")));
+        assertThat(attachments).contains(Uri.fromFile(new File("filesDir/mp_adalert_markup.html")));
+    }
+
+    @Test
+    public void send_shouldCreateEmailChooserIntent() throws Exception {
+
+        subject = new AdAlertReporter(Robolectric.buildActivity(Activity.class).create().get(), mockView, mockAdReport);
+        subject.send();
+
+        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_CHOOSER);
+        assertThat(intent.getStringExtra(Intent.EXTRA_TITLE)).isEqualTo("Send Email...");
+        assertThat(intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
+    }
+
+    @Ignore("pending")
+    @Test
+    public void getScreenshot_whenIsDrawingCacheEnabled_shouldKeepDrawingCacheEnabled() throws Exception {
+        reset(mockView);
+        stub(mockView.getRootView()).toReturn(mockView);
+        stub(mockView.isDrawingCacheEnabled()).toReturn(true);
+
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
+
+        verify(mockView, never()).setDrawingCacheEnabled(false);
+    }
+
+    @Ignore("pending")
+    @Test
+    public void getScreenshot_whenIsDrawingCacheDisabled_shouldKeepDrawingCacheDisabled() throws Exception {
+        reset(mockView);
+        stub(mockView.getRootView()).toReturn(mockView);
+        stub(mockView.isDrawingCacheEnabled()).toReturn(false);
+
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
+
+        verify(mockView).setDrawingCacheEnabled(false);
+    }
+
+    @Test
+    public void getScreenshot_whenViewIsNull_shouldPass() throws Exception {
+        subject = new AdAlertReporter(mockContext, null, mockAdReport);
+
+        // pass
+    }
+
+    @Test
+    public void getScreenshot_whenRootViewIsNull_shouldPass() throws Exception {
+        stub(mockView.getRootView()).toReturn(null);
+
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
+
+        // pass
+    }
+
+    @Test
+    public void getScreenshot_whenRootViewDrawingCacheIsNull_shouldPass() throws Exception {
+        stub(mockView.getDrawingCache()).toReturn(null);
+
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
+
+        // pass
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdTypeTranslatorTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdTypeTranslatorTest.java
index e681b56b..2d782a64 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/AdTypeTranslatorTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/AdTypeTranslatorTest.java
@@ -1,132 +1,132 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.content.Context;
-
-import com.mopub.common.AdFormat;
-import com.mopub.common.AdType;
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.ResponseHeader;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import java.util.HashMap;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.stub;
-
-@RunWith(SdkTestRunner.class)
-public class AdTypeTranslatorTest {
-    private String customEventName;
-    private MoPubView moPubView;
-    private MoPubInterstitial.MoPubInterstitialView moPubInterstitialView;
-    private Context context;
-    HashMap<String, String> headers;
-
-    @Before
-    public void setUp() throws Exception {
-        moPubView = mock(MoPubView.class);
-        moPubInterstitialView = mock(MoPubInterstitial.MoPubInterstitialView.class);
-
-        context = new Activity();
-        stub(moPubView.getContext()).toReturn(context);
-        stub(moPubInterstitialView.getContext()).toReturn(context);
-
-        headers = new HashMap<String, String>();
-    }
-
-    @Test
-    public void getCustomEventName_shouldBeGoogleBanner() {
-        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, "admob_native", null, headers);
-
-        assertThat(customEventName).isEqualTo("com.mopub.mobileads.GooglePlayServicesBanner");
-    }
-
-    @Test
-    public void getCustomEventName_shouldBeGoogleInterstitial() {
-        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, "interstitial", "admob_full", headers);
-
-        assertThat(customEventName).isEqualTo("com.mopub.mobileads.GooglePlayServicesInterstitial");
-    }
-
-    @Test
-    public void getCustomEventName_shouldBeMillenialBanner() {
-        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, "millennial_native", null, headers);
-
-        assertThat(customEventName).isEqualTo("com.mopub.mobileads.MillennialBanner");
-    }
-
-    @Test
-    public void getCustomEventName_shouldBeMillennialIntersitial() {
-        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.INTERSTITIAL, "interstitial", "millennial_full", headers);
-
-        assertThat(customEventName).isEqualTo("com.mopub.mobileads.MillennialInterstitial");
-    }
-
-    @Test
-    public void getCustomEventName_shouldBeMraidBanner() {
-        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, AdType.MRAID, null, headers);
-
-        assertThat(customEventName).isEqualTo("com.mopub.mraid.MraidBanner");
-    }
-
-    @Test
-    public void getCustomEventName_shouldBeMraidInterstitial() {
-        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.INTERSTITIAL, AdType.MRAID, null, headers);
-
-        assertThat(customEventName).isEqualTo("com.mopub.mraid.MraidInterstitial");
-    }
-
-    @Test
-    public void getCustomEventName_shouldBeHtmlBanner() {
-        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, "html", null, headers);
-
-        assertThat(customEventName).isEqualTo("com.mopub.mobileads.HtmlBanner");
-    }
-
-    @Test
-    public void getCustomEventName_shouldBeHtmlInterstitial() {
-        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.INTERSTITIAL, "html", null, headers);
-
-        assertThat(customEventName).isEqualTo("com.mopub.mobileads.HtmlInterstitial");
-    }
-
-    @Test
-    public void getCustomEventName_shouldBeVastInterstitial() {
-        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.INTERSTITIAL, "interstitial", "vast", headers);
-
-        assertThat(customEventName).isEqualTo("com.mopub.mobileads.VastVideoInterstitial");
-    }
-
-    @Test
-    public void getCustomEventName_shouldBeCustomClassName() {
-        headers.put(ResponseHeader.CUSTOM_EVENT_NAME.getKey(), "com.example.CustomClass");
-        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, AdType.CUSTOM, null, headers);
-
-        assertThat(customEventName).isEqualTo("com.example.CustomClass");
-    }
-
-    @Test
-    public void getCustomEventName_whenNameNotInHeaders_shouldBeNull() {
-        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, AdType.CUSTOM, null, headers);
-
-        assertThat(customEventName).isNull();
-    }
-
-    @Test
-    public void getCustomEventName_withNativeFormat_shouldBeMoPubNative() {
-        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.NATIVE, AdType.NATIVE, null, headers);
-
-        assertThat(customEventName).isEqualTo("com.mopub.nativeads.MoPubCustomEventNative");
-    }
-
-    @Test
-    public void getCustomEventName_whenInvalidAdTypeAndInvalidFullAdType_shouldReturnNull() {
-        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, "garbage", "garbage",
-                headers);
-        assertThat(customEventName).isNull();
-    }
-}
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.Context;
+
+import com.mopub.common.AdFormat;
+import com.mopub.common.AdType;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.ResponseHeader;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+
+import java.util.HashMap;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.stub;
+
+@RunWith(SdkTestRunner.class)
+public class AdTypeTranslatorTest {
+    private String customEventName;
+    private MoPubView moPubView;
+    private MoPubInterstitial.MoPubInterstitialView moPubInterstitialView;
+    HashMap<String, String> headers;
+
+    @Before
+    public void setUp() throws Exception {
+        moPubView = mock(MoPubView.class);
+        moPubInterstitialView = mock(MoPubInterstitial.MoPubInterstitialView.class);
+
+        Context context = Robolectric.buildActivity(Activity.class).create().get();
+        stub(moPubView.getContext()).toReturn(context);
+        stub(moPubInterstitialView.getContext()).toReturn(context);
+
+        headers = new HashMap<String, String>();
+    }
+
+    @Test
+    public void getCustomEventName_shouldBeGoogleBanner() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, "admob_native", null, headers);
+
+        assertThat(customEventName).isEqualTo("com.mopub.mobileads.GooglePlayServicesBanner");
+    }
+
+    @Test
+    public void getCustomEventName_shouldBeGoogleInterstitial() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, "interstitial", "admob_full", headers);
+
+        assertThat(customEventName).isEqualTo("com.mopub.mobileads.GooglePlayServicesInterstitial");
+    }
+
+    @Test
+    public void getCustomEventName_shouldBeMillenialBanner() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, "millennial_native", null, headers);
+
+        assertThat(customEventName).isEqualTo("com.mopub.mobileads.MillennialBanner");
+    }
+
+    @Test
+    public void getCustomEventName_shouldBeMillennialIntersitial() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.INTERSTITIAL, "interstitial", "millennial_full", headers);
+
+        assertThat(customEventName).isEqualTo("com.mopub.mobileads.MillennialInterstitial");
+    }
+
+    @Test
+    public void getCustomEventName_shouldBeMraidBanner() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, AdType.MRAID, null, headers);
+
+        assertThat(customEventName).isEqualTo("com.mopub.mraid.MraidBanner");
+    }
+
+    @Test
+    public void getCustomEventName_shouldBeMraidInterstitial() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.INTERSTITIAL, AdType.MRAID, null, headers);
+
+        assertThat(customEventName).isEqualTo("com.mopub.mraid.MraidInterstitial");
+    }
+
+    @Test
+    public void getCustomEventName_shouldBeHtmlBanner() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, "html", null, headers);
+
+        assertThat(customEventName).isEqualTo("com.mopub.mobileads.HtmlBanner");
+    }
+
+    @Test
+    public void getCustomEventName_shouldBeHtmlInterstitial() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.INTERSTITIAL, "html", null, headers);
+
+        assertThat(customEventName).isEqualTo("com.mopub.mobileads.HtmlInterstitial");
+    }
+
+    @Test
+    public void getCustomEventName_shouldBeVastInterstitial() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.INTERSTITIAL, "interstitial", "vast", headers);
+
+        assertThat(customEventName).isEqualTo("com.mopub.mobileads.VastVideoInterstitial");
+    }
+
+    @Test
+    public void getCustomEventName_shouldBeCustomClassName() {
+        headers.put(ResponseHeader.CUSTOM_EVENT_NAME.getKey(), "com.example.CustomClass");
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, AdType.CUSTOM, null, headers);
+
+        assertThat(customEventName).isEqualTo("com.example.CustomClass");
+    }
+
+    @Test
+    public void getCustomEventName_whenNameNotInHeaders_shouldBeNull() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, AdType.CUSTOM, null, headers);
+
+        assertThat(customEventName).isNull();
+    }
+
+    @Test
+    public void getCustomEventName_withNativeFormat_shouldBeMoPubNative() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.NATIVE, AdType.NATIVE, null, headers);
+
+        assertThat(customEventName).isEqualTo("com.mopub.nativeads.MoPubCustomEventNative");
+    }
+
+    @Test
+    public void getCustomEventName_whenInvalidAdTypeAndInvalidFullAdType_shouldReturnNull() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, "garbage", "garbage",
+                headers);
+        assertThat(customEventName).isNull();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseVideoPlayerActivityTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseVideoPlayerActivityTest.java
index 44a732de..f0017117 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseVideoPlayerActivityTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseVideoPlayerActivityTest.java
@@ -1,77 +1,77 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.content.Intent;
-
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.Utils;
-import com.mopub.mobileads.util.vast.VastVideoConfiguration;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-
-import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
-import static com.mopub.mobileads.BaseVideoPlayerActivity.VIDEO_URL;
-import static com.mopub.mobileads.BaseVideoPlayerActivity.startMraid;
-import static com.mopub.mobileads.BaseVideoPlayerActivity.startVast;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.withSettings;
-
-@RunWith(SdkTestRunner.class)
-public class BaseVideoPlayerActivityTest {
-    private static final String MRAID_VIDEO_URL = "http://mraidVideo";
-
-    private long testBroadcastIdentifier;
-    private VastVideoConfiguration vastVideoConfiguration;
-
-    @Before
-    public void setup() throws Exception {
-        vastVideoConfiguration = mock(VastVideoConfiguration.class, withSettings().serializable());
-        testBroadcastIdentifier = 1234;
-    }
-
-    @Test
-    public void startMraid_shouldStartMraidVideoPlayerActivity() throws Exception {
-        startMraid(new Activity(), MRAID_VIDEO_URL);
-        assertMraidVideoPlayerActivityStarted(MraidVideoPlayerActivity.class, MRAID_VIDEO_URL);
-    }
-
-    @Test
-    public void startVast_shouldStartMraidVideoPlayerActivity() throws Exception {
-        startVast(new Activity(), vastVideoConfiguration, testBroadcastIdentifier);
-        assertVastVideoPlayerActivityStarted(MraidVideoPlayerActivity.class, vastVideoConfiguration, testBroadcastIdentifier);
-    }
-
-    static void assertVastVideoPlayerActivityStarted(final Class clazz,
-            final VastVideoConfiguration vastVideoConfiguration,
-            final long broadcastIdentifier) {
-        final Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertIntentAndBroadcastIdentifierAreCorrect(intent, clazz, broadcastIdentifier);
-
-        final VastVideoConfiguration expectedVastVideoConfiguration =
-                (VastVideoConfiguration) intent.getSerializableExtra(VastVideoViewController.VAST_VIDEO_CONFIGURATION);
-        assertThat(expectedVastVideoConfiguration).isEqualsToByComparingFields(vastVideoConfiguration);
-    }
-
-    public static void assertMraidVideoPlayerActivityStarted(final Class clazz, final String url) {
-        final Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertIntentAndBroadcastIdentifierAreCorrect(intent, clazz, null);
-
-        assertThat(intent.getStringExtra(VIDEO_URL)).isEqualTo(url);
-    }
-
-    static void assertIntentAndBroadcastIdentifierAreCorrect(final Intent intent,
-            final Class clazz,
-            final Long expectedBroadcastId) {
-        assertThat(intent.getComponent().getClassName()).isEqualTo(clazz.getCanonicalName());
-        assertThat(Utils.bitMaskContainsFlag(intent.getFlags(), Intent.FLAG_ACTIVITY_NEW_TASK)).isTrue();
-
-        if (expectedBroadcastId != null) {
-            final long actualBroadcastId = (Long) intent.getSerializableExtra(BROADCAST_IDENTIFIER_KEY);
-            assertThat(actualBroadcastId).isEqualTo(expectedBroadcastId);
-        }
-    }
-}
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.Intent;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.Utils;
+import com.mopub.mobileads.util.vast.VastVideoConfiguration;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
+import static com.mopub.mobileads.BaseVideoPlayerActivity.VIDEO_URL;
+import static com.mopub.mobileads.BaseVideoPlayerActivity.startMraid;
+import static com.mopub.mobileads.BaseVideoPlayerActivity.startVast;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.withSettings;
+
+@RunWith(SdkTestRunner.class)
+public class BaseVideoPlayerActivityTest {
+    private static final String MRAID_VIDEO_URL = "http://mraidVideo";
+
+    private long testBroadcastIdentifier;
+    private VastVideoConfiguration vastVideoConfiguration;
+
+    @Before
+    public void setup() throws Exception {
+        vastVideoConfiguration = mock(VastVideoConfiguration.class, withSettings().serializable());
+        testBroadcastIdentifier = 1234;
+    }
+
+    @Test
+    public void startMraid_shouldStartMraidVideoPlayerActivity() throws Exception {
+        startMraid(Robolectric.buildActivity(Activity.class).create().get(), MRAID_VIDEO_URL);
+        assertMraidVideoPlayerActivityStarted(MraidVideoPlayerActivity.class, MRAID_VIDEO_URL);
+    }
+
+    @Test
+    public void startVast_shouldStartMraidVideoPlayerActivity() throws Exception {
+        startVast(Robolectric.buildActivity(Activity.class).create().get(), vastVideoConfiguration, testBroadcastIdentifier);
+        assertVastVideoPlayerActivityStarted(MraidVideoPlayerActivity.class, vastVideoConfiguration, testBroadcastIdentifier);
+    }
+
+    static void assertVastVideoPlayerActivityStarted(final Class clazz,
+            final VastVideoConfiguration vastVideoConfiguration,
+            final long broadcastIdentifier) {
+        final Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertIntentAndBroadcastIdentifierAreCorrect(intent, clazz, broadcastIdentifier);
+
+        final VastVideoConfiguration expectedVastVideoConfiguration =
+                (VastVideoConfiguration) intent.getSerializableExtra(VastVideoViewController.VAST_VIDEO_CONFIGURATION);
+        assertThat(expectedVastVideoConfiguration).isEqualsToByComparingFields(vastVideoConfiguration);
+    }
+
+    public static void assertMraidVideoPlayerActivityStarted(final Class clazz, final String url) {
+        final Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertIntentAndBroadcastIdentifierAreCorrect(intent, clazz, null);
+
+        assertThat(intent.getStringExtra(VIDEO_URL)).isEqualTo(url);
+    }
+
+    static void assertIntentAndBroadcastIdentifierAreCorrect(final Intent intent,
+            final Class clazz,
+            final Long expectedBroadcastId) {
+        assertThat(intent.getComponent().getClassName()).isEqualTo(clazz.getCanonicalName());
+        assertThat(Utils.bitMaskContainsFlag(intent.getFlags(), Intent.FLAG_ACTIVITY_NEW_TASK)).isTrue();
+
+        if (expectedBroadcastId != null) {
+            final long actualBroadcastId = (Long) intent.getSerializableExtra(BROADCAST_IDENTIFIER_KEY);
+            assertThat(actualBroadcastId).isEqualTo(expectedBroadcastId);
+        }
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseWebViewTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseWebViewTest.java
index 77abdb0d..d9415f2d 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseWebViewTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseWebViewTest.java
@@ -1,78 +1,79 @@
-package com.mopub.mobileads;
-
-
-import android.app.Activity;
-import android.os.Build.VERSION_CODES;
-import android.view.ViewGroup;
-import android.webkit.WebSettings;
-
-import com.mopub.common.test.support.SdkTestRunner;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.annotation.Config;
-import org.robolectric.shadows.ShadowWebView;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.robolectric.Robolectric.shadowOf;
-
-@RunWith(SdkTestRunner.class)
-public class BaseWebViewTest {
-    private Activity context;
-    private BaseWebView subject;
-
-    @Before
-    public void setup() {
-        context = new Activity();
-    }
-
-    @Config(reportSdk = VERSION_CODES.JELLY_BEAN_MR1)
-    @Test
-    public void beforeJellyBeanMr1_shouldDisablePluginsByDefault() throws Exception {
-        subject = new BaseWebView(context);
-
-        WebSettings webSettings = subject.getSettings();
-        assertThat(webSettings.getPluginState()).isEqualTo(WebSettings.PluginState.OFF);
-
-        subject.enablePlugins(true);
-        assertThat(webSettings.getPluginState()).isEqualTo(WebSettings.PluginState.ON);
-    }
-
-    @Config(reportSdk = VERSION_CODES.JELLY_BEAN_MR2)
-    @Test
-    public void atLeastJellybeanMr2_shouldPass() throws Exception {
-        subject = new BaseWebView(context);
-
-        subject.enablePlugins(true);
-
-        // pass
-    }
-
-    @Test
-    public void destroy_shouldRemoveSelfFromParent_beforeCallingDestroy() throws Exception {
-        subject = new BaseWebView(context);
-        ViewGroup parent = mock(ViewGroup.class);
-        ShadowWebView shadow = shadowOf(subject);
-        shadow.setMyParent(parent);
-
-        subject.destroy();
-
-        verify(parent).removeView(eq(subject));
-        assertThat(shadow.wasDestroyCalled()).isTrue();
-    }
-
-    @Test
-    public void destroy_shouldSetTheCorrectStateVariable() {
-        subject = new BaseWebView(context);
-
-        assertThat(subject.mIsDestroyed).isFalse();
-
-        subject.destroy();
-
-        assertThat(subject.mIsDestroyed).isTrue();
-    }
-}
+package com.mopub.mobileads;
+
+
+import android.app.Activity;
+import android.os.Build.VERSION_CODES;
+import android.view.ViewGroup;
+import android.webkit.WebSettings;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowWebView;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.robolectric.Robolectric.shadowOf;
+
+@RunWith(SdkTestRunner.class)
+public class BaseWebViewTest {
+    private Activity context;
+    private BaseWebView subject;
+
+    @Before
+    public void setup() {
+        context = Robolectric.buildActivity(Activity.class).create().get();
+    }
+
+    @Config(reportSdk = VERSION_CODES.JELLY_BEAN_MR1)
+    @Test
+    public void beforeJellyBeanMr1_shouldDisablePluginsByDefault() throws Exception {
+        subject = new BaseWebView(context);
+
+        WebSettings webSettings = subject.getSettings();
+        assertThat(webSettings.getPluginState()).isEqualTo(WebSettings.PluginState.OFF);
+
+        subject.enablePlugins(true);
+        assertThat(webSettings.getPluginState()).isEqualTo(WebSettings.PluginState.ON);
+    }
+
+    @Config(reportSdk = VERSION_CODES.JELLY_BEAN_MR2)
+    @Test
+    public void atLeastJellybeanMr2_shouldPass() throws Exception {
+        subject = new BaseWebView(context);
+
+        subject.enablePlugins(true);
+
+        // pass
+    }
+
+    @Test
+    public void destroy_shouldRemoveSelfFromParent_beforeCallingDestroy() throws Exception {
+        subject = new BaseWebView(context);
+        ViewGroup parent = mock(ViewGroup.class);
+        ShadowWebView shadow = shadowOf(subject);
+        shadow.setMyParent(parent);
+
+        subject.destroy();
+
+        verify(parent).removeView(eq(subject));
+        assertThat(shadow.wasDestroyCalled()).isTrue();
+    }
+
+    @Test
+    public void destroy_shouldSetTheCorrectStateVariable() {
+        subject = new BaseWebView(context);
+
+        assertThat(subject.mIsDestroyed).isFalse();
+
+        subject.destroy();
+
+        assertThat(subject.mIsDestroyed).isTrue();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventBannerAdapterTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventBannerAdapterTest.java
index 6d485822..ed91f90b 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventBannerAdapterTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventBannerAdapterTest.java
@@ -1,344 +1,344 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.content.Context;
-import android.location.Location;
-import android.view.View;
-
-import com.mopub.common.AdReport;
-import com.mopub.common.DataKeys;
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.mobileads.factories.CustomEventBannerFactory;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.Robolectric;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import static com.mopub.mobileads.CustomEventBanner.CustomEventBannerListener;
-import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR;
-import static com.mopub.mobileads.MoPubErrorCode.NETWORK_TIMEOUT;
-import static com.mopub.mobileads.MoPubErrorCode.UNSPECIFIED;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-@RunWith(SdkTestRunner.class)
-public class CustomEventBannerAdapterTest {
-    private CustomEventBannerAdapter subject;
-    @Mock
-    private MoPubView moPubView;
-    @Mock
-    private AdReport mockAdReport;
-    private static final String CLASS_NAME = "arbitrary_banner_adapter_class_name";
-    private static final long BROADCAST_IDENTIFIER = 123;
-    private Map<String, String> serverExtras;
-    private CustomEventBanner banner;
-    private Map<String,Object> localExtras;
-    private Map<String,Object> expectedLocalExtras;
-    private HashMap<String,String> expectedServerExtras;
-
-    @Before
-    public void setUp() throws Exception {
-
-        when(moPubView.getAdTimeoutDelay()).thenReturn(null);
-        when(moPubView.getAdWidth()).thenReturn(320);
-        when(moPubView.getAdHeight()).thenReturn(50);
-
-        localExtras = new HashMap<String, Object>();
-        when(moPubView.getLocalExtras()).thenReturn(localExtras);
-
-        serverExtras = new HashMap<String, String>();
-        serverExtras.put("key", "value");
-        serverExtras.put("another_key", "another_value");
-        subject = new CustomEventBannerAdapter(moPubView, CLASS_NAME, serverExtras, BROADCAST_IDENTIFIER, mockAdReport);
-
-        expectedLocalExtras = new HashMap<String, Object>();
-        expectedLocalExtras.put(DataKeys.AD_REPORT_KEY, mockAdReport);
-        expectedLocalExtras.put("broadcastIdentifier", BROADCAST_IDENTIFIER);
-        expectedLocalExtras.put(DataKeys.AD_WIDTH, 320);
-        expectedLocalExtras.put(DataKeys.AD_HEIGHT, 50);
-
-        expectedServerExtras = new HashMap<String, String>();
-
-        banner = CustomEventBannerFactory.create(CLASS_NAME);
-    }
-
-    @Test
-    public void constructor_shouldPopulateLocalExtrasWithAdWidthAndHeight() throws Exception {
-        assertThat(localExtras.get("com_mopub_ad_width")).isEqualTo(320);
-        assertThat(localExtras.get("com_mopub_ad_height")).isEqualTo(50);
-    }
-
-    @Test
-    public void timeout_shouldSignalFailureAndInvalidateWithDefaultDelay() throws Exception {
-        subject.loadAd();
-
-        Robolectric.idleMainLooper(CustomEventBannerAdapter.DEFAULT_BANNER_TIMEOUT_DELAY - 1);
-        verify(moPubView, never()).loadFailUrl(eq(NETWORK_TIMEOUT));
-        assertThat(subject.isInvalidated()).isFalse();
-
-        Robolectric.idleMainLooper(1);
-        verify(moPubView).loadFailUrl(eq(NETWORK_TIMEOUT));
-        assertThat(subject.isInvalidated()).isTrue();
-    }
-
-    @Test
-    public void timeout_withNegativeAdTimeoutDelay_shouldSignalFailureAndInvalidateWithDefaultDelay() throws Exception {
-        when(moPubView.getAdTimeoutDelay()).thenReturn(-1);
-
-        subject.loadAd();
-
-        Robolectric.idleMainLooper(CustomEventBannerAdapter.DEFAULT_BANNER_TIMEOUT_DELAY - 1);
-        verify(moPubView, never()).loadFailUrl(eq(NETWORK_TIMEOUT));
-        assertThat(subject.isInvalidated()).isFalse();
-
-        Robolectric.idleMainLooper(1);
-        verify(moPubView).loadFailUrl(eq(NETWORK_TIMEOUT));
-        assertThat(subject.isInvalidated()).isTrue();
-    }
-
-    @Test
-    public void timeout_withNonNullAdTimeoutDelay_shouldSignalFailureAndInvalidateWithCustomDelay() throws Exception {
-       when(moPubView.getAdTimeoutDelay()).thenReturn(77);
-
-        subject.loadAd();
-
-        Robolectric.idleMainLooper(77000 - 1);
-        verify(moPubView, never()).loadFailUrl(eq(NETWORK_TIMEOUT));
-        assertThat(subject.isInvalidated()).isFalse();
-
-        Robolectric.idleMainLooper(1);
-        verify(moPubView).loadFailUrl(eq(NETWORK_TIMEOUT));
-        assertThat(subject.isInvalidated()).isTrue();
-    }
-
-
-    @Test
-    public void loadAd_shouldPropagateLocationInLocalExtras() throws Exception {
-        Location expectedLocation = new Location("");
-        expectedLocation.setLongitude(10.0);
-        expectedLocation.setLongitude(20.1);
-
-        when(moPubView.getLocation()).thenReturn(expectedLocation);
-        subject = new CustomEventBannerAdapter(moPubView, CLASS_NAME, new HashMap<String, String>(), BROADCAST_IDENTIFIER, mockAdReport);
-        subject.loadAd();
-
-        expectedLocalExtras.put("location", moPubView.getLocation());
-
-        verify(banner).loadBanner(
-                any(Context.class),
-                eq(subject),
-                eq(expectedLocalExtras),
-                eq(expectedServerExtras)
-        );
-    }
-
-    @Test
-    public void loadAd_shouldPropagateServerExtrasToLoadBanner() throws Exception {
-        subject.loadAd();
-
-        expectedServerExtras.put("key", "value");
-        expectedServerExtras.put("another_key", "another_value");
-
-        verify(banner).loadBanner(
-                any(Context.class),
-                eq(subject),
-                eq(expectedLocalExtras),
-                eq(expectedServerExtras)
-        );
-    }
-
-    @Test
-    public void loadAd_shouldScheduleTimeout_bannerLoadedAndFailed_shouldCancelTimeout() throws Exception {
-        Robolectric.pauseMainLooper();
-
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
-
-        subject.loadAd();
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
-
-        subject.onBannerLoaded(null);
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
-
-        subject.loadAd();
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
-
-        subject.onBannerFailed(null);
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
-    }
-
-    @Test
-    public void loadAd_shouldScheduleTimeoutRunnableBeforeCallingLoadBanner() throws Exception {
-        Robolectric.pauseMainLooper();
-
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
-
-        Answer assertTimeoutRunnableHasStarted = new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
-                return null;
-            }
-        };
-
-        doAnswer(assertTimeoutRunnableHasStarted)
-                .when(banner)
-                .loadBanner(
-                        any(Context.class),
-                        any(CustomEventBannerListener.class),
-                        any(Map.class),
-                        any(Map.class)
-                );
-
-        subject.loadAd();
-    }
-
-
-    @Test
-    public void loadAd_whenCallingOnBannerFailed_shouldCancelExistingTimeoutRunnable() throws Exception {
-        Robolectric.pauseMainLooper();
-
-        Answer justCallOnBannerFailed = new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
-                subject.onBannerFailed(null);
-                assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
-                return null;
-            }
-        };
-
-        doAnswer(justCallOnBannerFailed)
-                .when(banner)
-                .loadBanner(
-                        any(Context.class),
-                        any(CustomEventBannerListener.class),
-                        any(Map.class),
-                        any(Map.class)
-                );
-
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
-        subject.loadAd();
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
-    }
-
-    @Test
-    public void onBannerLoaded_shouldSignalMoPubView() throws Exception {
-        View view = new View(new Activity());
-        subject.onBannerLoaded(view);
-
-        verify(moPubView).nativeAdLoaded();
-        verify(moPubView).setAdContentView(eq(view));
-        verify(moPubView).trackNativeImpression();
-    }
-
-    @Test
-    public void onBannerLoaded_whenViewIsHtmlBannerWebView_shouldNotTrackImpression() throws Exception {
-        View mockHtmlBannerWebView = mock(HtmlBannerWebView.class);
-        subject.onBannerLoaded(mockHtmlBannerWebView);
-
-        verify(moPubView).nativeAdLoaded();
-        verify(moPubView).setAdContentView(eq(mockHtmlBannerWebView));
-        verify(moPubView, never()).trackNativeImpression();
-    }
-
-    @Test
-    public void onBannerFailed_shouldLoadFailUrl() throws Exception {
-        subject.onBannerFailed(ADAPTER_CONFIGURATION_ERROR);
-
-        verify(moPubView).loadFailUrl(eq(ADAPTER_CONFIGURATION_ERROR));
-    }
-
-    @Test
-    public void onBannerFailed_whenErrorCodeIsNull_shouldPassUnspecifiedError() throws Exception {
-        subject.onBannerFailed(null);
-
-        verify(moPubView).loadFailUrl(eq(UNSPECIFIED));
-    }
-
-    @Test
-    public void onBannerExpanded_shouldPauseRefreshAndCallAdPresentOverlay() throws Exception {
-        subject.onBannerExpanded();
-
-        verify(moPubView).setAutorefreshEnabled(eq(false));
-        verify(moPubView).adPresentedOverlay();
-    }
-
-    @Test
-    public void onBannerCollapsed_shouldRestoreRefreshSettingAndCallAdClosed() throws Exception {
-        when(moPubView.getAutorefreshEnabled()).thenReturn(true);
-        subject.onBannerExpanded();
-        reset(moPubView);
-        subject.onBannerCollapsed();
-        verify(moPubView).setAutorefreshEnabled(eq(true));
-        verify(moPubView).adClosed();
-
-        when(moPubView.getAutorefreshEnabled()).thenReturn(false);
-        subject.onBannerExpanded();
-        reset(moPubView);
-        subject.onBannerCollapsed();
-        verify(moPubView).setAutorefreshEnabled(eq(false));
-        verify(moPubView).adClosed();
-    }
-
-    @Test
-    public void onBannerClicked_shouldRegisterClick() throws Exception {
-        subject.onBannerClicked();
-
-        verify(moPubView).registerClick();
-    }
-
-    @Test
-    public void onLeaveApplication_shouldRegisterClick() throws Exception {
-        subject.onLeaveApplication();
-
-        verify(moPubView).registerClick();
-    }
-
-    @Test
-    public void invalidate_shouldCauseLoadAdToDoNothing() throws Exception {
-        subject.invalidate();
-
-        subject.loadAd();
-
-        verify(banner, never()).loadBanner(
-                any(Context.class),
-                any(CustomEventBannerListener.class),
-                any(Map.class),
-                any(Map.class)
-        );
-    }
-
-    @Test
-    public void invalidate_shouldCauseBannerListenerMethodsToDoNothing() throws Exception {
-        subject.invalidate();
-
-        subject.onBannerLoaded(null);
-        subject.onBannerFailed(null);
-        subject.onBannerExpanded();
-        subject.onBannerCollapsed();
-        subject.onBannerClicked();
-        subject.onLeaveApplication();
-
-        verify(moPubView, never()).nativeAdLoaded();
-        verify(moPubView, never()).setAdContentView(any(View.class));
-        verify(moPubView, never()).trackNativeImpression();
-        verify(moPubView, never()).loadFailUrl(any(MoPubErrorCode.class));
-        verify(moPubView, never()).setAutorefreshEnabled(any(boolean.class));
-        verify(moPubView, never()).adClosed();
-        verify(moPubView, never()).registerClick();
-    }
-}
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.location.Location;
+import android.view.View;
+
+import com.mopub.common.AdReport;
+import com.mopub.common.DataKeys;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.factories.CustomEventBannerFactory;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import static com.mopub.mobileads.CustomEventBanner.CustomEventBannerListener;
+import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR;
+import static com.mopub.mobileads.MoPubErrorCode.NETWORK_TIMEOUT;
+import static com.mopub.mobileads.MoPubErrorCode.UNSPECIFIED;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class CustomEventBannerAdapterTest {
+    private CustomEventBannerAdapter subject;
+    @Mock
+    private MoPubView moPubView;
+    @Mock
+    private AdReport mockAdReport;
+    private static final String CLASS_NAME = "arbitrary_banner_adapter_class_name";
+    private static final long BROADCAST_IDENTIFIER = 123;
+    private Map<String, String> serverExtras;
+    private CustomEventBanner banner;
+    private Map<String,Object> localExtras;
+    private Map<String,Object> expectedLocalExtras;
+    private HashMap<String,String> expectedServerExtras;
+
+    @Before
+    public void setUp() throws Exception {
+
+        when(moPubView.getAdTimeoutDelay()).thenReturn(null);
+        when(moPubView.getAdWidth()).thenReturn(320);
+        when(moPubView.getAdHeight()).thenReturn(50);
+
+        localExtras = new HashMap<String, Object>();
+        when(moPubView.getLocalExtras()).thenReturn(localExtras);
+
+        serverExtras = new HashMap<String, String>();
+        serverExtras.put("key", "value");
+        serverExtras.put("another_key", "another_value");
+        subject = new CustomEventBannerAdapter(moPubView, CLASS_NAME, serverExtras, BROADCAST_IDENTIFIER, mockAdReport);
+
+        expectedLocalExtras = new HashMap<String, Object>();
+        expectedLocalExtras.put(DataKeys.AD_REPORT_KEY, mockAdReport);
+        expectedLocalExtras.put("broadcastIdentifier", BROADCAST_IDENTIFIER);
+        expectedLocalExtras.put(DataKeys.AD_WIDTH, 320);
+        expectedLocalExtras.put(DataKeys.AD_HEIGHT, 50);
+
+        expectedServerExtras = new HashMap<String, String>();
+
+        banner = CustomEventBannerFactory.create(CLASS_NAME);
+    }
+
+    @Test
+    public void constructor_shouldPopulateLocalExtrasWithAdWidthAndHeight() throws Exception {
+        assertThat(localExtras.get("com_mopub_ad_width")).isEqualTo(320);
+        assertThat(localExtras.get("com_mopub_ad_height")).isEqualTo(50);
+    }
+
+    @Test
+    public void timeout_shouldSignalFailureAndInvalidateWithDefaultDelay() throws Exception {
+        subject.loadAd();
+
+        Robolectric.idleMainLooper(CustomEventBannerAdapter.DEFAULT_BANNER_TIMEOUT_DELAY - 1);
+        verify(moPubView, never()).loadFailUrl(eq(NETWORK_TIMEOUT));
+        assertThat(subject.isInvalidated()).isFalse();
+
+        Robolectric.idleMainLooper(1);
+        verify(moPubView).loadFailUrl(eq(NETWORK_TIMEOUT));
+        assertThat(subject.isInvalidated()).isTrue();
+    }
+
+    @Test
+    public void timeout_withNegativeAdTimeoutDelay_shouldSignalFailureAndInvalidateWithDefaultDelay() throws Exception {
+        when(moPubView.getAdTimeoutDelay()).thenReturn(-1);
+
+        subject.loadAd();
+
+        Robolectric.idleMainLooper(CustomEventBannerAdapter.DEFAULT_BANNER_TIMEOUT_DELAY - 1);
+        verify(moPubView, never()).loadFailUrl(eq(NETWORK_TIMEOUT));
+        assertThat(subject.isInvalidated()).isFalse();
+
+        Robolectric.idleMainLooper(1);
+        verify(moPubView).loadFailUrl(eq(NETWORK_TIMEOUT));
+        assertThat(subject.isInvalidated()).isTrue();
+    }
+
+    @Test
+    public void timeout_withNonNullAdTimeoutDelay_shouldSignalFailureAndInvalidateWithCustomDelay() throws Exception {
+       when(moPubView.getAdTimeoutDelay()).thenReturn(77);
+
+        subject.loadAd();
+
+        Robolectric.idleMainLooper(77000 - 1);
+        verify(moPubView, never()).loadFailUrl(eq(NETWORK_TIMEOUT));
+        assertThat(subject.isInvalidated()).isFalse();
+
+        Robolectric.idleMainLooper(1);
+        verify(moPubView).loadFailUrl(eq(NETWORK_TIMEOUT));
+        assertThat(subject.isInvalidated()).isTrue();
+    }
+
+
+    @Test
+    public void loadAd_shouldPropagateLocationInLocalExtras() throws Exception {
+        Location expectedLocation = new Location("");
+        expectedLocation.setLongitude(10.0);
+        expectedLocation.setLongitude(20.1);
+
+        when(moPubView.getLocation()).thenReturn(expectedLocation);
+        subject = new CustomEventBannerAdapter(moPubView, CLASS_NAME, new HashMap<String, String>(), BROADCAST_IDENTIFIER, mockAdReport);
+        subject.loadAd();
+
+        expectedLocalExtras.put("location", moPubView.getLocation());
+
+        verify(banner).loadBanner(
+                any(Context.class),
+                eq(subject),
+                eq(expectedLocalExtras),
+                eq(expectedServerExtras)
+        );
+    }
+
+    @Test
+    public void loadAd_shouldPropagateServerExtrasToLoadBanner() throws Exception {
+        subject.loadAd();
+
+        expectedServerExtras.put("key", "value");
+        expectedServerExtras.put("another_key", "another_value");
+
+        verify(banner).loadBanner(
+                any(Context.class),
+                eq(subject),
+                eq(expectedLocalExtras),
+                eq(expectedServerExtras)
+        );
+    }
+
+    @Test
+    public void loadAd_shouldScheduleTimeout_bannerLoadedAndFailed_shouldCancelTimeout() throws Exception {
+        Robolectric.pauseMainLooper();
+
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+
+        subject.loadAd();
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+
+        subject.onBannerLoaded(null);
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+
+        subject.loadAd();
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+
+        subject.onBannerFailed(null);
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+    }
+
+    @Test
+    public void loadAd_shouldScheduleTimeoutRunnableBeforeCallingLoadBanner() throws Exception {
+        Robolectric.pauseMainLooper();
+
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+
+        Answer assertTimeoutRunnableHasStarted = new Answer() {
+            @Override
+            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+                assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+                return null;
+            }
+        };
+
+        doAnswer(assertTimeoutRunnableHasStarted)
+                .when(banner)
+                .loadBanner(
+                        any(Context.class),
+                        any(CustomEventBannerListener.class),
+                        any(Map.class),
+                        any(Map.class)
+                );
+
+        subject.loadAd();
+    }
+
+
+    @Test
+    public void loadAd_whenCallingOnBannerFailed_shouldCancelExistingTimeoutRunnable() throws Exception {
+        Robolectric.pauseMainLooper();
+
+        Answer justCallOnBannerFailed = new Answer() {
+            @Override
+            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+                assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+                subject.onBannerFailed(null);
+                assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+                return null;
+            }
+        };
+
+        doAnswer(justCallOnBannerFailed)
+                .when(banner)
+                .loadBanner(
+                        any(Context.class),
+                        any(CustomEventBannerListener.class),
+                        any(Map.class),
+                        any(Map.class)
+                );
+
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+        subject.loadAd();
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+    }
+
+    @Test
+    public void onBannerLoaded_shouldSignalMoPubView() throws Exception {
+        View view = new View(Robolectric.buildActivity(Activity.class).create().get());
+        subject.onBannerLoaded(view);
+
+        verify(moPubView).nativeAdLoaded();
+        verify(moPubView).setAdContentView(eq(view));
+        verify(moPubView).trackNativeImpression();
+    }
+
+    @Test
+    public void onBannerLoaded_whenViewIsHtmlBannerWebView_shouldNotTrackImpression() throws Exception {
+        View mockHtmlBannerWebView = mock(HtmlBannerWebView.class);
+        subject.onBannerLoaded(mockHtmlBannerWebView);
+
+        verify(moPubView).nativeAdLoaded();
+        verify(moPubView).setAdContentView(eq(mockHtmlBannerWebView));
+        verify(moPubView, never()).trackNativeImpression();
+    }
+
+    @Test
+    public void onBannerFailed_shouldLoadFailUrl() throws Exception {
+        subject.onBannerFailed(ADAPTER_CONFIGURATION_ERROR);
+
+        verify(moPubView).loadFailUrl(eq(ADAPTER_CONFIGURATION_ERROR));
+    }
+
+    @Test
+    public void onBannerFailed_whenErrorCodeIsNull_shouldPassUnspecifiedError() throws Exception {
+        subject.onBannerFailed(null);
+
+        verify(moPubView).loadFailUrl(eq(UNSPECIFIED));
+    }
+
+    @Test
+    public void onBannerExpanded_shouldPauseRefreshAndCallAdPresentOverlay() throws Exception {
+        subject.onBannerExpanded();
+
+        verify(moPubView).setAutorefreshEnabled(eq(false));
+        verify(moPubView).adPresentedOverlay();
+    }
+
+    @Test
+    public void onBannerCollapsed_shouldRestoreRefreshSettingAndCallAdClosed() throws Exception {
+        when(moPubView.getAutorefreshEnabled()).thenReturn(true);
+        subject.onBannerExpanded();
+        reset(moPubView);
+        subject.onBannerCollapsed();
+        verify(moPubView).setAutorefreshEnabled(eq(true));
+        verify(moPubView).adClosed();
+
+        when(moPubView.getAutorefreshEnabled()).thenReturn(false);
+        subject.onBannerExpanded();
+        reset(moPubView);
+        subject.onBannerCollapsed();
+        verify(moPubView).setAutorefreshEnabled(eq(false));
+        verify(moPubView).adClosed();
+    }
+
+    @Test
+    public void onBannerClicked_shouldRegisterClick() throws Exception {
+        subject.onBannerClicked();
+
+        verify(moPubView).registerClick();
+    }
+
+    @Test
+    public void onLeaveApplication_shouldRegisterClick() throws Exception {
+        subject.onLeaveApplication();
+
+        verify(moPubView).registerClick();
+    }
+
+    @Test
+    public void invalidate_shouldCauseLoadAdToDoNothing() throws Exception {
+        subject.invalidate();
+
+        subject.loadAd();
+
+        verify(banner, never()).loadBanner(
+                any(Context.class),
+                any(CustomEventBannerListener.class),
+                any(Map.class),
+                any(Map.class)
+        );
+    }
+
+    @Test
+    public void invalidate_shouldCauseBannerListenerMethodsToDoNothing() throws Exception {
+        subject.invalidate();
+
+        subject.onBannerLoaded(null);
+        subject.onBannerFailed(null);
+        subject.onBannerExpanded();
+        subject.onBannerCollapsed();
+        subject.onBannerClicked();
+        subject.onLeaveApplication();
+
+        verify(moPubView, never()).nativeAdLoaded();
+        verify(moPubView, never()).setAdContentView(any(View.class));
+        verify(moPubView, never()).trackNativeImpression();
+        verify(moPubView, never()).loadFailUrl(any(MoPubErrorCode.class));
+        verify(moPubView, never()).setAutorefreshEnabled(any(boolean.class));
+        verify(moPubView, never()).adClosed();
+        verify(moPubView, never()).registerClick();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlWebViewClientTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlWebViewClientTest.java
index e9b9ad44..d2db93fd 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlWebViewClientTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlWebViewClientTest.java
@@ -1,505 +1,469 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.content.ActivityNotFoundException;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.ResolveInfo;
-import android.net.Uri;
-import android.webkit.WebView;
-
-import com.mopub.common.MoPubBrowser;
-import com.mopub.common.test.support.SdkTestRunner;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.ArgumentCaptor;
-import org.robolectric.Robolectric;
-
-import static com.mopub.mobileads.MoPubErrorCode.UNSPECIFIED;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Mockito.any;
-import static org.mockito.Mockito.doThrow;
-import static org.mockito.Mockito.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.stub;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-@RunWith(SdkTestRunner.class)
-public class HtmlWebViewClientTest {
-
-    private static final String CLICKTHROUGH_URL = "http://clickthrough";
-
-    private HtmlWebViewClient subject;
-    private HtmlWebViewListener htmlWebViewListener;
-    private BaseHtmlWebView htmlWebView;
-    private Context context;
-
-    @Before
-    public void setUp() throws Exception {
-        htmlWebViewListener = mock(HtmlWebViewListener.class);
-        htmlWebView = mock(BaseHtmlWebView.class);
-        context = Robolectric.buildActivity(Activity.class).create().get().getApplicationContext();
-        when(htmlWebView.getContext()).thenReturn(context);
-        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, CLICKTHROUGH_URL, "redirect");
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withMoPubFinishLoad_shouldCallAdDidLoad() throws Exception {
-        boolean didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, "mopub://finishLoad");
-
-        assertThat(didOverrideUrl).isTrue();
-        verify(htmlWebViewListener).onLoaded(eq(htmlWebView));
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withMoPubClose_shouldCallAdDidClose() throws Exception {
-        boolean didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, "mopub://close");
-
-        assertThat(didOverrideUrl).isTrue();
-        verify(htmlWebViewListener).onCollapsed();
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withMoPubFailLoad_shouldCallLoadFailUrl() throws Exception {
-        boolean didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, "mopub://failLoad");
-
-        assertThat(didOverrideUrl).isTrue();
-        verify(htmlWebViewListener).onFailed(UNSPECIFIED);
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withMoPubCustom_withUserClick_shouldStartCustomIntent() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(true);
-
-        boolean didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, "mopub://custom?fnc=myFnc&data=myData");
-
-        assertThat(didOverrideUrl).isTrue();
-        verify(htmlWebViewListener).onClicked();
-        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedActivity).isNotNull();
-        assertThat(startedActivity.getAction()).isEqualTo("myFnc");
-        assertThat(startedActivity.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
-        assertThat(startedActivity.getStringExtra(HtmlBannerWebView.EXTRA_AD_CLICK_DATA)).isEqualTo("myData");
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withMoPubCustom_withoutUserClick_shouldNotStartActivity() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(false);
-
-        boolean didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, "mopub://custom?fnc=myFnc&data=myData");
-
-        assertThat(didOverrideUrl).isTrue();
-        verify(htmlWebViewListener, never()).onClicked();
-        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedActivity).isNull();
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withMoPubCustomAndNullData_withUserClick_shouldStartCustomIntent() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(true);
-
-        boolean didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, "mopub://custom?fnc=myFnc");
-
-        assertThat(didOverrideUrl).isTrue();
-        verify(htmlWebViewListener).onClicked();
-        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedActivity).isNotNull();
-        assertThat(startedActivity.getAction()).isEqualTo("myFnc");
-        assertThat(startedActivity.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
-        assertThat(startedActivity.getStringExtra(HtmlBannerWebView.EXTRA_AD_CLICK_DATA)).isNull();
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withMoPubCustomAndNullData_withoutUserClick_shouldNotStartCustomIntent() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(false);
-
-        boolean didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, "mopub://custom?fnc=myFnc");
-
-        assertThat(didOverrideUrl).isTrue();
-        verify(htmlWebViewListener, never()).onClicked();
-        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedActivity).isNull();
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withPhoneIntent_shouldStartDefaultIntent() throws Exception {
-        assertPhoneUrlStartedCorrectIntent("tel:");
-        assertPhoneUrlStartedCorrectIntent("voicemail:");
-        assertPhoneUrlStartedCorrectIntent("sms:");
-        assertPhoneUrlStartedCorrectIntent("mailto:");
-        assertPhoneUrlStartedCorrectIntent("geo:");
-        assertPhoneUrlStartedCorrectIntent("google.streetview:");
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withCustomApplicationIntent_withUserClick_andCanHandleCustomIntent_shouldTryToLaunchCustomIntent() throws Exception {
-        String customUrl = "myintent://something";
-        stub(htmlWebView.wasClicked()).toReturn(true);
-        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(Intent.ACTION_VIEW, Uri.parse(customUrl)), new ResolveInfo());
-
-        boolean didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, customUrl);
-
-        assertThat(didOverrideUrl).isTrue();
-        verify(htmlWebViewListener).onClicked();
-        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(intent).isNotNull();
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withCustomApplicationIntent_withoutUserClick_shouldNotTryToLaunchIntent() throws Exception {
-        String customUrl = "myintent://something";
-        stub(htmlWebView.wasClicked()).toReturn(false);
-        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
-
-        boolean didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, customUrl);
-
-        assertThat(didOverrideUrl).isTrue();
-        verify(htmlWebViewListener, never()).onClicked();
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withCustomApplicationIntent_withUserClick_butCanNotHandleCustomIntent_shouldFailSilently() throws Exception {
-        String customUrl = "myintent://something";
-        stub(htmlWebView.wasClicked()).toReturn(true);
-        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
-
-        boolean didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, customUrl);
-
-        assertThat(didOverrideUrl).isTrue();
-        verify(htmlWebViewListener, never()).onClicked();
-        Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedIntent).isNull();
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withHttpUrl_withUserClick_shouldOpenBrowser() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(true);
-        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
-        String validUrl = "http://www.mopub.com";
-        boolean didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, validUrl);
-
-        assertThat(didOverrideUrl).isTrue();
-        verify(htmlWebViewListener).onClicked();
-
-        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedActivity.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
-        assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(validUrl);
-        assertThat(startedActivity.getData()).isNull();
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withHttpUrl_withoutUserClick_shouldNotOpenBrowser() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(false);
-        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
-        String validUrl = "http://www.mopub.com";
-        boolean didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, validUrl);
-
-        assertThat(didOverrideUrl).isTrue();
-        verify(htmlWebViewListener, never()).onClicked();
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withClickTrackingRedirect_withUserClick_shouldNotChangeUrl() throws Exception {
-        String validUrl = "http://www.mopub.com";
-        stub(htmlWebView.wasClicked()).toReturn(true);
-
-        subject.shouldOverrideUrlLoading(htmlWebView, validUrl);
-
-        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(validUrl);
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withClickTrackingRedirect_withoutUserClick_shouldChangeUrl() throws Exception {
-        String validUrl = "http://www.mopub.com";
-        stub(htmlWebView.wasClicked()).toReturn(false);
-
-        subject.shouldOverrideUrlLoading(htmlWebView, validUrl);
-
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withEmptyUrl_withUserClick_shouldFailSilently() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(true);
-        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
-
-        subject.shouldOverrideUrlLoading(htmlWebView, "");
-
-        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedActivity).isNull();
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withEmptyUrl_withoutUserClick_shouldLoadAboutBlank() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(false);
-        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
-
-        subject.shouldOverrideUrlLoading(htmlWebView, "");
-
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withNativeBrowserScheme_withUserClick_shouldStartIntentWithActionView() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(true);
-        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
-
-        boolean shouldOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView,
-                "mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.mopub.com");
-
-        assertThat(shouldOverrideUrl).isTrue();
-        verify(htmlWebViewListener).onClicked();
-        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedActivity.getAction()).isEqualTo("android.intent.action.VIEW");
-        assertThat(startedActivity.getData().toString()).isEqualTo("http://www.mopub.com");
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withNativeBrowserScheme_withoutUserClick_shouldStartIntentWithActionView() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(false);
-        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
-
-        boolean shouldOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView,
-                "mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.mopub.com");
-
-        assertThat(shouldOverrideUrl).isTrue();
-        verify(htmlWebViewListener, never()).onClicked();
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withNativeBrowserScheme_butOpaqueUri_withUserClick_shouldNotBeHandledByNativeBrowser() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(true);
-        String opaqueNativeBrowserUriString = "mopubnativebrowser:navigate?url=http%3A%2F%2Fwww.mopub.com";
-        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
-
-        boolean shouldOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, opaqueNativeBrowserUriString);
-
-        assertThat(shouldOverrideUrl).isTrue();
-        verify(htmlWebViewListener, never()).onClicked();
-        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedActivity).isNull();
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withNativeBrowserScheme_butOpaqueUri_withoutUserClick_shouldNotLoad() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(false);
-        String opaqueNativeBrowserUriString = "mopubnativebrowser:navigate?url=http%3A%2F%2Fwww.mopub.com";
-        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
-
-        boolean shouldOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, opaqueNativeBrowserUriString);
-
-        assertThat(shouldOverrideUrl).isTrue();
-        verify(htmlWebViewListener, never()).onClicked();
-
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withNativeBrowserScheme_withInvalidHostSchemeUrl_withUserClick_shouldFailSilently() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(true);
-        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
-
-        boolean shouldOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, "something://blah?url=invalid");
-
-        assertThat(shouldOverrideUrl).isTrue();
-        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedActivity).isNull();
-
-        verify(htmlWebViewListener, never()).onClicked();
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withNativeBrowserScheme_withInvalidHostSchemeUrl_withoutUserClick_shouldNotInvokeNativeBrowser() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(false);
-        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
-
-        boolean shouldOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, "something://blah?url=invalid");
-
-        assertThat(shouldOverrideUrl).isTrue();
-        verify(htmlWebViewListener, never()).onClicked();
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withAboutBlankUrl_shouldFailSilently() {
-        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
-
-        subject.shouldOverrideUrlLoading(htmlWebView, "about:blank");
-
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
-        verify(htmlWebViewListener, never()).onClicked();
-    }
-
-    @Test
-    public void onPageStarted_whenLoadedUrlStartsWithRedirect_withUserClick_shouldOpenInBrowser() throws Exception {
-        String url = "redirectUrlToLoad";
-        stub(htmlWebView.wasClicked()).toReturn(true);
-        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, "redirect");
-        WebView view = mock(WebView.class);
-        subject.onPageStarted(view, url, null);
-
-        verify(view).stopLoading();
-
-        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(intent.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(url);
-        assertThat(intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
-        assertThat(intent.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
-    }
-
-    @Test
-    public void onPageStarted_whenLoadedUrlStartsWithRedirect_withoutUserClick_shouldOpenInBrowser() throws Exception {
-        String url = "redirectUrlToLoad";
-        stub(htmlWebView.wasClicked()).toReturn(false);
-        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, "redirect");
-        WebView view = mock(WebView.class);
-        subject.onPageStarted(view, url, null);
-
-        verify(view).stopLoading();
-
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
-    }
-
-    @Test
-    public void onPageStarted_whenLoadedUrlStartsWithRedirectAndHasClickthrough_withUserClick_shouldNotChangeUrl_shouldOpenInBrowser() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(true);
-        String url = "redirectUrlToLoad";
-        WebView view = mock(WebView.class);
-        subject.onPageStarted(view, url, null);
-
-        verify(view).stopLoading();
-
-        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(intent.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(url);
-        assertThat(intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
-        assertThat(intent.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
-    }
-
-    @Test
-    public void onPageStarted_whenLoadedUrlStartsWithRedirectAndHasClickthrough_withoutUserClick_shouldNotOpenInBrowser() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(false);
-        String url = "redirectUrlToLoad";
-        WebView view = mock(WebView.class);
-        subject.onPageStarted(view, url, null);
-
-        verify(view).stopLoading();
-
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
-    }
-
-    @Test
-    public void onPageStarted_whenLoadedUrlStartsWithRedirectAndHasClickthrough_withUserClick_whenMoPubBrowserCannotHandleIntent_shouldFailSilently() throws Exception {
-        Context mockContext = mock(Context.class);
-        stub(htmlWebView.wasClicked()).toReturn(true);
-        stub(htmlWebView.getContext()).toReturn(mockContext);
-        String url = "redirectUrlToLoad";
-
-        // We only want startActivity() to throw an exception the first time we call it.
-        doThrow(new ActivityNotFoundException())
-                .doNothing()
-                .when(mockContext).startActivity(any(Intent.class));
-
-        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, CLICKTHROUGH_URL, "redirect");
-        subject.onPageStarted(htmlWebView, url, null);
-
-        ArgumentCaptor<Intent> intentArgumentCaptor = ArgumentCaptor.forClass(Intent.class);
-        verify(mockContext).startActivity(intentArgumentCaptor.capture());
-
-        Intent intent = intentArgumentCaptor.getValue();
-        assertThat(intent.getData()).isNull();
-        verify(htmlWebViewListener, never()).onClicked();
-    }
-
-    @Test
-    public void onPageStarted_whenLoadedUrlDoesntStartWithRedirect_shouldDoNothing() throws Exception {
-        WebView view = mock(WebView.class);
-        subject.onPageStarted(view, "this doesn't start with redirect", null);
-
-        verify(view, never()).stopLoading();
-
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
-    }
-
-    @Test
-    public void launchIntentForUserClick_shouldStartActivityAndResetClickStatusAndReturnTrue() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(true);
-        Context context = mock(Context.class);
-        Intent intent = mock(Intent.class);
-
-        boolean result = subject.launchIntentForUserClick(context, intent, null);
-
-        verify(context).startActivity(eq(intent));
-        verify(htmlWebView).onResetUserClick();
-        assertThat(result).isTrue();
-    }
-
-    @Test
-    public void launchIntentForUserClick_whenUserHasNotClicked_shouldNotStartActivityAndReturnFalse() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(false);
-        Context context = mock(Context.class);
-        Intent intent = mock(Intent.class);
-
-        boolean result = subject.launchIntentForUserClick(context, intent, null);
-
-        verify(context, never()).startActivity(any(Intent.class));
-        verify(htmlWebView, never()).onResetUserClick();
-        assertThat(result).isFalse();
-    }
-
-    @Test
-    public void launchIntentForUserClick_whenNoMatchingActivity_shouldNotStartActivityAndReturnFalse() throws Exception {
-        Context context = mock(Context.class);
-        Intent intent = mock(Intent.class);
-
-        stub(htmlWebView.wasClicked()).toReturn(true);
-        doThrow(new ActivityNotFoundException()).when(context).startActivity(any(Intent.class));
-
-        boolean result = subject.launchIntentForUserClick(context, intent, null);
-
-        verify(htmlWebView, never()).onResetUserClick();
-        assertThat(result).isFalse();
-
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
-    }
-
-    @Test
-    public void launchIntentForUserClick_whenContextIsNull_shouldNotStartActivityAndReturnFalse() throws Exception {
-        stub(htmlWebView.wasClicked()).toReturn(true);
-        Intent intent = new Intent();
-
-        boolean result = subject.launchIntentForUserClick(null, intent, null);
-
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
-        verify(htmlWebView, never()).onResetUserClick();
-        assertThat(result).isFalse();
-    }
-
-    private void assertPhoneUrlStartedCorrectIntent(String url) {
-        boolean didOverrideUrl;
-
-        stub(htmlWebView.wasClicked()).toReturn(true);
-        didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, url);
-        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedActivity.getAction()).isEqualTo(Intent.ACTION_VIEW);
-        assertThat(startedActivity.getData().toString()).isEqualTo(url);
-        assertThat(didOverrideUrl).isTrue();
-        verify(htmlWebViewListener).onClicked();
-        reset(htmlWebViewListener);
-
-        stub(htmlWebView.wasClicked()).toReturn(false);
-        didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, url);
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
-        assertThat(didOverrideUrl).isTrue();
-        verify(htmlWebViewListener, never()).onClicked();
-        reset(htmlWebViewListener);
-    }
-}
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.ActivityNotFoundException;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.ResolveInfo;
+import android.net.Uri;
+import android.webkit.WebView;
+
+import com.mopub.common.MoPubBrowser;
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.robolectric.Robolectric;
+
+import static com.mopub.mobileads.MoPubErrorCode.UNSPECIFIED;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.stub;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class HtmlWebViewClientTest {
+
+    private static final String CLICKTHROUGH_URL = "http://clickthrough";
+
+    private HtmlWebViewClient subject;
+    private HtmlWebViewListener htmlWebViewListener;
+    private BaseHtmlWebView htmlWebView;
+    private Context context;
+
+    @Before
+    public void setUp() throws Exception {
+        htmlWebViewListener = mock(HtmlWebViewListener.class);
+        htmlWebView = mock(BaseHtmlWebView.class);
+        context = Robolectric.buildActivity(Activity.class).create().get().getApplicationContext();
+        when(htmlWebView.getContext()).thenReturn(context);
+        when(htmlWebView.wasClicked()).thenReturn(true);
+        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, CLICKTHROUGH_URL, "redirect");
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withMoPubFinishLoad_shouldCallAdDidLoad() throws Exception {
+        boolean didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, "mopub://finishLoad");
+
+        assertThat(didOverrideUrl).isTrue();
+        verify(htmlWebViewListener).onLoaded(eq(htmlWebView));
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withMoPubClose_shouldCallAdDidClose() throws Exception {
+        boolean didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, "mopub://close");
+
+        assertThat(didOverrideUrl).isTrue();
+        verify(htmlWebViewListener).onCollapsed();
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withMoPubFailLoad_shouldCallLoadFailUrl() throws Exception {
+        boolean didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, "mopub://failLoad");
+
+        assertThat(didOverrideUrl).isTrue();
+        verify(htmlWebViewListener).onFailed(UNSPECIFIED);
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withPhoneIntent_shouldStartDefaultIntent() throws Exception {
+        assertPhoneUrlStartedCorrectIntent("tel:");
+        assertPhoneUrlStartedCorrectIntent("voicemail:");
+        assertPhoneUrlStartedCorrectIntent("sms:");
+        assertPhoneUrlStartedCorrectIntent("mailto:");
+        assertPhoneUrlStartedCorrectIntent("geo:");
+        assertPhoneUrlStartedCorrectIntent("google.streetview:");
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withCustomApplicationIntent_withUserClick_andCanHandleCustomIntent_shouldTryToLaunchCustomIntent() throws Exception {
+        String customUrl = "myintent://something";
+        stub(htmlWebView.wasClicked()).toReturn(true);
+        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(Intent.ACTION_VIEW, Uri.parse(customUrl)), new ResolveInfo());
+
+        boolean didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, customUrl);
+
+        assertThat(didOverrideUrl).isTrue();
+        verify(htmlWebViewListener).onClicked();
+        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(intent).isNotNull();
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withCustomApplicationIntent_withoutUserClick_shouldNotTryToLaunchIntent() throws Exception {
+        String customUrl = "myintent://something";
+        stub(htmlWebView.wasClicked()).toReturn(false);
+        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
+
+        boolean didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, customUrl);
+
+        assertThat(didOverrideUrl).isTrue();
+        verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withCustomApplicationIntent_withUserClick_butCanNotHandleCustomIntent_shouldFailSilently() throws Exception {
+        String customUrl = "myintent://something";
+        stub(htmlWebView.wasClicked()).toReturn(true);
+        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
+
+        boolean didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, customUrl);
+
+        assertThat(didOverrideUrl).isTrue();
+        verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
+        Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(startedIntent).isNull();
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withHttpUrl_withUserClick_shouldOpenBrowser() throws Exception {
+        stub(htmlWebView.wasClicked()).toReturn(true);
+        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
+        String validUrl = "http://www.mopub.com";
+        boolean didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, validUrl);
+
+        assertThat(didOverrideUrl).isTrue();
+        verify(htmlWebViewListener).onClicked();
+
+        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(startedActivity.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
+        assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(validUrl);
+        assertThat(startedActivity.getData()).isNull();
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withHttpUrl_withoutUserClick_shouldNotOpenBrowser() throws Exception {
+        stub(htmlWebView.wasClicked()).toReturn(false);
+        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
+        String validUrl = "http://www.mopub.com";
+        boolean didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, validUrl);
+
+        assertThat(didOverrideUrl).isTrue();
+        verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withClickTrackingRedirect_withUserClick_shouldNotChangeUrl() throws Exception {
+        String validUrl = "http://www.mopub.com";
+        stub(htmlWebView.wasClicked()).toReturn(true);
+
+        subject.shouldOverrideUrlLoading(htmlWebView, validUrl);
+
+        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(validUrl);
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withClickTrackingRedirect_withoutUserClick_shouldChangeUrl() throws Exception {
+        String validUrl = "http://www.mopub.com";
+        stub(htmlWebView.wasClicked()).toReturn(false);
+
+        subject.shouldOverrideUrlLoading(htmlWebView, validUrl);
+
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withEmptyUrl_withUserClick_shouldFailSilently() throws Exception {
+        stub(htmlWebView.wasClicked()).toReturn(true);
+        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
+
+        subject.shouldOverrideUrlLoading(htmlWebView, "");
+
+        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(startedActivity).isNull();
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withEmptyUrl_withoutUserClick_shouldLoadAboutBlank() throws Exception {
+        stub(htmlWebView.wasClicked()).toReturn(false);
+        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
+
+        subject.shouldOverrideUrlLoading(htmlWebView, "");
+
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withNativeBrowserScheme_withUserClick_shouldStartIntentWithActionView() throws Exception {
+        stub(htmlWebView.wasClicked()).toReturn(true);
+        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
+
+        boolean shouldOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView,
+                "mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.mopub.com");
+
+        assertThat(shouldOverrideUrl).isTrue();
+        verify(htmlWebViewListener).onClicked();
+        verify(htmlWebView).onResetUserClick();
+        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(startedActivity.getAction()).isEqualTo("android.intent.action.VIEW");
+        assertThat(startedActivity.getData().toString()).isEqualTo("http://www.mopub.com");
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withNativeBrowserScheme_withoutUserClick_shouldStartIntentWithActionView() throws Exception {
+        stub(htmlWebView.wasClicked()).toReturn(false);
+        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
+
+        boolean shouldOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView,
+                "mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.mopub.com");
+
+        assertThat(shouldOverrideUrl).isTrue();
+        verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withNativeBrowserScheme_butOpaqueUri_withUserClick_shouldNotBeHandledByNativeBrowser() throws Exception {
+        stub(htmlWebView.wasClicked()).toReturn(true);
+        String opaqueNativeBrowserUriString = "mopubnativebrowser:navigate?url=http%3A%2F%2Fwww.mopub.com";
+        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
+
+        boolean shouldOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, opaqueNativeBrowserUriString);
+
+        assertThat(shouldOverrideUrl).isTrue();
+        verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
+        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(startedActivity).isNull();
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withNativeBrowserScheme_butOpaqueUri_withoutUserClick_shouldNotLoad() throws Exception {
+        stub(htmlWebView.wasClicked()).toReturn(false);
+        String opaqueNativeBrowserUriString = "mopubnativebrowser:navigate?url=http%3A%2F%2Fwww.mopub.com";
+        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
+
+        boolean shouldOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, opaqueNativeBrowserUriString);
+
+        assertThat(shouldOverrideUrl).isTrue();
+        verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
+
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withNativeBrowserScheme_withInvalidHostSchemeUrl_withUserClick_shouldFailSilently() throws Exception {
+        stub(htmlWebView.wasClicked()).toReturn(true);
+        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
+
+        boolean shouldOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, "something://blah?url=invalid");
+
+        assertThat(shouldOverrideUrl).isTrue();
+        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(startedActivity).isNull();
+
+        verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withNativeBrowserScheme_withInvalidHostSchemeUrl_withoutUserClick_shouldNotInvokeNativeBrowser() throws Exception {
+        stub(htmlWebView.wasClicked()).toReturn(false);
+        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
+
+        boolean shouldOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, "something://blah?url=invalid");
+
+        assertThat(shouldOverrideUrl).isTrue();
+        verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withAboutBlankUrl_shouldFailSilently() {
+        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
+
+        subject.shouldOverrideUrlLoading(htmlWebView, "about:blank");
+
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+        verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withMoPubFinishLoad_withoutUserClick_shouldDoNothing() throws Exception {
+        assertNothingHappensWithoutClick("mopub://finishLoad");
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withMoPubClose_withoutUserClick_shouldDoNothing() throws Exception {
+        assertNothingHappensWithoutClick("mopub://close");
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withMoPubFailLoad_withoutUserClick_shouldDoNothing() throws Exception {
+        assertNothingHappensWithoutClick("mopub://fail");
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withAboutScheme_withoutUserClick_shouldDoNothing() throws Exception {
+        assertNothingHappensWithoutClick("about:blank");
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withPhoneScheme_withoutUserClick_shouldDoNothing() throws Exception {
+        assertNothingHappensWithoutClick("tel:");
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withMarketUrl_withoutUserClick_shouldDoNothing() throws Exception {
+        assertNothingHappensWithoutClick("http://play.google.com/");
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withNativeBrowserUrl_withoutUserClick_shouldDoNothing() throws Exception {
+        assertNothingHappensWithoutClick("mopubnativebrowser://");
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withInAppBrowserUrl_withoutUserClick_shouldDoNothing() throws Exception {
+        assertNothingHappensWithoutClick("http://twitter.com");
+    }
+
+    @Test
+    public void shouldOverrideUrlLoading_withDeepLinkUrl_withoutUserClick_shouldDoNothing() throws Exception {
+        assertNothingHappensWithoutClick("myapp://view");
+    }
+
+    @Test
+    public void onPageStarted_whenLoadedUrlStartsWithRedirect_withUserClick_shouldOpenInBrowser() throws Exception {
+        String url = "redirectUrlToLoad";
+        stub(htmlWebView.wasClicked()).toReturn(true);
+        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, "redirect");
+        WebView view = mock(WebView.class);
+        subject.onPageStarted(view, url, null);
+
+        verify(view).stopLoading();
+
+        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(intent.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(url);
+        assertThat(intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
+        assertThat(intent.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
+    }
+
+    @Test
+    public void onPageStarted_whenLoadedUrlStartsWithRedirect_withoutUserClick_shouldOpenInBrowser() throws Exception {
+        String url = "redirectUrlToLoad";
+        stub(htmlWebView.wasClicked()).toReturn(false);
+        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, "redirect");
+        WebView view = mock(WebView.class);
+        subject.onPageStarted(view, url, null);
+
+        verify(view).stopLoading();
+
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+    }
+
+    @Test
+    public void onPageStarted_whenLoadedUrlStartsWithRedirectAndHasClickthrough_withUserClick_shouldNotChangeUrl_shouldOpenInBrowser() throws Exception {
+        stub(htmlWebView.wasClicked()).toReturn(true);
+        String url = "redirectUrlToLoad";
+        WebView view = mock(WebView.class);
+        subject.onPageStarted(view, url, null);
+
+        verify(view).stopLoading();
+
+        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(intent.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(url);
+        assertThat(intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
+        assertThat(intent.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
+    }
+
+    @Test
+    public void onPageStarted_whenLoadedUrlStartsWithRedirectAndHasClickthrough_withoutUserClick_shouldNotOpenInBrowser() throws Exception {
+        when(htmlWebView.wasClicked()).thenReturn(false);
+        String url = "redirectUrlToLoad";
+        WebView view = mock(WebView.class);
+        subject.onPageStarted(view, url, null);
+
+        verify(view).stopLoading();
+
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+    }
+
+    @Test
+    public void onPageStarted_whenLoadedUrlStartsWithRedirectAndHasClickthrough_withUserClick_whenMoPubBrowserCannotHandleIntent_shouldFailSilently() throws Exception {
+        Context mockContext = mock(Context.class);
+        stub(htmlWebView.wasClicked()).toReturn(true);
+        stub(htmlWebView.getContext()).toReturn(mockContext);
+        String url = "redirectUrlToLoad";
+
+        // We only want startActivity() to throw an exception the first time we call it.
+        doThrow(new ActivityNotFoundException())
+                .doNothing()
+                .when(mockContext).startActivity(any(Intent.class));
+
+        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, CLICKTHROUGH_URL, "redirect");
+        subject.onPageStarted(htmlWebView, url, null);
+
+        ArgumentCaptor<Intent> intentArgumentCaptor = ArgumentCaptor.forClass(Intent.class);
+        verify(mockContext).startActivity(intentArgumentCaptor.capture());
+
+        Intent intent = intentArgumentCaptor.getValue();
+        assertThat(intent.getData()).isNull();
+        verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
+    }
+
+    @Test
+    public void onPageStarted_whenLoadedUrlDoesntStartWithRedirect_shouldDoNothing() throws Exception {
+        WebView view = mock(WebView.class);
+        subject.onPageStarted(view, "this doesn't start with redirect", null);
+
+        verify(view, never()).stopLoading();
+
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+    }
+
+    private void assertPhoneUrlStartedCorrectIntent(String url) {
+        boolean didOverrideUrl;
+
+        stub(htmlWebView.wasClicked()).toReturn(true);
+        didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, url);
+        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(startedActivity.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        assertThat(startedActivity.getData().toString()).isEqualTo(url);
+        assertThat(didOverrideUrl).isTrue();
+        verify(htmlWebViewListener).onClicked();
+        verify(htmlWebView).onResetUserClick();
+        reset(htmlWebViewListener);
+        reset(htmlWebView);
+
+        stub(htmlWebView.wasClicked()).toReturn(false);
+        didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, url);
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+        assertThat(didOverrideUrl).isTrue();
+        verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
+        reset(htmlWebViewListener);
+        reset(htmlWebView);
+    }
+
+    private void assertNothingHappensWithoutClick(final String url) {
+        stub(htmlWebView.wasClicked()).toReturn(false);
+
+        subject.shouldOverrideUrlLoading(htmlWebView, url);
+
+        verify(htmlWebViewListener, never()).onClicked();
+        verify(htmlWebView, never()).onResetUserClick();
+        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(startedActivity).isNull();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubActivityTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubActivityTest.java
index 2ffa1587..4dd42595 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubActivityTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubActivityTest.java
@@ -1,294 +1,294 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.ActivityInfo;
-import android.view.View;
-import android.view.ViewGroup;
-import android.webkit.WebViewClient;
-import android.widget.FrameLayout;
-
-import com.mopub.common.AdReport;
-import com.mopub.common.CreativeOrientation;
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.mobileads.test.support.TestHtmlInterstitialWebViewFactory;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Mock;
-import org.robolectric.Robolectric;
-import org.robolectric.shadows.ShadowLocalBroadcastManager;
-
-import static com.mopub.common.DataKeys.CLICKTHROUGH_URL_KEY;
-import static com.mopub.common.DataKeys.CREATIVE_ORIENTATION_KEY;
-import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
-import static com.mopub.common.DataKeys.REDIRECT_URL_KEY;
-import static com.mopub.common.DataKeys.SCROLLABLE_KEY;
-import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
-import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_CLICK;
-import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
-import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_FAIL;
-import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
-import static com.mopub.mobileads.EventForwardingBroadcastReceiver.getHtmlInterstitialIntentFilter;
-import static com.mopub.mobileads.EventForwardingBroadcastReceiverTest.getIntentForActionAndIdentifier;
-import static com.mopub.mobileads.MoPubErrorCode.UNSPECIFIED;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-import static org.robolectric.Robolectric.shadowOf;
-
-@RunWith(SdkTestRunner.class)
-public class MoPubActivityTest {
-    private static final String EXPECTED_HTML_DATA = "htmlData";
-    private static final boolean EXPECTED_IS_SCROLLABLE = true;
-    @Mock private AdReport mockAdReport;
-    private static final String EXPECTED_REDIRECT_URL = "redirectUrl";
-    private static final String EXPECTED_CLICKTHROUGH_URL = "http://expected_url";
-    private static final CreativeOrientation EXPECTED_ORIENTATION = CreativeOrientation.PORTRAIT;
-
-    @Mock private BroadcastReceiver broadcastReceiver;
-    private long testBroadcastIdentifier = 2222;
-
-    private HtmlInterstitialWebView htmlInterstitialWebView;
-    private CustomEventInterstitialListener customEventInterstitialListener;
-
-    private MoPubActivity subject;
-
-    @Before
-    public void setUp() throws Exception {
-        htmlInterstitialWebView = TestHtmlInterstitialWebViewFactory.getSingletonMock();
-        resetMockedView(htmlInterstitialWebView);
-
-        Context context = Robolectric.buildActivity(Activity.class).create().get();
-        Intent moPubActivityIntent = MoPubActivity.createIntent(context,
-                EXPECTED_HTML_DATA, mockAdReport, EXPECTED_IS_SCROLLABLE,
-                EXPECTED_REDIRECT_URL,
-                EXPECTED_CLICKTHROUGH_URL, EXPECTED_ORIENTATION, testBroadcastIdentifier);
-
-        subject = Robolectric.buildActivity(MoPubActivity.class).withIntent(moPubActivityIntent).create().get();
-        customEventInterstitialListener = mock(CustomEventInterstitialListener.class);
-
-        resetMockedView(htmlInterstitialWebView);
-    }
-
-    @Test
-    public void onCreate_shouldHaveLockedOrientation() {
-        // Since robolectric doesn't set a requested orientation, verifying that we have a value tells us that one was set.
-        assertThat(subject.getRequestedOrientation()).isIn(ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT,
-                ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
-    }
-
-    @Test
-    public void preRenderHtml_shouldPreloadTheHtml() throws Exception {
-        String htmlData = "this is nonsense";
-        MoPubActivity.preRenderHtml(subject, mockAdReport, customEventInterstitialListener, htmlData);
-
-        verify(htmlInterstitialWebView).enablePlugins(eq(false));
-        verify(htmlInterstitialWebView).loadHtmlResponse(htmlData);
-    }
-
-    @Test
-    public void preRenderHtml_shouldHaveAWebViewClientThatForwardsFinishLoad() throws Exception {
-        MoPubActivity.preRenderHtml(subject, mockAdReport, customEventInterstitialListener, null);
-
-        ArgumentCaptor<WebViewClient> webViewClientCaptor = ArgumentCaptor.forClass(WebViewClient.class);
-        verify(htmlInterstitialWebView).setWebViewClient(webViewClientCaptor.capture());
-        WebViewClient webViewClient = webViewClientCaptor.getValue();
-
-        webViewClient.shouldOverrideUrlLoading(null, "mopub://finishLoad");
-
-        verify(customEventInterstitialListener).onInterstitialLoaded();
-        verify(customEventInterstitialListener, never()).onInterstitialFailed(any(MoPubErrorCode.class));
-    }
-
-    @Test
-    public void preRenderHtml_shouldHaveAWebViewClientThatForwardsFailLoad() throws Exception {
-        MoPubActivity.preRenderHtml(subject, mockAdReport, customEventInterstitialListener, null);
-
-        ArgumentCaptor<WebViewClient> webViewClientCaptor = ArgumentCaptor.forClass(WebViewClient.class);
-        verify(htmlInterstitialWebView).setWebViewClient(webViewClientCaptor.capture());
-        WebViewClient webViewClient = webViewClientCaptor.getValue();
-
-        webViewClient.shouldOverrideUrlLoading(null, "mopub://failLoad");
-
-        verify(customEventInterstitialListener, never()).onInterstitialLoaded();
-        verify(customEventInterstitialListener).onInterstitialFailed(any(MoPubErrorCode.class));
-    }
-
-    @Test
-    public void onCreate_shouldSetContentView() throws Exception {
-        subject.onCreate(null);
-
-        assertThat(getContentView().getChildCount()).isEqualTo(1);
-    }
-
-    @Test
-    public void onCreate_shouldLayoutWebView() throws Exception {
-        subject.onCreate(null);
-
-        ArgumentCaptor<FrameLayout.LayoutParams> captor = ArgumentCaptor.forClass(FrameLayout.LayoutParams.class);
-        verify(htmlInterstitialWebView).setLayoutParams(captor.capture());
-        FrameLayout.LayoutParams actualLayoutParams = captor.getValue();
-
-        assertThat(actualLayoutParams.width).isEqualTo(FrameLayout.LayoutParams.MATCH_PARENT);
-        assertThat(actualLayoutParams.height).isEqualTo(FrameLayout.LayoutParams.MATCH_PARENT);
-    }
-
-    @Test
-    public void getAdView_shouldReturnPopulatedHtmlWebView() throws Exception {
-        View adView = subject.getAdView();
-
-        assertThat(adView).isSameAs(htmlInterstitialWebView);
-        assertThat(TestHtmlInterstitialWebViewFactory.getLatestListener()).isNotNull();
-        assertThat(TestHtmlInterstitialWebViewFactory.getLatestIsScrollable()).isEqualTo(EXPECTED_IS_SCROLLABLE);
-        assertThat(TestHtmlInterstitialWebViewFactory.getLatestClickthroughUrl()).isEqualTo(EXPECTED_CLICKTHROUGH_URL);
-        assertThat(TestHtmlInterstitialWebViewFactory.getLatestRedirectUrl()).isEqualTo(EXPECTED_REDIRECT_URL);
-        verify(htmlInterstitialWebView).loadHtmlResponse(EXPECTED_HTML_DATA);
-    }
-
-    @Test
-    public void onDestroy_shouldDestroyMoPubView() throws Exception {
-        subject.onCreate(null);
-        subject.onDestroy();
-
-        verify(htmlInterstitialWebView).destroy();
-        assertThat(getContentView().getChildCount()).isEqualTo(0);
-    }
-
-    @Test
-    public void onDestroy_shouldFireJavascriptWebviewDidClose() throws Exception {
-        subject.onCreate(null);
-        subject.onDestroy();
-
-        verify(htmlInterstitialWebView).loadUrl(eq("javascript:webviewDidClose();"));
-    }
-
-    @Test
-    public void start_shouldStartMoPubActivityWithCorrectParameters() throws Exception {
-        MoPubActivity.start(subject, "expectedResponse", mockAdReport, true, "redirectUrl", "clickthroughUrl", CreativeOrientation.PORTRAIT, testBroadcastIdentifier);
-
-        Intent nextStartedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(nextStartedActivity.getStringExtra(HTML_RESPONSE_BODY_KEY)).isEqualTo("expectedResponse");
-        assertThat(nextStartedActivity.getBooleanExtra(SCROLLABLE_KEY, false)).isTrue();
-        assertThat(nextStartedActivity.getStringExtra(REDIRECT_URL_KEY)).isEqualTo("redirectUrl");
-        assertThat(nextStartedActivity.getStringExtra(CLICKTHROUGH_URL_KEY)).isEqualTo("clickthroughUrl");
-        assertThat(nextStartedActivity.getSerializableExtra(CREATIVE_ORIENTATION_KEY)).isEqualTo(CreativeOrientation.PORTRAIT);
-        assertThat(nextStartedActivity.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
-        assertThat(nextStartedActivity.getComponent().getClassName()).isEqualTo("com.mopub.mobileads.MoPubActivity");
-    }
-
-    @Test
-    public void getAdView_shouldCreateHtmlInterstitialWebViewAndLoadResponse() throws Exception {
-        subject.getAdView();
-
-        assertThat(TestHtmlInterstitialWebViewFactory.getLatestListener()).isNotNull();
-        assertThat(TestHtmlInterstitialWebViewFactory.getLatestIsScrollable()).isEqualTo(EXPECTED_IS_SCROLLABLE);
-        assertThat(TestHtmlInterstitialWebViewFactory.getLatestRedirectUrl()).isEqualTo(EXPECTED_REDIRECT_URL);
-        assertThat(TestHtmlInterstitialWebViewFactory.getLatestClickthroughUrl()).isEqualTo(EXPECTED_CLICKTHROUGH_URL);
-        verify(htmlInterstitialWebView).loadHtmlResponse(EXPECTED_HTML_DATA);
-    }
-
-    @Test
-    public void getAdView_shouldSetUpForBroadcastingClicks() throws Exception {
-        subject.getAdView();
-        BroadcastReceiver broadcastReceiver = mock(BroadcastReceiver.class);
-        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
-
-        TestHtmlInterstitialWebViewFactory.getLatestListener().onInterstitialClicked();
-
-        ArgumentCaptor<Intent> intentCaptor = ArgumentCaptor.forClass(Intent.class);
-        verify(broadcastReceiver).onReceive(any(Context.class), intentCaptor.capture());
-        Intent intent = intentCaptor.getValue();
-        assertThat(intent.getAction()).isEqualTo(ACTION_INTERSTITIAL_CLICK);
-    }
-
-    @Test
-    public void getAdView_shouldSetUpForBroadcastingFail() throws Exception {
-        subject.getAdView();
-        BroadcastReceiver broadcastReceiver = mock(BroadcastReceiver.class);
-        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
-
-        TestHtmlInterstitialWebViewFactory.getLatestListener().onInterstitialFailed(UNSPECIFIED);
-
-        ArgumentCaptor<Intent> intentCaptor = ArgumentCaptor.forClass(Intent.class);
-        verify(broadcastReceiver).onReceive(any(Context.class), intentCaptor.capture());
-        Intent intent = intentCaptor.getValue();
-        assertThat(intent.getAction()).isEqualTo(ACTION_INTERSTITIAL_FAIL);
-
-        assertThat(shadowOf(subject).isFinishing()).isTrue();
-    }
-
-    @Test
-    public void broadcastingInterstitialListener_onInterstitialLoaded_shouldCallJavascriptWebViewDidAppear() throws Exception {
-        MoPubActivity.BroadcastingInterstitialListener broadcastingInterstitialListener = ((MoPubActivity) subject).new BroadcastingInterstitialListener();
-
-        broadcastingInterstitialListener.onInterstitialLoaded();
-
-        verify(htmlInterstitialWebView).loadUrl(eq("javascript:webviewDidAppear();"));
-    }
-
-    @Test
-    public void broadcastingInterstitialListener_onInterstitialFailed_shouldBroadcastFailAndFinish() throws Exception {
-        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_FAIL, testBroadcastIdentifier);
-        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
-
-        MoPubActivity.BroadcastingInterstitialListener broadcastingInterstitialListener = ((MoPubActivity) subject).new BroadcastingInterstitialListener();
-        broadcastingInterstitialListener.onInterstitialFailed(null);
-
-        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
-        assertThat(shadowOf(subject).isFinishing()).isTrue();
-    }
-
-    @Test
-    public void broadcastingInterstitialListener_onInterstitialClicked_shouldBroadcastClick() throws Exception {
-        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_CLICK, testBroadcastIdentifier);
-        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
-
-        MoPubActivity.BroadcastingInterstitialListener broadcastingInterstitialListener = ((MoPubActivity) subject).new BroadcastingInterstitialListener();
-        broadcastingInterstitialListener.onInterstitialClicked();
-
-        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
-    }
-
-    @Test
-    public void onCreate_shouldBroadcastInterstitialShow() throws Exception {
-        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_SHOW, testBroadcastIdentifier);
-        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
-
-        subject.onCreate(null);
-
-        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
-    }
-
-    @Test
-    public void onDestroy_shouldBroadcastInterstitialDismiss() throws Exception {
-        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_DISMISS, testBroadcastIdentifier);
-        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
-
-        subject.onCreate(null);
-        subject.onDestroy();
-
-        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
-    }
-
-    private FrameLayout getContentView() {
-        return (FrameLayout) ((ViewGroup) subject.findViewById(android.R.id.content)).getChildAt(0);
-    }
-
-    protected void resetMockedView(View view) {
-        reset(view);
-        when(view.getLayoutParams()).thenReturn(
-                new FrameLayout.LayoutParams(FrameLayout.LayoutParams.WRAP_CONTENT,
-                        FrameLayout.LayoutParams.WRAP_CONTENT));
-    }
-}
-
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.ActivityInfo;
+import android.view.View;
+import android.view.ViewGroup;
+import android.webkit.WebViewClient;
+import android.widget.FrameLayout;
+
+import com.mopub.common.AdReport;
+import com.mopub.common.CreativeOrientation;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.test.support.TestHtmlInterstitialWebViewFactory;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+import org.robolectric.shadows.ShadowLocalBroadcastManager;
+import org.robolectric.util.ActivityController;
+
+import static com.mopub.common.DataKeys.CLICKTHROUGH_URL_KEY;
+import static com.mopub.common.DataKeys.CREATIVE_ORIENTATION_KEY;
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
+import static com.mopub.common.DataKeys.REDIRECT_URL_KEY;
+import static com.mopub.common.DataKeys.SCROLLABLE_KEY;
+import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
+import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_CLICK;
+import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
+import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_FAIL;
+import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
+import static com.mopub.mobileads.EventForwardingBroadcastReceiver.getHtmlInterstitialIntentFilter;
+import static com.mopub.mobileads.EventForwardingBroadcastReceiverTest.getIntentForActionAndIdentifier;
+import static com.mopub.mobileads.MoPubErrorCode.UNSPECIFIED;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+import static org.robolectric.Robolectric.shadowOf;
+
+@RunWith(SdkTestRunner.class)
+public class MoPubActivityTest {
+    private static final String EXPECTED_HTML_DATA = "htmlData";
+    private static final boolean EXPECTED_IS_SCROLLABLE = true;
+    @Mock private AdReport mockAdReport;
+    private static final String EXPECTED_REDIRECT_URL = "redirectUrl";
+    private static final String EXPECTED_CLICKTHROUGH_URL = "http://expected_url";
+    private static final CreativeOrientation EXPECTED_ORIENTATION = CreativeOrientation.PORTRAIT;
+
+    @Mock private BroadcastReceiver broadcastReceiver;
+    private long testBroadcastIdentifier = 2222;
+
+    private HtmlInterstitialWebView htmlInterstitialWebView;
+    private CustomEventInterstitialListener customEventInterstitialListener;
+
+    private MoPubActivity subject;
+
+    @Before
+    public void setUp() throws Exception {
+        htmlInterstitialWebView = TestHtmlInterstitialWebViewFactory.getSingletonMock();
+        resetMockedView(htmlInterstitialWebView);
+
+        Context context = Robolectric.buildActivity(Activity.class).create().get();
+        Intent moPubActivityIntent = MoPubActivity.createIntent(context,
+                EXPECTED_HTML_DATA, mockAdReport, EXPECTED_IS_SCROLLABLE,
+                EXPECTED_REDIRECT_URL,
+                EXPECTED_CLICKTHROUGH_URL, EXPECTED_ORIENTATION, testBroadcastIdentifier);
+
+        final ActivityController<MoPubActivity> subjectController = Robolectric.buildActivity(MoPubActivity.class).withIntent(moPubActivityIntent);
+        subject = subjectController.get();
+        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
+        subjectController.create();
+
+        customEventInterstitialListener = mock(CustomEventInterstitialListener.class);
+    }
+
+    @Test
+    public void onCreate_shouldHaveLockedOrientation() {
+        // Since robolectric doesn't set a requested orientation, verifying that we have a value tells us that one was set.
+        assertThat(subject.getRequestedOrientation()).isIn(ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT,
+                ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+    }
+
+    @Test
+    public void preRenderHtml_shouldPreloadTheHtml() throws Exception {
+        String htmlData = "this is nonsense";
+        MoPubActivity.preRenderHtml(subject, mockAdReport, customEventInterstitialListener, htmlData);
+
+        verify(htmlInterstitialWebView).enablePlugins(eq(false));
+        verify(htmlInterstitialWebView).loadHtmlResponse(htmlData);
+    }
+
+    @Test
+    public void preRenderHtml_shouldHaveAWebViewClientThatForwardsFinishLoad() throws Exception {
+        MoPubActivity.preRenderHtml(subject, mockAdReport, customEventInterstitialListener, null);
+
+        ArgumentCaptor<WebViewClient> webViewClientCaptor = ArgumentCaptor.forClass(WebViewClient.class);
+        verify(htmlInterstitialWebView).setWebViewClient(webViewClientCaptor.capture());
+        WebViewClient webViewClient = webViewClientCaptor.getValue();
+
+        webViewClient.shouldOverrideUrlLoading(null, "mopub://finishLoad");
+
+        verify(customEventInterstitialListener).onInterstitialLoaded();
+        verify(customEventInterstitialListener, never()).onInterstitialFailed(any(MoPubErrorCode.class));
+    }
+
+    @Test
+    public void preRenderHtml_shouldHaveAWebViewClientThatForwardsFailLoad() throws Exception {
+        MoPubActivity.preRenderHtml(subject, mockAdReport, customEventInterstitialListener, null);
+
+        ArgumentCaptor<WebViewClient> webViewClientCaptor = ArgumentCaptor.forClass(WebViewClient.class);
+        verify(htmlInterstitialWebView).setWebViewClient(webViewClientCaptor.capture());
+        WebViewClient webViewClient = webViewClientCaptor.getValue();
+
+        webViewClient.shouldOverrideUrlLoading(null, "mopub://failLoad");
+
+        verify(customEventInterstitialListener, never()).onInterstitialLoaded();
+        verify(customEventInterstitialListener).onInterstitialFailed(any(MoPubErrorCode.class));
+    }
+
+    @Test
+    public void onCreate_shouldSetContentView() throws Exception {
+        // onCreate is called above in #setup
+
+        assertThat(getContentView().getChildCount()).isEqualTo(1);
+    }
+
+    @Test
+    public void onCreate_shouldLayoutWebView() throws Exception {
+        // onCreate is called in #setup
+
+        ArgumentCaptor<FrameLayout.LayoutParams> captor = ArgumentCaptor.forClass(FrameLayout.LayoutParams.class);
+        verify(htmlInterstitialWebView).setLayoutParams(captor.capture());
+        FrameLayout.LayoutParams actualLayoutParams = captor.getValue();
+
+        assertThat(actualLayoutParams.width).isEqualTo(FrameLayout.LayoutParams.MATCH_PARENT);
+        assertThat(actualLayoutParams.height).isEqualTo(FrameLayout.LayoutParams.MATCH_PARENT);
+    }
+
+    @Test
+    public void getAdView_shouldReturnPopulatedHtmlWebView() throws Exception {
+        // This is needed because we preload in onCreate and the mock gets triggered.
+        resetMockedView(htmlInterstitialWebView);
+        View adView = subject.getAdView();
+
+        assertThat(adView).isSameAs(htmlInterstitialWebView);
+        assertThat(TestHtmlInterstitialWebViewFactory.getLatestListener()).isNotNull();
+        assertThat(TestHtmlInterstitialWebViewFactory.getLatestIsScrollable()).isEqualTo(EXPECTED_IS_SCROLLABLE);
+        assertThat(TestHtmlInterstitialWebViewFactory.getLatestClickthroughUrl()).isEqualTo(EXPECTED_CLICKTHROUGH_URL);
+        assertThat(TestHtmlInterstitialWebViewFactory.getLatestRedirectUrl()).isEqualTo(EXPECTED_REDIRECT_URL);
+        verify(htmlInterstitialWebView).loadHtmlResponse(EXPECTED_HTML_DATA);
+    }
+
+    @Test
+    public void onDestroy_shouldDestroyMoPubView() throws Exception {
+        // onCreate is called in #setup
+        subject.onDestroy();
+
+        verify(htmlInterstitialWebView).destroy();
+        assertThat(getContentView().getChildCount()).isEqualTo(0);
+    }
+
+    @Test
+    public void onDestroy_shouldFireJavascriptWebviewDidClose() throws Exception {
+        // onCreate is called in #setup
+        subject.onDestroy();
+
+        verify(htmlInterstitialWebView).loadUrl(eq("javascript:webviewDidClose();"));
+    }
+
+    @Test
+    public void start_shouldStartMoPubActivityWithCorrectParameters() throws Exception {
+        MoPubActivity.start(subject, "expectedResponse", mockAdReport, true, "redirectUrl", "clickthroughUrl", CreativeOrientation.PORTRAIT, testBroadcastIdentifier);
+
+        Intent nextStartedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(nextStartedActivity.getStringExtra(HTML_RESPONSE_BODY_KEY)).isEqualTo("expectedResponse");
+        assertThat(nextStartedActivity.getBooleanExtra(SCROLLABLE_KEY, false)).isTrue();
+        assertThat(nextStartedActivity.getStringExtra(REDIRECT_URL_KEY)).isEqualTo("redirectUrl");
+        assertThat(nextStartedActivity.getStringExtra(CLICKTHROUGH_URL_KEY)).isEqualTo("clickthroughUrl");
+        assertThat(nextStartedActivity.getSerializableExtra(CREATIVE_ORIENTATION_KEY)).isEqualTo(CreativeOrientation.PORTRAIT);
+        assertThat(nextStartedActivity.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
+        assertThat(nextStartedActivity.getComponent().getClassName()).isEqualTo("com.mopub.mobileads.MoPubActivity");
+    }
+
+    @Test
+    public void getAdView_shouldCreateHtmlInterstitialWebViewAndLoadResponse() throws Exception {
+        // This is needed because we preload in onCreate and the mock gets triggered.
+        resetMockedView(htmlInterstitialWebView);
+        subject.getAdView();
+
+        assertThat(TestHtmlInterstitialWebViewFactory.getLatestListener()).isNotNull();
+        assertThat(TestHtmlInterstitialWebViewFactory.getLatestIsScrollable()).isEqualTo(EXPECTED_IS_SCROLLABLE);
+        assertThat(TestHtmlInterstitialWebViewFactory.getLatestRedirectUrl()).isEqualTo(EXPECTED_REDIRECT_URL);
+        assertThat(TestHtmlInterstitialWebViewFactory.getLatestClickthroughUrl()).isEqualTo(EXPECTED_CLICKTHROUGH_URL);
+        verify(htmlInterstitialWebView).loadHtmlResponse(EXPECTED_HTML_DATA);
+    }
+
+    @Test
+    public void getAdView_shouldSetUpForBroadcastingClicks() throws Exception {
+        subject.getAdView();
+        BroadcastReceiver broadcastReceiver = mock(BroadcastReceiver.class);
+        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
+
+        TestHtmlInterstitialWebViewFactory.getLatestListener().onInterstitialClicked();
+
+        ArgumentCaptor<Intent> intentCaptor = ArgumentCaptor.forClass(Intent.class);
+        verify(broadcastReceiver).onReceive(any(Context.class), intentCaptor.capture());
+        Intent intent = intentCaptor.getValue();
+        assertThat(intent.getAction()).isEqualTo(ACTION_INTERSTITIAL_CLICK);
+    }
+
+    @Test
+    public void getAdView_shouldSetUpForBroadcastingFail() throws Exception {
+        subject.getAdView();
+        BroadcastReceiver broadcastReceiver = mock(BroadcastReceiver.class);
+        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
+
+        TestHtmlInterstitialWebViewFactory.getLatestListener().onInterstitialFailed(UNSPECIFIED);
+
+        ArgumentCaptor<Intent> intentCaptor = ArgumentCaptor.forClass(Intent.class);
+        verify(broadcastReceiver).onReceive(any(Context.class), intentCaptor.capture());
+        Intent intent = intentCaptor.getValue();
+        assertThat(intent.getAction()).isEqualTo(ACTION_INTERSTITIAL_FAIL);
+
+        assertThat(shadowOf(subject).isFinishing()).isTrue();
+    }
+
+    @Test
+    public void broadcastingInterstitialListener_onInterstitialLoaded_shouldCallJavascriptWebViewDidAppear() throws Exception {
+        MoPubActivity.BroadcastingInterstitialListener broadcastingInterstitialListener = ((MoPubActivity) subject).new BroadcastingInterstitialListener();
+
+        broadcastingInterstitialListener.onInterstitialLoaded();
+
+        verify(htmlInterstitialWebView).loadUrl(eq("javascript:webviewDidAppear();"));
+    }
+
+    @Test
+    public void broadcastingInterstitialListener_onInterstitialFailed_shouldBroadcastFailAndFinish() throws Exception {
+        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_FAIL, testBroadcastIdentifier);
+
+        MoPubActivity.BroadcastingInterstitialListener broadcastingInterstitialListener = ((MoPubActivity) subject).new BroadcastingInterstitialListener();
+        broadcastingInterstitialListener.onInterstitialFailed(null);
+
+        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
+        assertThat(shadowOf(subject).isFinishing()).isTrue();
+    }
+
+    @Test
+    public void broadcastingInterstitialListener_onInterstitialClicked_shouldBroadcastClick() throws Exception {
+        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_CLICK, testBroadcastIdentifier);
+
+        MoPubActivity.BroadcastingInterstitialListener broadcastingInterstitialListener = ((MoPubActivity) subject).new BroadcastingInterstitialListener();
+        broadcastingInterstitialListener.onInterstitialClicked();
+
+        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
+    }
+
+    @Test
+    public void onCreate_shouldBroadcastInterstitialShow() throws Exception {
+        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_SHOW, testBroadcastIdentifier);
+
+        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
+    }
+
+    @Test
+    public void onDestroy_shouldBroadcastInterstitialDismiss() throws Exception {
+        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_DISMISS, testBroadcastIdentifier);
+
+        subject.onDestroy();
+
+        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
+    }
+
+    private FrameLayout getContentView() {
+        return (FrameLayout) ((ViewGroup) subject.findViewById(android.R.id.content)).getChildAt(0);
+    }
+
+    protected void resetMockedView(View view) {
+        reset(view);
+        when(view.getLayoutParams()).thenReturn(
+                new FrameLayout.LayoutParams(FrameLayout.LayoutParams.WRAP_CONTENT,
+                        FrameLayout.LayoutParams.WRAP_CONTENT));
+    }
+}
+
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubInterstitialTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubInterstitialTest.java
index faeecf8e..67e4752b 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubInterstitialTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubInterstitialTest.java
@@ -1,362 +1,363 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-
-import com.mopub.common.LocationService;
-import com.mopub.common.MoPub;
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.mobileads.test.support.TestAdViewControllerFactory;
-import com.mopub.mobileads.test.support.TestCustomEventInterstitialAdapterFactory;
-
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import java.math.BigDecimal;
-import java.util.HashMap;
-import java.util.Map;
-
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_DATA;
-import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
-import static com.mopub.mobileads.MoPubErrorCode.CANCELLED;
-import static com.mopub.mobileads.MoPubErrorCode.INTERNAL_ERROR;
-import static com.mopub.mobileads.MoPubErrorCode.UNSPECIFIED;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.verify;
-
-@RunWith(SdkTestRunner.class)
-public class MoPubInterstitialTest {
-
-    private static final String KEYWORDS_VALUE = "expected_keywords";
-    private static final String AD_UNIT_ID_VALUE = "expected_adunitid";
-    private static final String SOURCE_VALUE = "expected_source";
-    private static final String CLICKTHROUGH_URL_VALUE = "expected_clickthrough_url";
-    private Activity activity;
-    private MoPubInterstitial subject;
-    private Map<String, String> serverExtras;
-    private CustomEventInterstitialAdapter customEventInterstitialAdapter;
-    private MoPubInterstitial.InterstitialAdListener interstitialAdListener;
-    private MoPubInterstitial.MoPubInterstitialView interstitialView;
-    private AdViewController adViewController;
-    private String customEventClassName;
-
-    @Before
-    public void setUp() throws Exception {
-        activity = new Activity();
-        subject = new MoPubInterstitial(activity, AD_UNIT_ID_VALUE);
-        interstitialAdListener = mock(MoPubInterstitial.InterstitialAdListener.class);
-        subject.setInterstitialAdListener(interstitialAdListener);
-
-        interstitialView = mock(MoPubInterstitial.MoPubInterstitialView.class);
-
-        customEventClassName = "class name";
-        serverExtras = new HashMap<String, String>();
-        serverExtras.put("testExtra", "class data");
-
-        customEventInterstitialAdapter = TestCustomEventInterstitialAdapterFactory.getSingletonMock();
-        reset(customEventInterstitialAdapter);
-        adViewController = TestAdViewControllerFactory.getSingletonMock();
-    }
-
-    @Test
-    public void forceRefresh_shouldResetInterstitialViewAndMarkNotDestroyed() throws Exception {
-        subject.setInterstitialView(interstitialView);
-        subject.onCustomEventInterstitialLoaded();
-        subject.forceRefresh();
-
-        assertThat(subject.isReady()).isFalse();
-        assertThat(subject.isDestroyed()).isFalse();
-        verify(interstitialView).forceRefresh();
-    }
-
-    @Test
-    public void setKeywordsTest() throws Exception {
-        subject.setInterstitialView(interstitialView);
-        String keywords = "these_are_keywords";
-
-        subject.setKeywords(keywords);
-        verify(interstitialView).setKeywords(eq(keywords));
-    }
-    @Test
-    public void getKeywordsTest() throws Exception {
-        subject.setInterstitialView(interstitialView);
-
-        subject.getKeywords();
-        verify(interstitialView).getKeywords();
-    }
-
-    @Test
-    public void setTestingTest() throws Exception {
-        subject.setInterstitialView(interstitialView);
-        subject.setTesting(true);
-        verify(interstitialView).setTesting(eq(true));
-    }
-
-    @Test
-    public void getInterstitialAdListenerTest() throws Exception {
-        interstitialAdListener = mock(MoPubInterstitial.InterstitialAdListener.class);
-        subject.setInterstitialAdListener(interstitialAdListener);
-        assertThat(subject.getInterstitialAdListener()).isSameAs(interstitialAdListener);
-    }
-
-    @Test
-    public void setLocationAwarenss_shouldChangeGlobalSetting() {
-        assertThat(MoPub.getLocationAwareness()).isEqualTo(MoPub.LocationAwareness.NORMAL);
-        subject.setLocationAwareness(LocationService.LocationAwareness.DISABLED);
-        assertThat(MoPub.getLocationAwareness()).isEqualTo(MoPub.LocationAwareness.DISABLED);
-    }
-
-    @Test
-    public void getTestingTest() throws Exception {
-        subject.setInterstitialView(interstitialView);
-        subject.getTesting();
-        verify(interstitialView).getTesting();
-    }
-
-    @Test
-    public void setLocalExtrasTest() throws Exception {
-        subject.setInterstitialView(interstitialView);
-
-        Map<String,Object> localExtras = new HashMap<String, Object>();
-        localExtras.put("guy", new Activity());
-        localExtras.put("other guy", new BigDecimal(27f));
-
-        subject.setLocalExtras(localExtras);
-        verify(interstitialView).setLocalExtras(eq(localExtras));
-    }
-
-    @Test
-    public void loadCustomEvent_shouldCreateAndLoadCustomEventInterstitialAdapter() throws Exception {
-        MoPubInterstitial.MoPubInterstitialView moPubInterstitialView = subject.new MoPubInterstitialView(activity);
-        moPubInterstitialView.loadCustomEvent(customEventClassName, serverExtras);
-
-        assertThat(TestCustomEventInterstitialAdapterFactory.getLatestMoPubInterstitial()).isSameAs(subject);
-        assertThat(TestCustomEventInterstitialAdapterFactory.getLatestClassName()).isEqualTo("class name");
-        assertThat(TestCustomEventInterstitialAdapterFactory.getLatestServerExtras().get("testExtra")).isEqualTo("class data");
-    }
-
-    @Test
-    public void onCustomEventInterstitialLoaded_shouldNotifyListener() throws Exception {
-        subject.setInterstitialView(interstitialView);
-
-        subject.onCustomEventInterstitialLoaded();
-        verify(interstitialAdListener).onInterstitialLoaded(eq(subject));
-
-        verify(interstitialView, never()).trackImpression();
-    }
-
-    @Test
-    public void onCustomEventInterstitialLoaded_whenInterstitialAdListenerIsNull_shouldNotNotifyListenerOrTrackImpression() throws Exception {
-        subject.setInterstitialView(interstitialView);
-        subject.setInterstitialAdListener(null);
-
-        subject.onCustomEventInterstitialLoaded();
-
-        verify(interstitialView, never()).trackImpression();
-        verify(interstitialAdListener, never()).onInterstitialLoaded(eq(subject));
-    }
-
-    @Test
-    public void onCustomEventInterstitialFailed_shouldLoadFailUrl() throws Exception {
-        subject.setInterstitialView(interstitialView);
-
-        subject.onCustomEventInterstitialFailed(INTERNAL_ERROR);
-
-        verify(interstitialView).loadFailUrl(INTERNAL_ERROR);
-    }
-
-    @Test
-    public void onCustomEventInterstitialShown_shouldTrackImpressionAndNotifyListener() throws Exception {
-        subject.setInterstitialView(interstitialView);
-        subject.onCustomEventInterstitialShown();
-
-        verify(interstitialView).trackImpression();
-        verify(interstitialAdListener).onInterstitialShown(eq(subject));
-    }
-
-    @Test
-    public void onCustomEventInterstitialShown_whenInterstitialAdListenerIsNull_shouldNotNotifyListener() throws Exception {
-        subject.setInterstitialAdListener(null);
-        subject.onCustomEventInterstitialShown();
-        verify(interstitialAdListener, never()).onInterstitialShown(eq(subject));
-    }
-
-    @Test
-    public void onCustomEventInterstitialClicked_shouldRegisterClickAndNotifyListener() throws Exception {
-        subject.setInterstitialView(interstitialView);
-
-        subject.onCustomEventInterstitialClicked();
-
-        verify(interstitialView).registerClick();
-        verify(interstitialAdListener).onInterstitialClicked(eq(subject));
-    }
-
-    @Test
-    public void onCustomEventInterstitialClicked_whenInterstitialAdListenerIsNull_shouldNotNotifyListener() throws Exception {
-        subject.setInterstitialAdListener(null);
-
-        subject.onCustomEventInterstitialClicked();
-
-        verify(interstitialAdListener, never()).onInterstitialClicked(eq(subject));
-    }
-
-    @Test
-    public void onCustomEventInterstitialDismissed_shouldNotifyListener() throws Exception {
-        subject.onCustomEventInterstitialDismissed();
-
-        verify(interstitialAdListener).onInterstitialDismissed(eq(subject));
-    }
-
-    @Test
-    public void onCustomEventInterstitialDismissed_whenInterstitialAdListenerIsNull_shouldNotNotifyListener() throws Exception {
-        subject.setInterstitialAdListener(null);
-        subject.onCustomEventInterstitialDismissed();
-        verify(interstitialAdListener, never()).onInterstitialDismissed(eq(subject));
-    }
-
-    @Test
-    public void destroy_shouldPreventOnCustomEventInterstitialLoadedNotification() throws Exception {
-        subject.destroy();
-
-        subject.onCustomEventInterstitialLoaded();
-
-        verify(interstitialAdListener, never()).onInterstitialLoaded(eq(subject));
-    }
-
-    @Test
-    public void destroy_shouldPreventOnCustomEventInterstitialFailedNotification() throws Exception {
-        subject.setInterstitialView(interstitialView);
-        subject.destroy();
-
-        subject.onCustomEventInterstitialFailed(UNSPECIFIED);
-
-        verify(interstitialView, never()).loadFailUrl(UNSPECIFIED);
-    }
-
-    @Test
-    public void destroy_shouldPreventOnCustomEventInterstitialClickedFromRegisteringClick() throws Exception {
-        subject.setInterstitialView(interstitialView);
-        subject.destroy();
-
-        subject.onCustomEventInterstitialClicked();
-
-        verify(interstitialView, never()).registerClick();
-    }
-
-    @Test
-    public void destroy_shouldPreventOnCustomEventShownNotification() throws Exception {
-        subject.destroy();
-
-        subject.onCustomEventInterstitialShown();
-
-        verify(interstitialAdListener, never()).onInterstitialShown(eq(subject));
-    }
-
-    @Test
-    public void destroy_shouldPreventOnCustomEventInterstitialDismissedNotification() throws Exception {
-        subject.destroy();
-
-        subject.onCustomEventInterstitialDismissed();
-
-        verify(interstitialAdListener, never()).onInterstitialDismissed(eq(subject));
-    }
-
-    @Test
-    public void newlyCreated_shouldNotBeReadyAndNotShow() throws Exception {
-        assertShowsCustomEventInterstitial(false);
-    }
-
-    @Test
-    public void loadingCustomEventInterstitial_shouldBecomeReadyToShowCustomEventAd() throws Exception {
-        subject.onCustomEventInterstitialLoaded();
-
-        assertShowsCustomEventInterstitial(true);
-    }
-
-    @Ignore("pending")
-    @Test
-    public void dismissingHtmlInterstitial_shouldNotBecomeReadyToShowHtmlAd() throws Exception {
-//        EventForwardingBroadcastReceiver broadcastReceiver = new EventForwardingBroadcastReceiver(subject.mInterstitialAdListener);
-//
-//        subject.onCustomEventInterstitialLoaded();
-//        broadcastReceiver.onHtmlInterstitialDismissed();
-//
-//        assertShowsCustomEventInterstitial(false);
-    }
-
-    @Test
-    public void failingCustomEventInterstitial_shouldNotBecomeReadyToShowCustomEventAd() throws Exception {
-        subject.onCustomEventInterstitialLoaded();
-        subject.onCustomEventInterstitialFailed(CANCELLED);
-
-        assertShowsCustomEventInterstitial(false);
-    }
-
-    @Test
-    public void dismissingCustomEventInterstitial_shouldNotBecomeReadyToShowCustomEventAd() throws Exception {
-        subject.onCustomEventInterstitialLoaded();
-        subject.onCustomEventInterstitialDismissed();
-
-        assertShowsCustomEventInterstitial(false);
-    }
-
-    @Test
-    public void loadCustomEvent_shouldInitializeCustomEventInterstitialAdapter() throws Exception {
-        MoPubInterstitial.MoPubInterstitialView moPubInterstitialView = subject.new MoPubInterstitialView(activity);
-
-        serverExtras.put("testExtra", "data");
-        moPubInterstitialView.loadCustomEvent("name", serverExtras);
-
-        assertThat(TestCustomEventInterstitialAdapterFactory.getLatestMoPubInterstitial()).isEqualTo(subject);
-        assertThat(TestCustomEventInterstitialAdapterFactory.getLatestClassName()).isEqualTo("name");
-        assertThat(TestCustomEventInterstitialAdapterFactory.getLatestServerExtras().get("testExtra")).isEqualTo("data");
-
-        verify(customEventInterstitialAdapter).setAdapterListener(eq(subject));
-        verify(customEventInterstitialAdapter).loadInterstitial();
-    }
-
-    @Test
-    public void loadCustomEvent_whenParamsMapIsNull_shouldCallLoadFailUrl() throws Exception {
-        MoPubInterstitial.MoPubInterstitialView moPubInterstitialView = subject.new MoPubInterstitialView(activity);
-
-        moPubInterstitialView.loadCustomEvent(null, null);
-
-        verify(adViewController).loadFailUrl(eq(ADAPTER_NOT_FOUND));
-        verify(customEventInterstitialAdapter, never()).invalidate();
-        verify(customEventInterstitialAdapter, never()).loadInterstitial();
-    }
-
-    @Test
-    public void adFailed_shouldNotifyInterstitialAdListener() throws Exception {
-        MoPubInterstitial.MoPubInterstitialView moPubInterstitialView = subject.new MoPubInterstitialView(activity);
-        moPubInterstitialView.adFailed(CANCELLED);
-
-        verify(interstitialAdListener).onInterstitialFailed(eq(subject), eq(CANCELLED));
-    }
-
-    private void loadCustomEvent() {
-        MoPubInterstitial.MoPubInterstitialView moPubInterstitialView = subject.new MoPubInterstitialView(activity);
-
-        serverExtras.put(CUSTOM_EVENT_DATA.getKey(), "data");
-        moPubInterstitialView.loadCustomEvent("name", serverExtras);
-    }
-
-    private void assertShowsCustomEventInterstitial(boolean shouldBeReady) {
-        MoPubInterstitial.MoPubInterstitialView moPubInterstitialView = subject.new MoPubInterstitialView(activity);
-        moPubInterstitialView.loadCustomEvent(customEventClassName, serverExtras);
-
-        assertThat(subject.isReady()).isEqualTo(shouldBeReady);
-        assertThat(subject.show()).isEqualTo(shouldBeReady);
-
-        if (shouldBeReady) {
-            verify(customEventInterstitialAdapter).showInterstitial();
-        } else {
-            verify(customEventInterstitialAdapter, never()).showInterstitial();
-        }
-    }
-}
+package com.mopub.mobileads;
+
+import android.app.Activity;
+
+import com.mopub.common.LocationService;
+import com.mopub.common.MoPub;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.test.support.TestAdViewControllerFactory;
+import com.mopub.mobileads.test.support.TestCustomEventInterstitialAdapterFactory;
+
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+
+import java.math.BigDecimal;
+import java.util.HashMap;
+import java.util.Map;
+
+import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_DATA;
+import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
+import static com.mopub.mobileads.MoPubErrorCode.CANCELLED;
+import static com.mopub.mobileads.MoPubErrorCode.INTERNAL_ERROR;
+import static com.mopub.mobileads.MoPubErrorCode.UNSPECIFIED;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+
+@RunWith(SdkTestRunner.class)
+public class MoPubInterstitialTest {
+
+    private static final String KEYWORDS_VALUE = "expected_keywords";
+    private static final String AD_UNIT_ID_VALUE = "expected_adunitid";
+    private static final String SOURCE_VALUE = "expected_source";
+    private static final String CLICKTHROUGH_URL_VALUE = "expected_clickthrough_url";
+    private Activity activity;
+    private MoPubInterstitial subject;
+    private Map<String, String> serverExtras;
+    private CustomEventInterstitialAdapter customEventInterstitialAdapter;
+    private MoPubInterstitial.InterstitialAdListener interstitialAdListener;
+    private MoPubInterstitial.MoPubInterstitialView interstitialView;
+    private AdViewController adViewController;
+    private String customEventClassName;
+
+    @Before
+    public void setUp() throws Exception {
+        activity = Robolectric.buildActivity(Activity.class).create().get();
+        subject = new MoPubInterstitial(activity, AD_UNIT_ID_VALUE);
+        interstitialAdListener = mock(MoPubInterstitial.InterstitialAdListener.class);
+        subject.setInterstitialAdListener(interstitialAdListener);
+
+        interstitialView = mock(MoPubInterstitial.MoPubInterstitialView.class);
+
+        customEventClassName = "class name";
+        serverExtras = new HashMap<String, String>();
+        serverExtras.put("testExtra", "class data");
+
+        customEventInterstitialAdapter = TestCustomEventInterstitialAdapterFactory.getSingletonMock();
+        reset(customEventInterstitialAdapter);
+        adViewController = TestAdViewControllerFactory.getSingletonMock();
+    }
+
+    @Test
+    public void forceRefresh_shouldResetInterstitialViewAndMarkNotDestroyed() throws Exception {
+        subject.setInterstitialView(interstitialView);
+        subject.onCustomEventInterstitialLoaded();
+        subject.forceRefresh();
+
+        assertThat(subject.isReady()).isFalse();
+        assertThat(subject.isDestroyed()).isFalse();
+        verify(interstitialView).forceRefresh();
+    }
+
+    @Test
+    public void setKeywordsTest() throws Exception {
+        subject.setInterstitialView(interstitialView);
+        String keywords = "these_are_keywords";
+
+        subject.setKeywords(keywords);
+        verify(interstitialView).setKeywords(eq(keywords));
+    }
+    @Test
+    public void getKeywordsTest() throws Exception {
+        subject.setInterstitialView(interstitialView);
+
+        subject.getKeywords();
+        verify(interstitialView).getKeywords();
+    }
+
+    @Test
+    public void setTestingTest() throws Exception {
+        subject.setInterstitialView(interstitialView);
+        subject.setTesting(true);
+        verify(interstitialView).setTesting(eq(true));
+    }
+
+    @Test
+    public void getInterstitialAdListenerTest() throws Exception {
+        interstitialAdListener = mock(MoPubInterstitial.InterstitialAdListener.class);
+        subject.setInterstitialAdListener(interstitialAdListener);
+        assertThat(subject.getInterstitialAdListener()).isSameAs(interstitialAdListener);
+    }
+
+    @Test
+    public void setLocationAwarenss_shouldChangeGlobalSetting() {
+        assertThat(MoPub.getLocationAwareness()).isEqualTo(MoPub.LocationAwareness.NORMAL);
+        subject.setLocationAwareness(LocationService.LocationAwareness.DISABLED);
+        assertThat(MoPub.getLocationAwareness()).isEqualTo(MoPub.LocationAwareness.DISABLED);
+    }
+
+    @Test
+    public void getTestingTest() throws Exception {
+        subject.setInterstitialView(interstitialView);
+        subject.getTesting();
+        verify(interstitialView).getTesting();
+    }
+
+    @Test
+    public void setLocalExtrasTest() throws Exception {
+        subject.setInterstitialView(interstitialView);
+
+        Map<String,Object> localExtras = new HashMap<String, Object>();
+        localExtras.put("guy", new Activity());
+        localExtras.put("other guy", new BigDecimal(27f));
+
+        subject.setLocalExtras(localExtras);
+        verify(interstitialView).setLocalExtras(eq(localExtras));
+    }
+
+    @Test
+    public void loadCustomEvent_shouldCreateAndLoadCustomEventInterstitialAdapter() throws Exception {
+        MoPubInterstitial.MoPubInterstitialView moPubInterstitialView = subject.new MoPubInterstitialView(activity);
+        moPubInterstitialView.loadCustomEvent(customEventClassName, serverExtras);
+
+        assertThat(TestCustomEventInterstitialAdapterFactory.getLatestMoPubInterstitial()).isSameAs(subject);
+        assertThat(TestCustomEventInterstitialAdapterFactory.getLatestClassName()).isEqualTo("class name");
+        assertThat(TestCustomEventInterstitialAdapterFactory.getLatestServerExtras().get("testExtra")).isEqualTo("class data");
+    }
+
+    @Test
+    public void onCustomEventInterstitialLoaded_shouldNotifyListener() throws Exception {
+        subject.setInterstitialView(interstitialView);
+
+        subject.onCustomEventInterstitialLoaded();
+        verify(interstitialAdListener).onInterstitialLoaded(eq(subject));
+
+        verify(interstitialView, never()).trackImpression();
+    }
+
+    @Test
+    public void onCustomEventInterstitialLoaded_whenInterstitialAdListenerIsNull_shouldNotNotifyListenerOrTrackImpression() throws Exception {
+        subject.setInterstitialView(interstitialView);
+        subject.setInterstitialAdListener(null);
+
+        subject.onCustomEventInterstitialLoaded();
+
+        verify(interstitialView, never()).trackImpression();
+        verify(interstitialAdListener, never()).onInterstitialLoaded(eq(subject));
+    }
+
+    @Test
+    public void onCustomEventInterstitialFailed_shouldLoadFailUrl() throws Exception {
+        subject.setInterstitialView(interstitialView);
+
+        subject.onCustomEventInterstitialFailed(INTERNAL_ERROR);
+
+        verify(interstitialView).loadFailUrl(INTERNAL_ERROR);
+    }
+
+    @Test
+    public void onCustomEventInterstitialShown_shouldTrackImpressionAndNotifyListener() throws Exception {
+        subject.setInterstitialView(interstitialView);
+        subject.onCustomEventInterstitialShown();
+
+        verify(interstitialView).trackImpression();
+        verify(interstitialAdListener).onInterstitialShown(eq(subject));
+    }
+
+    @Test
+    public void onCustomEventInterstitialShown_whenInterstitialAdListenerIsNull_shouldNotNotifyListener() throws Exception {
+        subject.setInterstitialAdListener(null);
+        subject.onCustomEventInterstitialShown();
+        verify(interstitialAdListener, never()).onInterstitialShown(eq(subject));
+    }
+
+    @Test
+    public void onCustomEventInterstitialClicked_shouldRegisterClickAndNotifyListener() throws Exception {
+        subject.setInterstitialView(interstitialView);
+
+        subject.onCustomEventInterstitialClicked();
+
+        verify(interstitialView).registerClick();
+        verify(interstitialAdListener).onInterstitialClicked(eq(subject));
+    }
+
+    @Test
+    public void onCustomEventInterstitialClicked_whenInterstitialAdListenerIsNull_shouldNotNotifyListener() throws Exception {
+        subject.setInterstitialAdListener(null);
+
+        subject.onCustomEventInterstitialClicked();
+
+        verify(interstitialAdListener, never()).onInterstitialClicked(eq(subject));
+    }
+
+    @Test
+    public void onCustomEventInterstitialDismissed_shouldNotifyListener() throws Exception {
+        subject.onCustomEventInterstitialDismissed();
+
+        verify(interstitialAdListener).onInterstitialDismissed(eq(subject));
+    }
+
+    @Test
+    public void onCustomEventInterstitialDismissed_whenInterstitialAdListenerIsNull_shouldNotNotifyListener() throws Exception {
+        subject.setInterstitialAdListener(null);
+        subject.onCustomEventInterstitialDismissed();
+        verify(interstitialAdListener, never()).onInterstitialDismissed(eq(subject));
+    }
+
+    @Test
+    public void destroy_shouldPreventOnCustomEventInterstitialLoadedNotification() throws Exception {
+        subject.destroy();
+
+        subject.onCustomEventInterstitialLoaded();
+
+        verify(interstitialAdListener, never()).onInterstitialLoaded(eq(subject));
+    }
+
+    @Test
+    public void destroy_shouldPreventOnCustomEventInterstitialFailedNotification() throws Exception {
+        subject.setInterstitialView(interstitialView);
+        subject.destroy();
+
+        subject.onCustomEventInterstitialFailed(UNSPECIFIED);
+
+        verify(interstitialView, never()).loadFailUrl(UNSPECIFIED);
+    }
+
+    @Test
+    public void destroy_shouldPreventOnCustomEventInterstitialClickedFromRegisteringClick() throws Exception {
+        subject.setInterstitialView(interstitialView);
+        subject.destroy();
+
+        subject.onCustomEventInterstitialClicked();
+
+        verify(interstitialView, never()).registerClick();
+    }
+
+    @Test
+    public void destroy_shouldPreventOnCustomEventShownNotification() throws Exception {
+        subject.destroy();
+
+        subject.onCustomEventInterstitialShown();
+
+        verify(interstitialAdListener, never()).onInterstitialShown(eq(subject));
+    }
+
+    @Test
+    public void destroy_shouldPreventOnCustomEventInterstitialDismissedNotification() throws Exception {
+        subject.destroy();
+
+        subject.onCustomEventInterstitialDismissed();
+
+        verify(interstitialAdListener, never()).onInterstitialDismissed(eq(subject));
+    }
+
+    @Test
+    public void newlyCreated_shouldNotBeReadyAndNotShow() throws Exception {
+        assertShowsCustomEventInterstitial(false);
+    }
+
+    @Test
+    public void loadingCustomEventInterstitial_shouldBecomeReadyToShowCustomEventAd() throws Exception {
+        subject.onCustomEventInterstitialLoaded();
+
+        assertShowsCustomEventInterstitial(true);
+    }
+
+    @Ignore("pending")
+    @Test
+    public void dismissingHtmlInterstitial_shouldNotBecomeReadyToShowHtmlAd() throws Exception {
+//        EventForwardingBroadcastReceiver broadcastReceiver = new EventForwardingBroadcastReceiver(subject.mInterstitialAdListener);
+//
+//        subject.onCustomEventInterstitialLoaded();
+//        broadcastReceiver.onHtmlInterstitialDismissed();
+//
+//        assertShowsCustomEventInterstitial(false);
+    }
+
+    @Test
+    public void failingCustomEventInterstitial_shouldNotBecomeReadyToShowCustomEventAd() throws Exception {
+        subject.onCustomEventInterstitialLoaded();
+        subject.onCustomEventInterstitialFailed(CANCELLED);
+
+        assertShowsCustomEventInterstitial(false);
+    }
+
+    @Test
+    public void dismissingCustomEventInterstitial_shouldNotBecomeReadyToShowCustomEventAd() throws Exception {
+        subject.onCustomEventInterstitialLoaded();
+        subject.onCustomEventInterstitialDismissed();
+
+        assertShowsCustomEventInterstitial(false);
+    }
+
+    @Test
+    public void loadCustomEvent_shouldInitializeCustomEventInterstitialAdapter() throws Exception {
+        MoPubInterstitial.MoPubInterstitialView moPubInterstitialView = subject.new MoPubInterstitialView(activity);
+
+        serverExtras.put("testExtra", "data");
+        moPubInterstitialView.loadCustomEvent("name", serverExtras);
+
+        assertThat(TestCustomEventInterstitialAdapterFactory.getLatestMoPubInterstitial()).isEqualTo(subject);
+        assertThat(TestCustomEventInterstitialAdapterFactory.getLatestClassName()).isEqualTo("name");
+        assertThat(TestCustomEventInterstitialAdapterFactory.getLatestServerExtras().get("testExtra")).isEqualTo("data");
+
+        verify(customEventInterstitialAdapter).setAdapterListener(eq(subject));
+        verify(customEventInterstitialAdapter).loadInterstitial();
+    }
+
+    @Test
+    public void loadCustomEvent_whenParamsMapIsNull_shouldCallLoadFailUrl() throws Exception {
+        MoPubInterstitial.MoPubInterstitialView moPubInterstitialView = subject.new MoPubInterstitialView(activity);
+
+        moPubInterstitialView.loadCustomEvent(null, null);
+
+        verify(adViewController).loadFailUrl(eq(ADAPTER_NOT_FOUND));
+        verify(customEventInterstitialAdapter, never()).invalidate();
+        verify(customEventInterstitialAdapter, never()).loadInterstitial();
+    }
+
+    @Test
+    public void adFailed_shouldNotifyInterstitialAdListener() throws Exception {
+        MoPubInterstitial.MoPubInterstitialView moPubInterstitialView = subject.new MoPubInterstitialView(activity);
+        moPubInterstitialView.adFailed(CANCELLED);
+
+        verify(interstitialAdListener).onInterstitialFailed(eq(subject), eq(CANCELLED));
+    }
+
+    private void loadCustomEvent() {
+        MoPubInterstitial.MoPubInterstitialView moPubInterstitialView = subject.new MoPubInterstitialView(activity);
+
+        serverExtras.put(CUSTOM_EVENT_DATA.getKey(), "data");
+        moPubInterstitialView.loadCustomEvent("name", serverExtras);
+    }
+
+    private void assertShowsCustomEventInterstitial(boolean shouldBeReady) {
+        MoPubInterstitial.MoPubInterstitialView moPubInterstitialView = subject.new MoPubInterstitialView(activity);
+        moPubInterstitialView.loadCustomEvent(customEventClassName, serverExtras);
+
+        assertThat(subject.isReady()).isEqualTo(shouldBeReady);
+        assertThat(subject.show()).isEqualTo(shouldBeReady);
+
+        if (shouldBeReady) {
+            verify(customEventInterstitialAdapter).showInterstitial();
+        } else {
+            verify(customEventInterstitialAdapter, never()).showInterstitial();
+        }
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubRewardedVideoManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubRewardedVideoManagerTest.java
index ef8c9753..9ffe543d 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubRewardedVideoManagerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubRewardedVideoManagerTest.java
@@ -1,272 +1,294 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-
-import com.mopub.common.AdType;
-import com.mopub.common.LifecycleListener;
-import com.mopub.common.MoPubReward;
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.network.AdRequest;
-import com.mopub.network.AdResponse;
-import com.mopub.network.MoPubRequestQueue;
-import com.mopub.network.Networking;
-import com.mopub.volley.VolleyError;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.Robolectric;
-
-import java.util.Map;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.when;
-
-@RunWith(SdkTestRunner.class)
-public class MoPubRewardedVideoManagerTest {
-
-    @Mock
-    MoPubRequestQueue mockRequestQueue;
-    @Mock
-    MoPubRewardedVideoListener mockVideoListener;
-
-    AdRequest.Listener requestListener;
-    private AdRequest request;
-    private boolean mLoaded;
-
-    @Before
-    public void setup() {
-        MoPubRewardedVideoManager.init(Robolectric.buildActivity(Activity.class).create().get());
-        MoPubRewardedVideoManager.setVideoListener(mockVideoListener);
-
-        when(mockRequestQueue.add(any(AdRequest.class))).then(new Answer<Object>() {
-            @Override
-            public Object answer(final InvocationOnMock invocationOnMock) throws Throwable {
-                request = ((AdRequest) invocationOnMock.getArguments()[0]);
-                requestListener = request.getListener();
-                return null;
-            }
-        });
-
-        Networking.setRequestQueueForTesting(mockRequestQueue);
-    }
-
-    @After
-    public void tearDown() {
-        // Unpause the main looper in case a test terminated while the looper was paused.
-        Robolectric.unPauseMainLooper();
-    }
-
-    @Test
-    public void callbackMethods_withNullListener_shouldNotError() {
-        // Clients can set RVM null.
-        MoPubRewardedVideoManager.setVideoListener(null);
-
-        AdResponse testResponse = new AdResponse.Builder()
-                .setCustomEventClassName("com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
-                .setAdType(AdType.CUSTOM)
-                .build();
-
-        // Robolectric executes its handlers immediately, so if we want the async behavior we see
-        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
-        Robolectric.pauseMainLooper();
-
-        MoPubRewardedVideoManager.loadVideo("testAdUnit");
-        // Triggers a call to MoPubRewardedVideoManager.onRewardedVideoLoadSuccess
-        requestListener.onSuccess(testResponse);
-
-        Robolectric.unPauseMainLooper();
-
-        MoPubRewardedVideoManager.onRewardedVideoClicked(TestCustomEvent.class, "id!");
-        MoPubRewardedVideoManager.onRewardedVideoStarted(TestCustomEvent.class, "id!");
-        MoPubRewardedVideoManager.onRewardedVideoClosed(TestCustomEvent.class, "id!");
-        MoPubRewardedVideoManager.onRewardedVideoCompleted(TestCustomEvent.class, "id!", MoPubReward.success("test", 111));
-
-        // The test passed because none of the above calls thew an exception even though the listener is null.
-    }
-
-    @Test
-    public void onAdSuccess_noCEFound_shouldCallFailCallback() throws Exception {
-        AdResponse testResponse = new AdResponse.Builder()
-                .setAdType(AdType.CUSTOM)
-                .setCustomEventClassName("doesn't_Exist")
-                .build();
-
-        MoPubRewardedVideoManager.loadVideo("testAdUnit");
-
-        requestListener.onSuccess(testResponse);
-
-        verify(mockVideoListener).onRewardedVideoLoadFailure(eq("testAdUnit"), eq(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR));
-        verifyNoMoreInteractions(mockVideoListener);
-    }
-
-    @Test
-    public void onAdSuccess_noCEFound_shouldLoadFailUrl() {
-        AdResponse testResponse = new AdResponse.Builder()
-                .setAdType(AdType.CUSTOM)
-                .setCustomEventClassName("doesn't_Exist")
-                .setFailoverUrl("fail.url")
-                .build();
-
-        MoPubRewardedVideoManager.loadVideo("testAdUnit");
-
-        assertThat(request.getUrl()).contains("testAdUnit");
-        requestListener.onSuccess(testResponse);
-        assertThat(request.getUrl()).isEqualTo("fail.url");
-        // Clear up the static state :(
-        requestListener.onErrorResponse(new VolleyError("reset"));
-    }
-
-    @Test
-    public void onAdSuccess_shouldInstantiateCustomEvent_andLoad() {
-        AdResponse testResponse = new AdResponse.Builder()
-                .setCustomEventClassName("com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
-                .setAdType(AdType.CUSTOM)
-                .build();
-
-        // Robolectric executes its handlers immediately, so if we want the async behavior we see
-        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
-        Robolectric.pauseMainLooper();
-
-        MoPubRewardedVideoManager.loadVideo("testAdUnit");
-        requestListener.onSuccess(testResponse);
-
-        Robolectric.unPauseMainLooper();
-
-        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isTrue();
-        verify(mockVideoListener).onRewardedVideoLoadSuccess(eq("testAdUnit"));
-        verifyNoMoreInteractions(mockVideoListener);
-    }
-
-    @Test
-    public void playVideo_shouldSetHasVideoFalse() {
-        AdResponse testResponse = new AdResponse.Builder()
-                .setCustomEventClassName("com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
-                .setAdType(AdType.CUSTOM)
-                .build();
-
-        // Robolectric executes its handlers immediately, so if we want the async behavior we see
-        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
-        Robolectric.pauseMainLooper();
-
-        MoPubRewardedVideoManager.loadVideo("testAdUnit");
-        requestListener.onSuccess(testResponse);
-
-        Robolectric.unPauseMainLooper();
-
-        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isTrue();
-        MoPubRewardedVideoManager.showVideo("testAdUnit");
-        verify(mockVideoListener).onRewardedVideoLoadSuccess(eq("testAdUnit"));
-        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isFalse();
-        verify(mockVideoListener).onRewardedVideoStarted(eq("testAdUnit"));
-    }
-    
-    @Test
-    public void playVideo_whenNotHasVideo_shouldFail() {
-        AdResponse testResponse = new AdResponse.Builder()
-                .setCustomEventClassName("com.mopub.mobileads.MoPubRewardedVideoManagerTest$NoVideoCustomEvent")
-                .setAdType(AdType.CUSTOM)
-                .build();
-
-        // Robolectric executes its handlers immediately, so if we want the async behavior we see
-        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
-        Robolectric.pauseMainLooper();
-
-        MoPubRewardedVideoManager.loadVideo("testAdUnit");
-        requestListener.onSuccess(testResponse);
-
-        Robolectric.unPauseMainLooper();
-
-        verify(mockVideoListener).onRewardedVideoLoadFailure(eq("testAdUnit"), eq(MoPubErrorCode.NETWORK_NO_FILL));
-
-        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isFalse();
-        MoPubRewardedVideoManager.showVideo("testAdUnit");
-        verify(mockVideoListener).onRewardedVideoLoadFailure(eq("testAdUnit"), eq(MoPubErrorCode.VIDEO_NOT_AVAILABLE));
-    }
-
-    @Test
-    public void onAdFailure_shouldCallFailCallback() {
-        VolleyError e = new VolleyError("testError!");
-
-        MoPubRewardedVideoManager.loadVideo("testAdUnit");
-
-        assertThat(request.getUrl()).contains("testAdUnit");
-        requestListener.onErrorResponse(e);
-        verify(mockVideoListener).onRewardedVideoLoadFailure(anyString(), any(MoPubErrorCode.class));
-        verifyNoMoreInteractions(mockVideoListener);
-    }
-
-    public static class TestCustomEvent extends CustomEventRewardedVideo {
-        protected boolean mPlayable = false;
-
-        @Nullable
-        @Override
-        protected CustomEventRewardedVideoListener getVideoListenerForSdk() {
-            return null;
-        }
-
-        @Nullable
-        @Override
-        protected LifecycleListener getLifecycleListener() {
-            return null;
-        }
-
-        @NonNull
-        @Override
-        protected String getAdNetworkId() {
-            return "id!";
-        }
-
-        @Override
-        protected void onInvalidate() {
-            mPlayable = false;
-        }
-
-        @Override
-        protected boolean checkAndInitializeSdk(@NonNull final Activity launcherActivity,
-                @NonNull final Map<String, Object> localExtras,
-                @NonNull final Map<String, String> serverExtras) throws Exception {
-            return false;
-        }
-
-        @Override
-        protected void loadWithSdkInitialized(@NonNull final Activity activity,
-                @NonNull final Map<String, Object> localExtras,
-                @NonNull final Map<String, String> serverExtras) throws Exception {
-            // Do nothing because robolectric handlers execute immediately.
-            mPlayable = true;
-            MoPubRewardedVideoManager.onRewardedVideoLoadSuccess(TestCustomEvent.class, "id!");
-        }
-
-        @Override
-        protected boolean hasVideoAvailable() {
-            return mPlayable;
-        }
-
-        @Override
-        protected void showVideo() {
-            MoPubRewardedVideoManager.onRewardedVideoStarted(TestCustomEvent.class, "id!");
-        }
-    }
-
-    public static class NoVideoCustomEvent extends TestCustomEvent {
-        @Override
-        protected void loadWithSdkInitialized(@NonNull final Activity activity,
-                @NonNull final Map<String, Object> localExtras,
-                @NonNull final Map<String, String> serverExtras) throws Exception {
-            mPlayable = false;
-            MoPubRewardedVideoManager.onRewardedVideoLoadFailure(NoVideoCustomEvent.class, "id!", MoPubErrorCode.NETWORK_NO_FILL);
-        }
-    }
-}
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.AdType;
+import com.mopub.common.LifecycleListener;
+import com.mopub.common.MoPubReward;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.network.AdRequest;
+import com.mopub.network.AdResponse;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.volley.VolleyError;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
+
+import java.util.Map;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class
+        MoPubRewardedVideoManagerTest {
+
+    @Mock
+    MoPubRequestQueue mockRequestQueue;
+    @Mock
+    MoPubRewardedVideoListener mockVideoListener;
+
+    AdRequest.Listener requestListener;
+    private AdRequest request;
+    private Activity mActivity;
+
+    @Before
+    public void setup() {
+        mActivity = Robolectric.buildActivity(Activity.class).create().get();
+        MoPubRewardedVideoManager.init(mActivity);
+        MoPubRewardedVideoManager.setVideoListener(mockVideoListener);
+
+        when(mockRequestQueue.add(any(AdRequest.class))).then(new Answer<Object>() {
+            @Override
+            public Object answer(final InvocationOnMock invocationOnMock) throws Throwable {
+                request = ((AdRequest) invocationOnMock.getArguments()[0]);
+                requestListener = request.getListener();
+                return null;
+            }
+        });
+
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+    }
+
+    @After
+    public void tearDown() {
+        // Unpause the main looper in case a test terminated while the looper was paused.
+        Robolectric.unPauseMainLooper();
+    }
+
+    @Test
+    public void callbackMethods_withNullListener_shouldNotError() {
+        // Clients can set RVM null.
+        MoPubRewardedVideoManager.setVideoListener(null);
+
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName("com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        Robolectric.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit");
+        // Triggers a call to MoPubRewardedVideoManager.onRewardedVideoLoadSuccess
+        requestListener.onSuccess(testResponse);
+
+        Robolectric.unPauseMainLooper();
+
+        MoPubRewardedVideoManager.onRewardedVideoClicked(TestCustomEvent.class, "id!");
+        MoPubRewardedVideoManager.onRewardedVideoStarted(TestCustomEvent.class, "id!");
+        MoPubRewardedVideoManager.onRewardedVideoClosed(TestCustomEvent.class, "id!");
+        MoPubRewardedVideoManager.onRewardedVideoCompleted(TestCustomEvent.class, "id!", MoPubReward.success("test", 111));
+
+        // The test passed because none of the above calls thew an exception even though the listener is null.
+    }
+
+    @Test
+    public void onAdSuccess_noActivityFound_shouldNotCallFailUrl() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setAdType(AdType.CUSTOM)
+                .setCustomEventClassName(
+                        "com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setFailoverUrl("fail.url")
+                .build();
+
+        MoPubRewardedVideoManager.updateActivity(null);
+        MoPubRewardedVideoManager.loadVideo("testAdUnit");
+        requestListener.onSuccess(testResponse);
+
+        verify(mockRequestQueue).add(any(AdRequest.class));
+        verifyNoMoreInteractions(mockRequestQueue);
+
+        // Clean up the static state we screwed up:
+        MoPubRewardedVideoManager.updateActivity(mActivity);
+    }
+
+    @Test
+    public void onAdSuccess_noCEFound_shouldCallFailCallback() throws Exception {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setAdType(AdType.CUSTOM)
+                .setCustomEventClassName("doesn't_Exist")
+                .build();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit");
+
+        requestListener.onSuccess(testResponse);
+
+        verify(mockVideoListener).onRewardedVideoLoadFailure(eq("testAdUnit"), eq(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR));
+        verifyNoMoreInteractions(mockVideoListener);
+    }
+
+    @Test
+    public void onAdSuccess_noCEFound_shouldLoadFailUrl() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setAdType(AdType.CUSTOM)
+                .setCustomEventClassName("doesn't_Exist")
+                .setFailoverUrl("fail.url")
+                .build();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit");
+
+        assertThat(request.getUrl()).contains("testAdUnit");
+        requestListener.onSuccess(testResponse);
+        assertThat(request.getUrl()).isEqualTo("fail.url");
+        // Clear up the static state :(
+        requestListener.onErrorResponse(new VolleyError("reset"));
+    }
+
+    @Test
+    public void onAdSuccess_shouldInstantiateCustomEvent_andLoad() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName("com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        Robolectric.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit");
+        requestListener.onSuccess(testResponse);
+
+        Robolectric.unPauseMainLooper();
+
+        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isTrue();
+        verify(mockVideoListener).onRewardedVideoLoadSuccess(eq("testAdUnit"));
+        verifyNoMoreInteractions(mockVideoListener);
+    }
+
+    @Test
+    public void playVideo_shouldSetHasVideoFalse() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName("com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        Robolectric.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit");
+        requestListener.onSuccess(testResponse);
+
+        Robolectric.unPauseMainLooper();
+
+        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isTrue();
+        MoPubRewardedVideoManager.showVideo("testAdUnit");
+        verify(mockVideoListener).onRewardedVideoLoadSuccess(eq("testAdUnit"));
+        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isFalse();
+        verify(mockVideoListener).onRewardedVideoStarted(eq("testAdUnit"));
+    }
+    
+    @Test
+    public void playVideo_whenNotHasVideo_shouldFail() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName("com.mopub.mobileads.MoPubRewardedVideoManagerTest$NoVideoCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        Robolectric.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit");
+        requestListener.onSuccess(testResponse);
+
+        Robolectric.unPauseMainLooper();
+
+        verify(mockVideoListener).onRewardedVideoLoadFailure(eq("testAdUnit"), eq(MoPubErrorCode.NETWORK_NO_FILL));
+
+        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isFalse();
+        MoPubRewardedVideoManager.showVideo("testAdUnit");
+        verify(mockVideoListener).onRewardedVideoLoadFailure(eq("testAdUnit"), eq(MoPubErrorCode.VIDEO_NOT_AVAILABLE));
+    }
+
+    @Test
+    public void onAdFailure_shouldCallFailCallback() {
+        VolleyError e = new VolleyError("testError!");
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit");
+
+        assertThat(request.getUrl()).contains("testAdUnit");
+        requestListener.onErrorResponse(e);
+        verify(mockVideoListener).onRewardedVideoLoadFailure(anyString(), any(MoPubErrorCode.class));
+        verifyNoMoreInteractions(mockVideoListener);
+    }
+
+    public static class TestCustomEvent extends CustomEventRewardedVideo {
+        protected boolean mPlayable = false;
+
+        @Nullable
+        @Override
+        protected CustomEventRewardedVideoListener getVideoListenerForSdk() {
+            return null;
+        }
+
+        @Nullable
+        @Override
+        protected LifecycleListener getLifecycleListener() {
+            return null;
+        }
+
+        @NonNull
+        @Override
+        protected String getAdNetworkId() {
+            return "id!";
+        }
+
+        @Override
+        protected void onInvalidate() {
+            mPlayable = false;
+        }
+
+        @Override
+        protected boolean checkAndInitializeSdk(@NonNull final Activity launcherActivity,
+                @NonNull final Map<String, Object> localExtras,
+                @NonNull final Map<String, String> serverExtras) throws Exception {
+            return false;
+        }
+
+        @Override
+        protected void loadWithSdkInitialized(@NonNull final Activity activity,
+                @NonNull final Map<String, Object> localExtras,
+                @NonNull final Map<String, String> serverExtras) throws Exception {
+            // Do nothing because robolectric handlers execute immediately.
+            mPlayable = true;
+            MoPubRewardedVideoManager.onRewardedVideoLoadSuccess(TestCustomEvent.class, "id!");
+        }
+
+        @Override
+        protected boolean hasVideoAvailable() {
+            return mPlayable;
+        }
+
+        @Override
+        protected void showVideo() {
+            MoPubRewardedVideoManager.onRewardedVideoStarted(TestCustomEvent.class, "id!");
+        }
+    }
+
+    public static class NoVideoCustomEvent extends TestCustomEvent {
+        @Override
+        protected void loadWithSdkInitialized(@NonNull final Activity activity,
+                @NonNull final Map<String, Object> localExtras,
+                @NonNull final Map<String, String> serverExtras) throws Exception {
+            mPlayable = false;
+            MoPubRewardedVideoManager.onRewardedVideoLoadFailure(NoVideoCustomEvent.class, "id!", MoPubErrorCode.NETWORK_NO_FILL);
+        }
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubViewTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubViewTest.java
index e63b00a9..4bab198e 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubViewTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubViewTest.java
@@ -1,208 +1,208 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.view.View;
-
-import com.mopub.common.LocationService;
-import com.mopub.common.MoPub;
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.mobileads.test.support.TestAdViewControllerFactory;
-import com.mopub.mobileads.test.support.TestCustomEventBannerAdapterFactory;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.shadows.ShadowApplication;
-
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.verify;
-
-@RunWith(SdkTestRunner.class)
-public class MoPubViewTest {
-    private MoPubView subject;
-    private Map<String,String> paramsMap = new HashMap<String, String>();
-    private CustomEventBannerAdapter customEventBannerAdapter;
-    private AdViewController adViewController;
-    private Context context;
-
-    @Before
-    public void setup() {
-        context = new Activity();
-        subject = new MoPubView(context);
-        customEventBannerAdapter = TestCustomEventBannerAdapterFactory.getSingletonMock();
-        reset(customEventBannerAdapter);
-        adViewController = TestAdViewControllerFactory.getSingletonMock();
-    }
-
-    @Test
-    public void screenStateBroadcastReceiver_withActionUserPresent_shouldUnpauseRefresh() throws Exception {
-        broadcastIntent(new Intent(Intent.ACTION_USER_PRESENT));
-
-        verify(adViewController).unpauseRefresh();
-    }
-
-    @Test
-    public void screenStateBroadcastReceiver_withActionScreenOff_shouldPauseRefersh() throws Exception {
-        broadcastIntent(new Intent(Intent.ACTION_SCREEN_OFF));
-
-        verify(adViewController).pauseRefresh();
-    }
-
-    @Test
-    public void screenStateBroadcastReceiver_withNullIntent_shouldDoNothing() throws Exception {
-        broadcastIntent(null);
-
-        verify(adViewController, never()).pauseRefresh();
-        verify(adViewController, never()).unpauseRefresh();
-    }
-
-    @Test
-    public void screenStateBroadcastReceiver_withRandomIntent_shouldDoNothing() throws Exception {
-        broadcastIntent(new Intent(Intent.ACTION_BATTERY_LOW));
-
-        verify(adViewController, never()).pauseRefresh();
-        verify(adViewController, never()).unpauseRefresh();
-    }
-
-    @Test
-    public void screenStateBroadcastReceiver_whenAdInBackground_shouldDoNothing() throws Exception {
-        subject.onWindowVisibilityChanged(View.INVISIBLE);
-        reset(adViewController);
-
-        broadcastIntent(new Intent(Intent.ACTION_USER_PRESENT));
-        verify(adViewController, never()).unpauseRefresh();
-
-        broadcastIntent(new Intent(Intent.ACTION_SCREEN_OFF));
-        verify(adViewController, never()).pauseRefresh();
-    }
-
-    @Test
-    public void screenStateBroadcastReceiver_afterOnDestroy_shouldDoNothing() throws Exception {
-        subject.destroy();
-
-        broadcastIntent(new Intent(Intent.ACTION_USER_PRESENT));
-        verify(adViewController, never()).unpauseRefresh();
-
-        broadcastIntent(new Intent(Intent.ACTION_SCREEN_OFF));
-        verify(adViewController, never()).pauseRefresh();
-    }
-
-    @Test
-    public void onWindowVisibilityChanged_fromVisibleToInvisible_shouldPauseRefresh() throws Exception {
-        // Default visibility is View.VISIBLE
-        subject.onWindowVisibilityChanged(View.INVISIBLE);
-
-        verify(adViewController).pauseRefresh();
-        verify(adViewController, never()).unpauseRefresh();
-    }
-
-
-    @Test
-    public void onWindowVisibilityChanged_fromInvisibleToVisible_shouldUnpauseRefresh() throws Exception {
-        subject.onWindowVisibilityChanged(View.INVISIBLE);
-        reset(adViewController);
-
-        subject.onWindowVisibilityChanged(View.VISIBLE);
-
-        verify(adViewController, never()).pauseRefresh();
-        verify(adViewController).unpauseRefresh();
-    }
-
-    @Test
-    public void onWindowVisibilityChanged_fromVisibleToVisible_shouldDoNothing() throws Exception {
-        // Default visibility is View.VISIBLE
-        subject.onWindowVisibilityChanged(View.VISIBLE);
-
-        verify(adViewController, never()).pauseRefresh();
-        verify(adViewController, never()).unpauseRefresh();
-    }
-
-    @Test
-    public void onWindowVisibilityChanged_fromInvisibleToGone_shouldDoNothing() throws Exception {
-        subject.onWindowVisibilityChanged(View.INVISIBLE);
-        reset(adViewController);
-
-        subject.onWindowVisibilityChanged(View.GONE);
-
-        verify(adViewController, never()).pauseRefresh();
-        verify(adViewController, never()).unpauseRefresh();
-    }
-
-    @Test
-    public void onWindowVisibilityChanged_fromGoneToInvisible_shouldDoNothing() throws Exception {
-        subject.onWindowVisibilityChanged(View.GONE);
-        reset(adViewController);
-
-        subject.onWindowVisibilityChanged(View.INVISIBLE);
-
-        verify(adViewController, never()).pauseRefresh();
-        verify(adViewController, never()).unpauseRefresh();
-    }
-
-    @Test
-    public void setAutorefreshEnabled_withRefreshTrue_shouldForwardToAdViewController() throws Exception {
-        subject.setAutorefreshEnabled(true);
-
-        verify(adViewController).forceSetAutorefreshEnabled(true);
-    }
-
-    @Test
-    public void setAutorefreshEnabled_withRefreshFalse_shouldForwardToAdViewController() throws Exception {
-        subject.setAutorefreshEnabled(false);
-
-        verify(adViewController).forceSetAutorefreshEnabled(false);
-    }
-    
-    @Test
-    public void nativeAdLoaded_shouldScheduleRefreshTimer() throws Exception {
-        subject.nativeAdLoaded();
-
-        verify(adViewController).scheduleRefreshTimerIfEnabled();
-    }
-
-    @Test
-    public void loadCustomEvent_shouldInitializeCustomEventBannerAdapter() throws Exception {
-        subject.loadCustomEvent("name", paramsMap);
-
-        assertThat(TestCustomEventBannerAdapterFactory.getLatestMoPubView()).isEqualTo(subject);
-        assertThat(TestCustomEventBannerAdapterFactory.getLatestClassName()).isEqualTo("name");
-        assertThat(TestCustomEventBannerAdapterFactory.getLatestClassData()).isEqualTo(paramsMap);
-
-        verify(customEventBannerAdapter).loadAd();
-    }
-
-    @Test
-    public void loadCustomEvent_whenParamsMapIsNull_shouldCallLoadFailUrl() throws Exception {
-        subject.loadCustomEvent(null, null);
-
-        verify(adViewController).loadFailUrl(eq(ADAPTER_NOT_FOUND));
-        verify(customEventBannerAdapter, never()).invalidate();
-        verify(customEventBannerAdapter, never()).loadAd();
-    }
-
-    @Test
-    public void setLocationAwarenss_shouldChangeGlobalSetting() {
-        assertThat(MoPub.getLocationAwareness()).isEqualTo(MoPub.LocationAwareness.NORMAL);
-        subject.setLocationAwareness(LocationService.LocationAwareness.DISABLED);
-        assertThat(MoPub.getLocationAwareness()).isEqualTo(MoPub.LocationAwareness.DISABLED);
-    }
-
-    private void broadcastIntent(final Intent intent) {
-        final List<ShadowApplication.Wrapper> wrappers = Robolectric.getShadowApplication().getRegisteredReceivers();
-
-        for (final ShadowApplication.Wrapper wrapper : wrappers) {
-            wrapper.broadcastReceiver.onReceive(context, intent);
-        }
-    }
-}
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.view.View;
+
+import com.mopub.common.LocationService;
+import com.mopub.common.MoPub;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.test.support.TestAdViewControllerFactory;
+import com.mopub.mobileads.test.support.TestCustomEventBannerAdapterFactory;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.shadows.ShadowApplication;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+
+@RunWith(SdkTestRunner.class)
+public class MoPubViewTest {
+    private MoPubView subject;
+    private Map<String,String> paramsMap = new HashMap<String, String>();
+    private CustomEventBannerAdapter customEventBannerAdapter;
+    private AdViewController adViewController;
+    private Context context;
+
+    @Before
+    public void setup() {
+        context = Robolectric.buildActivity(Activity.class).create().get();
+        subject = new MoPubView(context);
+        customEventBannerAdapter = TestCustomEventBannerAdapterFactory.getSingletonMock();
+        reset(customEventBannerAdapter);
+        adViewController = TestAdViewControllerFactory.getSingletonMock();
+    }
+
+    @Test
+    public void screenStateBroadcastReceiver_withActionUserPresent_shouldUnpauseRefresh() throws Exception {
+        broadcastIntent(new Intent(Intent.ACTION_USER_PRESENT));
+
+        verify(adViewController).unpauseRefresh();
+    }
+
+    @Test
+    public void screenStateBroadcastReceiver_withActionScreenOff_shouldPauseRefersh() throws Exception {
+        broadcastIntent(new Intent(Intent.ACTION_SCREEN_OFF));
+
+        verify(adViewController).pauseRefresh();
+    }
+
+    @Test
+    public void screenStateBroadcastReceiver_withNullIntent_shouldDoNothing() throws Exception {
+        broadcastIntent(null);
+
+        verify(adViewController, never()).pauseRefresh();
+        verify(adViewController, never()).unpauseRefresh();
+    }
+
+    @Test
+    public void screenStateBroadcastReceiver_withRandomIntent_shouldDoNothing() throws Exception {
+        broadcastIntent(new Intent(Intent.ACTION_BATTERY_LOW));
+
+        verify(adViewController, never()).pauseRefresh();
+        verify(adViewController, never()).unpauseRefresh();
+    }
+
+    @Test
+    public void screenStateBroadcastReceiver_whenAdInBackground_shouldDoNothing() throws Exception {
+        subject.onWindowVisibilityChanged(View.INVISIBLE);
+        reset(adViewController);
+
+        broadcastIntent(new Intent(Intent.ACTION_USER_PRESENT));
+        verify(adViewController, never()).unpauseRefresh();
+
+        broadcastIntent(new Intent(Intent.ACTION_SCREEN_OFF));
+        verify(adViewController, never()).pauseRefresh();
+    }
+
+    @Test
+    public void screenStateBroadcastReceiver_afterOnDestroy_shouldDoNothing() throws Exception {
+        subject.destroy();
+
+        broadcastIntent(new Intent(Intent.ACTION_USER_PRESENT));
+        verify(adViewController, never()).unpauseRefresh();
+
+        broadcastIntent(new Intent(Intent.ACTION_SCREEN_OFF));
+        verify(adViewController, never()).pauseRefresh();
+    }
+
+    @Test
+    public void onWindowVisibilityChanged_fromVisibleToInvisible_shouldPauseRefresh() throws Exception {
+        // Default visibility is View.VISIBLE
+        subject.onWindowVisibilityChanged(View.INVISIBLE);
+
+        verify(adViewController).pauseRefresh();
+        verify(adViewController, never()).unpauseRefresh();
+    }
+
+
+    @Test
+    public void onWindowVisibilityChanged_fromInvisibleToVisible_shouldUnpauseRefresh() throws Exception {
+        subject.onWindowVisibilityChanged(View.INVISIBLE);
+        reset(adViewController);
+
+        subject.onWindowVisibilityChanged(View.VISIBLE);
+
+        verify(adViewController, never()).pauseRefresh();
+        verify(adViewController).unpauseRefresh();
+    }
+
+    @Test
+    public void onWindowVisibilityChanged_fromVisibleToVisible_shouldDoNothing() throws Exception {
+        // Default visibility is View.VISIBLE
+        subject.onWindowVisibilityChanged(View.VISIBLE);
+
+        verify(adViewController, never()).pauseRefresh();
+        verify(adViewController, never()).unpauseRefresh();
+    }
+
+    @Test
+    public void onWindowVisibilityChanged_fromInvisibleToGone_shouldDoNothing() throws Exception {
+        subject.onWindowVisibilityChanged(View.INVISIBLE);
+        reset(adViewController);
+
+        subject.onWindowVisibilityChanged(View.GONE);
+
+        verify(adViewController, never()).pauseRefresh();
+        verify(adViewController, never()).unpauseRefresh();
+    }
+
+    @Test
+    public void onWindowVisibilityChanged_fromGoneToInvisible_shouldDoNothing() throws Exception {
+        subject.onWindowVisibilityChanged(View.GONE);
+        reset(adViewController);
+
+        subject.onWindowVisibilityChanged(View.INVISIBLE);
+
+        verify(adViewController, never()).pauseRefresh();
+        verify(adViewController, never()).unpauseRefresh();
+    }
+
+    @Test
+    public void setAutorefreshEnabled_withRefreshTrue_shouldForwardToAdViewController() throws Exception {
+        subject.setAutorefreshEnabled(true);
+
+        verify(adViewController).forceSetAutorefreshEnabled(true);
+    }
+
+    @Test
+    public void setAutorefreshEnabled_withRefreshFalse_shouldForwardToAdViewController() throws Exception {
+        subject.setAutorefreshEnabled(false);
+
+        verify(adViewController).forceSetAutorefreshEnabled(false);
+    }
+    
+    @Test
+    public void nativeAdLoaded_shouldScheduleRefreshTimer() throws Exception {
+        subject.nativeAdLoaded();
+
+        verify(adViewController).scheduleRefreshTimerIfEnabled();
+    }
+
+    @Test
+    public void loadCustomEvent_shouldInitializeCustomEventBannerAdapter() throws Exception {
+        subject.loadCustomEvent("name", paramsMap);
+
+        assertThat(TestCustomEventBannerAdapterFactory.getLatestMoPubView()).isEqualTo(subject);
+        assertThat(TestCustomEventBannerAdapterFactory.getLatestClassName()).isEqualTo("name");
+        assertThat(TestCustomEventBannerAdapterFactory.getLatestClassData()).isEqualTo(paramsMap);
+
+        verify(customEventBannerAdapter).loadAd();
+    }
+
+    @Test
+    public void loadCustomEvent_whenParamsMapIsNull_shouldCallLoadFailUrl() throws Exception {
+        subject.loadCustomEvent(null, null);
+
+        verify(adViewController).loadFailUrl(eq(ADAPTER_NOT_FOUND));
+        verify(customEventBannerAdapter, never()).invalidate();
+        verify(customEventBannerAdapter, never()).loadAd();
+    }
+
+    @Test
+    public void setLocationAwarenss_shouldChangeGlobalSetting() {
+        assertThat(MoPub.getLocationAwareness()).isEqualTo(MoPub.LocationAwareness.NORMAL);
+        subject.setLocationAwareness(LocationService.LocationAwareness.DISABLED);
+        assertThat(MoPub.getLocationAwareness()).isEqualTo(MoPub.LocationAwareness.DISABLED);
+    }
+
+    private void broadcastIntent(final Intent intent) {
+        final List<ShadowApplication.Wrapper> wrappers = Robolectric.getShadowApplication().getRegisteredReceivers();
+
+        for (final ShadowApplication.Wrapper wrapper : wrappers) {
+            wrapper.broadcastReceiver.onReceive(context, intent);
+        }
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidVideoPlayerActivityTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidVideoPlayerActivityTest.java
index 0de5e27c..4d9e765a 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidVideoPlayerActivityTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidVideoPlayerActivityTest.java
@@ -1,195 +1,195 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.ActivityInfo;
-import android.os.Bundle;
-import android.view.View;
-import android.widget.ImageView;
-
-import com.mopub.common.MoPubBrowser;
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.mobileads.util.vast.VastVideoConfiguration;
-import com.mopub.mraid.MraidVideoViewController;
-
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.shadows.ShadowActivity;
-
-import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.robolectric.Robolectric.shadowOf;
-
-@RunWith(SdkTestRunner.class)
-public class MraidVideoPlayerActivityTest {
-    private static final String VAST = "vast";
-    private static final String MRAID = "mraid";
-
-    private MraidVideoPlayerActivity subject;
-    private long testBroadcastIdentifier;
-    private Intent intent;
-    private Context context;
-    private BaseVideoViewController baseVideoViewController;
-
-    @Before
-    public void setup() {
-        context = new Activity();
-        intent = new Intent(context, MraidVideoPlayerActivity.class);
-
-        testBroadcastIdentifier = 1001;
-        intent.putExtra(BROADCAST_IDENTIFIER_KEY, testBroadcastIdentifier);
-        baseVideoViewController = mock(BaseVideoViewController.class);
-    }
-
-    @Test
-    public void onCreate_withVastExtraKey_shouldUseVastVideoViewController() throws Exception {
-        initializeSubjectForVast();
-
-        assertThat(subject.getBaseVideoViewController()).isInstanceOf(VastVideoViewController.class);
-    }
-
-    @Test
-    public void onCreate_withMraidExtraKey_shouldUseMraidVideoViewController() throws Exception {
-        initializeSubjectForMraid();
-
-        assertThat(subject.getBaseVideoViewController()).isInstanceOf(MraidVideoViewController.class);
-    }
-
-    @Ignore("pending: this is currently impossible to write")
-    @Test
-    public void onCreate_shouldForwardOnCreateToViewController() throws Exception {
-        initializeSubjectWithMockViewController();
-
-    }
-
-    @Test
-    public void onPause_shouldForwardOnPauseToViewController() throws Exception {
-        initializeSubjectWithMockViewController();
-
-        subject.onPause();
-
-        verify(baseVideoViewController).onPause();
-    }
-
-    @Test
-    public void onResume_shouldForwardOnResumeToViewController() throws Exception {
-        initializeSubjectWithMockViewController();
-
-        subject.onResume();
-
-        verify(baseVideoViewController).onResume();
-    }
-
-    @Test
-    public void onDestroy_shouldForwardOnDestroyToViewController() throws Exception {
-        initializeSubjectWithMockViewController();
-
-        subject.onDestroy();
-
-        verify(baseVideoViewController).onDestroy();
-    }
-
-    @Test
-    public void onActivityResult_shouldForwardOnActivityResultToViewController() throws Exception {
-        initializeSubjectWithMockViewController();
-
-        int expectedRequestCode = -100;
-        int expectedResultCode = 200;
-        Intent expectedData = new Intent("arbitrary_data");
-        subject.onActivityResult(expectedRequestCode, expectedResultCode, expectedData);
-
-        verify(baseVideoViewController).onActivityResult(
-                eq(expectedRequestCode),
-                eq(expectedResultCode),
-                eq(expectedData)
-        );
-    }
-
-    @Test
-    public void onSetContentView_shouldActuallySetContentView() throws Exception {
-        initializeSubjectWithMockViewController();
-        final View expectedView = new ImageView(context);
-
-        subject.onSetContentView(expectedView);
-
-        assertThat(shadowOf(subject).getContentView()).isEqualTo(expectedView);
-    }
-
-    @Test
-    public void onSetRequestedOrientation_shouldActuallySetRequestedOrientation() throws Exception {
-        initializeSubjectWithMockViewController();
-
-        subject.onSetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR);
-
-        assertThat(subject.getRequestedOrientation()).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_SENSOR);
-    }
-
-    @Test
-    public void onFinish_shouldActuallyCallFinish() throws Exception {
-        initializeSubjectWithMockViewController();
-
-        subject.onFinish();
-
-        assertThat(subject.isFinishing());
-    }
-
-    @Test
-    public void onStartActivityForResult_shouldStartAnActivityWithRelevantRequestCodeAndExtras() throws Exception {
-        initializeSubjectWithMockViewController();
-
-        final Bundle expectedExtras = new Bundle();
-        expectedExtras.putString("hello", "goodbye");
-
-        subject.onStartActivityForResult(MoPubBrowser.class, 100, expectedExtras);
-
-        final ShadowActivity.IntentForResult intentForResult = shadowOf(subject).getNextStartedActivityForResult();
-
-        assertThat(intentForResult.intent.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
-        assertThat(intentForResult.intent.getExtras()).isEqualTo(expectedExtras);
-        assertThat(intentForResult.requestCode).isEqualTo(100);
-    }
-
-    @Test
-    public void onStartActivityForResult_withNullClass_shouldNotStartAnActivity() throws Exception {
-        initializeSubjectWithMockViewController();
-
-        subject.onStartActivityForResult(null, 100, new Bundle());
-
-        final ShadowActivity.IntentForResult intentForResult = shadowOf(subject).getNextStartedActivityForResult();
-        assertThat(intentForResult).isNull();
-    }
-
-    private void initializeSubjectForMraid() {
-        intent.putExtra(BaseVideoPlayerActivity.VIDEO_CLASS_EXTRAS_KEY, "mraid");
-
-        subject = Robolectric.buildActivity(MraidVideoPlayerActivity.class)
-                .withIntent(intent)
-                .create()
-                .get();
-    }
-
-    private void initializeSubjectForVast() {
-        intent.putExtra(BaseVideoPlayerActivity.VIDEO_CLASS_EXTRAS_KEY, "vast");
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("video_path");
-        intent.putExtra(VastVideoViewController.VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        subject = Robolectric.buildActivity(MraidVideoPlayerActivity.class)
-                .withIntent(intent)
-                .create()
-                .get();
-    }
-
-    private void initializeSubjectWithMockViewController() {
-        initializeSubjectForMraid();
-
-        subject.setBaseVideoViewController(baseVideoViewController);
-    }
-}
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.ActivityInfo;
+import android.os.Bundle;
+import android.view.View;
+import android.widget.ImageView;
+
+import com.mopub.common.MoPubBrowser;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.util.vast.VastVideoConfiguration;
+import com.mopub.mraid.MraidVideoViewController;
+
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.shadows.ShadowActivity;
+
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.robolectric.Robolectric.shadowOf;
+
+@RunWith(SdkTestRunner.class)
+public class MraidVideoPlayerActivityTest {
+    private static final String VAST = "vast";
+    private static final String MRAID = "mraid";
+
+    private MraidVideoPlayerActivity subject;
+    private long testBroadcastIdentifier;
+    private Intent intent;
+    private Context context;
+    private BaseVideoViewController baseVideoViewController;
+
+    @Before
+    public void setup() {
+        context = Robolectric.buildActivity(Activity.class).create().get();
+        intent = new Intent(context, MraidVideoPlayerActivity.class);
+
+        testBroadcastIdentifier = 1001;
+        intent.putExtra(BROADCAST_IDENTIFIER_KEY, testBroadcastIdentifier);
+        baseVideoViewController = mock(BaseVideoViewController.class);
+    }
+
+    @Test
+    public void onCreate_withVastExtraKey_shouldUseVastVideoViewController() throws Exception {
+        initializeSubjectForVast();
+
+        assertThat(subject.getBaseVideoViewController()).isInstanceOf(VastVideoViewController.class);
+    }
+
+    @Test
+    public void onCreate_withMraidExtraKey_shouldUseMraidVideoViewController() throws Exception {
+        initializeSubjectForMraid();
+
+        assertThat(subject.getBaseVideoViewController()).isInstanceOf(MraidVideoViewController.class);
+    }
+
+    @Ignore("pending: this is currently impossible to write")
+    @Test
+    public void onCreate_shouldForwardOnCreateToViewController() throws Exception {
+        initializeSubjectWithMockViewController();
+
+    }
+
+    @Test
+    public void onPause_shouldForwardOnPauseToViewController() throws Exception {
+        initializeSubjectWithMockViewController();
+
+        subject.onPause();
+
+        verify(baseVideoViewController).onPause();
+    }
+
+    @Test
+    public void onResume_shouldForwardOnResumeToViewController() throws Exception {
+        initializeSubjectWithMockViewController();
+
+        subject.onResume();
+
+        verify(baseVideoViewController).onResume();
+    }
+
+    @Test
+    public void onDestroy_shouldForwardOnDestroyToViewController() throws Exception {
+        initializeSubjectWithMockViewController();
+
+        subject.onDestroy();
+
+        verify(baseVideoViewController).onDestroy();
+    }
+
+    @Test
+    public void onActivityResult_shouldForwardOnActivityResultToViewController() throws Exception {
+        initializeSubjectWithMockViewController();
+
+        int expectedRequestCode = -100;
+        int expectedResultCode = 200;
+        Intent expectedData = new Intent("arbitrary_data");
+        subject.onActivityResult(expectedRequestCode, expectedResultCode, expectedData);
+
+        verify(baseVideoViewController).onActivityResult(
+                eq(expectedRequestCode),
+                eq(expectedResultCode),
+                eq(expectedData)
+        );
+    }
+
+    @Test
+    public void onSetContentView_shouldActuallySetContentView() throws Exception {
+        initializeSubjectWithMockViewController();
+        final View expectedView = new ImageView(context);
+
+        subject.onSetContentView(expectedView);
+
+        assertThat(shadowOf(subject).getContentView()).isEqualTo(expectedView);
+    }
+
+    @Test
+    public void onSetRequestedOrientation_shouldActuallySetRequestedOrientation() throws Exception {
+        initializeSubjectWithMockViewController();
+
+        subject.onSetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR);
+
+        assertThat(subject.getRequestedOrientation()).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_SENSOR);
+    }
+
+    @Test
+    public void onFinish_shouldActuallyCallFinish() throws Exception {
+        initializeSubjectWithMockViewController();
+
+        subject.onFinish();
+
+        assertThat(subject.isFinishing());
+    }
+
+    @Test
+    public void onStartActivityForResult_shouldStartAnActivityWithRelevantRequestCodeAndExtras() throws Exception {
+        initializeSubjectWithMockViewController();
+
+        final Bundle expectedExtras = new Bundle();
+        expectedExtras.putString("hello", "goodbye");
+
+        subject.onStartActivityForResult(MoPubBrowser.class, 100, expectedExtras);
+
+        final ShadowActivity.IntentForResult intentForResult = shadowOf(subject).getNextStartedActivityForResult();
+
+        assertThat(intentForResult.intent.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
+        assertThat(intentForResult.intent.getExtras()).isEqualTo(expectedExtras);
+        assertThat(intentForResult.requestCode).isEqualTo(100);
+    }
+
+    @Test
+    public void onStartActivityForResult_withNullClass_shouldNotStartAnActivity() throws Exception {
+        initializeSubjectWithMockViewController();
+
+        subject.onStartActivityForResult(null, 100, new Bundle());
+
+        final ShadowActivity.IntentForResult intentForResult = shadowOf(subject).getNextStartedActivityForResult();
+        assertThat(intentForResult).isNull();
+    }
+
+    private void initializeSubjectForMraid() {
+        intent.putExtra(BaseVideoPlayerActivity.VIDEO_CLASS_EXTRAS_KEY, "mraid");
+
+        subject = Robolectric.buildActivity(MraidVideoPlayerActivity.class)
+                .withIntent(intent)
+                .create()
+                .get();
+    }
+
+    private void initializeSubjectForVast() {
+        intent.putExtra(BaseVideoPlayerActivity.VIDEO_CLASS_EXTRAS_KEY, "vast");
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("video_path");
+        intent.putExtra(VastVideoViewController.VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        subject = Robolectric.buildActivity(MraidVideoPlayerActivity.class)
+                .withIntent(intent)
+                .create()
+                .get();
+    }
+
+    private void initializeSubjectWithMockViewController() {
+        initializeSubjectForMraid();
+
+        subject.setBaseVideoViewController(baseVideoViewController);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/RepeatingHandlerRunnableTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/RepeatingHandlerRunnableTest.java
new file mode 100644
index 00000000..3c51f6f7
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/RepeatingHandlerRunnableTest.java
@@ -0,0 +1,88 @@
+package com.mopub.mobileads;
+
+import android.os.Handler;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyZeroInteractions;
+
+@RunWith(SdkTestRunner.class)
+public class RepeatingHandlerRunnableTest {
+
+    @Mock Handler mockHandler;
+    RepeatingHandlerRunnable subject;
+
+    @Before
+    public void setup() {
+      subject = new NoopRepeatingHandlerRunnable(mockHandler);
+    }
+
+    @Test
+    public void startTracking_whenRunning_shouldScheduleSelf() {
+        subject.startRepeating(100);
+        reset(mockHandler);
+        subject.run();
+
+        verify(mockHandler).postDelayed(eq(subject), eq(100l));
+    }
+
+    @Test
+    public void start_whenRunning_shouldNotScheduleAndRunShouldScheduleWithNewInterval() {
+        subject.startRepeating(100l);
+        reset(mockHandler);
+
+        subject.startRepeating(200l);
+
+        verifyZeroInteractions(mockHandler);
+
+        subject.run();
+
+        verify(mockHandler).postDelayed(eq(subject), eq(200l));
+    }
+
+    @Test
+    public void run_whenNotRunning_shouldNotSchedule() {
+        subject.stop();
+        reset(mockHandler);
+
+        subject.run();
+
+        verifyZeroInteractions(mockHandler);
+    }
+
+    @Test
+    public void stopTracking_whenRunning_shouldPreventNextScheduling() {
+        subject.startRepeating(100l);
+        verify(mockHandler).post(eq(subject));
+
+        subject.run();
+        verify(mockHandler).postDelayed(eq(subject), eq(100l));
+
+        reset(mockHandler);
+        subject.stop();
+
+        subject.run();
+        verifyZeroInteractions(mockHandler);
+    }
+
+    private static class NoopRepeatingHandlerRunnable extends RepeatingHandlerRunnable {
+
+        NoopRepeatingHandlerRunnable(@NonNull final Handler handler) {
+            super(handler);
+        }
+
+        @Override
+        public void doWork() {
+            // pass
+        }
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/ToolbarWidgetTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/ToolbarWidgetTest.java
index 91edb817..bee3c2d1 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/ToolbarWidgetTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/ToolbarWidgetTest.java
@@ -1,121 +1,118 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.graphics.drawable.BitmapDrawable;
-import android.view.View;
-import android.widget.ImageView;
-
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.mobileads.resource.CloseButtonDrawable;
-import com.mopub.network.MaxWidthImageLoader;
-import com.mopub.network.MoPubRequestQueue;
-import com.mopub.network.Networking;
-import com.mopub.volley.VolleyError;
-import com.mopub.volley.toolbox.ImageLoader;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Captor;
-import org.mockito.Mock;
-import org.robolectric.Robolectric;
-import org.robolectric.annotation.Config;
-
-import static android.view.Gravity.CENTER_VERTICAL;
-import static android.view.Gravity.RIGHT;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.eq;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-@Config(manifest = Config.NONE)
-@RunWith(SdkTestRunner.class)
-
-public class ToolbarWidgetTest {
-    private Context context;
-    private ToolbarWidget subject;
-
-    private static final String ICON_IMAGE_URL = "iconimageurl";
-
-    @Mock
-    MoPubRequestQueue mockRequestQueue;
-    @Mock
-    private MaxWidthImageLoader mockImageLoader;
-    @Mock
-    private ImageLoader.ImageContainer mockImageContainer;
-    @Mock
-    private Bitmap mockBitmap;
-    @Captor
-    private ArgumentCaptor<ImageLoader.ImageListener> imageCaptor;
-
-    @Before
-    public void setUp() throws Exception {
-        Networking.setRequestQueueForTesting(mockRequestQueue);
-        Networking.setImageLoaderForTesting(mockImageLoader);
-        context = Robolectric.buildActivity(Activity.class).create().get();
-    }
-
-    private void initializeSubject() {
-        subject = new ToolbarWidget.Builder(context)
-                .weight(1f)
-                .widgetGravity(CENTER_VERTICAL | RIGHT)
-                .defaultText("Close")
-                .drawable(new CloseButtonDrawable())
-                .visibility(View.GONE)
-                .build();
-    }
-
-    @Test
-    public void updateImage_imageListenerOnResponse_shouldUseImageBitmap() throws Exception {
-        initializeSubject();
-
-        when(mockImageContainer.getBitmap()).thenReturn(mockBitmap);
-
-        subject.updateImage(ICON_IMAGE_URL);
-
-        verify(mockImageLoader).get(eq(ICON_IMAGE_URL), imageCaptor.capture());
-        ImageLoader.ImageListener listener = imageCaptor.getValue();
-        listener.onResponse(mockImageContainer, true);
-        assertThat(((BitmapDrawable) subject.getImageViewDrawable()).getBitmap()).isEqualTo(mockBitmap);
-    }
-
-    @Test
-    public void updateImage_imageListenerOnResponseWhenReturnedBitMapIsNull_shouldUseDefaultCloseButtonDrawable() throws Exception {
-        initializeSubject();
-
-        final ImageView imageViewSpy = spy(subject.getImageView());
-        subject.setImageView(imageViewSpy);
-
-        when(mockImageContainer.getBitmap()).thenReturn(null);
-
-        subject.updateImage(ICON_IMAGE_URL);
-
-        verify(mockImageLoader).get(eq(ICON_IMAGE_URL), imageCaptor.capture());
-        ImageLoader.ImageListener listener = imageCaptor.getValue();
-        listener.onResponse(mockImageContainer, true);
-        verify(imageViewSpy, never()).setImageBitmap(any(Bitmap.class));
-        assertThat(subject.getImageViewDrawable()).isInstanceOf(CloseButtonDrawable.class);
-    }
-
-    @Test
-    public void updateImage_imageListenerOnErrorResponse_shouldUseDefaultCloseButtonDrawable() throws Exception {
-        initializeSubject();
-
-        final ImageView imageViewSpy = spy(subject.getImageView());
-        subject.setImageView(imageViewSpy);
-
-        subject.updateImage(ICON_IMAGE_URL);
-
-        verify(mockImageLoader).get(eq(ICON_IMAGE_URL), imageCaptor.capture());
-        ImageLoader.ImageListener listener = imageCaptor.getValue();
-        listener.onErrorResponse(new VolleyError());
-        verify(imageViewSpy, never()).setImageBitmap(any(Bitmap.class));
-        assertThat(subject.getImageViewDrawable()).isInstanceOf(CloseButtonDrawable.class);
-    }
-}
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.view.View;
+import android.widget.ImageView;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.resource.CloseButtonDrawable;
+import com.mopub.network.MaxWidthImageLoader;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.volley.VolleyError;
+import com.mopub.volley.toolbox.ImageLoader;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Captor;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+
+import static android.view.Gravity.CENTER_VERTICAL;
+import static android.view.Gravity.RIGHT;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class ToolbarWidgetTest {
+    private Context context;
+    private ToolbarWidget subject;
+
+    private static final String ICON_IMAGE_URL = "iconimageurl";
+
+    @Mock
+    MoPubRequestQueue mockRequestQueue;
+    @Mock
+    private MaxWidthImageLoader mockImageLoader;
+    @Mock
+    private ImageLoader.ImageContainer mockImageContainer;
+    @Mock
+    private Bitmap mockBitmap;
+    @Captor
+    private ArgumentCaptor<ImageLoader.ImageListener> imageCaptor;
+
+    @Before
+    public void setUp() throws Exception {
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+        Networking.setImageLoaderForTesting(mockImageLoader);
+        context = Robolectric.buildActivity(Activity.class).create().get();
+    }
+
+    private void initializeSubject() {
+        subject = new ToolbarWidget.Builder(context)
+                .weight(1f)
+                .widgetGravity(CENTER_VERTICAL | RIGHT)
+                .defaultText("Close")
+                .drawable(new CloseButtonDrawable())
+                .visibility(View.GONE)
+                .build();
+    }
+
+    @Test
+    public void updateImage_imageListenerOnResponse_shouldUseImageBitmap() throws Exception {
+        initializeSubject();
+
+        when(mockImageContainer.getBitmap()).thenReturn(mockBitmap);
+
+        subject.updateImage(ICON_IMAGE_URL);
+
+        verify(mockImageLoader).get(eq(ICON_IMAGE_URL), imageCaptor.capture());
+        ImageLoader.ImageListener listener = imageCaptor.getValue();
+        listener.onResponse(mockImageContainer, true);
+        assertThat(((BitmapDrawable) subject.getImageViewDrawable()).getBitmap()).isEqualTo(mockBitmap);
+    }
+
+    @Test
+    public void updateImage_imageListenerOnResponseWhenReturnedBitMapIsNull_shouldUseDefaultCloseButtonDrawable() throws Exception {
+        initializeSubject();
+
+        final ImageView imageViewSpy = spy(subject.getImageView());
+        subject.setImageView(imageViewSpy);
+
+        when(mockImageContainer.getBitmap()).thenReturn(null);
+
+        subject.updateImage(ICON_IMAGE_URL);
+
+        verify(mockImageLoader).get(eq(ICON_IMAGE_URL), imageCaptor.capture());
+        ImageLoader.ImageListener listener = imageCaptor.getValue();
+        listener.onResponse(mockImageContainer, true);
+        verify(imageViewSpy, never()).setImageBitmap(any(Bitmap.class));
+        assertThat(subject.getImageViewDrawable()).isInstanceOf(CloseButtonDrawable.class);
+    }
+
+    @Test
+    public void updateImage_imageListenerOnErrorResponse_shouldUseDefaultCloseButtonDrawable() throws Exception {
+        initializeSubject();
+
+        final ImageView imageViewSpy = spy(subject.getImageView());
+        subject.setImageView(imageViewSpy);
+
+        subject.updateImage(ICON_IMAGE_URL);
+
+        verify(mockImageLoader).get(eq(ICON_IMAGE_URL), imageCaptor.capture());
+        ImageLoader.ImageListener listener = imageCaptor.getValue();
+        listener.onErrorResponse(new VolleyError());
+        verify(imageViewSpy, never()).setImageBitmap(any(Bitmap.class));
+        assertThat(subject.getImageViewDrawable()).isInstanceOf(CloseButtonDrawable.class);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoToolbarTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoToolbarTest.java
index 3a28a824..79bd874c 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoToolbarTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoToolbarTest.java
@@ -1,210 +1,211 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.content.Context;
-import android.graphics.drawable.Drawable;
-import android.view.View;
-import android.widget.TextView;
-
-import com.mopub.mobileads.resource.TextDrawable;
-import com.mopub.common.test.support.SdkTestRunner;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verify;
-import static org.robolectric.Robolectric.shadowOf;
-
-@RunWith(SdkTestRunner.class)
-public class VastVideoToolbarTest {
-    private Context context;
-    private VastVideoToolbar subject;
-    private View.OnTouchListener onTouchListener;
-
-    @Before
-    public void setUp() throws Exception {
-        context = new Activity();
-        subject = new VastVideoToolbar(context);
-
-        onTouchListener = mock(View.OnTouchListener.class);
-    }
-
-    @Test
-    public void constructor_shouldSetOnTouchListenerThatConsumesAllTouchEvents() throws Exception {
-        final View.OnTouchListener onTouchListener = shadowOf(subject).getOnTouchListener();
-
-        assertThat(onTouchListener).isNotNull();
-        assertThat(onTouchListener.onTouch(null, null)).isTrue();
-    }
-
-    @Test
-    public void constructor_shouldAddWidgetsToToolbar() throws Exception {
-        assertThat(subject.getChildCount()).isEqualTo(4);
-
-        assertThat(subject.getDurationWidget().getParent()).isEqualTo(subject);
-        assertThat(subject.getLearnMoreWidget().getParent()).isEqualTo(subject);
-        assertThat(subject.getCountdownWidget().getParent()).isEqualTo(subject);
-        assertThat(subject.getCloseButtonWidget().getParent()).isEqualTo(subject);
-    }
-
-    @Test
-    public void constructor_shouldOnlyStartWithDurationWidgetsVisible() throws Exception {
-        assertThat(subject.getDurationWidget().getVisibility()).isEqualTo(View.VISIBLE);
-        assertThat(subject.getLearnMoreWidget().getVisibility()).isEqualTo(View.INVISIBLE);
-        assertThat(subject.getCountdownWidget().getVisibility()).isEqualTo(View.INVISIBLE);
-        assertThat(subject.getCloseButtonWidget().getVisibility()).isEqualTo(View.GONE);
-    }
-
-    @Test
-    public void makeInteractable_shouldHideCountdownWidgetAndShowLearnMoreAndCloseButtonWidgets() throws Exception {
-        subject.makeInteractable();
-
-        assertThat(subject.getDurationWidget().getVisibility()).isEqualTo(View.VISIBLE);
-        assertThat(subject.getLearnMoreWidget().getVisibility()).isEqualTo(View.VISIBLE);
-        assertThat(subject.getCountdownWidget().getVisibility()).isEqualTo(View.GONE);
-        assertThat(subject.getCloseButtonWidget().getVisibility()).isEqualTo(View.VISIBLE);
-    }
-
-    @Test
-    public void setCloseButtonOnTouchListener_shouldPropagateToCloseButtonWidget() throws Exception {
-        subject.setCloseButtonOnTouchListener(onTouchListener);
-
-        assertThat(shadowOf(subject.getCloseButtonWidget()).getOnTouchListener()).isEqualTo(onTouchListener);
-    }
-
-    @Test
-    public void setLearnButtonOnTouchListener_shouldPropagateToLearnButtonWidget() throws Exception {
-        subject.setLearnMoreButtonOnTouchListener(onTouchListener);
-
-        assertThat(shadowOf(subject.getLearnMoreWidget()).getOnTouchListener()).isEqualTo(onTouchListener);
-    }
-
-    @Test
-    public void convertMillisecondsToSecondsRoundedUp_shouldReturnLongMillisecondsAsRoundedUpLongSeconds() throws Exception {
-        assertThat(subject.convertMillisecondsToSecondsRoundedUp(0)).isEqualTo(0);
-
-        assertThat(subject.convertMillisecondsToSecondsRoundedUp(1)).isEqualTo(1);
-        assertThat(subject.convertMillisecondsToSecondsRoundedUp(999)).isEqualTo(1);
-        assertThat(subject.convertMillisecondsToSecondsRoundedUp(1000)).isEqualTo(1);
-
-        assertThat(subject.convertMillisecondsToSecondsRoundedUp(1001)).isEqualTo(2);
-        assertThat(subject.convertMillisecondsToSecondsRoundedUp(100000)).isEqualTo(100);
-    }
-
-    @Test
-    public void formatTime_shouldReturnLongMillisecondsAsFormattedString() {
-        assertThat(subject.formatTime(-8999)).isEqualTo("-8 seconds");
-        assertThat(subject.formatTime(-9000)).isEqualTo("-9 seconds");
-        assertThat(subject.formatTime(-9001)).isEqualTo("-9 seconds");
-        assertThat(subject.formatTime(0)).isEqualTo("0 seconds");
-
-        assertThat(subject.formatTime(1)).isEqualTo("1 second");
-        assertThat(subject.formatTime(1000)).isEqualTo("1 second");
-        assertThat(subject.formatTime(1005)).isEqualTo("2 seconds");
-
-        assertThat(subject.formatTime(59999)).isEqualTo("60 seconds");
-        assertThat(subject.formatTime(60000)).isEqualTo("60 seconds");
-        assertThat(subject.formatTime(60001)).isEqualTo("61 seconds");
-        assertThat(subject.formatTime(853437)).isEqualTo("854 seconds");
-
-        assertThat(subject.formatTime(3599999)).isEqualTo("3600 seconds");
-        assertThat(subject.formatTime(3600000)).isEqualTo("3600 seconds");
-        assertThat(subject.formatTime(3600001)).isEqualTo("3601 seconds");
-        assertThat(subject.formatTime(3660001)).isEqualTo("3661 seconds");
-        assertThat(subject.formatTime(65784693)).isEqualTo("65785 seconds");
-    }
-
-    @Test
-    public void updateCountdownWidget_shouldUpdateTextDrawablesDisplayNumber() throws Exception {
-        final TextDrawable countdownImageSpy = spy((TextDrawable) subject.getCountdownWidget().getImageViewDrawable());
-        subject.getCountdownWidget().setImageViewDrawable((Drawable) countdownImageSpy);
-
-        subject.updateCountdownWidget(1002);
-
-        verify(countdownImageSpy).updateText("2");
-    }
-
-    @Test
-    public void updateCountdownWidget_shouldHideCloseButtonAndShowCountdown() throws Exception {
-        subject.getCloseButtonWidget().setVisibility(View.INVISIBLE);
-        subject.getCountdownWidget().setVisibility(View.INVISIBLE);
-
-        subject.updateCountdownWidget(1);
-
-        assertThat(subject.getCloseButtonWidget().getVisibility()).isEqualTo(View.GONE);
-        assertThat(subject.getCountdownWidget().getVisibility()).isEqualTo(View.VISIBLE);
-    }
-
-    @Test
-    public void updateCountdownWidget_whenRemainingTimeIsNegative_shouldNotModifyWidgetVisibility() throws Exception {
-        subject.getCloseButtonWidget().setVisibility(View.INVISIBLE);
-        subject.getCountdownWidget().setVisibility(View.INVISIBLE);
-
-        subject.updateCountdownWidget(-1);
-
-        assertThat(subject.getCloseButtonWidget().getVisibility()).isEqualTo(View.INVISIBLE);
-        assertThat(subject.getCountdownWidget().getVisibility()).isEqualTo(View.INVISIBLE);
-    }
-
-    @Test
-    public void updateDurationWidget_shouldShowWhenVideoEnds() throws Exception {
-        final TextView durationWidgetTextView = getDurationWidgetTextView();
-
-        assertThat(durationWidgetTextView.getText()).isEqualTo("");
-
-        subject.updateDurationWidget(100000);
-
-        assertThat(durationWidgetTextView.getText()).isEqualTo("Ends in 100 seconds");
-
-        subject.updateDurationWidget(99000);
-
-        assertThat(durationWidgetTextView.getText()).isEqualTo("Ends in 99 seconds");
-    }
-
-    @Test
-    public void updateDurationWidget_whenBelowThresholdForHidingVideoDuration_shouldShowThanksForWatching() throws Exception {
-        final TextView durationWidgetTextView = getDurationWidgetTextView();
-
-        assertThat(durationWidgetTextView.getText()).isEqualTo("");
-
-        subject.updateDurationWidget(50000);
-
-        assertThat(durationWidgetTextView.getText()).isEqualTo("Ends in 50 seconds");
-
-        // 200ms of remaining video is the cut off for switching to "Thanks for watching"
-        subject.updateDurationWidget(200);
-
-        assertThat(durationWidgetTextView.getText()).isEqualTo("Ends in 1 second");
-
-        subject.updateDurationWidget(199);
-
-        assertThat(durationWidgetTextView.getText()).isEqualTo("Thanks for watching");
-    }
-
-    @Test
-    public void updateDurationWidget_whenRemainingTimeIsNegative_shouldDoNothing() throws Exception {
-        final TextView durationWidgetTextView = getDurationWidgetTextView();
-
-        assertThat(durationWidgetTextView.getText()).isEqualTo("");
-
-        subject.updateDurationWidget(-1);
-
-        assertThat(durationWidgetTextView.getText()).isEqualTo("");
-    }
-
-    private TextView getDurationWidgetTextView() {
-        final ToolbarWidget durationWidget = subject.getDurationWidget();
-        final int childCount = durationWidget.getChildCount();
-        for (int i = 0; i < childCount; i++) {
-            final View child = durationWidget.getChildAt(i);
-            if (child instanceof TextView) {
-                return (TextView) child;
-            }
-        }
-        return null;
-    }
-}
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.view.View;
+import android.widget.TextView;
+
+import com.mopub.mobileads.resource.TextDrawable;
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.robolectric.Robolectric.shadowOf;
+
+@RunWith(SdkTestRunner.class)
+public class VastVideoToolbarTest {
+    private Context context;
+    private VastVideoToolbar subject;
+    private View.OnTouchListener onTouchListener;
+
+    @Before
+    public void setUp() throws Exception {
+        context = Robolectric.buildActivity(Activity.class).create().get();
+        subject = new VastVideoToolbar(context);
+
+        onTouchListener = mock(View.OnTouchListener.class);
+    }
+
+    @Test
+    public void constructor_shouldSetOnTouchListenerThatConsumesAllTouchEvents() throws Exception {
+        final View.OnTouchListener onTouchListener = shadowOf(subject).getOnTouchListener();
+
+        assertThat(onTouchListener).isNotNull();
+        assertThat(onTouchListener.onTouch(null, null)).isTrue();
+    }
+
+    @Test
+    public void constructor_shouldAddWidgetsToToolbar() throws Exception {
+        assertThat(subject.getChildCount()).isEqualTo(4);
+
+        assertThat(subject.getDurationWidget().getParent()).isEqualTo(subject);
+        assertThat(subject.getLearnMoreWidget().getParent()).isEqualTo(subject);
+        assertThat(subject.getCountdownWidget().getParent()).isEqualTo(subject);
+        assertThat(subject.getCloseButtonWidget().getParent()).isEqualTo(subject);
+    }
+
+    @Test
+    public void constructor_shouldOnlyStartWithDurationWidgetsVisible() throws Exception {
+        assertThat(subject.getDurationWidget().getVisibility()).isEqualTo(View.VISIBLE);
+        assertThat(subject.getLearnMoreWidget().getVisibility()).isEqualTo(View.INVISIBLE);
+        assertThat(subject.getCountdownWidget().getVisibility()).isEqualTo(View.INVISIBLE);
+        assertThat(subject.getCloseButtonWidget().getVisibility()).isEqualTo(View.GONE);
+    }
+
+    @Test
+    public void makeInteractable_shouldHideCountdownWidgetAndShowLearnMoreAndCloseButtonWidgets() throws Exception {
+        subject.makeInteractable();
+
+        assertThat(subject.getDurationWidget().getVisibility()).isEqualTo(View.VISIBLE);
+        assertThat(subject.getLearnMoreWidget().getVisibility()).isEqualTo(View.VISIBLE);
+        assertThat(subject.getCountdownWidget().getVisibility()).isEqualTo(View.GONE);
+        assertThat(subject.getCloseButtonWidget().getVisibility()).isEqualTo(View.VISIBLE);
+    }
+
+    @Test
+    public void setCloseButtonOnTouchListener_shouldPropagateToCloseButtonWidget() throws Exception {
+        subject.setCloseButtonOnTouchListener(onTouchListener);
+
+        assertThat(shadowOf(subject.getCloseButtonWidget()).getOnTouchListener()).isEqualTo(onTouchListener);
+    }
+
+    @Test
+    public void setLearnButtonOnTouchListener_shouldPropagateToLearnButtonWidget() throws Exception {
+        subject.setLearnMoreButtonOnTouchListener(onTouchListener);
+
+        assertThat(shadowOf(subject.getLearnMoreWidget()).getOnTouchListener()).isEqualTo(onTouchListener);
+    }
+
+    @Test
+    public void convertMillisecondsToSecondsRoundedUp_shouldReturnLongMillisecondsAsRoundedUpLongSeconds() throws Exception {
+        assertThat(subject.convertMillisecondsToSecondsRoundedUp(0)).isEqualTo(0);
+
+        assertThat(subject.convertMillisecondsToSecondsRoundedUp(1)).isEqualTo(1);
+        assertThat(subject.convertMillisecondsToSecondsRoundedUp(999)).isEqualTo(1);
+        assertThat(subject.convertMillisecondsToSecondsRoundedUp(1000)).isEqualTo(1);
+
+        assertThat(subject.convertMillisecondsToSecondsRoundedUp(1001)).isEqualTo(2);
+        assertThat(subject.convertMillisecondsToSecondsRoundedUp(100000)).isEqualTo(100);
+    }
+
+    @Test
+    public void formatTime_shouldReturnLongMillisecondsAsFormattedString() {
+        assertThat(subject.formatTime(-8999)).isEqualTo("-8 seconds");
+        assertThat(subject.formatTime(-9000)).isEqualTo("-9 seconds");
+        assertThat(subject.formatTime(-9001)).isEqualTo("-9 seconds");
+        assertThat(subject.formatTime(0)).isEqualTo("0 seconds");
+
+        assertThat(subject.formatTime(1)).isEqualTo("1 second");
+        assertThat(subject.formatTime(1000)).isEqualTo("1 second");
+        assertThat(subject.formatTime(1005)).isEqualTo("2 seconds");
+
+        assertThat(subject.formatTime(59999)).isEqualTo("60 seconds");
+        assertThat(subject.formatTime(60000)).isEqualTo("60 seconds");
+        assertThat(subject.formatTime(60001)).isEqualTo("61 seconds");
+        assertThat(subject.formatTime(853437)).isEqualTo("854 seconds");
+
+        assertThat(subject.formatTime(3599999)).isEqualTo("3600 seconds");
+        assertThat(subject.formatTime(3600000)).isEqualTo("3600 seconds");
+        assertThat(subject.formatTime(3600001)).isEqualTo("3601 seconds");
+        assertThat(subject.formatTime(3660001)).isEqualTo("3661 seconds");
+        assertThat(subject.formatTime(65784693)).isEqualTo("65785 seconds");
+    }
+
+    @Test
+    public void updateCountdownWidget_shouldUpdateTextDrawablesDisplayNumber() throws Exception {
+        final TextDrawable countdownImageSpy = spy((TextDrawable) subject.getCountdownWidget().getImageViewDrawable());
+        subject.getCountdownWidget().setImageViewDrawable((Drawable) countdownImageSpy);
+
+        subject.updateCountdownWidget(1002);
+
+        verify(countdownImageSpy).updateText("2");
+    }
+
+    @Test
+    public void updateCountdownWidget_shouldHideCloseButtonAndShowCountdown() throws Exception {
+        subject.getCloseButtonWidget().setVisibility(View.INVISIBLE);
+        subject.getCountdownWidget().setVisibility(View.INVISIBLE);
+
+        subject.updateCountdownWidget(1);
+
+        assertThat(subject.getCloseButtonWidget().getVisibility()).isEqualTo(View.GONE);
+        assertThat(subject.getCountdownWidget().getVisibility()).isEqualTo(View.VISIBLE);
+    }
+
+    @Test
+    public void updateCountdownWidget_whenRemainingTimeIsNegative_shouldNotModifyWidgetVisibility() throws Exception {
+        subject.getCloseButtonWidget().setVisibility(View.INVISIBLE);
+        subject.getCountdownWidget().setVisibility(View.INVISIBLE);
+
+        subject.updateCountdownWidget(-1);
+
+        assertThat(subject.getCloseButtonWidget().getVisibility()).isEqualTo(View.INVISIBLE);
+        assertThat(subject.getCountdownWidget().getVisibility()).isEqualTo(View.INVISIBLE);
+    }
+
+    @Test
+    public void updateDurationWidget_shouldShowWhenVideoEnds() throws Exception {
+        final TextView durationWidgetTextView = getDurationWidgetTextView();
+
+        assertThat(durationWidgetTextView.getText()).isEqualTo("");
+
+        subject.updateDurationWidget(100000);
+
+        assertThat(durationWidgetTextView.getText()).isEqualTo("Ends in 100 seconds");
+
+        subject.updateDurationWidget(99000);
+
+        assertThat(durationWidgetTextView.getText()).isEqualTo("Ends in 99 seconds");
+    }
+
+    @Test
+    public void updateDurationWidget_whenBelowThresholdForHidingVideoDuration_shouldShowThanksForWatching() throws Exception {
+        final TextView durationWidgetTextView = getDurationWidgetTextView();
+
+        assertThat(durationWidgetTextView.getText()).isEqualTo("");
+
+        subject.updateDurationWidget(50000);
+
+        assertThat(durationWidgetTextView.getText()).isEqualTo("Ends in 50 seconds");
+
+        // 200ms of remaining video is the cut off for switching to "Thanks for watching"
+        subject.updateDurationWidget(200);
+
+        assertThat(durationWidgetTextView.getText()).isEqualTo("Ends in 1 second");
+
+        subject.updateDurationWidget(199);
+
+        assertThat(durationWidgetTextView.getText()).isEqualTo("Thanks for watching");
+    }
+
+    @Test
+    public void updateDurationWidget_whenRemainingTimeIsNegative_shouldDoNothing() throws Exception {
+        final TextView durationWidgetTextView = getDurationWidgetTextView();
+
+        assertThat(durationWidgetTextView.getText()).isEqualTo("");
+
+        subject.updateDurationWidget(-1);
+
+        assertThat(durationWidgetTextView.getText()).isEqualTo("");
+    }
+
+    private TextView getDurationWidgetTextView() {
+        final ToolbarWidget durationWidget = subject.getDurationWidget();
+        final int childCount = durationWidget.getChildCount();
+        for (int i = 0; i < childCount; i++) {
+            final View child = durationWidget.getChildAt(i);
+            if (child instanceof TextView) {
+                return (TextView) child;
+            }
+        }
+        return null;
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewControllerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewControllerTest.java
index 980eef97..b36fcaf5 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewControllerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewControllerTest.java
@@ -1,1614 +1,1651 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.graphics.Color;
-import android.graphics.drawable.BitmapDrawable;
-import android.graphics.drawable.Drawable;
-import android.graphics.drawable.GradientDrawable;
-import android.graphics.drawable.LayerDrawable;
-import android.media.MediaPlayer;
-import android.os.Build.VERSION_CODES;
-import android.os.Bundle;
-import android.view.View;
-import android.view.ViewGroup;
-import android.webkit.WebView;
-import android.widget.ImageView;
-import android.widget.VideoView;
-
-import com.mopub.common.MoPubBrowser;
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.DeviceUtils.ForceOrientation;
-import com.mopub.common.util.Dips;
-import com.mopub.common.util.Drawables;
-import com.mopub.mobileads.resource.CloseButtonDrawable;
-import com.mopub.mobileads.test.support.GestureUtils;
-import com.mopub.mobileads.util.vast.VastCompanionAd;
-import com.mopub.mobileads.util.vast.VastVideoConfiguration;
-import com.mopub.network.MaxWidthImageLoader;
-import com.mopub.network.MoPubRequestQueue;
-import com.mopub.network.Networking;
-
-import org.apache.http.HttpRequest;
-import org.apache.maven.artifact.ant.shaded.ReflectionUtils;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Mock;
-import org.robolectric.Robolectric;
-import org.robolectric.annotation.Config;
-import org.robolectric.shadows.ShadowLocalBroadcastManager;
-import org.robolectric.shadows.ShadowVideoView;
-import org.robolectric.tester.org.apache.http.RequestMatcher;
-import org.robolectric.tester.org.apache.http.TestHttpResponse;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.Arrays;
-
-import static android.content.pm.ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
-import static android.content.pm.ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
-import static android.view.ViewGroup.LayoutParams.MATCH_PARENT;
-import static com.mopub.common.MoPubBrowser.DESTINATION_URL_KEY;
-import static com.mopub.common.VolleyRequestMatcher.isUrl;
-import static com.mopub.common.util.ResponseHeader.USER_AGENT;
-import static com.mopub.mobileads.BaseVideoViewController.BaseVideoViewControllerListener;
-import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_CLICK;
-import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
-import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_FAIL;
-import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
-import static com.mopub.mobileads.EventForwardingBroadcastReceiver.getHtmlInterstitialIntentFilter;
-import static com.mopub.mobileads.EventForwardingBroadcastReceiverTest.getIntentForActionAndIdentifier;
-import static com.mopub.mobileads.VastVideoViewController.DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON;
-import static com.mopub.mobileads.VastVideoViewController.MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON;
-import static com.mopub.mobileads.VastVideoViewController.VAST_VIDEO_CONFIGURATION;
-import static com.mopub.volley.toolbox.ImageLoader.ImageListener;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.argThat;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.stub;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.verifyZeroInteractions;
-import static org.robolectric.Robolectric.shadowOf;
-
-@Config(manifest = Config.NONE)
-@RunWith(SdkTestRunner.class)
-public class VastVideoViewControllerTest {
-    public static final int NETWORK_DELAY = 100;
-
-    private static final String COMPANION_IMAGE_URL = "companion_image_url";
-    private static final String COMPANION_CLICK_TRACKING_URL_1 = "companion_click_tracking_url_1";
-    private static final String COMPANION_CLICK_TRACKING_URL_2 = "companion_click_tracking_url_2";
-    private static final String COMPANION_CLICK_DESTINATION_URL = "http://companion_click_destination_url";
-    private static final String CLICKTHROUGH_URL = "http://clickthrough_url";
-
-    private Context context;
-    private Bundle bundle;
-    private long testBroadcastIdentifier;
-    private VastVideoViewController subject;
-    private BaseVideoViewControllerListener baseVideoViewControllerListener;
-    private EventForwardingBroadcastReceiver broadcastReceiver;
-    private int expectedBrowserRequestCode;
-    private String expectedUserAgent;
-
-    @Mock
-    MoPubRequestQueue mockRequestQueue;
-    @Mock
-    MaxWidthImageLoader mockImageLoader;
-    @Mock
-    private MediaPlayer mockMediaPlayer;
-
-    @Before
-    public void setUp() throws Exception {
-        Networking.setRequestQueueForTesting(mockRequestQueue);
-        Networking.setImageLoaderForTesting(mockImageLoader);
-        context = new Activity();
-        bundle = new Bundle();
-        testBroadcastIdentifier = 1111;
-        broadcastReceiver = mock(EventForwardingBroadcastReceiver.class);
-        baseVideoViewControllerListener = mock(BaseVideoViewControllerListener.class);
-
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setNetworkMediaFileUrl("video_url");
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addAbsoluteTrackers(Arrays.asList(new VastAbsoluteProgressTracker("start", 2000)));
-        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("first", 0.25f),
-                new VastFractionalProgressTracker("mid", 0.5f), new VastFractionalProgressTracker("third", 0.75f)));
-        vastVideoConfiguration.addCompleteTrackers(Arrays.asList("complete"));
-        vastVideoConfiguration.addCloseTrackers(Arrays.asList("close"));
-        vastVideoConfiguration.addSkipTrackers(Arrays.asList("skip"));
-        vastVideoConfiguration.addImpressionTrackers(Arrays.asList("imp"));
-        vastVideoConfiguration.setClickThroughUrl(CLICKTHROUGH_URL);
-        vastVideoConfiguration.addClickTrackers(Arrays.asList("click_1", "click_2"));
-
-        VastCompanionAd vastCompanionAd = new VastCompanionAd(
-                300,
-                250,
-                COMPANION_IMAGE_URL,
-                COMPANION_CLICK_DESTINATION_URL,
-                new ArrayList<String>(Arrays.asList(COMPANION_CLICK_TRACKING_URL_1, COMPANION_CLICK_TRACKING_URL_2))
-        );
-        vastVideoConfiguration.setVastCompanionAd(vastCompanionAd);
-
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        expectedBrowserRequestCode = 1;
-
-        Robolectric.getUiThreadScheduler().pause();
-        Robolectric.getBackgroundScheduler().pause();
-        Robolectric.clearPendingHttpResponses();
-
-        // Used to give responses to Vast Download Tasks.
-        Robolectric.addHttpResponseRule(new RequestMatcher() {
-            @Override
-            public boolean matches(HttpRequest request) {
-                return true;
-            }
-        }, new TestHttpResponse(200, "body"));
-
-        ShadowLocalBroadcastManager.getInstance(context).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
-
-        expectedUserAgent = new WebView(context).getSettings().getUserAgentString();
-    }
-
-    @After
-    public void tearDown() throws Exception {
-        Robolectric.getUiThreadScheduler().reset();
-        Robolectric.getBackgroundScheduler().reset();
-
-        ShadowLocalBroadcastManager.getInstance(context).unregisterReceiver(broadcastReceiver);
-    }
-
-    @Test
-    public void constructor_shouldAddVastVideoToolbarToLayout() throws Exception {
-        initializeSubject();
-
-        VastVideoToolbar vastVideoToolbar = getVastVideoToolbar();
-        final ViewGroup.LayoutParams layoutParams = vastVideoToolbar.getLayoutParams();
-
-        assertThat(vastVideoToolbar.getParent()).isEqualTo(subject.getLayout());
-        assertThat(vastVideoToolbar.getVisibility()).isEqualTo(View.VISIBLE);
-
-        assertThat(layoutParams.width).isEqualTo(MATCH_PARENT);
-        assertThat(layoutParams.height).isEqualTo(Dips.dipsToIntPixels(44, context));
-    }
-
-    @Test
-    public void constructor_shouldSetVideoListenersAndVideoPath() throws Exception {
-        initializeSubject();
-        ShadowVideoView videoView = shadowOf(subject.getVideoView());
-
-        assertThat(videoView.getOnCompletionListener()).isNotNull();
-        assertThat(videoView.getOnErrorListener()).isNotNull();
-        assertThat(videoView.getOnTouchListener()).isNotNull();
-        assertThat(videoView.getOnPreparedListener()).isNotNull();
-
-        assertThat(videoView.getVideoPath()).isEqualTo("disk_video_path");
-        assertThat(subject.getVideoView().hasFocus()).isTrue();
-    }
-
-    @Test
-    public void constructor_shouldNotChangeCloseButtonDelay() throws Exception {
-        initializeSubject();
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
-    }
-
-    @Test
-    public void constructor_shouldAddThatchedBackgroundWithGradientToLayout() throws Exception {
-        initializeSubject();
-        ViewGroup viewGroup = subject.getLayout();
-        LayerDrawable layerDrawable = (LayerDrawable) viewGroup.getBackground();
-        assertThat(layerDrawable.getDrawable(0)).isEqualTo(Drawables.THATCHED_BACKGROUND.createDrawable(
-                context));
-        assertThat(layerDrawable.getDrawable(1)).isEqualTo(
-                new GradientDrawable(
-                        GradientDrawable.Orientation.TOP_BOTTOM,
-                        new int[]{Color.argb(0, 0, 0, 0), Color.argb(255, 0, 0, 0)})
-        );
-    }
-
-    @Test
-    public void constructor_withMissingVastVideoConfiguration_shouldThrowIllegalStateException() throws Exception {
-        bundle.clear();
-        try {
-            initializeSubject();
-            fail("VastVideoViewController didn't throw IllegalStateException");
-        } catch (IllegalStateException e) {
-            // pass
-        }
-    }
-
-    @Test
-    public void constructor_withNullVastVideoConfigurationDiskMediaFileUrl_shouldThrowIllegalStateException() throws Exception {
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, new VastVideoConfiguration());
-        try {
-            initializeSubject();
-            fail("VastVideoViewController didn't throw IllegalStateException");
-        } catch (IllegalStateException e) {
-            // pass
-        }
-    }
-
-    @Test
-    public void constructor_whenCustomCtaTextNotSpecified_shouldUseDefaultCtaText() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        initializeSubject();
-
-        assertThat(getVastVideoToolbar().getLearnMoreWidget().getTextViewText()).isEqualTo("Learn More");
-    }
-
-    @Test
-    public void constructor_whenCustomCtaTextSpecified_shouldUseCustomCtaText() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.setCustomCtaText("custom CTA text");
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        initializeSubject();
-
-        assertThat(getVastVideoToolbar().getLearnMoreWidget().getTextViewText()).isEqualTo("custom CTA text");
-    }
-
-    @Test
-    public void constructor_whenCustomSkipTextNotSpecified_shouldUseDefaultSkipText() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        initializeSubject();
-
-        assertThat(getVastVideoToolbar().getCloseButtonWidget().getTextViewText()).isEqualTo("Close");
-    }
-
-    @Test
-    public void constructor_whenCustomSkipTextSpecified_shouldUseCustomSkipText() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.setCustomSkipText("custom skip text");
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        initializeSubject();
-
-        assertThat(getVastVideoToolbar().getCloseButtonWidget().getTextViewText()).isEqualTo("custom skip text");
-    }
-
-    @Test
-    public void constructor_whenCustomCloseIconNotSpecified_shouldUseDefaultCloseIcon() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        initializeSubject();
-
-        Drawable imageViewDrawable = getVastVideoToolbar().getCloseButtonWidget().getImageViewDrawable();
-
-        // Default close icon is an instance of CloseButtonDrawable
-        assertThat(imageViewDrawable).isInstanceOf(CloseButtonDrawable.class);
-    }
-
-    @Test
-    public void constructor_whenCustomCloseIconSpecified_shouldUseCustomCloseIcon() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.setCustomCloseIconUrl("http://ton.twitter.com/exchange-media/images/v4/star_icon_3x_1.png");
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        initializeSubject();
-
-        verify(mockImageLoader).get(eq("http://ton.twitter.com/exchange-media/images/v4/star_icon_3x_1.png"), any(ImageListener.class));
-    }
-
-    @Test
-    public void onCreate_withCompanionAd_shouldDownloadCompanionAd() throws Exception {
-        initializeSubject();
-
-        final ImageView imageView = subject.getCompanionAdImageView();
-        assertThat(imageView.getDrawable()).isNull();
-
-        subject.onCreate();
-        Robolectric.getBackgroundScheduler().unPause();
-        Robolectric.getUiThreadScheduler().unPause();
-        Thread.sleep(NETWORK_DELAY);
-
-        assertThat(shadowOf(((BitmapDrawable) imageView.getDrawable()).getBitmap()).getCreatedFromBytes()).isEqualTo("body".getBytes());
-    }
-
-    @Test
-    public void onCreate_shouldFireImpressionTracker() throws Exception {
-        initializeSubject();
-
-        subject.onCreate();
-        verify(mockRequestQueue).add(argThat(isUrl("imp")));
-    }
-
-    @Test
-    public void onCreate_shouldBroadcastInterstitialShow() throws Exception {
-        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_SHOW, testBroadcastIdentifier);
-
-        initializeSubject();
-
-        Robolectric.getUiThreadScheduler().unPause();
-        subject.onCreate();
-        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
-    }
-
-    @Test
-    public void onCreate_whenCustomForceOrientationNotSpecified_shouldForceLandscapeOrientation() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        initializeSubject();
-        subject.onCreate();
-
-        verify(baseVideoViewControllerListener).onSetRequestedOrientation(SCREEN_ORIENTATION_LANDSCAPE);
-    }
-
-    @Test
-    public void onCreate_whenCustomForceOrientationIsDeviceOrientation_shouldNotForceLandscapeOrientation() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.setCustomForceOrientation(ForceOrientation.DEVICE_ORIENTATION);
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        initializeSubject();
-        subject.onCreate();
-
-        verify(baseVideoViewControllerListener, never()).onSetRequestedOrientation(anyInt());
-    }
-
-    @Test
-    public void onCreate_whenCustomForceOrientationIsPortraitOrientation_shouldForcePortraitOrientation() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.setCustomForceOrientation(ForceOrientation.FORCE_PORTRAIT);
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        initializeSubject();
-        subject.onCreate();
-
-        verify(baseVideoViewControllerListener).onSetRequestedOrientation(SCREEN_ORIENTATION_PORTRAIT);
-    }
-
-    @Test
-    public void onCreate_whenCustomForceOrientationIsLandscapeOrientation_shouldForceLandscapeOrientation() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.setCustomForceOrientation(ForceOrientation.FORCE_LANDSCAPE);
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        initializeSubject();
-        subject.onCreate();
-
-        verify(baseVideoViewControllerListener).onSetRequestedOrientation(SCREEN_ORIENTATION_LANDSCAPE);
-    }
-
-    @Test
-    public void onComplete_withNullDownloadResponse_shouldNotSetCompanionAdImageBitmap() throws Exception {
-        initializeSubject();
-
-        final ImageView imageView = subject.getCompanionAdImageView();
-        assertThat(imageView.getDrawable()).isNull();
-
-        subject.onComplete("url", null);
-
-        assertThat(imageView.getDrawable()).isNull();
-    }
-
-    @Test
-    public void onClick_withCompanionAd_shouldFireCompanionAdClickTrackersAndStartMoPubBrowser() throws Exception {
-        initializeSubject();
-
-        final ImageView imageView = subject.getCompanionAdImageView();
-        assertThat(imageView.performClick()).isFalse();
-        subject.onCreate();
-
-        Robolectric.getBackgroundScheduler().unPause();
-        Robolectric.getUiThreadScheduler().unPause();
-        Thread.sleep(NETWORK_DELAY);
-
-        assertThat(imageView.performClick()).isTrue();
-
-        // This request is still made by the older http stack.
-        assertHttpRequestsMade(expectedUserAgent, COMPANION_IMAGE_URL);
-
-        verify(mockRequestQueue).add(argThat(isUrl(COMPANION_CLICK_TRACKING_URL_1)));
-        verify(mockRequestQueue).add(argThat(isUrl(COMPANION_CLICK_TRACKING_URL_2)));
-
-        ArgumentCaptor<Bundle> bundleCaptor = ArgumentCaptor.forClass(Bundle.class);
-        verify(baseVideoViewControllerListener).onStartActivityForResult(
-                eq(MoPubBrowser.class),
-                eq(expectedBrowserRequestCode),
-                bundleCaptor.capture()
-        );
-
-        assertThat(bundleCaptor.getValue().get(DESTINATION_URL_KEY)).isEqualTo(COMPANION_CLICK_DESTINATION_URL);
-    }
-
-    @Test
-    public void onDestroy_shouldBroadcastInterstitialDismiss() throws Exception {
-        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_DISMISS, testBroadcastIdentifier);
-
-        initializeSubject();
-
-        subject.onDestroy();
-        Robolectric.getUiThreadScheduler().unPause();
-
-        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
-    }
-
-    @Test
-    public void onActivityResult_shouldCallFinish() throws Exception {
-        final int expectedResultCode = Activity.RESULT_OK;
-
-        initializeSubject();
-
-        subject.onActivityResult(expectedBrowserRequestCode, expectedResultCode, null);
-
-        verify(baseVideoViewControllerListener).onFinish();
-    }
-
-    @Test
-    public void onActivityResult_withIncorrectRequestCode_shouldNotCallFinish() throws Exception {
-        final int incorrectRequestCode = 1000;
-        final int expectedResultCode = Activity.RESULT_OK;
-
-        initializeSubject();
-
-        subject.onActivityResult(incorrectRequestCode, expectedResultCode, null);
-
-        verify(baseVideoViewControllerListener, never()).onFinish();
-    }
-
-    @Test
-    public void onActivityResult_withIncorrectResultCode_shouldNotCallFinish() throws Exception {
-        final int incorrectResultCode = Activity.RESULT_CANCELED;
-
-        initializeSubject();
-
-        subject.onActivityResult(expectedBrowserRequestCode, incorrectResultCode, null);
-
-        verify(baseVideoViewControllerListener, never()).onFinish();
-    }
-
-    @Test
-    public void onTouch_withTouchUp_whenVideoLessThan16Seconds_andClickBeforeEnd_shouldDoNothing() throws Exception {
-        stub(mockMediaPlayer.getDuration()).toReturn(15999);
-        stub(mockMediaPlayer.getCurrentPosition()).toReturn(15990);
-
-        initializeSubject();
-        setMockMediaPlayer(mockMediaPlayer);
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        Robolectric.getUiThreadScheduler().unPause();
-
-        getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(0, 0));
-
-        Intent nextStartedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(nextStartedActivity).isNull();
-    }
-
-    @Test
-    public void onTouch_withTouchUp_whenVideoLessThan16Seconds_andClickAfterEnd_shouldStartMoPubBrowser() throws Exception {
-        stub(mockMediaPlayer.getDuration()).toReturn(15999);
-        stub(mockMediaPlayer.getCurrentPosition()).toReturn(15999);
-
-        initializeSubject();
-        subject.onResume();
-
-        setMockMediaPlayer(mockMediaPlayer);
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        Robolectric.getUiThreadScheduler().unPause();
-
-        getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(0, 0));
-
-        ArgumentCaptor<Bundle> bundleCaptor = ArgumentCaptor.forClass(Bundle.class);
-        verify(baseVideoViewControllerListener).onStartActivityForResult(
-                eq(MoPubBrowser.class),
-                eq(expectedBrowserRequestCode),
-                bundleCaptor.capture()
-        );
-
-        assertThat(bundleCaptor.getValue().get(DESTINATION_URL_KEY)).isEqualTo(CLICKTHROUGH_URL);
-    }
-
-    @Test
-    public void onTouch_withTouchUp_whenVideoLongerThan16Seconds_andClickBefore5Seconds_shouldDoNothing() throws Exception {
-        stub(mockMediaPlayer.getDuration()).toReturn(100000);
-        stub(mockMediaPlayer.getCurrentPosition()).toReturn(4999);
-
-        initializeSubject();
-        subject.onResume();
-
-        setMockMediaPlayer(mockMediaPlayer);
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        Robolectric.getUiThreadScheduler().unPause();
-
-        getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(0, 0));
-
-        Intent nextStartedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(nextStartedActivity).isNull();
-    }
-
-    @Test
-    public void onTouch_withTouchUp_whenVideoLongerThan16Seconds_andClickAfter5Seconds_shouldStartMoPubBrowser() throws Exception {
-        stub(mockMediaPlayer.getDuration()).toReturn(100000);
-        stub(mockMediaPlayer.getCurrentPosition()).toReturn(5001);
-
-        initializeSubject();
-        subject.onResume();
-
-        setMockMediaPlayer(mockMediaPlayer);
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        Robolectric.getUiThreadScheduler().unPause();
-
-        getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(0, 0));
-
-        ArgumentCaptor<Bundle> bundleCaptor = ArgumentCaptor.forClass(Bundle.class);
-        verify(baseVideoViewControllerListener).onStartActivityForResult(
-                eq(MoPubBrowser.class),
-                eq(expectedBrowserRequestCode),
-                bundleCaptor.capture()
-        );
-
-        assertThat(bundleCaptor.getValue().get(DESTINATION_URL_KEY)).isEqualTo(CLICKTHROUGH_URL);
-    }
-
-    @Test
-    public void onTouch_whenCloseButtonVisible_shouldPingClickThroughTrackers() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addClickTrackers(Arrays.asList("click_1", "click_2"));
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        initializeSubject();
-
-        subject.setCloseButtonVisible(true);
-
-        getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(0, 0));
-        verify(mockRequestQueue).add(argThat(isUrl("click_1")));
-        verify(mockRequestQueue).add(argThat(isUrl("click_2")));
-    }
-
-    @Test
-    public void onTouch_whenCloseButtonNotVisible_shouldNotPingClickThroughTrackers() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addClickTrackers(Arrays.asList("click_1", "click_2"));
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        initializeSubject();
-
-        subject.setCloseButtonVisible(false);
-
-        getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(0, 0));
-        assertThat(Robolectric.httpRequestWasMade()).isFalse();
-    }
-
-    @Test
-    public void onTouch_withNullBaseVideoViewListener_andActionTouchUp_shouldReturnTrueAndNotBlowUp() throws Exception {
-        subject = new VastVideoViewController(context, bundle, testBroadcastIdentifier, null);
-
-        boolean result = getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(0, 0));
-
-        // pass
-
-        assertThat(result).isTrue();
-    }
-
-    @Test
-    public void onTouch_withActionTouchDown_shouldConsumeMotionEvent() throws Exception {
-        initializeSubject();
-
-        boolean result = getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionDown(0, 0));
-
-        assertThat(result).isTrue();
-    }
-
-    @Test
-    public void onPrepared_whenDurationIsLessThanMaxVideoDurationForCloseButton_shouldSetShowCloseButtonDelayToDuration() throws Exception {
-        initializeSubject();
-
-        stub(mockMediaPlayer.getDuration()).toReturn(1000);
-        setMockMediaPlayer(mockMediaPlayer);
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(1000);
-    }
-
-    @Test
-    public void onPrepared_whenDurationIsGreaterThanMaxVideoDurationForCloseButton_shouldNotSetShowCloseButtonDelay() throws Exception {
-        initializeSubject();
-
-        stub(mockMediaPlayer.getDuration()).toReturn(MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
-        setMockMediaPlayer(mockMediaPlayer);
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
-    }
-
-    @Test
-    public void onPrepared_whenPercentSkipOffsetSpecified_shouldSetShowCloseButtonDelayToSkipOffset() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.setSkipOffset("25%");
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        initializeSubject();
-
-        stub(mockMediaPlayer.getDuration()).toReturn(10 * 1000);
-        setMockMediaPlayer(mockMediaPlayer);
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(2500);
-        assertThat(subject.getHasSkipOffset()).isTrue();
-    }
-
-    @Test
-    public void onPrepared_whenAbsoluteSkipOffsetSpecified_shouldSetShowCloseButtonDelayToSkipOffset() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.setSkipOffset("00:00:03");
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        initializeSubject();
-
-        stub(mockMediaPlayer.getDuration()).toReturn(10 * 1000);
-        setMockMediaPlayer(mockMediaPlayer);
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(3000);
-        assertThat(subject.getHasSkipOffset()).isTrue();
-    }
-
-    @Test
-    public void onPrepared_whenAbsoluteSkipOffsetWithMillisecondsSpecified_shouldSetShowCloseButtonDelayToSkipOffset() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.setSkipOffset("00:00:03.141");
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        initializeSubject();
-
-        stub(mockMediaPlayer.getDuration()).toReturn(10 * 1000);
-        setMockMediaPlayer(mockMediaPlayer);
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(3141);
-        assertThat(subject.getHasSkipOffset()).isTrue();
-    }
-
-    @Test
-    public void onPrepared_whenSkipOffsetIsNull_shouldNotSetShowCloseButtonDelay() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.setSkipOffset(null);
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        initializeSubject();
-
-        stub(mockMediaPlayer.getDuration()).toReturn(MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
-        setMockMediaPlayer(mockMediaPlayer);
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
-        assertThat(subject.getHasSkipOffset()).isFalse();
-    }
-
-    @Test
-    public void onPrepared_whenSkipOffsetHasInvalidAbsoluteFormat_shouldNotSetShowCloseButtonDelay() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.setSkipOffset("123:4:56.7");
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        initializeSubject();
-
-        stub(mockMediaPlayer.getDuration()).toReturn(MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
-        setMockMediaPlayer(mockMediaPlayer);
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
-        assertThat(subject.getHasSkipOffset()).isFalse();
-    }
-
-    @Test
-    public void onPrepared_whenSkipOffsetHasInvalidPercentFormat_shouldNotSetShowCloseButtonDelay() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.setSkipOffset("101%");
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        initializeSubject();
-
-        stub(mockMediaPlayer.getDuration()).toReturn(MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
-        setMockMediaPlayer(mockMediaPlayer);
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
-        assertThat(subject.getHasSkipOffset()).isFalse();
-    }
-
-    @Test
-    public void onPrepared_whenSkipOffsetHasInvalidFractionalPercentFormat_shouldNotSetShowCloseButtonDelay() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.setSkipOffset("3.14%");
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        initializeSubject();
-
-        stub(mockMediaPlayer.getDuration()).toReturn(MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
-        setMockMediaPlayer(mockMediaPlayer);
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
-        assertThat(subject.getHasSkipOffset()).isFalse();
-    }
-
-    @Test
-    public void onPrepared_whenSkipOffsetIsNegative_shouldNotSetShowCloseButtonDelay() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.setSkipOffset("-00:00:03");
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        initializeSubject();
-
-        stub(mockMediaPlayer.getDuration()).toReturn(MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
-        setMockMediaPlayer(mockMediaPlayer);
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
-        assertThat(subject.getHasSkipOffset()).isFalse();
-    }
-
-    @Test
-    public void onPrepared_whenSkipOffsetIsZero_shouldSetShowCloseButtonDelayToZero() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.setSkipOffset("00:00:00");
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        initializeSubject();
-
-        stub(mockMediaPlayer.getDuration()).toReturn(MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
-        setMockMediaPlayer(mockMediaPlayer);
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(0);
-        assertThat(subject.getHasSkipOffset()).isTrue();
-    }
-
-    @Test
-    public void onPrepared_whenSkipOffsetIsLongerThanDurationForShortVideo_shouldNotSetShowCloseButtonDelay() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.setSkipOffset("00:00:11");   // 11s
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        initializeSubject();
-
-        stub(mockMediaPlayer.getDuration()).toReturn(10 * 1000);    // 10s: short video
-        setMockMediaPlayer(mockMediaPlayer);
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(10 * 1000);
-        assertThat(subject.getHasSkipOffset()).isFalse();
-    }
-
-    @Test
-    public void onPrepared_whenSkipOffsetIsLongerThanDurationForLongVideo_shouldNotSetShowCloseButtonDelay() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.setSkipOffset("00:00:21");   // 21s
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        initializeSubject();
-
-        stub(mockMediaPlayer.getDuration()).toReturn(20 * 1000);    // 20s: long video
-        setMockMediaPlayer(mockMediaPlayer);
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
-        assertThat(subject.getHasSkipOffset()).isFalse();
-    }
-
-    @Test
-    public void onCompletion_shouldMarkVideoAsFinished() throws Exception {
-        initializeSubject();
-
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
-
-        assertThat(subject.isVideoFinishedPlaying()).isTrue();
-    }
-
-    @Test
-    public void onCompletion_whenAllTrackersTracked_whenNoPlaybackErrors_shouldPingCompletionTrackersOnlyOnce() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        VastAbsoluteProgressTracker testTracker = new VastAbsoluteProgressTracker("testUrl", 123);
-        vastVideoConfiguration.addAbsoluteTrackers(Arrays.asList(testTracker));
-        vastVideoConfiguration.addCompleteTrackers(Arrays.asList("complete_1", "complete_2"));
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        initializeSubject();
-        testTracker.setTracked();
-
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
-        verify(mockRequestQueue).add(argThat(isUrl("complete_1")));
-        verify(mockRequestQueue).add(argThat(isUrl("complete_2")));
-
-        // Completion trackers should still only be hit once
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
-        verify(mockRequestQueue).add(argThat(isUrl("complete_1")));
-        verify(mockRequestQueue).add(argThat(isUrl("complete_2")));
-    }
-
-    @Test
-    public void onCompletion_whenSomeTrackersRemain_shouldNotPingCompletionTrackers() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addCompleteTrackers(Arrays.asList("complete_1", "complete_2"));
-        VastAbsoluteProgressTracker testTracker = new VastAbsoluteProgressTracker("testUrl", 123);
-        // Never track the testTracker, so completion trackers should not be fired.
-        vastVideoConfiguration.addAbsoluteTrackers(Arrays.asList(testTracker));
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        initializeSubject();
-
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
-        verify(mockRequestQueue, never()).add(argThat(isUrl("complete_1")));
-        verify(mockRequestQueue, never()).add(argThat(isUrl("complete_2")));
-    }
-
-    @Test
-    public void onCompletion_whenPlaybackError_shouldNotPingCompletionTrackers() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addCompleteTrackers(Arrays.asList("complete_1", "complete_2"));
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        initializeSubject();
-        subject.setVideoError();
-
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
-        verify(mockRequestQueue, never()).add(argThat(isUrl("complete_1")));
-        verify(mockRequestQueue, never()).add(argThat(isUrl("complete_2")));
-    }
-
-    @Test
-    public void onCompletion_shouldPreventOnResumeFromStartingVideo() throws Exception {
-        initializeSubject();
-
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
-
-        subject.onResume();
-
-        assertThat(getShadowVideoView().isPlaying()).isFalse();
-    }
-
-    @Test
-    public void onCompletion_shouldStopProgressChecker() throws Exception {
-        initializeSubject();
-        subject.onResume();
-
-        assertThat(subject.getIsVideoProgressShouldBeChecked()).isTrue();
-
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
-
-        assertThat(subject.getIsVideoProgressShouldBeChecked()).isFalse();
-    }
-
-    @Test
-    public void onCompletion_shouldDisplayCompanionAdIfAvailable() throws Exception {
-        initializeSubject();
-        subject.onCreate();
-
-        Robolectric.getBackgroundScheduler().unPause();
-        Robolectric.getUiThreadScheduler().unPause();
-        Thread.sleep(NETWORK_DELAY);
-
-        final ImageView imageView = subject.getCompanionAdImageView();
-
-        assertThat(subject.getVideoView().getVisibility()).isEqualTo(View.VISIBLE);
-        assertThat(imageView.getVisibility()).isEqualTo(View.INVISIBLE);
-
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
-
-        assertThat(subject.getVideoView().getVisibility()).isEqualTo(View.GONE);
-        assertThat(imageView.getVisibility()).isEqualTo(View.VISIBLE);
-        assertThat(shadowOf(((BitmapDrawable) imageView.getDrawable()).getBitmap()).getCreatedFromBytes()).isEqualTo("body".getBytes());
-    }
-
-    @Test
-    public void onCompletion_shouldShowThatchedBackground() throws Exception {
-        initializeSubject();
-
-        final ImageView imageView = subject.getCompanionAdImageView();
-
-        assertThat(subject.getVideoView().getVisibility()).isEqualTo(View.VISIBLE);
-        assertThat(imageView.getVisibility()).isEqualTo(View.INVISIBLE);
-
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
-
-        assertThat(subject.getVideoView().getVisibility()).isEqualTo(View.GONE);
-        assertThat(imageView.getVisibility()).isEqualTo(View.INVISIBLE);
-    }
-
-    @Test
-    public void onError_shouldFireVideoErrorAndReturnFalse() throws Exception {
-        initializeSubject();
-
-        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_FAIL, testBroadcastIdentifier);
-
-        boolean result = getShadowVideoView().getOnErrorListener().onError(null, 0, 0);
-        Robolectric.getUiThreadScheduler().unPause();
-
-        assertThat(result).isFalse();
-        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
-        assertThat(subject.getVideoError()).isTrue();
-    }
-
-    @Test
-    public void onError_shouldStopProgressChecker() throws Exception {
-        initializeSubject();
-        subject.onResume();
-
-        assertThat(subject.getIsVideoProgressShouldBeChecked()).isTrue();
-
-        getShadowVideoView().getOnErrorListener().onError(null, 0, 0);
-
-        assertThat(subject.getIsVideoProgressShouldBeChecked()).isFalse();
-    }
-
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH_MR1)
-    @Test
-    public void onError_withVideoFilePermissionErrorBelowJellyBean_shouldRetryPlayingTheVideo() throws Exception {
-        File file = new File("disk_video_path");
-        file.createNewFile();
-
-        initializeSubject();
-
-        assertThat(getShadowVideoView().getCurrentVideoState()).isEqualTo(-1);
-
-        assertThat(subject.getVideoRetries()).isEqualTo(0);
-        getShadowVideoView().getOnErrorListener().onError(new MediaPlayer(), 1, Integer.MIN_VALUE);
-
-        assertThat(getShadowVideoView().isPlaying()).isTrue();
-        assertThat(subject.getVideoRetries()).isEqualTo(1);
-
-        file.delete();
-    }
-
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH_MR1)
-    @Test
-    public void retryMediaPlayer_withVideoFilePermissionErrorAndBelowJellyBean_shouldReturnTrue() throws Exception {
-        File file = new File("disk_video_path");
-        file.createNewFile();
-
-        initializeSubject();
-
-        assertThat(subject.getVideoRetries()).isEqualTo(0);
-        assertThat(subject.retryMediaPlayer(new MediaPlayer(), 1, Integer.MIN_VALUE)).isTrue();
-        assertThat(subject.getVideoRetries()).isEqualTo(1);
-
-        file.delete();
-    }
-
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH_MR1)
-    @Test
-    public void retryMediaPlayer_shouldNotRunMoreThanOnce() throws Exception {
-        File file = new File("disk_video_path");
-        file.createNewFile();
-
-        initializeSubject();
-
-        assertThat(subject.getVideoRetries()).isEqualTo(0);
-        assertThat(subject.retryMediaPlayer(new MediaPlayer(), 1, Integer.MIN_VALUE)).isTrue();
-        assertThat(subject.getVideoRetries()).isEqualTo(1);
-
-        assertThat(subject.retryMediaPlayer(new MediaPlayer(), 1, Integer.MIN_VALUE)).isFalse();
-        assertThat(subject.getVideoRetries()).isEqualTo(1);
-
-        file.delete();
-    }
-
-    @Config(reportSdk = VERSION_CODES.JELLY_BEAN)
-    @Test
-    public void retryMediaPlayer_withAndroidVersionAboveJellyBean_shouldReturnFalse() throws Exception {
-        File file = new File("disk_video_path");
-        file.createNewFile();
-
-        initializeSubject();
-
-        assertThat(subject.getVideoRetries()).isEqualTo(0);
-        assertThat(subject.retryMediaPlayer(new MediaPlayer(), 1, Integer.MIN_VALUE)).isFalse();
-        assertThat(subject.getVideoRetries()).isEqualTo(0);
-
-        file.delete();
-    }
-
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
-    @Test
-    public void retryMediaPlayer_withOtherVideoError_shouldReturnFalse() throws Exception {
-        File file = new File("disk_video_path");
-        file.createNewFile();
-
-        initializeSubject();
-
-        assertThat(subject.getVideoRetries()).isEqualTo(0);
-        assertThat(subject.retryMediaPlayer(new MediaPlayer(), 2, Integer.MIN_VALUE)).isFalse();
-        assertThat(subject.getVideoRetries()).isEqualTo(0);
-
-        file.delete();
-    }
-
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
-    @Test
-    public void retryMediaPlayer_withExceptionThrown_shouldReturnFalseAndIncrementRetryCount() throws Exception {
-        File file = new File("disk_video_path");
-        if (file.exists()){
-            assertThat(file.delete()).isTrue();
-        }
-
-        initializeSubject();
-
-        assertThat(subject.getVideoRetries()).isEqualTo(0);
-        assertThat(subject.retryMediaPlayer(new MediaPlayer(), 1, Integer.MIN_VALUE)).isFalse();
-        assertThat(subject.getVideoRetries()).isEqualTo(1);
-    }
-
-    @Test
-    public void handleClick_shouldMakeRequestsToClickTrackingUrls() {
-        initializeSubject();
-        subject.handleClick(Arrays.asList("clicktracker1", "clicktracker2"), CLICKTHROUGH_URL);
-
-        verify(mockRequestQueue).add(argThat(isUrl("clicktracker1")));
-        verify(mockRequestQueue).add(argThat(isUrl("clicktracker2")));
-    }
-
-    @Test
-    public void handleClick_withNullClickTrackers_shouldNotThrowAnException() {
-        initializeSubject();
-        subject.handleClick(null, CLICKTHROUGH_URL);
-
-        // pass
-    }
-
-    @Test
-    public void handleClick_withNullClickThroughUrl_shouldNotBroadcastClickOrOpenNewActivity() {
-        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_CLICK, testBroadcastIdentifier);
-
-        initializeSubject();
-        subject.handleClick(Arrays.asList("clicktracker"), null);
-
-        Robolectric.getUiThreadScheduler().unPause();
-        verify(broadcastReceiver, never()).onReceive(any(Context.class), eq(expectedIntent));
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
-    }
-
-    @Test
-    public void handleClick_withMoPubNativeBrowserClickThroughUrl_shouldOpenExternalBrowser() {
-        initializeSubject();
-
-        subject.handleClick(Arrays.asList("clicktracker"),
-                "mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.mopub.com");
-
-        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(intent.getDataString()).isEqualTo("http://www.mopub.com");
-        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
-    }
-
-    @Test
-    public void handleClick_withMalformedMoPubNativeBrowserClickThroughUrl_shouldNotOpenANewActivity() {
-        initializeSubject();
-
-        // url2 is an invalid query parameter
-        subject.handleClick(Arrays.asList("clicktracker"),
-                "mopubnativebrowser://navigate?url2=http%3A%2F%2Fwww.mopub.com");
-
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
-    }
-
-    @Test
-    public void handleClick_withAboutBlankClickThroughUrl_shouldFailSilently() {
-        initializeSubject();
-
-        subject.handleClick(Arrays.asList("clicktracker"), "about:blank");
-
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
-    }
-
-    @Test
-    public void videoProgressCheckerRunnableRun_shouldFireOffAllProgressTrackers() throws Exception {
-        stub(mockMediaPlayer.getDuration()).toReturn(9002);
-        stub(mockMediaPlayer.getCurrentPosition()).toReturn(9002);
-
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("first", 0.25f),
-                new VastFractionalProgressTracker("second", 0.5f),
-                new VastFractionalProgressTracker("third", 0.75f)));
-
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        initializeSubject();
-        subject.onResume();
-        setMockMediaPlayer(mockMediaPlayer);
-
-        // this runs the videoProgressChecker
-        Robolectric.getUiThreadScheduler().unPause();
-
-        verify(mockRequestQueue).add(argThat(isUrl("first")));
-        verify(mockRequestQueue).add(argThat(isUrl("second")));
-        verify(mockRequestQueue).add(argThat(isUrl("third")));
-    }
-
-    @Test
-    public void videoProgressCheckerRunnableRun_whenDurationIsInvalid_shouldNotMakeAnyNetworkCalls() throws Exception {
-        stub(mockMediaPlayer.getDuration()).toReturn(0);
-        stub(mockMediaPlayer.getCurrentPosition()).toReturn(100);
-
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        initializeSubject();
-        setMockMediaPlayer(mockMediaPlayer);
-        subject.onResume();
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
-
-        Robolectric.getUiThreadScheduler().runOneTask();
-        // make sure the repeated task hasn't run yet
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
-        verifyZeroInteractions(mockRequestQueue);
-    }
-
-    @Test
-    public void videoProgressCheckerRunnableRun_whenCurrentTimeLessThanTwoSeconds_shouldNotFireStartTracker() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addAbsoluteTrackers(Arrays.asList(new VastAbsoluteProgressTracker("start", 2000)));
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        stub(mockMediaPlayer.getDuration()).toReturn(100000);
-        stub(mockMediaPlayer.getCurrentPosition()).toReturn(1999);
-
-        initializeSubject();
-        subject.onResume();
-        setMockMediaPlayer(mockMediaPlayer);
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
-
-        Robolectric.getUiThreadScheduler().runOneTask();
-        // make sure the repeated task hasn't run yet
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
-
-        // Since it has not yet been a second, we expect that the start tracker has not been fired
-        verifyZeroInteractions(mockRequestQueue);
-
-        // run checker another time
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
-        Robolectric.getUiThreadScheduler().runOneTask();
-
-        verifyZeroInteractions(mockRequestQueue);
-    }
-
-    @Test
-    public void videoProgressCheckerRunnableRun_whenCurrentTimeGreaterThanTwoSeconds_shouldFireStartTracker() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addAbsoluteTrackers(Arrays.asList(new VastAbsoluteProgressTracker("start", 2000)));
-        vastVideoConfiguration.addAbsoluteTrackers(Arrays.asList(new VastAbsoluteProgressTracker("later", 3000)));
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        stub(mockMediaPlayer.getDuration()).toReturn(100000);
-        stub(mockMediaPlayer.getCurrentPosition()).toReturn(2000);
-
-        initializeSubject();
-        subject.onResume();
-        setMockMediaPlayer(mockMediaPlayer);
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
-
-        Robolectric.getUiThreadScheduler().unPause();
-
-        verify(mockRequestQueue).add(argThat(isUrl("start")));
-
-        // run checker another time
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
-        Robolectric.getUiThreadScheduler().runOneTask();
-
-        verifyNoMoreInteractions(mockRequestQueue);
-    }
-
-    @Test
-    public void videoProgressCheckerRunnableRun_whenProgressIsPastFirstQuartile_shouldOnlyPingFirstQuartileTrackersOnce() throws Exception {
-        stub(mockMediaPlayer.getDuration()).toReturn(100);
-        stub(mockMediaPlayer.getCurrentPosition()).toReturn(26);
-
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("first", 0.25f)));
-        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("don't call", 0.28f)));
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        initializeSubject();
-        subject.onResume();
-        setMockMediaPlayer(mockMediaPlayer);
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
-
-        Robolectric.getUiThreadScheduler().unPause();
-
-        verify(mockRequestQueue).add(argThat(isUrl("first")));
-
-        // run checker another time
-        Robolectric.getUiThreadScheduler().runOneTask();
-
-        verifyNoMoreInteractions(mockRequestQueue);
-    }
-
-    @Test
-    public void videoProgressCheckerRunnableRun_whenProgressIsPastMidQuartile_shouldPingFirstQuartileTrackers_andMidQuartileTrackersBothOnlyOnce() throws Exception {
-        stub(mockMediaPlayer.getDuration()).toReturn(100);
-        stub(mockMediaPlayer.getCurrentPosition()).toReturn(51);
-
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("first", 0.25f)));
-        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("second", 0.5f)));
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        initializeSubject();
-        subject.onResume();
-        setMockMediaPlayer(mockMediaPlayer);
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
-
-        Robolectric.getUiThreadScheduler().unPause();
-
-        verify(mockRequestQueue).add(argThat(isUrl("first")));
-        verify(mockRequestQueue).add(argThat(isUrl("second")));
-
-        Robolectric.getUiThreadScheduler().runOneTask();
-
-        verifyNoMoreInteractions(mockRequestQueue);
-    }
-
-    @Test
-    public void videoProgressCheckerRunnableRun_whenProgressIsPastThirdQuartile_shouldPingFirstQuartileTrackers_andMidQuartileTrackers_andThirdQuartileTrackersAllOnlyOnce() throws Exception {
-        stub(mockMediaPlayer.getDuration()).toReturn(100);
-        stub(mockMediaPlayer.getCurrentPosition()).toReturn(76);
-
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("first", 0.25f)));
-        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("second", 0.5f)));
-        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("third", 0.75f)));
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        initializeSubject();
-        subject.onResume();
-        setMockMediaPlayer(mockMediaPlayer);
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
-
-        Robolectric.getUiThreadScheduler().unPause();
-
-        verify(mockRequestQueue).add(argThat(isUrl("first")));
-        verify(mockRequestQueue).add(argThat(isUrl("second")));
-        verify(mockRequestQueue).add(argThat(isUrl("third")));
-
-        Robolectric.getUiThreadScheduler().runOneTask();
-
-        verifyNoMoreInteractions(mockRequestQueue);
-    }
-
-    @Test
-    public void videoProgressCheckerRunnableRun_asVideoPlays_shouldPingAllThreeTrackersIndividuallyOnce() throws Exception {
-        stub(mockMediaPlayer.getDuration()).toReturn(100);
-
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("first", 0.25f)));
-        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("second", 0.5f)));
-        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("third", 0.75f)));
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        initializeSubject();
-        subject.onResume();
-        setMockMediaPlayer(mockMediaPlayer);
-
-        // before any trackers are fired
-        fastForwardMediaPlayerAndAssertRequestMade(1);
-
-        fastForwardMediaPlayerAndAssertRequestMade(24);
-
-        // after it hits first tracker
-        fastForwardMediaPlayerAndAssertRequestMade(26, "first");
-
-        // before mid quartile is hit
-        fastForwardMediaPlayerAndAssertRequestMade(49);
-
-        // after it hits mid trackers
-        fastForwardMediaPlayerAndAssertRequestMade(51, "second");
-
-        // before third quartile is hit
-        fastForwardMediaPlayerAndAssertRequestMade(74);
-
-        // after third quartile is hit
-        fastForwardMediaPlayerAndAssertRequestMade(76, "third");
-
-        // way after third quartile is hit
-        fastForwardMediaPlayerAndAssertRequestMade(99);
-    }
-
-    @Test
-    public void videoProgressCheckerRunnableRun_whenCurrentPositionIsGreaterThanShowCloseButtonDelay_shouldShowCloseButton() throws Exception {
-        stub(mockMediaPlayer.getDuration()).toReturn(5002);
-        stub(mockMediaPlayer.getCurrentPosition()).toReturn(5001);
-
-        initializeSubject();
-        subject.onResume();
-        setMockMediaPlayer(mockMediaPlayer);
-
-        assertThat(subject.isShowCloseButtonEventFired()).isFalse();
-        Robolectric.getUiThreadScheduler().unPause();
-
-        assertThat(subject.isShowCloseButtonEventFired()).isTrue();
-    }
-
-    @Test
-    public void videoProgressCheckerRunnableRun_whenCurrentPositionIsGreaterThanSkipOffset_shouldShowCloseButton() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.setSkipOffset("25%");    // skipoffset is at 2.5s
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        // duration is 10s
-        stub(mockMediaPlayer.getDuration()).toReturn(10 * 1000);
-
-        // current position is 1 ms after skipoffset
-        stub(mockMediaPlayer.getCurrentPosition()).toReturn(2501);
-
-        initializeSubject();
-        subject.onResume();
-        setMockMediaPlayer(mockMediaPlayer);
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(2500);
-        assertThat(subject.getHasSkipOffset()).isTrue();
-
-        assertThat(subject.isShowCloseButtonEventFired()).isFalse();
-        Robolectric.getUiThreadScheduler().unPause();
-
-        assertThat(subject.isShowCloseButtonEventFired()).isTrue();
-    }
-
-    @Test
-    public void videoProgressCheckerRunnableRun_whenCurrentPositionIsLessThanSkipOffset_shouldNotShowCloseButton() throws Exception {
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.setSkipOffset("00:00:03");   // skipoffset is at 3s
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        stub(mockMediaPlayer.getDuration()).toReturn(10 * 1000);    // duration is 10s
-        stub(mockMediaPlayer.getCurrentPosition()).toReturn(2999);  // current position is 1ms before skipoffset
-
-        initializeSubject();
-        subject.onResume();
-        setMockMediaPlayer(mockMediaPlayer);
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(3000);
-        assertThat(subject.getHasSkipOffset()).isTrue();
-
-        assertThat(subject.isShowCloseButtonEventFired()).isFalse();
-        Robolectric.getUiThreadScheduler().unPause();
-
-        assertThat(subject.isShowCloseButtonEventFired()).isFalse();
-    }
-
-    @Test
-    public void onPause_shouldStopProgressChecker() throws Exception {
-        initializeSubject();
-
-        subject.onResume();
-        assertThat(subject.getIsVideoProgressShouldBeChecked()).isTrue();
-
-        subject.onPause();
-        assertThat(subject.getIsVideoProgressShouldBeChecked()).isFalse();
-
-        subject.onPause();
-        assertThat(subject.getIsVideoProgressShouldBeChecked()).isFalse();
-    }
-
-    @Test
-    public void onResume_shouldStartVideoProgressCheckerOnce() throws Exception {
-        initializeSubject();
-
-        subject.onResume();
-        assertThat(subject.getIsVideoProgressShouldBeChecked()).isTrue();
-
-        subject.onPause();
-        assertThat(subject.getIsVideoProgressShouldBeChecked()).isFalse();
-
-        subject.onResume();
-        assertThat(subject.getIsVideoProgressShouldBeChecked()).isTrue();
-
-        subject.onResume();
-        assertThat(subject.getIsVideoProgressShouldBeChecked()).isTrue();
-    }
-
-    @Test
-    public void onResume_shouldSetVideoViewStateToStarted() throws Exception {
-        initializeSubject();
-
-        subject.onResume();
-
-        assertThat(getShadowVideoView().getCurrentVideoState()).isEqualTo(ShadowVideoView.START);
-        assertThat(getShadowVideoView().getPrevVideoState()).isNotEqualTo(ShadowVideoView.START);
-    }
-
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH_MR1)
-    @Test
-    public void onResume_shouldResetVideoRetryCountToZero() throws Exception {
-        File file = new File("disk_video_path");
-        file.createNewFile();
-
-        initializeSubject();
-
-        assertThat(subject.retryMediaPlayer(new MediaPlayer(), 1, Integer.MIN_VALUE)).isTrue();
-        assertThat(subject.getVideoRetries()).isEqualTo(1);
-
-        subject.onResume();
-        assertThat(subject.getVideoRetries()).isEqualTo(0);
-
-        file.delete();
-    }
-
-    @Ignore("pending")
-    @Test
-    public void onResume_shouldSeekToPrePausedPosition() throws Exception {
-        stub(mockMediaPlayer.getDuration()).toReturn(10000);
-        stub(mockMediaPlayer.getCurrentPosition()).toReturn(7000);
-
-        initializeSubject();
-        setMockMediaPlayer(mockMediaPlayer);
-        final VideoView videoView = spy(subject.getVideoView());
-
-        subject.onPause();
-
-        stub(mockMediaPlayer.getCurrentPosition()).toReturn(1000);
-
-        subject.onResume();
-        verify(videoView).seekTo(eq(7000));
-    }
-
-    @Test
-    public void backButtonEnabled_shouldDefaultToFalse() throws Exception {
-        initializeSubject();
-
-        assertThat(subject.backButtonEnabled()).isFalse();
-    }
-
-    @Test
-    public void backButtonEnabled_whenCloseButtonIsVisible_shouldReturnTrue() throws Exception {
-        initializeSubject();
-
-        subject.setCloseButtonVisible(true);
-
-        assertThat(subject.backButtonEnabled()).isTrue();
-    }
-
-    @Test
-    public void onClickCloseButton_whenCloseButtonIsVisible_shouldFireCloseTrackers() {
-        initializeSubject();
-
-        subject.setCloseButtonVisible(true);
-
-        // We don't have direct access to the CloseButtonWidget's close event, so we manually
-        // invoke its onTouchListener's onTouch callback with a fake MotionEvent.ACTION_UP action.
-        View.OnTouchListener closeButtonOnTouchListener =
-                shadowOf(getVastVideoToolbar().getCloseButtonWidget()).getOnTouchListener();
-        closeButtonOnTouchListener.onTouch(null, GestureUtils.createActionUp(0, 0));
-
-        verify(mockRequestQueue).add(argThat(isUrl("close")));
-        verify(mockRequestQueue).add(argThat(isUrl("skip")));
-    }
-
-    private void initializeSubject() {
-        subject = new VastVideoViewController(context, bundle, testBroadcastIdentifier, baseVideoViewControllerListener);
-    }
-
-    private void setMockMediaPlayer(final MediaPlayer mockMediaPlayer) throws IllegalAccessException {
-        final VideoView videoView = subject.getVideoView();
-        ReflectionUtils.setVariableValueInObject(videoView, "mMediaPlayer", mockMediaPlayer);
-
-        int state = (Integer) ReflectionUtils.getValueIncludingSuperclasses("STATE_PLAYING", videoView);
-
-        ReflectionUtils.setVariableValueInObject(videoView, "mCurrentState", state);
-    }
-
-    private void fastForwardMediaPlayerAndAssertRequestMade(int time, String... urls) throws Exception {
-        stub(mockMediaPlayer.getCurrentPosition()).toReturn(time);
-        Robolectric.getUiThreadScheduler().unPause();
-        Robolectric.getBackgroundScheduler().unPause();
-        Thread.sleep(NETWORK_DELAY);
-
-        for (String url : urls) {
-            verify(mockRequestQueue).add(argThat(isUrl(url)));
-        }
-
-        Robolectric.getFakeHttpLayer().clearRequestInfos();
-    }
-
-    private VastVideoToolbar getVastVideoToolbar() {
-        final ViewGroup layout = subject.getLayout();
-
-        for (int i = 0; i < layout.getChildCount(); i++) {
-            final View child = layout.getChildAt(i);
-            if (child instanceof VastVideoToolbar) {
-                return (VastVideoToolbar) child;
-            }
-        }
-
-        fail("Unable to find VastVideoToolbar in view hierarchy.");
-        return null;
-    }
-
-    private ShadowVideoView getShadowVideoView() {
-        return shadowOf(subject.getVideoView());
-    }
-
-    public static void assertHttpRequestsMade(final String userAgent, final String... urls) {
-        final int numberOfReceivedHttpRequests = Robolectric.getFakeHttpLayer().getSentHttpRequestInfos().size();
-        assertThat(numberOfReceivedHttpRequests).isEqualTo(urls.length);
-
-        for (final String url : urls) {
-            assertThat(Robolectric.httpRequestWasMade(url)).isTrue();
-        }
-
-        if (userAgent != null) {
-            while (true) {
-                final HttpRequest httpRequest = Robolectric.getNextSentHttpRequest();
-                if (httpRequest == null) {
-                    break;
-                }
-
-                assertThat(httpRequest.getFirstHeader(USER_AGENT.getKey()).getValue())
-                        .isEqualTo(userAgent);
-            }
-        }
-    }
-}
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.graphics.Color;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.graphics.drawable.GradientDrawable;
+import android.graphics.drawable.LayerDrawable;
+import android.media.MediaPlayer;
+import android.os.Build.VERSION_CODES;
+import android.os.Bundle;
+import android.view.View;
+import android.view.ViewGroup;
+import android.webkit.WebView;
+import android.widget.ImageView;
+import android.widget.VideoView;
+
+import com.mopub.common.MoPubBrowser;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.DeviceUtils.ForceOrientation;
+import com.mopub.common.util.Dips;
+import com.mopub.common.util.Drawables;
+import com.mopub.mobileads.resource.CloseButtonDrawable;
+import com.mopub.mobileads.test.support.GestureUtils;
+import com.mopub.mobileads.util.vast.VastCompanionAd;
+import com.mopub.mobileads.util.vast.VastVideoConfiguration;
+import com.mopub.network.MaxWidthImageLoader;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+
+import org.apache.http.HttpRequest;
+import org.apache.maven.artifact.ant.shaded.ReflectionUtils;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLocalBroadcastManager;
+import org.robolectric.shadows.ShadowVideoView;
+import org.robolectric.tester.org.apache.http.RequestMatcher;
+import org.robolectric.tester.org.apache.http.TestHttpResponse;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import static android.content.pm.ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
+import static android.content.pm.ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
+import static android.view.ViewGroup.LayoutParams.MATCH_PARENT;
+import static com.mopub.common.MoPubBrowser.DESTINATION_URL_KEY;
+import static com.mopub.common.VolleyRequestMatcher.isUrl;
+import static com.mopub.common.util.ResponseHeader.USER_AGENT;
+import static com.mopub.mobileads.BaseVideoViewController.BaseVideoViewControllerListener;
+import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_CLICK;
+import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
+import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_FAIL;
+import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
+import static com.mopub.mobileads.EventForwardingBroadcastReceiver.getHtmlInterstitialIntentFilter;
+import static com.mopub.mobileads.EventForwardingBroadcastReceiverTest.getIntentForActionAndIdentifier;
+import static com.mopub.mobileads.VastVideoViewController.DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON;
+import static com.mopub.mobileads.VastVideoViewController.MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON;
+import static com.mopub.mobileads.VastVideoViewController.VAST_VIDEO_CONFIGURATION;
+import static com.mopub.volley.toolbox.ImageLoader.ImageListener;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.anyLong;
+import static org.mockito.Matchers.argThat;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.verifyZeroInteractions;
+import static org.mockito.Mockito.when;
+import static org.robolectric.Robolectric.shadowOf;
+
+@RunWith(SdkTestRunner.class)
+public class VastVideoViewControllerTest {
+    public static final int NETWORK_DELAY = 100;
+
+    private static final String COMPANION_IMAGE_URL = "companion_image_url";
+    private static final String COMPANION_CLICK_TRACKING_URL_1 = "companion_click_tracking_url_1";
+    private static final String COMPANION_CLICK_TRACKING_URL_2 = "companion_click_tracking_url_2";
+    private static final String COMPANION_CLICK_DESTINATION_URL = "http://companion_click_destination_url";
+    private static final String CLICKTHROUGH_URL = "http://clickthrough_url";
+
+    private Context context;
+    private Bundle bundle;
+    private long testBroadcastIdentifier;
+    private VastVideoViewController subject;
+    private BaseVideoViewControllerListener baseVideoViewControllerListener;
+    private EventForwardingBroadcastReceiver broadcastReceiver;
+    private int expectedBrowserRequestCode;
+    private String expectedUserAgent;
+
+    @Mock
+    MoPubRequestQueue mockRequestQueue;
+    @Mock
+    MaxWidthImageLoader mockImageLoader;
+    @Mock
+    private VideoView mockVideoView;
+
+    private VastVideoViewCountdownRunnable spyCountdownRunnable;
+    private VastVideoViewProgressRunnable spyProgressRunnable;
+    private VideoView spyVideoView;
+
+
+    @Before
+    public void setUp() throws Exception {
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+        Networking.setImageLoaderForTesting(mockImageLoader);
+        context = Robolectric.buildActivity(Activity.class).create().get();
+        bundle = new Bundle();
+        testBroadcastIdentifier = 1111;
+        broadcastReceiver = mock(EventForwardingBroadcastReceiver.class);
+        baseVideoViewControllerListener = mock(BaseVideoViewControllerListener.class);
+
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setNetworkMediaFileUrl("video_url");
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.addAbsoluteTrackers(Arrays.asList(new VastAbsoluteProgressTracker("start", 2000)));
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("first", 0.25f),
+                new VastFractionalProgressTracker("mid", 0.5f), new VastFractionalProgressTracker("third", 0.75f)));
+        vastVideoConfiguration.addCompleteTrackers(Arrays.asList("complete"));
+        vastVideoConfiguration.addCloseTrackers(Arrays.asList("close"));
+        vastVideoConfiguration.addSkipTrackers(Arrays.asList("skip"));
+        vastVideoConfiguration.addImpressionTrackers(Arrays.asList("imp"));
+        vastVideoConfiguration.setClickThroughUrl(CLICKTHROUGH_URL);
+        vastVideoConfiguration.addClickTrackers(Arrays.asList("click_1", "click_2"));
+
+        VastCompanionAd vastCompanionAd = new VastCompanionAd(
+                300,
+                250,
+                COMPANION_IMAGE_URL,
+                COMPANION_CLICK_DESTINATION_URL,
+                new ArrayList<String>(Arrays.asList(COMPANION_CLICK_TRACKING_URL_1, COMPANION_CLICK_TRACKING_URL_2))
+        );
+        vastVideoConfiguration.setVastCompanionAd(vastCompanionAd);
+
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        expectedBrowserRequestCode = 1;
+
+        Robolectric.getUiThreadScheduler().pause();
+        Robolectric.getBackgroundScheduler().pause();
+        Robolectric.clearPendingHttpResponses();
+
+        // Used to give responses to Vast Download Tasks.
+        Robolectric.addHttpResponseRule(new RequestMatcher() {
+            @Override
+            public boolean matches(HttpRequest request) {
+                return true;
+            }
+        }, new TestHttpResponse(200, "body"));
+
+        ShadowLocalBroadcastManager.getInstance(context).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
+
+        expectedUserAgent = new WebView(context).getSettings().getUserAgentString();
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        Robolectric.getUiThreadScheduler().reset();
+        Robolectric.getBackgroundScheduler().reset();
+
+        ShadowLocalBroadcastManager.getInstance(context).unregisterReceiver(broadcastReceiver);
+    }
+
+    @Test
+    public void constructor_shouldAddVastVideoToolbarToLayout() throws Exception {
+        initializeSubject();
+
+        VastVideoToolbar vastVideoToolbar = getVastVideoToolbar();
+        final ViewGroup.LayoutParams layoutParams = vastVideoToolbar.getLayoutParams();
+
+        assertThat(vastVideoToolbar.getParent()).isEqualTo(subject.getLayout());
+        assertThat(vastVideoToolbar.getVisibility()).isEqualTo(View.VISIBLE);
+
+        assertThat(layoutParams.width).isEqualTo(MATCH_PARENT);
+        assertThat(layoutParams.height).isEqualTo(Dips.dipsToIntPixels(44, context));
+    }
+
+    @Test
+    public void constructor_shouldSetVideoListenersAndVideoPath() throws Exception {
+        initializeSubject();
+        ShadowVideoView videoView = shadowOf(subject.getVideoView());
+
+        assertThat(videoView.getOnCompletionListener()).isNotNull();
+        assertThat(videoView.getOnErrorListener()).isNotNull();
+        assertThat(videoView.getOnTouchListener()).isNotNull();
+        assertThat(videoView.getOnPreparedListener()).isNotNull();
+
+        assertThat(videoView.getVideoPath()).isEqualTo("disk_video_path");
+        assertThat(subject.getVideoView().hasFocus()).isTrue();
+    }
+
+    @Test
+    public void constructor_shouldNotChangeCloseButtonDelay() throws Exception {
+        initializeSubject();
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
+    }
+
+    @Test
+    public void constructor_shouldAddThatchedBackgroundWithGradientToLayout() throws Exception {
+        initializeSubject();
+        ViewGroup viewGroup = subject.getLayout();
+        LayerDrawable layerDrawable = (LayerDrawable) viewGroup.getBackground();
+        assertThat(layerDrawable.getDrawable(0)).isEqualTo(Drawables.THATCHED_BACKGROUND.createDrawable(
+                context));
+        assertThat(layerDrawable.getDrawable(1)).isEqualTo(
+                new GradientDrawable(
+                        GradientDrawable.Orientation.TOP_BOTTOM,
+                        new int[]{Color.argb(0, 0, 0, 0), Color.argb(255, 0, 0, 0)})
+        );
+    }
+
+    @Test
+    public void constructor_withMissingVastVideoConfiguration_shouldThrowIllegalStateException() throws Exception {
+        bundle.clear();
+        try {
+            initializeSubject();
+            fail("VastVideoViewController didn't throw IllegalStateException");
+        } catch (IllegalStateException e) {
+            // pass
+        }
+    }
+
+    @Test
+    public void constructor_withNullVastVideoConfigurationDiskMediaFileUrl_shouldThrowIllegalStateException() throws Exception {
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, new VastVideoConfiguration());
+        try {
+            initializeSubject();
+            fail("VastVideoViewController didn't throw IllegalStateException");
+        } catch (IllegalStateException e) {
+            // pass
+        }
+    }
+
+    @Test
+    public void constructor_whenCustomCtaTextNotSpecified_shouldUseDefaultCtaText() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+
+        assertThat(getVastVideoToolbar().getLearnMoreWidget().getTextViewText()).isEqualTo("Learn More");
+    }
+
+    @Test
+    public void constructor_whenCustomCtaTextSpecified_shouldUseCustomCtaText() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setCustomCtaText("custom CTA text");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+
+        assertThat(getVastVideoToolbar().getLearnMoreWidget().getTextViewText()).isEqualTo("custom CTA text");
+    }
+
+    @Test
+    public void constructor_whenCustomSkipTextNotSpecified_shouldUseDefaultSkipText() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+
+        assertThat(getVastVideoToolbar().getCloseButtonWidget().getTextViewText()).isEqualTo("Close");
+    }
+
+    @Test
+    public void constructor_whenCustomSkipTextSpecified_shouldUseCustomSkipText() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setCustomSkipText("custom skip text");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+
+        assertThat(getVastVideoToolbar().getCloseButtonWidget().getTextViewText()).isEqualTo("custom skip text");
+    }
+
+    @Test
+    public void constructor_whenCustomCloseIconNotSpecified_shouldUseDefaultCloseIcon() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+
+        Drawable imageViewDrawable = getVastVideoToolbar().getCloseButtonWidget().getImageViewDrawable();
+
+        // Default close icon is an instance of CloseButtonDrawable
+        assertThat(imageViewDrawable).isInstanceOf(CloseButtonDrawable.class);
+    }
+
+    @Test
+    public void constructor_whenCustomCloseIconSpecified_shouldUseCustomCloseIcon() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setCustomCloseIconUrl("http://ton.twitter.com/exchange-media/images/v4/star_icon_3x_1.png");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+
+        verify(mockImageLoader).get(eq("http://ton.twitter.com/exchange-media/images/v4/star_icon_3x_1.png"), any(ImageListener.class));
+    }
+
+    @Test
+    public void onCreate_withCompanionAd_shouldDownloadCompanionAd() throws Exception {
+        initializeSubject();
+
+        final ImageView imageView = subject.getCompanionAdImageView();
+        assertThat(imageView.getDrawable()).isNull();
+
+        subject.onCreate();
+        Robolectric.getBackgroundScheduler().unPause();
+        Robolectric.getUiThreadScheduler().unPause();
+        Thread.sleep(NETWORK_DELAY);
+
+        assertThat(shadowOf(((BitmapDrawable) imageView.getDrawable()).getBitmap()).getCreatedFromBytes()).isEqualTo("body".getBytes());
+    }
+
+    @Test
+    public void onCreate_shouldFireImpressionTracker() throws Exception {
+        initializeSubject();
+
+        subject.onCreate();
+        verify(mockRequestQueue).add(argThat(isUrl("imp")));
+    }
+
+    @Test
+    public void onCreate_shouldBroadcastInterstitialShow() throws Exception {
+        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_SHOW, testBroadcastIdentifier);
+
+        initializeSubject();
+
+        Robolectric.getUiThreadScheduler().unPause();
+        subject.onCreate();
+        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
+    }
+
+    @Test
+    public void onCreate_whenCustomForceOrientationNotSpecified_shouldForceLandscapeOrientation() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        subject.onCreate();
+
+        verify(baseVideoViewControllerListener).onSetRequestedOrientation(SCREEN_ORIENTATION_LANDSCAPE);
+    }
+
+    @Test
+    public void onCreate_whenCustomForceOrientationIsDeviceOrientation_shouldNotForceLandscapeOrientation() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setCustomForceOrientation(ForceOrientation.DEVICE_ORIENTATION);
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        subject.onCreate();
+
+        verify(baseVideoViewControllerListener, never()).onSetRequestedOrientation(anyInt());
+    }
+
+    @Test
+    public void onCreate_whenCustomForceOrientationIsPortraitOrientation_shouldForcePortraitOrientation() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setCustomForceOrientation(ForceOrientation.FORCE_PORTRAIT);
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        subject.onCreate();
+
+        verify(baseVideoViewControllerListener).onSetRequestedOrientation(SCREEN_ORIENTATION_PORTRAIT);
+    }
+
+    @Test
+    public void onCreate_whenCustomForceOrientationIsLandscapeOrientation_shouldForceLandscapeOrientation() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setCustomForceOrientation(ForceOrientation.FORCE_LANDSCAPE);
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        subject.onCreate();
+
+        verify(baseVideoViewControllerListener).onSetRequestedOrientation(SCREEN_ORIENTATION_LANDSCAPE);
+    }
+
+    @Test
+    public void onComplete_withNullDownloadResponse_shouldNotSetCompanionAdImageBitmap() throws Exception {
+        initializeSubject();
+
+        final ImageView imageView = subject.getCompanionAdImageView();
+        assertThat(imageView.getDrawable()).isNull();
+
+        subject.onComplete("url", null);
+
+        assertThat(imageView.getDrawable()).isNull();
+    }
+
+    @Test
+    public void onClick_withCompanionAd_shouldFireCompanionAdClickTrackersAndStartMoPubBrowser() throws Exception {
+        initializeSubject();
+
+        final ImageView imageView = subject.getCompanionAdImageView();
+        assertThat(imageView.performClick()).isFalse();
+        subject.onCreate();
+
+        Robolectric.getBackgroundScheduler().unPause();
+        Robolectric.getUiThreadScheduler().unPause();
+        Thread.sleep(NETWORK_DELAY);
+
+        assertThat(imageView.performClick()).isTrue();
+
+        // This request is still made by the older http stack.
+        assertHttpRequestsMade(expectedUserAgent, COMPANION_IMAGE_URL);
+
+        verify(mockRequestQueue).add(argThat(isUrl(COMPANION_CLICK_TRACKING_URL_1)));
+        verify(mockRequestQueue).add(argThat(isUrl(COMPANION_CLICK_TRACKING_URL_2)));
+
+        ArgumentCaptor<Bundle> bundleCaptor = ArgumentCaptor.forClass(Bundle.class);
+        verify(baseVideoViewControllerListener).onStartActivityForResult(
+                eq(MoPubBrowser.class),
+                eq(expectedBrowserRequestCode),
+                bundleCaptor.capture()
+        );
+
+        assertThat(bundleCaptor.getValue().get(DESTINATION_URL_KEY)).isEqualTo(COMPANION_CLICK_DESTINATION_URL);
+    }
+
+    @Test
+    public void onDestroy_shouldBroadcastInterstitialDismiss() throws Exception {
+        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_DISMISS, testBroadcastIdentifier);
+
+        initializeSubject();
+
+        subject.onDestroy();
+        Robolectric.getUiThreadScheduler().unPause();
+
+        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
+    }
+
+    @Test
+    public void onActivityResult_shouldCallFinish() throws Exception {
+        final int expectedResultCode = Activity.RESULT_OK;
+
+        initializeSubject();
+
+        subject.onActivityResult(expectedBrowserRequestCode, expectedResultCode, null);
+
+        verify(baseVideoViewControllerListener).onFinish();
+    }
+
+    @Test
+    public void onActivityResult_withIncorrectRequestCode_shouldNotCallFinish() throws Exception {
+        final int incorrectRequestCode = 1000;
+        final int expectedResultCode = Activity.RESULT_OK;
+
+        initializeSubject();
+
+        subject.onActivityResult(incorrectRequestCode, expectedResultCode, null);
+
+        verify(baseVideoViewControllerListener, never()).onFinish();
+    }
+
+    @Test
+    public void onActivityResult_withIncorrectResultCode_shouldNotCallFinish() throws Exception {
+        final int incorrectResultCode = Activity.RESULT_CANCELED;
+
+        initializeSubject();
+
+        subject.onActivityResult(expectedBrowserRequestCode, incorrectResultCode, null);
+
+        verify(baseVideoViewControllerListener, never()).onFinish();
+    }
+
+    @Test
+    public void onTouch_withTouchUp_whenVideoLessThan16Seconds_andClickBeforeEnd_shouldDoNothing() throws Exception {
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(15990, 15999);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        Robolectric.getUiThreadScheduler().unPause();
+
+        getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(0, 0));
+
+        Intent nextStartedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(nextStartedActivity).isNull();
+    }
+
+    @Test
+    public void onTouch_withTouchUp_whenVideoLessThan16Seconds_andClickAfterEnd_shouldStartMoPubBrowser() throws Exception {
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(15999, 15999);
+        subject.onResume();
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        Robolectric.getUiThreadScheduler().unPause();
+
+        getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(0, 0));
+
+        ArgumentCaptor<Bundle> bundleCaptor = ArgumentCaptor.forClass(Bundle.class);
+        verify(baseVideoViewControllerListener).onStartActivityForResult(
+                eq(MoPubBrowser.class),
+                eq(expectedBrowserRequestCode),
+                bundleCaptor.capture()
+        );
+
+        assertThat(bundleCaptor.getValue().get(DESTINATION_URL_KEY)).isEqualTo(CLICKTHROUGH_URL);
+    }
+
+    @Test
+    public void onTouch_withTouchUp_whenVideoLongerThan16Seconds_andClickBefore5Seconds_shouldDoNothing() throws Exception {
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(4999, 100000);
+        subject.onResume();
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        Robolectric.getUiThreadScheduler().unPause();
+
+        getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(0, 0));
+
+        Intent nextStartedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(nextStartedActivity).isNull();
+    }
+
+    @Test
+    public void onTouch_withTouchUp_whenVideoLongerThan16Seconds_andClickAfter5Seconds_shouldStartMoPubBrowser() throws Exception {
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(5001, 100000);
+        subject.onResume();
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        Robolectric.getUiThreadScheduler().unPause();
+
+        getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(0, 0));
+
+        ArgumentCaptor<Bundle> bundleCaptor = ArgumentCaptor.forClass(Bundle.class);
+        verify(baseVideoViewControllerListener).onStartActivityForResult(
+                eq(MoPubBrowser.class),
+                eq(expectedBrowserRequestCode),
+                bundleCaptor.capture()
+        );
+
+        assertThat(bundleCaptor.getValue().get(DESTINATION_URL_KEY)).isEqualTo(CLICKTHROUGH_URL);
+    }
+
+    @Test
+    public void onTouch_whenCloseButtonVisible_shouldPingClickThroughTrackers() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.addClickTrackers(Arrays.asList("click_1", "click_2"));
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+
+        subject.setCloseButtonVisible(true);
+
+        getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(0, 0));
+        verify(mockRequestQueue).add(argThat(isUrl("click_1")));
+        verify(mockRequestQueue).add(argThat(isUrl("click_2")));
+    }
+
+    @Test
+    public void onTouch_whenCloseButtonNotVisible_shouldNotPingClickThroughTrackers() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.addClickTrackers(Arrays.asList("click_1", "click_2"));
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+
+        subject.setCloseButtonVisible(false);
+
+        getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(0, 0));
+        assertThat(Robolectric.httpRequestWasMade()).isFalse();
+    }
+
+    @Test
+    public void onTouch_withNullBaseVideoViewListener_andActionTouchUp_shouldReturnTrueAndNotBlowUp() throws Exception {
+        subject = new VastVideoViewController(context, bundle, testBroadcastIdentifier, null);
+
+        boolean result = getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(0, 0));
+
+        // pass
+
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void onTouch_withActionTouchDown_shouldConsumeMotionEvent() throws Exception {
+        initializeSubject();
+
+        boolean result = getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionDown(0, 0));
+
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void onPrepared_whenDurationIsLessThanMaxVideoDurationForCloseButton_shouldSetShowCloseButtonDelayToDuration() throws Exception {
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, 1000);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(1000);
+    }
+
+    @Test
+    public void onPrepared_whenDurationIsGreaterThanMaxVideoDurationForCloseButton_shouldNotSetShowCloseButtonDelay() throws Exception {
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
+    }
+
+    @Test
+    public void onPrepared_whenPercentSkipOffsetSpecified_shouldSetShowCloseButtonDelayToSkipOffset() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("25%");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, 10000);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(2500);
+        assertThat(subject.getHasSkipOffset()).isTrue();
+    }
+
+    @Test
+    public void onPrepared_whenAbsoluteSkipOffsetSpecified_shouldSetShowCloseButtonDelayToSkipOffset() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("00:00:03");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, 10000);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(3000);
+        assertThat(subject.getHasSkipOffset()).isTrue();
+    }
+
+    @Test
+    public void onPrepared_whenAbsoluteSkipOffsetWithMillisecondsSpecified_shouldSetShowCloseButtonDelayToSkipOffset() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("00:00:03.141");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, 10000);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(3141);
+        assertThat(subject.getHasSkipOffset()).isTrue();
+    }
+
+    @Test
+    public void onPrepared_whenSkipOffsetIsNull_shouldNotSetShowCloseButtonDelay() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset(null);
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
+        assertThat(subject.getHasSkipOffset()).isFalse();
+    }
+
+    @Test
+    public void onPrepared_whenSkipOffsetHasInvalidAbsoluteFormat_shouldNotSetShowCloseButtonDelay() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("123:4:56.7");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
+        assertThat(subject.getHasSkipOffset()).isFalse();
+    }
+
+    @Test
+    public void onPrepared_whenSkipOffsetHasInvalidPercentFormat_shouldNotSetShowCloseButtonDelay() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("101%");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
+        assertThat(subject.getHasSkipOffset()).isFalse();
+    }
+
+    @Test
+    public void onPrepared_whenSkipOffsetHasInvalidFractionalPercentFormat_shouldNotSetShowCloseButtonDelay() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("3.14%");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
+        assertThat(subject.getHasSkipOffset()).isFalse();
+    }
+
+    @Test
+    public void onPrepared_whenSkipOffsetIsNegative_shouldNotSetShowCloseButtonDelay() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("-00:00:03");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
+        assertThat(subject.getHasSkipOffset()).isFalse();
+    }
+
+    @Test
+    public void onPrepared_whenSkipOffsetIsZero_shouldSetShowCloseButtonDelayToZero() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("00:00:00");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(0);
+        assertThat(subject.getHasSkipOffset()).isTrue();
+    }
+
+    @Test
+    public void onPrepared_whenSkipOffsetIsLongerThanDurationForShortVideo_shouldNotSetShowCloseButtonDelay() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("00:00:11");   // 11s
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, 10000);    // 10s: short video
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(10 * 1000);
+        assertThat(subject.getHasSkipOffset()).isFalse();
+    }
+
+    @Test
+    public void onPrepared_whenSkipOffsetIsLongerThanDurationForLongVideo_shouldNotSetShowCloseButtonDelay() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("00:00:21");   // 21s
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, 20000);    // 20s: long video
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
+        assertThat(subject.getHasSkipOffset()).isFalse();
+    }
+
+    @Test
+    public void onCompletion_shouldMarkVideoAsFinished() throws Exception {
+        initializeSubject();
+
+        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+
+        assertThat(subject.isVideoFinishedPlaying()).isTrue();
+    }
+
+    @Test
+    public void onCompletion_whenAllTrackersTracked_whenNoPlaybackErrors_shouldPingCompletionTrackersOnlyOnce() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        VastAbsoluteProgressTracker testTracker = new VastAbsoluteProgressTracker("testUrl", 123);
+        vastVideoConfiguration.addAbsoluteTrackers(Arrays.asList(testTracker));
+        vastVideoConfiguration.addCompleteTrackers(Arrays.asList("complete_1", "complete_2"));
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        testTracker.setTracked();
+
+        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+        verify(mockRequestQueue).add(argThat(isUrl("complete_1")));
+        verify(mockRequestQueue).add(argThat(isUrl("complete_2")));
+
+        // Completion trackers should still only be hit once
+        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+        verify(mockRequestQueue).add(argThat(isUrl("complete_1")));
+        verify(mockRequestQueue).add(argThat(isUrl("complete_2")));
+    }
+
+    @Test
+    public void onCompletion_whenSomeTrackersRemain_shouldNotPingCompletionTrackers() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.addCompleteTrackers(Arrays.asList("complete_1", "complete_2"));
+        VastAbsoluteProgressTracker testTracker = new VastAbsoluteProgressTracker("testUrl", 123);
+        // Never track the testTracker, so completion trackers should not be fired.
+        vastVideoConfiguration.addAbsoluteTrackers(Arrays.asList(testTracker));
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+
+        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+        verify(mockRequestQueue, never()).add(argThat(isUrl("complete_1")));
+        verify(mockRequestQueue, never()).add(argThat(isUrl("complete_2")));
+    }
+
+    @Test
+    public void onCompletion_whenPlaybackError_shouldNotPingCompletionTrackers() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.addCompleteTrackers(Arrays.asList("complete_1", "complete_2"));
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        subject.setVideoError();
+
+        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+        verify(mockRequestQueue, never()).add(argThat(isUrl("complete_1")));
+        verify(mockRequestQueue, never()).add(argThat(isUrl("complete_2")));
+    }
+
+    @Test
+    public void onCompletion_shouldPreventOnResumeFromStartingVideo() throws Exception {
+        initializeSubject();
+
+        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+
+        subject.onResume();
+
+        assertThat(getShadowVideoView().isPlaying()).isFalse();
+    }
+
+    @Test
+    public void onCompletion_shouldStopProgressCheckerAndCountdown() throws Exception {
+        initializeSubject();
+        subject.onResume();
+
+        reset(spyCountdownRunnable, spyCountdownRunnable);
+
+        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+
+        verify(spyCountdownRunnable).stop();
+        verify(spyProgressRunnable).stop();
+    }
+
+    @Test
+    public void onCompletion_shouldDisplayCompanionAdIfAvailable() throws Exception {
+        initializeSubject();
+        subject.onCreate();
+
+        Robolectric.getBackgroundScheduler().unPause();
+        Robolectric.getUiThreadScheduler().unPause();
+        Thread.sleep(NETWORK_DELAY);
+
+        final ImageView imageView = subject.getCompanionAdImageView();
+
+        assertThat(subject.getVideoView().getVisibility()).isEqualTo(View.VISIBLE);
+        assertThat(imageView.getVisibility()).isEqualTo(View.INVISIBLE);
+
+        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+
+        assertThat(subject.getVideoView().getVisibility()).isEqualTo(View.GONE);
+        assertThat(imageView.getVisibility()).isEqualTo(View.VISIBLE);
+        assertThat(shadowOf(((BitmapDrawable) imageView.getDrawable()).getBitmap()).getCreatedFromBytes()).isEqualTo("body".getBytes());
+    }
+
+    @Test
+    public void onCompletion_shouldShowThatchedBackground() throws Exception {
+        initializeSubject();
+
+        final ImageView imageView = subject.getCompanionAdImageView();
+
+        assertThat(subject.getVideoView().getVisibility()).isEqualTo(View.VISIBLE);
+        assertThat(imageView.getVisibility()).isEqualTo(View.INVISIBLE);
+
+        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+
+        assertThat(subject.getVideoView().getVisibility()).isEqualTo(View.GONE);
+        assertThat(imageView.getVisibility()).isEqualTo(View.INVISIBLE);
+    }
+
+    @Test
+    public void onError_shouldFireVideoErrorAndReturnFalse() throws Exception {
+        initializeSubject();
+
+        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_FAIL, testBroadcastIdentifier);
+
+        boolean result = getShadowVideoView().getOnErrorListener().onError(null, 0, 0);
+        Robolectric.getUiThreadScheduler().unPause();
+
+        assertThat(result).isFalse();
+        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
+        assertThat(subject.getVideoError()).isTrue();
+    }
+
+    @Test
+    public void onError_shouldStopProgressChecker() throws Exception {
+        initializeSubject();
+        subject.onResume();
+
+        verify(spyProgressRunnable).startRepeating(anyLong());
+        verify(spyCountdownRunnable).startRepeating(anyLong());
+        reset(spyProgressRunnable, spyCountdownRunnable);
+        getShadowVideoView().getOnErrorListener().onError(null, 0, 0);
+
+        verify(spyProgressRunnable).stop();
+        verify(spyCountdownRunnable).stop();
+    }
+
+    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH_MR1)
+    @Test
+    public void onError_withVideoFilePermissionErrorBelowJellyBean_shouldRetryPlayingTheVideo() throws Exception {
+        File file = new File("disk_video_path");
+        file.createNewFile();
+
+        initializeSubject();
+
+        assertThat(getShadowVideoView().getCurrentVideoState()).isEqualTo(-1);
+
+        assertThat(subject.getVideoRetries()).isEqualTo(0);
+        getShadowVideoView().getOnErrorListener().onError(new MediaPlayer(), 1, Integer.MIN_VALUE);
+
+        assertThat(getShadowVideoView().isPlaying()).isTrue();
+        assertThat(subject.getVideoRetries()).isEqualTo(1);
+
+        file.delete();
+    }
+
+    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH_MR1)
+    @Test
+    public void retryMediaPlayer_withVideoFilePermissionErrorAndBelowJellyBean_shouldReturnTrue() throws Exception {
+        File file = new File("disk_video_path");
+        file.createNewFile();
+
+        initializeSubject();
+
+        assertThat(subject.getVideoRetries()).isEqualTo(0);
+        assertThat(subject.retryMediaPlayer(new MediaPlayer(), 1, Integer.MIN_VALUE)).isTrue();
+        assertThat(subject.getVideoRetries()).isEqualTo(1);
+
+        file.delete();
+    }
+
+    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH_MR1)
+    @Test
+    public void retryMediaPlayer_shouldNotRunMoreThanOnce() throws Exception {
+        File file = new File("disk_video_path");
+        file.createNewFile();
+
+        initializeSubject();
+
+        assertThat(subject.getVideoRetries()).isEqualTo(0);
+        assertThat(subject.retryMediaPlayer(new MediaPlayer(), 1, Integer.MIN_VALUE)).isTrue();
+        assertThat(subject.getVideoRetries()).isEqualTo(1);
+
+        assertThat(subject.retryMediaPlayer(new MediaPlayer(), 1, Integer.MIN_VALUE)).isFalse();
+        assertThat(subject.getVideoRetries()).isEqualTo(1);
+
+        file.delete();
+    }
+
+    @Config(reportSdk = VERSION_CODES.JELLY_BEAN)
+    @Test
+    public void retryMediaPlayer_withAndroidVersionAboveJellyBean_shouldReturnFalse() throws Exception {
+        File file = new File("disk_video_path");
+        file.createNewFile();
+
+        initializeSubject();
+
+        assertThat(subject.getVideoRetries()).isEqualTo(0);
+        assertThat(subject.retryMediaPlayer(new MediaPlayer(), 1, Integer.MIN_VALUE)).isFalse();
+        assertThat(subject.getVideoRetries()).isEqualTo(0);
+
+        file.delete();
+    }
+
+    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Test
+    public void retryMediaPlayer_withOtherVideoError_shouldReturnFalse() throws Exception {
+        File file = new File("disk_video_path");
+        file.createNewFile();
+
+        initializeSubject();
+
+        assertThat(subject.getVideoRetries()).isEqualTo(0);
+        assertThat(subject.retryMediaPlayer(new MediaPlayer(), 2, Integer.MIN_VALUE)).isFalse();
+        assertThat(subject.getVideoRetries()).isEqualTo(0);
+
+        file.delete();
+    }
+
+    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Test
+    public void retryMediaPlayer_withExceptionThrown_shouldReturnFalseAndIncrementRetryCount() throws Exception {
+        File file = new File("disk_video_path");
+        if (file.exists()) {
+            assertThat(file.delete()).isTrue();
+        }
+
+        initializeSubject();
+
+        assertThat(subject.getVideoRetries()).isEqualTo(0);
+        assertThat(subject.retryMediaPlayer(new MediaPlayer(), 1, Integer.MIN_VALUE)).isFalse();
+        assertThat(subject.getVideoRetries()).isEqualTo(1);
+    }
+
+    @Test
+    public void handleClick_shouldMakeRequestsToClickTrackingUrls() throws Exception {
+        initializeSubject();
+        subject.handleClick(Arrays.asList("clicktracker1", "clicktracker2"), CLICKTHROUGH_URL);
+
+        verify(mockRequestQueue).add(argThat(isUrl("clicktracker1")));
+        verify(mockRequestQueue).add(argThat(isUrl("clicktracker2")));
+    }
+
+    @Test
+    public void handleClick_withNullClickTrackers_shouldNotThrowAnException() throws Exception {
+        initializeSubject();
+        subject.handleClick(null, CLICKTHROUGH_URL);
+
+        // pass
+    }
+
+    @Test
+    public void handleClick_withNullClickThroughUrl_shouldNotBroadcastClickOrOpenNewActivity() throws Exception {
+        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_CLICK, testBroadcastIdentifier);
+
+        initializeSubject();
+        subject.handleClick(Arrays.asList("clicktracker"), null);
+
+        Robolectric.getUiThreadScheduler().unPause();
+        verify(broadcastReceiver, never()).onReceive(any(Context.class), eq(expectedIntent));
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+    }
+
+    @Test
+    public void handleClick_withMoPubNativeBrowserClickThroughUrl_shouldOpenExternalBrowser() throws Exception {
+        initializeSubject();
+
+        subject.handleClick(Arrays.asList("clicktracker"),
+                "mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.mopub.com");
+
+        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(intent.getDataString()).isEqualTo("http://www.mopub.com");
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
+    }
+
+    @Test
+    public void handleClick_withMalformedMoPubNativeBrowserClickThroughUrl_shouldNotOpenANewActivity() throws Exception {
+        initializeSubject();
+
+        // url2 is an invalid query parameter
+        subject.handleClick(Arrays.asList("clicktracker"),
+                "mopubnativebrowser://navigate?url2=http%3A%2F%2Fwww.mopub.com");
+
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+    }
+
+    @Test
+    public void handleClick_withAboutBlankClickThroughUrl_shouldFailSilently() throws Exception {
+        initializeSubject();
+
+        subject.handleClick(Arrays.asList("clicktracker"), "about:blank");
+
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+    }
+
+    @Test
+    public void videoRunnablesRun_shouldFireOffAllProgressTrackers() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("first", 0.25f),
+                new VastFractionalProgressTracker("second", 0.5f),
+                new VastFractionalProgressTracker("third", 0.75f)));
+
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(9002, 9002);
+        subject.onResume();
+
+        // this runs the videoProgressChecker and countdown runnable
+        Robolectric.getUiThreadScheduler().unPause();
+
+        verify(mockRequestQueue).add(argThat(isUrl("first")));
+        verify(mockRequestQueue).add(argThat(isUrl("second")));
+        verify(mockRequestQueue).add(argThat(isUrl("third")));
+    }
+
+    @Test
+    public void getUntriggeredTrackersBefore_endOfVideo_shouldReturnAllTrackers() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("first", 0.25f),
+                new VastFractionalProgressTracker("second", 0.5f),
+                new VastFractionalProgressTracker("third", 0.75f)));
+        vastVideoConfiguration.addAbsoluteTrackers(Arrays.asList(new VastAbsoluteProgressTracker("1secs", 1000), new VastAbsoluteProgressTracker("10secs", 10000)));
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(11000, 11000);
+
+        final List<VastTracker> untriggeredTrackers = subject.getUntriggeredTrackersBefore(11000, 11000);
+        assertThat(untriggeredTrackers).hasSize(5);
+
+        // Sorted absolute trackers, followed by sorted fractional trackers
+        final VastTracker tracker0 = untriggeredTrackers.get(0);
+        assertThat(tracker0).isExactlyInstanceOf(VastAbsoluteProgressTracker.class);
+        assertThat(((VastAbsoluteProgressTracker) tracker0).getTrackingMilliseconds()).isEqualTo(1000);
+
+        final VastTracker tracker1 = untriggeredTrackers.get(1);
+        assertThat(tracker1).isExactlyInstanceOf(VastAbsoluteProgressTracker.class);
+        assertThat(((VastAbsoluteProgressTracker) tracker1).getTrackingMilliseconds()).isEqualTo(10000);
+
+
+        final VastTracker tracker2 = untriggeredTrackers.get(2);
+        assertThat(tracker2).isExactlyInstanceOf(VastFractionalProgressTracker.class);
+        assertThat(((VastFractionalProgressTracker) tracker2).trackingFraction()).isEqualTo(0.25f);
+
+        final VastTracker tracker3 = untriggeredTrackers.get(3);
+        assertThat(tracker3).isExactlyInstanceOf(VastFractionalProgressTracker.class);
+        assertThat(((VastFractionalProgressTracker) tracker3).trackingFraction()).isEqualTo(0.5f);
+
+        final VastTracker tracker4 = untriggeredTrackers.get(4);
+        assertThat(tracker4).isExactlyInstanceOf(VastFractionalProgressTracker.class);
+        assertThat(((VastFractionalProgressTracker) tracker4).trackingFraction()).isEqualTo(0.75f);
+    }
+
+    @Test
+    public void getUntriggeredTrackersBefore_withTriggeredTrackers_shouldNotReturnTriggered() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("first", 0.25f),
+                new VastFractionalProgressTracker("second", 0.5f),
+                new VastFractionalProgressTracker("third", 0.75f)));
+        vastVideoConfiguration.addAbsoluteTrackers(Arrays.asList(new VastAbsoluteProgressTracker("5secs", 5000), new VastAbsoluteProgressTracker("10secs", 10000)));
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(11000, 11000);
+
+        final List<VastTracker> untriggeredTrackers = subject.getUntriggeredTrackersBefore(11000, 11000);
+        assertThat(untriggeredTrackers).hasSize(5);
+        untriggeredTrackers.get(0).setTracked();
+
+        final List<VastTracker> secondTrackersList = subject.getUntriggeredTrackersBefore(11000, 11000);
+        assertThat(secondTrackersList).hasSize(4);
+    }
+
+    @Test
+    public void videoRunnablesRun_whenDurationIsInvalid_shouldNotMakeAnyNetworkCalls() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(0, 100);
+
+        subject.onResume();
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
+
+        Robolectric.getUiThreadScheduler().runTasks(2);
+        // make sure the repeated task hasn't run yet
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
+        verifyZeroInteractions(mockRequestQueue);
+    }
+
+    @Test
+    public void videoRunnablesRun_whenCurrentTimeLessThanTwoSeconds_shouldNotFireStartTracker() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.addAbsoluteTrackers(Arrays.asList(new VastAbsoluteProgressTracker("start", 2000)));
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(1999, 100000);
+        subject.onResume();
+
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
+
+        Robolectric.getUiThreadScheduler().runTasks(2);
+        // make sure the repeated task hasn't run yet
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
+
+        // Since it has not yet been a second, we expect that the start tracker has not been fired
+        verifyZeroInteractions(mockRequestQueue);
+
+        // run checker another time
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
+        Robolectric.getUiThreadScheduler().runTasks(2);
+
+        verifyZeroInteractions(mockRequestQueue);
+    }
+
+    @Test
+    public void videoRunnablesRun_whenCurrentTimeGreaterThanTwoSeconds_shouldFireStartTracker() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.addAbsoluteTrackers(Arrays.asList(new VastAbsoluteProgressTracker("start", 2000)));
+        vastVideoConfiguration.addAbsoluteTrackers(Arrays.asList(new VastAbsoluteProgressTracker("later", 3000)));
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(2000, 100000);
+        subject.onResume();
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
+
+        Robolectric.getUiThreadScheduler().unPause();
+
+        verify(mockRequestQueue).add(argThat(isUrl("start")));
+
+        // run checker another time
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
+        Robolectric.getUiThreadScheduler().runTasks(2);
+
+        verifyNoMoreInteractions(mockRequestQueue);
+    }
+
+    @Test
+    public void videoRunnablesRun_whenProgressIsPastFirstQuartile_shouldOnlyPingFirstQuartileTrackersOnce() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("first", 0.25f)));
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("don't call", 0.28f)));
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(26, 100);
+        subject.onResume();
+
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
+
+        Robolectric.getUiThreadScheduler().unPause();
+
+        verify(mockRequestQueue).add(argThat(isUrl("first")));
+
+        // run checker another time
+        Robolectric.getUiThreadScheduler().runTasks(2);
+
+        verifyNoMoreInteractions(mockRequestQueue);
+    }
+
+    @Test
+    public void videoRunnablesRun_whenProgressIsPastMidQuartile_shouldPingFirstQuartileTrackers_andMidQuartileTrackersBothOnlyOnce() throws Exception {
+
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("first", 0.25f)));
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("second", 0.5f)));
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(51, 100);
+
+        subject.onResume();
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
+
+        Robolectric.getUiThreadScheduler().unPause();
+
+        verify(mockRequestQueue).add(argThat(isUrl("first")));
+        verify(mockRequestQueue).add(argThat(isUrl("second")));
+
+        Robolectric.getUiThreadScheduler().runTasks(2);
+
+        verifyNoMoreInteractions(mockRequestQueue);
+    }
+
+    @Test
+    public void videoRunnablesRun_whenProgressIsPastThirdQuartile_shouldPingFirstQuartileTrackers_andMidQuartileTrackers_andThirdQuartileTrackersAllOnlyOnce() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("first", 0.25f)));
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("second", 0.5f)));
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("third", 0.75f)));
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(76, 100);
+
+        subject.onResume();
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
+
+        Robolectric.getUiThreadScheduler().unPause();
+
+        verify(mockRequestQueue).add(argThat(isUrl("first")));
+        verify(mockRequestQueue).add(argThat(isUrl("second")));
+        verify(mockRequestQueue).add(argThat(isUrl("third")));
+
+        Robolectric.getUiThreadScheduler().runTasks(2);
+
+        verifyNoMoreInteractions(mockRequestQueue);
+    }
+
+    @Test
+    public void videoRunnablesRun_asVideoPlays_shouldPingAllThreeTrackersIndividuallyOnce() throws Exception {
+        //stub(mockMediaPlayer.getDuration()).toReturn(100);
+
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("first", 0.25f)));
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("second", 0.5f)));
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("third", 0.75f)));
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        when(spyVideoView.getDuration()).thenReturn(100);
+        subject.onResume();
+
+        // before any trackers are fired
+        seekToAndAssertRequestsMade(1);
+
+        seekToAndAssertRequestsMade(24);
+
+        // after it hits first tracker
+        seekToAndAssertRequestsMade(26, "first");
+
+        // before mid quartile is hit
+        seekToAndAssertRequestsMade(49);
+
+        // after it hits mid trackers
+        seekToAndAssertRequestsMade(51, "second");
+
+        // before third quartile is hit
+        seekToAndAssertRequestsMade(74);
+
+        // after third quartile is hit
+        seekToAndAssertRequestsMade(76, "third");
+
+        // way after third quartile is hit
+        seekToAndAssertRequestsMade(99);
+    }
+
+    private void seekToAndAssertRequestsMade(int position, String... trackingUrls) {
+        when(spyVideoView.getCurrentPosition()).thenReturn(position);
+
+        for (String url : trackingUrls) {
+            Robolectric.getUiThreadScheduler().unPause();
+            verify(mockRequestQueue).add(argThat(isUrl(url)));
+        }
+    }
+
+    @Test
+    public void videoRunnablesRun_whenCurrentPositionIsGreaterThanShowCloseButtonDelay_shouldShowCloseButton() throws Exception {
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(5001, 5002);
+        subject.onResume();
+
+        assertThat(subject.isShowCloseButtonEventFired()).isFalse();
+        Robolectric.getUiThreadScheduler().unPause();
+
+        assertThat(subject.isShowCloseButtonEventFired()).isTrue();
+    }
+
+    @Test
+    public void videoRunnablesRun_whenCurrentPositionIsGreaterThanSkipOffset_shouldShowCloseButton() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("25%");    // skipoffset is at 2.5s
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(2501, 10000); // duration is 10s, current position is 1ms after skipoffset
+        subject.onResume();
+
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(2500);
+        assertThat(subject.getHasSkipOffset()).isTrue();
+
+        assertThat(subject.isShowCloseButtonEventFired()).isFalse();
+        Robolectric.getUiThreadScheduler().unPause();
+
+        assertThat(subject.isShowCloseButtonEventFired()).isTrue();
+    }
+
+    @Test
+    public void videoRunnablesRun_whenCurrentPositionIsLessThanSkipOffset_shouldNotShowCloseButton() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("00:00:03");   // skipoffset is at 3s
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(2999, 10000); // duration is 10s, current position is 1ms before skipoffset
+        subject.onResume();
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(3000);
+        assertThat(subject.getHasSkipOffset()).isTrue();
+
+        assertThat(subject.isShowCloseButtonEventFired()).isFalse();
+        Robolectric.getUiThreadScheduler().unPause();
+
+        assertThat(subject.isShowCloseButtonEventFired()).isFalse();
+    }
+
+    @Test
+    public void onPause_shouldStopRunnables() throws Exception {
+        initializeSubject();
+
+        subject.onResume();
+        verify(spyCountdownRunnable).startRepeating(anyLong());
+        verify(spyProgressRunnable).startRepeating(anyLong());
+
+        subject.onPause();
+        verify(spyCountdownRunnable).stop();
+        verify(spyProgressRunnable).stop();
+    }
+
+    @Test
+    public void onResume_shouldStartRunnables() throws Exception {
+        initializeSubject();
+
+        subject.onPause();
+        verify(spyCountdownRunnable).stop();
+        verify(spyProgressRunnable).stop();
+
+        subject.onResume();
+        verify(spyCountdownRunnable).startRepeating(anyLong());
+        verify(spyProgressRunnable).startRepeating(anyLong());
+    }
+
+    @Test
+    public void onResume_shouldSetVideoViewStateToStarted() throws Exception {
+        initializeSubject();
+
+        subject.onResume();
+
+        assertThat(getShadowVideoView().getCurrentVideoState()).isEqualTo(ShadowVideoView.START);
+        assertThat(getShadowVideoView().getPrevVideoState()).isNotEqualTo(ShadowVideoView.START);
+    }
+
+    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH_MR1)
+    @Test
+    public void onResume_shouldResetVideoRetryCountToZero() throws Exception {
+        File file = new File("disk_video_path");
+        file.createNewFile();
+
+        initializeSubject();
+
+        assertThat(subject.retryMediaPlayer(new MediaPlayer(), 1, Integer.MIN_VALUE)).isTrue();
+        assertThat(subject.getVideoRetries()).isEqualTo(1);
+
+        subject.onResume();
+        assertThat(subject.getVideoRetries()).isEqualTo(0);
+
+        file.delete();
+    }
+
+    @Test
+    public void onResume_shouldSeekToPrePausedPosition() throws Exception {
+        initializeSubject();
+        spyOnVideoView();
+        setVideoViewParams(7000, 10000);
+
+        subject.onPause();
+
+        setVideoViewParams(1000, 10000);
+
+        subject.onResume();
+        verify(spyVideoView).seekTo(eq(7000));
+    }
+
+    @Test
+    public void backButtonEnabled_shouldDefaultToFalse() throws Exception {
+        initializeSubject();
+
+        assertThat(subject.backButtonEnabled()).isFalse();
+    }
+
+    @Test
+    public void backButtonEnabled_whenCloseButtonIsVisible_shouldReturnTrue() throws Exception {
+        initializeSubject();
+
+        subject.setCloseButtonVisible(true);
+
+        assertThat(subject.backButtonEnabled()).isTrue();
+    }
+
+    @Test
+    public void onClickCloseButton_whenCloseButtonIsVisible_shouldFireCloseTrackers() throws Exception {
+        initializeSubject();
+
+        subject.setCloseButtonVisible(true);
+
+        // We don't have direct access to the CloseButtonWidget's close event, so we manually
+        // invoke its onTouchListener's onTouch callback with a fake MotionEvent.ACTION_UP action.
+        View.OnTouchListener closeButtonOnTouchListener =
+                shadowOf(getVastVideoToolbar().getCloseButtonWidget()).getOnTouchListener();
+        closeButtonOnTouchListener.onTouch(null, GestureUtils.createActionUp(0, 0));
+
+        verify(mockRequestQueue).add(argThat(isUrl("close")));
+        verify(mockRequestQueue).add(argThat(isUrl("skip")));
+    }
+
+    private void initializeSubject() throws IllegalAccessException {
+        subject = new VastVideoViewController(context, bundle, testBroadcastIdentifier, baseVideoViewControllerListener);
+        spyOnRunnables();
+    }
+
+    private void spyOnVideoView() throws IllegalAccessException {
+        spyVideoView = spy(subject.getVideoView());
+        ReflectionUtils.setVariableValueInObject(subject, "mVideoView", spyVideoView);
+    }
+
+    private void spyOnRunnables() throws IllegalAccessException {
+        final VastVideoViewProgressRunnable progressCheckerRunnable = (VastVideoViewProgressRunnable) ReflectionUtils.getValueIncludingSuperclasses("mProgressCheckerRunnable", subject);
+        spyProgressRunnable = spy(progressCheckerRunnable);
+
+        final VastVideoViewCountdownRunnable countdownRunnable = (VastVideoViewCountdownRunnable) ReflectionUtils.getValueIncludingSuperclasses("mCountdownRunnable", subject);
+        spyCountdownRunnable = spy(countdownRunnable);
+
+        ReflectionUtils.setVariableValueInObject(subject, "mProgressCheckerRunnable", spyProgressRunnable);
+        ReflectionUtils.setVariableValueInObject(subject, "mCountdownRunnable", spyCountdownRunnable);
+    }
+
+    private void setVideoViewParams(int currentPosition, int duration) throws IllegalAccessException {
+        when(spyVideoView.getCurrentPosition()).thenReturn(currentPosition);
+        when(spyVideoView.getDuration()).thenReturn(duration);
+    }
+
+    private VastVideoToolbar getVastVideoToolbar() {
+        final ViewGroup layout = subject.getLayout();
+
+        for (int i = 0; i < layout.getChildCount(); i++) {
+            final View child = layout.getChildAt(i);
+            if (child instanceof VastVideoToolbar) {
+                return (VastVideoToolbar) child;
+            }
+        }
+
+        fail("Unable to find VastVideoToolbar in view hierarchy.");
+        return null;
+    }
+
+    private ShadowVideoView getShadowVideoView() {
+        return shadowOf(subject.getVideoView());
+    }
+
+    public static void assertHttpRequestsMade(final String userAgent, final String... urls) {
+        final int numberOfReceivedHttpRequests = Robolectric.getFakeHttpLayer().getSentHttpRequestInfos().size();
+        assertThat(numberOfReceivedHttpRequests).isEqualTo(urls.length);
+
+        for (final String url : urls) {
+            assertThat(Robolectric.httpRequestWasMade(url)).isTrue();
+        }
+
+        if (userAgent != null) {
+            while (true) {
+                final HttpRequest httpRequest = Robolectric.getNextSentHttpRequest();
+                if (httpRequest == null) {
+                    break;
+                }
+
+                assertThat(httpRequest.getFirstHeader(USER_AGENT.getKey()).getValue())
+                        .isEqualTo(userAgent);
+            }
+        }
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewCountdownRunnableTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewCountdownRunnableTest.java
new file mode 100644
index 00000000..41c78e61
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewCountdownRunnableTest.java
@@ -0,0 +1,68 @@
+package com.mopub.mobileads;
+
+import android.os.Handler;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class VastVideoViewCountdownRunnableTest {
+
+    @Mock VastVideoViewController mockVideoViewController;
+    @Mock Handler mockHandler;
+
+    VastVideoViewCountdownRunnable subject;
+
+    @Before
+    public void setup() {
+        subject = new VastVideoViewCountdownRunnable(mockVideoViewController, mockHandler);
+    }
+
+    @Test
+    public void doWork_whenShouldBeInteractable_shouldCallMakeVideoInteractable() {
+        when(mockVideoViewController.shouldBeInteractable()).thenReturn(true);
+
+        subject.doWork();
+
+        verify(mockVideoViewController).makeVideoInteractable();
+        verify(mockVideoViewController).updateDuration();
+    }
+
+    @Test
+    public void doWork_whenShouldNotBeInteractable_shouldNotCallMakeVideoInteractable() {
+        when(mockVideoViewController.shouldBeInteractable()).thenReturn(false);
+
+        subject.doWork();
+
+        verify(mockVideoViewController, never()).makeVideoInteractable();
+        verify(mockVideoViewController).updateDuration();
+    }
+
+    @Test
+    public void doWork_whenShouldShowCountdown_shouldCallUpdateCountdown() {
+        when(mockVideoViewController.shouldShowCountdown()).thenReturn(true);
+
+        subject.doWork();
+
+        verify(mockVideoViewController).updateCountdown();
+        verify(mockVideoViewController).updateDuration();
+    }
+
+    @Test
+    public void run_whenShouldNotShowCountdown_shouldNotCallUpdateCountdown() {
+        when(mockVideoViewController.shouldShowCountdown()).thenReturn(false);
+
+        subject.doWork();
+
+        verify(mockVideoViewController, never()).updateCountdown();
+        verify(mockVideoViewController).updateDuration();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewProgressRunnableTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewProgressRunnableTest.java
new file mode 100644
index 00000000..b926db3c
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewProgressRunnableTest.java
@@ -0,0 +1,92 @@
+package com.mopub.mobileads;
+
+import android.content.Context;
+import android.os.Handler;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.network.TrackingRequest;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Captor;
+import org.mockito.Mock;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class VastVideoViewProgressRunnableTest {
+    @Mock VastVideoViewController mockVastVideoViewController;
+    @Mock Context mockContext;
+    @Mock Handler mockHandler;
+    @Mock MoPubRequestQueue mockRequestQueue;
+    @Captor ArgumentCaptor<TrackingRequest> requestCaptor;
+    VastVideoViewProgressRunnable subject;
+
+    @Before
+    public void setup() {
+        subject = new VastVideoViewProgressRunnable(mockVastVideoViewController, mockHandler);
+
+        // Request Queue needed to verify tracking requests made.
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+    }
+
+    @Test
+    public void doWork_whenTrackersReturned_shouldMakeTrackingRequests() {
+        List<VastTracker> testTrackers = new ArrayList<VastTracker>();
+        testTrackers.add(new VastAbsoluteProgressTracker("http://example.com/", 1999));
+        testTrackers.add(new VastAbsoluteProgressTracker("http://example1.com/", 2000));
+
+        when(mockVastVideoViewController.getUntriggeredTrackersBefore(eq(3000), eq(4000)))
+                .thenReturn(testTrackers);
+        when(mockVastVideoViewController.getCurrentPosition()).thenReturn(3000);
+        when(mockVastVideoViewController.getDuration()).thenReturn(4000);
+        when(mockVastVideoViewController.getContext()).thenReturn(mockContext);
+
+        subject.doWork();
+
+        verify(mockVastVideoViewController).getUntriggeredTrackersBefore(eq(3000), eq(4000));
+        verify(mockVastVideoViewController).getCurrentPosition();
+        verify(mockVastVideoViewController).getDuration();
+        verify(mockVastVideoViewController).getContext();
+
+        // Capture request queue - should get two different trackers.
+        verify(mockRequestQueue, times(2)).add(requestCaptor.capture());
+        final List<TrackingRequest> allValues = requestCaptor.getAllValues();
+        assertThat(allValues).hasSize(2);
+        assertThat(allValues.get(0).getUrl()).isEqualTo("http://example.com/");
+        assertThat(allValues.get(1).getUrl()).isEqualTo("http://example1.com/");
+
+        verifyNoMoreInteractions(mockVastVideoViewController, mockRequestQueue);
+    }
+
+    @Test
+    public void doWork_whenNoTrackersReturned_shouldNotMakeTrackingRequests() {
+        List<VastTracker> testTrackers = new ArrayList<VastTracker>();
+
+        when(mockVastVideoViewController.getUntriggeredTrackersBefore(eq(3000), eq(4000)))
+                .thenReturn(testTrackers);
+        when(mockVastVideoViewController.getCurrentPosition()).thenReturn(3000);
+        when(mockVastVideoViewController.getDuration()).thenReturn(4000);
+        when(mockVastVideoViewController.getContext()).thenReturn(mockContext);
+
+        subject.doWork();
+
+        verify(mockVastVideoViewController).getUntriggeredTrackersBefore(eq(3000), eq(4000));
+        verify(mockVastVideoViewController).getCurrentPosition();
+        verify(mockVastVideoViewController).getDuration();
+
+        verifyNoMoreInteractions(mockVastVideoViewController, mockRequestQueue);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/WebViewAdUrlGeneratorTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/WebViewAdUrlGeneratorTest.java
index e77cbffc..04a32c07 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/WebViewAdUrlGeneratorTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/WebViewAdUrlGeneratorTest.java
@@ -1,628 +1,631 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.res.Configuration;
-import android.content.res.Resources;
-import android.graphics.Point;
-import android.location.Location;
-import android.location.LocationManager;
-import android.net.ConnectivityManager;
-import android.net.NetworkInfo;
-import android.net.Uri;
-import android.os.Build;
-import android.provider.Settings;
-import android.telephony.TelephonyManager;
-import android.text.TextUtils;
-import android.util.DisplayMetrics;
-import android.view.Display;
-import android.view.WindowManager;
-
-import com.mopub.common.ClientMetadata;
-import com.mopub.common.GpsHelper;
-import com.mopub.common.GpsHelperTest;
-import com.mopub.common.MoPub;
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.Reflection.MethodBuilder;
-import com.mopub.common.util.Utils;
-import com.mopub.common.util.test.support.TestMethodBuilderFactory;
-import com.mopub.mobileads.test.support.MoPubShadowTelephonyManager;
-import com.mopub.mraid.MraidNativeCommandHandler;
-import com.mopub.network.Networking;
-import com.mopub.network.PlayServicesUrlRewriter;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.Robolectric;
-import org.robolectric.annotation.Config;
-import org.robolectric.shadows.ShadowConnectivityManager;
-import org.robolectric.shadows.ShadowLocationManager;
-import org.robolectric.shadows.ShadowNetworkInfo;
-
-import static android.Manifest.permission.ACCESS_NETWORK_STATE;
-import static android.net.ConnectivityManager.TYPE_DUMMY;
-import static android.net.ConnectivityManager.TYPE_ETHERNET;
-import static android.net.ConnectivityManager.TYPE_MOBILE;
-import static android.net.ConnectivityManager.TYPE_MOBILE_DUN;
-import static android.net.ConnectivityManager.TYPE_MOBILE_HIPRI;
-import static android.net.ConnectivityManager.TYPE_MOBILE_MMS;
-import static android.net.ConnectivityManager.TYPE_MOBILE_SUPL;
-import static android.net.ConnectivityManager.TYPE_WIFI;
-import static android.telephony.TelephonyManager.NETWORK_TYPE_UNKNOWN;
-import static com.mopub.common.ClientMetadata.MoPubNetworkType;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.when;
-import static org.robolectric.Robolectric.application;
-import static org.robolectric.Robolectric.shadowOf;
-
-@RunWith(SdkTestRunner.class)
-@Config(shadows = {MoPubShadowTelephonyManager.class})
-public class WebViewAdUrlGeneratorTest {
-
-    private static final String TEST_UDID = "20b013c721c";
-    private static final int TEST_SCREEN_WIDTH = 42;
-    private static final int TEST_SCREEN_HEIGHT = 1337;
-    private static final float TEST_DENSITY = 1.0f;
-
-    private WebViewAdUrlGenerator subject;
-    private String expectedUdid;
-    private Configuration configuration;
-    private MoPubShadowTelephonyManager shadowTelephonyManager;
-    private ShadowConnectivityManager shadowConnectivityManager;
-    private Activity context;
-    private MethodBuilder methodBuilder;
-
-    @Before
-    public void setup() {
-        context = spy(Robolectric.buildActivity(Activity.class).create().get());
-        shadowOf(context).grantPermissions(ACCESS_NETWORK_STATE);
-
-        // Set the expected screen dimensions to arbitrary numbers
-        final Resources spyResources = spy(context.getResources());
-        final DisplayMetrics mockDisplayMetrics = mock(DisplayMetrics.class);
-        mockDisplayMetrics.widthPixels = TEST_SCREEN_WIDTH;
-        mockDisplayMetrics.heightPixels = TEST_SCREEN_HEIGHT;
-        mockDisplayMetrics.density = TEST_DENSITY;
-        when(spyResources.getDisplayMetrics()).thenReturn(mockDisplayMetrics);
-        when(context.getResources()).thenReturn(spyResources);
-
-        // Only do this on Android 17+ because getRealSize doesn't exist before then.
-        // This is the default pathway.
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
-            final WindowManager mockWindowManager = mock(WindowManager.class);
-            final Display mockDisplay = mock(Display.class);
-            doAnswer(new Answer() {
-                @Override
-                public Object answer(final InvocationOnMock invocationOnMock) throws Throwable {
-                    final Point point = (Point) invocationOnMock.getArguments()[0];
-                    point.x = TEST_SCREEN_WIDTH;
-                    point.y = TEST_SCREEN_HEIGHT;
-                    return null;
-                }
-            }).when(mockDisplay).getRealSize(any(Point.class));
-            when(mockWindowManager.getDefaultDisplay()).thenReturn(mockDisplay);
-            final Context spyApplicationContext = spy(context.getApplicationContext());
-            when(spyApplicationContext.getSystemService(Context.WINDOW_SERVICE)).thenReturn(mockWindowManager);
-            when(context.getApplicationContext()).thenReturn(spyApplicationContext);
-        }
-
-        subject = new WebViewAdUrlGenerator(context,
-                new MraidNativeCommandHandler().isStorePictureSupported(context));
-        Settings.Secure.putString(application.getContentResolver(), Settings.Secure.ANDROID_ID, TEST_UDID);
-        expectedUdid = "sha%3A" + Utils.sha1(TEST_UDID);
-        configuration = application.getResources().getConfiguration();
-        shadowTelephonyManager = (MoPubShadowTelephonyManager) shadowOf((TelephonyManager) application.getSystemService(Context.TELEPHONY_SERVICE));
-        shadowConnectivityManager = shadowOf((ConnectivityManager) application.getSystemService(Context.CONNECTIVITY_SERVICE));
-        methodBuilder = TestMethodBuilderFactory.getSingletonMock();
-        Networking.useHttps(false);
-    }
-
-    @After
-    public void tearDown() throws Exception {
-        reset(methodBuilder);
-    }
-
-    @Test
-    public void generateAdUrl_shouldIncludeMinimumFields() throws Exception {
-        String expectedAdUrl = new AdUrlBuilder(expectedUdid).build();
-
-        String adUrl = generateMinimumUrlString();
-
-        assertThat(adUrl).isEqualTo(expectedAdUrl);
-    }
-
-    @Test
-    public void generateAdUrl_withHttpsScheme() throws Exception {
-        Networking.useHttps(true);
-        String adUrl = generateMinimumUrlString();
-        assertThat(adUrl).startsWith("https://");
-    }
-
-    @Test
-    public void generateAdUrl_shouldRunMultipleTimes() throws Exception {
-        String expectedAdUrl = new AdUrlBuilder(expectedUdid).build();
-
-        String adUrl = generateMinimumUrlString();
-        assertThat(adUrl).isEqualTo(expectedAdUrl);
-        adUrl = generateMinimumUrlString();
-        assertThat(adUrl).isEqualTo(expectedAdUrl);
-    }
-
-    @Test
-    public void generateAdUrl_shouldIncludeAllFields() throws Exception {
-        final String expectedAdUrl = new AdUrlBuilder(expectedUdid)
-                .withAdUnitId("adUnitId")
-                .withQuery("key%3Avalue")
-                .withLatLon("20.1%2C30.0", "1", "101325")
-                .withMcc("123")
-                .withMnc("456")
-                .withCountryIso("expected%20country")
-                .withCarrierName("expected%20carrier")
-                .withExternalStoragePermission(false)
-                .build();
-
-        shadowTelephonyManager.setNetworkOperator("123456");
-        shadowTelephonyManager.setNetworkCountryIso("expected country");
-        shadowTelephonyManager.setNetworkOperatorName("expected carrier");
-
-        Location location = new Location("");
-        location.setLatitude(20.1);
-        location.setLongitude(30.0);
-        location.setAccuracy(1.23f); // should get rounded to "1"
-        location.setTime(System.currentTimeMillis() - 101325);
-
-        String adUrl = subject
-                .withAdUnitId("adUnitId")
-                .withKeywords("key:value")
-                .withLocation(location)
-                .generateUrlString("ads.mopub.com");
-
-        // Only compare the seconds since millis can be off
-        adUrl = adUrl.replaceFirst("llf=101[0-9]{3}", "llf=101325");
-
-        assertThat(adUrl).isEqualTo(expectedAdUrl);
-    }
-
-    @Test
-    public void generateAdUrl_shouldRecognizeOrientation() throws Exception {
-        configuration.orientation = Configuration.ORIENTATION_LANDSCAPE;
-        assertThat(generateMinimumUrlString()).contains("&o=l");
-        configuration.orientation = Configuration.ORIENTATION_PORTRAIT;
-        assertThat(generateMinimumUrlString()).contains("&o=p");
-        configuration.orientation = Configuration.ORIENTATION_SQUARE;
-        assertThat(generateMinimumUrlString()).contains("&o=s");
-    }
-
-    @Test
-    public void generateAdUrl_shouldHandleFunkyNetworkOperatorCodes() throws Exception {
-        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
-
-        shadowTelephonyManager.setNetworkOperator("123456");
-        String adUrl = generateMinimumUrlString();
-        assertThat(adUrl).isEqualTo(urlBuilder.withMcc("123").withMnc("456").build());
-
-        ClientMetadata.clearForTesting();
-        shadowTelephonyManager.setNetworkOperator("12345");
-        adUrl = generateMinimumUrlString();
-        assertThat(adUrl).isEqualTo(urlBuilder.withMcc("123").withMnc("45").build());
-
-        ClientMetadata.clearForTesting();
-        shadowTelephonyManager.setNetworkOperator("1234");
-        adUrl = generateMinimumUrlString();
-        assertThat(adUrl).isEqualTo(urlBuilder.withMcc("123").withMnc("4").build());
-
-        ClientMetadata.clearForTesting();
-        shadowTelephonyManager.setNetworkOperator("123");
-        adUrl = generateMinimumUrlString();
-        assertThat(adUrl).isEqualTo(urlBuilder.withMcc("123").withMnc("").build());
-
-        ClientMetadata.clearForTesting();
-        shadowTelephonyManager.setNetworkOperator("12");
-        adUrl = generateMinimumUrlString();
-        assertThat(adUrl).isEqualTo(urlBuilder.withMcc("12").withMnc("").build());
-    }
-
-    @Test
-    public void generateAdUrl_needsAndDoesNotHaveReadPhoneState_shouldNotContainOperatorName() {
-        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
-
-        shadowTelephonyManager.setNeedsReadPhoneState(true);
-        shadowTelephonyManager.setReadPhoneStatePermission(false);
-
-        String adUrl = generateMinimumUrlString();
-        assertThat(adUrl).isEqualTo(urlBuilder.withCarrierName("").build());
-    }
-
-    @Test
-    public void generateAdUrl_needsAndHasReadPhoneState_shouldContainOperatorName() {
-        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
-
-        shadowTelephonyManager.setNeedsReadPhoneState(true);
-        shadowTelephonyManager.setReadPhoneStatePermission(true);
-        shadowTelephonyManager.setNetworkOperatorName("TEST_NAME");
-
-        String adUrl = generateMinimumUrlString();
-        assertThat(adUrl).isEqualTo(urlBuilder.withCarrierName("TEST_NAME").build());
-    }
-
-    @Test
-    public void generateAdUrl_doesNotNeedReadPhoneState_shouldContainOperatorName() {
-        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
-
-        shadowTelephonyManager.setNeedsReadPhoneState(false);
-        shadowTelephonyManager.setReadPhoneStatePermission(false);
-        shadowTelephonyManager.setNetworkOperatorName("TEST_NAME");
-
-        String adUrl = generateMinimumUrlString();
-        assertThat(adUrl).isEqualTo(urlBuilder.withCarrierName("TEST_NAME").build());
-    }
-
-    @Test
-    public void generateAdurl_whenOnCDMA_shouldGetOwnerStringFromSimCard() throws Exception {
-        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
-        shadowTelephonyManager.setPhoneType(TelephonyManager.PHONE_TYPE_CDMA);
-        shadowTelephonyManager.setSimState(TelephonyManager.SIM_STATE_READY);
-        shadowTelephonyManager.setNetworkOperator("123456");
-        shadowTelephonyManager.setSimOperator("789012");
-        String adUrl = generateMinimumUrlString();
-        assertThat(adUrl).isEqualTo(urlBuilder.withMcc("789").withMnc("012").build());
-    }
-
-    @Test
-    public void generateAdurl_whenSimNotReady_shouldDefaultToNetworkOperator() throws Exception {
-        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
-        shadowTelephonyManager.setPhoneType(TelephonyManager.PHONE_TYPE_CDMA);
-        shadowTelephonyManager.setSimState(TelephonyManager.SIM_STATE_ABSENT);
-        shadowTelephonyManager.setNetworkOperator("123456");
-        shadowTelephonyManager.setSimOperator("789012");
-        String adUrl = generateMinimumUrlString();
-        assertThat(adUrl).isEqualTo(urlBuilder.withMcc("123").withMnc("456").build());
-    }
-
-    @Test
-    public void generateAdUrl_shouldSetNetworkType() throws Exception {
-        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
-        String adUrl;
-
-        shadowConnectivityManager.setActiveNetworkInfo(createNetworkInfo(TYPE_DUMMY));
-        adUrl = generateMinimumUrlString();
-        assertThat(adUrl).isEqualTo(urlBuilder.withNetworkType(MoPubNetworkType.UNKNOWN).build());
-
-        shadowConnectivityManager.setActiveNetworkInfo(createNetworkInfo(TYPE_ETHERNET));
-        adUrl = generateMinimumUrlString();
-        assertThat(adUrl).isEqualTo(urlBuilder.withNetworkType(MoPubNetworkType.ETHERNET).build());
-
-        shadowConnectivityManager.setActiveNetworkInfo(createNetworkInfo(TYPE_WIFI));
-        adUrl = generateMinimumUrlString();
-        assertThat(adUrl).isEqualTo(urlBuilder.withNetworkType(MoPubNetworkType.WIFI).build());
-
-        // bunch of random mobile types just to make life more interesting
-        shadowConnectivityManager.setActiveNetworkInfo(createNetworkInfo(TYPE_MOBILE));
-        adUrl = generateMinimumUrlString();
-        assertThat(adUrl).isEqualTo(urlBuilder.withNetworkType(MoPubNetworkType.MOBILE).build());
-
-        shadowConnectivityManager.setActiveNetworkInfo(createNetworkInfo(TYPE_MOBILE_DUN));
-        adUrl = generateMinimumUrlString();
-        assertThat(adUrl).isEqualTo(urlBuilder.withNetworkType(MoPubNetworkType.MOBILE).build());
-
-        shadowConnectivityManager.setActiveNetworkInfo(createNetworkInfo(TYPE_MOBILE_HIPRI));
-        adUrl = generateMinimumUrlString();
-        assertThat(adUrl).isEqualTo(urlBuilder.withNetworkType(MoPubNetworkType.MOBILE).build());
-
-        shadowConnectivityManager.setActiveNetworkInfo(createNetworkInfo(TYPE_MOBILE_MMS));
-        adUrl = generateMinimumUrlString();
-        assertThat(adUrl).isEqualTo(urlBuilder.withNetworkType(MoPubNetworkType.MOBILE).build());
-
-        shadowConnectivityManager.setActiveNetworkInfo(createNetworkInfo(TYPE_MOBILE_SUPL));
-        adUrl = generateMinimumUrlString();
-        assertThat(adUrl).isEqualTo(urlBuilder.withNetworkType(MoPubNetworkType.MOBILE).build());
-    }
-
-    @Test
-    public void generateAdUrl_whenNoNetworkPermission_shouldGenerateUnknownNetworkType() throws Exception {
-        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
-
-        shadowOf(context).denyPermissions(ACCESS_NETWORK_STATE);
-        shadowConnectivityManager.setActiveNetworkInfo(createNetworkInfo(TYPE_MOBILE));
-
-        String adUrl = generateMinimumUrlString();
-
-        assertThat(adUrl).isEqualTo(urlBuilder.withNetworkType(MoPubNetworkType.UNKNOWN).build());
-    }
-
-    @Test
-    public void generateAdUrl_shouldTolerateNullActiveNetwork() throws Exception {
-        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
-        shadowConnectivityManager.setActiveNetworkInfo(null);
-
-        String adUrl = generateMinimumUrlString();
-
-        assertThat(adUrl).isEqualTo(urlBuilder.withNetworkType(MoPubNetworkType.UNKNOWN).build());
-    }
-
-
-
-    @Test
-    public void generateAdUrl_whenGooglePlayServicesIsLinkedAndAdInfoIsCached_shouldUseAdInfoParams() throws Exception {
-        GpsHelper.setClassNamesForTesting();
-        when(methodBuilder.setStatic(any(Class.class))).thenReturn(methodBuilder);
-        when(methodBuilder.addParam(any(Class.class), any())).thenReturn(methodBuilder);
-        when(methodBuilder.execute()).thenReturn(GpsHelper.GOOGLE_PLAY_SUCCESS_CODE);
-
-        GpsHelperTest.TestAdInfo adInfo = new GpsHelperTest.TestAdInfo();
-        final ClientMetadata clientMetadata = ClientMetadata.getInstance(context);
-        clientMetadata.setAdvertisingInfo(adInfo.mAdId, adInfo.mLimitAdTrackingEnabled);
-
-        expectedUdid = "ifa%3A" + adInfo.ADVERTISING_ID;
-        String expectedAdUrl = new AdUrlBuilder(expectedUdid)
-                .withDnt(adInfo.LIMIT_AD_TRACKING_ENABLED)
-                .build();
-        assertThat(generateMinimumUrlString()).isEqualTo(expectedAdUrl);
-    }
-
-    @Test
-    public void generateAdUrl_whenLocationServiceGpsProviderHasMostRecentLocation_shouldUseLocationServiceValue() {
-        Location locationFromDeveloper = new Location("");
-        locationFromDeveloper.setLatitude(42);
-        locationFromDeveloper.setLongitude(-42);
-        locationFromDeveloper.setAccuracy(3.5f);
-        locationFromDeveloper.setTime(1000);
-
-        // Mock out the LocationManager's last known location to be more recent than the
-        // developer-supplied location.
-        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
-                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
-        Location locationFromSdk = new Location("");
-        locationFromSdk.setLatitude(37);
-        locationFromSdk.setLongitude(-122);
-        locationFromSdk.setAccuracy(5.0f);
-        locationFromSdk.setTime(2000);
-        shadowLocationManager.setLastKnownLocation(LocationManager.GPS_PROVIDER, locationFromSdk);
-
-        String adUrl = subject.withLocation(locationFromDeveloper)
-                .generateUrlString("ads.mopub.com");
-        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isEqualTo("37.0,-122.0");
-        assertThat(getParameterFromRequestUrl(adUrl, "lla")).isEqualTo("5");
-        assertThat(getParameterFromRequestUrl(adUrl, "llsdk")).isEqualTo("1");
-    }
-
-    @Test
-    public void generateAdUrl_whenDeveloperSuppliesMoreRecentLocationThanLocationService_shouldUseDeveloperSuppliedLocation() {
-        Location locationFromDeveloper = new Location("");
-        locationFromDeveloper.setLatitude(42);
-        locationFromDeveloper.setLongitude(-42);
-        locationFromDeveloper.setAccuracy(3.5f);
-        locationFromDeveloper.setTime(1000);
-
-        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
-                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
-
-        // Mock out the LocationManager's last known location to be older than the
-        // developer-supplied location.
-        Location olderLocation = new Location("");
-        olderLocation.setLatitude(40);
-        olderLocation.setLongitude(-105);
-        olderLocation.setAccuracy(8.0f);
-        olderLocation.setTime(500);
-        shadowLocationManager.setLastKnownLocation(LocationManager.GPS_PROVIDER, olderLocation);
-
-        String adUrl = subject.withLocation(locationFromDeveloper)
-                .generateUrlString("ads.mopub.com");
-        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isEqualTo("42.0,-42.0");
-        assertThat(getParameterFromRequestUrl(adUrl, "lla")).isEqualTo("3");
-        assertThat(getParameterFromRequestUrl(adUrl, "llsdk")).isEmpty();
-    }
-
-    @Test
-    public void generateAdUrl_whenLocationServiceNetworkProviderHasMostRecentLocation_shouldUseLocationServiceValue() {
-        Location locationFromDeveloper = new Location("");
-        locationFromDeveloper.setLatitude(42);
-        locationFromDeveloper.setLongitude(-42);
-        locationFromDeveloper.setAccuracy(3.5f);
-        locationFromDeveloper.setTime(1000);
-
-        // Mock out the LocationManager's last known location to be more recent than the
-        // developer-supplied location.
-        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
-                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
-        Location locationFromSdk = new Location("");
-        locationFromSdk.setLatitude(38);
-        locationFromSdk.setLongitude(-123);
-        locationFromSdk.setAccuracy(5.0f);
-        locationFromSdk.setTime(2000);
-        shadowLocationManager.setLastKnownLocation(LocationManager.NETWORK_PROVIDER,
-                locationFromSdk);
-
-        String adUrl = subject.withLocation(locationFromDeveloper)
-                .generateUrlString("ads.mopub.com");
-        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isEqualTo("38.0,-123.0");
-        assertThat(getParameterFromRequestUrl(adUrl, "lla")).isEqualTo("5");
-        assertThat(getParameterFromRequestUrl(adUrl, "llsdk")).isEqualTo("1");
-    }
-
-    @Test
-    public void generateAdUrl_withNullPackageName_withEmptyPackageName_shouldNotIncludeBundleKey() {
-        when(context.getPackageName()).thenReturn(null).thenReturn("");
-
-        final String adUrlNullPackageName = generateMinimumUrlString();
-        final String adUrlEmptyPackageName = generateMinimumUrlString();
-
-        assertThat(adUrlNullPackageName).doesNotContain("&bundle=");
-        assertThat(adUrlEmptyPackageName).doesNotContain("&bundle=");
-    }
-
-    @Test
-    public void enableLocationTracking_shouldIncludeLocationInUrl() {
-        MoPub.setLocationAwareness(MoPub.LocationAwareness.NORMAL);
-        String adUrl = generateMinimumUrlString();
-        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isNotNull();
-    }
-
-    @Test
-    public void disableLocationCollection_shouldNotIncludeLocationInUrl() {
-        MoPub.setLocationAwareness(MoPub.LocationAwareness.DISABLED);
-        String adUrl = generateMinimumUrlString();
-        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isNullOrEmpty();
-    }
-
-    @Test
-    public void disableLocationCollection_whenLocationServiceHasMostRecentLocation_shouldNotIncludeLocationInUrl() {
-        MoPub.setLocationAwareness(MoPub.LocationAwareness.DISABLED);
-
-        // Mock out the LocationManager's last known location.
-        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
-                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
-        Location locationFromSdk = new Location("");
-        locationFromSdk.setLatitude(37);
-        locationFromSdk.setLongitude(-122);
-        locationFromSdk.setAccuracy(5.0f);
-        locationFromSdk.setTime(2000);
-        shadowLocationManager.setLastKnownLocation(LocationManager.GPS_PROVIDER, locationFromSdk);
-
-        String adUrl = generateMinimumUrlString();
-        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isNullOrEmpty();
-    }
-
-    private String getParameterFromRequestUrl(String requestString, String key) {
-        Uri requestUri = Uri.parse(requestString);
-        String parameter = requestUri.getQueryParameter(key);
-
-        if (TextUtils.isEmpty(parameter)) {
-            return "";
-        }
-
-        return parameter;
-    }
-
-    private NetworkInfo createNetworkInfo(int type) {
-        return ShadowNetworkInfo.newInstance(null,
-                type,
-                NETWORK_TYPE_UNKNOWN, true, true);
-    }
-
-    private String generateMinimumUrlString() {
-        return subject.generateUrlString("ads.mopub.com");
-    }
-
-    private static class AdUrlBuilder {
-        private String expectedUdid;
-        private String adUnitId = "";
-        private String query = "";
-        private String latLon = "";
-        private String locationAccuracy = "";
-        private String latLonLastUpdated = "";
-        private String mnc = "";
-        private String mcc = "";
-        private String countryIso = "";
-        private String carrierName = "";
-        private String dnt = "";
-        private MoPubNetworkType networkType = MoPubNetworkType.MOBILE;
-        private int externalStoragePermission;
-
-        public AdUrlBuilder(String expectedUdid) {
-            this.expectedUdid = expectedUdid;
-        }
-
-        public String build() {
-            return "http://ads.mopub.com/m/ad" +
-                    "?v=6" +
-                    paramIfNotEmpty("id", adUnitId) +
-                    "&nv=" + MoPub.SDK_VERSION +
-                    "&dn=" + Build.MANUFACTURER +
-                    "%2C" + Build.MODEL +
-                    "%2C" + Build.PRODUCT +
-                    "&bundle=" + "com.mopub.mobileads" +
-
-                    paramIfNotEmpty("q", query) +
-                    (TextUtils.isEmpty(latLon) ? "" :
-                            "&ll=" + latLon + "&lla=" + locationAccuracy + "&llf=" + latLonLastUpdated) +
-                    "&z=-0700" +
-                    "&o=u" +
-                    "&w=" + TEST_SCREEN_WIDTH +
-                    "&h=" + TEST_SCREEN_HEIGHT +
-                    "&sc_a=1.0" +
-                    paramIfNotEmpty("mcc", mcc) +
-                    paramIfNotEmpty("mnc", mnc) +
-                    paramIfNotEmpty("iso", countryIso) +
-                    paramIfNotEmpty("cn", carrierName) +
-                    "&ct=" + networkType +
-                    "&av=1.0" +
-                    "&udid=" + PlayServicesUrlRewriter.UDID_TEMPLATE +
-                    "&dnt=" + PlayServicesUrlRewriter.DO_NOT_TRACK_TEMPLATE +
-                    "&mr=1" +
-                    "&android_perms_ext_storage=" + externalStoragePermission;
-        }
-
-        public AdUrlBuilder withAdUnitId(String adUnitId) {
-            this.adUnitId = adUnitId;
-            return this;
-        }
-
-        public AdUrlBuilder withQuery(String query) {
-            this.query = query;
-            return this;
-        }
-
-        public AdUrlBuilder withLatLon(String latLon, String locationAccuracy,
-                String latLonLastUpdated) {
-            this.latLon = latLon;
-            this.locationAccuracy = locationAccuracy;
-            this.latLonLastUpdated = latLonLastUpdated;
-            return this;
-        }
-
-        public AdUrlBuilder withMcc(String mcc) {
-            this.mcc = mcc;
-            return this;
-        }
-
-        public AdUrlBuilder withMnc(String mnc) {
-            this.mnc = mnc;
-            return this;
-        }
-
-        public AdUrlBuilder withCountryIso(String countryIso) {
-            this.countryIso = countryIso;
-            return this;
-        }
-
-        public AdUrlBuilder withCarrierName(String carrierName) {
-            this.carrierName = carrierName;
-            return this;
-        }
-
-        public AdUrlBuilder withNetworkType(MoPubNetworkType networkType) {
-            this.networkType = networkType;
-            return this;
-        }
-
-        public AdUrlBuilder withExternalStoragePermission(boolean enabled) {
-            this.externalStoragePermission = enabled ? 1 : 0;
-            return this;
-        }
-
-        public AdUrlBuilder withDnt(boolean dnt) {
-            if (dnt) {
-                this.dnt = "1";
-            }
-            return this;
-        }
-
-        private String paramIfNotEmpty(String key, String value) {
-            if (TextUtils.isEmpty(value)) {
-                return "";
-            } else {
-                return "&" + key + "=" + value;
-            }
-        }
-    }
-}
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.res.Configuration;
+import android.content.res.Resources;
+import android.graphics.Point;
+import android.location.Location;
+import android.location.LocationManager;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+import android.net.Uri;
+import android.os.Build;
+import android.provider.Settings;
+import android.telephony.TelephonyManager;
+import android.text.TextUtils;
+import android.util.DisplayMetrics;
+import android.view.Display;
+import android.view.WindowManager;
+
+import com.mopub.common.ClientMetadata;
+import com.mopub.common.GpsHelper;
+import com.mopub.common.GpsHelperTest;
+import com.mopub.common.MoPub;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.Reflection.MethodBuilder;
+import com.mopub.common.util.Utils;
+import com.mopub.common.util.test.support.TestMethodBuilderFactory;
+import com.mopub.mobileads.test.support.MoPubShadowTelephonyManager;
+import com.mopub.mraid.MraidNativeCommandHandler;
+import com.mopub.network.Networking;
+import com.mopub.network.PlayServicesUrlRewriter;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowConnectivityManager;
+import org.robolectric.shadows.ShadowLocationManager;
+import org.robolectric.shadows.ShadowNetworkInfo;
+
+import static android.Manifest.permission.ACCESS_NETWORK_STATE;
+import static android.net.ConnectivityManager.TYPE_DUMMY;
+import static android.net.ConnectivityManager.TYPE_ETHERNET;
+import static android.net.ConnectivityManager.TYPE_MOBILE;
+import static android.net.ConnectivityManager.TYPE_MOBILE_DUN;
+import static android.net.ConnectivityManager.TYPE_MOBILE_HIPRI;
+import static android.net.ConnectivityManager.TYPE_MOBILE_MMS;
+import static android.net.ConnectivityManager.TYPE_MOBILE_SUPL;
+import static android.net.ConnectivityManager.TYPE_WIFI;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_UNKNOWN;
+import static com.mopub.common.ClientMetadata.MoPubNetworkType;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
+import static org.robolectric.Robolectric.application;
+import static org.robolectric.Robolectric.shadowOf;
+
+@RunWith(SdkTestRunner.class)
+@Config(shadows = {MoPubShadowTelephonyManager.class})
+public class WebViewAdUrlGeneratorTest {
+
+    private static final String TEST_UDID = "20b013c721c";
+    private static final int TEST_SCREEN_WIDTH = 42;
+    private static final int TEST_SCREEN_HEIGHT = 1337;
+    private static final float TEST_DENSITY = 1.0f;
+
+    private WebViewAdUrlGenerator subject;
+    private String expectedUdid;
+    private Configuration configuration;
+    private MoPubShadowTelephonyManager shadowTelephonyManager;
+    private ShadowConnectivityManager shadowConnectivityManager;
+    private Activity context;
+    private MethodBuilder methodBuilder;
+
+    @Before
+    public void setup() {
+        context = spy(Robolectric.buildActivity(Activity.class).create().get());
+        shadowOf(context).grantPermissions(ACCESS_NETWORK_STATE);
+
+        // Set the expected screen dimensions to arbitrary numbers
+        final Resources spyResources = spy(context.getResources());
+        final DisplayMetrics mockDisplayMetrics = mock(DisplayMetrics.class);
+        mockDisplayMetrics.widthPixels = TEST_SCREEN_WIDTH;
+        mockDisplayMetrics.heightPixels = TEST_SCREEN_HEIGHT;
+        mockDisplayMetrics.density = TEST_DENSITY;
+        when(spyResources.getDisplayMetrics()).thenReturn(mockDisplayMetrics);
+        when(context.getResources()).thenReturn(spyResources);
+        when(context.getPackageName()).thenReturn("testBundle");
+
+        // Only do this on Android 17+ because getRealSize doesn't exist before then.
+        // This is the default pathway.
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
+            final WindowManager mockWindowManager = mock(WindowManager.class);
+            final Display mockDisplay = mock(Display.class);
+            doAnswer(new Answer() {
+                @Override
+                public Object answer(final InvocationOnMock invocationOnMock) throws Throwable {
+                    final Point point = (Point) invocationOnMock.getArguments()[0];
+                    point.x = TEST_SCREEN_WIDTH;
+                    point.y = TEST_SCREEN_HEIGHT;
+                    return null;
+                }
+            }).when(mockDisplay).getRealSize(any(Point.class));
+            when(mockWindowManager.getDefaultDisplay()).thenReturn(mockDisplay);
+            final Context spyApplicationContext = spy(context.getApplicationContext());
+            when(spyApplicationContext.getSystemService(Context.WINDOW_SERVICE)).thenReturn(mockWindowManager);
+            when(context.getApplicationContext()).thenReturn(spyApplicationContext);
+        }
+
+        subject = new WebViewAdUrlGenerator(context,
+                new MraidNativeCommandHandler().isStorePictureSupported(context));
+        Settings.Secure.putString(application.getContentResolver(), Settings.Secure.ANDROID_ID, TEST_UDID);
+        expectedUdid = "sha%3A" + Utils.sha1(TEST_UDID);
+        configuration = application.getResources().getConfiguration();
+        shadowTelephonyManager = (MoPubShadowTelephonyManager) shadowOf((TelephonyManager) application.getSystemService(Context.TELEPHONY_SERVICE));
+        shadowConnectivityManager = shadowOf((ConnectivityManager) application.getSystemService(Context.CONNECTIVITY_SERVICE));
+        methodBuilder = TestMethodBuilderFactory.getSingletonMock();
+        Networking.useHttps(false);
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        reset(methodBuilder);
+    }
+
+    @Test
+    public void generateAdUrl_shouldIncludeMinimumFields() throws Exception {
+        String expectedAdUrl = new AdUrlBuilder(expectedUdid).build();
+
+        String adUrl = generateMinimumUrlString();
+
+        assertThat(adUrl).isEqualTo(expectedAdUrl);
+    }
+
+    @Test
+    public void generateAdUrl_withHttpsScheme() throws Exception {
+        Networking.useHttps(true);
+        String adUrl = generateMinimumUrlString();
+        assertThat(adUrl).startsWith("https://");
+    }
+
+    @Test
+    public void generateAdUrl_shouldRunMultipleTimes() throws Exception {
+        String expectedAdUrl = new AdUrlBuilder(expectedUdid).build();
+
+        String adUrl = generateMinimumUrlString();
+        assertThat(adUrl).isEqualTo(expectedAdUrl);
+        adUrl = generateMinimumUrlString();
+        assertThat(adUrl).isEqualTo(expectedAdUrl);
+    }
+
+    @Test
+    public void generateAdUrl_shouldIncludeAllFields() throws Exception {
+        final String expectedAdUrl = new AdUrlBuilder(expectedUdid)
+                .withAdUnitId("adUnitId")
+                .withQuery("key%3Avalue")
+                .withLatLon("20.1%2C30.0", "1", "101325")
+                .withMcc("123")
+                .withMnc("456")
+                .withCountryIso("expected%20country")
+                .withCarrierName("expected%20carrier")
+                .withExternalStoragePermission(false)
+                .build();
+
+        shadowTelephonyManager.setNetworkOperator("123456");
+        shadowTelephonyManager.setNetworkCountryIso("expected country");
+        shadowTelephonyManager.setNetworkOperatorName("expected carrier");
+
+        Location location = new Location("");
+        location.setLatitude(20.1);
+        location.setLongitude(30.0);
+        location.setAccuracy(1.23f); // should get rounded to "1"
+        location.setTime(System.currentTimeMillis() - 101325);
+
+        String adUrl = subject
+                .withAdUnitId("adUnitId")
+                .withKeywords("key:value")
+                .withLocation(location)
+                .generateUrlString("ads.mopub.com");
+
+        // Only compare the seconds since millis can be off
+        adUrl = adUrl.replaceFirst("llf=101[0-9]{3}", "llf=101325");
+
+        assertThat(adUrl).isEqualTo(expectedAdUrl);
+    }
+
+    @Test
+    public void generateAdUrl_shouldRecognizeOrientation() throws Exception {
+        configuration.orientation = Configuration.ORIENTATION_LANDSCAPE;
+        assertThat(generateMinimumUrlString()).contains("&o=l");
+        configuration.orientation = Configuration.ORIENTATION_PORTRAIT;
+        assertThat(generateMinimumUrlString()).contains("&o=p");
+        configuration.orientation = Configuration.ORIENTATION_SQUARE;
+        assertThat(generateMinimumUrlString()).contains("&o=s");
+    }
+
+    @Test
+    public void generateAdUrl_shouldHandleFunkyNetworkOperatorCodes() throws Exception {
+        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
+
+        shadowTelephonyManager.setNetworkOperator("123456");
+        String adUrl = generateMinimumUrlString();
+        assertThat(adUrl).isEqualTo(urlBuilder.withMcc("123").withMnc("456").build());
+
+        ClientMetadata.clearForTesting();
+        shadowTelephonyManager.setNetworkOperator("12345");
+        adUrl = generateMinimumUrlString();
+        assertThat(adUrl).isEqualTo(urlBuilder.withMcc("123").withMnc("45").build());
+
+        ClientMetadata.clearForTesting();
+        shadowTelephonyManager.setNetworkOperator("1234");
+        adUrl = generateMinimumUrlString();
+        assertThat(adUrl).isEqualTo(urlBuilder.withMcc("123").withMnc("4").build());
+
+        ClientMetadata.clearForTesting();
+        shadowTelephonyManager.setNetworkOperator("123");
+        adUrl = generateMinimumUrlString();
+        assertThat(adUrl).isEqualTo(urlBuilder.withMcc("123").withMnc("").build());
+
+        ClientMetadata.clearForTesting();
+        shadowTelephonyManager.setNetworkOperator("12");
+        adUrl = generateMinimumUrlString();
+        assertThat(adUrl).isEqualTo(urlBuilder.withMcc("12").withMnc("").build());
+    }
+
+    @Test
+    public void generateAdUrl_needsAndDoesNotHaveReadPhoneState_shouldNotContainOperatorName() {
+        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
+
+        shadowTelephonyManager.setNeedsReadPhoneState(true);
+        shadowTelephonyManager.setReadPhoneStatePermission(false);
+
+        String adUrl = generateMinimumUrlString();
+        assertThat(adUrl).isEqualTo(urlBuilder.withCarrierName("").build());
+    }
+
+    @Test
+    public void generateAdUrl_needsAndHasReadPhoneState_shouldContainOperatorName() {
+        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
+
+        shadowTelephonyManager.setNeedsReadPhoneState(true);
+        shadowTelephonyManager.setReadPhoneStatePermission(true);
+        shadowTelephonyManager.setNetworkOperatorName("TEST_NAME");
+
+        String adUrl = generateMinimumUrlString();
+        assertThat(adUrl).isEqualTo(urlBuilder.withCarrierName("TEST_NAME").build());
+    }
+
+    @Test
+    public void generateAdUrl_doesNotNeedReadPhoneState_shouldContainOperatorName() {
+        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
+
+        shadowTelephonyManager.setNeedsReadPhoneState(false);
+        shadowTelephonyManager.setReadPhoneStatePermission(false);
+        shadowTelephonyManager.setNetworkOperatorName("TEST_NAME");
+
+        String adUrl = generateMinimumUrlString();
+        assertThat(adUrl).isEqualTo(urlBuilder.withCarrierName("TEST_NAME").build());
+    }
+
+    @Test
+    public void generateAdurl_whenOnCDMA_shouldGetOwnerStringFromSimCard() throws Exception {
+        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
+        shadowTelephonyManager.setPhoneType(TelephonyManager.PHONE_TYPE_CDMA);
+        shadowTelephonyManager.setSimState(TelephonyManager.SIM_STATE_READY);
+        shadowTelephonyManager.setNetworkOperator("123456");
+        shadowTelephonyManager.setSimOperator("789012");
+        String adUrl = generateMinimumUrlString();
+        assertThat(adUrl).isEqualTo(urlBuilder.withMcc("789").withMnc("012").build());
+    }
+
+    @Test
+    public void generateAdurl_whenSimNotReady_shouldDefaultToNetworkOperator() throws Exception {
+        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
+        shadowTelephonyManager.setPhoneType(TelephonyManager.PHONE_TYPE_CDMA);
+        shadowTelephonyManager.setSimState(TelephonyManager.SIM_STATE_ABSENT);
+        shadowTelephonyManager.setNetworkOperator("123456");
+        shadowTelephonyManager.setSimOperator("789012");
+        String adUrl = generateMinimumUrlString();
+        assertThat(adUrl).isEqualTo(urlBuilder.withMcc("123").withMnc("456").build());
+    }
+
+    @Test
+    public void generateAdUrl_shouldSetNetworkType() throws Exception {
+        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
+        String adUrl;
+
+        shadowConnectivityManager.setActiveNetworkInfo(createNetworkInfo(TYPE_DUMMY));
+        adUrl = generateMinimumUrlString();
+        assertThat(adUrl).isEqualTo(urlBuilder.withNetworkType(MoPubNetworkType.UNKNOWN).build());
+
+        shadowConnectivityManager.setActiveNetworkInfo(createNetworkInfo(TYPE_ETHERNET));
+        adUrl = generateMinimumUrlString();
+        assertThat(adUrl).isEqualTo(urlBuilder.withNetworkType(MoPubNetworkType.ETHERNET).build());
+
+        shadowConnectivityManager.setActiveNetworkInfo(createNetworkInfo(TYPE_WIFI));
+        adUrl = generateMinimumUrlString();
+        assertThat(adUrl).isEqualTo(urlBuilder.withNetworkType(MoPubNetworkType.WIFI).build());
+
+        // bunch of random mobile types just to make life more interesting
+        shadowConnectivityManager.setActiveNetworkInfo(createNetworkInfo(TYPE_MOBILE));
+        adUrl = generateMinimumUrlString();
+        assertThat(adUrl).isEqualTo(urlBuilder.withNetworkType(MoPubNetworkType.MOBILE).build());
+
+        shadowConnectivityManager.setActiveNetworkInfo(createNetworkInfo(TYPE_MOBILE_DUN));
+        adUrl = generateMinimumUrlString();
+        assertThat(adUrl).isEqualTo(urlBuilder.withNetworkType(MoPubNetworkType.MOBILE).build());
+
+        shadowConnectivityManager.setActiveNetworkInfo(createNetworkInfo(TYPE_MOBILE_HIPRI));
+        adUrl = generateMinimumUrlString();
+        assertThat(adUrl).isEqualTo(urlBuilder.withNetworkType(MoPubNetworkType.MOBILE).build());
+
+        shadowConnectivityManager.setActiveNetworkInfo(createNetworkInfo(TYPE_MOBILE_MMS));
+        adUrl = generateMinimumUrlString();
+        assertThat(adUrl).isEqualTo(urlBuilder.withNetworkType(MoPubNetworkType.MOBILE).build());
+
+        shadowConnectivityManager.setActiveNetworkInfo(createNetworkInfo(TYPE_MOBILE_SUPL));
+        adUrl = generateMinimumUrlString();
+        assertThat(adUrl).isEqualTo(urlBuilder.withNetworkType(MoPubNetworkType.MOBILE).build());
+    }
+
+    @Test
+    public void generateAdUrl_whenNoNetworkPermission_shouldGenerateUnknownNetworkType() throws Exception {
+        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
+
+        shadowOf(context).denyPermissions(ACCESS_NETWORK_STATE);
+        shadowConnectivityManager.setActiveNetworkInfo(createNetworkInfo(TYPE_MOBILE));
+
+        String adUrl = generateMinimumUrlString();
+
+        assertThat(adUrl).isEqualTo(urlBuilder.withNetworkType(MoPubNetworkType.UNKNOWN).build());
+    }
+
+    @Test
+    public void generateAdUrl_shouldTolerateNullActiveNetwork() throws Exception {
+        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
+        shadowConnectivityManager.setActiveNetworkInfo(null);
+
+        String adUrl = generateMinimumUrlString();
+
+        assertThat(adUrl).isEqualTo(urlBuilder.withNetworkType(MoPubNetworkType.UNKNOWN).build());
+    }
+
+
+
+    @Test
+    public void generateAdUrl_whenGooglePlayServicesIsLinkedAndAdInfoIsCached_shouldUseAdInfoParams() throws Exception {
+        GpsHelper.setClassNamesForTesting();
+        when(methodBuilder.setStatic(any(Class.class))).thenReturn(methodBuilder);
+        when(methodBuilder.addParam(any(Class.class), any())).thenReturn(methodBuilder);
+        when(methodBuilder.execute()).thenReturn(GpsHelper.GOOGLE_PLAY_SUCCESS_CODE);
+
+        GpsHelperTest.TestAdInfo adInfo = new GpsHelperTest.TestAdInfo();
+        final ClientMetadata clientMetadata = ClientMetadata.getInstance(context);
+        clientMetadata.setAdvertisingInfo(adInfo.mAdId, adInfo.mLimitAdTrackingEnabled);
+
+        expectedUdid = "ifa%3A" + adInfo.ADVERTISING_ID;
+        String expectedAdUrl = new AdUrlBuilder(expectedUdid)
+                .withDnt(adInfo.LIMIT_AD_TRACKING_ENABLED)
+                .build();
+        assertThat(generateMinimumUrlString()).isEqualTo(expectedAdUrl);
+    }
+
+    @Test
+    public void generateAdUrl_whenLocationServiceGpsProviderHasMostRecentLocation_shouldUseLocationServiceValue() {
+        Location locationFromDeveloper = new Location("");
+        locationFromDeveloper.setLatitude(42);
+        locationFromDeveloper.setLongitude(-42);
+        locationFromDeveloper.setAccuracy(3.5f);
+        locationFromDeveloper.setTime(1000);
+
+        // Mock out the LocationManager's last known location to be more recent than the
+        // developer-supplied location.
+        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
+                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
+        Location locationFromSdk = new Location("");
+        locationFromSdk.setLatitude(37);
+        locationFromSdk.setLongitude(-122);
+        locationFromSdk.setAccuracy(5.0f);
+        locationFromSdk.setTime(2000);
+        shadowLocationManager.setLastKnownLocation(LocationManager.GPS_PROVIDER, locationFromSdk);
+
+        String adUrl = subject.withLocation(locationFromDeveloper)
+                .generateUrlString("ads.mopub.com");
+        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isEqualTo("37.0,-122.0");
+        assertThat(getParameterFromRequestUrl(adUrl, "lla")).isEqualTo("5");
+        assertThat(getParameterFromRequestUrl(adUrl, "llsdk")).isEqualTo("1");
+    }
+
+    @Test
+    public void generateAdUrl_whenDeveloperSuppliesMoreRecentLocationThanLocationService_shouldUseDeveloperSuppliedLocation() {
+        Location locationFromDeveloper = new Location("");
+        locationFromDeveloper.setLatitude(42);
+        locationFromDeveloper.setLongitude(-42);
+        locationFromDeveloper.setAccuracy(3.5f);
+        locationFromDeveloper.setTime(1000);
+
+        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
+                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
+
+        // Mock out the LocationManager's last known location to be older than the
+        // developer-supplied location.
+        Location olderLocation = new Location("");
+        olderLocation.setLatitude(40);
+        olderLocation.setLongitude(-105);
+        olderLocation.setAccuracy(8.0f);
+        olderLocation.setTime(500);
+        shadowLocationManager.setLastKnownLocation(LocationManager.GPS_PROVIDER, olderLocation);
+
+        String adUrl = subject.withLocation(locationFromDeveloper)
+                .generateUrlString("ads.mopub.com");
+        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isEqualTo("42.0,-42.0");
+        assertThat(getParameterFromRequestUrl(adUrl, "lla")).isEqualTo("3");
+        assertThat(getParameterFromRequestUrl(adUrl, "llsdk")).isEmpty();
+    }
+
+    @Test
+    public void generateAdUrl_whenLocationServiceNetworkProviderHasMostRecentLocation_shouldUseLocationServiceValue() {
+        Location locationFromDeveloper = new Location("");
+        locationFromDeveloper.setLatitude(42);
+        locationFromDeveloper.setLongitude(-42);
+        locationFromDeveloper.setAccuracy(3.5f);
+        locationFromDeveloper.setTime(1000);
+
+        // Mock out the LocationManager's last known location to be more recent than the
+        // developer-supplied location.
+        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
+                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
+        Location locationFromSdk = new Location("");
+        locationFromSdk.setLatitude(38);
+        locationFromSdk.setLongitude(-123);
+        locationFromSdk.setAccuracy(5.0f);
+        locationFromSdk.setTime(2000);
+        shadowLocationManager.setLastKnownLocation(LocationManager.NETWORK_PROVIDER,
+                locationFromSdk);
+
+        String adUrl = subject.withLocation(locationFromDeveloper)
+                .generateUrlString("ads.mopub.com");
+        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isEqualTo("38.0,-123.0");
+        assertThat(getParameterFromRequestUrl(adUrl, "lla")).isEqualTo("5");
+        assertThat(getParameterFromRequestUrl(adUrl, "llsdk")).isEqualTo("1");
+    }
+
+    @Test
+    public void generateAdUrl_withNullPackageName_withEmptyPackageName_shouldNotIncludeBundleKey() {
+        when(context.getPackageName()).thenReturn(null).thenReturn("");
+
+        final String adUrlNullPackageName = generateMinimumUrlString();
+        final String adUrlEmptyPackageName = generateMinimumUrlString();
+
+        assertThat(adUrlNullPackageName).doesNotContain("&bundle=");
+        assertThat(adUrlEmptyPackageName).doesNotContain("&bundle=");
+    }
+
+    @Test
+    public void enableLocationTracking_shouldIncludeLocationInUrl() {
+        MoPub.setLocationAwareness(MoPub.LocationAwareness.NORMAL);
+        String adUrl = generateMinimumUrlString();
+        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isNotNull();
+    }
+
+    @Test
+    public void disableLocationCollection_shouldNotIncludeLocationInUrl() {
+        MoPub.setLocationAwareness(MoPub.LocationAwareness.DISABLED);
+        String adUrl = generateMinimumUrlString();
+        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isNullOrEmpty();
+    }
+
+    @Test
+    public void disableLocationCollection_whenLocationServiceHasMostRecentLocation_shouldNotIncludeLocationInUrl() {
+        MoPub.setLocationAwareness(MoPub.LocationAwareness.DISABLED);
+
+        // Mock out the LocationManager's last known location.
+        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
+                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
+        Location locationFromSdk = new Location("");
+        locationFromSdk.setLatitude(37);
+        locationFromSdk.setLongitude(-122);
+        locationFromSdk.setAccuracy(5.0f);
+        locationFromSdk.setTime(2000);
+        shadowLocationManager.setLastKnownLocation(LocationManager.GPS_PROVIDER, locationFromSdk);
+
+        String adUrl = generateMinimumUrlString();
+        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isNullOrEmpty();
+    }
+
+    private String getParameterFromRequestUrl(String requestString, String key) {
+        Uri requestUri = Uri.parse(requestString);
+        String parameter = requestUri.getQueryParameter(key);
+
+        if (TextUtils.isEmpty(parameter)) {
+            return "";
+        }
+
+        return parameter;
+    }
+
+    private NetworkInfo createNetworkInfo(int type) {
+        return ShadowNetworkInfo.newInstance(null,
+                type,
+                NETWORK_TYPE_UNKNOWN, true, true);
+    }
+
+    private String generateMinimumUrlString() {
+        return subject.generateUrlString("ads.mopub.com");
+    }
+
+    private static class AdUrlBuilder {
+        private String expectedUdid;
+        private String adUnitId = "";
+        private String query = "";
+        private String latLon = "";
+        private String locationAccuracy = "";
+        private String latLonLastUpdated = "";
+        private String mnc = "";
+        private String mcc = "";
+        private String countryIso = "";
+        private String carrierName = "";
+        private String dnt = "";
+        private MoPubNetworkType networkType = MoPubNetworkType.MOBILE;
+        private int externalStoragePermission;
+
+        public AdUrlBuilder(String expectedUdid) {
+            this.expectedUdid = expectedUdid;
+        }
+
+        public String build() {
+            return "http://ads.mopub.com/m/ad" +
+                    "?v=6" +
+                    paramIfNotEmpty("id", adUnitId) +
+                    "&nv=" + MoPub.SDK_VERSION +
+                    "&dn=" + Build.MANUFACTURER +
+                    "%2C" + Build.MODEL +
+                    "%2C" + Build.PRODUCT +
+                    "&bundle=" + "testBundle" +
+                    paramIfNotEmpty("q", query) +
+                    (TextUtils.isEmpty(latLon) ? "" :
+                            "&ll=" + latLon + "&lla=" + locationAccuracy + "&llf=" + latLonLastUpdated) +
+                    "&z=-0700" +
+                    "&o=u" +
+                    "&w=" + TEST_SCREEN_WIDTH +
+                    "&h=" + TEST_SCREEN_HEIGHT +
+                    "&sc_a=1.0" +
+                    paramIfNotEmpty("mcc", mcc) +
+                    paramIfNotEmpty("mnc", mnc) +
+                    paramIfNotEmpty("iso", countryIso) +
+                    paramIfNotEmpty("cn", carrierName) +
+                    "&ct=" + networkType +
+                    // Maven version
+                    "&av=1.0" +
+                    // Gradle Version
+                    //"&av=" + BuildConfig.VERSION_NAME +
+                    "&udid=" + PlayServicesUrlRewriter.UDID_TEMPLATE +
+                    "&dnt=" + PlayServicesUrlRewriter.DO_NOT_TRACK_TEMPLATE +
+                    "&mr=1" +
+                    "&android_perms_ext_storage=" + externalStoragePermission;
+        }
+
+        public AdUrlBuilder withAdUnitId(String adUnitId) {
+            this.adUnitId = adUnitId;
+            return this;
+        }
+
+        public AdUrlBuilder withQuery(String query) {
+            this.query = query;
+            return this;
+        }
+
+        public AdUrlBuilder withLatLon(String latLon, String locationAccuracy,
+                String latLonLastUpdated) {
+            this.latLon = latLon;
+            this.locationAccuracy = locationAccuracy;
+            this.latLonLastUpdated = latLonLastUpdated;
+            return this;
+        }
+
+        public AdUrlBuilder withMcc(String mcc) {
+            this.mcc = mcc;
+            return this;
+        }
+
+        public AdUrlBuilder withMnc(String mnc) {
+            this.mnc = mnc;
+            return this;
+        }
+
+        public AdUrlBuilder withCountryIso(String countryIso) {
+            this.countryIso = countryIso;
+            return this;
+        }
+
+        public AdUrlBuilder withCarrierName(String carrierName) {
+            this.carrierName = carrierName;
+            return this;
+        }
+
+        public AdUrlBuilder withNetworkType(MoPubNetworkType networkType) {
+            this.networkType = networkType;
+            return this;
+        }
+
+        public AdUrlBuilder withExternalStoragePermission(boolean enabled) {
+            this.externalStoragePermission = enabled ? 1 : 0;
+            return this;
+        }
+
+        public AdUrlBuilder withDnt(boolean dnt) {
+            if (dnt) {
+                this.dnt = "1";
+            }
+            return this;
+        }
+
+        private String paramIfNotEmpty(String key, String value) {
+            if (TextUtils.isEmpty(value)) {
+                return "";
+            } else {
+                return "&" + key + "=" + value;
+            }
+        }
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastManagerTest.java
index caf962d8..e13e5a5d 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastManagerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastManagerTest.java
@@ -1,894 +1,892 @@
-package com.mopub.mobileads.util.vast;
-
-import android.app.Activity;
-import android.content.Context;
-import android.view.Display;
-import android.view.WindowManager;
-
-import com.mopub.common.CacheService;
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.DeviceUtils;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.Robolectric;
-import org.robolectric.annotation.Config;
-import org.robolectric.tester.org.apache.http.FakeHttpLayer;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.concurrent.Semaphore;
-
-import static com.mopub.mobileads.util.vast.VastManager.VastManagerListener;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-@Config(manifest = Config.NONE)
-@RunWith(SdkTestRunner.class)
-public class VastManagerTest {
-    static final String EXTENSIONS_SNIPPET_PLACEHOLDER = "<![CDATA[EXTENSIONS_SNIPPET]]>";
-    static final String TEST_VAST_XML_STRING = "<VAST version='2.0'><Ad id='62833'><Wrapper><AdSystem>Tapad</AdSystem><VASTAdTagURI>http://dsp.x-team.staging.mopub.com/xml</VASTAdTagURI><Impression>http://myTrackingURL/wrapper/impression1</Impression><Impression>http://myTrackingURL/wrapper/impression2</Impression><Creatives><Creative AdID='62833'><Linear><TrackingEvents><Tracking event='creativeView'>http://myTrackingURL/wrapper/creativeView</Tracking><Tracking event='start'>http://myTrackingURL/wrapper/start</Tracking><Tracking event='midpoint'>http://myTrackingURL/wrapper/midpoint</Tracking><Tracking event='progress' offset='00:00:03.100'>http://myTrackingURL/wrapper/progress</Tracking><Tracking event='firstQuartile'>http://myTrackingURL/wrapper/firstQuartile</Tracking><Tracking event='thirdQuartile'>http://myTrackingURL/wrapper/thirdQuartile</Tracking><Tracking event='complete'>http://myTrackingURL/wrapper/complete</Tracking><Tracking event='close'>http://myTrackingURL/wrapper/close</Tracking><Tracking event='skip'>http://myTrackingURL/wrapper/skip</Tracking><Tracking event='mute'>http://myTrackingURL/wrapper/mute</Tracking><Tracking event='unmute'>http://myTrackingURL/wrapper/unmute</Tracking><Tracking event='pause'>http://myTrackingURL/wrapper/pause</Tracking><Tracking event='resume'>http://myTrackingURL/wrapper/resume</Tracking><Tracking event='fullscreen'>http://myTrackingURL/wrapper/fullscreen</Tracking></TrackingEvents><VideoClicks><ClickTracking>http://myTrackingURL/wrapper/click</ClickTracking></VideoClicks><MediaFiles><MediaFile delivery='progressive' bitrate='416' width='300' height='250' type='video/mp4'><![CDATA[https://s3.amazonaws.com/mopub-vast/tapad-video1.mp4]]></MediaFile></MediaFiles></Linear></Creative><Creative AdID=\"601364-Companion\"> <CompanionAds><Companion width=\"9000\"></Companion> </CompanionAds></Creative></Creatives><![CDATA[EXTENSIONS_SNIPPET]]></Wrapper></Ad></VAST><MP_TRACKING_URLS><MP_TRACKING_URL>http://www.mopub.com/imp1</MP_TRACKING_URL><MP_TRACKING_URL>http://www.mopub.com/imp2</MP_TRACKING_URL></MP_TRACKING_URLS>";
-    static final String TEST_NESTED_VAST_XML_STRING = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><VAST version='2.0'><Ad id='57722'><InLine><AdSystem version='1.0'>Tapad</AdSystem><AdTitle><![CDATA[PKW6T_LIV_DSN_Audience_TAPAD_3rd Party Audience Targeting_Action Movi]]></AdTitle><Description/><Impression><![CDATA[http://rtb-test.dev.tapad.com:8080/creative/imp.png?ts=1374099035457&svid=1&creative_id=30731&ctx_type=InApp&ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&liverail_cp=1]]></Impression><Creatives><Creative sequence='1' id='57722'><Linear><TrackingEvents><Tracking event='close'>http://myTrackingURL/wrapper/nested_close</Tracking><Tracking event='skip'>http://myTrackingURL/wrapper/nested_skip</Tracking></TrackingEvents><Duration>00:00:15</Duration><VideoClicks><ClickThrough><![CDATA[http://rtb-test.dev.tapad.com:8080/click?ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&crid=30731&ta_action_id=click&ts=1374099035458&redirect=http%3A%2F%2Ftapad.com]]></ClickThrough></VideoClicks><MediaFiles><MediaFile delivery='progressive' bitrate='416' width='800' height='480' type='video/mp4'><![CDATA[https://s3.amazonaws.com/mopub-vast/tapad-video.mp4]]></MediaFile></MediaFiles></Linear></Creative><Creative AdID=\"601364-Companion\"><CompanionAds><Companion id=\"valid\" height=\"250\" width=\"300\"><StaticResource creativeType=\"image/jpeg\">http://demo.tremormedia.com/proddev/vast/Blistex1.jpg</StaticResource><TrackingEvents><Tracking event=\"creativeView\">http://myTrackingURL/firstCompanionCreativeView</Tracking><Tracking event=\"creativeView\">http://myTrackingURL/secondCompanionCreativeView</Tracking></TrackingEvents><CompanionClickThrough>http://www.tremormedia.com</CompanionClickThrough></Companion></CompanionAds></Creative></Creatives><![CDATA[EXTENSIONS_SNIPPET]]></InLine></Ad></VAST>";
-    static final String TEST_VAST_BAD_NEST_URL_XML_STRING = "<VAST version='2.0'><Ad id='62833'><Wrapper><AdSystem>Tapad</AdSystem><VASTAdTagURI>http://dsp.x-team.staging.mopub.com/xml\"$|||</VASTAdTagURI><Impression>http://myTrackingURL/wrapper/impression1</Impression><Impression>http://myTrackingURL/wrapper/impression2</Impression><Creatives><Creative AdID='62833'><Linear><TrackingEvents><Tracking event='creativeView'>http://myTrackingURL/wrapper/creativeView</Tracking><Tracking event='start'>http://myTrackingURL/wrapper/start</Tracking><Tracking event='midpoint'>http://myTrackingURL/wrapper/midpoint</Tracking><Tracking event='firstQuartile'>http://myTrackingURL/wrapper/firstQuartile</Tracking><Tracking event='thirdQuartile'>http://myTrackingURL/wrapper/thirdQuartile</Tracking><Tracking event='complete'>http://myTrackingURL/wrapper/complete</Tracking><Tracking event='mute'>http://myTrackingURL/wrapper/mute</Tracking><Tracking event='unmute'>http://myTrackingURL/wrapper/unmute</Tracking><Tracking event='pause'>http://myTrackingURL/wrapper/pause</Tracking><Tracking event='resume'>http://myTrackingURL/wrapper/resume</Tracking><Tracking event='fullscreen'>http://myTrackingURL/wrapper/fullscreen</Tracking></TrackingEvents><VideoClicks><ClickTracking>http://myTrackingURL/wrapper/click</ClickTracking></VideoClicks></Linear></Creative></Creatives></Wrapper></Ad></VAST><MP_TRACKING_URLS><MP_TRACKING_URL>http://www.mopub.com/imp1</MP_TRACKING_URL><MP_TRACKING_URL>http://www.mopub.com/imp2</MP_TRACKING_URL></MP_TRACKING_URLS>";
-
-    private VastManager subject;
-    private FakeHttpLayer mFakeHttpLayer;
-    private VastManagerListener vastManagerListener;
-    private Activity context;
-    private VastVideoConfiguration vastVideoConfiguration;
-    private Semaphore semaphore;
-
-    @Before
-    public void setup() {
-        context = Robolectric.buildActivity(Activity.class).create().get();
-        CacheService.initializeDiskCache(context);
-        subject = new VastManager(context);
-        mFakeHttpLayer = Robolectric.getFakeHttpLayer();
-
-        semaphore = new Semaphore(0);
-        vastManagerListener = mock(VastManagerListener.class);
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                Object[] args = invocationOnMock.getArguments();
-                VastManagerTest.this.vastVideoConfiguration = (VastVideoConfiguration) args[0];
-                semaphore.release();
-                return null;
-            }
-        }).when(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
-    }
-
-    private void prepareVastVideoConfiguration() {
-        subject.prepareVastVideoConfiguration(TEST_VAST_XML_STRING, vastManagerListener);
-
-        Robolectric.runBackgroundTasks();
-        Robolectric.runUiThreadTasks();
-    }
-
-    @Test
-    public void prepareVastVideoConfiguration_shouldNotifyTheListenerAndContainTheCorrectVastValues() throws Exception {
-        // Vast redirect responses
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
-        // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
-
-        prepareVastVideoConfiguration();
-        semaphore.acquire();
-        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
-
-        assertThat(vastVideoConfiguration.getNetworkMediaFileUrl()).isEqualTo("https://s3.amazonaws.com/mopub-vast/tapad-video.mp4");
-
-        final String expectedFilePathDiskCache = CacheService.getFilePathDiskCache(vastVideoConfiguration.getNetworkMediaFileUrl());
-        assertThat(vastVideoConfiguration.getDiskMediaFileUrl()).isEqualTo(expectedFilePathDiskCache);
-
-        assertThat(vastVideoConfiguration.getClickThroughUrl()).isEqualTo("http://rtb-test.dev.tapad.com:8080/click?ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&crid=30731&ta_action_id=click&ts=1374099035458&redirect=http%3A%2F%2Ftapad.com");
-        assertThat(vastVideoConfiguration.getImpressionTrackers().size()).isEqualTo(5);
-
-        // Verify quartile trackers
-        assertThat(vastVideoConfiguration.getFractionalTrackers().size()).isEqualTo(3);
-        assertThat(vastVideoConfiguration.getFractionalTrackers().get(0).trackingFraction()).isEqualTo(0.25f);
-        assertThat(vastVideoConfiguration.getFractionalTrackers().get(1).trackingFraction()).isEqualTo(0.5f);
-        assertThat(vastVideoConfiguration.getFractionalTrackers().get(2).trackingFraction()).isEqualTo(0.75f);
-
-        // Verify start tracker.
-        assertThat(vastVideoConfiguration.getAbsoluteTrackers().size()).isEqualTo(2);
-        assertThat(vastVideoConfiguration.getAbsoluteTrackers().get(0).getTrackingMilliseconds()).isEqualTo(2000);
-        assertThat(vastVideoConfiguration.getAbsoluteTrackers().get(1).getTrackingMilliseconds()).isEqualTo(3100);
-
-        assertThat(vastVideoConfiguration.getCompleteTrackers().size()).isEqualTo(1);
-
-        // We specifically added a close tracker and a skip tracker to the nested vast test case as well,
-        // therefore there are two expected trackers total for each type.
-        assertThat(vastVideoConfiguration.getCloseTrackers().size()).isEqualTo(2);
-        assertThat(vastVideoConfiguration.getSkipTrackers().size()).isEqualTo(2);
-        assertThat(vastVideoConfiguration.getClickTrackers().size()).isEqualTo(1);
-
-        final VastCompanionAd vastCompanionAd = vastVideoConfiguration.getVastCompanionAd();
-        assertThat(vastCompanionAd.getWidth()).isEqualTo(300);
-        assertThat(vastCompanionAd.getHeight()).isEqualTo(250);
-        assertThat(vastCompanionAd.getImageUrl()).isEqualTo("http://demo.tremormedia.com/proddev/vast/Blistex1.jpg");
-        assertThat(vastCompanionAd.getClickThroughUrl()).isEqualTo("http://www.tremormedia.com");
-        assertThat(vastCompanionAd.getClickTrackers())
-                .containsOnly("http://myTrackingURL/firstCompanionCreativeView", "http://myTrackingURL/secondCompanionCreativeView");
-    }
-
-    @Test
-    public void prepareVastVideoConfiguration_shouldHandleMultipleRedirects() throws Exception {
-        // Vast redirect responses
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_VAST_XML_STRING);
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_VAST_XML_STRING);
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
-        // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
-
-        prepareVastVideoConfiguration();
-        semaphore.acquire();
-        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
-
-        // at this point it should have 3 sets of data from TEST_VAST_XML_STRING and one set from TEST_NESTED_VAST_XML_STRING
-        assertThat(vastVideoConfiguration.getNetworkMediaFileUrl()).isEqualTo("https://s3.amazonaws.com/mopub-vast/tapad-video.mp4");
-        final String expectedFilePathDiskCache = CacheService.getFilePathDiskCache(vastVideoConfiguration.getNetworkMediaFileUrl());
-        assertThat(vastVideoConfiguration.getDiskMediaFileUrl()).isEqualTo(expectedFilePathDiskCache);
-
-        assertThat(vastVideoConfiguration.getClickThroughUrl()).isEqualTo("http://rtb-test.dev.tapad.com:8080/click?ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&crid=30731&ta_action_id=click&ts=1374099035458&redirect=http%3A%2F%2Ftapad.com");
-        assertThat(vastVideoConfiguration.getImpressionTrackers().size()).isEqualTo(13);
-
-        assertThat(vastVideoConfiguration.getAbsoluteTrackers().size()).isEqualTo(6);
-        assertThat(vastVideoConfiguration.getAbsoluteTrackers().get(0).getTrackingMilliseconds()).isEqualTo(2000);
-        assertThat(vastVideoConfiguration.getAbsoluteTrackers().get(1).getTrackingMilliseconds()).isEqualTo(2000);
-        assertThat(vastVideoConfiguration.getAbsoluteTrackers().get(2).getTrackingMilliseconds()).isEqualTo(2000);
-        assertThat(vastVideoConfiguration.getAbsoluteTrackers().get(3).getTrackingMilliseconds()).isEqualTo(3100);
-        assertThat(vastVideoConfiguration.getAbsoluteTrackers().get(4).getTrackingMilliseconds()).isEqualTo(3100);
-        assertThat(vastVideoConfiguration.getAbsoluteTrackers().get(5).getTrackingMilliseconds()).isEqualTo(3100);
-
-
-        assertThat(vastVideoConfiguration.getFractionalTrackers().size()).isEqualTo(9);
-        assertThat(vastVideoConfiguration.getFractionalTrackers().get(0).trackingFraction()).isEqualTo(0.25f);
-        assertThat(vastVideoConfiguration.getFractionalTrackers().get(1).trackingFraction()).isEqualTo(0.25f);
-        assertThat(vastVideoConfiguration.getFractionalTrackers().get(2).trackingFraction()).isEqualTo(0.25f);
-        assertThat(vastVideoConfiguration.getFractionalTrackers().get(3).trackingFraction()).isEqualTo(0.5f);
-        assertThat(vastVideoConfiguration.getFractionalTrackers().get(4).trackingFraction()).isEqualTo(0.5f);
-        assertThat(vastVideoConfiguration.getFractionalTrackers().get(5).trackingFraction()).isEqualTo(0.5f);
-        assertThat(vastVideoConfiguration.getFractionalTrackers().get(6).trackingFraction()).isEqualTo(0.75f);
-        assertThat(vastVideoConfiguration.getFractionalTrackers().get(7).trackingFraction()).isEqualTo(0.75f);
-        assertThat(vastVideoConfiguration.getFractionalTrackers().get(8).trackingFraction()).isEqualTo(0.75f);
-
-        assertThat(vastVideoConfiguration.getCompleteTrackers().size()).isEqualTo(3);
-        assertThat(vastVideoConfiguration.getCloseTrackers().size()).isEqualTo(4);
-        assertThat(vastVideoConfiguration.getSkipTrackers().size()).isEqualTo(4);
-        assertThat(vastVideoConfiguration.getClickTrackers().size()).isEqualTo(3);
-
-        final VastCompanionAd vastCompanionAd = vastVideoConfiguration.getVastCompanionAd();
-        assertThat(vastCompanionAd.getWidth()).isEqualTo(300);
-        assertThat(vastCompanionAd.getHeight()).isEqualTo(250);
-        assertThat(vastCompanionAd.getImageUrl()).isEqualTo("http://demo.tremormedia.com/proddev/vast/Blistex1.jpg");
-        assertThat(vastCompanionAd.getClickThroughUrl()).isEqualTo("http://www.tremormedia.com");
-        assertThat(vastCompanionAd.getClickTrackers())
-                .containsOnly("http://myTrackingURL/firstCompanionCreativeView", "http://myTrackingURL/secondCompanionCreativeView");
-    }
-
-    @Test
-    public void prepareVastVideoConfiguration_shouldReturnCorrectVastValuesWhenAVastRedirectFails() throws Exception {
-        // Vast redirect response
-        mFakeHttpLayer.addPendingHttpResponse(404, "");
-        // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
-
-        prepareVastVideoConfiguration();
-        semaphore.acquire();
-        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
-
-        assertThat(vastVideoConfiguration.getNetworkMediaFileUrl()).isEqualTo("https://s3.amazonaws.com/mopub-vast/tapad-video1.mp4");
-
-        final String expectedFilePathDiskCache = CacheService.getFilePathDiskCache(vastVideoConfiguration.getNetworkMediaFileUrl());
-        assertThat(vastVideoConfiguration.getDiskMediaFileUrl()).isEqualTo(expectedFilePathDiskCache);
-
-        assertThat(vastVideoConfiguration.getClickThroughUrl()).isEqualTo(null);
-        assertThat(vastVideoConfiguration.getImpressionTrackers().size()).isEqualTo(4);
-        assertThat(vastVideoConfiguration.getFractionalTrackers().size()).isEqualTo(3);
-    }
-
-    @Test
-    public void prepareVastVideoConfiguration_withNoExtensions_shouldContainTheCorrectDefaultExtensionValues() throws Exception {
-        // Vast redirect response to XML without VAST extensions
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
-        // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
-
-        prepareVastVideoConfiguration();
-        semaphore.acquire();
-        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
-
-        assertThat(vastVideoConfiguration.getCustomCtaText()).isNull();
-        assertThat(vastVideoConfiguration.getCustomSkipText()).isNull();
-        assertThat(vastVideoConfiguration.getCustomCloseIconUrl()).isNull();
-        assertThat(vastVideoConfiguration.getCustomForceOrientation()).isEqualTo(DeviceUtils.ForceOrientation.FORCE_LANDSCAPE);
-    }
-
-    @Test
-    public void prepareVastVideoConfiguration_withExtensionsUnderWrapper_shouldContainTheCorrectCustomExtensionValues() throws Exception {
-        // Vast redirect response to XML without extensions
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
-        // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
-
-        // Add extensions under Wrapper element in TEST_VAST_XML_STRING
-        subject.prepareVastVideoConfiguration(
-                TEST_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
-                        "<Extensions>" +
-                            "<Extension type=\"MoPub\">" +
-                                "<MoPubCtaText>custom CTA text</MoPubCtaText>" +
-                                "<MoPubSkipText>skip</MoPubSkipText>" +
-                                "<MoPubCloseIcon>http://ton.twitter.com/exchange-media/images/v4/star_icon_3x.png</MoPubCloseIcon>" +
-                                "<MoPubForceOrientation>device</MoPubForceOrientation>" +
-                            "</Extension>" +
-                        "</Extensions>"),
-                vastManagerListener);
-
-        Robolectric.runBackgroundTasks();
-        Robolectric.runUiThreadTasks();
-        semaphore.acquire();
-        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
-
-        // Verify custom extensions
-        assertThat(vastVideoConfiguration.getCustomCtaText()).isEqualTo("custom CTA text");
-        assertThat(vastVideoConfiguration.getCustomSkipText()).isEqualTo("skip");
-        assertThat(vastVideoConfiguration.getCustomCloseIconUrl()).isEqualTo("http://ton.twitter.com/exchange-media/images/v4/star_icon_3x.png");
-        assertThat(vastVideoConfiguration.getCustomForceOrientation()).isEqualTo(DeviceUtils.ForceOrientation.DEVICE_ORIENTATION);
-    }
-
-    @Test
-    public void prepareVastVideoConfiguration_withExtensionsUnderInline_shouldContainTheCorrectCustomExtensionValues() throws Exception {
-        // Vast redirect response to XML with extensions under Inline element
-        mFakeHttpLayer.addPendingHttpResponse(200,
-                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
-                        "<Extensions>" +
-                            "<Extension type=\"MoPub\">" +
-                                "<MoPubCtaText>custom CTA text</MoPubCtaText>" +
-                                "<MoPubSkipText>skip</MoPubSkipText>" +
-                                "<MoPubCloseIcon>http://ton.twitter.com/exchange-media/images/v4/star_icon_3x.png</MoPubCloseIcon>" +
-                                "<MoPubForceOrientation>device</MoPubForceOrientation>" +
-                            "</Extension>" +
-                        "</Extensions>"));
-        // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
-
-        prepareVastVideoConfiguration();
-        semaphore.acquire();
-
-        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
-
-        // Verify custom extensions
-        assertThat(vastVideoConfiguration.getCustomCtaText()).isEqualTo("custom CTA text");
-        assertThat(vastVideoConfiguration.getCustomSkipText()).isEqualTo("skip");
-        assertThat(vastVideoConfiguration.getCustomCloseIconUrl()).isEqualTo("http://ton.twitter.com/exchange-media/images/v4/star_icon_3x.png");
-        assertThat(vastVideoConfiguration.getCustomForceOrientation()).isEqualTo(DeviceUtils.ForceOrientation.DEVICE_ORIENTATION);
-    }
-
-    @Test
-    public void prepareVastVideoConfiguration_withExtensionsUnderBothWrapperAndInline_shouldContainLastParsedCustomExtensionValues() throws Exception {
-        // Vast redirect response to XML with extensions under Inline element in TEST_NESTED_VAST_XML_STRING, will be parsed last
-        mFakeHttpLayer.addPendingHttpResponse(200,
-                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
-                        "<Extensions>" +
-                            "<Extension type=\"MoPub\">" +
-                                "<MoPubCtaText>CTA 2</MoPubCtaText>" +
-                                "<MoPubSkipText>skip 2</MoPubSkipText>" +
-                                "<MoPubCloseIcon>http://ton.twitter.com/exchange-media/images/v4/star_icon_3x_2.png</MoPubCloseIcon>" +
-                                "<MoPubForceOrientation>landscape</MoPubForceOrientation>" +
-                            "</Extension>" +
-                        "</Extensions>"));
-        // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
-
-        // Also add extensions under Wrapper element in TEST_VAST_XML_STRING
-        subject.prepareVastVideoConfiguration(
-                TEST_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
-                        "<Extensions>" +
-                            "<Extension type=\"MoPub\">" +
-                                "<MoPubCtaText>CTA 1</MoPubCtaText>" +
-                                "<MoPubSkipText>skip 1</MoPubSkipText>" +
-                                "<MoPubCloseIcon>http://ton.twitter.com/exchange-media/images/v4/star_icon_3x_1.png</MoPubCloseIcon>" +
-                                "<MoPubForceOrientation>device orientation</MoPubForceOrientation>" +
-                            "</Extension>" +
-                        "</Extensions>"),
-                vastManagerListener);
-
-        Robolectric.runBackgroundTasks();
-        Robolectric.runUiThreadTasks();
-        semaphore.acquire();
-
-        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
-
-        // Verify custom extension values are the ones last parsed in TEST_NESTED_VAST_XML_STRING
-        assertThat(vastVideoConfiguration.getCustomCtaText()).isEqualTo("CTA 2");
-        assertThat(vastVideoConfiguration.getCustomSkipText()).isEqualTo("skip 2");
-        assertThat(vastVideoConfiguration.getCustomCloseIconUrl()).isEqualTo("http://ton.twitter.com/exchange-media/images/v4/star_icon_3x_2.png");
-        assertThat(vastVideoConfiguration.getCustomForceOrientation()).isEqualTo(DeviceUtils.ForceOrientation.FORCE_LANDSCAPE);
-    }
-
-    @Test
-    public void prepareVastVideoConfiguration_withCustomCtaTextAsSingleSpace_shouldReturnEmptyString() throws Exception {
-        // Vast redirect response
-        mFakeHttpLayer.addPendingHttpResponse(200,
-                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
-                        "<Extensions>" +
-                            "<Extension type=\"MoPub\">" +
-                                "<MoPubCtaText> </MoPubCtaText>" +     // single space, i.e. no text
-                            "</Extension>" +
-                        "</Extensions>"));
-        // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
-
-        prepareVastVideoConfiguration();
-        semaphore.acquire();
-
-        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
-        assertThat(vastVideoConfiguration.getCustomCtaText()).isEmpty();
-    }
-
-    @Test
-    public void prepareVastVideoConfiguration_withCustomCtaTextLongerThan15Chars_shouldReturnNull() throws Exception {
-        // Vast redirect response
-        mFakeHttpLayer.addPendingHttpResponse(200,
-                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
-                        "<Extensions>" +
-                            "<Extension type=\"MoPub\">" +
-                                "<MoPubCtaText>1234567890123456</MoPubCtaText>" +     // 16 chars
-                            "</Extension>" +
-                        "</Extensions>"));
-        // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
-
-        prepareVastVideoConfiguration();
-        semaphore.acquire();
-
-        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
-        assertThat(vastVideoConfiguration.getCustomCtaText()).isNull();
-    }
-
-    @Test
-    public void prepareVastVideoConfiguration_withCustomSkipTextLongerThan8Chars_shouldReturnNull() throws Exception {
-        // Vast redirect response
-        mFakeHttpLayer.addPendingHttpResponse(200,
-                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
-                        "<Extensions>" +
-                            "<Extension type=\"MoPub\">" +
-                                "<MoPubSkipText>123456789</MoPubSkipText>" +     // 9 chars
-                            "</Extension>" +
-                        "</Extensions>"));
-        // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
-
-        prepareVastVideoConfiguration();
-        semaphore.acquire();
-
-        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
-        assertThat(vastVideoConfiguration.getCustomSkipText()).isNull();
-    }
-
-    @Test
-    public void prepareVastVideoConfiguration_withInvalidCustomForceOrientation_shouldReturnDefaultForceLandscapeOrientation() throws Exception {
-        // Vast redirect response
-        mFakeHttpLayer.addPendingHttpResponse(200,
-                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
-                        "<Extensions>" +
-                            "<Extension type=\"MoPub\">" +
-                                "<MoPubForceOrientation>abcd</MoPubForceOrientation>" +   // invalid value
-                            "</Extension>" +
-                        "</Extensions>"));
-        // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
-
-        prepareVastVideoConfiguration();
-        semaphore.acquire();
-
-        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
-        assertThat(vastVideoConfiguration.getCustomForceOrientation()).isEqualTo(DeviceUtils.ForceOrientation.FORCE_LANDSCAPE);
-    }
-
-    @Test
-    public void prepareVastVideoConfiguration_withCustomForceOrientationInMixedCaseAndUntrimmed_shouldReturnCustomForceOrientation() throws Exception {
-        // Vast redirect response
-        mFakeHttpLayer.addPendingHttpResponse(200,
-                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
-                        "<Extensions>" +
-                            "<Extension type=\"MoPub\">" +
-                                "<MoPubForceOrientation> PortRAIT  </MoPubForceOrientation>" +
-                            "</Extension>" +
-                        "</Extensions>"));
-        // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
-
-        prepareVastVideoConfiguration();
-        semaphore.acquire();
-
-        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
-        assertThat(vastVideoConfiguration.getCustomForceOrientation()).isEqualTo(DeviceUtils.ForceOrientation.FORCE_PORTRAIT);
-    }
-
-    @Test
-    public void prepareVastVideoConfiguration_withValidPercentSkipOffset_shouldReturnCorrectValue() throws Exception {
-        // Vast redirect response
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset='25%'>"));
-        // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
-
-        prepareVastVideoConfiguration();
-        semaphore.acquire();
-
-        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
-
-        assertThat(vastVideoConfiguration.getSkipOffset()).isEqualTo("25%");
-    }
-
-
-    @Test
-    public void prepareVastVideoConfiguration_withValidAbsoluteSkipOffset_shouldReturnCorrectValue() throws Exception {
-        // Vast redirect response
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset='  00:03:14 '>"));
-        // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
-
-        prepareVastVideoConfiguration();
-        semaphore.acquire();
-
-        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
-
-        assertThat(vastVideoConfiguration.getSkipOffset()).isEqualTo("00:03:14");
-    }
-
-    @Test
-    public void prepareVastVideoConfiguration_withValidAbsoluteSkipOffsetWithExtraSpace_shouldReturnCorrectTrimmedValue() throws Exception {
-        // Vast redirect response
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset='  00:03:14.159 '>"));
-        // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
-
-        prepareVastVideoConfiguration();
-        semaphore.acquire();
-
-        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
-
-        assertThat(vastVideoConfiguration.getSkipOffset()).isEqualTo("00:03:14.159");
-    }
-
-    @Test
-    public void prepareVastVideoConfiguration_withSkipOffsets_shouldReturnLastParsedValue() throws Exception {
-        // Vast redirect response with skipoffset in percent format
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset='25%'>"));
-        // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
-
-        // Also add a skipoffset in absolute format
-        subject.prepareVastVideoConfiguration(
-                TEST_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset='00:03:14'>"),
-                vastManagerListener);
-
-        Robolectric.runBackgroundTasks();
-        Robolectric.runUiThreadTasks();
-        semaphore.acquire();
-
-        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
-
-        // Verify that the last parsed skipoffset value is returned
-        assertThat(vastVideoConfiguration.getSkipOffset()).isEqualTo("25%");
-    }
-
-    @Test
-    public void prepareVastVideoConfiguration_withEmptySkipOffset_shouldReturnNull() throws Exception {
-        // Vast redirect response
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset=' '>"));
-        // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
-
-        prepareVastVideoConfiguration();
-        semaphore.acquire();
-
-        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
-
-        assertThat(vastVideoConfiguration.getSkipOffset()).isNull();
-    }
-
-    @Test
-    public void prepareVastVideoConfiguration_withNoMediaUrlInXml_shouldReturnNull() throws Exception {
-        subject.prepareVastVideoConfiguration(TEST_VAST_BAD_NEST_URL_XML_STRING, vastManagerListener);
-
-        Robolectric.runBackgroundTasks();
-        Robolectric.runUiThreadTasks();
-        semaphore.acquire();
-
-        verify(vastManagerListener).onVastVideoConfigurationPrepared(null);
-        assertThat(vastVideoConfiguration).isEqualTo(null);
-    }
-
-    @Test
-    public void prepareVastVideoConfiguration_withNullXml_shouldReturnNull() throws Exception {
-        subject.prepareVastVideoConfiguration(null, vastManagerListener);
-
-        Robolectric.runBackgroundTasks();
-        Robolectric.runUiThreadTasks();
-        semaphore.acquire();
-
-        verify(vastManagerListener).onVastVideoConfigurationPrepared(null);
-        assertThat(vastVideoConfiguration).isEqualTo(null);
-    }
-
-    @Test
-    public void prepareVastVideoConfiguration_withEmptyXml_shouldReturnNull() throws Exception {
-        subject.prepareVastVideoConfiguration("", vastManagerListener);
-
-        Robolectric.runBackgroundTasks();
-        Robolectric.runUiThreadTasks();
-        semaphore.acquire();
-
-        verify(vastManagerListener).onVastVideoConfigurationPrepared(null);
-        assertThat(vastVideoConfiguration).isEqualTo(null);
-    }
-
-    @Test
-    public void prepareVastVideoConfiguration_withVideoInDiskCache_shouldNotDownloadVideo() throws Exception {
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
-
-        CacheService.putToDiskCache("https://s3.amazonaws.com/mopub-vast/tapad-video.mp4", "video_data".getBytes());
-
-        prepareVastVideoConfiguration();
-        semaphore.acquire();
-
-        assertThat(mFakeHttpLayer.getSentHttpRequestInfos().size()).isEqualTo(1);
-        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
-        assertThat(vastVideoConfiguration.getDiskMediaFileUrl())
-                .isEqualTo(CacheService.getFilePathDiskCache("https://s3.amazonaws.com/mopub-vast/tapad-video.mp4"));
-    }
-
-    @Test
-    public void prepareVastVideoConfiguration_withUninitializedDiskCache_shouldReturnNull() throws Exception {
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
-
-        prepareVastVideoConfiguration();
-        semaphore.acquire();
-
-        verify(vastManagerListener).onVastVideoConfigurationPrepared(null);
-        assertThat(vastVideoConfiguration).isEqualTo(null);
-    }
-
-    @Test
-    public void cancel_shouldCancelBackgroundProcessingAndNotNotifyListenerWithNull() throws Exception {
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
-
-        Robolectric.getBackgroundScheduler().pause();
-
-        subject.prepareVastVideoConfiguration(TEST_VAST_XML_STRING, vastManagerListener);
-
-        subject.cancel();
-
-        Robolectric.runBackgroundTasks();
-        Robolectric.runUiThreadTasks();
-        semaphore.acquire();
-
-        verify(vastManagerListener).onVastVideoConfigurationPrepared(null);
-        assertThat(vastVideoConfiguration).isEqualTo(null);
-    }
-
-    @Test
-    public void getBestMediaFileUrl_shouldReturnMediaFileUrl() throws Exception {
-        final VastXmlManager.MediaXmlManager mediaXmlManager = initializeMediaXmlManagerMock(300, 250, "video/mp4", "video_url");
-
-        final String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager));
-        assertThat(bestMediaFileUrl).isEqualTo("video_url");
-    }
-
-    @Test
-    public void getBestMediaFileUrl_withNullMediaType_shouldReturnNull() throws Exception {
-        final VastXmlManager.MediaXmlManager mediaXmlManager = initializeMediaXmlManagerMock(300, 250, null, "video_url");
-
-        final String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager));
-        assertThat(bestMediaFileUrl).isNull();
-    }
-
-    @Test
-    public void getBestMediaFileUrl_withIncompatibleMediaType_shouldReturnNull() throws Exception {
-        final VastXmlManager.MediaXmlManager mediaXmlManager = initializeMediaXmlManagerMock(300, 250, "video/rubbish", "video_url");
-
-        final String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager));
-        assertThat(bestMediaFileUrl).isNull();
-    }
-
-    @Test
-    public void getBestMediaFileUrl_withNullMediaUrl_shouldReturnNull() throws Exception {
-        final VastXmlManager.MediaXmlManager mediaXmlManager = initializeMediaXmlManagerMock(300, 250, "video/mp4", null);
-
-        final String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager));
-        assertThat(bestMediaFileUrl).isNull();
-    }
-
-    @Test
-    public void getBestMediaFileUrl_withNullDimension_shouldReturnMediaFileUrl() throws Exception {
-        final VastXmlManager.MediaXmlManager mediaXmlManager = initializeMediaXmlManagerMock(null, 250, "video/mp4", "video_url");
-
-        final String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager));
-        assertThat(bestMediaFileUrl).isEqualTo("video_url");
-    }
-
-    @Test
-    public void getBestMediaFileUrl_withZeroDimension_shouldReturnMediaFileUrl() throws Exception {
-        final VastXmlManager.MediaXmlManager mediaXmlManager = initializeMediaXmlManagerMock(0, 250, "video/mp4", "video_url");
-
-        final String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager));
-        assertThat(bestMediaFileUrl).isEqualTo("video_url");
-    }
-
-    @Test
-    public void getBestMediaFileUrl_withNegativeDimension_shouldReturnMediaFileUrl() throws Exception {
-        final VastXmlManager.MediaXmlManager mediaXmlManager = initializeMediaXmlManagerMock(-1, 250, "video/mp4", "video_url");
-
-        final String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager));
-        assertThat(bestMediaFileUrl).isEqualTo("video_url");
-    }
-
-    @Test
-    public void getBestMediaFileUrl_withSameAspectRatios_shouldReturnUrlWithAreaCloserToScreenArea1() throws Exception {
-        // Default screen width is 480, height is 800
-        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
-        assertThat(display.getWidth()).isEqualTo(480);
-        assertThat(display.getHeight()).isEqualTo(800);
-
-        // Triple screen size
-        final VastXmlManager.MediaXmlManager mediaXmlManager1 = initializeMediaXmlManagerMock(2400, 1440, "video/mp4", "video_url1");
-        // Double screen size
-        final VastXmlManager.MediaXmlManager mediaXmlManager2 = initializeMediaXmlManagerMock(1600, 960, "video/mp4", "video_url2");
-
-        String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager1, mediaXmlManager2));
-        assertThat(bestMediaFileUrl).isEqualTo("video_url2");
-    }
-
-    @Test
-    public void getBestMediaFileUrl_withSameAspectRatios_shouldReturnUrlWithAreaCloserToScreenArea2() throws Exception {
-        // Default screen width is 480, height is 800
-        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
-        assertThat(display.getWidth()).isEqualTo(480);
-        assertThat(display.getHeight()).isEqualTo(800);
-
-        // Triple screen size
-        final VastXmlManager.MediaXmlManager mediaXmlManager1 = initializeMediaXmlManagerMock(2400, 1440, "video/mp4", "video_url1");
-        // Half screen size
-        final VastXmlManager.MediaXmlManager mediaXmlManager2 = initializeMediaXmlManagerMock(400, 240, "video/mp4", "video_url2");
-
-        String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager1, mediaXmlManager2));
-        assertThat(bestMediaFileUrl).isEqualTo("video_url2");
-    }
-
-    @Test
-    public void getBestMediaFileUrl_withSameArea_shouldReturnUrlWithAspectRatioCloserToScreenAspectRatio() throws Exception {
-        // Default screen width is 480, height is 800
-        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
-        assertThat(display.getWidth()).isEqualTo(480);
-        assertThat(display.getHeight()).isEqualTo(800);
-
-        // Landscape
-        final VastXmlManager.MediaXmlManager mediaXmlManager1 = initializeMediaXmlManagerMock(400, 240, "video/mp4", "video_url1");
-        // Portrait
-        final VastXmlManager.MediaXmlManager mediaXmlManager2 = initializeMediaXmlManagerMock(240, 400, "video/mp4", "video_url2");
-
-        String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager1, mediaXmlManager2));
-        assertThat(bestMediaFileUrl).isEqualTo("video_url1");
-    }
-
-    @Test
-    public void getBestMediaFileUrl_withInvalidMediaTypeAndNullDimension_shouldReturnUrlWithNullDimension() throws Exception {
-        // Default screen width is 480, height is 800
-        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
-        assertThat(display.getWidth()).isEqualTo(480);
-        assertThat(display.getHeight()).isEqualTo(800);
-
-        // Invalid media type
-        final VastXmlManager.MediaXmlManager mediaXmlManager1 = initializeMediaXmlManagerMock(800, 480, "video/invalid", "video_url1");
-        // Null dimension
-        final VastXmlManager.MediaXmlManager mediaXmlManager2 = initializeMediaXmlManagerMock(null, null, "video/mp4", "video_url2");
-
-        String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager1, mediaXmlManager2));
-        assertThat(bestMediaFileUrl).isEqualTo("video_url2");
-    }
-
-    @Test
-    public void getBestMediaFileUrl_withInvalidMediaTypeAndNullMediaType_shouldReturnNull() throws Exception {
-        // Default screen width is 480, height is 800
-        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
-        assertThat(display.getWidth()).isEqualTo(480);
-        assertThat(display.getHeight()).isEqualTo(800);
-
-        final VastXmlManager.MediaXmlManager mediaXmlManager1 = initializeMediaXmlManagerMock(800, 480, "video/invalid", "video_url1");
-        final VastXmlManager.MediaXmlManager mediaXmlManager2 = initializeMediaXmlManagerMock(800, 480, null, "video_url2");
-
-        String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager1, mediaXmlManager2));
-        assertThat(bestMediaFileUrl).isNull();
-    }
-
-    @Test
-    public void getBestCompanionAd_shouldReturnCompanionAd() throws Exception {
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager = initializeCompanionXmlManagerMock(300, 250, "image/jpeg", "image_url");
-
-        final VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager));
-        assertCompanionAdsAreEqual(companionXmlManager, bestCompanionAd);
-    }
-
-    @Test
-    public void getBestCompanionAd_withNullMediaType_shouldReturnNull() throws Exception {
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager = initializeCompanionXmlManagerMock(300, 250, null, "image_url");
-
-        final VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager));
-        assertThat(bestCompanionAd).isNull();
-    }
-
-    @Test
-    public void getBestCompanionAd_withIncompatibleMediaType_shouldReturnNull() throws Exception {
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager = initializeCompanionXmlManagerMock(300, 250, "image/rubbish", "image_url");
-
-        final VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager));
-        assertThat(bestCompanionAd).isNull();
-    }
-
-    @Test
-    public void getBestCompanionAd_withNullImageUrl_shouldReturnNull() throws Exception {
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager = initializeCompanionXmlManagerMock(300, 250, "image/png", null);
-
-        final VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager));
-        assertThat(bestCompanionAd).isNull();
-    }
-
-    @Test
-    public void getBestCompanionAd_withNullDimension_shouldReturnCompanionAd() throws Exception {
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager = initializeCompanionXmlManagerMock(null, 250, "image/png", "image_url");
-
-        final VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager));
-        assertCompanionAdsAreEqual(companionXmlManager, bestCompanionAd);
-    }
-
-    @Test
-    public void getBestCompanionAd_withZeroDimension_shouldReturnMediaFileUrl() throws Exception {
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager = initializeCompanionXmlManagerMock(0, 250, "image/png", "image_url");
-
-        final VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager));
-        assertCompanionAdsAreEqual(companionXmlManager, bestCompanionAd);
-    }
-
-    @Test
-    public void getBestCompanionAd_withNegativeDimension_shouldReturnMediaFileUrl() throws Exception {
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager = initializeCompanionXmlManagerMock(-300, 250, "image/png", "image_url");
-
-        final VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager));
-        assertCompanionAdsAreEqual(companionXmlManager, bestCompanionAd);
-    }
-
-    @Test
-    public void getBestCompanionAd_withSameAspectRatios_shouldReturnCompanionAdWithAreaCloserToScreenArea1() throws Exception {
-        // Default screen width is 480, height is 800
-        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
-        assertThat(display.getWidth()).isEqualTo(480);
-        assertThat(display.getHeight()).isEqualTo(800);
-
-        // Triple screen size
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager1 = initializeCompanionXmlManagerMock(2400, 1440, "image/png", "image_url1");
-        // Double screen size
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager2 = initializeCompanionXmlManagerMock(1600, 960, "image/bmp", "image_url2");
-
-        VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager1, companionXmlManager2));
-        assertCompanionAdsAreEqual(companionXmlManager2, bestCompanionAd);
-    }
-
-    @Test
-    public void getBestCompanionAd_withSameAspectRatios_shouldReturnCompanionAdWithAreaCloserToScreenArea2() throws Exception {
-        // Default screen width is 480, height is 800
-        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
-        assertThat(display.getWidth()).isEqualTo(480);
-        assertThat(display.getHeight()).isEqualTo(800);
-
-        // Triple screen size
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager1 = initializeCompanionXmlManagerMock(2400, 1440, "image/png", "image_url1");
-        // Half screen size
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager2 = initializeCompanionXmlManagerMock(400, 240, "image/bmp", "image_url2");
-
-        VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager1, companionXmlManager2));
-        assertCompanionAdsAreEqual(companionXmlManager2, bestCompanionAd);
-    }
-
-    @Test
-    public void getBestCompanionAd_withSameArea_shouldReturnCompanionAdWithAspectRatioCloserToScreenAspectRatio() throws Exception {
-        // Default screen width is 480, height is 800
-        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
-        assertThat(display.getWidth()).isEqualTo(480);
-        assertThat(display.getHeight()).isEqualTo(800);
-
-        // Landscape
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager1 = initializeCompanionXmlManagerMock(400, 240, "image/png", "image_url1");
-        // Portrait
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager2 = initializeCompanionXmlManagerMock(240, 400, "image/bmp", "image_url2");
-
-        VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager1, companionXmlManager2));
-        assertCompanionAdsAreEqual(companionXmlManager1, bestCompanionAd);
-    }
-
-    @Test
-    public void getBestCompanionAd_withInvalidMediaTypeAndNullDimension_shouldReturnCompanionAdWithNullDimension() throws Exception {
-        // Default screen width is 480, height is 800
-        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
-        assertThat(display.getWidth()).isEqualTo(480);
-        assertThat(display.getHeight()).isEqualTo(800);
-
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager1 = initializeCompanionXmlManagerMock(800, 480, "image/invalid", "image_url1");
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager2 = initializeCompanionXmlManagerMock(null, null, "image/bmp", "image_url2");
-
-        VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager1, companionXmlManager2));
-        assertCompanionAdsAreEqual(companionXmlManager2, bestCompanionAd);
-    }
-
-    @Test
-    public void getBestCompanionAdithInvalidMediaTypeAndNullMediaType_shouldReturnNull() throws Exception {
-        // Default screen width is 480, height is 800
-        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
-        assertThat(display.getWidth()).isEqualTo(480);
-        assertThat(display.getHeight()).isEqualTo(800);
-
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager1 = initializeCompanionXmlManagerMock(800, 480, "image/invalid", "image_url1");
-        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager2 = initializeCompanionXmlManagerMock(800, 480, null, "image_url2");
-
-        VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager1, companionXmlManager2));
-        assertThat(bestCompanionAd).isEqualTo(null);
-    }
-
-    private VastXmlManager.MediaXmlManager initializeMediaXmlManagerMock(
-            final Integer width,
-            final Integer height,
-            final String type,
-            final String mediaUrl) {
-        VastXmlManager.MediaXmlManager mediaXmlManager = mock(VastXmlManager.MediaXmlManager.class);
-        when(mediaXmlManager.getWidth()).thenReturn(width);
-        when(mediaXmlManager.getHeight()).thenReturn(height);
-        when(mediaXmlManager.getType()).thenReturn(type);
-        when(mediaXmlManager.getMediaUrl()).thenReturn(mediaUrl);
-        return mediaXmlManager;
-    }
-
-    private VastXmlManager.ImageCompanionAdXmlManager initializeCompanionXmlManagerMock(
-            final Integer width,
-            final Integer height,
-            final String type,
-            final String imageUrl) {
-        VastXmlManager.ImageCompanionAdXmlManager companionXmlManager = mock(VastXmlManager.ImageCompanionAdXmlManager.class);
-        when(companionXmlManager.getWidth()).thenReturn(width);
-        when(companionXmlManager.getHeight()).thenReturn(height);
-        when(companionXmlManager.getType()).thenReturn(type);
-        when(companionXmlManager.getImageUrl()).thenReturn(imageUrl);
-        return companionXmlManager;
-    }
-
-    private void assertCompanionAdsAreEqual(
-            final VastXmlManager.ImageCompanionAdXmlManager imageCompanionAdXmlManager,
-            final VastCompanionAd vastCompanionAd) {
-        final VastCompanionAd vastCompanionAd1 = new VastCompanionAd(
-                imageCompanionAdXmlManager.getWidth(),
-                imageCompanionAdXmlManager.getHeight(),
-                imageCompanionAdXmlManager.getImageUrl(),
-                imageCompanionAdXmlManager.getClickThroughUrl(),
-                new ArrayList<String>(imageCompanionAdXmlManager.getClickTrackers())
-        );
-        assertCompanionAdsAreEqual(vastCompanionAd, vastCompanionAd1);
-    }
-
-    private void assertCompanionAdsAreEqual(
-            final VastCompanionAd vastCompanionAd1,
-            final VastCompanionAd vastCompanionAd2) {
-        assertThat(vastCompanionAd1.getWidth()).isEqualTo(vastCompanionAd2.getWidth());
-        assertThat(vastCompanionAd1.getHeight()).isEqualTo(vastCompanionAd2.getHeight());
-        assertThat(vastCompanionAd1.getImageUrl()).isEqualTo(vastCompanionAd2.getImageUrl());
-        assertThat(vastCompanionAd1.getClickThroughUrl()).isEqualTo(vastCompanionAd2.getClickThroughUrl());
-        assertThat(vastCompanionAd1.getClickTrackers()).isEqualTo(vastCompanionAd2.getClickTrackers());
-    }
-}
+package com.mopub.mobileads.util.vast;
+
+import android.app.Activity;
+import android.content.Context;
+import android.view.Display;
+import android.view.WindowManager;
+
+import com.mopub.common.CacheService;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.DeviceUtils;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
+import org.robolectric.tester.org.apache.http.FakeHttpLayer;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.concurrent.Semaphore;
+
+import static com.mopub.mobileads.util.vast.VastManager.VastManagerListener;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class VastManagerTest {
+    static final String EXTENSIONS_SNIPPET_PLACEHOLDER = "<![CDATA[EXTENSIONS_SNIPPET]]>";
+    static final String TEST_VAST_XML_STRING = "<VAST version='2.0'><Ad id='62833'><Wrapper><AdSystem>Tapad</AdSystem><VASTAdTagURI>http://dsp.x-team.staging.mopub.com/xml</VASTAdTagURI><Impression>http://myTrackingURL/wrapper/impression1</Impression><Impression>http://myTrackingURL/wrapper/impression2</Impression><Creatives><Creative AdID='62833'><Linear><TrackingEvents><Tracking event='creativeView'>http://myTrackingURL/wrapper/creativeView</Tracking><Tracking event='start'>http://myTrackingURL/wrapper/start</Tracking><Tracking event='midpoint'>http://myTrackingURL/wrapper/midpoint</Tracking><Tracking event='progress' offset='00:00:03.100'>http://myTrackingURL/wrapper/progress</Tracking><Tracking event='firstQuartile'>http://myTrackingURL/wrapper/firstQuartile</Tracking><Tracking event='thirdQuartile'>http://myTrackingURL/wrapper/thirdQuartile</Tracking><Tracking event='complete'>http://myTrackingURL/wrapper/complete</Tracking><Tracking event='close'>http://myTrackingURL/wrapper/close</Tracking><Tracking event='skip'>http://myTrackingURL/wrapper/skip</Tracking><Tracking event='mute'>http://myTrackingURL/wrapper/mute</Tracking><Tracking event='unmute'>http://myTrackingURL/wrapper/unmute</Tracking><Tracking event='pause'>http://myTrackingURL/wrapper/pause</Tracking><Tracking event='resume'>http://myTrackingURL/wrapper/resume</Tracking><Tracking event='fullscreen'>http://myTrackingURL/wrapper/fullscreen</Tracking></TrackingEvents><VideoClicks><ClickTracking>http://myTrackingURL/wrapper/click</ClickTracking></VideoClicks><MediaFiles><MediaFile delivery='progressive' bitrate='416' width='300' height='250' type='video/mp4'><![CDATA[https://s3.amazonaws.com/mopub-vast/tapad-video1.mp4]]></MediaFile></MediaFiles></Linear></Creative><Creative AdID=\"601364-Companion\"> <CompanionAds><Companion width=\"9000\"></Companion> </CompanionAds></Creative></Creatives><![CDATA[EXTENSIONS_SNIPPET]]></Wrapper></Ad></VAST><MP_TRACKING_URLS><MP_TRACKING_URL>http://www.mopub.com/imp1</MP_TRACKING_URL><MP_TRACKING_URL>http://www.mopub.com/imp2</MP_TRACKING_URL></MP_TRACKING_URLS>";
+    static final String TEST_NESTED_VAST_XML_STRING = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><VAST version='2.0'><Ad id='57722'><InLine><AdSystem version='1.0'>Tapad</AdSystem><AdTitle><![CDATA[PKW6T_LIV_DSN_Audience_TAPAD_3rd Party Audience Targeting_Action Movi]]></AdTitle><Description/><Impression><![CDATA[http://rtb-test.dev.tapad.com:8080/creative/imp.png?ts=1374099035457&svid=1&creative_id=30731&ctx_type=InApp&ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&liverail_cp=1]]></Impression><Creatives><Creative sequence='1' id='57722'><Linear><TrackingEvents><Tracking event='close'>http://myTrackingURL/wrapper/nested_close</Tracking><Tracking event='skip'>http://myTrackingURL/wrapper/nested_skip</Tracking></TrackingEvents><Duration>00:00:15</Duration><VideoClicks><ClickThrough><![CDATA[http://rtb-test.dev.tapad.com:8080/click?ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&crid=30731&ta_action_id=click&ts=1374099035458&redirect=http%3A%2F%2Ftapad.com]]></ClickThrough></VideoClicks><MediaFiles><MediaFile delivery='progressive' bitrate='416' width='800' height='480' type='video/mp4'><![CDATA[https://s3.amazonaws.com/mopub-vast/tapad-video.mp4]]></MediaFile></MediaFiles></Linear></Creative><Creative AdID=\"601364-Companion\"><CompanionAds><Companion id=\"valid\" height=\"250\" width=\"300\"><StaticResource creativeType=\"image/jpeg\">http://demo.tremormedia.com/proddev/vast/Blistex1.jpg</StaticResource><TrackingEvents><Tracking event=\"creativeView\">http://myTrackingURL/firstCompanionCreativeView</Tracking><Tracking event=\"creativeView\">http://myTrackingURL/secondCompanionCreativeView</Tracking></TrackingEvents><CompanionClickThrough>http://www.tremormedia.com</CompanionClickThrough></Companion></CompanionAds></Creative></Creatives><![CDATA[EXTENSIONS_SNIPPET]]></InLine></Ad></VAST>";
+    static final String TEST_VAST_BAD_NEST_URL_XML_STRING = "<VAST version='2.0'><Ad id='62833'><Wrapper><AdSystem>Tapad</AdSystem><VASTAdTagURI>http://dsp.x-team.staging.mopub.com/xml\"$|||</VASTAdTagURI><Impression>http://myTrackingURL/wrapper/impression1</Impression><Impression>http://myTrackingURL/wrapper/impression2</Impression><Creatives><Creative AdID='62833'><Linear><TrackingEvents><Tracking event='creativeView'>http://myTrackingURL/wrapper/creativeView</Tracking><Tracking event='start'>http://myTrackingURL/wrapper/start</Tracking><Tracking event='midpoint'>http://myTrackingURL/wrapper/midpoint</Tracking><Tracking event='firstQuartile'>http://myTrackingURL/wrapper/firstQuartile</Tracking><Tracking event='thirdQuartile'>http://myTrackingURL/wrapper/thirdQuartile</Tracking><Tracking event='complete'>http://myTrackingURL/wrapper/complete</Tracking><Tracking event='mute'>http://myTrackingURL/wrapper/mute</Tracking><Tracking event='unmute'>http://myTrackingURL/wrapper/unmute</Tracking><Tracking event='pause'>http://myTrackingURL/wrapper/pause</Tracking><Tracking event='resume'>http://myTrackingURL/wrapper/resume</Tracking><Tracking event='fullscreen'>http://myTrackingURL/wrapper/fullscreen</Tracking></TrackingEvents><VideoClicks><ClickTracking>http://myTrackingURL/wrapper/click</ClickTracking></VideoClicks></Linear></Creative></Creatives></Wrapper></Ad></VAST><MP_TRACKING_URLS><MP_TRACKING_URL>http://www.mopub.com/imp1</MP_TRACKING_URL><MP_TRACKING_URL>http://www.mopub.com/imp2</MP_TRACKING_URL></MP_TRACKING_URLS>";
+
+    private VastManager subject;
+    private FakeHttpLayer mFakeHttpLayer;
+    private VastManagerListener vastManagerListener;
+    private Activity context;
+    private VastVideoConfiguration vastVideoConfiguration;
+    private Semaphore semaphore;
+
+    @Before
+    public void setup() {
+        context = Robolectric.buildActivity(Activity.class).create().get();
+        CacheService.initializeDiskCache(context);
+        subject = new VastManager(context);
+        mFakeHttpLayer = Robolectric.getFakeHttpLayer();
+
+        semaphore = new Semaphore(0);
+        vastManagerListener = mock(VastManagerListener.class);
+        doAnswer(new Answer() {
+            @Override
+            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+                Object[] args = invocationOnMock.getArguments();
+                VastManagerTest.this.vastVideoConfiguration = (VastVideoConfiguration) args[0];
+                semaphore.release();
+                return null;
+            }
+        }).when(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+    }
+
+    private void prepareVastVideoConfiguration() {
+        subject.prepareVastVideoConfiguration(TEST_VAST_XML_STRING, vastManagerListener);
+
+        Robolectric.runBackgroundTasks();
+        Robolectric.runUiThreadTasks();
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_shouldNotifyTheListenerAndContainTheCorrectVastValues() throws Exception {
+        // Vast redirect responses
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+
+        assertThat(vastVideoConfiguration.getNetworkMediaFileUrl()).isEqualTo("https://s3.amazonaws.com/mopub-vast/tapad-video.mp4");
+
+        final String expectedFilePathDiskCache = CacheService.getFilePathDiskCache(vastVideoConfiguration.getNetworkMediaFileUrl());
+        assertThat(vastVideoConfiguration.getDiskMediaFileUrl()).isEqualTo(expectedFilePathDiskCache);
+
+        assertThat(vastVideoConfiguration.getClickThroughUrl()).isEqualTo("http://rtb-test.dev.tapad.com:8080/click?ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&crid=30731&ta_action_id=click&ts=1374099035458&redirect=http%3A%2F%2Ftapad.com");
+        assertThat(vastVideoConfiguration.getImpressionTrackers().size()).isEqualTo(5);
+
+        // Verify quartile trackers
+        assertThat(vastVideoConfiguration.getFractionalTrackers().size()).isEqualTo(3);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(0).trackingFraction()).isEqualTo(0.25f);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(1).trackingFraction()).isEqualTo(0.5f);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(2).trackingFraction()).isEqualTo(0.75f);
+
+        // Verify start tracker.
+        assertThat(vastVideoConfiguration.getAbsoluteTrackers().size()).isEqualTo(2);
+        assertThat(vastVideoConfiguration.getAbsoluteTrackers().get(0).getTrackingMilliseconds()).isEqualTo(2000);
+        assertThat(vastVideoConfiguration.getAbsoluteTrackers().get(1).getTrackingMilliseconds()).isEqualTo(3100);
+
+        assertThat(vastVideoConfiguration.getCompleteTrackers().size()).isEqualTo(1);
+
+        // We specifically added a close tracker and a skip tracker to the nested vast test case as well,
+        // therefore there are two expected trackers total for each type.
+        assertThat(vastVideoConfiguration.getCloseTrackers().size()).isEqualTo(2);
+        assertThat(vastVideoConfiguration.getSkipTrackers().size()).isEqualTo(2);
+        assertThat(vastVideoConfiguration.getClickTrackers().size()).isEqualTo(1);
+
+        final VastCompanionAd vastCompanionAd = vastVideoConfiguration.getVastCompanionAd();
+        assertThat(vastCompanionAd.getWidth()).isEqualTo(300);
+        assertThat(vastCompanionAd.getHeight()).isEqualTo(250);
+        assertThat(vastCompanionAd.getImageUrl()).isEqualTo("http://demo.tremormedia.com/proddev/vast/Blistex1.jpg");
+        assertThat(vastCompanionAd.getClickThroughUrl()).isEqualTo("http://www.tremormedia.com");
+        assertThat(vastCompanionAd.getClickTrackers())
+                .containsOnly("http://myTrackingURL/firstCompanionCreativeView", "http://myTrackingURL/secondCompanionCreativeView");
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_shouldHandleMultipleRedirects() throws Exception {
+        // Vast redirect responses
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_VAST_XML_STRING);
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_VAST_XML_STRING);
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+
+        // at this point it should have 3 sets of data from TEST_VAST_XML_STRING and one set from TEST_NESTED_VAST_XML_STRING
+        assertThat(vastVideoConfiguration.getNetworkMediaFileUrl()).isEqualTo("https://s3.amazonaws.com/mopub-vast/tapad-video.mp4");
+        final String expectedFilePathDiskCache = CacheService.getFilePathDiskCache(vastVideoConfiguration.getNetworkMediaFileUrl());
+        assertThat(vastVideoConfiguration.getDiskMediaFileUrl()).isEqualTo(expectedFilePathDiskCache);
+
+        assertThat(vastVideoConfiguration.getClickThroughUrl()).isEqualTo("http://rtb-test.dev.tapad.com:8080/click?ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&crid=30731&ta_action_id=click&ts=1374099035458&redirect=http%3A%2F%2Ftapad.com");
+        assertThat(vastVideoConfiguration.getImpressionTrackers().size()).isEqualTo(13);
+
+        assertThat(vastVideoConfiguration.getAbsoluteTrackers().size()).isEqualTo(6);
+        assertThat(vastVideoConfiguration.getAbsoluteTrackers().get(0).getTrackingMilliseconds()).isEqualTo(2000);
+        assertThat(vastVideoConfiguration.getAbsoluteTrackers().get(1).getTrackingMilliseconds()).isEqualTo(2000);
+        assertThat(vastVideoConfiguration.getAbsoluteTrackers().get(2).getTrackingMilliseconds()).isEqualTo(2000);
+        assertThat(vastVideoConfiguration.getAbsoluteTrackers().get(3).getTrackingMilliseconds()).isEqualTo(3100);
+        assertThat(vastVideoConfiguration.getAbsoluteTrackers().get(4).getTrackingMilliseconds()).isEqualTo(3100);
+        assertThat(vastVideoConfiguration.getAbsoluteTrackers().get(5).getTrackingMilliseconds()).isEqualTo(3100);
+
+
+        assertThat(vastVideoConfiguration.getFractionalTrackers().size()).isEqualTo(9);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(0).trackingFraction()).isEqualTo(0.25f);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(1).trackingFraction()).isEqualTo(0.25f);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(2).trackingFraction()).isEqualTo(0.25f);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(3).trackingFraction()).isEqualTo(0.5f);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(4).trackingFraction()).isEqualTo(0.5f);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(5).trackingFraction()).isEqualTo(0.5f);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(6).trackingFraction()).isEqualTo(0.75f);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(7).trackingFraction()).isEqualTo(0.75f);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(8).trackingFraction()).isEqualTo(0.75f);
+
+        assertThat(vastVideoConfiguration.getCompleteTrackers().size()).isEqualTo(3);
+        assertThat(vastVideoConfiguration.getCloseTrackers().size()).isEqualTo(4);
+        assertThat(vastVideoConfiguration.getSkipTrackers().size()).isEqualTo(4);
+        assertThat(vastVideoConfiguration.getClickTrackers().size()).isEqualTo(3);
+
+        final VastCompanionAd vastCompanionAd = vastVideoConfiguration.getVastCompanionAd();
+        assertThat(vastCompanionAd.getWidth()).isEqualTo(300);
+        assertThat(vastCompanionAd.getHeight()).isEqualTo(250);
+        assertThat(vastCompanionAd.getImageUrl()).isEqualTo("http://demo.tremormedia.com/proddev/vast/Blistex1.jpg");
+        assertThat(vastCompanionAd.getClickThroughUrl()).isEqualTo("http://www.tremormedia.com");
+        assertThat(vastCompanionAd.getClickTrackers())
+                .containsOnly("http://myTrackingURL/firstCompanionCreativeView", "http://myTrackingURL/secondCompanionCreativeView");
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_shouldReturnCorrectVastValuesWhenAVastRedirectFails() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(404, "");
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+
+        assertThat(vastVideoConfiguration.getNetworkMediaFileUrl()).isEqualTo("https://s3.amazonaws.com/mopub-vast/tapad-video1.mp4");
+
+        final String expectedFilePathDiskCache = CacheService.getFilePathDiskCache(vastVideoConfiguration.getNetworkMediaFileUrl());
+        assertThat(vastVideoConfiguration.getDiskMediaFileUrl()).isEqualTo(expectedFilePathDiskCache);
+
+        assertThat(vastVideoConfiguration.getClickThroughUrl()).isEqualTo(null);
+        assertThat(vastVideoConfiguration.getImpressionTrackers().size()).isEqualTo(4);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().size()).isEqualTo(3);
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withNoExtensions_shouldContainTheCorrectDefaultExtensionValues() throws Exception {
+        // Vast redirect response to XML without VAST extensions
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+
+        assertThat(vastVideoConfiguration.getCustomCtaText()).isNull();
+        assertThat(vastVideoConfiguration.getCustomSkipText()).isNull();
+        assertThat(vastVideoConfiguration.getCustomCloseIconUrl()).isNull();
+        assertThat(vastVideoConfiguration.getCustomForceOrientation()).isEqualTo(DeviceUtils.ForceOrientation.FORCE_LANDSCAPE);
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withExtensionsUnderWrapper_shouldContainTheCorrectCustomExtensionValues() throws Exception {
+        // Vast redirect response to XML without extensions
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        // Add extensions under Wrapper element in TEST_VAST_XML_STRING
+        subject.prepareVastVideoConfiguration(
+                TEST_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubCtaText>custom CTA text</MoPubCtaText>" +
+                                "<MoPubSkipText>skip</MoPubSkipText>" +
+                                "<MoPubCloseIcon>http://ton.twitter.com/exchange-media/images/v4/star_icon_3x.png</MoPubCloseIcon>" +
+                                "<MoPubForceOrientation>device</MoPubForceOrientation>" +
+                            "</Extension>" +
+                        "</Extensions>"),
+                vastManagerListener);
+
+        Robolectric.runBackgroundTasks();
+        Robolectric.runUiThreadTasks();
+        semaphore.acquire();
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+
+        // Verify custom extensions
+        assertThat(vastVideoConfiguration.getCustomCtaText()).isEqualTo("custom CTA text");
+        assertThat(vastVideoConfiguration.getCustomSkipText()).isEqualTo("skip");
+        assertThat(vastVideoConfiguration.getCustomCloseIconUrl()).isEqualTo("http://ton.twitter.com/exchange-media/images/v4/star_icon_3x.png");
+        assertThat(vastVideoConfiguration.getCustomForceOrientation()).isEqualTo(DeviceUtils.ForceOrientation.DEVICE_ORIENTATION);
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withExtensionsUnderInline_shouldContainTheCorrectCustomExtensionValues() throws Exception {
+        // Vast redirect response to XML with extensions under Inline element
+        mFakeHttpLayer.addPendingHttpResponse(200,
+                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubCtaText>custom CTA text</MoPubCtaText>" +
+                                "<MoPubSkipText>skip</MoPubSkipText>" +
+                                "<MoPubCloseIcon>http://ton.twitter.com/exchange-media/images/v4/star_icon_3x.png</MoPubCloseIcon>" +
+                                "<MoPubForceOrientation>device</MoPubForceOrientation>" +
+                            "</Extension>" +
+                        "</Extensions>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+
+        // Verify custom extensions
+        assertThat(vastVideoConfiguration.getCustomCtaText()).isEqualTo("custom CTA text");
+        assertThat(vastVideoConfiguration.getCustomSkipText()).isEqualTo("skip");
+        assertThat(vastVideoConfiguration.getCustomCloseIconUrl()).isEqualTo("http://ton.twitter.com/exchange-media/images/v4/star_icon_3x.png");
+        assertThat(vastVideoConfiguration.getCustomForceOrientation()).isEqualTo(DeviceUtils.ForceOrientation.DEVICE_ORIENTATION);
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withExtensionsUnderBothWrapperAndInline_shouldContainLastParsedCustomExtensionValues() throws Exception {
+        // Vast redirect response to XML with extensions under Inline element in TEST_NESTED_VAST_XML_STRING, will be parsed last
+        mFakeHttpLayer.addPendingHttpResponse(200,
+                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubCtaText>CTA 2</MoPubCtaText>" +
+                                "<MoPubSkipText>skip 2</MoPubSkipText>" +
+                                "<MoPubCloseIcon>http://ton.twitter.com/exchange-media/images/v4/star_icon_3x_2.png</MoPubCloseIcon>" +
+                                "<MoPubForceOrientation>landscape</MoPubForceOrientation>" +
+                            "</Extension>" +
+                        "</Extensions>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        // Also add extensions under Wrapper element in TEST_VAST_XML_STRING
+        subject.prepareVastVideoConfiguration(
+                TEST_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubCtaText>CTA 1</MoPubCtaText>" +
+                                "<MoPubSkipText>skip 1</MoPubSkipText>" +
+                                "<MoPubCloseIcon>http://ton.twitter.com/exchange-media/images/v4/star_icon_3x_1.png</MoPubCloseIcon>" +
+                                "<MoPubForceOrientation>device orientation</MoPubForceOrientation>" +
+                            "</Extension>" +
+                        "</Extensions>"),
+                vastManagerListener);
+
+        Robolectric.runBackgroundTasks();
+        Robolectric.runUiThreadTasks();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+
+        // Verify custom extension values are the ones last parsed in TEST_NESTED_VAST_XML_STRING
+        assertThat(vastVideoConfiguration.getCustomCtaText()).isEqualTo("CTA 2");
+        assertThat(vastVideoConfiguration.getCustomSkipText()).isEqualTo("skip 2");
+        assertThat(vastVideoConfiguration.getCustomCloseIconUrl()).isEqualTo("http://ton.twitter.com/exchange-media/images/v4/star_icon_3x_2.png");
+        assertThat(vastVideoConfiguration.getCustomForceOrientation()).isEqualTo(DeviceUtils.ForceOrientation.FORCE_LANDSCAPE);
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withCustomCtaTextAsSingleSpace_shouldReturnEmptyString() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200,
+                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubCtaText> </MoPubCtaText>" +     // single space, i.e. no text
+                            "</Extension>" +
+                        "</Extensions>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+        assertThat(vastVideoConfiguration.getCustomCtaText()).isEmpty();
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withCustomCtaTextLongerThan15Chars_shouldReturnNull() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200,
+                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubCtaText>1234567890123456</MoPubCtaText>" +     // 16 chars
+                            "</Extension>" +
+                        "</Extensions>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+        assertThat(vastVideoConfiguration.getCustomCtaText()).isNull();
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withCustomSkipTextLongerThan8Chars_shouldReturnNull() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200,
+                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubSkipText>123456789</MoPubSkipText>" +     // 9 chars
+                            "</Extension>" +
+                        "</Extensions>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+        assertThat(vastVideoConfiguration.getCustomSkipText()).isNull();
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withInvalidCustomForceOrientation_shouldReturnDefaultForceLandscapeOrientation() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200,
+                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubForceOrientation>abcd</MoPubForceOrientation>" +   // invalid value
+                            "</Extension>" +
+                        "</Extensions>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+        assertThat(vastVideoConfiguration.getCustomForceOrientation()).isEqualTo(DeviceUtils.ForceOrientation.FORCE_LANDSCAPE);
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withCustomForceOrientationInMixedCaseAndUntrimmed_shouldReturnCustomForceOrientation() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200,
+                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubForceOrientation> PortRAIT  </MoPubForceOrientation>" +
+                            "</Extension>" +
+                        "</Extensions>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+        assertThat(vastVideoConfiguration.getCustomForceOrientation()).isEqualTo(DeviceUtils.ForceOrientation.FORCE_PORTRAIT);
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withValidPercentSkipOffset_shouldReturnCorrectValue() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset='25%'>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+
+        assertThat(vastVideoConfiguration.getSkipOffset()).isEqualTo("25%");
+    }
+
+
+    @Test
+    public void prepareVastVideoConfiguration_withValidAbsoluteSkipOffset_shouldReturnCorrectValue() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset='  00:03:14 '>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+
+        assertThat(vastVideoConfiguration.getSkipOffset()).isEqualTo("00:03:14");
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withValidAbsoluteSkipOffsetWithExtraSpace_shouldReturnCorrectTrimmedValue() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset='  00:03:14.159 '>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+
+        assertThat(vastVideoConfiguration.getSkipOffset()).isEqualTo("00:03:14.159");
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withSkipOffsets_shouldReturnLastParsedValue() throws Exception {
+        // Vast redirect response with skipoffset in percent format
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset='25%'>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        // Also add a skipoffset in absolute format
+        subject.prepareVastVideoConfiguration(
+                TEST_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset='00:03:14'>"),
+                vastManagerListener);
+
+        Robolectric.runBackgroundTasks();
+        Robolectric.runUiThreadTasks();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+
+        // Verify that the last parsed skipoffset value is returned
+        assertThat(vastVideoConfiguration.getSkipOffset()).isEqualTo("25%");
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withEmptySkipOffset_shouldReturnNull() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset=' '>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+
+        assertThat(vastVideoConfiguration.getSkipOffset()).isNull();
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withNoMediaUrlInXml_shouldReturnNull() throws Exception {
+        subject.prepareVastVideoConfiguration(TEST_VAST_BAD_NEST_URL_XML_STRING, vastManagerListener);
+
+        Robolectric.runBackgroundTasks();
+        Robolectric.runUiThreadTasks();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(null);
+        assertThat(vastVideoConfiguration).isEqualTo(null);
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withNullXml_shouldReturnNull() throws Exception {
+        subject.prepareVastVideoConfiguration(null, vastManagerListener);
+
+        Robolectric.runBackgroundTasks();
+        Robolectric.runUiThreadTasks();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(null);
+        assertThat(vastVideoConfiguration).isEqualTo(null);
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withEmptyXml_shouldReturnNull() throws Exception {
+        subject.prepareVastVideoConfiguration("", vastManagerListener);
+
+        Robolectric.runBackgroundTasks();
+        Robolectric.runUiThreadTasks();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(null);
+        assertThat(vastVideoConfiguration).isEqualTo(null);
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withVideoInDiskCache_shouldNotDownloadVideo() throws Exception {
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
+
+        CacheService.putToDiskCache("https://s3.amazonaws.com/mopub-vast/tapad-video.mp4", "video_data".getBytes());
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        assertThat(mFakeHttpLayer.getSentHttpRequestInfos().size()).isEqualTo(1);
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+        assertThat(vastVideoConfiguration.getDiskMediaFileUrl())
+                .isEqualTo(CacheService.getFilePathDiskCache("https://s3.amazonaws.com/mopub-vast/tapad-video.mp4"));
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withUninitializedDiskCache_shouldReturnNull() throws Exception {
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(null);
+        assertThat(vastVideoConfiguration).isEqualTo(null);
+    }
+
+    @Test
+    public void cancel_shouldCancelBackgroundProcessingAndNotNotifyListenerWithNull() throws Exception {
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
+
+        Robolectric.getBackgroundScheduler().pause();
+
+        subject.prepareVastVideoConfiguration(TEST_VAST_XML_STRING, vastManagerListener);
+
+        subject.cancel();
+
+        Robolectric.runBackgroundTasks();
+        Robolectric.runUiThreadTasks();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(null);
+        assertThat(vastVideoConfiguration).isEqualTo(null);
+    }
+
+    @Test
+    public void getBestMediaFileUrl_shouldReturnMediaFileUrl() throws Exception {
+        final VastXmlManager.MediaXmlManager mediaXmlManager = initializeMediaXmlManagerMock(300, 250, "video/mp4", "video_url");
+
+        final String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager));
+        assertThat(bestMediaFileUrl).isEqualTo("video_url");
+    }
+
+    @Test
+    public void getBestMediaFileUrl_withNullMediaType_shouldReturnNull() throws Exception {
+        final VastXmlManager.MediaXmlManager mediaXmlManager = initializeMediaXmlManagerMock(300, 250, null, "video_url");
+
+        final String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager));
+        assertThat(bestMediaFileUrl).isNull();
+    }
+
+    @Test
+    public void getBestMediaFileUrl_withIncompatibleMediaType_shouldReturnNull() throws Exception {
+        final VastXmlManager.MediaXmlManager mediaXmlManager = initializeMediaXmlManagerMock(300, 250, "video/rubbish", "video_url");
+
+        final String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager));
+        assertThat(bestMediaFileUrl).isNull();
+    }
+
+    @Test
+    public void getBestMediaFileUrl_withNullMediaUrl_shouldReturnNull() throws Exception {
+        final VastXmlManager.MediaXmlManager mediaXmlManager = initializeMediaXmlManagerMock(300, 250, "video/mp4", null);
+
+        final String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager));
+        assertThat(bestMediaFileUrl).isNull();
+    }
+
+    @Test
+    public void getBestMediaFileUrl_withNullDimension_shouldReturnMediaFileUrl() throws Exception {
+        final VastXmlManager.MediaXmlManager mediaXmlManager = initializeMediaXmlManagerMock(null, 250, "video/mp4", "video_url");
+
+        final String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager));
+        assertThat(bestMediaFileUrl).isEqualTo("video_url");
+    }
+
+    @Test
+    public void getBestMediaFileUrl_withZeroDimension_shouldReturnMediaFileUrl() throws Exception {
+        final VastXmlManager.MediaXmlManager mediaXmlManager = initializeMediaXmlManagerMock(0, 250, "video/mp4", "video_url");
+
+        final String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager));
+        assertThat(bestMediaFileUrl).isEqualTo("video_url");
+    }
+
+    @Test
+    public void getBestMediaFileUrl_withNegativeDimension_shouldReturnMediaFileUrl() throws Exception {
+        final VastXmlManager.MediaXmlManager mediaXmlManager = initializeMediaXmlManagerMock(-1, 250, "video/mp4", "video_url");
+
+        final String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager));
+        assertThat(bestMediaFileUrl).isEqualTo("video_url");
+    }
+
+    @Test
+    public void getBestMediaFileUrl_withSameAspectRatios_shouldReturnUrlWithAreaCloserToScreenArea1() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        // Triple screen size
+        final VastXmlManager.MediaXmlManager mediaXmlManager1 = initializeMediaXmlManagerMock(2400, 1440, "video/mp4", "video_url1");
+        // Double screen size
+        final VastXmlManager.MediaXmlManager mediaXmlManager2 = initializeMediaXmlManagerMock(1600, 960, "video/mp4", "video_url2");
+
+        String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager1, mediaXmlManager2));
+        assertThat(bestMediaFileUrl).isEqualTo("video_url2");
+    }
+
+    @Test
+    public void getBestMediaFileUrl_withSameAspectRatios_shouldReturnUrlWithAreaCloserToScreenArea2() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        // Triple screen size
+        final VastXmlManager.MediaXmlManager mediaXmlManager1 = initializeMediaXmlManagerMock(2400, 1440, "video/mp4", "video_url1");
+        // Half screen size
+        final VastXmlManager.MediaXmlManager mediaXmlManager2 = initializeMediaXmlManagerMock(400, 240, "video/mp4", "video_url2");
+
+        String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager1, mediaXmlManager2));
+        assertThat(bestMediaFileUrl).isEqualTo("video_url2");
+    }
+
+    @Test
+    public void getBestMediaFileUrl_withSameArea_shouldReturnUrlWithAspectRatioCloserToScreenAspectRatio() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        // Landscape
+        final VastXmlManager.MediaXmlManager mediaXmlManager1 = initializeMediaXmlManagerMock(400, 240, "video/mp4", "video_url1");
+        // Portrait
+        final VastXmlManager.MediaXmlManager mediaXmlManager2 = initializeMediaXmlManagerMock(240, 400, "video/mp4", "video_url2");
+
+        String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager1, mediaXmlManager2));
+        assertThat(bestMediaFileUrl).isEqualTo("video_url1");
+    }
+
+    @Test
+    public void getBestMediaFileUrl_withInvalidMediaTypeAndNullDimension_shouldReturnUrlWithNullDimension() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        // Invalid media type
+        final VastXmlManager.MediaXmlManager mediaXmlManager1 = initializeMediaXmlManagerMock(800, 480, "video/invalid", "video_url1");
+        // Null dimension
+        final VastXmlManager.MediaXmlManager mediaXmlManager2 = initializeMediaXmlManagerMock(null, null, "video/mp4", "video_url2");
+
+        String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager1, mediaXmlManager2));
+        assertThat(bestMediaFileUrl).isEqualTo("video_url2");
+    }
+
+    @Test
+    public void getBestMediaFileUrl_withInvalidMediaTypeAndNullMediaType_shouldReturnNull() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        final VastXmlManager.MediaXmlManager mediaXmlManager1 = initializeMediaXmlManagerMock(800, 480, "video/invalid", "video_url1");
+        final VastXmlManager.MediaXmlManager mediaXmlManager2 = initializeMediaXmlManagerMock(800, 480, null, "video_url2");
+
+        String bestMediaFileUrl = subject.getBestMediaFileUrl(Arrays.asList(mediaXmlManager1, mediaXmlManager2));
+        assertThat(bestMediaFileUrl).isNull();
+    }
+
+    @Test
+    public void getBestCompanionAd_shouldReturnCompanionAd() throws Exception {
+        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager = initializeCompanionXmlManagerMock(300, 250, "image/jpeg", "image_url");
+
+        final VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager));
+        assertCompanionAdsAreEqual(companionXmlManager, bestCompanionAd);
+    }
+
+    @Test
+    public void getBestCompanionAd_withNullMediaType_shouldReturnNull() throws Exception {
+        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager = initializeCompanionXmlManagerMock(300, 250, null, "image_url");
+
+        final VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager));
+        assertThat(bestCompanionAd).isNull();
+    }
+
+    @Test
+    public void getBestCompanionAd_withIncompatibleMediaType_shouldReturnNull() throws Exception {
+        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager = initializeCompanionXmlManagerMock(300, 250, "image/rubbish", "image_url");
+
+        final VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager));
+        assertThat(bestCompanionAd).isNull();
+    }
+
+    @Test
+    public void getBestCompanionAd_withNullImageUrl_shouldReturnNull() throws Exception {
+        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager = initializeCompanionXmlManagerMock(300, 250, "image/png", null);
+
+        final VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager));
+        assertThat(bestCompanionAd).isNull();
+    }
+
+    @Test
+    public void getBestCompanionAd_withNullDimension_shouldReturnCompanionAd() throws Exception {
+        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager = initializeCompanionXmlManagerMock(null, 250, "image/png", "image_url");
+
+        final VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager));
+        assertCompanionAdsAreEqual(companionXmlManager, bestCompanionAd);
+    }
+
+    @Test
+    public void getBestCompanionAd_withZeroDimension_shouldReturnMediaFileUrl() throws Exception {
+        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager = initializeCompanionXmlManagerMock(0, 250, "image/png", "image_url");
+
+        final VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager));
+        assertCompanionAdsAreEqual(companionXmlManager, bestCompanionAd);
+    }
+
+    @Test
+    public void getBestCompanionAd_withNegativeDimension_shouldReturnMediaFileUrl() throws Exception {
+        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager = initializeCompanionXmlManagerMock(-300, 250, "image/png", "image_url");
+
+        final VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager));
+        assertCompanionAdsAreEqual(companionXmlManager, bestCompanionAd);
+    }
+
+    @Test
+    public void getBestCompanionAd_withSameAspectRatios_shouldReturnCompanionAdWithAreaCloserToScreenArea1() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        // Triple screen size
+        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager1 = initializeCompanionXmlManagerMock(2400, 1440, "image/png", "image_url1");
+        // Double screen size
+        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager2 = initializeCompanionXmlManagerMock(1600, 960, "image/bmp", "image_url2");
+
+        VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager1, companionXmlManager2));
+        assertCompanionAdsAreEqual(companionXmlManager2, bestCompanionAd);
+    }
+
+    @Test
+    public void getBestCompanionAd_withSameAspectRatios_shouldReturnCompanionAdWithAreaCloserToScreenArea2() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        // Triple screen size
+        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager1 = initializeCompanionXmlManagerMock(2400, 1440, "image/png", "image_url1");
+        // Half screen size
+        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager2 = initializeCompanionXmlManagerMock(400, 240, "image/bmp", "image_url2");
+
+        VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager1, companionXmlManager2));
+        assertCompanionAdsAreEqual(companionXmlManager2, bestCompanionAd);
+    }
+
+    @Test
+    public void getBestCompanionAd_withSameArea_shouldReturnCompanionAdWithAspectRatioCloserToScreenAspectRatio() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        // Landscape
+        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager1 = initializeCompanionXmlManagerMock(400, 240, "image/png", "image_url1");
+        // Portrait
+        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager2 = initializeCompanionXmlManagerMock(240, 400, "image/bmp", "image_url2");
+
+        VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager1, companionXmlManager2));
+        assertCompanionAdsAreEqual(companionXmlManager1, bestCompanionAd);
+    }
+
+    @Test
+    public void getBestCompanionAd_withInvalidMediaTypeAndNullDimension_shouldReturnCompanionAdWithNullDimension() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager1 = initializeCompanionXmlManagerMock(800, 480, "image/invalid", "image_url1");
+        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager2 = initializeCompanionXmlManagerMock(null, null, "image/bmp", "image_url2");
+
+        VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager1, companionXmlManager2));
+        assertCompanionAdsAreEqual(companionXmlManager2, bestCompanionAd);
+    }
+
+    @Test
+    public void getBestCompanionAdithInvalidMediaTypeAndNullMediaType_shouldReturnNull() throws Exception {
+        // Default screen width is 480, height is 800
+        final Display display = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        assertThat(display.getWidth()).isEqualTo(480);
+        assertThat(display.getHeight()).isEqualTo(800);
+
+        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager1 = initializeCompanionXmlManagerMock(800, 480, "image/invalid", "image_url1");
+        final VastXmlManager.ImageCompanionAdXmlManager companionXmlManager2 = initializeCompanionXmlManagerMock(800, 480, null, "image_url2");
+
+        VastCompanionAd bestCompanionAd = subject.getBestCompanionAd(Arrays.asList(companionXmlManager1, companionXmlManager2));
+        assertThat(bestCompanionAd).isEqualTo(null);
+    }
+
+    private VastXmlManager.MediaXmlManager initializeMediaXmlManagerMock(
+            final Integer width,
+            final Integer height,
+            final String type,
+            final String mediaUrl) {
+        VastXmlManager.MediaXmlManager mediaXmlManager = mock(VastXmlManager.MediaXmlManager.class);
+        when(mediaXmlManager.getWidth()).thenReturn(width);
+        when(mediaXmlManager.getHeight()).thenReturn(height);
+        when(mediaXmlManager.getType()).thenReturn(type);
+        when(mediaXmlManager.getMediaUrl()).thenReturn(mediaUrl);
+        return mediaXmlManager;
+    }
+
+    private VastXmlManager.ImageCompanionAdXmlManager initializeCompanionXmlManagerMock(
+            final Integer width,
+            final Integer height,
+            final String type,
+            final String imageUrl) {
+        VastXmlManager.ImageCompanionAdXmlManager companionXmlManager = mock(VastXmlManager.ImageCompanionAdXmlManager.class);
+        when(companionXmlManager.getWidth()).thenReturn(width);
+        when(companionXmlManager.getHeight()).thenReturn(height);
+        when(companionXmlManager.getType()).thenReturn(type);
+        when(companionXmlManager.getImageUrl()).thenReturn(imageUrl);
+        return companionXmlManager;
+    }
+
+    private void assertCompanionAdsAreEqual(
+            final VastXmlManager.ImageCompanionAdXmlManager imageCompanionAdXmlManager,
+            final VastCompanionAd vastCompanionAd) {
+        final VastCompanionAd vastCompanionAd1 = new VastCompanionAd(
+                imageCompanionAdXmlManager.getWidth(),
+                imageCompanionAdXmlManager.getHeight(),
+                imageCompanionAdXmlManager.getImageUrl(),
+                imageCompanionAdXmlManager.getClickThroughUrl(),
+                new ArrayList<String>(imageCompanionAdXmlManager.getClickTrackers())
+        );
+        assertCompanionAdsAreEqual(vastCompanionAd, vastCompanionAd1);
+    }
+
+    private void assertCompanionAdsAreEqual(
+            final VastCompanionAd vastCompanionAd1,
+            final VastCompanionAd vastCompanionAd2) {
+        assertThat(vastCompanionAd1.getWidth()).isEqualTo(vastCompanionAd2.getWidth());
+        assertThat(vastCompanionAd1.getHeight()).isEqualTo(vastCompanionAd2.getHeight());
+        assertThat(vastCompanionAd1.getImageUrl()).isEqualTo(vastCompanionAd2.getImageUrl());
+        assertThat(vastCompanionAd1.getClickThroughUrl()).isEqualTo(vastCompanionAd2.getClickThroughUrl());
+        assertThat(vastCompanionAd1.getClickTrackers()).isEqualTo(vastCompanionAd2.getClickTrackers());
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/XmlUtilsTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/XmlUtilsTest.java
index 6ceeffb2..af68ea88 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/XmlUtilsTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/XmlUtilsTest.java
@@ -1,240 +1,238 @@
-package com.mopub.mobileads.util.vast;
-
-import com.mopub.common.test.support.SdkTestRunner;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.annotation.Config;
-import org.w3c.dom.Document;
-import org.w3c.dom.Node;
-import org.xml.sax.InputSource;
-
-import java.io.StringReader;
-import java.text.DateFormat;
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.List;
-import java.util.Locale;
-
-import javax.xml.parsers.DocumentBuilder;
-import javax.xml.parsers.DocumentBuilderFactory;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-
-@Config(manifest = Config.NONE)
-@RunWith(SdkTestRunner.class)
-public class XmlUtilsTest {
-
-    // From Microsoft's sample xml documents page: https://msdn.microsoft.com/en-us/library/bb387026.aspx
-    private String testXml = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n" +
-            "<aw:PurchaseOrders xmlns:aw=\"http://www.adventure-works.com\">\n" +
-            "  <aw:PurchaseOrder aw:PurchaseOrderNumber=\"99503\" aw:OrderDate=\"1999-10-20\">\n" +
-            "    <aw:Address aw:Type=\"Shipping\">\n" +
-            "      <aw:Name>Ellen Adams</aw:Name>\n" +
-            "      <aw:Street>123 Maple Street</aw:Street>\n" +
-            "      <aw:City>Mill Valley</aw:City>\n" +
-            "      <aw:State>CA</aw:State>\n" +
-            "      <aw:Zip>10999</aw:Zip>\n" +
-            "      <aw:Country>USA</aw:Country>\n" +
-            "    </aw:Address>\n" +
-            "    <aw:Address aw:Type=\"Billing\">\n" +
-            "      <aw:Name>Tai Yee</aw:Name>\n" +
-            "      <aw:Street>8 Oak Avenue</aw:Street>\n" +
-            "      <aw:City>Old Town</aw:City>\n" +
-            "      <aw:State>PA</aw:State>\n" +
-            "      <aw:Zip>95819</aw:Zip>\n" +
-            "      <aw:Country>USA</aw:Country>\n" +
-            "    </aw:Address>\n" +
-            "    <aw:DeliveryNotes>Please leave packages in shed by driveway.</aw:DeliveryNotes>\n" +
-            "    <aw:Items>\n" +
-            "      <aw:Item aw:PartNumber=\"898-AZ\">\n" +
-            "        <aw:ProductName>Lawnmower</aw:ProductName>\n" +
-            "        <aw:Quantity>1</aw:Quantity>\n" +
-            "        <aw:USPrice>148.95</aw:USPrice>\n" +
-            "        <aw:Comment>Confirm this is electric</aw:Comment>\n" +
-            "      </aw:Item>\n" +
-            "      <aw:Item aw:PartNumber=\"926-AA\">\n" +
-            "        <aw:ProductName>Baby Monitor</aw:ProductName>\n" +
-            "        <aw:Quantity>2</aw:Quantity>\n" +
-            "        <aw:USPrice>39.98</aw:USPrice>\n" +
-            "        <aw:ShipDate>1999-05-21</aw:ShipDate>\n" +
-            "      </aw:Item>\n" +
-            "    </aw:Items>\n" +
-            "  </aw:PurchaseOrder>\n" +
-            "  <aw:PurchaseOrder aw:PurchaseOrderNumber=\"99505\" aw:OrderDate=\"1999-10-22\">\n" +
-            "    <aw:Address aw:Type=\"Shipping\">\n" +
-            "      <aw:Name>Cristian Osorio</aw:Name>\n" +
-            "      <aw:Street>456 Main Street</aw:Street>\n" +
-            "      <aw:City>Buffalo</aw:City>\n" +
-            "      <aw:State>NY</aw:State>\n" +
-            "      <aw:Zip>98112</aw:Zip>\n" +
-            "      <aw:Country>USA</aw:Country>\n" +
-            "    </aw:Address>\n" +
-            "    <aw:Address aw:Type=\"Billing\">\n" +
-            "      <aw:Name>Cristian Osorio</aw:Name>\n" +
-            "      <aw:Street>456 Main Street</aw:Street>\n" +
-            "      <aw:City>Buffalo</aw:City>\n" +
-            "      <aw:State>NY</aw:State>\n" +
-            "      <aw:Zip>98112</aw:Zip>\n" +
-            "      <aw:Country>USA</aw:Country>\n" +
-            "    </aw:Address>\n" +
-            "    <aw:DeliveryNotes>Please notify me before shipping.</aw:DeliveryNotes>\n" +
-            "    <aw:Items>\n" +
-            "      <aw:Item aw:PartNumber=\"456-NM\">\n" +
-            "        <aw:ProductName>Power Supply</aw:ProductName>\n" +
-            "        <aw:Quantity>1</aw:Quantity>\n" +
-            "        <aw:USPrice>45.99</aw:USPrice>\n" +
-            "      </aw:Item>\n" +
-            "    </aw:Items>\n" +
-            "  </aw:PurchaseOrder>\n" +
-            "  <aw:PurchaseOrder aw:PurchaseOrderNumber=\"99504\" aw:OrderDate=\"1999-10-22\">\n" +
-            "    <aw:Address aw:Type=\"Shipping\">\n" +
-            "      <aw:Name>Jessica Arnold</aw:Name>\n" +
-            "      <aw:Street>4055 Madison Ave</aw:Street>\n" +
-            "      <aw:City>Seattle</aw:City>\n" +
-            "      <aw:State>WA</aw:State>\n" +
-            "      <aw:Zip>98112</aw:Zip>\n" +
-            "      <aw:Country>USA</aw:Country>\n" +
-            "    </aw:Address>\n" +
-            "    <aw:Address aw:Type=\"Billing\">\n" +
-            "      <aw:Name>Jessica Arnold</aw:Name>\n" +
-            "      <aw:Street>4055 Madison Ave</aw:Street>\n" +
-            "      <aw:City>Buffalo</aw:City>\n" +
-            "      <aw:State>NY</aw:State>\n" +
-            "      <aw:Zip>98112</aw:Zip>\n" +
-            "      <aw:Country>USA</aw:Country>\n" +
-            "    </aw:Address>\n" +
-            "    <aw:Items>\n" +
-            "      <aw:Item aw:PartNumber=\"898-AZ\">\n" +
-            "        <aw:ProductName>Computer Keyboard</aw:ProductName>\n" +
-            "        <aw:Quantity>1</aw:Quantity>\n" +
-            "        <aw:USPrice>29.99</aw:USPrice>\n" +
-            "        <aw:Comment>this thing breaks all the time</aw:Comment>\n" +
-            "      </aw:Item>\n" +
-            "      <aw:Item aw:PartNumber=\"898-AM\">\n" +
-            "        <aw:ProductName>Wireless Mouse</aw:ProductName>\n" +
-            "        <aw:Quantity>1</aw:Quantity>\n" +
-            "        <aw:USPrice>14.99</aw:USPrice>\n" +
-            "      </aw:Item>\n" +
-            "    </aw:Items>\n" +
-            "  </aw:PurchaseOrder>\n" +
-            "</aw:PurchaseOrders>";
-    private Document testDoc;
-    private Node purchaseOrderNode;
-
-
-    @Before
-    public void setUp() throws Exception {
-        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
-        documentBuilderFactory.setCoalescing(true);
-        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
-        testDoc = documentBuilder.parse(new InputSource(new StringReader(testXml)));
-        purchaseOrderNode = testDoc.getFirstChild();
-    }
-
-    @Test
-    public void getFirstMatchingNode_shouldReturnValue() {
-        Node resultNode = XmlUtils.getFirstMatchingChildNode(purchaseOrderNode, "aw:PurchaseOrder");
-        assertThat(resultNode).isNotNull();
-    }
-
-    @Test
-    public void getFirstMatchingChildNode_shouldFindNode() throws Exception {
-        ArrayList<String> testList = new ArrayList<String>();
-        testList.add("1999-10-22");
-        Node resultNode = XmlUtils.getFirstMatchingChildNode(purchaseOrderNode, "aw:PurchaseOrder", "aw:OrderDate", testList);
-        assertThat(resultNode).isNotNull();
-        assertThat(resultNode.getNodeName()).isEqualTo("aw:PurchaseOrder");
-        assertThat(resultNode.getAttributes().getNamedItem("aw:OrderDate").getNodeValue()).isEqualTo("1999-10-22");
-    }
-
-    @Test
-    public void getFirstMatchingChildNode_withUnmatchedAttribute_shouldNotFindNode() throws Exception {
-        ArrayList<String> testList = new ArrayList<String>();
-        testList.add("1999-10-");
-        Node resultNode = XmlUtils.getFirstMatchingChildNode(purchaseOrderNode, "aw:PurchaseOrder", "aw:OrderDate", testList);
-        assertThat(resultNode).isNull();
-    }
-
-    @Test
-    public void getMatchingChildNodes_withNullAttributeValues_shouldReturnMultiple() throws Exception {
-        List<Node> results = XmlUtils.getMatchingChildNodes(purchaseOrderNode, "aw:PurchaseOrder", "aw:OrderDate", null);
-        assertThat(results.size()).isEqualTo(3);
-    }
-
-    @Test
-    public void getMatchingChildNodes_withEmptyAttributeValues_shouldReturnNone() {
-        List<Node> results = XmlUtils.getMatchingChildNodes(purchaseOrderNode, "aw:PurchaseOrder", "aw:OrderDate", new ArrayList<String>());
-        assertThat(results).isEmpty();
-    }
-
-    @Test
-    public void testGetListFromDocument() throws Exception {
-        // Get all the "aw:PurchaseOrder" nodes. If any of them have an "aw:OrderDate" attribute, extract a Date.
-        List<Date> orderDates = XmlUtils.getListFromDocument(testDoc, "aw:PurchaseOrder", "aw:OrderDate", null, new XmlUtils.NodeProcessor<Date>() {
-            DateFormat formatter = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
-
-            @Override
-            public Date process(final Node node) {
-                try {
-                    return formatter.parse(node.getAttributes().getNamedItem("aw:OrderDate").getNodeValue());
-                } catch (ParseException e) {
-                    return null;
-                }
-            }
-        });
-
-        assertThat(orderDates.size()).isEqualTo(3);
-        assertThat(orderDates.get(0).getYear()).isEqualTo(99);
-        assertThat(orderDates.get(0).getMonth()).isEqualTo(9);
-        assertThat(orderDates.get(0).getDate()).isEqualTo(20);
-
-        assertThat(orderDates.get(1).getYear()).isEqualTo(99);
-        assertThat(orderDates.get(1).getMonth()).isEqualTo(9);
-        assertThat(orderDates.get(1).getDate()).isEqualTo(22);
-
-        assertThat(orderDates.get(2).getYear()).isEqualTo(99);
-        assertThat(orderDates.get(2).getMonth()).isEqualTo(9);
-        assertThat(orderDates.get(2).getDate()).isEqualTo(22);
-    }
-
-    @Test
-    public void testGetFirstMatchFromDocument() throws Exception {
-        // Get the first "aw:PurchaseOrder" nodes. If it has an "aw:OrderDate" attribute, extract a Date.
-        Date orderDate = XmlUtils.getFirstMatchFromDocument(testDoc, "aw:PurchaseOrder", "aw:OrderDate", null, new XmlUtils.NodeProcessor<Date>() {
-            DateFormat formatter = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
-
-            @Override
-            public Date process(final Node node) {
-                try {
-                    return formatter.parse(node.getAttributes().getNamedItem("aw:OrderDate").getNodeValue());
-                } catch (ParseException e) {
-                    return null;
-                }
-            }
-        });
-
-        assertThat(orderDate).isNotNull();
-        assertThat(orderDate.getYear()).isEqualTo(99);
-        assertThat(orderDate.getMonth()).isEqualTo(9);
-        assertThat(orderDate.getDate()).isEqualTo(20);
-    }
-
-    @Test
-    public void testGetStringDataAsList_shouldFindDeepNested() throws Exception {
-        final List<String> strings = XmlUtils.getStringDataAsList(testDoc, "aw:Comment", null, null);
-        assertThat(strings.size()).isEqualTo(2);
-        assertThat(strings.get(0)).isEqualTo("Confirm this is electric");
-        assertThat(strings.get(1)).isEqualTo("this thing breaks all the time");
-    }
-
-    @Test
-    public void testGetFirstMatchingStringData_shouldFindFirstMatch() throws Exception {
-        final String firstMatch = XmlUtils.getFirstMatchingStringData(testDoc, "aw:Comment", null, null);
-        assertThat(firstMatch).isNotNull();
-        assertThat(firstMatch).isEqualTo("Confirm this is electric");
-    }
-}
+package com.mopub.mobileads.util.vast;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.w3c.dom.Document;
+import org.w3c.dom.Node;
+import org.xml.sax.InputSource;
+
+import java.io.StringReader;
+import java.text.DateFormat;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+import java.util.Locale;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+public class XmlUtilsTest {
+
+    // From Microsoft's sample xml documents page: https://msdn.microsoft.com/en-us/library/bb387026.aspx
+    private String testXml = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n" +
+            "<aw:PurchaseOrders xmlns:aw=\"http://www.adventure-works.com\">\n" +
+            "  <aw:PurchaseOrder aw:PurchaseOrderNumber=\"99503\" aw:OrderDate=\"1999-10-20\">\n" +
+            "    <aw:Address aw:Type=\"Shipping\">\n" +
+            "      <aw:Name>Ellen Adams</aw:Name>\n" +
+            "      <aw:Street>123 Maple Street</aw:Street>\n" +
+            "      <aw:City>Mill Valley</aw:City>\n" +
+            "      <aw:State>CA</aw:State>\n" +
+            "      <aw:Zip>10999</aw:Zip>\n" +
+            "      <aw:Country>USA</aw:Country>\n" +
+            "    </aw:Address>\n" +
+            "    <aw:Address aw:Type=\"Billing\">\n" +
+            "      <aw:Name>Tai Yee</aw:Name>\n" +
+            "      <aw:Street>8 Oak Avenue</aw:Street>\n" +
+            "      <aw:City>Old Town</aw:City>\n" +
+            "      <aw:State>PA</aw:State>\n" +
+            "      <aw:Zip>95819</aw:Zip>\n" +
+            "      <aw:Country>USA</aw:Country>\n" +
+            "    </aw:Address>\n" +
+            "    <aw:DeliveryNotes>Please leave packages in shed by driveway.</aw:DeliveryNotes>\n" +
+            "    <aw:Items>\n" +
+            "      <aw:Item aw:PartNumber=\"898-AZ\">\n" +
+            "        <aw:ProductName>Lawnmower</aw:ProductName>\n" +
+            "        <aw:Quantity>1</aw:Quantity>\n" +
+            "        <aw:USPrice>148.95</aw:USPrice>\n" +
+            "        <aw:Comment>Confirm this is electric</aw:Comment>\n" +
+            "      </aw:Item>\n" +
+            "      <aw:Item aw:PartNumber=\"926-AA\">\n" +
+            "        <aw:ProductName>Baby Monitor</aw:ProductName>\n" +
+            "        <aw:Quantity>2</aw:Quantity>\n" +
+            "        <aw:USPrice>39.98</aw:USPrice>\n" +
+            "        <aw:ShipDate>1999-05-21</aw:ShipDate>\n" +
+            "      </aw:Item>\n" +
+            "    </aw:Items>\n" +
+            "  </aw:PurchaseOrder>\n" +
+            "  <aw:PurchaseOrder aw:PurchaseOrderNumber=\"99505\" aw:OrderDate=\"1999-10-22\">\n" +
+            "    <aw:Address aw:Type=\"Shipping\">\n" +
+            "      <aw:Name>Cristian Osorio</aw:Name>\n" +
+            "      <aw:Street>456 Main Street</aw:Street>\n" +
+            "      <aw:City>Buffalo</aw:City>\n" +
+            "      <aw:State>NY</aw:State>\n" +
+            "      <aw:Zip>98112</aw:Zip>\n" +
+            "      <aw:Country>USA</aw:Country>\n" +
+            "    </aw:Address>\n" +
+            "    <aw:Address aw:Type=\"Billing\">\n" +
+            "      <aw:Name>Cristian Osorio</aw:Name>\n" +
+            "      <aw:Street>456 Main Street</aw:Street>\n" +
+            "      <aw:City>Buffalo</aw:City>\n" +
+            "      <aw:State>NY</aw:State>\n" +
+            "      <aw:Zip>98112</aw:Zip>\n" +
+            "      <aw:Country>USA</aw:Country>\n" +
+            "    </aw:Address>\n" +
+            "    <aw:DeliveryNotes>Please notify me before shipping.</aw:DeliveryNotes>\n" +
+            "    <aw:Items>\n" +
+            "      <aw:Item aw:PartNumber=\"456-NM\">\n" +
+            "        <aw:ProductName>Power Supply</aw:ProductName>\n" +
+            "        <aw:Quantity>1</aw:Quantity>\n" +
+            "        <aw:USPrice>45.99</aw:USPrice>\n" +
+            "      </aw:Item>\n" +
+            "    </aw:Items>\n" +
+            "  </aw:PurchaseOrder>\n" +
+            "  <aw:PurchaseOrder aw:PurchaseOrderNumber=\"99504\" aw:OrderDate=\"1999-10-22\">\n" +
+            "    <aw:Address aw:Type=\"Shipping\">\n" +
+            "      <aw:Name>Jessica Arnold</aw:Name>\n" +
+            "      <aw:Street>4055 Madison Ave</aw:Street>\n" +
+            "      <aw:City>Seattle</aw:City>\n" +
+            "      <aw:State>WA</aw:State>\n" +
+            "      <aw:Zip>98112</aw:Zip>\n" +
+            "      <aw:Country>USA</aw:Country>\n" +
+            "    </aw:Address>\n" +
+            "    <aw:Address aw:Type=\"Billing\">\n" +
+            "      <aw:Name>Jessica Arnold</aw:Name>\n" +
+            "      <aw:Street>4055 Madison Ave</aw:Street>\n" +
+            "      <aw:City>Buffalo</aw:City>\n" +
+            "      <aw:State>NY</aw:State>\n" +
+            "      <aw:Zip>98112</aw:Zip>\n" +
+            "      <aw:Country>USA</aw:Country>\n" +
+            "    </aw:Address>\n" +
+            "    <aw:Items>\n" +
+            "      <aw:Item aw:PartNumber=\"898-AZ\">\n" +
+            "        <aw:ProductName>Computer Keyboard</aw:ProductName>\n" +
+            "        <aw:Quantity>1</aw:Quantity>\n" +
+            "        <aw:USPrice>29.99</aw:USPrice>\n" +
+            "        <aw:Comment>this thing breaks all the time</aw:Comment>\n" +
+            "      </aw:Item>\n" +
+            "      <aw:Item aw:PartNumber=\"898-AM\">\n" +
+            "        <aw:ProductName>Wireless Mouse</aw:ProductName>\n" +
+            "        <aw:Quantity>1</aw:Quantity>\n" +
+            "        <aw:USPrice>14.99</aw:USPrice>\n" +
+            "      </aw:Item>\n" +
+            "    </aw:Items>\n" +
+            "  </aw:PurchaseOrder>\n" +
+            "</aw:PurchaseOrders>";
+    private Document testDoc;
+    private Node purchaseOrderNode;
+
+
+    @Before
+    public void setUp() throws Exception {
+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
+        documentBuilderFactory.setCoalescing(true);
+        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
+        testDoc = documentBuilder.parse(new InputSource(new StringReader(testXml)));
+        purchaseOrderNode = testDoc.getFirstChild();
+    }
+
+    @Test
+    public void getFirstMatchingNode_shouldReturnValue() {
+        Node resultNode = XmlUtils.getFirstMatchingChildNode(purchaseOrderNode, "aw:PurchaseOrder");
+        assertThat(resultNode).isNotNull();
+    }
+
+    @Test
+    public void getFirstMatchingChildNode_shouldFindNode() throws Exception {
+        ArrayList<String> testList = new ArrayList<String>();
+        testList.add("1999-10-22");
+        Node resultNode = XmlUtils.getFirstMatchingChildNode(purchaseOrderNode, "aw:PurchaseOrder", "aw:OrderDate", testList);
+        assertThat(resultNode).isNotNull();
+        assertThat(resultNode.getNodeName()).isEqualTo("aw:PurchaseOrder");
+        assertThat(resultNode.getAttributes().getNamedItem("aw:OrderDate").getNodeValue()).isEqualTo("1999-10-22");
+    }
+
+    @Test
+    public void getFirstMatchingChildNode_withUnmatchedAttribute_shouldNotFindNode() throws Exception {
+        ArrayList<String> testList = new ArrayList<String>();
+        testList.add("1999-10-");
+        Node resultNode = XmlUtils.getFirstMatchingChildNode(purchaseOrderNode, "aw:PurchaseOrder", "aw:OrderDate", testList);
+        assertThat(resultNode).isNull();
+    }
+
+    @Test
+    public void getMatchingChildNodes_withNullAttributeValues_shouldReturnMultiple() throws Exception {
+        List<Node> results = XmlUtils.getMatchingChildNodes(purchaseOrderNode, "aw:PurchaseOrder", "aw:OrderDate", null);
+        assertThat(results.size()).isEqualTo(3);
+    }
+
+    @Test
+    public void getMatchingChildNodes_withEmptyAttributeValues_shouldReturnNone() {
+        List<Node> results = XmlUtils.getMatchingChildNodes(purchaseOrderNode, "aw:PurchaseOrder", "aw:OrderDate", new ArrayList<String>());
+        assertThat(results).isEmpty();
+    }
+
+    @Test
+    public void testGetListFromDocument() throws Exception {
+        // Get all the "aw:PurchaseOrder" nodes. If any of them have an "aw:OrderDate" attribute, extract a Date.
+        List<Date> orderDates = XmlUtils.getListFromDocument(testDoc, "aw:PurchaseOrder", "aw:OrderDate", null, new XmlUtils.NodeProcessor<Date>() {
+            DateFormat formatter = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
+
+            @Override
+            public Date process(final Node node) {
+                try {
+                    return formatter.parse(node.getAttributes().getNamedItem("aw:OrderDate").getNodeValue());
+                } catch (ParseException e) {
+                    return null;
+                }
+            }
+        });
+
+        assertThat(orderDates.size()).isEqualTo(3);
+        assertThat(orderDates.get(0).getYear()).isEqualTo(99);
+        assertThat(orderDates.get(0).getMonth()).isEqualTo(9);
+        assertThat(orderDates.get(0).getDate()).isEqualTo(20);
+
+        assertThat(orderDates.get(1).getYear()).isEqualTo(99);
+        assertThat(orderDates.get(1).getMonth()).isEqualTo(9);
+        assertThat(orderDates.get(1).getDate()).isEqualTo(22);
+
+        assertThat(orderDates.get(2).getYear()).isEqualTo(99);
+        assertThat(orderDates.get(2).getMonth()).isEqualTo(9);
+        assertThat(orderDates.get(2).getDate()).isEqualTo(22);
+    }
+
+    @Test
+    public void testGetFirstMatchFromDocument() throws Exception {
+        // Get the first "aw:PurchaseOrder" nodes. If it has an "aw:OrderDate" attribute, extract a Date.
+        Date orderDate = XmlUtils.getFirstMatchFromDocument(testDoc, "aw:PurchaseOrder", "aw:OrderDate", null, new XmlUtils.NodeProcessor<Date>() {
+            DateFormat formatter = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
+
+            @Override
+            public Date process(final Node node) {
+                try {
+                    return formatter.parse(node.getAttributes().getNamedItem("aw:OrderDate").getNodeValue());
+                } catch (ParseException e) {
+                    return null;
+                }
+            }
+        });
+
+        assertThat(orderDate).isNotNull();
+        assertThat(orderDate.getYear()).isEqualTo(99);
+        assertThat(orderDate.getMonth()).isEqualTo(9);
+        assertThat(orderDate.getDate()).isEqualTo(20);
+    }
+
+    @Test
+    public void testGetStringDataAsList_shouldFindDeepNested() throws Exception {
+        final List<String> strings = XmlUtils.getStringDataAsList(testDoc, "aw:Comment", null, null);
+        assertThat(strings.size()).isEqualTo(2);
+        assertThat(strings.get(0)).isEqualTo("Confirm this is electric");
+        assertThat(strings.get(1)).isEqualTo("this thing breaks all the time");
+    }
+
+    @Test
+    public void testGetFirstMatchingStringData_shouldFindFirstMatch() throws Exception {
+        final String firstMatch = XmlUtils.getFirstMatchingStringData(testDoc, "aw:Comment", null, null);
+        assertThat(firstMatch).isNotNull();
+        assertThat(firstMatch).isEqualTo("Confirm this is electric");
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mraid/MraidVideoViewControllerTest.java b/mopub-sdk/src/test/java/com/mopub/mraid/MraidVideoViewControllerTest.java
index 605a60d2..a7385242 100644
--- a/mopub-sdk/src/test/java/com/mopub/mraid/MraidVideoViewControllerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mraid/MraidVideoViewControllerTest.java
@@ -1,169 +1,166 @@
-package com.mopub.mraid;
-
-import android.app.Activity;
-import android.content.Context;
-import android.os.Bundle;
-import android.widget.ImageButton;
-
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.mobileads.EventForwardingBroadcastReceiver;
-
-import org.apache.http.HttpRequest;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.annotation.Config;
-import org.robolectric.shadows.ShadowLocalBroadcastManager;
-import org.robolectric.shadows.ShadowVideoView;
-import org.robolectric.tester.org.apache.http.RequestMatcher;
-import org.robolectric.tester.org.apache.http.TestHttpResponse;
-
-import static android.view.View.GONE;
-import static android.view.View.VISIBLE;
-import static com.mopub.mobileads.BaseVideoPlayerActivity.VIDEO_URL;
-import static com.mopub.mobileads.BaseVideoViewController.BaseVideoViewControllerListener;
-import static com.mopub.mobileads.EventForwardingBroadcastReceiver.getHtmlInterstitialIntentFilter;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.robolectric.Robolectric.shadowOf;
-
-@RunWith(SdkTestRunner.class)
-@Config(manifest=Config.NONE)
-public class MraidVideoViewControllerTest {
-    private Context context;
-    private Bundle bundle;
-    private MraidVideoViewController subject;
-    private BaseVideoViewControllerListener baseVideoViewControllerListener;
-    private EventForwardingBroadcastReceiver broadcastReceiver;
-
-    @Before
-    public void setUp() throws Exception {
-        context = new Activity();
-        bundle = new Bundle();
-        baseVideoViewControllerListener = mock(BaseVideoViewControllerListener.class);
-
-        bundle.putString(VIDEO_URL, "http://video_url");
-
-        Robolectric.getUiThreadScheduler().pause();
-        Robolectric.getBackgroundScheduler().pause();
-
-        Robolectric.addHttpResponseRule(new RequestMatcher() {
-            @Override
-            public boolean matches(HttpRequest request) {
-                return true;
-            }
-        }, new TestHttpResponse(200, "body"));
-
-        ShadowLocalBroadcastManager.getInstance(context).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
-    }
-
-    @After
-    public void tearDown() throws Exception {
-        Robolectric.getUiThreadScheduler().reset();
-        Robolectric.getBackgroundScheduler().reset();
-        Robolectric.clearPendingHttpResponses();
-
-        ShadowLocalBroadcastManager.getInstance(context).unregisterReceiver(broadcastReceiver);
-    }
-
-    @Test
-    public void constructor_shouldSetListenersAndVideoPath() throws Exception {
-        initializeSubject();
-        ShadowVideoView shadowSubject = shadowOf(subject.getVideoView());
-
-        assertThat(shadowSubject.getOnCompletionListener()).isNotNull();
-        assertThat(shadowSubject.getOnErrorListener()).isNotNull();
-
-        assertThat(shadowSubject.getVideoPath()).isEqualTo("http://video_url");
-        assertThat(subject.getVideoView().hasFocus()).isTrue();
-    }
-    
-    @Test
-    public void onCreate_shouldCreateAndHideCloseButton() throws Exception {
-        initializeSubject();
-        subject.onCreate();
-
-        ImageButton closeButton = getCloseButton();
-
-        assertThat(closeButton).isNotNull();
-
-        assertThat(shadowOf(closeButton).getOnClickListener()).isNotNull();
-        assertThat(closeButton.getVisibility()).isEqualTo(GONE);
-    }
-
-    @Test
-    public void backButtonEnabled_shouldReturnTrue() throws Exception {
-        initializeSubject();
-
-        assertThat(subject.backButtonEnabled()).isTrue();
-    }
-
-    @Test
-    public void closeButton_onClick_shouldCallBaseVideoControllerListenerOnFinish() throws Exception {
-        initializeSubject();
-        subject.onCreate();
-
-        getCloseButton().performClick();
-        verify(baseVideoViewControllerListener).onFinish();
-    }
-
-    @Test
-    public void onCompletionListener_shouldCallBaseVideoViewControllerListenerOnFinish() throws Exception {
-        initializeSubject();
-        subject.onCreate();
-
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
-
-        verify(baseVideoViewControllerListener).onFinish();
-    }
-
-    @Test
-    public void onCompletionListener_shouldShowCloseButton() throws Exception {
-        initializeSubject();
-        subject.onCreate();
-
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
-
-        assertThat(getCloseButton().getVisibility()).isEqualTo(VISIBLE);
-    }
-
-    @Test
-    public void onCompletionListener_withNullBaseVideoViewControllerListener_shouldNotCallOnFinish() throws Exception {
-    }
-
-    @Test
-    public void onErrorListener_shouldReturnFalseAndNotCallBaseVideoControllerListenerOnFinish() throws Exception {
-        initializeSubject();
-        subject.onCreate();
-
-        assertThat(getShadowVideoView().getOnErrorListener().onError(null, 0, 0)).isEqualTo(false);
-
-        verify(baseVideoViewControllerListener, never()).onFinish();
-    }
-
-    @Test
-    public void onErrorListener_shouldShowCloseButton() throws Exception {
-        initializeSubject();
-        subject.onCreate();
-
-        assertThat(getShadowVideoView().getOnErrorListener().onError(null, 0, 0)).isEqualTo(false);
-
-        assertThat(getCloseButton().getVisibility()).isEqualTo(VISIBLE);
-    }
-
-    private void initializeSubject() {
-        subject = new MraidVideoViewController(context, bundle, baseVideoViewControllerListener);
-    }
-
-    private ShadowVideoView getShadowVideoView() {
-        return shadowOf(subject.getVideoView());
-    }
-
-    ImageButton getCloseButton() {
-        return (ImageButton) subject.getLayout().getChildAt(1);
-    }
-}
+package com.mopub.mraid;
+
+import android.app.Activity;
+import android.content.Context;
+import android.os.Bundle;
+import android.widget.ImageButton;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.EventForwardingBroadcastReceiver;
+
+import org.apache.http.HttpRequest;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.shadows.ShadowLocalBroadcastManager;
+import org.robolectric.shadows.ShadowVideoView;
+import org.robolectric.tester.org.apache.http.RequestMatcher;
+import org.robolectric.tester.org.apache.http.TestHttpResponse;
+
+import static android.view.View.GONE;
+import static android.view.View.VISIBLE;
+import static com.mopub.mobileads.BaseVideoPlayerActivity.VIDEO_URL;
+import static com.mopub.mobileads.BaseVideoViewController.BaseVideoViewControllerListener;
+import static com.mopub.mobileads.EventForwardingBroadcastReceiver.getHtmlInterstitialIntentFilter;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.robolectric.Robolectric.shadowOf;
+
+@RunWith(SdkTestRunner.class)
+public class MraidVideoViewControllerTest {
+    private Context context;
+    private Bundle bundle;
+    private MraidVideoViewController subject;
+    private BaseVideoViewControllerListener baseVideoViewControllerListener;
+    private EventForwardingBroadcastReceiver broadcastReceiver;
+
+    @Before
+    public void setUp() throws Exception {
+        context = Robolectric.buildActivity(Activity.class).create().get();
+        bundle = new Bundle();
+        baseVideoViewControllerListener = mock(BaseVideoViewControllerListener.class);
+
+        bundle.putString(VIDEO_URL, "http://video_url");
+
+        Robolectric.getUiThreadScheduler().pause();
+        Robolectric.getBackgroundScheduler().pause();
+
+        Robolectric.addHttpResponseRule(new RequestMatcher() {
+            @Override
+            public boolean matches(HttpRequest request) {
+                return true;
+            }
+        }, new TestHttpResponse(200, "body"));
+
+        ShadowLocalBroadcastManager.getInstance(context).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        Robolectric.getUiThreadScheduler().reset();
+        Robolectric.getBackgroundScheduler().reset();
+        Robolectric.clearPendingHttpResponses();
+
+        ShadowLocalBroadcastManager.getInstance(context).unregisterReceiver(broadcastReceiver);
+    }
+
+    @Test
+    public void constructor_shouldSetListenersAndVideoPath() throws Exception {
+        initializeSubject();
+        ShadowVideoView shadowSubject = shadowOf(subject.getVideoView());
+
+        assertThat(shadowSubject.getOnCompletionListener()).isNotNull();
+        assertThat(shadowSubject.getOnErrorListener()).isNotNull();
+
+        assertThat(shadowSubject.getVideoPath()).isEqualTo("http://video_url");
+        assertThat(subject.getVideoView().hasFocus()).isTrue();
+    }
+    
+    @Test
+    public void onCreate_shouldCreateAndHideCloseButton() throws Exception {
+        initializeSubject();
+        subject.onCreate();
+
+        ImageButton closeButton = getCloseButton();
+
+        assertThat(closeButton).isNotNull();
+        assertThat(shadowOf(closeButton).getOnClickListener()).isNotNull();
+        assertThat(closeButton.getVisibility()).isEqualTo(GONE);
+    }
+
+    @Test
+    public void backButtonEnabled_shouldReturnTrue() throws Exception {
+        initializeSubject();
+
+        assertThat(subject.backButtonEnabled()).isTrue();
+    }
+
+    @Test
+    public void closeButton_onClick_shouldCallBaseVideoControllerListenerOnFinish() throws Exception {
+        initializeSubject();
+        subject.onCreate();
+
+        getCloseButton().performClick();
+        verify(baseVideoViewControllerListener).onFinish();
+    }
+
+    @Test
+    public void onCompletionListener_shouldCallBaseVideoViewControllerListenerOnFinish() throws Exception {
+        initializeSubject();
+        subject.onCreate();
+
+        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+
+        verify(baseVideoViewControllerListener).onFinish();
+    }
+
+    @Test
+    public void onCompletionListener_shouldShowCloseButton() throws Exception {
+        initializeSubject();
+        subject.onCreate();
+
+        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+
+        assertThat(getCloseButton().getVisibility()).isEqualTo(VISIBLE);
+    }
+
+    @Test
+    public void onCompletionListener_withNullBaseVideoViewControllerListener_shouldNotCallOnFinish() throws Exception {
+    }
+
+    @Test
+    public void onErrorListener_shouldReturnFalseAndNotCallBaseVideoControllerListenerOnFinish() throws Exception {
+        initializeSubject();
+        subject.onCreate();
+
+        assertThat(getShadowVideoView().getOnErrorListener().onError(null, 0, 0)).isEqualTo(false);
+
+        verify(baseVideoViewControllerListener, never()).onFinish();
+    }
+
+    @Test
+    public void onErrorListener_shouldShowCloseButton() throws Exception {
+        initializeSubject();
+        subject.onCreate();
+
+        assertThat(getShadowVideoView().getOnErrorListener().onError(null, 0, 0)).isEqualTo(false);
+
+        assertThat(getCloseButton().getVisibility()).isEqualTo(VISIBLE);
+    }
+
+    private void initializeSubject() {
+        subject = new MraidVideoViewController(context, bundle, baseVideoViewControllerListener);
+    }
+
+    private ShadowVideoView getShadowVideoView() {
+        return shadowOf(subject.getVideoView());
+    }
+
+    ImageButton getCloseButton() {
+        return (ImageButton) subject.getLayout().getChildAt(1);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/AdapterHelperTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/AdapterHelperTest.java
index a29e1932..a2f85dbd 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/AdapterHelperTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/AdapterHelperTest.java
@@ -1,195 +1,196 @@
-package com.mopub.nativeads;
-
-import android.app.Activity;
-import android.content.Context;
-
-import com.mopub.common.test.support.SdkTestRunner;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-
-@RunWith(SdkTestRunner.class)
-public class AdapterHelperTest {
-    private AdapterHelper subject;
-    private Activity context;
-    private int contentRowCount;
-    private int start;
-    private int interval;
-
-    @Before
-    public void setUp() {
-        context = new Activity();
-        start = 1;
-        interval = 2;
-        subject = new AdapterHelper(context, start, interval);
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void constructor_whenPassedAnApplicationContext_shouldThrowIllegalArgumentException() {
-        new AdapterHelper(context.getApplicationContext(), start, interval);
-    }
-
-    @Test
-    public void getAdView_withNullActivityContext_shouldReturnEmptyViewWithApplicationContext() {
-        subject.clearActivityContext();
-        Context viewContext = subject.getAdView(null, null, mock(NativeResponse.class),
-                mock(ViewBinder.class),
-                null).getContext();
-        assertThat(viewContext).isEqualTo(context.getApplication());
-    }
-
-    @Test
-    public void adapterHelper_withContentRowCountOf10_shouldCalculateCorrectly() {
-        contentRowCount = 10;
-
-        start = 0;
-        interval = 2;
-        subject = new AdapterHelper(context, start, interval);
-
-//      acacacacacacacacacac
-        assertThat(subject.shiftedCount(contentRowCount)).isEqualTo(20);
-        validateRows(20, start, interval);
-        assertThat(subject.shiftedPosition(1)).isEqualTo(0);
-        assertThat(subject.shiftedPosition(3)).isEqualTo(1);
-        assertThat(subject.shiftedPosition(5)).isEqualTo(2);
-        assertThat(subject.shiftedPosition(7)).isEqualTo(3);
-        assertThat(subject.shiftedPosition(9)).isEqualTo(4);
-        assertThat(subject.shiftedPosition(11)).isEqualTo(5);
-        assertThat(subject.shiftedPosition(13)).isEqualTo(6);
-        assertThat(subject.shiftedPosition(15)).isEqualTo(7);
-        assertThat(subject.shiftedPosition(17)).isEqualTo(8);
-        assertThat(subject.shiftedPosition(19)).isEqualTo(9);
-
-        start = 0;
-        interval = 6;
-        subject = new AdapterHelper(context, start, interval);
-
-//      acccccaccccc
-        assertThat(subject.shiftedCount(contentRowCount)).isEqualTo(12);
-        validateRows(12, start, interval);
-        assertThat(subject.shiftedPosition(1)).isEqualTo(0);
-        assertThat(subject.shiftedPosition(2)).isEqualTo(1);
-        assertThat(subject.shiftedPosition(3)).isEqualTo(2);
-        assertThat(subject.shiftedPosition(4)).isEqualTo(3);
-        assertThat(subject.shiftedPosition(5)).isEqualTo(4);
-        assertThat(subject.shiftedPosition(7)).isEqualTo(5);
-        assertThat(subject.shiftedPosition(8)).isEqualTo(6);
-        assertThat(subject.shiftedPosition(9)).isEqualTo(7);
-        assertThat(subject.shiftedPosition(10)).isEqualTo(8);
-        assertThat(subject.shiftedPosition(11)).isEqualTo(9);
-
-        start = 0;
-        interval = 11;
-        subject = new AdapterHelper(context, start, interval);
-
-//      acccccccccc
-        assertThat(subject.shiftedCount(contentRowCount)).isEqualTo(11);
-        validateRows(11, start, interval);
-        assertThat(subject.shiftedPosition(1)).isEqualTo(0);
-        assertThat(subject.shiftedPosition(5)).isEqualTo(4);
-        assertThat(subject.shiftedPosition(10)).isEqualTo(9);
-
-        start = 0;
-        interval = 4;
-        subject = new AdapterHelper(context, start, interval);
-
-//      acccacccacccac
-        assertThat(subject.shiftedCount(contentRowCount)).isEqualTo(14);
-        validateRows(14, start, interval);
-
-        start = 5;
-        interval = 6;
-        subject = new AdapterHelper(context, start, interval);
-
-//      cccccaccccc
-        assertThat(subject.shiftedCount(contentRowCount)).isEqualTo(11);
-        validateRows(11, start, interval);
-        assertThat(subject.shiftedPosition(4)).isEqualTo(4);
-        assertThat(subject.shiftedPosition(6)).isEqualTo(5);
-        assertThat(subject.shiftedPosition(10)).isEqualTo(9);
-
-        start = 5;
-        interval = 5;
-        subject = new AdapterHelper(context, start, interval);
-
-//      cccccaccccac
-        assertThat(subject.shiftedCount(contentRowCount)).isEqualTo(12);
-        validateRows(12, start, interval);
-        assertThat(subject.shiftedPosition(6)).isEqualTo(5);
-        assertThat(subject.shiftedPosition(11)).isEqualTo(9);
-
-        start = 3;
-        interval = 4;
-        subject = new AdapterHelper(context, start, interval);
-
-//      cccacccacccac
-        assertThat(subject.shiftedCount(contentRowCount)).isEqualTo(13);
-        validateRows(13, start, interval);
-        assertThat(subject.shiftedPosition(0)).isEqualTo(0);
-        assertThat(subject.shiftedPosition(2)).isEqualTo(2);
-        assertThat(subject.shiftedPosition(12)).isEqualTo(9);
-
-        start = 10;
-        interval = 100;
-        subject = new AdapterHelper(context, start, interval);
-
-//      cccccccccc
-        assertThat(subject.shiftedCount(contentRowCount)).isEqualTo(10);
-        validateRows(10, start, interval);
-        assertThat(subject.shiftedPosition(3)).isEqualTo(3);
-        assertThat(subject.shiftedPosition(7)).isEqualTo(7);
-        assertThat(subject.shiftedPosition(9)).isEqualTo(9);
-
-        start = 0;
-        interval = 10;
-        subject = new AdapterHelper(context, start, interval);
-
-//      acccccccccac
-        assertThat(subject.shiftedCount(contentRowCount)).isEqualTo(12);
-        validateRows(12, start, interval);
-        assertThat(subject.shiftedPosition(1)).isEqualTo(0);
-        assertThat(subject.shiftedPosition(9)).isEqualTo(8);
-        assertThat(subject.shiftedPosition(11)).isEqualTo(9);
-    }
-
-    @Test
-    public void adapterHelper_withContentRowCountOf1_shouldCalculateCorrectly() {
-        contentRowCount = 1;
-        start = 0;
-        interval = 2;
-        subject = new AdapterHelper(context, start, interval);
-
-//      ac
-        assertThat(subject.shiftedCount(contentRowCount)).isEqualTo(2);
-        validateRows(2, start, interval);
-        assertThat(subject.shiftedPosition(1)).isEqualTo(0);
-
-        // We can still query for large numbers since the calculation assumes an infinite list
-        assertThat(subject.shiftedPosition(1001)).isEqualTo(500);
-
-        start = 1;
-        interval = 2;
-        subject = new AdapterHelper(context, start, interval);
-
-//      c
-        assertThat(subject.shiftedCount(contentRowCount)).isEqualTo(1);
-        validateRows(1, start, interval);
-        assertThat(subject.shiftedPosition(0)).isEqualTo(0);
-    }
-
-    private void validateRows(int totalRows, int start, int interval) {
-        for (int i = 0; i < totalRows; ++i) {
-            if (i == start) {
-                assertThat(subject.isAdPosition(i)).isTrue();
-            } else if (i > start && ((i - start) % (interval) == 0)) {
-                assertThat(subject.isAdPosition(i)).isTrue();
-            } else {
-                assertThat(subject.isAdPosition(i)).isFalse();
-            }
-        }
-    }
-}
+package com.mopub.nativeads;
+
+import android.app.Activity;
+import android.content.Context;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+
+@RunWith(SdkTestRunner.class)
+public class AdapterHelperTest {
+    private AdapterHelper subject;
+    private Activity context;
+    private int contentRowCount;
+    private int start;
+    private int interval;
+
+    @Before
+    public void setUp() {
+        context = Robolectric.buildActivity(Activity.class).create().get();
+        start = 1;
+        interval = 2;
+        subject = new AdapterHelper(context, start, interval);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void constructor_whenPassedAnApplicationContext_shouldThrowIllegalArgumentException() {
+        new AdapterHelper(context.getApplicationContext(), start, interval);
+    }
+
+    @Test
+    public void getAdView_withNullActivityContext_shouldReturnEmptyViewWithApplicationContext() {
+        subject.clearActivityContext();
+        Context viewContext = subject.getAdView(null, null, mock(NativeResponse.class),
+                mock(ViewBinder.class),
+                null).getContext();
+        assertThat(viewContext).isEqualTo(context.getApplication());
+    }
+
+    @Test
+    public void adapterHelper_withContentRowCountOf10_shouldCalculateCorrectly() {
+        contentRowCount = 10;
+
+        start = 0;
+        interval = 2;
+        subject = new AdapterHelper(context, start, interval);
+
+//      acacacacacacacacacac
+        assertThat(subject.shiftedCount(contentRowCount)).isEqualTo(20);
+        validateRows(20, start, interval);
+        assertThat(subject.shiftedPosition(1)).isEqualTo(0);
+        assertThat(subject.shiftedPosition(3)).isEqualTo(1);
+        assertThat(subject.shiftedPosition(5)).isEqualTo(2);
+        assertThat(subject.shiftedPosition(7)).isEqualTo(3);
+        assertThat(subject.shiftedPosition(9)).isEqualTo(4);
+        assertThat(subject.shiftedPosition(11)).isEqualTo(5);
+        assertThat(subject.shiftedPosition(13)).isEqualTo(6);
+        assertThat(subject.shiftedPosition(15)).isEqualTo(7);
+        assertThat(subject.shiftedPosition(17)).isEqualTo(8);
+        assertThat(subject.shiftedPosition(19)).isEqualTo(9);
+
+        start = 0;
+        interval = 6;
+        subject = new AdapterHelper(context, start, interval);
+
+//      acccccaccccc
+        assertThat(subject.shiftedCount(contentRowCount)).isEqualTo(12);
+        validateRows(12, start, interval);
+        assertThat(subject.shiftedPosition(1)).isEqualTo(0);
+        assertThat(subject.shiftedPosition(2)).isEqualTo(1);
+        assertThat(subject.shiftedPosition(3)).isEqualTo(2);
+        assertThat(subject.shiftedPosition(4)).isEqualTo(3);
+        assertThat(subject.shiftedPosition(5)).isEqualTo(4);
+        assertThat(subject.shiftedPosition(7)).isEqualTo(5);
+        assertThat(subject.shiftedPosition(8)).isEqualTo(6);
+        assertThat(subject.shiftedPosition(9)).isEqualTo(7);
+        assertThat(subject.shiftedPosition(10)).isEqualTo(8);
+        assertThat(subject.shiftedPosition(11)).isEqualTo(9);
+
+        start = 0;
+        interval = 11;
+        subject = new AdapterHelper(context, start, interval);
+
+//      acccccccccc
+        assertThat(subject.shiftedCount(contentRowCount)).isEqualTo(11);
+        validateRows(11, start, interval);
+        assertThat(subject.shiftedPosition(1)).isEqualTo(0);
+        assertThat(subject.shiftedPosition(5)).isEqualTo(4);
+        assertThat(subject.shiftedPosition(10)).isEqualTo(9);
+
+        start = 0;
+        interval = 4;
+        subject = new AdapterHelper(context, start, interval);
+
+//      acccacccacccac
+        assertThat(subject.shiftedCount(contentRowCount)).isEqualTo(14);
+        validateRows(14, start, interval);
+
+        start = 5;
+        interval = 6;
+        subject = new AdapterHelper(context, start, interval);
+
+//      cccccaccccc
+        assertThat(subject.shiftedCount(contentRowCount)).isEqualTo(11);
+        validateRows(11, start, interval);
+        assertThat(subject.shiftedPosition(4)).isEqualTo(4);
+        assertThat(subject.shiftedPosition(6)).isEqualTo(5);
+        assertThat(subject.shiftedPosition(10)).isEqualTo(9);
+
+        start = 5;
+        interval = 5;
+        subject = new AdapterHelper(context, start, interval);
+
+//      cccccaccccac
+        assertThat(subject.shiftedCount(contentRowCount)).isEqualTo(12);
+        validateRows(12, start, interval);
+        assertThat(subject.shiftedPosition(6)).isEqualTo(5);
+        assertThat(subject.shiftedPosition(11)).isEqualTo(9);
+
+        start = 3;
+        interval = 4;
+        subject = new AdapterHelper(context, start, interval);
+
+//      cccacccacccac
+        assertThat(subject.shiftedCount(contentRowCount)).isEqualTo(13);
+        validateRows(13, start, interval);
+        assertThat(subject.shiftedPosition(0)).isEqualTo(0);
+        assertThat(subject.shiftedPosition(2)).isEqualTo(2);
+        assertThat(subject.shiftedPosition(12)).isEqualTo(9);
+
+        start = 10;
+        interval = 100;
+        subject = new AdapterHelper(context, start, interval);
+
+//      cccccccccc
+        assertThat(subject.shiftedCount(contentRowCount)).isEqualTo(10);
+        validateRows(10, start, interval);
+        assertThat(subject.shiftedPosition(3)).isEqualTo(3);
+        assertThat(subject.shiftedPosition(7)).isEqualTo(7);
+        assertThat(subject.shiftedPosition(9)).isEqualTo(9);
+
+        start = 0;
+        interval = 10;
+        subject = new AdapterHelper(context, start, interval);
+
+//      acccccccccac
+        assertThat(subject.shiftedCount(contentRowCount)).isEqualTo(12);
+        validateRows(12, start, interval);
+        assertThat(subject.shiftedPosition(1)).isEqualTo(0);
+        assertThat(subject.shiftedPosition(9)).isEqualTo(8);
+        assertThat(subject.shiftedPosition(11)).isEqualTo(9);
+    }
+
+    @Test
+    public void adapterHelper_withContentRowCountOf1_shouldCalculateCorrectly() {
+        contentRowCount = 1;
+        start = 0;
+        interval = 2;
+        subject = new AdapterHelper(context, start, interval);
+
+//      ac
+        assertThat(subject.shiftedCount(contentRowCount)).isEqualTo(2);
+        validateRows(2, start, interval);
+        assertThat(subject.shiftedPosition(1)).isEqualTo(0);
+
+        // We can still query for large numbers since the calculation assumes an infinite list
+        assertThat(subject.shiftedPosition(1001)).isEqualTo(500);
+
+        start = 1;
+        interval = 2;
+        subject = new AdapterHelper(context, start, interval);
+
+//      c
+        assertThat(subject.shiftedCount(contentRowCount)).isEqualTo(1);
+        validateRows(1, start, interval);
+        assertThat(subject.shiftedPosition(0)).isEqualTo(0);
+    }
+
+    private void validateRows(int totalRows, int start, int interval) {
+        for (int i = 0; i < totalRows; ++i) {
+            if (i == start) {
+                assertThat(subject.isAdPosition(i)).isTrue();
+            } else if (i > start && ((i - start) % (interval) == 0)) {
+                assertThat(subject.isAdPosition(i)).isTrue();
+            } else {
+                assertThat(subject.isAdPosition(i)).isFalse();
+            }
+        }
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/ClickDestinationResolutionListenerTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/ClickDestinationResolutionListenerTest.java
index 0e738623..2cd79b4c 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/ClickDestinationResolutionListenerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/ClickDestinationResolutionListenerTest.java
@@ -1,145 +1,146 @@
-package com.mopub.nativeads;
-
-import android.app.Activity;
-import android.content.Intent;
-import android.content.pm.ResolveInfo;
-import android.net.Uri;
-
-import com.mopub.common.MoPubBrowser;
-import com.mopub.common.test.support.SdkTestRunner;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.ArgumentCaptor;
-import org.robolectric.Robolectric;
-
-import java.util.Iterator;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-@RunWith(SdkTestRunner.class)
-public class ClickDestinationResolutionListenerTest {
-
-    private Activity context;
-    private Iterator mockIterator;
-    private SpinningProgressView mockSpinningProgressView;
-    private ClickDestinationResolutionListener subject;
-
-    @Before
-    public void setUp() throws Exception {
-        context = spy(Robolectric.buildActivity(Activity.class).create().get());
-        when(context.getApplicationContext()).thenReturn(context);
-        mockIterator = mock(Iterator.class);
-        mockSpinningProgressView = mock(SpinningProgressView.class);
-
-        subject = new ClickDestinationResolutionListener(context, mockIterator,
-                mockSpinningProgressView);
-    }
-
-    @Test
-    public void onSuccess_withMoPubNativeBrowserUrl_shouldOpenExternalBrowserAndHideProgressView() {
-        subject.onSuccess("mopubnativebrowser://navigate?url=https%3A%2F%2Fwww.example.com");
-
-        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(intent.getDataString()).isEqualTo("https://www.example.com");
-        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
-        verify(mockSpinningProgressView).removeFromRoot();
-    }
-
-    @Test
-    public void onSuccess_withMalformedMoPubNativeBrowserUrl_shouldHideProgressViewButNotOpenExternalBrowser() {
-        // url2 is the wrong query parameter
-        subject.onSuccess("mopubnativebrowser://navigate?url2=https%3A%2F%2Fwww.example.com");
-
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
-        verify(mockSpinningProgressView).removeFromRoot();
-    }
-
-    @Test
-    public void onSuccess_withDeepLinkThatIsResolvable_shouldStartActionViewIntent_shouldRemoveSpinningProgressView() {
-        String deepLinkUrl = "appscheme://host";
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(Intent.ACTION_VIEW,
-                Uri.parse(deepLinkUrl)), new ResolveInfo());
-
-        subject.onSuccess(deepLinkUrl);
-
-        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
-        assertThat(intent.getDataString()).isEqualTo("appscheme://host");
-        verify(mockSpinningProgressView).removeFromRoot();
-    }
-
-    @Test
-    public void onSuccess_withDeepLinkThatIsUnresolvable_shouldNotStartNewIntent_shouldRemoveSpinningProgressView() {
-        String deepLinkUrl = "appscheme://host";
-        // don't add any relevant ResolveInfos to the Robolectric packageManager
-
-        subject.onSuccess(deepLinkUrl);
-
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
-        verify(mockSpinningProgressView).removeFromRoot();
-    }
-
-    @Test
-    public void onSuccess_withAppStoreUrl_shouldStartAppStoreIntent_shouldRemoveSpinningProgressView() {
-        String appStoreUrl = "play.google.com";
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(Intent.ACTION_VIEW,
-                Uri.parse(appStoreUrl)), new ResolveInfo());
-
-        subject.onSuccess(appStoreUrl);
-
-        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
-        assertThat(intent.getDataString()).isEqualTo("play.google.com");
-        verify(mockSpinningProgressView).removeFromRoot();
-    }
-
-    @Test
-    public void onSuccess_withHttpUrl_showOpenInMoPubBrowser_shouldRemoveSpinningProgressViewFromRoot() {
-        String httpUrl = "http://www.dotcom.com";
-
-        subject.onSuccess(httpUrl);
-
-        ArgumentCaptor<Intent> intentCaptor = ArgumentCaptor.forClass(Intent.class);
-        verify(context).startActivity(intentCaptor.capture());
-
-        Intent intent = intentCaptor.getValue();
-
-        assertThat(intent.getComponent().getPackageName()).isEqualTo("com.mopub.mobileads");
-        assertThat(intent.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
-        assertThat(intent.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(httpUrl);
-        verify(mockSpinningProgressView).removeFromRoot();
-    }
-
-    @Test
-    public void onSuccess_withHttpsUrl_showOpenInMoPubBrowser_shouldRemoveSpinningProgressViewFromRoot() {
-        String httpsUrl = "https://www.comdot.com";
-
-        subject.onSuccess(httpsUrl);
-
-        ArgumentCaptor<Intent> intentCaptor = ArgumentCaptor.forClass(Intent.class);
-        verify(context).startActivity(intentCaptor.capture());
-
-        Intent intent = intentCaptor.getValue();
-
-        assertThat(intent.getComponent().getPackageName()).isEqualTo("com.mopub.mobileads");
-        assertThat(intent.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
-        assertThat(intent.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(httpsUrl);
-        verify(mockSpinningProgressView).removeFromRoot();
-    }
-
-    @Test
-    public void onSuccess_withAboutBlankUrl_shouldFailSilently_shouldRemoveSpinningProgressView() {
-        String url = "about:blank";
-
-        subject.onSuccess(url);
-
-        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
-        verify(mockSpinningProgressView).removeFromRoot();
-    }
-}
+package com.mopub.nativeads;
+
+import android.app.Activity;
+import android.content.Intent;
+import android.content.pm.ResolveInfo;
+import android.net.Uri;
+
+import com.mopub.common.MoPubBrowser;
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.robolectric.Robolectric;
+
+import java.util.Iterator;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class ClickDestinationResolutionListenerTest {
+
+    private Activity context;
+    private Iterator mockIterator;
+    private SpinningProgressView mockSpinningProgressView;
+    private ClickDestinationResolutionListener subject;
+
+    @Before
+    public void setUp() throws Exception {
+        context = spy(Robolectric.buildActivity(Activity.class).create().get());
+        when(context.getApplicationContext()).thenReturn(context);
+        when(context.getPackageName()).thenReturn("testPackageName");
+        mockIterator = mock(Iterator.class);
+        mockSpinningProgressView = mock(SpinningProgressView.class);
+
+        subject = new ClickDestinationResolutionListener(context, mockIterator,
+                mockSpinningProgressView);
+    }
+
+    @Test
+    public void onSuccess_withMoPubNativeBrowserUrl_shouldOpenExternalBrowserAndHideProgressView() {
+        subject.onSuccess("mopubnativebrowser://navigate?url=https%3A%2F%2Fwww.example.com");
+
+        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(intent.getDataString()).isEqualTo("https://www.example.com");
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        verify(mockSpinningProgressView).removeFromRoot();
+    }
+
+    @Test
+    public void onSuccess_withMalformedMoPubNativeBrowserUrl_shouldHideProgressViewButNotOpenExternalBrowser() {
+        // url2 is the wrong query parameter
+        subject.onSuccess("mopubnativebrowser://navigate?url2=https%3A%2F%2Fwww.example.com");
+
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+        verify(mockSpinningProgressView).removeFromRoot();
+    }
+
+    @Test
+    public void onSuccess_withDeepLinkThatIsResolvable_shouldStartActionViewIntent_shouldRemoveSpinningProgressView() {
+        String deepLinkUrl = "appscheme://host";
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(Intent.ACTION_VIEW,
+                Uri.parse(deepLinkUrl)), new ResolveInfo());
+
+        subject.onSuccess(deepLinkUrl);
+
+        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        assertThat(intent.getDataString()).isEqualTo("appscheme://host");
+        verify(mockSpinningProgressView).removeFromRoot();
+    }
+
+    @Test
+    public void onSuccess_withDeepLinkThatIsUnresolvable_shouldNotStartNewIntent_shouldRemoveSpinningProgressView() {
+        String deepLinkUrl = "appscheme://host";
+        // don't add any relevant ResolveInfos to the Robolectric packageManager
+
+        subject.onSuccess(deepLinkUrl);
+
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+        verify(mockSpinningProgressView).removeFromRoot();
+    }
+
+    @Test
+    public void onSuccess_withAppStoreUrl_shouldStartAppStoreIntent_shouldRemoveSpinningProgressView() {
+        final String appStoreUrl = "play.google.com/";
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(Intent.ACTION_VIEW,
+                Uri.parse(appStoreUrl)), new ResolveInfo());
+
+        subject.onSuccess(appStoreUrl);
+
+        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        assertThat(intent.getDataString()).isEqualTo(appStoreUrl);
+        verify(mockSpinningProgressView).removeFromRoot();
+    }
+
+    @Test
+    public void onSuccess_withHttpUrl_showOpenInMoPubBrowser_shouldRemoveSpinningProgressViewFromRoot() {
+        String httpUrl = "http://www.dotcom.com";
+
+        subject.onSuccess(httpUrl);
+
+        ArgumentCaptor<Intent> intentCaptor = ArgumentCaptor.forClass(Intent.class);
+        verify(context).startActivity(intentCaptor.capture());
+
+        Intent intent = intentCaptor.getValue();
+
+        assertThat(intent.getComponent().getPackageName()).isEqualTo("testPackageName");
+        assertThat(intent.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
+        assertThat(intent.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(httpUrl);
+        verify(mockSpinningProgressView).removeFromRoot();
+    }
+
+    @Test
+    public void onSuccess_withHttpsUrl_showOpenInMoPubBrowser_shouldRemoveSpinningProgressViewFromRoot() {
+        String httpsUrl = "https://www.comdot.com";
+
+        subject.onSuccess(httpsUrl);
+
+        ArgumentCaptor<Intent> intentCaptor = ArgumentCaptor.forClass(Intent.class);
+        verify(context).startActivity(intentCaptor.capture());
+
+        Intent intent = intentCaptor.getValue();
+
+        assertThat(intent.getComponent().getPackageName()).isEqualTo("testPackageName");
+        assertThat(intent.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
+        assertThat(intent.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(httpsUrl);
+        verify(mockSpinningProgressView).removeFromRoot();
+    }
+
+    @Test
+    public void onSuccess_withAboutBlankUrl_shouldFailSilently_shouldRemoveSpinningProgressView() {
+        String url = "about:blank";
+
+        subject.onSuccess(url);
+
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+        verify(mockSpinningProgressView).removeFromRoot();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubAdAdapterTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubAdAdapterTest.java
index 4412c1a7..a81aed19 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubAdAdapterTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubAdAdapterTest.java
@@ -1,528 +1,526 @@
-package com.mopub.nativeads;
-
-import android.app.Activity;
-import android.database.DataSetObserver;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.AdapterView;
-import android.widget.AdapterView.OnItemClickListener;
-import android.widget.AdapterView.OnItemLongClickListener;
-import android.widget.AdapterView.OnItemSelectedListener;
-import android.widget.ArrayAdapter;
-import android.widget.ListView;
-
-import com.mopub.common.test.support.SdkTestRunner;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Mock;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.Robolectric;
-import org.robolectric.annotation.Config;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-@Config(manifest=Config.NONE)
-@RunWith(SdkTestRunner.class)
-public class MoPubAdAdapterTest {
-    private static final int AD_POSITION = 1;
-
-    @Mock
-    private MoPubStreamAdPlacer mockStreamAdPlacer;
-    @Mock
-    private NativeAdData mockNativeAdData;
-    @Mock
-    private View mockAdView;
-    @Mock
-    private VisibilityTracker mockVisibilityTracker;
-    @Mock
-    private MoPubNativeAdLoadedListener mockAdLoadedListener;
-    @Mock
-    private DataSetObserver mockDataSetObserver;
-    @Mock
-    private RequestParameters mockRequestParameters;
-    @Mock
-    private MoPubAdRenderer mockAdRenderer;
-    @Mock
-    private ListView mockListView;
-    @Mock
-    private OnItemClickListener mockOnItemClickListener;
-    @Mock
-    private OnItemLongClickListener mockOnItemLongClickListener;
-    @Mock
-    private OnItemSelectedListener mockOnItemSelectedListener;
-    @Mock
-    private View mockItemView;
-
-    private long originalItemId = 0;
-    private boolean originalHasStableIds = false;
-
-    private int originalItemViewType = 0;
-    private int originalViewTypeCount = 1;
-    private boolean originalItemsAreEnabled = false;
-    private ArrayAdapter<String> originalAdapter;
-    private MoPubAdAdapter subject;
-
-    @Before
-    public void setup() {
-        // Set up original adapter with 2 items
-        Activity activity = Robolectric.buildActivity(Activity.class).create().get();
-        originalAdapter = new ArrayAdapter<String>(activity, android.R.layout.simple_list_item_1) {
-            @Override
-            public boolean isEnabled(final int position) {
-                return originalItemsAreEnabled;
-            }
-
-            @Override
-            public long getItemId(final int position) {
-                return originalItemId;
-            }
-
-            @Override
-            public boolean hasStableIds() {
-                return originalHasStableIds;
-            }
-
-            @Override
-            public int getItemViewType(final int position) {
-                return originalItemViewType;
-            }
-
-            @Override
-            public int getViewTypeCount() {
-                return originalViewTypeCount;
-            }
-        };
-        originalAdapter.add("ITEM 1");
-        originalAdapter.add("ITEM 2");
-
-        subject = new MoPubAdAdapter(mockStreamAdPlacer, originalAdapter, mockVisibilityTracker);
-
-        // Reset because the constructor interacts with the stream ad placer, and we don't want
-        // to worry about verifying those changes in tests.
-        reset(mockStreamAdPlacer);
-
-        // Mock some simple adjustment behavior for tests. This is creating an ad placer that
-        // emulates a content item followed by an ad item, then another content item.
-        when(mockStreamAdPlacer.getAdData(AD_POSITION)).thenReturn(mockNativeAdData);
-        when(mockStreamAdPlacer.getAdView(eq(AD_POSITION), any(View.class), any(ViewGroup.class))).thenReturn(mockAdView);
-        when(mockStreamAdPlacer.isAd(anyInt())).thenAnswer(new Answer<Boolean>() {
-            @Override
-            public Boolean answer(final InvocationOnMock invocation) throws Throwable {
-                int position = (Integer)invocation.getArguments()[0];
-                return position == AD_POSITION;
-            }
-        });
-        when(mockStreamAdPlacer.getOriginalPosition(anyInt())).thenAnswer(new Answer<Integer>() {
-            @Override
-            public Integer answer(final InvocationOnMock invocation) throws Throwable {
-                int originalPosition = (Integer)invocation.getArguments()[0];
-                return originalPosition < AD_POSITION ? originalPosition : originalPosition - 1;
-            }
-        });
-        when(mockStreamAdPlacer.getAdViewType(anyInt())).thenAnswer(new Answer<Integer>() {
-            @Override
-            public Integer answer(final InvocationOnMock invocation) throws Throwable {
-                int originalPosition = (Integer)invocation.getArguments()[0];
-                return originalPosition == AD_POSITION ? 1 : MoPubStreamAdPlacer.CONTENT_VIEW_TYPE;
-            }
-        });
-        when(mockStreamAdPlacer.getAdjustedPosition(anyInt())).thenAnswer(new Answer<Integer>() {
-            @Override
-            public Integer answer(final InvocationOnMock invocation) throws Throwable {
-                int originalPosition = (Integer)invocation.getArguments()[0];
-                return originalPosition < AD_POSITION ? originalPosition : originalPosition + 1;
-            }
-        });
-        when(mockStreamAdPlacer.getAdjustedCount(anyInt())).thenAnswer(new Answer<Integer>() {
-            @Override
-            public Integer answer(final InvocationOnMock invocation) throws Throwable {
-                int originalCount = (Integer)invocation.getArguments()[0];
-                return originalCount < AD_POSITION ? originalCount : originalCount + 1;
-            }
-        });
-    }
-
-    @Test
-    public void originalAdapterChange_shouldNotifyDataSetChanged() {
-        subject.registerDataSetObserver(mockDataSetObserver);
-
-        originalAdapter.notifyDataSetChanged();
-
-        verify(mockDataSetObserver).onChanged();
-    }
-
-    @Test
-    public void originalAdapterInvalidated_shouldNotifyDataSetInvalidated() {
-        subject.registerDataSetObserver(mockDataSetObserver);
-
-        originalAdapter.notifyDataSetInvalidated();
-
-        verify(mockDataSetObserver).onInvalidated();
-    }
-
-    @Test
-    public void registerAdRenderer_shouldCallRegisterAdRendererOnAdPlacer() {
-        subject.registerAdRenderer(mockAdRenderer);
-
-        verify(mockStreamAdPlacer).registerAdRenderer(mockAdRenderer);
-    }
-
-    @Test
-    public void registerAdRenderer_withNull_shouldNotCallAdPlacer() {
-        subject.registerAdRenderer(null);
-
-        verify(mockStreamAdPlacer, never()).registerAdRenderer(any(MoPubAdRenderer.class));
-    }
-
-
-    @Test
-    public void setAdLoadedListener_handleAdLoaded_shouldCallCallback_shouldCallObserver() {
-        subject.setAdLoadedListener(mockAdLoadedListener);
-        subject.registerDataSetObserver(mockDataSetObserver);
-
-        subject.handleAdLoaded(8);
-
-        verify(mockAdLoadedListener).onAdLoaded(8);
-        verify(mockDataSetObserver).onChanged();
-    }
-
-    @Test
-    public void setAdLoadedListener_handleAdRemoved_shouldCallCallback_shouldCallObserver() {
-        subject.setAdLoadedListener(mockAdLoadedListener);
-        subject.registerDataSetObserver(mockDataSetObserver);
-
-        subject.handleAdRemoved(10);
-
-        verify(mockAdLoadedListener).onAdRemoved(10);
-        verify(mockDataSetObserver).onChanged();
-    }
-
-    @Test
-    public void loadAds_shouldCallLoadAdsOnAdPlacer() {
-        subject.loadAds("AD_UNIT_ID");
-
-        verify(mockStreamAdPlacer).loadAds("AD_UNIT_ID");
-
-        subject.loadAds("AD_UNIT_ID", mockRequestParameters);
-
-        verify(mockStreamAdPlacer).loadAds("AD_UNIT_ID", mockRequestParameters);
-    }
-
-    @Test
-    public void isAd_shouldCallIsAdOnAdPlacer() {
-        boolean isAd = subject.isAd(AD_POSITION);
-
-        assertThat(isAd).isTrue();
-
-        isAd = subject.isAd(AD_POSITION + 1);
-
-        assertThat(isAd).isFalse();
-
-        verify(mockStreamAdPlacer, times(2)).isAd(anyInt());
-    }
-
-    @Test
-    public void clearAds_shouldCallClearAdsOnAdPlacer() {
-        subject.clearAds();
-
-        verify(mockStreamAdPlacer).clearAds();
-    }
-
-    @Test
-    public void destroy_shouldDestroyStreamAdPlacer_shouldDestroyVisibilityTracker() {
-        subject.destroy();
-
-        verify(mockStreamAdPlacer).destroy();
-        verify(mockVisibilityTracker).destroy();
-    }
-
-    @Test
-    public void isEnabled_adPosition_shouldReturnTrue() {
-        boolean isEnabled = subject.isEnabled(AD_POSITION);
-
-        assertThat(isEnabled).isTrue();
-    }
-
-    @Test
-    public void isEnabled_withNonAdPosition_shouldUseOriginalAdapter() {
-        originalItemsAreEnabled = false;
-        boolean isEnabled = subject.isEnabled(AD_POSITION + 1);
-
-        assertThat(isEnabled).isFalse();
-
-        originalItemsAreEnabled = true;
-        isEnabled = subject.isEnabled(AD_POSITION + 1);
-
-        assertThat(isEnabled).isTrue();
-    }
-
-    @Test
-    public void getItem_withAdPosition_shouldReturnAd_shouldGetAdDataOnCallAdPlacer() {
-        Object actualItem = subject.getItem(AD_POSITION);
-
-        assertThat(actualItem).isEqualTo(mockNativeAdData);
-
-        verify(mockStreamAdPlacer).getAdData(AD_POSITION);
-    }
-
-    @Test
-    public void getItem_withNonAdPosition_shouldCallGetOriginalPositionOnAdPlacer() {
-        Object actualItem = subject.getItem(AD_POSITION + 1);
-
-        assertThat(actualItem).isNotEqualTo(mockNativeAdData);
-
-        verify(mockStreamAdPlacer).getOriginalPosition(AD_POSITION + 1);
-    }
-
-    @Test
-    public void getCount_shouldCallGetAdjustedCountOnAdPlacer() {
-        int actualCount = subject.getCount();
-
-        assertThat(actualCount).isEqualTo(3);
-
-        verify(mockStreamAdPlacer).getAdjustedCount(anyInt());
-    }
-
-    @Test
-    public void getItemId_withAdPosition_shouldBeNegative() {
-        long itemId = subject.getItemId(AD_POSITION);
-
-        assertThat(itemId).isLessThan(0);
-    }
-
-    @Test
-    public void getItemId_withNonAdPosition_shouldUseOriginalAdapterId() {
-        originalItemId = 42;
-        long itemId = subject.getItemId(AD_POSITION + 1);
-
-        assertThat(itemId).isEqualTo(42);
-    }
-
-    @Test
-    public void hasStableIds_shouldUseOriginalAdapterValue() {
-        originalHasStableIds = false;
-        boolean hasStableIds = subject.hasStableIds();
-
-        assertThat(hasStableIds).isFalse();
-
-        originalHasStableIds = true;
-        hasStableIds = subject.hasStableIds();
-
-        assertThat(hasStableIds).isTrue();
-    }
-
-    @Test
-    public void getView_withAdPosition_shouldReturnAdView_shouldTrackVisibility() {
-        View view = subject.getView(AD_POSITION, null, null);
-
-        assertThat(view).isEqualTo(mockAdView);
-
-        verify(mockVisibilityTracker).addView(eq(mockAdView), anyInt());
-    }
-
-    @Test
-    public void getView_withNonAdPosition_shouldOriginalAdapterView_shouldTrackVisibility() {
-        View view = subject.getView(AD_POSITION + 1, null, null);
-
-        assertThat(view).isNotEqualTo(mockAdView);
-
-        verify(mockVisibilityTracker).addView(any(View.class), anyInt());
-    }
-
-    @Test
-    public void getItemViewType_withAdPosition_shouldReturnOneGreaterThanViewType() {
-        originalItemViewType = 0;
-
-        int itemViewType = subject.getItemViewType(AD_POSITION);
-        assertThat(itemViewType).isEqualTo(originalItemViewType + 1);
-    }
-
-    @Test
-    public void getItemViewType_withNonAdPosition_shouldUseOriginalAdapterId() {
-        originalItemViewType = 0;
-
-        int itemViewType = subject.getItemViewType(AD_POSITION + 1);
-        assertThat(itemViewType).isEqualTo(originalItemViewType);
-    }
-
-    @Test
-    public void getViewTypeCount_shouldReturnOriginalViewTypeCountPlusOne() {
-        originalViewTypeCount = 1;
-
-        int viewTypeCount = subject.getViewTypeCount();
-        assertThat(viewTypeCount).isEqualTo(1);
-
-        originalViewTypeCount = 2;
-
-        viewTypeCount = subject.getViewTypeCount();
-        assertThat(viewTypeCount).isEqualTo(2);
-    }
-
-    @Test
-    public void isEmpty_shouldUseOriginalAdapterValue() {
-        boolean isEmpty = subject.isEmpty();
-
-        assertThat(isEmpty).isFalse();
-
-        originalAdapter.clear();
-
-        isEmpty = subject.isEmpty();
-
-        assertThat(isEmpty).isTrue();
-    }
-
-    @Test
-    public void getOriginalPosition_shouldCallStreamAdPlacer() {
-        subject.getOriginalPosition(5);
-
-        verify(mockStreamAdPlacer).getOriginalPosition(5);
-    }
-
-    @Test
-    public void getAdjustedPosition_shouldCallStreamAdPlacer() {
-        subject.getAdjustedPosition(5);
-
-        verify(mockStreamAdPlacer).getAdjustedPosition(5);
-    }
-
-    @Test
-    public void insertItem_shouldCallInsertItemOnStreamAdPlacer() {
-        subject.insertItem(5);
-
-        verify(mockStreamAdPlacer).insertItem(5);
-    }
-
-    @Test
-    public void removeItem_shouldCallRemoveItemOnStreamAdPlacer() {
-        subject.removeItem(5);
-
-        verify(mockStreamAdPlacer).removeItem(5);
-    }
-
-    @Test
-    public void setOnItemClickListener_withAdPosition_shouldNotCallListener() {
-        subject.setOnClickListener(mockListView, mockOnItemClickListener);
-
-        ArgumentCaptor<OnItemClickListener> listenerCaptor =
-                ArgumentCaptor.forClass(OnItemClickListener.class);
-        verify(mockListView).setOnItemClickListener(listenerCaptor.capture());
-
-        OnItemClickListener listener = listenerCaptor.getValue();
-        listener.onItemClick(mockListView, mockItemView, AD_POSITION, 0);
-
-        verify(mockOnItemClickListener, never()).onItemClick(
-                any(AdapterView.class), any(View.class), anyInt(), anyInt());
-    }
-
-    @Test
-    public void setOnItemClickListener_withNonAdPosition_shouldCallListener() {
-        subject.setOnClickListener(mockListView, mockOnItemClickListener);
-
-        ArgumentCaptor<OnItemClickListener> listenerCaptor =
-                ArgumentCaptor.forClass(OnItemClickListener.class);
-        verify(mockListView).setOnItemClickListener(listenerCaptor.capture());
-
-        OnItemClickListener listener = listenerCaptor.getValue();
-        listener.onItemClick(mockListView, mockItemView, AD_POSITION + 1, 0);
-
-        verify(mockOnItemClickListener).onItemClick(
-                mockListView, mockItemView, AD_POSITION, 0);
-    }
-
-    @Test
-    public void setOnItemLongClickListener_withAdPosition_shouldNotCallListener() {
-        subject.setOnItemLongClickListener(mockListView, mockOnItemLongClickListener);
-
-        ArgumentCaptor<OnItemLongClickListener> listenerCaptor =
-                ArgumentCaptor.forClass(OnItemLongClickListener.class);
-        verify(mockListView).setOnItemLongClickListener(listenerCaptor.capture());
-
-        OnItemLongClickListener listener = listenerCaptor.getValue();
-        listener.onItemLongClick(mockListView, mockItemView, AD_POSITION, 0);
-
-        verify(mockOnItemLongClickListener, never()).onItemLongClick(
-                any(AdapterView.class), any(View.class), anyInt(), anyInt());
-    }
-
-    @Test
-    public void setOnItemLongClickListener_withNonAdPosition_shouldCallListener() {
-        subject.setOnItemLongClickListener(mockListView, mockOnItemLongClickListener);
-
-        ArgumentCaptor<OnItemLongClickListener> listenerCaptor =
-                ArgumentCaptor.forClass(OnItemLongClickListener.class);
-        verify(mockListView).setOnItemLongClickListener(listenerCaptor.capture());
-
-        OnItemLongClickListener listener = listenerCaptor.getValue();
-        listener.onItemLongClick(mockListView, mockItemView, AD_POSITION + 1, 0);
-
-        verify(mockOnItemLongClickListener).onItemLongClick(
-                mockListView, mockItemView, AD_POSITION, 0);
-    }
-
-    @Test
-    public void setOnItemSelectedListener_withAdPosition_shouldNotCallListener() {
-        subject.setOnItemSelectedListener(mockListView, mockOnItemSelectedListener);
-
-        ArgumentCaptor<OnItemSelectedListener> listenerCaptor =
-                ArgumentCaptor.forClass(OnItemSelectedListener.class);
-        verify(mockListView).setOnItemSelectedListener(listenerCaptor.capture());
-
-        OnItemSelectedListener listener = listenerCaptor.getValue();
-        listener.onItemSelected(mockListView, mockItemView, AD_POSITION, 0);
-
-        verify(mockOnItemSelectedListener, never()).onItemSelected(
-                any(AdapterView.class), any(View.class), anyInt(), anyInt());
-    }
-
-    @Test
-    public void setOnItemSelectedListener_withNonAdPosition_shouldCallListener() {
-        subject.setOnItemSelectedListener(mockListView, mockOnItemSelectedListener);
-
-        ArgumentCaptor<OnItemSelectedListener> listenerCaptor =
-                ArgumentCaptor.forClass(OnItemSelectedListener.class);
-        verify(mockListView).setOnItemSelectedListener(listenerCaptor.capture());
-
-        OnItemSelectedListener listener = listenerCaptor.getValue();
-        listener.onItemSelected(mockListView, mockItemView, AD_POSITION + 1, 0);
-
-        verify(mockOnItemSelectedListener).onItemSelected(
-                mockListView, mockItemView, AD_POSITION, 0);
-    }
-
-    @Test
-    public void setSelection_shouldCallSetSelectionOnListView() {
-        subject.setSelection(mockListView, AD_POSITION);
-
-        // Since the original position is the ad position, the adjusted position is 1 higher
-        verify(mockListView).setSelection(AD_POSITION + 1);
-    }
-
-    @Test
-    public void smoothScrollToPosition_shouldCallSmooethScrollToPositionOnListView() {
-        subject.smoothScrollToPosition(mockListView, AD_POSITION);
-
-        // Since the original position is the ad position, the adjusted position is 1 higher
-        verify(mockListView).smoothScrollToPosition(AD_POSITION + 1);
-    }
-
-    @Test
-    public void refreshAds_shouldLoadAdsOnAdPlacer() {
-        when(mockListView.getAdapter()).thenReturn(subject);
-
-        subject.refreshAds(mockListView, "AD_UNIT_ID", mockRequestParameters);
-
-        verify(mockStreamAdPlacer).loadAds("AD_UNIT_ID", mockRequestParameters);
-    }
-}
+package com.mopub.nativeads;
+
+import android.app.Activity;
+import android.database.DataSetObserver;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.AdapterView;
+import android.widget.AdapterView.OnItemClickListener;
+import android.widget.AdapterView.OnItemLongClickListener;
+import android.widget.AdapterView.OnItemSelectedListener;
+import android.widget.ArrayAdapter;
+import android.widget.ListView;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class MoPubAdAdapterTest {
+    private static final int AD_POSITION = 1;
+
+    @Mock
+    private MoPubStreamAdPlacer mockStreamAdPlacer;
+    @Mock
+    private NativeAdData mockNativeAdData;
+    @Mock
+    private View mockAdView;
+    @Mock
+    private VisibilityTracker mockVisibilityTracker;
+    @Mock
+    private MoPubNativeAdLoadedListener mockAdLoadedListener;
+    @Mock
+    private DataSetObserver mockDataSetObserver;
+    @Mock
+    private RequestParameters mockRequestParameters;
+    @Mock
+    private MoPubAdRenderer mockAdRenderer;
+    @Mock
+    private ListView mockListView;
+    @Mock
+    private OnItemClickListener mockOnItemClickListener;
+    @Mock
+    private OnItemLongClickListener mockOnItemLongClickListener;
+    @Mock
+    private OnItemSelectedListener mockOnItemSelectedListener;
+    @Mock
+    private View mockItemView;
+
+    private long originalItemId = 0;
+    private boolean originalHasStableIds = false;
+
+    private int originalItemViewType = 0;
+    private int originalViewTypeCount = 1;
+    private boolean originalItemsAreEnabled = false;
+    private ArrayAdapter<String> originalAdapter;
+    private MoPubAdAdapter subject;
+
+    @Before
+    public void setup() {
+        // Set up original adapter with 2 items
+        Activity activity = Robolectric.buildActivity(Activity.class).create().get();
+        originalAdapter = new ArrayAdapter<String>(activity, android.R.layout.simple_list_item_1) {
+            @Override
+            public boolean isEnabled(final int position) {
+                return originalItemsAreEnabled;
+            }
+
+            @Override
+            public long getItemId(final int position) {
+                return originalItemId;
+            }
+
+            @Override
+            public boolean hasStableIds() {
+                return originalHasStableIds;
+            }
+
+            @Override
+            public int getItemViewType(final int position) {
+                return originalItemViewType;
+            }
+
+            @Override
+            public int getViewTypeCount() {
+                return originalViewTypeCount;
+            }
+        };
+        originalAdapter.add("ITEM 1");
+        originalAdapter.add("ITEM 2");
+
+        subject = new MoPubAdAdapter(mockStreamAdPlacer, originalAdapter, mockVisibilityTracker);
+
+        // Reset because the constructor interacts with the stream ad placer, and we don't want
+        // to worry about verifying those changes in tests.
+        reset(mockStreamAdPlacer);
+
+        // Mock some simple adjustment behavior for tests. This is creating an ad placer that
+        // emulates a content item followed by an ad item, then another content item.
+        when(mockStreamAdPlacer.getAdData(AD_POSITION)).thenReturn(mockNativeAdData);
+        when(mockStreamAdPlacer.getAdView(eq(AD_POSITION), any(View.class), any(ViewGroup.class))).thenReturn(mockAdView);
+        when(mockStreamAdPlacer.isAd(anyInt())).thenAnswer(new Answer<Boolean>() {
+            @Override
+            public Boolean answer(final InvocationOnMock invocation) throws Throwable {
+                int position = (Integer)invocation.getArguments()[0];
+                return position == AD_POSITION;
+            }
+        });
+        when(mockStreamAdPlacer.getOriginalPosition(anyInt())).thenAnswer(new Answer<Integer>() {
+            @Override
+            public Integer answer(final InvocationOnMock invocation) throws Throwable {
+                int originalPosition = (Integer)invocation.getArguments()[0];
+                return originalPosition < AD_POSITION ? originalPosition : originalPosition - 1;
+            }
+        });
+        when(mockStreamAdPlacer.getAdViewType(anyInt())).thenAnswer(new Answer<Integer>() {
+            @Override
+            public Integer answer(final InvocationOnMock invocation) throws Throwable {
+                int originalPosition = (Integer)invocation.getArguments()[0];
+                return originalPosition == AD_POSITION ? 1 : MoPubStreamAdPlacer.CONTENT_VIEW_TYPE;
+            }
+        });
+        when(mockStreamAdPlacer.getAdjustedPosition(anyInt())).thenAnswer(new Answer<Integer>() {
+            @Override
+            public Integer answer(final InvocationOnMock invocation) throws Throwable {
+                int originalPosition = (Integer)invocation.getArguments()[0];
+                return originalPosition < AD_POSITION ? originalPosition : originalPosition + 1;
+            }
+        });
+        when(mockStreamAdPlacer.getAdjustedCount(anyInt())).thenAnswer(new Answer<Integer>() {
+            @Override
+            public Integer answer(final InvocationOnMock invocation) throws Throwable {
+                int originalCount = (Integer)invocation.getArguments()[0];
+                return originalCount < AD_POSITION ? originalCount : originalCount + 1;
+            }
+        });
+    }
+
+    @Test
+    public void originalAdapterChange_shouldNotifyDataSetChanged() {
+        subject.registerDataSetObserver(mockDataSetObserver);
+
+        originalAdapter.notifyDataSetChanged();
+
+        verify(mockDataSetObserver).onChanged();
+    }
+
+    @Test
+    public void originalAdapterInvalidated_shouldNotifyDataSetInvalidated() {
+        subject.registerDataSetObserver(mockDataSetObserver);
+
+        originalAdapter.notifyDataSetInvalidated();
+
+        verify(mockDataSetObserver).onInvalidated();
+    }
+
+    @Test
+    public void registerAdRenderer_shouldCallRegisterAdRendererOnAdPlacer() {
+        subject.registerAdRenderer(mockAdRenderer);
+
+        verify(mockStreamAdPlacer).registerAdRenderer(mockAdRenderer);
+    }
+
+    @Test
+    public void registerAdRenderer_withNull_shouldNotCallAdPlacer() {
+        subject.registerAdRenderer(null);
+
+        verify(mockStreamAdPlacer, never()).registerAdRenderer(any(MoPubAdRenderer.class));
+    }
+
+
+    @Test
+    public void setAdLoadedListener_handleAdLoaded_shouldCallCallback_shouldCallObserver() {
+        subject.setAdLoadedListener(mockAdLoadedListener);
+        subject.registerDataSetObserver(mockDataSetObserver);
+
+        subject.handleAdLoaded(8);
+
+        verify(mockAdLoadedListener).onAdLoaded(8);
+        verify(mockDataSetObserver).onChanged();
+    }
+
+    @Test
+    public void setAdLoadedListener_handleAdRemoved_shouldCallCallback_shouldCallObserver() {
+        subject.setAdLoadedListener(mockAdLoadedListener);
+        subject.registerDataSetObserver(mockDataSetObserver);
+
+        subject.handleAdRemoved(10);
+
+        verify(mockAdLoadedListener).onAdRemoved(10);
+        verify(mockDataSetObserver).onChanged();
+    }
+
+    @Test
+    public void loadAds_shouldCallLoadAdsOnAdPlacer() {
+        subject.loadAds("AD_UNIT_ID");
+
+        verify(mockStreamAdPlacer).loadAds("AD_UNIT_ID");
+
+        subject.loadAds("AD_UNIT_ID", mockRequestParameters);
+
+        verify(mockStreamAdPlacer).loadAds("AD_UNIT_ID", mockRequestParameters);
+    }
+
+    @Test
+    public void isAd_shouldCallIsAdOnAdPlacer() {
+        boolean isAd = subject.isAd(AD_POSITION);
+
+        assertThat(isAd).isTrue();
+
+        isAd = subject.isAd(AD_POSITION + 1);
+
+        assertThat(isAd).isFalse();
+
+        verify(mockStreamAdPlacer, times(2)).isAd(anyInt());
+    }
+
+    @Test
+    public void clearAds_shouldCallClearAdsOnAdPlacer() {
+        subject.clearAds();
+
+        verify(mockStreamAdPlacer).clearAds();
+    }
+
+    @Test
+    public void destroy_shouldDestroyStreamAdPlacer_shouldDestroyVisibilityTracker() {
+        subject.destroy();
+
+        verify(mockStreamAdPlacer).destroy();
+        verify(mockVisibilityTracker).destroy();
+    }
+
+    @Test
+    public void isEnabled_adPosition_shouldReturnTrue() {
+        boolean isEnabled = subject.isEnabled(AD_POSITION);
+
+        assertThat(isEnabled).isTrue();
+    }
+
+    @Test
+    public void isEnabled_withNonAdPosition_shouldUseOriginalAdapter() {
+        originalItemsAreEnabled = false;
+        boolean isEnabled = subject.isEnabled(AD_POSITION + 1);
+
+        assertThat(isEnabled).isFalse();
+
+        originalItemsAreEnabled = true;
+        isEnabled = subject.isEnabled(AD_POSITION + 1);
+
+        assertThat(isEnabled).isTrue();
+    }
+
+    @Test
+    public void getItem_withAdPosition_shouldReturnAd_shouldGetAdDataOnCallAdPlacer() {
+        Object actualItem = subject.getItem(AD_POSITION);
+
+        assertThat(actualItem).isEqualTo(mockNativeAdData);
+
+        verify(mockStreamAdPlacer).getAdData(AD_POSITION);
+    }
+
+    @Test
+    public void getItem_withNonAdPosition_shouldCallGetOriginalPositionOnAdPlacer() {
+        Object actualItem = subject.getItem(AD_POSITION + 1);
+
+        assertThat(actualItem).isNotEqualTo(mockNativeAdData);
+
+        verify(mockStreamAdPlacer).getOriginalPosition(AD_POSITION + 1);
+    }
+
+    @Test
+    public void getCount_shouldCallGetAdjustedCountOnAdPlacer() {
+        int actualCount = subject.getCount();
+
+        assertThat(actualCount).isEqualTo(3);
+
+        verify(mockStreamAdPlacer).getAdjustedCount(anyInt());
+    }
+
+    @Test
+    public void getItemId_withAdPosition_shouldBeNegative() {
+        long itemId = subject.getItemId(AD_POSITION);
+
+        assertThat(itemId).isLessThan(0);
+    }
+
+    @Test
+    public void getItemId_withNonAdPosition_shouldUseOriginalAdapterId() {
+        originalItemId = 42;
+        long itemId = subject.getItemId(AD_POSITION + 1);
+
+        assertThat(itemId).isEqualTo(42);
+    }
+
+    @Test
+    public void hasStableIds_shouldUseOriginalAdapterValue() {
+        originalHasStableIds = false;
+        boolean hasStableIds = subject.hasStableIds();
+
+        assertThat(hasStableIds).isFalse();
+
+        originalHasStableIds = true;
+        hasStableIds = subject.hasStableIds();
+
+        assertThat(hasStableIds).isTrue();
+    }
+
+    @Test
+    public void getView_withAdPosition_shouldReturnAdView_shouldTrackVisibility() {
+        View view = subject.getView(AD_POSITION, null, null);
+
+        assertThat(view).isEqualTo(mockAdView);
+
+        verify(mockVisibilityTracker).addView(eq(mockAdView), anyInt());
+    }
+
+    @Test
+    public void getView_withNonAdPosition_shouldOriginalAdapterView_shouldTrackVisibility() {
+        View view = subject.getView(AD_POSITION + 1, null, null);
+
+        assertThat(view).isNotEqualTo(mockAdView);
+
+        verify(mockVisibilityTracker).addView(any(View.class), anyInt());
+    }
+
+    @Test
+    public void getItemViewType_withAdPosition_shouldReturnOneGreaterThanViewType() {
+        originalItemViewType = 0;
+
+        int itemViewType = subject.getItemViewType(AD_POSITION);
+        assertThat(itemViewType).isEqualTo(originalItemViewType + 1);
+    }
+
+    @Test
+    public void getItemViewType_withNonAdPosition_shouldUseOriginalAdapterId() {
+        originalItemViewType = 0;
+
+        int itemViewType = subject.getItemViewType(AD_POSITION + 1);
+        assertThat(itemViewType).isEqualTo(originalItemViewType);
+    }
+
+    @Test
+    public void getViewTypeCount_shouldReturnOriginalViewTypeCountPlusOne() {
+        originalViewTypeCount = 1;
+
+        int viewTypeCount = subject.getViewTypeCount();
+        assertThat(viewTypeCount).isEqualTo(1);
+
+        originalViewTypeCount = 2;
+
+        viewTypeCount = subject.getViewTypeCount();
+        assertThat(viewTypeCount).isEqualTo(2);
+    }
+
+    @Test
+    public void isEmpty_shouldUseOriginalAdapterValue() {
+        boolean isEmpty = subject.isEmpty();
+
+        assertThat(isEmpty).isFalse();
+
+        originalAdapter.clear();
+
+        isEmpty = subject.isEmpty();
+
+        assertThat(isEmpty).isTrue();
+    }
+
+    @Test
+    public void getOriginalPosition_shouldCallStreamAdPlacer() {
+        subject.getOriginalPosition(5);
+
+        verify(mockStreamAdPlacer).getOriginalPosition(5);
+    }
+
+    @Test
+    public void getAdjustedPosition_shouldCallStreamAdPlacer() {
+        subject.getAdjustedPosition(5);
+
+        verify(mockStreamAdPlacer).getAdjustedPosition(5);
+    }
+
+    @Test
+    public void insertItem_shouldCallInsertItemOnStreamAdPlacer() {
+        subject.insertItem(5);
+
+        verify(mockStreamAdPlacer).insertItem(5);
+    }
+
+    @Test
+    public void removeItem_shouldCallRemoveItemOnStreamAdPlacer() {
+        subject.removeItem(5);
+
+        verify(mockStreamAdPlacer).removeItem(5);
+    }
+
+    @Test
+    public void setOnItemClickListener_withAdPosition_shouldNotCallListener() {
+        subject.setOnClickListener(mockListView, mockOnItemClickListener);
+
+        ArgumentCaptor<OnItemClickListener> listenerCaptor =
+                ArgumentCaptor.forClass(OnItemClickListener.class);
+        verify(mockListView).setOnItemClickListener(listenerCaptor.capture());
+
+        OnItemClickListener listener = listenerCaptor.getValue();
+        listener.onItemClick(mockListView, mockItemView, AD_POSITION, 0);
+
+        verify(mockOnItemClickListener, never()).onItemClick(
+                any(AdapterView.class), any(View.class), anyInt(), anyInt());
+    }
+
+    @Test
+    public void setOnItemClickListener_withNonAdPosition_shouldCallListener() {
+        subject.setOnClickListener(mockListView, mockOnItemClickListener);
+
+        ArgumentCaptor<OnItemClickListener> listenerCaptor =
+                ArgumentCaptor.forClass(OnItemClickListener.class);
+        verify(mockListView).setOnItemClickListener(listenerCaptor.capture());
+
+        OnItemClickListener listener = listenerCaptor.getValue();
+        listener.onItemClick(mockListView, mockItemView, AD_POSITION + 1, 0);
+
+        verify(mockOnItemClickListener).onItemClick(
+                mockListView, mockItemView, AD_POSITION, 0);
+    }
+
+    @Test
+    public void setOnItemLongClickListener_withAdPosition_shouldNotCallListener() {
+        subject.setOnItemLongClickListener(mockListView, mockOnItemLongClickListener);
+
+        ArgumentCaptor<OnItemLongClickListener> listenerCaptor =
+                ArgumentCaptor.forClass(OnItemLongClickListener.class);
+        verify(mockListView).setOnItemLongClickListener(listenerCaptor.capture());
+
+        OnItemLongClickListener listener = listenerCaptor.getValue();
+        listener.onItemLongClick(mockListView, mockItemView, AD_POSITION, 0);
+
+        verify(mockOnItemLongClickListener, never()).onItemLongClick(
+                any(AdapterView.class), any(View.class), anyInt(), anyInt());
+    }
+
+    @Test
+    public void setOnItemLongClickListener_withNonAdPosition_shouldCallListener() {
+        subject.setOnItemLongClickListener(mockListView, mockOnItemLongClickListener);
+
+        ArgumentCaptor<OnItemLongClickListener> listenerCaptor =
+                ArgumentCaptor.forClass(OnItemLongClickListener.class);
+        verify(mockListView).setOnItemLongClickListener(listenerCaptor.capture());
+
+        OnItemLongClickListener listener = listenerCaptor.getValue();
+        listener.onItemLongClick(mockListView, mockItemView, AD_POSITION + 1, 0);
+
+        verify(mockOnItemLongClickListener).onItemLongClick(
+                mockListView, mockItemView, AD_POSITION, 0);
+    }
+
+    @Test
+    public void setOnItemSelectedListener_withAdPosition_shouldNotCallListener() {
+        subject.setOnItemSelectedListener(mockListView, mockOnItemSelectedListener);
+
+        ArgumentCaptor<OnItemSelectedListener> listenerCaptor =
+                ArgumentCaptor.forClass(OnItemSelectedListener.class);
+        verify(mockListView).setOnItemSelectedListener(listenerCaptor.capture());
+
+        OnItemSelectedListener listener = listenerCaptor.getValue();
+        listener.onItemSelected(mockListView, mockItemView, AD_POSITION, 0);
+
+        verify(mockOnItemSelectedListener, never()).onItemSelected(
+                any(AdapterView.class), any(View.class), anyInt(), anyInt());
+    }
+
+    @Test
+    public void setOnItemSelectedListener_withNonAdPosition_shouldCallListener() {
+        subject.setOnItemSelectedListener(mockListView, mockOnItemSelectedListener);
+
+        ArgumentCaptor<OnItemSelectedListener> listenerCaptor =
+                ArgumentCaptor.forClass(OnItemSelectedListener.class);
+        verify(mockListView).setOnItemSelectedListener(listenerCaptor.capture());
+
+        OnItemSelectedListener listener = listenerCaptor.getValue();
+        listener.onItemSelected(mockListView, mockItemView, AD_POSITION + 1, 0);
+
+        verify(mockOnItemSelectedListener).onItemSelected(
+                mockListView, mockItemView, AD_POSITION, 0);
+    }
+
+    @Test
+    public void setSelection_shouldCallSetSelectionOnListView() {
+        subject.setSelection(mockListView, AD_POSITION);
+
+        // Since the original position is the ad position, the adjusted position is 1 higher
+        verify(mockListView).setSelection(AD_POSITION + 1);
+    }
+
+    @Test
+    public void smoothScrollToPosition_shouldCallSmooethScrollToPositionOnListView() {
+        subject.smoothScrollToPosition(mockListView, AD_POSITION);
+
+        // Since the original position is the ad position, the adjusted position is 1 higher
+        verify(mockListView).smoothScrollToPosition(AD_POSITION + 1);
+    }
+
+    @Test
+    public void refreshAds_shouldLoadAdsOnAdPlacer() {
+        when(mockListView.getAdapter()).thenReturn(subject);
+
+        subject.refreshAds(mockListView, "AD_UNIT_ID", mockRequestParameters);
+
+        verify(mockStreamAdPlacer).loadAds("AD_UNIT_ID", mockRequestParameters);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubClientPositioningTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubClientPositioningTest.java
index 725c468a..1f117225 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubClientPositioningTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubClientPositioningTest.java
@@ -1,91 +1,89 @@
-package com.mopub.nativeads;
-
-import com.mopub.common.Preconditions.NoThrow;
-import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
-import com.mopub.common.test.support.SdkTestRunner;
-
-import org.fest.util.Lists;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.annotation.Config;
-
-import static com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning.NO_REPEAT;
-import static org.fest.assertions.api.Assertions.assertThat;
-
-@Config(manifest=Config.NONE)
-@RunWith(SdkTestRunner.class)
-public class MoPubClientPositioningTest {
-
-    private MoPubClientPositioning subject;
-
-    @Before
-    public void setup() {
-        subject = MoPubNativeAdPositioning.clientPositioning();
-    }
-
-    @Test
-    public void addFixedPositionsOutOfOrder_shouldBeSorted() {
-        subject.addFixedPosition(27);
-        subject.addFixedPosition(31);
-        subject.addFixedPosition(17);
-        subject.addFixedPosition(7);
-        subject.addFixedPosition(56);
-
-        assertThat(subject.getFixedPositions())
-                .isEqualTo(Lists.newArrayList(7, 17, 27, 31, 56));
-    }
-
-    @Test
-    public void setRepeatingEnabled_shouldHaveRightInterval() {
-        subject.addFixedPosition(10);
-        subject.enableRepeatingPositions(5);
-
-        assertThat(subject.getRepeatingInterval()).isEqualTo(5);
-        assertThat(subject.getFixedPositions()).isEqualTo(Lists.newArrayList(10));
-    }
-
-    @Test
-    public void setNoRepeat_shouldReturnNoRepeat() {
-        subject.enableRepeatingPositions(5);
-        subject.enableRepeatingPositions(NO_REPEAT);
-
-        assertThat(subject.getRepeatingInterval()).isEqualTo(NO_REPEAT);
-    }
-
-    @Test
-    public void setFixedPositionTwice_shouldReturnOnlyOne() {
-        subject.addFixedPosition(7);
-        subject.addFixedPosition(7);
-
-        assertThat(subject.getFixedPositions().size()).isEqualTo(1);
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void setInvalidFixedPosition_strictMode_shouldThrow() {
-        NoThrow.setStrictMode(true);
-        subject.addFixedPosition(-3);
-    }
-
-    @Test
-    public void setInvalidFixedPosition_releaseMode_shouldNotAddPosition() {
-        NoThrow.setStrictMode(false);
-        subject.addFixedPosition(-3);
-
-        assertThat(subject.getFixedPositions().size()).isEqualTo(0);
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void setInvalidRepeatingInterval_strictMode_shouldThrow() {
-        NoThrow.setStrictMode(true);
-        subject.enableRepeatingPositions(1);
-    }
-
-    @Test
-    public void setInvalidRepeatingInterval_releaseMode_shouldClearRepeatingInterval() {
-        NoThrow.setStrictMode(false);
-        subject.enableRepeatingPositions(0);
-
-        assertThat(subject.getRepeatingInterval()).isEqualTo(NO_REPEAT);
-    }
+package com.mopub.nativeads;
+
+import com.mopub.common.Preconditions.NoThrow;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
+
+import org.fest.util.Lists;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning.NO_REPEAT;
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+public class MoPubClientPositioningTest {
+
+    private MoPubClientPositioning subject;
+
+    @Before
+    public void setup() {
+        subject = MoPubNativeAdPositioning.clientPositioning();
+    }
+
+    @Test
+    public void addFixedPositionsOutOfOrder_shouldBeSorted() {
+        subject.addFixedPosition(27);
+        subject.addFixedPosition(31);
+        subject.addFixedPosition(17);
+        subject.addFixedPosition(7);
+        subject.addFixedPosition(56);
+
+        assertThat(subject.getFixedPositions())
+                .isEqualTo(Lists.newArrayList(7, 17, 27, 31, 56));
+    }
+
+    @Test
+    public void setRepeatingEnabled_shouldHaveRightInterval() {
+        subject.addFixedPosition(10);
+        subject.enableRepeatingPositions(5);
+
+        assertThat(subject.getRepeatingInterval()).isEqualTo(5);
+        assertThat(subject.getFixedPositions()).isEqualTo(Lists.newArrayList(10));
+    }
+
+    @Test
+    public void setNoRepeat_shouldReturnNoRepeat() {
+        subject.enableRepeatingPositions(5);
+        subject.enableRepeatingPositions(NO_REPEAT);
+
+        assertThat(subject.getRepeatingInterval()).isEqualTo(NO_REPEAT);
+    }
+
+    @Test
+    public void setFixedPositionTwice_shouldReturnOnlyOne() {
+        subject.addFixedPosition(7);
+        subject.addFixedPosition(7);
+
+        assertThat(subject.getFixedPositions().size()).isEqualTo(1);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void setInvalidFixedPosition_strictMode_shouldThrow() {
+        NoThrow.setStrictMode(true);
+        subject.addFixedPosition(-3);
+    }
+
+    @Test
+    public void setInvalidFixedPosition_releaseMode_shouldNotAddPosition() {
+        NoThrow.setStrictMode(false);
+        subject.addFixedPosition(-3);
+
+        assertThat(subject.getFixedPositions().size()).isEqualTo(0);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void setInvalidRepeatingInterval_strictMode_shouldThrow() {
+        NoThrow.setStrictMode(true);
+        subject.enableRepeatingPositions(1);
+    }
+
+    @Test
+    public void setInvalidRepeatingInterval_releaseMode_shouldClearRepeatingInterval() {
+        NoThrow.setStrictMode(false);
+        subject.enableRepeatingPositions(0);
+
+        assertThat(subject.getRepeatingInterval()).isEqualTo(NO_REPEAT);
+    }
 }
\ No newline at end of file
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeAdRendererTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeAdRendererTest.java
index 43739948..17f7dc4c 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeAdRendererTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeAdRendererTest.java
@@ -1,171 +1,170 @@
-package com.mopub.nativeads;
-
-import android.app.Activity;
-import android.view.ViewGroup;
-import android.widget.Button;
-import android.widget.ImageView;
-import android.widget.LinearLayout;
-import android.widget.RelativeLayout;
-import android.widget.TextView;
-
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.Utils;
-
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.ExpectedException;
-import org.junit.runner.RunWith;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-
-@RunWith(SdkTestRunner.class)
-public class MoPubNativeAdRendererTest {
-    private MoPubNativeAdRenderer subject;
-    private Activity context;
-    private RelativeLayout relativeLayout;
-    private ViewGroup viewGroup;
-    private NativeResponse nativeResponse;
-    private BaseForwardingNativeAd mNativeAd;
-    private ViewBinder viewBinder;
-    private TextView titleView;
-    private TextView textView;
-    private TextView callToActionView;
-    private ImageView mainImageView;
-    private ImageView iconImageView;
-    private ImageView badView;
-
-    @Before
-    public void setUp() throws Exception {
-        context = new Activity();
-        relativeLayout = new RelativeLayout(context);
-        relativeLayout.setId((int) Utils.generateUniqueId());
-        viewGroup = new LinearLayout(context);
-
-        mNativeAd = new BaseForwardingNativeAd() {};
-        mNativeAd.setTitle("test title");
-        mNativeAd.setText("test text");
-        mNativeAd.setCallToAction("test call to action");
-        mNativeAd.setClickDestinationUrl("destinationUrl");
-
-        nativeResponse = new NativeResponse(context,
-                "impressionTrackerUrl",
-                "clickTrackerUrl",
-                "test ID", mNativeAd,
-                mock(MoPubNative.MoPubNativeListener.class));
-
-        titleView = new TextView(context);
-        titleView.setId((int) Utils.generateUniqueId());
-        textView = new TextView(context);
-        textView.setId((int) Utils.generateUniqueId());
-        callToActionView = new Button(context);
-        callToActionView.setId((int) Utils.generateUniqueId());
-        mainImageView = new ImageView(context);
-        mainImageView.setId((int) Utils.generateUniqueId());
-        iconImageView = new ImageView(context);
-        iconImageView.setId((int) Utils.generateUniqueId());
-        badView = new ImageView(context);
-        badView.setId((int) Utils.generateUniqueId());
-
-        relativeLayout.addView(titleView);
-        relativeLayout.addView(textView);
-        relativeLayout.addView(callToActionView);
-        relativeLayout.addView(mainImageView);
-        relativeLayout.addView(iconImageView);
-        relativeLayout.addView(badView);
-
-        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
-                .titleId(titleView.getId())
-                .textId(textView.getId())
-                .callToActionId(callToActionView.getId())
-                .mainImageId(mainImageView.getId())
-                .iconImageId(iconImageView.getId())
-                .build();
-
-        subject = new MoPubNativeAdRenderer(viewBinder);
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void createAdView_withNullContext_shouldThrowNPE() {
-        subject.createAdView(null, viewGroup);
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void renderAdView_withNullView_shouldThrowNPE() {
-        subject.renderAdView(null, nativeResponse);
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void renderAdView_withNullNativeResponse_shouldThrowNPE() {
-        subject.renderAdView(relativeLayout, null);
-    }
-
-    @Rule public ExpectedException exception = ExpectedException.none();
-    public void renderAdView_withNullViewBinder_shouldThrowNPE() {
-        subject = new MoPubNativeAdRenderer(null);
-
-        exception.expect(NullPointerException.class);
-        subject.renderAdView(relativeLayout, nativeResponse);
-    }
-
-    @Test
-    public void renderAdView_shouldReturnPopulatedView() {
-        subject.renderAdView(relativeLayout, nativeResponse);
-
-        assertThat(((TextView)relativeLayout.findViewById(titleView.getId())).getText()).isEqualTo("test title");
-        assertThat(((TextView)relativeLayout.findViewById(textView.getId())).getText()).isEqualTo(
-                "test text");
-        assertThat(((TextView)relativeLayout.findViewById(callToActionView.getId())).getText()).isEqualTo("test call to action");
-
-        // not testing images due to testing complexity
-    }
-
-    public void renderAdView_withFailedViewBinder_shouldReturnEmptyViews() {
-        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
-                .titleId(titleView.getId())
-                .textId(badView.getId())
-                .callToActionId(callToActionView.getId())
-                .mainImageId(mainImageView.getId())
-                .iconImageId(iconImageView.getId())
-                .build();
-
-        subject = new MoPubNativeAdRenderer(viewBinder);
-        subject.renderAdView(relativeLayout, nativeResponse);
-
-        assertThat(((TextView)relativeLayout.findViewById(titleView.getId())).getText())
-                .isEqualTo("");
-        assertThat(((TextView)relativeLayout.findViewById(textView.getId())).getText())
-                .isEqualTo("");
-        assertThat(((TextView)relativeLayout.findViewById(callToActionView.getId())).getText())
-                .isEqualTo("");
-    }
-
-    @Test
-    public void renderAdView_withNoViewHolder_shouldCreateNativeViewHolder() {
-        subject.renderAdView(relativeLayout, nativeResponse);
-
-        NativeViewHolder expectedViewHolder = NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
-        NativeViewHolder viewHolder = subject.mViewHolderMap.get(relativeLayout);
-        compareNativeViewHolders(expectedViewHolder, viewHolder);
-    }
-
-    @Test
-    public void getOrCreateNativeViewHolder_withViewHolder_shouldNotReCreateNativeViewHolder() {
-        subject.renderAdView(relativeLayout, nativeResponse);
-        NativeViewHolder expectedViewHolder = subject.mViewHolderMap.get(relativeLayout);
-        subject.renderAdView(relativeLayout, nativeResponse);
-
-        NativeViewHolder viewHolder = subject.mViewHolderMap.get(relativeLayout);
-        assertThat(viewHolder).isEqualTo(expectedViewHolder);
-    }
-
-    static private void compareNativeViewHolders(final NativeViewHolder actualViewHolder,
-            final NativeViewHolder expectedViewHolder) {
-        assertThat(actualViewHolder.titleView).isEqualTo(expectedViewHolder.titleView);
-        assertThat(actualViewHolder.textView).isEqualTo(expectedViewHolder.textView);
-        assertThat(actualViewHolder.callToActionView).isEqualTo(expectedViewHolder.callToActionView);
-        assertThat(actualViewHolder.mainImageView).isEqualTo(expectedViewHolder.mainImageView);
-        assertThat(actualViewHolder.iconImageView).isEqualTo(expectedViewHolder.iconImageView);
-    }
+package com.mopub.nativeads;
+
+import android.app.Activity;
+import android.view.ViewGroup;
+import android.widget.Button;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.RelativeLayout;
+import android.widget.TextView;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.Utils;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+
+@RunWith(SdkTestRunner.class)
+public class MoPubNativeAdRendererTest {
+    private MoPubNativeAdRenderer subject;
+    private RelativeLayout relativeLayout;
+    private ViewGroup viewGroup;
+    private NativeResponse nativeResponse;
+    private ViewBinder viewBinder;
+    private TextView titleView;
+    private TextView textView;
+    private TextView callToActionView;
+    private ImageView mainImageView;
+    private ImageView iconImageView;
+    private ImageView badView;
+
+    @Before
+    public void setUp() throws Exception {
+        Activity context = Robolectric.buildActivity(Activity.class).create().get();
+        relativeLayout = new RelativeLayout(context);
+        relativeLayout.setId((int) Utils.generateUniqueId());
+        viewGroup = new LinearLayout(context);
+
+        BaseForwardingNativeAd baseForwardingNativeAd = new BaseForwardingNativeAd() {};
+        baseForwardingNativeAd.setTitle("test title");
+        baseForwardingNativeAd.setText("test text");
+        baseForwardingNativeAd.setCallToAction("test call to action");
+        baseForwardingNativeAd.setClickDestinationUrl("destinationUrl");
+
+        nativeResponse = new NativeResponse(context,
+                "impressionTrackerUrl",
+                "clickTrackerUrl",
+                "test ID", baseForwardingNativeAd,
+                mock(MoPubNative.MoPubNativeListener.class));
+
+        titleView = new TextView(context);
+        titleView.setId((int) Utils.generateUniqueId());
+        textView = new TextView(context);
+        textView.setId((int) Utils.generateUniqueId());
+        callToActionView = new Button(context);
+        callToActionView.setId((int) Utils.generateUniqueId());
+        mainImageView = new ImageView(context);
+        mainImageView.setId((int) Utils.generateUniqueId());
+        iconImageView = new ImageView(context);
+        iconImageView.setId((int) Utils.generateUniqueId());
+        badView = new ImageView(context);
+        badView.setId((int) Utils.generateUniqueId());
+
+        relativeLayout.addView(titleView);
+        relativeLayout.addView(textView);
+        relativeLayout.addView(callToActionView);
+        relativeLayout.addView(mainImageView);
+        relativeLayout.addView(iconImageView);
+        relativeLayout.addView(badView);
+
+        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
+                .titleId(titleView.getId())
+                .textId(textView.getId())
+                .callToActionId(callToActionView.getId())
+                .mainImageId(mainImageView.getId())
+                .iconImageId(iconImageView.getId())
+                .build();
+
+        subject = new MoPubNativeAdRenderer(viewBinder);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void createAdView_withNullContext_shouldThrowNPE() {
+        subject.createAdView(null, viewGroup);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void renderAdView_withNullView_shouldThrowNPE() {
+        subject.renderAdView(null, nativeResponse);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void renderAdView_withNullNativeResponse_shouldThrowNPE() {
+        subject.renderAdView(relativeLayout, null);
+    }
+
+    @Rule public ExpectedException exception = ExpectedException.none();
+    public void renderAdView_withNullViewBinder_shouldThrowNPE() {
+        subject = new MoPubNativeAdRenderer(null);
+
+        exception.expect(NullPointerException.class);
+        subject.renderAdView(relativeLayout, nativeResponse);
+    }
+
+    @Test
+    public void renderAdView_shouldReturnPopulatedView() {
+        subject.renderAdView(relativeLayout, nativeResponse);
+
+        assertThat(((TextView)relativeLayout.findViewById(titleView.getId())).getText()).isEqualTo("test title");
+        assertThat(((TextView)relativeLayout.findViewById(textView.getId())).getText()).isEqualTo(
+                "test text");
+        assertThat(((TextView)relativeLayout.findViewById(callToActionView.getId())).getText()).isEqualTo("test call to action");
+
+        // not testing images due to testing complexity
+    }
+
+    public void renderAdView_withFailedViewBinder_shouldReturnEmptyViews() {
+        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
+                .titleId(titleView.getId())
+                .textId(badView.getId())
+                .callToActionId(callToActionView.getId())
+                .mainImageId(mainImageView.getId())
+                .iconImageId(iconImageView.getId())
+                .build();
+
+        subject = new MoPubNativeAdRenderer(viewBinder);
+        subject.renderAdView(relativeLayout, nativeResponse);
+
+        assertThat(((TextView)relativeLayout.findViewById(titleView.getId())).getText())
+                .isEqualTo("");
+        assertThat(((TextView)relativeLayout.findViewById(textView.getId())).getText())
+                .isEqualTo("");
+        assertThat(((TextView)relativeLayout.findViewById(callToActionView.getId())).getText())
+                .isEqualTo("");
+    }
+
+    @Test
+    public void renderAdView_withNoViewHolder_shouldCreateNativeViewHolder() {
+        subject.renderAdView(relativeLayout, nativeResponse);
+
+        NativeViewHolder expectedViewHolder = NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
+        NativeViewHolder viewHolder = subject.mViewHolderMap.get(relativeLayout);
+        compareNativeViewHolders(expectedViewHolder, viewHolder);
+    }
+
+    @Test
+    public void getOrCreateNativeViewHolder_withViewHolder_shouldNotReCreateNativeViewHolder() {
+        subject.renderAdView(relativeLayout, nativeResponse);
+        NativeViewHolder expectedViewHolder = subject.mViewHolderMap.get(relativeLayout);
+        subject.renderAdView(relativeLayout, nativeResponse);
+
+        NativeViewHolder viewHolder = subject.mViewHolderMap.get(relativeLayout);
+        assertThat(viewHolder).isEqualTo(expectedViewHolder);
+    }
+
+    static private void compareNativeViewHolders(final NativeViewHolder actualViewHolder,
+            final NativeViewHolder expectedViewHolder) {
+        assertThat(actualViewHolder.titleView).isEqualTo(expectedViewHolder.titleView);
+        assertThat(actualViewHolder.textView).isEqualTo(expectedViewHolder.textView);
+        assertThat(actualViewHolder.callToActionView).isEqualTo(expectedViewHolder.callToActionView);
+        assertThat(actualViewHolder.mainImageView).isEqualTo(expectedViewHolder.mainImageView);
+        assertThat(actualViewHolder.iconImageView).isEqualTo(expectedViewHolder.iconImageView);
+    }
 }
\ No newline at end of file
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeTest.java
index 99be737f..e04b9023 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeTest.java
@@ -1,193 +1,193 @@
-package com.mopub.nativeads;
-
-import android.app.Activity;
-
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.test.support.ShadowAsyncTasks;
-import com.mopub.common.util.test.support.TestMethodBuilderFactory;
-import com.mopub.mobileads.MoPubErrorCode;
-import com.mopub.nativeads.MoPubNative.MoPubNativeEventListener;
-import com.mopub.nativeads.MoPubNative.MoPubNativeNetworkListener;
-import com.mopub.network.MoPubNetworkError;
-import com.mopub.network.MoPubRequestQueue;
-import com.mopub.network.Networking;
-import com.mopub.volley.NoConnectionError;
-import com.mopub.volley.Request;
-import com.mopub.volley.VolleyError;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.Robolectric;
-import org.robolectric.annotation.Config;
-import org.robolectric.shadows.ShadowLog;
-
-import java.net.MalformedURLException;
-import java.util.List;
-import java.util.concurrent.Semaphore;
-import java.util.logging.Level;
-import java.util.logging.LogManager;
-
-import static android.Manifest.permission.ACCESS_NETWORK_STATE;
-import static android.Manifest.permission.INTERNET;
-import static com.mopub.common.VolleyRequestMatcher.isUrl;
-import static com.mopub.common.util.Reflection.MethodBuilder;
-import static com.mopub.nativeads.MoPubNative.EMPTY_EVENT_LISTENER;
-import static com.mopub.nativeads.MoPubNative.EMPTY_NETWORK_LISTENER;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.argThat;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-import static org.robolectric.Robolectric.shadowOf;
-
-@RunWith(SdkTestRunner.class)
-@Config(shadows = {ShadowAsyncTasks.class})
-public class MoPubNativeTest {
-    private MoPubNative subject;
-    private MethodBuilder methodBuilder;
-    private Activity context;
-    private Semaphore semaphore;
-    private static final String adUnitId = "test_adunit_id";
-
-    @Mock private MoPubNativeEventListener mockEventListener;
-
-    @Mock private MoPubNativeNetworkListener mockNetworkListener;
-    @Mock private MoPubRequestQueue mockRequestQueue;
-
-
-    @Before
-    public void setup() {
-        context = new Activity();
-        shadowOf(context).grantPermissions(ACCESS_NETWORK_STATE);
-        shadowOf(context).grantPermissions(INTERNET);
-        subject = new MoPubNative(context, adUnitId, mockNetworkListener);
-        methodBuilder = TestMethodBuilderFactory.getSingletonMock();
-        Networking.setRequestQueueForTesting(mockRequestQueue);
-        semaphore = new Semaphore(0);
-    }
-
-    @After
-    public void tearDown() {
-        reset(methodBuilder);
-    }
-
-    @Test
-    public void destroy_shouldSetListenersToEmptyAndClearContext() {
-        assertThat(subject.getContextOrDestroy()).isSameAs(context);
-        assertThat(subject.getMoPubNativeNetworkListener()).isSameAs(mockNetworkListener);
-        subject.setNativeEventListener(mockEventListener);
-        assertThat(subject.getMoPubNativeEventListener()).isSameAs(mockEventListener);
-
-        subject.destroy();
-
-        assertThat(subject.getContextOrDestroy()).isNull();
-        assertThat(subject.getMoPubNativeNetworkListener()).isSameAs(EMPTY_NETWORK_LISTENER);
-        assertThat(subject.getMoPubNativeEventListener()).isSameAs(EMPTY_EVENT_LISTENER);
-    }
-
-    @Test
-    public void setNativeEventListener_shouldSetListener() {
-        assertThat(subject.getMoPubNativeNetworkListener()).isSameAs(mockNetworkListener);
-        subject.setNativeEventListener(mockEventListener);
-        assertThat(subject.getMoPubNativeEventListener()).isSameAs(mockEventListener);
-
-        subject.setNativeEventListener(null);
-        assertThat(subject.getMoPubNativeEventListener()).isSameAs(EMPTY_EVENT_LISTENER);
-    }
-
-    @Test
-    public void loadNativeAd_shouldReturnFast() {
-        Robolectric.getUiThreadScheduler().pause();
-
-        subject.destroy();
-        subject.makeRequest();
-
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
-    }
-
-    @Test
-    public void requestNativeAd_shouldFireNetworkRequest() {
-
-        subject.requestNativeAd("http://www.mopub.com");
-
-        verify(mockNetworkListener, never()).onNativeFail(any(NativeErrorCode.class));
-        verify(mockRequestQueue).add(argThat(isUrl("http://www.mopub.com")));
-    }
-
-    @Test
-    public void requestNativeAd_whenReqeustQueueDeliversUnknownError_shouldFireNativeFail() {
-
-        when(mockRequestQueue.add(any(Request.class)))
-                .then(new Answer<Void>() {
-                    @Override
-                    public Void answer(final InvocationOnMock invocationOnMock) throws Throwable {
-                        ((Request) invocationOnMock.getArguments()[0]).deliverError(new VolleyError(new MalformedURLException()));
-                        return null;
-                    }
-                });
-        subject.requestNativeAd("//\\//\\::::");
-
-        verify(mockNetworkListener).onNativeFail(any(NativeErrorCode.class));
-    }
-
-    @Test
-    public void requestNativeAd_withNullUrl_shouldFireNativeFail() {
-        Robolectric.getUiThreadScheduler().pause();
-
-        subject.requestNativeAd(null);
-
-        verify(mockNetworkListener).onNativeFail(any(NativeErrorCode.class));
-        verify(mockRequestQueue, never()).add(any(Request.class));
-    }
-
-    @Test
-    public void onAdError_shouldNotifyListener() {
-        subject.onAdError(new MoPubNetworkError(MoPubNetworkError.Reason.BAD_BODY));
-
-        verify(mockNetworkListener).onNativeFail(eq(NativeErrorCode.INVALID_JSON));
-    }
-
-    @Test
-    public void onAdError_whenNotMoPubError_shouldNotifyListener() {
-        subject.onAdError(new VolleyError("generic"));
-
-        verify(mockNetworkListener).onNativeFail(eq(NativeErrorCode.UNSPECIFIED));
-    }
-
-    @Test
-    public void onAdError_withVolleyErrorWarmingUp_shouldLogMoPubErrorCodeWarmup_shouldNotifyListener() {
-        LogManager.getLogManager().getLogger("com.mopub").setLevel(Level.ALL);
-
-        subject.onAdError(new MoPubNetworkError(MoPubNetworkError.Reason.WARMING_UP));
-
-        final List<ShadowLog.LogItem> allLogMessages = ShadowLog.getLogs();
-        final ShadowLog.LogItem latestLogMessage = allLogMessages.get(allLogMessages.size() - 1);
-
-        // All log messages end with a newline character.
-        assertThat(latestLogMessage.msg.trim()).isEqualTo(MoPubErrorCode.WARMUP.toString());
-        verify(mockNetworkListener).onNativeFail(eq(NativeErrorCode.EMPTY_AD_RESPONSE));
-    }
-
-    @Test
-    public void onAdError_withNoConnection_shouldLogMoPubErrorCodeNoConnection_shouldNotifyListener() {
-        LogManager.getLogManager().getLogger("com.mopub").setLevel(Level.ALL);
-        shadowOf(context).denyPermissions(INTERNET);
-
-        subject.onAdError(new NoConnectionError());
-
-        final List<ShadowLog.LogItem> allLogMessages = ShadowLog.getLogs();
-        final ShadowLog.LogItem latestLogMessage = allLogMessages.get(allLogMessages.size() - 1);
-
-        // All log messages end with a newline character.
-        assertThat(latestLogMessage.msg.trim()).isEqualTo(MoPubErrorCode.NO_CONNECTION.toString());
-        verify(mockNetworkListener).onNativeFail(eq(NativeErrorCode.CONNECTION_ERROR));
-    }
-}
+package com.mopub.nativeads;
+
+import android.app.Activity;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.test.support.ShadowAsyncTasks;
+import com.mopub.common.util.test.support.TestMethodBuilderFactory;
+import com.mopub.mobileads.MoPubErrorCode;
+import com.mopub.nativeads.MoPubNative.MoPubNativeEventListener;
+import com.mopub.nativeads.MoPubNative.MoPubNativeNetworkListener;
+import com.mopub.network.MoPubNetworkError;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.volley.NoConnectionError;
+import com.mopub.volley.Request;
+import com.mopub.volley.VolleyError;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLog;
+
+import java.net.MalformedURLException;
+import java.util.List;
+import java.util.concurrent.Semaphore;
+import java.util.logging.Level;
+import java.util.logging.LogManager;
+
+import static android.Manifest.permission.ACCESS_NETWORK_STATE;
+import static android.Manifest.permission.INTERNET;
+import static com.mopub.common.VolleyRequestMatcher.isUrl;
+import static com.mopub.common.util.Reflection.MethodBuilder;
+import static com.mopub.nativeads.MoPubNative.EMPTY_EVENT_LISTENER;
+import static com.mopub.nativeads.MoPubNative.EMPTY_NETWORK_LISTENER;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.argThat;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+import static org.robolectric.Robolectric.shadowOf;
+
+@RunWith(SdkTestRunner.class)
+@Config(shadows = {ShadowAsyncTasks.class})
+public class MoPubNativeTest {
+    private MoPubNative subject;
+    private MethodBuilder methodBuilder;
+    private Activity context;
+    private Semaphore semaphore;
+    private static final String adUnitId = "test_adunit_id";
+
+    @Mock private MoPubNativeEventListener mockEventListener;
+
+    @Mock private MoPubNativeNetworkListener mockNetworkListener;
+    @Mock private MoPubRequestQueue mockRequestQueue;
+
+
+    @Before
+    public void setup() {
+        context = Robolectric.buildActivity(Activity.class).create().get();
+        shadowOf(context).grantPermissions(ACCESS_NETWORK_STATE);
+        shadowOf(context).grantPermissions(INTERNET);
+        subject = new MoPubNative(context, adUnitId, mockNetworkListener);
+        methodBuilder = TestMethodBuilderFactory.getSingletonMock();
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+        semaphore = new Semaphore(0);
+    }
+
+    @After
+    public void tearDown() {
+        reset(methodBuilder);
+    }
+
+    @Test
+    public void destroy_shouldSetListenersToEmptyAndClearContext() {
+        assertThat(subject.getContextOrDestroy()).isSameAs(context);
+        assertThat(subject.getMoPubNativeNetworkListener()).isSameAs(mockNetworkListener);
+        subject.setNativeEventListener(mockEventListener);
+        assertThat(subject.getMoPubNativeEventListener()).isSameAs(mockEventListener);
+
+        subject.destroy();
+
+        assertThat(subject.getContextOrDestroy()).isNull();
+        assertThat(subject.getMoPubNativeNetworkListener()).isSameAs(EMPTY_NETWORK_LISTENER);
+        assertThat(subject.getMoPubNativeEventListener()).isSameAs(EMPTY_EVENT_LISTENER);
+    }
+
+    @Test
+    public void setNativeEventListener_shouldSetListener() {
+        assertThat(subject.getMoPubNativeNetworkListener()).isSameAs(mockNetworkListener);
+        subject.setNativeEventListener(mockEventListener);
+        assertThat(subject.getMoPubNativeEventListener()).isSameAs(mockEventListener);
+
+        subject.setNativeEventListener(null);
+        assertThat(subject.getMoPubNativeEventListener()).isSameAs(EMPTY_EVENT_LISTENER);
+    }
+
+    @Test
+    public void loadNativeAd_shouldReturnFast() {
+        Robolectric.getUiThreadScheduler().pause();
+
+        subject.destroy();
+        subject.makeRequest();
+
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+    }
+
+    @Test
+    public void requestNativeAd_shouldFireNetworkRequest() {
+
+        subject.requestNativeAd("http://www.mopub.com");
+
+        verify(mockNetworkListener, never()).onNativeFail(any(NativeErrorCode.class));
+        verify(mockRequestQueue).add(argThat(isUrl("http://www.mopub.com")));
+    }
+
+    @Test
+    public void requestNativeAd_whenReqeustQueueDeliversUnknownError_shouldFireNativeFail() {
+
+        when(mockRequestQueue.add(any(Request.class)))
+                .then(new Answer<Void>() {
+                    @Override
+                    public Void answer(final InvocationOnMock invocationOnMock) throws Throwable {
+                        ((Request) invocationOnMock.getArguments()[0]).deliverError(new VolleyError(new MalformedURLException()));
+                        return null;
+                    }
+                });
+        subject.requestNativeAd("//\\//\\::::");
+
+        verify(mockNetworkListener).onNativeFail(any(NativeErrorCode.class));
+    }
+
+    @Test
+    public void requestNativeAd_withNullUrl_shouldFireNativeFail() {
+        Robolectric.getUiThreadScheduler().pause();
+
+        subject.requestNativeAd(null);
+
+        verify(mockNetworkListener).onNativeFail(any(NativeErrorCode.class));
+        verify(mockRequestQueue, never()).add(any(Request.class));
+    }
+
+    @Test
+    public void onAdError_shouldNotifyListener() {
+        subject.onAdError(new MoPubNetworkError(MoPubNetworkError.Reason.BAD_BODY));
+
+        verify(mockNetworkListener).onNativeFail(eq(NativeErrorCode.INVALID_JSON));
+    }
+
+    @Test
+    public void onAdError_whenNotMoPubError_shouldNotifyListener() {
+        subject.onAdError(new VolleyError("generic"));
+
+        verify(mockNetworkListener).onNativeFail(eq(NativeErrorCode.UNSPECIFIED));
+    }
+
+    @Test
+    public void onAdError_withVolleyErrorWarmingUp_shouldLogMoPubErrorCodeWarmup_shouldNotifyListener() {
+        LogManager.getLogManager().getLogger("com.mopub").setLevel(Level.ALL);
+
+        subject.onAdError(new MoPubNetworkError(MoPubNetworkError.Reason.WARMING_UP));
+
+        final List<ShadowLog.LogItem> allLogMessages = ShadowLog.getLogs();
+        final ShadowLog.LogItem latestLogMessage = allLogMessages.get(allLogMessages.size() - 1);
+
+        // All log messages end with a newline character.
+        assertThat(latestLogMessage.msg.trim()).isEqualTo(MoPubErrorCode.WARMUP.toString());
+        verify(mockNetworkListener).onNativeFail(eq(NativeErrorCode.EMPTY_AD_RESPONSE));
+    }
+
+    @Test
+    public void onAdError_withNoConnection_shouldLogMoPubErrorCodeNoConnection_shouldNotifyListener() {
+        LogManager.getLogManager().getLogger("com.mopub").setLevel(Level.ALL);
+        shadowOf(context).denyPermissions(INTERNET);
+
+        subject.onAdError(new NoConnectionError());
+
+        final List<ShadowLog.LogItem> allLogMessages = ShadowLog.getLogs();
+        final ShadowLog.LogItem latestLogMessage = allLogMessages.get(allLogMessages.size() - 1);
+
+        // All log messages end with a newline character.
+        assertThat(latestLogMessage.msg.trim()).isEqualTo(MoPubErrorCode.NO_CONNECTION.toString());
+        verify(mockNetworkListener).onNativeFail(eq(NativeErrorCode.CONNECTION_ERROR));
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubStreamAdPlacerTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubStreamAdPlacerTest.java
index e4b93fdb..2e772506 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubStreamAdPlacerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubStreamAdPlacerTest.java
@@ -1,498 +1,498 @@
-package com.mopub.nativeads;
-
-import android.app.Activity;
-import android.content.Context;
-import android.view.View;
-import android.view.ViewGroup;
-
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
-import com.mopub.nativeads.PositioningSource.PositioningListener;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Answers;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Mock;
-import org.robolectric.Robolectric;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-@RunWith(SdkTestRunner.class)
-public class MoPubStreamAdPlacerTest {
-    private Context context;
-
-    MoPubClientPositioning positioning;
-
-    @Mock
-    PositioningSource mockPositioningSource;
-    @Mock
-    NativeAdSource mockAdSource;
-    @Mock
-    MoPubNativeAdRenderer mockAdRenderer;
-    @Mock
-    MoPubNativeAdLoadedListener mockAdLoadedListener;
-    @Mock
-    ImpressionTracker mockImpressionTracker;
-
-    @Mock(answer = Answers.RETURNS_DEEP_STUBS)
-    NativeResponse stubNativeResponse;
-
-    private MoPubStreamAdPlacer subject;
-
-    @Before
-    public void setup() {
-        context = new Activity();
-        positioning = MoPubNativeAdPositioning.clientPositioning()
-                .enableRepeatingPositions(2);
-
-        subject = new MoPubStreamAdPlacer(
-                context, mockAdSource, mockImpressionTracker, mockPositioningSource);
-        subject.registerAdRenderer(mockAdRenderer);
-        subject.setAdLoadedListener(mockAdLoadedListener);
-    }
-
-    @Test
-    public void isAd_initialState_hasNoAds() {
-        checkAdPositions();
-    }
-
-    @Test
-    public void isAd_loadPositions_withoutLoadingAds_hasNoAds() {
-        subject.handlePositioningLoad(positioning);
-        checkAdPositions();
-    }
-
-    @Test
-    public void isAd_loadAds_withoutLoadingPositions_hasNoAds() {
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
-        subject.handleAdsAvailable();
-        subject.setItemCount(4);
-        checkAdPositions();
-    }
-
-    @Test
-    public void isAd_loadAds_thenLoadPositions_hasAds() {
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
-        subject.registerAdRenderer(mockAdRenderer);
-        subject.loadAds("test-ad-unit-id");
-
-        subject.handleAdsAvailable();
-        subject.handlePositioningLoad(positioning);
-        subject.setItemCount(4);
-        checkAdPositions(1, 3, 5);
-    }
-
-    @Test
-    public void isAd_loadPositions_thenLoadAds_hasAds() {
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
-        subject.registerAdRenderer(mockAdRenderer);
-        subject.loadAds("test-ad-unit-id");
-
-        subject.handlePositioningLoad(positioning);
-        subject.handleAdsAvailable();
-        subject.setItemCount(4);
-        checkAdPositions(1, 3, 5);
-    }
-
-    @Test
-    public void getOriginalPosition_adjustsPositions() {
-        assertThat(subject.getOriginalPosition(0)).isEqualTo(0);
-        assertThat(subject.getOriginalPosition(1)).isEqualTo(1);
-        assertThat(subject.getOriginalPosition(2)).isEqualTo(2);
-        assertThat(subject.getOriginalPosition(3)).isEqualTo(3);
-        assertThat(subject.getOriginalPosition(4)).isEqualTo(4);
-
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
-        subject.registerAdRenderer(mockAdRenderer);
-        subject.loadAds("test-ad-unit-id");
-        subject.handlePositioningLoad(positioning);
-        subject.handleAdsAvailable();
-        subject.setItemCount(4);
-
-        assertThat(subject.getOriginalPosition(0)).isEqualTo(0);
-        assertThat(subject.getOriginalPosition(1)).isEqualTo(PlacementData.NOT_FOUND);
-        assertThat(subject.getOriginalPosition(2)).isEqualTo(1);
-        assertThat(subject.getOriginalPosition(3)).isEqualTo(PlacementData.NOT_FOUND);
-        assertThat(subject.getOriginalPosition(4)).isEqualTo(2);
-        assertThat(subject.getOriginalPosition(5)).isEqualTo(PlacementData.NOT_FOUND);
-        assertThat(subject.getOriginalPosition(6)).isEqualTo(3);
-        assertThat(subject.getOriginalPosition(7)).isEqualTo(4);
-        assertThat(subject.getOriginalPosition(8)).isEqualTo(5);
-        assertThat(subject.getOriginalPosition(9)).isEqualTo(6);
-    }
-
-    @Test
-    public void getAdjustedPosition_adjustsPositions() {
-        assertThat(subject.getAdjustedPosition(0)).isEqualTo(0);
-        assertThat(subject.getAdjustedPosition(1)).isEqualTo(1);
-        assertThat(subject.getAdjustedPosition(2)).isEqualTo(2);
-        assertThat(subject.getAdjustedPosition(3)).isEqualTo(3);
-        assertThat(subject.getAdjustedPosition(4)).isEqualTo(4);
-
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
-        subject.registerAdRenderer(mockAdRenderer);
-        subject.loadAds("test-ad-unit-id");
-        subject.handlePositioningLoad(positioning);
-        subject.handleAdsAvailable();
-        subject.setItemCount(4);
-
-        assertThat(subject.getAdjustedPosition(0)).isEqualTo(0);
-        assertThat(subject.getAdjustedPosition(1)).isEqualTo(2);
-        assertThat(subject.getAdjustedPosition(2)).isEqualTo(4);
-        assertThat(subject.getAdjustedPosition(3)).isEqualTo(6);
-        assertThat(subject.getAdjustedPosition(4)).isEqualTo(7);
-        assertThat(subject.getAdjustedPosition(5)).isEqualTo(8);
-        assertThat(subject.getAdjustedPosition(6)).isEqualTo(9);
-        assertThat(subject.getAdjustedPosition(7)).isEqualTo(10);
-        assertThat(subject.getAdjustedPosition(8)).isEqualTo(11);
-        assertThat(subject.getAdjustedPosition(9)).isEqualTo(12);
-    }
-
-    @Test
-    public void getOriginalCount_adjustsPositions() {
-        assertThat(subject.getOriginalCount(0)).isEqualTo(0);
-        assertThat(subject.getOriginalCount(1)).isEqualTo(1);
-        assertThat(subject.getOriginalCount(2)).isEqualTo(2);
-        assertThat(subject.getOriginalCount(3)).isEqualTo(3);
-        assertThat(subject.getOriginalCount(4)).isEqualTo(4);
-
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
-        subject.registerAdRenderer(mockAdRenderer);
-        subject.loadAds("test-ad-unit-id");
-        subject.handlePositioningLoad(positioning);
-        subject.handleAdsAvailable();
-        subject.setItemCount(4);
-
-        assertThat(subject.getOriginalCount(0)).isEqualTo(0);
-        assertThat(subject.getOriginalCount(1)).isEqualTo(1);
-        assertThat(subject.getOriginalCount(2)).isEqualTo(PlacementData.NOT_FOUND);
-        assertThat(subject.getOriginalCount(3)).isEqualTo(2);
-        assertThat(subject.getOriginalCount(4)).isEqualTo(PlacementData.NOT_FOUND);
-        assertThat(subject.getOriginalCount(5)).isEqualTo(3);
-        assertThat(subject.getOriginalCount(6)).isEqualTo(PlacementData.NOT_FOUND);
-        assertThat(subject.getOriginalCount(7)).isEqualTo(4);
-        assertThat(subject.getOriginalCount(8)).isEqualTo(5);
-        assertThat(subject.getOriginalCount(9)).isEqualTo(6);
-    }
-
-    @Test
-    public void getAdjustedCount_adjustsPositions() {
-        assertThat(subject.getAdjustedCount(0)).isEqualTo(0);
-        assertThat(subject.getAdjustedCount(1)).isEqualTo(1);
-        assertThat(subject.getAdjustedCount(2)).isEqualTo(2);
-        assertThat(subject.getAdjustedCount(3)).isEqualTo(3);
-        assertThat(subject.getAdjustedCount(4)).isEqualTo(4);
-
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
-        subject.registerAdRenderer(mockAdRenderer);
-        subject.loadAds("test-ad-unit-id");
-        subject.handlePositioningLoad(positioning);
-        subject.handleAdsAvailable();
-        subject.setItemCount(4);
-
-        assertThat(subject.getAdjustedCount(0)).isEqualTo(0);
-        assertThat(subject.getAdjustedCount(1)).isEqualTo(1);
-        assertThat(subject.getAdjustedCount(2)).isEqualTo(3);
-        assertThat(subject.getAdjustedCount(3)).isEqualTo(5);
-        assertThat(subject.getAdjustedCount(4)).isEqualTo(7);
-        assertThat(subject.getAdjustedCount(5)).isEqualTo(8);
-        assertThat(subject.getAdjustedCount(6)).isEqualTo(9);
-        assertThat(subject.getAdjustedCount(7)).isEqualTo(10);
-        assertThat(subject.getAdjustedCount(8)).isEqualTo(11);
-        assertThat(subject.getAdjustedCount(9)).isEqualTo(12);
-    }
-
-    @Test
-    public void placeAds_shouldCallListener() {
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
-        subject.registerAdRenderer(mockAdRenderer);
-        subject.loadAds("test-ad-unit-id");
-        subject.handlePositioningLoad(positioning);
-        subject.handleAdsAvailable();
-        subject.setItemCount(4);
-
-        verify(mockAdLoadedListener, never()).onAdLoaded(0);
-        verify(mockAdLoadedListener).onAdLoaded(1);
-        verify(mockAdLoadedListener, never()).onAdLoaded(2);
-        verify(mockAdLoadedListener).onAdLoaded(3);
-        verify(mockAdLoadedListener, never()).onAdLoaded(4);
-        verify(mockAdLoadedListener).onAdLoaded(5);
-        verify(mockAdLoadedListener, never()).onAdLoaded(6);
-        verify(mockAdLoadedListener, never()).onAdLoaded(7);
-    }
-
-    @Test
-    public void placeAdsInRange_shouldPlaceAfter() {
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
-        subject.registerAdRenderer(mockAdRenderer);
-        subject.loadAds("test-ad-unit-id");
-        subject.handlePositioningLoad(positioning);
-        subject.handleAdsAvailable();
-
-        Robolectric.getUiThreadScheduler().pause();
-        subject.setItemCount(100);
-        subject.placeAdsInRange(50, 50);
-        Robolectric.getUiThreadScheduler().advanceToLastPostedRunnable();
-
-        assertThat(subject.isAd(48)).isFalse();
-        assertThat(subject.isAd(49)).isFalse();
-        assertThat(subject.isAd(50)).isTrue();
-        assertThat(subject.isAd(51)).isFalse();
-        assertThat(subject.isAd(52)).isTrue();
-        assertThat(subject.isAd(53)).isFalse();
-        assertThat(subject.isAd(54)).isTrue();
-    }
-
-    @Test
-    public void placeAdsInRange_shouldCallListener() {
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
-        subject.registerAdRenderer(mockAdRenderer);
-        subject.loadAds("test-ad-unit-id");
-        subject.handlePositioningLoad(positioning);
-        subject.handleAdsAvailable();
-
-        Robolectric.getUiThreadScheduler().pause();
-        subject.setItemCount(100);
-        subject.placeAdsInRange(50, 54);
-        Robolectric.getUiThreadScheduler().advanceToLastPostedRunnable();
-
-        verify(mockAdLoadedListener).onAdLoaded(50);
-        verify(mockAdLoadedListener, never()).onAdLoaded(51);
-        verify(mockAdLoadedListener).onAdLoaded(52);
-        verify(mockAdLoadedListener, never()).onAdLoaded(53);
-        verify(mockAdLoadedListener).onAdLoaded(54);
-        verify(mockAdLoadedListener, never()).onAdLoaded(55);
-        verify(mockAdLoadedListener).onAdLoaded(56);
-    }
-
-    @Test
-    public void placeAdsInRange_aboveItemCount_shouldNotInsert() {
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
-        subject.registerAdRenderer(mockAdRenderer);
-        subject.loadAds("test-ad-unit-id");
-        subject.handlePositioningLoad(positioning);
-        subject.handleAdsAvailable();
-
-        Robolectric.getUiThreadScheduler().pause();
-        subject.setItemCount(0);
-        subject.placeAdsInRange(50, 54);
-        Robolectric.getUiThreadScheduler().advanceToLastPostedRunnable();
-
-        verify(mockAdLoadedListener, never()).onAdLoaded(50);
-    }
-
-    @Test
-    public void getAdView_withNoAds_returnsNull() {
-        assertThat(subject.getAdView(1, null, null)).isNull();
-    }
-
-    @Test
-    public void loadAds_shouldClearAds_afterFirstAdLoads() {
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
-        subject.registerAdRenderer(mockAdRenderer);
-        subject.loadAds("test-ad-unit-id");
-        subject.handlePositioningLoad(positioning);
-        subject.handleAdsAvailable();
-        subject.setItemCount(2);
-        subject.placeAdsInRange(0, 1);
-
-        subject.loadAds("test-ad-unit-id");
-
-        // Ad should still exist until a new ad is available
-        checkAdPositions(1);
-        verify(mockAdLoadedListener, never()).onAdRemoved(anyInt());
-
-        // Once an ad is available, it should be immediately removed and replaced
-        subject.handleAdsAvailable();
-        subject.handlePositioningLoad(positioning);
-        verify(mockAdLoadedListener).onAdRemoved(1);
-        verify(mockAdLoadedListener, times(2)).onAdLoaded(1);
-        checkAdPositions(1);
-    }
-
-    @Test
-    public void loadAds_withFailingPositioningSource_shouldNotLoadAds() {
-        ArgumentCaptor<PositioningListener> listenerCaptor =
-                ArgumentCaptor.forClass(PositioningListener.class);
-
-        subject.registerAdRenderer(mockAdRenderer);
-        subject.loadAds("test-ad-unit-id");
-        verify(mockPositioningSource).loadPositions(
-                eq("test-ad-unit-id"), listenerCaptor.capture());
-        listenerCaptor.getValue().onFailed();
-        verify(mockAdLoadedListener, never()).onAdLoaded(anyInt());
-    }
-
-    @Test
-    public void destroy_shouldClearAdSource_shouldDestroyImpressionTracker_shouldDestroyResponse() {
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
-
-        subject = new MoPubStreamAdPlacer(context,
-                mockAdSource, mockImpressionTracker, mockPositioningSource);
-        subject.registerAdRenderer(mockAdRenderer);
-        subject.loadAds("test-ad-unit-id");
-        subject.handlePositioningLoad(positioning);
-        subject.handleAdsAvailable();
-        subject.setItemCount(2);  // Places 1 ad
-
-        subject.destroy();
-
-        verify(mockAdSource).clear();
-        verify(mockImpressionTracker).destroy();
-        verify(stubNativeResponse).destroy();
-    }
-
-    @Test
-    public void getAdView_withNullConvertView_callsRenderer_addsToImpressionTracker() {
-        View view = new View(context);
-        when(mockAdRenderer.createAdView(any(Context.class), any(ViewGroup.class)))
-                .thenReturn(view);
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
-        subject.registerAdRenderer(mockAdRenderer);
-        subject.loadAds("test-ad-unit-id");
-        subject.handlePositioningLoad(positioning);
-        subject.handleAdsAvailable();
-        subject.setItemCount(100);
-
-        assertThat(subject.getAdView(1, null, null)).isEqualTo(view);
-        verify(mockAdRenderer).createAdView(any(Context.class), any(ViewGroup.class));
-        verify(mockAdRenderer).renderAdView(view, stubNativeResponse);
-        verify(mockImpressionTracker).addView(view, stubNativeResponse);
-    }
-
-    @Test
-    public void getAdView_withConvertView_callsRenderer_addsToImpressionTracker() {
-        View convertView = new View(context);
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
-        subject.registerAdRenderer(mockAdRenderer);
-        subject.loadAds("test-ad-unit-id");
-        subject.handlePositioningLoad(positioning);
-        subject.handleAdsAvailable();
-        subject.setItemCount(4);
-
-        assertThat(subject.getAdView(1, convertView, null)).isEqualTo(convertView);
-        verify(mockAdRenderer, never()).createAdView(any(Context.class), any(ViewGroup.class));
-        verify(mockAdRenderer).renderAdView(convertView, stubNativeResponse);
-        verify(mockImpressionTracker).addView(convertView, stubNativeResponse);
-    }
-
-    @Test
-    public void getAdView_shouldRemoveViewFromImpressionTracker_shouldClearPreviousNativeResponse() throws Exception {
-        NativeResponse mockNativeResponse = mock(NativeResponse.class);
-        View mockView = mock(View.class);
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse, mockNativeResponse, stubNativeResponse);
-        subject.registerAdRenderer(mockAdRenderer);
-        subject.loadAds("test-ad-unit-id");
-        subject.handlePositioningLoad(positioning);
-        subject.handleAdsAvailable();
-        subject.setItemCount(100);
-
-        subject.getAdView(1, mockView, null);
-        verify(mockImpressionTracker).removeView(mockView);
-
-        // Second call should clear the first NativeResponse
-        subject.getAdView(3, mockView, null);
-        verify(mockImpressionTracker, times(2)).removeView(mockView);
-        verify(stubNativeResponse).clear(mockView);
-
-        // Third call should clear the second NativeResponse
-        subject.getAdView(5, mockView, null);
-        verify(mockImpressionTracker, times(3)).removeView(mockView);
-        verify(mockNativeResponse).clear(mockView);
-    }
-
-    @Test
-    public void getAdView_withNetworkImpressionTracker_shouldNotAddViewToImpressionTracker_shouldPrepareNativeResponse() throws Exception {
-        View mockView = mock(View.class);
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
-        subject.registerAdRenderer(mockAdRenderer);
-        subject.loadAds("test-ad-unit-id");
-        subject.handlePositioningLoad(positioning);
-        subject.handleAdsAvailable();
-        subject.setItemCount(100);
-
-        when(stubNativeResponse.isOverridingImpressionTracker()).thenReturn(true);
-        subject.getAdView(1, mockView, null);
-
-        verify(mockImpressionTracker, never()).addView(any(View.class), any(NativeResponse.class));
-        verify(stubNativeResponse).prepare(mockView);
-    }
-
-    @Test
-    public void getAdView_withoutNetworkImpressionTracker_shouldAddViewToImpressionTracker_shouldPrepareNativeResponse() throws Exception {
-        View mockView = mock(View.class);
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
-        subject.registerAdRenderer(mockAdRenderer);
-        subject.loadAds("test-ad-unit-id");
-        subject.handlePositioningLoad(positioning);
-        subject.handleAdsAvailable();
-        subject.setItemCount(100);
-
-        when(stubNativeResponse.isOverridingImpressionTracker()).thenReturn(false);
-        subject.getAdView(1, mockView, null);
-
-        verify(mockImpressionTracker).addView(mockView, stubNativeResponse);
-        verify(stubNativeResponse).prepare(mockView);
-    }
-
-    @Test
-    public void destroy_shouldClearAdSource_shouldDestroyImpressionTracker_shouldResetPlacementData() {
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
-
-        subject = new MoPubStreamAdPlacer(context,
-                mockAdSource, mockImpressionTracker, mockPositioningSource);
-        subject.registerAdRenderer(mockAdRenderer);
-        subject.loadAds("test-ad-unit-id");
-        subject.handlePositioningLoad(positioning);
-        subject.handleAdsAvailable();
-        subject.setItemCount(2);  // Places 1 ad
-
-        subject.destroy();
-
-        verify(mockAdSource).clear();
-        verify(mockImpressionTracker).destroy();
-        verify(stubNativeResponse).destroy();
-    }
-
-    @Test
-    public void modifyClientPositioning_afterConstructingAdPlacer_shouldNotModifyAdPositions() {
-        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
-        subject.registerAdRenderer(mockAdRenderer);
-        subject.loadAds("test-ad-unit-id");
-        subject.handlePositioningLoad(positioning);
-        positioning.enableRepeatingPositions(5);
-
-        subject.handleAdsAvailable();
-        subject.setItemCount(4);
-        checkAdPositions(1, 3, 5);
-    }
-
-    void checkAdPositions(Integer... positions) {
-        List<Integer> expected = Arrays.asList(positions);
-        List<Integer> actual = new ArrayList<Integer>();
-        for (int i = 0; i < 20; i++) {
-            if (subject.isAd(i)) {
-                actual.add(i);
-                assertThat(subject.getAdData(i)).isNotNull();
-            } else {
-                assertThat(subject.getAdData(i)).isNull();
-            }
-        }
-
-        assertThat(actual).isEqualTo(expected);
-    }
-}
+package com.mopub.nativeads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.view.View;
+import android.view.ViewGroup;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
+import com.mopub.nativeads.PositioningSource.PositioningListener;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Answers;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class MoPubStreamAdPlacerTest {
+    private Context context;
+
+    MoPubClientPositioning positioning;
+
+    @Mock
+    PositioningSource mockPositioningSource;
+    @Mock
+    NativeAdSource mockAdSource;
+    @Mock
+    MoPubNativeAdRenderer mockAdRenderer;
+    @Mock
+    MoPubNativeAdLoadedListener mockAdLoadedListener;
+    @Mock
+    ImpressionTracker mockImpressionTracker;
+
+    @Mock(answer = Answers.RETURNS_DEEP_STUBS)
+    NativeResponse stubNativeResponse;
+
+    private MoPubStreamAdPlacer subject;
+
+    @Before
+    public void setup() {
+        context = Robolectric.buildActivity(Activity.class).create().get();
+        positioning = MoPubNativeAdPositioning.clientPositioning()
+                .enableRepeatingPositions(2);
+
+        subject = new MoPubStreamAdPlacer(
+                context, mockAdSource, mockImpressionTracker, mockPositioningSource);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.setAdLoadedListener(mockAdLoadedListener);
+    }
+
+    @Test
+    public void isAd_initialState_hasNoAds() {
+        checkAdPositions();
+    }
+
+    @Test
+    public void isAd_loadPositions_withoutLoadingAds_hasNoAds() {
+        subject.handlePositioningLoad(positioning);
+        checkAdPositions();
+    }
+
+    @Test
+    public void isAd_loadAds_withoutLoadingPositions_hasNoAds() {
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.handleAdsAvailable();
+        subject.setItemCount(4);
+        checkAdPositions();
+    }
+
+    @Test
+    public void isAd_loadAds_thenLoadPositions_hasAds() {
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
+
+        subject.handleAdsAvailable();
+        subject.handlePositioningLoad(positioning);
+        subject.setItemCount(4);
+        checkAdPositions(1, 3, 5);
+    }
+
+    @Test
+    public void isAd_loadPositions_thenLoadAds_hasAds() {
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
+
+        subject.handlePositioningLoad(positioning);
+        subject.handleAdsAvailable();
+        subject.setItemCount(4);
+        checkAdPositions(1, 3, 5);
+    }
+
+    @Test
+    public void getOriginalPosition_adjustsPositions() {
+        assertThat(subject.getOriginalPosition(0)).isEqualTo(0);
+        assertThat(subject.getOriginalPosition(1)).isEqualTo(1);
+        assertThat(subject.getOriginalPosition(2)).isEqualTo(2);
+        assertThat(subject.getOriginalPosition(3)).isEqualTo(3);
+        assertThat(subject.getOriginalPosition(4)).isEqualTo(4);
+
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
+        subject.handlePositioningLoad(positioning);
+        subject.handleAdsAvailable();
+        subject.setItemCount(4);
+
+        assertThat(subject.getOriginalPosition(0)).isEqualTo(0);
+        assertThat(subject.getOriginalPosition(1)).isEqualTo(PlacementData.NOT_FOUND);
+        assertThat(subject.getOriginalPosition(2)).isEqualTo(1);
+        assertThat(subject.getOriginalPosition(3)).isEqualTo(PlacementData.NOT_FOUND);
+        assertThat(subject.getOriginalPosition(4)).isEqualTo(2);
+        assertThat(subject.getOriginalPosition(5)).isEqualTo(PlacementData.NOT_FOUND);
+        assertThat(subject.getOriginalPosition(6)).isEqualTo(3);
+        assertThat(subject.getOriginalPosition(7)).isEqualTo(4);
+        assertThat(subject.getOriginalPosition(8)).isEqualTo(5);
+        assertThat(subject.getOriginalPosition(9)).isEqualTo(6);
+    }
+
+    @Test
+    public void getAdjustedPosition_adjustsPositions() {
+        assertThat(subject.getAdjustedPosition(0)).isEqualTo(0);
+        assertThat(subject.getAdjustedPosition(1)).isEqualTo(1);
+        assertThat(subject.getAdjustedPosition(2)).isEqualTo(2);
+        assertThat(subject.getAdjustedPosition(3)).isEqualTo(3);
+        assertThat(subject.getAdjustedPosition(4)).isEqualTo(4);
+
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
+        subject.handlePositioningLoad(positioning);
+        subject.handleAdsAvailable();
+        subject.setItemCount(4);
+
+        assertThat(subject.getAdjustedPosition(0)).isEqualTo(0);
+        assertThat(subject.getAdjustedPosition(1)).isEqualTo(2);
+        assertThat(subject.getAdjustedPosition(2)).isEqualTo(4);
+        assertThat(subject.getAdjustedPosition(3)).isEqualTo(6);
+        assertThat(subject.getAdjustedPosition(4)).isEqualTo(7);
+        assertThat(subject.getAdjustedPosition(5)).isEqualTo(8);
+        assertThat(subject.getAdjustedPosition(6)).isEqualTo(9);
+        assertThat(subject.getAdjustedPosition(7)).isEqualTo(10);
+        assertThat(subject.getAdjustedPosition(8)).isEqualTo(11);
+        assertThat(subject.getAdjustedPosition(9)).isEqualTo(12);
+    }
+
+    @Test
+    public void getOriginalCount_adjustsPositions() {
+        assertThat(subject.getOriginalCount(0)).isEqualTo(0);
+        assertThat(subject.getOriginalCount(1)).isEqualTo(1);
+        assertThat(subject.getOriginalCount(2)).isEqualTo(2);
+        assertThat(subject.getOriginalCount(3)).isEqualTo(3);
+        assertThat(subject.getOriginalCount(4)).isEqualTo(4);
+
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
+        subject.handlePositioningLoad(positioning);
+        subject.handleAdsAvailable();
+        subject.setItemCount(4);
+
+        assertThat(subject.getOriginalCount(0)).isEqualTo(0);
+        assertThat(subject.getOriginalCount(1)).isEqualTo(1);
+        assertThat(subject.getOriginalCount(2)).isEqualTo(PlacementData.NOT_FOUND);
+        assertThat(subject.getOriginalCount(3)).isEqualTo(2);
+        assertThat(subject.getOriginalCount(4)).isEqualTo(PlacementData.NOT_FOUND);
+        assertThat(subject.getOriginalCount(5)).isEqualTo(3);
+        assertThat(subject.getOriginalCount(6)).isEqualTo(PlacementData.NOT_FOUND);
+        assertThat(subject.getOriginalCount(7)).isEqualTo(4);
+        assertThat(subject.getOriginalCount(8)).isEqualTo(5);
+        assertThat(subject.getOriginalCount(9)).isEqualTo(6);
+    }
+
+    @Test
+    public void getAdjustedCount_adjustsPositions() {
+        assertThat(subject.getAdjustedCount(0)).isEqualTo(0);
+        assertThat(subject.getAdjustedCount(1)).isEqualTo(1);
+        assertThat(subject.getAdjustedCount(2)).isEqualTo(2);
+        assertThat(subject.getAdjustedCount(3)).isEqualTo(3);
+        assertThat(subject.getAdjustedCount(4)).isEqualTo(4);
+
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
+        subject.handlePositioningLoad(positioning);
+        subject.handleAdsAvailable();
+        subject.setItemCount(4);
+
+        assertThat(subject.getAdjustedCount(0)).isEqualTo(0);
+        assertThat(subject.getAdjustedCount(1)).isEqualTo(1);
+        assertThat(subject.getAdjustedCount(2)).isEqualTo(3);
+        assertThat(subject.getAdjustedCount(3)).isEqualTo(5);
+        assertThat(subject.getAdjustedCount(4)).isEqualTo(7);
+        assertThat(subject.getAdjustedCount(5)).isEqualTo(8);
+        assertThat(subject.getAdjustedCount(6)).isEqualTo(9);
+        assertThat(subject.getAdjustedCount(7)).isEqualTo(10);
+        assertThat(subject.getAdjustedCount(8)).isEqualTo(11);
+        assertThat(subject.getAdjustedCount(9)).isEqualTo(12);
+    }
+
+    @Test
+    public void placeAds_shouldCallListener() {
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
+        subject.handlePositioningLoad(positioning);
+        subject.handleAdsAvailable();
+        subject.setItemCount(4);
+
+        verify(mockAdLoadedListener, never()).onAdLoaded(0);
+        verify(mockAdLoadedListener).onAdLoaded(1);
+        verify(mockAdLoadedListener, never()).onAdLoaded(2);
+        verify(mockAdLoadedListener).onAdLoaded(3);
+        verify(mockAdLoadedListener, never()).onAdLoaded(4);
+        verify(mockAdLoadedListener).onAdLoaded(5);
+        verify(mockAdLoadedListener, never()).onAdLoaded(6);
+        verify(mockAdLoadedListener, never()).onAdLoaded(7);
+    }
+
+    @Test
+    public void placeAdsInRange_shouldPlaceAfter() {
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
+        subject.handlePositioningLoad(positioning);
+        subject.handleAdsAvailable();
+
+        Robolectric.getUiThreadScheduler().pause();
+        subject.setItemCount(100);
+        subject.placeAdsInRange(50, 50);
+        Robolectric.getUiThreadScheduler().advanceToLastPostedRunnable();
+
+        assertThat(subject.isAd(48)).isFalse();
+        assertThat(subject.isAd(49)).isFalse();
+        assertThat(subject.isAd(50)).isTrue();
+        assertThat(subject.isAd(51)).isFalse();
+        assertThat(subject.isAd(52)).isTrue();
+        assertThat(subject.isAd(53)).isFalse();
+        assertThat(subject.isAd(54)).isTrue();
+    }
+
+    @Test
+    public void placeAdsInRange_shouldCallListener() {
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
+        subject.handlePositioningLoad(positioning);
+        subject.handleAdsAvailable();
+
+        Robolectric.getUiThreadScheduler().pause();
+        subject.setItemCount(100);
+        subject.placeAdsInRange(50, 54);
+        Robolectric.getUiThreadScheduler().advanceToLastPostedRunnable();
+
+        verify(mockAdLoadedListener).onAdLoaded(50);
+        verify(mockAdLoadedListener, never()).onAdLoaded(51);
+        verify(mockAdLoadedListener).onAdLoaded(52);
+        verify(mockAdLoadedListener, never()).onAdLoaded(53);
+        verify(mockAdLoadedListener).onAdLoaded(54);
+        verify(mockAdLoadedListener, never()).onAdLoaded(55);
+        verify(mockAdLoadedListener).onAdLoaded(56);
+    }
+
+    @Test
+    public void placeAdsInRange_aboveItemCount_shouldNotInsert() {
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
+        subject.handlePositioningLoad(positioning);
+        subject.handleAdsAvailable();
+
+        Robolectric.getUiThreadScheduler().pause();
+        subject.setItemCount(0);
+        subject.placeAdsInRange(50, 54);
+        Robolectric.getUiThreadScheduler().advanceToLastPostedRunnable();
+
+        verify(mockAdLoadedListener, never()).onAdLoaded(50);
+    }
+
+    @Test
+    public void getAdView_withNoAds_returnsNull() {
+        assertThat(subject.getAdView(1, null, null)).isNull();
+    }
+
+    @Test
+    public void loadAds_shouldClearAds_afterFirstAdLoads() {
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
+        subject.handlePositioningLoad(positioning);
+        subject.handleAdsAvailable();
+        subject.setItemCount(2);
+        subject.placeAdsInRange(0, 1);
+
+        subject.loadAds("test-ad-unit-id");
+
+        // Ad should still exist until a new ad is available
+        checkAdPositions(1);
+        verify(mockAdLoadedListener, never()).onAdRemoved(anyInt());
+
+        // Once an ad is available, it should be immediately removed and replaced
+        subject.handleAdsAvailable();
+        subject.handlePositioningLoad(positioning);
+        verify(mockAdLoadedListener).onAdRemoved(1);
+        verify(mockAdLoadedListener, times(2)).onAdLoaded(1);
+        checkAdPositions(1);
+    }
+
+    @Test
+    public void loadAds_withFailingPositioningSource_shouldNotLoadAds() {
+        ArgumentCaptor<PositioningListener> listenerCaptor =
+                ArgumentCaptor.forClass(PositioningListener.class);
+
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
+        verify(mockPositioningSource).loadPositions(
+                eq("test-ad-unit-id"), listenerCaptor.capture());
+        listenerCaptor.getValue().onFailed();
+        verify(mockAdLoadedListener, never()).onAdLoaded(anyInt());
+    }
+
+    @Test
+    public void destroy_shouldClearAdSource_shouldDestroyImpressionTracker_shouldDestroyResponse() {
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+
+        subject = new MoPubStreamAdPlacer(context,
+                mockAdSource, mockImpressionTracker, mockPositioningSource);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
+        subject.handlePositioningLoad(positioning);
+        subject.handleAdsAvailable();
+        subject.setItemCount(2);  // Places 1 ad
+
+        subject.destroy();
+
+        verify(mockAdSource).clear();
+        verify(mockImpressionTracker).destroy();
+        verify(stubNativeResponse).destroy();
+    }
+
+    @Test
+    public void getAdView_withNullConvertView_callsRenderer_addsToImpressionTracker() {
+        View view = new View(context);
+        when(mockAdRenderer.createAdView(any(Context.class), any(ViewGroup.class)))
+                .thenReturn(view);
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
+        subject.handlePositioningLoad(positioning);
+        subject.handleAdsAvailable();
+        subject.setItemCount(100);
+
+        assertThat(subject.getAdView(1, null, null)).isEqualTo(view);
+        verify(mockAdRenderer).createAdView(any(Context.class), any(ViewGroup.class));
+        verify(mockAdRenderer).renderAdView(view, stubNativeResponse);
+        verify(mockImpressionTracker).addView(view, stubNativeResponse);
+    }
+
+    @Test
+    public void getAdView_withConvertView_callsRenderer_addsToImpressionTracker() {
+        View convertView = new View(context);
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
+        subject.handlePositioningLoad(positioning);
+        subject.handleAdsAvailable();
+        subject.setItemCount(4);
+
+        assertThat(subject.getAdView(1, convertView, null)).isEqualTo(convertView);
+        verify(mockAdRenderer, never()).createAdView(any(Context.class), any(ViewGroup.class));
+        verify(mockAdRenderer).renderAdView(convertView, stubNativeResponse);
+        verify(mockImpressionTracker).addView(convertView, stubNativeResponse);
+    }
+
+    @Test
+    public void getAdView_shouldRemoveViewFromImpressionTracker_shouldClearPreviousNativeResponse() throws Exception {
+        NativeResponse mockNativeResponse = mock(NativeResponse.class);
+        View mockView = mock(View.class);
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse, mockNativeResponse, stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
+        subject.handlePositioningLoad(positioning);
+        subject.handleAdsAvailable();
+        subject.setItemCount(100);
+
+        subject.getAdView(1, mockView, null);
+        verify(mockImpressionTracker).removeView(mockView);
+
+        // Second call should clear the first NativeResponse
+        subject.getAdView(3, mockView, null);
+        verify(mockImpressionTracker, times(2)).removeView(mockView);
+        verify(stubNativeResponse).clear(mockView);
+
+        // Third call should clear the second NativeResponse
+        subject.getAdView(5, mockView, null);
+        verify(mockImpressionTracker, times(3)).removeView(mockView);
+        verify(mockNativeResponse).clear(mockView);
+    }
+
+    @Test
+    public void getAdView_withNetworkImpressionTracker_shouldNotAddViewToImpressionTracker_shouldPrepareNativeResponse() throws Exception {
+        View mockView = mock(View.class);
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
+        subject.handlePositioningLoad(positioning);
+        subject.handleAdsAvailable();
+        subject.setItemCount(100);
+
+        when(stubNativeResponse.isOverridingImpressionTracker()).thenReturn(true);
+        subject.getAdView(1, mockView, null);
+
+        verify(mockImpressionTracker, never()).addView(any(View.class), any(NativeResponse.class));
+        verify(stubNativeResponse).prepare(mockView);
+    }
+
+    @Test
+    public void getAdView_withoutNetworkImpressionTracker_shouldAddViewToImpressionTracker_shouldPrepareNativeResponse() throws Exception {
+        View mockView = mock(View.class);
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
+        subject.handlePositioningLoad(positioning);
+        subject.handleAdsAvailable();
+        subject.setItemCount(100);
+
+        when(stubNativeResponse.isOverridingImpressionTracker()).thenReturn(false);
+        subject.getAdView(1, mockView, null);
+
+        verify(mockImpressionTracker).addView(mockView, stubNativeResponse);
+        verify(stubNativeResponse).prepare(mockView);
+    }
+
+    @Test
+    public void destroy_shouldClearAdSource_shouldDestroyImpressionTracker_shouldResetPlacementData() {
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+
+        subject = new MoPubStreamAdPlacer(context,
+                mockAdSource, mockImpressionTracker, mockPositioningSource);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
+        subject.handlePositioningLoad(positioning);
+        subject.handleAdsAvailable();
+        subject.setItemCount(2);  // Places 1 ad
+
+        subject.destroy();
+
+        verify(mockAdSource).clear();
+        verify(mockImpressionTracker).destroy();
+        verify(stubNativeResponse).destroy();
+    }
+
+    @Test
+    public void modifyClientPositioning_afterConstructingAdPlacer_shouldNotModifyAdPositions() {
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
+        subject.handlePositioningLoad(positioning);
+        positioning.enableRepeatingPositions(5);
+
+        subject.handleAdsAvailable();
+        subject.setItemCount(4);
+        checkAdPositions(1, 3, 5);
+    }
+
+    void checkAdPositions(Integer... positions) {
+        List<Integer> expected = Arrays.asList(positions);
+        List<Integer> actual = new ArrayList<Integer>();
+        for (int i = 0; i < 20; i++) {
+            if (subject.isAd(i)) {
+                actual.add(i);
+                assertThat(subject.getAdData(i)).isNotNull();
+            } else {
+                assertThat(subject.getAdData(i)).isNull();
+            }
+        }
+
+        assertThat(actual).isEqualTo(expected);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeResponseTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeResponseTest.java
index 4197a8bf..3ebefbe8 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeResponseTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeResponseTest.java
@@ -1,330 +1,330 @@
-package com.mopub.nativeads;
-
-import android.app.Activity;
-import android.support.annotation.NonNull;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.Button;
-import android.widget.LinearLayout;
-import android.widget.RelativeLayout;
-
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.Utils;
-import com.mopub.network.MoPubRequestQueue;
-import com.mopub.network.Networking;
-import com.mopub.volley.Request;
-import com.mopub.volley.RequestQueue;
-
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-
-import java.util.List;
-import java.util.Map;
-
-import static com.mopub.nativeads.MoPubNative.EMPTY_EVENT_LISTENER;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyZeroInteractions;
-import static org.mockito.Mockito.when;
-
-@RunWith(SdkTestRunner.class)
-public class NativeResponseTest {
-
-    private NativeResponse subject;
-    private BaseForwardingNativeAd mNativeAd;
-    private Activity context;
-    private ViewGroup view;
-    private MoPubNative.MoPubNativeListener moPubNativeListener;
-    private NativeResponse subjectWMockBaseNativeAd;
-    private NativeAdInterface mMockNativeAd;
-    private boolean baseNativeAdRecordedImpression;
-    private boolean baseNativeAdIsClicked;
-    @Mock
-    private MoPubRequestQueue mockRequestQueue;
-
-
-    @Before
-    public void setUp() throws Exception {
-        context = new Activity();
-        mNativeAd = new BaseForwardingNativeAd() {
-            @Override
-            public void recordImpression() {
-                baseNativeAdRecordedImpression = true;
-            }
-
-            @Override
-            public void handleClick(@NonNull final View view) {
-                baseNativeAdIsClicked = true;
-            }
-        };
-        mNativeAd.setTitle("title");
-        mNativeAd.setText("text");
-        mNativeAd.setMainImageUrl("mainImageUrl");
-        mNativeAd.setIconImageUrl("iconImageUrl");
-        mNativeAd.setClickDestinationUrl("clickDestinationUrl");
-        mNativeAd.setCallToAction("callToAction");
-        mNativeAd.addExtra("extra", "extraValue");
-        mNativeAd.addExtra("extraImage", "extraImageUrl");
-        mNativeAd.addImpressionTracker("impressionUrl");
-        mNativeAd.setImpressionMinTimeViewed(500);
-
-        view = new LinearLayout(context);
-
-        Networking.setRequestQueueForTesting(mockRequestQueue);
-
-        moPubNativeListener = mock(MoPubNative.MoPubNativeListener.class);
-
-        subject = new NativeResponse(context,
-                "moPubImpressionTrackerUrl",
-                "moPubClickTrackerUrl",
-                "adunit_id", mNativeAd, moPubNativeListener);
-
-        mMockNativeAd = mock(NativeAdInterface.class);
-        subjectWMockBaseNativeAd = new NativeResponse(context,
-                "moPubImpressionTrackerUrl",
-                "moPubClickTrackerUrl",
-                "adunit_id", mMockNativeAd, moPubNativeListener);
-    }
-
-    @Test
-    public void constructor_shouldSetNativeEventListenerOnNativeAdInterface() {
-        reset(mMockNativeAd);
-        subject = new NativeResponse(context, "moPubImpressionTrackerUrl", "moPubClickTrackerUrl",
-                "adunit_id", mMockNativeAd, moPubNativeListener);
-        verify(mMockNativeAd).setNativeEventListener(any(BaseForwardingNativeAd.NativeEventListener.class));
-    }
-
-    @Test
-    public void getTitle_shouldReturnTitleFromBaseNativeAd() {
-        assertThat(subject.getTitle()).isEqualTo("title");
-    }
-
-    @Test
-    public void getTitle_shouldReturnTextFromBaseNativeAd() {
-        assertThat(subject.getText()).isEqualTo("text");
-    }
-
-    @Test
-    public void getMainImageUrl_shouldReturnMainImageUrlFromBaseNativeAd() {
-        assertThat(subject.getMainImageUrl()).isEqualTo("mainImageUrl");
-    }
-
-    @Test
-    public void getIconImageUrl_shouldReturnIconImageUrlFromBaseNativeAd() {
-        assertThat(subject.getIconImageUrl()).isEqualTo("iconImageUrl");
-    }
-
-    @Test
-    public void getClickDestinationUrl_shouldReturnClickDestinationUrlFromBaseNativeAd() {
-        assertThat(subject.getClickDestinationUrl()).isEqualTo("clickDestinationUrl");
-    }
-
-    @Test
-    public void getCallToAction_shouldReturnCallToActionFromBaseNativeAd() {
-        assertThat(subject.getCallToAction()).isEqualTo("callToAction");
-    }
-
-    @Test
-    public void getExtra_shouldReturnExtraFromBaseNativeAd() {
-        assertThat(subject.getExtra("extra")).isEqualTo("extraValue");
-    }
-
-    @Test
-    public void getExtras_shouldReturnCopyOfExtrasMapFromBaseNativeAd() {
-        final Map<String, Object> extras = subject.getExtras();
-        assertThat(extras.size()).isEqualTo(2);
-        assertThat(extras.get("extra")).isEqualTo("extraValue");
-        assertThat(extras.get("extraImage")).isEqualTo("extraImageUrl");
-        assertThat(extras).isNotSameAs(mNativeAd.getExtras());
-    }
-
-    @Test
-    public void getImpressionTrackers_shouldReturnImpressionTrackersFromMoPubAndFromBaseNativeAd() {
-        final List<String> impressionTrackers = subject.getImpressionTrackers();
-        assertThat(impressionTrackers).containsOnly("moPubImpressionTrackerUrl", "impressionUrl");
-    }
-
-    @Test
-    public void getImpressionMinTimeViewed_shouldReturnImpressionMinTimeViewedFromBaseNativeAd() {
-        assertThat(subject.getImpressionMinTimeViewed()).isEqualTo(500);
-    }
-
-    @Test
-    public void getImpressionMinPercentageViewed_shouldReturnImpressionMinPercentageViewedFromBaseNativeAd() {
-        assertThat(subject.getImpressionMinPercentageViewed()).isEqualTo(50);
-    }
-
-    @Test
-    public void getClickTracker_shouldReturnMoPubClickTracker() {
-        assertThat(subject.getClickTracker()).isEqualTo("moPubClickTrackerUrl");
-    }
-
-    @Test
-    public void prepare_shouldCallPrepareOnBaseNativeAd() {
-        subjectWMockBaseNativeAd.prepare(view);
-        verify(mMockNativeAd).prepare(view);
-    }
-
-    @Test
-    public void prepare_whenDestroyed_shouldReturnFast() {
-        subjectWMockBaseNativeAd.destroy();
-        subjectWMockBaseNativeAd.prepare(view);
-        verify(mMockNativeAd, never()).prepare(view);
-    }
-    
-    @Test
-    public void prepare_withOverridingeClickTracker_shouldNotSetOnClickListener() throws Exception {
-        when(mMockNativeAd.isOverridingClickTracker()).thenReturn(true);
-        View view = mock(View.class);
-        subjectWMockBaseNativeAd.prepare(view);
-        verify(view, never()).setOnClickListener(any(NativeResponse.NativeViewClickListener.class));
-    }
-
-    @Test
-    public void prepare_withoutOverridingClickTracker_shouldSetOnClickListener() throws Exception {
-        when(mMockNativeAd.isOverridingClickTracker()).thenReturn(false);
-        View view = mock(View.class);
-        subjectWMockBaseNativeAd.prepare(view);
-        verify(view).setOnClickListener(any(NativeResponse.NativeViewClickListener.class));
-    }
-
-    @Test
-    public void prepare_shouldAttachClickListenersToViewTree() {
-        RelativeLayout relativeLayout = new RelativeLayout(context);
-        Button callToActionView = new Button(context);
-        callToActionView.setId((int) Utils.generateUniqueId());
-        relativeLayout.addView(callToActionView);
-
-        assertThat(relativeLayout.performClick()).isFalse();
-        assertThat(callToActionView.performClick()).isFalse();
-
-        subject.prepare(relativeLayout);
-
-        assertThat(relativeLayout.performClick()).isTrue();
-        assertThat(callToActionView.performClick()).isTrue();
-    }
-
-    @Test
-    public void recordImpression_shouldRecordImpressionsAndCallIntoBaseNativeAdAndNotifyListenerIdempotently() {
-        assertThat(subject.getRecordedImpression()).isFalse();
-
-        subject.recordImpression(view);
-
-        assertThat(subject.getRecordedImpression()).isTrue();
-
-        assertThat(baseNativeAdRecordedImpression).isTrue();
-        verify(moPubNativeListener).onNativeImpression(view);
-        // There are two impression trackers here.
-        verify(mockRequestQueue, times(2)).add(any(Request.class));
-
-        // reset state
-        baseNativeAdRecordedImpression = false;
-        reset(moPubNativeListener);
-        reset(mockRequestQueue);
-
-        // verify impression tracking doesn't fire again
-        subject.recordImpression(view);
-        assertThat(subject.getRecordedImpression()).isTrue();
-        assertThat(baseNativeAdRecordedImpression).isFalse();
-        verify(moPubNativeListener, never()).onNativeImpression(view);
-        verify(mockRequestQueue, never()).add(any(Request.class));
-    }
-
-    @Test
-    public void recordImpression_whenDestroyed_shouldReturnFast() {
-        subject.destroy();
-        subject.recordImpression(view);
-        assertThat(subject.getRecordedImpression()).isFalse();
-        assertThat(baseNativeAdRecordedImpression).isFalse();
-        verify(moPubNativeListener, never()).onNativeImpression(view);
-        verify(mockRequestQueue, never()).add(any(Request.class));
-    }
-
-    @Test
-    public void handleClick_withNoBaseNativeAdClickDestinationUrl_shouldRecordClickAndCallIntoBaseNativeAdAndNotifyListener() {
-        assertThat(subject.isClicked()).isFalse();
-
-        subject.handleClick(view);
-
-        assertThat(subject.isClicked()).isTrue();
-
-        assertThat(baseNativeAdIsClicked).isTrue();
-        verify(moPubNativeListener).onNativeClick(view);
-        verify(mockRequestQueue).add(any(Request.class));
-
-        // reset state
-        baseNativeAdIsClicked = false;
-        reset(moPubNativeListener);
-        reset(mockRequestQueue);
-
-        // second time, tracking does not fire
-        subject.handleClick(view);
-        assertThat(subject.isClicked()).isTrue();
-        assertThat(baseNativeAdRecordedImpression).isFalse();
-        verify(moPubNativeListener).onNativeClick(view);
-        verifyZeroInteractions(mockRequestQueue);
-    }
-
-    @Ignore("pending")
-    @Test
-    public void handleClick_withBaseNativeAdClickDestinationUrl_shouldRecordClickAndCallIntoBaseNativeAdAndOpenClickDestinationAndNotifyListener() {
-        // Really difficult to test url resolution since it doesn't use the apache http client
-    }
-
-    @Test
-    public void handleClick_whenDestroyed_shouldReturnFast() {
-        subject.destroy();
-        subject.handleClick(view);
-        assertThat(subject.isClicked()).isFalse();
-        assertThat(baseNativeAdIsClicked).isFalse();
-        verify(moPubNativeListener, never()).onNativeClick(view);
-        verifyZeroInteractions(mockRequestQueue);
-    }
-
-    @Test
-    public void destroy_shouldCallIntoBaseNativeAd() {
-        subjectWMockBaseNativeAd.destroy();
-        assertThat(subjectWMockBaseNativeAd.isDestroyed()).isTrue();
-        verify(mMockNativeAd).destroy();
-
-        reset(mMockNativeAd);
-
-        subjectWMockBaseNativeAd.destroy();
-        verify(mMockNativeAd, never()).destroy();
-    }
-
-    @Test
-    public void destroy_shouldSetMoPubNativeEventListenerToEmptyMoPubNativeListener() {
-        assertThat(subjectWMockBaseNativeAd.getMoPubNativeEventListener()).isSameAs(moPubNativeListener);
-
-        subjectWMockBaseNativeAd.destroy();
-
-        assertThat(subjectWMockBaseNativeAd.getMoPubNativeEventListener()).isSameAs(EMPTY_EVENT_LISTENER);
-    }
-
-    // NativeViewClickListener tests
-    @Test
-    public void NativeViewClickListener_onClick_shouldQueueClickTrackerAndUrlResolutionTasks() {
-        subject = mock(NativeResponse.class);
-        NativeResponse.NativeViewClickListener nativeViewClickListener = subject.new NativeViewClickListener();
-
-        View view = new View(context);
-        nativeViewClickListener.onClick(view);
-        verify(subject).handleClick(view);
-    }
-
-    @Ignore("pending")
-    @Test
-    public void loadExtrasImage_shouldAsyncLoadImages() {
-        // no easy way to test this since nothing can be mocked
-        // also not a critical test since it directly calls another service
-    }
-}
+package com.mopub.nativeads;
+
+import android.app.Activity;
+import android.support.annotation.NonNull;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.Button;
+import android.widget.LinearLayout;
+import android.widget.RelativeLayout;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.Utils;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.volley.Request;
+
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+
+import java.util.List;
+import java.util.Map;
+
+import static com.mopub.nativeads.MoPubNative.EMPTY_EVENT_LISTENER;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyZeroInteractions;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class NativeResponseTest {
+
+    private NativeResponse subject;
+    private BaseForwardingNativeAd mNativeAd;
+    private Activity context;
+    private ViewGroup view;
+    private MoPubNative.MoPubNativeListener moPubNativeListener;
+    private NativeResponse subjectWMockBaseNativeAd;
+    private NativeAdInterface mMockNativeAd;
+    private boolean baseNativeAdRecordedImpression;
+    private boolean baseNativeAdIsClicked;
+    @Mock
+    private MoPubRequestQueue mockRequestQueue;
+
+
+    @Before
+    public void setUp() throws Exception {
+        context = Robolectric.buildActivity(Activity.class).create().get();
+        mNativeAd = new BaseForwardingNativeAd() {
+            @Override
+            public void recordImpression() {
+                baseNativeAdRecordedImpression = true;
+            }
+
+            @Override
+            public void handleClick(@NonNull final View view) {
+                baseNativeAdIsClicked = true;
+            }
+        };
+        mNativeAd.setTitle("title");
+        mNativeAd.setText("text");
+        mNativeAd.setMainImageUrl("mainImageUrl");
+        mNativeAd.setIconImageUrl("iconImageUrl");
+        mNativeAd.setClickDestinationUrl("clickDestinationUrl");
+        mNativeAd.setCallToAction("callToAction");
+        mNativeAd.addExtra("extra", "extraValue");
+        mNativeAd.addExtra("extraImage", "extraImageUrl");
+        mNativeAd.addImpressionTracker("impressionUrl");
+        mNativeAd.setImpressionMinTimeViewed(500);
+
+        view = new LinearLayout(context);
+
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+
+        moPubNativeListener = mock(MoPubNative.MoPubNativeListener.class);
+
+        subject = new NativeResponse(context,
+                "moPubImpressionTrackerUrl",
+                "moPubClickTrackerUrl",
+                "adunit_id", mNativeAd, moPubNativeListener);
+
+        mMockNativeAd = mock(NativeAdInterface.class);
+        subjectWMockBaseNativeAd = new NativeResponse(context,
+                "moPubImpressionTrackerUrl",
+                "moPubClickTrackerUrl",
+                "adunit_id", mMockNativeAd, moPubNativeListener);
+    }
+
+    @Test
+    public void constructor_shouldSetNativeEventListenerOnNativeAdInterface() {
+        reset(mMockNativeAd);
+        subject = new NativeResponse(context, "moPubImpressionTrackerUrl", "moPubClickTrackerUrl",
+                "adunit_id", mMockNativeAd, moPubNativeListener);
+        verify(mMockNativeAd).setNativeEventListener(any(BaseForwardingNativeAd.NativeEventListener.class));
+    }
+
+    @Test
+    public void getTitle_shouldReturnTitleFromBaseNativeAd() {
+        assertThat(subject.getTitle()).isEqualTo("title");
+    }
+
+    @Test
+    public void getTitle_shouldReturnTextFromBaseNativeAd() {
+        assertThat(subject.getText()).isEqualTo("text");
+    }
+
+    @Test
+    public void getMainImageUrl_shouldReturnMainImageUrlFromBaseNativeAd() {
+        assertThat(subject.getMainImageUrl()).isEqualTo("mainImageUrl");
+    }
+
+    @Test
+    public void getIconImageUrl_shouldReturnIconImageUrlFromBaseNativeAd() {
+        assertThat(subject.getIconImageUrl()).isEqualTo("iconImageUrl");
+    }
+
+    @Test
+    public void getClickDestinationUrl_shouldReturnClickDestinationUrlFromBaseNativeAd() {
+        assertThat(subject.getClickDestinationUrl()).isEqualTo("clickDestinationUrl");
+    }
+
+    @Test
+    public void getCallToAction_shouldReturnCallToActionFromBaseNativeAd() {
+        assertThat(subject.getCallToAction()).isEqualTo("callToAction");
+    }
+
+    @Test
+    public void getExtra_shouldReturnExtraFromBaseNativeAd() {
+        assertThat(subject.getExtra("extra")).isEqualTo("extraValue");
+    }
+
+    @Test
+    public void getExtras_shouldReturnCopyOfExtrasMapFromBaseNativeAd() {
+        final Map<String, Object> extras = subject.getExtras();
+        assertThat(extras.size()).isEqualTo(2);
+        assertThat(extras.get("extra")).isEqualTo("extraValue");
+        assertThat(extras.get("extraImage")).isEqualTo("extraImageUrl");
+        assertThat(extras).isNotSameAs(mNativeAd.getExtras());
+    }
+
+    @Test
+    public void getImpressionTrackers_shouldReturnImpressionTrackersFromMoPubAndFromBaseNativeAd() {
+        final List<String> impressionTrackers = subject.getImpressionTrackers();
+        assertThat(impressionTrackers).containsOnly("moPubImpressionTrackerUrl", "impressionUrl");
+    }
+
+    @Test
+    public void getImpressionMinTimeViewed_shouldReturnImpressionMinTimeViewedFromBaseNativeAd() {
+        assertThat(subject.getImpressionMinTimeViewed()).isEqualTo(500);
+    }
+
+    @Test
+    public void getImpressionMinPercentageViewed_shouldReturnImpressionMinPercentageViewedFromBaseNativeAd() {
+        assertThat(subject.getImpressionMinPercentageViewed()).isEqualTo(50);
+    }
+
+    @Test
+    public void getClickTracker_shouldReturnMoPubClickTracker() {
+        assertThat(subject.getClickTracker()).isEqualTo("moPubClickTrackerUrl");
+    }
+
+    @Test
+    public void prepare_shouldCallPrepareOnBaseNativeAd() {
+        subjectWMockBaseNativeAd.prepare(view);
+        verify(mMockNativeAd).prepare(view);
+    }
+
+    @Test
+    public void prepare_whenDestroyed_shouldReturnFast() {
+        subjectWMockBaseNativeAd.destroy();
+        subjectWMockBaseNativeAd.prepare(view);
+        verify(mMockNativeAd, never()).prepare(view);
+    }
+    
+    @Test
+    public void prepare_withOverridingeClickTracker_shouldNotSetOnClickListener() throws Exception {
+        when(mMockNativeAd.isOverridingClickTracker()).thenReturn(true);
+        View view = mock(View.class);
+        subjectWMockBaseNativeAd.prepare(view);
+        verify(view, never()).setOnClickListener(any(NativeResponse.NativeViewClickListener.class));
+    }
+
+    @Test
+    public void prepare_withoutOverridingClickTracker_shouldSetOnClickListener() throws Exception {
+        when(mMockNativeAd.isOverridingClickTracker()).thenReturn(false);
+        View view = mock(View.class);
+        subjectWMockBaseNativeAd.prepare(view);
+        verify(view).setOnClickListener(any(NativeResponse.NativeViewClickListener.class));
+    }
+
+    @Test
+    public void prepare_shouldAttachClickListenersToViewTree() {
+        RelativeLayout relativeLayout = new RelativeLayout(context);
+        Button callToActionView = new Button(context);
+        callToActionView.setId((int) Utils.generateUniqueId());
+        relativeLayout.addView(callToActionView);
+
+        assertThat(relativeLayout.performClick()).isFalse();
+        assertThat(callToActionView.performClick()).isFalse();
+
+        subject.prepare(relativeLayout);
+
+        assertThat(relativeLayout.performClick()).isTrue();
+        assertThat(callToActionView.performClick()).isTrue();
+    }
+
+    @Test
+    public void recordImpression_shouldRecordImpressionsAndCallIntoBaseNativeAdAndNotifyListenerIdempotently() {
+        assertThat(subject.getRecordedImpression()).isFalse();
+
+        subject.recordImpression(view);
+
+        assertThat(subject.getRecordedImpression()).isTrue();
+
+        assertThat(baseNativeAdRecordedImpression).isTrue();
+        verify(moPubNativeListener).onNativeImpression(view);
+        // There are two impression trackers here.
+        verify(mockRequestQueue, times(2)).add(any(Request.class));
+
+        // reset state
+        baseNativeAdRecordedImpression = false;
+        reset(moPubNativeListener);
+        reset(mockRequestQueue);
+
+        // verify impression tracking doesn't fire again
+        subject.recordImpression(view);
+        assertThat(subject.getRecordedImpression()).isTrue();
+        assertThat(baseNativeAdRecordedImpression).isFalse();
+        verify(moPubNativeListener, never()).onNativeImpression(view);
+        verify(mockRequestQueue, never()).add(any(Request.class));
+    }
+
+    @Test
+    public void recordImpression_whenDestroyed_shouldReturnFast() {
+        subject.destroy();
+        subject.recordImpression(view);
+        assertThat(subject.getRecordedImpression()).isFalse();
+        assertThat(baseNativeAdRecordedImpression).isFalse();
+        verify(moPubNativeListener, never()).onNativeImpression(view);
+        verify(mockRequestQueue, never()).add(any(Request.class));
+    }
+
+    @Test
+    public void handleClick_withNoBaseNativeAdClickDestinationUrl_shouldRecordClickAndCallIntoBaseNativeAdAndNotifyListener() {
+        assertThat(subject.isClicked()).isFalse();
+
+        subject.handleClick(view);
+
+        assertThat(subject.isClicked()).isTrue();
+
+        assertThat(baseNativeAdIsClicked).isTrue();
+        verify(moPubNativeListener).onNativeClick(view);
+        verify(mockRequestQueue).add(any(Request.class));
+
+        // reset state
+        baseNativeAdIsClicked = false;
+        reset(moPubNativeListener);
+        reset(mockRequestQueue);
+
+        // second time, tracking does not fire
+        subject.handleClick(view);
+        assertThat(subject.isClicked()).isTrue();
+        assertThat(baseNativeAdRecordedImpression).isFalse();
+        verify(moPubNativeListener).onNativeClick(view);
+        verifyZeroInteractions(mockRequestQueue);
+    }
+
+    @Ignore("pending")
+    @Test
+    public void handleClick_withBaseNativeAdClickDestinationUrl_shouldRecordClickAndCallIntoBaseNativeAdAndOpenClickDestinationAndNotifyListener() {
+        // Really difficult to test url resolution since it doesn't use the apache http client
+    }
+
+    @Test
+    public void handleClick_whenDestroyed_shouldReturnFast() {
+        subject.destroy();
+        subject.handleClick(view);
+        assertThat(subject.isClicked()).isFalse();
+        assertThat(baseNativeAdIsClicked).isFalse();
+        verify(moPubNativeListener, never()).onNativeClick(view);
+        verifyZeroInteractions(mockRequestQueue);
+    }
+
+    @Test
+    public void destroy_shouldCallIntoBaseNativeAd() {
+        subjectWMockBaseNativeAd.destroy();
+        assertThat(subjectWMockBaseNativeAd.isDestroyed()).isTrue();
+        verify(mMockNativeAd).destroy();
+
+        reset(mMockNativeAd);
+
+        subjectWMockBaseNativeAd.destroy();
+        verify(mMockNativeAd, never()).destroy();
+    }
+
+    @Test
+    public void destroy_shouldSetMoPubNativeEventListenerToEmptyMoPubNativeListener() {
+        assertThat(subjectWMockBaseNativeAd.getMoPubNativeEventListener()).isSameAs(moPubNativeListener);
+
+        subjectWMockBaseNativeAd.destroy();
+
+        assertThat(subjectWMockBaseNativeAd.getMoPubNativeEventListener()).isSameAs(EMPTY_EVENT_LISTENER);
+    }
+
+    // NativeViewClickListener tests
+    @Test
+    public void NativeViewClickListener_onClick_shouldQueueClickTrackerAndUrlResolutionTasks() {
+        subject = mock(NativeResponse.class);
+        NativeResponse.NativeViewClickListener nativeViewClickListener = subject.new NativeViewClickListener();
+
+        View view = new View(context);
+        nativeViewClickListener.onClick(view);
+        verify(subject).handleClick(view);
+    }
+
+    @Ignore("pending")
+    @Test
+    public void loadExtrasImage_shouldAsyncLoadImages() {
+        // no easy way to test this since nothing can be mocked
+        // also not a critical test since it directly calls another service
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeUrlGeneratorTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeUrlGeneratorTest.java
index af63ddb3..7cd08ac5 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeUrlGeneratorTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeUrlGeneratorTest.java
@@ -1,373 +1,378 @@
-package com.mopub.nativeads;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.res.Resources;
-import android.graphics.Point;
-import android.location.Location;
-import android.location.LocationManager;
-import android.net.Uri;
-import android.os.Build;
-import android.telephony.TelephonyManager;
-import android.text.TextUtils;
-import android.util.DisplayMetrics;
-import android.view.Display;
-import android.view.WindowManager;
-
-import com.mopub.common.MoPub;
-import com.mopub.mobileads.test.support.MoPubShadowTelephonyManager;
-import com.mopub.common.test.support.SdkTestRunner;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.Robolectric;
-import org.robolectric.annotation.Config;
-import org.robolectric.shadows.ShadowLocationManager;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.EnumSet;
-import java.util.List;
-
-import static android.Manifest.permission.ACCESS_NETWORK_STATE;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.when;
-import static org.robolectric.Robolectric.application;
-import static org.robolectric.Robolectric.shadowOf;
-
-@RunWith(SdkTestRunner.class)
-@Config(shadows = {MoPubShadowTelephonyManager.class})
-public class NativeUrlGeneratorTest {
-    public static final String AD_UNIT_ID = "1234";
-    private static final int TEST_SCREEN_WIDTH = 999;
-    private static final int TEST_SCREEN_HEIGHT = 888;
-    private static final float TEST_DENSITY = 1.0f;
-    private Activity context;
-    private NativeUrlGenerator subject;
-    private MoPubShadowTelephonyManager shadowTelephonyManager;
-
-    @Before
-    public void setup() {
-        context = spy(Robolectric.buildActivity(Activity.class).create().get());
-        shadowOf(context).grantPermissions(ACCESS_NETWORK_STATE);
-        shadowTelephonyManager = (MoPubShadowTelephonyManager)
-                shadowOf((TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE));
-
-        // Set the expected screen dimensions to arbitrary numbers
-        final Resources spyResources = spy(context.getResources());
-        final DisplayMetrics mockDisplayMetrics = mock(DisplayMetrics.class);
-        mockDisplayMetrics.widthPixels = TEST_SCREEN_WIDTH;
-        mockDisplayMetrics.heightPixels = TEST_SCREEN_HEIGHT;
-        mockDisplayMetrics.density = TEST_DENSITY;
-        when(spyResources.getDisplayMetrics()).thenReturn(mockDisplayMetrics);
-        when(context.getResources()).thenReturn(spyResources);
-
-        // Only do this on Android 17+ because getRealSize doesn't exist before then.
-        // This is the default pathway.
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
-            final WindowManager mockWindowManager = mock(WindowManager.class);
-            final Display mockDisplay = mock(Display.class);
-            doAnswer(new Answer() {
-                @Override
-                public Object answer(final InvocationOnMock invocationOnMock) throws Throwable {
-                    final Point point = (Point) invocationOnMock.getArguments()[0];
-                    point.x = TEST_SCREEN_WIDTH;
-                    point.y = TEST_SCREEN_HEIGHT;
-                    return null;
-                }
-            }).when(mockDisplay).getRealSize(any(Point.class));
-            when(mockWindowManager.getDefaultDisplay()).thenReturn(mockDisplay);
-            final Context spyApplicationContext = spy(context.getApplicationContext());
-            when(spyApplicationContext.getSystemService(Context.WINDOW_SERVICE)).thenReturn(mockWindowManager);
-            when(context.getApplicationContext()).thenReturn(spyApplicationContext);
-        }
-    }
-
-    @Test
-    public void generateUrlString_shouldIncludeDesiredAssetIfSet() throws Exception {
-        EnumSet<RequestParameters.NativeAdAsset> assetsSet = EnumSet.of(RequestParameters.NativeAdAsset.TITLE);
-        RequestParameters requestParameters = new RequestParameters.Builder().desiredAssets(assetsSet).build();
-
-        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID).withRequest(requestParameters);
-
-        String requestString = generateMinimumUrlString();
-        List<String> desiredAssets = getDesiredAssetsListFromRequestUrlString(requestString);
-
-        assertThat(desiredAssets.size()).isEqualTo(1);
-        assertThat(desiredAssets).contains("title");
-    }
-
-    @Test
-    public void generateUrlString_shouldIncludeDesiredAssetsIfSet() throws Exception {
-        EnumSet<RequestParameters.NativeAdAsset> assetsSet = EnumSet.of(RequestParameters.NativeAdAsset.TITLE, RequestParameters.NativeAdAsset.TEXT, RequestParameters.NativeAdAsset.ICON_IMAGE);
-        RequestParameters requestParameters = new RequestParameters.Builder().desiredAssets(assetsSet).build();
-
-        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID).withRequest(requestParameters);
-
-        String requestString = generateMinimumUrlString();
-        List<String> desiredAssets = getDesiredAssetsListFromRequestUrlString(requestString);
-
-        assertThat(desiredAssets.size()).isEqualTo(3);
-        assertThat(desiredAssets).contains("title", "text", "iconimage");
-    }
-
-    @Test
-    public void generateUrlString_shouldNotIncludeDesiredAssetsIfNotSet() throws Exception {
-        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
-
-        String requestString = generateMinimumUrlString();
-        List<String> desiredAssets = getDesiredAssetsListFromRequestUrlString(requestString);
-
-        assertThat(desiredAssets.size()).isEqualTo(0);
-    }
-
-    @Test
-    public void generateUrlString_shouldNotIncludeDesiredAssetsIfNoAssetsAreSet() throws Exception {
-        EnumSet<RequestParameters.NativeAdAsset> assetsSet = EnumSet.noneOf(RequestParameters.NativeAdAsset.class);
-        RequestParameters requestParameters = new RequestParameters.Builder().desiredAssets(assetsSet).build();
-
-        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID).withRequest(requestParameters);
-
-        String requestString = generateMinimumUrlString();
-        List<String> desiredAssets = getDesiredAssetsListFromRequestUrlString(requestString);
-
-        assertThat(desiredAssets.size()).isEqualTo(0);
-    }
-
-    @Test
-    public void generateUrlString_needsButDoesNotHaveReadPhoneState_shouldNotContainOperatorName() {
-        shadowTelephonyManager.setNeedsReadPhoneState(true);
-        shadowTelephonyManager.setReadPhoneStatePermission(false);
-        shadowTelephonyManager.setNetworkOperatorName("TEST_CARRIER");
-
-        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
-        String requestString = generateMinimumUrlString();
-
-        assertThat(getNetworkOperatorNameFromRequestUrl(requestString)).isNullOrEmpty();
-    }
-
-    @Test
-    public void generateUrlString_needsAndHasReadPhoneState_shouldContainOperatorName() {
-        shadowTelephonyManager.setNeedsReadPhoneState(true);
-        shadowTelephonyManager.setReadPhoneStatePermission(true);
-        shadowTelephonyManager.setNetworkOperatorName("TEST_CARRIER");
-
-        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
-        String requestString = generateMinimumUrlString();
-
-        assertThat(getNetworkOperatorNameFromRequestUrl(requestString)).isEqualTo("TEST_CARRIER");
-    }
-
-    @Test
-    public void generateUrlString_doesNotNeedReadPhoneState_shouldContainOperatorName() {
-        shadowTelephonyManager.setNeedsReadPhoneState(false);
-        shadowTelephonyManager.setReadPhoneStatePermission(false);
-        shadowTelephonyManager.setNetworkOperatorName("TEST_CARRIER");
-
-        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
-        String requestString = generateMinimumUrlString();
-
-        assertThat(getNetworkOperatorNameFromRequestUrl(requestString)).isEqualTo("TEST_CARRIER");
-    }
-
-    @Test
-    public void generateUrlString_whenLocationServiceGpsProviderHasMostRecentLocation_shouldUseLocationServiceValue() {
-        Location locationFromDeveloper = new Location("");
-        locationFromDeveloper.setLatitude(42);
-        locationFromDeveloper.setLongitude(-42);
-        locationFromDeveloper.setAccuracy(3.5f);
-        locationFromDeveloper.setTime(1000);
-
-        // Mock out the LocationManager's last known location to be more recent than the
-        // developer-supplied location.
-        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
-                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
-        Location locationFromSdk = new Location("");
-        locationFromSdk.setLatitude(37);
-        locationFromSdk.setLongitude(-122);
-        locationFromSdk.setAccuracy(5.0f);
-        locationFromSdk.setTime(System.currentTimeMillis() - 555555);
-        shadowLocationManager.setLastKnownLocation(LocationManager.GPS_PROVIDER, locationFromSdk);
-
-        RequestParameters requestParameters = new RequestParameters.Builder()
-                .location(locationFromDeveloper)
-                .build();
-        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
-        String adUrl = subject.withRequest(requestParameters)
-                .generateUrlString("ads.mopub.com");
-        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isEqualTo("37.0,-122.0");
-        assertThat(getParameterFromRequestUrl(adUrl, "lla")).isEqualTo("5");
-        assertThat(getParameterFromRequestUrl(adUrl, "llsdk")).isEqualTo("1");
-        // Only test to the full second (as there may be small differences)
-        assertThat(getParameterFromRequestUrl(adUrl, "llf")).startsWith("555");
-        assertThat(getParameterFromRequestUrl(adUrl, "llf").length()).isEqualTo(6);
-    }
-
-    @Test
-    public void generateUrlString_whenDeveloperSuppliesMoreRecentLocationThanLocationService_shouldUseDeveloperSuppliedLocation() {
-        Location locationFromDeveloper = new Location("");
-        locationFromDeveloper.setLatitude(42);
-        locationFromDeveloper.setLongitude(-42);
-        locationFromDeveloper.setAccuracy(3.5f);
-        locationFromDeveloper.setTime(System.currentTimeMillis() - 777777);
-
-        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
-                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
-
-        // Mock out the LocationManager's last known location to be older than the
-        // developer-supplied location.
-        Location olderLocation = new Location("");
-        olderLocation.setLatitude(40);
-        olderLocation.setLongitude(-105);
-        olderLocation.setAccuracy(8.0f);
-        olderLocation.setTime(System.currentTimeMillis() - 888888);
-        shadowLocationManager.setLastKnownLocation(LocationManager.GPS_PROVIDER, olderLocation);
-
-        RequestParameters requestParameters = new RequestParameters.Builder()
-                .location(locationFromDeveloper)
-                .build();
-        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
-        String adUrl = subject.withRequest(requestParameters)
-                .generateUrlString("ads.mopub.com");
-        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isEqualTo("42.0,-42.0");
-        assertThat(getParameterFromRequestUrl(adUrl, "lla")).isEqualTo("3");
-        assertThat(getParameterFromRequestUrl(adUrl, "llsdk")).isEmpty();
-        // Only test to the full second (as there may be small differences)
-        assertThat(getParameterFromRequestUrl(adUrl, "llf")).startsWith("777");
-        assertThat(getParameterFromRequestUrl(adUrl, "llf").length()).isEqualTo(6);
-    }
-
-    @Test
-    public void generateUrlString_whenLocationServiceNetworkProviderHasMostRecentLocation_shouldUseLocationServiceValue() {
-        Location locationFromDeveloper = new Location("");
-        locationFromDeveloper.setLatitude(42);
-        locationFromDeveloper.setLongitude(-42);
-        locationFromDeveloper.setAccuracy(3.5f);
-        locationFromDeveloper.setTime(1000);
-
-        // Mock out the LocationManager's last known location to be more recent than the
-        // developer-supplied location.
-        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
-                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
-        Location locationFromSdk = new Location("");
-        locationFromSdk.setLatitude(38);
-        locationFromSdk.setLongitude(-123);
-        locationFromSdk.setAccuracy(5.0f);
-        locationFromSdk.setTime(System.currentTimeMillis() - 123456);
-        shadowLocationManager.setLastKnownLocation(LocationManager.NETWORK_PROVIDER,
-                locationFromSdk);
-
-        RequestParameters requestParameters = new RequestParameters.Builder()
-                .location(locationFromDeveloper)
-                .build();
-        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
-        String adUrl = subject.withRequest(requestParameters)
-                .generateUrlString("ads.mopub.com");
-        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isEqualTo("38.0,-123.0");
-        assertThat(getParameterFromRequestUrl(adUrl, "lla")).isEqualTo("5");
-        assertThat(getParameterFromRequestUrl(adUrl, "llsdk")).isEqualTo("1");
-        // Only test to the full second (as there may be small differences)
-        assertThat(getParameterFromRequestUrl(adUrl, "llf")).startsWith("123");
-        assertThat(getParameterFromRequestUrl(adUrl, "llf").length()).isEqualTo(6);
-    }
-
-    @Test
-    public void generateUrlString_withOnlyAdUnitSet_shouldReturnMinimumUrl() {
-        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
-        final String adUrl = generateMinimumUrlString();
-
-        assertThat(adUrl).isEqualTo(
-                "http://ads.mopub.com/m/ad?id=" +
-                        AD_UNIT_ID +
-                        "&nsv=3.6.1" +
-                        "&dn=unknown%2Cunknown%2Cunknown" +
-                        "&bundle=com.mopub.mobileads" +
-                        "&z=-0700" +
-                        "&o=u" +
-                        "&w=" +
-                        TEST_SCREEN_WIDTH +
-                        "&h=" +
-                        TEST_SCREEN_HEIGHT +
-                        "&sc_a=" +
-                        TEST_DENSITY +
-                        "&ct=3&av=1.0&udid=mp_tmpl_advertising_id&dnt=mp_tmpl_do_not_track");
-    }
-
-    @Test
-    public void enableLocation_shouldIncludeLocationInUrl() {
-        MoPub.setLocationAwareness(MoPub.LocationAwareness.NORMAL);
-        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
-
-        String requestString = generateMinimumUrlString();
-        assertThat(getParameterFromRequestUrl(requestString, "ll")).isNotNull();
-    }
-
-    @Test
-    public void disableLocation_shouldNotIncludeLocationInUrl() {
-        MoPub.setLocationAwareness(MoPub.LocationAwareness.DISABLED);
-        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
-
-        String requestString = generateMinimumUrlString();
-        assertThat(getParameterFromRequestUrl(requestString, "ll")).isNullOrEmpty();
-    }
-
-    @Test
-    public void disableLocationCollection_whenLocationServiceHasMostRecentLocation_shouldNotIncludeLocationInUrl() {
-        MoPub.setLocationAwareness(MoPub.LocationAwareness.DISABLED);
-        subject = new NativeUrlGenerator(context);
-
-        // Mock out the LocationManager's last known location.
-        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
-                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
-        Location locationFromSdk = new Location("");
-        locationFromSdk.setLatitude(37);
-        locationFromSdk.setLongitude(-122);
-        locationFromSdk.setAccuracy(5.0f);
-        locationFromSdk.setTime(2000);
-        shadowLocationManager.setLastKnownLocation(LocationManager.GPS_PROVIDER, locationFromSdk);
-
-        String requestString = generateMinimumUrlString();
-        assertThat(getParameterFromRequestUrl(requestString, "ll")).isNullOrEmpty();
-    }
-
-    private List<String> getDesiredAssetsListFromRequestUrlString(String requestString) {
-        Uri requestUri = Uri.parse(requestString);
-
-        String desiredAssetsString = requestUri.getQueryParameter("assets");
-        return (desiredAssetsString == null) ? new ArrayList<String>() : Arrays.asList(desiredAssetsString.split(","));
-    }
-
-    private String getNetworkOperatorNameFromRequestUrl(String requestString) {
-        Uri requestUri = Uri.parse(requestString);
-
-        String networkOperatorName = requestUri.getQueryParameter("cn");
-
-        if (TextUtils.isEmpty(networkOperatorName)) {
-            return "";
-        }
-
-        return networkOperatorName;
-    }
-
-    private String getParameterFromRequestUrl(String requestString, String key) {
-        Uri requestUri = Uri.parse(requestString);
-        String parameter = requestUri.getQueryParameter(key);
-
-        if (TextUtils.isEmpty(parameter)) {
-            return "";
-        }
-
-        return parameter;
-    }
-
-    private String generateMinimumUrlString() {
-        return subject.generateUrlString("ads.mopub.com");
-    }
-}
+package com.mopub.nativeads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Point;
+import android.location.Location;
+import android.location.LocationManager;
+import android.net.Uri;
+import android.os.Build;
+import android.telephony.TelephonyManager;
+import android.text.TextUtils;
+import android.util.DisplayMetrics;
+import android.view.Display;
+import android.view.WindowManager;
+
+import com.mopub.common.MoPub;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.test.support.MoPubShadowTelephonyManager;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLocationManager;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.EnumSet;
+import java.util.List;
+
+import static android.Manifest.permission.ACCESS_NETWORK_STATE;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
+import static org.robolectric.Robolectric.application;
+import static org.robolectric.Robolectric.shadowOf;
+
+@RunWith(SdkTestRunner.class)
+@Config(shadows = {MoPubShadowTelephonyManager.class})
+public class NativeUrlGeneratorTest {
+    public static final String AD_UNIT_ID = "1234";
+    private static final int TEST_SCREEN_WIDTH = 999;
+    private static final int TEST_SCREEN_HEIGHT = 888;
+    private static final float TEST_DENSITY = 1.0f;
+    private Activity context;
+    private NativeUrlGenerator subject;
+    private MoPubShadowTelephonyManager shadowTelephonyManager;
+
+    @Before
+    public void setup() {
+        context = spy(Robolectric.buildActivity(Activity.class).create().get());
+        shadowOf(context).grantPermissions(ACCESS_NETWORK_STATE);
+        when(context.getPackageName()).thenReturn("testBundle");
+        shadowTelephonyManager = (MoPubShadowTelephonyManager)
+                shadowOf((TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE));
+
+        // Set the expected screen dimensions to arbitrary numbers
+        final Resources spyResources = spy(context.getResources());
+        final DisplayMetrics mockDisplayMetrics = mock(DisplayMetrics.class);
+        mockDisplayMetrics.widthPixels = TEST_SCREEN_WIDTH;
+        mockDisplayMetrics.heightPixels = TEST_SCREEN_HEIGHT;
+        mockDisplayMetrics.density = TEST_DENSITY;
+        when(spyResources.getDisplayMetrics()).thenReturn(mockDisplayMetrics);
+        when(context.getResources()).thenReturn(spyResources);
+
+        // Only do this on Android 17+ because getRealSize doesn't exist before then.
+        // This is the default pathway.
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
+            final WindowManager mockWindowManager = mock(WindowManager.class);
+            final Display mockDisplay = mock(Display.class);
+            doAnswer(new Answer() {
+                @Override
+                public Object answer(final InvocationOnMock invocationOnMock) throws Throwable {
+                    final Point point = (Point) invocationOnMock.getArguments()[0];
+                    point.x = TEST_SCREEN_WIDTH;
+                    point.y = TEST_SCREEN_HEIGHT;
+                    return null;
+                }
+            }).when(mockDisplay).getRealSize(any(Point.class));
+            when(mockWindowManager.getDefaultDisplay()).thenReturn(mockDisplay);
+            final Context spyApplicationContext = spy(context.getApplicationContext());
+            when(spyApplicationContext.getSystemService(Context.WINDOW_SERVICE)).thenReturn(mockWindowManager);
+            when(context.getApplicationContext()).thenReturn(spyApplicationContext);
+        }
+    }
+
+    @Test
+    public void generateUrlString_shouldIncludeDesiredAssetIfSet() throws Exception {
+        EnumSet<RequestParameters.NativeAdAsset> assetsSet = EnumSet.of(RequestParameters.NativeAdAsset.TITLE);
+        RequestParameters requestParameters = new RequestParameters.Builder().desiredAssets(assetsSet).build();
+
+        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID).withRequest(requestParameters);
+
+        String requestString = generateMinimumUrlString();
+        List<String> desiredAssets = getDesiredAssetsListFromRequestUrlString(requestString);
+
+        assertThat(desiredAssets.size()).isEqualTo(1);
+        assertThat(desiredAssets).contains("title");
+    }
+
+    @Test
+    public void generateUrlString_shouldIncludeDesiredAssetsIfSet() throws Exception {
+        EnumSet<RequestParameters.NativeAdAsset> assetsSet = EnumSet.of(RequestParameters.NativeAdAsset.TITLE, RequestParameters.NativeAdAsset.TEXT, RequestParameters.NativeAdAsset.ICON_IMAGE);
+        RequestParameters requestParameters = new RequestParameters.Builder().desiredAssets(assetsSet).build();
+
+        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID).withRequest(requestParameters);
+
+        String requestString = generateMinimumUrlString();
+        List<String> desiredAssets = getDesiredAssetsListFromRequestUrlString(requestString);
+
+        assertThat(desiredAssets.size()).isEqualTo(3);
+        assertThat(desiredAssets).contains("title", "text", "iconimage");
+    }
+
+    @Test
+    public void generateUrlString_shouldNotIncludeDesiredAssetsIfNotSet() throws Exception {
+        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
+
+        String requestString = generateMinimumUrlString();
+        List<String> desiredAssets = getDesiredAssetsListFromRequestUrlString(requestString);
+
+        assertThat(desiredAssets.size()).isEqualTo(0);
+    }
+
+    @Test
+    public void generateUrlString_shouldNotIncludeDesiredAssetsIfNoAssetsAreSet() throws Exception {
+        EnumSet<RequestParameters.NativeAdAsset> assetsSet = EnumSet.noneOf(RequestParameters.NativeAdAsset.class);
+        RequestParameters requestParameters = new RequestParameters.Builder().desiredAssets(assetsSet).build();
+
+        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID).withRequest(requestParameters);
+
+        String requestString = generateMinimumUrlString();
+        List<String> desiredAssets = getDesiredAssetsListFromRequestUrlString(requestString);
+
+        assertThat(desiredAssets.size()).isEqualTo(0);
+    }
+
+    @Test
+    public void generateUrlString_needsButDoesNotHaveReadPhoneState_shouldNotContainOperatorName() {
+        shadowTelephonyManager.setNeedsReadPhoneState(true);
+        shadowTelephonyManager.setReadPhoneStatePermission(false);
+        shadowTelephonyManager.setNetworkOperatorName("TEST_CARRIER");
+
+        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
+        String requestString = generateMinimumUrlString();
+
+        assertThat(getNetworkOperatorNameFromRequestUrl(requestString)).isNullOrEmpty();
+    }
+
+    @Test
+    public void generateUrlString_needsAndHasReadPhoneState_shouldContainOperatorName() {
+        shadowTelephonyManager.setNeedsReadPhoneState(true);
+        shadowTelephonyManager.setReadPhoneStatePermission(true);
+        shadowTelephonyManager.setNetworkOperatorName("TEST_CARRIER");
+
+        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
+        String requestString = generateMinimumUrlString();
+
+        assertThat(getNetworkOperatorNameFromRequestUrl(requestString)).isEqualTo("TEST_CARRIER");
+    }
+
+    @Test
+    public void generateUrlString_doesNotNeedReadPhoneState_shouldContainOperatorName() {
+        shadowTelephonyManager.setNeedsReadPhoneState(false);
+        shadowTelephonyManager.setReadPhoneStatePermission(false);
+        shadowTelephonyManager.setNetworkOperatorName("TEST_CARRIER");
+
+        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
+        String requestString = generateMinimumUrlString();
+
+        assertThat(getNetworkOperatorNameFromRequestUrl(requestString)).isEqualTo("TEST_CARRIER");
+    }
+
+    @Test
+    public void generateUrlString_whenLocationServiceGpsProviderHasMostRecentLocation_shouldUseLocationServiceValue() {
+        Location locationFromDeveloper = new Location("");
+        locationFromDeveloper.setLatitude(42);
+        locationFromDeveloper.setLongitude(-42);
+        locationFromDeveloper.setAccuracy(3.5f);
+        locationFromDeveloper.setTime(1000);
+
+        // Mock out the LocationManager's last known location to be more recent than the
+        // developer-supplied location.
+        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
+                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
+        Location locationFromSdk = new Location("");
+        locationFromSdk.setLatitude(37);
+        locationFromSdk.setLongitude(-122);
+        locationFromSdk.setAccuracy(5.0f);
+        locationFromSdk.setTime(System.currentTimeMillis() - 555555);
+        shadowLocationManager.setLastKnownLocation(LocationManager.GPS_PROVIDER, locationFromSdk);
+
+        RequestParameters requestParameters = new RequestParameters.Builder()
+                .location(locationFromDeveloper)
+                .build();
+        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
+        String adUrl = subject.withRequest(requestParameters)
+                .generateUrlString("ads.mopub.com");
+        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isEqualTo("37.0,-122.0");
+        assertThat(getParameterFromRequestUrl(adUrl, "lla")).isEqualTo("5");
+        assertThat(getParameterFromRequestUrl(adUrl, "llsdk")).isEqualTo("1");
+        // Only test to the full second (as there may be small differences)
+        assertThat(getParameterFromRequestUrl(adUrl, "llf")).startsWith("555");
+        assertThat(getParameterFromRequestUrl(adUrl, "llf").length()).isEqualTo(6);
+    }
+
+    @Test
+    public void generateUrlString_whenDeveloperSuppliesMoreRecentLocationThanLocationService_shouldUseDeveloperSuppliedLocation() {
+        Location locationFromDeveloper = new Location("");
+        locationFromDeveloper.setLatitude(42);
+        locationFromDeveloper.setLongitude(-42);
+        locationFromDeveloper.setAccuracy(3.5f);
+        locationFromDeveloper.setTime(System.currentTimeMillis() - 777777);
+
+        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
+                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
+
+        // Mock out the LocationManager's last known location to be older than the
+        // developer-supplied location.
+        Location olderLocation = new Location("");
+        olderLocation.setLatitude(40);
+        olderLocation.setLongitude(-105);
+        olderLocation.setAccuracy(8.0f);
+        olderLocation.setTime(System.currentTimeMillis() - 888888);
+        shadowLocationManager.setLastKnownLocation(LocationManager.GPS_PROVIDER, olderLocation);
+
+        RequestParameters requestParameters = new RequestParameters.Builder()
+                .location(locationFromDeveloper)
+                .build();
+        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
+        String adUrl = subject.withRequest(requestParameters)
+                .generateUrlString("ads.mopub.com");
+        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isEqualTo("42.0,-42.0");
+        assertThat(getParameterFromRequestUrl(adUrl, "lla")).isEqualTo("3");
+        assertThat(getParameterFromRequestUrl(adUrl, "llsdk")).isEmpty();
+        // Only test to the full second (as there may be small differences)
+        assertThat(getParameterFromRequestUrl(adUrl, "llf")).startsWith("777");
+        assertThat(getParameterFromRequestUrl(adUrl, "llf").length()).isEqualTo(6);
+    }
+
+    @Test
+    public void generateUrlString_whenLocationServiceNetworkProviderHasMostRecentLocation_shouldUseLocationServiceValue() {
+        Location locationFromDeveloper = new Location("");
+        locationFromDeveloper.setLatitude(42);
+        locationFromDeveloper.setLongitude(-42);
+        locationFromDeveloper.setAccuracy(3.5f);
+        locationFromDeveloper.setTime(1000);
+
+        // Mock out the LocationManager's last known location to be more recent than the
+        // developer-supplied location.
+        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
+                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
+        Location locationFromSdk = new Location("");
+        locationFromSdk.setLatitude(38);
+        locationFromSdk.setLongitude(-123);
+        locationFromSdk.setAccuracy(5.0f);
+        locationFromSdk.setTime(System.currentTimeMillis() - 123456);
+        shadowLocationManager.setLastKnownLocation(LocationManager.NETWORK_PROVIDER,
+                locationFromSdk);
+
+        RequestParameters requestParameters = new RequestParameters.Builder()
+                .location(locationFromDeveloper)
+                .build();
+        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
+        String adUrl = subject.withRequest(requestParameters)
+                .generateUrlString("ads.mopub.com");
+        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isEqualTo("38.0,-123.0");
+        assertThat(getParameterFromRequestUrl(adUrl, "lla")).isEqualTo("5");
+        assertThat(getParameterFromRequestUrl(adUrl, "llsdk")).isEqualTo("1");
+        // Only test to the full second (as there may be small differences)
+        assertThat(getParameterFromRequestUrl(adUrl, "llf")).startsWith("123");
+        assertThat(getParameterFromRequestUrl(adUrl, "llf").length()).isEqualTo(6);
+    }
+
+    @Test
+    public void generateUrlString_withOnlyAdUnitSet_shouldReturnMinimumUrl() {
+        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
+        final String adUrl = generateMinimumUrlString();
+
+        assertThat(adUrl).isEqualTo(
+                "http://ads.mopub.com/m/ad?id=" +
+                        AD_UNIT_ID +
+                        "&nsv=" + MoPub.SDK_VERSION + 
+                        "&dn=unknown%2Cunknown%2Cunknown" +
+                        "&bundle=testBundle" +
+                        "&z=-0700" +
+                        "&o=u" +
+                        "&w=" +
+                        TEST_SCREEN_WIDTH +
+                        "&h=" +
+                        TEST_SCREEN_HEIGHT +
+                        "&sc_a=" +
+                        TEST_DENSITY +
+                        // maven version
+                        "&ct=3&av=1.0" +
+                        // Gradle version
+                        //"&ct=3&av=" + BuildConfig.VERSION_NAME +
+                        "&udid=mp_tmpl_advertising_id&dnt=mp_tmpl_do_not_track");
+    }
+
+    @Test
+    public void enableLocation_shouldIncludeLocationInUrl() {
+        MoPub.setLocationAwareness(MoPub.LocationAwareness.NORMAL);
+        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
+
+        String requestString = generateMinimumUrlString();
+        assertThat(getParameterFromRequestUrl(requestString, "ll")).isNotNull();
+    }
+
+    @Test
+    public void disableLocation_shouldNotIncludeLocationInUrl() {
+        MoPub.setLocationAwareness(MoPub.LocationAwareness.DISABLED);
+        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
+
+        String requestString = generateMinimumUrlString();
+        assertThat(getParameterFromRequestUrl(requestString, "ll")).isNullOrEmpty();
+    }
+
+    @Test
+    public void disableLocationCollection_whenLocationServiceHasMostRecentLocation_shouldNotIncludeLocationInUrl() {
+        MoPub.setLocationAwareness(MoPub.LocationAwareness.DISABLED);
+        subject = new NativeUrlGenerator(context);
+
+        // Mock out the LocationManager's last known location.
+        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
+                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
+        Location locationFromSdk = new Location("");
+        locationFromSdk.setLatitude(37);
+        locationFromSdk.setLongitude(-122);
+        locationFromSdk.setAccuracy(5.0f);
+        locationFromSdk.setTime(2000);
+        shadowLocationManager.setLastKnownLocation(LocationManager.GPS_PROVIDER, locationFromSdk);
+
+        String requestString = generateMinimumUrlString();
+        assertThat(getParameterFromRequestUrl(requestString, "ll")).isNullOrEmpty();
+    }
+
+    private List<String> getDesiredAssetsListFromRequestUrlString(String requestString) {
+        Uri requestUri = Uri.parse(requestString);
+
+        String desiredAssetsString = requestUri.getQueryParameter("assets");
+        return (desiredAssetsString == null) ? new ArrayList<String>() : Arrays.asList(desiredAssetsString.split(","));
+    }
+
+    private String getNetworkOperatorNameFromRequestUrl(String requestString) {
+        Uri requestUri = Uri.parse(requestString);
+
+        String networkOperatorName = requestUri.getQueryParameter("cn");
+
+        if (TextUtils.isEmpty(networkOperatorName)) {
+            return "";
+        }
+
+        return networkOperatorName;
+    }
+
+    private String getParameterFromRequestUrl(String requestString, String key) {
+        Uri requestUri = Uri.parse(requestString);
+        String parameter = requestUri.getQueryParameter(key);
+
+        if (TextUtils.isEmpty(parameter)) {
+            return "";
+        }
+
+        return parameter;
+    }
+
+    private String generateMinimumUrlString() {
+        return subject.generateUrlString("ads.mopub.com");
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeViewHolderTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeViewHolderTest.java
index b5b218d2..fdeb2107 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeViewHolderTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeViewHolderTest.java
@@ -1,390 +1,390 @@
-package com.mopub.nativeads;
-
-import android.app.Activity;
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.graphics.drawable.BitmapDrawable;
-import android.view.ViewGroup;
-import android.widget.Button;
-import android.widget.ImageView;
-import android.widget.LinearLayout;
-import android.widget.RelativeLayout;
-import android.widget.TextView;
-
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.Utils;
-import com.mopub.network.MaxWidthImageLoader;
-import com.mopub.network.MoPubRequestQueue;
-import com.mopub.network.Networking;
-import com.mopub.volley.RequestQueue;
-import com.mopub.volley.toolbox.ImageLoader;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Captor;
-import org.mockito.Mock;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.stub;
-import static org.mockito.Mockito.verify;
-
-@RunWith(SdkTestRunner.class)
-public class NativeViewHolderTest {
-    private Context context;
-    private RelativeLayout relativeLayout;
-    private ViewGroup viewGroup;
-    private NativeResponse nativeResponse;
-    private ViewBinder viewBinder;
-    private MoPubNative.MoPubNativeListener mopubNativeListener;
-    private TextView titleView;
-    private TextView textView;
-    private TextView callToActionView;
-    private ImageView mainImageView;
-    private ImageView iconImageView;
-    private TextView extrasTextView;
-    private ImageView extrasImageView;
-    private ImageView extrasImageView2;
-    private String mainImageUrl;
-    private String iconImageUrl;
-    private String mainImageData;
-    private String iconImageData;
-    private Bitmap iconImage;
-    private Bitmap mainImage;
-    private String extrasImageData;
-    private String extrasImageData2;
-    private Bitmap extrasImage2;
-    private Bitmap extrasImage;
-
-    private static final String IMPRESSION_URL = "http://example.com";
-    private static final String CLICK_URL = "http://test.com";
-    private static final String AD_UNIT_ID = "http://blah.org";
-
-    @Mock
-    private MoPubRequestQueue mockRequestQueue;
-    @Mock
-    private MaxWidthImageLoader mockImageLoader;
-    @Mock
-    private ImageLoader.ImageContainer mockImageContainer;
-    @Mock
-    private Bitmap mockBitmap;
-
-    @Captor
-    private ArgumentCaptor<ImageLoader.ImageListener> mainImageCaptor;
-    @Captor
-    private ArgumentCaptor<ImageLoader.ImageListener> iconImageCaptor;
-
-
-    @Before
-    public void setUp() throws Exception {
-
-        Networking.setRequestQueueForTesting(mockRequestQueue);
-        Networking.setImageLoaderForTesting(mockImageLoader);
-        context = new Activity();
-        relativeLayout = new RelativeLayout(context);
-        relativeLayout.setId((int) Utils.generateUniqueId());
-        viewGroup = new LinearLayout(context);
-
-        // Fields in the web ui
-        titleView = new TextView(context);
-        titleView.setId((int) Utils.generateUniqueId());
-        textView = new TextView(context);
-        textView.setId((int) Utils.generateUniqueId());
-        callToActionView = new Button(context);
-        callToActionView.setId((int) Utils.generateUniqueId());
-        mainImageView = new ImageView(context);
-        mainImageView.setId((int) Utils.generateUniqueId());
-        iconImageView = new ImageView(context);
-        iconImageView.setId((int) Utils.generateUniqueId());
-
-        // Extras
-        extrasTextView = new TextView(context);
-        extrasTextView.setId((int) Utils.generateUniqueId());
-        extrasImageView = new ImageView(context);
-        extrasImageView.setId((int) Utils.generateUniqueId());
-        extrasImageView2 = new ImageView(context);
-        extrasImageView2.setId((int) Utils.generateUniqueId());
-
-        relativeLayout.addView(titleView);
-        relativeLayout.addView(textView);
-        relativeLayout.addView(callToActionView);
-        relativeLayout.addView(mainImageView);
-        relativeLayout.addView(iconImageView);
-        relativeLayout.addView(extrasTextView);
-        relativeLayout.addView(extrasImageView);
-        relativeLayout.addView(extrasImageView2);
-
-        mainImageUrl = "mainimageurl";
-        iconImageUrl = "iconimageurl";
-        mainImageData = "mainimagedata";
-        iconImageData = "iconimagedata";
-        extrasImageData = "extrasimagedata";
-        extrasImageData2 = "extrasimagedata2";
-        iconImage = BitmapFactory.decodeByteArray(iconImageData.getBytes(), 0, iconImageData.getBytes().length);
-        mainImage = BitmapFactory.decodeByteArray(mainImageData.getBytes(), 0, mainImageData.getBytes().length);
-        extrasImage = BitmapFactory.decodeByteArray(extrasImageData.getBytes(), 0, extrasImageData.getBytes().length);
-        extrasImage2 = BitmapFactory.decodeByteArray(extrasImageData2.getBytes(), 0, extrasImageData2.getBytes().length);
-    }
-
-    @Test
-    public void fromViewBinder_shouldPopulateClassFields() throws Exception {
-        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
-                .titleId(titleView.getId())
-                .textId(textView.getId())
-                .callToActionId(callToActionView.getId())
-                .mainImageId(mainImageView.getId())
-                .iconImageId(iconImageView.getId())
-                .build();
-
-        NativeViewHolder nativeViewHolder =
-                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
-
-        assertThat(nativeViewHolder.titleView).isEqualTo(titleView);
-        assertThat(nativeViewHolder.textView).isEqualTo(textView);
-        assertThat(nativeViewHolder.callToActionView).isEqualTo(callToActionView);
-        assertThat(nativeViewHolder.mainImageView).isEqualTo(mainImageView);
-        assertThat(nativeViewHolder.iconImageView).isEqualTo(iconImageView);
-    }
-
-    @Test
-    public void fromViewBinder_withSubsetOfFields_shouldLeaveOtherFieldsNull() throws Exception {
-        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
-                .titleId(titleView.getId())
-                .iconImageId(iconImageView.getId())
-                .build();
-
-        NativeViewHolder nativeViewHolder =
-                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
-
-        assertThat(nativeViewHolder.titleView).isEqualTo(titleView);
-        assertThat(nativeViewHolder.textView).isNull();
-        assertThat(nativeViewHolder.callToActionView).isNull();
-        assertThat(nativeViewHolder.mainImageView).isNull();
-        assertThat(nativeViewHolder.iconImageView).isEqualTo(iconImageView);
-    }
-
-    @Test
-    public void fromViewBinder_withNonExistantIds_shouldLeaveFieldsNull() throws Exception {
-        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
-                .titleId((int) Utils.generateUniqueId())
-                .textId((int) Utils.generateUniqueId())
-                .callToActionId((int) Utils.generateUniqueId())
-                .mainImageId((int) Utils.generateUniqueId())
-                .iconImageId((int) Utils.generateUniqueId())
-                .build();
-
-        NativeViewHolder nativeViewHolder =
-                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
-
-        assertThat(nativeViewHolder.titleView).isNull();
-        assertThat(nativeViewHolder.textView).isNull();
-        assertThat(nativeViewHolder.callToActionView).isNull();
-        assertThat(nativeViewHolder.mainImageView).isNull();
-        assertThat(nativeViewHolder.iconImageView).isNull();
-    }
-
-    @Test
-    public void update_shouldAddValuesToViews() throws Exception {
-        // Setup for cache state for image gets
-
-        BaseForwardingNativeAd nativeAd = new BaseForwardingNativeAd() {};
-        nativeAd.setTitle("titletext");
-        nativeAd.setText("texttext");
-        nativeAd.setMainImageUrl("mainimageurl");
-        nativeAd.setIconImageUrl("iconimageurl");
-        nativeAd.setCallToAction("cta");
-
-        nativeResponse = new NativeResponse(context,
-                IMPRESSION_URL, CLICK_URL, AD_UNIT_ID, nativeAd, null);
-
-        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
-                .titleId(titleView.getId())
-                .textId(textView.getId())
-                .callToActionId(callToActionView.getId())
-                .mainImageId(mainImageView.getId())
-                .iconImageId(iconImageView.getId())
-                .build();
-
-        NativeViewHolder nativeViewHolder =
-                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
-
-        nativeViewHolder.update(nativeResponse);
-
-        assertThat(titleView.getText()).isEqualTo("titletext");
-        assertThat(textView.getText()).isEqualTo("texttext");
-        assertThat(callToActionView.getText()).isEqualTo("cta");
-        verify(mockImageLoader).get(eq("mainimageurl"), mainImageCaptor.capture());
-        verify(mockImageLoader).get(eq("iconimageurl"), iconImageCaptor.capture());
-
-        stub(mockImageContainer.getBitmap()).toReturn(mockBitmap);
-        mainImageCaptor.getValue().onResponse(mockImageContainer, true);
-        iconImageCaptor.getValue().onResponse(mockImageContainer, true);
-
-        assertThat(((BitmapDrawable) mainImageView.getDrawable()).getBitmap()).isEqualTo(mockBitmap);
-        assertThat(((BitmapDrawable) iconImageView.getDrawable()).getBitmap()).isEqualTo(mockBitmap);
-    }
-
-    @Test
-    public void update_withMissingNativeResponseFields_shouldClearPreviousValues() throws Exception {
-        // Set previous values that should be cleared
-        titleView.setText("previoustitletext");
-        textView.setText("previoustexttext");
-        callToActionView.setText("previousctatext");
-        mainImageView.setImageBitmap(BitmapFactory.decodeByteArray("previousmainimagedata".getBytes(), 0, "previousmainimagedata".getBytes().length));
-        iconImageView.setImageBitmap(BitmapFactory.decodeByteArray("previousiconimagedata".getBytes(), 0, "previousiconimagedata".getBytes().length));
-
-        // Only required fields in native response
-        nativeResponse = new NativeResponse(context,
-                IMPRESSION_URL, CLICK_URL, AD_UNIT_ID, mock(BaseForwardingNativeAd.class), null);
-
-        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
-                .titleId(titleView.getId())
-                .textId(textView.getId())
-                .callToActionId(callToActionView.getId())
-                .mainImageId(mainImageView.getId())
-                .iconImageId(iconImageView.getId())
-                .build();
-
-        NativeViewHolder nativeViewHolder =
-                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
-
-        nativeViewHolder.update(nativeResponse);
-
-        assertThat(titleView.getText()).isEqualTo("");
-        assertThat(textView.getText()).isEqualTo("");
-        assertThat(callToActionView.getText()).isEqualTo("");
-        assertThat(mainImageView.getDrawable()).isNull();
-        assertThat(iconImageView.getDrawable()).isNull();
-    }
-
-    @Test
-    public void update_withDifferentViewBinder_shouldNotClearPreviousValues() throws Exception {
-        // Set previous values that should be cleared
-        titleView.setText("previoustitletext");
-        textView.setText("previoustexttext");
-
-        BaseForwardingNativeAd nativeAd = new BaseForwardingNativeAd() {};
-        nativeAd.setCallToAction("cta");
-
-        nativeResponse = new NativeResponse(context,
-                IMPRESSION_URL, CLICK_URL, AD_UNIT_ID, nativeAd, null);
-
-        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
-                .callToActionId(callToActionView.getId())
-                .build();
-
-        NativeViewHolder nativeViewHolder =
-                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
-
-        nativeViewHolder.update(nativeResponse);
-
-        assertThat(titleView.getText()).isEqualTo("previoustitletext");
-        assertThat(textView.getText()).isEqualTo("previoustexttext");
-        assertThat(callToActionView.getText()).isEqualTo("cta");
-    }
-
-    @Test
-    public void updateExtras_shouldAddValuesToViews() throws Exception {
-        // Setup for cache state for image gets
-
-        BaseForwardingNativeAd nativeAd = new BaseForwardingNativeAd() {};
-        nativeAd.addExtra("extrastext", "extrastexttext");
-        nativeAd.addExtra("extrasimage", "extrasimageurl");
-        nativeAd.addExtra("extrasimage2", "extrasimageurl2");
-
-        nativeResponse = new NativeResponse(context,
-                IMPRESSION_URL, CLICK_URL, AD_UNIT_ID, nativeAd, null);
-
-        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
-                .addExtra("extrastext", extrasTextView.getId())
-                .addExtra("extrasimage", extrasImageView.getId())
-                .addExtra("extrasimage2", extrasImageView2.getId())
-                .build();
-
-        NativeViewHolder nativeViewHolder =
-                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
-
-        nativeViewHolder.updateExtras(relativeLayout, nativeResponse, viewBinder);
-
-        assertThat(extrasTextView.getText()).isEqualTo("extrastexttext");
-
-        verify(mockImageLoader).get(eq("extrasimageurl"), mainImageCaptor.capture());
-        verify(mockImageLoader).get(eq("extrasimageurl2"), iconImageCaptor.capture());
-
-        stub(mockImageContainer.getBitmap()).toReturn(mockBitmap);
-        mainImageCaptor.getValue().onResponse(mockImageContainer, true);
-        iconImageCaptor.getValue().onResponse(mockImageContainer, true);
-
-        assertThat(((BitmapDrawable) extrasImageView.getDrawable()).getBitmap()).isEqualTo(mockBitmap);
-        assertThat(((BitmapDrawable) extrasImageView2.getDrawable()).getBitmap()).isEqualTo(mockBitmap);
-    }
-
-    @Test
-    public void updateExtras_withMissingExtrasValues_shouldClearPreviousValues() throws Exception {
-        extrasTextView.setText("previousextrastext");
-        extrasImageView.setImageBitmap(BitmapFactory.decodeByteArray("previousextrasimagedata".getBytes(), 0, "previousextrasimagedata".getBytes().length));
-        extrasImageView2.setImageBitmap(BitmapFactory.decodeByteArray("previousextrasimagedata2".getBytes(), 0, "previousextrasimagedata2".getBytes().length));
-
-        nativeResponse = new NativeResponse(context,
-                IMPRESSION_URL, CLICK_URL, AD_UNIT_ID, new BaseForwardingNativeAd(){}, null);
-
-        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
-                .addExtra("extrastext", extrasTextView.getId())
-                .addExtra("extrasimage", extrasImageView.getId())
-                .addExtra("extrasimage2", extrasImageView2.getId())
-                .build();
-
-        NativeViewHolder nativeViewHolder =
-                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
-
-        assertThat(extrasTextView.getText()).isEqualTo("previousextrastext");
-
-        nativeViewHolder.updateExtras(relativeLayout, nativeResponse, viewBinder);
-
-        assertThat(extrasTextView.getText()).isEqualTo("");
-        assertThat(extrasImageView.getDrawable()).isNull();
-        assertThat(extrasImageView2.getDrawable()).isNull();
-    }
-
-    @Test
-    public void updateExtras_withMismatchingViewTypes_shouldSetTextViewToImageUrlAndSetExtrasImageViewToNull() throws Exception {
-        BaseForwardingNativeAd nativeAd = new BaseForwardingNativeAd() {};
-        nativeAd.addExtra("extrastext", "extrastexttext");
-        nativeAd.addExtra("extrasimage", "extrasimageurl");
-
-        nativeResponse = new NativeResponse(context,
-                IMPRESSION_URL, CLICK_URL, AD_UNIT_ID, nativeAd, null);
-
-        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
-                .addExtra("extrastext", extrasImageView.getId())
-                .addExtra("extrasimage", extrasTextView.getId())
-                .build();
-
-        NativeViewHolder nativeViewHolder =
-                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
-
-        assertThat(extrasTextView.getText()).isEqualTo("");
-        assertThat(extrasImageView.getDrawable()).isNull();
-
-        nativeViewHolder.updateExtras(relativeLayout, nativeResponse, viewBinder);
-
-        // Volley's imageloader will set this to a bitmapdrawable with no bitmap
-        assertThat(extrasTextView.getText()).isEqualTo("extrasimageurl");
-        assertThat(extrasImageView.getDrawable()).isNull();
-    }
-
-    public void fromViewBinder_withMixedViewTypes_shouldReturnEmptyViewHolder() throws Exception {
-        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
-                .titleId(mainImageView.getId())
-                .textId(textView.getId())
-                .build();
-
-        NativeViewHolder nativeViewHolder =
-                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
-        assertThat(nativeViewHolder).isEqualTo(NativeViewHolder.EMPTY_VIEW_HOLDER);
-    }
-}
+package com.mopub.nativeads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.drawable.BitmapDrawable;
+import android.view.ViewGroup;
+import android.widget.Button;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.RelativeLayout;
+import android.widget.TextView;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.Utils;
+import com.mopub.network.MaxWidthImageLoader;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.volley.toolbox.ImageLoader;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Captor;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.stub;
+import static org.mockito.Mockito.verify;
+
+@RunWith(SdkTestRunner.class)
+public class NativeViewHolderTest {
+    private Context context;
+    private RelativeLayout relativeLayout;
+    private ViewGroup viewGroup;
+    private NativeResponse nativeResponse;
+    private ViewBinder viewBinder;
+    private MoPubNative.MoPubNativeListener mopubNativeListener;
+    private TextView titleView;
+    private TextView textView;
+    private TextView callToActionView;
+    private ImageView mainImageView;
+    private ImageView iconImageView;
+    private TextView extrasTextView;
+    private ImageView extrasImageView;
+    private ImageView extrasImageView2;
+    private String mainImageUrl;
+    private String iconImageUrl;
+    private String mainImageData;
+    private String iconImageData;
+    private Bitmap iconImage;
+    private Bitmap mainImage;
+    private String extrasImageData;
+    private String extrasImageData2;
+    private Bitmap extrasImage2;
+    private Bitmap extrasImage;
+
+    private static final String IMPRESSION_URL = "http://example.com";
+    private static final String CLICK_URL = "http://test.com";
+    private static final String AD_UNIT_ID = "http://blah.org";
+
+    @Mock
+    private MoPubRequestQueue mockRequestQueue;
+    @Mock
+    private MaxWidthImageLoader mockImageLoader;
+    @Mock
+    private ImageLoader.ImageContainer mockImageContainer;
+    @Mock
+    private Bitmap mockBitmap;
+
+    @Captor
+    private ArgumentCaptor<ImageLoader.ImageListener> mainImageCaptor;
+    @Captor
+    private ArgumentCaptor<ImageLoader.ImageListener> iconImageCaptor;
+
+
+    @Before
+    public void setUp() throws Exception {
+
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+        Networking.setImageLoaderForTesting(mockImageLoader);
+        context = Robolectric.buildActivity(Activity.class).create().get();
+        relativeLayout = new RelativeLayout(context);
+        relativeLayout.setId((int) Utils.generateUniqueId());
+        viewGroup = new LinearLayout(context);
+
+        // Fields in the web ui
+        titleView = new TextView(context);
+        titleView.setId((int) Utils.generateUniqueId());
+        textView = new TextView(context);
+        textView.setId((int) Utils.generateUniqueId());
+        callToActionView = new Button(context);
+        callToActionView.setId((int) Utils.generateUniqueId());
+        mainImageView = new ImageView(context);
+        mainImageView.setId((int) Utils.generateUniqueId());
+        iconImageView = new ImageView(context);
+        iconImageView.setId((int) Utils.generateUniqueId());
+
+        // Extras
+        extrasTextView = new TextView(context);
+        extrasTextView.setId((int) Utils.generateUniqueId());
+        extrasImageView = new ImageView(context);
+        extrasImageView.setId((int) Utils.generateUniqueId());
+        extrasImageView2 = new ImageView(context);
+        extrasImageView2.setId((int) Utils.generateUniqueId());
+
+        relativeLayout.addView(titleView);
+        relativeLayout.addView(textView);
+        relativeLayout.addView(callToActionView);
+        relativeLayout.addView(mainImageView);
+        relativeLayout.addView(iconImageView);
+        relativeLayout.addView(extrasTextView);
+        relativeLayout.addView(extrasImageView);
+        relativeLayout.addView(extrasImageView2);
+
+        mainImageUrl = "mainimageurl";
+        iconImageUrl = "iconimageurl";
+        mainImageData = "mainimagedata";
+        iconImageData = "iconimagedata";
+        extrasImageData = "extrasimagedata";
+        extrasImageData2 = "extrasimagedata2";
+        iconImage = BitmapFactory.decodeByteArray(iconImageData.getBytes(), 0, iconImageData.getBytes().length);
+        mainImage = BitmapFactory.decodeByteArray(mainImageData.getBytes(), 0, mainImageData.getBytes().length);
+        extrasImage = BitmapFactory.decodeByteArray(extrasImageData.getBytes(), 0, extrasImageData.getBytes().length);
+        extrasImage2 = BitmapFactory.decodeByteArray(extrasImageData2.getBytes(), 0, extrasImageData2.getBytes().length);
+    }
+
+    @Test
+    public void fromViewBinder_shouldPopulateClassFields() throws Exception {
+        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
+                .titleId(titleView.getId())
+                .textId(textView.getId())
+                .callToActionId(callToActionView.getId())
+                .mainImageId(mainImageView.getId())
+                .iconImageId(iconImageView.getId())
+                .build();
+
+        NativeViewHolder nativeViewHolder =
+                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
+
+        assertThat(nativeViewHolder.titleView).isEqualTo(titleView);
+        assertThat(nativeViewHolder.textView).isEqualTo(textView);
+        assertThat(nativeViewHolder.callToActionView).isEqualTo(callToActionView);
+        assertThat(nativeViewHolder.mainImageView).isEqualTo(mainImageView);
+        assertThat(nativeViewHolder.iconImageView).isEqualTo(iconImageView);
+    }
+
+    @Test
+    public void fromViewBinder_withSubsetOfFields_shouldLeaveOtherFieldsNull() throws Exception {
+        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
+                .titleId(titleView.getId())
+                .iconImageId(iconImageView.getId())
+                .build();
+
+        NativeViewHolder nativeViewHolder =
+                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
+
+        assertThat(nativeViewHolder.titleView).isEqualTo(titleView);
+        assertThat(nativeViewHolder.textView).isNull();
+        assertThat(nativeViewHolder.callToActionView).isNull();
+        assertThat(nativeViewHolder.mainImageView).isNull();
+        assertThat(nativeViewHolder.iconImageView).isEqualTo(iconImageView);
+    }
+
+    @Test
+    public void fromViewBinder_withNonExistantIds_shouldLeaveFieldsNull() throws Exception {
+        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
+                .titleId((int) Utils.generateUniqueId())
+                .textId((int) Utils.generateUniqueId())
+                .callToActionId((int) Utils.generateUniqueId())
+                .mainImageId((int) Utils.generateUniqueId())
+                .iconImageId((int) Utils.generateUniqueId())
+                .build();
+
+        NativeViewHolder nativeViewHolder =
+                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
+
+        assertThat(nativeViewHolder.titleView).isNull();
+        assertThat(nativeViewHolder.textView).isNull();
+        assertThat(nativeViewHolder.callToActionView).isNull();
+        assertThat(nativeViewHolder.mainImageView).isNull();
+        assertThat(nativeViewHolder.iconImageView).isNull();
+    }
+
+    @Test
+    public void update_shouldAddValuesToViews() throws Exception {
+        // Setup for cache state for image gets
+
+        BaseForwardingNativeAd nativeAd = new BaseForwardingNativeAd() {};
+        nativeAd.setTitle("titletext");
+        nativeAd.setText("texttext");
+        nativeAd.setMainImageUrl("mainimageurl");
+        nativeAd.setIconImageUrl("iconimageurl");
+        nativeAd.setCallToAction("cta");
+
+        nativeResponse = new NativeResponse(context,
+                IMPRESSION_URL, CLICK_URL, AD_UNIT_ID, nativeAd, null);
+
+        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
+                .titleId(titleView.getId())
+                .textId(textView.getId())
+                .callToActionId(callToActionView.getId())
+                .mainImageId(mainImageView.getId())
+                .iconImageId(iconImageView.getId())
+                .build();
+
+        NativeViewHolder nativeViewHolder =
+                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
+
+        nativeViewHolder.update(nativeResponse);
+
+        assertThat(titleView.getText()).isEqualTo("titletext");
+        assertThat(textView.getText()).isEqualTo("texttext");
+        assertThat(callToActionView.getText()).isEqualTo("cta");
+        verify(mockImageLoader).get(eq("mainimageurl"), mainImageCaptor.capture());
+        verify(mockImageLoader).get(eq("iconimageurl"), iconImageCaptor.capture());
+
+        stub(mockImageContainer.getBitmap()).toReturn(mockBitmap);
+        mainImageCaptor.getValue().onResponse(mockImageContainer, true);
+        iconImageCaptor.getValue().onResponse(mockImageContainer, true);
+
+        assertThat(((BitmapDrawable) mainImageView.getDrawable()).getBitmap()).isEqualTo(mockBitmap);
+        assertThat(((BitmapDrawable) iconImageView.getDrawable()).getBitmap()).isEqualTo(mockBitmap);
+    }
+
+    @Test
+    public void update_withMissingNativeResponseFields_shouldClearPreviousValues() throws Exception {
+        // Set previous values that should be cleared
+        titleView.setText("previoustitletext");
+        textView.setText("previoustexttext");
+        callToActionView.setText("previousctatext");
+        mainImageView.setImageBitmap(BitmapFactory.decodeByteArray("previousmainimagedata".getBytes(), 0, "previousmainimagedata".getBytes().length));
+        iconImageView.setImageBitmap(BitmapFactory.decodeByteArray("previousiconimagedata".getBytes(), 0, "previousiconimagedata".getBytes().length));
+
+        // Only required fields in native response
+        nativeResponse = new NativeResponse(context,
+                IMPRESSION_URL, CLICK_URL, AD_UNIT_ID, mock(BaseForwardingNativeAd.class), null);
+
+        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
+                .titleId(titleView.getId())
+                .textId(textView.getId())
+                .callToActionId(callToActionView.getId())
+                .mainImageId(mainImageView.getId())
+                .iconImageId(iconImageView.getId())
+                .build();
+
+        NativeViewHolder nativeViewHolder =
+                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
+
+        nativeViewHolder.update(nativeResponse);
+
+        assertThat(titleView.getText()).isEqualTo("");
+        assertThat(textView.getText()).isEqualTo("");
+        assertThat(callToActionView.getText()).isEqualTo("");
+        assertThat(mainImageView.getDrawable()).isNull();
+        assertThat(iconImageView.getDrawable()).isNull();
+    }
+
+    @Test
+    public void update_withDifferentViewBinder_shouldNotClearPreviousValues() throws Exception {
+        // Set previous values that should be cleared
+        titleView.setText("previoustitletext");
+        textView.setText("previoustexttext");
+
+        BaseForwardingNativeAd nativeAd = new BaseForwardingNativeAd() {};
+        nativeAd.setCallToAction("cta");
+
+        nativeResponse = new NativeResponse(context,
+                IMPRESSION_URL, CLICK_URL, AD_UNIT_ID, nativeAd, null);
+
+        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
+                .callToActionId(callToActionView.getId())
+                .build();
+
+        NativeViewHolder nativeViewHolder =
+                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
+
+        nativeViewHolder.update(nativeResponse);
+
+        assertThat(titleView.getText()).isEqualTo("previoustitletext");
+        assertThat(textView.getText()).isEqualTo("previoustexttext");
+        assertThat(callToActionView.getText()).isEqualTo("cta");
+    }
+
+    @Test
+    public void updateExtras_shouldAddValuesToViews() throws Exception {
+        // Setup for cache state for image gets
+
+        BaseForwardingNativeAd nativeAd = new BaseForwardingNativeAd() {};
+        nativeAd.addExtra("extrastext", "extrastexttext");
+        nativeAd.addExtra("extrasimage", "extrasimageurl");
+        nativeAd.addExtra("extrasimage2", "extrasimageurl2");
+
+        nativeResponse = new NativeResponse(context,
+                IMPRESSION_URL, CLICK_URL, AD_UNIT_ID, nativeAd, null);
+
+        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
+                .addExtra("extrastext", extrasTextView.getId())
+                .addExtra("extrasimage", extrasImageView.getId())
+                .addExtra("extrasimage2", extrasImageView2.getId())
+                .build();
+
+        NativeViewHolder nativeViewHolder =
+                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
+
+        nativeViewHolder.updateExtras(relativeLayout, nativeResponse, viewBinder);
+
+        assertThat(extrasTextView.getText()).isEqualTo("extrastexttext");
+
+        verify(mockImageLoader).get(eq("extrasimageurl"), mainImageCaptor.capture());
+        verify(mockImageLoader).get(eq("extrasimageurl2"), iconImageCaptor.capture());
+
+        stub(mockImageContainer.getBitmap()).toReturn(mockBitmap);
+        mainImageCaptor.getValue().onResponse(mockImageContainer, true);
+        iconImageCaptor.getValue().onResponse(mockImageContainer, true);
+
+        assertThat(((BitmapDrawable) extrasImageView.getDrawable()).getBitmap()).isEqualTo(mockBitmap);
+        assertThat(((BitmapDrawable) extrasImageView2.getDrawable()).getBitmap()).isEqualTo(mockBitmap);
+    }
+
+    @Test
+    public void updateExtras_withMissingExtrasValues_shouldClearPreviousValues() throws Exception {
+        extrasTextView.setText("previousextrastext");
+        extrasImageView.setImageBitmap(BitmapFactory.decodeByteArray("previousextrasimagedata".getBytes(), 0, "previousextrasimagedata".getBytes().length));
+        extrasImageView2.setImageBitmap(BitmapFactory.decodeByteArray("previousextrasimagedata2".getBytes(), 0, "previousextrasimagedata2".getBytes().length));
+
+        nativeResponse = new NativeResponse(context,
+                IMPRESSION_URL, CLICK_URL, AD_UNIT_ID, new BaseForwardingNativeAd(){}, null);
+
+        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
+                .addExtra("extrastext", extrasTextView.getId())
+                .addExtra("extrasimage", extrasImageView.getId())
+                .addExtra("extrasimage2", extrasImageView2.getId())
+                .build();
+
+        NativeViewHolder nativeViewHolder =
+                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
+
+        assertThat(extrasTextView.getText()).isEqualTo("previousextrastext");
+
+        nativeViewHolder.updateExtras(relativeLayout, nativeResponse, viewBinder);
+
+        assertThat(extrasTextView.getText()).isEqualTo("");
+        assertThat(extrasImageView.getDrawable()).isNull();
+        assertThat(extrasImageView2.getDrawable()).isNull();
+    }
+
+    @Test
+    public void updateExtras_withMismatchingViewTypes_shouldSetTextViewToImageUrlAndSetExtrasImageViewToNull() throws Exception {
+        BaseForwardingNativeAd nativeAd = new BaseForwardingNativeAd() {};
+        nativeAd.addExtra("extrastext", "extrastexttext");
+        nativeAd.addExtra("extrasimage", "extrasimageurl");
+
+        nativeResponse = new NativeResponse(context,
+                IMPRESSION_URL, CLICK_URL, AD_UNIT_ID, nativeAd, null);
+
+        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
+                .addExtra("extrastext", extrasImageView.getId())
+                .addExtra("extrasimage", extrasTextView.getId())
+                .build();
+
+        NativeViewHolder nativeViewHolder =
+                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
+
+        assertThat(extrasTextView.getText()).isEqualTo("");
+        assertThat(extrasImageView.getDrawable()).isNull();
+
+        nativeViewHolder.updateExtras(relativeLayout, nativeResponse, viewBinder);
+
+        // Volley's imageloader will set this to a bitmapdrawable with no bitmap
+        assertThat(extrasTextView.getText()).isEqualTo("extrasimageurl");
+        assertThat(extrasImageView.getDrawable()).isNull();
+    }
+
+    public void fromViewBinder_withMixedViewTypes_shouldReturnEmptyViewHolder() throws Exception {
+        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
+                .titleId(mainImageView.getId())
+                .textId(textView.getId())
+                .build();
+
+        NativeViewHolder nativeViewHolder =
+                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
+        assertThat(nativeViewHolder).isEqualTo(NativeViewHolder.EMPTY_VIEW_HOLDER);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/PlacementDataTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/PlacementDataTest.java
index 9114f86a..bcab2a25 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/PlacementDataTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/PlacementDataTest.java
@@ -1,845 +1,844 @@
-
-
-package com.mopub.nativeads;
-
-import com.mopub.common.test.support.SdkTestRunner;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.robolectric.annotation.Config;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-import static com.mopub.nativeads.PlacementData.NOT_FOUND;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-@Config(manifest=Config.NONE)
-@RunWith(SdkTestRunner.class)
-public class PlacementDataTest {
-    private PlacementData noAds;
-    private PlacementData adAt0;
-    private PlacementData adAt1;
-    private PlacementData adsAt01;
-    private PlacementData adsAt1234;
-    private PlacementData adsAt14;
-    private PlacementData adsRepeating;
-    private PlacementData adsAt15repeating;
-
-    @Mock private NativeAdData mockNativeAdData;
-    @Mock private NativeAdData mockNativeAdData2;
-    @Mock private NativeAdData mockNativeAdData3;
-    @Mock private NativeAdData mockNativeAdData4;
-    @Mock private NativeResponse mockNativeResponse;
-    @Mock private NativeResponse mockNativeResponse2;
-    @Mock private NativeResponse mockNativeResponse3;
-    @Mock private NativeResponse mockNativeResponse4;
-
-    @Before
-    public void setup() {
-        noAds = PlacementData.fromAdPositioning(MoPubNativeAdPositioning.clientPositioning());
-        adAt0 = PlacementData.fromAdPositioning(MoPubNativeAdPositioning.clientPositioning()
-                .addFixedPosition(0));
-        adAt1 = PlacementData.fromAdPositioning(MoPubNativeAdPositioning.clientPositioning()
-                .addFixedPosition(1));
-        adsAt01 = PlacementData.fromAdPositioning(MoPubNativeAdPositioning.clientPositioning()
-                .addFixedPosition(0)
-                .addFixedPosition(1));
-        adsAt14 = PlacementData.fromAdPositioning(MoPubNativeAdPositioning.clientPositioning()
-                .addFixedPosition(1)
-                .addFixedPosition(4));
-        adsRepeating = PlacementData.fromAdPositioning(MoPubNativeAdPositioning.clientPositioning()
-                .enableRepeatingPositions(3));
-        adsAt15repeating = PlacementData.fromAdPositioning(MoPubNativeAdPositioning.clientPositioning()
-                .addFixedPosition(1)
-                .addFixedPosition(5)
-                .enableRepeatingPositions(3));
-        adsAt1234 = PlacementData.fromAdPositioning(MoPubNativeAdPositioning.clientPositioning()
-                .addFixedPosition(1)
-                .addFixedPosition(2)
-                .addFixedPosition(3)
-                .addFixedPosition(4));
-
-        when(mockNativeAdData.getAd()).thenReturn(mockNativeResponse);
-        when(mockNativeAdData2.getAd()).thenReturn(mockNativeResponse2);
-        when(mockNativeAdData3.getAd()).thenReturn(mockNativeResponse3);
-        when(mockNativeAdData4.getAd()).thenReturn(mockNativeResponse4);
-    }
-
-    @Test
-    public void initialState_isDesired() {
-        assertThat(noAds.shouldPlaceAd(0)).isFalse();
-        assertThat(noAds.shouldPlaceAd(1)).isFalse();
-        assertThat(noAds.shouldPlaceAd(2)).isFalse();
-        assertThat(noAds.shouldPlaceAd(3)).isFalse();
-        assertThat(noAds.shouldPlaceAd(4)).isFalse();
-
-        assertThat(adAt0.shouldPlaceAd(0)).isTrue();
-        assertThat(adAt0.shouldPlaceAd(1)).isFalse();
-        assertThat(adAt0.shouldPlaceAd(2)).isFalse();
-        assertThat(adAt0.shouldPlaceAd(3)).isFalse();
-        assertThat(adAt0.shouldPlaceAd(4)).isFalse();
-
-        assertThat(adAt1.shouldPlaceAd(0)).isFalse();
-        assertThat(adAt1.shouldPlaceAd(1)).isTrue();
-        assertThat(adAt1.shouldPlaceAd(2)).isFalse();
-        assertThat(adAt1.shouldPlaceAd(3)).isFalse();
-        assertThat(adAt1.shouldPlaceAd(4)).isFalse();
-
-        assertThat(adsAt01.shouldPlaceAd(0)).isTrue();
-        assertThat(adsAt01.shouldPlaceAd(1)).isFalse();
-        assertThat(adsAt01.shouldPlaceAd(2)).isFalse();
-        assertThat(adsAt01.shouldPlaceAd(3)).isFalse();
-        assertThat(adsAt01.shouldPlaceAd(4)).isFalse();
-
-        assertThat(adsAt14.shouldPlaceAd(0)).isFalse();
-        assertThat(adsAt14.shouldPlaceAd(1)).isTrue();
-        assertThat(adsAt14.shouldPlaceAd(2)).isFalse();
-        assertThat(adsAt14.shouldPlaceAd(3)).isTrue();
-        assertThat(adsAt14.shouldPlaceAd(4)).isFalse();
-
-        assertThat(adsRepeating.shouldPlaceAd(0)).isFalse();
-        assertThat(adsRepeating.shouldPlaceAd(1)).isFalse();
-        assertThat(adsRepeating.shouldPlaceAd(2)).isTrue();
-        assertThat(adsRepeating.shouldPlaceAd(3)).isFalse();
-        assertThat(adsRepeating.shouldPlaceAd(4)).isTrue();
-        assertThat(adsRepeating.shouldPlaceAd(5)).isFalse();
-        assertThat(adsRepeating.shouldPlaceAd(6)).isTrue();
-
-        assertThat(adsAt15repeating.shouldPlaceAd(0)).isFalse();
-        assertThat(adsAt15repeating.shouldPlaceAd(1)).isTrue();
-        assertThat(adsAt15repeating.shouldPlaceAd(2)).isFalse();
-        assertThat(adsAt15repeating.shouldPlaceAd(3)).isFalse();
-        assertThat(adsAt15repeating.shouldPlaceAd(4)).isTrue();
-        assertThat(adsAt15repeating.shouldPlaceAd(5)).isFalse();
-        assertThat(adsAt15repeating.shouldPlaceAd(6)).isTrue();
-        assertThat(adsAt15repeating.shouldPlaceAd(7)).isFalse();
-        assertThat(adsAt15repeating.shouldPlaceAd(8)).isTrue();
-
-        assertThat(adsAt1234.shouldPlaceAd(0)).isFalse();
-        assertThat(adsAt1234.shouldPlaceAd(1)).isTrue();
-        assertThat(adsAt1234.shouldPlaceAd(2)).isFalse();
-        assertThat(adsAt1234.shouldPlaceAd(3)).isFalse();
-    }
-
-    @Test
-    public void initialState_nextInsertionPosition() {
-        assertThat(noAds.nextInsertionPosition(0)).isEqualTo(NOT_FOUND);
-        assertThat(noAds.nextInsertionPosition(1)).isEqualTo(NOT_FOUND);
-
-        assertThat(adAt0.nextInsertionPosition(0)).isEqualTo(NOT_FOUND);
-        assertThat(adAt0.nextInsertionPosition(1)).isEqualTo(NOT_FOUND);
-
-        assertThat(adAt1.nextInsertionPosition(0)).isEqualTo(1);
-        assertThat(adAt1.nextInsertionPosition(1)).isEqualTo(NOT_FOUND);
-        assertThat(adAt1.nextInsertionPosition(2)).isEqualTo(NOT_FOUND);
-
-        assertThat(adsAt01.nextInsertionPosition(0)).isEqualTo(NOT_FOUND);
-        assertThat(adsAt01.nextInsertionPosition(1)).isEqualTo(NOT_FOUND);
-        assertThat(adsAt01.nextInsertionPosition(2)).isEqualTo(NOT_FOUND);
-
-        assertThat(adsAt14.nextInsertionPosition(0)).isEqualTo(1);
-        assertThat(adsAt14.nextInsertionPosition(1)).isEqualTo(3);
-        assertThat(adsAt14.nextInsertionPosition(2)).isEqualTo(3);
-        assertThat(adsAt14.nextInsertionPosition(3)).isEqualTo(NOT_FOUND);
-        assertThat(adsAt14.nextInsertionPosition(4)).isEqualTo(NOT_FOUND);
-
-        assertThat(adsRepeating.nextInsertionPosition(0)).isEqualTo(2);
-        assertThat(adsRepeating.nextInsertionPosition(1)).isEqualTo(2);
-        assertThat(adsRepeating.nextInsertionPosition(2)).isEqualTo(4);
-        assertThat(adsRepeating.nextInsertionPosition(3)).isEqualTo(4);
-        assertThat(adsRepeating.nextInsertionPosition(4)).isEqualTo(6);
-        assertThat(adsRepeating.nextInsertionPosition(5)).isEqualTo(6);
-        assertThat(adsRepeating.nextInsertionPosition(6)).isEqualTo(8);
-
-        assertThat(adsAt15repeating.nextInsertionPosition(0)).isEqualTo(1);
-        assertThat(adsAt15repeating.nextInsertionPosition(1)).isEqualTo(4);
-        assertThat(adsAt15repeating.nextInsertionPosition(2)).isEqualTo(4);
-        assertThat(adsAt15repeating.nextInsertionPosition(3)).isEqualTo(4);
-        assertThat(adsAt15repeating.nextInsertionPosition(4)).isEqualTo(6);
-        assertThat(adsAt15repeating.nextInsertionPosition(5)).isEqualTo(6);
-        assertThat(adsAt15repeating.nextInsertionPosition(6)).isEqualTo(8);
-        assertThat(adsAt15repeating.nextInsertionPosition(7)).isEqualTo(8);
-        assertThat(adsAt15repeating.nextInsertionPosition(8)).isEqualTo(10);
-
-        assertThat(adsAt1234.nextInsertionPosition(0)).isEqualTo(1);
-        assertThat(adsAt1234.nextInsertionPosition(1)).isEqualTo(NOT_FOUND);
-        assertThat(adsAt1234.nextInsertionPosition(2)).isEqualTo(NOT_FOUND);
-        assertThat(adsAt1234.nextInsertionPosition(3)).isEqualTo(NOT_FOUND);
-        assertThat(adsAt1234.nextInsertionPosition(4)).isEqualTo(NOT_FOUND);
-        assertThat(adsAt1234.nextInsertionPosition(5)).isEqualTo(NOT_FOUND);
-    }
-
-    @Test
-    public void initialState_prevInsertionPosition() {
-        assertThat(noAds.previousInsertionPosition(0)).isEqualTo(NOT_FOUND);
-        assertThat(noAds.previousInsertionPosition(1)).isEqualTo(NOT_FOUND);
-
-        assertThat(adAt0.previousInsertionPosition(0)).isEqualTo(NOT_FOUND);
-        assertThat(adAt0.previousInsertionPosition(1)).isEqualTo(0);
-        assertThat(adAt0.previousInsertionPosition(2)).isEqualTo(0);
-
-        assertThat(adAt1.previousInsertionPosition(0)).isEqualTo(NOT_FOUND);
-        assertThat(adAt1.previousInsertionPosition(1)).isEqualTo(NOT_FOUND);
-        assertThat(adAt1.previousInsertionPosition(2)).isEqualTo(1);
-        assertThat(adAt1.previousInsertionPosition(3)).isEqualTo(1);
-
-        assertThat(adsAt01.previousInsertionPosition(0)).isEqualTo(NOT_FOUND);
-        assertThat(adsAt01.previousInsertionPosition(1)).isEqualTo(0);
-        assertThat(adsAt01.previousInsertionPosition(2)).isEqualTo(0);
-        assertThat(adsAt01.previousInsertionPosition(3)).isEqualTo(0);
-
-        assertThat(adsAt14.previousInsertionPosition(0)).isEqualTo(NOT_FOUND);
-        assertThat(adsAt14.previousInsertionPosition(1)).isEqualTo(NOT_FOUND);
-        assertThat(adsAt14.previousInsertionPosition(2)).isEqualTo(1);
-        assertThat(adsAt14.previousInsertionPosition(3)).isEqualTo(1);
-        assertThat(adsAt14.previousInsertionPosition(4)).isEqualTo(3);
-        assertThat(adsAt14.previousInsertionPosition(5)).isEqualTo(3);
-
-        assertThat(adsRepeating.previousInsertionPosition(0)).isEqualTo(NOT_FOUND);
-        assertThat(adsRepeating.previousInsertionPosition(1)).isEqualTo(NOT_FOUND);
-        assertThat(adsRepeating.previousInsertionPosition(2)).isEqualTo(NOT_FOUND);
-        assertThat(adsRepeating.previousInsertionPosition(3)).isEqualTo(2);
-        assertThat(adsRepeating.previousInsertionPosition(4)).isEqualTo(2);
-        assertThat(adsRepeating.previousInsertionPosition(5)).isEqualTo(4);
-        assertThat(adsRepeating.previousInsertionPosition(6)).isEqualTo(4);
-        assertThat(adsRepeating.previousInsertionPosition(7)).isEqualTo(6);
-
-        assertThat(adsAt15repeating.previousInsertionPosition(0)).isEqualTo(NOT_FOUND);
-        assertThat(adsAt15repeating.previousInsertionPosition(1)).isEqualTo(NOT_FOUND);
-        assertThat(adsAt15repeating.previousInsertionPosition(2)).isEqualTo(1);
-        assertThat(adsAt15repeating.previousInsertionPosition(3)).isEqualTo(1);
-        assertThat(adsAt15repeating.previousInsertionPosition(4)).isEqualTo(1);
-        assertThat(adsAt15repeating.previousInsertionPosition(5)).isEqualTo(4);
-        assertThat(adsAt15repeating.previousInsertionPosition(6)).isEqualTo(4);
-        assertThat(adsAt15repeating.previousInsertionPosition(7)).isEqualTo(6);
-        assertThat(adsAt15repeating.previousInsertionPosition(8)).isEqualTo(6);
-        assertThat(adsAt15repeating.previousInsertionPosition(9)).isEqualTo(8);
-
-        assertThat(adsAt1234.previousInsertionPosition(0)).isEqualTo(NOT_FOUND);
-        assertThat(adsAt1234.previousInsertionPosition(1)).isEqualTo(NOT_FOUND);
-        assertThat(adsAt1234.previousInsertionPosition(2)).isEqualTo(1);
-        assertThat(adsAt1234.previousInsertionPosition(3)).isEqualTo(1);
-    }
-
-    @Test
-    public void initialState_isPlacedAd() {
-        assertThat(adsAt15repeating.isPlacedAd(0)).isFalse();
-        assertThat(adsAt15repeating.isPlacedAd(1)).isFalse();
-        assertThat(adsAt15repeating.isPlacedAd(10)).isFalse();
-        assertThat(adsAt15repeating.isPlacedAd(1000)).isFalse();
-
-        assertThat(noAds.isPlacedAd(0)).isFalse();
-        assertThat(noAds.isPlacedAd(1000)).isFalse();
-    }
-
-    @Test
-    public void initialState_getOriginalPosition() {
-        assertThat(adsAt15repeating.getOriginalPosition(0)).isEqualTo(0);
-        assertThat(adsAt15repeating.getOriginalPosition(1)).isEqualTo(1);
-        assertThat(adsAt15repeating.getOriginalPosition(10)).isEqualTo(10);
-        assertThat(adsAt15repeating.getOriginalPosition(1000)).isEqualTo(1000);
-
-        assertThat(noAds.getOriginalPosition(0)).isEqualTo(0);
-        assertThat(noAds.getOriginalPosition(1000)).isEqualTo(1000);
-    }
-
-    @Test
-    public void initialState_getOriginalCount() {
-        assertThat(adsAt15repeating.getOriginalCount(0)).isEqualTo(0);
-        assertThat(adsAt15repeating.getOriginalCount(1)).isEqualTo(1);
-        assertThat(adsAt15repeating.getOriginalCount(10)).isEqualTo(10);
-        assertThat(adsAt15repeating.getOriginalCount(1000)).isEqualTo(1000);
-
-        assertThat(noAds.getOriginalCount(0)).isEqualTo(0);
-        assertThat(noAds.getOriginalCount(1000)).isEqualTo(1000);
-    }
-
-    @Test
-    public void initialState_getAdjustedPosition() {
-        assertThat(adsAt15repeating.getAdjustedPosition(0)).isEqualTo(0);
-        assertThat(adsAt15repeating.getAdjustedPosition(1)).isEqualTo(1);
-        assertThat(adsAt15repeating.getAdjustedPosition(10)).isEqualTo(10);
-        assertThat(adsAt15repeating.getAdjustedPosition(1000)).isEqualTo(1000);
-
-        assertThat(noAds.getAdjustedPosition(0)).isEqualTo(0);
-        assertThat(noAds.getAdjustedPosition(1000)).isEqualTo(1000);
-    }
-
-    @Test
-    public void initialState_getAdjustedCount() {
-        assertThat(adsAt15repeating.getAdjustedCount(0)).isEqualTo(0);
-        assertThat(adsAt15repeating.getAdjustedCount(1)).isEqualTo(1);
-        assertThat(adsAt15repeating.getAdjustedCount(10)).isEqualTo(10);
-        assertThat(adsAt15repeating.getAdjustedCount(1000)).isEqualTo(1000);
-
-        assertThat(noAds.getAdjustedCount(0)).isEqualTo(0);
-        assertThat(noAds.getAdjustedCount(1000)).isEqualTo(1000);
-    }
-
-    @Test
-    public void placeAds_inOrder_shouldUpdatePositions() {
-        checkInsertionPositions(10, adsAt15repeating, 1, 4, 6, 8, 10);
-        checkPlacedPositions(20, adsAt15repeating);
-
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        checkInsertionPositions(10, adsAt15repeating, 5, 7, 9);
-        checkPlacedPositions(20, adsAt15repeating, 1);
-
-        adsAt15repeating.placeAd(5, mockNativeAdData);
-        checkInsertionPositions(10, adsAt15repeating, 8, 10);
-        checkPlacedPositions(20, adsAt15repeating, 1, 5);
-
-        adsAt15repeating.placeAd(8, mockNativeAdData);
-        checkInsertionPositions(10, adsAt15repeating);
-        checkPlacedPositions(20, adsAt15repeating, 1, 5, 8);
-    }
-
-    @Test
-    public void placeAds_outOfOrder_shouldUpdatePositions() {
-        checkInsertionPositions(10, adsAt15repeating, 1, 4, 6, 8, 10);
-        checkPlacedPositions(20, adsAt15repeating);
-
-        adsAt15repeating.placeAd(6, mockNativeAdData);
-        checkInsertionPositions(10, adsAt15repeating, 1, 4, 9);
-        checkPlacedPositions(20, adsAt15repeating, 6);
-
-        adsAt15repeating.placeAd(4, mockNativeAdData);
-        checkInsertionPositions(10, adsAt15repeating, 1, 10);
-        checkPlacedPositions(20, adsAt15repeating, 4, 7);
-
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        checkInsertionPositions(10, adsAt15repeating);
-        checkPlacedPositions(20, adsAt15repeating, 1, 5, 8);
-    }
-
-    @Test
-    public void placedAds_getOriginalPositionAndCount() {
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        adsAt15repeating.placeAd(5, mockNativeAdData);
-        adsAt15repeating.placeAd(8, mockNativeAdData);
-
-        assertThat(adsAt15repeating.getOriginalPosition(0)).isEqualTo(0);
-        assertThat(adsAt15repeating.getOriginalPosition(1)).isEqualTo(NOT_FOUND);
-        assertThat(adsAt15repeating.getOriginalPosition(2)).isEqualTo(1);
-        assertThat(adsAt15repeating.getOriginalPosition(3)).isEqualTo(2);
-        assertThat(adsAt15repeating.getOriginalPosition(4)).isEqualTo(3);
-        assertThat(adsAt15repeating.getOriginalPosition(5)).isEqualTo(NOT_FOUND);
-        assertThat(adsAt15repeating.getOriginalPosition(6)).isEqualTo(4);
-        assertThat(adsAt15repeating.getOriginalPosition(7)).isEqualTo(5);
-        assertThat(adsAt15repeating.getOriginalPosition(8)).isEqualTo(NOT_FOUND);
-        assertThat(adsAt15repeating.getOriginalPosition(9)).isEqualTo(6);
-        assertThat(adsAt15repeating.getOriginalPosition(10)).isEqualTo(7);
-
-        assertThat(adsAt15repeating.getOriginalCount(0)).isEqualTo(0);
-        assertThat(adsAt15repeating.getOriginalCount(10)).isEqualTo(7);
-        assertThat(adsAt15repeating.getOriginalCount(20)).isEqualTo(17);
-    }
-
-    @Test
-    public void placedAds_getAdjustedPositionAndCount() {
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        adsAt15repeating.placeAd(5, mockNativeAdData);
-        adsAt15repeating.placeAd(8, mockNativeAdData);
-
-        assertThat(adsAt15repeating.getAdjustedPosition(0)).isEqualTo(0);
-        // Ad here
-        assertThat(adsAt15repeating.getAdjustedPosition(1)).isEqualTo(2);
-        assertThat(adsAt15repeating.getAdjustedPosition(2)).isEqualTo(3);
-        assertThat(adsAt15repeating.getAdjustedPosition(3)).isEqualTo(4);
-        // Ad here
-        assertThat(adsAt15repeating.getAdjustedPosition(4)).isEqualTo(6);
-        assertThat(adsAt15repeating.getAdjustedPosition(5)).isEqualTo(7);
-        // Ad here
-        assertThat(adsAt15repeating.getAdjustedPosition(6)).isEqualTo(9);
-        assertThat(adsAt15repeating.getAdjustedPosition(7)).isEqualTo(10);
-        assertThat(adsAt15repeating.getAdjustedPosition(8)).isEqualTo(11);
-        assertThat(adsAt15repeating.getAdjustedPosition(9)).isEqualTo(12);
-        assertThat(adsAt15repeating.getAdjustedPosition(10)).isEqualTo(13);
-
-        assertThat(adsAt15repeating.getAdjustedCount(0)).isEqualTo(0);
-        assertThat(adsAt15repeating.getAdjustedCount(10)).isEqualTo(13);
-        assertThat(adsAt15repeating.getAdjustedCount(20)).isEqualTo(23);
-    }
-
-    @Test
-    public void placeAdsClumped_shouldPlaceAdsInOrder() {
-        int nextPosition = adsAt1234.nextInsertionPosition(0);
-        adsAt1234.placeAd(nextPosition, mockNativeAdData);
-
-        nextPosition = adsAt1234.nextInsertionPosition(nextPosition);
-        adsAt1234.placeAd(nextPosition, mockNativeAdData2);
-
-        nextPosition = adsAt1234.nextInsertionPosition(nextPosition);
-        adsAt1234.placeAd(nextPosition, mockNativeAdData3);
-
-        nextPosition = adsAt1234.nextInsertionPosition(nextPosition);
-        adsAt1234.placeAd(nextPosition, mockNativeAdData4);
-
-        nextPosition = adsAt1234.nextInsertionPosition(nextPosition);
-        assertThat(nextPosition).isEqualTo(NOT_FOUND);
-
-        assertThat(adsAt1234.isPlacedAd(0)).isFalse();
-        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mockNativeAdData);
-        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mockNativeAdData2);
-        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData3);
-        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mockNativeAdData4);
-        assertThat(adsAt1234.isPlacedAd(5)).isFalse();
-    }
-
-    @Test
-    public void placeAdsClumped_thenRemoveContentBeforeClumpedAds_shouldShiftAds() {
-        adsAt1234.placeAd(1, mockNativeAdData);
-        adsAt1234.placeAd(2, mockNativeAdData2);
-        adsAt1234.placeAd(3, mockNativeAdData3);
-        adsAt1234.placeAd(4, mockNativeAdData4);
-
-        adsAt1234.removeItem(0);
-        assertThat(adsAt1234.getPlacedAd(0)).isEqualTo(mockNativeAdData);
-        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mockNativeAdData2);
-        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mockNativeAdData3);
-        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData4);
-        assertThat(adsAt1234.isPlacedAd(4)).isFalse();
-
-        adsAt1234.removeItem(0);
-        assertThat(adsAt1234.getPlacedAd(0)).isEqualTo(mockNativeAdData);
-        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mockNativeAdData2);
-        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mockNativeAdData3);
-        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData4);
-        assertThat(adsAt1234.isPlacedAd(4)).isFalse();
-    }
-
-    @Test
-    public void placeAdsClumped_thenRemoveContentAfterClumpedAds_shouldNotShiftAds() {
-        adsAt1234.placeAd(1, mockNativeAdData);
-        adsAt1234.placeAd(2, mockNativeAdData2);
-        adsAt1234.placeAd(3, mockNativeAdData3);
-        adsAt1234.placeAd(4, mockNativeAdData4);
-
-        adsAt1234.removeItem(1);
-        assertThat(adsAt1234.isPlacedAd(0)).isFalse();
-        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mockNativeAdData);
-        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mockNativeAdData2);
-        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData3);
-        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mockNativeAdData4);
-        assertThat(adsAt1234.isPlacedAd(5)).isFalse();
-
-        adsAt1234.removeItem(2);
-        assertThat(adsAt1234.isPlacedAd(0)).isFalse();
-        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mockNativeAdData);
-        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mockNativeAdData2);
-        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData3);
-        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mockNativeAdData4);
-        assertThat(adsAt1234.isPlacedAd(5)).isFalse();
-    }
-
-    @Test
-    public void placeAdsClumped_thenInsertContentBeforeClumpedAds_shouldShiftAds() {
-        adsAt1234.placeAd(1, mockNativeAdData);
-        adsAt1234.placeAd(2, mockNativeAdData2);
-        adsAt1234.placeAd(3, mockNativeAdData3);
-        adsAt1234.placeAd(4, mockNativeAdData4);
-
-        adsAt1234.insertItem(1);
-        assertThat(adsAt1234.isPlacedAd(0)).isFalse();
-        assertThat(adsAt1234.isPlacedAd(1)).isFalse();
-        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mockNativeAdData);
-        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData2);
-        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mockNativeAdData3);
-        assertThat(adsAt1234.getPlacedAd(5)).isEqualTo(mockNativeAdData4);
-        assertThat(adsAt1234.isPlacedAd(6)).isFalse();
-
-        adsAt1234.insertItem(0);
-        assertThat(adsAt1234.isPlacedAd(0)).isFalse();
-        assertThat(adsAt1234.isPlacedAd(1)).isFalse();
-        assertThat(adsAt1234.isPlacedAd(2)).isFalse();
-        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData);
-        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mockNativeAdData2);
-        assertThat(adsAt1234.getPlacedAd(5)).isEqualTo(mockNativeAdData3);
-        assertThat(adsAt1234.getPlacedAd(6)).isEqualTo(mockNativeAdData4);
-        assertThat(adsAt1234.isPlacedAd(7)).isFalse();
-    }
-
-    @Test
-    public void placeAdsClumped_thenInsertContentAfterClumpedAds_shouldNotShiftAds() {
-        adsAt1234.placeAd(1, mockNativeAdData);
-        adsAt1234.placeAd(2, mockNativeAdData2);
-        adsAt1234.placeAd(3, mockNativeAdData3);
-        adsAt1234.placeAd(4, mockNativeAdData4);
-
-        adsAt1234.insertItem(2);
-        assertThat(adsAt1234.isPlacedAd(0)).isFalse();
-        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mockNativeAdData);
-        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mockNativeAdData2);
-        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData3);
-        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mockNativeAdData4);
-        assertThat(adsAt1234.isPlacedAd(5)).isFalse();
-
-        adsAt1234.removeItem(3);
-        assertThat(adsAt1234.isPlacedAd(0)).isFalse();
-        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mockNativeAdData);
-        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mockNativeAdData2);
-        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData3);
-        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mockNativeAdData4);
-        assertThat(adsAt1234.isPlacedAd(5)).isFalse();
-    }
-
-    @Test
-    public void placedAds_thenClearEmptyRange_doesNothing() {
-        checkPlacedPositions(15, adsAt15repeating);
-        checkPlacedPositions(15, adsAt15repeating);
-        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
-
-        adsAt15repeating.clearAdsInRange(0, 0);
-        checkPlacedPositions(15, adsAt15repeating);
-        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
-
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        adsAt15repeating.placeAd(5, mockNativeAdData);
-        adsAt15repeating.placeAd(8, mockNativeAdData);
-        checkPlacedPositions(15, adsAt15repeating, 1, 5, 8);
-        checkInsertionPositions(15, adsAt15repeating, 11, 13, 15);
-
-        adsAt15repeating.clearAdsInRange(4, 4);
-        checkPlacedPositions(15, adsAt15repeating, 1, 5, 8);
-        checkInsertionPositions(15, adsAt15repeating, 11, 13, 15);
-    }
-
-    @Test
-    public void placedAds_thenClearAll_shouldResetInsertionPositions() {
-        checkPlacedPositions(15, adsAt15repeating);
-        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
-
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        adsAt15repeating.placeAd(5, mockNativeAdData);
-        adsAt15repeating.placeAd(8, mockNativeAdData);
-        checkPlacedPositions(15, adsAt15repeating, 1, 5, 8);
-        checkInsertionPositions(15, adsAt15repeating, 11, 13, 15);
-
-        adsAt15repeating.clearAdsInRange(1, 10);
-        checkPlacedPositions(15, adsAt15repeating);
-        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
-    }
-
-    @Test
-    public void placedAds_thenClearRange_inOrder_shouldResetInsertionPositions() {
-        checkPlacedPositions(15, adsAt15repeating);
-        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
-
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        adsAt15repeating.placeAd(5, mockNativeAdData);
-        adsAt15repeating.placeAd(8, mockNativeAdData);
-        checkPlacedPositions(15, adsAt15repeating, 1, 5, 8);
-        checkInsertionPositions(15, adsAt15repeating, 11, 13, 15);
-
-        adsAt15repeating.clearAdsInRange(1, 2);
-        checkPlacedPositions(15, adsAt15repeating, 4, 7);
-        checkInsertionPositions(15, adsAt15repeating, 1, 10, 12, 14);
-
-        adsAt15repeating.clearAdsInRange(4, 5);
-        checkPlacedPositions(15, adsAt15repeating, 6);
-        checkInsertionPositions(15, adsAt15repeating, 1, 4, 9, 11, 13, 15);
-
-        adsAt15repeating.clearAdsInRange(6, 7);
-        checkPlacedPositions(15, adsAt15repeating);
-        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
-    }
-
-    @Test
-    public void placedAds_thenClearRange_descending_shouldResetInsertionPositions() {
-        checkPlacedPositions(15, adsAt15repeating);
-        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
-
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        adsAt15repeating.placeAd(5, mockNativeAdData);
-        adsAt15repeating.placeAd(8, mockNativeAdData);
-        checkPlacedPositions(15, adsAt15repeating, 1, 5, 8);
-        checkInsertionPositions(15, adsAt15repeating, 11, 13, 15);
-
-        adsAt15repeating.clearAdsInRange(8, 9);
-        checkPlacedPositions(15, adsAt15repeating, 1, 5);
-        checkInsertionPositions(15, adsAt15repeating, 8, 10, 12, 14);
-
-        adsAt15repeating.clearAdsInRange(5, 6);
-        checkPlacedPositions(15, adsAt15repeating, 1);
-        checkInsertionPositions(15, adsAt15repeating, 5, 7, 9, 11, 13, 15);
-
-        adsAt15repeating.clearAdsInRange(1, 2);
-        checkPlacedPositions(15, adsAt15repeating);
-        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
-    }
-
-    @Test
-    public void placedAds_thenClearRange_multiple_shouldResetInsertionPositions() {
-        checkPlacedPositions(15, adsAt15repeating);
-        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
-
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        adsAt15repeating.placeAd(5, mockNativeAdData);
-        adsAt15repeating.placeAd(8, mockNativeAdData);
-        checkPlacedPositions(15, adsAt15repeating, 1, 5, 8);
-        checkInsertionPositions(15, adsAt15repeating, 11, 13, 15);
-
-        adsAt15repeating.clearAdsInRange(1, 6);
-        checkPlacedPositions(15, adsAt15repeating, 6);
-        checkInsertionPositions(15, adsAt15repeating, 1, 4, 9, 11, 13, 15);
-
-        adsAt15repeating.clearAdsInRange(5, 10);
-        checkPlacedPositions(15, adsAt15repeating);
-        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
-    }
-
-    @Test
-    public void placedAds_thenClearRange_descending_multiple_shouldResetInsertionPositions() {
-        checkPlacedPositions(15, adsAt15repeating);
-        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
-
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        adsAt15repeating.placeAd(5, mockNativeAdData);
-        adsAt15repeating.placeAd(8, mockNativeAdData);
-        checkPlacedPositions(15, adsAt15repeating, 1, 5, 8);
-        checkInsertionPositions(15, adsAt15repeating, 11, 13, 15);
-
-        adsAt15repeating.clearAdsInRange(5, 9);
-        checkPlacedPositions(15, adsAt15repeating, 1);
-        checkInsertionPositions(15, adsAt15repeating, 5, 7, 9, 11, 13, 15);
-
-        adsAt15repeating.clearAdsInRange(1, 5);
-        checkPlacedPositions(15, adsAt15repeating);
-        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
-    }
-
-    @Test
-    public void placeAds_thenClear_shouldCallDestroy() {
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        adsAt15repeating.placeAd(5, mockNativeAdData2);
-        adsAt15repeating.placeAd(8, mockNativeAdData3);
-
-        adsAt15repeating.clearAdsInRange(5, 10);
-        verify(mockNativeResponse, never()).destroy();
-        verify(mockNativeResponse2).destroy();
-        verify(mockNativeResponse3).destroy();
-    }
-
-    @Test
-    public void insertItems_afterPlacing() {
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        adsAt15repeating.placeAd(5, mockNativeAdData);
-        adsAt15repeating.placeAd(8, mockNativeAdData);
-
-        adsAt15repeating.insertItem(1);
-        adsAt15repeating.insertItem(4);
-        adsAt15repeating.insertItem(12);
-
-        checkPlacedPositions(20, adsAt15repeating, 2, 7, 10);
-    }
-
-    @Test
-    public void insertItems_beforePlacing() {
-        checkInsertionPositions(7, adsAt15repeating, 1, 4, 6);
-
-        adsAt15repeating.insertItem(4);
-        adsAt15repeating.insertItem(7);
-
-        checkInsertionPositions(9, adsAt15repeating, 1, 5, 8);
-    }
-
-    @Test
-    public void removeThenInsertItem_atZero_shouldBeAtZero() {
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        adsAt15repeating.placeAd(5, mockNativeAdData);
-        adsAt15repeating.placeAd(8, mockNativeAdData);
-
-        adsAt15repeating.removeItem(0);
-        checkPlacedPositions(20, adsAt15repeating, 0, 4, 7);
-        checkInsertionPositions(16, adsAt15repeating, 10, 12, 14, 16);
-
-        adsAt15repeating.insertItem(0);
-        checkPlacedPositions(20, adsAt15repeating, 1, 5, 8);
-        checkInsertionPositions(16, adsAt15repeating, 11, 13, 15);
-    }
-
-    @Test
-    public void placeThenInsertThenPlace() {
-        adsAt15repeating.placeAd(4, mockNativeAdData);
-        adsAt15repeating.insertItem(4);
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-
-        checkPlacedPositions(20, adsAt15repeating, 1, 6);
-    }
-
-    @Test
-    public void removeItems_afterPlacing() {
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        adsAt15repeating.placeAd(5, mockNativeAdData);
-        adsAt15repeating.placeAd(8, mockNativeAdData);
-
-        checkPlacedPositions(20, adsAt15repeating, 1, 5, 8);
-
-        adsAt15repeating.removeItem(3);
-        adsAt15repeating.removeItem(5);
-
-        checkPlacedPositions(20, adsAt15repeating, 1, 4, 7);
-
-        // Check the adjusted positions.
-        assertThat(adsAt15repeating.getAdjustedPosition(0)).isEqualTo(0);
-        assertThat(adsAt15repeating.getAdjustedPosition(1)).isEqualTo(2);
-        assertThat(adsAt15repeating.getAdjustedPosition(2)).isEqualTo(3);
-        assertThat(adsAt15repeating.getAdjustedPosition(3)).isEqualTo(5);
-        assertThat(adsAt15repeating.getAdjustedPosition(4)).isEqualTo(6);
-        assertThat(adsAt15repeating.getAdjustedPosition(5)).isEqualTo(8);
-    }
-
-    @Test
-    public void removeItemsBetweenAds_thenInsert_shouldClumpAds() {
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        adsAt15repeating.placeAd(5, mockNativeAdData);
-        adsAt15repeating.placeAd(8, mockNativeAdData);
-
-        adsAt15repeating.removeItem(4);
-        adsAt15repeating.removeItem(4);
-
-        checkPlacedPositions(20, adsAt15repeating, 1, 5, 6);
-
-        adsAt15repeating.insertItem(5);
-
-        checkPlacedPositions(20, adsAt15repeating, 1, 5, 6);
-
-        adsAt15repeating.insertItem(4);
-
-        checkPlacedPositions(20, adsAt15repeating, 1, 6, 7);
-    }
-
-    @Test
-    public void removeItems_beforePlacing() {
-        checkInsertionPositions(7, adsAt15repeating, 1, 4, 6);
-
-        adsAt15repeating.removeItem(4);
-
-        // Check insertion positions.
-        checkInsertionPositions(7, adsAt15repeating, 1, 4, 5, 7);
-    }
-
-    @Test
-    public void removeItem_withClumpedAdsBeforeIt_shouldCorrectlyRemoveItem() throws Exception {
-        adsRepeating.placeAd(2, mockNativeAdData);
-        adsRepeating.placeAd(5, mockNativeAdData);
-        adsRepeating.placeAd(8, mockNativeAdData);
-
-        checkPlacedPositions(20, adsRepeating, 2, 5, 8);
-        assertThat(adsRepeating.getAdjustedCount(7)).isEqualTo(10);
-
-        // Removing from the head will cause ads to pile up
-        adsRepeating.removeItem(0);
-        adsRepeating.removeItem(0);
-        adsRepeating.removeItem(0);
-        adsRepeating.removeItem(0);
-        adsRepeating.removeItem(0);
-        adsRepeating.removeItem(0);
-
-        checkPlacedPositions(20, adsRepeating, 0, 1, 2);
-
-        adsRepeating.removeItem(0);
-
-        checkPlacedPositions(20, adsRepeating, 0, 1, 2);
-    }
-
-    @Test
-    public void removeItems_afterClumpedAds_shouldStayClumped() {
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        adsAt15repeating.placeAd(5, mockNativeAdData);
-        adsAt15repeating.placeAd(8, mockNativeAdData);
-
-        adsAt15repeating.removeItem(4);
-        adsAt15repeating.removeItem(4);
-
-        checkPlacedPositions(20, adsAt15repeating, 1, 5, 6);
-
-        // Shouldn't move any ads.
-        adsAt15repeating.removeItem(4);
-
-        checkPlacedPositions(20, adsAt15repeating, 1, 5, 6);
-
-        adsAt15repeating.removeItem(3);
-
-        checkPlacedPositions(20, adsAt15repeating, 1, 4, 5);
-    }
-
-    @Test
-    public void moveItems_afterPlacing() {
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        adsAt15repeating.placeAd(5, mockNativeAdData);
-        adsAt15repeating.placeAd(8, mockNativeAdData);
-
-        assertThat(adsAt15repeating.getAdjustedPosition(4)).isEqualTo(6);
-        assertThat(adsAt15repeating.getAdjustedPosition(5)).isEqualTo(7);
-
-        adsAt15repeating.moveItem(4, 2);
-
-        checkPlacedPositions(20, adsAt15repeating, 1, 6, 8);
-
-        assertThat(adsAt15repeating.getAdjustedPosition(4)).isEqualTo(5);
-        assertThat(adsAt15repeating.getAdjustedPosition(5)).isEqualTo(7);
-    }
-
-    @Test
-    public void clearAll_shouldCallDestroyOnAdData_shouldResetPositions() {
-        when(mockNativeAdData.getAd()).thenReturn(mockNativeResponse);
-        when(mockNativeAdData2.getAd()).thenReturn(mockNativeResponse2);
-        when(mockNativeAdData3.getAd()).thenReturn(mockNativeResponse3);
-
-        adsAt15repeating.placeAd(1, mockNativeAdData);
-        adsAt15repeating.placeAd(5, mockNativeAdData2);
-        adsAt15repeating.placeAd(8, mockNativeAdData3);
-
-        adsAt15repeating.clearAds();
-
-        verify(mockNativeResponse).destroy();
-        verify(mockNativeResponse2).destroy();
-        verify(mockNativeResponse3).destroy();
-
-        // Should reset to original positions
-        checkInsertionPositions(10, adsAt15repeating, 1, 4, 6, 8, 10);
-        checkPlacedPositions(20, adsAt15repeating);
-    }
-
-    void checkInsertionPositions(int maxValue, PlacementData placementData, Integer... positions) {
-        List<Integer> expected = Arrays.asList(positions);
-        List<Integer> actual = new ArrayList<Integer>();
-        for (int i = 0; i <= maxValue; i++) {
-            if (placementData.shouldPlaceAd(i)) {
-                actual.add(i);
-            }
-        }
-
-        assertThat(actual).isEqualTo(expected);
-    }
-
-    void checkPlacedPositions(int maxValue, PlacementData placementData, Integer... positions) {
-        List<Integer> expected = Arrays.asList(positions);
-        List<Integer> actual = new ArrayList<Integer>();
-        for (int i = 0; i < maxValue; i++) {
-            if (placementData.isPlacedAd(i)) {
-                actual.add(i);
-                assertThat(placementData.getPlacedAd(i)).isEqualTo(mockNativeAdData);
-            } else {
-                assertThat(placementData.getPlacedAd(i)).isNull();
-            }
-        }
-
-        assertThat(actual).isEqualTo(expected);
-
-        // Also check getPlacedAdPositions
-        List<Integer> actualFromAdPositions = new ArrayList<Integer>();
-        for (Integer position : placementData.getPlacedAdPositions()) {
-            actualFromAdPositions.add(position);
-        }
-        assertThat(actualFromAdPositions).isEqualTo(expected);
-    }
-}
+
+
+package com.mopub.nativeads;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.annotation.Config;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import static com.mopub.nativeads.PlacementData.NOT_FOUND;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class PlacementDataTest {
+    private PlacementData noAds;
+    private PlacementData adAt0;
+    private PlacementData adAt1;
+    private PlacementData adsAt01;
+    private PlacementData adsAt1234;
+    private PlacementData adsAt14;
+    private PlacementData adsRepeating;
+    private PlacementData adsAt15repeating;
+
+    @Mock private NativeAdData mockNativeAdData;
+    @Mock private NativeAdData mockNativeAdData2;
+    @Mock private NativeAdData mockNativeAdData3;
+    @Mock private NativeAdData mockNativeAdData4;
+    @Mock private NativeResponse mockNativeResponse;
+    @Mock private NativeResponse mockNativeResponse2;
+    @Mock private NativeResponse mockNativeResponse3;
+    @Mock private NativeResponse mockNativeResponse4;
+
+    @Before
+    public void setup() {
+        noAds = PlacementData.fromAdPositioning(MoPubNativeAdPositioning.clientPositioning());
+        adAt0 = PlacementData.fromAdPositioning(MoPubNativeAdPositioning.clientPositioning()
+                .addFixedPosition(0));
+        adAt1 = PlacementData.fromAdPositioning(MoPubNativeAdPositioning.clientPositioning()
+                .addFixedPosition(1));
+        adsAt01 = PlacementData.fromAdPositioning(MoPubNativeAdPositioning.clientPositioning()
+                .addFixedPosition(0)
+                .addFixedPosition(1));
+        adsAt14 = PlacementData.fromAdPositioning(MoPubNativeAdPositioning.clientPositioning()
+                .addFixedPosition(1)
+                .addFixedPosition(4));
+        adsRepeating = PlacementData.fromAdPositioning(MoPubNativeAdPositioning.clientPositioning()
+                .enableRepeatingPositions(3));
+        adsAt15repeating = PlacementData.fromAdPositioning(MoPubNativeAdPositioning.clientPositioning()
+                .addFixedPosition(1)
+                .addFixedPosition(5)
+                .enableRepeatingPositions(3));
+        adsAt1234 = PlacementData.fromAdPositioning(MoPubNativeAdPositioning.clientPositioning()
+                .addFixedPosition(1)
+                .addFixedPosition(2)
+                .addFixedPosition(3)
+                .addFixedPosition(4));
+
+        when(mockNativeAdData.getAd()).thenReturn(mockNativeResponse);
+        when(mockNativeAdData2.getAd()).thenReturn(mockNativeResponse2);
+        when(mockNativeAdData3.getAd()).thenReturn(mockNativeResponse3);
+        when(mockNativeAdData4.getAd()).thenReturn(mockNativeResponse4);
+    }
+
+    @Test
+    public void initialState_isDesired() {
+        assertThat(noAds.shouldPlaceAd(0)).isFalse();
+        assertThat(noAds.shouldPlaceAd(1)).isFalse();
+        assertThat(noAds.shouldPlaceAd(2)).isFalse();
+        assertThat(noAds.shouldPlaceAd(3)).isFalse();
+        assertThat(noAds.shouldPlaceAd(4)).isFalse();
+
+        assertThat(adAt0.shouldPlaceAd(0)).isTrue();
+        assertThat(adAt0.shouldPlaceAd(1)).isFalse();
+        assertThat(adAt0.shouldPlaceAd(2)).isFalse();
+        assertThat(adAt0.shouldPlaceAd(3)).isFalse();
+        assertThat(adAt0.shouldPlaceAd(4)).isFalse();
+
+        assertThat(adAt1.shouldPlaceAd(0)).isFalse();
+        assertThat(adAt1.shouldPlaceAd(1)).isTrue();
+        assertThat(adAt1.shouldPlaceAd(2)).isFalse();
+        assertThat(adAt1.shouldPlaceAd(3)).isFalse();
+        assertThat(adAt1.shouldPlaceAd(4)).isFalse();
+
+        assertThat(adsAt01.shouldPlaceAd(0)).isTrue();
+        assertThat(adsAt01.shouldPlaceAd(1)).isFalse();
+        assertThat(adsAt01.shouldPlaceAd(2)).isFalse();
+        assertThat(adsAt01.shouldPlaceAd(3)).isFalse();
+        assertThat(adsAt01.shouldPlaceAd(4)).isFalse();
+
+        assertThat(adsAt14.shouldPlaceAd(0)).isFalse();
+        assertThat(adsAt14.shouldPlaceAd(1)).isTrue();
+        assertThat(adsAt14.shouldPlaceAd(2)).isFalse();
+        assertThat(adsAt14.shouldPlaceAd(3)).isTrue();
+        assertThat(adsAt14.shouldPlaceAd(4)).isFalse();
+
+        assertThat(adsRepeating.shouldPlaceAd(0)).isFalse();
+        assertThat(adsRepeating.shouldPlaceAd(1)).isFalse();
+        assertThat(adsRepeating.shouldPlaceAd(2)).isTrue();
+        assertThat(adsRepeating.shouldPlaceAd(3)).isFalse();
+        assertThat(adsRepeating.shouldPlaceAd(4)).isTrue();
+        assertThat(adsRepeating.shouldPlaceAd(5)).isFalse();
+        assertThat(adsRepeating.shouldPlaceAd(6)).isTrue();
+
+        assertThat(adsAt15repeating.shouldPlaceAd(0)).isFalse();
+        assertThat(adsAt15repeating.shouldPlaceAd(1)).isTrue();
+        assertThat(adsAt15repeating.shouldPlaceAd(2)).isFalse();
+        assertThat(adsAt15repeating.shouldPlaceAd(3)).isFalse();
+        assertThat(adsAt15repeating.shouldPlaceAd(4)).isTrue();
+        assertThat(adsAt15repeating.shouldPlaceAd(5)).isFalse();
+        assertThat(adsAt15repeating.shouldPlaceAd(6)).isTrue();
+        assertThat(adsAt15repeating.shouldPlaceAd(7)).isFalse();
+        assertThat(adsAt15repeating.shouldPlaceAd(8)).isTrue();
+
+        assertThat(adsAt1234.shouldPlaceAd(0)).isFalse();
+        assertThat(adsAt1234.shouldPlaceAd(1)).isTrue();
+        assertThat(adsAt1234.shouldPlaceAd(2)).isFalse();
+        assertThat(adsAt1234.shouldPlaceAd(3)).isFalse();
+    }
+
+    @Test
+    public void initialState_nextInsertionPosition() {
+        assertThat(noAds.nextInsertionPosition(0)).isEqualTo(NOT_FOUND);
+        assertThat(noAds.nextInsertionPosition(1)).isEqualTo(NOT_FOUND);
+
+        assertThat(adAt0.nextInsertionPosition(0)).isEqualTo(NOT_FOUND);
+        assertThat(adAt0.nextInsertionPosition(1)).isEqualTo(NOT_FOUND);
+
+        assertThat(adAt1.nextInsertionPosition(0)).isEqualTo(1);
+        assertThat(adAt1.nextInsertionPosition(1)).isEqualTo(NOT_FOUND);
+        assertThat(adAt1.nextInsertionPosition(2)).isEqualTo(NOT_FOUND);
+
+        assertThat(adsAt01.nextInsertionPosition(0)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt01.nextInsertionPosition(1)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt01.nextInsertionPosition(2)).isEqualTo(NOT_FOUND);
+
+        assertThat(adsAt14.nextInsertionPosition(0)).isEqualTo(1);
+        assertThat(adsAt14.nextInsertionPosition(1)).isEqualTo(3);
+        assertThat(adsAt14.nextInsertionPosition(2)).isEqualTo(3);
+        assertThat(adsAt14.nextInsertionPosition(3)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt14.nextInsertionPosition(4)).isEqualTo(NOT_FOUND);
+
+        assertThat(adsRepeating.nextInsertionPosition(0)).isEqualTo(2);
+        assertThat(adsRepeating.nextInsertionPosition(1)).isEqualTo(2);
+        assertThat(adsRepeating.nextInsertionPosition(2)).isEqualTo(4);
+        assertThat(adsRepeating.nextInsertionPosition(3)).isEqualTo(4);
+        assertThat(adsRepeating.nextInsertionPosition(4)).isEqualTo(6);
+        assertThat(adsRepeating.nextInsertionPosition(5)).isEqualTo(6);
+        assertThat(adsRepeating.nextInsertionPosition(6)).isEqualTo(8);
+
+        assertThat(adsAt15repeating.nextInsertionPosition(0)).isEqualTo(1);
+        assertThat(adsAt15repeating.nextInsertionPosition(1)).isEqualTo(4);
+        assertThat(adsAt15repeating.nextInsertionPosition(2)).isEqualTo(4);
+        assertThat(adsAt15repeating.nextInsertionPosition(3)).isEqualTo(4);
+        assertThat(adsAt15repeating.nextInsertionPosition(4)).isEqualTo(6);
+        assertThat(adsAt15repeating.nextInsertionPosition(5)).isEqualTo(6);
+        assertThat(adsAt15repeating.nextInsertionPosition(6)).isEqualTo(8);
+        assertThat(adsAt15repeating.nextInsertionPosition(7)).isEqualTo(8);
+        assertThat(adsAt15repeating.nextInsertionPosition(8)).isEqualTo(10);
+
+        assertThat(adsAt1234.nextInsertionPosition(0)).isEqualTo(1);
+        assertThat(adsAt1234.nextInsertionPosition(1)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt1234.nextInsertionPosition(2)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt1234.nextInsertionPosition(3)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt1234.nextInsertionPosition(4)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt1234.nextInsertionPosition(5)).isEqualTo(NOT_FOUND);
+    }
+
+    @Test
+    public void initialState_prevInsertionPosition() {
+        assertThat(noAds.previousInsertionPosition(0)).isEqualTo(NOT_FOUND);
+        assertThat(noAds.previousInsertionPosition(1)).isEqualTo(NOT_FOUND);
+
+        assertThat(adAt0.previousInsertionPosition(0)).isEqualTo(NOT_FOUND);
+        assertThat(adAt0.previousInsertionPosition(1)).isEqualTo(0);
+        assertThat(adAt0.previousInsertionPosition(2)).isEqualTo(0);
+
+        assertThat(adAt1.previousInsertionPosition(0)).isEqualTo(NOT_FOUND);
+        assertThat(adAt1.previousInsertionPosition(1)).isEqualTo(NOT_FOUND);
+        assertThat(adAt1.previousInsertionPosition(2)).isEqualTo(1);
+        assertThat(adAt1.previousInsertionPosition(3)).isEqualTo(1);
+
+        assertThat(adsAt01.previousInsertionPosition(0)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt01.previousInsertionPosition(1)).isEqualTo(0);
+        assertThat(adsAt01.previousInsertionPosition(2)).isEqualTo(0);
+        assertThat(adsAt01.previousInsertionPosition(3)).isEqualTo(0);
+
+        assertThat(adsAt14.previousInsertionPosition(0)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt14.previousInsertionPosition(1)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt14.previousInsertionPosition(2)).isEqualTo(1);
+        assertThat(adsAt14.previousInsertionPosition(3)).isEqualTo(1);
+        assertThat(adsAt14.previousInsertionPosition(4)).isEqualTo(3);
+        assertThat(adsAt14.previousInsertionPosition(5)).isEqualTo(3);
+
+        assertThat(adsRepeating.previousInsertionPosition(0)).isEqualTo(NOT_FOUND);
+        assertThat(adsRepeating.previousInsertionPosition(1)).isEqualTo(NOT_FOUND);
+        assertThat(adsRepeating.previousInsertionPosition(2)).isEqualTo(NOT_FOUND);
+        assertThat(adsRepeating.previousInsertionPosition(3)).isEqualTo(2);
+        assertThat(adsRepeating.previousInsertionPosition(4)).isEqualTo(2);
+        assertThat(adsRepeating.previousInsertionPosition(5)).isEqualTo(4);
+        assertThat(adsRepeating.previousInsertionPosition(6)).isEqualTo(4);
+        assertThat(adsRepeating.previousInsertionPosition(7)).isEqualTo(6);
+
+        assertThat(adsAt15repeating.previousInsertionPosition(0)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt15repeating.previousInsertionPosition(1)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt15repeating.previousInsertionPosition(2)).isEqualTo(1);
+        assertThat(adsAt15repeating.previousInsertionPosition(3)).isEqualTo(1);
+        assertThat(adsAt15repeating.previousInsertionPosition(4)).isEqualTo(1);
+        assertThat(adsAt15repeating.previousInsertionPosition(5)).isEqualTo(4);
+        assertThat(adsAt15repeating.previousInsertionPosition(6)).isEqualTo(4);
+        assertThat(adsAt15repeating.previousInsertionPosition(7)).isEqualTo(6);
+        assertThat(adsAt15repeating.previousInsertionPosition(8)).isEqualTo(6);
+        assertThat(adsAt15repeating.previousInsertionPosition(9)).isEqualTo(8);
+
+        assertThat(adsAt1234.previousInsertionPosition(0)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt1234.previousInsertionPosition(1)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt1234.previousInsertionPosition(2)).isEqualTo(1);
+        assertThat(adsAt1234.previousInsertionPosition(3)).isEqualTo(1);
+    }
+
+    @Test
+    public void initialState_isPlacedAd() {
+        assertThat(adsAt15repeating.isPlacedAd(0)).isFalse();
+        assertThat(adsAt15repeating.isPlacedAd(1)).isFalse();
+        assertThat(adsAt15repeating.isPlacedAd(10)).isFalse();
+        assertThat(adsAt15repeating.isPlacedAd(1000)).isFalse();
+
+        assertThat(noAds.isPlacedAd(0)).isFalse();
+        assertThat(noAds.isPlacedAd(1000)).isFalse();
+    }
+
+    @Test
+    public void initialState_getOriginalPosition() {
+        assertThat(adsAt15repeating.getOriginalPosition(0)).isEqualTo(0);
+        assertThat(adsAt15repeating.getOriginalPosition(1)).isEqualTo(1);
+        assertThat(adsAt15repeating.getOriginalPosition(10)).isEqualTo(10);
+        assertThat(adsAt15repeating.getOriginalPosition(1000)).isEqualTo(1000);
+
+        assertThat(noAds.getOriginalPosition(0)).isEqualTo(0);
+        assertThat(noAds.getOriginalPosition(1000)).isEqualTo(1000);
+    }
+
+    @Test
+    public void initialState_getOriginalCount() {
+        assertThat(adsAt15repeating.getOriginalCount(0)).isEqualTo(0);
+        assertThat(adsAt15repeating.getOriginalCount(1)).isEqualTo(1);
+        assertThat(adsAt15repeating.getOriginalCount(10)).isEqualTo(10);
+        assertThat(adsAt15repeating.getOriginalCount(1000)).isEqualTo(1000);
+
+        assertThat(noAds.getOriginalCount(0)).isEqualTo(0);
+        assertThat(noAds.getOriginalCount(1000)).isEqualTo(1000);
+    }
+
+    @Test
+    public void initialState_getAdjustedPosition() {
+        assertThat(adsAt15repeating.getAdjustedPosition(0)).isEqualTo(0);
+        assertThat(adsAt15repeating.getAdjustedPosition(1)).isEqualTo(1);
+        assertThat(adsAt15repeating.getAdjustedPosition(10)).isEqualTo(10);
+        assertThat(adsAt15repeating.getAdjustedPosition(1000)).isEqualTo(1000);
+
+        assertThat(noAds.getAdjustedPosition(0)).isEqualTo(0);
+        assertThat(noAds.getAdjustedPosition(1000)).isEqualTo(1000);
+    }
+
+    @Test
+    public void initialState_getAdjustedCount() {
+        assertThat(adsAt15repeating.getAdjustedCount(0)).isEqualTo(0);
+        assertThat(adsAt15repeating.getAdjustedCount(1)).isEqualTo(1);
+        assertThat(adsAt15repeating.getAdjustedCount(10)).isEqualTo(10);
+        assertThat(adsAt15repeating.getAdjustedCount(1000)).isEqualTo(1000);
+
+        assertThat(noAds.getAdjustedCount(0)).isEqualTo(0);
+        assertThat(noAds.getAdjustedCount(1000)).isEqualTo(1000);
+    }
+
+    @Test
+    public void placeAds_inOrder_shouldUpdatePositions() {
+        checkInsertionPositions(10, adsAt15repeating, 1, 4, 6, 8, 10);
+        checkPlacedPositions(20, adsAt15repeating);
+
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        checkInsertionPositions(10, adsAt15repeating, 5, 7, 9);
+        checkPlacedPositions(20, adsAt15repeating, 1);
+
+        adsAt15repeating.placeAd(5, mockNativeAdData);
+        checkInsertionPositions(10, adsAt15repeating, 8, 10);
+        checkPlacedPositions(20, adsAt15repeating, 1, 5);
+
+        adsAt15repeating.placeAd(8, mockNativeAdData);
+        checkInsertionPositions(10, adsAt15repeating);
+        checkPlacedPositions(20, adsAt15repeating, 1, 5, 8);
+    }
+
+    @Test
+    public void placeAds_outOfOrder_shouldUpdatePositions() {
+        checkInsertionPositions(10, adsAt15repeating, 1, 4, 6, 8, 10);
+        checkPlacedPositions(20, adsAt15repeating);
+
+        adsAt15repeating.placeAd(6, mockNativeAdData);
+        checkInsertionPositions(10, adsAt15repeating, 1, 4, 9);
+        checkPlacedPositions(20, adsAt15repeating, 6);
+
+        adsAt15repeating.placeAd(4, mockNativeAdData);
+        checkInsertionPositions(10, adsAt15repeating, 1, 10);
+        checkPlacedPositions(20, adsAt15repeating, 4, 7);
+
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        checkInsertionPositions(10, adsAt15repeating);
+        checkPlacedPositions(20, adsAt15repeating, 1, 5, 8);
+    }
+
+    @Test
+    public void placedAds_getOriginalPositionAndCount() {
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(5, mockNativeAdData);
+        adsAt15repeating.placeAd(8, mockNativeAdData);
+
+        assertThat(adsAt15repeating.getOriginalPosition(0)).isEqualTo(0);
+        assertThat(adsAt15repeating.getOriginalPosition(1)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt15repeating.getOriginalPosition(2)).isEqualTo(1);
+        assertThat(adsAt15repeating.getOriginalPosition(3)).isEqualTo(2);
+        assertThat(adsAt15repeating.getOriginalPosition(4)).isEqualTo(3);
+        assertThat(adsAt15repeating.getOriginalPosition(5)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt15repeating.getOriginalPosition(6)).isEqualTo(4);
+        assertThat(adsAt15repeating.getOriginalPosition(7)).isEqualTo(5);
+        assertThat(adsAt15repeating.getOriginalPosition(8)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt15repeating.getOriginalPosition(9)).isEqualTo(6);
+        assertThat(adsAt15repeating.getOriginalPosition(10)).isEqualTo(7);
+
+        assertThat(adsAt15repeating.getOriginalCount(0)).isEqualTo(0);
+        assertThat(adsAt15repeating.getOriginalCount(10)).isEqualTo(7);
+        assertThat(adsAt15repeating.getOriginalCount(20)).isEqualTo(17);
+    }
+
+    @Test
+    public void placedAds_getAdjustedPositionAndCount() {
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(5, mockNativeAdData);
+        adsAt15repeating.placeAd(8, mockNativeAdData);
+
+        assertThat(adsAt15repeating.getAdjustedPosition(0)).isEqualTo(0);
+        // Ad here
+        assertThat(adsAt15repeating.getAdjustedPosition(1)).isEqualTo(2);
+        assertThat(adsAt15repeating.getAdjustedPosition(2)).isEqualTo(3);
+        assertThat(adsAt15repeating.getAdjustedPosition(3)).isEqualTo(4);
+        // Ad here
+        assertThat(adsAt15repeating.getAdjustedPosition(4)).isEqualTo(6);
+        assertThat(adsAt15repeating.getAdjustedPosition(5)).isEqualTo(7);
+        // Ad here
+        assertThat(adsAt15repeating.getAdjustedPosition(6)).isEqualTo(9);
+        assertThat(adsAt15repeating.getAdjustedPosition(7)).isEqualTo(10);
+        assertThat(adsAt15repeating.getAdjustedPosition(8)).isEqualTo(11);
+        assertThat(adsAt15repeating.getAdjustedPosition(9)).isEqualTo(12);
+        assertThat(adsAt15repeating.getAdjustedPosition(10)).isEqualTo(13);
+
+        assertThat(adsAt15repeating.getAdjustedCount(0)).isEqualTo(0);
+        assertThat(adsAt15repeating.getAdjustedCount(10)).isEqualTo(13);
+        assertThat(adsAt15repeating.getAdjustedCount(20)).isEqualTo(23);
+    }
+
+    @Test
+    public void placeAdsClumped_shouldPlaceAdsInOrder() {
+        int nextPosition = adsAt1234.nextInsertionPosition(0);
+        adsAt1234.placeAd(nextPosition, mockNativeAdData);
+
+        nextPosition = adsAt1234.nextInsertionPosition(nextPosition);
+        adsAt1234.placeAd(nextPosition, mockNativeAdData2);
+
+        nextPosition = adsAt1234.nextInsertionPosition(nextPosition);
+        adsAt1234.placeAd(nextPosition, mockNativeAdData3);
+
+        nextPosition = adsAt1234.nextInsertionPosition(nextPosition);
+        adsAt1234.placeAd(nextPosition, mockNativeAdData4);
+
+        nextPosition = adsAt1234.nextInsertionPosition(nextPosition);
+        assertThat(nextPosition).isEqualTo(NOT_FOUND);
+
+        assertThat(adsAt1234.isPlacedAd(0)).isFalse();
+        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mockNativeAdData);
+        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mockNativeAdData2);
+        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData3);
+        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mockNativeAdData4);
+        assertThat(adsAt1234.isPlacedAd(5)).isFalse();
+    }
+
+    @Test
+    public void placeAdsClumped_thenRemoveContentBeforeClumpedAds_shouldShiftAds() {
+        adsAt1234.placeAd(1, mockNativeAdData);
+        adsAt1234.placeAd(2, mockNativeAdData2);
+        adsAt1234.placeAd(3, mockNativeAdData3);
+        adsAt1234.placeAd(4, mockNativeAdData4);
+
+        adsAt1234.removeItem(0);
+        assertThat(adsAt1234.getPlacedAd(0)).isEqualTo(mockNativeAdData);
+        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mockNativeAdData2);
+        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mockNativeAdData3);
+        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData4);
+        assertThat(adsAt1234.isPlacedAd(4)).isFalse();
+
+        adsAt1234.removeItem(0);
+        assertThat(adsAt1234.getPlacedAd(0)).isEqualTo(mockNativeAdData);
+        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mockNativeAdData2);
+        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mockNativeAdData3);
+        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData4);
+        assertThat(adsAt1234.isPlacedAd(4)).isFalse();
+    }
+
+    @Test
+    public void placeAdsClumped_thenRemoveContentAfterClumpedAds_shouldNotShiftAds() {
+        adsAt1234.placeAd(1, mockNativeAdData);
+        adsAt1234.placeAd(2, mockNativeAdData2);
+        adsAt1234.placeAd(3, mockNativeAdData3);
+        adsAt1234.placeAd(4, mockNativeAdData4);
+
+        adsAt1234.removeItem(1);
+        assertThat(adsAt1234.isPlacedAd(0)).isFalse();
+        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mockNativeAdData);
+        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mockNativeAdData2);
+        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData3);
+        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mockNativeAdData4);
+        assertThat(adsAt1234.isPlacedAd(5)).isFalse();
+
+        adsAt1234.removeItem(2);
+        assertThat(adsAt1234.isPlacedAd(0)).isFalse();
+        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mockNativeAdData);
+        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mockNativeAdData2);
+        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData3);
+        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mockNativeAdData4);
+        assertThat(adsAt1234.isPlacedAd(5)).isFalse();
+    }
+
+    @Test
+    public void placeAdsClumped_thenInsertContentBeforeClumpedAds_shouldShiftAds() {
+        adsAt1234.placeAd(1, mockNativeAdData);
+        adsAt1234.placeAd(2, mockNativeAdData2);
+        adsAt1234.placeAd(3, mockNativeAdData3);
+        adsAt1234.placeAd(4, mockNativeAdData4);
+
+        adsAt1234.insertItem(1);
+        assertThat(adsAt1234.isPlacedAd(0)).isFalse();
+        assertThat(adsAt1234.isPlacedAd(1)).isFalse();
+        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mockNativeAdData);
+        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData2);
+        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mockNativeAdData3);
+        assertThat(adsAt1234.getPlacedAd(5)).isEqualTo(mockNativeAdData4);
+        assertThat(adsAt1234.isPlacedAd(6)).isFalse();
+
+        adsAt1234.insertItem(0);
+        assertThat(adsAt1234.isPlacedAd(0)).isFalse();
+        assertThat(adsAt1234.isPlacedAd(1)).isFalse();
+        assertThat(adsAt1234.isPlacedAd(2)).isFalse();
+        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData);
+        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mockNativeAdData2);
+        assertThat(adsAt1234.getPlacedAd(5)).isEqualTo(mockNativeAdData3);
+        assertThat(adsAt1234.getPlacedAd(6)).isEqualTo(mockNativeAdData4);
+        assertThat(adsAt1234.isPlacedAd(7)).isFalse();
+    }
+
+    @Test
+    public void placeAdsClumped_thenInsertContentAfterClumpedAds_shouldNotShiftAds() {
+        adsAt1234.placeAd(1, mockNativeAdData);
+        adsAt1234.placeAd(2, mockNativeAdData2);
+        adsAt1234.placeAd(3, mockNativeAdData3);
+        adsAt1234.placeAd(4, mockNativeAdData4);
+
+        adsAt1234.insertItem(2);
+        assertThat(adsAt1234.isPlacedAd(0)).isFalse();
+        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mockNativeAdData);
+        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mockNativeAdData2);
+        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData3);
+        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mockNativeAdData4);
+        assertThat(adsAt1234.isPlacedAd(5)).isFalse();
+
+        adsAt1234.removeItem(3);
+        assertThat(adsAt1234.isPlacedAd(0)).isFalse();
+        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mockNativeAdData);
+        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mockNativeAdData2);
+        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData3);
+        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mockNativeAdData4);
+        assertThat(adsAt1234.isPlacedAd(5)).isFalse();
+    }
+
+    @Test
+    public void placedAds_thenClearEmptyRange_doesNothing() {
+        checkPlacedPositions(15, adsAt15repeating);
+        checkPlacedPositions(15, adsAt15repeating);
+        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
+
+        adsAt15repeating.clearAdsInRange(0, 0);
+        checkPlacedPositions(15, adsAt15repeating);
+        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
+
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(5, mockNativeAdData);
+        adsAt15repeating.placeAd(8, mockNativeAdData);
+        checkPlacedPositions(15, adsAt15repeating, 1, 5, 8);
+        checkInsertionPositions(15, adsAt15repeating, 11, 13, 15);
+
+        adsAt15repeating.clearAdsInRange(4, 4);
+        checkPlacedPositions(15, adsAt15repeating, 1, 5, 8);
+        checkInsertionPositions(15, adsAt15repeating, 11, 13, 15);
+    }
+
+    @Test
+    public void placedAds_thenClearAll_shouldResetInsertionPositions() {
+        checkPlacedPositions(15, adsAt15repeating);
+        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
+
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(5, mockNativeAdData);
+        adsAt15repeating.placeAd(8, mockNativeAdData);
+        checkPlacedPositions(15, adsAt15repeating, 1, 5, 8);
+        checkInsertionPositions(15, adsAt15repeating, 11, 13, 15);
+
+        adsAt15repeating.clearAdsInRange(1, 10);
+        checkPlacedPositions(15, adsAt15repeating);
+        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
+    }
+
+    @Test
+    public void placedAds_thenClearRange_inOrder_shouldResetInsertionPositions() {
+        checkPlacedPositions(15, adsAt15repeating);
+        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
+
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(5, mockNativeAdData);
+        adsAt15repeating.placeAd(8, mockNativeAdData);
+        checkPlacedPositions(15, adsAt15repeating, 1, 5, 8);
+        checkInsertionPositions(15, adsAt15repeating, 11, 13, 15);
+
+        adsAt15repeating.clearAdsInRange(1, 2);
+        checkPlacedPositions(15, adsAt15repeating, 4, 7);
+        checkInsertionPositions(15, adsAt15repeating, 1, 10, 12, 14);
+
+        adsAt15repeating.clearAdsInRange(4, 5);
+        checkPlacedPositions(15, adsAt15repeating, 6);
+        checkInsertionPositions(15, adsAt15repeating, 1, 4, 9, 11, 13, 15);
+
+        adsAt15repeating.clearAdsInRange(6, 7);
+        checkPlacedPositions(15, adsAt15repeating);
+        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
+    }
+
+    @Test
+    public void placedAds_thenClearRange_descending_shouldResetInsertionPositions() {
+        checkPlacedPositions(15, adsAt15repeating);
+        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
+
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(5, mockNativeAdData);
+        adsAt15repeating.placeAd(8, mockNativeAdData);
+        checkPlacedPositions(15, adsAt15repeating, 1, 5, 8);
+        checkInsertionPositions(15, adsAt15repeating, 11, 13, 15);
+
+        adsAt15repeating.clearAdsInRange(8, 9);
+        checkPlacedPositions(15, adsAt15repeating, 1, 5);
+        checkInsertionPositions(15, adsAt15repeating, 8, 10, 12, 14);
+
+        adsAt15repeating.clearAdsInRange(5, 6);
+        checkPlacedPositions(15, adsAt15repeating, 1);
+        checkInsertionPositions(15, adsAt15repeating, 5, 7, 9, 11, 13, 15);
+
+        adsAt15repeating.clearAdsInRange(1, 2);
+        checkPlacedPositions(15, adsAt15repeating);
+        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
+    }
+
+    @Test
+    public void placedAds_thenClearRange_multiple_shouldResetInsertionPositions() {
+        checkPlacedPositions(15, adsAt15repeating);
+        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
+
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(5, mockNativeAdData);
+        adsAt15repeating.placeAd(8, mockNativeAdData);
+        checkPlacedPositions(15, adsAt15repeating, 1, 5, 8);
+        checkInsertionPositions(15, adsAt15repeating, 11, 13, 15);
+
+        adsAt15repeating.clearAdsInRange(1, 6);
+        checkPlacedPositions(15, adsAt15repeating, 6);
+        checkInsertionPositions(15, adsAt15repeating, 1, 4, 9, 11, 13, 15);
+
+        adsAt15repeating.clearAdsInRange(5, 10);
+        checkPlacedPositions(15, adsAt15repeating);
+        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
+    }
+
+    @Test
+    public void placedAds_thenClearRange_descending_multiple_shouldResetInsertionPositions() {
+        checkPlacedPositions(15, adsAt15repeating);
+        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
+
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(5, mockNativeAdData);
+        adsAt15repeating.placeAd(8, mockNativeAdData);
+        checkPlacedPositions(15, adsAt15repeating, 1, 5, 8);
+        checkInsertionPositions(15, adsAt15repeating, 11, 13, 15);
+
+        adsAt15repeating.clearAdsInRange(5, 9);
+        checkPlacedPositions(15, adsAt15repeating, 1);
+        checkInsertionPositions(15, adsAt15repeating, 5, 7, 9, 11, 13, 15);
+
+        adsAt15repeating.clearAdsInRange(1, 5);
+        checkPlacedPositions(15, adsAt15repeating);
+        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
+    }
+
+    @Test
+    public void placeAds_thenClear_shouldCallDestroy() {
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(5, mockNativeAdData2);
+        adsAt15repeating.placeAd(8, mockNativeAdData3);
+
+        adsAt15repeating.clearAdsInRange(5, 10);
+        verify(mockNativeResponse, never()).destroy();
+        verify(mockNativeResponse2).destroy();
+        verify(mockNativeResponse3).destroy();
+    }
+
+    @Test
+    public void insertItems_afterPlacing() {
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(5, mockNativeAdData);
+        adsAt15repeating.placeAd(8, mockNativeAdData);
+
+        adsAt15repeating.insertItem(1);
+        adsAt15repeating.insertItem(4);
+        adsAt15repeating.insertItem(12);
+
+        checkPlacedPositions(20, adsAt15repeating, 2, 7, 10);
+    }
+
+    @Test
+    public void insertItems_beforePlacing() {
+        checkInsertionPositions(7, adsAt15repeating, 1, 4, 6);
+
+        adsAt15repeating.insertItem(4);
+        adsAt15repeating.insertItem(7);
+
+        checkInsertionPositions(9, adsAt15repeating, 1, 5, 8);
+    }
+
+    @Test
+    public void removeThenInsertItem_atZero_shouldBeAtZero() {
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(5, mockNativeAdData);
+        adsAt15repeating.placeAd(8, mockNativeAdData);
+
+        adsAt15repeating.removeItem(0);
+        checkPlacedPositions(20, adsAt15repeating, 0, 4, 7);
+        checkInsertionPositions(16, adsAt15repeating, 10, 12, 14, 16);
+
+        adsAt15repeating.insertItem(0);
+        checkPlacedPositions(20, adsAt15repeating, 1, 5, 8);
+        checkInsertionPositions(16, adsAt15repeating, 11, 13, 15);
+    }
+
+    @Test
+    public void placeThenInsertThenPlace() {
+        adsAt15repeating.placeAd(4, mockNativeAdData);
+        adsAt15repeating.insertItem(4);
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+
+        checkPlacedPositions(20, adsAt15repeating, 1, 6);
+    }
+
+    @Test
+    public void removeItems_afterPlacing() {
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(5, mockNativeAdData);
+        adsAt15repeating.placeAd(8, mockNativeAdData);
+
+        checkPlacedPositions(20, adsAt15repeating, 1, 5, 8);
+
+        adsAt15repeating.removeItem(3);
+        adsAt15repeating.removeItem(5);
+
+        checkPlacedPositions(20, adsAt15repeating, 1, 4, 7);
+
+        // Check the adjusted positions.
+        assertThat(adsAt15repeating.getAdjustedPosition(0)).isEqualTo(0);
+        assertThat(adsAt15repeating.getAdjustedPosition(1)).isEqualTo(2);
+        assertThat(adsAt15repeating.getAdjustedPosition(2)).isEqualTo(3);
+        assertThat(adsAt15repeating.getAdjustedPosition(3)).isEqualTo(5);
+        assertThat(adsAt15repeating.getAdjustedPosition(4)).isEqualTo(6);
+        assertThat(adsAt15repeating.getAdjustedPosition(5)).isEqualTo(8);
+    }
+
+    @Test
+    public void removeItemsBetweenAds_thenInsert_shouldClumpAds() {
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(5, mockNativeAdData);
+        adsAt15repeating.placeAd(8, mockNativeAdData);
+
+        adsAt15repeating.removeItem(4);
+        adsAt15repeating.removeItem(4);
+
+        checkPlacedPositions(20, adsAt15repeating, 1, 5, 6);
+
+        adsAt15repeating.insertItem(5);
+
+        checkPlacedPositions(20, adsAt15repeating, 1, 5, 6);
+
+        adsAt15repeating.insertItem(4);
+
+        checkPlacedPositions(20, adsAt15repeating, 1, 6, 7);
+    }
+
+    @Test
+    public void removeItems_beforePlacing() {
+        checkInsertionPositions(7, adsAt15repeating, 1, 4, 6);
+
+        adsAt15repeating.removeItem(4);
+
+        // Check insertion positions.
+        checkInsertionPositions(7, adsAt15repeating, 1, 4, 5, 7);
+    }
+
+    @Test
+    public void removeItem_withClumpedAdsBeforeIt_shouldCorrectlyRemoveItem() throws Exception {
+        adsRepeating.placeAd(2, mockNativeAdData);
+        adsRepeating.placeAd(5, mockNativeAdData);
+        adsRepeating.placeAd(8, mockNativeAdData);
+
+        checkPlacedPositions(20, adsRepeating, 2, 5, 8);
+        assertThat(adsRepeating.getAdjustedCount(7)).isEqualTo(10);
+
+        // Removing from the head will cause ads to pile up
+        adsRepeating.removeItem(0);
+        adsRepeating.removeItem(0);
+        adsRepeating.removeItem(0);
+        adsRepeating.removeItem(0);
+        adsRepeating.removeItem(0);
+        adsRepeating.removeItem(0);
+
+        checkPlacedPositions(20, adsRepeating, 0, 1, 2);
+
+        adsRepeating.removeItem(0);
+
+        checkPlacedPositions(20, adsRepeating, 0, 1, 2);
+    }
+
+    @Test
+    public void removeItems_afterClumpedAds_shouldStayClumped() {
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(5, mockNativeAdData);
+        adsAt15repeating.placeAd(8, mockNativeAdData);
+
+        adsAt15repeating.removeItem(4);
+        adsAt15repeating.removeItem(4);
+
+        checkPlacedPositions(20, adsAt15repeating, 1, 5, 6);
+
+        // Shouldn't move any ads.
+        adsAt15repeating.removeItem(4);
+
+        checkPlacedPositions(20, adsAt15repeating, 1, 5, 6);
+
+        adsAt15repeating.removeItem(3);
+
+        checkPlacedPositions(20, adsAt15repeating, 1, 4, 5);
+    }
+
+    @Test
+    public void moveItems_afterPlacing() {
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(5, mockNativeAdData);
+        adsAt15repeating.placeAd(8, mockNativeAdData);
+
+        assertThat(adsAt15repeating.getAdjustedPosition(4)).isEqualTo(6);
+        assertThat(adsAt15repeating.getAdjustedPosition(5)).isEqualTo(7);
+
+        adsAt15repeating.moveItem(4, 2);
+
+        checkPlacedPositions(20, adsAt15repeating, 1, 6, 8);
+
+        assertThat(adsAt15repeating.getAdjustedPosition(4)).isEqualTo(5);
+        assertThat(adsAt15repeating.getAdjustedPosition(5)).isEqualTo(7);
+    }
+
+    @Test
+    public void clearAll_shouldCallDestroyOnAdData_shouldResetPositions() {
+        when(mockNativeAdData.getAd()).thenReturn(mockNativeResponse);
+        when(mockNativeAdData2.getAd()).thenReturn(mockNativeResponse2);
+        when(mockNativeAdData3.getAd()).thenReturn(mockNativeResponse3);
+
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(5, mockNativeAdData2);
+        adsAt15repeating.placeAd(8, mockNativeAdData3);
+
+        adsAt15repeating.clearAds();
+
+        verify(mockNativeResponse).destroy();
+        verify(mockNativeResponse2).destroy();
+        verify(mockNativeResponse3).destroy();
+
+        // Should reset to original positions
+        checkInsertionPositions(10, adsAt15repeating, 1, 4, 6, 8, 10);
+        checkPlacedPositions(20, adsAt15repeating);
+    }
+
+    void checkInsertionPositions(int maxValue, PlacementData placementData, Integer... positions) {
+        List<Integer> expected = Arrays.asList(positions);
+        List<Integer> actual = new ArrayList<Integer>();
+        for (int i = 0; i <= maxValue; i++) {
+            if (placementData.shouldPlaceAd(i)) {
+                actual.add(i);
+            }
+        }
+
+        assertThat(actual).isEqualTo(expected);
+    }
+
+    void checkPlacedPositions(int maxValue, PlacementData placementData, Integer... positions) {
+        List<Integer> expected = Arrays.asList(positions);
+        List<Integer> actual = new ArrayList<Integer>();
+        for (int i = 0; i < maxValue; i++) {
+            if (placementData.isPlacedAd(i)) {
+                actual.add(i);
+                assertThat(placementData.getPlacedAd(i)).isEqualTo(mockNativeAdData);
+            } else {
+                assertThat(placementData.getPlacedAd(i)).isNull();
+            }
+        }
+
+        assertThat(actual).isEqualTo(expected);
+
+        // Also check getPlacedAdPositions
+        List<Integer> actualFromAdPositions = new ArrayList<Integer>();
+        for (Integer position : placementData.getPlacedAdPositions()) {
+            actualFromAdPositions.add(position);
+        }
+        assertThat(actualFromAdPositions).isEqualTo(expected);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/VisibilityTrackerTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/VisibilityTrackerTest.java
index 7cccfbc5..bee7ae9e 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/VisibilityTrackerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/VisibilityTrackerTest.java
@@ -1,338 +1,339 @@
-package com.mopub.nativeads;
-
-import android.app.Activity;
-import android.graphics.Rect;
-import android.os.Handler;
-import android.os.SystemClock;
-import android.view.View;
-import android.view.ViewParent;
-import android.view.ViewTreeObserver;
-import android.view.Window;
-
-import com.mopub.nativeads.VisibilityTracker.TrackingInfo;
-import com.mopub.common.test.support.SdkTestRunner;
-
-import org.fest.util.Lists;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Mock;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.shadows.ShadowSystemClock;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-import java.util.WeakHashMap;
-
-import static android.view.ViewTreeObserver.OnPreDrawListener;
-import static com.mopub.nativeads.VisibilityTracker.VisibilityChecker;
-import static com.mopub.nativeads.VisibilityTracker.VisibilityTrackerListener;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-@RunWith(SdkTestRunner.class)
-public class VisibilityTrackerTest {
-    private static final int MIN_PERCENTAGE_VIEWED = 50;
-
-    private Activity activity;
-    private VisibilityTracker subject;
-    private Map<View, TrackingInfo> trackedViews;
-    private VisibilityChecker visibilityChecker;
-
-    @Mock private VisibilityTrackerListener visibilityTrackerListener;
-    @Mock private View view;
-    @Mock private View view2;
-    @Mock private Handler visibilityHandler;
-
-    @Before
-    public void setUp() throws Exception {
-        trackedViews = new WeakHashMap<View, TrackingInfo>();
-        visibilityChecker = new VisibilityChecker();
-        activity = new Activity();
-        view = createViewMock(View.VISIBLE, 100, 100, 100, 100, true, true);
-        view2 = createViewMock(View.VISIBLE, 100, 100, 100, 100, true, true);
-
-        // Add a proxy listener to that makes a safe copy of the listener args.
-        VisibilityTrackerListener proxyListener = new VisibilityTrackerListener() {
-            @Override
-            public void onVisibilityChanged(List<View> visibleViews, List<View> invisibleViews) {
-                ArrayList<View> safeVisibleViews = new ArrayList<View>(visibleViews);
-                ArrayList<View> safeInVisibleViews = new ArrayList<View>(invisibleViews);
-                visibilityTrackerListener.onVisibilityChanged(safeVisibleViews, safeInVisibleViews);
-            }
-        };
-        subject = new VisibilityTracker(activity, trackedViews, visibilityChecker, visibilityHandler);
-        subject.setVisibilityTrackerListener(proxyListener);
-
-        // XXX We need this to ensure that our SystemClock starts
-        ShadowSystemClock.uptimeMillis();
-    }
-
-    @Test
-    public void constructor_shouldSetOnPreDrawListenerForDecorView() throws Exception {
-        Activity activity1 = mock(Activity.class);
-        Window window = mock(Window.class);
-        View decorView = mock(View.class);
-        ViewTreeObserver viewTreeObserver = mock(ViewTreeObserver.class);
-
-        when(activity1.getWindow()).thenReturn(window);
-        when(window.getDecorView()).thenReturn(decorView);
-        when(decorView.getViewTreeObserver()).thenReturn(viewTreeObserver);
-        when(viewTreeObserver.isAlive()).thenReturn(true);
-
-        subject = new VisibilityTracker(activity1, trackedViews, visibilityChecker, visibilityHandler);
-        assertThat(subject.mRootView.get()).isEqualTo(decorView);
-        assertThat(subject.mOnPreDrawListener).isNotNull();
-        verify(viewTreeObserver).addOnPreDrawListener(subject.mOnPreDrawListener);
-    }
-
-    @Test
-    public void constructor_withNonAliveViewTreeObserver_shouldNotSetOnPreDrawListenerForDecorView() throws Exception {
-        Activity activity1 = mock(Activity.class);
-        Window window = mock(Window.class);
-        View decorView = mock(View.class);
-        ViewTreeObserver viewTreeObserver = mock(ViewTreeObserver.class);
-
-        when(activity1.getWindow()).thenReturn(window);
-        when(window.getDecorView()).thenReturn(decorView);
-        when(decorView.getViewTreeObserver()).thenReturn(viewTreeObserver);
-        when(viewTreeObserver.isAlive()).thenReturn(false);
-
-        subject = new VisibilityTracker(activity1, trackedViews, visibilityChecker, visibilityHandler);
-        assertThat(subject.mRootView.get()).isEqualTo(decorView);
-        assertThat(subject.mOnPreDrawListener).isNull();
-        verify(viewTreeObserver, never()).addOnPreDrawListener(subject.mOnPreDrawListener);
-    }
-
-    @Test
-    public void addView_withVisibleView_shouldAddVisibleViewToTrackedViews() throws Exception {
-        subject.addView(view, MIN_PERCENTAGE_VIEWED);
-
-        assertThat(trackedViews).hasSize(1);
-    }
-
-    @Test(expected = AssertionError.class)
-    public void addView_whenViewIsNull_shouldThrowNPE() throws Exception {
-        subject.addView(null, MIN_PERCENTAGE_VIEWED);
-
-        assertThat(trackedViews).isEmpty();
-    }
-
-    @Test
-    public void removeView_shouldRemoveFromTrackedViews() throws Exception {
-        subject.addView(view, MIN_PERCENTAGE_VIEWED);
-
-        assertThat(trackedViews).hasSize(1);
-        assertThat(trackedViews).containsKey(view);
-
-        subject.removeView(view);
-
-        assertThat(trackedViews).isEmpty();
-    }
-
-    @Test
-    public void clear_shouldRemoveAllViewsFromTrackedViews_shouldRemoveMessagesFromVisibilityHandler_shouldResetIsVisibilityScheduled() throws Exception {
-        subject.addView(view, MIN_PERCENTAGE_VIEWED);
-        subject.addView(view2, MIN_PERCENTAGE_VIEWED);
-        assertThat(trackedViews).hasSize(2);
-
-        subject.clear();
-
-        assertThat(trackedViews).isEmpty();
-        verify(visibilityHandler).removeMessages(0);
-    }
-
-    @Test
-    public void destroy_shouldCallClear_shouldRemoveListenerFromDecorView() throws Exception {
-        Activity activity1 = mock(Activity.class);
-        Window window = mock(Window.class);
-        View decorView = mock(View.class);
-        ViewTreeObserver viewTreeObserver = mock(ViewTreeObserver.class);
-
-        when(activity1.getWindow()).thenReturn(window);
-        when(window.getDecorView()).thenReturn(decorView);
-        when(decorView.getViewTreeObserver()).thenReturn(viewTreeObserver);
-        when(viewTreeObserver.isAlive()).thenReturn(true);
-
-        subject = new VisibilityTracker(activity1, trackedViews, visibilityChecker, visibilityHandler);
-
-        subject.addView(view, MIN_PERCENTAGE_VIEWED);
-        subject.addView(view2, MIN_PERCENTAGE_VIEWED);
-        assertThat(trackedViews).hasSize(2);
-
-        subject.destroy();
-
-        assertThat(trackedViews).isEmpty();
-        verify(visibilityHandler).removeMessages(0);
-        verify(viewTreeObserver).removeOnPreDrawListener(any(OnPreDrawListener.class));
-        assertThat(subject.mOnPreDrawListener).isNull();
-    }
-
-    @Test
-    public void visibilityRunnable_run_withVisibleView_shouldCallOnVisibleCallback() throws Exception {
-        subject.addView(view, MIN_PERCENTAGE_VIEWED);
-
-        subject.new VisibilityRunnable().run();
-
-        verify(visibilityTrackerListener).onVisibilityChanged(
-                Lists.newArrayList(view), Lists.<View>newArrayList());
-    }
-
-    @Test
-    public void visibilityRunnable_run_withNonVisibleView_shouldCallOnNonVisibleCallback() throws Exception {
-        when(view.getVisibility()).thenReturn(View.INVISIBLE);
-        subject.addView(view, MIN_PERCENTAGE_VIEWED);
-
-        subject.new VisibilityRunnable().run();
-
-        ArgumentCaptor<List> visibleCaptor = ArgumentCaptor.forClass(List.class);
-        ArgumentCaptor<List> invisibleCaptor = ArgumentCaptor.forClass(List.class);
-        verify(visibilityTrackerListener).onVisibilityChanged(visibleCaptor.capture(),
-                invisibleCaptor.capture());
-        assertThat(visibleCaptor.getValue().size()).isEqualTo(0);
-        assertThat(invisibleCaptor.getValue().size()).isEqualTo(1);
-    }
-
-    // VisibilityChecker tests
-
-    @Test
-    public void hasRequiredTimeElapsed_withElapsedTimeGreaterThanMinTimeViewed_shouldReturnTrue() throws Exception {
-        assertThat(visibilityChecker.hasRequiredTimeElapsed(SystemClock.uptimeMillis() - 501, 500)).isTrue();
-    }
-
-    @Test
-    public void hasRequiredTimeElapsed_withElapsedTimeLessThanMinTimeViewed_shouldReturnFalse() throws Exception {
-        assertThat(visibilityChecker.hasRequiredTimeElapsed(SystemClock.uptimeMillis() - 499, 500)).isFalse();
-    }
-
-    @Test
-    public void isMostlyVisible_whenParentIsNull_shouldReturnFalse() throws Exception {
-        view = createViewMock(View.VISIBLE, 100, 100, 100, 100, false, true);
-        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isFalse();
-    }
-
-    @Test
-    public void isMostlyVisible_whenViewIsOffScreen_shouldReturnFalse() throws Exception {
-        view = createViewMock(View.VISIBLE, 100, 100, 100, 100, true, false);
-        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isFalse();
-    }
-
-    @Test
-    public void isMostlyVisible_whenViewIsEntirelyOnScreen_shouldReturnTrue() throws Exception {
-        view = createViewMock(View.VISIBLE, 100, 100, 100, 100, true, true);
-
-        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isTrue();
-    }
-
-    @Test
-    public void isMostlyVisible_whenViewIs50PercentVisible_shouldReturnTrue() throws Exception {
-        view = createViewMock(View.VISIBLE, 50, 100, 100, 100, true, true);
-
-        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isTrue();
-    }
-
-    @Test
-    public void isMostlyVisible_whenViewIs49PercentVisible_shouldReturnFalse() throws Exception {
-        view = createViewMock(View.VISIBLE, 49, 100, 100, 100, true, true);
-
-        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isFalse();
-    }
-
-    @Test
-    public void isMostlyVisible_whenVisibleAreaIsZero_shouldReturnFalse() throws Exception {
-        view = createViewMock(View.VISIBLE, 0, 0, 100, 100, true, true);
-
-        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isFalse();
-    }
-
-    @Test
-    public void isMostlyVisible_whenViewIsInvisibleOrGone_shouldReturnFalse() throws Exception {
-        View view = createViewMock(View.INVISIBLE, 100, 100, 100, 100, true, true);
-        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isFalse();
-
-        reset(view);
-        view = createViewMock(View.GONE, 100, 100, 100, 100, true, true);
-        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isFalse();
-    }
-
-    @Test
-    public void isMostlyVisible_whenViewHasZeroWidthAndHeight_shouldReturnFalse() throws Exception {
-        view = createViewMock(View.VISIBLE, 100, 100, 0, 0, true, true);
-
-        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isFalse();
-    }
-
-    @Test
-    public void isMostlyVisible_whenViewIsNull_shouldReturnFalse() throws Exception {
-        assertThat(visibilityChecker.isVisible(null, MIN_PERCENTAGE_VIEWED)).isFalse();
-    }
-
-    @Test
-    public void addView_shouldClearViewAfterNumAccesses() {
-        // Access 1 time
-        subject.addView(view, MIN_PERCENTAGE_VIEWED);
-        assertThat(trackedViews).hasSize(1);
-
-        // Access 2-49 times
-        for (int i = 0; i < VisibilityTracker.NUM_ACCESSES_BEFORE_TRIMMING - 2; ++i) {
-            subject.addView(view2, MIN_PERCENTAGE_VIEWED);
-        }
-        assertThat(trackedViews).hasSize(2);
-
-        // 50th time
-        subject.addView(view2, MIN_PERCENTAGE_VIEWED);
-        assertThat(trackedViews).hasSize(2);
-
-        // 51-99
-        for (int i = 0; i < VisibilityTracker.NUM_ACCESSES_BEFORE_TRIMMING - 1; ++i) {
-            subject.addView(view2, MIN_PERCENTAGE_VIEWED);
-        }
-        assertThat(trackedViews).hasSize(2);
-
-        // 100
-        subject.addView(view2, MIN_PERCENTAGE_VIEWED);
-        assertThat(trackedViews).hasSize(1);
-    }
-
-    static View createViewMock(final int visibility,
-            final int visibleWidth,
-            final int visibleHeight,
-            final int viewWidth,
-            final int viewHeight,
-            final boolean isParentSet,
-            final boolean isOnScreen) {
-        View view = mock(View.class);
-        when(view.getContext()).thenReturn(new Activity());
-        when(view.getVisibility()).thenReturn(visibility);
-
-        when(view.getGlobalVisibleRect(any(Rect.class)))
-                .thenAnswer(new Answer<Boolean>() {
-                    @Override
-                    public Boolean answer(InvocationOnMock invocationOnMock) throws Throwable {
-                        Object[] args = invocationOnMock.getArguments();
-                        Rect rect = (Rect) args[0];
-                        rect.set(0, 0, visibleWidth, visibleHeight);
-                        return isOnScreen;
-                    }
-                });
-
-        when(view.getWidth()).thenReturn(viewWidth);
-        when(view.getHeight()).thenReturn(viewHeight);
-
-        if (isParentSet) {
-            when(view.getParent()).thenReturn(mock(ViewParent.class));
-        }
-
-        when(view.getViewTreeObserver()).thenCallRealMethod();
-
-        return view;
-    }
-}
+package com.mopub.nativeads;
+
+import android.app.Activity;
+import android.graphics.Rect;
+import android.os.Handler;
+import android.os.SystemClock;
+import android.view.View;
+import android.view.ViewParent;
+import android.view.ViewTreeObserver;
+import android.view.Window;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.nativeads.VisibilityTracker.TrackingInfo;
+
+import org.fest.util.Lists;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
+import org.robolectric.shadows.ShadowSystemClock;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.WeakHashMap;
+
+import static android.view.ViewTreeObserver.OnPreDrawListener;
+import static com.mopub.nativeads.VisibilityTracker.VisibilityChecker;
+import static com.mopub.nativeads.VisibilityTracker.VisibilityTrackerListener;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class VisibilityTrackerTest {
+    private static final int MIN_PERCENTAGE_VIEWED = 50;
+
+    private Activity activity;
+    private VisibilityTracker subject;
+    private Map<View, TrackingInfo> trackedViews;
+    private VisibilityChecker visibilityChecker;
+
+    @Mock private VisibilityTrackerListener visibilityTrackerListener;
+    @Mock private View view;
+    @Mock private View view2;
+    @Mock private Handler visibilityHandler;
+
+    @Before
+    public void setUp() throws Exception {
+        trackedViews = new WeakHashMap<View, TrackingInfo>();
+        visibilityChecker = new VisibilityChecker();
+        activity = Robolectric.buildActivity(Activity.class).create().get();
+        view = createViewMock(View.VISIBLE, 100, 100, 100, 100, true, true);
+        view2 = createViewMock(View.VISIBLE, 100, 100, 100, 100, true, true);
+
+        // Add a proxy listener to that makes a safe copy of the listener args.
+        VisibilityTrackerListener proxyListener = new VisibilityTrackerListener() {
+            @Override
+            public void onVisibilityChanged(List<View> visibleViews, List<View> invisibleViews) {
+                ArrayList<View> safeVisibleViews = new ArrayList<View>(visibleViews);
+                ArrayList<View> safeInVisibleViews = new ArrayList<View>(invisibleViews);
+                visibilityTrackerListener.onVisibilityChanged(safeVisibleViews, safeInVisibleViews);
+            }
+        };
+        subject = new VisibilityTracker(activity, trackedViews, visibilityChecker, visibilityHandler);
+        subject.setVisibilityTrackerListener(proxyListener);
+
+        // XXX We need this to ensure that our SystemClock starts
+        ShadowSystemClock.uptimeMillis();
+    }
+
+    @Test
+    public void constructor_shouldSetOnPreDrawListenerForDecorView() throws Exception {
+        Activity activity1 = mock(Activity.class);
+        Window window = mock(Window.class);
+        View decorView = mock(View.class);
+        ViewTreeObserver viewTreeObserver = mock(ViewTreeObserver.class);
+
+        when(activity1.getWindow()).thenReturn(window);
+        when(window.getDecorView()).thenReturn(decorView);
+        when(decorView.getViewTreeObserver()).thenReturn(viewTreeObserver);
+        when(viewTreeObserver.isAlive()).thenReturn(true);
+
+        subject = new VisibilityTracker(activity1, trackedViews, visibilityChecker, visibilityHandler);
+        assertThat(subject.mRootView.get()).isEqualTo(decorView);
+        assertThat(subject.mOnPreDrawListener).isNotNull();
+        verify(viewTreeObserver).addOnPreDrawListener(subject.mOnPreDrawListener);
+    }
+
+    @Test
+    public void constructor_withNonAliveViewTreeObserver_shouldNotSetOnPreDrawListenerForDecorView() throws Exception {
+        Activity activity1 = mock(Activity.class);
+        Window window = mock(Window.class);
+        View decorView = mock(View.class);
+        ViewTreeObserver viewTreeObserver = mock(ViewTreeObserver.class);
+
+        when(activity1.getWindow()).thenReturn(window);
+        when(window.getDecorView()).thenReturn(decorView);
+        when(decorView.getViewTreeObserver()).thenReturn(viewTreeObserver);
+        when(viewTreeObserver.isAlive()).thenReturn(false);
+
+        subject = new VisibilityTracker(activity1, trackedViews, visibilityChecker, visibilityHandler);
+        assertThat(subject.mRootView.get()).isEqualTo(decorView);
+        assertThat(subject.mOnPreDrawListener).isNull();
+        verify(viewTreeObserver, never()).addOnPreDrawListener(subject.mOnPreDrawListener);
+    }
+
+    @Test
+    public void addView_withVisibleView_shouldAddVisibleViewToTrackedViews() throws Exception {
+        subject.addView(view, MIN_PERCENTAGE_VIEWED);
+
+        assertThat(trackedViews).hasSize(1);
+    }
+
+    @Test(expected = AssertionError.class)
+    public void addView_whenViewIsNull_shouldThrowNPE() throws Exception {
+        subject.addView(null, MIN_PERCENTAGE_VIEWED);
+
+        assertThat(trackedViews).isEmpty();
+    }
+
+    @Test
+    public void removeView_shouldRemoveFromTrackedViews() throws Exception {
+        subject.addView(view, MIN_PERCENTAGE_VIEWED);
+
+        assertThat(trackedViews).hasSize(1);
+        assertThat(trackedViews).containsKey(view);
+
+        subject.removeView(view);
+
+        assertThat(trackedViews).isEmpty();
+    }
+
+    @Test
+    public void clear_shouldRemoveAllViewsFromTrackedViews_shouldRemoveMessagesFromVisibilityHandler_shouldResetIsVisibilityScheduled() throws Exception {
+        subject.addView(view, MIN_PERCENTAGE_VIEWED);
+        subject.addView(view2, MIN_PERCENTAGE_VIEWED);
+        assertThat(trackedViews).hasSize(2);
+
+        subject.clear();
+
+        assertThat(trackedViews).isEmpty();
+        verify(visibilityHandler).removeMessages(0);
+    }
+
+    @Test
+    public void destroy_shouldCallClear_shouldRemoveListenerFromDecorView() throws Exception {
+        Activity activity1 = mock(Activity.class);
+        Window window = mock(Window.class);
+        View decorView = mock(View.class);
+        ViewTreeObserver viewTreeObserver = mock(ViewTreeObserver.class);
+
+        when(activity1.getWindow()).thenReturn(window);
+        when(window.getDecorView()).thenReturn(decorView);
+        when(decorView.getViewTreeObserver()).thenReturn(viewTreeObserver);
+        when(viewTreeObserver.isAlive()).thenReturn(true);
+
+        subject = new VisibilityTracker(activity1, trackedViews, visibilityChecker, visibilityHandler);
+
+        subject.addView(view, MIN_PERCENTAGE_VIEWED);
+        subject.addView(view2, MIN_PERCENTAGE_VIEWED);
+        assertThat(trackedViews).hasSize(2);
+
+        subject.destroy();
+
+        assertThat(trackedViews).isEmpty();
+        verify(visibilityHandler).removeMessages(0);
+        verify(viewTreeObserver).removeOnPreDrawListener(any(OnPreDrawListener.class));
+        assertThat(subject.mOnPreDrawListener).isNull();
+    }
+
+    @Test
+    public void visibilityRunnable_run_withVisibleView_shouldCallOnVisibleCallback() throws Exception {
+        subject.addView(view, MIN_PERCENTAGE_VIEWED);
+
+        subject.new VisibilityRunnable().run();
+
+        verify(visibilityTrackerListener).onVisibilityChanged(
+                Lists.newArrayList(view), Lists.<View>newArrayList());
+    }
+
+    @Test
+    public void visibilityRunnable_run_withNonVisibleView_shouldCallOnNonVisibleCallback() throws Exception {
+        when(view.getVisibility()).thenReturn(View.INVISIBLE);
+        subject.addView(view, MIN_PERCENTAGE_VIEWED);
+
+        subject.new VisibilityRunnable().run();
+
+        ArgumentCaptor<List> visibleCaptor = ArgumentCaptor.forClass(List.class);
+        ArgumentCaptor<List> invisibleCaptor = ArgumentCaptor.forClass(List.class);
+        verify(visibilityTrackerListener).onVisibilityChanged(visibleCaptor.capture(),
+                invisibleCaptor.capture());
+        assertThat(visibleCaptor.getValue().size()).isEqualTo(0);
+        assertThat(invisibleCaptor.getValue().size()).isEqualTo(1);
+    }
+
+    // VisibilityChecker tests
+
+    @Test
+    public void hasRequiredTimeElapsed_withElapsedTimeGreaterThanMinTimeViewed_shouldReturnTrue() throws Exception {
+        assertThat(visibilityChecker.hasRequiredTimeElapsed(SystemClock.uptimeMillis() - 501, 500)).isTrue();
+    }
+
+    @Test
+    public void hasRequiredTimeElapsed_withElapsedTimeLessThanMinTimeViewed_shouldReturnFalse() throws Exception {
+        assertThat(visibilityChecker.hasRequiredTimeElapsed(SystemClock.uptimeMillis() - 499, 500)).isFalse();
+    }
+
+    @Test
+    public void isMostlyVisible_whenParentIsNull_shouldReturnFalse() throws Exception {
+        view = createViewMock(View.VISIBLE, 100, 100, 100, 100, false, true);
+        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isFalse();
+    }
+
+    @Test
+    public void isMostlyVisible_whenViewIsOffScreen_shouldReturnFalse() throws Exception {
+        view = createViewMock(View.VISIBLE, 100, 100, 100, 100, true, false);
+        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isFalse();
+    }
+
+    @Test
+    public void isMostlyVisible_whenViewIsEntirelyOnScreen_shouldReturnTrue() throws Exception {
+        view = createViewMock(View.VISIBLE, 100, 100, 100, 100, true, true);
+
+        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isTrue();
+    }
+
+    @Test
+    public void isMostlyVisible_whenViewIs50PercentVisible_shouldReturnTrue() throws Exception {
+        view = createViewMock(View.VISIBLE, 50, 100, 100, 100, true, true);
+
+        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isTrue();
+    }
+
+    @Test
+    public void isMostlyVisible_whenViewIs49PercentVisible_shouldReturnFalse() throws Exception {
+        view = createViewMock(View.VISIBLE, 49, 100, 100, 100, true, true);
+
+        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isFalse();
+    }
+
+    @Test
+    public void isMostlyVisible_whenVisibleAreaIsZero_shouldReturnFalse() throws Exception {
+        view = createViewMock(View.VISIBLE, 0, 0, 100, 100, true, true);
+
+        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isFalse();
+    }
+
+    @Test
+    public void isMostlyVisible_whenViewIsInvisibleOrGone_shouldReturnFalse() throws Exception {
+        View view = createViewMock(View.INVISIBLE, 100, 100, 100, 100, true, true);
+        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isFalse();
+
+        reset(view);
+        view = createViewMock(View.GONE, 100, 100, 100, 100, true, true);
+        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isFalse();
+    }
+
+    @Test
+    public void isMostlyVisible_whenViewHasZeroWidthAndHeight_shouldReturnFalse() throws Exception {
+        view = createViewMock(View.VISIBLE, 100, 100, 0, 0, true, true);
+
+        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isFalse();
+    }
+
+    @Test
+    public void isMostlyVisible_whenViewIsNull_shouldReturnFalse() throws Exception {
+        assertThat(visibilityChecker.isVisible(null, MIN_PERCENTAGE_VIEWED)).isFalse();
+    }
+
+    @Test
+    public void addView_shouldClearViewAfterNumAccesses() {
+        // Access 1 time
+        subject.addView(view, MIN_PERCENTAGE_VIEWED);
+        assertThat(trackedViews).hasSize(1);
+
+        // Access 2-49 times
+        for (int i = 0; i < VisibilityTracker.NUM_ACCESSES_BEFORE_TRIMMING - 2; ++i) {
+            subject.addView(view2, MIN_PERCENTAGE_VIEWED);
+        }
+        assertThat(trackedViews).hasSize(2);
+
+        // 50th time
+        subject.addView(view2, MIN_PERCENTAGE_VIEWED);
+        assertThat(trackedViews).hasSize(2);
+
+        // 51-99
+        for (int i = 0; i < VisibilityTracker.NUM_ACCESSES_BEFORE_TRIMMING - 1; ++i) {
+            subject.addView(view2, MIN_PERCENTAGE_VIEWED);
+        }
+        assertThat(trackedViews).hasSize(2);
+
+        // 100
+        subject.addView(view2, MIN_PERCENTAGE_VIEWED);
+        assertThat(trackedViews).hasSize(1);
+    }
+
+    static View createViewMock(final int visibility,
+            final int visibleWidth,
+            final int visibleHeight,
+            final int viewWidth,
+            final int viewHeight,
+            final boolean isParentSet,
+            final boolean isOnScreen) {
+        View view = mock(View.class);
+        when(view.getContext()).thenReturn(new Activity());
+        when(view.getVisibility()).thenReturn(visibility);
+
+        when(view.getGlobalVisibleRect(any(Rect.class)))
+                .thenAnswer(new Answer<Boolean>() {
+                    @Override
+                    public Boolean answer(InvocationOnMock invocationOnMock) throws Throwable {
+                        Object[] args = invocationOnMock.getArguments();
+                        Rect rect = (Rect) args[0];
+                        rect.set(0, 0, visibleWidth, visibleHeight);
+                        return isOnScreen;
+                    }
+                });
+
+        when(view.getWidth()).thenReturn(viewWidth);
+        when(view.getHeight()).thenReturn(viewHeight);
+
+        if (isParentSet) {
+            when(view.getParent()).thenReturn(mock(ViewParent.class));
+        }
+
+        when(view.getViewTreeObserver()).thenCallRealMethod();
+
+        return view;
+    }
+}
