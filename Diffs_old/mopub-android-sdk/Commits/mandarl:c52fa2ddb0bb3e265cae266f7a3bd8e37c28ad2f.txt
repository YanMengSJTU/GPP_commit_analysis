diff --git a/.gitmodules b/.gitmodules
deleted file mode 100644
index e69de29b..00000000
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 7d69bbf3..97db1038 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,7 +1,60 @@
-## Version 3.2.2 (October 29, 2014)
+## Version 3.7.0 (April 30, 2015)
+
+- Updated GooglePlayServices custom events to depend on the Google Play Services `play-services-ads 7.0.0` API.
+- Vungle support updated to SDK 3.3.3.
+- Updated InMobi and Greystripe custom events to accept application IDs from the MoPub UI.
+    - For InMobi: `{"app_id" : "YOUR_INMOBI_APP_ID"}`
+    - For Greystripe: `{"GUID" : "YOUR GREYSTRIPE_GUID"}`
+- Added toasts to the MoPub Sample App for ad load failures due to no connection.
+- Fixed a crash related to dismissing `MoPubBrowser` when zoom controls are visible; Fixes [issue #158](https://github.com/mopub/mopub-android-sdk/issues/158).
+- Fixed a bug in processing VAST progress trackers in a VAST wrapper tag.
+- Fixed a bug where ad refresh times could be incorrect when an ad request was not filled.
+- Updated the following dependencies:
+    - support-v4 AAR to 22.0.0
+    - support-annotations JAR to 22.0.0
+    - Android Maven Plugin to 4.2.0
+
+#### Version 3.6.1 (April 6, 2015)
+
+ - **Bug Fix** Fixed a compile error in FacebookBanner.java
+
+## Version 3.6.0 (April 3, 2015)
+
+ - **Facebook Update** Updated supported Facebook Audience Network version to 3.23.1
+ - **Bug fix** Fixed a bug where interstitials could leak memory; Fixes [issue #153](https://github.com/mopub/mopub-android-sdk/issues/153)
+ - **VAST Video** Updated the VAST video player to support Progress events.
+ - Updated **Volley** version to 1.1.0.
+
+## Version 3.5.0 (March 10, 2015)
+
+ - Dependency changes in Maven and Gradle. No new dependencies have been added, but your build script will need to change slightly to include JCenter. See our [Getting Started Guide](https://github.com/mopub/mopub-android-sdk/wiki/Getting-Started#adding-the-support-libraries-to-your-project) for complete instructions.
+ - Security Improvement: removed the @JavascriptInterface annotation for WebViews.
+ - Fixed a bug where video playback would sometimes fail to stop when an ad was dismissed.
+ - Fixed a bug where it was not possible to disable ad refresh; Fixes [issue #148](https://github.com/mopub/mopub-android-sdk/issues/148)
+ - Fixed a null pointer exception in AdViewController; Fixes [issue #150](https://github.com/mopub/mopub-android-sdk/issues/150)
+
+## Version 3.4.0 (January 30, 2015)
+
+  - **Volley networking stack** MoPub for Android now uses Google's Volley library for HTTP requests. You will need to add our bundled Volley JAR (available at `mopub-sdk/libs/mopub-volley-1.0.0.jar`) as a compile-time dependency. See instructions in our [integration page](https://dev.twitter.com/mopub/android/getting-started).
+  - **Updated Vungle Support** Certified the `VungleInterstitial` custom event against Vungle SDK 3.2.2
+  - **VAST Video Bug Fixes**
+    - Fixed inability to parse VAST tags referencing URLs that contain 3rd party macros
+    - VAST videos no longer fire completion trackers upon video playback error
+  - Added support for the `mopubnativebrowser://` click-destination scheme for Native, MRAID, and VAST ads (it was already supported for HTML ads). Links of this type (e.g. `mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.mopub.com`) will open the specified URL in the device's default browser, rather than in MoPub's in-app browser.
+
+## Version 3.3.0 (December 8, 2014)
+
+  - **MRAID 2.0 Support** - The MoPub SDK is now compliant with the MRAID 2.0 specification to enable rich media ads in banners and interstitial ad units. Learn more about MRAID from the [IAB](http://www.iab.net/MRAID#MRAID).
+  - **Location Polling Updates** - Changed the interaction between application- and device-provided location data: more recent location data is now always used (in the past, application-provided location data was always preferred).
+
+    As before, you may still disable MoPub SDK's location polling by calling `MoPub.setLocationAwareness(LocationAwareness.DISABLED)`.
+  - **Updated Chartboost SDK** Updated the `ChartboostInterstitial` custom event to support Chartboost SDK 5.0.4
+  - **Android Support Annotations** Introduced a dependency on android-support-annotations.jar to support code analysis of `@Nullable` and `@NonNull` annotations.
+
+#### Version 3.2.2 (October 29, 2014)
   - **Bug Fix** Fixes a bug in fetching the Google Advertising ID from Google Play Services.
 
-## Version 3.2.1 (October 21, 2014)
+#### Version 3.2.1 (October 21, 2014)
   - **Bug Fix** Fixes a bug in processing certain HTTP headers for Native Ads.
 
 ## Version 3.2.0 (October 17, 2014)
@@ -31,8 +84,7 @@
   - **Build target SDK is now API Level 19.** If you are building the MoPub SDK from source,
   modify your dependencies to reference Android 4.4.2, API Level 19. This does not affect the
   minimum device API level, which remains at API Level 9.
-  - **Source-level support for Gradle projects.** The SDK source now includes a build.gradle file
-   you can use to build source as part of your Gradle project.
+  - **Source-level support for Gradle projects.** The SDK source now includes a build.gradle file you can use to build source as part of your Gradle project.
   - **The SDK now uses Play Services 5.0.89**
   - **Bug fixes:**
     - Millennial Interstitial caching now properly handles request failures
@@ -75,6 +127,11 @@
     - Added support for companion banners (shown upon video completion)
   - Added Logcat warnings (and Toasts for debug builds) in cases where all necessary Activity permissions haven't been added to the `AndroidManifest`
 
+#### Version 2.0.1 (April 30, 2014)
+
+  - Fixed cases where VAST Video Interstitials were failing to fire `InterstitialAdListener` callbacks; fixes [GitHub issue #78](https://github.com/mopub/mopub-android-sdk/issues/78)
+  - Simplified click tracking logic for HTML ads
+
 ## Version 2.0 (April 22, 2014)
 
   - **Native Ads** public release; integration instructions and documentation available on the [GitHub wiki](https://github.com/mopub/mopub-android-sdk/wiki/Native-Ads-Integration)
@@ -82,8 +139,8 @@
   - Added support for Google Play Services advertising identifier
   - Renamed the `com.mopub.mobileads.MraidBrowser` Activity to `com.mopub.common.MoPubBrowser`.
       - **Important Note:** This change requires a modification to the `AndroidManifest`. The updated set of requisite activity permissions are as follows:
-      
-      	```      	      	
+
+      	```
     <activity android:name="com.mopub.common.MoPubBrowser"
 				android:configChanges="keyboardHidden|orientation"/>
     <activity android:name="com.mopub.mobileads.MoPubActivity"
@@ -92,58 +149,53 @@
                 android:configChanges="keyboardHidden|orientation"/>
 	<activity android:name="com.mopub.mobileads.MraidVideoPlayerActivity"
                 android:configChanges="keyboardHidden|orientation"/>
-		```  
+		```
   - Upgraded the bundled `android-support-v4` library to r19.1.
       - **Note for Maven users:** Newer versions of the `android-support-v4` artifact are unavailable on Maven central, so we have included a small script to update the version in your local artifact repository. Please navigate to the `mopub-sdk` directory, and run `scripts/mavenize_support_library`.
-      
-###### Version 2.0.1 (April 30, 2014)
 
-  - Fixed cases where VAST Video Interstitials were failing to fire `InterstitialAdListener` callbacks; fixes [GitHub issue #78](https://github.com/mopub/mopub-android-sdk/issues/78)
-  - Simplified click tracking logic for HTML ads
+#### Version 1.17.3.1 (March 24, 2014)
 
-## Version 1.17 (Nov 20, 2013)
+  - Restricted use of methods and fields that require API 4+ (`WebView#removeJavascriptInterface` and `ConnectivityManager`'s connection types)
 
-  - Support for VAST 2.0 video playback via MoPub Marketplace
-    - Short videos (less than 15 seconds) autoplay and and are unskippable
-    - Longer videos autoplay and are skippable after 5 seconds
-    - **Note:** The video cache can use up to 100 MB of internal storage. For developers sensitive to storage constraints, this value may be changed in `VastVideoInterstitial.CACHE_MAX_SIZE`.
-  - Updated InMobi custom event support to 4.0.0
-  - Added custom events for video ad network mediation, which can be found in the extras directory of the SDK (`/extras/src/com/mopub/mobileads/`)
-    - Added the `AdColonyInterstitial` custom event
-    - Added the `VungleInterstitial` custom event
-    - **Note:** Virtual currency callbacks (v4vc) are not supported for the above ad networks
-  - Enabled deeplinking via custom URIs in ad creatives
-  - All `WebView`s are removed from their parents before `destroy()`; fixes [GitHub issue #38](https://github.com/mopub/mopub-android-sdk/issues/38)
-  - Removed previously-deprecated `HTML5AdView`
-  
-### Version 1.17.3 (March 19, 2014)
+## Version 1.17.3 (March 19, 2014)
 
   - Added safeguards to prevent two different `MoPubInterstitial` objects from listening in on one other's lifecycle callbacks
   - Disabled Javascript loading into `destroy()`ed `WebView`s; fixes [GitHub issue #62](https://github.com/mopub/mopub-android-sdk/issues/62)
   - Fixed an `IllegalArgumentException` resulting from VAST videos with malformed redirect tags
   - MRAID ads that utilize `mraid.open()` now correctly record a click event
   - Added missing `FLAG_ACTIVITY_NEW_TASK` to `VastVideoView`'s intent creation; fixes part of [GitHub issue #56](https://github.com/mopub/mopub-android-sdk/issues/56)
-  
-###### Version 1.17.3.1 (March 24, 2014)
 
-  - Restricted use of methods and fields that require API 4+ (`WebView#removeJavascriptInterface` and `ConnectivityManager`'s connection types)
-  
-### Version 1.17.2 (February 20, 2014)
+## Version 1.17.2 (February 20, 2014)
 
   - Updated InMobi custom events to support InMobi SDK 4.0.3+ only
   - MRAID viewable property now correctly updates on viewability change
   - `MraidView` properly handles null schemes; fixes [GitHub issue #63](https://github.com/mopub/mopub-android-sdk/pull/63)
   - Internal disk LRU cache correctly hashes keys when checking for existing files
-  
-### Version 1.17.1 (January 23, 2014)
+
+#### Version 1.17.1.1 (February 5, 2014)
+  - Fixed bug that caused clicks to not be recorded in the MoPub UI (introduced in 1.17.1)
+
+## Version 1.17.1 (January 23, 2014)
 
   - Added custom events for Google Play Services. `GooglePlayServicesBanner` and `GooglePlayServicesInterstitial` can be found in the extras directory of the SDK (`/extras/src/com/mopub/mobileads`)
   - Resolved issues with missing annotations on `addJavascriptInterface` when `targetSdkVersion` is set to API level 17 or above
   - Updated MoPub sample application to allow in-app text entry of ad unit IDs
-    
-###### Version 1.17.1.1 (February 5, 2014)
-  - Fixed bug that caused clicks to not be recorded in the MoPub UI (introduced in 1.17.1)
-  
+
+## Version 1.17 (Nov 20, 2013)
+
+  - Support for VAST 2.0 video playback via MoPub Marketplace
+    - Short videos (less than 15 seconds) autoplay and and are unskippable
+    - Longer videos autoplay and are skippable after 5 seconds
+    - **Note:** The video cache can use up to 100 MB of internal storage. For developers sensitive to storage constraints, this value may be changed in `VastVideoInterstitial.CACHE_MAX_SIZE`.
+  - Updated InMobi custom event support to 4.0.0
+  - Added custom events for video ad network mediation, which can be found in the extras directory of the SDK (`/extras/src/com/mopub/mobileads/`)
+    - Added the `AdColonyInterstitial` custom event
+    - Added the `VungleInterstitial` custom event
+    - **Note:** Virtual currency callbacks (v4vc) are not supported for the above ad networks
+  - Enabled deeplinking via custom URIs in ad creatives
+  - All `WebView`s are removed from their parents before `destroy()`; fixes [GitHub issue #38](https://github.com/mopub/mopub-android-sdk/issues/38)
+  - Removed previously-deprecated `HTML5AdView`
+
 ## Version 1.16 (October 16, 2013)
 
   - Improved creative controls
@@ -158,50 +210,57 @@
   - Simplified internal construction and handling of `WebView`s by removing `WebViewPool` and its subclasses
   - Updated mraid.getVersion() to return 2.0
 
+#### Version 1.15.2.2 (September 20, 2013)
+  - Removed `WebSettings.setPluginsEnabled()` so the SDK builds against Android API 18; fixes [GitHub issue #28](https://github.com/mopub/mopub-android-sdk/issues/28)
+  - AdMob banners are now removed from the view hierarchy before they are destroyed; fixes the reopened [GitHub issue #23](https://github.com/mopub/mopub-android-sdk/issues/23)
+  - Prevent ads from launching system features, such as a browser view, until the user has interacted with the ad.
+
+#### Version 1.15.2.1 (September 13, 2013)
+  - Made the SDK more resilient to creatives that improperly use the `mopubnativebrowser://` scheme; fixes [GitHub issue #36](https://github.com/mopub/mopub-android-sdk/issues/36)
+
+## Version 1.15.2 (September 11, 2013)
+  - Allowed Facebook Support to be disabled optionally with `setFacebookSupported(false)`:
+  	- Use `MoPubInterstitial.setFacebookSupported(false);` for interstitials
+  	- Use `MoPubView.setFacebookSupported(false);` for banners
+  	- Note: the `setFacebookSupported(false)` method call must come __before__ `loadAd()`
+  	- Note: facebook support is on by default
+  - Changed banner refresh default to be 60 seconds when requests timed out
+  - Fixed edge case in Millennial Media ad fetch failure when there is no inventory; fixes [GitHub issue #18](https://github.com/mopub/mopub-android-sdk/issues/18)
+  - Fixed a bug where redirect URLs were malformed, causing the native browser to not render ads
+  - Updated Millennial Media jar to 5.1.0
+  - Updated Greystripe custom event support to 2.3.0
+  - Fixed MRAID 2.0 `storePicture` command's messaging when a picture either fails to download or fails to save to device
+  - Expanded MRAID 2.0 `createCalendarEvent` command to support both minute- and second-level granularity
+
+#### Version 1.15.1.1 (September 4, 2013)
+  - Made the SDK more resilient to unexpected Flash creatives
+
+## Version 1.15.1 (August 27, 2013)
+  - Updated documentation to remove the requirement for certain AndroidManifest permissions
+  - Fixed minor bug with MRAID 2.0 `storePicture` command where the user sees a false download completed message
+
 ## Version 1.15 (August 21, 2013)
 
 Includes support for ads in the MRAID 2.0 format. MRAID 2.0 allows advertisers to create ads with rich media functionality, including adding calendar events, storing pictures and playing videos in the native video player. To learn more about MRAID 2.0, read our [help article](http://j.mp/16MKSci).
 
   - Added the following MRAID 2.0 features: `createCalendarEvent` (Android 4.0 and above), `playVideo`, `storePicture`, and `supports`
-  - Hardware Acceleration is now enabled by default for `MraidInterstitial`s on Android 4.0 and above  
-  - Ensured that Cursors in `FacebookKeywordProvider` are always closed properly; fixes [GitHub issue #8](https://github.com/mopub/mopub-android-sdk/issues/8)  
-  - Added tracking parameter to InMobi ad requests; fixes [GitHub issue #15](https://github.com/mopub/mopub-android-sdk/issues/15)  
-  - Banner WebViews are now removed from the view hierarchy before they are destroyed; fixes [GitHub issue #23](https://github.com/mopub/mopub-android-sdk/issues/23)  
+  - Hardware Acceleration is now enabled by default for `MraidInterstitial`s on Android 4.0 and above
+  - Ensured that Cursors in `FacebookKeywordProvider` are always closed properly; fixes [GitHub issue #8](https://github.com/mopub/mopub-android-sdk/issues/8)
+  - Added tracking parameter to InMobi ad requests; fixes [GitHub issue #15](https://github.com/mopub/mopub-android-sdk/issues/15)
+  - Banner WebViews are now removed from the view hierarchy before they are destroyed; fixes [GitHub issue #23](https://github.com/mopub/mopub-android-sdk/issues/23)
 
-To correctly display ads that ask the user to save a picture (storePicture ads), you need to make the following change to AndroidManifest.xml:  
-* Add the`WRITE_EXTERNAL_STORAGE` permission. Note: **Adding the permission is optional**. If the permission is not added, we will not deliver any store picture ads to the users' devices. All other features will remain functional without the new permission. 
+To correctly display ads that ask the user to save a picture (storePicture ads), you need to make the following change to AndroidManifest.xml:
+* Add the`WRITE_EXTERNAL_STORAGE` permission. Note: **Adding the permission is optional**. If the permission is not added, we will not deliver any store picture ads to the users' devices. All other features will remain functional without the new permission.
 
-To allow users to play videos using the native video player:  
+To allow users to play videos using the native video player:
 * Declare activity `com.mopub.mobileads.MraidVideoPlayerActivity`. This activity is required to support playing videos in the native player and we strongly recommend adding it.
- 
-### Version 1.15.2 (September 11, 2013) 
-  - Allowed Facebook Support to be disabled optionally with `setFacebookSupported(false)`: 
-  	- Use `MoPubInterstitial.setFacebookSupported(false);` for interstitials 
-  	- Use `MoPubView.setFacebookSupported(false);` for banners 
-  	- Note: the `setFacebookSupported(false)` method call must come __before__ `loadAd()` 
-  	- Note: facebook support is on by default 
-  - Changed banner refresh default to be 60 seconds when requests timed out  
-  - Fixed edge case in Millennial Media ad fetch failure when there is no inventory; fixes [GitHub issue #18](https://github.com/mopub/mopub-android-sdk/issues/18)
-  - Fixed a bug where redirect URLs were malformed, causing the native browser to not render ads    
-  - Updated Millennial Media jar to 5.1.0
-  - Updated Greystripe custom event support to 2.3.0
-  - Fixed MRAID 2.0 `storePicture` command's messaging when a picture either fails to download or fails to save to device 
-  - Expanded MRAID 2.0 `createCalendarEvent` command to support both minute- and second-level granularity  
 
-###### Version 1.15.2.1 (September 13, 2013)
-  - Made the SDK more resilient to creatives that improperly use the `mopubnativebrowser://` scheme; fixes [GitHub issue #36](https://github.com/mopub/mopub-android-sdk/issues/36)
-   
-###### Version 1.15.2.2 (September 20, 2013)
-  - Removed `WebSettings.setPluginsEnabled()` so the SDK builds against Android API 18; fixes [GitHub issue #28](https://github.com/mopub/mopub-android-sdk/issues/28)
-  - AdMob banners are now removed from the view hierarchy before they are destroyed; fixes the reopened [GitHub issue #23](https://github.com/mopub/mopub-android-sdk/issues/23)
-  - Prevent ads from launching system features, such as a browser view, until the user has interacted with the ad.
- 
-### Version 1.15.1 (August 27, 2013)
-  - Updated documentation to remove the requirement for certain AndroidManifest permissions
-  - Fixed minor bug with MRAID 2.0 `storePicture` command where the user sees a false download completed message
-  
-###### Version 1.15.1.1 (September 4, 2013)
-  - Made the SDK more resilient to unexpected Flash creatives
+## Version 1.14.1 (June 21, 2013)
+  - Wait until after loaded interstitials are shown to report an impression
+  - Remove phantom impression tracking from interstitials
+  - Remove extra whitespace from Millennial banner ads
+  - Added `onInterstitialClicked()` notification to `InterstitialAdListener`
+  - Provide default implementations for `BannerAdListener` and `InterstitialAdListener`
 
 ## Version 1.14 (May 28, 2013)
 
@@ -209,14 +268,20 @@ To allow users to play videos using the native video player:
   - Removed reference to TYPE_DUMMY in AdUrlGenerator because it is not available in earlier versions of Android; fixes [GitHub issue #3](https://github.com/mopub/mopub-android-sdk/issues/3)
   - Fixed NPE in AdUrlGenerator when WiFi is off and Airplane mode is on; fixes [GitHub issue #5](https://github.com/mopub/mopub-android-sdk/issues/5)
   - `MraidInterstitial`s now properly notify `InterstitialAdListener` when they are shown and dismissed
-  
-### Version 1.14.1 (June 21, 2013)
-  - Wait until after loaded interstitials are shown to report an impression
-  - Remove phantom impression tracking from interstitials
-  - Remove extra whitespace from Millennial banner ads
-  - Added `onInterstitialClicked()` notification to `InterstitialAdListener`
-  - Provide default implementations for `BannerAdListener` and `InterstitialAdListener`
-  
+
+## Version 1.13.1 (May 21, 2013)
+  - Updated Millennial support to Millennial Media SDK version 5.0.1
+
+#### Version 1.13.0.2 (May 17, 2013)
+
+  - Relaxed access modifiers for `CustomEventBanner` and `CustomEventInterstitial`
+
+#### Version 1.13.0.1 (May 15, 2013)
+
+  - Removed extraneous display call in `MillennialInterstitial` custom event
+  - Fixed potential NPE in `AdView`'s loadUrl()
+  - Deprecated `HTML5AdView` after fixing some compilation issues
+
 ## Version 1.13 (May 9, 2013)
   - Moved all Android code and documentation to its own repository: [mopub-android-sdk](https://github.com/mopub/mopub-android-sdk)
   - Updated Millennial support to Millennial Media SDK version 5.0
@@ -225,19 +290,6 @@ To allow users to play videos using the native video player:
   - Removed obsolete native network adapters
   - Added timeout for third-party networks (10 seconds for banners and 30 seconds for interstitials)
   - Added more data signals (application version, connection type, and location accuracy)
-  
-### Version 1.13.1 (May 21, 2013)
-  - Updated Millennial support to Millennial Media SDK version 5.0.1
-
-###### Version 1.13.0.1 (May 15, 2013)
-
-  - Removed extraneous display call in `MillennialInterstitial` custom event
-  - Fixed potential NPE in `AdView`'s loadUrl()
-  - Deprecated `HTML5AdView` after fixing some compilation issues
-  
-###### Version 1.13.0.2 (May 17, 2013)
-
-  - Relaxed access modifiers for `CustomEventBanner` and `CustomEventInterstitial`
 
 ## Version 1.12 (April 26, 2013)
   - Chartboost custom event now automatically parses server data
@@ -286,7 +338,7 @@ To allow users to play videos using the native video player:
 ## Version 1.5 (May 10, 2012)
   - Added support for Millennial Media SDK 4.5.5
   - Fixed ANR relating to synchronization in `LoadUrlTask`
-  - Fixed IllegalArgumentExceptions when creating HttpGet objects with malformed URLs 
+  - Fixed IllegalArgumentExceptions when creating HttpGet objects with malformed URLs
 
 ## Version 1.4 (March 28, 2012)
   - Fixed some NullPointerExceptions in the AdMob and Millennial native adapters
diff --git a/README.md b/README.md
index 64b44d52..dc18ee75 100644
--- a/README.md
+++ b/README.md
@@ -4,7 +4,14 @@ Thanks for taking a look at MoPub! We take pride in having an easy-to-use, flexi
 
 Sign up for an account at [http://app.mopub.com/](http://app.mopub.com/).
 
-Help is available on the [wiki](https://github.com/mopub/mopub-android-sdk/wiki/Getting-Started).
+## Need Help?
+
+You can find integration documentation on our [wiki](https://github.com/mopub/mopub-android-sdk/wiki/Getting-Started) and
+additional help documentation on our [developer help site](http://dev.twitter.com/mopub). 
+
+To file an issue with our team visit the [MoPub Forum](https://twittercommunity.com/c/fabric/mopub). 
+
+**Note: We will be deprecating the use of GitHub issues in the near future and migrating all issues to the forum to provide a faster response time.**
 
 ## Download
 
@@ -27,11 +34,29 @@ Integration instructions are available on the [wiki](https://github.com/mopub/mo
 
 Please view the [changelog](https://github.com/mopub/mopub-android-sdk/blob/master/CHANGELOG.md) for details.
 
-  - **Bug Fixes**
+- Updated GooglePlayServices custom events to depend on the Google Play Services `play-services-ads 7.0.0` API.
+- Vungle support updated to SDK 3.3.3.
+- Updated InMobi and Greystripe custom events to accept application IDs from the MoPub UI.
+  - For InMobi: `{"app_id" : "YOUR_INMOBI_APP_ID"}`
+  - For Greystripe: `{"GUID" : "YOUR GREYSTRIPE_GUID"}`
+
+- Updated the following dependencies:
+	- support-v4 AAR to 22.0.0
+	- support-annotations JAR to 22.0.0
+	- Android Maven Plugin to 4.2.0
+	
+- Bug Fixes
 
 ## Requirements
 
-Android 2.3.1 (API Version 9) and up
+- Android 2.3.1 (API Version 9) and up
+- android-support-v4.jar, r22 (**Updated in 3.7.0**)
+- android-support-annotations.jar, r22 (**Updated in 3.7.0**)
+- MoPub Volley Library (mopub-volley-1.1.0.jar - available on JCenter) (**Updated in 3.6.0**)
+- **Recommended** Google Play Services 7.0.0
+
+## Upgrading from 3.2.0 and Prior
+In 3.3.0 a dependency on android-support-annotations.jar was added. If you are using Maven or Gradle to include the MoPub SDK, this dependency is included in the build scripts. For instructions on adding dependencies for Eclipse projects, see our [Getting Started Guide](https://github.com/mopub/mopub-android-sdk/wiki/Getting-Started#adding-the-support-libraries-to-your-project)
 
 ## License
 
diff --git a/build.gradle.bkp b/build.gradle.bkp
index a61d8f91..80cc530d 100644
--- a/build.gradle.bkp
+++ b/build.gradle.bkp
@@ -1,14 +1,14 @@
 buildscript {
-    repositories {   
+    repositories {
         mavenCentral()
+        jcenter()
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:0.12.1+'
-        classpath 'org.robolectric:robolectric-gradle-plugin:0.12.+'
+        classpath 'com.android.tools.build:gradle:1.0.0'
     }
 }
 
 task wrapper(type: Wrapper) {
-    gradleVersion = '1.12'
+    gradleVersion = '2.2.1'
 }
diff --git a/extras/src/com/mopub/mobileads/AdColonyInterstitial.java b/extras/src/com/mopub/mobileads/AdColonyInterstitial.java
index 6b542709..6e42be9c 100644
--- a/extras/src/com/mopub/mobileads/AdColonyInterstitial.java
+++ b/extras/src/com/mopub/mobileads/AdColonyInterstitial.java
@@ -15,8 +15,6 @@
 import java.util.concurrent.ScheduledThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 
-import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR;
-
 /*
  * Tested with AdColony SDK 2.0.3.
  */
@@ -36,10 +34,10 @@
     /*
      * These keys are intended for MoPub internal use. Do not modify.
      */
-    private static final String CLIENT_OPTIONS_KEY = "clientOptions";
-    private static final String APP_ID_KEY = "appId";
-    private static final String ALL_ZONE_IDS_KEY = "allZoneIds";
-    private static final String ZONE_ID_KEY = "zoneId";
+    public static final String CLIENT_OPTIONS_KEY = "clientOptions";
+    public static final String APP_ID_KEY = "appId";
+    public static final String ALL_ZONE_IDS_KEY = "allZoneIds";
+    public static final String ZONE_ID_KEY = "zoneId";
 
     private static boolean isAdColonyConfigured = false;
 
@@ -50,7 +48,7 @@
     private boolean mIsLoading;
 
     public AdColonyInterstitial() {
-        mScheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(10);
+        mScheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(1);
         mHandler = new Handler();
     }
 
@@ -60,7 +58,7 @@ protected void loadInterstitial(Context context,
                                     Map<String, Object> localExtras,
                                     Map<String, String> serverExtras) {
         if (!(context instanceof Activity)) {
-            customEventInterstitialListener.onInterstitialFailed(ADAPTER_CONFIGURATION_ERROR);
+            customEventInterstitialListener.onInterstitialFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
             return;
         }
 
diff --git a/extras/src/com/mopub/mobileads/AdColonyRewardedVideo.java b/extras/src/com/mopub/mobileads/AdColonyRewardedVideo.java
new file mode 100644
index 00000000..4d9baac4
--- /dev/null
+++ b/extras/src/com/mopub/mobileads/AdColonyRewardedVideo.java
@@ -0,0 +1,333 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.os.Handler;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.jirbo.adcolony.AdColony;
+import com.jirbo.adcolony.AdColonyAd;
+import com.jirbo.adcolony.AdColonyAdListener;
+import com.jirbo.adcolony.AdColonyV4VCAd;
+import com.jirbo.adcolony.AdColonyV4VCListener;
+import com.jirbo.adcolony.AdColonyV4VCReward;
+import com.mopub.common.BaseLifecycleListener;
+import com.mopub.common.DataKeys;
+import com.mopub.common.LifecycleListener;
+import com.mopub.common.MediationSettings;
+import com.mopub.common.MoPubReward;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Json;
+
+import java.util.Map;
+import java.util.WeakHashMap;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.ScheduledThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * A custom event for showing AdColony rewarded videos.
+ *
+ * Certified with AdColony 2.0.3
+ */
+public class AdColonyRewardedVideo extends CustomEventRewardedVideo {
+    /*
+     * We recommend passing the AdColony client options, app ID, all zone IDs, and current zone ID
+     * in the serverExtras Map by specifying Custom Event Data in MoPub's web interface.
+     *
+     * Please see AdColony's documentation for more information:
+     * https://github.com/AdColony/AdColony-Android-SDK/wiki/API-Details#configure-activity-activity-string-client_options-string-app_id-string-zone_ids-
+     */
+    private static final String DEFAULT_CLIENT_OPTIONS = "version=YOUR_APP_VERSION_HERE,store:google";
+    private static final String DEFAULT_APP_ID = "YOUR_AD_COLONY_APP_ID_HERE";
+    private static final String[] DEFAULT_ALL_ZONE_IDS = {"ZONE_ID_1", "ZONE_ID_2", "..."};
+    private static final String DEFAULT_ZONE_ID = "YOUR_CURRENT_ZONE_ID";
+
+    /*
+     * These keys are intended for MoPub internal use. Do not modify.
+     */
+    public static final String CLIENT_OPTIONS_KEY = "clientOptions";
+    public static final String APP_ID_KEY = "appId";
+    public static final String ALL_ZONE_IDS_KEY = "allZoneIds";
+    public static final String ZONE_ID_KEY = "zoneId";
+
+    private static boolean sInitialized = false;
+    private static LifecycleListener sLifecycleListener = new BaseLifecycleListener() {
+        @Override
+        public void onPause(@NonNull final Activity activity) {
+            super.onPause(activity);
+            AdColony.pause();
+        }
+
+        @Override
+        public void onResume(@NonNull final Activity activity) {
+            super.onResume(activity);
+            AdColony.resume(activity);
+        }
+    };
+    private static AdColonyListener sAdColonyListener = new AdColonyListener();
+    private static WeakHashMap<AdColonyAd, String> sAdToZoneIdMap = new WeakHashMap<AdColonyAd, String>();
+
+    private AdColonyV4VCAd mAd;
+    private String mZoneId;
+    @Nullable private String mAdUnitId;
+    private boolean mIsLoading = false;
+
+    // For waiting and notifying the SDK:
+    private final Handler mHandler;
+    private final ScheduledThreadPoolExecutor mScheduledThreadPoolExecutor;
+    private ScheduledFuture<?> mFuture;
+
+    public AdColonyRewardedVideo() {
+        mScheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(1);
+        mHandler = new Handler();
+    }
+
+    @Nullable
+    @Override
+    public CustomEventRewardedVideoListener getVideoListenerForSdk() {
+        return sAdColonyListener;
+    }
+
+    @Nullable
+    @Override
+    public LifecycleListener getLifecycleListener() {
+        return sLifecycleListener;
+    }
+
+    @NonNull
+    @Override
+    public String getAdNetworkId() {
+        return mZoneId;
+    }
+
+    @Override
+    protected void onInvalidate() {
+        mScheduledThreadPoolExecutor.shutdownNow();
+    }
+
+    @Override
+    public boolean checkAndInitializeSdk(@NonNull final Activity launcherActivity,
+            @NonNull final Map<String, Object> localExtras,
+            @NonNull final Map<String, String> serverExtras) throws Exception {
+        synchronized (AdColonyRewardedVideo.class) {
+            if (sInitialized) {
+                return false;
+            }
+
+            String adColonyClientOptions = DEFAULT_CLIENT_OPTIONS;
+            String adColonyAppId = DEFAULT_APP_ID;
+            String[] adColonyAllZoneIds = DEFAULT_ALL_ZONE_IDS;
+
+            // Set up serverExtras
+            if (extrasAreValid(serverExtras)) {
+                adColonyClientOptions = serverExtras.get(CLIENT_OPTIONS_KEY);
+                adColonyAppId = serverExtras.get(APP_ID_KEY);
+                adColonyAllZoneIds = extractAllZoneIds(serverExtras);
+            }
+
+            setUpGlobalSettings();
+            AdColony.configure(launcherActivity, adColonyClientOptions, adColonyAppId, adColonyAllZoneIds);
+            AdColony.addV4VCListener(sAdColonyListener);
+            sInitialized = true;
+            return true;
+        }
+    }
+
+    @Override
+    protected void loadWithSdkInitialized(@NonNull final Activity activity,
+            @NonNull final Map<String, Object> localExtras,
+            @NonNull final Map<String, String> serverExtras) throws Exception {
+
+        mZoneId = DEFAULT_ZONE_ID;
+        if (extrasAreValid(serverExtras)) {
+            mZoneId = serverExtras.get(ZONE_ID_KEY);
+        }
+        Object adUnitObject = localExtras.get(DataKeys.AD_UNIT_ID_KEY);
+        if (adUnitObject != null && adUnitObject instanceof String) {
+            mAdUnitId = (String) adUnitObject;
+        }
+
+        mAd = new AdColonyV4VCAd(mZoneId).withListener(sAdColonyListener);
+        sAdToZoneIdMap.put(mAd, mZoneId);
+        scheduleOnVideoReady();
+    }
+
+    @Override
+    public boolean hasVideoAvailable() {
+        return mAd != null && mAd.isReady() && mAd.getAvailableViews() != 0;
+    }
+
+    @Override
+    public void showVideo() {
+        if (this.hasVideoAvailable()) {
+            boolean withConfirmationDialog = getConfirmationDialogFromSettings();
+            boolean withResultsDialog = getResultsDialogFromSettings();
+            mAd.withConfirmationDialog(withConfirmationDialog).withResultsDialog(withResultsDialog).show();
+        } else {
+            MoPubRewardedVideoManager.onRewardedVideoPlaybackError(AdColonyRewardedVideo.class, mZoneId, MoPubErrorCode.VIDEO_PLAYBACK_ERROR);
+        }
+    }
+
+    private boolean extrasAreValid(Map<String, String> extras) {
+        return extras.containsKey(CLIENT_OPTIONS_KEY)
+                && extras.containsKey(APP_ID_KEY)
+                && extras.containsKey(ALL_ZONE_IDS_KEY)
+                && extras.containsKey(ZONE_ID_KEY);
+    }
+
+    private String[] extractAllZoneIds(Map<String, String> serverExtras) {
+        String[] result = Json.jsonArrayToStringArray(serverExtras.get(ALL_ZONE_IDS_KEY));
+
+        // AdColony requires at least one valid String in the allZoneIds array.
+        if (result.length == 0) {
+            result = new String[]{""};
+        }
+
+        return result;
+    }
+
+    private void setUpGlobalSettings() {
+        final AdColonyGlobalMediationSettings globalMediationSettings =
+                MoPubRewardedVideoManager.getGlobalMediationSettings(AdColonyGlobalMediationSettings.class);
+        if (globalMediationSettings != null) {
+            if (globalMediationSettings.getCustomId() != null) {
+                AdColony.setCustomID(globalMediationSettings.getCustomId());
+            }
+            if (globalMediationSettings.getDeviceId() != null) {
+                AdColony.setDeviceID(globalMediationSettings.getDeviceId());
+            }
+        }
+    }
+
+    private boolean getConfirmationDialogFromSettings() {
+        final AdColonyInstanceMediationSettings settings =
+                MoPubRewardedVideoManager.getInstanceMediationSettings(AdColonyInstanceMediationSettings.class, mAdUnitId);
+        return settings != null && settings.withConfirmationDialog();
+    }
+
+    private boolean getResultsDialogFromSettings() {
+        final AdColonyInstanceMediationSettings settings =
+                MoPubRewardedVideoManager.getInstanceMediationSettings(AdColonyInstanceMediationSettings.class, mAdUnitId);
+        return settings != null && settings.withResultsDialog();
+    }
+
+    private void scheduleOnVideoReady() {
+        Runnable runnable = new Runnable() {
+            @Override
+            public void run() {
+                if (mAd.isReady()) {
+                    mIsLoading = false;
+                    mScheduledThreadPoolExecutor.shutdownNow();
+                    mHandler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            if (mAd.getAvailableViews() > 0) {
+                                MoPubRewardedVideoManager.onRewardedVideoLoadSuccess(
+                                        AdColonyRewardedVideo.class,
+                                        mZoneId);
+                            } else {
+                                MoPubRewardedVideoManager.onRewardedVideoLoadFailure(
+                                        AdColonyRewardedVideo.class,
+                                        mZoneId,
+                                        MoPubErrorCode.NETWORK_NO_FILL);
+                            }
+                        }
+                    });
+                }
+            }
+        };
+
+        if (!mIsLoading) {
+            mScheduledThreadPoolExecutor.scheduleAtFixedRate(runnable, 1, 1, TimeUnit.SECONDS);
+            mIsLoading = true;
+        }
+    }
+
+    private static class AdColonyListener implements AdColonyAdListener,
+            AdColonyV4VCListener, CustomEventRewardedVideoListener {
+
+        @Override
+        public void onAdColonyAdAttemptFinished(final AdColonyAd adColonyAd) {
+            String zoneId = sAdToZoneIdMap.get(adColonyAd);
+            MoPubRewardedVideoManager.onRewardedVideoClosed(AdColonyRewardedVideo.class, zoneId);
+            if (adColonyAd.notShown()) {
+                if (adColonyAd.canceled() || adColonyAd.skipped()) {
+                    MoPubLog.d("User canceled ad playback");
+                    return;
+                }
+
+                MoPubErrorCode reason = MoPubErrorCode.VIDEO_DOWNLOAD_ERROR;
+                if (adColonyAd.noFill()) {
+                    reason = MoPubErrorCode.NETWORK_NO_FILL;
+                }
+
+                MoPubRewardedVideoManager.onRewardedVideoLoadFailure(
+                        AdColonyRewardedVideo.class,
+                        zoneId,
+                        reason);
+            }
+        }
+
+        @Override
+        public void onAdColonyAdStarted(final com.jirbo.adcolony.AdColonyAd adColonyAd) {
+            MoPubRewardedVideoManager.onRewardedVideoStarted(
+                    AdColonyRewardedVideo.class,
+                    sAdToZoneIdMap.get(adColonyAd));
+        }
+
+        @Override
+        public void onAdColonyV4VCReward(final AdColonyV4VCReward adColonyV4VCReward) {
+            MoPubReward reward;
+            if (adColonyV4VCReward.success()) {
+                reward = MoPubReward.success(adColonyV4VCReward.name(), adColonyV4VCReward.amount());
+            } else {
+                reward = MoPubReward.failure();
+            }
+            MoPubRewardedVideoManager.onRewardedVideoCompleted(
+                    AdColonyRewardedVideo.class,
+                    null, // Can't deduce the zoneId from this object.
+                    reward);
+        }
+    }
+
+    public static final class AdColonyGlobalMediationSettings implements MediationSettings {
+
+        @Nullable private final String mCustomId;
+        @Nullable private final String mDeviceId;
+
+        public AdColonyGlobalMediationSettings(@Nullable String customId, @Nullable String deviceId) {
+            mCustomId = customId;
+            mDeviceId = deviceId;
+        }
+
+        @Nullable
+        public String getCustomId() {
+            return mCustomId;
+        }
+
+        @Nullable
+        public String getDeviceId() {
+            return mDeviceId;
+        }
+    }
+
+    public static final class AdColonyInstanceMediationSettings implements MediationSettings {
+        private final boolean mWithConfirmationDialog;
+        private final boolean mWithResultsDialog;
+
+        public AdColonyInstanceMediationSettings(
+                boolean withConfirmationDialog, boolean withResultsDialog) {
+            mWithConfirmationDialog = withConfirmationDialog;
+            mWithResultsDialog = withResultsDialog;
+        }
+
+        public boolean withConfirmationDialog() {
+            return mWithConfirmationDialog;
+        }
+
+        public boolean withResultsDialog() {
+            return mWithResultsDialog;
+        }
+    }
+}
diff --git a/extras/src/com/mopub/mobileads/ChartboostInterstitial.java b/extras/src/com/mopub/mobileads/ChartboostInterstitial.java
index 3127790d..a1f3142d 100644
--- a/extras/src/com/mopub/mobileads/ChartboostInterstitial.java
+++ b/extras/src/com/mopub/mobileads/ChartboostInterstitial.java
@@ -3,13 +3,18 @@
 import android.app.Activity;
 import android.content.Context;
 import android.util.Log;
+
 import com.chartboost.sdk.Chartboost;
 import com.chartboost.sdk.ChartboostDelegate;
+import com.mopub.common.VisibleForTesting;
+
+import java.util.HashMap;
+import java.util.Map;
 
-import java.util.*;
+import static com.chartboost.sdk.Model.CBError.CBImpressionError;
 
 /*
- * Tested with Chartboost SDK 3.1.5.
+ * Tested with Chartboost SDK 5.0.4.
  */
 class ChartboostInterstitial extends CustomEventInterstitial {
     /*
@@ -19,6 +24,7 @@
     public static final String APP_SIGNATURE_KEY = "appSignature";
     public static final String LOCATION_KEY = "location";
     public static final String LOCATION_DEFAULT = "Default";
+
     private String appId;
     private String appSignature;
     private String location;
@@ -37,11 +43,6 @@ static SingletonChartboostDelegate getDelegate() {
         return SingletonChartboostDelegate.instance;
     }
 
-    @Deprecated // for test only
-    public static void resetDelegate() {
-        SingletonChartboostDelegate.instance = new SingletonChartboostDelegate();
-    }
-
     /*
      * Abstract methods from CustomEventInterstitial
      */
@@ -53,9 +54,6 @@ protected void loadInterstitial(Context context, CustomEventInterstitialListener
             return;
         }
 
-        Activity activity = (Activity) context;
-        Chartboost chartboost = Chartboost.sharedChartboost();
-
         if (extrasAreValid(serverExtras)) {
             setAppId(serverExtras.get(APP_ID_KEY));
             setAppSignature(serverExtras.get(APP_SIGNATURE_KEY));
@@ -68,6 +66,9 @@ protected void loadInterstitial(Context context, CustomEventInterstitialListener
             return;
         }
 
+        Activity activity = (Activity) context;
+        Chartboost.startWithAppId(activity, appId, appSignature);
+
         if (getDelegate().hasLocation(location) &&
                 getDelegate().getListener(location) != interstitialListener) {
             interstitialListener.onInterstitialFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
@@ -75,16 +76,19 @@ protected void loadInterstitial(Context context, CustomEventInterstitialListener
         }
 
         getDelegate().registerListener(location, interstitialListener);
-        chartboost.onCreate(activity, appId, appSignature, getDelegate());
-        chartboost.onStart(activity);
-
-        chartboost.cacheInterstitial(location);
+        Chartboost.setDelegate(getDelegate());
+        Chartboost.setAutoCacheAds(false);
+        Chartboost.setShouldRequestInterstitialsInFirstSession(true);
+        Chartboost.setShouldDisplayLoadingViewForMoreApps(false);
+        Chartboost.onCreate(activity);
+        Chartboost.onStart(activity);
+        Chartboost.cacheInterstitial(location);
     }
 
     @Override
     protected void showInterstitial() {
         Log.d("MoPub", "Showing Chartboost interstitial ad.");
-        Chartboost.sharedChartboost().showInterstitial(location);
+        Chartboost.showInterstitial(location);
     }
 
     @Override
@@ -108,7 +112,8 @@ private boolean extrasAreValid(Map<String, String> serverExtras) {
         return serverExtras.containsKey(APP_ID_KEY) && serverExtras.containsKey(APP_SIGNATURE_KEY);
     }
 
-    private static class SingletonChartboostDelegate implements ChartboostDelegate {
+    @VisibleForTesting
+    static class SingletonChartboostDelegate extends ChartboostDelegate {
         private static final CustomEventInterstitialListener NULL_LISTENER = new CustomEventInterstitialListener() {
             @Override public void onInterstitialLoaded() { }
             @Override public void onInterstitialFailed(MoPubErrorCode errorCode) { }
@@ -146,11 +151,6 @@ public boolean shouldRequestInterstitial(String location) {
             return true;
         }
 
-        @Override
-        public boolean shouldRequestInterstitialsInFirstSession() {
-            return true;
-        }
-
         @Override
         public void didCacheInterstitial(String location) {
             Log.d("MoPub", "Chartboost interstitial loaded successfully.");
@@ -158,8 +158,8 @@ public void didCacheInterstitial(String location) {
         }
 
         @Override
-        public void didFailToLoadInterstitial(String location) {
-            Log.d("MoPub", "Chartboost interstitial ad failed to load.");
+        public void didFailToLoadInterstitial(String location, CBImpressionError error) {
+            Log.d("MoPub", "Chartboost interstitial ad failed to load. Error: " + error.name());
             getListener(location).onInterstitialFailed(MoPubErrorCode.NETWORK_NO_FILL);
         }
 
@@ -181,7 +181,7 @@ public void didClickInterstitial(String location) {
         }
 
         @Override
-        public void didShowInterstitial(String location) {
+        public void didDisplayInterstitial(String location) {
             Log.d("MoPub", "Chartboost interstitial ad shown.");
             getListener(location).onInterstitialShown();
         }
@@ -190,42 +190,33 @@ public void didShowInterstitial(String location) {
          * More Apps delegate methods
          */
         @Override
-        public boolean shouldDisplayLoadingViewForMoreApps() {
+        public boolean shouldRequestMoreApps(String location) {
             return false;
         }
 
         @Override
-        public boolean shouldRequestMoreApps() {
+        public boolean shouldDisplayMoreApps(String location) {
             return false;
         }
 
         @Override
-        public boolean shouldDisplayMoreApps() {
-            return false;
-        }
-
-        @Override
-        public void didFailToLoadMoreApps() {
-        }
-
-        @Override
-        public void didCacheMoreApps() {
+        public void didFailToLoadMoreApps(String location, CBImpressionError error) {
         }
 
         @Override
-        public void didDismissMoreApps() {
+        public void didCacheMoreApps(String location) {
         }
 
         @Override
-        public void didCloseMoreApps() {
+        public void didDismissMoreApps(String location) {
         }
 
         @Override
-        public void didClickMoreApps() {
+        public void didCloseMoreApps(String location) {
         }
 
         @Override
-        public void didShowMoreApps() {
+        public void didClickMoreApps(String location) {
         }
 
         CustomEventInterstitialListener getListener(String location) {
@@ -233,4 +224,11 @@ CustomEventInterstitialListener getListener(String location) {
             return listener != null ? listener : NULL_LISTENER;
         }
     }
+
+    @VisibleForTesting
+    @Deprecated
+    public static void resetDelegate() {
+        SingletonChartboostDelegate.instance = new SingletonChartboostDelegate();
+    }
+
 }
diff --git a/extras/src/com/mopub/mobileads/ChartboostRewardedVideo.java b/extras/src/com/mopub/mobileads/ChartboostRewardedVideo.java
new file mode 100644
index 00000000..0cd02f58
--- /dev/null
+++ b/extras/src/com/mopub/mobileads/ChartboostRewardedVideo.java
@@ -0,0 +1,278 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.os.Handler;
+import android.support.annotation.NonNull;
+import com.chartboost.sdk.Chartboost;
+import com.chartboost.sdk.ChartboostDelegate;
+import com.chartboost.sdk.Model.CBError;
+import com.mopub.common.DataKeys;
+import com.mopub.common.LifecycleListener;
+import com.mopub.common.MediationSettings;
+import com.mopub.common.MoPubReward;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+
+import java.util.*;
+
+import static com.mopub.mobileads.MoPubErrorCode.VIDEO_DOWNLOAD_ERROR;
+
+/**
+ * A custom event for showing Chartboost rewarded videos.
+ *
+ * Certified with Chartboost 5.0.4
+ */
+public class ChartboostRewardedVideo extends CustomEventRewardedVideo {
+    public static final String APP_ID_KEY = "appId";
+    public static final String APP_SIGNATURE_KEY = "appSignature";
+    public static final String LOCATION_KEY = "location";
+    public static final String LOCATION_DEFAULT = "Default";
+
+    @NonNull private static final SingletonChartboostDelegate sSingletonChartboostDelegate =
+            new SingletonChartboostDelegate();
+    @NonNull private static final LifecycleListener sLifecycleListener =
+            new ChartboostLifecycleListener();
+    private static boolean sInitialized = false;
+
+    @NonNull private String mLocation = LOCATION_DEFAULT;
+    @NonNull private final Handler mHandler;
+
+    public ChartboostRewardedVideo() {
+        mHandler = new Handler();
+    }
+
+    @Override
+    @NonNull
+    public CustomEventRewardedVideoListener getVideoListenerForSdk() {
+        return sSingletonChartboostDelegate;
+    }
+
+    @Override
+    @NonNull
+    public LifecycleListener getLifecycleListener() {
+        return sLifecycleListener;
+    }
+
+    @Override
+    @NonNull
+    public String getAdNetworkId() {
+        return mLocation;
+    }
+
+    @Override
+    public boolean checkAndInitializeSdk(@NonNull Activity launcherActivity,
+            @NonNull Map<String, Object> localExtras,
+            @NonNull Map<String, String> serverExtras) throws Exception {
+        synchronized (ChartboostRewardedVideo.class) {
+            if (sInitialized) {
+                return false;
+            }
+
+            if (!serverExtras.containsKey(APP_ID_KEY)) {
+                throw new IllegalStateException("Chartboost rewarded video initialization" +
+                        " failed due to missing application ID.");
+            }
+
+            if (!serverExtras.containsKey(APP_SIGNATURE_KEY)) {
+                throw new IllegalStateException("Chartboost rewarded video initialization" +
+                        " failed due to missing application signature.");
+            }
+
+            final String appId = serverExtras.get(APP_ID_KEY);
+            final String appSignature = serverExtras.get(APP_SIGNATURE_KEY);
+
+            Chartboost.startWithAppId(launcherActivity, appId, appSignature);
+            Chartboost.setDelegate(sSingletonChartboostDelegate);
+
+            sInitialized = true;
+            return true;
+        }
+    }
+
+    @Override
+    protected void loadWithSdkInitialized(@NonNull Activity activity,
+            @NonNull Map<String, Object> localExtras, @NonNull Map<String, String> serverExtras)
+            throws Exception {
+        if (serverExtras.containsKey(LOCATION_KEY)) {
+            mLocation = serverExtras.get(LOCATION_KEY);
+        } else {
+            mLocation = LOCATION_DEFAULT;
+        }
+
+        sSingletonChartboostDelegate.mLocationsToLoad.add(mLocation);
+        setUpMediationSettingsForRequest((String) localExtras.get(DataKeys.AD_UNIT_ID_KEY));
+
+        // We do this to ensure that the custom event manager has a chance to get the listener
+        // and ad unit ID before and delegate callbacks are made.
+        mHandler.post(new Runnable() {
+            public void run() {
+                Chartboost.cacheRewardedVideo(mLocation);
+            }
+        });
+    }
+
+    private void setUpMediationSettingsForRequest(String moPubId) {
+        final ChartboostMediationSettings globalSettings =
+                MoPubRewardedVideoManager.getGlobalMediationSettings(ChartboostMediationSettings.class);
+        final ChartboostMediationSettings instanceSettings =
+                MoPubRewardedVideoManager.getInstanceMediationSettings(ChartboostMediationSettings.class, moPubId);
+
+        // Instance settings override global settings.
+        if (instanceSettings != null) {
+            Chartboost.setCustomId(instanceSettings.getCustomId());
+        } else if (globalSettings != null) {
+            Chartboost.setCustomId(globalSettings.getCustomId());
+        }
+    }
+
+    @Override
+    public boolean hasVideoAvailable() {
+        return Chartboost.hasRewardedVideo(mLocation);
+    }
+
+    @Override
+    public void showVideo() {
+        if (hasVideoAvailable()) {
+            Chartboost.showRewardedVideo(mLocation);
+        } else {
+            MoPubLog.d("Attempted to show Chartboost rewarded video before it was available.");
+        }
+    }
+
+    @Override
+    protected void onInvalidate() {
+        // This prevents sending didCache or didFailToCache callbacks.
+        sSingletonChartboostDelegate.mLocationsToLoad.remove(mLocation);
+    }
+
+    private static final class SingletonChartboostDelegate extends ChartboostDelegate
+            implements CustomEventRewardedVideoListener {
+
+        private Set<String> mLocationsToLoad = Collections.synchronizedSet(new TreeSet<String>());
+
+        @Override
+        public boolean shouldDisplayRewardedVideo(String location) {
+            return super.shouldDisplayRewardedVideo(location);
+        }
+
+        @Override
+        public void didCacheRewardedVideo(String location) {
+            super.didCacheRewardedVideo(location);
+
+            if (mLocationsToLoad.contains(location)) {
+                MoPubLog.d("Chartboost rewarded video cached for location " + location + ".");
+                MoPubRewardedVideoManager.onRewardedVideoLoadSuccess(ChartboostRewardedVideo.class, location);
+                mLocationsToLoad.remove(location);
+            }
+        }
+
+        @Override
+        public void didFailToLoadRewardedVideo(String location, CBError.CBImpressionError error) {
+            super.didFailToLoadRewardedVideo(location, error);
+
+            if (mLocationsToLoad.contains(location)) {
+                MoPubLog.d("Chartboost rewarded video cache failed for location " + location + ".");
+                MoPubRewardedVideoManager.onRewardedVideoLoadFailure(ChartboostRewardedVideo.class, location, VIDEO_DOWNLOAD_ERROR);
+                mLocationsToLoad.remove(location);
+            }
+        }
+
+        @Override
+        public void didDismissRewardedVideo(String location) {
+            // This is called before didCloseRewardedVideo and didClickRewardedVideo
+            super.didDismissRewardedVideo(location);
+            MoPubRewardedVideoManager.onRewardedVideoClosed(ChartboostRewardedVideo.class, location);
+            MoPubLog.d("Chartboost rewarded video dismissed for location " + location + ".");
+        }
+
+        @Override
+        public void didCloseRewardedVideo(String location) {
+            super.didCloseRewardedVideo(location);
+            MoPubLog.d("Chartboost rewarded video closed for location " + location + ".");
+        }
+
+        @Override
+        public void didClickRewardedVideo(String location) {
+            super.didClickRewardedVideo(location);
+            MoPubRewardedVideoManager.onRewardedVideoClicked(ChartboostRewardedVideo.class, location);
+            MoPubLog.d("Chartboost rewarded video clicked for location " + location + ".");
+        }
+
+        @Override
+        public void didCompleteRewardedVideo(String location, int reward) {
+            super.didCompleteRewardedVideo(location, reward);
+            MoPubLog.d("Chartboost rewarded video completed for location " + location + " with "
+                    + "reward amount " + reward);
+            MoPubRewardedVideoManager.onRewardedVideoCompleted(
+                    ChartboostRewardedVideo.class,
+                    location,
+                    MoPubReward.success(MoPubReward.NO_REWARD_LABEL, reward));
+        }
+
+        @Override
+        public void didDisplayRewardedVideo(String location) {
+            super.didDisplayRewardedVideo(location);
+            MoPubLog.d("Chartboost rewarded video displayed for location " + location + ".");
+            MoPubRewardedVideoManager.onRewardedVideoStarted(ChartboostRewardedVideo.class, location);
+        }
+    }
+
+    private static final class ChartboostLifecycleListener implements LifecycleListener {
+        @Override
+        public void onCreate(@NonNull Activity activity) {
+            Chartboost.onCreate(activity);
+        }
+
+        @Override
+        public void onStart(@NonNull Activity activity) {
+            Chartboost.onStart(activity);
+        }
+
+        @Override
+        public void onPause(@NonNull Activity activity) {
+            Chartboost.onPause(activity);
+        }
+
+        @Override
+        public void onResume(@NonNull Activity activity) {
+            Chartboost.onResume(activity);
+        }
+
+        @Override
+        public void onRestart(@NonNull Activity activity) {
+        }
+
+        @Override
+        public void onStop(@NonNull Activity activity) {
+            Chartboost.onStop(activity);
+        }
+
+        @Override
+        public void onDestroy(@NonNull Activity activity) {
+            Chartboost.onDestroy(activity);
+        }
+
+        @Override
+        public void onBackPressed(@NonNull Activity activity) {
+            Chartboost.onBackPressed();
+        }
+    }
+
+    public static final class ChartboostMediationSettings implements MediationSettings {
+        @NonNull private final String mCustomId;
+
+        public ChartboostMediationSettings(@NonNull final String customId) {
+            mCustomId = customId;
+        }
+
+        @NonNull public String getCustomId() {
+            return mCustomId;
+        }
+    }
+
+    @Deprecated // for testing
+    @VisibleForTesting
+    static void resetInitialization() {
+        sInitialized = false;
+    }
+}
diff --git a/extras/src/com/mopub/mobileads/FacebookBanner.java b/extras/src/com/mopub/mobileads/FacebookBanner.java
index d58000f6..f0513a57 100644
--- a/extras/src/com/mopub/mobileads/FacebookBanner.java
+++ b/extras/src/com/mopub/mobileads/FacebookBanner.java
@@ -1,6 +1,8 @@
 package com.mopub.mobileads;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.Log;
 
 import com.facebook.ads.Ad;
@@ -8,15 +10,16 @@
 import com.facebook.ads.AdListener;
 import com.facebook.ads.AdSize;
 import com.facebook.ads.AdView;
+import com.mopub.common.DataKeys;
 import com.mopub.common.util.Views;
 
 import java.util.Map;
 
 /**
- * Tested with Facebook SDK 3.18.1.
+ * Tested with Facebook SDK 3.23.1.
  */
 public class FacebookBanner extends CustomEventBanner implements AdListener {
-    private static final String PLACEMENT_ID_KEY = "placement_id";
+    public static final String PLACEMENT_ID_KEY = "placement_id";
 
     private AdView mFacebookBanner;
     private CustomEventBannerListener mBannerListener;
@@ -33,15 +36,32 @@ protected void loadBanner(final Context context,
         mBannerListener = customEventBannerListener;
 
         final String placementId;
-        if (extrasAreValid(serverExtras)) {
+        if (serverExtrasAreValid(serverExtras)) {
             placementId = serverExtras.get(PLACEMENT_ID_KEY);
         } else {
             mBannerListener.onBannerFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
             return;
         }
 
-        mFacebookBanner = new AdView(context, placementId, AdSize.BANNER_320_50);
+        int width;
+        int height;
+        if (localExtrasAreValid(localExtras)) {
+            width = (Integer) localExtras.get(DataKeys.AD_WIDTH);
+            height = (Integer) localExtras.get(DataKeys.AD_HEIGHT);
+        } else {
+            mBannerListener.onBannerFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
+            return;
+        }
+
+        AdSize adSize = calculateAdSize(width, height);
+        if (adSize == null) {
+            mBannerListener.onBannerFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
+            return;
+        }
+
+        mFacebookBanner = new AdView(context, placementId, adSize);
         mFacebookBanner.setAdListener(this);
+        mFacebookBanner.disableAutoRefresh();
         mFacebookBanner.loadAd();
     }
 
@@ -82,11 +102,30 @@ public void onAdClicked(Ad ad) {
         mBannerListener.onBannerClicked();
     }
 
-    private boolean extrasAreValid(final Map<String, String> serverExtras) {
+    private boolean serverExtrasAreValid(final Map<String, String> serverExtras) {
         final String placementId = serverExtras.get(PLACEMENT_ID_KEY);
         return (placementId != null && placementId.length() > 0);
     }
 
+    private boolean localExtrasAreValid(@NonNull final Map<String, Object> localExtras) {
+        return localExtras.get(DataKeys.AD_WIDTH) instanceof Integer
+                && localExtras.get(DataKeys.AD_HEIGHT) instanceof Integer;
+    }
+
+    @Nullable
+    private AdSize calculateAdSize(int width, int height) {
+        // Use the smallest AdSize that will properly contain the adView
+        if (height <= AdSize.BANNER_320_50.getHeight()) {
+            return AdSize.BANNER_320_50;
+        } else if (height <= AdSize.BANNER_HEIGHT_90.getHeight()) {
+            return AdSize.BANNER_HEIGHT_90;
+        } else if (height <= AdSize.RECTANGLE_HEIGHT_250.getHeight()) {
+            return AdSize.RECTANGLE_HEIGHT_250;
+        } else {
+            return null;
+        }
+    }
+
     @Deprecated // for testing
     AdView getAdView() {
         return mFacebookBanner;
diff --git a/extras/src/com/mopub/mobileads/FacebookInterstitial.java b/extras/src/com/mopub/mobileads/FacebookInterstitial.java
index d6dde364..3ff45d1b 100644
--- a/extras/src/com/mopub/mobileads/FacebookInterstitial.java
+++ b/extras/src/com/mopub/mobileads/FacebookInterstitial.java
@@ -10,16 +10,11 @@
 
 import java.util.Map;
 
-import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR;
-import static com.mopub.mobileads.MoPubErrorCode.NETWORK_INVALID_STATE;
-import static com.mopub.mobileads.MoPubErrorCode.NETWORK_NO_FILL;
-import static com.mopub.mobileads.MoPubErrorCode.UNSPECIFIED;
-
 /**
- * Tested with Facebook SDK 3.18.1.
+ * Tested with Facebook SDK 3.23.1.
  */
 public class FacebookInterstitial extends CustomEventInterstitial implements InterstitialAdListener {
-    private static final String PLACEMENT_ID_KEY = "placement_id";
+    public static final String PLACEMENT_ID_KEY = "placement_id";
 
     private InterstitialAd mFacebookInterstitial;
     private CustomEventInterstitialListener mInterstitialListener;
@@ -39,7 +34,7 @@ protected void loadInterstitial(final Context context,
         if (extrasAreValid(serverExtras)) {
             placementId = serverExtras.get(PLACEMENT_ID_KEY);
         } else {
-            mInterstitialListener.onInterstitialFailed(ADAPTER_CONFIGURATION_ERROR);
+            mInterstitialListener.onInterstitialFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
             return;
         }
 
@@ -79,11 +74,11 @@ public void onAdLoaded(final Ad ad) {
     public void onError(final Ad ad, final AdError error) {
         Log.d("MoPub", "Facebook interstitial ad failed to load.");
         if (error == AdError.NO_FILL) {
-            mInterstitialListener.onInterstitialFailed(NETWORK_NO_FILL);
+            mInterstitialListener.onInterstitialFailed(MoPubErrorCode.NETWORK_NO_FILL);
         } else if (error == AdError.INTERNAL_ERROR) {
-            mInterstitialListener.onInterstitialFailed(NETWORK_INVALID_STATE);
+            mInterstitialListener.onInterstitialFailed(MoPubErrorCode.NETWORK_INVALID_STATE);
         } else {
-            mInterstitialListener.onInterstitialFailed(UNSPECIFIED);
+            mInterstitialListener.onInterstitialFailed(MoPubErrorCode.UNSPECIFIED);
         }
     }
 
diff --git a/extras/src/com/mopub/mobileads/GooglePlayServicesBanner.java b/extras/src/com/mopub/mobileads/GooglePlayServicesBanner.java
index a71e120c..17273749 100644
--- a/extras/src/com/mopub/mobileads/GooglePlayServicesBanner.java
+++ b/extras/src/com/mopub/mobileads/GooglePlayServicesBanner.java
@@ -15,11 +15,9 @@
 import static com.google.android.gms.ads.AdSize.FULL_BANNER;
 import static com.google.android.gms.ads.AdSize.LEADERBOARD;
 import static com.google.android.gms.ads.AdSize.MEDIUM_RECTANGLE;
-import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR;
-import static com.mopub.mobileads.MoPubErrorCode.NETWORK_NO_FILL;
 
 /*
- * Compatible with version 5.0.89 of the Google Play Services SDK.
+ * Compatible with version 7.0.0 of the Google Play Services SDK.
  */
 
 // Note: AdMob ads will now use this class as Google has deprecated the AdMob SDK.
@@ -28,10 +26,10 @@
     /*
      * These keys are intended for MoPub internal use. Do not modify.
      */
-    private static final String AD_UNIT_ID_KEY = "adUnitID";
-    private static final String AD_WIDTH_KEY = "adWidth";
-    private static final String AD_HEIGHT_KEY = "adHeight";
-    private static final String LOCATION_KEY = "location";
+    public static final String AD_UNIT_ID_KEY = "adUnitID";
+    public static final String AD_WIDTH_KEY = "adWidth";
+    public static final String AD_HEIGHT_KEY = "adHeight";
+    public static final String LOCATION_KEY = "location";
 
     private CustomEventBannerListener mBannerListener;
     private AdView mGoogleAdView;
@@ -52,7 +50,7 @@ protected void loadBanner(
             adWidth = Integer.parseInt(serverExtras.get(AD_WIDTH_KEY));
             adHeight = Integer.parseInt(serverExtras.get(AD_HEIGHT_KEY));
         } else {
-            mBannerListener.onBannerFailed(ADAPTER_CONFIGURATION_ERROR);
+            mBannerListener.onBannerFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
             return;
         }
 
@@ -62,19 +60,21 @@ protected void loadBanner(
 
         final AdSize adSize = calculateAdSize(adWidth, adHeight);
         if (adSize == null) {
-            mBannerListener.onBannerFailed(ADAPTER_CONFIGURATION_ERROR);
+            mBannerListener.onBannerFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
             return;
         }
 
         mGoogleAdView.setAdSize(adSize);
 
-        final AdRequest adRequest = new AdRequest.Builder().build();
+        final AdRequest adRequest = new AdRequest.Builder()
+                .setRequestAgent("MoPub")
+                .build();
 
         try {
             mGoogleAdView.loadAd(adRequest);
         } catch (NoClassDefFoundError e) {
             // This can be thrown by Play Services on Honeycomb.
-            mBannerListener.onBannerFailed(NETWORK_NO_FILL);
+            mBannerListener.onBannerFailed(MoPubErrorCode.NETWORK_NO_FILL);
         }
     }
 
@@ -126,7 +126,7 @@ public void onAdClosed() {
         public void onAdFailedToLoad(int errorCode) {
             Log.d("MoPub", "Google Play Services banner ad failed to load.");
             if (mBannerListener != null) {
-                mBannerListener.onBannerFailed(NETWORK_NO_FILL);
+                mBannerListener.onBannerFailed(MoPubErrorCode.NETWORK_NO_FILL);
             }
         }
 
diff --git a/extras/src/com/mopub/mobileads/GooglePlayServicesInterstitial.java b/extras/src/com/mopub/mobileads/GooglePlayServicesInterstitial.java
index 24146033..9aab1650 100644
--- a/extras/src/com/mopub/mobileads/GooglePlayServicesInterstitial.java
+++ b/extras/src/com/mopub/mobileads/GooglePlayServicesInterstitial.java
@@ -9,11 +9,8 @@
 
 import java.util.Map;
 
-import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR;
-import static com.mopub.mobileads.MoPubErrorCode.NETWORK_NO_FILL;
-
 /*
- * Compatible with version 5.0.89 of the Google Play Services SDK.
+ * Compatible with version 7.0.0 of the Google Play Services SDK.
  */
 
 // Note: AdMob ads will now use this class as Google has deprecated the AdMob SDK.
@@ -22,8 +19,8 @@
     /*
      * These keys are intended for MoPub internal use. Do not modify.
      */
-    private static final String AD_UNIT_ID_KEY = "adUnitID";
-    private static final String LOCATION_KEY = "location";
+    public static final String AD_UNIT_ID_KEY = "adUnitID";
+    public static final String LOCATION_KEY = "location";
 
     private CustomEventInterstitialListener mInterstitialListener;
     private InterstitialAd mGoogleInterstitialAd;
@@ -40,7 +37,7 @@ protected void loadInterstitial(
         if (extrasAreValid(serverExtras)) {
             adUnitId = serverExtras.get(AD_UNIT_ID_KEY);
         } else {
-            mInterstitialListener.onInterstitialFailed(ADAPTER_CONFIGURATION_ERROR);
+            mInterstitialListener.onInterstitialFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
             return;
         }
 
@@ -48,13 +45,15 @@ protected void loadInterstitial(
         mGoogleInterstitialAd.setAdListener(new InterstitialAdListener());
         mGoogleInterstitialAd.setAdUnitId(adUnitId);
 
-        final AdRequest adRequest = new AdRequest.Builder().build();
+        final AdRequest adRequest = new AdRequest.Builder()
+                .setRequestAgent("MoPub")
+                .build();
 
         try {
             mGoogleInterstitialAd.loadAd(adRequest);
         } catch (NoClassDefFoundError e) {
             // This can be thrown by Play Services on Honeycomb.
-            mInterstitialListener.onInterstitialFailed(NETWORK_NO_FILL);
+            mInterstitialListener.onInterstitialFailed(MoPubErrorCode.NETWORK_NO_FILL);
         }
     }
 
@@ -94,7 +93,7 @@ public void onAdClosed() {
         public void onAdFailedToLoad(int errorCode) {
             Log.d("MoPub", "Google Play Services interstitial ad failed to load.");
             if (mInterstitialListener != null) {
-                mInterstitialListener.onInterstitialFailed(NETWORK_NO_FILL);
+                mInterstitialListener.onInterstitialFailed(MoPubErrorCode.NETWORK_NO_FILL);
             }
         }
 
diff --git a/extras/src/com/mopub/mobileads/MillennialBanner.java b/extras/src/com/mopub/mobileads/MillennialBanner.java
index ac1c4fe6..5ea0a596 100644
--- a/extras/src/com/mopub/mobileads/MillennialBanner.java
+++ b/extras/src/com/mopub/mobileads/MillennialBanner.java
@@ -13,19 +13,20 @@
 
 import java.util.Map;
 
-import static com.mopub.mobileads.MoPubErrorCode.NETWORK_NO_FILL;
-
 /**
  * Compatible with version 5.3.0 of the Millennial Media SDK.
  */
 
 class MillennialBanner extends CustomEventBanner {
-    private MMAdView mMillennialAdView;
-    private CustomEventBannerListener mBannerListener;
+
     public static final String APID_KEY = "adUnitID";
     public static final String AD_WIDTH_KEY = "adWidth";
     public static final String AD_HEIGHT_KEY = "adHeight";
 
+    private MMAdView mMillennialAdView;
+    private CustomEventBannerListener mBannerListener;
+
+
     @Override
     protected void loadBanner(final Context context, final CustomEventBannerListener customEventBannerListener,
                               final Map<String, Object> localExtras, final Map<String, String> serverExtras) {
@@ -109,7 +110,7 @@ public void requestCompleted(final MMAd mmAd) {
         @Override
         public void requestFailed(final MMAd mmAd, final MMException e) {
             Log.d("MoPub", "Millennial banner ad failed to load.");
-            mBannerListener.onBannerFailed(NETWORK_NO_FILL);
+            mBannerListener.onBannerFailed(MoPubErrorCode.NETWORK_NO_FILL);
         }
 
         @Override
diff --git a/extras/src/com/mopub/mobileads/MillennialInterstitial.java b/extras/src/com/mopub/mobileads/MillennialInterstitial.java
index 474d2203..e4ca44b6 100644
--- a/extras/src/com/mopub/mobileads/MillennialInterstitial.java
+++ b/extras/src/com/mopub/mobileads/MillennialInterstitial.java
@@ -13,17 +13,17 @@
 
 import java.util.Map;
 
-import static com.mopub.mobileads.MoPubErrorCode.NETWORK_INVALID_STATE;
-import static com.mopub.mobileads.MoPubErrorCode.NETWORK_NO_FILL;
-
 /**
  * Compatible with version 5.3.0 of the Millennial Media SDK.
  */
 
 class MillennialInterstitial extends CustomEventInterstitial {
+
+    public static final String APID_KEY = "adUnitID";
+
     private MMInterstitial mMillennialInterstitial;
     private CustomEventInterstitialListener mInterstitialListener;
-    public static final String APID_KEY = "adUnitID";
+
 
     @Override
     protected void loadInterstitial(final Context context, final CustomEventInterstitialListener customEventInterstitialListener,
@@ -96,21 +96,21 @@ public void requestCompleted(final MMAd mmAd) {
                 mInterstitialListener.onInterstitialLoaded();
             } else {
                 Log.d("MoPub", "Millennial interstitial request completed, but no ad was available.");
-                mInterstitialListener.onInterstitialFailed(NETWORK_INVALID_STATE);
+                mInterstitialListener.onInterstitialFailed(MoPubErrorCode.NETWORK_INVALID_STATE);
             }
         }
 
         @Override
         public void requestFailed(final MMAd mmAd, final MMException e) {
             if (mMillennialInterstitial == null || e == null) {
-                mInterstitialListener.onInterstitialFailed(NETWORK_INVALID_STATE);
+                mInterstitialListener.onInterstitialFailed(MoPubErrorCode.NETWORK_INVALID_STATE);
             } else if (e.getCode() == MMException.CACHE_NOT_EMPTY && mMillennialInterstitial.isAdAvailable()) {
                 // requestFailed can be due to an ad already loaded or an ad failed to load.
                 Log.d("MoPub", "Millennial interstitial loaded successfully from cache.");
                 mInterstitialListener.onInterstitialLoaded();
             } else {
                 Log.d("MoPub", "Millennial interstitial ad failed to load.");
-                mInterstitialListener.onInterstitialFailed(NETWORK_NO_FILL);
+                mInterstitialListener.onInterstitialFailed(MoPubErrorCode.NETWORK_NO_FILL);
             }
         }
 
diff --git a/extras/src/com/mopub/mobileads/VungleInterstitial.java b/extras/src/com/mopub/mobileads/VungleInterstitial.java
index b662a2b7..1e2ea4b8 100644
--- a/extras/src/com/mopub/mobileads/VungleInterstitial.java
+++ b/extras/src/com/mopub/mobileads/VungleInterstitial.java
@@ -2,6 +2,7 @@
 
 import android.content.Context;
 import android.os.Handler;
+import android.os.Looper;
 import android.util.Log;
 
 import com.vungle.publisher.EventListener;
@@ -11,19 +12,17 @@
 import java.util.concurrent.ScheduledThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 
-import static com.mopub.mobileads.MoPubErrorCode.NETWORK_INVALID_STATE;
-
 /*
- * Tested with Vungle SDK 3.1.0.
+ * Tested with Vungle SDK 3.3.0
  */
 public class VungleInterstitial extends CustomEventInterstitial implements EventListener {
 
-    public static final String DEFAULT_VUNGLE_APP_ID = "YOUR_DEFAULT_VUNGLE_APP_ID";
+    private static final String DEFAULT_VUNGLE_APP_ID = "YOUR_DEFAULT_VUNGLE_APP_ID";
 
     /*
      * APP_ID_KEY is intended for MoPub internal use. Do not modify.
      */
-    private static final String APP_ID_KEY = "appId";
+    public static final String APP_ID_KEY = "appId";
 
     private final VunglePub mVunglePub;
     private final Handler mHandler;
@@ -32,7 +31,7 @@
     private boolean mIsLoading;
 
     public VungleInterstitial() {
-        mHandler = new Handler();
+        mHandler = new Handler(Looper.getMainLooper());
         mScheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(10);
         mVunglePub = VunglePub.getInstance();
     }
@@ -45,7 +44,7 @@ protected void loadInterstitial(Context context,
         mCustomEventInterstitialListener = customEventInterstitialListener;
 
         if (context == null) {
-            mCustomEventInterstitialListener.onInterstitialFailed(NETWORK_INVALID_STATE);
+            mCustomEventInterstitialListener.onInterstitialFailed(MoPubErrorCode.NETWORK_INVALID_STATE);
             return;
         }
 
@@ -60,14 +59,15 @@ protected void loadInterstitial(Context context,
             appId = DEFAULT_VUNGLE_APP_ID;
         }
 
-        mVunglePub.setEventListener(this);
+        // init clears the event listener.
         mVunglePub.init(context, appId);
+        mVunglePub.setEventListeners(this);
         scheduleOnInterstitialLoaded();
     }
 
     @Override
     protected void showInterstitial() {
-        if (mVunglePub.isCachedAdAvailable()) {
+        if (mVunglePub.isAdPlayable()) {
             mVunglePub.playAd();
         } else {
             Log.d("MoPub", "Tried to show a Vungle interstitial ad before it finished loading. Please try again.");
@@ -76,7 +76,7 @@ protected void showInterstitial() {
 
     @Override
     protected void onInvalidate() {
-        mVunglePub.setEventListener(null);
+        mVunglePub.clearEventListeners();
         mScheduledThreadPoolExecutor.shutdownNow();
         mIsLoading = false;
     }
@@ -89,7 +89,7 @@ private void scheduleOnInterstitialLoaded() {
         Runnable runnable = new Runnable() {
             @Override
             public void run() {
-            if (mVunglePub.isCachedAdAvailable()) {
+            if (mVunglePub.isAdPlayable()) {
                 Log.d("MoPub", "Vungle interstitial ad successfully loaded.");
                 mScheduledThreadPoolExecutor.shutdownNow();
                 mHandler.post(new Runnable() {
@@ -131,12 +131,15 @@ public void run() {
     }
 
     @Override
-    public void onAdEnd() {
+    public void onAdEnd(final boolean wasCallToActionClicked) {
         mHandler.post(new Runnable() {
             @Override
             public void run() {
                 Log.d("MoPub", "Vungle interstitial ad dismissed.");
                 mCustomEventInterstitialListener.onInterstitialDismissed();
+                if (wasCallToActionClicked) {
+                    mCustomEventInterstitialListener.onInterstitialClicked();
+                }
             }
         });
     }
@@ -147,8 +150,9 @@ public void onAdUnavailable(final String s) {
     }
 
     @Override
-    public void onCachedAdAvailable() {
-        // Due to the inconsistent behavior of this method, we rely on scheduleOnInterstitialLoaded instead.
+    public void onAdPlayableChanged(final boolean playable) {
+        // Do nothing here. After loading is kicked off, we scheduleOnInterstitialLoaded and check until
+        // we have a playable ad or we timeout.
     }
 
     @Deprecated // for testing
diff --git a/extras/src/com/mopub/mobileads/VungleRewardedVideo.java b/extras/src/com/mopub/mobileads/VungleRewardedVideo.java
new file mode 100644
index 00000000..9d020b40
--- /dev/null
+++ b/extras/src/com/mopub/mobileads/VungleRewardedVideo.java
@@ -0,0 +1,284 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.os.Handler;
+import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+import com.mopub.common.BaseLifecycleListener;
+import com.mopub.common.DataKeys;
+import com.mopub.common.LifecycleListener;
+import com.mopub.common.MediationSettings;
+import com.mopub.common.MoPubReward;
+import com.mopub.common.logging.MoPubLog;
+import com.vungle.publisher.AdConfig;
+import com.vungle.publisher.EventListener;
+import com.vungle.publisher.VunglePub;
+
+import java.util.*;
+import java.util.concurrent.*;
+
+/**
+ * A custom event for showing Vungle rewarded videos.
+ *
+ * Certified with Vungle 3.3.0
+ */
+public class VungleRewardedVideo extends CustomEventRewardedVideo {
+
+    private static final String DEFAULT_VUNGLE_APP_ID = "YOUR_DEFAULT_VUNGLE_APP_ID";
+
+    /*
+     * These constants are intended for MoPub internal use. Do not modify.
+     */
+    public static final String APP_ID_KEY = "appId";
+    public static final String VUNGLE_AD_NETWORK_CONSTANT = "vngl_id";
+
+    // This has to be reinitialized every time the CE loads to avoid conflict with the interstitials.
+    private static VunglePub sVunglePub;
+    private static VungleRewardedVideoListener sVungleListener = new VungleRewardedVideoListener();
+    private static boolean sInitialized;
+    private static final LifecycleListener sLifecycleListener = new BaseLifecycleListener() {
+        @Override
+        public void onPause(@NonNull final Activity activity) {
+            super.onPause(activity);
+            sVunglePub.onPause();
+        }
+
+        @Override
+        public void onResume(@NonNull final Activity activity) {
+            super.onResume(activity);
+            sVunglePub.onResume();
+        }
+    };
+
+    private final Handler mHandler;
+    private final ScheduledThreadPoolExecutor mScheduledThreadPoolExecutor;
+    private boolean mIsLoading;
+    private String mAdUnitId;
+
+
+    public VungleRewardedVideo() {
+        mHandler = new Handler(Looper.getMainLooper());
+        mScheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(1);
+        mIsLoading = false;
+    }
+
+    @Nullable
+    @Override
+    public CustomEventRewardedVideoListener getVideoListenerForSdk() {
+        return sVungleListener;
+    }
+
+    @Nullable
+    @Override
+    public LifecycleListener getLifecycleListener() {
+        return sLifecycleListener;
+    }
+
+    @NonNull
+    @Override
+    protected String getAdNetworkId() {
+        return VUNGLE_AD_NETWORK_CONSTANT;
+    }
+
+    @Override
+    protected boolean checkAndInitializeSdk(@NonNull final Activity launcherActivity,
+                @NonNull final Map<String, Object> localExtras,
+                @NonNull final Map<String, String> serverExtras) throws Exception {
+        synchronized (VungleRewardedVideo.class) {
+            if (!sInitialized) {
+                sVunglePub = VunglePub.getInstance();
+                sInitialized = true;
+                return true;
+            }
+            return false;
+        }
+    }
+
+    @Override
+    protected void loadWithSdkInitialized(@NonNull final Activity activity, @NonNull final Map<String, Object> localExtras, @NonNull final Map<String, String> serverExtras) throws Exception {
+        String appId = serverExtras.containsKey(APP_ID_KEY) ? serverExtras.get(APP_ID_KEY) : DEFAULT_VUNGLE_APP_ID;
+        sVunglePub.init(activity, appId);
+        sVunglePub.setEventListeners(sVungleListener);
+        Object adUnitObject = localExtras.get(DataKeys.AD_UNIT_ID_KEY);
+        if (adUnitObject instanceof String) {
+            mAdUnitId = (String) adUnitObject;
+        }
+        scheduleOnVideoLoaded();
+    }
+
+    @Override
+    protected boolean hasVideoAvailable() {
+        return sVunglePub.isAdPlayable();
+    }
+
+    @Override
+    protected void showVideo() {
+        final AdConfig adConfig = new AdConfig();
+        adConfig.setIncentivized(true);
+        setUpMediationSettingsForRequest(adConfig);
+        sVunglePub.playAd(adConfig);
+    }
+
+    private void setUpMediationSettingsForRequest(AdConfig adConfig) {
+        final VungleMediationSettings globalMediationSettings =
+                MoPubRewardedVideoManager.getGlobalMediationSettings(VungleMediationSettings.class);
+        final VungleMediationSettings instanceMediationSettings =
+                MoPubRewardedVideoManager.getInstanceMediationSettings(VungleMediationSettings.class, mAdUnitId);
+
+        // Local options override global options.
+        // The two objects are not merged.
+        if (instanceMediationSettings != null) {
+            modifyAdConfig(adConfig, instanceMediationSettings);
+        } else if (globalMediationSettings != null) {
+            modifyAdConfig(adConfig, globalMediationSettings);
+        }
+    }
+
+    private void modifyAdConfig(AdConfig adConfig, VungleMediationSettings mediationSettings) {
+        if (!TextUtils.isEmpty(mediationSettings.body)) {
+            adConfig.setIncentivizedCancelDialogBodyText(mediationSettings.body);
+        }
+        if (!TextUtils.isEmpty(mediationSettings.closeButtonText)) {
+            adConfig.setIncentivizedCancelDialogCloseButtonText(mediationSettings.closeButtonText);
+        }
+        if (!TextUtils.isEmpty(mediationSettings.keepWatchingButtonText)) {
+            adConfig.setIncentivizedCancelDialogKeepWatchingButtonText(mediationSettings.keepWatchingButtonText);
+        }
+        if (!TextUtils.isEmpty(mediationSettings.title)) {
+            adConfig.setIncentivizedCancelDialogTitle(mediationSettings.title);
+        }
+        if (!TextUtils.isEmpty(mediationSettings.userId)) {
+            adConfig.setIncentivizedUserId(mediationSettings.userId);
+        }
+    }
+
+    private void scheduleOnVideoLoaded() {
+        Runnable runnable = new Runnable() {
+            @Override
+            public void run() {
+                if (sVunglePub.isAdPlayable()) {
+                    MoPubLog.d("Vungle interstitial ad successfully loaded.");
+                    mScheduledThreadPoolExecutor.shutdownNow();
+                    mHandler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            MoPubRewardedVideoManager.onRewardedVideoLoadSuccess(VungleRewardedVideo.class, VUNGLE_AD_NETWORK_CONSTANT);
+                        }
+                    });
+                    mIsLoading = false;
+                }
+            }
+        };
+
+        if (!mIsLoading) {
+            mScheduledThreadPoolExecutor.scheduleAtFixedRate(runnable, 1, 1, TimeUnit.SECONDS);
+            mIsLoading = true;
+        }
+    }
+
+    @Override
+    protected void onInvalidate() {
+        mScheduledThreadPoolExecutor.shutdownNow();
+    }
+
+    private static class VungleRewardedVideoListener implements EventListener,
+            CustomEventRewardedVideoListener {
+
+        @Override
+        public void onAdEnd(final boolean wasCallToActionClicked) {
+            if (wasCallToActionClicked) {
+                MoPubRewardedVideoManager.onRewardedVideoClicked(VungleRewardedVideo.class,
+                        VUNGLE_AD_NETWORK_CONSTANT);
+            }
+            MoPubRewardedVideoManager.onRewardedVideoClosed(VungleRewardedVideo.class,
+                    VUNGLE_AD_NETWORK_CONSTANT);
+        }
+
+        @Override
+        public void onAdStart() {
+            MoPubRewardedVideoManager.onRewardedVideoStarted(VungleRewardedVideo.class,
+                    VUNGLE_AD_NETWORK_CONSTANT);
+        }
+
+        @Override
+        public void onAdUnavailable(final String s) {
+            MoPubRewardedVideoManager.onRewardedVideoLoadFailure(VungleRewardedVideo.class,
+                    VUNGLE_AD_NETWORK_CONSTANT, MoPubErrorCode.NETWORK_NO_FILL);
+        }
+
+        @Override
+        public void onAdPlayableChanged(final boolean playable) {
+            // Do nothing here. After loading is kicked off, we scheduleOnInterstitialLoaded and check until
+            // we have a playable ad or we timeout.
+        }
+
+        @Override
+        public void onVideoView(final boolean isCompletedView, final int watchedMillis, final int videoMillis) {
+            MoPubLog.d(String.format(Locale.US, "%.1f%% of Vungle video watched.",
+                    (double) watchedMillis / videoMillis * 100));
+            if (isCompletedView) {
+                // Vungle does not provide a callback when a user should be rewarded.
+                // You will need to provide your own reward logic if you receive a reward with
+                // "NO_REWARD_LABEL" && "NO_REWARD_AMOUNT"
+                MoPubRewardedVideoManager.onRewardedVideoCompleted(VungleRewardedVideo.class,
+                        VUNGLE_AD_NETWORK_CONSTANT,
+                        MoPubReward.success(MoPubReward.NO_REWARD_LABEL, MoPubReward.NO_REWARD_AMOUNT));
+            }
+        }
+    }
+
+    public static class VungleMediationSettings implements MediationSettings {
+        @Nullable private final String userId;
+        @Nullable private final String title;
+        @Nullable private final String body;
+        @Nullable private final String closeButtonText;
+        @Nullable private final String keepWatchingButtonText;
+
+        public static class Builder {
+            @Nullable private String userId;
+            @Nullable private String title;
+            @Nullable private String body;
+            @Nullable private String closeButtonText;
+            @Nullable private String keepWatchingButtonText;
+
+            public Builder withUserId(@NonNull final String userId) {
+                this.userId = userId;
+                return this;
+            }
+
+            public Builder withCancelDialogTitle(@NonNull final String title) {
+                this.title = title;
+                return this;
+            }
+
+            public Builder withCancelDialogBody(@NonNull final String body) {
+                this.body = body;
+                return this;
+            }
+
+            public Builder withCancelDialogCloseButton(@NonNull final String buttonText) {
+                this.closeButtonText = buttonText;
+                return this;
+            }
+
+            public Builder withCancelDialogKeepWatchingButton(@NonNull final String buttonText) {
+                this.keepWatchingButtonText = buttonText;
+                return this;
+            }
+
+            public VungleMediationSettings build() {
+                return new VungleMediationSettings(this);
+            }
+        }
+
+        private VungleMediationSettings(@NonNull final Builder builder) {
+            this.userId = builder.userId;
+            this.title = builder.title;
+            this.body = builder.body;
+            this.closeButtonText = builder.closeButtonText;
+            this.keepWatchingButtonText = builder.keepWatchingButtonText;
+        }
+    }
+}
diff --git a/extras/src/com/mopub/nativeads/FacebookNative.java b/extras/src/com/mopub/nativeads/FacebookNative.java
index 868610b5..76985261 100644
--- a/extras/src/com/mopub/nativeads/FacebookNative.java
+++ b/extras/src/com/mopub/nativeads/FacebookNative.java
@@ -15,7 +15,7 @@
 import java.util.Map;
 
 /*
- * Tested with Facebook SDK 3.18.1
+ * Tested with Facebook SDK 3.23.1
  */
 public class FacebookNative extends CustomEventNative {
     private static final String PLACEMENT_ID_KEY = "placement_id";
diff --git a/extras/src/com/mopub/mobileads/GreystripeBanner.java b/extras/src/com/mopub/simpleadsdemo/GreystripeBanner.java
similarity index 85%
rename from extras/src/com/mopub/mobileads/GreystripeBanner.java
rename to extras/src/com/mopub/simpleadsdemo/GreystripeBanner.java
index 8497f2e6..07311691 100644
--- a/extras/src/com/mopub/mobileads/GreystripeBanner.java
+++ b/extras/src/com/mopub/simpleadsdemo/GreystripeBanner.java
@@ -11,13 +11,19 @@
 import com.mopub.mobileads.CustomEventBanner;
 import com.mopub.mobileads.MoPubErrorCode;
 
-import java.util.*;
+import java.util.Map;
 
 /*
  * Tested with Greystripe SDK 2.4.0.
  */
 class GreystripeBanner extends CustomEventBanner implements GSAdListener {
-    public static final String DEFAULT_GREYSTRIPE_APP_ID = "YOUR_GREYSTRIPE_APP_ID";
+
+    private static final String DEFAULT_GREYSTRIPE_APP_ID = "YOUR_GREYSTRIPE_APP_ID";
+
+    /*
+     * These keys are intended for MoPub internal use. Do not modify.
+     */
+    public static final String APP_ID_KEY = "GUID";
 
     private CustomEventBannerListener mBannerListener;
     private GSMobileBannerAdView mGreystripeAd;
@@ -32,17 +38,21 @@ protected void loadBanner(final Context context,
                               final Map<String, String> serverExtras) {
         mBannerListener = bannerListener;
 
-        /*
-         * You may also pass this String down in the serverExtras Map by specifying Custom Event Data
-         * in MoPub's web interface.
-         */
         String greystripeAppId = DEFAULT_GREYSTRIPE_APP_ID;
+        if (extrasAreValid(serverExtras)) {
+            greystripeAppId = serverExtras.get(APP_ID_KEY);
+        }
+
         mGreystripeAd = new GSMobileBannerAdView(context, greystripeAppId);
         mGreystripeAd.addListener(this);
 
         mGreystripeAd.refresh();
     }
 
+    private boolean extrasAreValid(Map<String, String> extras) {
+        return extras.containsKey(APP_ID_KEY);
+    }
+
     @Override
     protected void onInvalidate() {
         mGreystripeAd.removeListener(this);
diff --git a/extras/src/com/mopub/mobileads/GreystripeInterstitial.java b/extras/src/com/mopub/simpleadsdemo/GreystripeInterstitial.java
similarity index 87%
rename from extras/src/com/mopub/mobileads/GreystripeInterstitial.java
rename to extras/src/com/mopub/simpleadsdemo/GreystripeInterstitial.java
index 57dc89ab..6540db04 100644
--- a/extras/src/com/mopub/mobileads/GreystripeInterstitial.java
+++ b/extras/src/com/mopub/simpleadsdemo/GreystripeInterstitial.java
@@ -11,17 +11,23 @@
 import com.mopub.mobileads.CustomEventInterstitial;
 import com.mopub.mobileads.MoPubErrorCode;
 
-import java.util.*;
+import java.util.Map;
 
 /*
  * Tested with Greystripe SDK 2.4.0.
  */
 class GreystripeInterstitial extends CustomEventInterstitial implements GSAdListener {
-    public static final String DEFAULT_GREYSTRIPE_APP_ID = "YOUR_GREYSTRIPE_APP_ID";
+
+    private static final String DEFAULT_GREYSTRIPE_APP_ID = "YOUR_GREYSTRIPE_APP_ID";
+
+    /*
+     * These keys are intended for MoPub internal use. Do not modify.
+     */
+    public static final String APP_ID_KEY = "GUID";
 
     private CustomEventInterstitialListener mInterstitialListener;
     private GSFullscreenAd mGreystripeAd;
-    
+
     /*
      * Abstract methods from CustomEventInterstitial
      */
@@ -32,30 +38,33 @@ protected void loadInterstitial(final Context context,
                                     final Map<String, String> serverExtras) {
         mInterstitialListener = interstitialListener;
 
-        /*
-         * You may also pass this String down in the serverExtras Map by specifying Custom Event Data
-         * in MoPub's web interface.
-         */
         String greystripeAppId = DEFAULT_GREYSTRIPE_APP_ID;
-        
+        if (extrasAreValid(serverExtras)) {
+            greystripeAppId = serverExtras.get(APP_ID_KEY);
+        }
+
         mGreystripeAd = new GSFullscreenAd(context, greystripeAppId);
         mGreystripeAd.addListener(this);
-        
+
         mGreystripeAd.fetch();
     }
 
+    private static boolean extrasAreValid(Map<String, String> extras) {
+        return extras.containsKey(APP_ID_KEY);
+    }
+
     @Override
     protected void showInterstitial() {
         if (!mGreystripeAd.isAdReady()) {
             mInterstitialListener.onInterstitialFailed(MoPubErrorCode.NETWORK_INVALID_STATE);
             return;
         }
-        
+
         Log.d("MoPub", "Showing Greystripe interstitial ad.");
         mGreystripeAd.display();
         mInterstitialListener.onInterstitialShown();
     }
-    
+
     @Override
     protected void onInvalidate() {
         mGreystripeAd.removeListener(this);
diff --git a/extras/src/com/mopub/mobileads/InMobiBanner.java b/extras/src/com/mopub/simpleadsdemo/InMobiBanner.java
similarity index 82%
rename from extras/src/com/mopub/mobileads/InMobiBanner.java
rename to extras/src/com/mopub/simpleadsdemo/InMobiBanner.java
index ac22d974..b51fb04c 100644
--- a/extras/src/com/mopub/mobileads/InMobiBanner.java
+++ b/extras/src/com/mopub/simpleadsdemo/InMobiBanner.java
@@ -2,6 +2,7 @@
 
 import android.app.Activity;
 import android.content.Context;
+
 import com.inmobi.commons.InMobi;
 import com.inmobi.commons.InMobi.LOG_LEVEL;
 import com.inmobi.monetization.IMBanner;
@@ -12,19 +13,27 @@
 import com.mopub.mobileads.CustomEventBanner;
 import com.mopub.mobileads.MoPubErrorCode;
 
-import java.util.*;
+import java.util.HashMap;
+import java.util.Map;
 
 /*
  * Tested with InMobi SDK 4.4.1
  */
 public class InMobiBanner extends CustomEventBanner implements IMBannerListener {
 
+    private static final String DEFAULT_APP_ID = "YOUR_INMOBI_APP_ID_HERE";
+
+    /*
+     * These keys are intended for MoPub internal use. Do not modify.
+     */
+    public static final String APP_ID_KEY = "app_id";
+
     @Override
     protected void loadBanner(Context context,
-                              CustomEventBannerListener bannerListener,
-                              Map<String, Object> localExtras, Map<String, String> serverExtras) {
+            CustomEventBannerListener bannerListener,
+            Map<String, Object> localExtras, Map<String, String> serverExtras) {
         mBannerListener = bannerListener;
-        String inMobiAppId = "YOUR_INMOBI_APP_ID";
+        String inMobiAppId = DEFAULT_APP_ID;
 
         Activity activity = null;
         if (context instanceof Activity) {
@@ -37,15 +46,16 @@ protected void loadBanner(Context context,
             mBannerListener.onBannerFailed(null);
             return;
         }
+
+        if (extrasAreValid(serverExtras)) {
+            inMobiAppId = serverExtras.get(APP_ID_KEY);
+        }
+
         if (!isAppInitialized) {
             InMobi.initialize(activity, inMobiAppId);
             isAppInitialized = true;
         }
 
-		/*
-		 * You may also pass this String down in the serverExtras Map by
-		 * specifying Custom Event Data in MoPub's web interface.
-		 */
         iMBanner = new IMBanner(activity, inMobiAppId,
                 IMBanner.INMOBI_AD_UNIT_320X50);
 
@@ -60,13 +70,17 @@ protected void loadBanner(Context context,
 
     }
 
+    private boolean extrasAreValid(Map<String, String> extras) {
+        return extras.containsKey(APP_ID_KEY);
+    }
+
     private CustomEventBannerListener mBannerListener;
     private IMBanner iMBanner;
     private static boolean isAppInitialized = false;
 
-	/*
-	 * Abstract methods from CustomEventBanner
-	 */
+    /*
+     * Abstract methods from CustomEventBanner
+     */
 
     @Override
     public void onInvalidate() {
diff --git a/extras/src/com/mopub/mobileads/InMobiInterstitial.java b/extras/src/com/mopub/simpleadsdemo/InMobiInterstitial.java
similarity index 86%
rename from extras/src/com/mopub/mobileads/InMobiInterstitial.java
rename to extras/src/com/mopub/simpleadsdemo/InMobiInterstitial.java
index 80f222d7..ad45e7d8 100644
--- a/extras/src/com/mopub/mobileads/InMobiInterstitial.java
+++ b/extras/src/com/mopub/simpleadsdemo/InMobiInterstitial.java
@@ -2,6 +2,7 @@
 
 import android.app.Activity;
 import android.content.Context;
+
 import com.inmobi.commons.InMobi;
 import com.inmobi.monetization.IMErrorCode;
 import com.inmobi.monetization.IMInterstitial;
@@ -10,19 +11,26 @@
 import com.mopub.mobileads.CustomEventInterstitial;
 import com.mopub.mobileads.MoPubErrorCode;
 
-import java.util.*;
+import java.util.HashMap;
+import java.util.Map;
 
 /*
  * Tested with InMobi SDK  4.4.1
  */
 public class InMobiInterstitial extends CustomEventInterstitial implements IMInterstitialListener {
 
+    private static final String DEFAULT_APP_ID = "YOUR_INMOBI_APP_ID_HERE";
+
+    /*
+     * These keys are intended for MoPub internal use. Do not modify.
+     */
+    public static final String APP_ID_KEY = "app_id";
+
     @Override
     protected void loadInterstitial(Context context,
                                     CustomEventInterstitialListener interstitialListener,
                                     Map<String, Object> localExtras, Map<String, String> serverExtras) {
         mInterstitialListener = interstitialListener;
-        String inMobiAppId = "YOUR_INMOBI_APP_ID";
 
         Activity activity = null;
         if (context instanceof Activity) {
@@ -37,10 +45,11 @@ protected void loadInterstitial(Context context,
             return;
         }
 
-		/*
-		 * You may also pass this String down in the serverExtras Map by
-		 * specifying Custom Event Data in MoPub's web interface.
-		 */
+        String inMobiAppId = DEFAULT_APP_ID;
+        if (extrasAreValid(serverExtras)) {
+            inMobiAppId = serverExtras.get(APP_ID_KEY);
+        }
+
         if (!isAppInitialized) {
             InMobi.initialize(activity, inMobiAppId);
             isAppInitialized = true;
@@ -55,13 +64,17 @@ protected void loadInterstitial(Context context,
         iMInterstitial.loadInterstitial();
     }
 
+    private boolean extrasAreValid(Map<String, String> extras) {
+        return extras.containsKey(APP_ID_KEY);
+    }
+
     private CustomEventInterstitialListener mInterstitialListener;
     private IMInterstitial iMInterstitial;
     private static boolean isAppInitialized = false;
 
-	/*
-	 * Abstract methods from CustomEventInterstitial
-	 */
+    /*
+     * Abstract methods from CustomEventInterstitial
+     */
 
     @Override
     public void showInterstitial() {
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index 0087cd3b..3d0dee6e 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 51905da1..cd2daf52 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Tue Aug 05 14:58:07 PDT 2014
+#Tue Nov 18 14:15:01 PST 2014
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-1.12-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-bin.zip
diff --git a/mopub-sample/AndroidManifest.xml b/mopub-sample/AndroidManifest.xml
index 4d4616a1..dcdf1e32 100644
--- a/mopub-sample/AndroidManifest.xml
+++ b/mopub-sample/AndroidManifest.xml
@@ -1,39 +1,39 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
       package="com.mopub.simpleadsdemo"
-      android:versionCode="18"
-      android:versionName="3.2.2">
+      android:versionCode="24"
+      android:versionName="3.7.0">
     <uses-sdk android:minSdkVersion="9"
-              android:targetSdkVersion="19"/>
+              android:targetSdkVersion="22"/>
 
     <uses-permission android:name="android.permission.INTERNET" />
     <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
     <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
 
+
     <!-- For MRAID 2 -->
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
 
     <application android:icon="@drawable/icon" android:label="@string/app_name">
 	    <activity android:name="com.mopub.simpleadsdemo.MoPubSampleActivity"
 	            android:label="@string/app_name"
-                android:configChanges="orientation">
+                android:configChanges="orientation|screenSize">
 	        <intent-filter>
 	            <action android:name="android.intent.action.MAIN" />
 	            <category android:name="android.intent.category.LAUNCHER" />
 	        </intent-filter>
 	    </activity>
         <activity android:name="com.mopub.mobileads.MoPubActivity"
-                android:configChanges="keyboardHidden|orientation"/>
+                android:configChanges="keyboardHidden|orientation|screenSize"/>
         <activity android:name="com.mopub.mobileads.MraidActivity"
-                android:configChanges="keyboardHidden|orientation"/>
+                android:configChanges="keyboardHidden|orientation|screenSize"/>
         <activity android:name="com.mopub.common.MoPubBrowser"
-                android:configChanges="keyboardHidden|orientation"/>
+                android:configChanges="keyboardHidden|orientation|screenSize"/>
         <activity android:name="com.mopub.mobileads.MraidVideoPlayerActivity"
-                android:configChanges="keyboardHidden|orientation"/>
+                android:configChanges="keyboardHidden|orientation|screenSize"/>
 
         <meta-data android:name="com.google.android.gms.version"
                    android:value="@integer/google_play_services_version" />
-
     </application>
 
 </manifest>
diff --git a/mopub-sample/build.gradle b/mopub-sample/build.gradle
index 50be0c68..0369f1a5 100644
--- a/mopub-sample/build.gradle
+++ b/mopub-sample/build.gradle
@@ -1,3 +1,7 @@
+repositories {
+    jcenter()
+}
+
 apply plugin: 'com.android.application'
 
 group = 'com.mopub'
@@ -5,14 +9,25 @@ group = 'com.mopub'
 description = '''MoPub SDK'''
 
 android {
-    compileSdkVersion 19
-    buildToolsVersion '19.1.0'
+    compileSdkVersion 22
+    buildToolsVersion '22.0.1'
 
     defaultConfig {
-        versionCode 1
-        versionName "3.2.1"
+        versionCode 24
+        versionName "3.7.0"
         minSdkVersion 9
-        targetSdkVersion 19
+        targetSdkVersion 22
+    }
+
+    buildTypes {
+      release {
+        minifyEnabled true
+        proguardFiles = [getDefaultProguardFile('proguard-android.txt'), 'proguard.cfg']
+      }
+      debug {
+        minifyEnabled true
+        proguardFiles = [getDefaultProguardFile('proguard-android.txt'), 'proguard.cfg']
+      }
     }
 
     sourceSets {
@@ -36,7 +51,7 @@ android {
 }
 
 dependencies {
-    compile 'com.android.support:support-v4:19.1.+'
-    compile 'com.google.android.gms:play-services:5.0.89'
+    compile 'com.android.support:support-v4:22.0.0'
+    compile 'com.google.android.gms:play-services-ads:7.0.0'
     compile project(':mopub-sdk')
 }
diff --git a/mopub-sample/pom.xml b/mopub-sample/pom.xml
index a1d02f01..2411f18d 100644
--- a/mopub-sample/pom.xml
+++ b/mopub-sample/pom.xml
@@ -27,20 +27,20 @@
             <groupId>com.mopub.mobileads</groupId>
             <artifactId>mopub-sdk</artifactId>
             <version>1.0.0-SNAPSHOT</version>
-            <type>jar</type>
+            <type>aar</type>
         </dependency>
 
         <dependency>
             <groupId>com.android.support</groupId>
             <artifactId>support-v4</artifactId>
-            <version>19.1.0</version>
-            <type>jar</type>
+            <version>22.0.0</version>
+            <type>aar</type>
         </dependency>
 
         <dependency>
             <groupId>com.google.android.gms</groupId>
-            <artifactId>play-services</artifactId>
-            <version>5.0.89</version>
+            <artifactId>play-services-ads</artifactId>
+            <version>7.0.0</version>
             <type>aar</type>
         </dependency>
 
@@ -109,13 +109,15 @@
                 </configuration>
             </plugin>
             <plugin>
-                <groupId>com.jayway.maven.plugins.android.generation2</groupId>
+                <groupId>com.simpligility.maven.plugins</groupId>
                 <artifactId>android-maven-plugin</artifactId>
-                <version>3.8.2</version>
+                <version>4.2.0</version>
                 <configuration>
+                    <androidManifestFile>AndroidManifest.xml</androidManifestFile>
+                    <resourceDirectory>res</resourceDirectory>
                     <sdk>
                         <!-- platform or api level (api level 4 = platform 1.6)-->
-                        <platform>19</platform>
+                        <platform>22</platform>
                     </sdk>
                     <undeployBeforeDeploy>true</undeployBeforeDeploy>
                 </configuration>
diff --git a/mopub-sample/proguard.cfg b/mopub-sample/proguard.cfg
index c1f97c67..9b84b5cf 100644
--- a/mopub-sample/proguard.cfg
+++ b/mopub-sample/proguard.cfg
@@ -15,4 +15,23 @@
 # Support for Android Advertiser ID.
 -keep class com.google.android.gms.common.GooglePlayServicesUtil {*;}
 -keep class com.google.android.gms.ads.identifier.AdvertisingIdClient {*;}
+-keep class com.google.android.gms.ads.identifier.AdvertisingIdClient$Info {*;}
 
+# Support for Google Play Services
+# http://developer.android.com/google/play-services/setup.html
+-keep class * extends java.util.ListResourceBundle {
+    protected Object[][] getContents();
+}
+
+-keep public class com.google.android.gms.common.internal.safeparcel.SafeParcelable {
+    public static final *** NULL;
+}
+
+-keepnames @com.google.android.gms.common.annotation.KeepName class *
+-keepclassmembernames class * {
+    @com.google.android.gms.common.annotation.KeepName *;
+}
+
+-keepnames class * implements android.os.Parcelable {
+    public static final ** CREATOR;
+}
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/InterstitialDetailFragment.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/InterstitialDetailFragment.java
index 2314e718..10a1cd82 100644
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/InterstitialDetailFragment.java
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/InterstitialDetailFragment.java
@@ -33,9 +33,11 @@ public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle sa
         views.mLoadButton.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View view) {
+                if (mMoPubInterstitial == null) {
+                    mMoPubInterstitial = new MoPubInterstitial(getActivity(), adUnitId);
+                    mMoPubInterstitial.setInterstitialAdListener(InterstitialDetailFragment.this);
+                }
                 final String keywords = views.mKeywordsField.getText().toString();
-                mMoPubInterstitial = new MoPubInterstitial(getActivity(), adUnitId);
-                mMoPubInterstitial.setInterstitialAdListener(InterstitialDetailFragment.this);
                 mMoPubInterstitial.setKeywords(keywords);
                 mMoPubInterstitial.load();
                 mShowButton.setEnabled(false);
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/LoggingUtils.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/LoggingUtils.java
new file mode 100644
index 00000000..ce5051d3
--- /dev/null
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/LoggingUtils.java
@@ -0,0 +1,93 @@
+package com.mopub.simpleadsdemo;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.mobileads.MoPubErrorCode;
+
+import java.util.logging.Handler;
+import java.util.logging.Level;
+import java.util.logging.LogManager;
+import java.util.logging.LogRecord;
+import java.util.logging.Logger;
+
+/**
+ * Used to intercept logs so that we can view logs at a lower level
+ * than Verbose (ie. Level.FINEST). This will show a toast when we
+ * receive a matching error from the mopub sdk.
+ */
+public class LoggingUtils {
+    private LoggingUtils() {
+    }
+
+    /**
+     * The name of the custom logger we're looking for
+     */
+    private static final String LOGGER_NAME = "com.mopub";
+
+    private static boolean sEnabled;
+
+    /**
+     * Makes it so that this app can intercept Level.FINEST log messages.
+     * This is not thread safe.
+     *
+     * @param context Needs a context to send toasts.
+     */
+    static void enableCanaryLogging(@NonNull final Context context) {
+        if (sEnabled) {
+            return;
+        }
+
+        final Handler handler = new SampleAppLogHandler(context.getApplicationContext());
+        final Logger logger = getLogger();
+
+        logger.setLevel(Level.ALL);
+        logger.addHandler(handler);
+
+        sEnabled = true;
+    }
+
+    private static Logger getLogger() {
+        // This makes sure the static block in MoPubLog is executed before
+        // LogManager#getLogManager is called.
+        MoPubLog.c("Canary level logging enabled");
+
+        return LogManager.getLogManager().getLogger(LOGGER_NAME);
+    }
+
+    private static class SampleAppLogHandler extends Handler {
+
+        @NonNull
+        private final Context mContext;
+
+        protected SampleAppLogHandler(@NonNull final Context context) {
+            super();
+            mContext = context;
+        }
+
+        @Override
+        public void publish(final LogRecord logRecord) {
+            if (logRecord == null) {
+                return;
+            }
+            // Toasts the warmup message if X-Warmup flag is set to 1
+            if (MoPubErrorCode.WARMUP.toString().equals(logRecord.getMessage())) {
+                Utils.logToast(mContext, MoPubErrorCode.WARMUP.toString());
+            }
+            // Toasts the no connection message if a native response failed due to no internet
+            if (MoPubErrorCode.NO_CONNECTION.toString().equals(logRecord.getMessage())) {
+                Utils.logToast(mContext, MoPubErrorCode.NO_CONNECTION.toString());
+            }
+        }
+
+        @Override
+        public void flush() {
+        }
+
+        @Override
+        public void close() throws SecurityException {
+        }
+    }
+}
+
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleActivity.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleActivity.java
index f2ba89bc..8322b4ac 100644
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleActivity.java
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleActivity.java
@@ -1,13 +1,29 @@
 package com.mopub.simpleadsdemo;
 
+import android.annotation.TargetApi;
+import android.os.Build;
 import android.os.Bundle;
 import android.support.v4.app.FragmentActivity;
 import android.support.v4.app.FragmentManager;
+import android.webkit.WebView;
 
 import com.mopub.common.MoPub;
 
 
 public class MoPubSampleActivity extends FragmentActivity {
+
+    // Sample app web views are debuggable.
+    static {
+        setWebDebugging();
+    }
+
+    @TargetApi(Build.VERSION_CODES.KITKAT)
+    private static void setWebDebugging() {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
+            WebView.setWebContentsDebuggingEnabled(true);
+        }
+    }
+
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
@@ -29,5 +45,9 @@ protected void onCreate(Bundle savedInstanceState) {
                     .add(R.id.fragment_container, listFragment)
                     .commit();
         }
+
+        // Intercepts all logs including Level.FINEST so we can show a toast
+        // that is not normally user-facing. This is only used for native ads.
+        LoggingUtils.enableCanaryLogging(this);
     }
 }
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleAdUnit.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleAdUnit.java
index dfeacd95..0192728d 100644
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleAdUnit.java
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleAdUnit.java
@@ -1,6 +1,7 @@
 package com.mopub.simpleadsdemo;
 
 import android.os.Bundle;
+import android.support.annotation.NonNull;
 import android.support.v4.app.Fragment;
 
 import java.util.Comparator;
@@ -158,7 +159,7 @@ static MoPubSampleAdUnit fromBundle(final Bundle bundle) {
     }
 
     @Override
-    public int compareTo(MoPubSampleAdUnit that) {
+    public int compareTo(@NonNull MoPubSampleAdUnit that) {
         if (mAdType != that.mAdType) {
             return mAdType.ordinal() - that.mAdType.ordinal();
         }
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeGalleryFragment.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeGalleryFragment.java
index ede4745c..42b2ba38 100644
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeGalleryFragment.java
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeGalleryFragment.java
@@ -13,7 +13,6 @@
 import android.widget.TextView;
 
 import com.mopub.nativeads.MoPubNativeAdLoadedListener;
-import com.mopub.nativeads.MoPubNativeAdPositioning;
 import com.mopub.nativeads.MoPubNativeAdRenderer;
 import com.mopub.nativeads.MoPubStreamAdPlacer;
 import com.mopub.nativeads.RequestParameters;
@@ -69,12 +68,9 @@ public void onClick(View view) {
         views.mDescriptionView.setText(mAdConfiguration.getDescription());
         views.mAdUnitIdView.setText(adUnitId);
         mViewPager = (ViewPager) view.findViewById(R.id.gallery_pager);
-        mStreamAdPlacer = new MoPubStreamAdPlacer(getActivity(),
-                MoPubNativeAdPositioning.clientPositioning()
-                        .addFixedPosition(4)
-                        .addFixedPosition(1)
-                        .enableRepeatingPositions(3)
-        );
+
+        // This ad placer is used to automatically insert ads into the ViewPager.
+        mStreamAdPlacer = new MoPubStreamAdPlacer(getActivity());
         final MoPubNativeAdRenderer adRenderer = new MoPubNativeAdRenderer(
                 new ViewBinder.Builder(R.layout.native_ad_list_item)
                         .titleId(R.id.native_title)
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeListViewFragment.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeListViewFragment.java
index ba042047..5c48fe32 100644
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeListViewFragment.java
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeListViewFragment.java
@@ -10,7 +10,6 @@
 import android.widget.ListView;
 
 import com.mopub.nativeads.MoPubAdAdapter;
-import com.mopub.nativeads.MoPubNativeAdPositioning;
 import com.mopub.nativeads.MoPubNativeAdRenderer;
 import com.mopub.nativeads.RequestParameters;
 import com.mopub.nativeads.ViewBinder;
@@ -69,12 +68,9 @@ public void onClick(View view) {
             adapter.add("Item " + i);
         }
 
-        // Create an ad adapter with ads in positions 0, 4, and every 10 places thereafter.
+        // Create an ad adapter that gets its positioning information from the MoPub Ad Server.
         // This adapter will be used in place of the original adapter for the ListView.
-        mAdAdapter = new MoPubAdAdapter(getActivity(), adapter, MoPubNativeAdPositioning.clientPositioning()
-                .addFixedPosition(0)
-                .addFixedPosition(4)
-                .enableRepeatingPositions(10));
+        mAdAdapter = new MoPubAdAdapter(getActivity(), adapter);
 
         // Set up an renderer that knows how to put ad data in an ad view.
         final MoPubNativeAdRenderer adRenderer = new MoPubNativeAdRenderer(
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/Utils.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/Utils.java
index f63af8fe..734e777b 100644
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/Utils.java
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/Utils.java
@@ -35,6 +35,9 @@ static boolean isAlphaNumeric(final String input) {
 
     static void logToast(Context context, String message) {
         Log.d(LOGTAG, message);
-        Toast.makeText(context, message, Toast.LENGTH_SHORT).show();
+
+        if (context != null) {
+            Toast.makeText(context, message, Toast.LENGTH_SHORT).show();
+        }
     }
 }
diff --git a/mopub-sample/src/test/resources/org.robolectric.Config.properties b/mopub-sample/src/test/resources/org.robolectric.Config.properties
new file mode 100644
index 00000000..ce97d608
--- /dev/null
+++ b/mopub-sample/src/test/resources/org.robolectric.Config.properties
@@ -0,0 +1 @@
+shadows=com.mopub.nativeads.test.support.MoPubShadowDisplay,com.mopub.nativeads.test.support.MoPubShadowBitmap
diff --git a/mopub-sdk/AndroidManifest.xml b/mopub-sdk/AndroidManifest.xml
index 22ac7cb1..988c0a04 100644
--- a/mopub-sdk/AndroidManifest.xml
+++ b/mopub-sdk/AndroidManifest.xml
@@ -5,5 +5,6 @@
 		android:versionName="1.0">
 	<uses-sdk
         android:minSdkVersion="9"
-        android:targetSdkVersion="19"/>
+        android:targetSdkVersion="22"/>
+    <application/>
 </manifest>
\ No newline at end of file
diff --git a/mopub-sdk/build.gradle b/mopub-sdk/build.gradle
index 7d273422..9728a789 100644
--- a/mopub-sdk/build.gradle
+++ b/mopub-sdk/build.gradle
@@ -15,8 +15,8 @@ android {
     buildToolsVersion rootProject.buildToolsVersion
 
     defaultConfig {
-        versionCode 1
-        versionName "3.2.2"
+        versionCode 24
+        versionName "3.7.0"
         minSdkVersion rootProject.minSdkVersion
         targetSdkVersion rootProject.targetSdkVersion
         consumerProguardFiles 'proguard.txt'
@@ -48,12 +48,17 @@ android {
 }
 
 dependencies {
+    compile 'com.android.support:support-annotations:22.0.0'
+    compile 'com.mopub.volley:mopub-volley:1.1.0'
     compile rootProject.supportV4
     //compile rootProject.playServices
     compile rootProject.playServicesAds
     compile files('libs/MMSDK-5.4.0.jar')
 }
 
-// Don't run the Robolectric Unit Tests. They don't build properly in Gradle or Android Studio in this version.
+// Don't run the Robolectric Unit Tests.
 check.dependsOn.remove("test")
+check.dependsOn.remove("unitTest")
 check.dependsOn.remove("testDebug")
+check.dependsOn.remove("unitTestDebug")
+
diff --git a/mopub-sdk/etc/mraid.js b/mopub-sdk/etc/mraid.js
index 1dff72b6..7ce13b28 100644
--- a/mopub-sdk/etc/mraid.js
+++ b/mopub-sdk/etc/mraid.js
@@ -13,63 +13,48 @@
   }
 }());
 
-(function() {
-  // Establish the root mraidbridge object.
-  var mraidbridge = window.mraidbridge = {};
-
-  // native SDK is ready to process mraid commands.
-  var nativeSDKFiredReady = false;
-
-  // Listeners for bridge events.
-  var listeners = {};
-
-  // Queue to track pending calls to the native SDK.
-  var nativeCallQueue = [];
 
-  // Whether a native call is currently in progress.
-  var nativeCallInFlight = false;
+(function() {
+  var mraid = window.mraid = {};
 
   //////////////////////////////////////////////////////////////////////////////////////////////////
 
-  mraidbridge.fireReadyEvent = function() {
-    nativeSDKFiredReady = true;
-    mraidbridge.fireEvent('ready');
-  };
+  // Bridge interface to SDK
 
-  mraidbridge.fireChangeEvent = function(properties) {
-    mraidbridge.fireEvent('change', properties);
+  var bridge = window.mraidbridge = {
+    nativeSDKFiredReady: false,
+    nativeCallQueue: [],
+    nativeCallInFlight: false,
+    lastSizeChangeProperties: null
   };
 
-  mraidbridge.fireErrorEvent = function(message, action) {
-    mraidbridge.fireEvent('error', message, action);
-  };
 
-  mraidbridge.fireEvent = function(type) {
-    var ls = listeners[type];
-    if (ls) {
-      var args = Array.prototype.slice.call(arguments);
-      args.shift();
-      var l = ls.length;
-      for (var i = 0; i < l; i++) {
-        ls[i].apply(null, args);
+  bridge.fireChangeEvent = function(properties) {
+    for (var p in properties) {
+      if (properties.hasOwnProperty(p)) {
+        // Change handlers defined by MRAID below
+        var handler = changeHandlers[p];
+        handler(properties[p]);
       }
     }
   };
 
-  mraidbridge.nativeCallComplete = function(command) {
-    if (nativeCallQueue.length === 0) {
-      nativeCallInFlight = false;
+  bridge.nativeCallComplete = function(command) {
+    if (this.nativeCallQueue.length === 0) {
+      this.nativeCallInFlight = false;
       return;
     }
 
-    var nextCall = nativeCallQueue.pop();
+    var nextCall = this.nativeCallQueue.pop();
     window.location = nextCall;
   };
 
-  mraidbridge.executeNativeCall = function(command) {
-    if (!nativeSDKFiredReady) {
+  bridge.executeNativeCall = function(args) {
+    var command = args.shift();
+
+    if (!this.nativeSDKFiredReady) {
         console.log('rejecting ' + command + ' because mraid is not ready');
-        mraidbridge.fireErrorEvent('mraid is not ready', command);
+        bridge.notifyErrorEvent('mraid is not ready', command);
         return;
     }
 
@@ -78,9 +63,9 @@
     var key, value;
     var isFirstArgument = true;
 
-    for (var i = 1; i < arguments.length; i += 2) {
-      key = arguments[i];
-      value = arguments[i + 1];
+    for (var i = 0; i < args.length; i += 2) {
+      key = args[i];
+      value = args[i + 1];
 
       if (value === null) continue;
 
@@ -94,55 +79,133 @@
       call += encodeURIComponent(key) + '=' + encodeURIComponent(value);
     }
 
-    if (nativeCallInFlight) {
-      nativeCallQueue.push(call);
+    if (this.nativeCallInFlight) {
+      this.nativeCallQueue.push(call);
     } else {
-      nativeCallInFlight = true;
+      this.nativeCallInFlight = true;
       window.location = call;
     }
   };
 
-  //////////////////////////////////////////////////////////////////////////////////////////////////
 
-  mraidbridge.addEventListener = function(event, listener) {
-    var eventListeners;
-    listeners[event] = listeners[event] || [];
-    eventListeners = listeners[event];
+  bridge.setCurrentPosition = function(x, y, width, height) {
+    currentPosition = {
+      x: x,
+      y: y,
+      width: width,
+      height: height
+    };
+    broadcastEvent(EVENTS.INFO, 'Set current position to ' + stringify(currentPosition));
+  };
+
+  bridge.setDefaultPosition = function(x, y, width, height) {
+    defaultPosition = {
+      x: x,
+      y: y,
+      width: width,
+      height: height
+    };
+    broadcastEvent(EVENTS.INFO, 'Set default position to ' + stringify(defaultPosition));
+  };
+  
+  bridge.setMaxSize = function(width, height) {
+    maxSize = {
+      width: width,
+      height: height
+    };
+
+    expandProperties.width = width;
+    expandProperties.height = height;
+
+    broadcastEvent(EVENTS.INFO, 'Set max size to ' + stringify(maxSize));
+  };
 
-    for (var l in eventListeners) {
-      // Listener already registered, so no need to add it.
-      if (listener === l) return;
+  bridge.setPlacementType = function(_placementType) {
+    placementType = _placementType;
+    broadcastEvent(EVENTS.INFO, 'Set placement type to ' + stringify(placementType));
+  };
+
+  bridge.setScreenSize = function(width, height) {
+    screenSize = {
+      width: width,
+      height: height
+    };
+    broadcastEvent(EVENTS.INFO, 'Set screen size to ' + stringify(screenSize));
+  };
+
+  bridge.setState = function(_state) {
+    state = _state;
+    broadcastEvent(EVENTS.INFO, 'Set state to ' + stringify(state));
+    broadcastEvent(EVENTS.STATECHANGE, state);
+  };
+
+  bridge.setIsViewable = function(_isViewable) {
+    isViewable = _isViewable;
+    broadcastEvent(EVENTS.INFO, 'Set isViewable to ' + stringify(isViewable));
+    broadcastEvent(EVENTS.VIEWABLECHANGE, isViewable);
+  };
+
+  bridge.setSupports = function(sms, tel, calendar, storePicture, inlineVideo) {
+    supportProperties = {
+      sms: sms,
+      tel: tel,
+      calendar: calendar,
+      storePicture: storePicture,
+      inlineVideo: inlineVideo
+    };
+  };
+
+  bridge.notifyReadyEvent = function() {
+    this.nativeSDKFiredReady = true;
+    broadcastEvent(EVENTS.READY);
+  };
+
+  bridge.notifyErrorEvent = function(message, action) {
+    broadcastEvent(EVENTS.ERROR, message, action);
+  };
+
+  // Temporary aliases while we migrate to the new API
+  bridge.fireReadyEvent = bridge.notifyReadyEvent;
+  bridge.fireErrorEvent = bridge.notifyErrorEvent;
+
+  bridge.notifySizeChangeEvent = function(width, height) {
+    if (this.lastSizeChangeProperties &&
+          width == this.lastSizeChangeProperties.width && height == this.lastSizeChangeProperties.height) {
+      return;
     }
 
-    eventListeners.push(listener);
+    this.lastSizeChangeProperties = {
+        width: width,
+        height: height
+    };
+    broadcastEvent(EVENTS.SIZECHANGE, width, height);
   };
 
-  mraidbridge.removeEventListener = function(event, listener) {
-    if (listeners.hasOwnProperty(event)) {
-      var eventListeners = listeners[event];
-      if (eventListeners) {
-        var idx = eventListeners.indexOf(listener);
-        if (idx !== -1) {
-          eventListeners.splice(idx, 1);
-        }
-      }
+  bridge.notifyStateChangeEvent = function() {
+    if (state === STATES.LOADING) {
+      broadcastEvent(EVENTS.INFO, 'Native SDK initialized.');
     }
+
+    broadcastEvent(EVENTS.INFO, 'Set state to ' + stringify(state));
+    broadcastEvent(EVENTS.STATECHANGE, state);
+  };
+
+  bridge.notifyViewableChangeEvent = function() {
+    broadcastEvent(EVENTS.INFO, 'Set isViewable to ' + stringify(isViewable));
+    broadcastEvent(EVENTS.VIEWABLECHANGE, isViewable);
   };
-}());
 
-(function() {
-  var mraid = window.mraid = {};
-  var bridge = window.mraidbridge;
 
   // Constants. ////////////////////////////////////////////////////////////////////////////////////
 
-  var VERSION = mraid.VERSION = '1.0';
+  var VERSION = mraid.VERSION = '2.0';
 
   var STATES = mraid.STATES = {
-    LOADING: 'loading',     // Initial state.
+    LOADING: 'loading',
     DEFAULT: 'default',
     EXPANDED: 'expanded',
-    HIDDEN: 'hidden'
+    HIDDEN: 'hidden',
+    RESIZED: 'resized'
   };
 
   var EVENTS = mraid.EVENTS = {
@@ -150,7 +213,8 @@
     INFO: 'info',
     READY: 'ready',
     STATECHANGE: 'stateChange',
-    VIEWABLECHANGE: 'viewableChange'
+    VIEWABLECHANGE: 'viewableChange',
+    SIZECHANGE: 'sizeChange'
   };
 
   var PLACEMENT_TYPES = mraid.PLACEMENT_TYPES = {
@@ -163,14 +227,44 @@
 
   // Properties which define the behavior of an expandable ad.
   var expandProperties = {
-    width: -1,
-    height: -1,
+    width: false,
+    height: false,
     useCustomClose: false,
-    isModal: true,
-    lockOrientation: false
+    isModal: true
   };
 
-  var hasSetCustomSize = false;
+  var resizeProperties = {
+    width: false, 
+    height: false,
+    offsetX: false, 
+    offsetY: false,
+    customClosePosition: 'top-right',
+    allowOffscreen: true
+  };
+
+  var orientationProperties = {
+    allowOrientationChange: true,
+    forceOrientation: "none"
+  };
+
+  var supportProperties = {
+    sms: false,
+    tel: false,
+    calendar: false,
+    storePicture: false,
+    inlineVideo: false
+  };
+
+  // default is undefined so that notifySizeChangeEvent can track changes
+  var lastSizeChangeProperties;
+
+  var maxSize = {};
+
+  var currentPosition = {};
+
+  var defaultPosition = {};
+
+  var screenSize = {};
 
   var hasSetCustomClose = false;
 
@@ -182,18 +276,8 @@
 
   var isViewable = false;
 
-  var screenSize = { width: -1, height: -1 };
-
   var placementType = PLACEMENT_TYPES.UNKNOWN;
 
-  var supports = {
-    sms: false,
-    tel: false,
-    calendar: false,
-    storePicture: false,
-    inlineVideo: false
-  };
-
   //////////////////////////////////////////////////////////////////////////////////////////////////
 
   var EventListeners = function(event) {
@@ -229,7 +313,7 @@
 
     this.broadcast = function(args) {
       for (var id in listeners) {
-        if (listeners.hasOwnProperty(id)) listeners[id].apply({}, args);
+        if (listeners.hasOwnProperty(id)) listeners[id].apply(mraid, args);
       }
     };
 
@@ -305,29 +389,17 @@
       placementType = val;
     },
 
-    screenSize: function(val) {
+    sizeChange: function(val) {
       broadcastEvent(EVENTS.INFO, 'Set screenSize to ' + stringify(val));
       for (var key in val) {
         if (val.hasOwnProperty(key)) screenSize[key] = val[key];
       }
-
-      if (!hasSetCustomSize) {
-        expandProperties['width'] = screenSize['width'];
-        expandProperties['height'] = screenSize['height'];
-      }
-    },
-
-    expandProperties: function(val) {
-      broadcastEvent(EVENTS.INFO, 'Merging expandProperties with ' + stringify(val));
-      for (var key in val) {
-        if (val.hasOwnProperty(key)) expandProperties[key] = val[key];
-      }
     },
 
     supports: function(val) {
       broadcastEvent(EVENTS.INFO, 'Set supports to ' + stringify(val));
-        supports = val;
-    },
+        supportProperties = val;
+    }
   };
 
   var validate = function(obj, validators, action, merge) {
@@ -339,7 +411,7 @@
       } else {
         for (var i in validators) {
           if (validators.hasOwnProperty(i) && obj[i] === undefined) {
-            broadcastEvent(EVENTS.ERROR, 'Object is missing required property: ' + i + '.', action);
+            broadcastEvent(EVENTS.ERROR, 'Object is missing required property: ' + i, action);
             return false;
           }
         }
@@ -351,8 +423,7 @@
       var value = obj[prop];
       if (validator && !validator(value)) {
         // Failed validation.
-        broadcastEvent(EVENTS.ERROR, 'Value of property ' + prop + ' is invalid.',
-          action);
+        broadcastEvent(EVENTS.ERROR, 'Value of property ' + prop + ' is invalid: ' + value, action);
         return false;
       }
     }
@@ -360,40 +431,20 @@
   };
 
   var expandPropertyValidators = {
-    width: function(v) { return !isNaN(v) && v >= 0; },
-    height: function(v) { return !isNaN(v) && v >= 0; },
     useCustomClose: function(v) { return (typeof v === 'boolean'); },
-    lockOrientation: function(v) { return (typeof v === 'boolean'); }
   };
 
   //////////////////////////////////////////////////////////////////////////////////////////////////
 
-  bridge.addEventListener('change', function(properties) {
-    for (var p in properties) {
-      if (properties.hasOwnProperty(p)) {
-        var handler = changeHandlers[p];
-        handler(properties[p]);
-      }
-    }
-  });
-
-  bridge.addEventListener('error', function(message, action) {
-    broadcastEvent(EVENTS.ERROR, message, action);
-  });
-
-  bridge.addEventListener('ready', function() {
-    broadcastEvent(EVENTS.READY);
-  });
-
-  //////////////////////////////////////////////////////////////////////////////////////////////////
-
   mraid.addEventListener = function(event, listener) {
     if (!event || !listener) {
       broadcastEvent(EVENTS.ERROR, 'Both event and listener are required.', 'addEventListener');
     } else if (!contains(event, EVENTS)) {
       broadcastEvent(EVENTS.ERROR, 'Unknown MRAID event: ' + event, 'addEventListener');
     } else {
-      if (!listeners[event]) listeners[event] = new EventListeners(event);
+      if (!listeners[event]) {
+        listeners[event] = new EventListeners(event);
+      }
       listeners[event].add(listener);
     }
   };
@@ -402,45 +453,25 @@
     if (state === STATES.HIDDEN) {
       broadcastEvent(EVENTS.ERROR, 'Ad cannot be closed when it is already hidden.',
         'close');
-    } else bridge.executeNativeCall('close');
+    } else bridge.executeNativeCall(['close']);
   };
 
   mraid.expand = function(URL) {
-    if (this.getState() !== STATES.DEFAULT) {
-      broadcastEvent(EVENTS.ERROR, 'Ad can only be expanded from the default state.', 'expand');
+    if (!(this.getState() === STATES.DEFAULT || this.getState() === STATES.RESIZED)) {
+      broadcastEvent(EVENTS.ERROR, 'Ad can only be expanded from the default or resized state.', 'expand');
     } else {
-      var args = ['expand'];
-
-      if (this.getHasSetCustomClose()) {
-        args = args.concat(['shouldUseCustomClose', expandProperties.useCustomClose ? 'true' : 'false']);
-      }
-
-      if (this.getHasSetCustomSize()) {
-        if (expandProperties.width >= 0 && expandProperties.height >= 0) {
-          args = args.concat(['w', expandProperties.width, 'h', expandProperties.height]);
-        }
-      }
-
-      if (typeof expandProperties.lockOrientation !== 'undefined') {
-        args = args.concat(['lockOrientation', expandProperties.lockOrientation]);
-      }
+      var args = ['expand',
+        'shouldUseCustomClose', expandProperties.useCustomClose
+      ];
 
       if (URL) {
         args = args.concat(['url', URL]);
       }
 
-      bridge.executeNativeCall.apply(this, args);
+      bridge.executeNativeCall(args);
     }
   };
 
-  mraid.getHasSetCustomClose = function() {
-      return hasSetCustomClose;
-  };
-
-  mraid.getHasSetCustomSize = function() {
-      return hasSetCustomSize;
-  };
-
   mraid.getExpandProperties = function() {
     var properties = {
       width: expandProperties.width,
@@ -451,56 +482,93 @@
     return properties;
   };
 
+
+  mraid.getCurrentPosition = function() {
+    return {
+      x: currentPosition.x,
+      y: currentPosition.y,
+      width: currentPosition.width,
+      height: currentPosition.height
+    };
+  };
+
+  mraid.getDefaultPosition = function() {
+    return {
+      x: defaultPosition.x,
+      y: defaultPosition.y,
+      width: defaultPosition.width,
+      height: defaultPosition.height
+    };
+  };
+
+  mraid.getMaxSize = function() {
+    return {
+      width: maxSize.width,
+      height: maxSize.height
+    };
+  };
+
   mraid.getPlacementType = function() {
     return placementType;
   };
 
-  mraid.getState = function() {
-    return state;
+  mraid.getScreenSize = function() {
+    return {
+      width: screenSize.width,
+      height: screenSize.height
+    };
   };
 
-  mraid.getVersion = function() {
-    return mraid.VERSION;
+  mraid.getState = function() {
+    return state;
   };
 
   mraid.isViewable = function() {
     return isViewable;
   };
 
+  mraid.getVersion = function() {
+    return mraid.VERSION;
+  };
+
   mraid.open = function(URL) {
     if (!URL) broadcastEvent(EVENTS.ERROR, 'URL is required.', 'open');
-    else bridge.executeNativeCall('open', 'url', URL);
+    else bridge.executeNativeCall(['open', 'url', URL]);
   };
 
   mraid.removeEventListener = function(event, listener) {
-    if (!event) broadcastEvent(EVENTS.ERROR, 'Event is required.', 'removeEventListener');
-    else {
-      if (listener && (!listeners[event] || !listeners[event].remove(listener))) {
-        broadcastEvent(EVENTS.ERROR, 'Listener not currently registered for event.',
-          'removeEventListener');
-        return;
-      } else if (listeners[event]) listeners[event].removeAll();
+    if (!event) {
+      broadcastEvent(EVENTS.ERROR, 'Event is required.', 'removeEventListener');
+      return;
+    }
 
-      if (listeners[event] && listeners[event].count === 0) {
-        listeners[event] = null;
-        delete listeners[event];
+    if (listener) {
+      // If we have a valid event, we'll try to remove the listener from it.
+      var success = false;
+      if (listeners[event]) {
+        success = listeners[event].remove(listener);
+      }
+
+      // If we didn't have a valid event or couldn't remove the listener from the event, broadcast an error and return early.
+      if (!success) {
+        broadcastEvent(EVENTS.ERROR, 'Listener not currently registered for event.', 'removeEventListener');
+        return;
       }
+
+    } else if (!listener && listeners[event]) {
+      listeners[event].removeAll();
+    }
+
+    if (listeners[event] && listeners[event].count === 0) {
+      listeners[event] = null;
+      delete listeners[event];
     }
   };
 
   mraid.setExpandProperties = function(properties) {
     if (validate(properties, expandPropertyValidators, 'setExpandProperties', true)) {
-      if (properties.hasOwnProperty('width') || properties.hasOwnProperty('height')) {
-        hasSetCustomSize = true;
-      }
-
-      if (properties.hasOwnProperty('useCustomClose')) hasSetCustomClose = true;
-
-      var desiredProperties = ['width', 'height', 'useCustomClose', 'lockOrientation'];
-      var length = desiredProperties.length;
-      for (var i = 0; i < length; i++) {
-        var propname = desiredProperties[i];
-        if (properties.hasOwnProperty(propname)) expandProperties[propname] = properties[propname];
+      if (properties.hasOwnProperty('useCustomClose')) {
+        expandProperties.useCustomClose = properties.useCustomClose;
       }
     }
   };
@@ -508,7 +576,7 @@
   mraid.useCustomClose = function(shouldUseCustomClose) {
     expandProperties.useCustomClose = shouldUseCustomClose;
     hasSetCustomClose = true;
-    bridge.executeNativeCall('usecustomclose', 'shouldUseCustomClose', shouldUseCustomClose);
+    bridge.executeNativeCall(['usecustomclose', 'shouldUseCustomClose', shouldUseCustomClose]);
   };
 
   // MRAID 2.0 APIs ////////////////////////////////////////////////////////////////////////////////
@@ -516,14 +584,14 @@
   mraid.createCalendarEvent = function(parameters) {
     CalendarEventParser.initialize(parameters);
     if (CalendarEventParser.parse()) {
-      bridge.executeNativeCall.apply(this, CalendarEventParser.arguments);
+      bridge.executeNativeCall(CalendarEventParser.arguments);
     } else {
       broadcastEvent(EVENTS.ERROR, CalendarEventParser.errors[0], 'createCalendarEvent');
     }
   };
 
   mraid.supports = function(feature) {
-    return supports[feature];
+    return supportProperties[feature];
   };
 
   mraid.playVideo = function(uri) {
@@ -535,7 +603,7 @@
     if (!uri) {
       broadcastEvent(EVENTS.ERROR, 'playVideo must be called with a valid URI', 'playVideo');
     } else {
-      bridge.executeNativeCall.apply(this, ['playVideo', 'uri', uri]);
+      bridge.executeNativeCall(['playVideo', 'uri', uri]);
     }
   };
 
@@ -548,36 +616,102 @@
     if (!uri) {
       broadcastEvent(EVENTS.ERROR, 'storePicture must be called with a valid URI', 'storePicture');
     } else {
-      bridge.executeNativeCall.apply(this, ['storePicture', 'uri', uri]);
+      bridge.executeNativeCall(['storePicture', 'uri', uri]);
     }
   };
 
-  mraid.resize = function() {
-    bridge.executeNativeCall('resize');
-  };
 
-  mraid.getResizeProperties = function() {
-    bridge.executeNativeCall('getResizeProperties');
+  var resizePropertyValidators = {
+    width: function(v) {
+      return !isNaN(v) && v > 0; 
+    },
+    height: function(v) {
+      return !isNaN(v) && v > 0; 
+    },
+    offsetX: function(v) {
+      return !isNaN(v);
+    },
+    offsetY: function(v) {
+      return !isNaN(v);
+    },
+    customClosePosition: function(v) {
+      return (typeof v === 'string' && 
+        ['top-right', 'bottom-right', 'top-left', 'bottom-left', 'center', 'top-center', 'bottom-center'].indexOf(v) > -1);
+    },
+    allowOffscreen: function(v) {
+      return (typeof v === 'boolean');
+    }
   };
 
-  mraid.setResizeProperties = function(resizeProperties) {
-    bridge.executeNativeCall('setResizeProperties', 'resizeProperties', resizeProperties);
+  mraid.setOrientationProperties = function(properties) {
+
+    if (properties.hasOwnProperty('allowOrientationChange')) {
+      orientationProperties.allowOrientationChange = properties.allowOrientationChange;
+    }
+
+    if (properties.hasOwnProperty('forceOrientation')) {
+      orientationProperties.forceOrientation = properties.forceOrientation;
+    }
+
+    var args = ['setOrientationProperties',
+      'allowOrientationChange', orientationProperties.allowOrientationChange,
+      'forceOrientation', orientationProperties.forceOrientation
+    ];
+    bridge.executeNativeCall(args);
   };
 
-  mraid.getCurrentPosition = function() {
-    bridge.executeNativeCall('getCurrentPosition');
+  mraid.getOrientationProperties = function() {
+    return {
+      allowOrientationChange: orientationProperties.allowOrientationChange,
+      forceOrientation: orientationProperties.forceOrientation
+    };
   };
 
-  mraid.getDefaultPosition = function() {
-    bridge.executeNativeCall('getDefaultPosition');
+  mraid.resize = function() {
+    if (!(this.getState() === STATES.DEFAULT || this.getState() === STATES.RESIZED)) {
+      broadcastEvent(EVENTS.ERROR, 'Ad can only be resized from the default or resized state.', 'resize');
+    } else if (!resizeProperties.width || !resizeProperties.height) {
+      broadcastEvent(EVENTS.ERROR, 'Must set resize properties before calling resize()', 'resize');
+    } else {
+      var args = ['resize',
+        'width', resizeProperties.width,
+        'height', resizeProperties.height,
+        'offsetX', resizeProperties.offsetX || 0,
+        'offsetY', resizeProperties.offsetY || 0,
+        'customClosePosition', resizeProperties.customClosePosition,
+        'allowOffscreen', !!resizeProperties.allowOffscreen
+        ];
+
+      bridge.executeNativeCall(args);
+    } 
   };
 
-  mraid.getMaxSize = function() {
-    bridge.executeNativeCall('getMaxSize');
+  mraid.getResizeProperties = function() {
+    var properties = {
+      width: resizeProperties.width,
+      height: resizeProperties.height,
+      offsetX: resizeProperties.offsetX,
+      offsetY: resizeProperties.offsetY,
+      customClosePosition: resizeProperties.customClosePosition,
+      allowOffscreen: resizeProperties.allowOffscreen
+    };
+    return properties;
   };
 
-  mraid.getScreenSize = function() {
-    bridge.executeNativeCall('getScreenSize');
+  mraid.setResizeProperties = function(properties) {
+    if (validate(properties, resizePropertyValidators, 'setResizeProperties', true)) {
+
+      var desiredProperties = ['width', 'height', 'offsetX', 'offsetY', 'customClosePosition', 'allowOffscreen'];
+
+      var length = desiredProperties.length;
+
+      for (var i = 0; i < length; i++) {
+        var propname = desiredProperties[i];
+        if (properties.hasOwnProperty(propname)) {
+          resizeProperties[propname] = properties[propname];
+        }
+      }
+    }
   };
 
   var CalendarEventParser = {
@@ -659,7 +793,7 @@
       var validValues = ['opaque', 'transparent'];
 
       if (this.parameters.hasOwnProperty('transparency')) {
-        var transparency = this.parameters['transparency'];
+        var transparency = this.parameters.transparency;
         if (contains(transparency, validValues)) {
           this.arguments.push('transparency');
           this.arguments.push(transparency);
@@ -684,7 +818,7 @@
 
     parseRecurrenceInterval: function(recurrenceDict) {
       if (recurrenceDict.hasOwnProperty('interval')) {
-        var interval = recurrenceDict['interval'];
+        var interval = recurrenceDict.interval;
         if (!interval) {
           this.errors.push('Recurrence interval cannot be null.');
         } else {
@@ -700,7 +834,7 @@
 
     parseRecurrenceFrequency: function(recurrenceDict) {
       if (recurrenceDict.hasOwnProperty('frequency')) {
-        var frequency = recurrenceDict['frequency'];
+        var frequency = recurrenceDict.frequency;
         var validFrequencies = ['daily', 'weekly', 'monthly', 'yearly'];
         if (contains(frequency, validFrequencies)) {
           this.arguments.push('frequency');
@@ -712,7 +846,7 @@
     },
 
     parseRecurrenceEndDate: function(recurrenceDict) {
-      var expires = recurrenceDict['expires'];
+      var expires = recurrenceDict.expires;
 
       if (!expires) {
         return;
@@ -744,6 +878,6 @@
         this.arguments.push(kind);
         this.arguments.push(dateString);
       }
-    },
+    }
   };
 }());
\ No newline at end of file
diff --git a/mopub-sdk/pom.xml b/mopub-sdk/pom.xml
index 6b8156e6..9b391fc2 100644
--- a/mopub-sdk/pom.xml
+++ b/mopub-sdk/pom.xml
@@ -11,7 +11,7 @@
 
     <artifactId>mopub-sdk</artifactId>
     <version>1.0.0-SNAPSHOT</version>
-    <packaging>jar</packaging>
+    <packaging>aar</packaging>
     <name>MoPub SDK</name>
     <description>The SDK for MoPub developers.</description>
 
@@ -22,10 +22,23 @@
     <dependencies>
 
         <!--main-->
+        <dependency>
+            <groupId>com.android.support</groupId>
+            <artifactId>support-annotations</artifactId>
+            <version>22.0.0</version>
+        </dependency>
+
         <dependency>
             <groupId>com.android.support</groupId>
             <artifactId>support-v4</artifactId>
-            <version>19.1.0</version>
+            <version>22.0.0</version>
+            <type>aar</type>
+        </dependency>
+
+        <dependency>
+            <groupId>com.mopub.volley</groupId>
+            <artifactId>mopub-volley</artifactId>
+            <version>1.1.0</version>
         </dependency>
 
         <!--test-->
@@ -86,13 +99,15 @@
                 </configuration>
             </plugin>
             <plugin>
-                <groupId>com.jayway.maven.plugins.android.generation2</groupId>
+                <groupId>com.simpligility.maven.plugins</groupId>
                 <artifactId>android-maven-plugin</artifactId>
-                <version>3.8.2</version>
+                <version>4.2.0</version>
                 <configuration>
+                    <androidManifestFile>AndroidManifest.xml</androidManifestFile>
+                    <resourceDirectory>res</resourceDirectory>
                     <sdk>
                         <!-- platform or api level (api level 4 = platform 1.6)-->
-                        <platform>19</platform>
+                        <platform>22</platform>
                     </sdk>
                     <undeployBeforeDeploy>true</undeployBeforeDeploy>
                 </configuration>
diff --git a/mopub-sdk/proguard.txt b/mopub-sdk/proguard.txt
index 17b5b82f..0a2e3c08 100644
--- a/mopub-sdk/proguard.txt
+++ b/mopub-sdk/proguard.txt
@@ -10,7 +10,9 @@
 -keep class * extends com.mopub.mobileads.CustomEventBanner {}
 -keep class * extends com.mopub.mobileads.CustomEventInterstitial {}
 -keep class * extends com.mopub.nativeads.CustomEventNative {}
+-keep class * extends com.mopub.mobileads.CustomEventRewardedVideo {}
 
 # Support for Android Advertiser ID.
 -keep class com.google.android.gms.common.GooglePlayServicesUtil {*;}
 -keep class com.google.android.gms.ads.identifier.AdvertisingIdClient {*;}
+-keep class com.google.android.gms.ads.identifier.AdvertisingIdClient$Info {*;}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/AdFormat.java b/mopub-sdk/src/main/java/com/mopub/common/AdFormat.java
new file mode 100644
index 00000000..630c180e
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/AdFormat.java
@@ -0,0 +1,8 @@
+package com.mopub.common;
+
+public enum AdFormat {
+    BANNER,
+    INTERSTITIAL,
+    NATIVE,
+    REWARDED_VIDEO,
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/AdReport.java b/mopub-sdk/src/main/java/com/mopub/common/AdReport.java
new file mode 100644
index 00000000..0415b271
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/AdReport.java
@@ -0,0 +1,81 @@
+package com.mopub.common;
+
+import android.os.Build;
+import android.support.annotation.NonNull;
+
+import com.mopub.network.AdResponse;
+
+import java.io.Serializable;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
+
+/**
+ * A value class used for generating reports to send data back to MoPub
+ */
+public class AdReport implements Serializable {
+    private static final long serialVersionUID = 1L;
+
+    private static final String DATE_FORMAT_PATTERN = "M/d/yy hh:mm:ss a z";
+    private final AdResponse mAdResponse;
+    private final String mAdUnitId;
+    private final String mSdkVersion;
+    private final String mDeviceModel;
+    private final Locale mDeviceLocale;
+    private final String mUdid;
+
+    public AdReport(@NonNull String adUnitId, @NonNull ClientMetadata clientMetadata, @NonNull AdResponse adResponse) {
+        mAdUnitId = adUnitId;
+        mSdkVersion = clientMetadata.getSdkVersion();
+        mDeviceModel = clientMetadata.getDeviceModel();
+        mDeviceLocale = clientMetadata.getDeviceLocale();
+        mUdid = clientMetadata.getDeviceId();
+        mAdResponse = adResponse;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder parameters = new StringBuilder();
+        appendKeyValue(parameters, "sdk_version", mSdkVersion);
+        appendKeyValue(parameters, "creative_id", mAdResponse.getDspCreativeId());
+        appendKeyValue(parameters, "platform_version", Integer.toString(Build.VERSION.SDK_INT));
+        appendKeyValue(parameters, "device_model", mDeviceModel);
+        appendKeyValue(parameters, "ad_unit_id", mAdUnitId);
+        appendKeyValue(parameters, "device_locale",
+                mDeviceLocale == null ? null : mDeviceLocale.toString());
+        appendKeyValue(parameters, "device_id", mUdid);
+        appendKeyValue(parameters, "network_type", mAdResponse.getNetworkType());
+        appendKeyValue(parameters, "platform", "android");
+        appendKeyValue(parameters, "timestamp", getFormattedTimeStamp(mAdResponse.getTimestamp()));
+        appendKeyValue(parameters, "ad_type", mAdResponse.getAdType());
+        Integer width = mAdResponse.getWidth();
+        Integer height = mAdResponse.getHeight();
+        appendKeyValue(parameters, "ad_size", "{"
+                + (width == null ? "0" : width)
+                + ", "
+                + (height == null ? "0" : height)
+                + "}");
+
+        return parameters.toString();
+    }
+
+    public String getResponseString() {
+        return mAdResponse.getStringBody();
+    }
+
+    private void appendKeyValue(StringBuilder parameters, String key, String value) {
+        parameters.append(key);
+        parameters.append(" : ");
+        parameters.append(value);
+        parameters.append("\n");
+    }
+
+    private String getFormattedTimeStamp(long timeStamp) {
+        if (timeStamp != -1) {
+            SimpleDateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT_PATTERN, Locale.US);
+            return dateFormat.format(new Date(timeStamp));
+        } else {
+            return null;
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/AdType.java b/mopub-sdk/src/main/java/com/mopub/common/AdType.java
new file mode 100644
index 00000000..86543d5a
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/AdType.java
@@ -0,0 +1,14 @@
+package com.mopub.common;
+
+/**
+ * Valid values for the "X-Adtype" header from the MoPub ad server. The value of this header
+ * controls the custom event loading behavior.
+ */
+public class AdType {
+    public static final String HTML = "html";
+    public static final String MRAID = "mraid";
+    public static final String INTERSTITIAL = "interstitial";
+    public static final String NATIVE = "json";
+    public static final String CUSTOM = "custom";
+    public static final String CLEAR = "clear";
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/AdUrlGenerator.java b/mopub-sdk/src/main/java/com/mopub/common/AdUrlGenerator.java
index 2a012bed..397a0d04 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/AdUrlGenerator.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/AdUrlGenerator.java
@@ -2,25 +2,110 @@
 
 import android.content.Context;
 import android.location.Location;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
 
-import com.mopub.common.util.IntentUtils;
+import com.mopub.common.util.DateAndTime;
 
 import static com.mopub.common.ClientMetadata.MoPubNetworkType;
 
 public abstract class AdUrlGenerator extends BaseUrlGenerator {
-    private static TwitterAppInstalledStatus sTwitterAppInstalledStatus = TwitterAppInstalledStatus.UNKNOWN;
+
+    /**
+     * The ad unit id which identifies a spot for an ad to be placed.
+     */
+    private static final String AD_UNIT_ID_KEY = "id";
+
+    /**
+     * nv = native version. This is the version of MoPub.
+     */
+    private static final String SDK_VERSION_KEY = "nv";
+
+    /**
+     * q = query. This is for big publishers to send up certain
+     * keywords that better match ads.
+     */
+    private static final String KEYWORDS_KEY = "q";
+
+    /**
+     * Location represented in latitude and longitude.
+     * e.g. "47.638,-122.321"
+     */
+    private static final String LAT_LONG_KEY = "ll";
+
+    /**
+     * Estimated accuracy of this location, in meters.
+     * See {@link android.location.Location#getAccuracy()}
+     * for more information.
+     */
+    private static final String LAT_LONG_ACCURACY_KEY = "lla";
+
+    /**
+     * Milliseconds since location was updated.
+     */
+    private static final String LAT_LONG_FRESHNESS_KEY = "llf";
+
+    /**
+     * Whether or not the location came from the MoPub SDK
+     * and not the developer. 1 = from MoPub.
+     */
+    private static final String LAT_LONG_FROM_SDK_KEY = "llsdk";
+
+    /**
+     * Timezone offset. e.g. Pacific Standard Time = -0800.
+     */
+    private static final String TIMEZONE_OFFSET_KEY = "z";
+
+    /**
+     * "p" for portrait, "l" for landscape
+     */
+    private static final String ORIENTATION_KEY = "o";
+
+    /**
+     * Density as represented by a float. See
+     * http://developer.android.com/guide/practices/screens_support.html
+     * for details on values this can be.
+     */
+    private static final String SCREEN_SCALE_KEY = "sc_a";
+
+    /**
+     * Whether or not this is using mraid. 1 = yes.
+     */
+    private static final String IS_MRAID_KEY = "mr";
+
+    /**
+     * mcc, the mobile country code, paired with the mobile network code,
+     * uniquely identifies a carrier in a country.
+     */
+    private static final String MOBILE_COUNTRY_CODE_KEY = "mcc";
+    private static final String MOBILE_NETWORK_CODE_KEY = "mnc";
+
+    /**
+     * The International Organization for Standardization's 2-character country code
+     */
+    private static final String COUNTRY_CODE_KEY = "iso";
+
+    /**
+     * String name of the carrier. e.g. "Verizon%20Wireless"
+     */
+    private static final String CARRIER_NAME_KEY = "cn";
+
+    /**
+     * Carrier type as in what kind of network this device is on.
+     * See {@link android.net.ConnectivityManager} for constants.
+     */
+    private static final String CARRIER_TYPE_KEY = "ct";
+
+    /**
+     * Bundle ID, as in package name.
+     */
+    private static final String BUNDLE_ID_KEY = "bundle";
 
     protected Context mContext;
     protected String mAdUnitId;
     protected String mKeywords;
     protected Location mLocation;
 
-    public static enum TwitterAppInstalledStatus {
-        UNKNOWN,
-        NOT_INSTALLED,
-        INSTALLED,
-    }
-
     public AdUrlGenerator(Context context) {
         mContext = context;
     }
@@ -41,87 +126,132 @@ public AdUrlGenerator withLocation(Location location) {
     }
 
     protected void setAdUnitId(String adUnitId) {
-        addParam("id", adUnitId);
+        addParam(AD_UNIT_ID_KEY, adUnitId);
     }
 
     protected void setSdkVersion(String sdkVersion) {
-        addParam("nv", sdkVersion);
+        addParam(SDK_VERSION_KEY, sdkVersion);
     }
 
     protected void setKeywords(String keywords) {
-        addParam("q", keywords);
+        addParam(KEYWORDS_KEY, keywords);
     }
 
-    protected void setLocation(Location location) {
-        if (location != null) {
-            addParam("ll", location.getLatitude() + "," + location.getLongitude());
-            addParam("lla", "" + (int) location.getAccuracy());
+    protected void setLocation(@Nullable Location location) {
+        Location bestLocation = location;
+        Location locationFromLocationService = LocationService.getLastKnownLocation(mContext,
+                MoPub.getLocationPrecision(),
+                MoPub.getLocationAwareness());
+
+        if (locationFromLocationService != null &&
+                (location == null || locationFromLocationService.getTime() >= location.getTime())) {
+            bestLocation = locationFromLocationService;
+        }
+
+        if (bestLocation != null) {
+            addParam(LAT_LONG_KEY, bestLocation.getLatitude() + "," + bestLocation.getLongitude());
+            addParam(LAT_LONG_ACCURACY_KEY, String.valueOf((int) bestLocation.getAccuracy()));
+            addParam(LAT_LONG_FRESHNESS_KEY,
+                    String.valueOf(calculateLocationStalenessInMilliseconds(bestLocation)));
+
+            if (bestLocation == locationFromLocationService) {
+                addParam(LAT_LONG_FROM_SDK_KEY, "1");
+            }
         }
     }
 
     protected void setTimezone(String timeZoneOffsetString) {
-        addParam("z", timeZoneOffsetString);
+        addParam(TIMEZONE_OFFSET_KEY, timeZoneOffsetString);
     }
 
     protected void setOrientation(String orientation) {
-        addParam("o", orientation);
+        addParam(ORIENTATION_KEY, orientation);
     }
 
     protected void setDensity(float density) {
-        addParam("sc_a", "" + density);
+        addParam(SCREEN_SCALE_KEY, "" + density);
     }
 
     protected void setMraidFlag(boolean mraid) {
-        if (mraid) addParam("mr", "1");
+        if (mraid) {
+            addParam(IS_MRAID_KEY, "1");
+        }
     }
 
     protected void setMccCode(String networkOperator) {
         String mcc = networkOperator == null ? "" : networkOperator.substring(0, mncPortionLength(networkOperator));
-        addParam("mcc", mcc);
+        addParam(MOBILE_COUNTRY_CODE_KEY, mcc);
     }
 
     protected void setMncCode(String networkOperator) {
         String mnc = networkOperator == null ? "" : networkOperator.substring(mncPortionLength(networkOperator));
-        addParam("mnc", mnc);
+        addParam(MOBILE_NETWORK_CODE_KEY, mnc);
     }
 
     protected void setIsoCountryCode(String networkCountryIso) {
-        addParam("iso", networkCountryIso);
+        addParam(COUNTRY_CODE_KEY, networkCountryIso);
     }
 
     protected void setCarrierName(String networkOperatorName) {
-        addParam("cn", networkOperatorName);
+        addParam(CARRIER_NAME_KEY, networkOperatorName);
     }
 
     protected void setNetworkType(MoPubNetworkType networkType) {
-        addParam("ct", networkType);
+        addParam(CARRIER_TYPE_KEY, networkType);
     }
 
-    private void addParam(String key, MoPubNetworkType value) {
-        addParam(key, value.toString());
+    protected void setBundleId(String bundleId) {
+        if (!TextUtils.isEmpty(bundleId)) {
+            addParam(BUNDLE_ID_KEY, bundleId);
+        }
     }
 
-    private int mncPortionLength(String networkOperator) {
-        return Math.min(3, networkOperator.length());
-    }
+    protected void addBaseParams(final ClientMetadata clientMetadata) {
+        setAdUnitId(mAdUnitId);
 
-    protected void setTwitterAppInstalledFlag() {
-        if (sTwitterAppInstalledStatus == TwitterAppInstalledStatus.UNKNOWN) {
-            sTwitterAppInstalledStatus = getTwitterAppInstallStatus();
-        }
+        setSdkVersion(clientMetadata.getSdkVersion());
+        setDeviceInfo(clientMetadata.getDeviceManufacturer(),
+                clientMetadata.getDeviceModel(),
+                clientMetadata.getDeviceProduct());
+        setBundleId(clientMetadata.getAppPackageName());
 
-        if (sTwitterAppInstalledStatus == TwitterAppInstalledStatus.INSTALLED) {
-            addParam("ts", "1");
-        }
+        setKeywords(mKeywords);
+
+        setLocation(mLocation);
+
+        setTimezone(DateAndTime.getTimeZoneOffsetString());
+
+        setOrientation(clientMetadata.getOrientationString());
+        setDeviceDimensions(clientMetadata.getDeviceDimensions());
+        setDensity(clientMetadata.getDensity());
+
+        final String networkOperator = clientMetadata.getNetworkOperatorForUrl();
+        setMccCode(networkOperator);
+        setMncCode(networkOperator);
+
+        setIsoCountryCode(clientMetadata.getIsoCountryCode());
+        setCarrierName(clientMetadata.getNetworkOperatorName());
+
+        setNetworkType(clientMetadata.getActiveNetworkType());
+
+        setAppVersion(clientMetadata.getAppVersion());
+
+        appendAdvertisingInfoTemplates();
     }
 
-    public TwitterAppInstalledStatus getTwitterAppInstallStatus() {
-        return IntentUtils.canHandleTwitterUrl(mContext) ? TwitterAppInstalledStatus.INSTALLED : TwitterAppInstalledStatus.NOT_INSTALLED;
+    private void addParam(String key, MoPubNetworkType value) {
+        addParam(key, value.toString());
+    }
+
+    private int mncPortionLength(String networkOperator) {
+        return Math.min(3, networkOperator.length());
     }
 
-    @Deprecated // for testing
-    public static void setTwitterAppInstalledStatus(TwitterAppInstalledStatus status) {
-        sTwitterAppInstalledStatus = status;
+    private static int calculateLocationStalenessInMilliseconds(final Location location) {
+        Preconditions.checkNotNull(location);
+        final long locationLastUpdatedInMillis = location.getTime();
+        final long nowInMillis = System.currentTimeMillis();
+        return (int) (nowInMillis - locationLastUpdatedInMillis);
     }
 
     /**
diff --git a/mopub-sdk/src/main/java/com/mopub/common/BaseLifecycleListener.java b/mopub-sdk/src/main/java/com/mopub/common/BaseLifecycleListener.java
new file mode 100644
index 00000000..994f01db
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/BaseLifecycleListener.java
@@ -0,0 +1,36 @@
+package com.mopub.common;
+
+import android.app.Activity;
+import android.support.annotation.NonNull;
+
+/**
+ * This empty implementation of {@link com.mopub.common.LifecycleListener} is convenient for writing
+ * your own adapters for an SDK that MoPub can mediate. You can override only the lifecycle callbacks
+ * that the SDK requires.
+ */
+public class BaseLifecycleListener implements LifecycleListener {
+
+    @Override
+    public void onCreate(@NonNull final Activity activity) {}
+
+    @Override
+    public void onStart(@NonNull final Activity activity) {}
+
+    @Override
+    public void onPause(@NonNull final Activity activity) {}
+
+    @Override
+    public void onResume(@NonNull final Activity activity) {}
+
+    @Override
+    public void onRestart(@NonNull final Activity activity) {}
+
+    @Override
+    public void onStop(@NonNull final Activity activity) {}
+
+    @Override
+    public void onDestroy(@NonNull final Activity activity) {}
+
+    @Override
+    public void onBackPressed(@NonNull final Activity activity) {}
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/BaseUrlGenerator.java b/mopub-sdk/src/main/java/com/mopub/common/BaseUrlGenerator.java
index 2b7eb021..68d88289 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/BaseUrlGenerator.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/BaseUrlGenerator.java
@@ -1,12 +1,17 @@
 package com.mopub.common;
 
+import android.graphics.Point;
 import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.text.TextUtils;
 
-import static com.mopub.common.util.Strings.isEmpty;
+import com.mopub.network.Networking;
+import com.mopub.network.PlayServicesUrlRewriter;
 
 public abstract class BaseUrlGenerator {
-    private static final String IFA_PREFIX = "ifa:";
-    private static final String SHA_PREFIX = "sha:";
+
+    private static final String WIDTH_KEY = "w";
+    private static final String HEIGHT_KEY = "h";
 
     private StringBuilder mStringBuilder;
     private boolean mFirstParam;
@@ -14,7 +19,8 @@
     public abstract String generateUrlString(String serverHostname);
 
     protected void initUrlString(String serverHostname, String handlerType) {
-        mStringBuilder = new StringBuilder("http://" + serverHostname + handlerType);
+        String scheme = Networking.useHttps() ? Constants.HTTPS : Constants.HTTP;
+        mStringBuilder = new StringBuilder(scheme).append("://").append(serverHostname).append(handlerType);
         mFirstParam = true;
     }
 
@@ -23,7 +29,7 @@ protected String getFinalUrlString() {
     }
 
     protected void addParam(String key, String value) {
-        if (value == null || isEmpty(value)) {
+        if (TextUtils.isEmpty(value)) {
             return;
         }
 
@@ -76,4 +82,23 @@ protected void setDoNotTrack(boolean dnt) {
     protected void setUdid(String udid) {
         addParam("udid", udid);
     }
+
+    /**
+     * Appends special keys/values for advertising id and do-not-track. PlayServicesUrlRewriter will
+     * replace these templates with the correct values when the request is processed.
+     */
+    protected void appendAdvertisingInfoTemplates() {
+        addParam("udid", PlayServicesUrlRewriter.UDID_TEMPLATE);
+        addParam("dnt", PlayServicesUrlRewriter.DO_NOT_TRACK_TEMPLATE);
+    }
+
+    /**
+     * Adds the width and height.
+     *
+     * @param dimensions The width and height of the screen
+     */
+    protected void setDeviceDimensions(@NonNull final Point dimensions) {
+        addParam(WIDTH_KEY, "" + dimensions.x);
+        addParam(HEIGHT_KEY, "" + dimensions.y);
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/CacheService.java b/mopub-sdk/src/main/java/com/mopub/common/CacheService.java
index fcc5fad2..81f77af7 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/CacheService.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/CacheService.java
@@ -32,19 +32,6 @@
     private static final int DISK_CACHE_INDEX = 0;
 
     private static DiskLruCache sDiskLruCache;
-    private static BitmapLruCache sBitmapLruCache;
-
-    public static boolean initializeBitmapCache(final Context context) {
-        if (context == null) {
-            return false;
-        }
-
-        if (sBitmapLruCache == null) {
-            final int memoryCacheSizeBytes = DeviceUtils.memoryCacheSizeBytes(context);
-            sBitmapLruCache = new BitmapLruCache(memoryCacheSizeBytes);
-        }
-        return true;
-    }
 
     public static boolean initializeDiskCache(final Context context) {
         if (context == null) {
@@ -69,7 +56,6 @@ public static boolean initializeDiskCache(final Context context) {
     }
 
     public static void initialize(final Context context) {
-        initializeBitmapCache(context);
         initializeDiskCache(context);
     }
 
@@ -110,14 +96,6 @@ public static String getFilePathDiskCache(final String key) {
                 + DISK_CACHE_INDEX;
     }
 
-    public static Bitmap getFromBitmapCache(final String key) {
-        if (sBitmapLruCache == null) {
-            return null;
-        }
-
-        return sBitmapLruCache.get(key);
-    }
-
     public static byte[] getFromDiskCache(final String key) {
         if (sDiskLruCache == null) {
             return null;
@@ -156,14 +134,6 @@ public static void getFromDiskCacheAsync(final String key, final DiskLruCacheGet
         new DiskLruCacheGetTask(key, diskLruCacheGetListener).execute();
     }
 
-    public static void putToBitmapCache(final String key, final Bitmap bitmap) {
-        if (sBitmapLruCache == null) {
-            return;
-        }
-
-        sBitmapLruCache.put(key, bitmap);
-    }
-
     public static boolean putToDiskCache(final String key, final byte[] content) {
         return putToDiskCache(key, new ByteArrayInputStream(content));
     }
@@ -208,21 +178,6 @@ public static void putToDiskCacheAsync(final String key, final byte[] content) {
         new DiskLruCachePutTask(key, content).execute();
     }
 
-    private static class BitmapLruCache extends LruCache<String, Bitmap> {
-        public BitmapLruCache(final int maxSize) {
-            super(maxSize);
-        }
-
-        @Override
-        protected int sizeOf(final String key, final Bitmap bitmap) {
-            if (bitmap != null) {
-                return bitmap.getRowBytes() * bitmap.getHeight();
-            }
-
-            return super.sizeOf(key, bitmap);
-        }
-    }
-
     private static class DiskLruCacheGetTask extends AsyncTask<Void, Void, byte[]> {
         private final DiskLruCacheGetListener mDiskLruCacheGetListener;
         private final String mKey;
@@ -285,17 +240,6 @@ public static void clearAndNullCaches() {
                 sDiskLruCache = null;
             }
         }
-        if (sBitmapLruCache != null) {
-            sBitmapLruCache.evictAll();
-            sBitmapLruCache = null;
-        }
-    }
-
-    // Testing
-    @Deprecated
-    @VisibleForTesting
-    public static LruCache<String, Bitmap> getBitmapLruCache() {
-        return sBitmapLruCache;
     }
 
     // Testing
diff --git a/mopub-sdk/src/main/java/com/mopub/common/ClientMetadata.java b/mopub-sdk/src/main/java/com/mopub/common/ClientMetadata.java
index 6589c171..412f47be 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/ClientMetadata.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/ClientMetadata.java
@@ -1,8 +1,11 @@
 package com.mopub.common;
 
 import android.content.Context;
+import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
 import android.content.res.Configuration;
+import android.graphics.Point;
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
 import android.os.Build;
@@ -10,9 +13,14 @@
 import android.telephony.TelephonyManager;
 
 import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.DeviceUtils;
+import com.mopub.common.util.Dips;
 import com.mopub.common.util.Utils;
 
+import java.util.Locale;
+
 import static android.Manifest.permission.ACCESS_NETWORK_STATE;
+import static android.content.pm.PackageManager.NameNotFoundException;
 import static android.content.pm.PackageManager.PERMISSION_GRANTED;
 
 /**
@@ -30,50 +38,17 @@
     private static final String SHA_PREFIX = "sha:";
     private static final int UNKNOWN_NETWORK = -1;
 
-    private static volatile ClientMetadata sInstance;
-
-    private String mNetworkOperator;
-    private String mIsoCountryCode;
+    private String mNetworkOperatorForUrl;
+    private final String mNetworkOperator;
+    private String mSimOperator;
+    private final String mIsoCountryCode;
+    private final String mSimIsoCountryCode;
     private String mNetworkOperatorName;
+    private String mSimOperatorName;
     private String mUdid;
     private boolean mDoNotTrack = false;
     private boolean mAdvertisingInfoSet = false;
 
-    /**
-     * Returns the singleton ClientMetadata object, using the context to obtain data if necessary.
-     */
-    public static ClientMetadata getInstance(Context context) {
-        // Use a local variable so we can reduce accesses of the volatile field.
-        ClientMetadata result = sInstance;
-        if (result == null) {
-            synchronized (ClientMetadata.class) {
-                result = sInstance;
-                if (result == null) {
-                    result = new ClientMetadata(context);
-                    sInstance = result;
-                }
-            }
-        }
-        return result;
-    }
-
-    /**
-     * Can be used by background threads and other objects without a context to attempt to get
-     * ClientMetadata. If the object has never been referenced from a thread with a context,
-     * this will return null.
-     */
-    public static ClientMetadata getInstance() {
-        ClientMetadata result = sInstance;
-        if (result == null) {
-            // If it's being initialized in another thread, wait for the lock.
-            synchronized (ClientMetadata.class) {
-                result = sInstance;
-            }
-        }
-
-        return result;
-    }
-
     public static enum MoPubNetworkType {
         UNKNOWN(0),
         ETHERNET(1),
@@ -81,7 +56,6 @@ public static ClientMetadata getInstance() {
         MOBILE(3);
 
         private final int mId;
-
         private MoPubNetworkType(int id) {
             mId = id;
         }
@@ -107,44 +81,108 @@ private static MoPubNetworkType fromAndroidNetworkType(int type) {
                     return UNKNOWN;
             }
         }
+
+        public int getId() {
+            return mId;
+        }
     }
 
+    private static volatile ClientMetadata sInstance;
+
     // Cached client metadata used for generating URLs and events.
     private final String mDeviceManufacturer;
     private final String mDeviceModel;
     private final String mDeviceProduct;
+    private final String mDeviceOsVersion;
     private final String mSdkVersion;
     private final String mAppVersion;
+    private final String mAppPackageName;
+    private String mAppName;
     private final Context mContext;
     private final ConnectivityManager mConnectivityManager;
 
-    private ClientMetadata(Context context) {
+    /**
+     * Returns the singleton ClientMetadata object, using the context to obtain data if necessary.
+     */
+    public static ClientMetadata getInstance(Context context) {
+        // Use a local variable so we can reduce accesses of the volatile field.
+        ClientMetadata result = sInstance;
+        if (result == null) {
+            synchronized (ClientMetadata.class) {
+                result = sInstance;
+                if (result == null) {
+                    result = new ClientMetadata(context);
+                    sInstance = result;
+                }
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Can be used by background threads and other objects without a context to attempt to get
+     * ClientMetadata. If the object has never been referenced from a thread with a context,
+     * this will return null.
+     */
+    public static ClientMetadata getInstance() {
+        ClientMetadata result = sInstance;
+        if (result == null) {
+            // If it's being initialized in another thread, wait for the lock.
+            synchronized (ClientMetadata.class) {
+                result = sInstance;
+            }
+        }
+
+        return result;
+    }
+
+    // NEVER CALL THIS AS A USER. Get it from the Singletons class.
+    public ClientMetadata(Context context) {
         mContext = context.getApplicationContext();
         mConnectivityManager =
                 (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
         mDeviceManufacturer = Build.MANUFACTURER;
         mDeviceModel = Build.MODEL;
         mDeviceProduct = Build.PRODUCT;
+        mDeviceOsVersion = Build.VERSION.RELEASE;
+
         mSdkVersion = MoPub.SDK_VERSION;
 
         // Cache context items that don't change:
         mAppVersion = getAppVersionFromContext(mContext);
+        PackageManager packageManager = mContext.getPackageManager();
+        ApplicationInfo applicationInfo = null;
+        mAppPackageName = context.getPackageName();
+        try {
+            applicationInfo = packageManager.getApplicationInfo(mAppPackageName, 0);
+        } catch (final NameNotFoundException e) {
+            // swallow
+        }
+        if (applicationInfo != null) {
+            mAppName = (String) packageManager.getApplicationLabel(applicationInfo);
+        }
 
         final TelephonyManager telephonyManager =
                 (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);
-
+        mNetworkOperatorForUrl = telephonyManager.getNetworkOperator();
         mNetworkOperator = telephonyManager.getNetworkOperator();
         if (telephonyManager.getPhoneType() == TelephonyManager.PHONE_TYPE_CDMA &&
                 telephonyManager.getSimState() == TelephonyManager.SIM_STATE_READY) {
-            mNetworkOperator = telephonyManager.getSimOperator();
+            mNetworkOperatorForUrl = telephonyManager.getSimOperator();
+            mSimOperator = telephonyManager.getSimOperator();
         }
 
         mIsoCountryCode = telephonyManager.getNetworkCountryIso();
+        mSimIsoCountryCode = telephonyManager.getSimCountryIso();
         try {
             // Some Lenovo devices require READ_PHONE_STATE here.
             mNetworkOperatorName = telephonyManager.getNetworkOperatorName();
+            if (telephonyManager.getSimState() == TelephonyManager.SIM_STATE_READY) {
+                mSimOperatorName = telephonyManager.getSimOperatorName();
+            }
         } catch (SecurityException e) {
             mNetworkOperatorName = null;
+            mSimOperatorName = null;
         }
 
         // Get the device ID. This will be replaced later when the Play Services callbacks complete.
@@ -205,6 +243,13 @@ public float getDensity() {
         return mContext.getResources().getDisplayMetrics().density;
     }
 
+    /**
+     * @return the network operator for URL generators.
+     */
+    public String getNetworkOperatorForUrl() {
+        return mNetworkOperatorForUrl;
+    }
+
     /**
      * @return the network operator.
      */
@@ -212,6 +257,17 @@ public String getNetworkOperator() {
         return mNetworkOperator;
     }
 
+    public Locale getDeviceLocale() {
+        return mContext.getResources().getConfiguration().locale;
+    }
+
+    /**
+     * @return the sim operator.
+     */
+    public String getSimOperator() {
+        return mSimOperator;
+    }
+
     /**
      * @return the country code of the device.
      */
@@ -219,6 +275,13 @@ public String getIsoCountryCode() {
         return mIsoCountryCode;
     }
 
+    /**
+     * @return the sim provider's country code.
+     */
+    public String getSimIsoCountryCode() {
+        return mSimIsoCountryCode;
+    }
+
     /**
      * @return the network operator name.
      */
@@ -226,10 +289,17 @@ public String getNetworkOperatorName() {
         return mNetworkOperatorName;
     }
 
+    /**
+     * @return the sim operator name.
+     */
+    public String getSimOperatorName() {
+        return mSimOperatorName;
+    }
+
     /**
      * @return the stored device ID.
      */
-    public synchronized String getAdvertisingId() {
+    public synchronized String getDeviceId() {
         return mUdid;
     }
 
@@ -272,6 +342,41 @@ public String getDeviceProduct() {
         return mDeviceProduct;
     }
 
+    /**
+     * @return the device os version.
+     */
+    public String getDeviceOsVersion() {
+        return mDeviceOsVersion;
+    }
+
+    /**
+     * @return the device screen width in dips according to current orientation.
+     */
+    public int getDeviceScreenWidthDip() {
+        return Dips.screenWidthAsIntDips(mContext);
+    }
+
+    /**
+     * @return the device screen height in dips according to current orientation.
+     */
+    public int getDeviceScreenHeightDip() {
+        return Dips.screenHeightAsIntDips(mContext);
+    }
+
+    /**
+     * This tries to get the physical number of pixels on the device. This attempts to include
+     * the pixels in the notification bar and soft buttons. This method only works after
+     * mContext is initialized.
+     *
+     * @return Width and height of the device. This is 0 by 0 if there is no context.
+     */
+    public Point getDeviceDimensions() {
+        if (Preconditions.NoThrow.checkNotNull(mContext)) {
+            return DeviceUtils.getDeviceDimensions(mContext);
+        }
+        return new Point(0, 0);
+    }
+
     /**
      * @return the MoPub SDK Version.
      */
@@ -286,8 +391,30 @@ public String getAppVersion() {
         return mAppVersion;
     }
 
+    /**
+     * @return the package of the application the SDK is included in.
+     */
+    public String getAppPackageName() {
+        return mAppPackageName;
+    }
+
+    /**
+     * @return the name of the application the SDK is included in.
+     */
+    public String getAppName() {
+        return mAppName;
+    }
+
+    @Deprecated
+    @VisibleForTesting
+    public static void setInstance(ClientMetadata clientMetadata) {
+        synchronized (ClientMetadata.class) {
+            sInstance = clientMetadata;
+        }
+    }
+
     @VisibleForTesting
-    public static synchronized void clearForTesting() {
+    public static void clearForTesting() {
         sInstance = null;
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/CloseableLayout.java b/mopub-sdk/src/main/java/com/mopub/common/CloseableLayout.java
new file mode 100644
index 00000000..a38f4b52
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/CloseableLayout.java
@@ -0,0 +1,295 @@
+package com.mopub.common;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Rect;
+import android.graphics.drawable.StateListDrawable;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.view.Gravity;
+import android.view.MotionEvent;
+import android.view.SoundEffectConstants;
+import android.view.ViewConfiguration;
+import android.widget.FrameLayout;
+
+import com.mopub.common.util.Dips;
+
+import static com.mopub.common.util.Drawables.INTERSTITIAL_CLOSE_BUTTON_NORMAL;
+import static com.mopub.common.util.Drawables.INTERSTITIAL_CLOSE_BUTTON_PRESSED;
+
+/**
+ * CloseableLayout provides a layout class that shows a close button, and allows setting a
+ * {@link OnCloseListener}. Otherwise CloseableLayout behaves identically to
+ * {@link FrameLayout}.
+ *
+ * Rather than adding a button to the view tree, CloseableLayout is designed to draw the close
+ * button directly on the canvas and to track MotionEvents on its close region. While
+ * marginally more efficient, the main benefit to this is that CloseableLayout can function
+ * exactly as a regular FrameLayout without needing to override addView, removeView,
+ * removeAllViews, and a host of other methods.
+ *
+ * You can hide the close button using {@link #setCloseVisible} and change its position
+ * using {@link #setClosePosition}.
+ */
+public class CloseableLayout extends FrameLayout {
+    public interface OnCloseListener {
+        void onClose();
+    }
+
+    @VisibleForTesting
+    static final float CLOSE_BUTTON_SIZE_DP = 30.0f;
+    static final float CLOSE_REGION_SIZE_DP = 50.0f;
+
+    @VisibleForTesting
+    static final float CLOSE_BUTTON_PADDING_DP = 8.0f;
+
+    /**
+     * Defines a subset of supported gravity combinations for the CloseableLayout. These values
+     * include the possible values for customClosePosition as defined in the
+     * <a href="http://www.iab.net/media/file/IAB_MRAID_v2_FINAL.pdf">MRAID 2.0
+     * specification</a>.
+     */
+    public static enum ClosePosition {
+        TOP_LEFT(Gravity.TOP | Gravity.LEFT),
+        TOP_CENTER(Gravity.TOP | Gravity.CENTER_HORIZONTAL),
+        TOP_RIGHT(Gravity.TOP | Gravity.RIGHT),
+        CENTER(Gravity.CENTER),
+        BOTTOM_LEFT(Gravity.BOTTOM | Gravity.LEFT),
+        BOTTOM_CENTER(Gravity.BOTTOM | Gravity.CENTER_HORIZONTAL),
+        BOTTOM_RIGHT(Gravity.BOTTOM | Gravity.RIGHT);
+
+        private final int mGravity;
+
+        ClosePosition(final int mGravity) {
+            this.mGravity = mGravity;
+        }
+
+        int getGravity() {
+            return mGravity;
+        }
+    }
+
+    // Used in onTouchEvent to be lenient about moving outside the close button bounds. This is the
+    // same pattern used in the Android framework to handle click events.
+    private final int mTouchSlop;
+
+    @Nullable
+    private OnCloseListener mOnCloseListener;
+
+    @NonNull
+    private final StateListDrawable mCloseDrawable;
+    @NonNull
+    private ClosePosition mClosePosition;
+    private final int mCloseRegionSize;  // Size of the touchable close region.
+    private final int mCloseButtonSize;  // Size of the drawn close button.
+    private final int mCloseButtonPadding;
+
+    // Whether we need to recalculate the close bounds on the next draw pass
+    private boolean mCloseBoundChanged;
+
+    // Hang on to our bounds Rects so we don't allocate memory in the draw() method.
+    private final Rect mClosableLayoutRect = new Rect();
+    private final Rect mCloseRegionBounds = new Rect();
+    private final Rect mCloseButtonBounds = new Rect();
+    private final Rect mInsetCloseRegionBounds = new Rect();
+
+    @Nullable
+    private UnsetPressedState mUnsetPressedState;
+
+    public CloseableLayout(@NonNull Context context) {
+        super(context);
+
+        mCloseDrawable = new StateListDrawable();
+        mClosePosition = ClosePosition.TOP_RIGHT;
+
+        mCloseDrawable.addState(SELECTED_STATE_SET,
+                INTERSTITIAL_CLOSE_BUTTON_PRESSED.createDrawable(context));
+        mCloseDrawable.addState(EMPTY_STATE_SET,
+                INTERSTITIAL_CLOSE_BUTTON_NORMAL.createDrawable(context));
+
+        mCloseDrawable.setState(EMPTY_STATE_SET);
+        mCloseDrawable.setCallback(this);
+
+        mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop();
+
+        mCloseRegionSize = Dips.asIntPixels(CLOSE_REGION_SIZE_DP, context);
+        mCloseButtonSize = Dips.asIntPixels(CLOSE_BUTTON_SIZE_DP, context);
+        mCloseButtonPadding = Dips.asIntPixels(CLOSE_BUTTON_PADDING_DP, context);
+
+        setWillNotDraw(false);
+    }
+
+    public void setOnCloseListener(@Nullable OnCloseListener onCloseListener) {
+        mOnCloseListener = onCloseListener;
+    }
+
+    public void setClosePosition(@NonNull ClosePosition closePosition) {
+        Preconditions.checkNotNull(closePosition);
+
+        mClosePosition = closePosition;
+        mCloseBoundChanged = true;
+        invalidate();
+    }
+
+    public void setCloseVisible(boolean visible) {
+        if (mCloseDrawable.setVisible(visible, false)) {
+            invalidate(mCloseRegionBounds);
+        }
+    }
+
+    @Override
+    protected void onSizeChanged(int width, int height, int oldWidth, int oldHeight) {
+        super.onSizeChanged(width, height, oldWidth, oldHeight);
+        mCloseBoundChanged = true;
+    }
+
+    @Override
+    public void draw(@NonNull final Canvas canvas) {
+        super.draw(canvas);
+
+        // Only recalculate the close bounds if they are dirty
+        if (mCloseBoundChanged) {
+            mCloseBoundChanged = false;
+
+            mClosableLayoutRect.set(0, 0, getWidth(), getHeight());
+            // Create the bounds for our close regions.
+            applyCloseRegionBounds(mClosePosition, mClosableLayoutRect, mCloseRegionBounds);
+
+            // The inset rect applies padding around the visible closeButton.
+            mInsetCloseRegionBounds.set(mCloseRegionBounds);
+            mInsetCloseRegionBounds.inset(mCloseButtonPadding, mCloseButtonPadding);
+            // The close button sits inside the close region with padding and gravity
+            // in the same way the close region sits inside the whole ClosableLayout
+            applyCloseButtonBounds(mClosePosition, mInsetCloseRegionBounds, mCloseButtonBounds);
+            mCloseDrawable.setBounds(mCloseButtonBounds);
+        }
+
+        // Draw last so that this gets drawn as the top layer. This is also why we override
+        // draw instead of onDraw.
+        if (mCloseDrawable.isVisible()) {
+            mCloseDrawable.draw(canvas);
+        }
+    }
+
+    public void applyCloseRegionBounds(ClosePosition closePosition, Rect bounds, Rect closeBounds) {
+        applyCloseBoundsWithSize(closePosition, mCloseRegionSize, bounds, closeBounds);
+    }
+
+    private void applyCloseButtonBounds(ClosePosition closePosition, Rect bounds, Rect outBounds) {
+        applyCloseBoundsWithSize(closePosition, mCloseButtonSize, bounds, outBounds);
+    }
+
+    private void applyCloseBoundsWithSize(ClosePosition closePosition, final int size, Rect bounds, Rect outBounds) {
+        Gravity.apply(closePosition.getGravity(), size, size, bounds, outBounds);
+    }
+
+    @Override
+    public boolean onInterceptTouchEvent(@NonNull final MotionEvent event) {
+        // See http://developer.android.com/training/gestures/viewgroup.html for details on
+        // capturing motion events
+
+        // Start intercepting touch events only when we see a down event
+        if (event.getAction() != MotionEvent.ACTION_DOWN) {
+            return false;
+        }
+
+        // Start intercepting if the down event is in the close bounds. Returning true
+        // here causes onTouchEvent to get called for all events up until ACTION_CANCEL gets called.
+        final int x = (int) event.getX();
+        final int y = (int) event.getY();
+        return pointInCloseBounds(x, y, 0);
+    }
+
+    @Override
+    public boolean onTouchEvent(@NonNull MotionEvent event) {
+        // Stop receiving touch events if we aren't within the bounds, including some slop.
+        final int x = (int) event.getX();
+        final int y = (int) event.getY();
+        if (!pointInCloseBounds(x, y, mTouchSlop)) {
+            setClosePressed(false);
+            super.onTouchEvent(event);
+            return false;
+        }
+
+        switch (event.getAction()) {
+            case MotionEvent.ACTION_DOWN:
+                setClosePressed(true);
+                break;
+            case MotionEvent.ACTION_CANCEL:
+                // Cancelled by a parent
+                setClosePressed(false);
+                break;
+            case MotionEvent.ACTION_UP:
+                if (isClosePressed()) {
+                    // Delay setting the unpressed state so that the button remains pressed
+                    // at least long enough to respond to the close event.
+                    if (mUnsetPressedState == null) {
+                        mUnsetPressedState = new UnsetPressedState();
+                    }
+                    postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration());
+                    performClose();
+                }
+                break;
+        }
+        return true;
+    }
+
+    private void setClosePressed(boolean pressed) {
+        if (pressed == isClosePressed()) {
+            return;
+        }
+
+        mCloseDrawable.setState(pressed ? SELECTED_STATE_SET : EMPTY_STATE_SET);
+        invalidate(mCloseRegionBounds);
+    }
+
+    @VisibleForTesting
+    boolean isClosePressed() {
+        return mCloseDrawable.getState() == SELECTED_STATE_SET;
+    }
+
+    @VisibleForTesting
+    boolean pointInCloseBounds(int x, int y, int slop) {
+        return x >= mCloseRegionBounds.left - slop
+                && y >= mCloseRegionBounds.top - slop
+                && x < mCloseRegionBounds.right + slop
+                && y < mCloseRegionBounds.bottom + slop;
+    }
+
+    private void performClose() {
+        playSoundEffect(SoundEffectConstants.CLICK);
+        if (mOnCloseListener != null) {
+            mOnCloseListener.onClose();
+        }
+    }
+
+    /**
+     * This is a copy of the UnsetPressedState pattern from Android's View.java, which is used
+     * to unset the pressed state of a button after a delay.
+     */
+    private final class UnsetPressedState implements Runnable {
+        public void run() {
+            setClosePressed(false);
+        }
+    }
+
+    @VisibleForTesting
+    void setCloseBounds(Rect closeBounds) {
+        mCloseRegionBounds.set(closeBounds);
+    }
+
+    @VisibleForTesting
+    Rect getCloseBounds() {
+        return mCloseRegionBounds;
+    }
+
+    @VisibleForTesting
+    void setCloseBoundChanged(boolean changed) {
+        mCloseBoundChanged = changed;
+    }
+
+    @VisibleForTesting
+    public boolean isCloseVisible() {
+        return mCloseDrawable.isVisible();
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/Constants.java b/mopub-sdk/src/main/java/com/mopub/common/Constants.java
new file mode 100644
index 00000000..0ca157fe
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/Constants.java
@@ -0,0 +1,20 @@
+package com.mopub.common;
+
+public class Constants {
+    private Constants() {}
+
+    public static final String HTTP = "http";
+    public static final String HTTPS = "https";
+
+    public static final String HOST = "ads.mopub.com";
+
+    public static final String AD_HANDLER = "/m/ad";
+    public static final String CONVERSION_TRACKING_HANDLER = "/m/open";
+    public static final String POSITIONING_HANDLER = "/m/pos";
+
+
+    public static final int TEN_SECONDS_MILLIS = 10 * 1000;
+    public static final int THIRTY_SECONDS_MILLIS = 30 * 1000;
+
+    public static final int TEN_MB = 10 * 1024 * 1024;
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/CreativeOrientation.java b/mopub-sdk/src/main/java/com/mopub/common/CreativeOrientation.java
new file mode 100644
index 00000000..f6fec437
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/CreativeOrientation.java
@@ -0,0 +1,24 @@
+package com.mopub.common;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+/**
+ * Represents the orientation returned for MoPub ads from the MoPub ad server.
+ */
+public enum CreativeOrientation {
+    PORTRAIT, LANDSCAPE, UNDEFINED;
+
+    @NonNull
+    public static CreativeOrientation fromHeader(@Nullable String orientation) {
+        if ("l".equalsIgnoreCase(orientation)) {
+            return LANDSCAPE;
+        }
+
+        if ("p".equalsIgnoreCase(orientation)) {
+            return PORTRAIT;
+        }
+
+        return UNDEFINED;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/DataKeys.java b/mopub-sdk/src/main/java/com/mopub/common/DataKeys.java
new file mode 100644
index 00000000..3adb73e3
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/DataKeys.java
@@ -0,0 +1,18 @@
+package com.mopub.common;
+
+/**
+ * Keys used in localExtras and serverExtras maps for MoPub custom events.
+ */
+public class DataKeys {
+    public static final String AD_REPORT_KEY = "mopub-intent-ad-report";
+    public static final String HTML_RESPONSE_BODY_KEY = "Html-Response-Body";
+    public static final String REDIRECT_URL_KEY = "Redirect-Url";
+    public static final String CLICKTHROUGH_URL_KEY = "Clickthrough-Url";
+    public static final String SCROLLABLE_KEY = "Scrollable";
+    public static final String CREATIVE_ORIENTATION_KEY = "com_mopub_orientation";
+    public static final String JSON_BODY_KEY = "com_mopub_native_json";
+    public static final String BROADCAST_IDENTIFIER_KEY = "broadcastIdentifier";
+    public static final String AD_UNIT_ID_KEY = "com_mopub_ad_unit_id";
+    public static final String AD_WIDTH = "com_mopub_ad_width";
+    public static final String AD_HEIGHT = "com_mopub_ad_height";
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/DiskLruCache.java b/mopub-sdk/src/main/java/com/mopub/common/DiskLruCache.java
index 0c603e66..c62d6594 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/DiskLruCache.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/DiskLruCache.java
@@ -16,6 +16,8 @@
 
 package com.mopub.common;
 
+import android.support.annotation.NonNull;
+
 import java.io.BufferedWriter;
 import java.io.Closeable;
 import java.io.EOFException;
@@ -846,7 +848,7 @@ private FaultHidingOutputStream(OutputStream out) {
         }
       }
 
-      @Override public void write(byte[] buffer, int offset, int length) {
+      @Override public void write(@NonNull byte[] buffer, int offset, int length) {
         try {
           out.write(buffer, offset, length);
         } catch (IOException e) {
diff --git a/mopub-sdk/src/main/java/com/mopub/common/DownloadResponse.java b/mopub-sdk/src/main/java/com/mopub/common/DownloadResponse.java
index 6b396539..6ce126e8 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/DownloadResponse.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/DownloadResponse.java
@@ -4,6 +4,7 @@
 import com.mopub.common.util.Streams;
 
 import org.apache.http.Header;
+import org.apache.http.HttpEntity;
 import org.apache.http.HttpResponse;
 
 import java.io.BufferedInputStream;
@@ -19,9 +20,12 @@ public DownloadResponse(final HttpResponse httpResponse) throws Exception {
         final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
         BufferedInputStream inputStream = null;
         try {
-            inputStream = new BufferedInputStream(httpResponse.getEntity().getContent());
-            Streams.copyContent(inputStream, outputStream);
-            mBytes = outputStream.toByteArray();
+            HttpEntity httpEntity = httpResponse.getEntity();
+            if (httpEntity != null) {
+                inputStream = new BufferedInputStream(httpEntity.getContent());
+                Streams.copyContent(inputStream, outputStream);
+                mBytes = outputStream.toByteArray();
+            }
         } finally {
             Streams.closeStream(inputStream);
             Streams.closeStream(outputStream);
diff --git a/mopub-sdk/src/main/java/com/mopub/common/DownloadTask.java b/mopub-sdk/src/main/java/com/mopub/common/DownloadTask.java
index fc31c97c..7230a2ae 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/DownloadTask.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/DownloadTask.java
@@ -2,7 +2,9 @@
 
 import android.net.http.AndroidHttpClient;
 import android.os.AsyncTask;
+
 import com.mopub.common.logging.MoPubLog;
+
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpUriRequest;
 
@@ -39,7 +41,6 @@ protected DownloadResponse doInBackground(final HttpUriRequest... httpUriRequest
             return new DownloadResponse(httpResponse);
         } catch (Exception e) {
             MoPubLog.d("Download task threw an internal exception", e);
-            cancel(true);
             return null;
         } finally {
             if (httpClient != null) {
@@ -60,6 +61,6 @@ protected void onPostExecute(final DownloadResponse downloadResponse) {
 
     @Override
     protected void onCancelled() {
-        mDownloadTaskListener.onComplete(mUrl, null);
+        MoPubLog.d("DownloadTask was cancelled.");
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/GpsHelper.java b/mopub-sdk/src/main/java/com/mopub/common/GpsHelper.java
index 75b9bdf7..e26371b0 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/GpsHelper.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/GpsHelper.java
@@ -2,6 +2,8 @@
 
 import android.content.Context;
 import android.os.AsyncTask;
+import android.support.annotation.Nullable;
+
 import com.mopub.common.factories.MethodBuilderFactory;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.util.AsyncTasks;
@@ -18,11 +20,21 @@
     private static String sPlayServicesUtilClassName = "com.google.android.gms.common.GooglePlayServicesUtil";
     private static String sAdvertisingIdClientClassName = "com.google.android.gms.ads.identifier.AdvertisingIdClient";
 
+    public static class AdvertisingInfo {
+        public final String advertisingId;
+        public final boolean limitAdTracking;
+
+        public AdvertisingInfo(String adId, boolean limitAdTrackingEnabled) {
+            advertisingId = adId;
+            limitAdTracking = limitAdTrackingEnabled;
+        }
+    }
+
     public interface GpsHelperListener {
         public void onFetchAdInfoCompleted();
     }
 
-    static boolean isPlayServicesAvailable(final Context context) {
+    public static boolean isPlayServicesAvailable(final Context context) {
         try {
             MethodBuilder methodBuilder = MethodBuilderFactory.create(null, "isGooglePlayServicesAvailable")
                     .setStatic(Class.forName(sPlayServicesUtilClassName))
@@ -68,6 +80,29 @@ static public void fetchAdvertisingInfoAsync(final Context context, final GpsHel
         }
     }
 
+    @Nullable
+    static public AdvertisingInfo fetchAdvertisingInfoSync(final Context context) {
+        if (context == null) {
+            return null;
+        }
+        Object adInfo = null;
+        try {
+            MethodBuilder methodBuilder = MethodBuilderFactory.create(null, "getAdvertisingIdInfo")
+                    .setStatic(Class.forName(sAdvertisingIdClientClassName))
+                    .addParam(Context.class, context);
+
+            adInfo = methodBuilder.execute();
+        } catch (Exception e) {
+            MoPubLog.d("Unable to obtain Google AdvertisingIdClient.Info via reflection.");
+            return null;
+        }
+
+        String advertisingId = reflectedGetAdvertisingId(adInfo, null);
+        boolean isLimitAdTrackingEnabled = reflectedIsLimitAdTrackingEnabled(adInfo, false);
+
+        return new AdvertisingInfo(advertisingId, isLimitAdTrackingEnabled);
+    }
+
     static private void internalFetchAdvertisingInfoAsync(final Context context, final GpsHelperListener gpsHelperListener) {
         if (!classFound(sAdvertisingIdClientClassName)) {
             if (gpsHelperListener != null) {
@@ -114,7 +149,7 @@ protected Void doInBackground(Void... voids) {
                     updateClientMetadata(context, adInfo);
                 }
             } catch (Exception exception) {
-                MoPubLog.d("Unable to obtain AdvertisingIdClient.getAdvertisingIdInfo()");
+                MoPubLog.d("Unable to obtain Google AdvertisingIdClient.Info via reflection.");
             }
 
             return null;
diff --git a/mopub-sdk/src/main/java/com/mopub/common/HttpClient.java b/mopub-sdk/src/main/java/com/mopub/common/HttpClient.java
index 88e4f7bd..c1161d70 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/HttpClient.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/HttpClient.java
@@ -2,31 +2,34 @@
 
 import android.content.Context;
 import android.net.http.AndroidHttpClient;
-import android.os.Handler;
-import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
 import android.webkit.WebView;
 
-import com.mopub.common.util.AsyncTasks;
-import com.mopub.common.util.DeviceUtils;
 import com.mopub.common.logging.MoPubLog;
 
-import org.apache.http.HttpStatus;
 import org.apache.http.client.methods.HttpGet;
 import org.apache.http.client.params.HttpClientParams;
 import org.apache.http.params.HttpConnectionParams;
 import org.apache.http.params.HttpParams;
 
-import java.util.Arrays;
+import java.io.UnsupportedEncodingException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.net.URLDecoder;
 
 import static com.mopub.common.util.ResponseHeader.USER_AGENT;
 
 public class HttpClient {
     private static final int CONNECTION_TIMEOUT = 10000;
     private static final int SOCKET_TIMEOUT = 10000;
+    private static final String DEFAULT_USER_AGENT = System.getProperty("http.agent");
     private static String sWebViewUserAgent;
 
     public static AndroidHttpClient getHttpClient() {
-        String userAgent = DeviceUtils.getUserAgent();
+        final String userAgent = getWebViewUserAgent(DEFAULT_USER_AGENT);
 
         AndroidHttpClient httpClient = AndroidHttpClient.newInstance(userAgent);
 
@@ -38,8 +41,22 @@ public static AndroidHttpClient getHttpClient() {
         return httpClient;
     }
 
-    public static HttpGet initializeHttpGet(final String url, final Context context) {
-        final HttpGet httpGet = new HttpGet(url);
+    public static HttpGet initializeHttpGet(@NonNull final String url) {
+        return initializeHttpGet(url, null);
+    }
+
+    public static HttpGet initializeHttpGet(@NonNull String url, @Nullable final Context context) {
+        Preconditions.checkNotNull(url);
+
+        // Try to encode url. If this fails, then fallback on the original url
+        String getUrl;
+        try {
+            getUrl = urlEncode(url);
+        } catch (Exception e) {
+            getUrl = url;
+        }
+
+        final HttpGet httpGet = new HttpGet(getUrl);
 
         if (getWebViewUserAgent() == null && context != null) {
             // Memoize the user agent since creating WebViews is expensive
@@ -55,56 +72,90 @@ public static HttpGet initializeHttpGet(final String url, final Context context)
         return httpGet;
     }
 
-    public static void makeTrackingHttpRequest(final Iterable<String> urls, final Context context) {
-        if (urls == null || context == null) {
-            return;
+    /**
+     * This method constructs a properly encoded and valid URI adhering to legal characters for
+     * each component. See Android docs on these classes for reference.
+     */
+    public static String urlEncode(@NonNull final String url) throws Exception {
+        Preconditions.checkNotNull(url);
+
+        // If the URL is improperly encoded, then fail
+        if (isUrlImproperlyEncoded(url)) {
+            throw new UnsupportedEncodingException("URL is improperly encoded: " + url);
+        }
+
+        // If the url is unencoded, then encode it. Otherwise it is already properly encoded
+        // and leave it as is.
+        URI uri;
+        if (isUrlUnencoded(url)) {
+            uri = encodeUrl(url);
+        } else {
+            uri = new URI(url);
         }
 
-        final DownloadTask.DownloadTaskListener downloadTaskListener = new DownloadTask.DownloadTaskListener() {
-            @Override
-            public void onComplete(final String url, final DownloadResponse downloadResponse) {
-                if (downloadResponse == null || downloadResponse.getStatusCode() != HttpStatus.SC_OK) {
-                    MoPubLog.d("Failed to hit tracking endpoint: " + url);
-                    return;
-                }
-
-                String result = HttpResponses.asResponseString(downloadResponse);
-
-                if (result != null) {
-                    MoPubLog.d("Successfully hit tracking endpoint: " + url);
-                } else {
-                    MoPubLog.d("Failed to hit tracking endpoint: " + url);
-                }
-            }
-        };
-
-        // Hold onto the application context in closure instead of activity context
-        final Context appContext = context.getApplicationContext();
-        final Runnable trackingHttpRequestRunnable = new Runnable() {
-            @Override
-            public void run() {
-                for (final String url : urls) {
-                    try {
-                        final HttpGet httpGet = initializeHttpGet(url, appContext);
-                        AsyncTasks.safeExecuteOnExecutor(new DownloadTask(downloadTaskListener), httpGet);
-                    } catch (Exception e) {
-                        MoPubLog.d("Failed to hit tracking endpoint: " + url);
-                    }
-                }
-            }
-        };
-
-        new Handler(Looper.getMainLooper()).post(trackingHttpRequestRunnable);
+        return uri.toURL().toString();
     }
 
-    public static void makeTrackingHttpRequest(final String url, final Context context) {
-        makeTrackingHttpRequest(Arrays.asList(url), context);
+    /**
+     * This method tries to decode the URL and returns false if it can't due to improper encoding.
+     */
+    static boolean isUrlImproperlyEncoded(@NonNull String url) {
+        try {
+            URLDecoder.decode(url, "UTF-8");
+        } catch (UnsupportedEncodingException e) {
+            MoPubLog.w("Url is improperly encoded: " + url);
+            return true;
+        }
+        return false;
     }
 
-    public synchronized static String getWebViewUserAgent() {
+    /**
+     * This method tries to construct a URI and returns true if it can't due to illegal characters
+     * in the url.
+     */
+    static boolean isUrlUnencoded(@NonNull String url) {
+        try {
+            new URI(url);
+        } catch (URISyntaxException e) {
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * This method encodes each component of the URL into a valid URI.
+     */
+    static URI encodeUrl(@NonNull String urlString) throws Exception {
+        URI uri;
+        try {
+            URL url = new URL(urlString);
+            uri = new URI(url.getProtocol(), url.getUserInfo(), url.getHost(), url.getPort(),
+                    url.getPath(), url.getQuery(), url.getRef());
+        } catch (Exception e) {
+            MoPubLog.w("Failed to encode url: " + urlString);
+            throw e;
+        }
+        return uri;
+    }
+
+    /**
+     * @param defaultUserAgent the String to return if the WebView user agent hasn't been generated.
+     * @return the user agent of an Android WebView, or {@code defaultUserAgent}
+     */
+    public synchronized static String getWebViewUserAgent(String defaultUserAgent) {
+        if (TextUtils.isEmpty(sWebViewUserAgent)) {
+            return defaultUserAgent;
+        }
         return sWebViewUserAgent;
     }
 
+    /**
+     * @return the user agent of an Android WebView or {@code null}
+     */
+    public synchronized static String getWebViewUserAgent() {
+        return getWebViewUserAgent(null);
+    }
+
     public synchronized static void setWebViewUserAgent(final String userAgent) {
         sWebViewUserAgent = userAgent;
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/LifecycleListener.java b/mopub-sdk/src/main/java/com/mopub/common/LifecycleListener.java
new file mode 100644
index 00000000..d92f8d5d
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/LifecycleListener.java
@@ -0,0 +1,21 @@
+package com.mopub.common;
+
+import android.app.Activity;
+import android.support.annotation.NonNull;
+
+/**
+ * This is a uniform interface to 3rd party SDKs that need to know when Activity lifecycle events
+ * occur.
+ */
+public interface LifecycleListener {
+
+    public void onCreate(@NonNull Activity activity);
+    public void onStart(@NonNull Activity activity);
+    public void onPause(@NonNull Activity activity);
+    public void onResume(@NonNull Activity activity);
+
+    public void onRestart(@NonNull Activity activity);
+    public void onStop(@NonNull Activity activity);
+    public void onDestroy(@NonNull Activity activity);
+    public void onBackPressed(@NonNull Activity activity);
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/LocationService.java b/mopub-sdk/src/main/java/com/mopub/common/LocationService.java
index 52b2c67b..6602db66 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/LocationService.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/LocationService.java
@@ -3,6 +3,7 @@
 import android.content.Context;
 import android.location.Location;
 import android.location.LocationManager;
+import android.support.annotation.Nullable;
 
 import com.mopub.common.logging.MoPubLog;
 
@@ -48,6 +49,7 @@
      * - The location providers don't exist
      * - Location awareness is disabled in the parent MoPubView
      */
+    @Nullable
     public static Location getLastKnownLocation(final Context context,
             final int locationPrecision,
             final MoPub.LocationAwareness locationLocationAwareness) {
@@ -65,6 +67,8 @@ public static Location getLastKnownLocation(final Context context,
             MoPubLog.d("Failed to retrieve GPS location: access appears to be disabled.");
         } catch (IllegalArgumentException e) {
             MoPubLog.d("Failed to retrieve GPS location: device has no GPS provider.");
+        } catch (NullPointerException e) { // This happens on 4.2.2 on a few Android TV devices
+            MoPubLog.d("Failed to retrieve GPS location: device has no GPS provider.");
         }
 
         Location networkLocation = null;
@@ -74,6 +78,8 @@ public static Location getLastKnownLocation(final Context context,
             MoPubLog.d("Failed to retrieve network location: access appears to be disabled.");
         } catch (IllegalArgumentException e) {
             MoPubLog.d("Failed to retrieve network location: device has no network provider.");
+        }  catch (NullPointerException e) { // This happens on 4.2.2 on a few Android TV devices
+            MoPubLog.d("Failed to retrieve GPS location: device has no network provider.");
         }
 
         if (gpsLocation == null && networkLocation == null) {
diff --git a/mopub-sdk/src/main/java/com/mopub/common/MediationSettings.java b/mopub-sdk/src/main/java/com/mopub/common/MediationSettings.java
new file mode 100644
index 00000000..42e7b7a6
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/MediationSettings.java
@@ -0,0 +1,6 @@
+package com.mopub.common;
+
+/**
+ * A marker interface for 3rd party SDK options.
+ */
+public interface MediationSettings {}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/MoPub.java b/mopub-sdk/src/main/java/com/mopub/common/MoPub.java
index 808400cf..9b053d6c 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/MoPub.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/MoPub.java
@@ -1,7 +1,14 @@
 package com.mopub.common;
 
+import android.app.Activity;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.mobileads.MoPubRewardedVideoListener;
+import com.mopub.mobileads.MoPubRewardedVideoManager;
+
 public class MoPub {
-    public static final String SDK_VERSION = "3.2.2";
+    public static final String SDK_VERSION = "3.7.0";
 
     public static enum LocationAwareness { NORMAL, TRUNCATED, DISABLED }
 
@@ -28,4 +35,68 @@ public static int getLocationPrecision() {
     public static void setLocationPrecision(int precision) {
         sLocationPrecision = Math.min(Math.max(0, precision), DEFAULT_LOCATION_PRECISION);
     }
+
+
+    //////// MoPub LifecycleListener messages ////////
+
+    public static void onCreate(@NonNull final Activity activity) {
+        MoPubLifecycleManager.getInstance(activity).onCreate(activity);
+        updateActivity(activity);
+    }
+
+    public static void onStart(@NonNull final Activity activity) {
+        MoPubLifecycleManager.getInstance(activity).onStart(activity);
+        updateActivity(activity);
+    }
+
+    public static void onPause(@NonNull final Activity activity) {
+        MoPubLifecycleManager.getInstance(activity).onPause(activity);
+    }
+
+    public static void onResume(@NonNull final Activity activity) {
+        MoPubLifecycleManager.getInstance(activity).onResume(activity);
+        updateActivity(activity);
+    }
+
+    public static void onRestart(@NonNull final Activity activity) {
+        MoPubLifecycleManager.getInstance(activity).onRestart(activity);
+        updateActivity(activity);
+    }
+
+    public static void onStop(@NonNull final Activity activity) {
+        MoPubLifecycleManager.getInstance(activity).onStop(activity);
+    }
+
+    public static void onDestroy(@NonNull final Activity activity) {
+        MoPubLifecycleManager.getInstance(activity).onDestroy(activity);
+    }
+
+    public static void onBackPressed(@NonNull final Activity activity) {
+        MoPubLifecycleManager.getInstance(activity).onBackPressed(activity);
+    }
+
+    ////////// MoPub RewardedVideoControl methods //////////
+    public static void initializeRewardedVideo(@NonNull Activity activity, MediationSettings... mediationSettings) {
+        MoPubRewardedVideoManager.init(activity, mediationSettings);
+    }
+
+    private static void updateActivity(@NonNull Activity activity) {
+        MoPubRewardedVideoManager.updateActivity(activity);
+    }
+
+    public static void setRewardedVideoListener(@Nullable MoPubRewardedVideoListener listener) {
+        MoPubRewardedVideoManager.setVideoListener(listener);
+    }
+
+    public static void loadRewardedVideo(@NonNull String adUnitId, @Nullable MediationSettings... mediationSettings) {
+        MoPubRewardedVideoManager.loadVideo(adUnitId, mediationSettings);
+    }
+
+    public static boolean hasRewardedVideo(@NonNull String adUnitId) {
+        return MoPubRewardedVideoManager.hasVideo(adUnitId);
+    }
+
+    public static void showRewardedVideo(@NonNull String adUnitId) {
+        MoPubRewardedVideoManager.showVideo(adUnitId);
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/MoPubBrowser.java b/mopub-sdk/src/main/java/com/mopub/common/MoPubBrowser.java
index 4e55f583..a2eb90cc 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/MoPubBrowser.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/MoPubBrowser.java
@@ -10,6 +10,7 @@
 import android.os.Bundle;
 import android.view.Gravity;
 import android.view.View;
+import android.view.ViewGroup;
 import android.view.Window;
 import android.webkit.CookieSyncManager;
 import android.webkit.WebChromeClient;
@@ -19,9 +20,10 @@
 import android.widget.ImageButton;
 import android.widget.LinearLayout;
 import android.widget.RelativeLayout;
-import android.widget.Toast;
 
 import com.mopub.common.logging.MoPubLog;
+import com.mopub.mobileads.BaseWebView;
+import com.mopub.mobileads.util.WebViews;
 
 import static android.view.ViewGroup.LayoutParams.MATCH_PARENT;
 import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;
@@ -32,8 +34,8 @@
 import static com.mopub.common.util.Drawables.RIGHT_ARROW;
 import static com.mopub.common.util.Drawables.UNLEFT_ARROW;
 import static com.mopub.common.util.Drawables.UNRIGHT_ARROW;
-import static com.mopub.common.util.IntentUtils.deviceCanHandleIntent;
-import static com.mopub.common.util.IntentUtils.isDeepLink;
+import static com.mopub.common.util.Intents.deviceCanHandleIntent;
+import static com.mopub.common.util.Intents.isDeepLink;
 
 public class MoPubBrowser extends Activity {
     public static final String DESTINATION_URL_KEY = "URL";
@@ -88,7 +90,7 @@ private void initializeWebView() {
             @Override
             public void onReceivedError(WebView view, int errorCode, String description,
                     String failingUrl) {
-                Toast.makeText(MoPubBrowser.this, "MoPubBrowser error: " + description, Toast.LENGTH_SHORT).show();
+                MoPubLog.d("MoPubBrowser error: " + description);
             }
 
             @Override
@@ -110,7 +112,7 @@ public boolean shouldOverrideUrlLoading(WebView view, String url) {
             @Override
             public void onPageStarted(WebView view, String url, Bitmap favicon) {
                 super.onPageStarted(view, url, favicon);
-                mForwardButton.setImageDrawable(UNRIGHT_ARROW.decodeImage(MoPubBrowser.this));
+                mForwardButton.setImageDrawable(UNRIGHT_ARROW.createDrawable(MoPubBrowser.this));
             }
 
             @Override
@@ -118,13 +120,13 @@ public void onPageFinished(WebView view, String url) {
                 super.onPageFinished(view, url);
 
                 Drawable backImageDrawable = view.canGoBack()
-                        ? LEFT_ARROW.decodeImage(MoPubBrowser.this)
-                        : UNLEFT_ARROW.decodeImage(MoPubBrowser.this);
+                        ? LEFT_ARROW.createDrawable(MoPubBrowser.this)
+                        : UNLEFT_ARROW.createDrawable(MoPubBrowser.this);
                 mBackButton.setImageDrawable(backImageDrawable);
 
                 Drawable forwardImageDrawable = view.canGoForward()
-                        ? RIGHT_ARROW.decodeImage(MoPubBrowser.this)
-                        : UNRIGHT_ARROW.decodeImage(MoPubBrowser.this);
+                        ? RIGHT_ARROW.createDrawable(MoPubBrowser.this)
+                        : UNRIGHT_ARROW.createDrawable(MoPubBrowser.this);
                 mForwardButton.setImageDrawable(forwardImageDrawable);
             }
         });
@@ -183,12 +185,30 @@ private void enableCookies() {
     protected void onPause() {
         super.onPause();
         CookieSyncManager.getInstance().stopSync();
+        WebViews.onPause(mWebView, isFinishing());
     }
 
     @Override
     protected void onResume() {
         super.onResume();
         CookieSyncManager.getInstance().startSync();
+        WebViews.onResume(mWebView);
+    }
+
+    @Override
+    public void finish() {
+        // ZoomButtonController adds buttons to the window's decorview. If they're still visible
+        // when finish() is called, they need to be removed or a Window object will be leaked.
+        ViewGroup decorView = (ViewGroup) getWindow().getDecorView();
+        decorView.removeAllViews();
+        super.finish();
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        mWebView.destroy();
+        mWebView = null;
     }
 
     private View getMoPubBrowserView() {
@@ -207,20 +227,20 @@ private View getMoPubBrowserView() {
         RelativeLayout.LayoutParams innerLayoutParams = new RelativeLayout.LayoutParams(MATCH_PARENT, WRAP_CONTENT);
         innerLayoutParams.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM);
         innerLayout.setLayoutParams(innerLayoutParams);
-        innerLayout.setBackgroundDrawable(BACKGROUND.decodeImage(this));
+        innerLayout.setBackgroundDrawable(BACKGROUND.createDrawable(this));
         outerLayout.addView(innerLayout);
 
-        mBackButton = getButton(LEFT_ARROW.decodeImage(this));
-        mForwardButton = getButton(RIGHT_ARROW.decodeImage(this));
-        mRefreshButton = getButton(REFRESH.decodeImage(this));
-        mCloseButton = getButton(CLOSE.decodeImage(this));
+        mBackButton = getButton(LEFT_ARROW.createDrawable(this));
+        mForwardButton = getButton(RIGHT_ARROW.createDrawable(this));
+        mRefreshButton = getButton(REFRESH.createDrawable(this));
+        mCloseButton = getButton(CLOSE.createDrawable(this));
 
         innerLayout.addView(mBackButton);
         innerLayout.addView(mForwardButton);
         innerLayout.addView(mRefreshButton);
         innerLayout.addView(mCloseButton);
 
-        mWebView = new WebView(this);
+        mWebView = new BaseWebView(this);
         RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(MATCH_PARENT, MATCH_PARENT);
         layoutParams.addRule(RelativeLayout.ABOVE, INNER_LAYOUT_ID);
         mWebView.setLayoutParams(layoutParams);
@@ -240,4 +260,10 @@ private ImageButton getButton(final Drawable drawable) {
 
         return imageButton;
     }
+
+    @Deprecated
+    @VisibleForTesting
+    void setWebView(WebView webView) {
+        mWebView = webView;
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/MoPubLifecycleManager.java b/mopub-sdk/src/main/java/com/mopub/common/MoPubLifecycleManager.java
new file mode 100644
index 00000000..41394805
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/MoPubLifecycleManager.java
@@ -0,0 +1,107 @@
+package com.mopub.common;
+
+import android.app.Activity;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import java.lang.ref.WeakReference;
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * This class handles delegating lifecycle callback events to ads SDKs that require them.
+ */
+public class MoPubLifecycleManager implements LifecycleListener {
+    private static MoPubLifecycleManager sInstance;
+
+    @NonNull private final Set<LifecycleListener> mLifecycleListeners;
+    @NonNull private final WeakReference<Activity> mMainActivity;
+
+    private MoPubLifecycleManager(Activity mainActivity) {
+        mLifecycleListeners = new HashSet<LifecycleListener>();
+        mMainActivity = new WeakReference<Activity>(mainActivity);
+    }
+
+    @NonNull public static synchronized MoPubLifecycleManager getInstance(Activity mainActivity) {
+        if (sInstance == null) {
+            sInstance = new MoPubLifecycleManager(mainActivity);
+        }
+
+        return sInstance;
+    }
+
+    /**
+     * Adds a lifecycle listener to the manager. The manager takes ownership with a strong reference.
+     *
+     * @param listener the listener to add to the lifecycle manager.
+     */
+    public void addLifecycleListener(@Nullable LifecycleListener listener) {
+        // Get the instance or bail if not initialized.
+        if (listener == null) {
+            return;
+        }
+        if (mLifecycleListeners.add(listener)) {
+            Activity activity = mMainActivity.get();
+            if (activity != null) {
+                listener.onCreate(activity);
+                listener.onStart(activity);
+            }
+        }
+    }
+
+    @Override
+    public void onCreate(@NonNull final Activity activity) {
+        for (LifecycleListener lifecycleListener : mLifecycleListeners) {
+            lifecycleListener.onCreate(activity);
+        }
+    }
+
+    @Override
+    public void onStart(@NonNull final Activity activity) {
+        for (LifecycleListener lifecycleListener : mLifecycleListeners) {
+            lifecycleListener.onStart(activity);
+        }
+    }
+
+    @Override
+    public void onPause(@NonNull final Activity activity) {
+        for (LifecycleListener lifecycleListener : mLifecycleListeners) {
+            lifecycleListener.onPause(activity);
+        }
+    }
+
+    @Override
+    public void onResume(@NonNull final Activity activity) {
+        for (LifecycleListener lifecycleListener : mLifecycleListeners) {
+            lifecycleListener.onResume(activity);
+        }
+    }
+
+    @Override
+    public void onRestart(@NonNull final Activity activity) {
+        for (LifecycleListener lifecycleListener : mLifecycleListeners) {
+            lifecycleListener.onRestart(activity);
+        }
+    }
+
+    @Override
+    public void onStop(@NonNull final Activity activity) {
+        for (LifecycleListener lifecycleListener : mLifecycleListeners) {
+            lifecycleListener.onRestart(activity);
+        }
+    }
+
+    @Override
+    public void onDestroy(@NonNull final Activity activity) {
+        for (LifecycleListener lifecycleListener : mLifecycleListeners) {
+            lifecycleListener.onRestart(activity);
+        }
+    }
+
+    @Override
+    public void onBackPressed(@NonNull final Activity activity) {
+        for (LifecycleListener lifecycleListener : mLifecycleListeners) {
+            lifecycleListener.onBackPressed(activity);
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/MoPubReward.java b/mopub-sdk/src/main/java/com/mopub/common/MoPubReward.java
new file mode 100644
index 00000000..85f0f3c2
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/MoPubReward.java
@@ -0,0 +1,43 @@
+package com.mopub.common;
+
+import android.support.annotation.NonNull;
+
+/**
+ * Represents a reward to the user for completing a rewarded task like watching a video.
+ */
+public final class MoPubReward {
+    public static final String NO_REWARD_LABEL = "";
+    public static final int NO_REWARD_AMOUNT = -123;
+    private final boolean mSuccess;
+    private final @NonNull String mLabel;
+    private final int mAmount;
+
+    private MoPubReward(boolean success, @NonNull String label, int amount) {
+        mSuccess = success;
+        mLabel = label;
+        mAmount = amount;
+    }
+
+    @NonNull
+    public static MoPubReward failure() {
+        return new MoPubReward(false, NO_REWARD_LABEL, 0);
+    }
+
+    @NonNull
+    public static MoPubReward success(@NonNull final String rewardLabel, final int amount) {
+        return new MoPubReward(true, rewardLabel, amount);
+    }
+
+    public final boolean isSuccessful() {
+        return mSuccess;
+    }
+
+    @NonNull
+    public final String getLabel() {
+        return mLabel;
+    }
+
+    public final int getAmount() {
+        return mAmount;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/BaseEvent.java b/mopub-sdk/src/main/java/com/mopub/common/event/BaseEvent.java
index 4e053528..db599026 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/event/BaseEvent.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/BaseEvent.java
@@ -1,43 +1,572 @@
 package com.mopub.common.event;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
 import com.mopub.common.ClientMetadata;
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+
+import java.text.SimpleDateFormat;
+import java.util.Date;
+
+import static com.mopub.common.ClientMetadata.MoPubNetworkType;
 
 public abstract class BaseEvent {
-    public enum Type {
-        NETWORK_REQUEST("request"),
-        DATA_ERROR("invalid_data");
 
-        public final String mName;
-        Type(String name) {
+    public static enum ScribeCategory {
+        EXCHANGE_CLIENT_EVENT("exchange_client_event"),
+        EXCHANGE_CLIENT_ERROR("exchange_client_error");
+
+        @NonNull private final String mScribeCategory;
+        private ScribeCategory(@NonNull String scribeCategory) {
+            mScribeCategory = scribeCategory;
+        }
+
+        @NonNull
+        public String getCategory() {
+            return mScribeCategory;
+        }
+    }
+
+    public static enum SdkProduct {
+        NONE(0),
+        WEB_VIEW(1),
+        NATIVE(2);
+
+        private final int mType;
+        private SdkProduct(int type) {
+            mType = type;
+        }
+
+        public int getType() {
+            return mType;
+        }
+    }
+
+    public static enum AppPlatform {
+        NONE(0),
+        IOS(1),
+        ANDROID(2),
+        MOBILE_WEB(3);
+
+        private final int mType;
+        private AppPlatform(int type) {
+            mType = type;
+        }
+
+        public int getType() {
+            return mType;
+        }
+    }
+
+    public enum Name {
+        AD_REQUEST("ad_request"),
+        IMPRESSION_REQUEST("impression_request"),
+        CLICK_REQUEST("click_request");
+
+        @NonNull private final String mName;
+        private Name(@NonNull String name) {
             mName = name;
         }
+
+        @NonNull
+        public String getName() {
+            return mName;
+        }
+    }
+
+    public enum Category {
+        REQUESTS("requests");
+
+        @NonNull private final String mCategory;
+        private Category(@NonNull String category) {
+            mCategory = category;
+        }
+
+        @NonNull
+        public String getCategory() {
+            return mCategory;
+        }
+    }
+
+    public enum SamplingRate {
+        AD_REQUEST(0.1);
+
+        private final double mSamplingRate;
+        private SamplingRate(double samplingRate) {
+            mSamplingRate = samplingRate;
+        }
+
+        public double getSamplingRate() {
+            return mSamplingRate;
+        }
+    }
+
+    @NonNull private final ScribeCategory mScribeCategory;
+    @NonNull private final Name mName;
+    @NonNull private final Category mCategory;
+    @Nullable private final SdkProduct mSdkProduct;
+    @Nullable private final String mAdUnitId;
+    @Nullable private final String mAdCreativeId;
+    @Nullable private final String mAdType;
+    @Nullable private final String mAdNetworkType;
+    @Nullable private final Double mAdWidthPx;
+    @Nullable private final Double mAdHeightPx;
+    @Nullable private final Integer mDeviceScreenWidthDip;
+    @Nullable private final Integer mDeviceScreenHeightDip;
+    @Nullable private final Double mGeoLat;
+    @Nullable private final Double mGeoLon;
+    @Nullable private final Double mGeoAccuracy;
+    @Nullable private final MoPubNetworkType mNetworkType;
+    @Nullable private final String mNetworkOperator;
+    @Nullable private final String mNetworkOperatorName;
+    @Nullable private final String mIsoCountryCode;
+    @Nullable private final String mSimOperator;
+    @Nullable private final String mSimOperatorName;
+    @Nullable private final String mSimIsoCountryCode;
+    @Nullable private final Double mPerformanceDurationMs;
+    @Nullable private final String mRequestId;
+    @Nullable private final Integer mRequestStatusCode;
+    @Nullable private final String mRequestUri;
+    @Nullable private final Integer mRequestRetries;
+    private final long mTimestampUtcMs;
+    @Nullable private ClientMetadata mClientMetaData;
+
+     /**
+     * The percentage of events, in range 0 - 1.0, to be logged.
+     */
+    private final double mSamplingRate;
+
+    public BaseEvent(@NonNull final Builder builder) {
+        Preconditions.checkNotNull(builder);
+
+        mScribeCategory = builder.mScribeCategory;
+        mName = builder.mName;
+        mCategory = builder.mCategory;
+        mSdkProduct = builder.mSdkProduct;
+        mAdUnitId = builder.mAdUnitId;
+        mAdCreativeId = builder.mAdCreativeId;
+        mAdType = builder.mAdType;
+        mAdNetworkType = builder.mAdNetworkType;
+        mAdWidthPx = builder.mAdWidthPx;
+        mAdHeightPx = builder.mAdHeightPx;
+        mGeoLat = builder.mGeoLat;
+        mGeoLon = builder.mGeoLon;
+        mGeoAccuracy = builder.mGeoAccuracy;
+        mPerformanceDurationMs = builder.mPerformanceDurationMs;
+        mRequestId = builder.mRequestId;
+        mRequestStatusCode = builder.mRequestStatusCode;
+        mRequestUri = builder.mRequestUri;
+        mRequestRetries = builder.mRequestRetries;
+        mSamplingRate = builder.mSamplingRate;
+        mTimestampUtcMs = System.currentTimeMillis();
+
+        mClientMetaData = ClientMetadata.getInstance();
+        if (mClientMetaData != null) {
+            mDeviceScreenWidthDip = mClientMetaData.getDeviceScreenWidthDip();
+            mDeviceScreenHeightDip = mClientMetaData.getDeviceScreenHeightDip();
+            mNetworkType = mClientMetaData.getActiveNetworkType();
+            mNetworkOperator = mClientMetaData.getNetworkOperator();
+            mNetworkOperatorName = mClientMetaData.getNetworkOperatorName();
+            mIsoCountryCode = mClientMetaData.getIsoCountryCode();
+            mSimOperator = mClientMetaData.getSimOperator();
+            mSimOperatorName = mClientMetaData.getSimOperatorName();
+            mSimIsoCountryCode = mClientMetaData.getSimIsoCountryCode();
+        } else {
+            // Need to silence warnings about variables not being initialized
+            mDeviceScreenWidthDip = null;
+            mDeviceScreenHeightDip = null;
+            mNetworkType = null;
+            mNetworkOperator = null;
+            mNetworkOperatorName = null;
+            mIsoCountryCode = null;
+            mSimOperator = null;
+            mSimOperatorName = null;
+            mSimIsoCountryCode = null;
+        }
+    }
+
+    @NonNull
+    public ScribeCategory getScribeCategory() {
+        return mScribeCategory;
+    }
+
+    @NonNull
+    public Name getName() {
+        return mName;
+    }
+
+    @NonNull
+    public Category getCategory() {
+        return mCategory;
+    }
+
+    @Nullable
+    public SdkProduct getSdkProduct() {
+        return mSdkProduct;
+    }
+
+    @Nullable
+    public String getSdkVersion() {
+        return mClientMetaData == null ? null : mClientMetaData.getSdkVersion();
+    }
+
+    @Nullable
+    public String getAdUnitId() {
+        return mAdUnitId;
+    }
+
+    @Nullable
+    public String getAdCreativeId() {
+        return mAdCreativeId;
+    }
+
+    @Nullable
+    public String getAdType() {
+        return mAdType;
+    }
+
+    @Nullable
+    public String getAdNetworkType() {
+        return mAdNetworkType;
+    }
+
+    @Nullable
+    public Double getAdWidthPx() {
+        return mAdWidthPx;
+    }
+
+    @Nullable
+    public Double getAdHeightPx() {
+        return mAdHeightPx;
+    }
+
+    @Nullable
+    public AppPlatform getAppPlatform() {
+        return AppPlatform.ANDROID;
+    }
+
+    @Nullable
+    public String getAppName() {
+        return mClientMetaData == null ? null : mClientMetaData.getAppName();
+    }
+
+    @Nullable
+    public String getAppPackageName() {
+        return mClientMetaData == null ? null : mClientMetaData.getAppPackageName();
+    }
+
+    @Nullable
+    public String getAppVersion() {
+        return mClientMetaData == null ? null : mClientMetaData.getAppVersion();
+    }
+
+    @Nullable
+    public String getClientAdvertisingId() {
+        return mClientMetaData == null ? null : mClientMetaData.getDeviceId();
+    }
+
+    @NonNull
+    public String getObfuscatedClientAdvertisingId() {
+        // This is a placeholder for the advertising id until we approve a plan to use the
+        // real value
+        return "ifa:XXXX";
     }
 
-    private final ClientMetadata mMetadata;
-    private final String mEventName;
-    private final String mRequestUrl;
-    private final long mEventTimeUtcMillis;
+    @NonNull
+    public Boolean getClientDoNotTrack() {
+        // Default to true if we don't have access to the client meta data
+        return mClientMetaData == null || mClientMetaData.isDoNotTrackSet();
+    }
+
+    @Nullable
+    public String getDeviceManufacturer() {
+        return mClientMetaData == null ? null : mClientMetaData.getDeviceManufacturer();
+    }
+
+    @Nullable
+    public String getDeviceModel() {
+        return mClientMetaData == null ? null : mClientMetaData.getDeviceModel();
+    }
+
+    @Nullable
+    public String getDeviceProduct() {
+        return mClientMetaData == null ? null : mClientMetaData.getDeviceProduct();
+    }
+
+    @Nullable
+    public String getDeviceOsVersion() {
+        return mClientMetaData == null ? null : mClientMetaData.getDeviceOsVersion();
+    }
+
+    @Nullable
+    public Integer getDeviceScreenWidthDip() {
+        return mDeviceScreenWidthDip;
+    }
+
+    @Nullable
+    public Integer getDeviceScreenHeightDip() {
+        return mDeviceScreenHeightDip;
+    }
+
+    @Nullable
+    public Double getGeoLat() {
+        return mGeoLat;
+    }
+
+    @Nullable
+    public Double getGeoLon() {
+        return mGeoLon;
+    }
+
+    @Nullable
+    public Double getGeoAccuracy() {
+        return mGeoAccuracy;
+    }
+
+    @Nullable
+    public Double getPerformanceDurationMs() {
+        return mPerformanceDurationMs;
+    }
+
+    @Nullable
+    public MoPubNetworkType getNetworkType() {
+        return mNetworkType;
+    }
+
+    @Nullable
+    public String getNetworkOperatorCode() {
+        return mNetworkOperator;
+    }
+
+    @Nullable
+    public String getNetworkOperatorName() {
+        return mNetworkOperatorName;
+    }
+
+    @Nullable
+    public String getNetworkIsoCountryCode() {
+        return mIsoCountryCode;
+    }
+
+    @Nullable
+    public String getNetworkSimCode() {
+        return mSimOperator;
+    }
+
+    @Nullable
+    public String getNetworkSimOperatorName() {
+        return mSimOperatorName;
+    }
+
+    @Nullable
+    public String getNetworkSimIsoCountryCode() {
+        return mSimIsoCountryCode;
+    }
+
+    @Nullable
+    public String getRequestId() {
+        return mRequestId;
+    }
+
+    @Nullable
+    public Integer getRequestStatusCode() {
+        return mRequestStatusCode;
+    }
 
-    BaseEvent(Type eventType, String requestUrl, ClientMetadata metadata) {
-        mEventTimeUtcMillis = System.currentTimeMillis();
-        mEventName = eventType.mName;
-        mRequestUrl = requestUrl;
-        mMetadata = metadata;
+    @Nullable
+    public String getRequestUri() {
+        return mRequestUri;
     }
 
-    public long getEventTimeUtcMillis() {
-        return mEventTimeUtcMillis;
+    @Nullable
+    public Integer getRequestRetries() {
+        return mRequestRetries;
     }
 
-    public String getRequestUrl() {
-        return mRequestUrl;
+    public double getSamplingRate() {
+        return mSamplingRate;
     }
 
-    public String getEventName() {
-        return mEventName;
+    @NonNull
+    public Long getTimestampUtcMs() {
+        return mTimestampUtcMs;
     }
 
-    public ClientMetadata getMetadata() {
-        return mMetadata;
+    @Override
+    public String toString() {
+        return  "BaseEvent\n" +
+                "ScribeCategory: " + getScribeCategory() + "\n" +
+                "Name: " + getName() + "\n" +
+                "Category: " + getCategory() + "\n" +
+                "SdkProduct: " + getSdkProduct() + "\n" +
+                "SdkVersion: " + getSdkVersion() + "\n" +
+                "AdUnitId: " + getAdUnitId() + "\n" +
+                "AdCreativeId: " + getAdCreativeId() + "\n" +
+                "AdType: " + getAdType() + "\n" +
+                "AdNetworkType: " + getAdNetworkType() + "\n" +
+                "AdWidthPx: " + getAdWidthPx() + "\n" +
+                "AdHeightPx: " + getAdHeightPx() + "\n" +
+                "AppPlatform: " + getAppPlatform() + "\n" +
+                "AppName: " + getAppName() + "\n" +
+                "AppPackageName: " + getAppPackageName() + "\n" +
+                "AppVersion: " + getAppVersion() + "\n" +
+                "DeviceManufacturer: " + getDeviceManufacturer() + "\n" +
+                "DeviceModel: " + getDeviceModel() + "\n" +
+                "DeviceProduct: " + getDeviceProduct() + "\n" +
+                "DeviceOsVersion: " + getDeviceOsVersion() + "\n" +
+                "DeviceScreenWidth: " + getDeviceScreenWidthDip() + "\n" +
+                "DeviceScreenHeight: " + getDeviceScreenHeightDip() + "\n" +
+                "GeoLat: " + getGeoLat() + "\n" +
+                "GeoLon: " + getGeoLon() + "\n" +
+                "GeoAccuracy: " + getGeoAccuracy() + "\n" +
+                "PerformanceDurationMs: " + getPerformanceDurationMs() + "\n" +
+                "NetworkType: " + getNetworkType() + "\n" +
+                "NetworkOperatorCode: " + getNetworkOperatorCode() + "\n" +
+                "NetworkOperatorName: " + getNetworkOperatorName() + "\n" +
+                "NetworkIsoCountryCode: " + getNetworkIsoCountryCode() + "\n" +
+                "NetworkSimCode: " + getNetworkSimCode() + "\n" +
+                "NetworkSimOperatorName: " + getNetworkSimOperatorName() + "\n" +
+                "NetworkSimIsoCountryCode: " + getNetworkSimIsoCountryCode() + "\n" +
+                "RequestId: " + getRequestId() + "\n" +
+                "RequestStatusCode: " + getRequestStatusCode() + "\n" +
+                "RequestUri: " + getRequestUri() + "\n" +
+                "RequestRetries: " + getRequestRetries() + "\n" +
+                "SamplingRate: " + getSamplingRate() + "\n" +
+                "TimestampUtcMs: " + new SimpleDateFormat().format(new Date(getTimestampUtcMs())) + "\n";
+    }
+
+    public static abstract class Builder {
+        @NonNull private ScribeCategory mScribeCategory;
+        @NonNull private Name mName;
+        @NonNull private Category mCategory;
+        @Nullable private SdkProduct mSdkProduct;
+        @Nullable private String mAdUnitId;
+        @Nullable private String mAdCreativeId;
+        @Nullable private String mAdType;
+        @Nullable private String mAdNetworkType;
+        @Nullable private Double mAdWidthPx;
+        @Nullable private Double mAdHeightPx;
+        @Nullable private Double mGeoLat;
+        @Nullable private Double mGeoLon;
+        @Nullable private Double mGeoAccuracy;
+        @Nullable private Double mPerformanceDurationMs;
+        @Nullable private String mRequestId;
+        @Nullable private Integer mRequestStatusCode;
+        @Nullable private String mRequestUri;
+        @Nullable private Integer mRequestRetries;
+
+        /**
+         * The percentage of events, in range 0 - 1.0, to be logged.
+         */
+        private double mSamplingRate;
+
+        public Builder(@NonNull ScribeCategory scribeCategory,
+                @NonNull Name name,
+                @NonNull Category category,
+                double samplingRate) {
+            Preconditions.checkNotNull(scribeCategory);
+            Preconditions.checkNotNull(name);
+            Preconditions.checkNotNull(category);
+            Preconditions.checkArgument(samplingRate >= 0 && samplingRate <= 1.0);
+
+            mScribeCategory = scribeCategory;
+            mName = name;
+            mCategory = category;
+            mSamplingRate = samplingRate;
+        }
+
+        @NonNull
+        public Builder withSdkProduct(@Nullable SdkProduct sdkProduct) {
+            mSdkProduct = sdkProduct;
+            return this;
+        }
+
+        @NonNull
+        public Builder withAdUnitId(@Nullable String adUnitId) {
+            mAdUnitId = adUnitId;
+            return this;
+        }
+
+        @NonNull
+        public Builder withAdCreativeId(@Nullable String adCreativeId) {
+            mAdCreativeId = adCreativeId;
+            return this;
+        }
+
+        @NonNull
+        public Builder withAdType(@Nullable String adType) {
+            mAdType = adType;
+            return this;
+        }
+
+        @NonNull
+        public Builder withAdNetworkType(@Nullable String adNetworkType) {
+            mAdNetworkType = adNetworkType;
+            return this;
+        }
+
+        @NonNull
+        public Builder withAdWidthPx(@Nullable Double adWidthPx) {
+            mAdWidthPx = adWidthPx;
+            return this;
+        }
+
+        @NonNull
+        public Builder withAdHeightPx(@Nullable Double adHeightPx) {
+            mAdHeightPx = adHeightPx;
+            return this;
+        }
+
+        @NonNull
+        public Builder withGeoLat(@Nullable Double geoLat) {
+            mGeoLat = geoLat;
+            return this;
+        }
+
+        @NonNull
+        public Builder withGeoLon(@Nullable Double geoLon) {
+            mGeoLon = geoLon;
+            return this;
+        }
+
+        @NonNull
+        public Builder withGeoAccuracy(@Nullable Double geoAccuracy) {
+            mGeoAccuracy = geoAccuracy;
+            return this;
+        }
+
+        @NonNull
+        public Builder withPerformanceDurationMs(@Nullable Double performanceDurationMs) {
+            mPerformanceDurationMs = performanceDurationMs;
+            return this;
+        }
+
+        @NonNull
+        public Builder withRequestId(@Nullable String requestId) {
+            mRequestId = requestId;
+            return this;
+        }
+
+        @NonNull
+        public Builder withRequestStatusCode(@Nullable Integer requestStatusCode) {
+            mRequestStatusCode = requestStatusCode;
+            return this;
+        }
+
+        @NonNull
+        public Builder withRequestUri(@Nullable String requestUri) {
+            mRequestUri = requestUri;
+            return this;
+        }
+
+        @NonNull
+        public Builder withRequestRetries(@Nullable Integer requestRetries) {
+            mRequestRetries = requestRetries;
+            return this;
+        }
+
+        public abstract BaseEvent build();
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/ErrorEvent.java b/mopub-sdk/src/main/java/com/mopub/common/event/ErrorEvent.java
new file mode 100644
index 00000000..05a3d93f
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/ErrorEvent.java
@@ -0,0 +1,160 @@
+package com.mopub.common.event;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import java.io.PrintWriter;
+import java.io.StringWriter;
+
+/**
+ * Immutable data class with error event data.
+ */
+public class ErrorEvent extends BaseEvent {
+    @Nullable private final String mErrorExceptionClassName;
+    @Nullable private final String mErrorMessage;
+    @Nullable private final String mErrorStackTrace;
+    @Nullable private final String mErrorFileName;
+    @Nullable private final String mErrorClassName;
+    @Nullable private final String mErrorMethodName;
+    @Nullable private final Integer mErrorLineNumber;
+
+    private ErrorEvent(@NonNull Builder builder) {
+        super(builder);
+        mErrorExceptionClassName = builder.mErrorExceptionClassName;
+        mErrorMessage = builder.mErrorMessage;
+        mErrorStackTrace = builder.mErrorStackTrace;
+        mErrorFileName = builder.mErrorFileName;
+        mErrorClassName = builder.mErrorClassName;
+        mErrorMethodName = builder.mErrorMethodName;
+        mErrorLineNumber = builder.mErrorLineNumber;
+    }
+
+    @Nullable
+    public String getErrorExceptionClassName() {
+        return mErrorExceptionClassName;
+    }
+
+    @Nullable
+    public String getErrorMessage() {
+        return mErrorMessage;
+    }
+
+    @Nullable
+    public String getErrorStackTrace() {
+        return mErrorStackTrace;
+    }
+
+    @Nullable
+    public String getErrorFileName() {
+        return mErrorFileName;
+    }
+
+    @Nullable
+    public String getErrorClassName() {
+        return mErrorClassName;
+    }
+
+    @Nullable
+    public String getErrorMethodName() {
+        return mErrorMethodName;
+    }
+
+    @Nullable
+    public Integer getErrorLineNumber() {
+        return mErrorLineNumber;
+    }
+
+    @Override
+    public String toString() {
+        final String string = super.toString();
+        return string +
+                "ErrorEvent\n" +
+                "ErrorExceptionClassName: " + getErrorExceptionClassName() + "\n" +
+                "ErrorMessage: " + getErrorMessage() + "\n" +
+                "ErrorStackTrace: " + getErrorStackTrace() + "\n" +
+                "ErrorFileName: " + getErrorFileName() + "\n" +
+                "ErrorClassName: " + getErrorClassName() + "\n" +
+                "ErrorMethodName: " + getErrorMethodName() + "\n" +
+                "ErrorLineNumber: " + getErrorLineNumber() + "\n";
+    }
+
+    public static class Builder extends BaseEvent.Builder {
+        @Nullable private String mErrorExceptionClassName;
+        @Nullable private String mErrorMessage;
+        @Nullable private String mErrorStackTrace;
+        @Nullable private String mErrorFileName;
+        @Nullable private String mErrorClassName;
+        @Nullable private String mErrorMethodName;
+        @Nullable private Integer mErrorLineNumber;
+
+        public Builder(@NonNull Name name, @NonNull Category category, double samplingRate) {
+            super(ScribeCategory.EXCHANGE_CLIENT_ERROR, name, category, samplingRate);
+        }
+
+        @NonNull
+        public Builder withErrorExceptionClassName(@Nullable String errorExceptionClassName) {
+            mErrorExceptionClassName = errorExceptionClassName;
+            return this;
+        }
+
+        @NonNull
+        public Builder withErrorMessage(@Nullable String errorMessage) {
+            mErrorMessage = errorMessage;
+            return this;
+        }
+
+        @NonNull
+        public Builder withErrorStackTrace(@Nullable String errorStackTrace) {
+            mErrorStackTrace = errorStackTrace;
+            return this;
+        }
+
+        @NonNull
+        public Builder withErrorFileName(@Nullable String errorFileName) {
+            mErrorFileName = errorFileName;
+            return this;
+        }
+
+        @NonNull
+        public Builder withErrorClassName(@Nullable String errorClassName) {
+            mErrorClassName = errorClassName;
+            return this;
+        }
+
+        @NonNull
+        public Builder withErrorMethodName(@Nullable String errorMethodName) {
+            mErrorMethodName = errorMethodName;
+            return this;
+        }
+
+        @NonNull
+        public Builder withErrorLineNumber(@Nullable Integer errorLineNumber) {
+            mErrorLineNumber = errorLineNumber;
+            return this;
+        }
+
+        @NonNull
+        public Builder withException(@Nullable Exception exception) {
+            mErrorExceptionClassName = exception.getClass().getName();
+            mErrorMessage = exception.getMessage();
+
+            StringWriter stringWriter = new StringWriter();
+            exception.printStackTrace(new PrintWriter(stringWriter));
+            mErrorStackTrace = stringWriter.toString();
+
+            if (exception.getStackTrace().length > 0) {
+                mErrorFileName = exception.getStackTrace()[0].getFileName();
+                mErrorClassName = exception.getStackTrace()[0].getClassName();
+                mErrorMethodName = exception.getStackTrace()[0].getMethodName();
+                mErrorLineNumber = exception.getStackTrace()[0].getLineNumber();
+            }
+            return this;
+        }
+
+        @NonNull
+        @Override
+        public ErrorEvent build() {
+            return new ErrorEvent(this);
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/Event.java b/mopub-sdk/src/main/java/com/mopub/common/event/Event.java
index fee902fd..4228ab35 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/event/Event.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/Event.java
@@ -1,12 +1,24 @@
 package com.mopub.common.event;
 
-import com.mopub.common.ClientMetadata;
+import android.support.annotation.NonNull;
 
 /**
  * Immutable data class with client event data.
  */
 public class Event extends BaseEvent {
-    Event(final Type eventType, final String requestUrl, final ClientMetadata metadata) {
-        super(eventType, requestUrl, metadata);
+    private Event(@NonNull Builder builder) {
+        super(builder);
+    }
+
+    public static class Builder extends BaseEvent.Builder {
+        public Builder(@NonNull Name name, @NonNull Category category, double samplingRate) {
+            super(ScribeCategory.EXCHANGE_CLIENT_EVENT, name, category, samplingRate);
+        }
+
+        @NonNull
+        @Override
+        public Event build() {
+            return new Event(this);
+        }
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/EventDispatcher.java b/mopub-sdk/src/main/java/com/mopub/common/event/EventDispatcher.java
new file mode 100644
index 00000000..f5ca5dbc
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/EventDispatcher.java
@@ -0,0 +1,49 @@
+package com.mopub.common.event;
+
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+
+public class EventDispatcher {
+    private final Iterable<EventRecorder> mEventRecorders;
+    private final Looper mLooper;
+    private final Handler mMessageHandler;
+    private final Handler.Callback mHandlerCallback;
+
+    @VisibleForTesting
+    EventDispatcher(Iterable<EventRecorder> recorders, Looper looper) {
+        mEventRecorders = recorders;
+        mLooper = looper;
+        mHandlerCallback = new Handler.Callback() {
+            @Override
+            public boolean handleMessage(final Message msg) {
+                if (msg.obj instanceof BaseEvent) {
+                    for (final EventRecorder recorder : mEventRecorders) {
+                        recorder.record((BaseEvent) msg.obj);
+                    }
+                } else {
+                    MoPubLog.d("EventDispatcher received non-BaseEvent message type.");
+                }
+                return true;
+            }
+        };
+        mMessageHandler = new Handler(mLooper, mHandlerCallback);
+    }
+
+    public void dispatch(BaseEvent event) {
+        Message.obtain(mMessageHandler, 0, event).sendToTarget();
+    }
+
+    @VisibleForTesting
+    Iterable<EventRecorder> getEventRecorders() {
+        return mEventRecorders;
+    }
+
+    @VisibleForTesting
+    Handler.Callback getHandlerCallback() {
+        return mHandlerCallback;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/EventRecorder.java b/mopub-sdk/src/main/java/com/mopub/common/event/EventRecorder.java
index 13ed5518..efaa5515 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/event/EventRecorder.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/EventRecorder.java
@@ -4,6 +4,5 @@
  * This interface represents a backend to which MoPub client events are logged.
  */
 public interface EventRecorder {
-    public void recordEvent(Event event);
-    public void recordTimedEvent(TimedEvent event);
+    public void record(BaseEvent baseEvent);
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/EventSampler.java b/mopub-sdk/src/main/java/com/mopub/common/event/EventSampler.java
new file mode 100644
index 00000000..607d28d8
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/EventSampler.java
@@ -0,0 +1,39 @@
+package com.mopub.common.event;
+
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+
+import java.util.Random;
+
+/**
+ * Samples events based on rules defined in the sample method.
+ */
+public class EventSampler {
+
+    @NonNull private Random mRandom;
+
+    public EventSampler() {
+        this(new Random());
+    }
+
+    @VisibleForTesting
+    public EventSampler(@NonNull Random random) {
+        mRandom = random;
+    }
+
+    /**
+     * Samples events based on custom rules.
+     *
+     * @param baseEvent The event to be sampled.
+     *
+     * @return Will return {@code true} if the event passed sampling and {@code false}
+     * if it is to be discarded.
+     */
+    boolean sample(@NonNull BaseEvent baseEvent) {
+        Preconditions.checkNotNull(baseEvent);
+
+        return mRandom.nextDouble() < baseEvent.getSamplingRate();
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/EventSerializer.java b/mopub-sdk/src/main/java/com/mopub/common/event/EventSerializer.java
new file mode 100644
index 00000000..94cf7c31
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/EventSerializer.java
@@ -0,0 +1,142 @@
+package com.mopub.common.event;
+
+import android.support.annotation.NonNull;
+
+import com.mopub.common.ClientMetadata;
+import com.mopub.common.Preconditions;
+import com.mopub.common.logging.MoPubLog;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.List;
+
+/**
+ * Serializes events to the data format expected by the Scribe service.
+ */
+public class EventSerializer {
+
+    /**
+     * Serializes a list of events as a JSON array of flattened JSON objects.
+     *
+     * @param events The events to be serialized.
+     *
+     * @return Will return a {@code JSONArray} of serialized {@code JSONObject}s.
+     */
+    @NonNull
+    public JSONArray serializeAsJson(@NonNull List<BaseEvent> events) {
+        Preconditions.checkNotNull(events);
+
+        JSONArray jsonArray = new JSONArray();
+        for (BaseEvent event : events) {
+            try {
+                jsonArray.put(serializeAsJson(event));
+            } catch (JSONException e) {
+                MoPubLog.d("Failed to serialize event \"" + event.getName() + "\" to JSON: ", e);
+            }
+        }
+        return jsonArray;
+    }
+
+    /**
+     * Serializes a single event as a flattened JSON object. Key values are expected by the Scribe
+     * service.
+     *
+     * @param event The event to be serialized.
+     *
+     * @return Will return a single serialized {@code JSONObject}.
+     */
+    @NonNull
+    public JSONObject serializeAsJson(@NonNull BaseEvent event) throws JSONException {
+        Preconditions.checkNotNull(event);
+
+        // Note: adding null values to the JSONObject will remove the key value pair
+        JSONObject jsonObject = new JSONObject();
+
+        // Required Scribe Request Keys
+        jsonObject.put("_category_", event.getScribeCategory().getCategory());
+        jsonObject.put("ts", event.getTimestampUtcMs());
+
+        // Name Details
+        jsonObject.put("name",  event.getName().getName());
+        jsonObject.put("name_category", event.getCategory().getCategory());
+
+        // SDK Details
+        BaseEvent.SdkProduct sdkProduct = event.getSdkProduct();
+        jsonObject.put("sdk_product", sdkProduct == null ? null : sdkProduct.getType());
+        jsonObject.put("sdk_version", event.getSdkVersion());
+
+        // Ad Details
+        jsonObject.put("ad_unit_id", event.getAdUnitId());
+        jsonObject.put("ad_creative_id", event.getAdCreativeId());
+        jsonObject.put("ad_type", event.getAdType());
+        jsonObject.put("ad_network_type", event.getAdNetworkType());
+        jsonObject.put("ad_width_px", event.getAdWidthPx());
+        jsonObject.put("ad_height_px", event.getAdHeightPx());
+
+        // App Details
+        BaseEvent.AppPlatform appPlatform = event.getAppPlatform();
+        jsonObject.put("app_platform", appPlatform == null ? null : appPlatform.getType());
+        jsonObject.put("app_name", event.getAppName());
+        jsonObject.put("app_package_name", event.getAppPackageName());
+        jsonObject.put("app_version", event.getAppVersion());
+
+        // Client Details
+        // Server side requires these values to be populated to satisfy thrift union
+        jsonObject.put("client_advertising_id", event.getObfuscatedClientAdvertisingId());
+        jsonObject.put("client_do_not_track", event.getClientDoNotTrack());
+
+        // Device Details
+        jsonObject.put("device_manufacturer", event.getDeviceManufacturer());
+        jsonObject.put("device_model", event.getDeviceModel());
+        jsonObject.put("device_product", event.getDeviceProduct());
+        jsonObject.put("device_os_version", event.getDeviceOsVersion());
+
+        // These fields will actually be the dip value until deprecated and new fields
+        // added for future releases
+        jsonObject.put("device_screen_width_px", event.getDeviceScreenWidthDip());
+        jsonObject.put("device_screen_height_px", event.getDeviceScreenHeightDip());
+
+        // Geo Details
+        jsonObject.put("geo_lat", event.getGeoLat());
+        jsonObject.put("geo_lon", event.getGeoLon());
+        jsonObject.put("geo_accuracy_radius_meters", event.getGeoAccuracy());
+
+        // Performance Details
+        jsonObject.put("perf_duration_ms", event.getPerformanceDurationMs());
+
+        // Network Details
+        ClientMetadata.MoPubNetworkType moPubNetworkType = event.getNetworkType();
+        jsonObject.put("network_type", moPubNetworkType == null ? null : moPubNetworkType.getId());
+        jsonObject.put("network_operator_code", event.getNetworkOperatorCode());
+        jsonObject.put("network_operator_name", event.getNetworkOperatorName());
+        jsonObject.put("network_iso_country_code", event.getNetworkIsoCountryCode());
+        jsonObject.put("network_sim_code", event.getNetworkSimCode());
+        jsonObject.put("network_sim_operator_name", event.getNetworkSimOperatorName());
+        jsonObject.put("network_sim_iso_country_code", event.getNetworkSimIsoCountryCode());
+
+        // Request Details
+        jsonObject.put("req_id", event.getRequestId());
+        jsonObject.put("req_status_code", event.getRequestStatusCode());
+        jsonObject.put("req_uri", event.getRequestUri());
+        jsonObject.put("req_retries", event.getRequestRetries());
+
+        // Timestamp Details
+        jsonObject.put("timestamp_client", event.getTimestampUtcMs());
+
+        if (event instanceof ErrorEvent) {
+            ErrorEvent errorEvent = (ErrorEvent) event;
+            // Error Details
+            jsonObject.put("error_exception_class_name", errorEvent.getErrorExceptionClassName());
+            jsonObject.put("error_message", errorEvent.getErrorMessage());
+            jsonObject.put("error_stack_trace", errorEvent.getErrorStackTrace());
+            jsonObject.put("error_file_name", errorEvent.getErrorFileName());
+            jsonObject.put("error_class_name", errorEvent.getErrorClassName());
+            jsonObject.put("error_method_name", errorEvent.getErrorMethodName());
+            jsonObject.put("error_line_number", errorEvent.getErrorLineNumber());
+        }
+
+        return jsonObject;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/LogCatEventRecorder.java b/mopub-sdk/src/main/java/com/mopub/common/event/LogCatEventRecorder.java
new file mode 100644
index 00000000..f983de70
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/LogCatEventRecorder.java
@@ -0,0 +1,11 @@
+package com.mopub.common.event;
+
+import com.mopub.common.logging.MoPubLog;
+
+class LogCatEventRecorder implements EventRecorder {
+    @Override
+    public void record(final BaseEvent baseEvent) {
+        MoPubLog.d(baseEvent.toString());
+    }
+}
+
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/MoPubEvents.java b/mopub-sdk/src/main/java/com/mopub/common/event/MoPubEvents.java
index a36c4f9f..3e76abff 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/event/MoPubEvents.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/MoPubEvents.java
@@ -1,36 +1,24 @@
 package com.mopub.common.event;
 
-import android.os.Handler;
 import android.os.HandlerThread;
-import android.os.Message;
 
-import com.mopub.common.ClientMetadata;
 import com.mopub.common.VisibleForTesting;
 
 import java.util.ArrayList;
 
 /**
- * Records both untimed and timed events. This class maintains a queue of events to be recorded and
- * launches a background thread to handler their recording.
+ * Public interface used to record client events.
  */
 public class MoPubEvents {
 
     private static volatile EventDispatcher sEventDispatcher;
 
-    private static EventDispatcher getDispatcher() {
-        EventDispatcher result = sEventDispatcher;
-        if (result == null) {
-            synchronized (MoPubEvents.class) {
-                result = sEventDispatcher;
-                if (result == null) {
-                    ArrayList<EventRecorder> recorders = new ArrayList<EventRecorder>();
-                    recorders.add(new NoopEventRecorder());
-                    HandlerThread handlerThread = new HandlerThread("mopub_event_queue");
-                    result = sEventDispatcher = new EventDispatcher(recorders, handlerThread);
-                }
-            }
-        }
-        return result;
+    /**
+     * Log a BaseEvent. MoPub uses logged events to analyze and improve performance.
+     * This method should not be called by app developers.
+     */
+    public static void log(BaseEvent baseEvent) {
+        MoPubEvents.getDispatcher().dispatch(baseEvent);
     }
 
     @VisibleForTesting
@@ -39,87 +27,29 @@ public static void setEventDispatcher(EventDispatcher dispatcher) {
     }
 
     /**
-     * Log a ClientEvent. MoPub uses logged events to analyze and improve performance.
-     * This method should not be called by app developers.
+     * Returns a singleton event dispatcher constructed with a single background thread meant to be
+     * used for all event logging operations. Operations that end up on the main thread, such as
+     * the result of a network request, should post to this background thread when interacting
+     * with shared resources in order to avoid concurrency issues.
+     *
+     * This design is meant to emulate an {@code IntentService} which we can't use due to
+     * the requirement of the publisher having to update their manifest file.
      */
-    public static void event(Event.Type eventType, String requestUrl) {
-        final EventDispatcher dispatcher = MoPubEvents.getDispatcher();
-        final Event event = new Event(eventType, requestUrl, ClientMetadata.getInstance());
-        dispatcher.sendEventToHandlerThread(event);
-    }
-
-
-    /**
-     * Create and start a TimedEvent. A TimedEvent isn't recored until
-     * {@link com.mopub.common.event.TimedEvent#stop(int)} is called.
-     */
-    public static TimedEvent timedEvent(Event.Type eventType, String requestUrl) {
-        final EventDispatcher events = getDispatcher();
-        final TimedEvent event =
-                new TimedEvent(eventType, requestUrl, ClientMetadata.getInstance(), events);
-        return event;
-    }
-
-    private static class NoopEventRecorder implements EventRecorder {
-
-        @Override
-        public void recordEvent(final Event event) {
-
-        }
-
-        @Override
-        public void recordTimedEvent(final TimedEvent event) {
-
-        }
-    }
-
     @VisibleForTesting
-    public static class EventDispatcher implements TimedEvent.Listener {
-        private final Iterable<EventRecorder> mEventRecorders;
-        private final HandlerThread mHandlerThread;
-        private final Handler mMessageHandler;
-
-        @VisibleForTesting Handler.Callback mHandlerCallback;
-
-        @VisibleForTesting
-        EventDispatcher(Iterable<EventRecorder> recorders, HandlerThread handlerThread) {
-            mEventRecorders = recorders;
-            mHandlerCallback = new Handler.Callback() {
-                @Override
-                public boolean handleMessage(final Message msg) {
-                    if (msg.obj instanceof TimedEvent) {
-                        final TimedEvent event = (TimedEvent) msg.obj;
-                        for (final EventRecorder recorder : mEventRecorders) {
-                            recorder.recordTimedEvent(event);
-                        }
-
-                    } else if (msg.obj instanceof Event) {
-                        final Event event = (Event) msg.obj;
-                        for (final EventRecorder recorder : mEventRecorders) {
-                            recorder.recordEvent(event);
-                        }
-                    }
-                    return true; // Even if it's not an event, swallow the message.
+    static EventDispatcher getDispatcher() {
+        EventDispatcher result = sEventDispatcher;
+        if (result == null) {
+            synchronized (MoPubEvents.class) {
+                result = sEventDispatcher;
+                if (result == null) {
+                    ArrayList<EventRecorder> recorders = new ArrayList<EventRecorder>();
+                    HandlerThread handlerThread = new HandlerThread("mopub_event_logging");
+                    handlerThread.start();
+                    recorders.add(new ScribeEventRecorder(handlerThread.getLooper()));
+                    result = sEventDispatcher = new EventDispatcher(recorders, handlerThread.getLooper());
                 }
-            };
-            mHandlerThread = handlerThread;
-            mHandlerThread.start();
-            mMessageHandler = new Handler(mHandlerThread.getLooper(), mHandlerCallback);
-        }
-
-        private void sendEventToHandlerThread(BaseEvent event) {
-            final Message message = Message.obtain(mMessageHandler, 0, event);
-            message.sendToTarget();
-        }
-
-        @Override
-        public void onStopped(final TimedEvent event) {
-            this.sendEventToHandlerThread(event);
-        }
-
-        @Override
-        public void onCancelled(final TimedEvent event) {
-            // Nothing to do for now.
+            }
         }
+        return result;
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/NoopEventRecorder.java b/mopub-sdk/src/main/java/com/mopub/common/event/NoopEventRecorder.java
new file mode 100644
index 00000000..5459ffbe
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/NoopEventRecorder.java
@@ -0,0 +1,8 @@
+package com.mopub.common.event;
+
+class NoopEventRecorder implements EventRecorder {
+    @Override
+    public void record(final BaseEvent baseEvent) {
+    }
+}
+
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/ScribeEventRecorder.java b/mopub-sdk/src/main/java/com/mopub/common/event/ScribeEventRecorder.java
new file mode 100644
index 00000000..96a63ae9
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/event/ScribeEventRecorder.java
@@ -0,0 +1,142 @@
+package com.mopub.common.event;
+
+import android.os.Handler;
+import android.os.Looper;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.network.ScribeBackoffPolicy;
+import com.mopub.network.ScribeRequest;
+import com.mopub.network.ScribeRequestManager;
+
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Queue;
+
+/**
+ * The ScribeEventRecorder manages events being sent to the Scribe service. It is responsible for
+ * sampling, batching and kicking off network requests. It is also responsible for ensuring batched
+ * events don't grow unbounded.
+ */
+public class ScribeEventRecorder implements EventRecorder {
+    private static final String SCRIBE_URL = "https://analytics.mopub.com/i/jot/exchange_client_event";
+    private static final int QUEUE_MAX_SIZE = 500;
+
+    /**
+     * As of SDK 3.6.0, events are roughly 1200 bytes in size. 1200 * 100 = 0.114441 MiB
+     * This threshhold must always be < 1 MiB
+     */
+    private static final int EVENT_COUNT_SEND_THRESHHOLD = 100;
+
+    /**
+     * 2 minute polling time to check for send up events
+     */
+    private static final int POLLING_PERIOD_MS = 2 * 60 * 1000;
+
+    @NonNull private final EventSampler mEventSampler;
+    @NonNull private final Queue<BaseEvent> mEventQueue;
+    @NonNull private final EventSerializer mEventSerializer;
+    @NonNull private final ScribeRequestManager mScribeRequestManager;
+
+    @NonNull private final Handler mPollHandler;
+    @NonNull private final PollingRunnable mPollingRunnable;
+
+    ScribeEventRecorder(@NonNull Looper looper) {
+        this(new EventSampler(),
+                new LinkedList<BaseEvent>(),
+                new EventSerializer(),
+                new ScribeRequestManager(looper),
+                new Handler(looper));
+    }
+
+    @VisibleForTesting
+    ScribeEventRecorder(@NonNull EventSampler eventSampler,
+            @NonNull Queue<BaseEvent> eventQueue,
+            @NonNull EventSerializer eventSerializer,
+            @NonNull ScribeRequestManager scribeRequestManager,
+            @NonNull Handler handler) {
+        mEventSampler = eventSampler;
+        mEventQueue = eventQueue;
+        mEventSerializer = eventSerializer;
+        mScribeRequestManager = scribeRequestManager;
+        mPollHandler = handler;
+        mPollingRunnable = new PollingRunnable();
+    }
+
+    @Override
+    public void record(@NonNull BaseEvent baseEvent) {
+        if (!mEventSampler.sample(baseEvent)) {
+            return;
+        }
+
+        if (mEventQueue.size() >= QUEUE_MAX_SIZE) {
+            MoPubLog.d("EventQueue is at max capacity. " +
+                    "Event \"" + baseEvent.getName() + "\" is being dropped.");
+            return;
+        }
+
+        mEventQueue.add(baseEvent);
+        if (mEventQueue.size() >= EVENT_COUNT_SEND_THRESHHOLD) {
+            sendEvents();
+        }
+
+        scheduleNextPoll();
+    }
+
+    @VisibleForTesting
+    void sendEvents() {
+        if (mScribeRequestManager.isAtCapacity()) {
+            return;
+        }
+
+        final List<BaseEvent> events = dequeueEvents();
+        if (events.isEmpty()) {
+            return;
+        }
+
+        mScribeRequestManager.makeRequest(
+                new ScribeRequest.ScribeRequestFactory() {
+                    @Override
+                    public ScribeRequest createRequest(ScribeRequest.Listener listener) {
+                        return new ScribeRequest(SCRIBE_URL, events, mEventSerializer, listener);
+                    }
+                },
+                new ScribeBackoffPolicy()
+        );
+    }
+
+    @VisibleForTesting
+    @NonNull
+    List<BaseEvent> dequeueEvents() {
+        ArrayList<BaseEvent> baseEvents = new ArrayList<BaseEvent>();
+
+        // Note: Some queues do not have constant time O(1) performance for its #size()
+        // method, so we're peeking and polling instead
+        while (mEventQueue.peek() != null && baseEvents.size() < EVENT_COUNT_SEND_THRESHHOLD) {
+            baseEvents.add(mEventQueue.poll());
+        }
+        return baseEvents;
+    }
+
+    @VisibleForTesting
+    void scheduleNextPoll() {
+        // Only schedule if there are no messages already scheduled.
+        // The user defined message code, the 'what' param in Handler#hasMessages, defaults to
+        // 0 for posting a delayed runnable
+        if (mPollHandler.hasMessages(0) || mEventQueue.isEmpty()) {
+            return;
+        }
+
+        mPollHandler.postDelayed(mPollingRunnable, POLLING_PERIOD_MS);
+    }
+
+    class PollingRunnable implements Runnable {
+        @Override
+        public void run() {
+            sendEvents();
+            scheduleNextPoll();
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/event/TimedEvent.java b/mopub-sdk/src/main/java/com/mopub/common/event/TimedEvent.java
deleted file mode 100644
index c2aa7dc9..00000000
--- a/mopub-sdk/src/main/java/com/mopub/common/event/TimedEvent.java
+++ /dev/null
@@ -1,76 +0,0 @@
-package com.mopub.common.event;
-
-import com.mopub.common.ClientMetadata;
-
-import java.util.concurrent.TimeUnit;
-
-/**
- * Immutable data class with client event data, including a duration.
- */
-public class TimedEvent extends BaseEvent {
-    interface Listener {
-        public void onStopped(TimedEvent event);
-
-        public void onCancelled(TimedEvent event);
-    }
-
-    /**
-     * Use this status code when stopping an event where an HTTP Status Code isn't relevant.
-     */
-    public static final int SC_NOT_RELEVANT = 0;
-
-    /**
-     * Use this status code when the timed event has no response.
-     */
-    public static final int SC_NO_RESPONSE = -1;
-
-    private final long mStartTimeNanos;
-    private enum State {
-        WAITING, STOPPED, CANCELLED
-    }
-    private State mState;
-    private final Listener mListener;
-
-
-    private long mDurationMillis;
-    private int mHttpStatusCode;
-
-    TimedEvent(final Type eventType, final String requestUrl,
-            final ClientMetadata clientMetadata, Listener listener) {
-        super(eventType, requestUrl, clientMetadata);
-        // System.nanoTime isn't affected by changing the system time, so we use it here.
-        mState = State.WAITING;
-        mStartTimeNanos = System.nanoTime();
-        mListener = listener;
-    }
-
-    public synchronized void stop(int httpStatusCode) {
-        if (mState == State.WAITING) {
-            mState = State.STOPPED;
-            mHttpStatusCode = httpStatusCode;
-            long stopTimeNanos = System.nanoTime();
-            mDurationMillis = TimeUnit.MILLISECONDS.convert(stopTimeNanos - mStartTimeNanos,
-                    TimeUnit.NANOSECONDS);
-            if (mListener != null) {
-                mListener.onStopped(this);
-            }
-        }
-    }
-
-    public synchronized void cancel() {
-        if (mState == State.WAITING) {
-            mState = State.CANCELLED;
-            if (mListener != null) {
-                mListener.onCancelled(this);
-            }
-        }
-    }
-
-    public final synchronized long getDurationMillis() {
-        return mDurationMillis;
-    }
-
-    public final synchronized int getHttpStatusCode() {
-        return mHttpStatusCode;
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/logging/MoPubLog.java b/mopub-sdk/src/main/java/com/mopub/common/logging/MoPubLog.java
index 70ac4e7b..d12ea28a 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/logging/MoPubLog.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/logging/MoPubLog.java
@@ -1,12 +1,8 @@
 package com.mopub.common.logging;
 
 import android.util.Log;
-import android.util.SparseArray;
 
-import java.util.ArrayList;
-import java.util.EnumMap;
 import java.util.HashMap;
-import java.util.List;
 import java.util.Map;
 import java.util.logging.Handler;
 import java.util.logging.Level;
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/DateAndTime.java b/mopub-sdk/src/main/java/com/mopub/common/util/DateAndTime.java
index 01e6edb3..27f49bc5 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/DateAndTime.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/DateAndTime.java
@@ -2,6 +2,7 @@
 
 import java.text.SimpleDateFormat;
 import java.util.Date;
+import java.util.Locale;
 import java.util.TimeZone;
 
 public class DateAndTime {
@@ -23,7 +24,7 @@ public static Date now() {
     public static String getTimeZoneOffsetString() {
         // A new instance is created with each call because DateFormat objects have
         // internal state and are not thread safe.
-        SimpleDateFormat format = new SimpleDateFormat("Z");
+        SimpleDateFormat format = new SimpleDateFormat("Z", Locale.US);
         format.setTimeZone(localTimeZone());
         return format.format(now());
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/DeviceUtils.java b/mopub-sdk/src/main/java/com/mopub/common/util/DeviceUtils.java
index 3ac25c61..8d9b34c6 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/DeviceUtils.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/DeviceUtils.java
@@ -1,14 +1,28 @@
 package com.mopub.common.util;
 
+import android.annotation.TargetApi;
+import android.app.Activity;
 import android.app.ActivityManager;
 import android.content.Context;
+import android.content.pm.ActivityInfo;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
+import android.content.res.Configuration;
+import android.graphics.Point;
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
+import android.os.Build;
 import android.os.StatFs;
 import android.provider.Settings;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.DisplayMetrics;
+import android.view.Display;
+import android.view.Surface;
+import android.view.WindowManager;
 
+import com.mopub.common.CreativeOrientation;
+import com.mopub.common.Preconditions;
 import com.mopub.common.logging.MoPubLog;
 
 import org.apache.http.conn.util.InetAddressUtils;
@@ -17,11 +31,11 @@
 import java.net.InetAddress;
 import java.net.NetworkInterface;
 import java.net.SocketException;
+import java.util.Locale;
 
 import static android.Manifest.permission.ACCESS_NETWORK_STATE;
 import static android.Manifest.permission.INTERNET;
 import static com.mopub.common.util.Reflection.MethodBuilder;
-
 import static com.mopub.common.util.VersionCode.HONEYCOMB;
 import static com.mopub.common.util.VersionCode.currentApiLevel;
 import static java.util.Collections.list;
@@ -33,6 +47,30 @@
 
     private DeviceUtils() {}
 
+    public static enum ForceOrientation {
+        FORCE_PORTRAIT("portrait"),
+        FORCE_LANDSCAPE("landscape"),
+        DEVICE_ORIENTATION("device"),
+        UNDEFINED("");
+
+        @NonNull private final String mKey;
+
+        private ForceOrientation(@NonNull final String key) {
+            mKey = key;
+        }
+
+        @NonNull
+        public static ForceOrientation getForceOrientation(@Nullable String key) {
+            for (final ForceOrientation orientation : ForceOrientation.values()) {
+                if (orientation.mKey.equalsIgnoreCase(key)) {
+                    return orientation;
+                }
+            }
+
+            return UNDEFINED;
+        }
+    }
+
     public static enum IP {
         IPv4,
         IPv6;
@@ -64,7 +102,7 @@ public static String getIpAddress(IP ip) throws SocketException {
         for (final NetworkInterface networkInterface : list(NetworkInterface.getNetworkInterfaces())) {
             for (final InetAddress address : list(networkInterface.getInetAddresses())) {
                 if (!address.isLoopbackAddress()) {
-                    String hostAddress = address.getHostAddress().toUpperCase();
+                    String hostAddress = address.getHostAddress().toUpperCase(Locale.US);
                     if (ip.matches(hostAddress)) {
                         return ip.toString(hostAddress);
                     }
@@ -84,11 +122,7 @@ public static String getHashedUdid(final Context context) {
         return Utils.sha1(udid);
     }
 
-    public static String getUserAgent() {
-        return System.getProperty("http.agent");
-    }
-
-    public static boolean isNetworkAvailable(final Context context) {
+    public static boolean isNetworkAvailable(@Nullable final Context context) {
         if (context == null) {
             return false;
         }
@@ -138,9 +172,8 @@ public static int memoryCacheSizeBytes(final Context context) {
         return (int) result;
     }
 
-    public static long diskCacheSizeBytes(File dir) {
-        long size = MIN_DISK_CACHE_SIZE;
-
+    public static long diskCacheSizeBytes(File dir, long minSize) {
+        long size = minSize;
         try {
             StatFs statFs = new StatFs(dir.getAbsolutePath());
             long availableBytes = ((long) statFs.getBlockCount()) * statFs.getBlockSize();
@@ -152,4 +185,126 @@ public static long diskCacheSizeBytes(File dir) {
         // Bound inside min/max size for disk cache.
         return Math.max(Math.min(size, MAX_DISK_CACHE_SIZE), MIN_DISK_CACHE_SIZE);
     }
+
+    public static long diskCacheSizeBytes(File dir) {
+        return diskCacheSizeBytes(dir, MIN_DISK_CACHE_SIZE);
+    }
+
+    public static int getScreenOrientation(@NonNull final Activity activity) {
+        final int rotation = activity.getWindowManager().getDefaultDisplay().getRotation();
+        final int deviceOrientation = activity.getResources().getConfiguration().orientation;
+
+        return getScreenOrientationFromRotationAndOrientation(rotation, deviceOrientation);
+    }
+
+    static int getScreenOrientationFromRotationAndOrientation(int rotation, int orientation) {
+        if (Configuration.ORIENTATION_PORTRAIT == orientation) {
+            switch (rotation) {
+                case Surface.ROTATION_180:
+                case Surface.ROTATION_270:
+                    return ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT;
+
+                case Surface.ROTATION_0:
+                case Surface.ROTATION_90:
+                default:
+                    return ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
+            }
+        } else if (Configuration.ORIENTATION_LANDSCAPE == orientation) {
+            switch (rotation) {
+                case Surface.ROTATION_180:
+                case Surface.ROTATION_270:
+                    return ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE;
+
+                case Surface.ROTATION_0:
+                case Surface.ROTATION_90:
+                default:
+                    return ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
+            }
+        } else {
+            MoPubLog.d("Unknown screen orientation. Defaulting to portrait.");
+            return ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT;
+        }
+    }
+
+    /**
+     * Lock this activity in the requested orientation, rotating the display if necessary.
+     *
+     * @param creativeOrientation the orientation of the screen needed by the ad creative.
+     */
+    public static void lockOrientation(@NonNull Activity activity, @NonNull CreativeOrientation creativeOrientation) {
+        if (!Preconditions.NoThrow.checkNotNull(creativeOrientation) || !Preconditions.NoThrow.checkNotNull(activity)) {
+            return;
+        }
+
+        Display display = ((WindowManager) activity.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        final int currentRotation = display.getRotation();
+        final int deviceOrientation = activity.getResources().getConfiguration().orientation;
+
+        final int currentOrientation = getScreenOrientationFromRotationAndOrientation(currentRotation, deviceOrientation);
+        int requestedOrientation;
+
+        // Choose a requested orientation that will result in the smallest change from the existing orientation.
+        if (CreativeOrientation.PORTRAIT == creativeOrientation) {
+            if (ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT == currentOrientation) {
+                requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT;
+            } else {
+                requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
+            }
+        } else if (CreativeOrientation.LANDSCAPE == creativeOrientation) {
+            if (ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE == currentOrientation) {
+                requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE;
+            } else {
+                requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
+            }
+        } else {
+            // Don't lock screen orientation if the creative doesn't care.
+            return;
+        }
+
+        activity.setRequestedOrientation(requestedOrientation);
+    }
+
+    /**
+     * This tries to get the physical number of pixels on the device. This attempts to include
+     * the pixels in the notification bar and soft buttons.
+     *
+     * @param context Needs a context (application is fine) to determine width/height.
+     * @return Width and height of the device
+     */
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+    public static Point getDeviceDimensions(@NonNull final Context context) {
+        Integer bestWidthPixels = null;
+        Integer bestHeightPixels = null;
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {
+            final WindowManager windowManager = (WindowManager) context.getSystemService(
+                    Context.WINDOW_SERVICE);
+            final Display display = windowManager.getDefaultDisplay();
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
+                final Point screenSize = new Point();
+                display.getRealSize(screenSize);
+                bestWidthPixels = screenSize.x;
+                bestHeightPixels = screenSize.y;
+            } else {
+                try {
+                    bestWidthPixels = (Integer) new MethodBuilder(display,
+                            "getRawWidth").execute();
+                    bestHeightPixels = (Integer) new MethodBuilder(display,
+                            "getRawHeight").execute();
+                } catch (Exception e) {
+                    // Best effort. If this fails, just get the height and width normally,
+                    // which may not capture the pixels used in the notification bar.
+                    MoPubLog.v("Display#getRawWidth/Height failed.", e);
+                }
+            }
+        }
+
+        if (bestWidthPixels == null || bestHeightPixels == null) {
+            final DisplayMetrics displayMetrics = context.getResources().getDisplayMetrics();
+            bestWidthPixels = displayMetrics.widthPixels;
+            bestHeightPixels = displayMetrics.heightPixels;
+        }
+
+        return new Point(bestWidthPixels, bestHeightPixels);
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/Dips.java b/mopub-sdk/src/main/java/com/mopub/common/util/Dips.java
index 71e2f464..bde599fa 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/Dips.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Dips.java
@@ -1,9 +1,12 @@
 package com.mopub.common.util;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import android.util.DisplayMetrics;
 import android.util.TypedValue;
 
+import com.mopub.common.Preconditions;
+
 public class Dips {
     public static float pixelsToFloatDips(final float pixels, final Context context) {
         return pixels / getDensity(context);
@@ -33,4 +36,16 @@ public static float asFloatPixels(float dips, Context context) {
     public static int asIntPixels(float dips, Context context) {
         return (int) (asFloatPixels(dips, context) + 0.5f);
     }
+
+    public static int screenWidthAsIntDips(@NonNull Context context) {
+        Preconditions.checkNotNull(context);
+
+        return pixelsToIntDips(context.getResources().getDisplayMetrics().widthPixels, context);
+    }
+
+    public static int screenHeightAsIntDips(@NonNull Context context) {
+        Preconditions.checkNotNull(context);
+
+        return pixelsToIntDips(context.getResources().getDisplayMetrics().heightPixels, context);
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/Drawables.java b/mopub-sdk/src/main/java/com/mopub/common/util/Drawables.java
index 63d32fa3..5e1b1a68 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/Drawables.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Drawables.java
@@ -1,13 +1,13 @@
 package com.mopub.common.util;
 
 import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
 import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
 import android.util.Base64;
 import android.util.DisplayMetrics;
 
-import java.io.ByteArrayInputStream;
-
 public enum Drawables {
     BACKGROUND("iVBORw0KGgoAAAANSUhEUgAAAAEAAAAsCAIAAAArRUU2AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAEFJREFUeNpicPP0Zvr3/z/T/3//gDQQg+i//5j+gum/QBqIQXwg+x+YjckH6fkL0/f3NwMPHz8jKxsbAw0AQIABAGYHPKslk98oAAAAAElFTkSuQmCC"),
     DEFAULT_VIDEO_POSTER("iVBORw0KGgoAAAANSUhEUgAAAEsAAAA8CAYAAAAuaUeTAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAADU1JREFUeNrUW2+kXdkVP/vkCI8QQikllFfv3cu0Q8bwmA8VwpB+CUNG52M/lTChOkKjdExN9VupGUbzqcKEahgThpG0MSFf8jSduvdliFbLMAyPMDzC27tr77vXOr+1zj5/7ptW0/vct8/ZZ/9b66z1W3/2vu769etV/Cz3ljuucs9V+RPoj+4r/GAdXd+Zz+aP042nb50b/R9cE61zouOlAdos7bvz+Xy3iQMsP1v+mh7+lBv1lWbgQ5r0tfnW/AYvxNNfHVfzDF/Tmn9Ea//dCG2qTMK0XF6t9z7bOxZCuBQrXHBp0FQGKJnjIcTR0j3VH6Pnl4ILqQ8PGss0RuWeufp4TTS8nmitDI2W9khzWPEk030pCugJ4viGTzJaJe6nt+BqeRuxc557JUTBc7uTPPGYVD4LZX7nJxU9VCe0BkOzq5AXG7UQ73MDX60G4tK1ZerkVoNyfeQ6MzrA30ozn7H6zKTEFNcyB2mVZ5FWr8s6+Cyuri2TiLos0t6LyMa2zmcx962osegy82KJIv7M1COAo9rF0q1olWeZ7tQ/9iF6G9HtkN9AMINVZlAAPSo39vb2zgTU0f/RB9c11IY+x5keppelDmllCZV29GkEf0C9IuMip1PJeu+cDCa67epNKh+gWsLKWjWuzLW22botll1qu32YqLi+SKRrMVWNA/WKnrBSMaZVaMQ6l9spIHcAfBYAGRQNEaL3UdSdX13nhUl9xhAeo1Nf+XKdy9euHRMxieeS9WnjI+Nxe8twYWrVgrx6IWjQ6HmTuAfmMmFXyNgVtFiK+jndR6QxiyyrcWwXVitWplxUHcx3aslzZ5zo4Aq3dxpLUUpYCpJmVMrVaVU108dlwmJ0j6qqy4fE2Mx9Fj8cXHXOxOIzi2fIDOuz8Bw4VudZMPNUvlhiO5kveMUUlmKeE+nDF9YZq6q64+RnDTIjvRWWpCwtUoIp7iNexoA3qybGPiUJBnzga5QEbKckvIepYpByu741iqTbuYPWpMaqFenwre3Z9g86gLuKH6+T7v6QJc6CJIN/xxBUZcNRAlg0OMknYkAOLfBKGwbsvH4BYm7DZdC4HO9lTOf/9vz3nv9uyXo+/OvDd6jPj3ne5Dqw78STCUczAQj6yPmEG5lh4q8BZlnXA8fkOoU/TuOTqLNzXTXLbZOEejNvHz6hlPJzP+BrAJzEPrXCH4iJBLBDUGpY0v0OhpVwBrEKcQ4xI3RxUYF0we9TOGdekAV3NBLWUS3zStPbKCY5cE7pc0h/bFrZE7a6TQP9g8rfU/m5xRwlFdkPUgS7ghVmCYF+IoVVt7/CU8Qwp+jaoHbnqe6cspiV025FQbJwLQ2acWQU+ius6wjY+dk+lS8Qxu0XHcy+umrEYe1zVKue/mN9Vte/Icx9n9Z7ESW1lmRXWbLiH+NwYxE/pzHKmBM6Vuzu1mxrP+IVMhxLxClVV7XzqX7mHsOvToIumOyCwUUUhOxQ3yRaLqKFHJMslOJGMMKLVTq5XC7P2H752SlUBxrswPphGJ/ZWHKsrtf0r9lfuTJYH8JXkY5EsxfrurG7u3umxCuSum+wJYzkJslK5pRNdEy3uuqBEu+IX2GFX4xjSt/hDaJ4j9UtHy1PU+9v0/f+fDZ/Ku4B4+QRxhTYsOO4NrpAd4W+m9TvQUmFmVamvUYzn9yGPFhiIt8X3hhaEvFlMH6ELz7nkhh1gZ7+ncb4M5X/JDy5KPkkM06pPz4fq0uBPr9X4xZx7Mh5OeSBZEkzzXVUv6Sb3rV5HC591nu/8ke4Lg2Uy9Q/W84ppYRFPrxOYxzLY36Tvu8vFovbi73FnNvxi+Kyb9xSW3wubTIdlh7xzZAHflWm2NozTGXrxtxF79zmslMdOoPwJiU/DzntUj37T/Q5xaneROAq2XiW6v+yt7f3Nn1PoM+HiT2ss2Vn/yA46YPpHCzRLVKuTDZ83LZGZuAfpjzkTWcHFZ9LnprTIvCx9WKmwZ/CpGNud5y+V6huQap5Qe0LFOaY8ozTPNb5LaZ8gFZsE+9rFjUOVyT08VocxWT7oEpW4wiCY6XCQhyHVYKNxkr0TxNxf1wsFx/Sd5Mli/sXxzSlWoNRv1XqytBaAc2V132qrIYicj6oWEj8L85P+6BiQsarIbXrUxur7mqhUQrcKmalv/PU9FNSy1/QdwPDlSHVs6UYd1QvYAzuN0i86YJiaB25zpMmUMxvInE0XvtDYWJsF+9lVye/RV4UMgQXi/XsSLJ0yXhghWXeOF9IQL1BdT+n55/uLffO2z0/O76yZLwe78tSaCy8zMlryBAR6xpMeeR+9+j6sjhjOs38Fq3zZcYX7mN9m6GSU9GCaZDawbWoVEyb5tmkug8Jy25S98vkm/0LfTPrd6l61+KlCnFC9ZievyrPwbekuis03yvcvhHVaoPWJ7Ot2W7JoyU12FepXogX2YFDI2Hr1W5xVB+bnvE6ZSMw4J2U2ahcoP7nKNJ4YzabvYvz9JViUTkA97Keg52dnSK99+/f/xLTQXUH+bNflVQv45R87UZmbouGAH0ZrLfP2BLaVDRbR7SWyllsr0/Q9x2SsnNJ/cAg4TyyLkgS4BzVYDpLW+y6BJjsDqCHy5OU2g7FdZIuxtyW02PZ/L3Na2FWVWLTFpees/FhJ3cG/lpp83WIWbiOhnUY07Aqm4mJO27r2rQuc30ogO0wLFtIwZNQd/Alecz5T3AM2mcqDmicD+x6hzY61H6iG9m59dpfrMUfycGyHB8yLj9vbbP6SduqUu1sKFGsg9MtxRAmlEMZ0+4javcCYdbjvvlQNTn1nMbM0sRWb0iycI1NYfPh5OLRoj9FkwGPD1BgLmtKSjm19kFJb3FDAzc2nEo4Lqn8yfZs+yOJWw3GlOZO+4PRC7ebFs5tfHLvk/4UDbRtZDfWS0rjpbquH0jkkCWen4sa1JXaPFVnoCbkquwblReQtslXWYJYpnlXardPc16lNby3tbV1aNV/VA2D6+62r1R5k8Z/ILR6QzO4MI2cHAGzjnVsYq1IJqsjrnhV9m16ck0o4lJ6GJ+cQZj7KdX/lqrfJCY9wW13y6zSHFwvAbvNYvjD9mAJhHxCD8BPw/4Opnx7D2ZgIi3ovP3aFtEcIrFp41x/k6reIJV7jDvYQ0akpI6882Npks1XgACEJcWT6JQWT81wCYOhm4CHRkrJ/6HMpWWIyre38zyk8vJse3a3JElTs6RqQ8J1T/eUXpDigcHPxp7LUlhjDobg5qX4Z667E2RTNDZtklXiEBea5/mCyqvz7fk1yZIOMcCkaPrSNuLmFM5jqTMXhf1FLOtSRqB0MFVF+eDk2eC1VNoAO1vDG+AQx42PX1L5HZKmawm/BgLkvrFtEK/6Z2lRB14KtNrUs6hwUsPQtQLpTXivrVENTpprdzx4wD6L2FcSU35FseYuzXWa+t0if+kLDEWm7vJM3RlKbgOcJbPWT6TQ1y3dueTgv8HzU3hOQOWtKghyK50Dwg1ZaxEH8YuYTQz7WB0uWwOHpljATlRQeXVeFhOQ6gV518HuhFnKsqyIvkcdLstpmKD8q7eo7cuwmOO9GDGGX8wcCHWmYtPYHKW+GZOPIxNyu2hpX7XMzdJ0ha5f4TU2jPawL/hkPpvvlrbEKcLfj28opT1WXu3OYrk4QYD81ZRNzt4zXYVnQ/2mqJ8NrLNFO5vW7tq9wEN3eHD2+2eLKZo7f7rzpRxpitv3Ys1y8kuCVPvmg06eZY/7W/Ts9vLR8lrvAdxqpG78GPJwH3jeORerpXIez1rZA7pCV28s3fKgsXl1tnAskpi8w+QZ4NaL9O/F9AIxmvdwzsBV3cO7Tnv+qs51z4UpR7L0jNNKXjm1K3qcPr/K42BcOXQcXFwH9D1wUX1bTHiQHh05dVwJD4zhQTKXNwzg6CXzSakl7gQH/aMGdZDftfuO8jJc68Gzm6PW6yrlbA6dz+IxGVrqEoZgQ9n+7juoahy4zo8M7Enj0o+nqv7DsKW9PjVHjyPZSQTiwWJzyHgs+cdjNwUrcpKA/ExP/1N9m6jrWrCxs1FT+/TVr2E5N27fuX2mNL+cosn9m8LCXqLyAQ5euh5bOLoDU5lQ6juFESX3ZI15Nql5h97SeHXnp3MD2+FjC+/dOp+49b7u3EP4elQpLI0n9V+XiKEF28VNHWfofojYsXUM9elrp2HliEQU/ZGBhQ5JcKkdjjs03zpt+9ZYmrdEQzM22AjAfk73bw6pSAnv+phaesvrrGeK4aDP29ZQDWkDrruZYnkGwHefQqP3rHM4eBp5/FTxeqeep/ar5FciP6O1n5oaX6pyDK+GxNMGxcWfyYWBn8/1tasm9Avr9Sv9/G8MpzuuxNhhsEEmVVVfHHZUtf6PtCuVuPYhfB02CFV1QA8Pj2K66f7g67gGY6cFj+pKlOaHnfSDMS3qWcPTenu2Hbeabq51ZKgd/EaK3CcQ99+SpKnuC/zq9g99gD5C+wdNnuc1+t6iyp2J+hyl8WNi9C11VmsN12KsfiyZdxTLGO/JIF0lkI/p7LMxeWmZ1LOWu3R/498CDACoBOJw5WW+ZwAAAABJRU5ErkJggg=="),
@@ -19,32 +19,40 @@
     REFRESH("iVBORw0KGgoAAAANSUhEUgAAABMAAAAUCAYAAABvVQZ0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2NJREFUeNqMVF1Ik1EYPm7TpsIca84pGs6VrboYaeRPpFgXKUzBH4S8sLoIMVCpRERCAgfSZXpR2ZVJCEIgaIQm+MdCIkXRTTTnQG0qorCFm21zp+f9+IQ5NHvh4eP7vnOe877Ped5Xyv4dEYAMSK2rq/tkt9tlXq83Cu9BwC8+zyQ4B5wHLgAG4M7IyAgfHR31FhcXv8F7EXAZUADSo43SMCLKQimS0GKDTqfLys7OvlldXZ2Vnp4uy8nJuZGWlmacnp52ejyeANZ4AB/AQ4kigSQgT6/XPzebzd8pk4WFBb6+vs6xkVP4/X6+s7PDx8bGPJWVlWasTxGTOJZRInC3oaHh88zMjLDh4OCA+3w+4RkIBPhRHB4e8u3tbd7f38+rqqpM2CcJ1YhKu4Vsvq2urnKIzN1uN3c4HHxqaso1Pj7+Y3d3VyAicqfTyaHhenNzc1Eo0VF5F2traz+srKwIRFtbW3xoaMjW1tZ2X9Q12WazcZfLxefn53lXV9fbiooKjZjIsVAkJSXdIw1IFyqvt7d3pLy8PCFksXJgYIAPDg5aGxsbs8OzCY2E+vr692tra4LIFovld15eXmrYqbKmpiZzuNAnRXJ3d7eVStjc3OQo7ZXos7OC5ImjZAA1EE0nSbRarUYulzNoxeCfb/gW+A+yGEAvuoC8ZieyoFKpVEulUgYPMVy3Qyzn8IwuiYWNXl5FQB4/9r0gIf+gxG34iEVFRbH8/HwSOPakmwovMTMz81JZWZm+oKDAkJiYGENk3o2NjSVYgsXFxbHc3NxCMXX5KYRkFRU2XzEajQZUxSQSCdvb2/tJZAfLy8uDyI4pFApmMpkKNRpNJr7rxEaWiaS0NhrQAuk1NTVPoDWDiRmS2RweHrYK9aO0FPjMvb+/z3EC7+vr+6VWqx/j321xauhEsa8DJjR9NxIQDI6xxFtbW58emx4tLS0PFhcXhT4kwomJCS/67qNKparH/4fAo4yMDHNHR8c8EdDB1J8w+NRJVors7Ox8t7S0JCwkIH1utVr57Owsn5ub49RudBAdSC2HG7SVlJRoT7ssaXt7e+3k5KSLiIiQJgRFMBgUmpzIqE97enq+lJaWhrbciYwRKE+NW32GIVgcHx9/TSaTMfAxkLsx2ywge40J8zV8bP8VYACAQuluULZPjQAAAABJRU5ErkJggg=="),
     CLOSE("iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAg9JREFUeNp8kk1rWkEUhodc5aJUEbVqJQRcqCUgERottIKYQhdZSEh1pcWFSFd2HdzFhfobpOJCFLEbddONEUUQEUSDxi4KtWIq+LGQanOLFqdnJAO3peTAe+98PXPmvDMMQkgE0ikUilcajca2WCx+Q58DbUAYJARpQccmk+l8Op1CE/0inycqlcqdTCZvi8XincViCcHYEUgKYkH7oNfhcLhRKpWw1+v9AH0zMhgMh6lU6utkMsGQDddqNQo/Az0lUCQSaQyHQ7xcLnGn08GBQOCSsdlsKtB7nU7HSqVSJJfLhWaz+UWv15uPx2M2Go1eeDye51qtFgkEAgQwgvEv5Kh7wWDwZb1e/wGBt9stJv9Wq8Wl0+mb0WiEN5vNTiRrIpHI3deN/guv12vMcdyDEA3W5XKdtdvtnwTix3w+x/F4/BOsUZAkfEhI3ctms9ckEz+gJmy32/lu7/0FgRENWhM/VqsV320Ko8egE2o5rYkcj2QiEDWMwFar9QLWHxLwIBaLlfkQaWcymVwoFLL/63alUrlzOBxvGTDkyOl0Xur1+t09QRYEL+Sjz+fzQIZvYrG4qlar3TKZjBWJRLvSYPNHTL/fvzUajTOlUnlKLrdareb8fr+XvtVms/mdwDDvhqxst9v9nM/nzxgyWS6XW7DreDAYDOE+391DNHawRCK5ms1mmkKh8AY0/SPAAEsFgVbY4GziAAAAAElFTkSuQmCC"),
 
-    INTERSTITIAL_CLOSE_BUTTON_NORMAL("iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAAKfGlDQ1BJQ0MgUHJvZmlsZQAAeAHVlndUU8kex+fe9AaBQOgQeu8dpNdQBKmCqIQkhBpCqGJDRFzBtSAiAuqKrogouBbaWhBRLCwCCnY3yCKgrIsFUVF5N/BgPee9/e/98+ac+c3n/uY3v5k75ZwvAOROlkCQAlMBSOVnCkN83BnLo6IZuMeAAFQBFcgDOoudIXALDg4A/1g+DAJI3HnXWJzrH8P+e4cUh5vBBgAKRrrjOBnsVITPIfyNLRBmAgCLuTcnU4AwqhBhGSGyQIQrxMyb55Nijpvn9rmYsBAPJOYeAHgyiyXkAUASIX5GNpuH5CEjCMz4nEQ+wmYIO7MTWByEBQgbpaamibkaYb247/LwvmMWK24xJ4vFW+T5f0FGIhN7JmYIUlhr5j7+lyY1JQvZr7kijVgyP2VpANLSkTrGYXn6L7AgZe7M5vxcfnjogp8ftzRogeOF3iELLMh0/46Dwxb8eQkeSxeYm+G1mCeJ5Sc+s7n8wqyQ8AXOyA71WuC8hLDIBeZwPRf98YnezAV/YiZzca7kNP/FNYAwkACyAB9wABcIQRxIAykAOb1Mbi5iAfBIE6wRJvISMhluyK3jGjGYfLaJEcPCzNxc3P1/U8TvbX6x7+hz7wii3/rbl94OgH0x8ibEV/3fcSxNAFpfAED78LdP8y1yFXYBcLGXnSXMns+HFjcYQASSQAYoIO9ZE+gBY2ABbIAjcAVewA8EIbscBVYBNrLXqcgu54B1YBMoAiVgF9gLKsEhcAQcB6fAGdAMLoAr4Dq4DXrBAHgMRGAEvAKT4AOYgSAIB1EgGqQAqUHakCFkAdlBzpAXFACFQFFQLMSD+FAWtA7aDJVApVAldBiqg36BWqEr0E2oD3oIDUHj0FvoM4yCybAMrALrwKawHewG+8Nh8EqYB6fDeXAhvAOugGvgk3ATfAW+DQ/AIvgVPIUCKBKKjlJHGaPsUB6oIFQ0Kh4lRG1AFaPKUTWoBlQbqgt1FyVCTaA+obFoGpqBNkY7on3R4Wg2Oh29Ab0dXYk+jm5Cd6LvoofQk+hvGApGGWOIccAwMcsxPEwOpghTjjmGOY+5hhnAjGA+YLFYOlYXa4v1xUZhk7BrsduxB7CN2HZsH3YYO4XD4RRwhjgnXBCOhcvEFeH2407iLuP6cSO4j3gSXg1vgffGR+P5+AJ8Of4E/hK+Hz+KnyFQCdoEB0IQgUNYQ9hJOEpoI9whjBBmiFJEXaITMYyYRNxErCA2EK8RnxDfkUgkDZI9aRkpkZRPqiCdJt0gDZE+kaXJBmQPcgw5i7yDXEtuJz8kv6NQKDoUV0o0JZOyg1JHuUp5RvkoQZMwkWBKcCQ2SlRJNEn0S7yWJEhqS7pJrpLMkyyXPCt5R3KCSqDqUD2oLOoGahW1lXqfOiVFkzKXCpJKldoudULqptSYNE5aR9pLmiNdKH1E+qr0MA1F06R50Ni0zbSjtGu0ERmsjK4MUyZJpkTmlEyPzKSstKyVbIRsrmyV7EVZER1F16Ez6Sn0nfQz9EH6ZzkVOTc5rtw2uQa5frlpeSV5V3mufLF8o/yA/GcFhoKXQrLCboVmhaeKaEUDxWWKOYoHFa8pTijJKDkqsZWKlc4oPVKGlQ2UQ5TXKh9R7laeUlFV8VERqOxXuaoyoUpXdVVNUi1TvaQ6rkZTc1ZLVCtTu6z2kiHLcGOkMCoYnYxJdWV1X/Us9cPqPeozGroa4RoFGo0aTzWJmnaa8Zplmh2ak1pqWoFa67TqtR5pE7TttBO092l3aU/r6OpE6mzVadYZ05XXZerm6dbrPtGj6LnopevV6N3Tx+rb6SfrH9DvNYANrA0SDKoM7hjChjaGiYYHDPuMMEb2RnyjGqP7xmRjN+Ns43rjIRO6SYBJgUmzyWtTLdNo092mXabfzKzNUsyOmj02lzb3My8wbzN/a2FgwbaosrhnSbH0ttxo2WL5xsrQimt10OqBNc060HqrdYf1VxtbG6FNg824rZZtrG217X07Gbtgu+12N+wx9u72G+0v2H9ysHHIdDjj8JejsWOy4wnHsSW6S7hLji4ZdtJwYjkddhI5M5xjnX9yFrmou7Bcalyeu2q6clyPuY666bsluZ10e+1u5i50P+8+7eHgsd6j3RPl6eNZ7NnjJe0V7lXp9cxbw5vnXe896WPts9an3Rfj6++72/c+U4XJZtYxJ/1s/db7dfqT/UP9K/2fBxgECAPaAuFAv8A9gU+Wai/lL20OAkHMoD1BT4N1g9ODf12GXRa8rGrZixDzkHUhXaG00NWhJ0I/hLmH7Qx7HK4XnhXeESEZERNRFzEd6RlZGilabrp8/fLbUYpRiVEt0bjoiOhj0VMrvFbsXTESYx1TFDO4Undl7sqbqxRXpay6uFpyNWv12VhMbGTsidgvrCBWDWsqjhlXHTfJ9mDvY7/iuHLKOONcJ24pdzTeKb40foznxNvDG09wSShPmEj0SKxMfJPkm3QoaTo5KLk2eTYlMqUxFZ8am9rKl+Yn8zvTVNNy0/oEhoIigSjdIX1v+qTQX3gsA8pYmdGSKYMIm+4svawtWUPZztlV2R9zInLO5krl8nO71xis2bZmNM877+e16LXstR3r1NdtWje03m394Q3QhrgNHRs1NxZuHMn3yT++ibgpedNvBWYFpQXvN0dubitUKcwvHN7is6W+SKJIWHR/q+PWQz+gf0j8oWeb5bb9274Vc4pvlZiVlJd82c7efutH8x8rfpzdEb+jZ6fNzoO7sLv4uwZ3u+w+XipVmlc6vCdwT1MZo6y47P3e1XtvlluVH9pH3Je1T1QRUNGyX2v/rv1fKhMqB6rcqxqrlau3VU8f4BzoP+h6sOGQyqGSQ59/SvzpwWGfw001OjXlR7BHso+8OBpxtOtnu5/rjikeKzn2tZZfKzoecryzzrau7oTyiZ31cH1W/fjJmJO9pzxPtTQYNxxupDeWnAans06//CX2l8Ez/mc6ztqdbTinfa76PO18cRPUtKZpsjmhWdQS1dLX6tfa0ebYdv5Xk19rL6hfqLooe3HnJeKlwkuzl/MuT7UL2ieu8K4Md6zueHx1+dV7ncs6e675X7tx3fv61S63rss3nG5cuOlws/WW3a3m2za3m7qtu8//Zv3b+R6bnqY7tndaeu172/qW9F3qd+m/ctfz7vV7zHu3B5YO9A2GDz64H3Nf9IDzYOxhysM3j7IfzTzOf4J5UvyU+rT8mfKzmt/1f28U2YguDnkOdT8Pff54mD386o+MP76MFL6gvCgfVRutG7MYuzDuPd77csXLkVeCVzMTRX9K/Vn9Wu/1ub9c/+qeXD458kb4Zvbt9ncK72rfW73vmAqeevYh9cPMdPFHhY/HP9l96voc+Xl0JucL7kvFV/2vbd/8vz2ZTZ2dFbCErDktgEIsHB8PwNtaAChRiHboBYAoMa+H5yKgeQ2PsFjLz+n5/+R5zTwXbwNArSsA4fkABLQDcBCp2giTkVYsC8NcAWxpuVgRj7hkxFtazAFEFiLS5OPs7DsVAHBtAHwVzs7OHJid/XoU0e0PAWhPn9fh4mgsFYBSXVktWe6trar5c+O/M/8CArPqa05dv3oAAAAJcEhZcwAACxMAAAsTAQCanBgAAAekSURBVFgJpZhJiJRXEMff9Kgz4zaijg4q7orgQclBFL0k5KIGFI0bJIyec/CkEA+jhoSIBw+iiBCUUXDFfUHBgAaiePOgYQZBXHBfcJvM2l/n/6vuenzdduNIHrx+e9X/VdWrqq+rcrlcqFSqVLRepfXE9+zfv3/ymjVrJiRJUtvZ2TmopqambsCAAf1Y7+7u7lXp1LF/Nd919uzZJytWrPjHz6rNbN26NWzZskVkKzBmvkI1MIVz1ZcvX2569uzZHy9fvmzVXJ/K8+fPnz58+PDQhQsXfhKYeh2qxCvOx07J5oyPDxw48M39+/f/bm9vT4PI9vT09EpC2XKVNW2mWuno6Mi1trW27tmz59eFCxfW7Nixo+7YsWPVSEzSyqjl8obFOppIFzaYim7cuNE8c+bMn4cOHVqrOYj3vnjxolq3rjp37ly4e/duEDNUZeelulBXVxdmzJgRFi1aFMaPH58bPXp0VovQrO7q6gr37t1rv3Xr1g9S++mrV6/WXrt2rXvz5s3YTd52HFmhjZJ58uTJXhAUSo9AZA8ePJjMnj0bsH2qs2bNSjgjCSei06Oahd6jR4/+Wr58+Up1uWXkyTitsrjw7t27Fi1SMNJeGWcyf/78CKKxsTEZMWJEMnLkyLKVNUkm7p8zZ05y+vTpRKoEWBeEb9++/UEX+0rdgPpoqQ4o6jAlGbOR3bt3R8ITJkxIBg0alOgVxbly0mKdyt6JEyfGvTt37kxkcxFUW1vbnzpfAxBsyQBpAjAG6Pr1683qUwzM9u3bjdioUaNMEtxcdhIZlAOTnuvfv7+da2hoSKDB2rZt2xLZnaswJzv9TfwQDO6lio4h4zVJVR0am5527dplBCZNmpRAGKIQ5OYDBw78LCgZd1JdXW37OMtFXFpISuozexLP9kOHDs0TW8NiKhOjap42YFR60DfMx4wZY2CGDBliYzm5CMTn2FdaBw8eHOdWrVplffZzMZcUPOAFwwcPHlxRk8dCB6dX8DOJFrNz5841Ihx2yaxfvz7Rk08wcADIFVgtBwbVMn/ixInk9evXyYYNGz6hh6HDC0Dv37/PXblyZRVYDBUemAWVrpaWFjs8ZcoUe0kQ5pavXr3iRlZPnjxpe7g1wBwUkhk+fLiNjx49GvdLLUlTU5PNc0FXHbzgCeMChhD27ds3WeGgjcmnT59mp0+fbgdhhIgzmYyNz58/Hxloq90eIMOGDUsAxovCDTB35MiRor3SgM2zVltbG21w2rRpyTPxhLcw3JXPmoqn/ZoJlezNmzftoDxsNMi0ARf0Hpm5pPA5Y8eOtbNpyYhmcvHixQjGbYuH4X4KntpnYUYu4dsg21kIGuLPpk2b7DDEOeSqSKvm1KlTERAMGfs+ObiiNQVVW+OF1dfXx33sdzuDZyH25d68efNdkNF9DyCC5LJly+zQuHHjig5DABUCjH6ppI4fP54cPny4CIxLpl+/fqZWB+2tPxZ4whsMwrIyfPz48UcHtHjx4oqAHBQ2Q//MmTNFAEQjjh2McqKyYDjvgODpgPTamjISpyVX2hQkOpogdVlb+qMDIZvNBuk/LFmyJMiGbIvAuD8LZAFEer22IAMOb9++LSVTNFaojGPtz5AWfFFRphikBjvjaQcDQFF8ThcN7P3SkiHt9EN65tZ14j7vrV6J5TuPHz8mQofVq1fbEhKVe7C+0oogQw/yK0GhI8j2/HjZ1i/HIlgySpo6fKd07t1PWhl04NZykEFPOyiMxD2oCRBeli5daupEXVyuLKi8QEOap2Hpy7PHf/gzLXV6/rQF5hNDJ3Qwz0PgldL36vTSzx4sFR2je2iithMpdXoOBuIkbewrdQnuPFnDm9Pi4xpH5/cXHKM9e5z0p6FjWj50cJjQgR+BCLeV+GMllDCPJ8fp4aPcJZQ6Tw/I7McVuPcndBCuRJfQ0UoYKwquehXdyouMEdmhi5XgStR2QC4ZPLCDgFkl5/nhw4dk7dq1RpcMIh1c4QmgGFzVL0o/SOYXLFhgh3Fe7sA2btyYELUvXbpkawTJNBgAOSgPE0gRMM3NzRGM00ulHwmpDykQWNx/FCVoejUREFLwoOgpBIydqQNJt2kDdslAA1rlEjSSQ523RB9AZVNY0kyYIF4I+c2Yc4BpEKV9N2DmAQENVxW0+ZoR7xxpM+kz0gGL9ldO8knInaCrD6Nkri/VJNKQzzpdMtAsxC4DVPiwAExM8m1QQIiH3as+xb48XFIA4Ia8kHRqUgkYe9jrUmEftNJgCp9c8I8YfEBrqmNRQbRFLQXJ9uJbMEJnTnLFC/QPxYaRMn5VH7PmCRhn/EMRWtCEsFQFD+cfefuEt3Eh9cHI+R4ScnLgqVOnRmAOsFLLXs4Uknn7woBYiWQiTy3l/3UQwXTBsGAayv3ZoL9Y7M8G5UOhtbU18AeCLm7nCZTEJv5sID3xPxukPtKDKkm+886dO7/PmzfvFzuQ/xPCeBXG8VPaJeRtRP0//o4xD4xE8DM87dRrgk/kgWS8xo5PpFo+r6mAT/9hZV8omv9s4WsGD4zTg4YOwC/SLYyLMDjDKLF0R6K2w5qLYv3cX3qkEPLi7QrOncqzH6xbt+5eimYmTzJ/y9R87P4HkQsq2faR5dQAAAAASUVORK5CYII="),
-    INTERSTITIAL_CLOSE_BUTTON_PRESSED("iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAAKfGlDQ1BJQ0MgUHJvZmlsZQAAeAHVlndUU8kex+fe9AaBQOgQeu8dpNdQBKmCqIQkhBpCqGJDRFzBtSAiAuqKrogouBbaWhBRLCwCCnY3yCKgrIsFUVF5N/BgPee9/e/98+ac+c3n/uY3v5k75ZwvAOROlkCQAlMBSOVnCkN83BnLo6IZuMeAAFQBFcgDOoudIXALDg4A/1g+DAJI3HnXWJzrH8P+e4cUh5vBBgAKRrrjOBnsVITPIfyNLRBmAgCLuTcnU4AwqhBhGSGyQIQrxMyb55Nijpvn9rmYsBAPJOYeAHgyiyXkAUASIX5GNpuH5CEjCMz4nEQ+wmYIO7MTWByEBQgbpaamibkaYb247/LwvmMWK24xJ4vFW+T5f0FGIhN7JmYIUlhr5j7+lyY1JQvZr7kijVgyP2VpANLSkTrGYXn6L7AgZe7M5vxcfnjogp8ftzRogeOF3iELLMh0/46Dwxb8eQkeSxeYm+G1mCeJ5Sc+s7n8wqyQ8AXOyA71WuC8hLDIBeZwPRf98YnezAV/YiZzca7kNP/FNYAwkACyAB9wABcIQRxIAykAOb1Mbi5iAfBIE6wRJvISMhluyK3jGjGYfLaJEcPCzNxc3P1/U8TvbX6x7+hz7wii3/rbl94OgH0x8ibEV/3fcSxNAFpfAED78LdP8y1yFXYBcLGXnSXMns+HFjcYQASSQAYoIO9ZE+gBY2ABbIAjcAVewA8EIbscBVYBNrLXqcgu54B1YBMoAiVgF9gLKsEhcAQcB6fAGdAMLoAr4Dq4DXrBAHgMRGAEvAKT4AOYgSAIB1EgGqQAqUHakCFkAdlBzpAXFACFQFFQLMSD+FAWtA7aDJVApVAldBiqg36BWqEr0E2oD3oIDUHj0FvoM4yCybAMrALrwKawHewG+8Nh8EqYB6fDeXAhvAOugGvgk3ATfAW+DQ/AIvgVPIUCKBKKjlJHGaPsUB6oIFQ0Kh4lRG1AFaPKUTWoBlQbqgt1FyVCTaA+obFoGpqBNkY7on3R4Wg2Oh29Ab0dXYk+jm5Cd6LvoofQk+hvGApGGWOIccAwMcsxPEwOpghTjjmGOY+5hhnAjGA+YLFYOlYXa4v1xUZhk7BrsduxB7CN2HZsH3YYO4XD4RRwhjgnXBCOhcvEFeH2407iLuP6cSO4j3gSXg1vgffGR+P5+AJ8Of4E/hK+Hz+KnyFQCdoEB0IQgUNYQ9hJOEpoI9whjBBmiFJEXaITMYyYRNxErCA2EK8RnxDfkUgkDZI9aRkpkZRPqiCdJt0gDZE+kaXJBmQPcgw5i7yDXEtuJz8kv6NQKDoUV0o0JZOyg1JHuUp5RvkoQZMwkWBKcCQ2SlRJNEn0S7yWJEhqS7pJrpLMkyyXPCt5R3KCSqDqUD2oLOoGahW1lXqfOiVFkzKXCpJKldoudULqptSYNE5aR9pLmiNdKH1E+qr0MA1F06R50Ni0zbSjtGu0ERmsjK4MUyZJpkTmlEyPzKSstKyVbIRsrmyV7EVZER1F16Ez6Sn0nfQz9EH6ZzkVOTc5rtw2uQa5frlpeSV5V3mufLF8o/yA/GcFhoKXQrLCboVmhaeKaEUDxWWKOYoHFa8pTijJKDkqsZWKlc4oPVKGlQ2UQ5TXKh9R7laeUlFV8VERqOxXuaoyoUpXdVVNUi1TvaQ6rkZTc1ZLVCtTu6z2kiHLcGOkMCoYnYxJdWV1X/Us9cPqPeozGroa4RoFGo0aTzWJmnaa8Zplmh2ak1pqWoFa67TqtR5pE7TttBO092l3aU/r6OpE6mzVadYZ05XXZerm6dbrPtGj6LnopevV6N3Tx+rb6SfrH9DvNYANrA0SDKoM7hjChjaGiYYHDPuMMEb2RnyjGqP7xmRjN+Ns43rjIRO6SYBJgUmzyWtTLdNo092mXabfzKzNUsyOmj02lzb3My8wbzN/a2FgwbaosrhnSbH0ttxo2WL5xsrQimt10OqBNc060HqrdYf1VxtbG6FNg824rZZtrG217X07Gbtgu+12N+wx9u72G+0v2H9ysHHIdDjj8JejsWOy4wnHsSW6S7hLji4ZdtJwYjkddhI5M5xjnX9yFrmou7Bcalyeu2q6clyPuY666bsluZ10e+1u5i50P+8+7eHgsd6j3RPl6eNZ7NnjJe0V7lXp9cxbw5vnXe896WPts9an3Rfj6++72/c+U4XJZtYxJ/1s/db7dfqT/UP9K/2fBxgECAPaAuFAv8A9gU+Wai/lL20OAkHMoD1BT4N1g9ODf12GXRa8rGrZixDzkHUhXaG00NWhJ0I/hLmH7Qx7HK4XnhXeESEZERNRFzEd6RlZGilabrp8/fLbUYpRiVEt0bjoiOhj0VMrvFbsXTESYx1TFDO4Undl7sqbqxRXpay6uFpyNWv12VhMbGTsidgvrCBWDWsqjhlXHTfJ9mDvY7/iuHLKOONcJ24pdzTeKb40foznxNvDG09wSShPmEj0SKxMfJPkm3QoaTo5KLk2eTYlMqUxFZ8am9rKl+Yn8zvTVNNy0/oEhoIigSjdIX1v+qTQX3gsA8pYmdGSKYMIm+4svawtWUPZztlV2R9zInLO5krl8nO71xis2bZmNM877+e16LXstR3r1NdtWje03m394Q3QhrgNHRs1NxZuHMn3yT++ibgpedNvBWYFpQXvN0dubitUKcwvHN7is6W+SKJIWHR/q+PWQz+gf0j8oWeb5bb9274Vc4pvlZiVlJd82c7efutH8x8rfpzdEb+jZ6fNzoO7sLv4uwZ3u+w+XipVmlc6vCdwT1MZo6y47P3e1XtvlluVH9pH3Je1T1QRUNGyX2v/rv1fKhMqB6rcqxqrlau3VU8f4BzoP+h6sOGQyqGSQ59/SvzpwWGfw001OjXlR7BHso+8OBpxtOtnu5/rjikeKzn2tZZfKzoecryzzrau7oTyiZ31cH1W/fjJmJO9pzxPtTQYNxxupDeWnAans06//CX2l8Ez/mc6ztqdbTinfa76PO18cRPUtKZpsjmhWdQS1dLX6tfa0ebYdv5Xk19rL6hfqLooe3HnJeKlwkuzl/MuT7UL2ieu8K4Md6zueHx1+dV7ncs6e675X7tx3fv61S63rss3nG5cuOlws/WW3a3m2za3m7qtu8//Zv3b+R6bnqY7tndaeu172/qW9F3qd+m/ctfz7vV7zHu3B5YO9A2GDz64H3Nf9IDzYOxhysM3j7IfzTzOf4J5UvyU+rT8mfKzmt/1f28U2YguDnkOdT8Pff54mD386o+MP76MFL6gvCgfVRutG7MYuzDuPd77csXLkVeCVzMTRX9K/Vn9Wu/1ub9c/+qeXD458kb4Zvbt9ncK72rfW73vmAqeevYh9cPMdPFHhY/HP9l96voc+Xl0JucL7kvFV/2vbd/8vz2ZTZ2dFbCErDktgEIsHB8PwNtaAChRiHboBYAoMa+H5yKgeQ2PsFjLz+n5/+R5zTwXbwNArSsA4fkABLQDcBCp2giTkVYsC8NcAWxpuVgRj7hkxFtazAFEFiLS5OPs7DsVAHBtAHwVzs7OHJid/XoU0e0PAWhPn9fh4mgsFYBSXVktWe6trar5c+O/M/8CArPqa05dv3oAAAAJcEhZcwAACxMAAAsTAQCanBgAAAkNSURBVFgJjZhbaFXZGcfX3vtEExMVL9E0NdZEvEQTH+oVGi+1oDNlsMVrKaVgH2zL0NJKUaiJxtTrQ7UwfajzUCkMXqEIRapTUh3RkMZL6ZjEeJkIE6OiTjQm5nrO2f3/1jnrGOJJMgv22Xuv9V3+3//71mUfLwxDM0Lz9u7d6+3Zsyfu5PReFI/Hv6UrS/rZvu9na8w3gekLo2Gn+ruDIGjr7OysP3LkSDd6mzdvDs6cOYONYR16wwGSY98B2blzZ/7o0aN/Imdz5Gy5nmd5nmfS6Qug6e7u7pXsvzT+n1gsduLgwYPNAJPNSGVlZUz9aYGlBSRHnpQsK9u3b8/Kycn5ULZ+mZmZWZSRkWF6e3u55C+OUQ9HrgFSVxiJRALJG4ExPT09rQriRwruqpMbGKzr454OEA4s+t27d5fK+McyvkwGARF98+ZN+OrVK//+/fv+ixcvTH9/v4lGo9am5MyoUaPMpEmTzOzZs8Px48fHs7OzjdiM9PX1GQXwWVZW1i6N123btq0/HajBgFJgFM0WefmzjE2W07hAxB8+fBjU1dWZJ0+eWAAj/UydmmeWLVtqCgsLYxMmTIhgPDsnx3R1df6xvHz379AfDCoFSExY6sltVVXVh4r6qKLNECv9Dx48CGqu1XhftnxpMQgk0aatHyugH8zBHi0/P98sX748FGtx1ZdtcqOY91Qxjm/88hyoVrjT6V+6dCkU4s3K+8eqFcBEb926FTl37pzX/rrdiG4LhBQBaKSLNKPT1tZmGhoaPD37eXl5IYik+90rV648WbVq1U18624BWYYcbbt27SqRkX+LmVwVYrS2tjaorq42FLJrgEkG47qGvMuRoa5o6KC7evVqpXFZXAUfiMEOAXtv3759NQ4DgGzdqGOUBqslWNbV1dV/48aNyIULFwxFqXdr2KVAAVp2hkSigYEyBMRsI9VaDszatWvN4sWLY1mZmZGe3t7bHR0dK44ePfpKap4vILZ2pLBN7JRpNsQ1gwLAMG0BQ6SAmTt3rsVAqkjHUI0xZGjouEBUAjawixcvmnv37gViLKZslI4bN84VuBdQN1r0xoraYwKQq6kcExhfqG2UREp0isisWbPGFBQUUA8WJGOD0+eA0r9x40azdOlSC66lpcWCITjAvnz50sycOTOuNc4X4ILz58///cCBA+0+UQjIT0XrPNEZY2q3trYaobaKjpmVK1favuLiYrNp0yY7NpgpB4YANmzYYObNm2fGjh1rVqxYYUpKSlJMUeiPHz82zc3NARNH74Vjxoz5MVgsIBleQnq098Rramps9OQaw7Smpibz6NGjFIj58+dbULDABRAuokdn/fr1BhlaqMWcAO/cuWPfGe/r7bPPV69eNSy0yUlTQmcgIzz8QYLZz549865du+aJRrs94Mylpb6+3kyZMsVMnTLVGuM5NzfXpo+ZBCDYBAxsoMfVdLfJnDhxIgUcVrHLii4CYBF/TK4JWgb+6auwpomdKSrmmJiwBY5HlGguLRjXbm0aGlU/yX5Y0C5ugVCwpAkwNNiClZMnT9p3QDvG6XD28YlvzcACYcn3NTApOeixN6VrGMLBW1CNJhBAGnVC8bo0IQNbpPnUqVNWBjCsQekaPgmapnsWVr8JIC43Pe3ooJ90oACJMVhZsGCB1aAPMAOZGQoMCkmfNjPSHeML/fgkQ0NG4bA5UBQh6bt9+7aYCmwqGIOZxsZGC4bn4ZgZaNM9y24GDCX4cr1f4w4LNECI25QGgdFHI3Uu0JTACA9i24tIqc05IKLhGlEjy9mGAqaoSZnTA4ybYTDo6smBTGcbmwNajy/hxzjhSq4HA8bfPjpF6sGBcQ5JE8uCk6HQh1o831pMPCV9hviX7a6IHr5KAgonT57s3b17d7BOyhGRutmEEHoU8OnTp60O7/MFJibW3MJ49uxZmzrApmNKPmHSY0wyXb7m/0MdNb7QQhVoI0ycSWQY4zRYQJjLrTOOGbfO4IxIE+vU2yUBUI4p9NFzzdmXz7gwsJ99rnuzX15e/oWEq9lfdAaOgZgVFGWUqBEaa42Lmn7A2HVGuJ0cOg4UOuiis2ULp+HEO7IEQB1OnDgRn5yNCLhW57EWC1kCdYDQ2SdSVlamOk8s7a5YOUIUFhba4sVpCoycRILEoieDFpgDRV3xzIVuaWmpBQWTbBs0+cKnrwwBsp4+C0isfKJo/qcd15sxY0Z8+vTp9iBFNBigTpIbIeeYIVfgwaDQ4zyl/dGuWckCtrbzv5FvioqKYspMILaadH0CIDZXf8eOHdHLly+HAvWBBDj7hpo1GkqkjDvnmdevXxudn2yRDrXowS6scGfmtbe3m+vXr6f6cEoq3//++5ytKFQK+qP9+/df5BibOsJu3bo1c9q0aZ8pn0s4o+hzJ+BkR22xcZJ3t7XwDBvDNUDhmAYzyKtoU0fYJTrCjtYRVszUy37ZoUOH2iXqkTK+NPzjx4/3SGkHYOQwsnDhwvhqHcg5F2GchmGeRwKDLGBglnrhjh62sIntSEZGRL56tfb8GjBgkFpovzqkYOc41ayBKhmpEPK4rvDmzZs+TNFgS31fCxDyMAkggNA43C9atCimwNyW8Ft9m/1JQxYC/i0gK61O3e06JFB/kdLPWZV1RVXIvg5PnvtixYl0k2rpb8QIeJr7UJw1axaH+gwYFoMV+iDdl9RO+U7kItFrU8ejUP9CbP5eWN6opiI6R/taS2Lr1q0LWTtwRD0NdyGDrHQ4xMVkw9MszpDOVwrmZw6MS1US2Lt/NiAgQLYatVB9W7TvV7TvkS6o13rVr5kTaIvxnj9/bkG5miJF1BmL65w5c4y+56MC4eviMA8rVxTkrzSjPk8CSDEzJCAnKGD27xiSW1lZ+QMZ+43GvqOviAjA5IBp5mrP3iXqth7+jvEVBMdTGG3Q2EdPnz7967Fjx+y/HrJJybyT94E15ECm7sl/vVLzu6KiYqNsfE9M/FDO8hStrSVmFE1O7WyCKVZfMfcPza5PBf5vhw8f7kBmYAZ4H9yGBZQU9hxbTlnf4sVyOFtAisXEEgHhZM+neKtA1KpO/qsviWb13VD6bWUngcDIO6w4u9z/D0aZ6sEzTu2gAAAAAElFTkSuQmCC"),
+    INTERSTITIAL_CLOSE_BUTTON_NORMAL("iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAMAAADVRocKAAAAUVBMVEUAAAD///////////////////////////////////////////////8AAAAQEBAgICAwMDBAQEBQUFBgYGBwcHCAgICfn5+/v7/Pz8/v7+////9QtCtmAAAADXRSTlMAECBQYHCAj5+/z9/v87rZqQAAAfxJREFUeAHslc2SgyAQhHeJ8UcZVBIJ+P4PuoWZA26t7ehySZV9DKn+GLoz+bp06dKlD5IqqqabWV1TFiqn+61m71Rdfct090rPG9KV+r99PUPVKpu9d9PImpzPg7hrNgnOGlrJWBf4UN/PXr9lh5elP2Vf/IVWnaoOX9/1tKne8RAnClXy7UeCGnmK8qj/O93wpF09wzvrM/5+IIEGDwnA3xkSyThAAO/vSCx3LIcb8IcEYZeUBv6QoJUI0CJ/TGhF+2Hpj6GDMkuX7sIHCgMd1hAkj8QNTX5fDwQbwiP5xYm6qpb9kPijceKlE8KyNZRkgDH1Z8KGf0oYBSOoXw0K8zZh4EOzbhIeoYpf6dcmawI66uMHFQRoTgDZgIOYgt5dEhYboY8tLwwYccBXxYOFnZg7jhgQgD/H3O10yOI4cfQW96iIxwYXBlfLxIMCltQTQQLwj/Lwj6fhCCAB+HMIDcx4IkzA/jTBlHkPQQL05320A8AE5C8HYALwxwCFAUyA/hjwnQ+Q4Yk+L+QsNf1pzw4NAIBhEAi6iqruP21lTCTnYIcEePih8VfBnx1/19xwuGVy0/exhQcvHx15+OXx3RcQXKF8CfQ11hdxjxI8DPE4xwMpj9Q8FPRY04NZj5Y9HN/x/kvifT9Q+InFj0Qzc52ZuW505vKqqqr6JLIRlkedBesAAAAASUVORK5CYII="),
+    INTERSTITIAL_CLOSE_BUTTON_PRESSED("iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAMAAADVRocKAAAAY1BMVEUAAAAjHyD///93cXH///9bVlZ3cXF3cXFxbGx3cXFybGx3cXF3cXFzbW13cXF3cXF0bm53cXF3cXETEhIZGBggHh4mJCQsKioyMDA5NjY/PDxFQkJSTU1eWVlkX19xa2t3cXE1H1L7AAAAE3RSTlMACBAgIDBQYHiAiI+fp7/P19/vm4QQ3gAAAg9JREFUeAHsld1ygyAUhNumahKNjoBIIhHf/ylb8cwEO2XBn5vMuJcysx/HXY8fhw4dOvRGOmV5WQ+kurxmpz3d04K8XdVFutPdczZ4xPLtcyS3AeqWbLt98bLqddeSOt2/nhcbpjgzMjFaCT6TUNrQITuvvX5FDk/F/5V6DpOqVUOkdH3dcK8aTUOsKNSFbt9yqJamuCz1n9I1Dx7Uw0xZr/HvJY+Q7AEB+mvBoyQ0IID3r3m09LIcUugPCGlk/xn0BwQW9z1U2B8Rqqj9YPsjlgKE7dI58gUZyRdLmtlLwg11vq87gklzd764qK4mdj84/mAce2mHYLdGEgDY/0vr+hPB4+8SWvsHCiTwp0Fm8BMkHYp5k3AK+fCrZm4yI8CjZnyQQwCzCQAbcEApsOCSUMgIP1ZwYVBHDb4qHswEmlpTxIAA/CnmOtAhhePE0Svco2w8FrgwuFpiPMhgSXtUeYn8rcaVd/UCSooAEKA/hVDCjDuOCdifdzBl2kOQAP1pHwUAmAD8YwGYgP0x4JsAiED+GPDpAXztCNj+it4v5F1q+tOeHVoBAMIwEBUI3kOx/7TILsB3lx3aJBd+aPpV+GfH3zU3HG6Z3vR5bOHBy0dHHn55fPcFRFcoXwJ9jfVF3KMEDkM8zvFAyiM1DwU91vRg1qNlD8c93vcDhZ9Y+Eg0WvvMzHW/zlxeKaX0AEs5cjxqSuS5AAAAAElFTkSuQmCC"),
 
     THATCHED_BACKGROUND("iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAAAAADRE4smAAAACXBIWXMAAAsTAAALEwEAmpwYAAADGGlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjaY2BgnuDo4uTKJMDAUFBUUuQe5BgZERmlwH6egY2BmYGBgYGBITG5uMAxIMCHgYGBIS8/L5UBFTAyMHy7xsDIwMDAcFnX0cXJlYE0wJpcUFTCwMBwgIGBwSgltTiZgYHhCwMDQ3p5SUEJAwNjDAMDg0hSdkEJAwNjAQMDg0h2SJAzAwNjCwMDE09JakUJAwMDg3N+QWVRZnpGiYKhpaWlgmNKflKqQnBlcUlqbrGCZ15yflFBflFiSWoKAwMD1A4GBgYGXpf8EgX3xMw8BSMDVQYqg4jIKAUICxE+CDEESC4tKoMHJQODAIMCgwGDA0MAQyJDPcMChqMMbxjFGV0YSxlXMN5jEmMKYprAdIFZmDmSeSHzGxZLlg6WW6x6rK2s99gs2aaxfWMPZ9/NocTRxfGFM5HzApcj1xZuTe4FPFI8U3mFeCfxCfNN45fhXyygI7BD0FXwilCq0A/hXhEVkb2i4aJfxCaJG4lfkaiQlJM8JpUvLS19QqZMVl32llyfvIv8H4WtioVKekpvldeqFKiaqP5UO6jepRGqqaT5QeuA9iSdVF0rPUG9V/pHDBYY1hrFGNuayJsym740u2C+02KJ5QSrOutcmzjbQDtXe2sHY0cdJzVnJRcFV3k3BXdlD3VPXS8Tbxsfd99gvwT//ID6wIlBS4N3hVwMfRnOFCEXaRUVEV0RMzN2T9yDBLZE3aSw5IaUNak30zkyLDIzs+ZmX8xlz7PPryjYVPiuWLskq3RV2ZsK/cqSql01jLVedVPrHzbqNdU0n22VaytsP9op3VXUfbpXta+x/+5Em0mzJ/+dGj/t8AyNmf2zvs9JmHt6vvmCpYtEFrcu+bYsc/m9lSGrTq9xWbtvveWGbZtMNm/ZarJt+w6rnft3u+45uy9s/4ODOYd+Hmk/Jn58xUnrU+fOJJ/9dX7SRe1LR68kXv13fc5Nm1t379TfU75/4mHeY7En+59lvhB5efB1/lv5dxc+NH0y/fzq64Lv4T8Ffp360/rP8f9/AA0ADzT6lvFdAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAIDwSURBVHja7L1rthu7jjQYAFOu6p5Tz39I37pWkugfiUeAqds9AFO16txzbO+9JVkEgUA8rv8HNwYmAIEBWFAIFi5MAAbBwIRBYBB8sDDxPAyAAhBMCCYu3AAA9e8kMFxQ/B/8wcIHf3FhwgAA4n9O8cUAcAP+uwLFDQEw/LlM/64LwBcXBMP/hABYEEwMXFiYEAgEC4Bi+p8xLCgMmt8ZGPl86yfsjwHDAnDhxoRC8MFf/47Pe6L+Dj2Pif8b//H35cKNP1hY/qdvf0+Q78s3vy5em9AzFv8+goHlv/v87QzA/5ZuXACAv7ig/rdx4S+AP/jr391wAbgx8pk8r/WDr/+cC+fxTz+uOEnw82z+iTQA5p+4OrXPybj9E/qcf/Hzqv5nJSuE+Vcu/++ZpwD+3dXPsORXCtT/e+V3ef7LAMz8mfBnIP684d8h/n/leUN+jfqfH/46FgQKQGEY+RVR/eB1Y2Bi+PcZ/vo1n5/kqebTrFB/N+NdsNdb/5zwBcHKKhXvarwbw5/FU7MEI8/xyNO7cPlz0nyeklVd8tmZv7vLK8hTV04F+NcrQH06LW+Z6Z9v8U9jnX3F9NsE9Mme/iu3n2nkSXzubfFPqvinD3knxZmeECyo/9fC8K+3fG6SPcXzuf6LkT/fvA5J/huoc6nztLzSxOtbVItuf+bL/1v87C2vUJZVaWU9qhNf5/t5L76AV5HnNa4861E7pteheGVPdZHtOa/8Hsi/E4NgYuGGQb3zWV6t9UedkfwJz5+Kn+gfgHMGTg/weqhPAMiT/tw8dWaQXXz0pcj/7Z204oOP/17dwOL97fBP5vAqoX5/mv+a+nl9fpJ4v6vZKcRN9r5dZ57jONHq1cOofsWJ5YrWb83nO1lWjriTo28ZfudX7YlnazkNab4/6lNKvFcfDL+vBYrht/vz/8vfDWBiQv3eFnqV5n9Py7/DUwkmBLf/r/mrXtlxqXdi61SA88gPQNwS5idr5H2n2WObd8CgSR3gGYL74brLnrt+5mde/CaMsxPn+DnZM89goAlKHWudVK5O8G7asoNWRxXq+yyvGs/3W3Rvxx0uNOssmiSMsAXLd6lO0E19RK+Qz/njOcD8VUZnASzcgGMrmv3Q8l8xOuczX1/8PWmecPW/FUvM4PlbNEcXzP8N+b+Sr/tUgDMFoHXbyzvL6GlrPph0fp6vGK+bNz734jfQ8tsR1M+aIwJfGAw3Lj898Htz+a/Zj+/+IJOFPqifffVKgexwv9kLPK/jysqCPP+W57pqA17IAldC2ZCN+m/dqqHmnVy9QUxIw7+rZE0EvTtre92Lfm0mJrLye32pFj9o6sDChW++ioE7f9pqHcDpAU4F6Ge3brO67XjKDQSwPvf7tLDajd+3Bqshfs/n94+fI81TYXSzP/8eJ3b51Pt0C6PN44uqWNztkrhE4QWKO7tp8a5jUKWrSXrRmRdHJwohlfyK5RPNJCyyXmugfZYThOQcgVfHwHXFCBHR7INi/3AlmvInuyhA8XHkP+arj79CZMWYDak5FeBfrwAxQZrvz6Qh1XGL1s036R4Z2Q2Yf5aMcPyVCIJ43yBZU9RvoUmdNqP38aeU7j/J+Z97WlBHsNerp+4EJvgUPCH8oKbzZyb/+nkD1QjLnz3zFE/C7JW6Ee4BCkmsd2/4Ozgd05e2ReCuh29qc9zQ6HeAL27/iq+/J8/r+gvDX58b7kQrFs16vNsZpwIcJNDvJJ4CeHfNdz9aLzAwfBJ4uoKP/1fcqk99GDmn8glZuSuw3BOYY2TVT8zt51revpb3c9Sa5xbWxLziVlevWc+MffufmNt5je6lMPrYO6L1RWiYPr8zi/73qWzcJ4EmC2yVjjcujPPNvPm5T9NtcuH3Vv2Mj6xfyA5r5b5kJnawoKcC/PMV4Jv38MpzsIiTgpyM9/s7UHrAcPvdtrbZ9Zn0+5maPsmjba3F92Efx+3N+1zQeZu+8bp9y7Dyvr3yDlavQ9ruvY+fpst7dmmoOnKDiHzl0u7zuM01XzNP/rF9lHxlw5/V8i4E2Yf0KX85KjIdOxm00Ry046wpwQihqJ9vtDuMzUPf5/B89UxTE0hW0Xn8uxXgcoZJ8eaA934NbYfMp8aylx7+T4Phgy8uLCxcMHz8zxRPT7NOMAIWCGSg6s85vcEbr2ABauLpgXBNuqWritVOA8mcq0lA2hnpyEch/5Jo6Z34flSB5X3L9FM1G+ZRnIBFSGQhlCurat3Zi3AEtL0Hn30jxMNoWgi21ndjS8yN+ajOdzwV4F+vAM8neCQqfDkLrvPqjGrC2qbJheLRwDm2kpvqBfNJdRLeZl41lp/nYOd+vcf+OHp95UQcu+/41I/Wj9TMLXRT178/J1Ubqlgdej0L0E0d05FSvZOGfUpiFdiQfSPkAn4qlfgCgzA/aV974XZesWXvFX8rhSUWQ6O2Dk+38Sd5A4UNVAc2cjaKanIqwNkF1F22aC/H+/24fSY+fosafY7jsxsTMN/q9uooLFH86u6H36yBytXJKubdbPXH8Df5reL3/0pdgyUnB4S6S3YyxfDV7Jyfn1/bc20z/s550Paqet9QZ/vO9y2mj6eKjWTlMA/x6Wxm22j0aUFyWwD6W+oMhdm2CyAMRLKHqp98KsCpAF+fQw1fZ5N9EhMDfZqnd7XLT8lKzBzg/Xj9cyUKx732Is6vJmul+PTFax8w/HEFjiQvSHMjXretovZ1QvyXft8VPj+IaxTI3kqkEYngWdtPcD2pe96oJgYaYIlygKqg/ZjkgyMtuZmTHxsTRg0X9V6am4XQVszGHI6ZP2ak4EYIgmd4cIBTAS7fGQVrThNjU6ApZp5J/4+fqNvxtb95Bkf2n9Y+tdpUcJo6gdpMo/UIpSKYzo8zn7R5oxVnq25W9c//aLh7cX1DjxD/Pol5oHlDwhlRg9BQI5WDpBKiuhXuFhaphhirlMaKVGfzS75z1irNpB1E5wIr9UXq3/X5OR/c2dlMYmaCdhHM4H5+71SAf70C3H7bmXeaf/GHegDW8w1X/9SZWw3LG/jm3km3aZing9qPd54gCNWTVkf6yTeaClY+w+prbz+ht9ckeGfDvTHz9VkbJdmTGzEjQZMF/NyEds/oxldi4ZlvN25cztUTYjjrq4vhfWNXLz7vt+L7qq/xPu06yOHbkQngQ/grWl18nsepAP96BRit27TtTDBTcO+u9/t7Ao0DL/R10thBIJ5+/Ixg0CuQ2h84Y3i4emjlGVtNxxi4QbGClXi4Qv4H2m5XVjMVqy76oUEYX/Fq0HYi5rd+zeAz2Y1o28JA7EbuDrH1KcVSjg5sJt/Cmha54w/xbn9bVb19Upu5FVRiRklOQqcCHCSwJuSnlxx0py6I80qfTX2w0LXttY1m89odhOpX6B5XGP4H6tj2F6BTL40Ht1wDuxw5iM15nMtFDGVrGJgmmlcdiLZzNAm1W8lCiso3CI3rfYdQdzTxIVygXoP6q+x3NXLG+BIeIjmXh+L3aijsvhu0DY+sd7+wyJXs6pnvIu9mJPXK5k4w5/FvV4DpKN/MT/bzmXq6V3OkaaJYb3UPX83bIyZQSQ1c3Wqa6r2VPD6eIYw2d4Xa94e6085qvcrMytHdR0Dnb2Q/ECz55eygC39T3dC3m6N9L03dgZA2qabyYuqtZDEhsX2jTmjkba75vgWPafiNX9wHzW2jJSuBmX62vV7mOV4+sVmyMycpLkO1dCrAmQJm9rzx+Y4NtDZ3q9r4L7/DbqoYD9585+dz5jnofS4rg7j35b1WaeTu/LTHuSwHn1Iwz8ZXYs0PvIrVM4xeWfAf1zcKncfV7tdFqGPH9IX0kiv1g6Uq5J49eFLlNmT4+DZTaOp/GHqLEI3qz4b/75UoQmF7E6yjUFJ0VNVAbjiQHdFTQ04F+NcrQJ2bkd2mAqRrta3bn+nnMclDjHf28sOzwzb+3XQfPvH+F96rKuHpk7CyYiYbzdmdt78cmeufevFzEQgDI/AjlcWgDqDrIMrBS14bC23MiY6OGKarpdgd6fn+f7FcGc3OAtO5hc/9Pfy/h9fab+qtgx9w+f/H8/lmDeN+KFCUYAF+W/U9FeBfrwArN051zz3d69VmZBDiFT37RZ80baeOUfX6av49cUeMcLn45Oc1nsUHl/OVR+MDaD7T2Ziz0jiH5StS7prrpXCoZ19YRUw6lhVhOFeImUXFhq594MNgvNo8o/8Ffpmt34p3/ZNeSOV29ij9P/k8zRmTlvtXA1qngG1ymMQtDvV2oAunApwKYMmICbTocbd97p4HS7oJ+bZky2jyU436fdnwcmwanNqfC03QhmLHGzlxSTtFStzcQX+WPUsZewwM7nESZvxPs1JwZ3Kj/BKZtVs6J/41Idzu9n//S1iipDfA2qb1mXzGwAKnv6fl2LL3MrWz4PlgVxTunZeRDhOpi5y+JTg9wKkASlOA+X1sfgspPqTGx7azt0SYufP9b56Ck5TBSvdvoV7hfVPoeX2GhbyLjfg20jwvJFlN33QcfbYbMeGoMxWl6WV5zoYjBaPd96XQE2BzSCsVUkz7mtvO4TtN9fljP80gRH53QistwXAsVfzWv1Lbq+ncvGsONec6pCYY9D1jM3kqwMEB0HZePD8vQggedw24Yme4f/7l/LnbHavF59aPfz7n5jaoyQVezUcoeIUzZ/W+ESuMYiavr7vpsrPQTbeupJIgPIEv+ppyA71ax9I1kuJo3sxtYnUbmjMUHDctruH0d2e2u7gnB/D3kWQHXcR4UnxhuLOfWcn4ZYeWtTkMlYJZXZPAE1pV7VMBzhQg21ysqaHXZAKwK4+R2tUcrXr23F9HtCcWvo56I3vPyz+pazsH1S9jcyu0xrgF/URWxHZUMNyxlHDNYiUKLu9rOie5OIZK04AQ/jEJ7+BXdieiVlq9kaynkex9a/vDfbO/6w8WWG3VK2J5ofOWZVANt8RUJZ3K7/wTK90E5OwCzuP6X/8kC648XR8/3+q+OjzFBz4oyRPYvafEv5emm/2DbGt6BKPtthftB5ihPNrun3GE6d9dSB8YfJz5o38fpLzvTKHAHdmZuDiFfZvHjGbm5j8sg2cveKXLgbjLT0ca+iwxm0rx9mnkJv/wwjuUOFOhLxqvvYtsE0pkuShtBmKnuvxv6jz+9R6gNvI33R6LtmRzY+uV4iym5+/mAgZC47HdVkZTcMe2BnEFRurs+LsOqhErecT6A3M04tgyZ3A5H26RVjaQ0JEVh51/0F4DbwGDnTizd38YFBft/YSyxYL1xE7DksjrJLxkJhIiPtVwvskkxHA11tWk59i3G+HQMhqX+PgEngowwS7W87UXk0TAg+XLbn/skWeEtNUdO7edgGXdqIoy6XwqueZqnonL61JtHYV+CmieB5hjtNJZozt9W3bvd/Y1ce5umk2WswdnVr7K39FW9SLVMNRTT5W4tyQDpAda8CxL52A+SwmQu1FrKSeBOQz/6uf3vg1ReeONMUHM5rES24hTAf71ClCnh7uBmo3tdbsKnZCOa++fPGnfQXMHjo2vg/TQLh8NBXNg46ab2SmwBxh39jVr6+YFeKGnCAYm+eR41tlhTNDcXZBxdPboE3TvgBt31tDKJFp0Mw90599KTPrttzBbomFxlKsH6X8XixTBQhiDNf/36nVOBfjXK8AnT1lp71bj8Zgject73OW412z3Pzv3Fi5QzNfezwu6ItHaFNv9gUF4udF/Fw/mbkr4ztUvrUJo+he9LkbIu3YX7bnFuewbDM4xiK5lJDpgnm9SnB1O7BFCKYVyxvDqEIIVVfP/yufTfRC6xyNrNi5HTxndeKrpqQD/egWwtpES4tMM95B5VHA9dy9UJ+UNzg78tZ+fG4aHhhMwHyiyscTxCL7VJH0Lrbl28RQcf3Zs/qPXD/yOd3nPM/6++Pw1z9SEXb4HmkhdsSYlkQRx5Q27ewh1INM3+5Lbgkhk09ZzfQDSMPP7qa0vkFfVlM2JCIk+lAphncSQ8wCuSc5TK2+X4uJMLPzNnfrMz1PP9Rn0OQ+PiuWf8uDfrB+uH8iTOPLX2Vk4PrNCPliXI9lGiYPdpY+rzqRMXlDlGHlnTkzcyTSWZNIKpQDNzR1BSCOIdBSuajQbB6Gc2MUrnPp+bibyio09WNjIhW/u8Cp1LZBL3jxcbS+zNs0wo4+VZnwqwNkFiG+GJs2Jgaqtxu8tN11W83Ukobw7je5s1tj2O7n+VPlol5cvKEW8UPhnPr+zd4jbbILV8tq8vIqDoImwjbxhr9ZRd3ct9gfkfLXY9lVfX71BTdvDJywjFCFyPSXzhJUU1oHKaqqNr/zOK7ebixDBvcfaOdfBLGJGdLzXpwIcJNAob+KLP1tHqbTV083XE+icHEv12gLnc1bymHh3ezsOh/aJh2NTX4TSdSbmLk25PzKDS9D9BLSlcoZecNBJWIS0XYQeIBOUy020O2txRbCmQjDwhnBktdMNSQ1Hkwm09xSpdZrZl0Q/9sGXqpK1tAFL5o819BLEeTZ6ZUgVSPjAnArwr1eAgfLUBy58/E5F+3Xu3a1N0iM/TZyONSjpunCzSfuFlTs9xZ3M90e/OpvfnuXUPKgbWc13V2jm1daR8AwOcgEQ8kZc221v5KOHjdPf3RIkO/JF7IPwN7bUWFsyei7c+Dhn6q2hLo//8WMPYy+/P3llnij1KCv1DuFZGFrJyjM6FeBfrwDlD1x96yDUqJA1Te1KKYEXOWCt5tzDU3nxCSoR8/be9obi69P6cDZusOPK838mq5Udf349zHHE8jVclPVbSWKBQQ7y8O6MIKUNhyLYBayTsubT2WsHa3J/eRnJlsnYPQZWZiZachGqvk7KaV7NkfHXZmUlolg1wvJv4lSAgwROZ7wADxuGt2icRMf35cLA7dM+a/5Wu3Etd/vaUOhgHimh7tE5hAOAtDse7TMcn921sV8k0T+uCPu5qO+g2+ntToXmmWeWviLFcbgIYbOc9q0lBYTD0sDA/fJPqFpj22uLKcfIRWzku4OspbUpDLxgpMdw7QhWe/9CV1V/V6cCnCkA5PnDTD7Nu09SXfNw/Dmlc+XUW075hY/NHxO0EEfI0p+3NuWavybNfVRzK1gZ5v3mtDaRG7EaAbzuXKWOJrxN79TpcuaB5HPSZDiwU5LmtkMzAS1q2SQUH69NxXr5kGu+wn1KqPeyuFOVS2TpUFBI7WiOSEicBJkUd5RBpwI8u6Q7OSort4PlBRI5f+ZegCP79+mfVc2OVTbWHE/iA5y5W8l2yyeCysHl82xt4yDErlttTh/+0wO71KYr2N2NuZOW5OROGG4/05LOpEaoRaEhi1yL68629CIJtCIyD5Genc97/vUKWXu90bYQ3REYdPNLw/ZKTx1Tz/Qd4Zd8n2duG5XynE5y6KkAhed3jqn6vqqYeHF+NRkqw/H0r9+KRnf53Kbj+vdg6I3cmq901Z15W638NA/ajT9f982uuPQz0+flkXM/+2Tte/rCM5XqyZX9dngE/EluXnUVM/cE9X8X1Ya4yY2Uwtb8Dos3ocQ3ttwL9u3DzJOtP3qomKnMv/4C3Mf8SvTvSvykXAVid3gqwL9eARad1jdrT1ra7kqOkPrpnAglzcybMnIzjBI3bHP8XHRWBB/KCtVk1kYi+ZN/89c/x0r8/uLojVQPaebvDFQCgOYpMH/mmlszEH6553XelDYWPcvI3kUS5wcufx+6T5mRn6HQuxzzt6Yecvf7GqT5675MXe9g+c4/+SJ/KQdx5gZ10t+jkhfzqQCnApQ/TZ9+e4KfUb7VjXKhGnmrI9PwBuF7K28o5gOt5oSnuPEhTcHMjX0leUy67zk5F80Hj2sV+25M4iYZ8RNn+gkUGsCcH+RUPYGmrAkOz8j9f2AY9+a41HO9uEIIPUNseMnM77OaO2uxCpAdh9L7X8/9eT++pEmopOWV+MOpAKcCaO7bOydOszfg26x2XKUW6vp/e2XllKegbCxCztLtrpdCz6Snc8MnA9A9tsg3rG8lIxF0JPKnPjFojkFCKX68vyzfvpVVorBJzuVZrpTaZ58FTijcdXx77toCCE2obV95goxWSTTdnEa+NqRfw8AfFPexNjrmCaMPovs5FeCfrwCGTyJVzDtbmb1Zvn2TWKbM96mNQTEHqnuduCilOpKKP7m7gqtv4RPAaneitRxwTc9MdZcgcb/tmaza4t9qYm+LeELyYz9RtcMIJ1jUZyzSKXAPspK9z+4IK1+HtWoi9P52bFIy1wCZnT6SX7hX4pWoSfi6VF1EcpLmtg0B2FH5efanApwpANmpDmKTDz+ZtfdT8sxVwvEV4cXfefw1z34B9xA0wtNKHX83v7zOvlMU35a9/Ep7s3JeNuIvrJYApKQLeE86o3H8q8cv7aA2rh2yXsV3vqguxDu26MyVv0flqs3MYJZ2vqvDevgUt2/xlZLPKw/RiCklPoWMVB4qKb1L2/DbIfU8/tVdAM/Msk2MaJPlnh3MXKDQvKwNy5p00uJ8a2IHV2KJz8/9vnCulbN1+Q0sTzYsNsHwTcTIWYP1w3znA2+/skU7PmuTRzluIivcTWoC7iJAjAihW99awlhNMt/cpk7fPSITzmIHG46l5QsW3gOTPBxjZxnphsOxTuYZz9eWUbzKn8e/PgXM3GaDNmmaHtea6H509Up9sOT8Otrp2h+S5xWJqQMXBoA/vmm8vCbw7f/2FLHXVqx7Fa2mZkD7PaP+nPsAzjxeVIPYHSQ4SiO5UIv28PUdeXaxbeMwEkH84/4Ln/Ri/49ntQJPTnN4Mf4P/npletKDJDP/2EWpTzqc5M5/J0b5xwvfwwc4j0szpw6EJ+0css6Mk/w8M4++tMGayYCgGvJ8lzv3B+rnvlSB8lP1wshc+Ape6WdiyZ03csIGMQAsT2Ix7L+JPbD7bvTVMXEMwvCKGS2E2FXisWxMxFId9VSVQBq+uN1nJbqkG8iUX3Pn0Oe5lq4R6TrSOVIgjqOBddvRzWnbZBQX4lSAMwWAMLByteGsuZ5AK/TZWp4dYs1LNxiAkszikclAzM8zOlWsy0Pj5ws4i0z9JEvjG5Sr9jPdSusJQN4Cgxy0g1+sLZvMtp9qW10C0KZ8e+V3MbeR2RaRXC7N17TjipYdfr2Cue1HujOwtVQyI9+22o2+XdeD73EqwEEC+61QutzZ7jXQHNrzetZLBb8as6U8w5AIW0/bFHQVi237BmmJwYvy9oqZi8ze66jXyg7ANl/CtfkMcypJ1UWlvASjnqb/hMIjqzeId3DkVCP4AK42Km9AazOHOTuioydcJUrRqAjPpHIzCFbUnSjhN72QekUBpZaex789BRjdaoyi7Tff+jFdS3PhCobNIr7r+sFzXY6IS86l4htDdgGV3Dawf5+Q92jNLdEJT+y5pYvmie6lF/ezNo6CUTWY6ZTUkQFND/CVswb/76LJBs25q3DFqLhXzv6CgRuf1GhYPjt5bSKZpVwooaXGs+ctdl2iJnZ7lEGnAiD9gVlTijZTDs/E0s2JCgAxVhbhY5P8PKz1489n/QbIIetu+zD23g6+68xTGF2ytHkhvAcmsKXvKumMxlbRsD1DA7Znotv5l2QuSE5NnPsb3ODgWs+Wkmbk2F/551/KDQSd3EUZakKdUPdatNcr6PtFofq8Nk7h4QSex5MevtI/EtTfLtSe3/AXn7yzR+sBmAFTGXbPhDl9m8Z53JWi1zH5Qd7iSI/r6bVnUaI4cu5f6eu1Ws9Q1Uk3L+G9zkje9sPfA+YoLnIslU3jLw2J/DgvIPwCJFkMw/U5Iz0EOX9c0lN1pXeHbjge91HVPxWisFINuZIFNInPNHNS+TSe0uEDnAeu3uFrKkiV7rzS0Ekm6PV9u7SkgJWoH39y0ZI+Zu4ACt0aG+rWtXRrw+5X28TzuV5gdnw9lwt73knk9k1n4YG4fPC5XV9uXpzzWwze0DRERfxSv14pa4rOQez+ZfxO105010zPLZWk8FCh/x3t97DNOVGPTwX41yvATTi20eZqtXM+kx8fn3dmApufIaN0jEH4/KQszFKoxV1eqpy5cViNsDVGJwIxeOeaVGo2CItEniXZ0Pe4LbEloIAY0NqYhmg7R95WWnM1qk28pPOfJSoYz+ymP9HRFWv7hpGsqQHFp3VLnZO03O1hwihvaJLKM3qmycug8/hnK8BFiNWfTMjQ5K7EZzXcuCV17e+N9KQ92Gp+XB3N1jxt7N7HuWXW5tV9cr9QmkDNlOLuVbqz7o3S0GvzsXKqny0NVHMCWLS/APkTM74A7I5cnKS8WubRoCr7VmUXj2htqihpfxtwD9Bnv/D1rcAfTPID0KwA4X30VIaLOMonM+hUgDqpI1Esox5SyFsSyfZZlAUu/k/Bh9g9Sp42fdvQb2SjPKAdn5PsPeLuCreQK/9MeRUaPduR7L+uB+DkHtD5/7X7UJRGB9sz481ifT9tiSQ1+9yJa2LbKQilBLOusbJYQX8nPcmxkI7pd/wXhm97L1iPPT39yVJfIQcHOI9LmvtEJWrMximJ8664U1tfLDzJzOvyrav08UWf4n7W5uYlVpVgJoeNkwsCY0ND54SYt/UKNDuEQsOFUsFBOrzVNPar5futtrO35Bb0KbzPR8s7qEg+ehz/P+558Dz3T2b33t7b39T5K3kih0OJprZobQqnkThuII0juZCS3qOBeEStetDKUwH+9QrA3h/22ppLY90JMfv2k4t2MkotEHfTh9CD+irOGLXsswelmXauEXOReMO12mtYhF4ITeQ3YZW8I1gNFwg2byWfLBTrYGTdKqze2r8bpZLE7mNR4nnd+nf+miWTAdlvTaqbj9vHn9zNdDxjUmdye1c2qfuZqcWsvcJyr9NTAU4P0LNxNB22OBk7XHLLK4N7fJ7Al7Pdy1dwkTtY76S5ygj56U9Xzsb0IYQqzNQWVIfc87H1hYGzu6egEo3ZLYvvU2SmV2h4R2p6Qd1G19oLpS/J9krZF3x5XgLrFiT/axLnkreflprft+ppkL9ZpbFjy3bs73jsMk8FODiANEVsoHHatPCTcjBWqlUfz86ZbJvpulRrPKFnBh7EoF9NvcIpA0o4o5D31UjW0vPJ/lAWuP1QAYRj/8zs0MgHgX+9ZkI3VzpmQFg6AFV+UPQnvM97axS5PsnLN3mgnNbhGWmxwbs25FO2DANmMUjOGUg9Z3AHIxt8dyjt3MejCziPhxWsOS0a7QLu5ohhDUUrXc6erseplYJIJp6prdWc4tcL6+LdWZ3omjDKVz+cMLWx+0d7DpGrO+j37+YyKJmLgNcr6JhloKRKqDxPQ5rZHquh/ZX6A/Lzv4mnXJ6Gz0/4S+f2duQuzvZI94CZm8f18nItBYW1PkRcn2XkmHIqwKkAwXqprK/OXu2b7dlydqQ57cjmw8WuXR//XEeHrnlD812/aGNXbt41hdd+/M6puXOOxsZ5QdYCyfleadaOPly3jDP+Hqv10Gu77+tnGPX80vyEjbqH56bfPYR27+7wIGfmpKU/u1B+0Hj1UUJMZaQr0cdxx0Gzw2EEnceTGgbv3ovfJ+0+Bfnq950Zc96x/f4k/9HuryWUGsCnlrPwin8EqivxbPbM3+qH92xNS3wOjaeAhmf2f+MsYmve30JKv9Xqj1DV4g4+kPkr/cFX4y2/XQur/hl6irPm+2XuqLg7IA1idICciSxd2h71giWb+1SAMwXwjBlYmrYuFq+bvqt9ukdO16/Yxu2NXn74jmom1lU8wyuVQJoJO2g38N1cfXg+li1vSLY5ZjStDOjOtYYQYrvrbZsMuA68/zSjcjV3fxMv6S4mlvhGJaQidUdVhxa9B0b+rpFrWgrJYmtq/hq7udTrPxXgIIHWcmvC3VeSNVYdQaVa8n99/faJ8zOa7w5n5vDnFY33jsTQizvDHTnQEcuLzvm+zbhya175h+WZOzPlk91DF/UItn2/8QMtWC+0QGhjgY0JYS0jxegeX9sWQTdfYGxVbHdM+e2ujkxzMd87aL5fK9/NB908FeBfrwAf+qTD87gWTeszd1f8CaqTMLJfZzXryORddtmLyVrTB7c+tbE9qDM/s3oYbeJqwy2EBAglhvW8guAHhf7h8tcq/gye3WflarGTiDjfDq/bn/d1AGjHiMYf1uypRqYUxTag1Dux/7hzIoLz/59dwZ4lqOQDZIS8aua4XyinM6SqO1DE4f6reirAeVxGmnfQ7QRK+EQmT6KhfTOn9hvhuX0nCqCkByy920iGWuUE1CaCuTZvpT7Iu9QITePEvrpTS227XjjFaoh55W5F1tavzr/fzd0/jDcMtUMsf+DoIiZ9pzq/l283jLqf8jYsRWZsP5k1VSlg7Aiy0l955U60OxDUNvI8/u0KcPu5vzHwdXWrpcKsVPkznbasIYFGet+VCXpGKpt3anhhCEKconC4H7mlqy3BoETxx13Yknm/6Pyztj82/nw/7+eZtQJCuh9sJ7vvRdk17Z141GuTtiTvkR1G1/3U7mLm6xq0uVhNS/R95ZErvugpRR3Hrb8Fpeynkx18HrhqKz0JmZJMsg217Ui/cKH5lHlD7N+luNKBeJAGLj6vN/F7wz1neUbRzLQiUDrAdH890GzfHe+44vD+TjZdMHvnsDqx/E1mSw/srBrO6WN9k3nt2rHRvqGfxG4wYihbuo1oY2E9mOcXf5pyWZuKejV/xSu7fn53WKdpbaN5KsC/XgEu3woPV50/veonu9mLfK5GS+dD4waM/DMDyPsOL8S8HDJYBYzs1DmbpGeIzcavtcbn7VMA5593B47V3LV2j86V20LJmlZndtLEHxrpke/DJIWCOIJSnsm1yws+j6aDZ83isyELpUy+/Pt9vP5dvjEo5mV1KjNTVWo26h3BIO+Qwwc4FSA+1zeu1MGsnGdrHq1bP7B6a0ng+zwu6SSu5Ba8wE4d2rRCY2PZAZwvIu10yM8+N2rGzGl35RzeOQvsahDYPDJva20IvFBKh5GmedL0rW2Cn5R7HFnroHs8vp63AB0j0OzKxHG7cvuaziCsub/URjP/lhY5jnUlUemsjz/AqQCcvL2SeTrTD2DR/Ck0mSJ1quWs0bPvWN1mlPLHKdeS3JXLNxHPtPHFx5EHIR/i8MYT8gm0xByez/9Ne/C5+Q115BB0umM7wQwjEHIf2YjapgyQM2m4iij5eoJ8u9QVwJEwXvtB9k/HlgZSyd87y6F0z0rvaWWNTppr7NUrLa/vxx/gVADZEH+kEzYygw55m/WtX3lPYVPYSdtgVdcvvvOaiSDcqY8V3FjeX8Q9fPlO4UEYF80RdbvVp39sXL9gKKwXEqi5zxhZp57HnXN+ryCTMlVkm28CSxibgkdJ8xff4/YuIzpxJVcBTl4oDdJqe9b+bzF3jNQYjvbu195l76CC5XAqwL9eAbDtz/ssun58iTX33/02xXbX1t17uUIAKN3gyDt3EEZQypXZbj40h12hdA5W0jLyb+S4V6oioayB0kPXSS2l1CJOcXXRVYcsv98ipO4iF7Tg/BUmJ63isIuPtT9lm6MRgI1DUUjG7rCkbae57z6Kj3HUwacCzKZl2526VnMMRWb+mut9Qbm6e3KQbeh7+W+OxANu3xhY+tdJ0+8Uhw4NsytMsDuD7l7DQtPIvflngTr62j9Wwu/IPmM11j/v1EotpOSktPIcypaDJNsUMpKLUH2WkNviPrOs/CqlWmSuMcbGp+ipbNU9LOrcTgU4UwA2fYxSR6Ab5lbTgrStQKFms2XWF9O2K9cKNa+TvLakHTQ3H0W59CqxCAf5iQp5lK90Gtv18fsufdfxLnIxXS3fAz6NTJ+k+ZwNR/1X8+VlPyTNXh+k0C3XVfO0MKHaIS/v4drqDao/f7Orimc16R1kp1FrzmlnG3gqgNJn8d3vl9ZGSDE0Um9uxMfRnEnrduy3YqhZFNiSxHrOrWTfrInwPz/lenHx8TrLlphYbONmqh3u7PFBXppC3odPFRvEn9FEF6dnp8Q7oel5Hjz8jil0d4XVdM/W8BVkgpAlCtB5Rn2OfxTGAyu9P7uG80pv53IkmWDtFI4y6Dx8FxCclPKrXU3bh3abBPu+d/0PNr+cad9VLDyTa5tkeWOtTUEP+uw/7hzTfy4awmWbZ2aftS3zePBiDDKSHjXp4720tsSz0iYo+XSZ70EmoY/1bCXTR4zYvZN6Gkn0wLKiwusKTxj9vai6MpNl/Jzw25EUbYmud1Nq9ung9ADnwUhgnVh53TmrseB/qdunf+7mxo1Vz7Yt3G6/9e2lsiu2wGz6eSFO4ZeywtD48ez3yypmaTy6nU2IHwnhXJ9kS08K5+Tw/x2kZ+Izttr8FDuL6Gzq7Aupm0HZYoW+VLYbu4Up9fwrk4uQ/gp7P1eoQPwdnQpwcIBgxI9NFRv97aCzoOnr8WtmqH8ulDfH3Rw6igUb6vc7nfRD31demSMzBrtv4XDfMaXZoTr/td136v0C6wSU0LVQGwxHDOO13jknhH+KJeo+8XVU7cbEoMTAub2L/02PYG3X0t0EK+HMqBe68k4XZ1tV/aqpqWMimh2BtQT3mibO40wBizgAu8eFNCdcULc6/QZjR9DanhUK3xm2ozF6BPBJVsiJID6Z5UEaDEEllP5K5+JA4mobiOw6QM9q/kwuCYziYeBre/XdeZQzBCXZN4Nuct3OOBp3QMhluScbvfugvpuR5l1Qyn9WKDH+WBV3EnLaq6OdKeA8gKvw6RvTfWx4U6aUPFs6NfbgjE/2gDjbzRLJHr6DU9Li9tndnIU80s8q2EFKHFghH+K4g7Ul47EeboFd9DkxAMCmlynVHbN8qz/oswLauR7Eb5xZK2bzUvq10YvJpnzIB/20ylKM/KOZzuuBTc7MJAk8ZL2Sl/fdoFAGeVWYUwH+9QpQWTJKGdo1VyvdbNb6c22zArNyVjtzkvf317O0kUlk16YUwI/s4O4wuFrPrI1F1LMMi4n0t3XE/XblBB7NpB3m52jmj4WzSOnxlzOpzZ0LHw8+daRwUD5X3eXqvkqLMLvZeNeWToqVWDLxqILD1bE8iRc5Bk7iXyptY5hlINTfHBzgVACl0y5+11x5Hupeww+uCZpm9c4blTOAv8SOm4mXl06mdnNKrh570oc25f7MDeMivFBa7k5N/ko8nq5ikuahJz/3CVEjVuMFcB5HOYivhtS/1flA10Tye1gcwUEegtZuadlA3JkJZZH3Pjx9YLhWoOaUSme/ED4jZwo4D1yVKMXcnkjVLmRun0trszeaNgU0m4dSZeXmjlN00XQ/8vLDi9MnqXdfqVyo71EMo0ozqtfzpG0Znb23s8/uHyRUkyRfmTRPj/D1YqzOmr4P1JswvqKbE8mgeWrl98SWRsTdi9I0U69otcoyE4EFvt5VfFsKK45H0Hn4LiD4N7tejVOt6zQK3ZCT7rXaAs6tUxB0xv/zqf2Q3t5IQSfkZlU7hUHse2x7rpUc2Sv3Zuqzcjn/8OzP2uD/ttWwTXmP9uzr/egaHp6Y0FzQLXmKzCH4XYmwbQg6Z+pO3PabPUBlHhghCaDsck0kQEkrfaaAUwH2LtRoXxy+k4s4sou2e/2EBFo9aBuw+3baps8dqf4JzF79p1UdWlQ/gO5LAnDWmGy9imQ10vyeu2sY9+gL5Vt0pyZg/UTzghEUX/VJtCN6lq7erV1GeZLtyH95EJciWTPDsPb36u/zQKirvqlk6qkGRjuRSawFO27h5+EVoNK2hTg2oE5Uc4JEfhL7lD6Im2b+ibxI5VI4m2DPIBr0vaoDHogMrpg3Ppk/ooRRIE//alzjx7N05iSymqOQvTSPkaJ5ZxfyIWZgnPhFHGLBxzm5kn33c0Pfucm8HMNbdA6t7Q2qg6oaoC0HbPrX35t/qSLyh8uTWYivUEqMYgyvNgfY2QWchzOCjDy0yt+nI9icGBideanf2edrpv8NUDyBPe92NeZPdxQt59HK3L4dX5vbNqs8fm9K9uXUzMr9u/DdOu/oQK7sFhZ5/S98kiuxyAFUs8bAOwEhtjP7HxnploqLU9uQ8D4diW8Y8Q45xajPYz37Vyk7GC9WdWQajsT+7nwmxx/gVAAjf4u6rdFw/8KshD5/mjf7SI482ud00py/UgF8+6fWEtHuuEFoZAa6Or5YLdwzhOseWoahgpn65UH8B7cz6xZ6yumiaWEQXmivmSF+5pNutDaUgdl+y326V05T3C/gpYLoCED8GU1/dODtXlqzv1CqQu8nIvdBiS00Pb3oVIDTAyBZpsi90vL9/RsfC9b9c25GTqqFUj88oMu5KyN76eW/9iEGrGzMNnYNtOQWCGHofRuxf9bLg0BR6R+frUO+AMo7ZGVAzfcrVU2cO4iWV2LNTZyTDNk9SPOn3qmsXFTr9uSP8j8QYh2UO1FPCvq1cWSvVPh0w/lsrPM+FeAggZY5PHFHKxa+ebtJ0wat7Pk194jWbin4ff9MsF9y5oktVp21kRyWmFTjVM+Wrsva2dobrkTqBJXDrfn9nw7/S57joW6c211755nsambxc9P5uKyw5Y0GqJINcg8tb1EQqyCmFd6woDGdAxPpmqxF6eEx5X8p/V2J/7vabmO0HNKoyudxpgCk50RNsqM5TYHcuVe6YCBV74tcstlPtCYHJYS/FHeDtvxIFJ35OZxNwK6Ett2HoO9um0+gbtrCYt8ucNpX3Io3OfKL9zKr6WxXUwwuP4PL1Q+W+T+3JyntysjiS66sKJqan54GoJtzy8hkgknsp+otGN1TMPvZfnQKpwKcHqDvonhfxcpbuHr+wk2zO3L7xb58QmrccsUz4uZ1Bl7pWWZz2i/VkjQHMWa+XJlTsFA8uZXK/EVdB9IhhH1KJG9U1i+uRNvLLwmUgAbqzzlzUJzHf+X0UW7Is3kX6I8bH+1Xy8kwdIH1rsSMEpNE9yjlucQo0cW2P3MqwKkA1X2vZLUUu3ckM6Az9HkzfyWCvTKdM7QsTxZJzAhGGJsmb0Watpfne/XdotC5uaGO7DO/TXzG/ubpKPV9KZ9r6h2IJDRJ5GIlB6K7Dc48a5ZdOPdKMzft02/zlapJtE2fbbsVdmIo99Ur94MzOX2S05QClNVmm7M5byMYLV2eqFzdlfEH4Dz+8QoAuvd3P67RTifaZ3nl53b3s4hpOnbfpR1gNxz+xErTttX8XxlDnVkXCmPO0V3EiwPNGR/K64npnetMfL+Rk0uc/NH0CqC9hhB3uvDIkejD218FLa9IfJ8qVEsWMSB2bxHNDJauYWBf4a5rKExxbYgJV45TAc4ugCuAZvrGJE+cyu8rBiHjU2Nz5140+zKbfVH2UP9eMQvIy61YEtkvh/HO6JG2dd+3asuxy5t6/ODvVobnTfg+2laNs8d2VY+0DUjfQXLSUOkYORt4tBMb7IGea4R0IrPNg7DXFM4rNWI9hrPB5dgBtj3FqQCnAihCv/NFKd5X8vYZJwg2y2pb7K6bKdfsfk7W/8eTuFufvCiRR/x3H2fxyyf5SQxYa0ngoM8+64CiY7BEARn7W57fPVJX23nH7OwH4t7PVAJeeeZHywYGKYl5U1K1EJTO1LVR2jp1IWyA/dKNsElrCsTCGrlWiruyTMcSTwX41ytA7POiW+dcvPLIZG/A2W4eELIVfcNIBh37C2pjpAeKra0Ljt3jyIzcwrk/yaIbiUtIYvX9frXND7PQMyO0Q3JWn4nlm3t6Fq9/Nd+BSTimpK6h6sVqXbrQqxfyHhByN1kb13JlkpKlN0Flo93pUwjSXa+N1xXvYG0Avs5OUtyZrKiHFXweF16TYb8vGE+uMzXbtq7vDNHSAcJBODbks/lU8hZigtl0lmcr7rCvq2+QeWGr9dDdT1udsafJvP36eR3URYR+XhOnrFvRtrye6t1B9UDy1yw9vicun6PuVON0t9XZ9EI8Myh5/4jrf75A8ykbhADohjAscHq65js+aN9YuqzTA5wKsEhTt6fTWNvfA6yS3dMoHlXMlV3943BzJTPn2ZgLofdCnrmFfo28y7uLRuXtKqkTa7t+t65XyDm3u+QsyiZfNPXv2VpoHD9GQoMBsNrzG3mXi2/sK5lXc7MX+Ufsy1KegT2dyba/i3pWnOq8cqZ5ap5kzzYyBRLZby3sGudTAQ4OgKYIlMYf3TcFyI4/9nY8E3wQnlozZwBJFFvSO6g8fpXu7NACdqQv3G0qRaSw+JiqA9HvKGBk98zs9b80nU9w4hlP/Z3nv3yXWTu71bKP7QcCv3KTYtj5gjtO+auXR9uuhBcLe4yYb0TReIeBqhaPeDQm0kr2VXVQpwKcKUC2W4E/naA7H7SFXs57WQ0TZ9caZBbu888v8WQLx1p0UoU4xtVZ3PQ79awE+DHpK3H8NCcQIXW+uoLQHCGfQGP096QuTV1OVQojPbMRBrKoYo7kDXVVsBH+b5TW3LH/8jVnbyOjbQj7LPSqosmPkuw2CjeRpgHnLuU8/uUK8EsvX6579Wk1+r/I5pP8LME9M7venfM5CreXtvnvXAIjZ3sBiMtuhPCDPP7ntm8QQtzr1xSRgzqbRzD3JHWSbUtDj1ngaluOcicSfNp0UcrcuKsFv1JJQI4IjCGqew9MAB/iHitxo42ywMxRj69XNVYmM1ZZzu76YhCfx7/dA1Qirrbuf2QqLVrmduyzhabnkfyzSuZYidR/qFsebSetzUNw5O5e0iU3ZgMhh+zw3rB0xeQqIuTFa/SpV3Ik7/ob+CQykuv3Jxm/wREyf5UrdwWxu/xLUzqyDi7a9TFHStpZB9ilKaaG0DCz50htMB5MkxPUH20X6x3tB77L+5CjCziPRxtYd3o5csSnvhJuw5kW6Yf9pFav3CqFshjEnzXaUN3NiZ9nZNvw9oVSwagjDB/PH0Pj3ZkzjzW9QfesLDT8e/+9uN9jzrgdtVRPTlDyK5DmJWBZOa9N31RnLTg5s/EPjJSGzzO+s1bCf336O2++oVTq82VLBpDXFNBZhXz+2c39+ASeR2gD5zZT8oa6Juya00uhN/3E35muOemenZ6rJZsj755zL+1UWN7VwdRfvu9nDrKQPuZO1H0RbqG40nMv0EhtnppRjQZhZdOf+XSXIiE0vW8AJniG+j1JRT3seuRCJm4IBH8wAO+2Pqn9C93FIrcUyaoavUU4/rL7V5/eqrOovijeg1MB/vUKMEkvtgjBq/QM1pqt3Hk9J2KgFOyWvbGQMx0IQZjtdEzKILStHuiWhDdyxq65d1H/PLwLty3xY2Y1QZ5ny7yftemLQcwkpGeK5b70RqnyNLuC6nzqGWoikZpeiAMgXHFtddBe+uEJZh1KcwkYLYd0AbTvx2vvIJToBspWnGcKOI/roo4/knBn9qpK8yr307FHn9kDPCfySs1s3dN3cmaN0D2hNFueDSQzv9EQ+UKx4ms0NwCRQlhTe7kPSWZ6hvJpJlcRm0uQ0X6vmIRovVGhAtZOV2WFVNbClzhQxf6b+GYVEPSMwcIw7cfMUrrrrp7Q5l1Qk75mPV3U+/SvPBXg4ACcLN155oXlYfPnAqnyNROGy9l6UiUB/mTWFXcP+za9dyPacv3uRLRrVghegpLSqLx36kzaf0kGYOeBON3dEUFyh3ejXLfYp1Ne/GNpeefhT6BtSlDiQY3GErJ0EN17+aqBVSe0sS9LC8S+hpw9zG6C4Qt3KsDBATi1j5mqE8WwY87Q2tx9u2NlTxnkaVg3htFwNy1t6SRKzn7VmQf3f7XzidY99AzROt2W2kVNDpMCpDtmnKycxyNdu+8Yq7aUauHZmIS7ouXcwAwE5B6P+QC8iZ2p+w9lwACaKxGotglpg5TcCJDcIWv8DQW7i6xkUJ0K8K9XAG0nqrBmfbkBWHpdVgrY2lzzQM7Ca1P8W0OmKutypt/w4+g9E+PTvOc4L3uRGxka+h736qSUY1A3v+j2r05eNyZunfLpW77O90Ge3PITKoXi8uRjyd+9fZNZU4zQ+awEgq72jb+XXaFpiQVqPq/uEzpSB1CuieVQ3rNcTwU4FYAV6pFBY1vSV+2yJfV5cY+DNtLWdLPWNLW6aQvQas7wjkBRFYl1hzXPSvMmKEUCp5nx1F5JnnVvWvP4XpvL79tvazVMIirYpBSe6pS0ZSBJw98WOKdAyGe9Xo019HSkr9rMyozGq3ze37ulj4BcCuOnPc/nwsTt7/J9tIHnAVwgjG813EkB2i0v9Cy83VEfrywxbV+z8m6WF47FfsT1lb1SWPr4PL6cH9Llq/PmCm0rFtBKzJ65S6u5cU5IMvc6hg6wS8pq20bmJCr+kjOHknZAweq/RbiqohKPajfCzj94IfuMARZmyd4f5gqMj2sph9epQVsdpY7jVIDTA7DvRM/FsEToroYRWna64fatLcfHXv3ybF25tmSNPQWkOKt4ncryBsNrvrCWNljKpccPY/gNqA1PE9+BKLkZI29+zjLT5NP0nV306Ve6+YDuc9C0URVWtwS14k4tqngdn7TNlaF+Buetg/IN6m/vJt+m5fueeF9PBTgVgJnjzADYuXp8H410mi/3rOHKgEmf+0cp/wdX9ps1YSixednzBj+cwniG/ZWxC/pOQn754bVZ27mV7FpGJgb+41Xt3t6HYvZqq0flXMqTdU/mfb8O26af6O4l1cVGKgDQXpBZUkI+Re9MVXXdvzlrcyZeKV7JB339qQD/egUoRxzdfKbZHW+2+XQ6P2a4HthSDz8guKD4myzhK7kBjCsa6fjXhuxbngzbvg7khCMNV+jTfahzpWEI0TGvdpbFWb1XKgOChbtSB1H4wNz6g1IATaAphxexDkK7zJrHmn80Nx2BhVRK28iN4pV43iDP1FAMTPJWuXzGv2EQfFMLZcmbVkJKTwX41yvAaNPr8GoA8s+oFI3inGtOBoW0D9LeG7GICy2fmZz5K60Q7TxjQ/p5eyfk8j1TCVTe/OuFIdQ2Yb2Sz6uHCDbR8tuxNoiaNTJmhdn2FeuHCidu6wn8yPUMjt7KmhrMoeriq5fpqEnVlcBNGRsdUOcvYENFkcwNS9bxqQD/egVgf4li/kt631cPvpoPNzZ9O9+qaKhhpIqOROwZ3erzBzuM9S66OmPduEpGuTpCXj2z5ZMI5e2gsWetOYNYy+GtXbolix+p15G2OeAuxsg/VZtWaZHjf99GCKH7RlPN/rDW8+h21pmhyLyIkfmq7FF8lEGnAoBUaY8O50oe76JPf+WFa8OglBgo/WQpuW3OxAGLkzK9r10/7kdNL8vZbtT6jI/sMMqNyJobqLS9ReUO3i+Xn2e7IHkaV3Y1i1g0oRuqVALWNA2wPyh/50WnHOkDKLS/rFrK78AvtKP7CIEyErsfayH+kkgmP+8HxxmnBziPqzPjBwxfoKUGP5/5+FXF13vvAcXfdi4L4QNxbi6fq6e7XlTxeWrJvblko7mEcHXYkbRJ+wFx3GtQpSm8bRF77/14UkU+5MVZ7gcjE8GKW1teBaU3XGCnzqiBAsud3NNHzeTsc9bP2voO0Oaf3wPJVCJQ7gpPNYtUhewTaE31cDvueXCAUwFAZ3/lqS31Gk/jkcg30nGqe/6aq3ilaYpt2yPwxnu2adtemYK9vzXqwcPJY+WsDYR+IPI55g8NvWwoIN/xjJoHD2rQCXpO2L3h+dZmFLSM7nD+mLQr6M+CMwi4w5L27llDUTmh7GFxzXQE7LsS+aF10IbMngpwcIBfD07N6WozpBOQbDga82vZSUNSz265+2Ie4UwcEvlpnp4MYpsev3I6lOqVktZwkcN+9ef9fq0E0NlUzZ0P+CACX/+30d4boVOHRBH69IGGP1RqoqVieNGzmzkfLJqfVsNJn2d9+3e5snJHpkhll46t31nJZhT6c+tUgPO4ygVn5C0+27nH6x7tk6fR7Fu3Ne+z1buGPwD53MXeer4wf8usrjql6qjVs7f7Ut9dSP5vx8/VNEDFxp8/akNtEoymenYGsU3f0BkKSglmkpMC0ifk9o5ltr5/wZzBNz150BK1qJrTEVM4Xruzr4wmjL67vAlhrKp3KsCZAuJTXgl9IzXwoOSZN0un34lVDYxcBSU1/9UjVxqnvBIAlbCEkS42lcqtL7asJGd5RwsDM+SO4CJUcdFrY12PNYYN0gMBLVmg9iHsLFpYvG3oXvkC7j3+SNWFkMPX2zXA0jVkkd+PoacdCu5MdqyM0jvTx3vFOBXgVADu50feG312tvZvkXqlzedD6RRyTbgRitXO8rHU/g/C7Y2UMosY7/3244wg83l99wwO5G5k/60wfDIbCOl4zrsyft2LPDVtm+GL9Vf83pVq/0Xov22TftTMT7orK/kyFQ+j+hHN/618ospPZu3iyD0OMwBmIpgLIP/gows4D1yfnDyxuWgX+nVRAvbKGfOZSJVwvcDPFmEBccdd1AcMwsj+JtKupCYEKgNDSFdXs4qRZwlw4S/+J3ODlJxCLD/rUYtmm1Divr7TfzhOyGj3djybiQv/wR8/f08XPRyFVEz8Idek6K6+/t59vfOefto/riQQfJzF+Mk683CSvqknMmcrTddD/U+yDEemC4vvNWMLMNMf0fCf3BvM9GBeZwo4j+vrmPloSFnX5y3vv5FTJDYk8LnLQ38ymwp+paNonLwPdfDFuOnetiPzg6T5aivKTaT3B6Wj7dNKzezBXA5k7oMvrnQ3+2Rlm+RZUmnDK50D69c5oYwTuiIxUFvFq51r1yZJc1aLxETOWGSsQdoeQinvQNNJ6Mo9wVNJbvxJTKQmh+MUeh64YvMd/PJyBeN5f2wbOtu2a8/nzJInsDYvCiMfLKFNt5KHBc/R8uIEc4f/MPlH7tbLW+9h7ExCAlnjX2k70QUzV/jruOMkTA2ZwgVCEcMFWZx9e6XbSTzDm3yElTKFr3T258lGiDVkQMso3NMDg31g2XfUtDC9448t5iKPUKXXXe/1YQSdCmCZB84+8pOm/ZjVB7Dx1NcLS+f+nTsK9h2rbUFgeMx9seaJy/vwtbkAIvN9JD3wLlLWSOJs3A8sOoHskLxzD2Jfx8npkqdLU+NYWzZz1lPlioeGYm5diyZib/lu9coASgpknuAiTKDciYtNIaTekI0xrM0zSQgZPY9/uwdAukZG9rW0zI7pd1dwgEcy9rR1voXldQ398vM+6T6M8yiUpAH61Qv3yy9XaUL5i0/eu2/2PP9UPi3vfUVtPxf1DJZYeuf1M7qgpHL64zevEDdBgObEMYgXIK0PielF2ysVdzOoimCuvCwvc/O/mZH7/pj6y5FsUNIwmkeznPTw80hW8CJNXu+gIy8IxCvvCcD16dKtYwdYiVI3qebOQImFt7OCOxrPnsULf9InX9MH4KbZQ72m3TB83MEn0PK1qZzQOHwxT39Jo9uZAoyYrtzuz/zeXQcdU/ek82w0HdRssrLzmW0zuXddkzQRyxHM2BI+e38ADeVUcoG27W/nVICzC2BVreape3uGSSLJdU7RPu3lDhhsvEkambqZCkMbmYg1U0vb00MKS1Ny6P0/+EOzd20cmAnQFcFRp4a7+K9EIIpThJYEYLSxsFff3jPM9+SP5YznSXxDeWWD181tjaUc0/rdUpNAd/3MaY0TRQDWTq9UHHVMx9q281SAswuIm0ebkq2nTbFvZe/54/Tu+nilZJ5dQzxyhl8+gVzb15UP9pe62kmfemz6n1IO90zufcKfhPJZcwsyehWSnoPSPPr5JEn+7uWbxjrnF8Q3/kiM73YHFZDTzy/GxfM6ivPLaitOBYhuZaST+vP6tOWG8mxlG3YrZwo4jwv0eX8+/V+Y5/z+Stno8zp390ZJ3935r+drrKZGvGl6rs9tZRSNzO1SVDrOx3/W2hIOV5tM9NWl9OQTy5ufHYeen/0/UN84fIGW9CnEfoos4NXSSUIHMYln+WghmVfdcYOOM2jykBZA3IfuagzsWSBPiqqRs3vVR3vhqocRdB64Ps4WHQBN22PD+f+7Wu/hnKn38pXbHdoapd0AI+ErVXVKSbf7wzaMIfZkX//32zHK9epyNbfwF2kY47TMPH212w8OsxFXaOXp1pZ5Li1VpE/poNzwYvRJ7j/XS+VfDsfly1TpYyCEJvYzqzmbz9a/FNu5ppvyeNn/Pk8F+NcrwGyZdjVbsxId9ClkdHvlPo55O8F4KQbNyM/55ViBOVp3J9NA0f165itPsPQ9w286+PZv73qNsLDlTMDqASalC1QuUr1C9joR7PpcpfoW788NTgJH1ree2stsJ0HnKvVcj3h3I49htsQ2SU8wy6S2qjG27TsjFXq1vqHeqVMBzhRQm6uZiVXa7mB5cXYqZ7t8Kvh0KKlfJt2Q/SQsmqi/7RSGhy5afzxphkZL4NHk/vcuGyjVY5zgSXPM3nHYtgWZeb6CKbicRWP5388z/R9MfMhdSbeJpPKJPvmuVbbwpD9tqQ9Y/pPXixcl7RVUnVLiHc5tH3Enw9poj3MqwL9eAXjDFTfQx7fO2s7ozL69M2AX9eecqLG2nQFj1cExWs0pB685A8Sur0+1IhyOJ2mAvw1fq4n52vBJeyED3beff0/8hEp2N5PqGwB8cKVf6ddxjeAFhkPaykoU+47gBsS8NRFeTIu8xtndrDqJmZUBuReo2//NLSouFjOvomqcCvCvV4DKAR903qf3yDNVQeU6ZYlBz1TZmjvUo93ujJnPhsNJcoy6GuCNB7B3ebECb1f03e2nYqs5SipCTuTqer1flac2ADUNFK9Y2t5CaHfKysnlTAiljGXmANz5TL7J7enPo+rMyq3oaBWza4k5ddjS1zSQSfZnslRZnwrwr1eAmsK1KVfM1X+aKFlgfJIbfctP6Wq3uPpEP1vq/WqdNs+sfYu46J6v/6puWvIZip8ayW65+mjGzsqvW9pzGOjMZiW2w6KkgHAZEPIVUHJE5+0iiMEklAKy0hG8dx2SbKtFnICqJrM5lMiGuwSqMAkNrfyRyHtdyZYQynM86uDzQGYHA6EfifN5I/Ksy31jorZYixR+1u4k9ssrfPDeHEXLy2Y1351i2qv33ZZZuIOw8bqt1zZDKD6+CRs+d1+ubrxxuWf50/F8UpW/8gaNZxcI22jdNAhx6+mG1t4FdVZi+QjalpJe33WkFrCjB0q9xswtwt2y2Wa6hq32jkSeQfCuds4XCJs9j38dB0B+NgwzdfJ35m9FuvfI1JBFbpXcSXY0S163Oqv/zTtlvvHqhlqZql1322znUxMr161LMPcJ6PuzZ17++rT+qPcWvulOwrOMkS9BaaVWJhxN3wuu5rTekwVZC8RZbLwF2LNXlWaP4kYpuY1JIpnqWxG0LENpLmHxPe5kESq+ub/FmQLOw13CpPnjqONnxYVTchKzdKnRxnDhZMvKrFFy2HpP+NJQ7d/Z4uI+F4Ly4Hm2gJ+sEka+WaAM3+G3/Wx3d/28K2vJdDVSKZsHsJ1TbXN38IAG6Y0HYSCBykU9u3ODcuWuRWj/+HyPm2plnOW5VUjuRIDiDV55/pW2EZHcFtNIeSQcp9Dz4A9AsGEGPsmajxN2eU7wF0h9upBPP1JNOAgfiM8qb7btdTNi2xMgTzUjDUYnUdyFJG5hVvQIsWNLgRBM3e+2J6g8Tn4O1uYM3TBG86ThSAoYyS5a3vcXDjmg+Hpy8Uhm48en82cuQZ5Mwx/8TdxkZcbSIF51VLPHLfWZHu7Nw23mzqR0gpHzHNuRmZkspwKcClBdZmjYVu68kFodozRMacz0mFGF+tf5cuwsP8+dlyYvF338ZPkhnYY6h9eIK28bdx+EuxWeoXmmasfXdwKWr2c1tEOJtcS9gfpMoZRewO4/kaP8nOd7Y+YWV+kXq5rz2APTnNQbGFWRrmyqZICRmCHcRSGmnFMBTgVY2U0+n7lPTgKsVTWfDIR4taAOtlyzJoqDN+nuZt4wnzVNZSzftX1esJbPzdtuSaZNRx3khxb2nRca+t7OGJLsWRhfrJweaZ5l5ifpfjkpgbQTljppTZRemmsqSIXI+qZ6DYOwl5F1W7ev6CqM+XpPjRLSzxRwKsBK/P6LYKBeyUNlt4/ln/FFd1x130L434Xy+wYlZ638Ewreyct2n8Z3jzyBvlWoDV156pazrpG370iPo9LHCzFniqm3Xtk93I1I+gzazyqCxosufxUjv4LI7NWt75D8E7MlHNQuFWD/MWQ1XZRJXt+plJxA+Qlw3kDvbE4F+NcrQGHQw/v5K7WmhT8v6iIvoKn7WDlbiKKmg6ZRbwDUdhzERi7nf+6vl6t/Bn3Ol28kag5YiIywQhjVZ9zbb97wBlfqeMoXvc8A2k525QHe2aVPQvVk6y+MsjsXncSV3cvVPAxAeMdqzAh2DxvJ7wehK0ZspD0ZTVpHw8zhkxl0HlwB+g1plL0leVN2hv3KX+Vul93tuQsvPmD44o/XXdXVAp0h+LB+ruQoKSq7LxTJ0pQxQjenUUpY+RuU974k1yeUvGvT0Qs5kgdyONKTZFCvPv00FnK5srpovqNCqSTWOieuVYVfgtybGIP4Uu5QdRHTWROW9beQltXmEztTwHkAwPVg1B//pH5p5xen9s5P0WindG0ZPUgfesbfbOs9jRJKkbfRzgaOjZtkjuBTeT4t1Rjtey56DtyXyIbvly/vyvwdo2fcHTXRkkGiF2BH5efrPsQIqJt2NFeE3SmIz7fkDIbkH4Y7gb6mJf5egyrsyHdTiGFQGEU5LhmAv6cCnMe1qKuNfw50h6Dq3bk/KFR6/XDL6v49mnOBputH3bDsC6gNFR/pZLyyh+8ZeiAn8vivtaGCaP6k7DzYK9VsnfLDLNS25Tff5mnm7wSnsBjK6pVUvF+IDkKSn8AMKW1YXVcnrrahfO9I5LX3sFYV4V3BN7mE4WZY/cSpAKcHCCS7fC96Z2veIe/Zf/jpcyUNher3KPvWsi9OqQZ0Sy0udQxrZM2TeaTd+pziC6ovgc11HC8Yxwo0veCiXTlvMmvi7ju3QgiBnkNUnohINkR93WjzUmzyBnVQi96nSk3vk1LPCkdDUdD6NfVuLv6Gb+d4ngrwr1eAm9QmMW2W593YNKW9L+idfM8ZnNg5NsGPG+3GUsLLGE+QltWzKDE0sDHduDv7518bDgdSJ6Ld+dLw/PJJefR7V6rsFj4wLHyd0zd9LlJKJuUKxFsFQ+fxIT3OLB3Lu2NzxzTY4Z/RQ55S3qmglu4G5p2AkM7jexJDziObwPCMu/0Xi5cvDefud/fM3bw1BczcbnD+TpI9NaPkjP8zRqjpRDLbXf3NLV2g3T2XE+lSFPwm1vx17NxyC8IZX7E7KD/Q5c6fHyx6h7Sddf2hdgQ48+zeUlRCjdVxUEkfj/79dr6TkX8akqfMM8X02jISGbxbZvOpAP96Bdh9/wKRql59UQrGUyfqvx6/Ln11n+F705HDvYOwLV1s7yuMbm0+sZWga3RfsxpGaRtvlGFqdK4K6+9dvbUphd2Lv9ThlHOpuKaIb+i+73srfyUTQflnormtC3mrjG3SsVfVQ1av0SqSuNbh49vLUDWFO8upAP96BfgC5J8X6r6bzttsk7hRmk+hBYvmYaFbaefvIl0yYqYelGQNOiXddXC9vG2CA/c7Q3S1bcGi2zKUOhdKkxevVOkOVjqp3Vm8Y52cGSA/EwQAbHwfa5rm4lxoMnWNXL+jEqj3NNwp9NmH/UDYA/rZn8ascqc/8jwV4Dyuj+NQ4frDfXCpyfpjpV+AttM5SUmwNvXrDbStW3e+qn5gtJmZk0dvShuK7eQinCye28j9QDybctwf3vlO4jxpQydX+pDHzFBq3MtvzUV9jXiv/b9eB0e6BWvOQEZMfbRsspFoxdj4EYP4kUY1IqrYaHPVdGTxdr+B8GeVVDgM6khG9gdHF3AqALY+FABp7xnPr7t6pM/HaOkfmni2tDSuYBJ+CQksRnDxYuWFfpV38SR3ouqiOxY40hW0VMOjbQjiFn4cPcOvoJy46l1Q8jSyZAI8XIZJzMHID/3PCwcsH+L+vUC+Z7VJ/XqXMtsMz13RIH+Q6sBCE3GDOUtryxiQH73LwQHOA54d3NHsUujOF75eGn2jGxB+Pi7Hz43SQziVRghvi/trIBQDkWdfG4Plne/HOQiDegbO0MGrO5ct96zvDJTwzf9xjXGkDf4lto96B2GEOvTpItj+7wlBGye41ItC70P0/3dqHAchk4Uh7nkA+5SxqPpI1p7uiWBN77wa0/E8/m0kcCTu9ijo7f/nS4xOs5AT7YWP9+asHNLccCtNA0InYxKqvfxT/PhhPbXoTi7Ol3p3TsbgiWHis3XvPDl33PC5e8Or++kLOKODU9RKL1lzkWZ3vm9IreWcFtNqUm/QXUJKWblvOVd2ALtWi5kC+64jENP5Q+dUfdrhA5wKgBeSptlNr40hX+59PXOqa1qUXLAtXbg0s7h5p8/pRNJwueG+5dO7DkuurLWUT8YHH2+DGwsLX+/a0XaT14+OYLU9ACeLF5L+dv6Xhuex63FPSIoKq/5e3PkcBp32ehU9rYk5mdawjtmYD+yBHA4pi3Yh9iP50A4f4DwoN5AzM2f2k9Y2UM8N883PZJyt20/s9L1Y17KuRA6MJtPuymGk0g2PXPP733KmXS8+MF4ovdKJuID06twnEckpZoF1fcCuDmafkn1zr5uiaudFX6nSAdUHSdxjJeOANxKyafwBdi5/u40GwqiU39K/UlpWInsWngpwcICZmPo3N2acpCsvDy/kLYbECEdu3W5SxoE2AOKMFUPtH1mB0PM8dePwrrxJ58ttt05CsXl462/EeK4TJHR2hNSEkhvFSV6paNhdbQLeTiTyyhhG2wRq9iIjvXuYwWi0Q7WtZ2GtY38HLPFUpV/vmazSMMCTG3geDw5wAa4LKN+YcrQa5OovOUuyiv3pbi/v2bvDdVfjan4eLc+gbkkdQmfj2X59kxeA9C6c9Bm3rWceW19v7X7fE72Yh7ua+vFqeUVoXYhtXCehysEcybmpqCITNJQAxV5gXiTnnIC0xF39UB3+QnVyM7NUihXQ/YO5PzsV4FSAmZ/+6pe/rg24Xym3Bk63qB68O38aoVvit6n6fF7qdyMHEf6ukVb0dBMjv3Z6bZq5A1hbAthK/70F/MwDrRMGcuUD3atGbD3Leb2SyqvurFT3CPUa1nyRNVMHb9TmcSaXQdKVODiWd1P/6ZZ0MigteBLHwQgRrHdBE0msV8YJw4cTeB64PtlfF4I1UDmCvd8ubqpsnW59+t+bL0t/jwlm0Ot2RpF+xd2RL3x4+83NzjmafjfhwzX8pOyvIBCy3ZPENv9zyxrV3ZAquVebiw9QXuKa/xvcaKH945O18vE62VVVlQEYmQN32y2YbwdjkghOT1dNWHqACm1Bes9zMoPOoyOB1X2+7/lFXDZLv0/kr1by7UwU4SJGTt9rPSdhbOh5n+jRbr7SBpUWv/w06nz09LG5pZ8ik/ykORnjhfXLi3WI/zKP20vxt+gZzZeOeAFtVmAF8wKIlxDMAKOJqTaIzIbsuOR4ZaRJ1qbaXAan+riFnwogibmV5j+23pM+L+K/El5WI2/fQR1x8WLVz6di4fJ7qjLCJ25nqC/KB1wtMbzcxYono45MBJpejDuj9AK4IlCA125t7/u15RoqKZWMMr7H5rFnW+JpoXEDnCtSmGn5/SsxllbuXatCxD5T0gds5owW25Ivdfazqat+IYXs9Fb+D08/cirA2QXEZCkoZb6Rdr7P17ah1jMdhp4zOtPRexEWLQ2dC7bald2wULKe5V5c0ouHNTo11y7C12W7n2d2HfVpf7Sx5vx53V7z7nwg5D3MN/ncvEX7n56EONT3lVcWmJB/OFoXZFRp2P+7OhQDmsIC6Ty0Xlg/aAuxWjWaxyn0PDI7+BkIbLstpTF9dt+w3t9Wv6nJrOdtOnuBCf37/NHPWsvt1pw2lPg31pQLtUOLXI/w574IU1ueh/SB4g/g6ptJr4u9iueP/Scanq65CVnpR3ChnASKZSDZBXFSKvOW/5uvEuMskjlCoRREdm9CU8C+MzS8vYTPLuA84gMgryndUudT+j1NR5u7uQGjzQkKUHJv+QCOvH3i03qR7mA0Vo/QHgF0f5UqYJH+p7oMo/6kPEuD23CT3n55ZuhM5H7l9n8lW9+8ZxB8ffKQNo3HM/jm9yyO1POTZ07li9hHIK7FBCjXm92UfzmKYquphW4IbTj2Ocf+i8L5+XmnApwKYO2ksVO/bBkX2rzq9k5A0gd4vu5W2XrnyCFazpoDVRzJyXxu+37Q1xePkCeLUPyVZqhuRyNWwdhSx9QZwIN6gMgQH/hDKts6hYGrfbyWWdtxhCpBqffvCSTy6p4A1jEYuo+ovLyUQDPDWwModPdrbjHQGAqnBzgVYJInx+5R273l5YcK7xfCJm1vXryW0VL9hJJskR25NVUxkiFr7b8kcQYQIrfIC5O7iK4NWIRugvjNQp2AveboODlKyEAwGr+5k4zp5usVr3r6md07azC1cSgKCywe0v4n7Of0Vc5CoSUc1LXBK601zWb8PZwKcHoApNtl7dlXu5sGzZ7F6bfNGw95moy8xc35xg/DJ5LAb0fNjDIDh7NcKiVspYfu2j79A/BNgiI0QeXLv14nRQkxVKpC2pRAlXRULLzyQLuyL9BXGjq7J5fb+qC9CXKrUU7omkrIeCW3c7EsWdbffE511m275aX5uCh1bt2TTZrGK1xPzuNf3wXAZ9bKux+0Z1c6IeuFUdXdMxvfrE7XU0+uvO9DmfPHfyLXj0F+Hexhw9y7mWdW3acQLa37+fcbn5c/r2bXwCj/JCQi7uBF+AJI/9Qdyc1fwYXufMguQCORhsLslVi8MSnUu1VpCtY0lbZlLbLb8J1qiXI9/OJDrMCHWfR1B7JFjmmnApxdQHzuLmergjLCR56cRQmdSp9w9TM4Uleo9PmqLtg29OrOarM2L63SvzHmMAmvN1wwfJvnVvGSIneTtwZCTltCPl/Ml+NM47HliyCfqeU0z9PLohu4PAsUnd3L+ebSELqepizkCbbaDT8IozVKaJwY6QUQXoPsY3DlV1+eDH96gPOIHoBxYt5JCSVz795UK/9r0S1XuXvTp1HkXfpWtfUE0dXQKsOFkfVIE6OLnnrkjB3JoyvVtrtqeFJO5qI5pc76x3/2yh184ZGTPE5qLrJUDK4NqS+0b/3ICDfqU0D8BtYVoOEPa0NZZm4Tka8aDd+7iFscvgmamqGuZTyMoFMBmGG/sO+iS8HT+SzIRNBB+d2Se4AHYpDU8klzuF+0ORi+pwf5AsQ2frkzP9zJa9F2DYkZ9Jl/ZZLBagxdcYeiSPUR+r2VqmPb3LTqrkQ6qpYDWOWhIbGN/jyeZ35Td7NeqR+8ZagEguVzx01ahYEvaamAUlhN9//es4mCRSDkSMr+gmcbeCoAo3eWSpxirj438CcngcjLC858ee2uTdNuDUe3lorHp3O5Ik5SHaPOiJ35Z6ZPskauPDORbENxBAqZk0TiNPGGUOSNl2dO+fgulOuR0vwyvVKJc3snOYqvlj3UFULwKld9QPiE1bzzKy9hee/DGJ+CfUmiO9KcNz5Avps8I0n2O2vDbk8F+NcrwNp86Yzu1UnnIdi/facsyUir248V9CPvVp7uC+8bfkKu5CbX7DqcOXzn/Ds2JR4oY0xzUl8/E8WY96R0Dy7SzkfG+GwVTFpSkvmkUgnCT23SVC1UvnpP/yrMfpIKCC++byGKT07x2lx/WH1UXcDyxFL1bPXp75/QrvCmCnQyg84jKkDhdLFRu5OvFndiqHfWD45vd8j85XKJbU/w/Mokj83bJ4rVnLkM2FBFNCcC2Ri7tu0wqhJpnvN9d4nmDLbnD/Uehv1+YhdhzXVXSVcY3iszc8X7Tw3vQCTfKqaGy/8m/iSnmZlNnDxc70ft/+XHVGSJvir9jjYn5/P4NyvA5Z/k2c4M64D4VvpvD81sOmx9APPa1+b0t7LTkJwI4Ch/Of08EzH/940BwRefZOhYIgbSErTXhs53j21WIKxt4g8s8JNOf5rofvkXRf8x6b4t356VqWvftolcnkj63MdPhu+dz+RuKu1wFpXsv5S6gtD8zpc62ppfuHhFMfINigp1Hv92BVDCiiKPU9O7BtnfzlYJasNnOS0/Z+iLq2VZat7jSjxXziQe/qtjy+qqPxtY5XN+P74N/GDkJoy9DNbmpCm5JZfUGa9E/6VVrMIolXAKzdtUW+2KqXo6d2cQYl94JHcxt3c/5YpeHKZIUlmNpd0rSucjIKtfvdZBO0IQNjIoP7H8CQ4SeCrAIA0Nb7LnxiXr3jkCtPxNTX3KSKediXL5QUOn3//cfeyqb+j6OUudsb2QR3YyWa0/mdmjWGP1RHWqTeYA54UxY882R0J+D1ifBxSbXzbu8VsLYC3Pq1z8S0WgjdkvDQlASxpA7gOK+7sIpXw6jmAGBLZyKsC/XgG+5Jjd2TXwHhXNdWZnvxnNpuUL3NVD1qaLuk/vPAmRYtn//KL7rjKMo+ONz/Kdt51uzr+VPbwo7fzhED8pWzf1K113N/LeVAg++LYELtkcyitf8aL+QYhTXG4pgOLru1KuBSMRh+rpy79x0XddVH/rXtcf2Ii1JFbOFoqt6qkA/3oF2Kfi/vmOW9ISleuTtDQNOvcMkz6VnFtVG4eJYsPM5OiKz9RKmYGxRRj+hNltTGn3hsw5EdIXFLrId/G1ZRn17SUrlCN/yAjvqF0io5bsjG7JGOicqupidEv8iB5l5PZSKEuAc9BGSzba/dZ3l/TeVwXXMLqMUwFOBWD/Hfa7ncmqK68go0+7Ug7maL1tx9q5A5aGwK/mEbhadkal9k1wmkZXtg3yOLZtA/fWLhndtY/C50rnrbfLv5BOT9pzXanQKU4SJygin+0ifLB7rLy11XyKWeNcdfjKruhDXYak61f3CtuzxbFV46cungpwKkB0l4OygYGJP5v/pmSimNFebd/77afvmSSqe0dWk5GOAIHKoaXdBlZujvZN8iwKBf7Ms2KUsVOf6uH3ffiBBmZY6QW1C6y+epKjOcDpBkKO26GcqJ1AP5GlX4o9amdOWEtTLxSznE7qZ9x5np+Kc+fP+PrMtvz3lDYJUccF+37Tsns5FeBfrwD2g3u+2ie0awLYpW/mab5et0+4bD6alUoSjD/xQc/wrT6/fEks/YTCP1foFAipcFfqAqZvE1fDzLtrIO/9Oa+7oxXFuTdy+5vk4BObhY7hL9IhTCDZxuJKQSOF3+/TWSyJgdu1PObuBcXKnrTrQPqjD6q73IutbVaIv4tTAf71CrC7ZRTeJz96Ss7TwJahyxWkXMTL1bt+VTdWy57Bg593FjJnr86wpG9ZnYzVJo/KQ2HHId4BVgfye5KpnZslZ2nmRnHld1FCEBdK0/z1RCYlr27Zun6hfULnT/YdCnMNlbAAI4xBW05DeRZMsDf55b3KqQCnBwiHm+WMfCOWe/cK0vY5rmohtP/qXtma3D+QK3nlfwS77qZ7qZgsu5qI/fuF0IiOqdcGDy1pU2lTUZ79APvyx+a/cng0XU161atc8PAX0jyl4UA60pdUEn8TUjDq669jZpdRnKyqhTed/Ek6fwFz/8oBYaZj6p18q5l7hUdPdCrA6QGKa7r3jdxvc89avvWyaU+QZwjU5b+ze+G6HWuY3n7rcuI9dxeGSSx5EFMPWV0sHThXun5Kcy5RZxtODPz1ihCana+rhuFzjELdZ7zue6OkhModMU8ut0Q5Is1PM0nBEiFgh4DuyyTtBsfGKa7fR+NCDZqnJJ1HFFf2AA/7U1NXfSrAQQI7E4fZLHVHfRJBG9kLGG0OhVLBC5Ue3n1Xvgd7V/YbbmL3st09C+OzPTfOf+z578QHjRI4xE+2kGP+QvkWXMAru1TQmX/Pd7ydNVk+KO/UgIWeHijOO+DnipyEehr5rmZiLZI1lsOvuR7k0h7zw6A5qLygrDkengpwpgD+tPXP8Gr+YA9HXVAq/vqM3i2vktFtxgVWIlqaqn/GA3oO36I9W78Hq4+Q5CMH3seuYKU4kFfPrduEje139/SQkbqafk+D5oxy5tNkDMd9v1qPxBsPEMrxeBiMfNcGeKs/KF9pUP1RykMD+Y0ZzWnxHXTTd5wKcKYApO53bp9vaScTeXvZ1puWi4gSS8g2RV9sBIL1Mr3Dvr0ffvxsZeMmwdN9uAvonN/q76V5YA6/pTmNgBl65dhbDBxOSQKlfqzMACx//8IaNRmJ4RhyU2ULFL8q4qRNoDb09fn+Qg6B6t93ZXdlr16tqm0wpJh7tTYmtbXNxakAZwpQ954Jj4nZ7rqYeNWngXDknLQ3r52Y4ZPzLrtfxZwq3geEA1AoXjhpQ8hbszxIp7ODFiZu/EkF0CKVklBvojlj9HtaUyFf2UWr9SloKYiWXyvkzSFbus8kdeMkz5TRfBQGdTPS+hJpWWGSSsArMwvU/25q7z+yprF78MzfWe1V80zHGQunApwKsPLWCQUvaNM/SX+LvA8Xqfae839vjvcTeHWcsqGCz019Y0/DENTeqr5H7RzHS2FT6oAFEO+2EDqlm5+5eZrnhpN7uvcY1zJrm8OqQZa+iNZ8hXiqWMQblKY1spZsULf3TW4gxbSeVDVX01tIei28E6B+dRwHBzgV4LlZZ6pQbr+HtbnXsV/XoI073+uLFLXFR9Ntqwdiwq3k/YFQr/4w1wCP9AgtNHy83EmU8Ii99uyqQUsV1GjpoJauY4vO96JzyyikgX2+LKeRch5bLedEHRsUykJgDb9s7+4736RPREqvPWryxzeHQDGFxJObNZPRcNLDz8P9AbS5R7M6jr32+TZDu8k6kw10g+//JkBzxSymLDODgV0L35lBAHsQV85AIQeLWIFCtWflfICWG9YRhMhM0HTe7QlcRi6chZTWM5pbuu/ttaq8D6ejFIu4j/wO845TWmXsnOKZiidxr3dmI1pyEKYzollReHCA84Czgm/URvrekGTQyeQu1ZoiTrI33514hHLv5cUMAPrOjxlya+sF6idU/h9S6zZpLt5nCE3f47FVMWxsP6FOpjYK1nyMld6Nd2LaIL8gbH/Ckj1VHKdFnUmhCgY0LhWIWaAolmJsTzghbWVd6ZqkyhULbfZRB58HLvVPS8z1pZy7yZdn5Oft+YxfOefXxq7mYHYPXdQj2KZZG6ll0XZv796DmmjgaqiEphfXp6Fxe+UAIej7TxCqFgreNMZXqOt2P/6nP5mwBNpBTK9D1u5YbWebcZK+41SqVpPwemReMajH+vpPXK+aauROLOQKNLJGF2fjcSI/FeAggdZ4/bNlCf+apNFc9cLhrhw7xDeLTy99EbbOyaGa7sP1k9br5PYdN28hNd3vy/9GmttJddV1+o3OePf1A9CcAPjEcnbHw/FhzMMyxcDIN6W4utK4kUpuhkaYBjZOYK+V2t7hPz7rvzuQ6nLCJ908p1HbK5XkWp4KcCpAuFeyr7Umt04yra948MV/7bz1wqYX9bPBikV2FG99vP64tzu+h4a/8e3N/xYs/vLLZwZdZXLW3fl/USZa5Q5JnpgLk3RAtnGF3ond+7PUxkaefhtbbgfY4dfcHV3z7+Jy1sSi/uQi/9NKO6/aLMS4QiIVjMny8zsV4FSA4YhXdZLP5+qGZd/4IMmSSSHlJaAvbTGwqwslt3S/7ngl7iFv4djDv7iJ7FjyK01bW9rpIqfCQfhjZ+nOnDSAK/H37mTM/uQr++tBNbCf+hvlgByqZ57yg/c0G7rf2ZYrE9GQm8BQCN+5DVn03TV//mj+ImtLK5PjEHIeXgEG+VxJcuOUNmFo587aRr3rgnmbvzYdesz9rOwzOmlcMQoJhzt2P532hzy90NQBlSAsNMVL1rNy0htAS/Xj7KLHqfxdyXgrqI3Rx69ds/dZieCXyxgr9i1R+/f2s6aEX1lCk7C9b0NWNL/byJ+4GnK5PGNopUrJfEo7j3+5AtzpelOfTiOtqbVNXmy/B02hhbTvZxvAtk1nnfEkjZ4kmzXw+OLA249uu7K745nf5LHPU37ljY+W7K1tRzazRoxkB5WT+Z16w+ob7OWfjOalVOmr9XzCE33mlnFHP/oOdlFVCN2x5dZzkA8pV+CZf4eRLb6y+kzc6e/+vLOnAvzrFUAyfVcIleq4+fLuM3TEcWOWfrj37kL/HKkTHHnPdt6AJTJXXjw3MXCQvbLS+ectY93BI7uH8g+TZM6yX2khkPEqyru/Y+zLu48vYZg8s+xJKqzgU2I/WHICbgj1GpxTZpmmzNwkpeqwJ5X3KUxf01YpNn/tJw8r+FSA7oGNNjHzxF2ft54t2J15fjEBJnXizLuprdTIxJyqIsw7WOlW8Nxipa9bGxLW0ww0vcy17SgNu5cuM5omLsrqWa45/uaZZkUze6Qucvdb2Zko4Z/BnbxzY2LUzQSTJ/hIkltHyzor2X8gPQjweuf7DmRlWmp5KI+sracC/OsVwLadsrVP8j7hl4d18Wc6EljOWaPp4fg09Aoyt9Ry7tkL69dE5G9UYml/hjXVj4Z2DZ8rYoaJruTG5bVhkPfP82uffAfW5sjNVXFQqok6tNoVkZrIoJDjMTMmJOuTZPVVwgF4ytfMUpXWryFr98r3K7LNxoabcPLimQJOBfi1Uy6Pzuob1+Y+bzTvKmVgCfELNO+zwrIl0bhFO6w3A8Hy+4WaMJwyJWeSes4jO36AMwNXOnmsdAvk1JKJiemuPiAv4kIPkOnGoJ2FZvXSl7dZPKcbf3w3Wf5qMcH3fUQ4myx65cj7W9IXbLjj4EwkRDb2hiRya/QOcBVfhOycCnAezxTA7H/LLvnCwtc5cYwN7rs0ZA9fCXc1+Uqmh1UW+cg+oyPyO/LVNQHLu4W7+WOF9+i9uX2u1DWC+unVtgUrp5GZTgSLfAYkJ/3ZXHq1eX5weq95xVHyEVyEzFnqnMMxgX0X0JyMK2c99plXpoJJ6hWkpSLIz4mg93XlD3QqwHk8SOAkzx5NfGzhm/fnwHL97w240oUrAjblLRpGbcQNQuLa1nyDiuNfN2q59YdfzgUj1/DopK9052UU/mouOtJQudq2MfrJ3iTl0jdydzfJsbcU1KEklLZ91Fe+wEAogjT/5PRXtRqOF8/tQjC176xZaDvZyAJmNwVkTez+T7sfkrhn8Hn82xVgNS250KejJln1ufLCAJwfXyoYYPps2tN7VnbypZifpDt4tAfaMofK4WrQvbZnYsP9+nRLIw+fT/biinN10a5RskIEO+CiLbo1p+Bn8rhdbWupTirHDaWcZZAaZ71+VYg3jK1a4jXXV6US8v1cNPkYbVCFOMHxvCZNIKxZBuEhpwIcHKCnggxwDsDatgSchrMIrbN2c3dd3uMc9PXvOOjErjY7aOP8FR/JwK5hkmcU7fzLloYDMC9wta4+puj6mbP5BN2EhE7HHqsC7Gl8lXLYN3GcwsTY4O58LLklZV6PNBYvVxPzenwn/xnN0ylcBPWnzqK+xzzZwefh6mDePUsyRjS79s7h74622rb/nGXz3j5jcxeUhsyHC/czC3z8kzwyA0Pbz1f8cgHhpPLKC0dOMjwF8JaNsxA5pReeLni1XcWbyye515tQ/HV/4mdzWZiH5iRUzzU2A4yL9nMbVexRZD66pDvZwdq4/vbSIo6NAcHqpYXrVIB/vgJoemGYn7iZLJrH+0t+pocIuYdb0wko3XHRmYbSIPrnm84gJ3gZFH8TtbszvTy4fSNvV7wQB9u0dOunt7ABxHrWrTatH325OCoqia5bbiiKczg2zC5qh9KvSuvje/4a8wgkOxKuAlExn4mrpinWVjGWC3Te9uUK8PCAmjh8gPN4egC0k6PuoR+5PleevEE4es+6nFtiF8Da+IcDp+1kKenkea8uiZPDM0U0N5GBS5aGvnxwV9MMdK0t45XBABZX9Qgpj6MLYL+y5Yr8u1UL8SnIEgf460x7aRNL9wPXlntujcMMsOZCflQh9U3AO1VJCAmpbuP592/uSSSrmCSqeZRBpwJgcwEdlIYx/YTfWLi9H7B0uuqJAQCo/2de3MxP457+UzecNdzLstZwel5UlEET8shuZWaVCh/gSjZ9p2nbdreOfOWDHEkkEbfLz3uvMCu3ncAnmUzlj6ibX8mk77AyXUygntO8vOaFd3r0KYO0/Hc+q6oQX3dvjh7u6Vo0U8YudLfgQfPCqQCnAqzWm5ZrtTZsK/ZTt3+eHnz9b0P9uoemEodAc5/OjgLadMZG+8Hl+/xBN+Xb+6f6BmsoBacF9hQUEN/3zsy/y+eRZ8tg5CwYvrx3ooPP97y2XduTDzrxpHmXE7qRoqprmNGSy1fuMKuqREYBZ6Igc9SRXqCBPyA3ljMZzQ8z6aY040Hu6HKQwPO4rHnOFZpU7h837fpLMTgyUbM29tI2AnjxZrjC1K3+nuct9+OBxt3Uqa9NNds3k/UrK3dgxc1/EhGq9hTzNhJNhZy+hM5RfHXsP0a730fb5LNySGi3Ii1fwH44qPHksl74qTYfYVA/MhqG2HWdShiEvXxHTwU4SKA27//C5zlFJz5dN+HIy9UyjEBL2wPs/kGVZlM+Ph2/GzntdkeCPcUcpMW35iJSvBnzUz6aakkb/xaJHzz//CYu2t01iwe8iGNcnUVkBN0AuS2t7U8CePn68bsmm/uCNQeF7rUg1E1wBVWfJSYlmSmYBTW2Pcd5/NsVQF74N7a7p+tzIn12z/u1lqP1S6tWt9Mbg9/rSNfDLzrf/bvJj5xz7kFWpmZVtvDMOVhad67p9rdyvhgb07lwhNWSzQa+QPYUvB0VDFzpn/og8ux1aBteWL3Myu/dPVjG1h91n6XQJ6lPUANoaqa+sz09wKkAv722+CQLnaxC2Cd18rK54+4INXNfyrWykiu6/mj6jhzUb0TqdngajjaVCPUi1fEW6lX9b6GMK5n1gViE53hl+A7abT590p1zTSkfxbcdyHNoLZFgNebz3OohiBEdvMZJHAzOdH3QlL/5jHpWULyDD8Pp9mdVf2tCk0rxGk4FODgAJ8zC3WPe86jhxieR/emnyyiT+z2fgj5nd7JaP8QMBEq1Z34un93VB7zBG5Tee+WtqNmFVDbPSOZuMXvKa3Ok4lByfl45MUS+Bz+3SlXtqtryNtKmkVaAtEXvXEBrtaEq7aLE9dHeweF1QRvGUCjq23e13I2ZNzFpltH8Wz8V4F+vAD3xHsngt1dPoOTDU9qZ4SlY3w0DCC8LdsMqB9vlnn+LULHnZ3/JgciIJWsbyvX27zTC4PkeZiYTq3/RvL0r2bQwSnhXcG/6A9De3pr3GF7dFNIZSNI1OfKar9QMdYTj6RU0e5VABD7NH+TXJFU1E/h4LePscSWE89kTnArwr1cAUCfaffx2nm1H9IoH99zQf3Dn/c0KYqUzJYRCgdzBQGni4mfiyhkhNC7lYhyM/UGf/gVsnPpJqplC1tjLYHo6b0cyjbIHR/YW1voidgnQhtHNZALAJx7ZEAPL3X55g8xtnxrzxQRISXn7hh/YUw9AJz/mpj3FEdQv1PM9FeBUAGyqcnmd+vKVltyTP5+sD0A6QOSfkY2bityPa8u6kpx+J93S0vKwQR32ovxu8a8bzv2pe5/dCyWdeTW1B8uZu0/m8Y0/lDq6kgegtP2sfeQi58JIANs9FkCe3089++L9PjNXv/45iTlV+b53YyzG39IAOzYU27n8Gd8abuZ0n8SQ88Clr8kWbVMN4t1KouBPN/rNMxObr9G875892SKUjm/bud2tRh48hTVyus7MM19d70idrJGjEMDp4c9ruKnzD3XNIH2+ojb6V37Hj+MiknzB0kC9e6Sn216pUa7OqnOEgz9YuouZWuWJnr5oxKmIDuRKriCa2mmgvN0VaFyIeM5dy3kqwMEBuO8srwl2kqqTy0wfVvZ1l6/oizV5RtFF3PkVRgh9qYLmppzrG3Btnqb1PKz9mrTTsj8sWQCC7+awwY6GizoQ9jhZxFtE5pdbziwLxSQIje5q+Z1GmUvlvzrStUBaZRyE31U1+ALkB1J9ALOOw5GxtjGzdRHKY+B5/MM9wHKU3donaCafv/bfilLCGeWAPd5d5QXGidac3VUMHLQJF22nUEqfmlhl+2f4EUpmX7A/4cpPtiRiHzcrq3k0T7BSJg8aG8/aViN+rVLVgsM88xnxDkRyy7hPRb3Grpb8OwjhXD/YgQusB+xZ7ELJKezXWukChc4cHOA84gMg+M3NCafbRYyyqACWrnWcPjUA8tMSQtLnS1c/UY4E0nJFA7uejdHC2L85/6a2C88mT9F9y2a73bXxcEZTG3DeR883NLrZH2fRQT0/JxKxexn3IZrOYDvDolTExT9Q6i5qerAtyVUaI0Hy2cCVDiMVSrJ5mjBycSrAv14BBt2ArKgZ2YV3tr+Qnk7xyds17pfZ/LNm3tOg+2hmdxuJv6GQl5b18+suZq4dTx4dKVvNi4ixsElbyap0fDIt6waar+HIn7rnK3U3Xmz/1ZXCkTN+017k673JJCSlPH1DRV2zQ+Ub2eZMtBoDC8SqfirsJ1MRh2u/TgX41yvA3zwVQN8a1elQSqcrpG+lh56121Joijbc7TRJY6UM0hFq493weS4nASHegW16QW27fUnG4e1IfmnxVyL/7Gt8N2xyv22Li4vGiLDmSlQ7gji/t5/cv+kFLH72p+ena/buxROYL+witEdd/TQTjVivJPTKTCqcpf6Wym/8VIAzBSC3TbplfNiLJ8zn2wixG6TnY+zv4bOs/H1tvgCsPtLtxrf8hBbWZvg2p8t+uyP7DMuqshIRt8Qd2VVnkEo+3I7QpmvWMlviCoM4yZyVAHIxUmI7XM6lqunjD7EX6/Wwfg85iUluX5b3Crubcr1fMW8t9w0A+TCuja9spwc4j0s25Ks6bU03Ck7kqk5TCN8W+qSxQm953tYi1xGl/nY0/7rSKEbCJqjjqM96dcOh8Ac+mO7OF1kgf70HGfi0GR+ZTCobuiavioctkyNcPb+by1g4hA3CPpWmlUoWinfpzlv8oszTQTtQrrClylJnNl+O7gFf/9+ZastAJ66W317ZS6woPBXgVICYMcv/QrBaGnDPCLzSvyY+9V8/r+GI/5zBgfDzCeecqyFRCmYQV91Q6ncr8fKdhaH0J0p/G/82HF27wPnFsvnnLlIS34QdaqrqhBzMpSEOjwJvgR27jPqO0uCMhqWgYQ7dv7BOf3cXD1b/nZXr8QW6M+lU0rFt0GsbG87ZMd5TAc7jUQYpadmxba3qBg5NQPiHCGliOANEyJ3bmnef/NC2jzZR2GuLbz/2hYXmF6bwbCMuXIlGSkvdQ/qfaaaSMr/59jl9JP8uHNH7PL7as1t02oy4U/D5RTxdhd8Bae9Az0bXbaoZ+dXDnVLDBawy1epVaMtt0c2ZcTad0uEEnkdUgMjjNZ+5hfDk6H0tUSxNF72VSNSi+byScEE3bv+O5ZKvxN7HhqTXWRiOn5tn3ipVpZm1JFj5aL2LNaRuvTp90N5hbTNOzxmKnf9NfHzuufkxX68X6Llq0xUJzOxnR/N676WxBTRflRG3SrLnGM2NeNArhDsTftNpcR4c4DyuyKbTDcNHnq/qg2t7NDInK25gzZPx8Gwn2P1Gtzlbs1/ek4jZ7QLptik/UMK1eZCxQwHwN3PL1d0Mn81AuPP/x2tKnKX/dTXNdGVynKHqceB+nh9yG/qDL4CPY26FMWp2Kkp4Qk32w7VQShy+ykOQzfnEkpOFjaG0u6XFdlJo9kFLY5nk84qzCziPSxPzU/pkDZR6TRN9Kj16MeeCvbsSiV5NvaJ5kmM3tbbPbOfd1H2rYK4cMlkg7suJhat5goE0ypKnLfYNsRuoPbgQq7dPHqW/ndtEJM0PddEOVKi7VqB5JxYKULnMe+o6n+9d01yZDsuZWOXvyPOJNC9Ha8ipkv/bcAT1uISdCjAop/dDXWwkWU3U/lipx++fPKVsLtu4tMM/c5J8wok/iX1fic7H3l7Ailh2vSzMQpMJbKRRAHXB7HQIyhaI2bnri8q7Y3n2r1L3IsQhqiqxJ6hwtaukYNYrg37O201JSLsszdFT2mnnisn7yKpMu0IitIKa6urqv04F+NcrwMouV6lDtDz7lfYJ7/O7blB+OAJaU59MlHLgyfz85vahulJQzwty5dZN6Qefuz8v58A7d2pCfXMlf2hT4wpllIZi5plr/gAvN+JB3gLWkj/4zl45/zPzUKmGypa23LsObJWhbujgNBWzgbN/eg1cuSOJWz8Qk0VeiFHtTgU4OEBh6oXHr4Zk1dZNE5e7Mic7XLaZdYMXFrXScWs6t96IO2ctg9QIY68zEpXEfCbZtw2jzRb79lB9Q8iegUr5iJb7TBBqVz+7q5QqcZ13dxdtQdT3JuM1RZQHQFTSke+QkG+REcNnEs7K+xrJDPFKU3wrktX5SQ/SuNpW4lSAf70CoGnypp/oRZm2w1WC3Z9ztt09z6CDTvbuclupP4ErTkIIqgqNRAb7fRv6AnY0UML/ynHL2nYgfDZn8oxu58sETm40+Stq96mUkFLdw9w6Fmk7iAm8/EKVWMyFrVgiFUgmQakXw3k4+MTqyYvqFXdkzS0vUCEeJW8B0CaZYhucCnBwgAnFlxQ8Qpi25KdQMsF+5pR5UVcr6UPH+j1rN2o/m4vOXufazNZZd/Vb9c9G0/1ILXHnMdX5UXBylhD/V1t+mKUGB9TZd4TONi1VPad3TjL7ctWWLuomKK1lUeJ3PeeRtS/4y6xT7Nh/IJAj9QJPtfnSdsfS7+R51acCnB7A0qnLiA2jAPnL3N7TKpiFbv8lGWARBseTLbvphqfN/eq5QV0q9wW8PUAmY9ze2Yvv/i7vPwY60+Zv1qtCOjTzQp7X80VPIlkApQywNxgzhJ9MsQ8ivXB35ipkrzDPJzXg4+5hSK8Q0H9H118dmfhzZAxhbghheA7eqeK483e1oYeCkxdwHsEKHtl5d8fQSP5mjjoj7LFJKCfrmET7bquUQpoo3JV5mDeKgRNdft1939YRCND0veYziLVcQmtnRDe3kUW+HIGWDXfvLX4Pp/pWimlHBzkvfTY9M9IZpFR71afM3HqspnKeyRZavvfr3EVOUarprZTZ6tmFtQn84s1Hir8xO7mB53EJcV4knXV406VNk2rNkfPd3yrNyPpfOmHL5Att20akw2755ZSDQG3GH9c/9ROyWl8+c7MuucW4MxHAXqgcmkvP3o+snAs6whnuxYFvXMQMLuQhqtLd0siGK5eFHETYr/xORFDp/ezqbc5bU0IaPvjr8xhvYxahEOW1Fujlefzru4BFWTe7m2ydXmndbe3+J+lZjfzy+qlS6m3Z8X/RWYlJRBJ1ZG9eJc2Abfy/XSsbP/FCcN+Zfa9bUhHaZICX/7+k+1l/X/ZaUkopnn0eLdWHHLuezJPI71O8vbwta4Rhej18at7MZDG4T+sktSVoYmBPZqS7iZI74TyZQecBXCtTuQSCG4YP6fJ5K6fEBYxcjrElUOw5HdNv9N8nJ1DtT2YGFUZe5+WXfwBSuQd0Fkwxa3Rj0AxX1pR3ILZ7VZKtXHneunGbrU3qQrzewEaCXfBt/MXR+L0XemIo18ln9hmukK7XZ7lBCU3VIF4A71Qt/6ZiW/rNmeNu2OWpAKcC9HSAkZy0UtWN3JNL4myxE/i4X39s9XTrrT9+qlerE5ywxT+t53lqY+RWx8sqmrV1J7a5HlfewHTPHhAzKLgFIzttdfRP878Gdm9NSW8CI0Vx1UejKWg2x6E6u9ZedZzynn5siVPw8xXfRmruSkt7fOVG5/nV2+vE0z186G9B0z/0VIBTAdAm+jeqb1uvjMzEAL6OVX9TKyhtljYM/MdVsne7KZGK5Kg77Lb3TO+Mp5eeRXPf3fMGpCEP3A2EFie26pO0N+tHgkd/rQvdN11ytu6O5IP4ONLqkFIKkSbGb7nRWMR7VHptK1WI8X0/WWNH/sSB0ksHf2AQZruIAViJL4EongpwcIDaXI2N6Su030f7TAs4kT7264u27fAp85l64Z9KSw6rbep1tE5AaLo2mjBAeD9yN8/OA7bhA4w6GPUePNcbdetG37F7/K9WXZ76N3I+ktzLx3wynDPx6C042cBSdQX3N1rba4i/hVJsWqvSjLrMzDxFeiZ9SS+N3Jd0tqUet/DzAP7fAQDHEpe2ebdV9QAAAABJRU5ErkJggg==");
 
     private final String encodedString;
-    private BitmapDrawable cachedImage;
+
+    // We cache a bitmap, NOT a drawable. Drawables maintain view specific properties,
+    // such as their bounds, and caching them causes problems when the same drawable is used by
+    // multiple views.
+    private Bitmap cachedBitmap;
 
     private Drawables(final String encodedString) {
         this.encodedString = encodedString;
     }
 
-    public Drawable decodeImage(final Context context) {
-        if (cachedImage == null) {
-            final DisplayMetrics displayMetrics = context.getResources().getDisplayMetrics();
-            int scaledDensity = Dips.asIntPixels(displayMetrics.xdpi, context);
+    public Drawable createDrawable(final Context context) {
+        Bitmap bitmap = getBitmap();
+        BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);
 
+        final DisplayMetrics displayMetrics = context.getResources().getDisplayMetrics();
+        drawable.setTargetDensity(Dips.asIntPixels(displayMetrics.xdpi, context));
+        return drawable;
+    }
+
+    public Bitmap getBitmap() {
+        if (cachedBitmap == null) {
             byte[] rawImageData = Base64.decode(encodedString, Base64.DEFAULT);
-            cachedImage = new BitmapDrawable(new ByteArrayInputStream(rawImageData));
-            cachedImage.setTargetDensity(scaledDensity);
+            cachedBitmap = BitmapFactory.decodeByteArray(rawImageData, 0, rawImageData.length);
         }
-
-        return cachedImage;
+        return cachedBitmap;
     }
 
     public void clear() {
-        cachedImage = null;
+        cachedBitmap = null;
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/IntentUtils.java b/mopub-sdk/src/main/java/com/mopub/common/util/IntentUtils.java
deleted file mode 100644
index ac1a3d71..00000000
--- a/mopub-sdk/src/main/java/com/mopub/common/util/IntentUtils.java
+++ /dev/null
@@ -1,113 +0,0 @@
-package com.mopub.common.util;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.content.pm.ResolveInfo;
-import android.net.Uri;
-import android.os.Bundle;
-
-import com.mopub.common.logging.MoPubLog;
-
-import java.util.List;
-
-import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
-
-public class IntentUtils {
-    private static final String TWITTER_APPLICATION_DEEPLINK_URL = "twitter://timeline";
-    private static final String PLAY_GOOGLE_COM = "play.google.com";
-    private static final String MARKET_ANDROID_COM = "market.android.com";
-    private static final String MARKET = "market";
-    private static final String HTTP = "http";
-    private static final String HTTPS = "https";
-
-    private IntentUtils() {}
-
-    /**
-     * Adding FLAG_ACTIVITY_NEW_TASK with startActivityForResult will always result in a
-     * RESULT_CANCELED, so don't use it for Activity contexts.
-     */
-    public static Intent getStartActivityIntent(final Context context, final Class clazz, final Bundle extras) {
-        final Intent intent = new Intent(context, clazz);
-
-        if (!(context instanceof Activity)) {
-            intent.addFlags(FLAG_ACTIVITY_NEW_TASK);
-        }
-
-        if (extras != null) {
-            intent.putExtras(extras);
-        }
-
-        return intent;
-    }
-
-
-    public static boolean deviceCanHandleIntent(final Context context, final Intent intent) {
-        try {
-            final PackageManager packageManager = context.getPackageManager();
-            final List<ResolveInfo> activities = packageManager.queryIntentActivities(intent, 0);
-            return !activities.isEmpty();
-        } catch (NullPointerException e) {
-            return false;
-        }
-    }
-
-    public static boolean isHttpUrl(final String url) {
-        if (url == null) {
-            return false;
-        }
-
-        final String scheme = Uri.parse(url).getScheme();
-        return (HTTP.equals(scheme) || HTTPS.equals(scheme));
-    }
-
-    private static boolean isAppStoreUrl(final String url) {
-        if (url == null) {
-            return false;
-        }
-
-        final Uri uri = Uri.parse(url);
-        final String scheme = uri.getScheme();
-        final String host = uri.getHost();
-
-        if (PLAY_GOOGLE_COM.equals(host) || MARKET_ANDROID_COM.equals(host)) {
-            return true;
-        }
-
-        if (MARKET.equals(scheme)) {
-            return true;
-        }
-
-        return false;
-    }
-
-    public static boolean isDeepLink(final String url) {
-        return isAppStoreUrl(url) || !isHttpUrl(url);
-    }
-
-    public static boolean canHandleTwitterUrl(Context context) {
-        return canHandleApplicationUrl(context, TWITTER_APPLICATION_DEEPLINK_URL, false);
-    }
-
-    public static boolean canHandleApplicationUrl(Context context, String url) {
-        return canHandleApplicationUrl(context, url, true);
-    }
-
-    public static boolean canHandleApplicationUrl(Context context, String url, boolean logError) {
-        // Determine which activities can handle the intent
-        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
-
-        // If there are no relevant activities, don't follow the link
-        if (!IntentUtils.deviceCanHandleIntent(context, intent)) {
-            if (logError) {
-                MoPubLog.w("Could not handle application specific action: " + url + ". " +
-                        "You may be running in the emulator or another device which does not " +
-                        "have the required application.");
-            }
-            return false;
-        }
-
-        return true;
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/Intents.java b/mopub-sdk/src/main/java/com/mopub/common/util/Intents.java
new file mode 100644
index 00000000..ec1b70ed
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Intents.java
@@ -0,0 +1,182 @@
+package com.mopub.common.util;
+
+import android.app.Activity;
+import android.content.ActivityNotFoundException;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.net.Uri;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.exceptions.IntentNotResolvableException;
+import com.mopub.exceptions.UrlParseException;
+
+import java.util.List;
+
+import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
+import static com.mopub.common.Constants.HTTP;
+import static com.mopub.common.Constants.HTTPS;
+
+public class Intents {
+    private static final String PLAY_GOOGLE_COM = "play.google.com";
+    private static final String MARKET_ANDROID_COM = "market.android.com";
+    private static final String MARKET = "market";
+
+    private Intents() {}
+
+    public static void startActivity(@NonNull final Context context, @NonNull final Intent intent)
+            throws IntentNotResolvableException {
+        Preconditions.checkNotNull(context);
+        Preconditions.checkNotNull(intent);
+
+        if (!(context instanceof Activity)) {
+            intent.addFlags(FLAG_ACTIVITY_NEW_TASK);
+        }
+
+        try {
+            context.startActivity(intent);
+        } catch (ActivityNotFoundException e) {
+            throw new IntentNotResolvableException(e);
+        }
+    }
+
+    /**
+     * Adding FLAG_ACTIVITY_NEW_TASK with startActivityForResult will always result in a
+     * RESULT_CANCELED, so don't use it for Activity contexts.
+     */
+    public static Intent getStartActivityIntent(@NonNull final Context context,
+            @NonNull final Class clazz, @Nullable final Bundle extras) {
+        final Intent intent = new Intent(context, clazz);
+
+        if (!(context instanceof Activity)) {
+            intent.addFlags(FLAG_ACTIVITY_NEW_TASK);
+        }
+
+        if (extras != null) {
+            intent.putExtras(extras);
+        }
+
+        return intent;
+    }
+
+    public static boolean deviceCanHandleIntent(@NonNull final Context context,
+            @NonNull final Intent intent) {
+        try {
+            final PackageManager packageManager = context.getPackageManager();
+            final List<ResolveInfo> activities = packageManager.queryIntentActivities(intent, 0);
+            return !activities.isEmpty();
+        } catch (NullPointerException e) {
+            return false;
+        }
+    }
+
+    public static boolean isHttpUrl(final String url) {
+        if (url == null) {
+            return false;
+        }
+
+        final String scheme = Uri.parse(url).getScheme();
+        return (HTTP.equals(scheme) || HTTPS.equals(scheme));
+    }
+
+    private static boolean isAppStoreUrl(final String url) {
+        if (url == null) {
+            return false;
+        }
+
+        final Uri uri = Uri.parse(url);
+        final String scheme = uri.getScheme();
+        final String host = uri.getHost();
+
+        if (PLAY_GOOGLE_COM.equals(host) || MARKET_ANDROID_COM.equals(host)) {
+            return true;
+        }
+
+        if (MARKET.equals(scheme)) {
+            return true;
+        }
+
+        return false;
+    }
+
+    public static boolean isDeepLink(final String url) {
+        return isAppStoreUrl(url) || !isHttpUrl(url);
+    }
+
+    public static boolean canHandleApplicationUrl(final Context context, final String url) {
+        return canHandleApplicationUrl(context, url, true);
+    }
+
+    public static boolean canHandleApplicationUrl(final Context context, final String url,
+            final boolean logError) {
+        // Determine which activities can handle the intent
+        final Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
+
+        // If there are no relevant activities, don't follow the link
+        if (!Intents.deviceCanHandleIntent(context, intent)) {
+            if (logError) {
+                MoPubLog.w("Could not handle application specific action: " + url + ". " +
+                        "You may be running in the emulator or another device which does not " +
+                        "have the required application.");
+            }
+            return false;
+        }
+
+        return true;
+    }
+
+    public static boolean isNativeBrowserScheme(@NonNull final String url) {
+        return url.startsWith("mopubnativebrowser://");
+    }
+
+    public static boolean isAboutScheme(@NonNull final String url) {
+        return "about".equals(Uri.parse(url).getScheme());
+    }
+
+    /**
+     * Native Browser Scheme URLs provide a means for advertisers to include links that click out to
+     * an external browser, rather than the MoPub in-app browser. Properly formatted native browser
+     * URLs take the form of "mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.mopub.com".
+     *
+     * @param url
+     * @return An Intent that will open an app-external browser taking the user to a page specified
+     * in the query parameter of the passed-in url
+     * @throws UrlParseException if the provided url has an invalid format or is non-hierarchical
+     */
+    public static Intent intentForNativeBrowserScheme(@NonNull final String url)
+            throws UrlParseException {
+        Preconditions.checkNotNull(url);
+
+        if (!isNativeBrowserScheme(url)) {
+            throw new UrlParseException("URL does not have mopubnativebrowser:// scheme.");
+        }
+
+        final Uri uri = Uri.parse(url);
+
+        if (!"navigate".equals(uri.getHost())) {
+            throw new UrlParseException("URL missing 'navigate' host parameter.");
+        }
+
+        final String urlToOpenInNativeBrowser;
+        try {
+            urlToOpenInNativeBrowser = uri.getQueryParameter("url");
+        } catch (UnsupportedOperationException e) {
+            // Accessing query parameters only makes sense for hierarchical URIs as per:
+            // http://developer.android.com/reference/android/net/Uri.html#getQueryParameter(java.lang.String)
+            MoPubLog.w("Could not handle url: " + url);
+            throw new UrlParseException("Passed-in URL did not create a hierarchical URI.");
+        }
+
+        if (urlToOpenInNativeBrowser == null) {
+            throw new UrlParseException("URL missing 'url' query parameter.");
+        }
+
+        final Uri intentUri = Uri.parse(urlToOpenInNativeBrowser);
+        return new Intent(Intent.ACTION_VIEW, intentUri);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/Json.java b/mopub-sdk/src/main/java/com/mopub/common/util/Json.java
index e33ac0b3..91e0e614 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/Json.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Json.java
@@ -1,5 +1,7 @@
 package com.mopub.common.util;
 
+import android.text.TextUtils;
+
 import com.mopub.common.logging.MoPubLog;
 
 import org.json.JSONArray;
@@ -12,10 +14,10 @@
 import java.util.Map;
 
 public class Json {
-    public static Map<String, String> jsonStringToMap(String jsonParams) throws Exception {
+    public static Map<String, String> jsonStringToMap(String jsonParams) throws JSONException {
         Map<String, String> jsonMap = new HashMap<String, String>();
 
-        if (jsonParams == null || jsonParams.equals("")) return jsonMap;
+        if (TextUtils.isEmpty(jsonParams)) return jsonMap;
 
         JSONObject jsonObject = (JSONObject) new JSONTokener(jsonParams).nextValue();
         Iterator<?> keys = jsonObject.keys();
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/ManifestUtils.java b/mopub-sdk/src/main/java/com/mopub/common/util/ManifestUtils.java
index aff7bb39..aaf7b4bf 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/ManifestUtils.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/ManifestUtils.java
@@ -1,21 +1,37 @@
 package com.mopub.common.util;
 
+import android.annotation.TargetApi;
 import android.app.Activity;
+import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
+import android.content.pm.ActivityInfo;
 import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.support.annotation.NonNull;
 import android.view.Gravity;
 import android.widget.Toast;
 
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
 
 import java.util.ArrayList;
 import java.util.List;
 
+import static com.mopub.common.util.VersionCode.HONEYCOMB_MR2;
+import static com.mopub.common.util.VersionCode.currentApiLevel;
+
 public class ManifestUtils {
     private ManifestUtils() {}
 
     private static final List<Class<? extends Activity>> REQUIRED_WEB_VIEW_SDK_ACTIVITIES;
+    private static FlagCheckUtil sFlagCheckUtil = new FlagCheckUtil();
+
+    /**
+     * This class maintains two different lists of required Activity permissions,
+     * for the WebView and Native SDKs.
+     */
     static {
         REQUIRED_WEB_VIEW_SDK_ACTIVITIES = new ArrayList<Class<? extends Activity>>(4);
         // As a convenience, full class paths are provided here, in case the MoPub SDK was imported
@@ -32,90 +48,233 @@ private ManifestUtils() {}
         REQUIRED_NATIVE_SDK_ACTIVITIES.add(com.mopub.common.MoPubBrowser.class);
     }
 
-    public static void checkWebViewActivitiesDeclared(final Context context) {
+    public static void checkWebViewActivitiesDeclared(@NonNull final Context context) {
+        if (!Preconditions.NoThrow.checkNotNull(context, "context is not allowed to be null")) {
+            return;
+        }
+
         displayWarningForMissingActivities(context, REQUIRED_WEB_VIEW_SDK_ACTIVITIES);
+        displayWarningForMisconfiguredActivities(context, REQUIRED_WEB_VIEW_SDK_ACTIVITIES);
     }
 
-    public static void checkNativeActivitiesDeclared(final Context context) {
+    public static void checkNativeActivitiesDeclared(@NonNull final Context context) {
+        if (!Preconditions.NoThrow.checkNotNull(context, "context is not allowed to be null")) {
+            return;
+        }
+
         displayWarningForMissingActivities(context, REQUIRED_NATIVE_SDK_ACTIVITIES);
+        displayWarningForMisconfiguredActivities(context, REQUIRED_NATIVE_SDK_ACTIVITIES);
     }
 
     /**
      * This method is intended to display a warning to developers when they have accidentally
-     * omitted Activity declarations in their application's AndroidManifest. This class maintains
-     * two different lists of required Activity permissions, for the WebView and Native SDKs.
+     * omitted Activity declarations in their application's AndroidManifest.
      * Calling this when there are inadequate permissions will always Log a warning to the
      * developer, and if the the application is debuggable, it will also display a Toast.
      */
-    static void displayWarningForMissingActivities(final Context context,
-            final List<Class<? extends Activity>> requiredActivities) {
-        if (context == null) {
-            return;
-        }
+    @VisibleForTesting
+    static void displayWarningForMissingActivities(@NonNull final Context context,
+            @NonNull final List<Class<? extends Activity>> requiredActivities) {
 
-        final List<String> undeclaredActivities = getUndeclaredActivities(context, requiredActivities);
+        final List<Class<? extends Activity>> undeclaredActivities =
+                filterDeclaredActivities(context, requiredActivities, false);
 
         if (undeclaredActivities.isEmpty()) {
             return;
         }
 
-        // If the application is debuggable, display a loud toast
-        if (isDebuggable(context)) {
-            final String message =  "ERROR: YOUR MOPUB INTEGRATION IS INCOMPLETE.\n" +
-                    "Check logcat and update your AndroidManifest.xml with the correct activities.";
-            final Toast toast = Toast.makeText(context, message, Toast.LENGTH_LONG);
-            toast.setGravity(Gravity.FILL_HORIZONTAL, 0, 0);
-            toast.show();
-        }
+        logWarningToast(context);
 
         // Regardless, log a warning
         logMissingActivities(undeclaredActivities);
     }
 
-    static boolean isDebuggable(final Context context) {
-        if (context == null || context.getApplicationInfo() == null) {
-            return false;
+    /**
+     * This method is intended to display a warning to developers when they have accidentally
+     * omitted configChanges values from Activity declarations in their application's AndroidManifest.
+     * Calling this when there are inadequate permissions will always Log a warning to the
+     * developer, and if the the application is debuggable, it will also display a Toast.
+     */
+    @VisibleForTesting
+    static void displayWarningForMisconfiguredActivities(@NonNull final Context context,
+            @NonNull final List<Class<? extends Activity>> requiredActivities) {
+
+        final List<Class<? extends Activity>> declaredActivities =
+                filterDeclaredActivities(context, requiredActivities, true);
+        final List<Class<? extends Activity>> misconfiguredActivities =
+                getMisconfiguredActivities(context, declaredActivities);
+
+        if (misconfiguredActivities.isEmpty()) {
+            return;
         }
 
-        final int applicationFlags = context.getApplicationInfo().flags;
+        logWarningToast(context);
+
+        // Regardless, log a warning
+        logMisconfiguredActivities(context, misconfiguredActivities);
+    }
 
+    public static boolean isDebuggable(@NonNull final Context context) {
+        final int applicationFlags = context.getApplicationInfo().flags;
         return Utils.bitMaskContainsFlag(applicationFlags, ApplicationInfo.FLAG_DEBUGGABLE);
     }
 
-    private static List<String> getUndeclaredActivities(final Context context,
-            List<Class<? extends Activity>> requiredActivities) {
-        final List<String> undeclaredActivities = new ArrayList<String>();
+    /**
+     * Filters in activities to be returned based on matching their declaration state
+     * in the Android Manifest with the isDeclared param.
+     *
+     * @param context
+     * @param requiredActivities activities to filter against
+     * @param isDeclared desired declaration state of activities in Android Manifest to be returned
+     * @return the list of filtered in activities
+     */
+    private static List<Class<? extends Activity>> filterDeclaredActivities(@NonNull final Context context,
+            @NonNull final List<Class<? extends Activity>> requiredActivities,
+            final boolean isDeclared) {
+        final List<Class<? extends Activity>> activities =
+                new ArrayList<Class<? extends Activity>>();
 
         for (final Class<? extends Activity> activityClass : requiredActivities) {
             final Intent intent = new Intent(context, activityClass);
 
-            if (!IntentUtils.deviceCanHandleIntent(context, intent)) {
-                undeclaredActivities.add(activityClass.getName());
+            if (Intents.deviceCanHandleIntent(context, intent) == isDeclared) {
+                activities.add(activityClass);
             }
         }
 
-        return undeclaredActivities;
+        return activities;
     }
 
-    private static void logMissingActivities(final List<String> undeclaredActivities) {
+    @TargetApi(13)
+    private static List<Class<? extends Activity>> getMisconfiguredActivities(@NonNull final Context context,
+            @NonNull final List<Class<? extends Activity>> activities) {
+        final List<Class<? extends Activity>> misconfiguredActivities =
+                new ArrayList<Class<? extends Activity>>();
+
+        for (final Class<? extends Activity> activity : activities) {
+            ActivityConfigChanges activityConfigChanges;
+            try {
+                activityConfigChanges = getActivityConfigChanges(context, activity);
+            } catch (PackageManager.NameNotFoundException e) {
+                continue;
+            }
+
+            if (!activityConfigChanges.hasKeyboardHidden || !activityConfigChanges.hasOrientation || !activityConfigChanges.hasScreenSize) {
+                misconfiguredActivities.add(activity);
+            }
+        }
+
+        return misconfiguredActivities;
+    }
+
+    private static void logMissingActivities(@NonNull final List<Class<? extends Activity>> undeclaredActivities) {
         final StringBuilder stringBuilder =
                 new StringBuilder("AndroidManifest permissions for the following required MoPub activities are missing:\n");
 
-        for (final String activity : undeclaredActivities) {
-            stringBuilder.append("\n\t").append(activity);
+        for (final Class<? extends Activity> activity : undeclaredActivities) {
+            stringBuilder.append("\n\t").append(activity.getName());
+        }
+        stringBuilder.append("\n\nPlease update your manifest to include them.");
+
+        MoPubLog.w(stringBuilder.toString());
+    }
+
+    private static void logMisconfiguredActivities(@NonNull Context context,
+            @NonNull final List<Class<? extends Activity>> misconfiguredActivities) {
+        final StringBuilder stringBuilder =
+                new StringBuilder("In AndroidManifest, the android:configChanges param is missing values for the following MoPub activities:\n");
+
+        for (final Class<? extends Activity> activity: misconfiguredActivities) {
+
+            ActivityConfigChanges activityConfigChanges;
+            try {
+                activityConfigChanges = getActivityConfigChanges(context, activity);
+            } catch (PackageManager.NameNotFoundException e) {
+                continue;
+            }
+
+            if (!activityConfigChanges.hasKeyboardHidden) {
+                stringBuilder.append("\n\tThe android:configChanges param for activity " + activity.getName() + " must include keyboardHidden.");
+            }
+            if (!activityConfigChanges.hasOrientation) {
+                stringBuilder.append("\n\tThe android:configChanges param for activity " + activity.getName() + " must include orientation.");
+            }
+            if (!activityConfigChanges.hasScreenSize) {
+                stringBuilder.append("\n\tThe android:configChanges param for activity " + activity.getName() + " must include screenSize.");
+            }
         }
+
         stringBuilder.append("\n\nPlease update your manifest to include them.");
 
         MoPubLog.w(stringBuilder.toString());
     }
 
+    private static ActivityConfigChanges getActivityConfigChanges(@NonNull Context context,
+            @NonNull Class<? extends Activity> activity) throws PackageManager.NameNotFoundException {
+        ActivityInfo activityInfo;
+
+        // This line can throw NameNotFoundException but we don't expect it to happen since we
+        // should only be operating on declared activities
+        activityInfo = context.getPackageManager()
+                .getActivityInfo(new ComponentName(context, activity.getName()), 0);
+
+        ActivityConfigChanges activityConfigChanges = new ActivityConfigChanges();
+        activityConfigChanges.hasKeyboardHidden = sFlagCheckUtil.hasFlag(activity, activityInfo.configChanges, ActivityInfo.CONFIG_KEYBOARD_HIDDEN);
+        activityConfigChanges.hasOrientation = sFlagCheckUtil.hasFlag(activity, activityInfo.configChanges, ActivityInfo.CONFIG_ORIENTATION);
+        activityConfigChanges.hasScreenSize = true;
+
+        // For screenSize, only set to false if the API level and target API are >= 13
+        // If the target API is < 13, then Android will implement its own backwards compatibility
+        if (currentApiLevel().isAtLeast(HONEYCOMB_MR2) &&
+                context.getApplicationInfo().targetSdkVersion >= VersionCode.HONEYCOMB_MR2.getApiLevel()) {
+            activityConfigChanges.hasScreenSize = sFlagCheckUtil.hasFlag(activity, activityInfo.configChanges, ActivityInfo.CONFIG_SCREEN_SIZE);
+        }
+
+        return activityConfigChanges;
+    }
+
+    private static void logWarningToast(@NonNull final Context context) {
+        // If the application is debuggable, display a loud toast
+        if (isDebuggable(context)) {
+            final String message = "ERROR: YOUR MOPUB INTEGRATION IS INCOMPLETE.\n" +
+                    "Check logcat and update your AndroidManifest.xml with the correct activities and configuration.";
+            final Toast toast = Toast.makeText(context, message, Toast.LENGTH_LONG);
+            toast.setGravity(Gravity.FILL_HORIZONTAL, 0, 0);
+            toast.show();
+        }
+    }
+
+    private static class ActivityConfigChanges {
+        public boolean hasKeyboardHidden;
+        public boolean hasOrientation;
+        public boolean hasScreenSize;
+    }
+
+    @VisibleForTesting
     @Deprecated // for testing
     static List<Class<? extends Activity>> getRequiredWebViewSdkActivities() {
         return REQUIRED_WEB_VIEW_SDK_ACTIVITIES;
     }
 
+    @VisibleForTesting
     @Deprecated // for testing
     static List<Class<? extends Activity>> getRequiredNativeSdkActivities() {
         return REQUIRED_NATIVE_SDK_ACTIVITIES;
     }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    static void setFlagCheckUtil(final FlagCheckUtil flagCheckUtil) {
+        sFlagCheckUtil = flagCheckUtil;
+    }
+
+    static class FlagCheckUtil {
+        // We're only passing in the Class param here to ease testing and
+        // allow mocks to match on it
+        public boolean hasFlag(@SuppressWarnings("unused") Class clazz,
+                int bitMask,
+                int flag) {
+            return Utils.bitMaskContainsFlag(bitMask, flag);
+        }
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/MoPubCollections.java b/mopub-sdk/src/main/java/com/mopub/common/util/MoPubCollections.java
new file mode 100644
index 00000000..a83bec24
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/MoPubCollections.java
@@ -0,0 +1,15 @@
+package com.mopub.common.util;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import java.util.Collection;
+import java.util.Collections;
+
+public class MoPubCollections {
+    public static <T> void addAllNonNull(@NonNull final Collection<? super T> c,
+            @Nullable final T... a) {
+        Collections.addAll(c, a);
+        c.removeAll(Collections.singleton(null));
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/Reflection.java b/mopub-sdk/src/main/java/com/mopub/common/util/Reflection.java
index bfb34e9a..3efa8598 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/Reflection.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Reflection.java
@@ -1,5 +1,11 @@
 package com.mopub.common.util;
 
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.List;
@@ -88,4 +94,17 @@ public static boolean classFound(final String className) {
             return false;
         }
     }
+
+    public static <T> T instantiateClassWithEmptyConstructor(@NonNull final String className,
+            @NonNull final Class<? extends T> superclass)
+            throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException,
+            InvocationTargetException, InstantiationException, NullPointerException {
+        Preconditions.checkNotNull(className);
+
+        final Class<? extends T> clazz = Class.forName(className).asSubclass(superclass);
+        final Constructor<? extends T> constructor = clazz.getDeclaredConstructor((Class[]) null);
+        constructor.setAccessible(true);
+
+        return constructor.newInstance();
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/ResponseHeader.java b/mopub-sdk/src/main/java/com/mopub/common/util/ResponseHeader.java
index 4e0987b7..6e407f85 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/ResponseHeader.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/ResponseHeader.java
@@ -3,7 +3,7 @@
 public enum ResponseHeader {
     AD_TIMEOUT("X-AdTimeout"),
     AD_TYPE("X-Adtype"),
-    CLICKTHROUGH_URL("X-Clickthrough"),
+    CLICK_TRACKING_URL("X-Clickthrough"),
     CUSTOM_EVENT_DATA("X-Custom-Event-Class-Data"),
     CUSTOM_EVENT_NAME("X-Custom-Event-Class-Name"),
     CUSTOM_EVENT_HTML_DATA("X-Custom-Event-Html-Data"),
@@ -15,6 +15,7 @@
     REDIRECT_URL("X-Launchpage"),
     NATIVE_PARAMS("X-Nativeparams"),
     NETWORK_TYPE("X-Networktype"),
+    ORIENTATION("X-Orientation"),
     REFRESH_TIME("X-Refreshtime"),
     SCROLLABLE("X-Scrollable"),
     WARMUP("X-Warmup"),
@@ -22,6 +23,7 @@
 
     LOCATION("Location"),
     USER_AGENT("User-Agent"),
+    ACCEPT_LANGUAGE("Accept-Language"),
 
     @Deprecated CUSTOM_SELECTOR("X-Customselector");
 
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/Strings.java b/mopub-sdk/src/main/java/com/mopub/common/util/Strings.java
index dd20902e..bcb949c7 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/Strings.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Strings.java
@@ -1,12 +1,19 @@
 package com.mopub.common.util;
 
+import android.text.TextUtils;
+
 import java.io.IOException;
 import java.io.InputStream;
+import java.util.regex.Pattern;
 
 public class Strings {
+    // Regex patterns
+    private static Pattern percentagePattern = Pattern.compile("((\\d{1,2})|(100))%");
+    private static Pattern absolutePattern = Pattern.compile("\\d{2}:\\d{2}:\\d{2}(.\\d{3})?");
+
     public static String fromStream(InputStream inputStream) throws IOException {
         int numberBytesRead = 0;
-        StringBuffer out = new StringBuffer();
+        StringBuilder out = new StringBuilder();
         byte[] bytes = new byte[4096];
 
         while (numberBytesRead != -1) {
@@ -19,11 +26,24 @@ public static String fromStream(InputStream inputStream) throws IOException {
         return out.toString();
     }
 
-    public static boolean isEmpty(String input) {
-        if (input == null) {
-            return false;
-        } else {
-            return input.length() == 0;
+    public static boolean isPercentageTracker(String progressValue) {
+        return !TextUtils.isEmpty(progressValue)
+                && percentagePattern.matcher(progressValue).matches();
+    }
+
+    public static boolean isAbsoluteTracker(String progressValue) {
+        return !TextUtils.isEmpty(progressValue)
+                && absolutePattern.matcher(progressValue).matches();
+    }
+
+    public static Integer parseAbsoluteOffset(String progressValue) {
+        final String[] split = progressValue.split(":");
+        if (split.length != 3) {
+            return null;
         }
+
+        return Integer.parseInt(split[0]) * 60 * 60 * 1000 // Hours
+                + Integer.parseInt(split[1]) * 60 * 1000 // Minutes
+                + (int)(Float.parseFloat(split[2]) * 1000);
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/Timer.java b/mopub-sdk/src/main/java/com/mopub/common/util/Timer.java
new file mode 100644
index 00000000..b53c4de3
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Timer.java
@@ -0,0 +1,38 @@
+package com.mopub.common.util;
+
+import java.util.concurrent.TimeUnit;
+
+public class Timer {
+    private static enum State { STARTED, STOPPED }
+    private long mStopTimeNanos;
+    private long mStartTimeNanos;
+    private State mState;
+
+    public Timer() {
+        mState = State.STOPPED;
+    }
+
+    public void start() {
+        // System.nanoTime isn't affected by changing the system time
+        mStartTimeNanos = System.nanoTime();
+        mState = State.STARTED;
+    }
+
+    public void stop() {
+        if (mState != State.STARTED) {
+            throw new IllegalStateException("EventTimer was not started.");
+        }
+        mState = State.STOPPED;
+        mStopTimeNanos = System.nanoTime();
+    }
+
+    public long getTime() {
+        long endTime;
+        if (mState == State.STARTED) {
+            endTime = System.nanoTime();
+        } else {
+            endTime = mStopTimeNanos;
+        }
+        return TimeUnit.MILLISECONDS.convert(endTime - mStartTimeNanos, TimeUnit.NANOSECONDS);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/Utils.java b/mopub-sdk/src/main/java/com/mopub/common/util/Utils.java
index ae829979..c4b620de 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/util/Utils.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Utils.java
@@ -1,6 +1,9 @@
 package com.mopub.common.util;
 
+import com.mopub.common.VisibleForTesting;
+
 import java.security.MessageDigest;
+import java.util.Locale;
 import java.util.concurrent.atomic.AtomicLong;
 
 public class Utils {
@@ -19,7 +22,7 @@ public static String sha1(String string) {
                 stringBuilder.append(String.format("%02X", b));
             }
 
-            return stringBuilder.toString().toLowerCase();
+            return stringBuilder.toString().toLowerCase(Locale.US);
         } catch (Exception e) {
             return "";
         }
diff --git a/mopub-sdk/src/main/java/com/mopub/exceptions/IntentNotResolvableException.java b/mopub-sdk/src/main/java/com/mopub/exceptions/IntentNotResolvableException.java
new file mode 100644
index 00000000..aa114d2a
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/exceptions/IntentNotResolvableException.java
@@ -0,0 +1,7 @@
+package com.mopub.exceptions;
+
+public class IntentNotResolvableException extends Exception {
+    public IntentNotResolvableException(Throwable throwable) {
+        super(throwable);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/exceptions/UrlParseException.java b/mopub-sdk/src/main/java/com/mopub/exceptions/UrlParseException.java
new file mode 100644
index 00000000..cca732da
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/exceptions/UrlParseException.java
@@ -0,0 +1,11 @@
+package com.mopub.exceptions;
+
+public class UrlParseException extends Exception {
+    public UrlParseException(final String detailMessage) {
+        super(detailMessage);
+    }
+
+    public UrlParseException(final Throwable throwable) {
+        super(throwable);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertGestureListener.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertGestureListener.java
index 57567c9e..ced94fa6 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertGestureListener.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertGestureListener.java
@@ -1,13 +1,17 @@
 package com.mopub.mobileads;
 
+import android.support.annotation.Nullable;
 import android.view.GestureDetector;
 import android.view.MotionEvent;
 import android.view.View;
 
+import com.mopub.common.AdReport;
+
 public class AdAlertGestureListener extends GestureDetector.SimpleOnGestureListener{
     private static final int MINIMUM_NUMBER_OF_ZIGZAGS_TO_FLAG = 4;
     private static final float MAXIMUM_THRESHOLD_X_IN_DIPS = 100;
-    private static final float MAXIMUM_THRESHOLD_Y_IN_DIPS = 50;
+    private static final float MAXIMUM_THRESHOLD_Y_IN_DIPS = 100;
+    @Nullable private final AdReport mAdReport;
 
     private float mCurrentThresholdInDips = MAXIMUM_THRESHOLD_X_IN_DIPS;
     private float mPreviousPositionX;
@@ -21,15 +25,14 @@
     private ZigZagState mCurrentZigZagState = ZigZagState.UNSET;
 
     private View mView;
-    private AdConfiguration mAdConfiguration;
 
-    AdAlertGestureListener(View view, AdConfiguration adConfiguration) {
+    AdAlertGestureListener(View view, @Nullable AdReport adReport) {
         super();
         if (view != null && view.getWidth() > 0) {
             mCurrentThresholdInDips = Math.min(MAXIMUM_THRESHOLD_X_IN_DIPS, view.getWidth() / 3f);
         }
         mView = view;
-        mAdConfiguration = adConfiguration;
+        mAdReport = adReport;
     }
 
     @Override
@@ -69,7 +72,7 @@ public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float d
 
     void finishGestureDetection() {
         if (mCurrentZigZagState == mCurrentZigZagState.FINISHED) {
-            mAdAlertReporter = new AdAlertReporter(mView.getContext(), mView, mAdConfiguration);
+            mAdAlertReporter = new AdAlertReporter(mView.getContext(), mView, mAdReport);
             mAdAlertReporter.send();
         }
         reset();
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertReporter.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertReporter.java
index 47ac6f49..1516ee64 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertReporter.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertReporter.java
@@ -4,15 +4,21 @@
 import android.content.Intent;
 import android.graphics.Bitmap;
 import android.net.Uri;
+import android.support.annotation.Nullable;
+import android.util.Base64;
 import android.view.View;
+
+import com.mopub.common.AdReport;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.util.DateAndTime;
 import com.mopub.common.util.Streams;
-import com.mopub.mobileads.util.Base64;
 
-import java.io.*;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
 import java.text.SimpleDateFormat;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Locale;
 
 public class AdAlertReporter {
     private static final String EMAIL_RECIPIENT = "creative-review@mopub.com";
@@ -28,30 +34,32 @@
 
     private final View mView;
     private final Context mContext;
-    private final AdConfiguration mAdConfiguration;
     private Intent mEmailIntent;
     private ArrayList<Uri> mEmailAttachments;
     private String mParameters;
     private String mResponse;
 
-    public AdAlertReporter(final Context context, final View view, final AdConfiguration adConfiguration) {
+    public AdAlertReporter(final Context context, final View view, @Nullable final AdReport adReport) {
         mView = view;
         mContext = context;
-        mAdConfiguration = adConfiguration;
 
         mEmailAttachments = new ArrayList<Uri>();
 
-        SimpleDateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT_PATTERN);
+        SimpleDateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT_PATTERN, Locale.US);
         mDateString = dateFormat.format(DateAndTime.now());
 
         initEmailIntent();
         Bitmap screenShot = takeScreenShot();
         String screenShotString = convertBitmapInWEBPToBase64EncodedString(screenShot);
-        mParameters = formParameters();
-        mResponse = getResponseString();
+        mParameters = "";
+        mResponse = "";
+        if (adReport != null) {
+            mParameters = adReport.toString();
+            mResponse = adReport.getResponseString();
+        }
 
         addEmailSubject();
-        addEmailBody( new String[]{ mParameters, mResponse, screenShotString });
+        addEmailBody(mParameters, mResponse, screenShotString);
         addTextAttachment(PARAMETERS_FILENAME, mParameters);
         addTextAttachment(MARKUP_FILENAME, mResponse);
         addImageAttachment(SCREEN_SHOT_FILENAME, screenShot);
@@ -63,7 +71,6 @@ public void send() {
         Intent chooserIntent = Intent.createChooser(mEmailIntent, "Send Email...");
         chooserIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
         mContext.startActivity(chooserIntent);
-
     }
 
     private void initEmailIntent() {
@@ -108,38 +115,6 @@ private String convertBitmapInWEBPToBase64EncodedString(Bitmap bitmap) {
         return result;
     }
 
-    private String formParameters() {
-        StringBuilder parameters = new StringBuilder();
-
-        if (mAdConfiguration != null) {
-            appendKeyValue(parameters, "sdk_version", mAdConfiguration.getSdkVersion());
-            appendKeyValue(parameters, "creative_id", mAdConfiguration.getDspCreativeId());
-            appendKeyValue(parameters, "platform_version", Integer.toString(mAdConfiguration.getPlatformVersion()));
-            appendKeyValue(parameters, "device_model", mAdConfiguration.getDeviceModel());
-            appendKeyValue(parameters, "ad_unit_id", mAdConfiguration.getAdUnitId());
-            appendKeyValue(parameters, "device_locale", mAdConfiguration.getDeviceLocale());
-            appendKeyValue(parameters, "device_id", mAdConfiguration.getHashedUdid());
-            appendKeyValue(parameters, "network_type", mAdConfiguration.getNetworkType());
-            appendKeyValue(parameters, "platform", mAdConfiguration.getPlatform());
-            appendKeyValue(parameters, "timestamp", getFormattedTimeStamp(mAdConfiguration.getTimeStamp()));
-            appendKeyValue(parameters, "ad_type", mAdConfiguration.getAdType());
-            appendKeyValue(parameters, "ad_size", "{" + mAdConfiguration.getWidth() + ", " + mAdConfiguration.getHeight() + "}");
-        }
-
-        return parameters.toString();
-    }
-
-    private String getResponseString() {
-        return (mAdConfiguration != null) ? mAdConfiguration.getResponseString() : "";
-    }
-
-    private void appendKeyValue(StringBuilder parameters, String key, String value) {
-        parameters.append(key);
-        parameters.append(" : ");
-        parameters.append(value);
-        parameters.append("\n");
-    }
-
     private void addEmailSubject() {
         mEmailIntent.putExtra(Intent.EXTRA_SUBJECT, "New creative violation report - " + mDateString);
     }
@@ -198,15 +173,6 @@ private void addTextAttachment(String fileName, String body) {
         }
     }
 
-    private String getFormattedTimeStamp(long timeStamp) {
-        if (timeStamp != -1) {
-            SimpleDateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT_PATTERN);
-            return dateFormat.format(new Date(timeStamp));
-        } else {
-            return null;
-        }
-    }
-
     @Deprecated // for testing
     Intent getEmailIntent() {
         return mEmailIntent;
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdConfiguration.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdConfiguration.java
deleted file mode 100644
index 236c577b..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdConfiguration.java
+++ /dev/null
@@ -1,287 +0,0 @@
-package com.mopub.mobileads;
-
-import android.content.Context;
-import android.os.Build;
-import android.provider.Settings;
-import android.webkit.WebView;
-import com.mopub.common.MoPub;
-import com.mopub.common.util.DateAndTime;
-import com.mopub.common.util.Utils;
-import com.mopub.common.util.VersionCode;
-import org.apache.http.HttpResponse;
-
-import java.io.Serializable;
-import java.util.Map;
-
-import static com.mopub.common.util.ResponseHeader.AD_TIMEOUT;
-import static com.mopub.common.util.ResponseHeader.AD_TYPE;
-import static com.mopub.common.util.ResponseHeader.CLICKTHROUGH_URL;
-import static com.mopub.common.util.ResponseHeader.DSP_CREATIVE_ID;
-import static com.mopub.common.util.ResponseHeader.FAIL_URL;
-import static com.mopub.common.util.ResponseHeader.HEIGHT;
-import static com.mopub.common.util.ResponseHeader.IMPRESSION_URL;
-import static com.mopub.common.util.ResponseHeader.NETWORK_TYPE;
-import static com.mopub.common.util.ResponseHeader.REDIRECT_URL;
-import static com.mopub.common.util.ResponseHeader.REFRESH_TIME;
-import static com.mopub.common.util.ResponseHeader.WIDTH;
-import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
-import static com.mopub.mobileads.util.HttpResponses.extractHeader;
-import static com.mopub.mobileads.util.HttpResponses.extractIntHeader;
-import static com.mopub.mobileads.util.HttpResponses.extractIntegerHeader;
-
-public class AdConfiguration implements Serializable {
-    private static final long serialVersionUID = 0L;
-
-    private static final int MINIMUM_REFRESH_TIME_MILLISECONDS = 10000;
-    private static final int DEFAULT_REFRESH_TIME_MILLISECONDS = 60000;
-    private static final String mPlatform = "Android";
-    private final String mSdkVersion;
-
-    private final String mHashedUdid;
-    private final String mUserAgent;
-    private final String mDeviceLocale;
-    private final String mDeviceModel;
-    private final int mPlatformVersion;
-
-    private long mBroadcastIdentifier;
-    private String mResponseString;
-    private String mAdUnitId;
-
-    private String mAdType;
-    private String mNetworkType;
-    private String mRedirectUrl;
-    private String mClickthroughUrl;
-    private String mFailUrl;
-    private String mImpressionUrl;
-    private long mTimeStamp;
-    private int mWidth;
-    private int mHeight;
-    private Integer mAdTimeoutDelay;
-    private int mRefreshTimeMilliseconds;
-    private String mDspCreativeId;
-
-    static AdConfiguration extractFromMap(Map<String,Object> map) {
-        if (map == null) {
-            return null;
-        }
-
-        Object adConfiguration = map.get(AD_CONFIGURATION_KEY);
-
-        if (adConfiguration instanceof AdConfiguration) {
-            return (AdConfiguration) adConfiguration;
-        }
-
-        return null;
-    }
-
-    AdConfiguration(final Context context) {
-        setDefaults();
-
-        if (context != null) {
-            String udid = Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID);
-            mHashedUdid = Utils.sha1((udid != null) ? udid : "");
-
-            mUserAgent = new WebView(context).getSettings().getUserAgentString();
-            mDeviceLocale = context.getResources().getConfiguration().locale.toString();
-        } else {
-            mHashedUdid = null;
-            mUserAgent = null;
-            mDeviceLocale = null;
-        }
-
-        mBroadcastIdentifier = Utils.generateUniqueId();
-        mDeviceModel = Build.MANUFACTURER + " " + Build.MODEL;
-        mPlatformVersion = VersionCode.currentApiLevel().getApiLevel();
-        mSdkVersion = MoPub.SDK_VERSION;
-    }
-
-    void cleanup() {
-        setDefaults();
-    }
-
-    void addHttpResponse(final HttpResponse httpResponse) {
-        mAdType = extractHeader(httpResponse, AD_TYPE);
-
-        // Set the network type of the ad.
-        mNetworkType = extractHeader(httpResponse, NETWORK_TYPE);
-
-        // Set the redirect URL prefix: navigating to any matching URLs will send us to the browser.
-        mRedirectUrl = extractHeader(httpResponse, REDIRECT_URL);
-
-        // Set the URL that is prepended to links for click-tracking purposes.
-        mClickthroughUrl = extractHeader(httpResponse, CLICKTHROUGH_URL);
-
-        // Set the fall-back URL to be used if the current request fails.
-        mFailUrl = extractHeader(httpResponse, FAIL_URL);
-
-        // Set the URL to be used for impression tracking.
-        mImpressionUrl = extractHeader(httpResponse, IMPRESSION_URL);
-
-        // Set the timestamp used for Ad Alert Reporting.
-        mTimeStamp = DateAndTime.now().getTime();
-
-        // Set the width and height.
-        mWidth = extractIntHeader(httpResponse, WIDTH, 0);
-        mHeight = extractIntHeader(httpResponse, HEIGHT, 0);
-
-        // Set the allowable amount of time an ad has before it automatically fails.
-        mAdTimeoutDelay = extractIntegerHeader(httpResponse, AD_TIMEOUT);
-
-        // Set the auto-refresh time. A timer will be scheduled upon ad success or failure.
-        if (!httpResponse.containsHeader(REFRESH_TIME.getKey())) {
-            mRefreshTimeMilliseconds = 0;
-        } else {
-            mRefreshTimeMilliseconds = extractIntHeader(httpResponse, REFRESH_TIME, 0) * 1000;
-            mRefreshTimeMilliseconds = Math.max(
-                    mRefreshTimeMilliseconds,
-                    MINIMUM_REFRESH_TIME_MILLISECONDS);
-        }
-
-        // Set the unique identifier for the creative that was returned.
-        mDspCreativeId = extractHeader(httpResponse, DSP_CREATIVE_ID);
-    }
-
-    /*
-     * MoPubView
-     */
-
-    String getAdUnitId() {
-        return mAdUnitId;
-    }
-
-    void setAdUnitId(String adUnitId) {
-        mAdUnitId = adUnitId;
-    }
-
-    String getResponseString() {
-        return mResponseString;
-    }
-
-    void setResponseString(String responseString) {
-        mResponseString = responseString;
-    }
-
-    long getBroadcastIdentifier() {
-        return mBroadcastIdentifier;
-    }
-
-    /*
-     * HttpResponse
-     */
-
-    String getAdType() {
-        return mAdType;
-    }
-
-    String getNetworkType() {
-        return mNetworkType;
-    }
-
-    String getRedirectUrl() {
-        return mRedirectUrl;
-    }
-
-    String getClickthroughUrl() {
-        return mClickthroughUrl;
-    }
-
-    @Deprecated
-    void setClickthroughUrl(String clickthroughUrl) {
-        mClickthroughUrl = clickthroughUrl;
-    }
-
-    String getFailUrl() {
-        return mFailUrl;
-    }
-
-    void setFailUrl(String failUrl) {
-        mFailUrl = failUrl;
-    }
-
-    String getImpressionUrl() {
-        return mImpressionUrl;
-    }
-
-    long getTimeStamp() {
-        return mTimeStamp;
-    }
-
-    int getWidth() {
-        return mWidth;
-    }
-
-    int getHeight() {
-        return mHeight;
-    }
-
-    Integer getAdTimeoutDelay() {
-        return mAdTimeoutDelay;
-    }
-
-    int getRefreshTimeMilliseconds() {
-        return mRefreshTimeMilliseconds;
-    }
-
-    @Deprecated
-    void setRefreshTimeMilliseconds(int refreshTimeMilliseconds) {
-        mRefreshTimeMilliseconds = refreshTimeMilliseconds;
-    }
-
-    String getDspCreativeId() {
-        return mDspCreativeId;
-    }
-
-    /*
-     * Context
-     */
-
-    String getHashedUdid() {
-        return mHashedUdid;
-    }
-
-    String getUserAgent() {
-        return mUserAgent;
-    }
-
-    String getDeviceLocale() {
-        return mDeviceLocale;
-    }
-
-    String getDeviceModel() {
-        return mDeviceModel;
-    }
-
-    int getPlatformVersion() {
-        return mPlatformVersion;
-    }
-
-    String getPlatform() {
-        return mPlatform;
-    }
-
-    /*
-     * Misc.
-     */
-
-    String getSdkVersion() {
-        return mSdkVersion;
-    }
-
-    private void setDefaults() {
-        mBroadcastIdentifier = 0;
-        mAdUnitId = null;
-        mResponseString = null;
-        mAdType = null;
-        mNetworkType = null;
-        mRedirectUrl = null;
-        mClickthroughUrl = null;
-        mImpressionUrl = null;
-        mTimeStamp = DateAndTime.now().getTime();
-        mWidth = 0;
-        mHeight = 0;
-        mAdTimeoutDelay = null;
-        mRefreshTimeMilliseconds = DEFAULT_REFRESH_TIME_MILLISECONDS;
-        mFailUrl = null;
-        mDspCreativeId = null;
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdFetchTask.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdFetchTask.java
deleted file mode 100644
index 85875e25..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdFetchTask.java
+++ /dev/null
@@ -1,250 +0,0 @@
-package com.mopub.mobileads;
-
-import android.os.AsyncTask;
-import com.mopub.common.logging.MoPubLog;
-import com.mopub.mobileads.factories.HttpClientFactory;
-import org.apache.http.HttpResponse;
-import org.apache.http.HttpStatus;
-import org.apache.http.client.HttpClient;
-import org.apache.http.client.methods.HttpGet;
-import org.apache.http.conn.ClientConnectionManager;
-
-import static com.mopub.common.util.ResponseHeader.AD_TYPE;
-import static com.mopub.common.util.ResponseHeader.USER_AGENT;
-import static com.mopub.common.util.ResponseHeader.WARMUP;
-import static com.mopub.mobileads.util.HttpResponses.extractHeader;
-
-public class AdFetchTask extends AsyncTask<String, Void, AdLoadTask> {
-    private TaskTracker mTaskTracker;
-    private AdViewController mAdViewController;
-    private Exception mException;
-    private HttpClient mHttpClient;
-    private long mTaskId;
-    private String mUserAgent;
-
-    private AdFetcher.FetchStatus mFetchStatus = AdFetcher.FetchStatus.NOT_SET;
-    private static final int MAXIMUM_REFRESH_TIME_MILLISECONDS = 600000;
-    private static final double EXPONENTIAL_BACKOFF_FACTOR = 1.5;
-
-    public AdFetchTask(TaskTracker taskTracker, AdViewController adViewController, String userAgent, int timeoutMilliseconds) {
-        mTaskTracker = taskTracker;
-
-        mAdViewController = adViewController;
-        mHttpClient = HttpClientFactory.create(timeoutMilliseconds);
-        mTaskId = mTaskTracker.getCurrentTaskId();
-        mUserAgent = userAgent;
-    }
-
-    @Override
-    protected AdLoadTask doInBackground(String... urls) {
-        AdLoadTask result = null;
-        try {
-            result = fetch(urls[0]);
-        } catch (Exception exception) {
-            mException = exception;
-        } finally {
-            shutdownHttpClient();
-        }
-        return result;
-    }
-
-    private AdLoadTask fetch(String url) throws Exception {
-        HttpGet httpget = new HttpGet(url);
-        httpget.addHeader(USER_AGENT.getKey(), mUserAgent);
-
-        if (!isStateValid()) return null;
-
-        HttpResponse response = mHttpClient.execute(httpget);
-
-        if (!isResponseValid(response)) return null;
-
-        mAdViewController.configureUsingHttpResponse(response);
-
-        if (!responseContainsContent(response)) return null;
-
-        return AdLoadTask.fromHttpResponse(response, mAdViewController);
-    }
-
-    private boolean responseContainsContent(HttpResponse response) {
-        // Ensure that the ad is not warming up.
-        if ("1".equals(extractHeader(response, WARMUP))) {
-            MoPubLog.d("Ad Unit (" + mAdViewController.getAdUnitId() + ") is still warming up. " +
-                    "Please try again in a few minutes.");
-            mFetchStatus = AdFetcher.FetchStatus.AD_WARMING_UP;
-            return false;
-        }
-
-        // Ensure that the ad type header is valid and not "clear".
-        String adType = extractHeader(response, AD_TYPE);
-        if ("clear".equals(adType)) {
-            MoPubLog.d("No ads found for adunit (" + mAdViewController.getAdUnitId() + ").");
-            mFetchStatus = AdFetcher.FetchStatus.CLEAR_AD_TYPE;
-            return false;
-        }
-
-        return true;
-    }
-
-    private boolean isResponseValid(HttpResponse response) {
-        if (response == null || response.getEntity() == null) {
-            MoPubLog.d("MoPub server returned null response.");
-            mFetchStatus = AdFetcher.FetchStatus.INVALID_SERVER_RESPONSE_NOBACKOFF;
-            return false;
-        }
-
-        final int statusCode = response.getStatusLine().getStatusCode();
-
-        // Client and Server HTTP errors should result in an exponential backoff
-        if (statusCode >= 400) {
-            MoPubLog.d("Server error: returned HTTP status code " + Integer.toString(statusCode) +
-                    ". Please try again.");
-            mFetchStatus = AdFetcher.FetchStatus.INVALID_SERVER_RESPONSE_BACKOFF;
-            return false;
-        }
-        // Other non-200 HTTP status codes should still fail
-        else if (statusCode != HttpStatus.SC_OK) {
-            MoPubLog.d("MoPub server returned invalid response: HTTP status code " +
-                    Integer.toString(statusCode) + ".");
-            mFetchStatus = AdFetcher.FetchStatus.INVALID_SERVER_RESPONSE_NOBACKOFF;
-            return false;
-        }
-        return true;
-    }
-
-    private boolean isStateValid() {
-        // We check to see if this AsyncTask was cancelled, as per
-        // http://developer.android.com/reference/android/os/AsyncTask.html
-        if (isCancelled()) {
-            mFetchStatus = AdFetcher.FetchStatus.FETCH_CANCELLED;
-            return false;
-        }
-
-        if (mAdViewController == null || mAdViewController.isDestroyed()) {
-            MoPubLog.d("Error loading ad: AdViewController has already been GCed or destroyed.");
-            return false;
-        }
-        return true;
-    }
-
-    @Override
-    protected void onPostExecute(AdLoadTask adLoadTask) {
-        if (!isMostCurrentTask()) {
-            MoPubLog.d("Ad response is stale.");
-            cleanup();
-            return;
-        }
-
-        // If cleanup() has already been called on the AdViewController, don't proceed.
-        if (mAdViewController == null || mAdViewController.isDestroyed()) {
-            if (adLoadTask != null) {
-                adLoadTask.cleanup();
-            }
-            mTaskTracker.markTaskCompleted(mTaskId);
-            cleanup();
-            return;
-        }
-
-        if (adLoadTask == null) {
-            if (mException != null) {
-                MoPubLog.d("Exception caught while loading ad: " + mException);
-            }
-
-            MoPubErrorCode errorCode;
-            switch (mFetchStatus) {
-                case NOT_SET:
-                    errorCode = MoPubErrorCode.UNSPECIFIED;
-                    break;
-                case FETCH_CANCELLED:
-                    errorCode = MoPubErrorCode.CANCELLED;
-                    break;
-                case INVALID_SERVER_RESPONSE_BACKOFF:
-                case INVALID_SERVER_RESPONSE_NOBACKOFF:
-                    errorCode = MoPubErrorCode.SERVER_ERROR;
-                    break;
-                case CLEAR_AD_TYPE:
-                case AD_WARMING_UP:
-                    errorCode = MoPubErrorCode.NO_FILL;
-                    break;
-                default:
-                    errorCode = MoPubErrorCode.UNSPECIFIED;
-                    break;
-            }
-
-            mAdViewController.adDidFail(errorCode);
-
-            /*
-             * There are numerous reasons for the ad fetch to fail, but only in the specific
-             * case of actual server failure should we exponentially back off.
-             *
-             * Note: We place the exponential backoff after AdViewController's adDidFail because we only
-             * want to increase refresh times after the first failure refresh timer is
-             * scheduled, and not before.
-             */
-            if (mFetchStatus == AdFetcher.FetchStatus.INVALID_SERVER_RESPONSE_BACKOFF) {
-                exponentialBackoff();
-                mFetchStatus = AdFetcher.FetchStatus.NOT_SET;
-            }
-        } else {
-            adLoadTask.execute();
-            adLoadTask.cleanup();
-        }
-
-        mTaskTracker.markTaskCompleted(mTaskId);
-        cleanup();
-    }
-
-    @Override
-    protected void onCancelled() {
-        if (!isMostCurrentTask()) {
-            MoPubLog.d("Ad response is stale.");
-            cleanup();
-            return;
-        }
-
-        MoPubLog.d("Ad loading was cancelled.");
-        if (mException != null) {
-            MoPubLog.d("Exception caught while loading ad: " + mException);
-        }
-        mTaskTracker.markTaskCompleted(mTaskId);
-        cleanup();
-    }
-
-    /* This helper function is called when a 4XX or 5XX error is received during an ad fetch.
-     * It exponentially increases the parent AdViewController's refreshTime up to a specified cap.
-     */
-    private void exponentialBackoff() {
-        if (mAdViewController == null) {
-            return;
-        }
-
-        int refreshTimeMilliseconds = mAdViewController.getRefreshTimeMilliseconds();
-
-        refreshTimeMilliseconds = (int) (refreshTimeMilliseconds * EXPONENTIAL_BACKOFF_FACTOR);
-        if (refreshTimeMilliseconds > MAXIMUM_REFRESH_TIME_MILLISECONDS) {
-            refreshTimeMilliseconds = MAXIMUM_REFRESH_TIME_MILLISECONDS;
-        }
-
-        mAdViewController.setRefreshTimeMilliseconds(refreshTimeMilliseconds);
-    }
-
-    private void cleanup() {
-        mTaskTracker = null;
-        mException = null;
-        mFetchStatus = AdFetcher.FetchStatus.NOT_SET;
-    }
-
-    private void shutdownHttpClient() {
-        if (mHttpClient != null) {
-            ClientConnectionManager manager = mHttpClient.getConnectionManager();
-            if (manager != null) {
-                manager.shutdown();
-            }
-            mHttpClient = null;
-        }
-    }
-
-    private boolean isMostCurrentTask() {
-        // if we've been cleaned up already, then we're definitely not the current task
-        return (mTaskTracker == null) ? false : mTaskTracker.isMostCurrentTask(mTaskId);
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdFetcher.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdFetcher.java
deleted file mode 100644
index 79486a06..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdFetcher.java
+++ /dev/null
@@ -1,82 +0,0 @@
-package com.mopub.mobileads;
-
-import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.AsyncTasks;
-import com.mopub.mobileads.factories.AdFetchTaskFactory;
-
-/*
- * AdFetcher is a delegate of an AdViewController that handles loading ad data over a
- * network connection. The ad is fetched in a background thread by executing
- * AdFetchTask, which is an AsyncTask subclass. This class gracefully handles
- * the changes to AsyncTask in Android 4.0.1 (we continue to run parallel to
- * the app developer's background tasks). Further, AdFetcher keeps track of
- * the last completed task to prevent out-of-order execution.
- */
-public class AdFetcher {
-    public static final String HTML_RESPONSE_BODY_KEY = "Html-Response-Body";
-    public static final String REDIRECT_URL_KEY = "Redirect-Url";
-    public static final String CLICKTHROUGH_URL_KEY = "Clickthrough-Url";
-    public static final String SCROLLABLE_KEY = "Scrollable";
-    public static final String AD_CONFIGURATION_KEY = "Ad-Configuration";
-
-    private int mTimeoutMilliseconds = 10000;
-    private AdViewController mAdViewController;
-
-    private AdFetchTask mCurrentTask;
-    private String mUserAgent;
-    private final TaskTracker mTaskTracker;
-
-    enum FetchStatus {
-        NOT_SET,
-        FETCH_CANCELLED,
-        INVALID_SERVER_RESPONSE_BACKOFF,
-        INVALID_SERVER_RESPONSE_NOBACKOFF,
-        CLEAR_AD_TYPE,
-        AD_WARMING_UP;
-    }
-
-    public AdFetcher(AdViewController adview, String userAgent) {
-        mAdViewController = adview;
-        mUserAgent = userAgent;
-        mTaskTracker = new TaskTracker();
-    }
-
-    public void fetchAdForUrl(String url) {
-        mTaskTracker.newTaskStarted();
-        MoPubLog.i("Fetching ad for task #" + getCurrentTaskId());
-
-        if (mCurrentTask != null) {
-            mCurrentTask.cancel(true);
-        }
-
-        mCurrentTask = AdFetchTaskFactory.create(mTaskTracker, mAdViewController, mUserAgent, mTimeoutMilliseconds);
-
-        try {
-            AsyncTasks.safeExecuteOnExecutor(mCurrentTask, url);
-        } catch (Exception exception) {
-            MoPubLog.d("Error executing AdFetchTask", exception);
-        }
-    }
-
-    public void cancelFetch() {
-        if (mCurrentTask != null) {
-            MoPubLog.i("Canceling fetch ad for task #" + getCurrentTaskId());
-            mCurrentTask.cancel(true);
-        }
-    }
-
-    void cleanup() {
-        cancelFetch();
-
-        mAdViewController = null;
-        mUserAgent = "";
-    }
-
-    protected void setTimeout(int milliseconds) {
-        mTimeoutMilliseconds = milliseconds;
-    }
-
-    private long getCurrentTaskId() {
-        return mTaskTracker.getCurrentTaskId();
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdLoadTask.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdLoadTask.java
deleted file mode 100644
index cb379e71..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdLoadTask.java
+++ /dev/null
@@ -1,240 +0,0 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.net.Uri;
-
-import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.Json;
-import com.mopub.common.util.Strings;
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpResponse;
-
-import java.io.*;
-import java.lang.ref.WeakReference;
-import java.lang.reflect.Method;
-import java.util.*;
-
-import static com.mopub.common.util.ResponseHeader.AD_TYPE;
-import static com.mopub.common.util.ResponseHeader.CLICKTHROUGH_URL;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_DATA;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_NAME;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_SELECTOR;
-import static com.mopub.common.util.ResponseHeader.FULL_AD_TYPE;
-import static com.mopub.common.util.ResponseHeader.NATIVE_PARAMS;
-import static com.mopub.common.util.ResponseHeader.REDIRECT_URL;
-import static com.mopub.common.util.ResponseHeader.SCROLLABLE;
-import static com.mopub.mobileads.AdFetcher.CLICKTHROUGH_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
-import static com.mopub.mobileads.AdFetcher.REDIRECT_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.SCROLLABLE_KEY;
-import static com.mopub.mobileads.util.HttpResponses.extractBooleanHeader;
-import static com.mopub.mobileads.util.HttpResponses.extractHeader;
-
-abstract class AdLoadTask {
-    WeakReference<AdViewController> mWeakAdViewController;
-    AdLoadTask(AdViewController adViewController) {
-        mWeakAdViewController = new WeakReference<AdViewController>(adViewController);
-    }
-
-    abstract void execute();
-
-    /*
-     * The AsyncTask thread pool often appears to keep references to these
-     * objects, preventing GC. This method should be used to release
-     * resources to mitigate the GC issue.
-     */
-    abstract void cleanup();
-
-    static AdLoadTask fromHttpResponse(HttpResponse response, AdViewController adViewController) throws IOException {
-        return new TaskExtractor(response, adViewController).extract();
-    }
-
-    private static class TaskExtractor {
-        private final HttpResponse response;
-        private final AdViewController adViewController;
-        private String adType;
-        private String adTypeCustomEventName;
-        private String fullAdType;
-
-        TaskExtractor(HttpResponse response, AdViewController adViewController){
-            this.response = response;
-            this.adViewController = adViewController;
-        }
-
-        AdLoadTask extract() throws IOException {
-            adType = extractHeader(response, AD_TYPE);
-            fullAdType = extractHeader(response, FULL_AD_TYPE);
-
-            MoPubLog.d("Loading ad type: " + AdTypeTranslator.getAdNetworkType(adType, fullAdType));
-
-            adTypeCustomEventName = AdTypeTranslator.getCustomEventNameForAdType(
-                    adViewController.getMoPubView(), adType, fullAdType);
-
-            if ("custom".equals(adType)) {
-                return extractCustomEventAdLoadTask();
-            } else if (eventDataIsInResponseBody(adType)) {
-                return extractCustomEventAdLoadTaskFromResponseBody();
-            } else {
-                return extractCustomEventAdLoadTaskFromNativeParams();
-            }
-        }
-
-        private AdLoadTask extractCustomEventAdLoadTask() {
-            MoPubLog.i("Performing custom event.");
-
-            // If applicable, try to invoke the new custom event system (which uses custom classes)
-            adTypeCustomEventName = extractHeader(response, CUSTOM_EVENT_NAME);
-            if (adTypeCustomEventName != null) {
-                String customEventData = extractHeader(response, CUSTOM_EVENT_DATA);
-                return createCustomEventAdLoadTask(customEventData);
-            }
-
-            // Otherwise, use the (deprecated) legacy custom event system for older clients
-            Header oldCustomEventHeader = response.getFirstHeader(CUSTOM_SELECTOR.getKey());
-            return new AdLoadTask.LegacyCustomEventAdLoadTask(adViewController, oldCustomEventHeader);
-        }
-
-        private AdLoadTask extractCustomEventAdLoadTaskFromResponseBody() throws IOException {
-            HttpEntity entity = response.getEntity();
-            String htmlData = entity != null ? Strings.fromStream(entity.getContent()) : "";
-
-            adViewController.getAdConfiguration().setResponseString(htmlData);
-
-            String redirectUrl = extractHeader(response, REDIRECT_URL);
-            String clickthroughUrl = extractHeader(response, CLICKTHROUGH_URL);
-            boolean scrollingEnabled = extractBooleanHeader(response, SCROLLABLE, false);
-
-            Map<String, String> eventDataMap = new HashMap<String, String>();
-            eventDataMap.put(HTML_RESPONSE_BODY_KEY, Uri.encode(htmlData));
-            eventDataMap.put(SCROLLABLE_KEY, Boolean.toString(scrollingEnabled));
-            if (redirectUrl != null) {
-                eventDataMap.put(REDIRECT_URL_KEY, redirectUrl);
-            }
-            if (clickthroughUrl != null) {
-                eventDataMap.put(CLICKTHROUGH_URL_KEY, clickthroughUrl);
-            }
-
-            String eventData = Json.mapToJsonString(eventDataMap);
-            return createCustomEventAdLoadTask(eventData);
-        }
-
-        private AdLoadTask extractCustomEventAdLoadTaskFromNativeParams() throws IOException {
-            String eventData = extractHeader(response, NATIVE_PARAMS);
-
-            return createCustomEventAdLoadTask(eventData);
-        }
-
-        private AdLoadTask createCustomEventAdLoadTask(String customEventData) {
-            Map<String, String> paramsMap = new HashMap<String, String>();
-            paramsMap.put(CUSTOM_EVENT_NAME.getKey(), adTypeCustomEventName);
-
-            if (customEventData != null) {
-                paramsMap.put(CUSTOM_EVENT_DATA.getKey(), customEventData);
-            }
-
-            return new AdLoadTask.CustomEventAdLoadTask(adViewController, paramsMap);
-        }
-
-        private boolean eventDataIsInResponseBody(String adType) {
-            // XXX Hack
-            return "mraid".equals(adType) || "html".equals(adType) || ("interstitial".equals(adType) && "vast".equals(fullAdType));
-        }
-    }
-
-    /*
-     * This is the new way of performing Custom Events. This will be invoked on new clients when
-     * X-Adtype is "custom" and the X-Custom-Event-Class-Name header is specified.
-     */
-    static class CustomEventAdLoadTask extends AdLoadTask {
-        private Map<String,String> mParamsMap;
-
-        public CustomEventAdLoadTask(AdViewController adViewController, Map<String, String> paramsMap) {
-            super(adViewController);
-            mParamsMap = paramsMap;
-        }
-
-        @Override
-        void execute() {
-            AdViewController adViewController = mWeakAdViewController.get();
-
-            if (adViewController == null || adViewController.isDestroyed()) {
-                return;
-            }
-
-            adViewController.setNotLoading();
-            adViewController.getMoPubView().loadCustomEvent(mParamsMap);
-        }
-
-        @Override
-        void cleanup() {
-            mParamsMap = null;
-        }
-
-        @Deprecated // for testing
-        Map<String, String> getParamsMap() {
-            return mParamsMap;
-        }
-    }
-
-    /*
-     * This is the old way of performing Custom Events, and is now deprecated. This will still be
-     * invoked on old clients when X-Adtype is "custom" and the new X-Custom-Event-Class-Name header
-     * is not specified (legacy custom events parse the X-Customselector header instead).
-     */
-    @Deprecated
-    static class LegacyCustomEventAdLoadTask extends AdLoadTask {
-        private Header mHeader;
-
-        public LegacyCustomEventAdLoadTask(AdViewController adViewController, Header header) {
-            super(adViewController);
-            mHeader = header;
-        }
-
-        @Override
-        void execute() {
-            AdViewController adViewController = mWeakAdViewController.get();
-            if (adViewController == null || adViewController.isDestroyed()) {
-                return;
-            }
-
-            adViewController.setNotLoading();
-            MoPubView mpv = adViewController.getMoPubView();
-
-            if (mHeader == null) {
-                MoPubLog.i("Couldn't call custom method because the server did not specify one.");
-                mpv.loadFailUrl(MoPubErrorCode.ADAPTER_NOT_FOUND);
-                return;
-            }
-
-            String methodName = mHeader.getValue();
-            MoPubLog.i("Trying to call method named " + methodName);
-
-            Class<? extends Activity> c;
-            Method method;
-            Activity userActivity = mpv.getActivity();
-            try {
-                c = userActivity.getClass();
-                method = c.getMethod(methodName, MoPubView.class);
-                method.invoke(userActivity, mpv);
-            } catch (NoSuchMethodException e) {
-                MoPubLog.d("Couldn't perform custom method named " + methodName +
-                        "(MoPubView view) because your activity class has no such method");
-                mpv.loadFailUrl(MoPubErrorCode.ADAPTER_NOT_FOUND);
-            } catch (Exception e) {
-                MoPubLog.d("Couldn't perform custom method named " + methodName);
-                mpv.loadFailUrl(MoPubErrorCode.ADAPTER_NOT_FOUND);
-            }
-        }
-
-        @Override
-        void cleanup() {
-            mHeader = null;
-        }
-
-        @Deprecated // for testing
-        Header getHeader() {
-            return mHeader;
-        }
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdLoader.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdLoader.java
new file mode 100644
index 00000000..3b0e073c
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/AdLoader.java
@@ -0,0 +1,72 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.network.AdResponse;
+
+import java.lang.ref.WeakReference;
+import java.util.Map;
+
+abstract class AdLoader {
+
+    WeakReference<AdViewController> mWeakAdViewController;
+    AdLoader(AdViewController adViewController) {
+        mWeakAdViewController = new WeakReference<AdViewController>(adViewController);
+    }
+
+    abstract void load();
+
+    @Nullable
+    static AdLoader fromAdResponse(AdResponse response, AdViewController adViewController) {
+        MoPubLog.i("Performing custom event.");
+
+        // If applicable, try to invoke the new custom event system (which uses custom classes)
+        String adTypeCustomEventName = response.getCustomEventClassName();
+        if (adTypeCustomEventName != null) {
+            Map<String, String> customEventData = response.getServerExtras();
+            return new CustomEventAdLoader(adViewController, adTypeCustomEventName, customEventData);
+        }
+
+        MoPubLog.i("Failed to create custom event.");
+        return null;
+    }
+
+    static class CustomEventAdLoader extends AdLoader {
+        private String mCustomEventClassName;
+        private Map<String,String> mServerExtras;
+
+        public CustomEventAdLoader(AdViewController adViewController,
+                String customEventCLassName,
+                Map<String, String> serverExtras) {
+            super(adViewController);
+            mCustomEventClassName = customEventCLassName;
+            mServerExtras = serverExtras;
+        }
+
+        @Override
+        void load() {
+            AdViewController adViewController = mWeakAdViewController.get();
+            if (adViewController == null
+                    || adViewController.isDestroyed()
+                    || TextUtils.isEmpty(mCustomEventClassName)) {
+                return;
+            }
+            adViewController.setNotLoading();
+
+            final MoPubView moPubView = adViewController.getMoPubView();
+            if (moPubView == null) {
+                MoPubLog.d("Can't load an ad in this ad view because it was destroyed.");
+                return;
+            }
+            moPubView.loadCustomEvent(mCustomEventClassName, mServerExtras);
+        }
+
+        @VisibleForTesting
+        Map<String, String> getServerExtras() {
+            return mServerExtras;
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdRequestStatusMapping.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdRequestStatusMapping.java
new file mode 100644
index 00000000..10d6625b
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/AdRequestStatusMapping.java
@@ -0,0 +1,199 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import com.mopub.common.Preconditions;
+import com.mopub.network.AdRequest;
+
+import java.util.Map;
+import java.util.TreeMap;
+
+public class AdRequestStatusMapping {
+    @NonNull
+    private final Map<String, AdRequestStatus> mAdUnitToAdRequestStatus;
+
+    public AdRequestStatusMapping() {
+        mAdUnitToAdRequestStatus = new TreeMap<String, AdRequestStatus>();
+    }
+
+    void markFail(@NonNull final String adUnitId) {
+        mAdUnitToAdRequestStatus.remove(adUnitId);
+    }
+
+    void markLoading(@NonNull final String adUnitId) {
+        mAdUnitToAdRequestStatus.put(adUnitId, new AdRequestStatus(LoadingStatus.LOADING));
+    }
+
+    void markLoaded(
+            @NonNull final String adUnitId,
+            @Nullable final String failUrlString,
+            @Nullable final String impressionTrackerUrlString,
+            @Nullable final String clickTrackerUrlString) {
+        mAdUnitToAdRequestStatus.put(adUnitId, new AdRequestStatus(
+                LoadingStatus.LOADED,
+                failUrlString,
+                impressionTrackerUrlString,
+                clickTrackerUrlString));
+    }
+
+    void markPlayed(@NonNull final String adUnitId) {
+        // If possible, attempt to keep the URL fields in AdRequestStatus
+        if (mAdUnitToAdRequestStatus.containsKey(adUnitId)) {
+            final AdRequestStatus adRequestStatus = mAdUnitToAdRequestStatus.get(adUnitId);
+            adRequestStatus.setStatus(LoadingStatus.PLAYED);
+        } else {
+            mAdUnitToAdRequestStatus.put(adUnitId, new AdRequestStatus(LoadingStatus.PLAYED));
+        }
+    }
+
+    boolean canPlay(@NonNull final String adUnitId) {
+        final AdRequestStatus adRequestStatus = mAdUnitToAdRequestStatus.get(adUnitId);
+        return adRequestStatus != null
+            && LoadingStatus.LOADED.equals(adRequestStatus.getStatus());
+    }
+
+    boolean isLoading(@NonNull final String adUnitId) {
+        if (!mAdUnitToAdRequestStatus.containsKey(adUnitId)) {
+            return false;
+        }
+
+        return mAdUnitToAdRequestStatus.get(adUnitId).getStatus() == LoadingStatus.LOADING;
+    }
+
+    @Nullable String getFailoverUrl(@NonNull final String adUnitId) {
+        if (!mAdUnitToAdRequestStatus.containsKey(adUnitId)) {
+            return null;
+        }
+
+        return mAdUnitToAdRequestStatus.get(adUnitId).getFailurl();
+    }
+
+    @Nullable String getImpressionTrackerUrlString(@NonNull final String adUnitId) {
+        if (!mAdUnitToAdRequestStatus.containsKey(adUnitId)) {
+            return null;
+        }
+
+        return mAdUnitToAdRequestStatus.get(adUnitId).getImpressionUrl();
+    }
+
+    @Nullable String getClickTrackerUrlString(@NonNull final String adUnitId) {
+        if (!mAdUnitToAdRequestStatus.containsKey(adUnitId)) {
+            return null;
+        }
+
+        return mAdUnitToAdRequestStatus.get(adUnitId).getClickUrl();
+    }
+
+    void clearImpressionUrl(@NonNull final String adUnitId) {
+        if (mAdUnitToAdRequestStatus.containsKey(adUnitId)) {
+            mAdUnitToAdRequestStatus.get(adUnitId).setImpressionUrl(null);
+        }
+    }
+
+    void clearClickUrl(@NonNull final String adUnitId) {
+        if (mAdUnitToAdRequestStatus.containsKey(adUnitId)) {
+            mAdUnitToAdRequestStatus.get(adUnitId).setClickUrl(null);
+        }
+    }
+
+    private static enum LoadingStatus { LOADING, LOADED, PLAYED }
+    private static class AdRequestStatus {
+        @NonNull
+        private LoadingStatus mLoadingStatus;
+        @Nullable
+        private String mFailUrl;
+        @Nullable
+        private String mImpressionUrl;
+        @Nullable
+        private String mClickUrl;
+
+        public AdRequestStatus(@NonNull final LoadingStatus loadingStatus) {
+            this(loadingStatus, null, null, null);
+        }
+
+        public AdRequestStatus(
+                @NonNull final LoadingStatus loadingStatus,
+                @Nullable final String failUrl,
+                @Nullable final String impressionUrl,
+                @Nullable final String clickUrl) {
+            Preconditions.checkNotNull(loadingStatus);
+
+            mLoadingStatus = loadingStatus;
+            mFailUrl = failUrl;
+            mImpressionUrl = impressionUrl;
+            mClickUrl = clickUrl;
+        }
+
+        @NonNull
+        private LoadingStatus getStatus() {
+            return mLoadingStatus;
+        }
+
+        private void setStatus(@NonNull final LoadingStatus loadingStatus) {
+            mLoadingStatus = loadingStatus;
+        }
+
+        @Nullable
+        private String getFailurl() {
+            return mFailUrl;
+        }
+
+        @Nullable
+        private String getImpressionUrl() {
+            return mImpressionUrl;
+        }
+
+        private void setImpressionUrl(@Nullable final String impressionUrl) {
+            mImpressionUrl = impressionUrl;
+        }
+
+        @Nullable
+        private String getClickUrl() {
+            return mClickUrl;
+        }
+
+        private void setClickUrl(@Nullable final String clickUrl) {
+            mClickUrl = clickUrl;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (o == null) {
+                return false;
+            }
+
+            if (this == o) {
+                return true;
+            }
+
+            if (!(o instanceof AdRequestStatus)) {
+                return false;
+            }
+
+            final AdRequestStatus that = (AdRequestStatus) o;
+
+            return this.mLoadingStatus.equals(that.mLoadingStatus) &&
+                    TextUtils.equals(this.mFailUrl, that.mFailUrl) &&
+                    TextUtils.equals(this.mImpressionUrl, that.mImpressionUrl) &&
+                    TextUtils.equals(this.mClickUrl, that.mClickUrl);
+        }
+
+        @Override
+        public int hashCode() {
+            int result = 29;
+            result = 31 * result + mLoadingStatus.ordinal();
+            result = 31 * result + (mFailUrl != null
+                    ? mFailUrl.hashCode()
+                    : 0);
+            result = 31 * result + (mImpressionUrl != null
+                    ? mImpressionUrl.hashCode()
+                    : 0);
+            result = 31 * result + (mClickUrl != null
+                    ? mClickUrl.hashCode()
+                    : 0);
+            return result;
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdTypeTranslator.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdTypeTranslator.java
index 2ac1f294..f2d5e8c9 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdTypeTranslator.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/AdTypeTranslator.java
@@ -1,18 +1,31 @@
 package com.mopub.mobileads;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.AdFormat;
+import com.mopub.common.AdType;
+import com.mopub.common.util.ResponseHeader;
+
+import java.util.Map;
+
+import static com.mopub.network.HeaderUtils.extractHeader;
+
 public class AdTypeTranslator {
     public enum CustomEventType {
-        // With the deprecation of a standalone AdMob SDK, these now point to Google Play Services
+        // "Special" custom events that we let people choose in the UI.
         GOOGLE_PLAY_SERVICES_BANNER("admob_native_banner", "com.mopub.mobileads.GooglePlayServicesBanner"),
         GOOGLE_PLAY_SERVICES_INTERSTITIAL("admob_full_interstitial", "com.mopub.mobileads.GooglePlayServicesInterstitial"),
-
         MILLENNIAL_BANNER("millennial_native_banner", "com.mopub.mobileads.MillennialBanner"),
         MILLENNIAL_INTERSTITIAL("millennial_full_interstitial", "com.mopub.mobileads.MillennialInterstitial"),
-        MRAID_BANNER("mraid_banner", "com.mopub.mobileads.MraidBanner"),
-        MRAID_INTERSTITIAL("mraid_interstitial", "com.mopub.mobileads.MraidInterstitial"),
+
+        // MoPub-specific custom events.
+        MRAID_BANNER("mraid_banner", "com.mopub.mraid.MraidBanner"),
+        MRAID_INTERSTITIAL("mraid_interstitial", "com.mopub.mraid.MraidInterstitial"),
         HTML_BANNER("html_banner", "com.mopub.mobileads.HtmlBanner"),
         HTML_INTERSTITIAL("html_interstitial", "com.mopub.mobileads.HtmlInterstitial"),
         VAST_VIDEO_INTERSTITIAL("vast_interstitial", "com.mopub.mobileads.VastVideoInterstitial"),
+        MOPUB_NATIVE("mopub_native", "com.mopub.nativeads.MoPubCustomEventNative"),
 
         UNSPECIFIED("", null);
 
@@ -40,28 +53,30 @@ public String toString() {
         }
     }
 
+    public static final String BANNER_SUFFIX = "_banner";
+    public static final String INTERSTITIAL_SUFFIX = "_interstitial";
+
     static String getAdNetworkType(String adType, String fullAdType) {
-        String adNetworkType = "interstitial".equals(adType) ? fullAdType : adType;
+        String adNetworkType = AdType.INTERSTITIAL.equals(adType) ? fullAdType : adType;
         return adNetworkType != null ? adNetworkType : "unknown";
     }
 
-    static String getCustomEventNameForAdType(MoPubView moPubView, String adType, String fullAdType) {
-        CustomEventType customEventType;
-
-        if ("html".equals(adType) || "mraid".equals(adType)) {
-            customEventType = (isInterstitial(moPubView))
-                    ? CustomEventType.fromString(adType + "_interstitial")
-                    : CustomEventType.fromString(adType + "_banner");
+    public static String getCustomEventName(@NonNull AdFormat adFormat,
+            @NonNull String adType,
+            @Nullable String fullAdType,
+            @NonNull Map<String, String> headers) {
+        if (AdType.CUSTOM.equalsIgnoreCase(adType)) {
+            return extractHeader(headers, ResponseHeader.CUSTOM_EVENT_NAME);
+        } else if (AdType.NATIVE.equalsIgnoreCase(adType)){
+            return CustomEventType.MOPUB_NATIVE.toString();
+        } else if (AdType.HTML.equalsIgnoreCase(adType) || AdType.MRAID.equalsIgnoreCase(adType)) {
+            return (AdFormat.INTERSTITIAL.equals(adFormat)
+                    ? CustomEventType.fromString(adType + INTERSTITIAL_SUFFIX)
+                    : CustomEventType.fromString(adType + BANNER_SUFFIX)).toString();
+        } else if (AdType.INTERSTITIAL.equalsIgnoreCase(adType)) {
+            return CustomEventType.fromString(fullAdType + INTERSTITIAL_SUFFIX).toString();
         } else {
-            customEventType = ("interstitial".equals(adType))
-                    ? CustomEventType.fromString(fullAdType + "_interstitial")
-                    : CustomEventType.fromString(adType + "_banner");
+            return CustomEventType.fromString(adType + BANNER_SUFFIX).toString();
         }
-
-        return customEventType.toString();
-    }
-
-    private static boolean isInterstitial(MoPubView moPubView) {
-        return moPubView instanceof MoPubInterstitial.MoPubInterstitialView;
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdViewController.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdViewController.java
index a9c537f9..a049e317 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdViewController.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/AdViewController.java
@@ -6,50 +6,75 @@
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
 import android.os.Handler;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
 import android.util.Log;
 import android.view.Gravity;
 import android.view.View;
 import android.widget.FrameLayout;
 
-import com.mopub.common.GpsHelper;
-import com.mopub.common.MoPub;
+import com.mopub.common.AdReport;
+import com.mopub.common.ClientMetadata;
+import com.mopub.common.Constants;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.event.BaseEvent;
 import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.DeviceUtils;
 import com.mopub.common.util.Dips;
-import com.mopub.mobileads.factories.AdFetcherFactory;
-import com.mopub.mobileads.factories.HttpClientFactory;
-import org.apache.http.HttpResponse;
-import org.apache.http.client.methods.HttpGet;
-import org.apache.http.impl.client.DefaultHttpClient;
-
-import java.util.*;
+import com.mopub.common.util.Utils;
+import com.mopub.mraid.MraidNativeCommandHandler;
+import com.mopub.network.AdRequest;
+import com.mopub.network.AdResponse;
+import com.mopub.network.MoPubNetworkError;
+import com.mopub.network.Networking;
+import com.mopub.network.TrackingRequest;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.RequestQueue;
+import com.mopub.volley.VolleyError;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.TreeMap;
+import java.util.WeakHashMap;
 
 import static android.Manifest.permission.ACCESS_NETWORK_STATE;
-import static com.mopub.common.GpsHelper.GpsHelperListener;
-import static com.mopub.common.LocationService.getLastKnownLocation;
 
 public class AdViewController {
-    static final int MINIMUM_REFRESH_TIME_MILLISECONDS = 10000;
-    static final int DEFAULT_REFRESH_TIME_MILLISECONDS = 60000;
+    static final int DEFAULT_REFRESH_TIME_MILLISECONDS = 60000;  // 1 minute
+    static final int MAX_REFRESH_TIME_MILLISECONDS = 600000; // 10 minutes
+    static final double BACKOFF_FACTOR = 1.5;
     private static final FrameLayout.LayoutParams WRAP_AND_CENTER_LAYOUT_PARAMS =
             new FrameLayout.LayoutParams(
                     FrameLayout.LayoutParams.WRAP_CONTENT,
                     FrameLayout.LayoutParams.WRAP_CONTENT,
                     Gravity.CENTER);
-    private static WeakHashMap<View,Boolean> sViewShouldHonorServerDimensions = new WeakHashMap<View, Boolean>();;
+    private final static WeakHashMap<View,Boolean> sViewShouldHonorServerDimensions = new WeakHashMap<View, Boolean>();
+
+    private final long mBroadcastIdentifier;
 
-    private final Context mContext;
-    private GpsHelperListener mGpsHelperListener;
+    @Nullable
+    private Context mContext;
+    @Nullable
     private MoPubView mMoPubView;
-    private final WebViewAdUrlGenerator mUrlGenerator;
-    private AdFetcher mAdFetcher;
-    private AdConfiguration mAdConfiguration;
+    @Nullable
+    private WebViewAdUrlGenerator mUrlGenerator;
+
+    @Nullable
+    private AdResponse mAdResponse;
     private final Runnable mRefreshRunnable;
+    @NonNull
+    private final AdRequest.Listener mAdListener;
 
     private boolean mIsDestroyed;
     private Handler mHandler;
     private boolean mIsLoading;
     private String mUrl;
 
+    // This is the power of the exponential term in the exponential backoff calculation.
+    @VisibleForTesting
+    int mBackoffPower = 1;
+
     private Map<String, Object> mLocalExtras = new HashMap<String, Object>();
     private boolean mAutoRefreshEnabled = true;
     private boolean mPreviousAutoRefreshSetting = true;
@@ -57,8 +82,15 @@
     private Location mLocation;
     private boolean mIsTesting;
     private boolean mAdWasLoaded;
-
-    protected static void setShouldHonorServerDimensions(View view) {
+    @Nullable
+    private String mAdUnitId;
+    private int mTimeoutMilliseconds;
+    @Nullable
+    private AdRequest mActiveRequest;
+    @Nullable
+    private Integer mRefreshTimeMillis;
+
+    public static void setShouldHonorServerDimensions(View view) {
         sViewShouldHonorServerDimensions.put(view, true);
     }
 
@@ -66,36 +98,127 @@ private static boolean getShouldHonorServerDimensions(View view) {
         return sViewShouldHonorServerDimensions.get(view) != null;
     }
 
-    public AdViewController(Context context, MoPubView view) {
+    public AdViewController(@NonNull Context context, @NonNull MoPubView view) {
         mContext = context;
         mMoPubView = view;
 
-        mUrlGenerator = new WebViewAdUrlGenerator(context);
-        mAdConfiguration = new AdConfiguration(mContext);
+        // Default timeout means "never refresh"
+        mTimeoutMilliseconds = -1;
+        mBroadcastIdentifier = Utils.generateUniqueId();
 
-        mAdFetcher = AdFetcherFactory.create(this, mAdConfiguration.getUserAgent());
+        mUrlGenerator = new WebViewAdUrlGenerator(mContext.getApplicationContext(),
+                MraidNativeCommandHandler.isStorePictureSupported(mContext));
 
-        mGpsHelperListener = new AdViewControllerGpsHelperListener();
+        mAdListener = new AdRequest.Listener() {
+            @Override
+            public void onSuccess(final AdResponse response) {
+                onAdLoadSuccess(response);
+            }
 
-        GpsHelper.fetchAdvertisingInfoAsync(mContext, null);
+            @Override
+            public void onErrorResponse(final VolleyError volleyError) {
+                onAdLoadError(volleyError);
+            }
+        };
 
         mRefreshRunnable = new Runnable() {
             public void run() {
-                loadAd();
+                internalLoadAd();
             }
         };
-
+        mRefreshTimeMillis = DEFAULT_REFRESH_TIME_MILLISECONDS;
         mHandler = new Handler();
     }
 
+    @VisibleForTesting
+    void onAdLoadSuccess(@NonNull final AdResponse adResponse) {
+        mBackoffPower = 1;
+        mAdResponse = adResponse;
+        // Do other ad loading setup. See AdFetcher & AdLoadTask.
+        mTimeoutMilliseconds = mAdResponse.getAdTimeoutMillis() == null
+                ? mTimeoutMilliseconds
+                : mAdResponse.getAdTimeoutMillis();
+        mRefreshTimeMillis = mAdResponse.getRefreshTimeMillis();
+        setNotLoading();
+
+        // Get our custom event from the ad response and load into the view.
+        AdLoader adLoader = AdLoader.fromAdResponse(mAdResponse, this);
+        if (adLoader != null) {
+            adLoader.load();
+        }
+        scheduleRefreshTimerIfEnabled();
+    }
+
+    @VisibleForTesting
+    void onAdLoadError(final VolleyError error) {
+        if (error instanceof MoPubNetworkError) {
+            // If provided, the MoPubNetworkError's refresh time takes precedence over the
+            // previously set refresh time.
+            // The only types of NetworkErrors that can possibly modify
+            // an ad's refresh time are CLEAR requests. For CLEAR requests that (erroneously) omit a
+            // refresh time header and for all other non-CLEAR types of NetworkErrors, we simply
+            // maintain the previous refresh time value.
+            final MoPubNetworkError moPubNetworkError = (MoPubNetworkError) error;
+            if (moPubNetworkError.getRefreshTimeMillis() != null) {
+                mRefreshTimeMillis = moPubNetworkError.getRefreshTimeMillis();
+            }
+        }
+
+        final MoPubErrorCode errorCode = getErrorCodeFromVolleyError(error, mContext);
+        if (errorCode == MoPubErrorCode.SERVER_ERROR) {
+            mBackoffPower++;
+        }
+
+        setNotLoading();
+        adDidFail(errorCode);
+    }
+
+    @VisibleForTesting
+    @NonNull
+    static MoPubErrorCode getErrorCodeFromVolleyError(@NonNull final VolleyError error,
+            @Nullable final Context context) {
+        final NetworkResponse networkResponse = error.networkResponse;
+
+        // For MoPubNetworkErrors, networkResponse is null.
+        if (error instanceof MoPubNetworkError) {
+            switch (((MoPubNetworkError) error).getReason()) {
+                case WARMING_UP:
+                    return MoPubErrorCode.WARMUP;
+                case NO_FILL:
+                    return MoPubErrorCode.NO_FILL;
+                default:
+                    return MoPubErrorCode.UNSPECIFIED;
+            }
+        }
+
+        if (networkResponse == null) {
+            if (!DeviceUtils.isNetworkAvailable(context)) {
+                return MoPubErrorCode.NO_CONNECTION;
+            }
+            return MoPubErrorCode.UNSPECIFIED;
+        }
+
+        if (error.networkResponse.statusCode >= 400) {
+            return MoPubErrorCode.SERVER_ERROR;
+        }
+
+        return MoPubErrorCode.UNSPECIFIED;
+    }
+
+    @Nullable
     public MoPubView getMoPubView() {
         return mMoPubView;
     }
 
     public void loadAd() {
+        mBackoffPower = 1;
+        internalLoadAd();
+    }
+
+    private void internalLoadAd() {
         mAdWasLoaded = true;
-        if (mAdConfiguration.getAdUnitId() == null) {
-            MoPubLog.d("Can't load an ad in this ad view because the ad unit ID is null. " +
+        if (TextUtils.isEmpty(mAdUnitId)) {
+            MoPubLog.d("Can't load an ad in this ad view because the ad unit ID is not set. " +
                     "Did you forget to call setAdUnitId()?");
             return;
         }
@@ -106,16 +229,8 @@ public void loadAd() {
             return;
         }
 
-        if (mLocation == null) {
-            mLocation = getLastKnownLocation(mContext,
-                    MoPub.getLocationPrecision(),
-                    MoPub.getLocationAwareness());
-        }
-
-        // If we have access to Google Play Services (GPS) but the advertising info
-        // is not cached then guarantee we get it before building the ad request url
-        // in the callback, this is a requirement from Google
-        GpsHelper.fetchAdvertisingInfoAsync(mContext, mGpsHelperListener);
+        String adUrl = generateAdUrl();
+        loadNonJavascript(adUrl);
     }
 
     void loadNonJavascript(String url) {
@@ -123,14 +238,13 @@ void loadNonJavascript(String url) {
 
         MoPubLog.d("Loading url: " + url);
         if (mIsLoading) {
-            if (mAdConfiguration.getAdUnitId() != null) {
-                MoPubLog.i("Already loading an ad for " + mAdConfiguration.getAdUnitId() + ", wait to finish.");
+            if (!TextUtils.isEmpty(mAdUnitId)) {  // This shouldn't be able to happen?
+                MoPubLog.i("Already loading an ad for " + mAdUnitId + ", wait to finish.");
             }
             return;
         }
 
         mUrl = url;
-        mAdConfiguration.setFailUrl(null);
         mIsLoading = true;
 
         fetchAd(mUrl);
@@ -146,21 +260,29 @@ void loadFailUrl(MoPubErrorCode errorCode) {
 
         Log.v("MoPub", "MoPubErrorCode: " + (errorCode == null ? "" : errorCode.toString()));
 
-        if (mAdConfiguration.getFailUrl() != null) {
-            MoPubLog.d("Loading failover url: " + mAdConfiguration.getFailUrl());
-            loadNonJavascript(mAdConfiguration.getFailUrl());
+        final String failUrl = mAdResponse == null ? "" : mAdResponse.getFailoverUrl();
+        if (!TextUtils.isEmpty(failUrl)) {
+            MoPubLog.d("Loading failover url: " + failUrl);
+            loadNonJavascript(failUrl);
         } else {
             // No other URLs to try, so signal a failure.
             adDidFail(MoPubErrorCode.NO_FILL);
         }
     }
 
+    @Deprecated
     void setFailUrl(String failUrl) {
-        mAdConfiguration.setFailUrl(failUrl);
+        // Does nothing.
     }
 
     void setNotLoading() {
         this.mIsLoading = false;
+        if (mActiveRequest != null) {
+            if (!mActiveRequest.isCanceled()) {
+                mActiveRequest.cancel();
+            }
+            mActiveRequest = null;
+        }
     }
 
     public String getKeywords() {
@@ -180,37 +302,50 @@ public void setLocation(Location location) {
     }
 
     public String getAdUnitId() {
-        return mAdConfiguration.getAdUnitId();
+        return mAdUnitId;
     }
 
-    public void setAdUnitId(String adUnitId) {
-        mAdConfiguration.setAdUnitId(adUnitId);
+    public void setAdUnitId(@NonNull String adUnitId) {
+        mAdUnitId = adUnitId;
+    }
+
+    public long getBroadcastIdentifier() {
+        return mBroadcastIdentifier;
     }
 
     public void setTimeout(int milliseconds) {
-        if (mAdFetcher != null) {
-            mAdFetcher.setTimeout(milliseconds);
-        }
+       mTimeoutMilliseconds = milliseconds;
     }
 
     public int getAdWidth() {
-        return mAdConfiguration.getWidth();
+        if (mAdResponse != null && mAdResponse.getWidth() != null) {
+            return mAdResponse.getWidth();
+        }
+
+        return 0;
     }
 
     public int getAdHeight() {
-        return mAdConfiguration.getHeight();
+        if (mAdResponse != null && mAdResponse.getHeight() != null) {
+            return mAdResponse.getHeight();
+        }
+
+        return 0;
     }
 
-    public String getClickthroughUrl() {
-        return mAdConfiguration.getClickthroughUrl();
+    @Deprecated
+    public String getClickTrackingUrl() {
+        return mAdResponse == null ? null : mAdResponse.getClickTrackingUrl();
     }
 
+    @Deprecated
     public String getRedirectUrl() {
-        return mAdConfiguration.getRedirectUrl();
+        return mAdResponse == null ? null : mAdResponse.getRedirectUrl();
     }
 
+    @Deprecated
     public String getResponseString() {
-        return mAdConfiguration.getResponseString();
+        return mAdResponse == null ? null : mAdResponse.getStringBody();
     }
 
     public boolean getAutorefreshEnabled() {
@@ -235,9 +370,7 @@ private void setAutorefreshEnabled(boolean enabled) {
         final boolean autorefreshChanged = mAdWasLoaded && (mAutoRefreshEnabled != enabled);
         if (autorefreshChanged) {
             final String enabledString = (enabled) ? "enabled" : "disabled";
-            final String adUnitId = (mAdConfiguration != null) ? mAdConfiguration.getAdUnitId() : null;
-
-            MoPubLog.d("Refresh " + enabledString + " for ad unit (" + adUnitId + ").");
+            MoPubLog.d("Refresh " + enabledString + " for ad unit (" + mAdUnitId + ").");
         }
 
         mAutoRefreshEnabled = enabled;
@@ -248,6 +381,14 @@ private void setAutorefreshEnabled(boolean enabled) {
         }
     }
 
+    @Nullable
+    public AdReport getAdReport() {
+        if (mAdUnitId != null && mAdResponse != null) {
+            return new AdReport(mAdUnitId, ClientMetadata.getInstance(mContext), mAdResponse);
+        }
+        return null;
+    }
+
     public boolean getTesting() {
         return mIsTesting;
     }
@@ -256,8 +397,9 @@ public void setTesting(boolean enabled) {
         mIsTesting = enabled;
     }
 
-    AdConfiguration getAdConfiguration() {
-        return mAdConfiguration;
+    @Deprecated
+    Object getAdConfiguration() {
+        return null;
     }
 
     boolean isDestroyed() {
@@ -272,84 +414,60 @@ void cleanup() {
             return;
         }
 
+        if (mActiveRequest != null) {
+            mActiveRequest.cancel();
+            mActiveRequest = null;
+        }
+
         setAutorefreshEnabled(false);
         cancelRefreshTimer();
 
         // WebView subclasses are not garbage-collected in a timely fashion on Froyo and below,
         // thanks to some persistent references in WebViewCore. We manually release some resources
         // to compensate for this "leak".
-
-        mAdFetcher.cleanup();
-        mAdFetcher = null;
-
-        mAdConfiguration.cleanup();
-
         mMoPubView = null;
+        mContext = null;
+        mUrlGenerator = null;
 
         // Flag as destroyed. LoadUrlTask checks this before proceeding in its onPostExecute().
         mIsDestroyed = true;
     }
 
-    void configureUsingHttpResponse(final HttpResponse response) {
-        mAdConfiguration.addHttpResponse(response);
-    }
-
     Integer getAdTimeoutDelay() {
-        return mAdConfiguration.getAdTimeoutDelay();
-    }
-
-    int getRefreshTimeMilliseconds() {
-        return mAdConfiguration.getRefreshTimeMilliseconds();
-    }
-
-    @Deprecated
-    void setRefreshTimeMilliseconds(int refreshTimeMilliseconds) {
-        mAdConfiguration.setRefreshTimeMilliseconds(refreshTimeMilliseconds);
+        return mAdResponse == null ? null : mAdResponse.getAdTimeoutMillis();
     }
 
     void trackImpression() {
-        new Thread(new Runnable() {
-            public void run () {
-                if (mAdConfiguration.getImpressionUrl() == null) return;
-
-                DefaultHttpClient httpClient = HttpClientFactory.create();
-                try {
-                    HttpGet httpget = new HttpGet(mAdConfiguration.getImpressionUrl());
-                    httpget.addHeader("User-Agent", mAdConfiguration.getUserAgent());
-                    httpClient.execute(httpget);
-                } catch (Exception e) {
-                    MoPubLog.d("Impression tracking failed : " + mAdConfiguration.getImpressionUrl(), e);
-                } finally {
-                    httpClient.getConnectionManager().shutdown();
-                }
-            }
-        }).start();
+        if (mAdResponse != null) {
+            TrackingRequest.makeTrackingHttpRequest(mAdResponse.getImpressionTrackingUrl(),
+                    mContext, BaseEvent.Name.IMPRESSION_REQUEST);
+        }
     }
 
     void registerClick() {
-        new Thread(new Runnable() {
-            public void run () {
-                if (mAdConfiguration.getClickthroughUrl() == null) return;
-
-                DefaultHttpClient httpClient = HttpClientFactory.create();
-                try {
-                    MoPubLog.d("Tracking click for: " + mAdConfiguration.getClickthroughUrl());
-                    HttpGet httpget = new HttpGet(mAdConfiguration.getClickthroughUrl());
-                    httpget.addHeader("User-Agent", mAdConfiguration.getUserAgent());
-                    httpClient.execute(httpget);
-                } catch (Exception e) {
-                    MoPubLog.d("Click tracking failed: " + mAdConfiguration.getClickthroughUrl(), e);
-                } finally {
-                    httpClient.getConnectionManager().shutdown();
-                }
-            }
-        }).start();
+        if (mAdResponse != null) {
+            TrackingRequest.makeTrackingHttpRequest(mAdResponse.getClickTrackingUrl(),
+                    mContext, BaseEvent.Name.CLICK_REQUEST);
+        }
     }
 
-    void fetchAd(String mUrl) {
-        if (mAdFetcher != null) {
-            mAdFetcher.fetchAdForUrl(mUrl);
+    void fetchAd(String url) {
+        MoPubView moPubView = getMoPubView();
+        if (moPubView == null || mContext == null) {
+            MoPubLog.d("Can't load an ad in this ad view because it was destroyed.");
+            setNotLoading();
+            return;
         }
+
+        AdRequest adRequest = new AdRequest(url,
+                moPubView.getAdFormat(),
+                mAdUnitId,
+                mContext,
+                mAdListener
+        );
+        RequestQueue requestQueue = Networking.getRequestQueue(mContext);
+        requestQueue.add(adRequest);
+        mActiveRequest = adRequest;
     }
 
     void forceRefresh() {
@@ -357,50 +475,61 @@ void forceRefresh() {
         loadAd();
     }
 
+    @Nullable
     String generateAdUrl() {
-        return mUrlGenerator
-                .withAdUnitId(mAdConfiguration.getAdUnitId())
+        return mUrlGenerator == null ? null : mUrlGenerator
+                .withAdUnitId(mAdUnitId)
                 .withKeywords(mKeywords)
                 .withLocation(mLocation)
-                .generateUrlString(getServerHostname());
+                .generateUrlString(Constants.HOST);
     }
 
     void adDidFail(MoPubErrorCode errorCode) {
         MoPubLog.i("Ad failed to load.");
         setNotLoading();
+
+        MoPubView moPubView = getMoPubView();
+        if (moPubView == null) {
+            return;
+        }
+
         scheduleRefreshTimerIfEnabled();
-        getMoPubView().adFailed(errorCode);
+        moPubView.adFailed(errorCode);
     }
 
     void scheduleRefreshTimerIfEnabled() {
         cancelRefreshTimer();
-        if (mAutoRefreshEnabled && mAdConfiguration.getRefreshTimeMilliseconds() > 0) {
-            mHandler.postDelayed(mRefreshRunnable, mAdConfiguration.getRefreshTimeMilliseconds());
-        }
+        if (mAutoRefreshEnabled && mRefreshTimeMillis != null && mRefreshTimeMillis > 0) {
 
+            mHandler.postDelayed(mRefreshRunnable,
+                    Math.min(MAX_REFRESH_TIME_MILLISECONDS,
+                            mRefreshTimeMillis * (long) Math.pow(BACKOFF_FACTOR, mBackoffPower)));
+        }
     }
 
     void setLocalExtras(Map<String, Object> localExtras) {
         mLocalExtras = (localExtras != null)
-                ? new HashMap<String,Object>(localExtras)
-                : new HashMap<String,Object>();
+                ? new TreeMap<String,Object>(localExtras)
+                : new TreeMap<String,Object>();
     }
 
+    /**
+     * Returns a copied map of localExtras
+     */
     Map<String, Object> getLocalExtras() {
         return (mLocalExtras != null)
-                ? new HashMap<String,Object>(mLocalExtras)
-                : new HashMap<String,Object>();
+                ? new TreeMap<String,Object>(mLocalExtras)
+                : new TreeMap<String,Object>();
     }
 
     private void cancelRefreshTimer() {
         mHandler.removeCallbacks(mRefreshRunnable);
     }
 
-    private String getServerHostname() {
-        return mIsTesting ? MoPubView.HOST_FOR_TESTING : MoPubView.HOST;
-    }
-
     private boolean isNetworkAvailable() {
+        if (mContext == null) {
+            return false;
+        }
         // If we don't have network state access, just assume the network is up.
         int result = mContext.checkCallingPermission(ACCESS_NETWORK_STATE);
         if (result == PackageManager.PERMISSION_DENIED) return true;
@@ -430,10 +559,14 @@ public void run() {
     }
 
     private FrameLayout.LayoutParams getAdLayoutParams(View view) {
-        int width = mAdConfiguration.getWidth();
-        int height = mAdConfiguration.getHeight();
+        Integer width = null;
+        Integer height = null;
+        if (mAdResponse != null) {
+            width = mAdResponse.getWidth();
+            height = mAdResponse.getHeight();
+        }
 
-        if (getShouldHonorServerDimensions(view) && width > 0 && height > 0) {
+        if (width != null && height != null && getShouldHonorServerDimensions(view) && width > 0 && height > 0) {
             int scaledWidth = Dips.asIntPixels(width, mContext);
             int scaledHeight = Dips.asIntPixels(height, mContext);
 
@@ -443,17 +576,16 @@ public void run() {
         }
     }
 
-    class AdViewControllerGpsHelperListener implements GpsHelperListener {
-        @Override
-        public void onFetchAdInfoCompleted() {
-            String adUrl = generateAdUrl();
-            loadNonJavascript(adUrl);
-        }
+    @Deprecated // for testing
+    @VisibleForTesting
+    Integer getRefreshTimeMillis() {
+        return mRefreshTimeMillis;
     }
 
-    @Deprecated
-    void setGpsHelperListener(GpsHelperListener gpsHelperListener) {
-        mGpsHelperListener = gpsHelperListener;
+    @Deprecated // for testing
+    @VisibleForTesting
+    void setRefreshTimeMillis(@Nullable final Integer refreshTimeMillis) {
+        mRefreshTimeMillis = refreshTimeMillis;
     }
 
     @Deprecated
@@ -475,7 +607,7 @@ public void customEventActionWillBegin() {
 
     @Deprecated
     public void setClickthroughUrl(String clickthroughUrl) {
-        mAdConfiguration.setClickthroughUrl(clickthroughUrl);
+        // Does nothing
     }
 
     /**
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseHtmlWebView.java b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseHtmlWebView.java
index 6f8cea10..6af45e32 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseHtmlWebView.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseHtmlWebView.java
@@ -4,6 +4,9 @@
 import android.graphics.Color;
 import android.view.MotionEvent;
 import android.view.View;
+
+import com.mopub.common.AdReport;
+import com.mopub.common.Constants;
 import com.mopub.common.logging.MoPubLog;
 
 import static com.mopub.common.util.VersionCode.ICE_CREAM_SANDWICH;
@@ -14,13 +17,13 @@
     private final ViewGestureDetector mViewGestureDetector;
     private boolean mClicked;
 
-    public BaseHtmlWebView(Context context, AdConfiguration adConfiguration) {
+    public BaseHtmlWebView(Context context, AdReport adReport) {
         super(context);
 
         disableScrollingAndZoom();
         getSettings().setJavaScriptEnabled(true);
 
-        mViewGestureDetector = new ViewGestureDetector(context, this, adConfiguration);
+        mViewGestureDetector = new ViewGestureDetector(context, this, adReport);
         mViewGestureDetector.setUserClickListener(this);
 
         if (currentApiLevel().isAtLeast(ICE_CREAM_SANDWICH)) {
@@ -52,7 +55,8 @@ private void disableScrollingAndZoom() {
     }
 
     void loadHtmlResponse(String htmlResponse) {
-        loadDataWithBaseURL("http://ads.mopub.com/", htmlResponse, "text/html", "utf-8", null);
+        loadDataWithBaseURL("http://" + Constants.HOST + "/", htmlResponse, "text/html", "utf-8",
+                null);
     }
 
     void initializeOnTouchListener(final boolean isScrollable) {
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseInterstitialActivity.java b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseInterstitialActivity.java
index 5fb5f449..1b1ddf21 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseInterstitialActivity.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseInterstitialActivity.java
@@ -1,50 +1,46 @@
 package com.mopub.mobileads;
 
 import android.app.Activity;
-import android.graphics.drawable.StateListDrawable;
+import android.content.Intent;
 import android.os.Bundle;
+import android.support.annotation.Nullable;
 import android.view.View;
-import android.view.View.OnClickListener;
 import android.view.Window;
 import android.view.WindowManager;
-import android.widget.ImageButton;
-import android.widget.ImageView;
-import android.widget.RelativeLayout;
+import android.widget.FrameLayout.LayoutParams;
 
-import com.mopub.common.util.Dips;
-import com.mopub.mobileads.util.Interstitials;
+import com.mopub.common.AdReport;
+import com.mopub.common.CloseableLayout;
+import com.mopub.common.CloseableLayout.OnCloseListener;
+import com.mopub.common.DataKeys;
 
-import static android.view.View.INVISIBLE;
-import static android.view.View.VISIBLE;
-import static com.mopub.common.util.Drawables.INTERSTITIAL_CLOSE_BUTTON_NORMAL;
-import static com.mopub.common.util.Drawables.INTERSTITIAL_CLOSE_BUTTON_PRESSED;
-import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
 
 abstract class BaseInterstitialActivity extends Activity {
-    private OnClickListener mCloseOnClickListener;
+    protected AdReport mAdReport;
 
     enum JavaScriptWebViewCallbacks {
-        WEB_VIEW_DID_APPEAR("javascript:webviewDidAppear();"),
-        WEB_VIEW_DID_CLOSE("javascript:webviewDidClose();");
+        // The ad server appends these functions to the MRAID javascript to help with third party
+        // impression tracking.
+        WEB_VIEW_DID_APPEAR("webviewDidAppear();"),
+        WEB_VIEW_DID_CLOSE("webviewDidClose();");
+
+        private String mJavascript;
+        private JavaScriptWebViewCallbacks(String javascript) {
+            mJavascript = javascript;
+        }
 
-        private String mUrl;
-        private JavaScriptWebViewCallbacks(String url) {
-            mUrl = url;
+        protected String getJavascript() {
+            return mJavascript;
         }
 
         protected String getUrl() {
-            return mUrl;
+            return "javascript:" + mJavascript;
         }
     }
 
-    private static final float CLOSE_BUTTON_SIZE_DP = 50f;
-    private static final float CLOSE_BUTTON_PADDING = 8f;
-
-    private ImageView mCloseButton;
-    private RelativeLayout mLayout;
-    private int mButtonSize;
-    private int mButtonPadding;
-    private long mBroadcastIdentifier;
+    private CloseableLayout mCloseableLayout;
+    private Long mBroadcastIdentifier;
 
     public abstract View getAdView();
 
@@ -52,85 +48,60 @@ protected String getUrl() {
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
 
+        Intent intent = getIntent();
+        mBroadcastIdentifier = getBroadcastIdentifierFromIntent(intent);
+        mAdReport = getAdReportFromIntent(intent);
+
         requestWindowFeature(Window.FEATURE_NO_TITLE);
         getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
 
-        mButtonSize = Dips.asIntPixels(CLOSE_BUTTON_SIZE_DP, this);
-        mButtonPadding = Dips.asIntPixels(CLOSE_BUTTON_PADDING, this);
-        mCloseOnClickListener = new OnClickListener() {
+        View adView = getAdView();
+
+        mCloseableLayout = new CloseableLayout(this);
+        mCloseableLayout.setOnCloseListener(new OnCloseListener() {
             @Override
-            public void onClick(final View view) {
+            public void onClose() {
                 finish();
             }
-        };
-
-        // The contentView needs to be a RelativeLayout so the close button can be properly aligned
-        mLayout = new RelativeLayout(this);
-        final RelativeLayout.LayoutParams adViewLayout = new RelativeLayout.LayoutParams(
-                RelativeLayout.LayoutParams.MATCH_PARENT, RelativeLayout.LayoutParams.MATCH_PARENT);
-        mLayout.addView(getAdView(), adViewLayout);
-        setContentView(mLayout);
-
-        final AdConfiguration adConfiguration = getAdConfiguration();
-        if (adConfiguration != null) {
-            mBroadcastIdentifier = adConfiguration.getBroadcastIdentifier();
-        }
+        });
+        mCloseableLayout.addView(adView,
+                new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
+        setContentView(mCloseableLayout);
+
 
-        createInterstitialCloseButton();
     }
 
     @Override
     protected void onDestroy() {
-        mLayout.removeAllViews();
+        mCloseableLayout.removeAllViews();
         super.onDestroy();
     }
 
-    long getBroadcastIdentifier() {
+    Long getBroadcastIdentifier() {
         return mBroadcastIdentifier;
     }
 
     protected void showInterstitialCloseButton() {
-        mCloseButton.setVisibility(VISIBLE);
+        mCloseableLayout.setCloseVisible(true);
     }
 
     protected void hideInterstitialCloseButton() {
-        mCloseButton.setVisibility(INVISIBLE);
+        mCloseableLayout.setCloseVisible(false);
     }
 
-    protected AdConfiguration getAdConfiguration() {
-        AdConfiguration adConfiguration;
-        try {
-            adConfiguration = (AdConfiguration) getIntent().getSerializableExtra(AD_CONFIGURATION_KEY);
-        } catch (ClassCastException e) {
-            adConfiguration = null;
+    protected static Long getBroadcastIdentifierFromIntent(Intent intent) {
+        if (intent.hasExtra(BROADCAST_IDENTIFIER_KEY)) {
+            return intent.getLongExtra(BROADCAST_IDENTIFIER_KEY, -1L);
         }
-        return adConfiguration;
+        return null;
     }
 
-    void addCloseEventRegion() {
-        final int buttonSizePixels = Dips.dipsToIntPixels(CLOSE_BUTTON_SIZE_DP, this);
-        final RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(buttonSizePixels, buttonSizePixels);
-        layoutParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
-        layoutParams.addRule(RelativeLayout.ALIGN_PARENT_TOP);
-        Interstitials.addCloseEventRegion(mLayout, layoutParams, mCloseOnClickListener);
-    }
-
-    private void createInterstitialCloseButton() {
-        mCloseButton = new ImageButton(this);
-        StateListDrawable states = new StateListDrawable();
-        states.addState(new int[] {-android.R.attr.state_pressed}, INTERSTITIAL_CLOSE_BUTTON_NORMAL.decodeImage(this));
-        states.addState(new int[] {android.R.attr.state_pressed}, INTERSTITIAL_CLOSE_BUTTON_PRESSED.decodeImage(this));
-        mCloseButton.setImageDrawable(states);
-        mCloseButton.setBackgroundDrawable(null);
-        mCloseButton.setOnClickListener(new OnClickListener() {
-            public void onClick(View v) {
-                finish();
-            }
-        });
-
-        RelativeLayout.LayoutParams buttonLayout = new RelativeLayout.LayoutParams(mButtonSize, mButtonSize);
-        buttonLayout.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
-        buttonLayout.setMargins(mButtonPadding, 0, mButtonPadding, 0);
-        mLayout.addView(mCloseButton, buttonLayout);
+    @Nullable
+    protected static AdReport getAdReportFromIntent(Intent intent) {
+        try {
+            return (AdReport) intent.getSerializableExtra(DataKeys.AD_REPORT_KEY);
+        } catch (ClassCastException e) {
+            return null;
+        }
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseVideoPlayerActivity.java b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseVideoPlayerActivity.java
index ec9ce51c..ba2482a7 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseVideoPlayerActivity.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseVideoPlayerActivity.java
@@ -9,15 +9,15 @@
 import com.mopub.mobileads.util.vast.VastVideoConfiguration;
 
 import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
-import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
 import static com.mopub.mobileads.VastVideoViewController.VAST_VIDEO_CONFIGURATION;
 
-class BaseVideoPlayerActivity extends Activity {
+public class BaseVideoPlayerActivity extends Activity {
     static final String VIDEO_CLASS_EXTRAS_KEY = "video_view_class_name";
-    static final String VIDEO_URL = "video_url";
+    public static final String VIDEO_URL = "video_url";
 
-    static void startMraid(final Context context, final String videoUrl, final AdConfiguration adConfiguration) {
-        final Intent intentVideoPlayerActivity = createIntentMraid(context, videoUrl, adConfiguration);
+    public static void startMraid(final Context context, final String videoUrl) {
+        final Intent intentVideoPlayerActivity = createIntentMraid(context, videoUrl);
         try {
             context.startActivity(intentVideoPlayerActivity);
         } catch (ActivityNotFoundException e) {
@@ -26,20 +26,18 @@ static void startMraid(final Context context, final String videoUrl, final AdCon
     }
 
     static Intent createIntentMraid(final Context context,
-            final String videoUrl,
-            final AdConfiguration adConfiguration) {
+            final String videoUrl) {
         final Intent intentVideoPlayerActivity = new Intent(context, MraidVideoPlayerActivity.class);
         intentVideoPlayerActivity.setFlags(FLAG_ACTIVITY_NEW_TASK);
         intentVideoPlayerActivity.putExtra(VIDEO_CLASS_EXTRAS_KEY, "mraid");
         intentVideoPlayerActivity.putExtra(VIDEO_URL, videoUrl);
-        intentVideoPlayerActivity.putExtra(AD_CONFIGURATION_KEY, adConfiguration);
         return intentVideoPlayerActivity;
     }
 
     static void startVast(final Context context,
             final VastVideoConfiguration vastVideoConfiguration,
-            final AdConfiguration adConfiguration) {
-        final Intent intentVideoPlayerActivity = createIntentVast(context, vastVideoConfiguration, adConfiguration);
+            final long broadcastIdentifier) {
+        final Intent intentVideoPlayerActivity = createIntentVast(context, vastVideoConfiguration, broadcastIdentifier);
         try {
             context.startActivity(intentVideoPlayerActivity);
         } catch (ActivityNotFoundException e) {
@@ -49,12 +47,12 @@ static void startVast(final Context context,
 
     static Intent createIntentVast(final Context context,
             final VastVideoConfiguration vastVideoConfiguration,
-            final AdConfiguration adConfiguration) {
+            final long broadcastIdentifier) {
         final Intent intentVideoPlayerActivity = new Intent(context, MraidVideoPlayerActivity.class);
         intentVideoPlayerActivity.setFlags(FLAG_ACTIVITY_NEW_TASK);
         intentVideoPlayerActivity.putExtra(VIDEO_CLASS_EXTRAS_KEY, "vast");
         intentVideoPlayerActivity.putExtra(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-        intentVideoPlayerActivity.putExtra(AD_CONFIGURATION_KEY, adConfiguration);
+        intentVideoPlayerActivity.putExtra(BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
         return intentVideoPlayerActivity;
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseVideoViewController.java b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseVideoViewController.java
index 195b1612..d9ab5587 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseVideoViewController.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseVideoViewController.java
@@ -4,22 +4,23 @@
 import android.content.Context;
 import android.content.Intent;
 import android.os.Bundle;
+import android.support.annotation.Nullable;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.RelativeLayout;
 import android.widget.VideoView;
+
 import com.mopub.common.logging.MoPubLog;
 
-import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_CLICK;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_FAIL;
 
-abstract class BaseVideoViewController {
+public abstract class BaseVideoViewController {
     private final Context mContext;
     private final RelativeLayout mLayout;
     private final BaseVideoViewControllerListener mBaseVideoViewControllerListener;
-    private long mBroadcastIdentifier;
+    @Nullable private Long mBroadcastIdentifier;
 
-    interface BaseVideoViewControllerListener {
+    public interface BaseVideoViewControllerListener {
         void onSetContentView(final View view);
         void onSetRequestedOrientation(final int requestedOrientation);
         void onFinish();
@@ -28,14 +29,14 @@ void onStartActivityForResult(final Class<? extends Activity> clazz,
                 final Bundle extras);
     }
 
-    BaseVideoViewController(final Context context, final long broadcastIdentifier, final BaseVideoViewControllerListener baseVideoViewControllerListener) {
+    protected BaseVideoViewController(final Context context, @Nullable final Long broadcastIdentifier, final BaseVideoViewControllerListener baseVideoViewControllerListener) {
         mContext = context.getApplicationContext();
         mBroadcastIdentifier = broadcastIdentifier;
         mBaseVideoViewControllerListener = baseVideoViewControllerListener;
         mLayout = new RelativeLayout(mContext);
     }
 
-     void onCreate() {
+     protected void onCreate() {
         final RelativeLayout.LayoutParams adViewLayout = new RelativeLayout.LayoutParams(
                 RelativeLayout.LayoutParams.FILL_PARENT, RelativeLayout.LayoutParams.WRAP_CONTENT);
         adViewLayout.addRule(RelativeLayout.CENTER_IN_PARENT);
@@ -43,12 +44,12 @@ void onCreate() {
         mBaseVideoViewControllerListener.onSetContentView(mLayout);
     }
 
-    abstract VideoView getVideoView();
-    abstract void onPause();
-    abstract void onResume();
-    abstract void onDestroy();
+    protected abstract VideoView getVideoView();
+    protected abstract void onPause();
+    protected abstract void onResume();
+    protected abstract void onDestroy();
 
-    boolean backButtonEnabled() {
+    public boolean backButtonEnabled() {
         return true;
     }
 
@@ -56,38 +57,37 @@ void onActivityResult(final int requestCode, final int resultCode, final Intent
         // By default, the activity result is ignored
     }
 
-    BaseVideoViewControllerListener getBaseVideoViewControllerListener() {
+    protected BaseVideoViewControllerListener getBaseVideoViewControllerListener() {
         return mBaseVideoViewControllerListener;
     }
 
-    Context getContext() {
+    protected Context getContext() {
         return mContext;
     }
 
-    ViewGroup getLayout() {
+    public ViewGroup getLayout() {
         return mLayout;
     }
 
-
-    void videoError(boolean shouldFinish) {
-        MoPubLog.d("Error: video can not be played.");
+    protected void videoError(boolean shouldFinish) {
+        MoPubLog.e("Video cannot be played.");
         broadcastAction(ACTION_INTERSTITIAL_FAIL);
         if (shouldFinish) {
            mBaseVideoViewControllerListener.onFinish();
         }
     }
 
-    void videoCompleted(boolean shouldFinish) {
+    protected void videoCompleted(boolean shouldFinish) {
         if (shouldFinish) {
             mBaseVideoViewControllerListener.onFinish();
         }
     }
 
-    void videoClicked() {
-        broadcastAction(ACTION_INTERSTITIAL_CLICK);
-    }
-
     void broadcastAction(final String action) {
-        EventForwardingBroadcastReceiver.broadcastAction(mContext, mBroadcastIdentifier, action);
+        if (mBroadcastIdentifier != null) {
+            EventForwardingBroadcastReceiver.broadcastAction(mContext, mBroadcastIdentifier, action);
+        } else {
+            MoPubLog.w("Tried to broadcast a video event without a braodcast identifier to send to.");
+        }
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseWebView.java b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseWebView.java
index c9f633be..a9331a31 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseWebView.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseWebView.java
@@ -1,6 +1,13 @@
 package com.mopub.mobileads;
 
 import android.content.Context;
+import android.graphics.Color;
+import android.graphics.PixelFormat;
+import android.os.Build.VERSION;
+import android.os.Build.VERSION_CODES;
+import android.support.annotation.NonNull;
+import android.view.Gravity;
+import android.view.WindowManager;
 import android.webkit.WebSettings;
 import android.webkit.WebView;
 
@@ -9,6 +16,7 @@
 import com.mopub.mobileads.util.WebViews;
 
 public class BaseWebView extends WebView {
+    private static boolean sDeadlockCleared = false;
     protected boolean mIsDestroyed;
 
     public BaseWebView(Context context) {
@@ -20,6 +28,11 @@ public BaseWebView(Context context) {
         enablePlugins(false);
 
         WebViews.setDisableJSChromeClient(this);
+
+        if (!sDeadlockCleared) {
+            clearWebViewDeadlock(getContext());
+            sDeadlockCleared = true;
+        }
     }
 
     protected void enablePlugins(final boolean enabled) {
@@ -39,7 +52,13 @@ protected void enablePlugins(final boolean enabled) {
     public void destroy() {
         mIsDestroyed = true;
 
+        // Needed to prevent receiving the following error on Android versions using WebViewClassic
+        // https://code.google.com/p/android/issues/detail?id=65833.
         Views.removeFromParent(this);
+
+        // Even after removing from the parent, WebViewClassic can leak because of a static
+        // reference from HTML5VideoViewProcessor. Removing children fixes this problem.
+        removeAllViews();
         super.destroy();
     }
 
@@ -47,4 +66,43 @@ public void destroy() {
     void setIsDestroyed(boolean isDestroyed) {
         mIsDestroyed = isDestroyed;
     }
+
+    /**
+     * This fixes https://code.google.com/p/android/issues/detail?id=63754,
+     * which occurs on KitKat devices. When a WebView containing an HTML5 video is
+     * is destroyed it can deadlock the WebView thread until another hardware accelerated WebView
+     * is added to the view hierarchy and restores the GL context. Since we need to use WebView
+     * before adding it to the view hierarchy, this method clears the deadlock by adding a
+     * separate invisible WebView.
+     *
+     * This potential deadlock must be cleared anytime you attempt to access a WebView that
+     * is not added to the view hierarchy.
+     */
+    private void clearWebViewDeadlock(@NonNull final Context context) {
+        if (VERSION.SDK_INT == VERSION_CODES.KITKAT) {
+            // Create an invisible webview
+            final WebView webView = new WebView(context.getApplicationContext());
+            webView.setBackgroundColor(Color.TRANSPARENT);
+
+            // For the deadlock to be cleared, we must load content and add to the view hierarchy. Since
+            // we don't have an activity context, we'll use a system window.
+            webView.loadDataWithBaseURL(null, "", "text/html", "UTF-8", null);
+            final WindowManager.LayoutParams params = new WindowManager.LayoutParams();
+            params.width = 1;
+            params.height = 1;
+            // Unlike other system window types TYPE_TOAST doesn't require extra permissions
+            params.type = WindowManager.LayoutParams.TYPE_TOAST;
+            params.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
+                    | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE
+                    | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
+            params.format = PixelFormat.TRANSPARENT;
+            params.gravity = Gravity.START | Gravity.TOP;
+            final WindowManager windowManager =
+                    (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
+
+            windowManager.addView(webView, params);
+        }
+    }
+
+
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventBannerAdapter.java b/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventBannerAdapter.java
index 5cdad507..bd9abaad 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventBannerAdapter.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventBannerAdapter.java
@@ -2,23 +2,30 @@
 
 import android.content.Context;
 import android.os.Handler;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 
+import com.mopub.common.AdReport;
+import com.mopub.common.Constants;
+import com.mopub.common.Preconditions;
 import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.Json;
 import com.mopub.mobileads.CustomEventBanner.CustomEventBannerListener;
 import com.mopub.mobileads.factories.CustomEventBannerFactory;
 
-import java.util.HashMap;
 import java.util.Map;
+import java.util.TreeMap;
 
-import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
+import static com.mopub.common.DataKeys.AD_HEIGHT;
+import static com.mopub.common.DataKeys.AD_REPORT_KEY;
+import static com.mopub.common.DataKeys.AD_WIDTH;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
 import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_TIMEOUT;
 import static com.mopub.mobileads.MoPubErrorCode.UNSPECIFIED;
 
 public class CustomEventBannerAdapter implements CustomEventBannerListener {
-    public static final int DEFAULT_BANNER_TIMEOUT_DELAY = 10000;
+    public static final int DEFAULT_BANNER_TIMEOUT_DELAY = Constants.TEN_SECONDS_MILLIS;
     private boolean mInvalidated;
     private MoPubView mMoPubView;
     private Context mContext;
@@ -30,12 +37,15 @@
     private final Runnable mTimeout;
     private boolean mStoredAutorefresh;
 
-    public CustomEventBannerAdapter(MoPubView moPubView, String className, String classData) {
+    public CustomEventBannerAdapter(@NonNull MoPubView moPubView,
+            @NonNull String className,
+            @NonNull Map<String, String> serverExtras,
+            long broadcastIdentifier,
+            @Nullable AdReport adReport) {
+        Preconditions.checkNotNull(serverExtras);
         mHandler = new Handler();
         mMoPubView = moPubView;
         mContext = moPubView.getContext();
-        mLocalExtras = new HashMap<String, Object>();
-        mServerExtras = new HashMap<String, String>();
         mTimeout = new Runnable() {
             @Override
             public void run() {
@@ -55,19 +65,16 @@ public void run() {
         }
 
         // Attempt to load the JSON extras into mServerExtras.
-        try {
-            mServerExtras = Json.jsonStringToMap(classData);
-        } catch (Exception exception) {
-            MoPubLog.d("Failed to create Map from JSON: " + classData + exception.toString());
-        }
+        mServerExtras = new TreeMap<String,String>(serverExtras);
 
         mLocalExtras = mMoPubView.getLocalExtras();
         if (mMoPubView.getLocation() != null) {
             mLocalExtras.put("location", mMoPubView.getLocation());
         }
-        if (mMoPubView.getAdViewController() != null) {
-            mLocalExtras.put(AD_CONFIGURATION_KEY, mMoPubView.getAdViewController().getAdConfiguration());
-        }
+        mLocalExtras.put(BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
+        mLocalExtras.put(AD_REPORT_KEY, adReport);
+        mLocalExtras.put(AD_WIDTH, mMoPubView.getAdWidth());
+        mLocalExtras.put(AD_HEIGHT, mMoPubView.getAdHeight());
     }
 
     void loadAd() {
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventInterstitialAdapter.java b/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventInterstitialAdapter.java
index f4a74c41..e9139058 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventInterstitialAdapter.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventInterstitialAdapter.java
@@ -2,22 +2,27 @@
 
 import android.content.Context;
 import android.os.Handler;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 
+import com.mopub.common.AdReport;
+import com.mopub.common.Constants;
+import com.mopub.common.Preconditions;
 import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.Json;
 import com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
 import com.mopub.mobileads.factories.CustomEventInterstitialFactory;
 
-import java.util.HashMap;
 import java.util.Map;
+import java.util.TreeMap;
 
-import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
+import static com.mopub.common.DataKeys.AD_REPORT_KEY;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
 import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_TIMEOUT;
 import static com.mopub.mobileads.MoPubErrorCode.UNSPECIFIED;
 
 public class CustomEventInterstitialAdapter implements CustomEventInterstitialListener {
-    public static final int DEFAULT_INTERSTITIAL_TIMEOUT_DELAY = 30000;
+    public static final int DEFAULT_INTERSTITIAL_TIMEOUT_DELAY = Constants.THIRTY_SECONDS_MILLIS;
 
     private final MoPubInterstitial mMoPubInterstitial;
     private boolean mInvalidated;
@@ -29,11 +34,14 @@
     private final Handler mHandler;
     private final Runnable mTimeout;
 
-    public CustomEventInterstitialAdapter(final MoPubInterstitial moPubInterstitial, final String className, final String jsonParams) {
+    public CustomEventInterstitialAdapter(@NonNull final MoPubInterstitial moPubInterstitial,
+            @NonNull final String className,
+            @NonNull final Map<String, String> serverExtras,
+            long broadcastIdentifier,
+            @Nullable AdReport adReport) {
+        Preconditions.checkNotNull(serverExtras);
         mHandler = new Handler();
         mMoPubInterstitial = moPubInterstitial;
-        mServerExtras = new HashMap<String, String>();
-        mLocalExtras = new HashMap<String, Object>();
         mContext = mMoPubInterstitial.getActivity();
         mTimeout = new Runnable() {
             @Override
@@ -53,22 +61,13 @@ public void run() {
             return;
         }
 
-        // Attempt to load the JSON extras into mServerExtras.
-        try {
-            mServerExtras = Json.jsonStringToMap(jsonParams);
-        } catch (Exception exception) {
-            MoPubLog.d("Failed to create Map from JSON: " + jsonParams);
-        }
-
+        mServerExtras = new TreeMap<String, String>(serverExtras);
         mLocalExtras = mMoPubInterstitial.getLocalExtras();
         if (mMoPubInterstitial.getLocation() != null) {
             mLocalExtras.put("location", mMoPubInterstitial.getLocation());
         }
-
-        final AdViewController adViewController = mMoPubInterstitial.getMoPubInterstitialView().getAdViewController();
-        if (adViewController != null) {
-            mLocalExtras.put(AD_CONFIGURATION_KEY, adViewController.getAdConfiguration());
-        }
+        mLocalExtras.put(BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
+        mLocalExtras.put(AD_REPORT_KEY, adReport);
     }
     
     void loadInterstitial() {
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventRewardedVideo.java b/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventRewardedVideo.java
new file mode 100644
index 00000000..266472ab
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventRewardedVideo.java
@@ -0,0 +1,124 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.LifecycleListener;
+import com.mopub.common.MoPubLifecycleManager;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+
+import java.util.Map;
+
+/**
+ *
+ */
+public abstract class CustomEventRewardedVideo {
+    /**
+     * This marker interface is used to indicate that an object is a listener for a 3rd party SDKs
+     * rewarded video system.
+     */
+    @VisibleForTesting
+    protected static interface CustomEventRewardedVideoListener {}
+
+    /**
+     * Called by the {@link MoPubRewardedVideoManager} after loading the custom event.
+     */
+    @Nullable
+    @VisibleForTesting
+    protected abstract CustomEventRewardedVideoListener getVideoListenerForSdk();
+
+    /**
+     * Provides a {@link LifecycleListener} if the custom event's ad network wishes to be notified of
+     * activity lifecycle events in the application.
+     *
+     * @return a LifecycleListener. May be null.
+     */
+    @Nullable
+    @VisibleForTesting
+    protected abstract LifecycleListener getLifecycleListener();
+
+    /**
+     * Called by the {@link MoPubRewardedVideoManager} after loading the custom event.
+     * This should return the "ad unit id", "zone id" or similar identifier for the network.
+     * May be empty if the network does not have anything more specific than an application ID.
+     *
+     * @return the id string for this ad unit with the ad network.
+     */
+    @NonNull
+    protected abstract String getAdNetworkId();
+
+    /**
+     * Called to when the custom event is no longer used. Implementers should cancel any
+     * pending requests. The initialized SDK may be reused by another CustomEvent instance
+     * and should not be shut down or cleaned up.
+     */
+    protected abstract void onInvalidate();
+
+    /**
+     * The MoPub ad loading system calls this after MoPub indicates that this custom event should
+     * be loaded.
+     *
+     * @param launcherActivity the "main activity" of the app. Useful for initializing sdks.
+     * @param localExtras
+     * @param serverExtras
+     */
+    final void loadCustomEvent(@NonNull Activity launcherActivity,
+            @NonNull Map<String, Object> localExtras,
+            @NonNull Map<String, String> serverExtras) {
+        try {
+            if (checkAndInitializeSdk(launcherActivity, localExtras, serverExtras)) {
+                MoPubLifecycleManager.getInstance(launcherActivity).addLifecycleListener(getLifecycleListener());
+            }
+            loadWithSdkInitialized(launcherActivity, localExtras, serverExtras);
+        } catch (Exception e) {
+            MoPubLog.e(e.getMessage());
+        }
+    }
+
+    /**
+     * Sets up the 3rd party ads SDK if it needs configuration. Extenders should use this
+     * to do any static initialization the first time this method is run by any class instance.
+     * From then on, the SDK should be reused without initialization.
+     *
+     * @return true if the SDK performed initialization.
+     */
+    protected abstract boolean checkAndInitializeSdk(@NonNull Activity launcherActivity,
+            @NonNull Map<String, Object> localExtras,
+            @NonNull Map<String, String> serverExtras)
+            throws Exception;
+
+    /**
+     * Runs the ad-loading logic for the 3rd party SDK. localExtras & serverExtras should together
+     * contain all the data needed to load an ad.
+     *
+     * Implementers should also use this method (or checkAndInitializeSdk)
+     * to register a listener for their SDK, wrap it in a
+     * {@link com.mopub.mobileads.CustomEventRewardedVideo.CustomEventRewardedVideoListener}
+     *
+     * This method should not call any {@link MoPubRewardedVideoManager} event methods directly
+     * (onAdLoadSuccess, etc). Instead the SDK delegate/listener should call these methods.
+     *
+     * @param activity the "main activity" of the app. Useful for initializing sdks.
+     * @param localExtras
+     * @param serverExtras
+     */
+    protected abstract void loadWithSdkInitialized(@NonNull Activity activity,
+            @NonNull Map<String, Object> localExtras,
+            @NonNull Map<String, String> serverExtras)
+            throws Exception;
+
+    /**
+     * Implementers should query the 3rd party SDK for whether there is a video available for the
+     * 3rd party SDK & ID represented by the custom event.
+     *
+     * @return true iff a video is available to play.
+     */
+    protected abstract boolean hasVideoAvailable();
+
+    /**
+     * Implementers should now play the rewarded video for this custom event.
+     */
+    protected abstract void showVideo();
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/EventForwardingBroadcastReceiver.java b/mopub-sdk/src/main/java/com/mopub/mobileads/EventForwardingBroadcastReceiver.java
index 624995f2..d5561d92 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/EventForwardingBroadcastReceiver.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/EventForwardingBroadcastReceiver.java
@@ -6,19 +6,20 @@
 import android.content.IntentFilter;
 import android.support.v4.content.LocalBroadcastManager;
 
+import com.mopub.common.DataKeys;
+
 import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_INVALID_STATE;
 
-class EventForwardingBroadcastReceiver extends BroadcastReceiver {
+public class EventForwardingBroadcastReceiver extends BroadcastReceiver {
     private final CustomEventInterstitialListener mCustomEventInterstitialListener;
     private final long mBroadcastIdentifier;
     private Context mContext;
 
-    static final String BROADCAST_IDENTIFIER_KEY = "broadcastIdentifier";
-    static final String ACTION_INTERSTITIAL_FAIL = "com.mopub.action.interstitial.fail";
-    static final String ACTION_INTERSTITIAL_SHOW = "com.mopub.action.interstitial.show";
-    static final String ACTION_INTERSTITIAL_DISMISS = "com.mopub.action.interstitial.dismiss";
-    static final String ACTION_INTERSTITIAL_CLICK = "com.mopub.action.interstitial.click";
+    public static final String ACTION_INTERSTITIAL_FAIL = "com.mopub.action.interstitial.fail";
+    public static final String ACTION_INTERSTITIAL_SHOW = "com.mopub.action.interstitial.show";
+    public static final String ACTION_INTERSTITIAL_DISMISS = "com.mopub.action.interstitial.dismiss";
+    public static final String ACTION_INTERSTITIAL_CLICK = "com.mopub.action.interstitial.click";
     private static IntentFilter sIntentFilter;
 
 
@@ -30,11 +31,11 @@ public EventForwardingBroadcastReceiver(CustomEventInterstitialListener customEv
 
     static void broadcastAction(final Context context, final long broadcastIdentifier, final String action) {
         Intent intent = new Intent(action);
-        intent.putExtra(BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
+        intent.putExtra(DataKeys.BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
         LocalBroadcastManager.getInstance(context.getApplicationContext()).sendBroadcast(intent);
     }
 
-    static IntentFilter getHtmlInterstitialIntentFilter() {
+    public static IntentFilter getHtmlInterstitialIntentFilter() {
         if (sIntentFilter == null) {
             sIntentFilter = new IntentFilter();
             sIntentFilter.addAction(ACTION_INTERSTITIAL_FAIL);
@@ -57,7 +58,7 @@ public void onReceive(Context context, Intent intent) {
          * this here because there is no appropriate IntentFilter condition that can recreate this
          * behavior.
          */
-        final long receivedIdentifier = intent.getLongExtra(BROADCAST_IDENTIFIER_KEY, -1);
+        final long receivedIdentifier = intent.getLongExtra(DataKeys.BROADCAST_IDENTIFIER_KEY, -1);
         if (mBroadcastIdentifier != receivedIdentifier) {
             return;
         }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlBanner.java b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlBanner.java
index c8a4942b..dcdf11bd 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlBanner.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlBanner.java
@@ -1,16 +1,16 @@
 package com.mopub.mobileads;
 
 import android.content.Context;
-import android.net.Uri;
 
+import com.mopub.common.AdReport;
+import com.mopub.common.DataKeys;
+import com.mopub.common.logging.MoPubLog;
 import com.mopub.mobileads.factories.HtmlBannerWebViewFactory;
 
 import java.util.Map;
 
-import static com.mopub.mobileads.AdFetcher.CLICKTHROUGH_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
-import static com.mopub.mobileads.AdFetcher.REDIRECT_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.SCROLLABLE_KEY;
+import static com.mopub.common.DataKeys.AD_REPORT_KEY;
+import static com.mopub.mobileads.MoPubErrorCode.INTERNAL_ERROR;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_INVALID_STATE;
 
 public class HtmlBanner extends CustomEventBanner {
@@ -28,18 +28,25 @@ protected void loadBanner(
         String redirectUrl;
         String clickthroughUrl;
         Boolean isScrollable;
+        AdReport adReport;
         if (extrasAreValid(serverExtras)) {
-            htmlData = Uri.decode(serverExtras.get(HTML_RESPONSE_BODY_KEY));
-            redirectUrl = serverExtras.get(REDIRECT_URL_KEY);
-            clickthroughUrl = serverExtras.get(CLICKTHROUGH_URL_KEY);
-            isScrollable = Boolean.valueOf(serverExtras.get(SCROLLABLE_KEY));
+            htmlData = serverExtras.get(DataKeys.HTML_RESPONSE_BODY_KEY);
+            redirectUrl = serverExtras.get(DataKeys.REDIRECT_URL_KEY);
+            clickthroughUrl = serverExtras.get(DataKeys.CLICKTHROUGH_URL_KEY);
+            isScrollable = Boolean.valueOf(serverExtras.get(DataKeys.SCROLLABLE_KEY));
+            try {
+                adReport = (AdReport) localExtras.get(AD_REPORT_KEY);
+            } catch (ClassCastException e) {
+                MoPubLog.e("LocalExtras contained an incorrect type.");
+                customEventBannerListener.onBannerFailed(INTERNAL_ERROR);
+                return;
+            }
         } else {
             customEventBannerListener.onBannerFailed(NETWORK_INVALID_STATE);
             return;
         }
 
-        AdConfiguration adConfiguration = AdConfiguration.extractFromMap(localExtras);
-        mHtmlBannerWebView = HtmlBannerWebViewFactory.create(context, customEventBannerListener, isScrollable, redirectUrl, clickthroughUrl, adConfiguration);
+        mHtmlBannerWebView = HtmlBannerWebViewFactory.create(context, adReport, customEventBannerListener, isScrollable, redirectUrl, clickthroughUrl);
         AdViewController.setShouldHonorServerDimensions(mHtmlBannerWebView);
         mHtmlBannerWebView.loadHtmlResponse(htmlData);
     }
@@ -52,6 +59,6 @@ protected void onInvalidate() {
     }
 
     private boolean extrasAreValid(Map<String, String> serverExtras) {
-        return serverExtras.containsKey(HTML_RESPONSE_BODY_KEY);
+        return serverExtras.containsKey(DataKeys.HTML_RESPONSE_BODY_KEY);
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlBannerWebView.java b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlBannerWebView.java
index b707d66f..358ea16c 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlBannerWebView.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlBannerWebView.java
@@ -2,13 +2,15 @@
 
 import android.content.Context;
 
+import com.mopub.common.AdReport;
+
 import static com.mopub.mobileads.CustomEventBanner.CustomEventBannerListener;
 
 public class HtmlBannerWebView extends BaseHtmlWebView {
     public static final String EXTRA_AD_CLICK_DATA = "com.mopub.intent.extra.AD_CLICK_DATA";
 
-    public HtmlBannerWebView(Context context, AdConfiguration adConfiguration) {
-        super(context, adConfiguration);
+    public HtmlBannerWebView(Context context, AdReport adReport) {
+        super(context, adReport);
     }
 
     public void init(CustomEventBannerListener customEventBannerListener, boolean isScrollable, String redirectUrl, String clickthroughUrl) {
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlInterstitial.java b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlInterstitial.java
index d3ddf4a9..f0643055 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlInterstitial.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlInterstitial.java
@@ -1,35 +1,43 @@
 package com.mopub.mobileads;
 
-import android.net.Uri;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.CreativeOrientation;
 
 import java.util.Map;
 
-import static com.mopub.mobileads.AdFetcher.CLICKTHROUGH_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
-import static com.mopub.mobileads.AdFetcher.REDIRECT_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.SCROLLABLE_KEY;
+import static com.mopub.common.DataKeys.CLICKTHROUGH_URL_KEY;
+import static com.mopub.common.DataKeys.CREATIVE_ORIENTATION_KEY;
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
+import static com.mopub.common.DataKeys.REDIRECT_URL_KEY;
+import static com.mopub.common.DataKeys.SCROLLABLE_KEY;
 
 public class HtmlInterstitial extends ResponseBodyInterstitial {
     private String mHtmlData;
     private boolean mIsScrollable;
     private String mRedirectUrl;
     private String mClickthroughUrl;
+    @NonNull
+    private CreativeOrientation mOrientation;
 
     @Override
     protected void extractExtras(Map<String, String> serverExtras) {
-        mHtmlData = Uri.decode(serverExtras.get(HTML_RESPONSE_BODY_KEY));
+        mHtmlData = serverExtras.get(HTML_RESPONSE_BODY_KEY);
         mIsScrollable = Boolean.valueOf(serverExtras.get(SCROLLABLE_KEY));
         mRedirectUrl = serverExtras.get(REDIRECT_URL_KEY);
         mClickthroughUrl = serverExtras.get(CLICKTHROUGH_URL_KEY);
+        mOrientation = CreativeOrientation.fromHeader(serverExtras.get(CREATIVE_ORIENTATION_KEY));
     }
 
     @Override
     protected void preRenderHtml(CustomEventInterstitialListener customEventInterstitialListener) {
-        MoPubActivity.preRenderHtml(mContext, customEventInterstitialListener, mHtmlData);
+        MoPubActivity.preRenderHtml(mContext, mAdReport, customEventInterstitialListener, mHtmlData);
     }
 
     @Override
-    protected void showInterstitial() {
-        MoPubActivity.start(mContext, mHtmlData, mIsScrollable, mRedirectUrl, mClickthroughUrl, mAdConfiguration);
+    public void showInterstitial() {
+        MoPubActivity.start(mContext, mHtmlData, mAdReport, mIsScrollable,
+                mRedirectUrl, mClickthroughUrl, mOrientation,
+                mBroadcastIdentifier);
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlInterstitialWebView.java b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlInterstitialWebView.java
index 54f10701..78795c1b 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlInterstitialWebView.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlInterstitialWebView.java
@@ -1,25 +1,17 @@
 package com.mopub.mobileads;
 
-import android.annotation.TargetApi;
 import android.content.Context;
 import android.os.Handler;
-import android.webkit.JavascriptInterface;
 
-import static com.mopub.common.util.VersionCode.HONEYCOMB;
-import static com.mopub.common.util.VersionCode.currentApiLevel;
+import com.mopub.common.AdReport;
+
 import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
 
 public class HtmlInterstitialWebView extends BaseHtmlWebView {
     private Handler mHandler;
 
-    protected static final String MOPUB_JS_INTERFACE_NAME = "mopubUriInterface";
-
-    interface MoPubUriJavascriptFireFinishLoadListener {
-        abstract void onInterstitialLoaded();
-    }
-
-    public HtmlInterstitialWebView(Context context, AdConfiguration adConfiguration) {
-        super(context, adConfiguration);
+    public HtmlInterstitialWebView(Context context, AdReport adReport) {
+        super(context, adReport);
 
         mHandler = new Handler();
     }
@@ -30,61 +22,12 @@ public void init(final CustomEventInterstitialListener customEventInterstitialLi
         HtmlInterstitialWebViewListener htmlInterstitialWebViewListener = new HtmlInterstitialWebViewListener(customEventInterstitialListener);
         HtmlWebViewClient htmlWebViewClient = new HtmlWebViewClient(htmlInterstitialWebViewListener, this, clickthroughUrl, redirectUrl);
         setWebViewClient(htmlWebViewClient);
-
-        addMoPubUriJavascriptInterface(new MoPubUriJavascriptFireFinishLoadListener() {
-            @Override
-            public void onInterstitialLoaded() {
-                if (!mIsDestroyed) {
-                    customEventInterstitialListener.onInterstitialLoaded();
-                }
-            }
-        });
     }
 
     private void postHandlerRunnable(Runnable r) {
         mHandler.post(r);
     }
 
-    /*
-     * XXX (2/15/12): This is a workaround for a problem on ICS devices where
-     * WebViews with layout height WRAP_CONTENT can mysteriously render with
-     * zero height. This seems to happen when calling loadData() with HTML that
-     * sets window.location during its "onload" event. We use loadData() when
-     * displaying interstitials, and our creatives use window.location to
-     * communicate ad loading status to AdViews. This results in zero-height
-     * interstitials. We counteract this by using a Javascript interface object
-     * to signal loading status, rather than modifying window.location.
-     */
-    void addMoPubUriJavascriptInterface(final MoPubUriJavascriptFireFinishLoadListener moPubUriJavascriptFireFinishLoadListener) {
-        final class MoPubUriJavascriptInterface {
-            // This method appears to be unused, since it will only be called from JavaScript.
-            @SuppressWarnings("unused")
-            @JavascriptInterface
-            public boolean fireFinishLoad() {
-                HtmlInterstitialWebView.this.postHandlerRunnable(new Runnable() {
-                    @Override
-                    public void run() {
-                        moPubUriJavascriptFireFinishLoadListener.onInterstitialLoaded();
-                    }
-                });
-
-                return true;
-            }
-        }
-
-        addJavascriptInterface(new MoPubUriJavascriptInterface(), MOPUB_JS_INTERFACE_NAME);
-    }
-
-    @TargetApi(11)
-    @Override
-    public void destroy() {
-        if (currentApiLevel().isAtLeast(HONEYCOMB)) {
-            removeJavascriptInterface(MOPUB_JS_INTERFACE_NAME);
-        }
-
-        super.destroy();
-    }
-
     static class HtmlInterstitialWebViewListener implements HtmlWebViewListener {
         private final CustomEventInterstitialListener mCustomEventInterstitialListener;
 
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlWebViewClient.java b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlWebViewClient.java
index 1b8726d3..858053a3 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlWebViewClient.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlWebViewClient.java
@@ -4,13 +4,18 @@
 import android.content.Intent;
 import android.graphics.Bitmap;
 import android.net.Uri;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.webkit.WebView;
 import android.webkit.WebViewClient;
 
 import com.mopub.common.MoPubBrowser;
+import com.mopub.common.Preconditions;
 import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.IntentUtils;
-import com.mopub.mobileads.util.Utils;
+import com.mopub.common.util.Intents;
+import com.mopub.exceptions.IntentNotResolvableException;
+import com.mopub.exceptions.UrlParseException;
 
 import static com.mopub.mobileads.MoPubErrorCode.UNSPECIFIED;
 
@@ -32,22 +37,53 @@
         mContext = htmlWebView.getContext();
     }
 
+    /**
+     * Called upon user click, when the WebView attempts to load a new URL. Attempts to handle mopub
+     * and phone-specific schemes, open mopubnativebrowser links in the device browser, deep-links
+     * in the corresponding application, and all other links in the MoPub in-app browser.
+     */
     @Override
-    public boolean shouldOverrideUrlLoading(WebView view, String url) {
-        if (handleSpecialMoPubScheme(url) || handlePhoneScheme(url) || handleNativeBrowserScheme(url)) {
+    public boolean shouldOverrideUrlLoading(final WebView view, final String url) {
+        MoPubLog.d("Ad event URL: " + url);
+
+        if (handleSpecialMoPubScheme(url)) {
             return true;
         }
 
-        MoPubLog.d("Ad clicked. Click URL: " + url);
+        if (Intents.isAboutScheme(url)) {
+            MoPubLog.d("Link to about page ignored.");
+            return true;
+        }
 
-        // this is added because http/s can also be intercepted
-        if (!isWebSiteUrl(url) && IntentUtils.canHandleApplicationUrl(mContext, url)) {
-            if (launchApplicationUrl(url)) {
-                return true;
+        if (handlePhoneScheme(url)) {
+            return true;
+        }
+
+        // MoPubNativeBrowser URLs
+        if (Intents.isNativeBrowserScheme(url)) {
+            final String errorMessage = "Unable to load mopub native browser url: " + url;
+            try {
+                final Intent intent = Intents.intentForNativeBrowserScheme(url);
+                launchIntentForUserClick(mContext, intent, errorMessage);
+            } catch (UrlParseException e) {
+                MoPubLog.d(errorMessage + ". " + e.getMessage());
             }
+
+            return true;
+        }
+
+        if (Intents.isHttpUrl(url)) {
+            showMoPubBrowserForUrl(url);
+            return true;
+        }
+
+        // Non-http(s) URLs like app deep links
+        if (Intents.canHandleApplicationUrl(mContext, url)) {
+            launchApplicationUrl(url);
+            return true;
         }
 
-        showMoPubBrowserForUrl(url);
+        MoPubLog.d("Link ignored. Unable to handle url: " + url);
         return true;
     }
 
@@ -105,46 +141,6 @@ private boolean handlePhoneScheme(String url) {
         return true;
     }
 
-    private boolean isNativeBrowserScheme(String url) {
-        return url.startsWith("mopubnativebrowser://");
-    }
-
-    private boolean handleNativeBrowserScheme(String url) {
-        if (!isNativeBrowserScheme(url)) {
-            return false;
-        }
-
-        Uri uri = Uri.parse(url);
-
-        String urlToOpenInNativeBrowser;
-        try {
-            urlToOpenInNativeBrowser = uri.getQueryParameter("url");
-        } catch (UnsupportedOperationException e) {
-            MoPubLog.w("Could not handle url: " + url);
-            return false;
-        }
-
-        if (!"navigate".equals(uri.getHost()) || urlToOpenInNativeBrowser == null) {
-            return false;
-        }
-
-        Uri intentUri = Uri.parse(urlToOpenInNativeBrowser);
-
-        Intent intent = new Intent(Intent.ACTION_VIEW, intentUri);
-        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-
-        String errorMessage = "Could not handle intent with URI: " + url
-                + ". Is this intent supported on your phone?";
-
-        launchIntentForUserClick(mContext, intent, errorMessage);
-
-        return true;
-    }
-
-    private boolean isWebSiteUrl(String url) {
-        return url.startsWith("http://") || url.startsWith("https://");
-    }
-
     private boolean launchApplicationUrl(String url) {
         Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
         intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
@@ -155,23 +151,20 @@ private boolean launchApplicationUrl(String url) {
     }
 
     private void showMoPubBrowserForUrl(String url) {
-        if (url == null || url.equals("")) url = "about:blank";
+        if (url == null || url.equals("")) {
+            url = "about:blank";
+        }
         MoPubLog.d("Final URI to show in browser: " + url);
-        Intent intent = new Intent(mContext, MoPubBrowser.class);
-        intent.putExtra(MoPubBrowser.DESTINATION_URL_KEY, url);
-        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+
+        final Bundle extras = new Bundle();
+        extras.putString(MoPubBrowser.DESTINATION_URL_KEY, url);
+        Intent intent = Intents.getStartActivityIntent(mContext, MoPubBrowser.class, extras);
 
         String errorMessage = "Could not handle intent action. "
                 + ". Perhaps you forgot to declare com.mopub.common.MoPubBrowser"
                 + " in your Android manifest file.";
 
-        boolean handledByMoPubBrowser = launchIntentForUserClick(mContext, intent, errorMessage);
-
-        if (!handledByMoPubBrowser) {
-            intent = new Intent(Intent.ACTION_VIEW, Uri.parse("about:blank"));
-            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-            launchIntentForUserClick(mContext, intent, null);
-        }
+        launchIntentForUserClick(mContext, intent, errorMessage);
     }
 
     private void handleCustomIntentFromUri(Uri uri) {
@@ -195,17 +188,27 @@ private void handleCustomIntentFromUri(Uri uri) {
         launchIntentForUserClick(mContext, customIntent, errorMessage);
     }
 
-    boolean launchIntentForUserClick(Context context, Intent intent, String errorMessage) {
+    boolean launchIntentForUserClick(@Nullable final Context context, @NonNull final Intent intent,
+            @Nullable final String errorMessage) {
+        Preconditions.NoThrow.checkNotNull(intent);
+
+        if (context == null) {
+            MoPubLog.d(errorMessage);
+            return false;
+        }
+
         if (!mHtmlWebView.wasClicked()) {
             return false;
         }
 
-        boolean wasIntentStarted = Utils.executeIntent(context, intent, errorMessage);
-        if (wasIntentStarted) {
+        try {
+            Intents.startActivity(context, intent);
             mHtmlWebViewListener.onClicked();
             mHtmlWebView.onResetUserClick();
+            return true;
+        } catch (IntentNotResolvableException e) {
+            MoPubLog.d(errorMessage);
+            return false;
         }
-
-        return wasIntentStarted;
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubActivity.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubActivity.java
index 223c015e..bf0168d3 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubActivity.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubActivity.java
@@ -9,13 +9,21 @@
 import android.webkit.WebView;
 import android.webkit.WebViewClient;
 
+import com.mopub.common.AdReport;
+import com.mopub.common.CreativeOrientation;
+import com.mopub.common.DataKeys;
+import com.mopub.common.util.DeviceUtils;
 import com.mopub.mobileads.factories.HtmlInterstitialWebViewFactory;
 
-import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
-import static com.mopub.mobileads.AdFetcher.CLICKTHROUGH_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
-import static com.mopub.mobileads.AdFetcher.REDIRECT_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.SCROLLABLE_KEY;
+import java.io.Serializable;
+
+import static com.mopub.common.DataKeys.AD_REPORT_KEY;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
+import static com.mopub.common.DataKeys.CLICKTHROUGH_URL_KEY;
+import static com.mopub.common.DataKeys.CREATIVE_ORIENTATION_KEY;
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
+import static com.mopub.common.DataKeys.REDIRECT_URL_KEY;
+import static com.mopub.common.DataKeys.SCROLLABLE_KEY;
 import static com.mopub.mobileads.BaseInterstitialActivity.JavaScriptWebViewCallbacks.WEB_VIEW_DID_APPEAR;
 import static com.mopub.mobileads.BaseInterstitialActivity.JavaScriptWebViewCallbacks.WEB_VIEW_DID_CLOSE;
 import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
@@ -30,8 +38,11 @@
 public class MoPubActivity extends BaseInterstitialActivity {
     private HtmlInterstitialWebView mHtmlInterstitialWebView;
 
-    public static void start(Context context, String htmlData, boolean isScrollable, String redirectUrl, String clickthroughUrl, AdConfiguration adConfiguration) {
-        Intent intent = createIntent(context, htmlData, isScrollable, redirectUrl, clickthroughUrl, adConfiguration);
+    public static void start(Context context, String htmlData, AdReport adReport,
+            boolean isScrollable, String redirectUrl, String clickthroughUrl,
+            CreativeOrientation creativeOrientation, long broadcastIdentifier) {
+        Intent intent = createIntent(context, htmlData, adReport, isScrollable,
+                redirectUrl, clickthroughUrl, creativeOrientation, broadcastIdentifier);
         try {
             context.startActivity(intent);
         } catch (ActivityNotFoundException anfe) {
@@ -39,27 +50,26 @@ public static void start(Context context, String htmlData, boolean isScrollable,
         }
     }
 
-    static Intent createIntent(Context context, String htmlData, boolean isScrollable, String redirectUrl, String clickthroughUrl, AdConfiguration adConfiguration) {
+    static Intent createIntent(Context context,
+            String htmlData, AdReport adReport, boolean isScrollable, String redirectUrl,
+            String clickthroughUrl, CreativeOrientation orientation, long broadcastIdentifier) {
         Intent intent = new Intent(context, MoPubActivity.class);
         intent.putExtra(HTML_RESPONSE_BODY_KEY, htmlData);
         intent.putExtra(SCROLLABLE_KEY, isScrollable);
         intent.putExtra(CLICKTHROUGH_URL_KEY, clickthroughUrl);
         intent.putExtra(REDIRECT_URL_KEY, redirectUrl);
-        intent.putExtra(AD_CONFIGURATION_KEY, adConfiguration);
+        intent.putExtra(BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
+        intent.putExtra(AD_REPORT_KEY, adReport);
+        intent.putExtra(CREATIVE_ORIENTATION_KEY, orientation);
         intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
         return intent;
     }
 
-    static void preRenderHtml(final Context context, final CustomEventInterstitialListener customEventInterstitialListener, String htmlData) {
-        HtmlInterstitialWebView dummyWebView = HtmlInterstitialWebViewFactory.create(context, customEventInterstitialListener, false, null, null, null);
+    static void preRenderHtml(final Context context, final AdReport adReport,
+            final CustomEventInterstitialListener customEventInterstitialListener,
+            String htmlData) {
+        HtmlInterstitialWebView dummyWebView = HtmlInterstitialWebViewFactory.create(context, adReport, customEventInterstitialListener, false, null, null);
         dummyWebView.enablePlugins(false);
-
-        dummyWebView.addMoPubUriJavascriptInterface(new HtmlInterstitialWebView.MoPubUriJavascriptFireFinishLoadListener() {
-            @Override
-            public void onInterstitialLoaded() {
-                customEventInterstitialListener.onInterstitialLoaded();
-            }
-        });
         dummyWebView.setWebViewClient(new WebViewClient() {
             @Override
             public boolean shouldOverrideUrlLoading(WebView view, String url) {
@@ -83,7 +93,7 @@ public View getAdView() {
         String clickthroughUrl = intent.getStringExtra(CLICKTHROUGH_URL_KEY);
         String htmlResponse = intent.getStringExtra(HTML_RESPONSE_BODY_KEY);
 
-        mHtmlInterstitialWebView = HtmlInterstitialWebViewFactory.create(getApplicationContext(), new BroadcastingInterstitialListener(), isScrollable, redirectUrl, clickthroughUrl, getAdConfiguration());
+        mHtmlInterstitialWebView = HtmlInterstitialWebViewFactory.create(getApplicationContext(), mAdReport, new BroadcastingInterstitialListener(), isScrollable, redirectUrl, clickthroughUrl);
         mHtmlInterstitialWebView.loadHtmlResponse(htmlResponse);
 
         return mHtmlInterstitialWebView;
@@ -93,6 +103,15 @@ public View getAdView() {
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
 
+        // Lock the device orientation
+        Serializable orientationExtra = getIntent().getSerializableExtra(DataKeys.CREATIVE_ORIENTATION_KEY);
+        CreativeOrientation requestedOrientation;
+        if (orientationExtra == null || !(orientationExtra instanceof CreativeOrientation)) {
+            requestedOrientation = CreativeOrientation.UNDEFINED;
+        } else {
+            requestedOrientation = (CreativeOrientation) orientationExtra;
+        }
+        DeviceUtils.lockOrientation(this, requestedOrientation);
         broadcastAction(this, getBroadcastIdentifier(), ACTION_INTERSTITIAL_SHOW);
     }
 
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubBrowserController.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubBrowserController.java
deleted file mode 100644
index ff9a8f49..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubBrowserController.java
+++ /dev/null
@@ -1,54 +0,0 @@
-package com.mopub.mobileads;
-
-
-import android.content.Context;
-import android.content.Intent;
-import android.net.Uri;
-import android.util.Log;
-import com.mopub.common.MoPubBrowser;
-import com.mopub.common.util.IntentUtils;
-import com.mopub.mobileads.util.Utils;
-
-class MoPubBrowserController extends MraidAbstractController {
-    private static final String LOGTAG = "MoPubBrowserController";
-    private Context mContext;
-
-    MoPubBrowserController(MraidView view) {
-        super(view);
-        mContext = view.getContext();
-    }
-    
-    protected void open(String url) {
-        Log.d(LOGTAG, "Opening url: " + url);
-        
-        final MraidView mraidView = getMraidView();
-        if (mraidView.getMraidListener() != null) {
-            mraidView.getMraidListener().onOpen(mraidView);
-        }
-
-        // this is added because http/s can also be intercepted
-        if (!isWebSiteUrl(url) && IntentUtils.canHandleApplicationUrl(mContext, url)) {
-            launchApplicationUrl(url);
-            return;
-        }
-
-        Intent i = new Intent(mContext, MoPubBrowser.class);
-        i.putExtra(MoPubBrowser.DESTINATION_URL_KEY, url);
-        i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-        mContext.startActivity(i);
-    }
-
-
-    private boolean launchApplicationUrl(String url) {
-        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
-        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-
-        String errorMessage = "Unable to open intent.";
-
-        return Utils.executeIntent(getMraidView().getContext(), intent, errorMessage);
-    }
-
-    private boolean isWebSiteUrl(String url) {
-        return url.startsWith("http://") || url.startsWith("https://");
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubConversionTracker.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubConversionTracker.java
index f1f98dc6..edcf4b3f 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubConversionTracker.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubConversionTracker.java
@@ -2,31 +2,21 @@
 
 import android.content.Context;
 import android.content.SharedPreferences;
+import android.support.annotation.NonNull;
+
 import com.mopub.common.BaseUrlGenerator;
 import com.mopub.common.ClientMetadata;
-import com.mopub.common.GpsHelper;
+import com.mopub.common.Constants;
 import com.mopub.common.SharedPreferencesHelper;
 import com.mopub.common.logging.MoPubLog;
-import com.mopub.mobileads.factories.HttpClientFactory;
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpResponse;
-import org.apache.http.HttpStatus;
-import org.apache.http.client.methods.HttpGet;
-import org.apache.http.impl.client.DefaultHttpClient;
+import com.mopub.network.TrackingRequest;
+import com.mopub.volley.VolleyError;
 
 public class MoPubConversionTracker {
-    private static final String TRACK_HOST = "ads.mopub.com";
-    private static final String TRACK_HANDLER = "/m/open";
-
     private Context mContext;
     private String mIsTrackedKey;
     private SharedPreferences mSharedPreferences;
     private String mPackageName;
-    private ConversionTrackerGpsHelperListener mConversionTrackerGpsHelperListener;
-
-    public MoPubConversionTracker() {
-        mConversionTrackerGpsHelperListener = new ConversionTrackerGpsHelperListener();
-    }
 
     public void reportAppOpen(Context context) {
         if (context == null) {
@@ -39,7 +29,19 @@ public void reportAppOpen(Context context) {
         mSharedPreferences = SharedPreferencesHelper.getSharedPreferences(mContext);
 
         if (!isAlreadyTracked()) {
-            GpsHelper.fetchAdvertisingInfoAsync(mContext, mConversionTrackerGpsHelperListener);
+            TrackingRequest.makeTrackingHttpRequest(new ConversionUrlGenerator().generateUrlString(Constants.HOST),
+                    mContext, new TrackingRequest.Listener() {
+                @Override
+                public void onResponse(@NonNull String url) {
+                    mSharedPreferences
+                            .edit()
+                            .putBoolean(mIsTrackedKey, true)
+                            .commit();
+                }
+
+                @Override
+                public void onErrorResponse(final VolleyError volleyError) { }
+            });
         } else {
             MoPubLog.d("Conversion already tracked");
         }
@@ -52,15 +54,12 @@ private boolean isAlreadyTracked() {
     private class ConversionUrlGenerator extends BaseUrlGenerator {
         @Override
         public String generateUrlString(String serverHostname) {
-            initUrlString(serverHostname, TRACK_HANDLER);
-
+            initUrlString(serverHostname, Constants.CONVERSION_TRACKING_HANDLER);
             setApiVersion("6");
             setPackageId(mPackageName);
-
             ClientMetadata clientMetadata = ClientMetadata.getInstance(mContext);
-            setUdid(clientMetadata.getAdvertisingId());
-            setDoNotTrack(clientMetadata.isDoNotTrackSet());
             setAppVersion(clientMetadata.getAppVersion());
+            appendAdvertisingInfoTemplates();
             return getFinalUrlString();
         }
 
@@ -68,46 +67,4 @@ private void setPackageId(String packageName) {
             addParam("id", packageName);
         }
     }
-
-    private class TrackOpen implements Runnable {
-        public void run() {
-            String url = new ConversionUrlGenerator().generateUrlString(TRACK_HOST);
-            MoPubLog.d("Conversion track: " + url);
-
-            DefaultHttpClient httpClient = HttpClientFactory.create();
-            HttpResponse response;
-            try {
-                HttpGet httpget = new HttpGet(url);
-                response = httpClient.execute(httpget);
-            } catch (Exception e) {
-                MoPubLog.d("Conversion track failed [" + e.getClass().getSimpleName() + "]: " + url);
-                return;
-            }
-
-            if (response.getStatusLine().getStatusCode() != HttpStatus.SC_OK) {
-                MoPubLog.d("Conversion track failed: Status code != 200.");
-                return;
-            }
-
-            HttpEntity entity = response.getEntity();
-            if (entity == null || entity.getContentLength() == 0) {
-                MoPubLog.d("Conversion track failed: Response was empty.");
-                return;
-            }
-
-            // If we made it here, the request has been tracked
-            MoPubLog.d("Conversion track successful.");
-            mSharedPreferences
-                    .edit()
-                    .putBoolean(mIsTrackedKey, true)
-                    .commit();
-        }
-    }
-
-    class ConversionTrackerGpsHelperListener implements GpsHelper.GpsHelperListener {
-        @Override
-        public void onFetchAdInfoCompleted() {
-            new Thread(new TrackOpen()).start();
-        }
-    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubErrorCode.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubErrorCode.java
index a858a746..d3322c04 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubErrorCode.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubErrorCode.java
@@ -2,10 +2,12 @@
 
 public enum MoPubErrorCode {
     NO_FILL("No ads found."),
+    WARMUP("Ad unit is warming up. Try again in a few minutes."),
     SERVER_ERROR("Unable to connect to MoPub adserver."),
     INTERNAL_ERROR("Unable to serve ad due to invalid internal state."),
     CANCELLED("Ad request was cancelled."),
-    
+    NO_CONNECTION("No internet connection detected."),
+
     ADAPTER_NOT_FOUND("Unable to find Native Network or Custom Event adapter."),
     ADAPTER_CONFIGURATION_ERROR("Native Network or Custom Event adapter was configured incorrectly."),
     NETWORK_TIMEOUT("Third-party network failed to respond in a timely manner."),
@@ -15,14 +17,17 @@
     VIDEO_CACHE_ERROR("Error creating a cache to store downloaded videos."),
     VIDEO_DOWNLOAD_ERROR("Error downloading video."),
 
+    VIDEO_NOT_AVAILABLE("No video loaded for ad unit."),
+    VIDEO_PLAYBACK_ERROR("Error playing a video."),
+
     UNSPECIFIED("Unspecified error.");
-    
+
     private final String message;
-    
+
     private MoPubErrorCode(String message) {
         this.message = message;
     }
-    
+
     @Override
     public String toString() {
         return this.message;
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubInterstitial.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubInterstitial.java
index be773f6c..5aa4176d 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubInterstitial.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubInterstitial.java
@@ -3,7 +3,9 @@
 import android.app.Activity;
 import android.content.Context;
 import android.location.Location;
+import android.text.TextUtils;
 
+import com.mopub.common.AdFormat;
 import com.mopub.common.MoPub;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.mobileads.factories.CustomEventInterstitialAdapterFactory;
@@ -11,8 +13,6 @@
 import java.util.Map;
 
 import static com.mopub.common.LocationService.LocationAwareness;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_DATA;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_NAME;
 import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
 
 public class MoPubInterstitial implements CustomEventInterstitialAdapter.CustomEventInterstitialAdapterListener {
@@ -253,8 +253,17 @@ public MoPubInterstitialView(Context context) {
         }
 
         @Override
-        protected void loadCustomEvent(Map<String, String> paramsMap) {
-            if (paramsMap == null) {
+        public AdFormat getAdFormat() {
+            return AdFormat.INTERSTITIAL;
+        }
+
+        @Override
+        protected void loadCustomEvent(String customEventClassName, Map<String, String> serverExtras) {
+            if (mAdViewController == null) {
+                return;
+            }
+
+            if (TextUtils.isEmpty(customEventClassName)) {
                 MoPubLog.d("Couldn't invoke custom event because the server did not specify one.");
                 loadFailUrl(ADAPTER_NOT_FOUND);
                 return;
@@ -268,8 +277,10 @@ protected void loadCustomEvent(Map<String, String> paramsMap) {
 
             mCustomEventInterstitialAdapter = CustomEventInterstitialAdapterFactory.create(
                     MoPubInterstitial.this,
-                    paramsMap.get(CUSTOM_EVENT_NAME.getKey()),
-                    paramsMap.get(CUSTOM_EVENT_DATA.getKey()));
+                    customEventClassName,
+                    serverExtras,
+                    mAdViewController.getBroadcastIdentifier(),
+                    mAdViewController.getAdReport());
             mCustomEventInterstitialAdapter.setAdapterListener(MoPubInterstitial.this);
             mCustomEventInterstitialAdapter.loadInterstitial();
         }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoListener.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoListener.java
new file mode 100644
index 00000000..50d4f927
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoListener.java
@@ -0,0 +1,45 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+
+import com.mopub.common.MoPubReward;
+
+import java.util.Set;
+
+/**
+ * Listener for rewarded video events. Implementers of this interface should be long-lived.
+ */
+public interface MoPubRewardedVideoListener {
+
+    /**
+     * Called when the adUnitId has loaded. At this point you should be able to call
+     * {@link com.mopub.common.MoPub#showRewardedVideo(String)} to show the video.
+     */
+    public void onRewardedVideoLoadSuccess(@NonNull String adUnitId);
+
+    /**
+     * Called when a video fails to load for the given ad unit id. The provided error code will
+     * give more insight into the reason for the failure to load.
+     */
+    public void onRewardedVideoLoadFailure(@NonNull String adUnitId, @NonNull MoPubErrorCode errorCode);
+
+    /**
+     * Called when a rewarded video starts playing.
+     */
+    public void onRewardedVideoStarted(@NonNull String adUnitId);
+
+    /**
+     * Called when there is an error during video playback.
+     */
+    public void onRewardedVideoPlaybackError(@NonNull String adUnitId, @NonNull MoPubErrorCode errorCode);
+
+    /**
+     * Called when a rewarded video is closed. At this point your application should resume.
+     */
+    public void onRewardedVideoClosed(@NonNull String adUnitId);
+
+    /**
+     * Called when a rewarded video is completed and the user should be rewarded.
+     */
+    public void onRewardedVideoCompleted(@NonNull Set<String> adUnitIds, @NonNull MoPubReward reward);
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoManager.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoManager.java
new file mode 100644
index 00000000..804a6baf
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubRewardedVideoManager.java
@@ -0,0 +1,507 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.os.Handler;
+import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.AdFormat;
+import com.mopub.common.AdUrlGenerator;
+import com.mopub.common.Constants;
+import com.mopub.common.DataKeys;
+import com.mopub.common.LocationService;
+import com.mopub.common.MediationSettings;
+import com.mopub.common.MoPub;
+import com.mopub.common.MoPubReward;
+import com.mopub.common.Preconditions;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.MoPubCollections;
+import com.mopub.common.util.Reflection;
+import com.mopub.network.AdRequest;
+import com.mopub.network.AdResponse;
+import com.mopub.network.MoPubNetworkError;
+import com.mopub.network.Networking;
+import com.mopub.network.TrackingRequest;
+import com.mopub.volley.RequestQueue;
+import com.mopub.volley.VolleyError;
+
+import java.lang.ref.WeakReference;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeMap;
+
+public class MoPubRewardedVideoManager {
+    private static MoPubRewardedVideoManager sInstance;
+    private static final int DEFAULT_LOAD_TIMEOUT = Constants.THIRTY_SECONDS_MILLIS;
+
+    @NonNull private final Handler mCallbackHandler;
+    @NonNull private WeakReference<Activity> mMainActivity;
+    @NonNull private final Context mContext;
+    @NonNull private final AdRequestStatusMapping mAdRequestStatus;
+    @NonNull private final RewardedVideoData mRewardedVideoData;
+    @Nullable private MoPubRewardedVideoListener mVideoListener;
+    
+    @NonNull private final Set<MediationSettings> mGlobalMediationSettings;
+    @NonNull private final Map<String, Set<MediationSettings>> mInstanceMediationSettings;
+
+    @NonNull private final Handler mCustomEventTimeoutHandler;
+    @NonNull private final Map<String, Runnable> mTimeoutMap;
+
+    public static class RewardedVideoRequestListener implements AdRequest.Listener {
+        public final String adUnitId;
+        private final MoPubRewardedVideoManager mVideoManager;
+
+        public RewardedVideoRequestListener(MoPubRewardedVideoManager videoManager, String adUnitId) {
+            this.adUnitId = adUnitId;
+            this.mVideoManager = videoManager;
+        }
+
+        @Override
+        public void onSuccess(final AdResponse response) {
+            mVideoManager.onAdSuccess(response, adUnitId);
+        }
+
+        @Override
+        public void onErrorResponse(final VolleyError volleyError) {
+            mVideoManager.onAdError(volleyError, adUnitId);
+        }
+    }
+
+    private MoPubRewardedVideoManager(@NonNull Activity mainActivity, MediationSettings... mediationSettings) {
+        mMainActivity = new WeakReference<Activity>(mainActivity);
+        mContext = mainActivity.getApplicationContext();
+        mRewardedVideoData = new RewardedVideoData();
+        mCallbackHandler = new Handler(Looper.getMainLooper());
+        mGlobalMediationSettings = new HashSet<MediationSettings>();
+        MoPubCollections.addAllNonNull(mGlobalMediationSettings, mediationSettings);
+        mInstanceMediationSettings = new HashMap<String, Set<MediationSettings>>();
+        mCustomEventTimeoutHandler = new Handler();
+        mTimeoutMap = new HashMap<String, Runnable>();
+        
+        mAdRequestStatus = new AdRequestStatusMapping();
+    }
+
+    public static synchronized void init(@NonNull Activity mainActivity, MediationSettings... mediationSettings) {
+        if (sInstance == null) {
+            sInstance = new MoPubRewardedVideoManager(mainActivity, mediationSettings);
+        } else {
+            MoPubLog.e("Tried to call initializeRewardedVideo more than once. Only the first " +
+                    "initialization call has any effect.");
+        }
+    }
+
+    public static void updateActivity(@NonNull Activity activity) {
+        if (sInstance != null) {
+            sInstance.mMainActivity = new WeakReference<Activity>(activity);
+        } else {
+            logErrorNotInitialized();
+        }
+    }
+
+    /**
+     * Returns a global {@link MediationSettings} object of the type 'clazz', if one is registered.
+     * This method will only return an object if its type is identical to 'clazz', not if it is a
+     * subtype.
+     *
+     * @param clazz the exact Class of the {@link MediationSettings} instance to retrieve
+     * @return an instance of Class<T> or null if none is registered.
+     */
+    @Nullable
+    public static <T extends MediationSettings> T getGlobalMediationSettings(@NonNull final Class<T> clazz) {
+        if (sInstance == null) {
+            logErrorNotInitialized();
+            return null;
+        }
+
+        for (final MediationSettings mediationSettings : sInstance.mGlobalMediationSettings) {
+            // The two classes must be of exactly equal types
+            if (clazz.equals(mediationSettings.getClass())) {
+                return clazz.cast(mediationSettings);
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * Returns an instance {@link MediationSettings} object of the type 'clazz', if one is
+     * registered. This method will only return an object if its type is identical to 'clazz', not
+     * if it is a subtype.
+     *
+     * @param clazz the exact Class of the {@link MediationSettings} instance to retrieve
+     * @param adUnitId String identifier used to obtain the appropriate instance MediationSettings
+     * @return an instance of Class<T> or null if none is registered.
+     */
+    @Nullable
+    public static <T extends MediationSettings> T getInstanceMediationSettings(
+            @NonNull final Class<T> clazz, @NonNull final String adUnitId) {
+        if (sInstance == null) {
+            logErrorNotInitialized();
+            return null;
+        }
+
+        final Set<MediationSettings> instanceMediationSettings =
+                sInstance.mInstanceMediationSettings.get(adUnitId);
+        if (instanceMediationSettings == null) {
+            return null;
+        }
+
+        for (final MediationSettings mediationSettings : instanceMediationSettings) {
+            // The two classes must be of exactly equal types
+            if (clazz.equals(mediationSettings.getClass())) {
+                return clazz.cast(mediationSettings);
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * Sets the {@link MoPubRewardedVideoListener} that will receive events from the
+     * rewarded video system. Set this to null to stop receiving event callbacks.
+     */
+    public static void setVideoListener(@Nullable MoPubRewardedVideoListener listener) {
+        if (sInstance != null) {
+            sInstance.mVideoListener = listener;
+        } else {
+            logErrorNotInitialized();
+        }
+    }
+
+    /**
+     * Builds an AdRequest for the given adUnitId and adds it to the singleton RequestQueue. This
+     * method will not make a new request if there is already a video loading for this adUnitId.
+     *
+     * @param adUnitId MoPub adUnitId String
+     * @param mediationSettings Optional instance-level MediationSettings to associate with the
+     *                          above adUnitId.
+     */
+    public static void loadVideo(@NonNull String adUnitId, @Nullable final MediationSettings... mediationSettings) {
+        if (sInstance == null) {
+            logErrorNotInitialized();
+            return;
+        }
+
+        // If any instance MediationSettings have been specified, update the internal map.
+        // Note: This always clears the MediationSettings for the ad unit, whether or not any
+        // MediationSettings have been provided.
+        final Set<MediationSettings> newInstanceMediationSettings = new HashSet<MediationSettings>();
+        MoPubCollections.addAllNonNull(newInstanceMediationSettings, mediationSettings);
+        sInstance.mInstanceMediationSettings.put(adUnitId, newInstanceMediationSettings);
+
+        final AdUrlGenerator urlGenerator = new WebViewAdUrlGenerator(sInstance.mContext, false);
+        final String adUrlString = urlGenerator.withAdUnitId(adUnitId)
+                .withLocation(
+                        LocationService.getLastKnownLocation(
+                                sInstance.mContext,
+                                MoPub.getLocationPrecision(),
+                                MoPub.getLocationAwareness()
+                        )
+                )
+                .generateUrlString(Constants.HOST);
+
+        loadVideo(adUnitId, adUrlString);
+    }
+
+    private static void loadVideo(@NonNull String adUnitId, @NonNull String adUrlString) {
+        if (sInstance == null) {
+            logErrorNotInitialized();
+            return;
+        }
+
+        if (sInstance.mAdRequestStatus.isLoading(adUnitId)) {
+            MoPubLog.d(String.format(Locale.US, "Did not queue rewarded video request for ad " +
+                    "unit %s. A request is already pending.", adUnitId));
+            return;
+        }
+
+        // Issue MoPub request
+        final AdRequest request = new AdRequest(
+                adUrlString,
+                AdFormat.REWARDED_VIDEO,
+                adUnitId,
+                sInstance.mContext,
+                new RewardedVideoRequestListener(sInstance, adUnitId)
+        );
+        final RequestQueue requestQueue = Networking.getRequestQueue(sInstance.mContext);
+        requestQueue.add(request);
+        sInstance.mAdRequestStatus.markLoading(adUnitId);
+    }
+
+    public static boolean hasVideo(@NonNull String adUnitId) {
+        if (sInstance != null) {
+            final CustomEventRewardedVideo customEvent = sInstance.mRewardedVideoData.getCustomEvent(adUnitId);
+            return isPlayable(adUnitId, customEvent);
+        } else {
+            logErrorNotInitialized();
+            return false;
+        }
+    }
+
+    public static void showVideo(@NonNull String adUnitId) {
+        if (sInstance != null) {
+            final CustomEventRewardedVideo customEvent = sInstance.mRewardedVideoData.getCustomEvent(adUnitId);
+            if (isPlayable(adUnitId, customEvent)) {
+                sInstance.mAdRequestStatus.markPlayed(adUnitId);
+                customEvent.showVideo();
+            } else {
+                sInstance.failover(adUnitId, MoPubErrorCode.VIDEO_NOT_AVAILABLE);
+            }
+        } else {
+            logErrorNotInitialized();
+        }
+    }
+
+    private static boolean isPlayable(String adUnitId, @Nullable CustomEventRewardedVideo customEvent) {
+        return (sInstance != null
+                && sInstance.mAdRequestStatus.canPlay(adUnitId)
+                && customEvent != null
+                && customEvent.hasVideoAvailable());
+    }
+
+    ///// Ad Request / Response methods /////
+    private void onAdSuccess(AdResponse adResponse, String adUnitId) {
+        mAdRequestStatus.markLoaded(adUnitId,
+                adResponse.getFailoverUrl(),
+                adResponse.getImpressionTrackingUrl(),
+                adResponse.getClickTrackingUrl());
+
+        Integer timeoutMillis = adResponse.getAdTimeoutMillis();
+        if (timeoutMillis == null || timeoutMillis <= 0) {
+            timeoutMillis = DEFAULT_LOAD_TIMEOUT;
+        }
+
+        final String customEventClassName = adResponse.getCustomEventClassName();
+        if (customEventClassName == null) {
+            MoPubLog.e("Couldn't create custom event, class name was null.");
+            failover(adUnitId, MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
+            return;
+        }
+
+        try {
+            // Instantiate a custom event
+            final CustomEventRewardedVideo customEvent =
+                    Reflection.instantiateClassWithEmptyConstructor(
+                            customEventClassName,
+                            CustomEventRewardedVideo.class);
+
+            // Put important data into localExtras...
+            final Map<String, Object> localExtras = new TreeMap<String, Object>();
+            localExtras.put(DataKeys.AD_UNIT_ID_KEY, adUnitId);
+
+            // Set up timeout calls.
+            Runnable timeout = new Runnable() {
+                @Override
+                public void run() {
+                    MoPubLog.d("Custom Event failed to load rewarded video in a timely fashion.");
+                    onRewardedVideoLoadFailure(customEvent.getClass(), customEvent.getAdNetworkId(), MoPubErrorCode.NETWORK_TIMEOUT);
+                    customEvent.onInvalidate();
+                }
+            };
+            mCustomEventTimeoutHandler.postDelayed(timeout, timeoutMillis);
+            mTimeoutMap.put(adUnitId, timeout);
+
+            // Load custom event - need an activity reference!
+            customEvent.loadCustomEvent(mMainActivity.get(), localExtras, adResponse.getServerExtras());
+
+            final CustomEventRewardedVideo.CustomEventRewardedVideoListener listener =
+                    customEvent.getVideoListenerForSdk();
+            final String adNetworkId = customEvent.getAdNetworkId();
+            mRewardedVideoData.updateAdUnitCustomEventMapping(adUnitId, customEvent, listener, adNetworkId);
+
+        } catch (Exception e) {
+            MoPubLog.e(String.format(Locale.US, "Couldn't create custom event with class name %s", customEventClassName));
+            failover(adUnitId, MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
+        }
+    }
+
+    private void onAdError(@NonNull VolleyError volleyError, @NonNull String adUnitId) {
+        MoPubErrorCode errorCode = MoPubErrorCode.INTERNAL_ERROR;
+        if (volleyError instanceof MoPubNetworkError) {
+            MoPubNetworkError err = (MoPubNetworkError) volleyError;
+            switch (err.getReason()) {
+                case NO_FILL:
+                case WARMING_UP:
+                    errorCode = MoPubErrorCode.NO_FILL;
+                    break;
+                case BAD_BODY:
+                case BAD_HEADER_DATA:
+                default:
+                    errorCode = MoPubErrorCode.INTERNAL_ERROR;
+            }
+        }
+        failover(adUnitId, errorCode);
+    }
+
+    private void failover(@NonNull final String adUnitId, @NonNull final MoPubErrorCode errorCode) {
+        final String failoverUrl = mAdRequestStatus.getFailoverUrl(adUnitId);
+        mAdRequestStatus.markFail(adUnitId);
+
+        if (failoverUrl != null) {
+            loadVideo(adUnitId, failoverUrl);
+        } else if (mVideoListener != null) {
+            mVideoListener.onRewardedVideoLoadFailure(adUnitId, errorCode);
+        }
+    }
+
+    private void cancelTimeouts(@NonNull String moPubId) {
+        final Runnable runnable = mTimeoutMap.remove(moPubId);
+        if (runnable != null) {  // We can't pass null or all callbacks will be removed.
+            mCustomEventTimeoutHandler.removeCallbacks(runnable);
+        }
+    }
+
+    //////// Listener methods that should be called by third-party SDKs. //////////
+
+    /**
+     * Notify the manager that a rewarded video loaded successfully.
+     *
+     * @param customEventClass - the Class of the third-party custom event object.
+     * @param thirdPartyId - the ad id of the third party SDK. This may be an empty String if the
+     *                     SDK does not use ad ids, zone ids, or a analogous concept.
+     * @param <T> - a class that extends {@link CustomEventRewardedVideo}. Only rewarded video
+     *           custom events should use these methods.
+     */
+    public static <T extends CustomEventRewardedVideo>
+    void onRewardedVideoLoadSuccess(@NonNull final Class<T> customEventClass, @NonNull final String thirdPartyId) {
+        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
+            @Override
+            protected void forEach(@NonNull final String moPubId) {
+                sInstance.cancelTimeouts(moPubId);
+                if (sInstance.mVideoListener != null) {
+                    sInstance.mVideoListener.onRewardedVideoLoadSuccess(moPubId);
+                }
+            }
+        });
+    }
+
+    public static <T extends CustomEventRewardedVideo>
+    void onRewardedVideoLoadFailure(@NonNull final Class<T> customEventClass, final String thirdPartyId, final MoPubErrorCode errorCode) {
+        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
+            @Override
+            protected void forEach(@NonNull final String moPubId) {
+                   sInstance.cancelTimeouts(moPubId);
+                   sInstance.failover(moPubId, errorCode);
+            }
+        });
+    }
+
+    public static <T extends CustomEventRewardedVideo>
+    void onRewardedVideoStarted(@NonNull final Class<T> customEventClass, final String thirdPartyId) {
+        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
+            @Override
+            protected void forEach(@NonNull final String moPubId) {
+                if (sInstance.mVideoListener != null) {
+                    sInstance.mVideoListener.onRewardedVideoStarted(moPubId);
+                }
+                TrackingRequest.makeTrackingHttpRequest(
+                        sInstance.mAdRequestStatus.getImpressionTrackerUrlString(moPubId),
+                        sInstance.mContext);
+                sInstance.mAdRequestStatus.clearImpressionUrl(moPubId);
+            }
+        });
+    }
+
+    public static <T extends CustomEventRewardedVideo>
+    void onRewardedVideoPlaybackError(@NonNull final Class<T> customEventClass, final String thirdPartyId, final MoPubErrorCode errorCode) {
+        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
+            @Override
+            protected void forEach(@NonNull final String moPubId) {
+                if (sInstance.mVideoListener != null) {
+                    sInstance.mVideoListener.onRewardedVideoPlaybackError(moPubId, errorCode);
+                }
+            }
+        });
+
+    }
+
+    public static <T extends CustomEventRewardedVideo>
+    void onRewardedVideoClicked(@NonNull final Class<T> customEventClass, final String thirdPartyId) {
+        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
+            @Override
+            protected void forEach(@NonNull final String moPubId) {
+                TrackingRequest.makeTrackingHttpRequest(
+                        sInstance.mAdRequestStatus.getClickTrackerUrlString(moPubId),
+                        sInstance.mContext);
+                sInstance.mAdRequestStatus.clearClickUrl(moPubId);
+            }
+        });
+    }
+
+    public static <T extends CustomEventRewardedVideo>
+    void onRewardedVideoClosed(@NonNull final Class<T> customEventClass, final String thirdPartyId) {
+        postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
+            @Override
+            protected void forEach(@NonNull final String moPubId) {
+                if (sInstance.mVideoListener != null) {
+                    sInstance.mVideoListener.onRewardedVideoClosed(moPubId);
+                }
+            }
+        });
+    }
+
+    public static <T extends CustomEventRewardedVideo>
+    void onRewardedVideoCompleted(@NonNull final Class<T> customEventClass, final String thirdPartyId, @NonNull final MoPubReward moPubReward) {
+        // Unlike other callbacks in this class, only call the listener once with all the MoPubIds in the matching set.
+        postToInstance(new Runnable() {
+            @Override
+            public void run() {
+                final Set<String> moPubIds = sInstance.mRewardedVideoData.getMoPubIdsForAdNetwork(customEventClass, thirdPartyId);
+                Set<String> rewarded = new HashSet<String>(moPubIds);
+                if (sInstance.mVideoListener != null) {
+                    sInstance.mVideoListener.onRewardedVideoCompleted(rewarded, moPubReward);
+                }
+            }
+        });
+    }
+
+    /**
+     * Posts the runnable to the static instance's handler. Does nothing if sInstance is null.
+     * Useful for ensuring that all event callbacks run on the main thread.
+     * The {@link Runnable} can assume that sInstance is non-null.
+     */
+    private static void postToInstance(@NonNull Runnable runnable) {
+        if (sInstance != null) {
+            sInstance.mCallbackHandler.post(runnable);
+        }
+    }
+
+    private static void logErrorNotInitialized() {
+        MoPubLog.e("MoPub rewarded video was not initialized. You must call " +
+                "MoPub.initializeRewardedVideo() before loading or attempting " +
+                "to play video ads.");
+    }
+
+    /**
+     * A runnable that calls forEach on each member of the rewarded video data passed to the runnable.
+     */
+    private static abstract class ForEachMoPubIdRunnable implements Runnable {
+
+        @NonNull private final Class<? extends CustomEventRewardedVideo> mCustomEventClass;
+        @NonNull private final String mThirdPartyId;
+
+        ForEachMoPubIdRunnable(@NonNull final Class<? extends CustomEventRewardedVideo> customEventClass,
+                @NonNull final String thirdPartyId) {
+            Preconditions.checkNotNull(customEventClass);
+            Preconditions.checkNotNull(thirdPartyId);
+            mCustomEventClass = customEventClass;
+            mThirdPartyId = thirdPartyId;
+        }
+
+        protected abstract void forEach(@NonNull final String moPubId);
+
+        @Override
+        public void run() {
+            final Set<String> moPubIds = sInstance.mRewardedVideoData
+                    .getMoPubIdsForAdNetwork(mCustomEventClass, mThirdPartyId);
+            for (String moPubId : moPubIds) {
+                forEach(moPubId);
+            }
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubView.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubView.java
index 86aad8f7..ca0f5422 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubView.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubView.java
@@ -6,10 +6,14 @@
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.location.Location;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
 import android.util.AttributeSet;
 import android.view.View;
 import android.webkit.WebViewDatabase;
 import android.widget.FrameLayout;
+
+import com.mopub.common.AdFormat;
 import com.mopub.common.MoPub;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.util.ManifestUtils;
@@ -17,11 +21,10 @@
 import com.mopub.mobileads.factories.AdViewControllerFactory;
 import com.mopub.mobileads.factories.CustomEventBannerAdapterFactory;
 
-import java.util.*;
+import java.util.Map;
+import java.util.TreeMap;
 
 import static com.mopub.common.LocationService.LocationAwareness;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_DATA;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_NAME;
 import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
 
 public class MoPubView extends FrameLayout {
@@ -33,11 +36,8 @@
         public void onBannerCollapsed(MoPubView banner);
     }
 
-    public static final String HOST = "ads.mopub.com";
-    public static final String HOST_FOR_TESTING = "testing.ads.mopub.com";
-    public static final String AD_HANDLER = "/m/ad";
     public static final int DEFAULT_LOCATION_PRECISION = 6;
-
+    @Nullable
     protected AdViewController mAdViewController;
     protected CustomEventBannerAdapter mCustomEventBannerAdapter;
 
@@ -148,8 +148,11 @@ protected void loadFailUrl(MoPubErrorCode errorCode) {
         if (mAdViewController != null) mAdViewController.loadFailUrl(errorCode);
     }
 
-    protected void loadCustomEvent(Map<String, String> paramsMap) {
-        if (paramsMap == null) {
+    protected void loadCustomEvent(String customEventClassName, Map<String, String> serverExtras) {
+        if (mAdViewController == null) {
+            return;
+        }
+        if (TextUtils.isEmpty(customEventClassName)) {
             MoPubLog.d("Couldn't invoke custom event because the server did not specify one.");
             loadFailUrl(ADAPTER_NOT_FOUND);
             return;
@@ -163,8 +166,10 @@ protected void loadCustomEvent(Map<String, String> paramsMap) {
 
         mCustomEventBannerAdapter = CustomEventBannerAdapterFactory.create(
                 this,
-                paramsMap.get(CUSTOM_EVENT_NAME.getKey()),
-                paramsMap.get(CUSTOM_EVENT_DATA.getKey()));
+                customEventClassName,
+                serverExtras,
+                mAdViewController.getBroadcastIdentifier(),
+                mAdViewController.getAdReport());
         mCustomEventBannerAdapter.loadAd();
     }
 
@@ -292,12 +297,18 @@ public String getResponseString() {
         return (mAdViewController != null) ? mAdViewController.getResponseString() : null;
     }
 
+    @Deprecated
     public void setClickthroughUrl(String url) {
-        if (mAdViewController != null) mAdViewController.setClickthroughUrl(url);
+        // Does nothing.
     }
 
+    public String getClickTrackingUrl() {
+        return (mAdViewController != null) ? mAdViewController.getClickTrackingUrl() : null;
+    }
+
+    @Deprecated
     public String getClickthroughUrl() {
-        return (mAdViewController != null) ? mAdViewController.getClickthroughUrl() : null;
+        return getClickTrackingUrl();
     }
 
     public Activity getActivity() {
@@ -317,8 +328,10 @@ public void setLocalExtras(Map<String, Object> localExtras) {
     }
 
     public Map<String, Object> getLocalExtras() {
-        if (mAdViewController != null) return mAdViewController.getLocalExtras();
-        return Collections.emptyMap();
+        if (mAdViewController != null) {
+            return mAdViewController.getLocalExtras();
+        }
+        return new TreeMap<String, Object>();
     }
 
     public void setAutorefreshEnabled(boolean enabled) {
@@ -366,6 +379,10 @@ AdViewController getAdViewController() {
         return mAdViewController;
     }
 
+    public AdFormat getAdFormat() {
+        return AdFormat.BANNER;
+    }
+
     @Deprecated
     public void setLocationAwareness(LocationAwareness locationAwareness) {
         MoPub.setLocationAwareness(locationAwareness.getNewLocationAwareness());
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidAbstractController.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidAbstractController.java
deleted file mode 100644
index 7f56c51f..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidAbstractController.java
+++ /dev/null
@@ -1,15 +0,0 @@
-package com.mopub.mobileads;
-
-
-class MraidAbstractController {
-    private final MraidView mMraidView;
-
-    MraidAbstractController(MraidView view) {
-        super();
-        mMraidView = view;
-    }
-    
-    public MraidView getMraidView() {
-        return mMraidView;
-    }
-}
\ No newline at end of file
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidActivity.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidActivity.java
index ac5dedce..62bf5b27 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidActivity.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidActivity.java
@@ -1,163 +1,199 @@
 package com.mopub.mobileads;
 
-import android.annotation.TargetApi;
 import android.content.ActivityNotFoundException;
 import android.content.Context;
 import android.content.Intent;
+import android.os.Build.VERSION;
+import android.os.Build.VERSION_CODES;
 import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.Log;
 import android.view.View;
 import android.view.WindowManager;
 import android.webkit.WebView;
 import android.webkit.WebViewClient;
 
-import com.mopub.mobileads.MraidView.ExpansionStyle;
-import com.mopub.mobileads.MraidView.NativeCloseButtonStyle;
-import com.mopub.mobileads.MraidView.PlacementType;
-import com.mopub.mobileads.MraidView.ViewState;
-import com.mopub.mobileads.factories.MraidViewFactory;
-import com.mopub.mobileads.util.WebViews;
-
-import static com.mopub.common.util.VersionCode.ICE_CREAM_SANDWICH;
-import static com.mopub.common.util.VersionCode.currentApiLevel;
-import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
+import com.mopub.common.AdReport;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
+import com.mopub.mraid.MraidController;
+import com.mopub.mraid.MraidController.MraidListener;
+import com.mopub.mraid.MraidController.UseCustomCloseListener;
+import com.mopub.mraid.MraidWebViewDebugListener;
+import com.mopub.mraid.PlacementType;
+
+import static com.mopub.common.DataKeys.AD_REPORT_KEY;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
 import static com.mopub.mobileads.BaseInterstitialActivity.JavaScriptWebViewCallbacks.WEB_VIEW_DID_APPEAR;
 import static com.mopub.mobileads.BaseInterstitialActivity.JavaScriptWebViewCallbacks.WEB_VIEW_DID_CLOSE;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_CLICK;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
+import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_FAIL;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.broadcastAction;
 
 public class MraidActivity extends BaseInterstitialActivity {
-    private MraidView mMraidView;
+    @Nullable private MraidController mMraidController;
+    @Nullable private MraidWebViewDebugListener mDebugListener;
 
-    static void preRenderHtml(final Context context, final CustomEventInterstitial.CustomEventInterstitialListener customEventInterstitialListener, final String htmlData) {
-        MraidView dummyMraidView = MraidViewFactory.create(context, null, ExpansionStyle.DISABLED, NativeCloseButtonStyle.ALWAYS_VISIBLE, PlacementType.INTERSTITIAL);
+    public static void preRenderHtml(@NonNull final Context context,
+            @NonNull final CustomEventInterstitialListener customEventInterstitialListener,
+            @NonNull final String htmlData) {
+        BaseWebView dummyWebView = new BaseWebView(context);
 
-        dummyMraidView.enablePlugins(false);
-        dummyMraidView.setMraidListener(new MraidView.MraidListener() {
+        dummyWebView.enablePlugins(false);
+        dummyWebView.setWebViewClient(new WebViewClient() {
             @Override
-            public void onReady(MraidView view) {
+            public void onPageFinished(final WebView view, final String url) {
                 customEventInterstitialListener.onInterstitialLoaded();
             }
 
-            @Override
-            public void onFailure(MraidView view) {
-                customEventInterstitialListener.onInterstitialFailed(null);
-            }
-
-            @Override
-            public void onExpand(MraidView view) {
-            }
-
-            @Override
-            public void onOpen(MraidView view) {
-            }
-
-            @Override
-            public void onClose(MraidView view, MraidView.ViewState newViewState) {
-            }
-        });
-        dummyMraidView.setWebViewClient(new WebViewClient() {
             @Override
             public boolean shouldOverrideUrlLoading(WebView view, String url) {
                 return true;
             }
 
             @Override
-            public void onPageFinished(WebView view, String url) {
-                customEventInterstitialListener.onInterstitialLoaded();
+            public void onReceivedError(final WebView view, final int errorCode,
+                    final String description,
+                    final String failingUrl) {
+                super.onReceivedError(view, errorCode, description, failingUrl);
+                customEventInterstitialListener.onInterstitialFailed(
+                        MoPubErrorCode.MRAID_LOAD_ERROR);
             }
         });
-        dummyMraidView.loadHtmlData(htmlData);
+
+        dummyWebView.loadDataWithBaseURL(null, htmlData, "text/html", "UTF-8", null);
     }
 
-    public static void start(Context context, String htmlData, AdConfiguration adConfiguration) {
-        Intent intent = createIntent(context, htmlData, adConfiguration);
+    public static void start(@NonNull Context context, @Nullable AdReport adreport, @NonNull String htmlData, long broadcastIdentifier) {
+        Intent intent = createIntent(context, adreport, htmlData, broadcastIdentifier);
         try {
             context.startActivity(intent);
-        } catch (ActivityNotFoundException anfe) {
+        } catch (ActivityNotFoundException exception) {
             Log.d("MraidInterstitial", "MraidActivity.class not found. Did you declare MraidActivity in your manifest?");
         }
     }
 
-    private static Intent createIntent(Context context, String htmlData, AdConfiguration adConfiguration) {
+    @VisibleForTesting
+    protected static Intent createIntent(@NonNull Context context, @Nullable AdReport adReport,
+            @NonNull String htmlData, long broadcastIdentifier) {
         Intent intent = new Intent(context, MraidActivity.class);
         intent.putExtra(HTML_RESPONSE_BODY_KEY, htmlData);
-        intent.putExtra(AD_CONFIGURATION_KEY, adConfiguration);
+        intent.putExtra(BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
+        intent.putExtra(AD_REPORT_KEY, adReport);
         intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
         return intent;
     }
 
     @Override
     public View getAdView() {
-        mMraidView = MraidViewFactory.create(this, getAdConfiguration(), ExpansionStyle.DISABLED, NativeCloseButtonStyle.AD_CONTROLLED, PlacementType.INTERSTITIAL);
+        String htmlData = getIntent().getStringExtra(HTML_RESPONSE_BODY_KEY);
+        if (htmlData == null) {
+            MoPubLog.w("MraidActivity received a null HTML body. Finishing the activity.");
+            finish();
+            return new View(this);
+        }
 
-        mMraidView.setMraidListener(new MraidView.BaseMraidListener(){
-            public void onReady(MraidView view) {
-                mMraidView.loadUrl(WEB_VIEW_DID_APPEAR.getUrl());
-                showInterstitialCloseButton();
+        mMraidController = new MraidController(
+                this, mAdReport, PlacementType.INTERSTITIAL);
+
+        mMraidController.setDebugListener(mDebugListener);
+        mMraidController.setMraidListener(new MraidListener() {
+            @Override
+            public void onLoaded(View view) {
+                // This is only done for the interstitial. Banners have a different mechanism
+                // for tracking third party impressions.
+                mMraidController.loadJavascript(WEB_VIEW_DID_APPEAR.getJavascript());
             }
 
             @Override
-            public void onOpen(MraidView view) {
-                broadcastAction(MraidActivity.this, getBroadcastIdentifier(), ACTION_INTERSTITIAL_CLICK);
+            public void onFailedToLoad() {
+                MoPubLog.d("MraidActivity failed to load. Finishing the activity");
+                broadcastAction(MraidActivity.this, getBroadcastIdentifier(),
+                        ACTION_INTERSTITIAL_FAIL);
+                finish();
             }
 
-            public void onClose(MraidView view, ViewState newViewState) {
-                mMraidView.loadUrl(WEB_VIEW_DID_CLOSE.getUrl());
+            public void onClose() {
+                mMraidController.loadJavascript(WEB_VIEW_DID_CLOSE.getJavascript());
                 finish();
             }
+
+            @Override
+            public void onExpand() {
+                // No-op. The interstitial is always expanded.
+            }
+
+            @Override
+            public void onOpen() {
+                broadcastAction(MraidActivity.this, getBroadcastIdentifier(),
+                        ACTION_INTERSTITIAL_CLICK);
+            }
         });
 
-        mMraidView.setOnCloseButtonStateChange(new MraidView.OnCloseButtonStateChangeListener() {
-            public void onCloseButtonStateChange(MraidView view, boolean enabled) {
-                if (enabled) {
-                    showInterstitialCloseButton();
-                } else {
+        // Needed because the Activity provides the close button, not the controller. This
+        // gets called if the creative calls mraid.useCustomClose.
+        mMraidController.setUseCustomCloseListener(new UseCustomCloseListener() {
+            public void useCustomCloseChanged(boolean useCustomClose) {
+                if (useCustomClose) {
                     hideInterstitialCloseButton();
+                } else {
+                    showInterstitialCloseButton();
                 }
             }
         });
 
-        String source = getIntent().getStringExtra(HTML_RESPONSE_BODY_KEY);
-        mMraidView.loadHtmlData(source);
-
-        return mMraidView;
+        mMraidController.loadContent(htmlData);
+        return mMraidController.getAdContainer();
     }
 
-    @TargetApi(11)
     @Override
-    public void onCreate(Bundle savedInstanceState) {
+    public void onCreate(@Nullable Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         broadcastAction(this, getBroadcastIdentifier(), ACTION_INTERSTITIAL_SHOW);
 
-        if (currentApiLevel().isAtLeast(ICE_CREAM_SANDWICH)) {
+        if (VERSION.SDK_INT >= VERSION_CODES.ICE_CREAM_SANDWICH) {
             getWindow().setFlags(
                     WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,
                     WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
         }
-
-        addCloseEventRegion();
     }
 
     @Override
     protected void onPause() {
+        if (mMraidController != null) {
+            mMraidController.pause(isFinishing());
+        }
         super.onPause();
-        WebViews.onPause(mMraidView);
     }
 
     @Override
     protected void onResume() {
         super.onResume();
-        WebViews.onResume(mMraidView);
+        if (mMraidController != null) {
+            mMraidController.resume();
+        }
     }
 
     @Override
     protected void onDestroy() {
-        mMraidView.destroy();
+        if (mMraidController != null) {
+            mMraidController.destroy();
+        }
+
         broadcastAction(this, getBroadcastIdentifier(), ACTION_INTERSTITIAL_DISMISS);
         super.onDestroy();
     }
+
+    @VisibleForTesting
+    public void setDebugListener(@Nullable MraidWebViewDebugListener debugListener) {
+        mDebugListener = debugListener;
+        if (mMraidController != null) {
+            mMraidController.setDebugListener(debugListener);
+        }
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidBanner.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidBanner.java
deleted file mode 100644
index f79a337b..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidBanner.java
+++ /dev/null
@@ -1,96 +0,0 @@
-package com.mopub.mobileads;
-
-import android.content.Context;
-import android.net.Uri;
-
-import com.mopub.mobileads.MraidView.ViewState;
-import com.mopub.mobileads.factories.MraidViewFactory;
-
-import java.util.Map;
-
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
-import static com.mopub.mobileads.MoPubErrorCode.MRAID_LOAD_ERROR;
-import static com.mopub.mobileads.MraidView.MraidListener;
-
-class MraidBanner extends CustomEventBanner {
-    private MraidView mMraidView;
-    private CustomEventBannerListener mBannerListener;
-
-    @Override
-    protected void loadBanner(Context context,
-                    CustomEventBannerListener customEventBannerListener,
-                    Map<String, Object> localExtras,
-                    Map<String, String> serverExtras) {
-        mBannerListener = customEventBannerListener;
-
-        String htmlData;
-        if (extrasAreValid(serverExtras)) {
-            htmlData = Uri.decode(serverExtras.get(HTML_RESPONSE_BODY_KEY));
-        } else {
-            mBannerListener.onBannerFailed(MRAID_LOAD_ERROR);
-            return;
-        }
-
-        AdConfiguration adConfiguration = AdConfiguration.extractFromMap(localExtras);
-        mMraidView = MraidViewFactory.create(context, adConfiguration);
-        mMraidView.loadHtmlData(htmlData);
-        initMraidListener();
-    }
-
-    @Override
-    protected void onInvalidate() {
-        if (mMraidView != null) {
-            resetMraidListener();
-            mMraidView.destroy();
-        }
-    }
-
-    private void onReady() {
-        mBannerListener.onBannerLoaded(mMraidView);
-    }
-
-    private void onFail() {
-        mBannerListener.onBannerFailed(MRAID_LOAD_ERROR);
-    }
-
-    private void onExpand() {
-        mBannerListener.onBannerExpanded();
-        mBannerListener.onBannerClicked();
-    }
-
-    private void onOpen() {
-        mBannerListener.onBannerClicked();
-    }
-
-    private void onClose() {
-        mBannerListener.onBannerCollapsed();
-    }
-
-    private boolean extrasAreValid(Map<String, String> serverExtras) {
-        return serverExtras.containsKey(HTML_RESPONSE_BODY_KEY);
-    }
-
-    private void initMraidListener() {
-        mMraidView.setMraidListener(new MraidListener() {
-            public void onReady(MraidView view) {
-                MraidBanner.this.onReady();
-            }
-            public void onFailure(MraidView view) {
-                onFail();
-            }
-            public void onExpand(MraidView view) {
-                MraidBanner.this.onExpand();
-            }
-            public void onOpen(MraidView view) {
-                MraidBanner.this.onOpen();
-            }
-            public void onClose(MraidView view, ViewState newViewState) {
-                MraidBanner.this.onClose();
-            }
-        });
-    }
-
-    private void resetMraidListener() {
-        mMraidView.setMraidListener(null);
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidCommand.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidCommand.java
deleted file mode 100644
index c6e64d64..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidCommand.java
+++ /dev/null
@@ -1,288 +0,0 @@
-package com.mopub.mobileads;
-
-import com.mopub.common.logging.MoPubLog;
-
-import java.util.Map;
-
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.GET_RESIZE_PROPERTIES;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.OPEN;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.PLAY_VIDEO;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.RESIZE;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.SET_RESIZE_PROPERTIES;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.STORE_PICTURE;
-import static com.mopub.mobileads.MraidView.PlacementType;
-
-abstract class MraidCommand {
-    protected static final String URI_KEY = "uri";
-    protected Map<String, String> mParams;
-    protected MraidView mView;
-
-    MraidCommand(Map<String, String> params, MraidView view) {
-        mParams = params;
-        mView = view;
-    }
-    
-    abstract void execute();
-    
-    protected int getIntFromParamsForKey(String key) {
-        String s = mParams.get(key);
-        if (s == null) return -1;
-        else {
-            try {
-                return Integer.parseInt(s, 10);
-            } catch (NumberFormatException e) {
-                return -1;
-            }
-        }
-    }
-    
-    protected String getStringFromParamsForKey(String key) {
-        return mParams.get(key);
-    }
-    
-    protected float getFloatFromParamsForKey(String key) {
-        String s = mParams.get(key);
-        if (s == null) return 0.0f;
-        else {
-            try {
-                return Float.parseFloat(key);
-            } catch (NumberFormatException e) {
-                return 0.0f;
-            }
-        }
-    }
-    
-    protected boolean getBooleanFromParamsForKey(String key) {
-        return "true".equals(mParams.get(key));
-    }
-
-    protected boolean isCommandDependentOnUserClick(PlacementType placementType) {
-        return false;
-    }
-}
-
-class MraidCommandPlayVideo extends MraidCommand {
-    public MraidCommandPlayVideo(Map<String,String> params, MraidView view) {
-        super(params, view);
-    }
-
-    @Override
-    void execute() {
-        String url = getStringFromParamsForKey(URI_KEY);
-        if (url != null && !url.equals("")){
-            mView.getDisplayController().showVideo(url);
-        } else {
-            mView.fireErrorEvent(PLAY_VIDEO, "Video can't be played with null or empty URL");
-        }
-    }
-
-    @Override
-    protected boolean isCommandDependentOnUserClick(PlacementType placementType) {
-        switch (placementType) {
-            case INLINE:
-                return true;
-            case INTERSTITIAL:
-                return false;
-            default:
-                return super.isCommandDependentOnUserClick(placementType);
-        }
-    }
-}
-
-class MraidCommandStorePicture extends MraidCommand {
-    public static final String MIME_TYPE_HEADER = "Content-Type";
-
-    public MraidCommandStorePicture(Map<String,String> params, MraidView view) {
-        super(params, view);
-    }
-
-    @Override
-    void execute() {
-        String url = getStringFromParamsForKey(URI_KEY);
-
-        if (url != null && !url.equals("")) {
-            mView.getDisplayController().showUserDownloadImageAlert(url);
-        } else {
-            mView.fireErrorEvent(STORE_PICTURE, "Image can't be stored with null or empty URL");
-            MoPubLog.d("Invalid URI for Mraid Store Picture.");
-        }
-    }
-
-    @Override
-    protected boolean isCommandDependentOnUserClick(PlacementType placementType) {
-        return true;
-    }
-}
-
-class MraidCommandClose extends MraidCommand {
-    MraidCommandClose(Map<String, String> params, MraidView view) {
-        super(params, view);
-    }
-
-    @Override
-    void execute() {
-        mView.getDisplayController().close();
-    }
-}
-
-class MraidCommandExpand extends MraidCommand {
-    MraidCommandExpand(Map<String, String> params, MraidView view) {
-        super(params, view);
-    }
-
-    @Override
-    void execute() {
-        int width = getIntFromParamsForKey("w");
-        int height = getIntFromParamsForKey("h");
-        String url = getStringFromParamsForKey("url");
-        boolean shouldUseCustomClose = getBooleanFromParamsForKey("shouldUseCustomClose");
-        boolean shouldLockOrientation = getBooleanFromParamsForKey("lockOrientation");
-        
-        if (width <= 0) width = mView.getDisplayController().mScreenWidth;
-        if (height <= 0) height = mView.getDisplayController().mScreenHeight;
-        
-        mView.getDisplayController().expand(url, width, height, shouldUseCustomClose,
-                shouldLockOrientation);
-    }
-
-    @Override
-    protected boolean isCommandDependentOnUserClick(PlacementType placementType) {
-        switch (placementType) {
-            case INLINE:
-                return true;
-            case INTERSTITIAL:
-                return false;
-            default:
-                return super.isCommandDependentOnUserClick(placementType);
-        }
-    }
-}
-
-class MraidCommandUseCustomClose extends MraidCommand {
-    MraidCommandUseCustomClose(Map<String, String> params, MraidView view) {
-        super(params, view);
-    }
-
-    @Override
-    void execute() {
-        boolean shouldUseCustomClose = getBooleanFromParamsForKey("shouldUseCustomClose");
-        mView.getDisplayController().useCustomClose(shouldUseCustomClose);
-    }
-}
-
-class MraidCommandOpen extends MraidCommand {
-    MraidCommandOpen(Map<String, String> params, MraidView view) {
-        super(params, view);
-    }
-
-    @Override
-    void execute() {
-        String url = getStringFromParamsForKey("url");
-        if (url == null) {
-            mView.fireErrorEvent(OPEN, "Url can not be null.");
-            return;
-        }
-        mView.getBrowserController().open(url);
-    }
-
-    @Override
-    protected boolean isCommandDependentOnUserClick(PlacementType placementType) {
-        return true;
-    }
-}
-
-//As of version 1.15, we've decided to stub the resize command. However, this should be implemented in future versions
-class MraidCommandResize extends MraidCommand {
-    MraidCommandResize(Map<String, String> params, MraidView view) {
-        super(params, view);
-    }
-
-    @Override
-    void execute() {
-        mView.fireErrorEvent(RESIZE, "Unsupported action resize.");
-    }
-}
-
-class MraidCommandGetResizeProperties extends MraidCommand {
-    MraidCommandGetResizeProperties(Map<String, String> params, MraidView view) {
-        super(params, view);
-    }
-
-    @Override
-    void execute() {
-        mView.fireErrorEvent(GET_RESIZE_PROPERTIES, "Unsupported action getResizeProperties.");
-    }
-}
-
-class MraidCommandSetResizeProperties extends MraidCommand {
-    MraidCommandSetResizeProperties(Map<String, String> params, MraidView view) {
-        super(params, view);
-    }
-
-    @Override
-    void execute() {
-        mView.fireErrorEvent(SET_RESIZE_PROPERTIES, "Unsupported action setResizeProperties.");
-    }
-}
-
-class MraidCommandGetCurrentPosition extends MraidCommand {
-    MraidCommandGetCurrentPosition(Map<String, String> params, MraidView view) {
-        super(params, view);
-    }
-
-    @Override
-    void execute() {
-        mView.getDisplayController().getCurrentPosition();
-    }
-}
-
-
-class MraidCommandGetDefaultPosition extends MraidCommand {
-    MraidCommandGetDefaultPosition(Map<String, String> params, MraidView view) {
-        super(params, view);
-    }
-
-    @Override
-    void execute() {
-        mView.getDisplayController().getDefaultPosition();
-    }
-}
-
-class MraidCommandGetMaxSize extends MraidCommand {
-    MraidCommandGetMaxSize(Map<String, String> params, MraidView view) {
-        super(params, view);
-    }
-
-    @Override
-    void execute() {
-        mView.getDisplayController().getMaxSize();
-    }
-}
-
-class MraidCommandGetScreenSize extends MraidCommand {
-    MraidCommandGetScreenSize(Map<String, String> params, MraidView view) {
-        super(params, view);
-    }
-
-    @Override
-    void execute() {
-        mView.getDisplayController().getScreenSize();
-    }
-}
-
-class MraidCommandCreateCalendarEvent extends MraidCommand {
-    MraidCommandCreateCalendarEvent(Map<String, String> params, MraidView view) {
-        super(params, view);
-    }
-
-    @Override
-    void execute() {
-        mView.getDisplayController().createCalendarEvent(mParams);
-    }
-
-    @Override
-    protected boolean isCommandDependentOnUserClick(PlacementType placementType) {
-        return true;
-    }
-}
-
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidCommandFactory.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidCommandFactory.java
deleted file mode 100644
index 4145b710..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidCommandFactory.java
+++ /dev/null
@@ -1,93 +0,0 @@
-package com.mopub.mobileads;
-
-import java.util.Map;
-
-class MraidCommandFactory {
-    protected static MraidCommandFactory instance = new MraidCommandFactory();
-
-    enum MraidJavascriptCommand {
-        CLOSE("close"),
-        EXPAND("expand"),
-        USECUSTOMCLOSE("usecustomclose"),
-        OPEN("open"),
-        RESIZE("resize"),
-        GET_RESIZE_PROPERTIES("getResizeProperties"),
-        SET_RESIZE_PROPERTIES("setResizeProperties"),
-        PLAY_VIDEO("playVideo"),
-        STORE_PICTURE("storePicture"),
-        GET_CURRENT_POSITION("getCurrentPosition"),
-        GET_DEFAULT_POSITION("getDefaultPosition"),
-        GET_MAX_SIZE("getMaxSize"),
-        GET_SCREEN_SIZE("getScreenSize"),
-        CREATE_CALENDAR_EVENT("createCalendarEvent"),
-        UNSPECIFIED("");
-
-        private String mCommand;
-
-        private MraidJavascriptCommand(String command) {
-            mCommand = command;
-        }
-
-        private static MraidJavascriptCommand fromString(String string) {
-            for (MraidJavascriptCommand command : MraidJavascriptCommand.values()) {
-                if (command.mCommand.equals(string)) {
-                    return command;
-                }
-            }
-
-            return UNSPECIFIED;
-        }
-
-        String getCommand() {
-            return mCommand;
-        }
-    }
-
-    @Deprecated // for testing
-    public static void setInstance(MraidCommandFactory factory) {
-        instance = factory;
-    }
-
-    public static MraidCommand create(String command, Map<String, String> params, MraidView view) {
-        return instance.internalCreate(command, params, view);
-    }
-
-    protected MraidCommand internalCreate(String command, Map<String, String> params, MraidView view) {
-        MraidJavascriptCommand mraidJavascriptCommand = MraidJavascriptCommand.fromString(command);
-
-        switch (mraidJavascriptCommand) {
-            case CLOSE:
-                return new MraidCommandClose(params, view);
-            case EXPAND:
-                return new MraidCommandExpand(params, view);
-            case USECUSTOMCLOSE:
-                return new MraidCommandUseCustomClose(params, view);
-            case OPEN:
-                return new MraidCommandOpen(params, view);
-            case RESIZE:
-                return new MraidCommandResize(params, view);
-            case GET_RESIZE_PROPERTIES:
-                return new MraidCommandGetResizeProperties(params, view);
-            case SET_RESIZE_PROPERTIES:
-                return new MraidCommandSetResizeProperties(params, view);
-            case PLAY_VIDEO:
-                return new MraidCommandPlayVideo(params, view);
-            case STORE_PICTURE:
-                return new MraidCommandStorePicture(params, view);
-            case GET_CURRENT_POSITION:
-                return new MraidCommandGetCurrentPosition(params, view);
-            case GET_DEFAULT_POSITION:
-                return new MraidCommandGetDefaultPosition(params, view);
-            case GET_MAX_SIZE:
-                return new MraidCommandGetMaxSize(params, view);
-            case GET_SCREEN_SIZE:
-                return new MraidCommandGetScreenSize(params, view);
-            case CREATE_CALENDAR_EVENT:
-                return new MraidCommandCreateCalendarEvent(params, view);
-            case UNSPECIFIED:
-                return null;
-            default:
-                return null;
-        }
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidDisplayController.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidDisplayController.java
deleted file mode 100644
index 8c1ac81a..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidDisplayController.java
+++ /dev/null
@@ -1,867 +0,0 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.app.AlertDialog;
-import android.content.ActivityNotFoundException;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.DialogInterface;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.content.pm.ActivityInfo;
-import android.graphics.Rect;
-import android.graphics.drawable.StateListDrawable;
-import android.media.MediaScannerConnection;
-import android.net.Uri;
-import android.os.Environment;
-import android.os.Handler;
-import android.provider.CalendarContract;
-import android.util.DisplayMetrics;
-import android.util.Log;
-import android.view.Gravity;
-import android.view.MotionEvent;
-import android.view.View;
-import android.view.View.OnClickListener;
-import android.view.View.OnTouchListener;
-import android.view.ViewGroup;
-import android.view.Window;
-import android.view.WindowManager;
-import android.webkit.URLUtil;
-import android.widget.FrameLayout;
-import android.widget.ImageButton;
-import android.widget.ImageView;
-import android.widget.RelativeLayout;
-import android.widget.Toast;
-import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.Dips;
-import com.mopub.common.util.Streams;
-import com.mopub.mobileads.MraidView.ExpansionStyle;
-import com.mopub.mobileads.MraidView.NativeCloseButtonStyle;
-import com.mopub.mobileads.MraidView.PlacementType;
-import com.mopub.mobileads.MraidView.ViewState;
-import com.mopub.mobileads.factories.HttpClientFactory;
-import com.mopub.mobileads.util.HttpResponses;
-import com.mopub.mobileads.util.Interstitials;
-import com.mopub.mobileads.util.Mraids;
-import org.apache.http.Header;
-import org.apache.http.HttpResponse;
-import org.apache.http.client.HttpClient;
-import org.apache.http.client.methods.HttpGet;
-
-import java.io.*;
-import java.net.URI;
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
-import java.util.*;
-
-import static android.graphics.Color.TRANSPARENT;
-import static com.mopub.common.util.Drawables.INTERSTITIAL_CLOSE_BUTTON_NORMAL;
-import static com.mopub.common.util.Drawables.INTERSTITIAL_CLOSE_BUTTON_PRESSED;
-import static com.mopub.common.util.ResponseHeader.LOCATION;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.CREATE_CALENDAR_EVENT;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.EXPAND;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.GET_CURRENT_POSITION;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.GET_DEFAULT_POSITION;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.GET_MAX_SIZE;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.GET_SCREEN_SIZE;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.STORE_PICTURE;
-import static com.mopub.mobileads.MraidCommandStorePicture.MIME_TYPE_HEADER;
-import static com.mopub.mobileads.MraidView.BaseMraidListener;
-import static com.mopub.mobileads.util.Mraids.ANDROID_CALENDAR_CONTENT_TYPE;
-import static com.mopub.mobileads.util.Mraids.isCalendarAvailable;
-import static com.mopub.mobileads.util.Mraids.isInlineVideoAvailable;
-import static com.mopub.mobileads.util.Mraids.isSmsAvailable;
-import static com.mopub.mobileads.util.Mraids.isStorePictureSupported;
-import static com.mopub.mobileads.util.Mraids.isTelAvailable;
-
-class MraidDisplayController extends MraidAbstractController {
-    private static final String LOGTAG = "MraidDisplayController";
-    private static final long VIEWABILITY_TIMER_MILLIS = 3000;
-    private static final int CLOSE_BUTTON_SIZE_DP = 50;
-    private static final String[] DATE_FORMATS = {
-            "yyyy-MM-dd'T'HH:mm:ssZZZZZ",
-            "yyyy-MM-dd'T'HH:mmZZZZZ"
-    };
-    private static final int MAX_NUMBER_DAYS_IN_MONTH = 31;
-
-    // The view's current state.
-    private ViewState mViewState = ViewState.HIDDEN;
-
-    // Tracks whether this controller's view responds to expand() calls.
-    private final ExpansionStyle mExpansionStyle;
-
-    // Tracks how this controller's view should display its native close button.
-    private final NativeCloseButtonStyle mNativeCloseButtonStyle;
-
-    // Separate instance of MraidView, for displaying "two-part" creatives via the expand(URL) API.
-    private MraidView mTwoPartExpansionView;
-
-    // A reference to the root view.
-    private FrameLayout mRootView;
-
-    // Handler for scheduling viewability checks.
-    private Handler mHandler = new Handler();
-
-    // Stores the requested orientation for the Activity to which this controller's view belongs.
-    // This is needed to restore the Activity's requested orientation in the event that the view
-    // itself requires an orientation lock.
-    private final int mOriginalRequestedOrientation;
-
-    private OrientationBroadcastReceiver mOrientationBroadcastReceiver = new OrientationBroadcastReceiver();
-
-    // Native close button, used for expanded content.
-    private ImageView mCloseButton;
-
-    // Tracks whether expanded content provides its own, non-native close button.
-    private boolean mAdWantsCustomCloseButton;
-
-    // The scale factor for a dip (relative to a 160 dpi screen).
-    protected float mDensity;
-
-    // The width of the screen in pixels.
-    protected int mScreenWidth = -1;
-
-    // The height of the screen in pixels.
-    protected int mScreenHeight = -1;
-
-    // The view's position within its parent.
-    private int mViewIndexInParent;
-
-    // A view that replaces the MraidView within its parent view when the MraidView is expanded
-    // (i.e. moved to the top of the view hierarchy).
-    private FrameLayout mPlaceholderView;
-    private FrameLayout mAdContainerLayout;
-    private RelativeLayout mExpansionLayout;
-    private final OnClickListener mCloseOnClickListener;
-
-    MraidDisplayController(MraidView view, MraidView.ExpansionStyle expStyle,
-            MraidView.NativeCloseButtonStyle buttonStyle) {
-        super(view);
-        mExpansionStyle = expStyle;
-        mNativeCloseButtonStyle = buttonStyle;
-
-        Context context = getContext();
-        mOriginalRequestedOrientation = (context instanceof Activity) ?
-                ((Activity) context).getRequestedOrientation() :
-                ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
-
-        initialize();
-
-        mCloseOnClickListener = new OnClickListener() {
-            @Override
-            public void onClick(final View view) {
-                MraidDisplayController.this.close();
-            }
-        };
-
-        mAdContainerLayout = createAdContainerLayout();
-        mExpansionLayout = createExpansionLayout();
-        mPlaceholderView = createPlaceholderView();
-    }
-
-    private void initialize() {
-        mViewState = ViewState.LOADING;
-        initializeScreenMetrics();
-        mOrientationBroadcastReceiver.register(getContext());
-    }
-
-    private void initializeScreenMetrics() {
-        Context context = getContext();
-        DisplayMetrics metrics = new DisplayMetrics();
-        WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
-        wm.getDefaultDisplay().getMetrics(metrics);
-        mDensity = metrics.density;
-
-        int statusBarHeight = 0, titleBarHeight = 0;
-        if (context instanceof Activity) {
-            Activity activity = (Activity) context;
-            Window window = activity.getWindow();
-            Rect rect = new Rect();
-            window.getDecorView().getWindowVisibleDisplayFrame(rect);
-            statusBarHeight = rect.top;
-            int contentViewTop = window.findViewById(Window.ID_ANDROID_CONTENT).getTop();
-            titleBarHeight = contentViewTop - statusBarHeight;
-        }
-
-        int widthPixels = metrics.widthPixels;
-        int heightPixels = metrics.heightPixels - statusBarHeight - titleBarHeight;
-        mScreenWidth = (int) (widthPixels * (160.0 / metrics.densityDpi));
-        mScreenHeight = (int) (heightPixels * (160.0 / metrics.densityDpi));
-    }
-
-    private int getDisplayRotation() {
-        WindowManager wm = (WindowManager) getContext()
-                .getSystemService(Context.WINDOW_SERVICE);
-        return wm.getDefaultDisplay().getOrientation();
-    }
-
-    private void onOrientationChanged(int currentRotation) {
-        initializeScreenMetrics();
-        getMraidView().fireChangeEventForProperty(
-                MraidScreenSizeProperty.createWithSize(mScreenWidth, mScreenHeight));
-    }
-
-    public void destroy() {
-        try {
-            mOrientationBroadcastReceiver.unregister();
-        } catch (IllegalArgumentException e) {
-            if (!e.getMessage().contains("Receiver not registered")) {
-                throw e;
-            } // Else ignore this exception.
-        }
-    }
-
-    protected void initializeJavaScriptState() {
-        ArrayList<MraidProperty> properties = new ArrayList<MraidProperty>();
-        properties.add(MraidScreenSizeProperty.createWithSize(mScreenWidth, mScreenHeight));
-        properties.add(MraidViewableProperty.createWithViewable(getMraidView().getIsVisible()));
-        getMraidView().fireChangeEventForProperties(properties);
-
-        mViewState = ViewState.DEFAULT;
-        getMraidView().fireChangeEventForProperty(MraidStateProperty.createWithViewState(mViewState));
-        initializeSupportedFunctionsProperty();
-    }
-
-    protected boolean isExpanded() {
-        return (mViewState == ViewState.EXPANDED);
-    }
-
-    protected void close() {
-        if (mViewState == ViewState.EXPANDED) {
-            resetViewToDefaultState();
-            setOrientationLockEnabled(false);
-            mViewState = ViewState.DEFAULT;
-            getMraidView().fireChangeEventForProperty(MraidStateProperty.createWithViewState(mViewState));
-        } else if (mViewState == ViewState.DEFAULT) {
-            getMraidView().setVisibility(View.INVISIBLE);
-            mViewState = ViewState.HIDDEN;
-            getMraidView().fireChangeEventForProperty(MraidStateProperty.createWithViewState(mViewState));
-        }
-
-        if (getMraidView().getMraidListener() != null) {
-            getMraidView().getMraidListener().onClose(getMraidView(), mViewState);
-        }
-    }
-
-    private void resetViewToDefaultState() {
-        setNativeCloseButtonEnabled(false);
-        mAdContainerLayout.removeAllViewsInLayout();
-
-        mExpansionLayout.removeAllViewsInLayout();
-        mRootView.removeView(mExpansionLayout);
-
-        getMraidView().requestLayout();
-
-        ViewGroup parent = (ViewGroup) mPlaceholderView.getParent();
-        parent.addView(getMraidView(), mViewIndexInParent);
-        parent.removeView(mPlaceholderView);
-        parent.invalidate();
-    }
-
-    protected void expand(String url, int width, int height, boolean shouldUseCustomClose,
-            boolean shouldLockOrientation) {
-        if (mExpansionStyle == MraidView.ExpansionStyle.DISABLED) return;
-
-        if (url != null && !URLUtil.isValidUrl(url)) {
-            getMraidView().fireErrorEvent(EXPAND, "URL passed to expand() was invalid.");
-            return;
-        }
-
-        // Obtain the root content view, since that's where we're going to insert the expanded 
-        // content. We must do this before swapping the MraidView with its place-holder;
-        // otherwise, getRootView() will return the wrong view (or null).
-        mRootView = (FrameLayout) getMraidView().getRootView().findViewById(android.R.id.content);
-
-        useCustomClose(shouldUseCustomClose);
-        setOrientationLockEnabled(shouldLockOrientation);
-        swapViewWithPlaceholderView();
-
-        View expansionContentView = getMraidView();
-        if (url != null) {
-            mTwoPartExpansionView = new MraidView(getContext(), getMraidView().getAdConfiguration(), ExpansionStyle.DISABLED,
-                    NativeCloseButtonStyle.AD_CONTROLLED, PlacementType.INLINE);
-            mTwoPartExpansionView.setMraidListener(new BaseMraidListener() {
-                public void onClose(MraidView view, ViewState newViewState) {
-                    close();
-                }
-            });
-            mTwoPartExpansionView.loadUrl(url);
-            expansionContentView = mTwoPartExpansionView;
-        }
-
-        expandLayouts(expansionContentView, (int) (width * mDensity), (int) (height * mDensity));
-        mRootView.addView(mExpansionLayout, new RelativeLayout.LayoutParams(
-                RelativeLayout.LayoutParams.FILL_PARENT, RelativeLayout.LayoutParams.FILL_PARENT));
-
-        if (mNativeCloseButtonStyle == MraidView.NativeCloseButtonStyle.ALWAYS_VISIBLE ||
-                (!mAdWantsCustomCloseButton &&
-                mNativeCloseButtonStyle != MraidView.NativeCloseButtonStyle.ALWAYS_HIDDEN)) {
-            setNativeCloseButtonEnabled(true);
-        }
-
-        mViewState = ViewState.EXPANDED;
-        getMraidView().fireChangeEventForProperty(MraidStateProperty.createWithViewState(mViewState));
-        if (getMraidView().getMraidListener() != null) getMraidView().getMraidListener().onExpand(getMraidView());
-    }
-
-    protected void showUserDownloadImageAlert(String imageUrl) {
-        Context context = getContext();
-        if (!isStorePictureSupported(context)) {
-            getMraidView().fireErrorEvent(STORE_PICTURE, "Error downloading file - the device does not have an SD card mounted, or the Android permission is not granted.");
-            MoPubLog.d("Error downloading file - the device does not have an SD card mounted, or the Android permission is not granted.");
-            return;
-        }
-
-        if (context instanceof Activity) {
-            showUserDialog(imageUrl);
-        } else {
-            showUserToast("Downloading image to Picture gallery...");
-            downloadImage(imageUrl);
-        }
-    }
-
-    private void showUserToast(final String message) {
-        mHandler.post(new Runnable() {
-            @Override
-            public void run() {
-                Toast.makeText(getContext(), message, Toast.LENGTH_SHORT).show();
-            }
-        });
-    }
-
-    private void downloadImage(final String uriString) {
-        final File pictureStoragePath = getPictureStoragePath();
-
-        pictureStoragePath.mkdirs();
-
-        new Thread(new Runnable() {
-            private URI uri;
-            private InputStream pictureInputStream;
-            private OutputStream pictureOutputStream;
-            private MediaScannerConnection mediaScannerConnection;
-
-            @Override
-            public void run() {
-                try {
-                    uri = URI.create(uriString);
-                    HttpClient httpClient = HttpClientFactory.create();
-                    HttpGet httpGet = new HttpGet(uri);
-
-                    HttpResponse httpResponse = httpClient.execute(httpGet);
-                    pictureInputStream = httpResponse.getEntity().getContent();
-
-                    String redirectLocation = HttpResponses.extractHeader(httpResponse, LOCATION);
-                    if (redirectLocation != null) {
-                        uri = URI.create(redirectLocation);
-                    }
-
-                    final String pictureFileName = getFileNameForUriAndHttpResponse(uri, httpResponse);
-                    File pictureFile = new File(pictureStoragePath, pictureFileName);
-                    final String pictureFileFullPath = pictureFile.toString();
-                    pictureOutputStream = new FileOutputStream(pictureFile);
-
-                    Streams.copyContent(pictureInputStream, pictureOutputStream);
-
-                    loadPictureIntoGalleryApp(pictureFileFullPath);
-                } catch (Exception exception) {
-                    mHandler.post(new Runnable() {
-                        @Override
-                        public void run() {
-                            showUserToast("Image failed to download.");
-                            getMraidView().fireErrorEvent(STORE_PICTURE, "Error downloading and saving image file.");
-                            MoPubLog.d("Error downloading and saving image file.");
-                        }
-                    });
-                } finally {
-                    Streams.closeStream(pictureInputStream);
-                    Streams.closeStream(pictureOutputStream);
-                }
-            }
-
-            private void loadPictureIntoGalleryApp(final String filename) {
-                MoPubMediaScannerConnectionClient mediaScannerConnectionClient = new MoPubMediaScannerConnectionClient(filename, null);
-                mediaScannerConnection = new MediaScannerConnection(getContext().getApplicationContext(), mediaScannerConnectionClient);
-                mediaScannerConnectionClient.setMediaScannerConnection(mediaScannerConnection);
-                mediaScannerConnection.connect();
-            }
-        }).start();
-    }
-
-    private void showUserDialog(final String imageUrl) {
-        AlertDialog.Builder alertDialogDownloadImage = new AlertDialog.Builder(getContext());
-        alertDialogDownloadImage
-                .setTitle("Save Image")
-                .setMessage("Download image to Picture gallery?")
-                .setNegativeButton("Cancel", null)
-                .setPositiveButton("Okay", new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(DialogInterface dialog, int which) {
-                        downloadImage(imageUrl);
-                    }
-                })
-                .setCancelable(true)
-                .show();
-    }
-
-    protected void showVideo(String videoUrl) {
-        MraidVideoPlayerActivity.startMraid(getContext(), videoUrl, getMraidView().getAdConfiguration());
-    }
-
-    protected void getCurrentPosition(){
-        getMraidView().fireErrorEvent(GET_CURRENT_POSITION, "Unsupported action getCurrentPosition");
-    }
-
-    protected void getDefaultPosition(){
-        getMraidView().fireErrorEvent(GET_DEFAULT_POSITION, "Unsupported action getDefaultPosition");
-    }
-
-    protected void getMaxSize(){
-        getMraidView().fireErrorEvent(GET_MAX_SIZE, "Unsupported action getMaxSize");
-    }
-
-    protected void getScreenSize(){
-        getMraidView().fireErrorEvent(GET_SCREEN_SIZE, "Unsupported action getScreenSize");
-    }
-
-    protected void createCalendarEvent(Map<String, String> params) {
-        Context context = getMraidView().getContext();
-        if (Mraids.isCalendarAvailable(context)) {
-            try {
-                Map<String, Object> calendarParams = translateJSParamsToAndroidCalendarEventMapping(params);
-                Intent intent = new Intent(Intent.ACTION_INSERT).setType(ANDROID_CALENDAR_CONTENT_TYPE);
-                for (String key : calendarParams.keySet()) {
-                    Object value = calendarParams.get(key);
-                    if (value instanceof Long) {
-                        intent.putExtra(key, ((Long) value).longValue());
-                    } else if (value instanceof Integer) {
-                        intent.putExtra(key, ((Integer) value).intValue());
-                    } else {
-                        intent.putExtra(key, (String) value);
-                    }
-                }
-                intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-                context.startActivity(intent);
-            } catch (ActivityNotFoundException anfe) {
-                Log.d(LOGTAG, "no calendar app installed");
-                getMraidView().fireErrorEvent(CREATE_CALENDAR_EVENT, "Action is unsupported on this device - no calendar app installed");
-            } catch (IllegalArgumentException iae) {
-                Log.d(LOGTAG, "create calendar: invalid parameters " + iae.getMessage());
-                getMraidView().fireErrorEvent(CREATE_CALENDAR_EVENT, iae.getMessage());
-            } catch (Exception exception){
-                Log.d(LOGTAG, "could not create calendar event");
-                getMraidView().fireErrorEvent(CREATE_CALENDAR_EVENT, "could not create calendar event");
-            }
-        } else {
-            Log.d(LOGTAG, "unsupported action createCalendarEvent for devices pre-ICS");
-            getMraidView().fireErrorEvent(CREATE_CALENDAR_EVENT, "Action is unsupported on this device (need Android version Ice Cream Sandwich or above)");
-        }
-    }
-
-    private Map<String, Object> translateJSParamsToAndroidCalendarEventMapping(Map<String, String> params) throws Exception {
-        Map<String, Object> validatedParamsMapping = new HashMap<String, Object>();
-        if (!params.containsKey("description") || !params.containsKey("start")) {
-            throw new IllegalArgumentException("Missing start and description fields");
-        }
-
-        validatedParamsMapping.put(CalendarContract.Events.TITLE, params.get("description"));
-
-        if (params.containsKey("start") && params.get("start") != null) {
-            Date startDateTime = parseDate(params.get("start"));
-            if (startDateTime != null) {
-                validatedParamsMapping.put(CalendarContract.EXTRA_EVENT_BEGIN_TIME, startDateTime.getTime());
-            } else {
-                throw new IllegalArgumentException("Invalid calendar event: start time is malformed. Date format expecting (yyyy-MM-DDTHH:MM:SS-xx:xx) or (yyyy-MM-DDTHH:MM-xx:xx) i.e. 2013-08-14T09:00:01-08:00");
-            }
-        } else {
-            throw new IllegalArgumentException("Invalid calendar event: start is null.");
-        }
-
-        if (params.containsKey("end") && params.get("end") != null) {
-            Date endDateTime = parseDate(params.get("end"));
-            if (endDateTime != null) {
-                validatedParamsMapping.put(CalendarContract.EXTRA_EVENT_END_TIME, endDateTime.getTime());
-            } else {
-                throw new IllegalArgumentException("Invalid calendar event: end time is malformed. Date format expecting (yyyy-MM-DDTHH:MM:SS-xx:xx) or (yyyy-MM-DDTHH:MM-xx:xx) i.e. 2013-08-14T09:00:01-08:00");
-            }
-        }
-
-        if (params.containsKey("location")) {
-            validatedParamsMapping.put(CalendarContract.Events.EVENT_LOCATION, params.get("location"));
-        }
-
-        if (params.containsKey("summary")) {
-            validatedParamsMapping.put(CalendarContract.Events.DESCRIPTION, params.get("summary"));
-        }
-
-        if (params.containsKey("transparency")) {
-            validatedParamsMapping.put(
-                    CalendarContract.Events.AVAILABILITY,
-                    params.get("transparency").equals("transparent") ?
-                            CalendarContract.Events.AVAILABILITY_FREE :
-                            CalendarContract.Events.AVAILABILITY_BUSY
-            );
-        }
-
-        validatedParamsMapping.put(CalendarContract.Events.RRULE, parseRecurrenceRule(params));
-
-        return validatedParamsMapping;
-    }
-
-    private Date parseDate(String dateTime) {
-        Date result = null;
-        for (int i=0; i<DATE_FORMATS.length; i++) {
-            try {
-                result = new SimpleDateFormat(DATE_FORMATS[i]).parse(dateTime);
-                if (result != null) {
-                    break;
-                }
-            } catch (ParseException e) {
-                // an exception is okay, just try the next format and find the first one that works
-            }
-        }
-        return result;
-    }
-
-    private String parseRecurrenceRule(Map<String, String> params) throws IllegalArgumentException {
-        StringBuilder rule = new StringBuilder();
-        if (params.containsKey("frequency")) {
-            String frequency = params.get("frequency");
-            int interval = -1;
-            if (params.containsKey("interval")) {
-                interval = Integer.parseInt(params.get("interval"));
-            }
-            if ("daily".equals(frequency)) {
-                rule.append("FREQ=DAILY;");
-                if (interval != -1) {
-                    rule.append("INTERVAL=" + interval + ";");
-                }
-            } else if("weekly".equals(frequency)) {
-                rule.append("FREQ=WEEKLY;");
-                if (interval != -1) {
-                    rule.append("INTERVAL=" + interval + ";");
-                }
-                if (params.containsKey("daysInWeek")) {
-                    String weekdays = translateWeekIntegersToDays(params.get("daysInWeek"));
-                    if (weekdays == null) {
-                       throw new IllegalArgumentException("invalid ");
-                    }
-                    rule.append("BYDAY=" + weekdays + ";");
-                }
-            } else if("monthly".equals(frequency)) {
-                rule.append("FREQ=MONTHLY;");
-                if (interval != -1) {
-                    rule.append("INTERVAL=" + interval + ";");
-                }
-                if (params.containsKey("daysInMonth")) {
-                    String monthDays = translateMonthIntegersToDays(params.get("daysInMonth"));
-                    if (monthDays == null) {
-                        throw new IllegalArgumentException();
-                    }
-                    rule.append("BYMONTHDAY=" + monthDays + ";");
-                }
-            } else {
-                throw new IllegalArgumentException("frequency is only supported for daily, weekly, and monthly.");
-            }
-        }
-        return rule.toString();
-    }
-
-    private String translateWeekIntegersToDays(String expression) throws IllegalArgumentException{
-        StringBuilder daysResult = new StringBuilder();
-        boolean[] daysAlreadyCounted = new boolean[7];
-        String[] days = expression.split(",");
-        int dayNumber;
-        for (int i=0; i<days.length; i++) {
-            dayNumber = Integer.parseInt(days[i]);
-            dayNumber = dayNumber == 7 ? 0 : dayNumber;
-            if (!daysAlreadyCounted[dayNumber]) {
-                daysResult.append(dayNumberToDayOfWeekString(dayNumber) + ",");
-                daysAlreadyCounted[dayNumber] = true;
-            }
-        }
-        if (days.length == 0) {
-            throw new IllegalArgumentException("must have at least 1 day of the week if specifying repeating weekly");
-        }
-        daysResult.deleteCharAt(daysResult.length()-1);
-        return daysResult.toString();
-    }
-
-    private String translateMonthIntegersToDays(String expression) throws IllegalArgumentException {
-        StringBuilder daysResult = new StringBuilder();
-        boolean[] daysAlreadyCounted = new boolean[2*MAX_NUMBER_DAYS_IN_MONTH +1]; //for -31 to 31
-        String[] days = expression.split(",");
-        int dayNumber;
-        for (int i=0; i<days.length; i++) {
-            dayNumber = Integer.parseInt(days[i]);
-            if (!daysAlreadyCounted[dayNumber+MAX_NUMBER_DAYS_IN_MONTH]) {
-                daysResult.append(dayNumberToDayOfMonthString(dayNumber) + ",");
-                daysAlreadyCounted[dayNumber+MAX_NUMBER_DAYS_IN_MONTH] = true;
-            }
-        }
-        if (days.length == 0) {
-            throw new IllegalArgumentException("must have at least 1 day of the month if specifying repeating weekly");
-        }
-        daysResult.deleteCharAt(daysResult.length() - 1);
-        return daysResult.toString();
-    }
-
-    private String dayNumberToDayOfWeekString(int number) throws IllegalArgumentException {
-        String dayOfWeek;
-        switch(number) {
-            case 0: dayOfWeek="SU"; break;
-            case 1: dayOfWeek="MO"; break;
-            case 2: dayOfWeek="TU"; break;
-            case 3: dayOfWeek="WE"; break;
-            case 4: dayOfWeek="TH"; break;
-            case 5: dayOfWeek="FR"; break;
-            case 6: dayOfWeek="SA"; break;
-            default: throw new IllegalArgumentException("invalid day of week " + number);
-        }
-        return dayOfWeek;
-    }
-
-    private String dayNumberToDayOfMonthString(int number) throws IllegalArgumentException {
-        String dayOfMonth;
-        // https://android.googlesource.com/platform/frameworks/opt/calendar/+/504844526f1b7afec048c6d2976ffb332670d5ba/src/com/android/calendarcommon2/EventRecurrence.java
-        if (number != 0 && number >= -MAX_NUMBER_DAYS_IN_MONTH && number <= MAX_NUMBER_DAYS_IN_MONTH) {
-            dayOfMonth = "" + number;
-        } else {
-            throw new IllegalArgumentException("invalid day of month " + number);
-        }
-        return dayOfMonth;
-    }
-
-    private void swapViewWithPlaceholderView() {
-        ViewGroup parent = (ViewGroup) getMraidView().getParent();
-        if (parent == null) return;
-
-        int index;
-        int count = parent.getChildCount();
-        for (index = 0; index < count; index++) {
-            if (parent.getChildAt(index) == getMraidView()) break;
-        }
-
-        mViewIndexInParent = index;
-        parent.addView(mPlaceholderView, index,
-                new ViewGroup.LayoutParams(getMraidView().getWidth(), getMraidView().getHeight()));
-        parent.removeView(getMraidView());
-    }
-
-    private void expandLayouts(View expansionContentView, int expandWidth, int expandHeight) {
-        int closeButtonSize = (int) (CLOSE_BUTTON_SIZE_DP * mDensity + 0.5f);
-        if (expandWidth < closeButtonSize) expandWidth = closeButtonSize;
-        if (expandHeight < closeButtonSize) expandHeight = closeButtonSize;
-
-        View dimmingView = new View(getContext());
-        dimmingView.setBackgroundColor(TRANSPARENT);
-        dimmingView.setOnTouchListener(new OnTouchListener() {
-            public boolean onTouch(View v, MotionEvent event) {
-                return true;
-            }
-        });
-
-        mExpansionLayout.addView(dimmingView, new RelativeLayout.LayoutParams(
-                RelativeLayout.LayoutParams.FILL_PARENT, RelativeLayout.LayoutParams.FILL_PARENT));
-
-        mAdContainerLayout.addView(expansionContentView, new RelativeLayout.LayoutParams(
-                RelativeLayout.LayoutParams.FILL_PARENT, RelativeLayout.LayoutParams.FILL_PARENT));
-
-        addCloseEventRegion(mAdContainerLayout);
-
-        RelativeLayout.LayoutParams lp = new RelativeLayout.LayoutParams(expandWidth, expandHeight);
-        lp.addRule(RelativeLayout.CENTER_IN_PARENT);
-        mExpansionLayout.addView(mAdContainerLayout, lp);
-    }
-
-    private void setOrientationLockEnabled(boolean enabled) {
-        Context context = getContext();
-        Activity activity = null;
-        try {
-            activity = (Activity) context;
-            int requestedOrientation = enabled ?
-                    activity.getResources().getConfiguration().orientation :
-                    mOriginalRequestedOrientation;
-            activity.setRequestedOrientation(requestedOrientation);
-        } catch (ClassCastException e) {
-            Log.d(LOGTAG, "Unable to modify device orientation.");
-        }
-    }
-
-    protected void setNativeCloseButtonEnabled(boolean enabled) {
-        if (mRootView == null) {
-            return;
-        }
-
-        if (enabled) {
-            if (mCloseButton == null) {
-                StateListDrawable states = new StateListDrawable();
-                states.addState(new int[] {-android.R.attr.state_pressed}, INTERSTITIAL_CLOSE_BUTTON_NORMAL.decodeImage(mRootView.getContext()));
-                states.addState(new int[] {android.R.attr.state_pressed}, INTERSTITIAL_CLOSE_BUTTON_PRESSED.decodeImage(mRootView.getContext()));
-                mCloseButton = new ImageButton(getContext());
-                mCloseButton.setImageDrawable(states);
-                mCloseButton.setBackgroundDrawable(null);
-                mCloseButton.setOnClickListener(new OnClickListener() {
-                    public void onClick(View v) {
-                        MraidDisplayController.this.close();
-                    }
-                });
-            }
-
-            final int closeButtonSize = Dips.dipsToIntPixels(CLOSE_BUTTON_SIZE_DP, getContext());
-            FrameLayout.LayoutParams buttonLayout = new FrameLayout.LayoutParams(
-                    closeButtonSize, closeButtonSize, Gravity.RIGHT);
-            mAdContainerLayout.addView(mCloseButton, buttonLayout);
-        } else {
-            mAdContainerLayout.removeView(mCloseButton);
-        }
-
-        MraidView view = getMraidView();
-        if (view.getOnCloseButtonStateChangeListener() != null) {
-            view.getOnCloseButtonStateChangeListener().onCloseButtonStateChange(view, enabled);
-        }
-    }
-
-    protected void useCustomClose(boolean shouldUseCustomCloseButton) {
-        mAdWantsCustomCloseButton = shouldUseCustomCloseButton;
-
-        MraidView view = getMraidView();
-        boolean enabled = !shouldUseCustomCloseButton;
-        if (view.getOnCloseButtonStateChangeListener() != null) {
-            view.getOnCloseButtonStateChangeListener().onCloseButtonStateChange(view, enabled);
-        }
-    }
-
-    FrameLayout createAdContainerLayout() {
-        return new FrameLayout(getContext());
-    }
-
-    void addCloseEventRegion(final FrameLayout frameLayout) {
-        final int buttonSizePixels = Dips.dipsToIntPixels(CLOSE_BUTTON_SIZE_DP, getContext());
-        final FrameLayout.LayoutParams layoutParams =
-                new FrameLayout.LayoutParams(buttonSizePixels, buttonSizePixels, Gravity.TOP | Gravity.RIGHT);
-        Interstitials.addCloseEventRegion(frameLayout, layoutParams, mCloseOnClickListener);
-    }
-
-    RelativeLayout createExpansionLayout() {
-        return new RelativeLayout(getContext());
-    }
-
-    FrameLayout createPlaceholderView() {
-        return new FrameLayout(getContext());
-    }
-
-    private Context getContext() {
-        return getMraidView().getContext();
-    }
-
-    protected void initializeSupportedFunctionsProperty() {
-        Context context = getContext();
-        getMraidView().fireChangeEventForProperty(
-                new MraidSupportsProperty()
-                        .withTel(isTelAvailable(context))
-                        .withSms(isSmsAvailable(context))
-                        .withCalendar(isCalendarAvailable(context))
-                        .withInlineVideo(isInlineVideoAvailable(context))
-                        .withStorePicture(isStorePictureSupported(context)));
-    }
-
-    private File getPictureStoragePath() {
-        return new File(Environment.getExternalStorageDirectory(), "Pictures");
-    }
-
-    private String getFileNameForUriAndHttpResponse(final URI uri, final HttpResponse response) {
-        final String path = uri.getPath();
-
-        if (path == null) {
-            return null;
-        }
-
-        String filename = new File(path).getName();
-
-        Header header = response.getFirstHeader(MIME_TYPE_HEADER);
-        if (header != null) {
-            String[] fields = header.getValue().split(";");
-            for (final String field : fields) {
-                String extension;
-                if (field.contains("image/")) {
-                    extension = "." + field.split("/")[1];
-                    if (!filename.endsWith(extension)) {
-                        filename += extension;
-                    }
-                    break;
-                }
-            }
-        }
-
-        return filename;
-    }
-
-    private class MoPubMediaScannerConnectionClient implements MediaScannerConnection.MediaScannerConnectionClient {
-        private final String mFilename;
-        private final String mMimeType;
-        private MediaScannerConnection mMediaScannerConnection;
-
-        private MoPubMediaScannerConnectionClient(String filename, String mimeType) {
-            mFilename = filename;
-            mMimeType = mimeType;
-        }
-
-        private void setMediaScannerConnection(MediaScannerConnection connection) {
-            mMediaScannerConnection = connection;
-        }
-
-        @Override
-        public void onMediaScannerConnected() {
-            if (mMediaScannerConnection != null) {
-                mMediaScannerConnection.scanFile(mFilename, mMimeType);
-            }
-        }
-
-        @Override
-        public void onScanCompleted(String path, Uri uri) {
-            if (mMediaScannerConnection != null) {
-                mMediaScannerConnection.disconnect();
-            }
-        }
-    }
-
-    class OrientationBroadcastReceiver extends BroadcastReceiver {
-        private int mLastRotation;
-        private Context mContext;
-
-        public void onReceive(Context context, Intent intent) {
-            if(!isRegistered()) {
-                return;
-            }
-            String action = intent.getAction();
-            if (action.equals(Intent.ACTION_CONFIGURATION_CHANGED)) {
-                int orientation = MraidDisplayController.this.getDisplayRotation();
-                if (orientation != mLastRotation) {
-                    mLastRotation = orientation;
-                    MraidDisplayController.this.onOrientationChanged(mLastRotation);
-                }
-            }
-        }
-
-        private boolean isRegistered() {
-            return mContext != null;
-        }
-
-        public void register(Context context) {
-            mContext = context;
-            context.registerReceiver(this,
-                    new IntentFilter(Intent.ACTION_CONFIGURATION_CHANGED));
-        }
-
-        public void unregister() {
-            mContext.unregisterReceiver(this);
-            mContext = null;
-        }
-    }
-
-    // testing
-    @Deprecated
-    public OnClickListener getCloseOnClickListener() {
-        return mCloseOnClickListener;
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidInterstitial.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidInterstitial.java
deleted file mode 100644
index 53ac578e..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidInterstitial.java
+++ /dev/null
@@ -1,27 +0,0 @@
-package com.mopub.mobileads;
-
-
-import android.net.Uri;
-
-import java.util.Map;
-
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
-
-class MraidInterstitial extends ResponseBodyInterstitial {
-    private String mHtmlData;
-
-    @Override
-    protected void extractExtras(Map<String, String> serverExtras) {
-        mHtmlData = Uri.decode(serverExtras.get(HTML_RESPONSE_BODY_KEY));
-    }
-
-    @Override
-    protected void preRenderHtml(CustomEventInterstitialListener customEventInterstitialListener) {
-        MraidActivity.preRenderHtml(mContext, customEventInterstitialListener, mHtmlData);
-    }
-
-    @Override
-    protected void showInterstitial() {
-        MraidActivity.start(mContext, mHtmlData, mAdConfiguration);
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidProperty.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidProperty.java
deleted file mode 100644
index bfcfdf56..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidProperty.java
+++ /dev/null
@@ -1,132 +0,0 @@
-package com.mopub.mobileads;
-
-import com.mopub.mobileads.MraidView.PlacementType;
-import com.mopub.mobileads.MraidView.ViewState;
-
-abstract class MraidProperty {
-    private String sanitize(String str) {
-        return (str != null) ? str.replaceAll("[^a-zA-Z0-9_,:\\s\\{\\}\\\'\\\"]", "") : "";
-    }
-
-    @Override
-    public String toString() {
-        return sanitize(toJsonPair());
-    }
-
-    public abstract String toJsonPair();
-}
-
-class MraidPlacementTypeProperty extends MraidProperty {
-    private final PlacementType mPlacementType;
-
-    MraidPlacementTypeProperty(PlacementType placementType) {
-        mPlacementType = placementType;
-    }
-
-    public static MraidPlacementTypeProperty createWithType(
-            PlacementType placementType) {
-        return new MraidPlacementTypeProperty(placementType);
-    }
-
-    @Override
-    public String toJsonPair() {
-        return "placementType: '" + mPlacementType.toString().toLowerCase() + "'";
-    }
-}
-
-class MraidScreenSizeProperty extends MraidProperty {
-    private final int mScreenWidth;
-    private final int mScreenHeight;
-
-    MraidScreenSizeProperty(int width, int height) {
-        mScreenWidth = width;
-        mScreenHeight = height;
-    }
-
-    public static MraidScreenSizeProperty createWithSize(int width, int height) {
-        return new MraidScreenSizeProperty(width, height);
-    }
-
-    @Override
-    public String toJsonPair() {
-        return "screenSize: { width: " + mScreenWidth + ", height: " + mScreenHeight + " }";
-    }
-}
-
-class MraidStateProperty extends MraidProperty {
-    private final ViewState mViewState;
-
-    MraidStateProperty(ViewState viewState) {
-        mViewState = viewState;
-    }
-
-    public static MraidStateProperty createWithViewState(ViewState viewState) {
-        return new MraidStateProperty(viewState);
-    }
-
-    @Override
-    public String toJsonPair() {
-        return "state: '" + mViewState.toString().toLowerCase() + "'";
-    }
-}
-
-class MraidViewableProperty extends MraidProperty {
-    private final boolean mViewable;
-
-    MraidViewableProperty(boolean viewable) {
-        mViewable = viewable;
-    }
-
-    public static MraidViewableProperty createWithViewable(boolean viewable) {
-        return new MraidViewableProperty(viewable);
-    }
-
-    @Override
-    public String toJsonPair() {
-        return "viewable: " + (mViewable ? "true" : "false");
-    }
-}
-
-class MraidSupportsProperty extends MraidProperty{
-    private boolean sms;
-    private boolean tel;
-    private boolean calendar;
-    private boolean storePicture;
-    private boolean inlineVideo;
-
-    @Override
-    public String toJsonPair() {
-        return "supports: {" +
-                "sms: " + String.valueOf(sms) + ", " +
-                "tel: " + String.valueOf(tel) + ", " +
-                "calendar: " + String.valueOf(calendar) + ", " +
-                "storePicture: " + String.valueOf(storePicture) + ", " +
-                "inlineVideo: " + String.valueOf(inlineVideo) + "}";
-    }
-
-    public MraidSupportsProperty withSms(boolean value) {
-        sms = value;
-        return this;
-    }
-
-
-    public MraidSupportsProperty withTel(boolean value) {
-        tel = value;
-        return this;
-    }
-
-    public MraidSupportsProperty withCalendar(boolean value) {
-        calendar = value;
-        return this;
-    }
-
-    public MraidSupportsProperty withStorePicture(boolean value) {
-        storePicture = value;
-        return this;
-    }
-
-    public MraidSupportsProperty withInlineVideo(boolean value) {
-        inlineVideo = value;
-        return this;
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidVideoPlayerActivity.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidVideoPlayerActivity.java
index 7c9a2202..8fa79451 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidVideoPlayerActivity.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidVideoPlayerActivity.java
@@ -4,18 +4,21 @@
 import android.content.ActivityNotFoundException;
 import android.content.Intent;
 import android.os.Bundle;
+import android.support.annotation.Nullable;
 import android.view.View;
 import android.view.Window;
 import android.view.WindowManager;
 
 import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.IntentUtils;
+import com.mopub.common.util.Intents;
+import com.mopub.mraid.MraidVideoViewController;
 
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_FAIL;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.broadcastAction;
 
 public class MraidVideoPlayerActivity extends BaseVideoPlayerActivity implements BaseVideoViewController.BaseVideoViewControllerListener {
-    private BaseVideoViewController mBaseVideoController;
+    @Nullable private BaseVideoViewController mBaseVideoController;
     private long mBroadcastIdentifier;
 
     @Override
@@ -25,16 +28,14 @@ protected void onCreate(Bundle savedInstanceState) {
         requestWindowFeature(Window.FEATURE_NO_TITLE);
         getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
 
-        final AdConfiguration adConfiguration = getAdConfiguration();
-        if (adConfiguration != null) {
-            mBroadcastIdentifier = adConfiguration.getBroadcastIdentifier();
-        } else {
-            MoPubLog.d("Unable to obtain broadcast identifier. Video interactions cannot be tracked.");
-        }
+        mBroadcastIdentifier = getBroadcastIdentifierFromIntent(getIntent());
 
         try {
             mBaseVideoController = createVideoViewController();
         } catch (IllegalStateException e) {
+            // This can happen if the activity was started without valid intent extras. We leave
+            // mBaseVideoController set to null, and finish the activity immediately.
+            
             broadcastAction(this, mBroadcastIdentifier, ACTION_INTERSTITIAL_FAIL);
             finish();
             return;
@@ -45,42 +46,40 @@ protected void onCreate(Bundle savedInstanceState) {
 
     @Override
     protected void onPause() {
-        mBaseVideoController.onPause();
+        if (mBaseVideoController != null) {
+            mBaseVideoController.onPause();
+        }
         super.onPause();
     }
 
     @Override
     protected void onResume() {
         super.onResume();
-        mBaseVideoController.onResume();
+        if (mBaseVideoController != null) {
+            mBaseVideoController.onResume();
+        }
     }
 
     @Override
     protected void onDestroy() {
-        mBaseVideoController.onDestroy();
+        if (mBaseVideoController != null) {
+            mBaseVideoController.onDestroy();
+        }
         super.onDestroy();
     }
 
     @Override
     public void onBackPressed() {
-        if (mBaseVideoController.backButtonEnabled()) {
+        if (mBaseVideoController != null && mBaseVideoController.backButtonEnabled()) {
             super.onBackPressed();
         }
     }
 
     @Override
     protected void onActivityResult(final int requestCode, final int resultCode, final Intent data) {
-        mBaseVideoController.onActivityResult(requestCode, resultCode, data);
-    }
-
-    private AdConfiguration getAdConfiguration() {
-        AdConfiguration adConfiguration;
-        try {
-            adConfiguration = (AdConfiguration) getIntent().getSerializableExtra(AdFetcher.AD_CONFIGURATION_KEY);
-        } catch (ClassCastException e) {
-            adConfiguration = null;
+        if (mBaseVideoController != null) {
+            mBaseVideoController.onActivityResult(requestCode, resultCode, data);
         }
-        return adConfiguration;
     }
 
     private BaseVideoViewController createVideoViewController() throws IllegalStateException {
@@ -89,7 +88,7 @@ private BaseVideoViewController createVideoViewController() throws IllegalStateE
         if ("vast".equals(clazz)) {
             return new VastVideoViewController(this, getIntent().getExtras(), mBroadcastIdentifier, this);
         } else if ("mraid".equals(clazz)) {
-            return new MraidVideoViewController(this, getIntent().getExtras(), mBroadcastIdentifier, this);
+            return new MraidVideoViewController(this, getIntent().getExtras(), this);
         } else {
             throw new IllegalStateException("Unsupported video type: " + clazz);
         }
@@ -122,7 +121,7 @@ public void onStartActivityForResult(final Class<? extends Activity> clazz,
             return;
         }
 
-        final Intent intent = IntentUtils.getStartActivityIntent(this, clazz, extras);
+        final Intent intent = Intents.getStartActivityIntent(this, clazz, extras);
 
         try {
             startActivityForResult(intent, requestCode);
@@ -131,6 +130,10 @@ public void onStartActivityForResult(final Class<? extends Activity> clazz,
         }
     }
 
+    protected static long getBroadcastIdentifierFromIntent(Intent intent) {
+        return intent.getLongExtra(BROADCAST_IDENTIFIER_KEY, -1);
+    }
+
     @Deprecated // for testing
     BaseVideoViewController getBaseVideoViewController() {
         return mBaseVideoController;
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidView.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidView.java
deleted file mode 100644
index 4a5fa6b9..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidView.java
+++ /dev/null
@@ -1,411 +0,0 @@
-package com.mopub.mobileads;
-
-import android.content.ActivityNotFoundException;
-import android.content.Context;
-import android.content.Intent;
-import android.graphics.Color;
-import android.net.Uri;
-import android.util.Log;
-import android.view.MotionEvent;
-import android.view.View;
-import android.webkit.WebView;
-import android.webkit.WebViewClient;
-import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.Strings;
-import com.mopub.mobileads.factories.HttpClientFactory;
-import com.mopub.mobileads.resource.MraidJavascript;
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpResponse;
-import org.apache.http.NameValuePair;
-import org.apache.http.client.ClientProtocolException;
-import org.apache.http.client.HttpClient;
-import org.apache.http.client.methods.HttpGet;
-import org.apache.http.client.utils.URLEncodedUtils;
-
-import java.io.*;
-import java.net.URI;
-import java.util.*;
-
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand;
-import static com.mopub.mobileads.ViewGestureDetector.UserClickListener;
-
-public class MraidView extends BaseWebView implements UserClickListener {
-    private static final String LOGTAG = "MraidView";
-    
-    private MoPubBrowserController mBrowserController;
-    private MraidDisplayController mDisplayController;
-    
-    private WebViewClient mWebViewClient;
-
-    private boolean mHasFiredReadyEvent;
-    private boolean mClicked;
-    private final PlacementType mPlacementType;
-    private ViewGestureDetector mViewGestureDetector;
-    private AdConfiguration mAdConfiguration;
-    private boolean mIsVisible;
-
-    static class MraidListenerInfo {
-        private MraidListener mMraidListener;
-        private OnCloseButtonStateChangeListener mOnCloseButtonListener;
-    }
-    private MraidListenerInfo mListenerInfo;
-
-    public enum ViewState {
-        LOADING,
-        DEFAULT,
-        EXPANDED,
-        HIDDEN
-    }
-
-    public enum ExpansionStyle {
-        ENABLED,
-        DISABLED
-    }
-
-    public enum NativeCloseButtonStyle {
-        ALWAYS_VISIBLE,
-        ALWAYS_HIDDEN,
-        AD_CONTROLLED
-    }
-
-    public enum PlacementType {
-        INLINE,
-        INTERSTITIAL
-    }
-
-    public MraidView(Context context, AdConfiguration adConfiguration) {
-        this(context, adConfiguration, ExpansionStyle.ENABLED, NativeCloseButtonStyle.AD_CONTROLLED,
-                PlacementType.INLINE);
-    }
-
-    public MraidView(Context context, AdConfiguration adConfiguration, ExpansionStyle expStyle, NativeCloseButtonStyle buttonStyle,
-                     PlacementType placementType) {
-        super(context);
-        mPlacementType = placementType;
-
-        mAdConfiguration = adConfiguration;
-        mViewGestureDetector = new ViewGestureDetector(context, this, adConfiguration);
-        mViewGestureDetector.setUserClickListener(this);
-
-        mIsVisible = (getVisibility() == View.VISIBLE);
-
-        initialize(expStyle, buttonStyle);
-    }
-
-    @Override
-    public void onUserClick() {
-        mClicked = true;
-    }
-
-    @Override
-    public void onResetUserClick() {
-        mClicked = false;
-    }
-
-    @Override
-    public boolean wasClicked() {
-        return mClicked;
-    }
-
-    private void initialize(ExpansionStyle expStyle, NativeCloseButtonStyle buttonStyle) {
-        setScrollContainer(false);
-        setBackgroundColor(Color.TRANSPARENT);
-        
-        setVerticalScrollBarEnabled(false);
-        setHorizontalScrollBarEnabled(false);
-        
-        setOnTouchListener(new View.OnTouchListener() {
-            public boolean onTouch(View v, MotionEvent event) {
-                mViewGestureDetector.sendTouchEvent(event);
-
-                switch (event.getAction()) {
-                    case MotionEvent.ACTION_DOWN:
-                    case MotionEvent.ACTION_UP:
-                        if (!v.hasFocus()) {
-                            v.requestFocus();
-                        }
-                        break;
-                }
-                return false;
-            }
-        });
-        
-        getSettings().setJavaScriptEnabled(true);
-        
-        mBrowserController = new MoPubBrowserController(this);
-        mDisplayController = new MraidDisplayController(this, expStyle, buttonStyle);
-        
-        mWebViewClient = new MraidWebViewClient();
-        setWebViewClient(mWebViewClient);
-
-        mListenerInfo = new MraidListenerInfo();
-    }
-
-    AdConfiguration getAdConfiguration() {
-        return mAdConfiguration;
-    }
-
-    @Override
-    public void destroy() {
-        mDisplayController.destroy();
-        super.destroy();
-    }
-
-    public void loadHtmlData(String data) {
-        if (data == null) {
-            return;
-        }
-
-        // If the string data lacks the HTML boilerplate, add it.
-        if (!data.contains("<html>")) {
-            data = "<html><head></head><body style='margin:0;padding:0;'>" + data +
-                    "</body></html>";
-        }
-        
-        // Inject the MRAID JavaScript bridge.
-        data = data.replace("<head>", "<head><script>" + MraidJavascript.JAVASCRIPT_SOURCE + "</script>");
-
-        loadDataWithBaseURL(null, data, "text/html", "UTF-8", null);
-    }
-
-    @Override
-    public void loadUrl(String url) {
-        if (url == null) {
-            return;
-        }
-
-        if (url.startsWith("javascript:")) {
-            super.loadUrl(url);
-            return;
-        }
-
-        HttpClient httpClient = HttpClientFactory.create();
-        String outString = "";
-        
-        try {
-            HttpGet httpGet = new HttpGet(url);
-            HttpResponse response = httpClient.execute(httpGet);
-            HttpEntity entity = response.getEntity();
-    
-            if (entity != null) {
-                outString = Strings.fromStream(entity.getContent());
-            }
-        } catch (IllegalArgumentException e) {
-            MoPubLog.d("Mraid loadUrl failed (IllegalArgumentException): " + url);
-            notifyOnFailureListener();
-            return;
-        } catch (ClientProtocolException e) {
-            notifyOnFailureListener();
-            return;
-        } catch (IOException e) {
-            notifyOnFailureListener();
-            return;
-        }
-
-        loadHtmlData(outString);
-    }
-    
-    private void notifyOnFailureListener() {
-        if (mListenerInfo.mMraidListener != null) {
-            mListenerInfo.mMraidListener.onFailure(this);
-        }
-    }
-
-    // Controllers /////////////////////////////////////////////////////////////////////////////////
-    
-    protected MoPubBrowserController getBrowserController() {
-        return mBrowserController;
-    }
-    
-    protected MraidDisplayController getDisplayController() {
-        return mDisplayController;
-    }
-    
-    // Listeners ///////////////////////////////////////////////////////////////////////////////////
-
-    public void setMraidListener(MraidListener mraidListener) {
-        mListenerInfo.mMraidListener = mraidListener;
-    }
-
-    public MraidListener getMraidListener() {
-        return mListenerInfo.mMraidListener;
-    }
-
-    public void setOnCloseButtonStateChange(OnCloseButtonStateChangeListener listener) {
-        mListenerInfo.mOnCloseButtonListener = listener;
-    }
-    
-    public OnCloseButtonStateChangeListener getOnCloseButtonStateChangeListener() {
-        return mListenerInfo.mOnCloseButtonListener;
-    }
-    
-    // JavaScript injection ////////////////////////////////////////////////////////////////////////
-    
-    protected void injectJavaScript(String js) {
-        if (js != null) super.loadUrl("javascript:" + js);
-    }
-    
-    protected void fireChangeEventForProperty(MraidProperty property) {
-        String json = "{" + property.toString() + "}";
-        injectJavaScript("window.mraidbridge.fireChangeEvent(" + json + ");");
-        Log.d(LOGTAG, "Fire change: " + json);
-    }
-    
-    protected void fireChangeEventForProperties(ArrayList<MraidProperty> properties) {
-        String props = properties.toString();
-        if (props.length() < 2) return;
-        
-        String json = "{" + props.substring(1, props.length() - 1) + "}";
-        injectJavaScript("window.mraidbridge.fireChangeEvent(" + json + ");");
-        Log.d(LOGTAG, "Fire changes: " + json);
-    }
-    
-    protected void fireErrorEvent(MraidJavascriptCommand mraidJavascriptCommand, String message) {
-        String action = mraidJavascriptCommand.getCommand();
-
-        injectJavaScript("window.mraidbridge.fireErrorEvent('" + action + "', '" + message + "');");
-    }
-    
-    protected void fireReadyEvent() {
-        injectJavaScript("window.mraidbridge.fireReadyEvent();");
-    }
-    
-    protected void fireNativeCommandCompleteEvent(String command) {
-        injectJavaScript("window.mraidbridge.nativeCallComplete('" + command + "');");
-    }
-    
-    private boolean tryCommand(URI uri) {
-        String commandType = uri.getHost();
-        List<NameValuePair> list = URLEncodedUtils.parse(uri, "UTF-8");
-        Map<String, String> params = new HashMap<String, String>();
-        for (NameValuePair pair : list) {
-            params.put(pair.getName(), pair.getValue());
-        }
-
-        MraidCommand command = MraidCommandFactory.create(commandType, params, this);
-
-        if (command == null) {
-            fireNativeCommandCompleteEvent(commandType);
-            return false;
-        } else if (command.isCommandDependentOnUserClick(mPlacementType) && !wasClicked()) {
-            return false;
-        } else {
-            command.execute();
-            fireNativeCommandCompleteEvent(commandType);
-            return true;
-        }
-    }
-
-    private class MraidWebViewClient extends WebViewClient {
-        @Override
-        public void onReceivedError(WebView view, int errorCode, String description, String failingUrl) {
-            Log.d(LOGTAG, "Error: " + description);
-            super.onReceivedError(view, errorCode, description, failingUrl);
-        }
-        
-        @Override
-        public boolean shouldOverrideUrlLoading(WebView view, String url) {
-            Uri uri = Uri.parse(url);
-
-            // Note that scheme will be null when we are passed a relative Uri
-            String scheme = uri.getScheme();
-
-            if ("mopub".equals(scheme)) {
-                return true;
-            }
-
-            if ("mraid".equals(scheme)) {
-                tryCommand(URI.create(url)); // java.net.URI, not android.net.Uri
-                return true;
-            }
-
-            if (wasClicked()) {
-                Intent i = new Intent();
-                i.setAction(Intent.ACTION_VIEW);
-                i.setData(Uri.parse(url));
-                i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-
-                try {
-                    getContext().startActivity(i);
-                    return true;
-                } catch (ActivityNotFoundException e) {
-                    return false;
-                }
-            }
-
-            return false;
-        }
-        
-        @Override
-        public void onPageFinished(WebView view, String url) {
-            if (!mHasFiredReadyEvent) {
-                mDisplayController.initializeJavaScriptState();
-                fireChangeEventForProperty(MraidPlacementTypeProperty.createWithType(mPlacementType));
-                fireReadyEvent();
-                if (getMraidListener() != null) {
-                    getMraidListener().onReady(MraidView.this);
-                }
-                mIsVisible = (getVisibility() == View.VISIBLE);
-                fireChangeEventForProperty(MraidViewableProperty.createWithViewable(mIsVisible));
-                mHasFiredReadyEvent = true;
-            }
-        }
-        
-        @Override
-        public void onLoadResource(WebView view, String url) {
-            Log.d(LOGTAG, "Loaded resource: " + url);
-        }
-    }
-
-    public interface MraidListener {
-        public void onReady(MraidView view);
-        public void onFailure(MraidView view);
-        public void onExpand(MraidView view);
-        public void onOpen(MraidView view);
-        public void onClose(MraidView view, ViewState newViewState);
-    }
-
-    public static class BaseMraidListener implements MraidListener {
-        @Override public void onReady(MraidView view) { }
-        @Override public void onFailure(MraidView view) { }
-        @Override public void onExpand(MraidView view) { }
-        @Override public void onOpen(MraidView view) { }
-        @Override public void onClose(MraidView view, ViewState newViewState) { }
-    }
-
-    public interface OnCloseButtonStateChangeListener {
-        public void onCloseButtonStateChange(MraidView view, boolean enabled);
-    }
-
-    public boolean getIsVisible() {
-        return mIsVisible;
-    }
-
-    @Override
-    protected void onVisibilityChanged (View changedView, int visibility) {
-        super.onVisibilityChanged(changedView, visibility);
-
-        boolean newIsVisible = (visibility == View.VISIBLE);
-        if (newIsVisible != mIsVisible) {
-            mIsVisible = newIsVisible;
-            if (mHasFiredReadyEvent) {
-                fireChangeEventForProperty(MraidViewableProperty.createWithViewable(mIsVisible));
-            }
-        }
-    }
-
-    @Deprecated // for testing
-    void setHasFiredReadyEvent(boolean hasFired) {
-        mHasFiredReadyEvent = hasFired;
-    }
-
-    @Deprecated // for testing
-    WebViewClient getMraidWebViewClient() {
-        return mWebViewClient;
-    }
-
-    @Deprecated // for testing
-    void setMraidDisplayController(MraidDisplayController mraidDisplayController) {
-        mDisplayController = mraidDisplayController;
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/ResponseBodyInterstitial.java b/mopub-sdk/src/main/java/com/mopub/mobileads/ResponseBodyInterstitial.java
index 2d73912e..a6b3c625 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/ResponseBodyInterstitial.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/ResponseBodyInterstitial.java
@@ -2,23 +2,28 @@
 
 import android.content.Context;
 
+import com.mopub.common.AdReport;
+import com.mopub.common.logging.MoPubLog;
+
 import java.util.Map;
 
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
+import static com.mopub.common.DataKeys.AD_REPORT_KEY;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_INVALID_STATE;
 
-abstract class ResponseBodyInterstitial extends CustomEventInterstitial {
+public abstract class ResponseBodyInterstitial extends CustomEventInterstitial {
     private EventForwardingBroadcastReceiver mBroadcastReceiver;
     protected Context mContext;
-    protected AdConfiguration mAdConfiguration;
-    long mBroadcastIdentifier;
+    protected AdReport mAdReport;
+    protected long mBroadcastIdentifier;
 
     abstract protected void extractExtras(Map<String, String> serverExtras);
     abstract protected void preRenderHtml(CustomEventInterstitialListener customEventInterstitialListener);
-    abstract protected void showInterstitial();
+    public abstract void showInterstitial();
 
     @Override
-    protected void loadInterstitial(
+    public void loadInterstitial(
             Context context,
             CustomEventInterstitialListener customEventInterstitialListener,
             Map<String, Object> localExtras,
@@ -33,19 +38,31 @@ protected void loadInterstitial(
             return;
         }
 
-        mAdConfiguration = AdConfiguration.extractFromMap(localExtras);
-        if (mAdConfiguration != null) {
-            mBroadcastIdentifier = mAdConfiguration.getBroadcastIdentifier();
+
+        try {
+            mAdReport = (AdReport) localExtras.get(AD_REPORT_KEY);
+            Long boxedBroadcastId = (Long) localExtras.get(BROADCAST_IDENTIFIER_KEY);
+            if (boxedBroadcastId == null) {
+                MoPubLog.e("Broadcast Identifier was not set in localExtras");
+                customEventInterstitialListener.onInterstitialFailed(MoPubErrorCode.INTERNAL_ERROR);
+                return;
+            }
+            mBroadcastIdentifier = boxedBroadcastId;
+        } catch (ClassCastException e) {
+            MoPubLog.e("LocalExtras contained an incorrect type.");
+            customEventInterstitialListener.onInterstitialFailed(MoPubErrorCode.INTERNAL_ERROR);
+            return;
         }
 
-        mBroadcastReceiver = new EventForwardingBroadcastReceiver(customEventInterstitialListener, mBroadcastIdentifier);
+        mBroadcastReceiver = new EventForwardingBroadcastReceiver(customEventInterstitialListener,
+                mBroadcastIdentifier);
         mBroadcastReceiver.register(context);
 
         preRenderHtml(customEventInterstitialListener);
     }
 
     @Override
-    protected void onInvalidate() {
+    public void onInvalidate() {
         if (mBroadcastReceiver != null) {
             mBroadcastReceiver.unregister();
         }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/RewardedVideoData.java b/mopub-sdk/src/main/java/com/mopub/mobileads/RewardedVideoData.java
new file mode 100644
index 00000000..c3d45cec
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/RewardedVideoData.java
@@ -0,0 +1,118 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.Pair;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeMap;
+
+/**
+ * Used to manage the mapping between MoPub ad unit ids and third-party ad network ids for rewarded videos.
+ */
+class RewardedVideoData {
+    @NonNull
+    private final Map<String, CustomEventRewardedVideo> mAdUnitToCustomEventMap;
+    @NonNull
+    private final Map<TwoPartKey, Set<String>> mCustomEventToMoPubIdMap;
+    @NonNull
+    private final Set<CustomEventRewardedVideo.CustomEventRewardedVideoListener> mAdNetworkListeners;
+
+    RewardedVideoData() {
+        mAdUnitToCustomEventMap = new TreeMap<String, CustomEventRewardedVideo>();
+        mCustomEventToMoPubIdMap = new HashMap<TwoPartKey, Set<String>>();
+        mAdNetworkListeners = new HashSet<CustomEventRewardedVideo.CustomEventRewardedVideoListener>();
+    }
+
+    @Nullable
+    CustomEventRewardedVideo getCustomEvent(@NonNull String moPubId) {
+        return mAdUnitToCustomEventMap.get(moPubId);
+    }
+
+    @NonNull
+    Set<String> getMoPubIdsForAdNetwork(
+            @NonNull Class<? extends CustomEventRewardedVideo> customEventClass,
+            @Nullable String adNetworkId) {
+        if (adNetworkId == null) {
+            final Set<String> allIds = new HashSet<String>();
+            for (final Map.Entry<TwoPartKey, Set<String>> entry : mCustomEventToMoPubIdMap.entrySet()) {
+                final Class<?> clazz = entry.getKey().customEventClass;
+                if (customEventClass == clazz) {
+                    allIds.addAll(entry.getValue());
+                }
+            }
+            return allIds;
+        } else {
+            final TwoPartKey key = new TwoPartKey(customEventClass, adNetworkId);
+            return mCustomEventToMoPubIdMap.containsKey(key)
+                    ? mCustomEventToMoPubIdMap.get(key)
+                    : Collections.<String>emptySet();
+        }
+    }
+
+    void updateAdUnitCustomEventMapping(
+            @NonNull String moPubId,
+            @NonNull CustomEventRewardedVideo customEvent,
+            @Nullable CustomEventRewardedVideo.CustomEventRewardedVideoListener listener,
+            @NonNull String adNetworkId) {
+        mAdUnitToCustomEventMap.put(moPubId, customEvent);
+        mAdNetworkListeners.add(listener);
+        associateCustomEventWithMoPubId(customEvent.getClass(), adNetworkId, moPubId);
+    }
+
+    void associateCustomEventWithMoPubId(
+            @NonNull Class<? extends CustomEventRewardedVideo> customEventClass,
+            @NonNull String adNetworkId,
+            @NonNull String moPubId) {
+        final TwoPartKey newCustomEventMapping = new TwoPartKey(customEventClass, adNetworkId);
+
+        // Remove previous mapping for this moPubId
+        final Iterator<Map.Entry<TwoPartKey, Set<String>>> entryIterator =
+                mCustomEventToMoPubIdMap.entrySet().iterator();
+        while (entryIterator.hasNext()) {
+            final Map.Entry<TwoPartKey, Set<String>> entry = entryIterator.next();
+
+            if (!entry.getKey().equals(newCustomEventMapping)) {
+                if (entry.getValue().contains(moPubId)) {
+                    entry.getValue().remove(moPubId);
+                    // Ensure that entries containing empty Sets are completely removed from the Map
+                    if (entry.getValue().isEmpty()) {
+                        entryIterator.remove();
+                    }
+
+                    // moPubIds can exist at most once in the Map values, so break upon finding a match
+                    break;
+                }
+            }
+        }
+
+        // Add a new mapping if necessary.
+        Set<String> moPubIds = mCustomEventToMoPubIdMap.get(newCustomEventMapping);
+        if (moPubIds == null) {
+            moPubIds = new HashSet<String>();
+            mCustomEventToMoPubIdMap.put(newCustomEventMapping, moPubIds);
+        }
+        moPubIds.add(moPubId);
+    }
+
+    private static class TwoPartKey extends Pair<Class<? extends CustomEventRewardedVideo>, String> {
+        @NonNull
+        final Class<? extends CustomEventRewardedVideo> customEventClass;
+        @NonNull
+        final String adNetworkId;
+
+        public TwoPartKey(
+                @NonNull final Class<? extends CustomEventRewardedVideo> customEventClass,
+                @NonNull final String adNetworkId) {
+            super(customEventClass, adNetworkId);
+
+            this.customEventClass = customEventClass;
+            this.adNetworkId = adNetworkId;
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/TaskTracker.java b/mopub-sdk/src/main/java/com/mopub/mobileads/TaskTracker.java
deleted file mode 100644
index ffe0a65b..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/TaskTracker.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package com.mopub.mobileads;
-
-public class TaskTracker {
-    private long mCurrentTaskId = -1l;
-    private long mLastCompletedTaskId;
-
-    public long getCurrentTaskId() {
-        return mCurrentTaskId;
-    }
-
-    public void newTaskStarted() {
-        mCurrentTaskId++;
-    }
-
-    public void markTaskCompleted(long taskId) {
-        if (taskId > mLastCompletedTaskId) {
-            mLastCompletedTaskId = taskId;
-        }
-    }
-
-    public boolean isMostCurrentTask(long taskId) {
-        return taskId >= mLastCompletedTaskId;
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/ToolbarWidget.java b/mopub-sdk/src/main/java/com/mopub/mobileads/ToolbarWidget.java
index 382b0e03..df1fd823 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/ToolbarWidget.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/ToolbarWidget.java
@@ -1,6 +1,7 @@
 package com.mopub.mobileads;
 
 import android.content.Context;
+import android.graphics.Bitmap;
 import android.graphics.Color;
 import android.graphics.drawable.Drawable;
 import android.text.TextUtils;
@@ -11,10 +12,13 @@
 import android.widget.RelativeLayout;
 import android.widget.TextView;
 
-import com.mopub.common.util.Dips;
 import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Dips;
 import com.mopub.common.util.Utils;
 import com.mopub.mobileads.resource.TextDrawable;
+import com.mopub.network.Networking;
+import com.mopub.volley.VolleyError;
+import com.mopub.volley.toolbox.ImageLoader;
 
 import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;
 
@@ -105,6 +109,7 @@ ToolbarWidget build() {
 
     private TextView mTextView;
     private ImageView mImageView;
+    private final ImageLoader mImageLoader;
 
     private static final int TEXT_PADDING_DIPS = 5;
     private static final int IMAGE_PADDING_DIPS = 5;
@@ -125,6 +130,8 @@ private ToolbarWidget(Builder builder) {
         mImagePadding = Dips.dipsToIntPixels(IMAGE_PADDING_DIPS, getContext());
         mImageSideLength = Dips.dipsToIntPixels(IMAGE_SIDE_LENGTH_DIPS, getContext());
 
+        mImageLoader = Networking.getImageLoader(getContext());
+
         setVisibility(builder.visibility);
 
         if (builder.hasDrawable) {
@@ -188,13 +195,48 @@ void updateImageText(final String text) {
         }
     }
 
+    void updateImage(final String imageUrl) {
+        mImageLoader.get(imageUrl, new ImageLoader.ImageListener() {
+            @Override
+            public void onResponse(final ImageLoader.ImageContainer imageContainer,
+                    final boolean isImmediate) {
+                Bitmap bitmap = imageContainer.getBitmap();
+                if (bitmap != null) {
+                    mImageView.setImageBitmap(bitmap);
+                } else {
+                    MoPubLog.d(String.format("%s returned null bitmap", imageUrl));
+                }
+            }
+
+            @Override
+            public void onErrorResponse(final VolleyError volleyError) {
+                MoPubLog.d("Failed to load image.", volleyError);
+            }
+        });
+    }
+
+    @Deprecated // for testing
+    ImageView getImageView() {
+        return mImageView;
+    }
+
+    @Deprecated // for testing
+    void setImageView(ImageView imageView) {
+        mImageView = imageView;
+    }
+
+    @Deprecated // for testing
+    Drawable getImageViewDrawable() {
+        return mImageView.getDrawable();
+    }
+
     @Deprecated // for testing
-    TextDrawable getImageViewDrawable() {
-        return (TextDrawable) mImageView.getDrawable();
+    void setImageViewDrawable(Drawable drawable) {
+        mImageView.setImageDrawable(drawable);
     }
 
     @Deprecated // for testing
-    void setImageViewDrawable(TextDrawable drawable) {
-        mImageView.setImageDrawable((Drawable) drawable);
+    String getTextViewText() {
+        return mTextView.getText().toString();
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastAbsoluteProgressTracker.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastAbsoluteProgressTracker.java
new file mode 100644
index 00000000..63fd8513
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastAbsoluteProgressTracker.java
@@ -0,0 +1,40 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+
+import java.io.Serializable;
+import java.util.Locale;
+
+/**
+ * A Vast tracking URL with an "absolute" trigger threshold. The tracker should be triggered
+ * after a fixed number of milliseconds have been played.
+ */
+public class VastAbsoluteProgressTracker extends VastTracker implements Comparable<VastAbsoluteProgressTracker>, Serializable {
+    private static final long serialVersionUID = 0L;
+    private final int mTrackingMilliseconds;
+
+    public VastAbsoluteProgressTracker(@NonNull final String trackingUrl, int trackingMilliseconds) {
+        super(trackingUrl);
+        Preconditions.checkArgument(trackingMilliseconds >= 0);
+        mTrackingMilliseconds = trackingMilliseconds;
+    }
+
+    public int getTrackingMilliseconds() {
+        return mTrackingMilliseconds;
+    }
+
+    @Override
+    public int compareTo(@NonNull final VastAbsoluteProgressTracker other) {
+        int you = other.getTrackingMilliseconds();
+        int me = getTrackingMilliseconds();
+
+        return me - you;
+    }
+
+    @Override
+    public String toString() {
+        return String.format(Locale.US, "%dms: %s", mTrackingMilliseconds, mTrackingUrl);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastFractionalProgressTracker.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastFractionalProgressTracker.java
new file mode 100644
index 00000000..824f9516
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastFractionalProgressTracker.java
@@ -0,0 +1,40 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+
+import java.io.Serializable;
+import java.util.Locale;
+
+/**
+ * A Vast tracking URL with a "fractional" tracking threshold on the interval [0.0, 1.0].
+ * The tracker should be triggered after the given fraction of the video has been played.
+ */
+public class VastFractionalProgressTracker extends VastTracker implements Comparable<VastFractionalProgressTracker>, Serializable {
+    private static final long serialVersionUID = 0L;
+    private final float mFraction;
+
+    public VastFractionalProgressTracker(@NonNull final String trackingUrl, float trackingFraction) {
+        super(trackingUrl);
+        Preconditions.checkArgument(trackingFraction >= 0);
+        mFraction = trackingFraction;
+    }
+
+    public float trackingFraction() {
+        return mFraction;
+    }
+
+    @Override
+    public int compareTo(@NonNull final VastFractionalProgressTracker other) {
+        float you = other.trackingFraction();
+        float me = trackingFraction();
+
+        return Double.compare(me, you);
+    }
+
+    @Override
+    public String toString() {
+        return String.format(Locale.US, "%2f: %s", mFraction, mTrackingUrl);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastTracker.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastTracker.java
new file mode 100644
index 00000000..36f07711
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastTracker.java
@@ -0,0 +1,35 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+
+import java.io.Serializable;
+
+/**
+ * State encapsulation for VAST tracking URLs that should only be called once. For example, progress
+ * trackers are only called once.
+ */
+public class VastTracker implements Serializable {
+    private static final long serialVersionUID = 0L;
+    @NonNull protected final String mTrackingUrl;
+    private boolean mCalled;
+
+    public VastTracker(@NonNull String trackingUrl) {
+        Preconditions.checkNotNull(trackingUrl);
+        mTrackingUrl = trackingUrl;
+    }
+
+    @NonNull
+    public String getTrackingUrl() {
+        return mTrackingUrl;
+    }
+
+    public void setTracked() {
+        mCalled = true;
+    }
+
+    public boolean isTracked() {
+        return mCalled;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoDownloadTask.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoDownloadTask.java
index 778d7de1..9077525a 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoDownloadTask.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoDownloadTask.java
@@ -37,7 +37,7 @@ protected Boolean doInBackground(final String... params) {
         AndroidHttpClient httpClient = null;
         try {
             httpClient = HttpClient.getHttpClient();
-            final HttpGet httpget = new HttpGet(videoUrl);
+            final HttpGet httpget = HttpClient.initializeHttpGet(videoUrl);
             final HttpResponse response = httpClient.execute(httpget);
 
             if (response == null || response.getEntity() == null) {
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoInterstitial.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoInterstitial.java
index b96d0f89..3ca5a8d3 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoInterstitial.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoInterstitial.java
@@ -1,8 +1,7 @@
 package com.mopub.mobileads;
 
-import android.net.Uri;
-
 import com.mopub.common.CacheService;
+import com.mopub.common.DataKeys;
 import com.mopub.mobileads.factories.VastManagerFactory;
 import com.mopub.mobileads.util.vast.VastManager;
 import com.mopub.mobileads.util.vast.VastVideoConfiguration;
@@ -17,7 +16,7 @@
 
     @Override
     protected void extractExtras(Map<String, String> serverExtras) {
-        mVastResponse = Uri.decode(serverExtras.get(AdFetcher.HTML_RESPONSE_BODY_KEY));
+        mVastResponse = serverExtras.get(DataKeys.HTML_RESPONSE_BODY_KEY);
     }
 
     @Override
@@ -34,12 +33,12 @@ protected void preRenderHtml(CustomEventInterstitialListener customEventIntersti
     }
 
     @Override
-    protected void showInterstitial() {
-        MraidVideoPlayerActivity.startVast(mContext, mVastVideoConfiguration, mAdConfiguration);
+    public void showInterstitial() {
+        MraidVideoPlayerActivity.startVast(mContext, mVastVideoConfiguration, mBroadcastIdentifier);
     }
 
     @Override
-    protected void onInvalidate() {
+    public void onInvalidate() {
         if (mVastManager != null) {
             mVastManager.cancel();
         }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoToolbar.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoToolbar.java
index 2d4431bf..cb89e081 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoToolbar.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoToolbar.java
@@ -6,6 +6,7 @@
 import android.widget.LinearLayout;
 import android.widget.RelativeLayout;
 
+import com.mopub.common.VisibleForTesting;
 import com.mopub.common.util.Dips;
 import com.mopub.common.util.Utils;
 import com.mopub.mobileads.resource.CloseButtonDrawable;
@@ -16,7 +17,7 @@
 import static android.view.Gravity.CENTER_VERTICAL;
 import static android.view.Gravity.LEFT;
 import static android.view.Gravity.RIGHT;
-import static android.view.ViewGroup.LayoutParams.FILL_PARENT;
+import static android.view.ViewGroup.LayoutParams.MATCH_PARENT;
 
 class VastVideoToolbar extends LinearLayout {
     private static final int TOOLBAR_HEIGHT_DIPS = 44;
@@ -42,7 +43,7 @@ public boolean onTouch(View view, MotionEvent motionEvent) {
 
         final int videoToolbarHeight = Dips.dipsToIntPixels(TOOLBAR_HEIGHT_DIPS, getContext());
         final LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(
-                FILL_PARENT,
+                MATCH_PARENT,
                 videoToolbarHeight);
         setLayoutParams(layoutParams);
 
@@ -60,25 +61,59 @@ public boolean onTouch(View view, MotionEvent motionEvent) {
         addView(mCloseButtonWidget);
     }
 
-    String getDisplaySeconds(final long millisecondsRemaining) {
-        return String.valueOf(Math.round(Math.ceil(millisecondsRemaining / 1000f)));
+    /**
+     * Rounds up to the nearest full second. Formally, this is the long
+     * closest to negative infinity above or equal to millis, in milliseconds,
+     * converted to seconds.
+     *
+     * @param millis Time in milliseconds
+     * @return Time in seconds, rounded up.
+     */
+    @VisibleForTesting
+    long convertMillisecondsToSecondsRoundedUp(final long millis) {
+        return Math.round(Math.ceil(millis / 1000f));
     }
 
+    @VisibleForTesting
     void updateDurationWidget(final int remainingTime) {
         if (remainingTime >= THRESHOLD_FOR_HIDING_VIDEO_DURATION) {
-            mDurationWidget.updateText("Ends in " + getDisplaySeconds(remainingTime) + " seconds");
+            mDurationWidget.updateText("Ends in " + formatTime(remainingTime));
         } else if (remainingTime >= 0) {
             mDurationWidget.updateText("Thanks for watching");
         }
     }
 
+    @VisibleForTesting
+    String formatTime(final long milliseconds) {
+        final long seconds = convertMillisecondsToSecondsRoundedUp(milliseconds);
+
+        if (seconds == 1) {
+            return "1 second";
+        } else {
+            return String.valueOf(seconds) + " seconds";
+        }
+    }
+
     void updateCountdownWidget(final int remainingTime) {
         if (remainingTime >= 0 && mCountdownWidget.getVisibility() == View.INVISIBLE) {
             mCloseButtonWidget.setVisibility(View.GONE);
             mCountdownWidget.setVisibility(View.VISIBLE);
         }
 
-        mCountdownWidget.updateImageText(getDisplaySeconds(remainingTime));
+        mCountdownWidget.updateImageText(String.valueOf(convertMillisecondsToSecondsRoundedUp(
+                remainingTime)));
+    }
+
+    void updateLearnMoreButtonText(final String customCtaText) {
+        mLearnMoreWidget.updateText(customCtaText);
+    }
+
+    void updateCloseButtonText(final String customSkipText) {
+        mCloseButtonWidget.updateText(customSkipText);
+    }
+
+    void updateCloseButtonIcon(final String customCloseIconUrl) {
+        mCloseButtonWidget.updateImage(customCloseIconUrl);
     }
 
     void makeInteractable() {
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewController.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewController.java
index c73582b5..da130670 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewController.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoViewController.java
@@ -11,49 +11,62 @@
 import android.media.MediaPlayer;
 import android.os.Bundle;
 import android.os.Handler;
+import android.support.annotation.NonNull;
+import android.text.TextUtils;
 import android.view.Gravity;
 import android.view.MotionEvent;
 import android.view.View;
 import android.widget.ImageView;
 import android.widget.RelativeLayout;
 import android.widget.VideoView;
+
 import com.mopub.common.DownloadResponse;
 import com.mopub.common.DownloadTask;
 import com.mopub.common.HttpResponses;
 import com.mopub.common.MoPubBrowser;
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.event.BaseEvent;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.util.AsyncTasks;
 import com.mopub.common.util.Dips;
 import com.mopub.common.util.Drawables;
+import com.mopub.common.util.Intents;
 import com.mopub.common.util.Streams;
+import com.mopub.common.util.Strings;
 import com.mopub.common.util.VersionCode;
+import com.mopub.exceptions.IntentNotResolvableException;
+import com.mopub.exceptions.UrlParseException;
 import com.mopub.mobileads.util.vast.VastCompanionAd;
 import com.mopub.mobileads.util.vast.VastVideoConfiguration;
+import com.mopub.network.TrackingRequest;
+
 import org.apache.http.HttpStatus;
 import org.apache.http.client.methods.HttpGet;
 
-import java.io.*;
-import java.util.*;
-import java.util.concurrent.*;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
 
 import static android.content.pm.ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
+import static android.content.pm.ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
 import static com.mopub.common.HttpClient.initializeHttpGet;
-import static com.mopub.common.HttpClient.makeTrackingHttpRequest;
+import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_CLICK;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
+import static com.mopub.network.TrackingRequest.makeTrackingHttpRequest;
 
 public class VastVideoViewController extends BaseVideoViewController implements DownloadTask.DownloadTaskListener {
     static final String VAST_VIDEO_CONFIGURATION = "vast_video_configuration";
 
-    private static final float FIRST_QUARTER_MARKER = 0.25f;
-    private static final float MID_POINT_MARKER = 0.50f;
-    private static final float THIRD_QUARTER_MARKER = 0.75f;
     private static final long VIDEO_PROGRESS_TIMER_CHECKER_DELAY = 50;
     private static final int MOPUB_BROWSER_REQUEST_CODE = 1;
     private static final int MAX_VIDEO_RETRIES = 1;
     private static final int VIDEO_VIEW_FILE_PERMISSION_ERROR = Integer.MIN_VALUE;
 
-    private static final ThreadPoolExecutor sThreadPoolExecutor = new ThreadPoolExecutor(10, 50, 1, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
     static final int DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON = 5 * 1000;
     static final int MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON = 16 * 1000;
 
@@ -70,14 +83,16 @@
     private int mShowCloseButtonDelay = DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON;
 
     private boolean mShowCloseButtonEventFired;
-    private boolean mIsStartMarkHit;
-    private boolean mIsFirstMarkHit;
-    private boolean mIsSecondMarkHit;
-    private boolean mIsThirdMarkHit;
+
     private int mSeekerPositionOnPause;
     private boolean mIsVideoFinishedPlaying;
     private int mVideoRetries;
 
+    private boolean mVideoError;
+    private boolean mCompletionTrackerFired;
+
+    private boolean mHasSkipOffset = false;
+
     VastVideoViewController(final Context context,
             final Bundle bundle,
             final long broadcastIdentifier,
@@ -124,29 +139,45 @@ public boolean onTouch(View view, MotionEvent motionEvent) {
         getLayout().addView(mVastVideoToolbar);
 
         mCompanionAdImageView = createCompanionAdImageView(context);
-
-        makeTrackingHttpRequest(mVastVideoConfiguration.getImpressionTrackers(), context);
-
         mVideoProgressCheckerRunnable = createVideoProgressCheckerRunnable();
     }
 
     @Override
-    VideoView getVideoView() {
+    protected VideoView getVideoView() {
         return mVideoView;
     }
 
     @Override
-    void onCreate() {
+    protected void onCreate() {
         super.onCreate();
-        getBaseVideoViewControllerListener().onSetRequestedOrientation(SCREEN_ORIENTATION_LANDSCAPE);
 
-        broadcastAction(ACTION_INTERSTITIAL_SHOW);
+        switch (mVastVideoConfiguration.getCustomForceOrientation()) {
+            case FORCE_PORTRAIT:
+                getBaseVideoViewControllerListener().onSetRequestedOrientation(SCREEN_ORIENTATION_PORTRAIT);
+                break;
+            case FORCE_LANDSCAPE:
+                getBaseVideoViewControllerListener().onSetRequestedOrientation(SCREEN_ORIENTATION_LANDSCAPE);
+                break;
+            case DEVICE_ORIENTATION:
+                break;  // don't do anything
+            case UNDEFINED:
+                break;  // don't do anything
+            default:
+                break;
+        }
 
         downloadCompanionAd();
+
+        makeTrackingHttpRequest(
+                mVastVideoConfiguration.getImpressionTrackers(),
+                getContext(),
+                BaseEvent.Name.IMPRESSION_REQUEST
+        );
+        broadcastAction(ACTION_INTERSTITIAL_SHOW);
     }
 
     @Override
-    void onResume() {
+    protected void onResume() {
         // When resuming, VideoView needs to reinitialize its MediaPlayer with the video path
         // and therefore reset the count to zero, to let it retry on error
         mVideoRetries = 0;
@@ -159,21 +190,21 @@ void onResume() {
     }
 
     @Override
-    void onPause() {
+    protected void onPause() {
         stopProgressChecker();
         mSeekerPositionOnPause = mVideoView.getCurrentPosition();
         mVideoView.pause();
     }
 
     @Override
-    void onDestroy() {
+    protected void onDestroy() {
         stopProgressChecker();
         broadcastAction(ACTION_INTERSTITIAL_DISMISS);
     }
 
     // Enable the device's back button when the video close button has been displayed
     @Override
-    boolean backButtonEnabled() {
+    public boolean backButtonEnabled() {
         return mShowCloseButtonEventFired;
     }
 
@@ -227,37 +258,67 @@ private void downloadCompanionAd() {
         }
     }
 
-    private Runnable createVideoProgressCheckerRunnable() {
-        return new Runnable() {
-            @Override
-            public void run() {
-                float videoLength = mVideoView.getDuration();
-                float currentPosition = mVideoView.getCurrentPosition();
+    private void adjustSkipOffset() {
+        int videoDuration = mVideoView.getDuration();
 
-                if (videoLength > 0) {
-                    float progressPercentage = currentPosition / videoLength;
+        // Default behavior: video is non-skippable if duration < 16 seconds
+        if (videoDuration < MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON) {
+            mShowCloseButtonDelay = videoDuration;
+        }
 
-                    if (!mIsStartMarkHit && currentPosition >= 1000) {
-                        mIsStartMarkHit = true;
-                        makeTrackingHttpRequest(mVastVideoConfiguration.getStartTrackers(), getContext());
+        // Override if skipoffset attribute is specified in VAST
+        String skipOffsetString = mVastVideoConfiguration.getSkipOffset();
+        if (skipOffsetString != null) {
+            try {
+                if (Strings.isAbsoluteTracker(skipOffsetString)) {
+                    Integer skipOffsetMilliseconds = Strings.parseAbsoluteOffset(skipOffsetString);
+                    if (skipOffsetMilliseconds != null && skipOffsetMilliseconds < videoDuration) {
+                        mShowCloseButtonDelay = skipOffsetMilliseconds;
+                        mHasSkipOffset = true;
                     }
-
-                    if (!mIsFirstMarkHit && progressPercentage > FIRST_QUARTER_MARKER) {
-                        mIsFirstMarkHit = true;
-                        makeTrackingHttpRequest(mVastVideoConfiguration.getFirstQuartileTrackers(), getContext());
+                } else if (Strings.isPercentageTracker(skipOffsetString)) {
+                    float percentage = Float.parseFloat(skipOffsetString.replace("%", "")) / 100f;
+                    int skipOffsetMillisecondsRounded = Math.round(videoDuration * percentage);
+                    if (skipOffsetMillisecondsRounded < videoDuration) {
+                        mShowCloseButtonDelay = skipOffsetMillisecondsRounded;
+                        mHasSkipOffset = true;
                     }
+                } else {
+                    MoPubLog.d(String.format("Invalid VAST skipoffset format: %s", skipOffsetString));
+                }
+            } catch (NumberFormatException e) {
+                MoPubLog.d(String.format("Failed to parse skipoffset %s", skipOffsetString));
+            }
+        }
+    }
 
-                    if (!mIsSecondMarkHit && progressPercentage > MID_POINT_MARKER) {
-                        mIsSecondMarkHit = true;
-                        makeTrackingHttpRequest(mVastVideoConfiguration.getMidpointTrackers(), getContext());
-                    }
+    @NonNull
+    private Runnable createVideoProgressCheckerRunnable() {
+        // This Runnable must only be run from the main thread due to accessing
+        // class instance variables
+        return new Runnable() {
+            @Override
+            public void run() {
+                int videoLength = mVideoView.getDuration();
+                int currentPosition = mVideoView.getCurrentPosition();
 
-                    if (!mIsThirdMarkHit && progressPercentage > THIRD_QUARTER_MARKER) {
-                        mIsThirdMarkHit = true;
-                        makeTrackingHttpRequest(mVastVideoConfiguration.getThirdQuartileTrackers(), getContext());
+                if (videoLength > 0) {
+                    final List<VastTracker> trackersToTrack =
+                            getUntriggeredTrackersBefore(currentPosition, videoLength);
+                    if (!trackersToTrack.isEmpty()) {
+                        final List<String> trackUrls = new ArrayList<String>();
+                        for (VastTracker tracker : trackersToTrack) {
+                            trackUrls.add(tracker.getTrackingUrl());
+                            tracker.setTracked();
+                        }
+                        TrackingRequest.makeTrackingHttpRequest(trackUrls, getContext());
                     }
 
-                    if (isLongVideo(mVideoView.getDuration()) ) {
+                    // show countdown if any of the following conditions is satisfied:
+                    // 1) long video
+                    // 2) skipoffset is specified in VAST and is less than video duration
+                    if (isLongVideo(mVideoView.getDuration()) ||
+                            (mHasSkipOffset && mShowCloseButtonDelay < mVideoView.getDuration())) {
                         mVastVideoToolbar.updateCountdownWidget(mShowCloseButtonDelay - mVideoView.getCurrentPosition());
                     }
 
@@ -275,13 +336,61 @@ public void run() {
         };
     }
 
+    /**
+     * Returns untriggered VAST progress trackers with a progress before the provided position.
+     *
+     * @param currentPositionMillis the current video position in milliseconds.
+     * @param videoLengthMillis the total video length.
+     */
+    @NonNull
+    private List<VastTracker> getUntriggeredTrackersBefore(int currentPositionMillis, int videoLengthMillis) {
+        if (Preconditions.NoThrow.checkArgument(videoLengthMillis > 0)) {
+            float progressFraction = currentPositionMillis / (float) (videoLengthMillis);
+            List<VastTracker> untriggeredTrackers = new ArrayList<VastTracker>();
+
+            final ArrayList<VastAbsoluteProgressTracker> absoluteTrackers = mVastVideoConfiguration.getAbsoluteTrackers();
+            VastAbsoluteProgressTracker absoluteTest = new VastAbsoluteProgressTracker("", currentPositionMillis);
+            int absoluteTrackerCount = absoluteTrackers.size();
+            for (int i = 0; i < absoluteTrackerCount; i++) {
+                VastAbsoluteProgressTracker tracker = absoluteTrackers.get(i);
+                if (tracker.compareTo(absoluteTest) > 0) {
+                    break;
+                }
+                if (!tracker.isTracked()) {
+                    untriggeredTrackers.add(tracker);
+                }
+            }
+
+            final ArrayList<VastFractionalProgressTracker> fractionalTrackers = mVastVideoConfiguration.getFractionalTrackers();
+            final VastFractionalProgressTracker fractionalTest = new VastFractionalProgressTracker("", progressFraction);
+            int fractionalTrackerCount = fractionalTrackers.size();
+            for (int i = 0; i < fractionalTrackerCount; i++) {
+                VastFractionalProgressTracker tracker = fractionalTrackers.get(i);
+                if (tracker.compareTo(fractionalTest) > 0) {
+                    break;
+                }
+                if (!tracker.isTracked()) {
+                    untriggeredTrackers.add(tracker);
+                }
+            }
+
+            return untriggeredTrackers;
+        } else {
+            return Collections.emptyList();
+        }
+    }
+
+    private int remainingProgressTrackerCount() {
+        return getUntriggeredTrackersBefore(Integer.MAX_VALUE, Integer.MAX_VALUE).size();
+    }
+
     private void createVideoBackground(final Context context) {
         GradientDrawable gradientDrawable = new GradientDrawable(
                 GradientDrawable.Orientation.TOP_BOTTOM,
                 new int[] {Color.argb(0,0,0,0), Color.argb(255,0,0,0)}
         );
         Drawable[] layers = new Drawable[2];
-        layers[0] = Drawables.THATCHED_BACKGROUND.decodeImage(context);
+        layers[0] = Drawables.THATCHED_BACKGROUND.createDrawable(context);
         layers[1] = gradientDrawable;
         LayerDrawable layerList = new LayerDrawable(layers);
         getLayout().setBackgroundDrawable(layerList);
@@ -293,12 +402,35 @@ private VastVideoToolbar createVastVideoToolBar(final Context context) {
             @Override
             public boolean onTouch(View view, MotionEvent motionEvent) {
                 if (motionEvent.getAction() == MotionEvent.ACTION_UP) {
+                    TrackingRequest.makeTrackingHttpRequest(
+                            mVastVideoConfiguration.getCloseTrackers(), context);
+                    TrackingRequest.makeTrackingHttpRequest(
+                            mVastVideoConfiguration.getSkipTrackers(), context);
                     getBaseVideoViewControllerListener().onFinish();
                 }
                 return true;
             }
         });
         vastVideoToolbar.setLearnMoreButtonOnTouchListener(mClickThroughListener);
+
+        // update custom CTA text if specified in VAST extension
+        String customCtaText = mVastVideoConfiguration.getCustomCtaText();
+        if (customCtaText != null) {
+            vastVideoToolbar.updateLearnMoreButtonText(customCtaText);
+        }
+
+        // update custom skip text if specified in VAST extensions
+        String customSkipText = mVastVideoConfiguration.getCustomSkipText();
+        if (customSkipText != null) {
+            vastVideoToolbar.updateCloseButtonText(customSkipText);
+        }
+
+        // update custom close icon if specified in VAST extensions
+        String customCloseIconUrl = mVastVideoConfiguration.getCustomCloseIconUrl();
+        if (customCloseIconUrl != null) {
+            vastVideoToolbar.updateCloseButtonIcon(customCloseIconUrl);
+        }
+
         return vastVideoToolbar;
     }
 
@@ -307,9 +439,8 @@ private VideoView createVideoView(final Context context) {
         videoView.setOnPreparedListener(new MediaPlayer.OnPreparedListener() {
             @Override
             public void onPrepared(MediaPlayer mp) {
-                if (mVideoView.getDuration() < MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON) {
-                    mShowCloseButtonDelay = mVideoView.getDuration();
-                }
+                // Called when media source is ready for playback
+                adjustSkipOffset();
             }
         });
         videoView.setOnTouchListener(mClickThroughListener);
@@ -321,10 +452,15 @@ public void onCompletion(MediaPlayer mp) {
                 makeVideoInteractable();
 
                 videoCompleted(false);
-
-                makeTrackingHttpRequest(mVastVideoConfiguration.getCompleteTrackers(), context);
                 mIsVideoFinishedPlaying = true;
 
+                // Only fire the completion tracker if we hit all the progress marks. Some Android implementations
+                // fire the completion event even if the whole video isn't watched.
+                if (!mVideoError && remainingProgressTrackerCount() == 0 && !mCompletionTrackerFired) {
+                    makeTrackingHttpRequest(mVastVideoConfiguration.getCompleteTrackers(), context);
+                    mCompletionTrackerFired = true;
+                }
+
                 videoView.setVisibility(View.GONE);
                 // check the drawable to see if the image view was populated with content
                 if (mCompanionAdImageView.getDrawable() != null) {
@@ -342,6 +478,7 @@ public boolean onError(final MediaPlayer mediaPlayer, final int what, final int
                     stopProgressChecker();
                     makeVideoInteractable();
                     videoError(false);
+                    mVideoError = true;
                     return false;
                 }
             }
@@ -389,6 +526,52 @@ boolean retryMediaPlayer(final MediaPlayer mediaPlayer, final int what, final in
         return false;
     }
 
+    /**
+     * Called upon user click. Attempts open mopubnativebrowser links in the device browser and all
+     * other links in the MoPub in-app browser.
+     */
+    @VisibleForTesting
+    void handleClick(final List<String> clickThroughTrackers, final String clickThroughUrl) {
+        makeTrackingHttpRequest(clickThroughTrackers, getContext(), BaseEvent.Name.CLICK_REQUEST);
+
+        if (TextUtils.isEmpty(clickThroughUrl)) {
+            return;
+        }
+
+        broadcastAction(ACTION_INTERSTITIAL_CLICK);
+
+        if (Intents.isAboutScheme(clickThroughUrl)) {
+            MoPubLog.d("Link to about page ignored.");
+            return;
+        }
+
+        if (Intents.isNativeBrowserScheme(clickThroughUrl)) {
+            try {
+                final Intent intent = Intents.intentForNativeBrowserScheme(clickThroughUrl);
+                Intents.startActivity(getContext(), intent);
+                return;
+            } catch (UrlParseException e) {
+                MoPubLog.d(e.getMessage());
+            } catch (IntentNotResolvableException e) {
+                MoPubLog.d("Could not handle intent for URI: " + clickThroughUrl + ". "
+                        + e.getMessage());
+            }
+
+            return;
+        }
+
+        if (Intents.isHttpUrl(clickThroughUrl)) {
+            Bundle bundle = new Bundle();
+            bundle.putString(MoPubBrowser.DESTINATION_URL_KEY, clickThroughUrl);
+
+            getBaseVideoViewControllerListener().onStartActivityForResult(MoPubBrowser.class,
+                    MOPUB_BROWSER_REQUEST_CODE, bundle);
+            return;
+        }
+
+        MoPubLog.d("Link ignored. Unable to handle url: " + clickThroughUrl);
+    }
+
     private ImageView createCompanionAdImageView(final Context context) {
         RelativeLayout relativeLayout = new RelativeLayout(context);
         relativeLayout.setGravity(Gravity.CENTER);
@@ -412,18 +595,6 @@ private ImageView createCompanionAdImageView(final Context context) {
         return imageView;
     }
 
-    private void handleClick(final List<String> clickThroughTrackers, final String clickThroughUrl) {
-        makeTrackingHttpRequest(clickThroughTrackers, getContext());
-
-        videoClicked();
-
-        Bundle bundle = new Bundle();
-        bundle.putString(MoPubBrowser.DESTINATION_URL_KEY, clickThroughUrl);
-
-        getBaseVideoViewControllerListener().onStartActivityForResult(MoPubBrowser.class,
-                MOPUB_BROWSER_REQUEST_CODE, bundle);
-    }
-
     private boolean isLongVideo(final int duration) {
         return (duration >= MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON);
     }
@@ -434,7 +605,7 @@ private void makeVideoInteractable() {
     }
 
     private boolean shouldBeInteractable() {
-        return !mShowCloseButtonEventFired && mVideoView.getCurrentPosition() > mShowCloseButtonDelay;
+        return !mShowCloseButtonEventFired && mVideoView.getCurrentPosition() >= mShowCloseButtonDelay;
     }
 
     private boolean shouldAllowClickThrough() {
@@ -457,49 +628,71 @@ private void stopProgressChecker() {
 
     // for testing
     @Deprecated
+    @VisibleForTesting
     boolean getIsVideoProgressShouldBeChecked() {
         return mIsVideoProgressShouldBeChecked;
     }
 
     // for testing
     @Deprecated
+    @VisibleForTesting
     int getVideoRetries() {
         return mVideoRetries;
     }
 
     // for testing
     @Deprecated
-    Runnable getVideoProgressCheckerRunnable() {
-        return mVideoProgressCheckerRunnable;
+    @VisibleForTesting
+    boolean getHasSkipOffset() {
+        return mHasSkipOffset;
     }
 
     // for testing
     @Deprecated
+    @VisibleForTesting
     int getShowCloseButtonDelay() {
         return mShowCloseButtonDelay;
     }
 
     // for testing
     @Deprecated
+    @VisibleForTesting
     boolean isShowCloseButtonEventFired() {
         return mShowCloseButtonEventFired;
     }
 
     // for testing
     @Deprecated
+    @VisibleForTesting
     void setCloseButtonVisible(boolean visible) {
         mShowCloseButtonEventFired = visible;
     }
 
     // for testing
     @Deprecated
+    @VisibleForTesting
     boolean isVideoFinishedPlaying() {
         return mIsVideoFinishedPlaying;
     }
 
     // for testing
     @Deprecated
+    @VisibleForTesting
     ImageView getCompanionAdImageView() {
         return mCompanionAdImageView;
     }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    void setVideoError() {
+        mVideoError = true;
+    }
+
+    // for testing
+    @Deprecated
+    @VisibleForTesting
+    boolean getVideoError() {
+        return mVideoError;
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/ViewGestureDetector.java b/mopub-sdk/src/main/java/com/mopub/mobileads/ViewGestureDetector.java
index bb9a23df..cdb92180 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/ViewGestureDetector.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/ViewGestureDetector.java
@@ -1,16 +1,19 @@
 package com.mopub.mobileads;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.GestureDetector;
 import android.view.MotionEvent;
 import android.view.View;
 
+import com.mopub.common.AdReport;
 import com.mopub.common.logging.MoPubLog;
 
 public class ViewGestureDetector extends GestureDetector {
     private final View mView;
 
-    interface UserClickListener {
+    public interface UserClickListener {
         void onUserClick();
         void onResetUserClick();
         boolean wasClicked();
@@ -19,8 +22,8 @@
     private AdAlertGestureListener mAdAlertGestureListener;
     private UserClickListener mUserClickListener;
 
-    public ViewGestureDetector(Context context, View view, AdConfiguration adConfiguration)  {
-        this(context, view, new AdAlertGestureListener(view, adConfiguration));
+    public ViewGestureDetector(@NonNull Context context, @NonNull View view, @Nullable AdReport adReport)  {
+        this(context, view, new AdAlertGestureListener(view, adReport));
     }
 
     private ViewGestureDetector(Context context, View view, AdAlertGestureListener adAlertGestureListener) {
@@ -32,7 +35,7 @@ private ViewGestureDetector(Context context, View view, AdAlertGestureListener a
         setIsLongpressEnabled(false);
     }
 
-    void sendTouchEvent(MotionEvent motionEvent) {
+    public void sendTouchEvent(MotionEvent motionEvent) {
         switch (motionEvent.getAction()) {
             case MotionEvent.ACTION_UP:
                 if (mUserClickListener != null) {
@@ -60,7 +63,7 @@ void sendTouchEvent(MotionEvent motionEvent) {
         }
     }
 
-    void setUserClickListener(UserClickListener listener) {
+    public void setUserClickListener(UserClickListener listener) {
         mUserClickListener = listener;
     }
 
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/WebViewAdUrlGenerator.java b/mopub-sdk/src/main/java/com/mopub/mobileads/WebViewAdUrlGenerator.java
index e4d92329..975b69cb 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/WebViewAdUrlGenerator.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/WebViewAdUrlGenerator.java
@@ -1,84 +1,32 @@
 package com.mopub.mobileads;
 
 import android.content.Context;
-import android.location.Location;
 
 import com.mopub.common.AdUrlGenerator;
 import com.mopub.common.ClientMetadata;
-import com.mopub.common.LocationService;
-import com.mopub.common.MoPub;
-import com.mopub.common.util.DateAndTime;
-
-import static com.mopub.mobileads.util.Mraids.isStorePictureSupported;
+import com.mopub.common.Constants;
 
 public class WebViewAdUrlGenerator extends AdUrlGenerator {
-    public WebViewAdUrlGenerator(Context context) {
+    private final boolean mIsStorePictureSupported;
+
+    public WebViewAdUrlGenerator(Context context, boolean isStorePictureSupported) {
         super(context);
+        mIsStorePictureSupported = isStorePictureSupported;
     }
 
     @Override
     public String generateUrlString(String serverHostname) {
-        initUrlString(serverHostname, MoPubView.AD_HANDLER);
-
-        final ClientMetadata clientMetadata = ClientMetadata.getInstance(mContext);
+        initUrlString(serverHostname, Constants.AD_HANDLER);
 
         setApiVersion("6");
 
-        setAdUnitId(mAdUnitId);
-
-        setSdkVersion(clientMetadata.getSdkVersion());
-
-        setDeviceInfo(clientMetadata.getDeviceManufacturer(),
-                clientMetadata.getDeviceModel(),
-                clientMetadata.getDeviceProduct());
-
-        setUdid(clientMetadata.getAdvertisingId());
-
-        setDoNotTrack(clientMetadata.isDoNotTrackSet());
-
-        setKeywords(mKeywords);
-
-        Location location = mLocation;
-        if (location == null) {
-            location = LocationService.getLastKnownLocation(mContext,
-                    MoPub.getLocationPrecision(),
-                    MoPub.getLocationAwareness());
-        }
-        setLocation(location);
-
-        setTimezone(DateAndTime.getTimeZoneOffsetString());
-
-        setOrientation(clientMetadata.getOrientationString());
-
-        setDensity(clientMetadata.getDensity());
-
-        setMraidFlag(detectIsMraidSupported());
-
-        String networkOperator = clientMetadata.getNetworkOperator();
-        setMccCode(networkOperator);
-        setMncCode(networkOperator);
-
-        setIsoCountryCode(clientMetadata.getIsoCountryCode());
-        setCarrierName(clientMetadata.getNetworkOperatorName());
-
-        setNetworkType(clientMetadata.getActiveNetworkType());
-
-        setAppVersion(clientMetadata.getAppVersion());
+        final ClientMetadata clientMetadata = ClientMetadata.getInstance(mContext);
+        addBaseParams(clientMetadata);
 
-        setExternalStoragePermission(isStorePictureSupported(mContext));
+        setMraidFlag(true);
 
-        setTwitterAppInstalledFlag();
+        setExternalStoragePermission(mIsStorePictureSupported);
 
         return getFinalUrlString();
     }
-
-    private boolean detectIsMraidSupported() {
-        boolean mraid = true;
-        try {
-            Class.forName("com.mopub.mobileads.MraidView");
-        } catch (ClassNotFoundException e) {
-            mraid = false;
-        }
-        return mraid;
-    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/AdFetchTaskFactory.java b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/AdFetchTaskFactory.java
deleted file mode 100644
index 23c463be..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/AdFetchTaskFactory.java
+++ /dev/null
@@ -1,22 +0,0 @@
-package com.mopub.mobileads.factories;
-
-import com.mopub.mobileads.AdFetchTask;
-import com.mopub.mobileads.AdViewController;
-import com.mopub.mobileads.TaskTracker;
-
-public class AdFetchTaskFactory {
-    protected static AdFetchTaskFactory instance = new AdFetchTaskFactory();
-
-    @Deprecated // for testing
-    public static void setInstance(AdFetchTaskFactory factory) {
-        instance = factory;
-    }
-
-    public static AdFetchTask create(TaskTracker taskTracker, AdViewController adViewController, String userAgent, int timeoutMilliseconds) {
-        return instance.internalCreate(taskTracker, adViewController, userAgent, timeoutMilliseconds);
-    }
-
-    protected AdFetchTask internalCreate(TaskTracker taskTracker, AdViewController adViewController, String userAgent, int timeoutMilliseconds) {
-        return new AdFetchTask(taskTracker, adViewController, userAgent, timeoutMilliseconds);
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/AdFetcherFactory.java b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/AdFetcherFactory.java
deleted file mode 100644
index 7490ced8..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/AdFetcherFactory.java
+++ /dev/null
@@ -1,21 +0,0 @@
-package com.mopub.mobileads.factories;
-
-import com.mopub.mobileads.AdFetcher;
-import com.mopub.mobileads.AdViewController;
-
-public class AdFetcherFactory {
-    protected static AdFetcherFactory instance = new AdFetcherFactory();
-
-    @Deprecated // for testing
-    public static void setInstance(AdFetcherFactory factory) {
-        instance = factory;
-    }
-
-    public static AdFetcher create(AdViewController adViewController, String userAgent) {
-        return instance.internalCreate(adViewController, userAgent);
-    }
-
-    protected AdFetcher internalCreate(AdViewController adViewController, String userAgent) {
-        return new AdFetcher(adViewController, userAgent);
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/CustomEventBannerAdapterFactory.java b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/CustomEventBannerAdapterFactory.java
index bf363e57..d6a53767 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/CustomEventBannerAdapterFactory.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/CustomEventBannerAdapterFactory.java
@@ -1,8 +1,13 @@
 package com.mopub.mobileads.factories;
 
+import android.support.annotation.NonNull;
+
+import com.mopub.common.AdReport;
 import com.mopub.mobileads.CustomEventBannerAdapter;
 import com.mopub.mobileads.MoPubView;
 
+import java.util.Map;
+
 public class CustomEventBannerAdapterFactory {
     protected static CustomEventBannerAdapterFactory instance = new CustomEventBannerAdapterFactory();
 
@@ -11,11 +16,19 @@ public static void setInstance(CustomEventBannerAdapterFactory factory) {
         instance = factory;
     }
 
-    public static CustomEventBannerAdapter create(MoPubView moPubView, String className, String classData) {
-        return instance.internalCreate(moPubView, className, classData);
+    public static CustomEventBannerAdapter create(@NonNull MoPubView moPubView,
+            @NonNull String className,
+            @NonNull Map<String, String> serverExtras,
+            long broadcastIdentifier,
+            @NonNull AdReport adReport) {
+        return instance.internalCreate(moPubView, className, serverExtras, broadcastIdentifier, adReport);
     }
 
-    protected CustomEventBannerAdapter internalCreate(MoPubView moPubView, String className, String classData) {
-        return new CustomEventBannerAdapter(moPubView, className, classData);
+    protected CustomEventBannerAdapter internalCreate(@NonNull MoPubView moPubView,
+            @NonNull String className,
+            @NonNull Map<String, String> serverExtras,
+            long broadcastIdentifier,
+            @NonNull AdReport adReport) {
+        return new CustomEventBannerAdapter(moPubView, className, serverExtras, broadcastIdentifier, adReport);
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/CustomEventInterstitialAdapterFactory.java b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/CustomEventInterstitialAdapterFactory.java
index f6534dda..e7042f5c 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/CustomEventInterstitialAdapterFactory.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/CustomEventInterstitialAdapterFactory.java
@@ -1,8 +1,11 @@
 package com.mopub.mobileads.factories;
 
+import com.mopub.common.AdReport;
 import com.mopub.mobileads.CustomEventInterstitialAdapter;
 import com.mopub.mobileads.MoPubInterstitial;
 
+import java.util.Map;
+
 public class CustomEventInterstitialAdapterFactory {
     protected static CustomEventInterstitialAdapterFactory instance = new CustomEventInterstitialAdapterFactory();
 
@@ -11,11 +14,11 @@ public static void setInstance(CustomEventInterstitialAdapterFactory factory) {
         instance = factory;
     }
 
-    public static CustomEventInterstitialAdapter create(MoPubInterstitial moPubInterstitial, String className, String classData) {
-        return instance.internalCreate(moPubInterstitial, className, classData);
+    public static CustomEventInterstitialAdapter create(MoPubInterstitial moPubInterstitial, String className, Map<String, String> serverExtras, long broadcastIdentifier, AdReport adReport) {
+        return instance.internalCreate(moPubInterstitial, className, serverExtras, broadcastIdentifier, adReport);
     }
 
-    protected CustomEventInterstitialAdapter internalCreate(MoPubInterstitial moPubInterstitial, String className, String classData) {
-        return new CustomEventInterstitialAdapter(moPubInterstitial, className, classData);
+    protected CustomEventInterstitialAdapter internalCreate(MoPubInterstitial moPubInterstitial, String className, Map<String, String> serverExtras, long broadcastIdentifier, AdReport adReport) {
+        return new CustomEventInterstitialAdapter(moPubInterstitial, className, serverExtras, broadcastIdentifier, adReport);
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/HtmlBannerWebViewFactory.java b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/HtmlBannerWebViewFactory.java
index e7d300b1..59b9544d 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/HtmlBannerWebViewFactory.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/HtmlBannerWebViewFactory.java
@@ -2,7 +2,7 @@
 
 import android.content.Context;
 
-import com.mopub.mobileads.AdConfiguration;
+import com.mopub.common.AdReport;
 import com.mopub.mobileads.HtmlBannerWebView;
 
 import static com.mopub.mobileads.CustomEventBanner.CustomEventBannerListener;
@@ -12,22 +12,22 @@
 
     public static HtmlBannerWebView create(
             Context context,
+            AdReport adReport,
             CustomEventBannerListener customEventBannerListener,
             boolean isScrollable,
             String redirectUrl,
-            String clickthroughUrl,
-            AdConfiguration adConfiguration) {
-        return instance.internalCreate(context, customEventBannerListener, isScrollable, redirectUrl, clickthroughUrl, adConfiguration);
+            String clickthroughUrl) {
+        return instance.internalCreate(context, adReport, customEventBannerListener, isScrollable, redirectUrl, clickthroughUrl);
     }
 
     public HtmlBannerWebView internalCreate(
             Context context,
+            AdReport adReport,
             CustomEventBannerListener customEventBannerListener,
             boolean isScrollable,
             String redirectUrl,
-            String clickthroughUrl,
-            AdConfiguration adConfiguration) {
-        HtmlBannerWebView htmlBannerWebView = new HtmlBannerWebView(context, adConfiguration);
+            String clickthroughUrl) {
+        HtmlBannerWebView htmlBannerWebView = new HtmlBannerWebView(context, adReport);
         htmlBannerWebView.init(customEventBannerListener, isScrollable, redirectUrl, clickthroughUrl);
         return htmlBannerWebView;
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/HtmlInterstitialWebViewFactory.java b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/HtmlInterstitialWebViewFactory.java
index ab8c4490..65d97a39 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/HtmlInterstitialWebViewFactory.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/HtmlInterstitialWebViewFactory.java
@@ -2,7 +2,7 @@
 
 import android.content.Context;
 
-import com.mopub.mobileads.AdConfiguration;
+import com.mopub.common.AdReport;
 import com.mopub.mobileads.HtmlInterstitialWebView;
 
 import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
@@ -12,22 +12,22 @@
 
     public static HtmlInterstitialWebView create(
             Context context,
+            AdReport adReport,
             CustomEventInterstitialListener customEventInterstitialListener,
             boolean isScrollable,
             String redirectUrl,
-            String clickthroughUrl,
-            AdConfiguration adConfiguration) {
-        return instance.internalCreate(context, customEventInterstitialListener, isScrollable, redirectUrl, clickthroughUrl, adConfiguration);
+            String clickthroughUrl) {
+        return instance.internalCreate(context, adReport, customEventInterstitialListener, isScrollable, redirectUrl, clickthroughUrl);
     }
 
     public HtmlInterstitialWebView internalCreate(
             Context context,
+            AdReport adReport,
             CustomEventInterstitialListener customEventInterstitialListener,
             boolean isScrollable,
             String redirectUrl,
-            String clickthroughUrl,
-            AdConfiguration adConfiguration) {
-        HtmlInterstitialWebView htmlInterstitialWebView = new HtmlInterstitialWebView(context, adConfiguration);
+            String clickthroughUrl) {
+        HtmlInterstitialWebView htmlInterstitialWebView = new HtmlInterstitialWebView(context, adReport);
         htmlInterstitialWebView.init(customEventInterstitialListener, isScrollable, redirectUrl, clickthroughUrl);
         return htmlInterstitialWebView;
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/MraidControllerFactory.java b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/MraidControllerFactory.java
new file mode 100644
index 00000000..50c5391e
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/MraidControllerFactory.java
@@ -0,0 +1,30 @@
+package com.mopub.mobileads.factories;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.AdReport;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.mraid.MraidController;
+import com.mopub.mraid.PlacementType;
+
+public class MraidControllerFactory {
+    protected static MraidControllerFactory instance = new MraidControllerFactory();
+
+    @VisibleForTesting
+    public static void setInstance(MraidControllerFactory factory) {
+        instance = factory;
+    }
+
+    public static MraidController create(@NonNull final Context context, 
+            @NonNull final AdReport adReport, 
+            @NonNull final PlacementType placementType) {
+        return instance.internalCreate(context, adReport, placementType);
+    }
+
+    protected MraidController internalCreate(@NonNull final Context context, 
+            @NonNull final AdReport adReport, 
+            @NonNull final PlacementType placementType) {
+        return new MraidController(context, adReport, placementType);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/MraidViewFactory.java b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/MraidViewFactory.java
deleted file mode 100644
index a139babf..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/MraidViewFactory.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package com.mopub.mobileads.factories;
-
-import android.content.Context;
-
-import com.mopub.mobileads.AdConfiguration;
-import com.mopub.mobileads.MraidView;
-import com.mopub.mobileads.MraidView.NativeCloseButtonStyle;
-
-public class MraidViewFactory {
-    protected static MraidViewFactory instance = new MraidViewFactory();
-
-    @Deprecated // for testing
-    public static void setInstance(MraidViewFactory factory) {
-        instance = factory;
-    }
-
-    public static MraidView create(Context context, AdConfiguration adConfiguration) {
-        return instance.internalCreate(context, adConfiguration);
-    }
-
-    public static MraidView create(
-            Context context,
-            AdConfiguration adConfiguration,
-            MraidView.ExpansionStyle expansionStyle,
-            NativeCloseButtonStyle buttonStyle,
-            MraidView.PlacementType placementType) {
-        return instance.internalCreate(context, adConfiguration, expansionStyle, buttonStyle, placementType);
-    }
-
-    protected MraidView internalCreate(Context context, AdConfiguration adConfiguration) {
-        return new MraidView(context, adConfiguration);
-    }
-
-    protected MraidView internalCreate(
-            Context context,
-            AdConfiguration adConfiguration,
-            MraidView.ExpansionStyle expansionStyle,
-            NativeCloseButtonStyle buttonStyle,
-            MraidView.PlacementType placementType) {
-        return new MraidView(context, adConfiguration, expansionStyle, buttonStyle, placementType);
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/ViewGestureDetectorFactory.java b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/ViewGestureDetectorFactory.java
deleted file mode 100644
index d8e377c0..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/ViewGestureDetectorFactory.java
+++ /dev/null
@@ -1,25 +0,0 @@
-package com.mopub.mobileads.factories;
-
-import android.content.Context;
-import android.view.View;
-
-import com.mopub.mobileads.AdConfiguration;
-import com.mopub.mobileads.ViewGestureDetector;
-
-public class ViewGestureDetectorFactory {
-    protected static ViewGestureDetectorFactory instance = new ViewGestureDetectorFactory();
-
-    @Deprecated // for testing
-    public static void setInstance(ViewGestureDetectorFactory factory) {
-        instance = factory;
-    }
-
-    public static ViewGestureDetector create(Context context, View view, AdConfiguration adConfiguration) {
-        return instance.internalCreate(context, view, adConfiguration);
-    }
-
-    protected ViewGestureDetector internalCreate(Context context, View view, AdConfiguration adConfiguration) {
-        return new ViewGestureDetector(context, view, adConfiguration);
-    }
-}
-
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/resource/CloseButtonDrawable.java b/mopub-sdk/src/main/java/com/mopub/mobileads/resource/CloseButtonDrawable.java
index af32b51a..557b6e11 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/resource/CloseButtonDrawable.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/resource/CloseButtonDrawable.java
@@ -2,7 +2,6 @@
 
 import android.graphics.Canvas;
 import android.graphics.Paint;
-import android.graphics.Path;
 import android.graphics.Point;
 
 public class CloseButtonDrawable extends CircleDrawable {
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/resource/MraidJavascript.java b/mopub-sdk/src/main/java/com/mopub/mobileads/resource/MraidJavascript.java
index 94228d44..7071ffa0 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/resource/MraidJavascript.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/resource/MraidJavascript.java
@@ -17,63 +17,48 @@
             "  }\n" +
             "}());\n" +
             "\n" +
-            "(function() {\n" +
-            "  // Establish the root mraidbridge object.\n" +
-            "  var mraidbridge = window.mraidbridge = {};\n" +
-            "\n" +
-            "  // native SDK is ready to process mraid commands.\n" +
-            "  var nativeSDKFiredReady = false;\n" +
-            "\n" +
-            "  // Listeners for bridge events.\n" +
-            "  var listeners = {};\n" +
-            "\n" +
-            "  // Queue to track pending calls to the native SDK.\n" +
-            "  var nativeCallQueue = [];\n" +
             "\n" +
-            "  // Whether a native call is currently in progress.\n" +
-            "  var nativeCallInFlight = false;\n" +
+            "(function() {\n" +
+            "  var mraid = window.mraid = {};\n" +
             "\n" +
             "  //////////////////////////////////////////////////////////////////////////////////////////////////\n" +
             "\n" +
-            "  mraidbridge.fireReadyEvent = function() {\n" +
-            "    nativeSDKFiredReady = true;\n" +
-            "    mraidbridge.fireEvent('ready');\n" +
-            "  };\n" +
+            "  // Bridge interface to SDK\n" +
             "\n" +
-            "  mraidbridge.fireChangeEvent = function(properties) {\n" +
-            "    mraidbridge.fireEvent('change', properties);\n" +
+            "  var bridge = window.mraidbridge = {\n" +
+            "    nativeSDKFiredReady: false,\n" +
+            "    nativeCallQueue: [],\n" +
+            "    nativeCallInFlight: false,\n" +
+            "    lastSizeChangeProperties: null\n" +
             "  };\n" +
             "\n" +
-            "  mraidbridge.fireErrorEvent = function(message, action) {\n" +
-            "    mraidbridge.fireEvent('error', message, action);\n" +
-            "  };\n" +
             "\n" +
-            "  mraidbridge.fireEvent = function(type) {\n" +
-            "    var ls = listeners[type];\n" +
-            "    if (ls) {\n" +
-            "      var args = Array.prototype.slice.call(arguments);\n" +
-            "      args.shift();\n" +
-            "      var l = ls.length;\n" +
-            "      for (var i = 0; i < l; i++) {\n" +
-            "        ls[i].apply(null, args);\n" +
+            "  bridge.fireChangeEvent = function(properties) {\n" +
+            "    for (var p in properties) {\n" +
+            "      if (properties.hasOwnProperty(p)) {\n" +
+            "        // Change handlers defined by MRAID below\n" +
+            "        var handler = changeHandlers[p];\n" +
+            "        handler(properties[p]);\n" +
             "      }\n" +
             "    }\n" +
             "  };\n" +
             "\n" +
-            "  mraidbridge.nativeCallComplete = function(command) {\n" +
-            "    if (nativeCallQueue.length === 0) {\n" +
-            "      nativeCallInFlight = false;\n" +
+            "  bridge.nativeCallComplete = function(command) {\n" +
+            "    if (this.nativeCallQueue.length === 0) {\n" +
+            "      this.nativeCallInFlight = false;\n" +
             "      return;\n" +
             "    }\n" +
             "\n" +
-            "    var nextCall = nativeCallQueue.pop();\n" +
+            "    var nextCall = this.nativeCallQueue.pop();\n" +
             "    window.location = nextCall;\n" +
             "  };\n" +
             "\n" +
-            "  mraidbridge.executeNativeCall = function(command) {\n" +
-            "    if (!nativeSDKFiredReady) {\n" +
+            "  bridge.executeNativeCall = function(args) {\n" +
+            "    var command = args.shift();\n" +
+            "\n" +
+            "    if (!this.nativeSDKFiredReady) {\n" +
             "        console.log('rejecting ' + command + ' because mraid is not ready');\n" +
-            "        mraidbridge.fireErrorEvent('mraid is not ready', command);\n" +
+            "        bridge.notifyErrorEvent('mraid is not ready', command);\n" +
             "        return;\n" +
             "    }\n" +
             "\n" +
@@ -82,9 +67,9 @@
             "    var key, value;\n" +
             "    var isFirstArgument = true;\n" +
             "\n" +
-            "    for (var i = 1; i < arguments.length; i += 2) {\n" +
-            "      key = arguments[i];\n" +
-            "      value = arguments[i + 1];\n" +
+            "    for (var i = 0; i < args.length; i += 2) {\n" +
+            "      key = args[i];\n" +
+            "      value = args[i + 1];\n" +
             "\n" +
             "      if (value === null) continue;\n" +
             "\n" +
@@ -98,55 +83,133 @@
             "      call += encodeURIComponent(key) + '=' + encodeURIComponent(value);\n" +
             "    }\n" +
             "\n" +
-            "    if (nativeCallInFlight) {\n" +
-            "      nativeCallQueue.push(call);\n" +
+            "    if (this.nativeCallInFlight) {\n" +
+            "      this.nativeCallQueue.push(call);\n" +
             "    } else {\n" +
-            "      nativeCallInFlight = true;\n" +
+            "      this.nativeCallInFlight = true;\n" +
             "      window.location = call;\n" +
             "    }\n" +
             "  };\n" +
             "\n" +
-            "  //////////////////////////////////////////////////////////////////////////////////////////////////\n" +
             "\n" +
-            "  mraidbridge.addEventListener = function(event, listener) {\n" +
-            "    var eventListeners;\n" +
-            "    listeners[event] = listeners[event] || [];\n" +
-            "    eventListeners = listeners[event];\n" +
+            "  bridge.setCurrentPosition = function(x, y, width, height) {\n" +
+            "    currentPosition = {\n" +
+            "      x: x,\n" +
+            "      y: y,\n" +
+            "      width: width,\n" +
+            "      height: height\n" +
+            "    };\n" +
+            "    broadcastEvent(EVENTS.INFO, 'Set current position to ' + stringify(currentPosition));\n" +
+            "  };\n" +
+            "\n" +
+            "  bridge.setDefaultPosition = function(x, y, width, height) {\n" +
+            "    defaultPosition = {\n" +
+            "      x: x,\n" +
+            "      y: y,\n" +
+            "      width: width,\n" +
+            "      height: height\n" +
+            "    };\n" +
+            "    broadcastEvent(EVENTS.INFO, 'Set default position to ' + stringify(defaultPosition));\n" +
+            "  };\n" +
+            "\n" +
+            "  bridge.setMaxSize = function(width, height) {\n" +
+            "    maxSize = {\n" +
+            "      width: width,\n" +
+            "      height: height\n" +
+            "    };\n" +
+            "\n" +
+            "    expandProperties.width = width;\n" +
+            "    expandProperties.height = height;\n" +
             "\n" +
-            "    for (var l in eventListeners) {\n" +
-            "      // Listener already registered, so no need to add it.\n" +
-            "      if (listener === l) return;\n" +
+            "    broadcastEvent(EVENTS.INFO, 'Set max size to ' + stringify(maxSize));\n" +
+            "  };\n" +
+            "\n" +
+            "  bridge.setPlacementType = function(_placementType) {\n" +
+            "    placementType = _placementType;\n" +
+            "    broadcastEvent(EVENTS.INFO, 'Set placement type to ' + stringify(placementType));\n" +
+            "  };\n" +
+            "\n" +
+            "  bridge.setScreenSize = function(width, height) {\n" +
+            "    screenSize = {\n" +
+            "      width: width,\n" +
+            "      height: height\n" +
+            "    };\n" +
+            "    broadcastEvent(EVENTS.INFO, 'Set screen size to ' + stringify(screenSize));\n" +
+            "  };\n" +
+            "\n" +
+            "  bridge.setState = function(_state) {\n" +
+            "    state = _state;\n" +
+            "    broadcastEvent(EVENTS.INFO, 'Set state to ' + stringify(state));\n" +
+            "    broadcastEvent(EVENTS.STATECHANGE, state);\n" +
+            "  };\n" +
+            "\n" +
+            "  bridge.setIsViewable = function(_isViewable) {\n" +
+            "    isViewable = _isViewable;\n" +
+            "    broadcastEvent(EVENTS.INFO, 'Set isViewable to ' + stringify(isViewable));\n" +
+            "    broadcastEvent(EVENTS.VIEWABLECHANGE, isViewable);\n" +
+            "  };\n" +
+            "\n" +
+            "  bridge.setSupports = function(sms, tel, calendar, storePicture, inlineVideo) {\n" +
+            "    supportProperties = {\n" +
+            "      sms: sms,\n" +
+            "      tel: tel,\n" +
+            "      calendar: calendar,\n" +
+            "      storePicture: storePicture,\n" +
+            "      inlineVideo: inlineVideo\n" +
+            "    };\n" +
+            "  };\n" +
+            "\n" +
+            "  bridge.notifyReadyEvent = function() {\n" +
+            "    this.nativeSDKFiredReady = true;\n" +
+            "    broadcastEvent(EVENTS.READY);\n" +
+            "  };\n" +
+            "\n" +
+            "  bridge.notifyErrorEvent = function(message, action) {\n" +
+            "    broadcastEvent(EVENTS.ERROR, message, action);\n" +
+            "  };\n" +
+            "\n" +
+            "  // Temporary aliases while we migrate to the new API\n" +
+            "  bridge.fireReadyEvent = bridge.notifyReadyEvent;\n" +
+            "  bridge.fireErrorEvent = bridge.notifyErrorEvent;\n" +
+            "\n" +
+            "  bridge.notifySizeChangeEvent = function(width, height) {\n" +
+            "    if (this.lastSizeChangeProperties &&\n" +
+            "          width == this.lastSizeChangeProperties.width && height == this.lastSizeChangeProperties.height) {\n" +
+            "      return;\n" +
             "    }\n" +
             "\n" +
-            "    eventListeners.push(listener);\n" +
+            "    this.lastSizeChangeProperties = {\n" +
+            "        width: width,\n" +
+            "        height: height\n" +
+            "    };\n" +
+            "    broadcastEvent(EVENTS.SIZECHANGE, width, height);\n" +
             "  };\n" +
             "\n" +
-            "  mraidbridge.removeEventListener = function(event, listener) {\n" +
-            "    if (listeners.hasOwnProperty(event)) {\n" +
-            "      var eventListeners = listeners[event];\n" +
-            "      if (eventListeners) {\n" +
-            "        var idx = eventListeners.indexOf(listener);\n" +
-            "        if (idx !== -1) {\n" +
-            "          eventListeners.splice(idx, 1);\n" +
-            "        }\n" +
-            "      }\n" +
+            "  bridge.notifyStateChangeEvent = function() {\n" +
+            "    if (state === STATES.LOADING) {\n" +
+            "      broadcastEvent(EVENTS.INFO, 'Native SDK initialized.');\n" +
             "    }\n" +
+            "\n" +
+            "    broadcastEvent(EVENTS.INFO, 'Set state to ' + stringify(state));\n" +
+            "    broadcastEvent(EVENTS.STATECHANGE, state);\n" +
+            "  };\n" +
+            "\n" +
+            "  bridge.notifyViewableChangeEvent = function() {\n" +
+            "    broadcastEvent(EVENTS.INFO, 'Set isViewable to ' + stringify(isViewable));\n" +
+            "    broadcastEvent(EVENTS.VIEWABLECHANGE, isViewable);\n" +
             "  };\n" +
-            "}());\n" +
             "\n" +
-            "(function() {\n" +
-            "  var mraid = window.mraid = {};\n" +
-            "  var bridge = window.mraidbridge;\n" +
             "\n" +
             "  // Constants. ////////////////////////////////////////////////////////////////////////////////////\n" +
             "\n" +
-            "  var VERSION = mraid.VERSION = '1.0';\n" +
+            "  var VERSION = mraid.VERSION = '2.0';\n" +
             "\n" +
             "  var STATES = mraid.STATES = {\n" +
-            "    LOADING: 'loading',     // Initial state.\n" +
+            "    LOADING: 'loading',\n" +
             "    DEFAULT: 'default',\n" +
             "    EXPANDED: 'expanded',\n" +
-            "    HIDDEN: 'hidden'\n" +
+            "    HIDDEN: 'hidden',\n" +
+            "    RESIZED: 'resized'\n" +
             "  };\n" +
             "\n" +
             "  var EVENTS = mraid.EVENTS = {\n" +
@@ -154,7 +217,8 @@
             "    INFO: 'info',\n" +
             "    READY: 'ready',\n" +
             "    STATECHANGE: 'stateChange',\n" +
-            "    VIEWABLECHANGE: 'viewableChange'\n" +
+            "    VIEWABLECHANGE: 'viewableChange',\n" +
+            "    SIZECHANGE: 'sizeChange'\n" +
             "  };\n" +
             "\n" +
             "  var PLACEMENT_TYPES = mraid.PLACEMENT_TYPES = {\n" +
@@ -167,14 +231,44 @@
             "\n" +
             "  // Properties which define the behavior of an expandable ad.\n" +
             "  var expandProperties = {\n" +
-            "    width: -1,\n" +
-            "    height: -1,\n" +
+            "    width: false,\n" +
+            "    height: false,\n" +
             "    useCustomClose: false,\n" +
-            "    isModal: true,\n" +
-            "    lockOrientation: false\n" +
+            "    isModal: true\n" +
+            "  };\n" +
+            "\n" +
+            "  var resizeProperties = {\n" +
+            "    width: false,\n" +
+            "    height: false,\n" +
+            "    offsetX: false,\n" +
+            "    offsetY: false,\n" +
+            "    customClosePosition: 'top-right',\n" +
+            "    allowOffscreen: true\n" +
+            "  };\n" +
+            "\n" +
+            "  var orientationProperties = {\n" +
+            "    allowOrientationChange: true,\n" +
+            "    forceOrientation: \"none\"\n" +
+            "  };\n" +
+            "\n" +
+            "  var supportProperties = {\n" +
+            "    sms: false,\n" +
+            "    tel: false,\n" +
+            "    calendar: false,\n" +
+            "    storePicture: false,\n" +
+            "    inlineVideo: false\n" +
             "  };\n" +
             "\n" +
-            "  var hasSetCustomSize = false;\n" +
+            "  // default is undefined so that notifySizeChangeEvent can track changes\n" +
+            "  var lastSizeChangeProperties;\n" +
+            "\n" +
+            "  var maxSize = {};\n" +
+            "\n" +
+            "  var currentPosition = {};\n" +
+            "\n" +
+            "  var defaultPosition = {};\n" +
+            "\n" +
+            "  var screenSize = {};\n" +
             "\n" +
             "  var hasSetCustomClose = false;\n" +
             "\n" +
@@ -186,18 +280,8 @@
             "\n" +
             "  var isViewable = false;\n" +
             "\n" +
-            "  var screenSize = { width: -1, height: -1 };\n" +
-            "\n" +
             "  var placementType = PLACEMENT_TYPES.UNKNOWN;\n" +
             "\n" +
-            "  var supports = {\n" +
-            "    sms: false,\n" +
-            "    tel: false,\n" +
-            "    calendar: false,\n" +
-            "    storePicture: false,\n" +
-            "    inlineVideo: false\n" +
-            "  };\n" +
-            "\n" +
             "  //////////////////////////////////////////////////////////////////////////////////////////////////\n" +
             "\n" +
             "  var EventListeners = function(event) {\n" +
@@ -233,7 +317,7 @@
             "\n" +
             "    this.broadcast = function(args) {\n" +
             "      for (var id in listeners) {\n" +
-            "        if (listeners.hasOwnProperty(id)) listeners[id].apply({}, args);\n" +
+            "        if (listeners.hasOwnProperty(id)) listeners[id].apply(mraid, args);\n" +
             "      }\n" +
             "    };\n" +
             "\n" +
@@ -309,29 +393,17 @@
             "      placementType = val;\n" +
             "    },\n" +
             "\n" +
-            "    screenSize: function(val) {\n" +
+            "    sizeChange: function(val) {\n" +
             "      broadcastEvent(EVENTS.INFO, 'Set screenSize to ' + stringify(val));\n" +
             "      for (var key in val) {\n" +
             "        if (val.hasOwnProperty(key)) screenSize[key] = val[key];\n" +
             "      }\n" +
-            "\n" +
-            "      if (!hasSetCustomSize) {\n" +
-            "        expandProperties['width'] = screenSize['width'];\n" +
-            "        expandProperties['height'] = screenSize['height'];\n" +
-            "      }\n" +
-            "    },\n" +
-            "\n" +
-            "    expandProperties: function(val) {\n" +
-            "      broadcastEvent(EVENTS.INFO, 'Merging expandProperties with ' + stringify(val));\n" +
-            "      for (var key in val) {\n" +
-            "        if (val.hasOwnProperty(key)) expandProperties[key] = val[key];\n" +
-            "      }\n" +
             "    },\n" +
             "\n" +
             "    supports: function(val) {\n" +
             "      broadcastEvent(EVENTS.INFO, 'Set supports to ' + stringify(val));\n" +
-            "        supports = val;\n" +
-            "    },\n" +
+            "        supportProperties = val;\n" +
+            "    }\n" +
             "  };\n" +
             "\n" +
             "  var validate = function(obj, validators, action, merge) {\n" +
@@ -343,7 +415,7 @@
             "      } else {\n" +
             "        for (var i in validators) {\n" +
             "          if (validators.hasOwnProperty(i) && obj[i] === undefined) {\n" +
-            "            broadcastEvent(EVENTS.ERROR, 'Object is missing required property: ' + i + '.', action);\n" +
+            "            broadcastEvent(EVENTS.ERROR, 'Object is missing required property: ' + i, action);\n" +
             "            return false;\n" +
             "          }\n" +
             "        }\n" +
@@ -355,8 +427,7 @@
             "      var value = obj[prop];\n" +
             "      if (validator && !validator(value)) {\n" +
             "        // Failed validation.\n" +
-            "        broadcastEvent(EVENTS.ERROR, 'Value of property ' + prop + ' is invalid.',\n" +
-            "          action);\n" +
+            "        broadcastEvent(EVENTS.ERROR, 'Value of property ' + prop + ' is invalid: ' + value, action);\n" +
             "        return false;\n" +
             "      }\n" +
             "    }\n" +
@@ -364,40 +435,20 @@
             "  };\n" +
             "\n" +
             "  var expandPropertyValidators = {\n" +
-            "    width: function(v) { return !isNaN(v) && v >= 0; },\n" +
-            "    height: function(v) { return !isNaN(v) && v >= 0; },\n" +
             "    useCustomClose: function(v) { return (typeof v === 'boolean'); },\n" +
-            "    lockOrientation: function(v) { return (typeof v === 'boolean'); }\n" +
             "  };\n" +
             "\n" +
             "  //////////////////////////////////////////////////////////////////////////////////////////////////\n" +
             "\n" +
-            "  bridge.addEventListener('change', function(properties) {\n" +
-            "    for (var p in properties) {\n" +
-            "      if (properties.hasOwnProperty(p)) {\n" +
-            "        var handler = changeHandlers[p];\n" +
-            "        handler(properties[p]);\n" +
-            "      }\n" +
-            "    }\n" +
-            "  });\n" +
-            "\n" +
-            "  bridge.addEventListener('error', function(message, action) {\n" +
-            "    broadcastEvent(EVENTS.ERROR, message, action);\n" +
-            "  });\n" +
-            "\n" +
-            "  bridge.addEventListener('ready', function() {\n" +
-            "    broadcastEvent(EVENTS.READY);\n" +
-            "  });\n" +
-            "\n" +
-            "  //////////////////////////////////////////////////////////////////////////////////////////////////\n" +
-            "\n" +
             "  mraid.addEventListener = function(event, listener) {\n" +
             "    if (!event || !listener) {\n" +
             "      broadcastEvent(EVENTS.ERROR, 'Both event and listener are required.', 'addEventListener');\n" +
             "    } else if (!contains(event, EVENTS)) {\n" +
             "      broadcastEvent(EVENTS.ERROR, 'Unknown MRAID event: ' + event, 'addEventListener');\n" +
             "    } else {\n" +
-            "      if (!listeners[event]) listeners[event] = new EventListeners(event);\n" +
+            "      if (!listeners[event]) {\n" +
+            "        listeners[event] = new EventListeners(event);\n" +
+            "      }\n" +
             "      listeners[event].add(listener);\n" +
             "    }\n" +
             "  };\n" +
@@ -406,45 +457,25 @@
             "    if (state === STATES.HIDDEN) {\n" +
             "      broadcastEvent(EVENTS.ERROR, 'Ad cannot be closed when it is already hidden.',\n" +
             "        'close');\n" +
-            "    } else bridge.executeNativeCall('close');\n" +
+            "    } else bridge.executeNativeCall(['close']);\n" +
             "  };\n" +
             "\n" +
             "  mraid.expand = function(URL) {\n" +
-            "    if (this.getState() !== STATES.DEFAULT) {\n" +
-            "      broadcastEvent(EVENTS.ERROR, 'Ad can only be expanded from the default state.', 'expand');\n" +
+            "    if (!(this.getState() === STATES.DEFAULT || this.getState() === STATES.RESIZED)) {\n" +
+            "      broadcastEvent(EVENTS.ERROR, 'Ad can only be expanded from the default or resized state.', 'expand');\n" +
             "    } else {\n" +
-            "      var args = ['expand'];\n" +
-            "\n" +
-            "      if (this.getHasSetCustomClose()) {\n" +
-            "        args = args.concat(['shouldUseCustomClose', expandProperties.useCustomClose ? 'true' : 'false']);\n" +
-            "      }\n" +
-            "\n" +
-            "      if (this.getHasSetCustomSize()) {\n" +
-            "        if (expandProperties.width >= 0 && expandProperties.height >= 0) {\n" +
-            "          args = args.concat(['w', expandProperties.width, 'h', expandProperties.height]);\n" +
-            "        }\n" +
-            "      }\n" +
-            "\n" +
-            "      if (typeof expandProperties.lockOrientation !== 'undefined') {\n" +
-            "        args = args.concat(['lockOrientation', expandProperties.lockOrientation]);\n" +
-            "      }\n" +
+            "      var args = ['expand',\n" +
+            "        'shouldUseCustomClose', expandProperties.useCustomClose\n" +
+            "      ];\n" +
             "\n" +
             "      if (URL) {\n" +
             "        args = args.concat(['url', URL]);\n" +
             "      }\n" +
             "\n" +
-            "      bridge.executeNativeCall.apply(this, args);\n" +
+            "      bridge.executeNativeCall(args);\n" +
             "    }\n" +
             "  };\n" +
             "\n" +
-            "  mraid.getHasSetCustomClose = function() {\n" +
-            "      return hasSetCustomClose;\n" +
-            "  };\n" +
-            "\n" +
-            "  mraid.getHasSetCustomSize = function() {\n" +
-            "      return hasSetCustomSize;\n" +
-            "  };\n" +
-            "\n" +
             "  mraid.getExpandProperties = function() {\n" +
             "    var properties = {\n" +
             "      width: expandProperties.width,\n" +
@@ -455,56 +486,93 @@
             "    return properties;\n" +
             "  };\n" +
             "\n" +
+            "\n" +
+            "  mraid.getCurrentPosition = function() {\n" +
+            "    return {\n" +
+            "      x: currentPosition.x,\n" +
+            "      y: currentPosition.y,\n" +
+            "      width: currentPosition.width,\n" +
+            "      height: currentPosition.height\n" +
+            "    };\n" +
+            "  };\n" +
+            "\n" +
+            "  mraid.getDefaultPosition = function() {\n" +
+            "    return {\n" +
+            "      x: defaultPosition.x,\n" +
+            "      y: defaultPosition.y,\n" +
+            "      width: defaultPosition.width,\n" +
+            "      height: defaultPosition.height\n" +
+            "    };\n" +
+            "  };\n" +
+            "\n" +
+            "  mraid.getMaxSize = function() {\n" +
+            "    return {\n" +
+            "      width: maxSize.width,\n" +
+            "      height: maxSize.height\n" +
+            "    };\n" +
+            "  };\n" +
+            "\n" +
             "  mraid.getPlacementType = function() {\n" +
             "    return placementType;\n" +
             "  };\n" +
             "\n" +
-            "  mraid.getState = function() {\n" +
-            "    return state;\n" +
+            "  mraid.getScreenSize = function() {\n" +
+            "    return {\n" +
+            "      width: screenSize.width,\n" +
+            "      height: screenSize.height\n" +
+            "    };\n" +
             "  };\n" +
             "\n" +
-            "  mraid.getVersion = function() {\n" +
-            "    return mraid.VERSION;\n" +
+            "  mraid.getState = function() {\n" +
+            "    return state;\n" +
             "  };\n" +
             "\n" +
             "  mraid.isViewable = function() {\n" +
             "    return isViewable;\n" +
             "  };\n" +
             "\n" +
+            "  mraid.getVersion = function() {\n" +
+            "    return mraid.VERSION;\n" +
+            "  };\n" +
+            "\n" +
             "  mraid.open = function(URL) {\n" +
             "    if (!URL) broadcastEvent(EVENTS.ERROR, 'URL is required.', 'open');\n" +
-            "    else bridge.executeNativeCall('open', 'url', URL);\n" +
+            "    else bridge.executeNativeCall(['open', 'url', URL]);\n" +
             "  };\n" +
             "\n" +
             "  mraid.removeEventListener = function(event, listener) {\n" +
-            "    if (!event) broadcastEvent(EVENTS.ERROR, 'Event is required.', 'removeEventListener');\n" +
-            "    else {\n" +
-            "      if (listener && (!listeners[event] || !listeners[event].remove(listener))) {\n" +
-            "        broadcastEvent(EVENTS.ERROR, 'Listener not currently registered for event.',\n" +
-            "          'removeEventListener');\n" +
-            "        return;\n" +
-            "      } else if (listeners[event]) listeners[event].removeAll();\n" +
+            "    if (!event) {\n" +
+            "      broadcastEvent(EVENTS.ERROR, 'Event is required.', 'removeEventListener');\n" +
+            "      return;\n" +
+            "    }\n" +
             "\n" +
-            "      if (listeners[event] && listeners[event].count === 0) {\n" +
-            "        listeners[event] = null;\n" +
-            "        delete listeners[event];\n" +
+            "    if (listener) {\n" +
+            "      // If we have a valid event, we'll try to remove the listener from it.\n" +
+            "      var success = false;\n" +
+            "      if (listeners[event]) {\n" +
+            "        success = listeners[event].remove(listener);\n" +
+            "      }\n" +
+            "\n" +
+            "      // If we didn't have a valid event or couldn't remove the listener from the event, broadcast an error and return early.\n" +
+            "      if (!success) {\n" +
+            "        broadcastEvent(EVENTS.ERROR, 'Listener not currently registered for event.', 'removeEventListener');\n" +
+            "        return;\n" +
             "      }\n" +
+            "\n" +
+            "    } else if (!listener && listeners[event]) {\n" +
+            "      listeners[event].removeAll();\n" +
+            "    }\n" +
+            "\n" +
+            "    if (listeners[event] && listeners[event].count === 0) {\n" +
+            "      listeners[event] = null;\n" +
+            "      delete listeners[event];\n" +
             "    }\n" +
             "  };\n" +
             "\n" +
             "  mraid.setExpandProperties = function(properties) {\n" +
             "    if (validate(properties, expandPropertyValidators, 'setExpandProperties', true)) {\n" +
-            "      if (properties.hasOwnProperty('width') || properties.hasOwnProperty('height')) {\n" +
-            "        hasSetCustomSize = true;\n" +
-            "      }\n" +
-            "\n" +
-            "      if (properties.hasOwnProperty('useCustomClose')) hasSetCustomClose = true;\n" +
-            "\n" +
-            "      var desiredProperties = ['width', 'height', 'useCustomClose', 'lockOrientation'];\n" +
-            "      var length = desiredProperties.length;\n" +
-            "      for (var i = 0; i < length; i++) {\n" +
-            "        var propname = desiredProperties[i];\n" +
-            "        if (properties.hasOwnProperty(propname)) expandProperties[propname] = properties[propname];\n" +
+            "      if (properties.hasOwnProperty('useCustomClose')) {\n" +
+            "        expandProperties.useCustomClose = properties.useCustomClose;\n" +
             "      }\n" +
             "    }\n" +
             "  };\n" +
@@ -512,7 +580,7 @@
             "  mraid.useCustomClose = function(shouldUseCustomClose) {\n" +
             "    expandProperties.useCustomClose = shouldUseCustomClose;\n" +
             "    hasSetCustomClose = true;\n" +
-            "    bridge.executeNativeCall('usecustomclose', 'shouldUseCustomClose', shouldUseCustomClose);\n" +
+            "    bridge.executeNativeCall(['usecustomclose', 'shouldUseCustomClose', shouldUseCustomClose]);\n" +
             "  };\n" +
             "\n" +
             "  // MRAID 2.0 APIs ////////////////////////////////////////////////////////////////////////////////\n" +
@@ -520,14 +588,14 @@
             "  mraid.createCalendarEvent = function(parameters) {\n" +
             "    CalendarEventParser.initialize(parameters);\n" +
             "    if (CalendarEventParser.parse()) {\n" +
-            "      bridge.executeNativeCall.apply(this, CalendarEventParser.arguments);\n" +
+            "      bridge.executeNativeCall(CalendarEventParser.arguments);\n" +
             "    } else {\n" +
             "      broadcastEvent(EVENTS.ERROR, CalendarEventParser.errors[0], 'createCalendarEvent');\n" +
             "    }\n" +
             "  };\n" +
             "\n" +
             "  mraid.supports = function(feature) {\n" +
-            "    return supports[feature];\n" +
+            "    return supportProperties[feature];\n" +
             "  };\n" +
             "\n" +
             "  mraid.playVideo = function(uri) {\n" +
@@ -539,7 +607,7 @@
             "    if (!uri) {\n" +
             "      broadcastEvent(EVENTS.ERROR, 'playVideo must be called with a valid URI', 'playVideo');\n" +
             "    } else {\n" +
-            "      bridge.executeNativeCall.apply(this, ['playVideo', 'uri', uri]);\n" +
+            "      bridge.executeNativeCall(['playVideo', 'uri', uri]);\n" +
             "    }\n" +
             "  };\n" +
             "\n" +
@@ -552,36 +620,102 @@
             "    if (!uri) {\n" +
             "      broadcastEvent(EVENTS.ERROR, 'storePicture must be called with a valid URI', 'storePicture');\n" +
             "    } else {\n" +
-            "      bridge.executeNativeCall.apply(this, ['storePicture', 'uri', uri]);\n" +
+            "      bridge.executeNativeCall(['storePicture', 'uri', uri]);\n" +
             "    }\n" +
             "  };\n" +
             "\n" +
-            "  mraid.resize = function() {\n" +
-            "    bridge.executeNativeCall('resize');\n" +
-            "  };\n" +
             "\n" +
-            "  mraid.getResizeProperties = function() {\n" +
-            "    bridge.executeNativeCall('getResizeProperties');\n" +
+            "  var resizePropertyValidators = {\n" +
+            "    width: function(v) {\n" +
+            "      return !isNaN(v) && v > 0;\n" +
+            "    },\n" +
+            "    height: function(v) {\n" +
+            "      return !isNaN(v) && v > 0;\n" +
+            "    },\n" +
+            "    offsetX: function(v) {\n" +
+            "      return !isNaN(v);\n" +
+            "    },\n" +
+            "    offsetY: function(v) {\n" +
+            "      return !isNaN(v);\n" +
+            "    },\n" +
+            "    customClosePosition: function(v) {\n" +
+            "      return (typeof v === 'string' &&\n" +
+            "        ['top-right', 'bottom-right', 'top-left', 'bottom-left', 'center', 'top-center', 'bottom-center'].indexOf(v) > -1);\n" +
+            "    },\n" +
+            "    allowOffscreen: function(v) {\n" +
+            "      return (typeof v === 'boolean');\n" +
+            "    }\n" +
             "  };\n" +
             "\n" +
-            "  mraid.setResizeProperties = function(resizeProperties) {\n" +
-            "    bridge.executeNativeCall('setResizeProperties', 'resizeProperties', resizeProperties);\n" +
+            "  mraid.setOrientationProperties = function(properties) {\n" +
+            "\n" +
+            "    if (properties.hasOwnProperty('allowOrientationChange')) {\n" +
+            "      orientationProperties.allowOrientationChange = properties.allowOrientationChange;\n" +
+            "    }\n" +
+            "\n" +
+            "    if (properties.hasOwnProperty('forceOrientation')) {\n" +
+            "      orientationProperties.forceOrientation = properties.forceOrientation;\n" +
+            "    }\n" +
+            "\n" +
+            "    var args = ['setOrientationProperties',\n" +
+            "      'allowOrientationChange', orientationProperties.allowOrientationChange,\n" +
+            "      'forceOrientation', orientationProperties.forceOrientation\n" +
+            "    ];\n" +
+            "    bridge.executeNativeCall(args);\n" +
             "  };\n" +
             "\n" +
-            "  mraid.getCurrentPosition = function() {\n" +
-            "    bridge.executeNativeCall('getCurrentPosition');\n" +
+            "  mraid.getOrientationProperties = function() {\n" +
+            "    return {\n" +
+            "      allowOrientationChange: orientationProperties.allowOrientationChange,\n" +
+            "      forceOrientation: orientationProperties.forceOrientation\n" +
+            "    };\n" +
             "  };\n" +
             "\n" +
-            "  mraid.getDefaultPosition = function() {\n" +
-            "    bridge.executeNativeCall('getDefaultPosition');\n" +
+            "  mraid.resize = function() {\n" +
+            "    if (!(this.getState() === STATES.DEFAULT || this.getState() === STATES.RESIZED)) {\n" +
+            "      broadcastEvent(EVENTS.ERROR, 'Ad can only be resized from the default or resized state.', 'resize');\n" +
+            "    } else if (!resizeProperties.width || !resizeProperties.height) {\n" +
+            "      broadcastEvent(EVENTS.ERROR, 'Must set resize properties before calling resize()', 'resize');\n" +
+            "    } else {\n" +
+            "      var args = ['resize',\n" +
+            "        'width', resizeProperties.width,\n" +
+            "        'height', resizeProperties.height,\n" +
+            "        'offsetX', resizeProperties.offsetX || 0,\n" +
+            "        'offsetY', resizeProperties.offsetY || 0,\n" +
+            "        'customClosePosition', resizeProperties.customClosePosition,\n" +
+            "        'allowOffscreen', !!resizeProperties.allowOffscreen\n" +
+            "        ];\n" +
+            "\n" +
+            "      bridge.executeNativeCall(args);\n" +
+            "    }\n" +
             "  };\n" +
             "\n" +
-            "  mraid.getMaxSize = function() {\n" +
-            "    bridge.executeNativeCall('getMaxSize');\n" +
+            "  mraid.getResizeProperties = function() {\n" +
+            "    var properties = {\n" +
+            "      width: resizeProperties.width,\n" +
+            "      height: resizeProperties.height,\n" +
+            "      offsetX: resizeProperties.offsetX,\n" +
+            "      offsetY: resizeProperties.offsetY,\n" +
+            "      customClosePosition: resizeProperties.customClosePosition,\n" +
+            "      allowOffscreen: resizeProperties.allowOffscreen\n" +
+            "    };\n" +
+            "    return properties;\n" +
             "  };\n" +
             "\n" +
-            "  mraid.getScreenSize = function() {\n" +
-            "    bridge.executeNativeCall('getScreenSize');\n" +
+            "  mraid.setResizeProperties = function(properties) {\n" +
+            "    if (validate(properties, resizePropertyValidators, 'setResizeProperties', true)) {\n" +
+            "\n" +
+            "      var desiredProperties = ['width', 'height', 'offsetX', 'offsetY', 'customClosePosition', 'allowOffscreen'];\n" +
+            "\n" +
+            "      var length = desiredProperties.length;\n" +
+            "\n" +
+            "      for (var i = 0; i < length; i++) {\n" +
+            "        var propname = desiredProperties[i];\n" +
+            "        if (properties.hasOwnProperty(propname)) {\n" +
+            "          resizeProperties[propname] = properties[propname];\n" +
+            "        }\n" +
+            "      }\n" +
+            "    }\n" +
             "  };\n" +
             "\n" +
             "  var CalendarEventParser = {\n" +
@@ -663,7 +797,7 @@
             "      var validValues = ['opaque', 'transparent'];\n" +
             "\n" +
             "      if (this.parameters.hasOwnProperty('transparency')) {\n" +
-            "        var transparency = this.parameters['transparency'];\n" +
+            "        var transparency = this.parameters.transparency;\n" +
             "        if (contains(transparency, validValues)) {\n" +
             "          this.arguments.push('transparency');\n" +
             "          this.arguments.push(transparency);\n" +
@@ -688,7 +822,7 @@
             "\n" +
             "    parseRecurrenceInterval: function(recurrenceDict) {\n" +
             "      if (recurrenceDict.hasOwnProperty('interval')) {\n" +
-            "        var interval = recurrenceDict['interval'];\n" +
+            "        var interval = recurrenceDict.interval;\n" +
             "        if (!interval) {\n" +
             "          this.errors.push('Recurrence interval cannot be null.');\n" +
             "        } else {\n" +
@@ -704,7 +838,7 @@
             "\n" +
             "    parseRecurrenceFrequency: function(recurrenceDict) {\n" +
             "      if (recurrenceDict.hasOwnProperty('frequency')) {\n" +
-            "        var frequency = recurrenceDict['frequency'];\n" +
+            "        var frequency = recurrenceDict.frequency;\n" +
             "        var validFrequencies = ['daily', 'weekly', 'monthly', 'yearly'];\n" +
             "        if (contains(frequency, validFrequencies)) {\n" +
             "          this.arguments.push('frequency');\n" +
@@ -716,7 +850,7 @@
             "    },\n" +
             "\n" +
             "    parseRecurrenceEndDate: function(recurrenceDict) {\n" +
-            "      var expires = recurrenceDict['expires'];\n" +
+            "      var expires = recurrenceDict.expires;\n" +
             "\n" +
             "      if (!expires) {\n" +
             "        return;\n" +
@@ -748,7 +882,7 @@
             "        this.arguments.push(kind);\n" +
             "        this.arguments.push(dateString);\n" +
             "      }\n" +
-            "    },\n" +
+            "    }\n" +
             "  };\n" +
             "}());\n";
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/Base64.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/Base64.java
deleted file mode 100644
index 5a2aebe0..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/Base64.java
+++ /dev/null
@@ -1,725 +0,0 @@
-package com.mopub.mobileads.util;
-
-import java.io.UnsupportedEncodingException;
-
-/**
- * Utilities for encoding and decoding the Base64 representation of
- * binary data.  See RFCs <a
- * href="http://www.ietf.org/rfc/rfc2045.txt">2045</a> and <a
- * href="http://www.ietf.org/rfc/rfc3548.txt">3548</a>.
- */
-public class Base64 {
-    /**
-     * Default values for encoder/decoder flags.
-     */
-    public static final int DEFAULT = 0;
-
-    /**
-     * Encoder flag bit to omit the padding '=' characters at the end
-     * of the output (if any).
-     */
-    public static final int NO_PADDING = 1;
-
-    /**
-     * Encoder flag bit to omit all line terminators (i.e., the output
-     * will be on one long line).
-     */
-    public static final int NO_WRAP = 2;
-
-    /**
-     * Encoder flag bit to indicate lines should be terminated with a
-     * CRLF pair instead of just an LF.  Has no effect if {@code
-     * NO_WRAP} is specified as well.
-     */
-    public static final int CRLF = 4;
-
-    /**
-     * Encoder/decoder flag bit to indicate using the "URL and
-     * filename safe" variant of Base64 (see RFC 3548 section 4) where
-     * {@code -} and {@code _} are used in place of {@code +} and
-     * {@code /}.
-     */
-    public static final int URL_SAFE = 8;
-
-    /**
-     * Flag to pass to Base64OutputStream to indicate that it
-     * should not close the output stream it is wrapping when it
-     * itself is closed.
-     */
-    public static final int NO_CLOSE = 16;
-
-    //  --------------------------------------------------------
-    //  shared code
-    //  --------------------------------------------------------
-
-    /* package */ static abstract class Coder {
-        public byte[] output;
-        public int op;
-
-        /**
-         * Encode/decode another block of input data.  this.output is
-         * provided by the caller, and must be big enough to hold all
-         * the coded data.  On exit, this.opwill be set to the length
-         * of the coded data.
-         *
-         * @param finish true if this is the final call to process for
-         *        this object.  Will finalize the coder state and
-         *        include any final bytes in the output.
-         *
-         * @return true if the input so far is good; false if some
-         *         error has been detected in the input stream..
-         */
-        public abstract boolean process(byte[] input, int offset, int len, boolean finish);
-
-        /**
-         * @return the maximum number of bytes a call to process()
-         * could produce for the given number of input bytes.  This may
-         * be an overestimate.
-         */
-        public abstract int maxOutputSize(int len);
-    }
-
-    //  --------------------------------------------------------
-    //  decoding
-    //  --------------------------------------------------------
-
-    /**
-     * Decode the Base64-encoded data in input and return the data in
-     * a new byte array.
-     *
-     * <p>The padding '=' characters at the end are considered optional, but
-     * if any are present, there must be the correct number of them.
-     *
-     * @param str    the input String to decode, which is converted to
-     *               bytes using the default charset
-     * @param flags  controls certain features of the decoded output.
-     *               Pass {@code DEFAULT} to decode standard Base64.
-     *
-     * @throws IllegalArgumentException if the input contains
-     * incorrect padding
-     */
-    public static byte[] decode(String str, int flags) {
-        return decode(str.getBytes(), flags);
-    }
-
-    /**
-     * Decode the Base64-encoded data in input and return the data in
-     * a new byte array.
-     *
-     * <p>The padding '=' characters at the end are considered optional, but
-     * if any are present, there must be the correct number of them.
-     *
-     * @param input the input array to decode
-     * @param flags  controls certain features of the decoded output.
-     *               Pass {@code DEFAULT} to decode standard Base64.
-     *
-     * @throws IllegalArgumentException if the input contains
-     * incorrect padding
-     */
-    public static byte[] decode(byte[] input, int flags) {
-        return decode(input, 0, input.length, flags);
-    }
-
-    /**
-     * Decode the Base64-encoded data in input and return the data in
-     * a new byte array.
-     *
-     * <p>The padding '=' characters at the end are considered optional, but
-     * if any are present, there must be the correct number of them.
-     *
-     * @param input  the data to decode
-     * @param offset the position within the input array at which to start
-     * @param len    the number of bytes of input to decode
-     * @param flags  controls certain features of the decoded output.
-     *               Pass {@code DEFAULT} to decode standard Base64.
-     *
-     * @throws IllegalArgumentException if the input contains
-     * incorrect padding
-     */
-    public static byte[] decode(byte[] input, int offset, int len, int flags) {
-        // Allocate space for the most data the input could represent.
-        // (It could contain less if it contains whitespace, etc.)
-        Decoder decoder = new Decoder(flags, new byte[len*3/4]);
-
-        if (!decoder.process(input, offset, len, true)) {
-            throw new IllegalArgumentException("bad base-64");
-        }
-
-        // Maybe we got lucky and allocated exactly enough output space.
-        if (decoder.op == decoder.output.length) {
-            return decoder.output;
-        }
-
-        // Need to shorten the array, so allocate a new one of the
-        // right size and copy.
-        byte[] temp = new byte[decoder.op];
-        System.arraycopy(decoder.output, 0, temp, 0, decoder.op);
-        return temp;
-    }
-
-    /* package */ static class Decoder extends Coder {
-        /**
-         * Lookup table for turning bytes into their position in the
-         * Base64 alphabet.
-         */
-        private static final int DECODE[] = {
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
-                52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
-                -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
-                15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
-                -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
-                41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-        };
-
-        /**
-         * Decode lookup table for the "web safe" variant (RFC 3548
-         * sec. 4) where - and _ replace + and /.
-         */
-        private static final int DECODE_WEBSAFE[] = {
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1,
-                52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
-                -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
-                15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63,
-                -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
-                41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-        };
-
-        /** Non-data values in the DECODE arrays. */
-        private static final int SKIP = -1;
-        private static final int EQUALS = -2;
-
-        /**
-         * States 0-3 are reading through the next input tuple.
-         * State 4 is having read one '=' and expecting exactly
-         * one more.
-         * State 5 is expecting no more data or padding characters
-         * in the input.
-         * State 6 is the error state; an error has been detected
-         * in the input and no future input can "fix" it.
-         */
-        private int state;   // state number (0 to 6)
-        private int value;
-
-        final private int[] alphabet;
-
-        public Decoder(int flags, byte[] output) {
-            this.output = output;
-
-            alphabet = ((flags & URL_SAFE) == 0) ? DECODE : DECODE_WEBSAFE;
-            state = 0;
-            value = 0;
-        }
-
-        /**
-         * @return an overestimate for the number of bytes {@code
-         * len} bytes could decode to.
-         */
-        public int maxOutputSize(int len) {
-            return len * 3/4 + 10;
-        }
-
-        /**
-         * Decode another block of input data.
-         *
-         * @return true if the state machine is still healthy.  false if
-         *         bad base-64 data has been detected in the input stream.
-         */
-        public boolean process(byte[] input, int offset, int len, boolean finish) {
-            if (this.state == 6) return false;
-
-            int p = offset;
-            len += offset;
-
-            // Using local variables makes the decoder about 12%
-            // faster than if we manipulate the member variables in
-            // the loop.  (Even alphabet makes a measurable
-            // difference, which is somewhat surprising to me since
-            // the member variable is final.)
-            int state = this.state;
-            int value = this.value;
-            int op = 0;
-            final byte[] output = this.output;
-            final int[] alphabet = this.alphabet;
-
-            while (p < len) {
-                // Try the fast path:  we're starting a new tuple and the
-                // next four bytes of the input stream are all data
-                // bytes.  This corresponds to going through states
-                // 0-1-2-3-0.  We expect to use this method for most of
-                // the data.
-                //
-                // If any of the next four bytes of input are non-data
-                // (whitespace, etc.), value will end up negative.  (All
-                // the non-data values in decode are small negative
-                // numbers, so shifting any of them up and or'ing them
-                // together will result in a value with its top bit set.)
-                //
-                // You can remove this whole block and the output should
-                // be the same, just slower.
-                if (state == 0) {
-                    while (p+4 <= len &&
-                            (value = ((alphabet[input[p] & 0xff] << 18) |
-                                    (alphabet[input[p+1] & 0xff] << 12) |
-                                    (alphabet[input[p+2] & 0xff] << 6) |
-                                    (alphabet[input[p+3] & 0xff]))) >= 0) {
-                        output[op+2] = (byte) value;
-                        output[op+1] = (byte) (value >> 8);
-                        output[op] = (byte) (value >> 16);
-                        op += 3;
-                        p += 4;
-                    }
-                    if (p >= len) break;
-                }
-
-                // The fast path isn't available -- either we've read a
-                // partial tuple, or the next four input bytes aren't all
-                // data, or whatever.  Fall back to the slower state
-                // machine implementation.
-
-                int d = alphabet[input[p++] & 0xff];
-
-                switch (state) {
-                    case 0:
-                        if (d >= 0) {
-                            value = d;
-                            ++state;
-                        } else if (d != SKIP) {
-                            this.state = 6;
-                            return false;
-                        }
-                        break;
-
-                    case 1:
-                        if (d >= 0) {
-                            value = (value << 6) | d;
-                            ++state;
-                        } else if (d != SKIP) {
-                            this.state = 6;
-                            return false;
-                        }
-                        break;
-
-                    case 2:
-                        if (d >= 0) {
-                            value = (value << 6) | d;
-                            ++state;
-                        } else if (d == EQUALS) {
-                            // Emit the last (partial) output tuple;
-                            // expect exactly one more padding character.
-                            output[op++] = (byte) (value >> 4);
-                            state = 4;
-                        } else if (d != SKIP) {
-                            this.state = 6;
-                            return false;
-                        }
-                        break;
-
-                    case 3:
-                        if (d >= 0) {
-                            // Emit the output triple and return to state 0.
-                            value = (value << 6) | d;
-                            output[op+2] = (byte) value;
-                            output[op+1] = (byte) (value >> 8);
-                            output[op] = (byte) (value >> 16);
-                            op += 3;
-                            state = 0;
-                        } else if (d == EQUALS) {
-                            // Emit the last (partial) output tuple;
-                            // expect no further data or padding characters.
-                            output[op+1] = (byte) (value >> 2);
-                            output[op] = (byte) (value >> 10);
-                            op += 2;
-                            state = 5;
-                        } else if (d != SKIP) {
-                            this.state = 6;
-                            return false;
-                        }
-                        break;
-
-                    case 4:
-                        if (d == EQUALS) {
-                            ++state;
-                        } else if (d != SKIP) {
-                            this.state = 6;
-                            return false;
-                        }
-                        break;
-
-                    case 5:
-                        if (d != SKIP) {
-                            this.state = 6;
-                            return false;
-                        }
-                        break;
-                }
-            }
-
-            if (!finish) {
-                // We're out of input, but a future call could provide
-                // more.
-                this.state = state;
-                this.value = value;
-                this.op = op;
-                return true;
-            }
-
-            // Done reading input.  Now figure out where we are left in
-            // the state machine and finish up.
-
-            switch (state) {
-                case 0:
-                    // Output length is a multiple of three.  Fine.
-                    break;
-                case 1:
-                    // Read one extra input byte, which isn't enough to
-                    // make another output byte.  Illegal.
-                    this.state = 6;
-                    return false;
-                case 2:
-                    // Read two extra input bytes, enough to emit 1 more
-                    // output byte.  Fine.
-                    output[op++] = (byte) (value >> 4);
-                    break;
-                case 3:
-                    // Read three extra input bytes, enough to emit 2 more
-                    // output bytes.  Fine.
-                    output[op++] = (byte) (value >> 10);
-                    output[op++] = (byte) (value >> 2);
-                    break;
-                case 4:
-                    // Read one padding '=' when we expected 2.  Illegal.
-                    this.state = 6;
-                    return false;
-                case 5:
-                    // Read all the padding '='s we expected and no more.
-                    // Fine.
-                    break;
-            }
-
-            this.state = state;
-            this.op = op;
-            return true;
-        }
-    }
-
-    //  --------------------------------------------------------
-    //  encoding
-    //  --------------------------------------------------------
-
-    /**
-     * Base64-encode the given data and return a newly allocated
-     * String with the result.
-     *
-     * @param input  the data to encode
-     * @param flags  controls certain features of the encoded output.
-     *               Passing {@code DEFAULT} results in output that
-     *               adheres to RFC 2045.
-     */
-    public static String encodeToString(byte[] input, int flags) {
-        try {
-            return new String(encode(input, flags), "US-ASCII");
-        } catch (UnsupportedEncodingException e) {
-            // US-ASCII is guaranteed to be available.
-            throw new AssertionError(e);
-        }
-    }
-
-    /**
-     * Base64-encode the given data and return a newly allocated
-     * String with the result.
-     *
-     * @param input  the data to encode
-     * @param offset the position within the input array at which to
-     *               start
-     * @param len    the number of bytes of input to encode
-     * @param flags  controls certain features of the encoded output.
-     *               Passing {@code DEFAULT} results in output that
-     *               adheres to RFC 2045.
-     */
-    public static String encodeToString(byte[] input, int offset, int len, int flags) {
-        try {
-            return new String(encode(input, offset, len, flags), "US-ASCII");
-        } catch (UnsupportedEncodingException e) {
-            // US-ASCII is guaranteed to be available.
-            throw new AssertionError(e);
-        }
-    }
-
-    /**
-     * Base64-encode the given data and return a newly allocated
-     * byte[] with the result.
-     *
-     * @param input  the data to encode
-     * @param flags  controls certain features of the encoded output.
-     *               Passing {@code DEFAULT} results in output that
-     *               adheres to RFC 2045.
-     */
-    public static byte[] encode(byte[] input, int flags) {
-        return encode(input, 0, input.length, flags);
-    }
-
-    /**
-     * Base64-encode the given data and return a newly allocated
-     * byte[] with the result.
-     *
-     * @param input  the data to encode
-     * @param offset the position within the input array at which to
-     *               start
-     * @param len    the number of bytes of input to encode
-     * @param flags  controls certain features of the encoded output.
-     *               Passing {@code DEFAULT} results in output that
-     *               adheres to RFC 2045.
-     */
-    public static byte[] encode(byte[] input, int offset, int len, int flags) {
-        Encoder encoder = new Encoder(flags, null);
-
-        // Compute the exact length of the array we will produce.
-        int output_len = len / 3 * 4;
-
-        // Account for the tail of the data and the padding bytes, if any.
-        if (encoder.do_padding) {
-            if (len % 3 > 0) {
-                output_len += 4;
-            }
-        } else {
-            switch (len % 3) {
-                case 0: break;
-                case 1: output_len += 2; break;
-                case 2: output_len += 3; break;
-            }
-        }
-
-        // Account for the newlines, if any.
-        if (encoder.do_newline && len > 0) {
-            output_len += (((len-1) / (3 * Encoder.LINE_GROUPS)) + 1) *
-                    (encoder.do_cr ? 2 : 1);
-        }
-
-        encoder.output = new byte[output_len];
-        encoder.process(input, offset, len, true);
-
-        assert encoder.op == output_len;
-
-        return encoder.output;
-    }
-
-    /* package */ static class Encoder extends Coder {
-        /**
-         * Emit a new line every this many output tuples.  Corresponds to
-         * a 76-character line length (the maximum allowable according to
-         * <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>).
-         */
-        public static final int LINE_GROUPS = 19;
-
-        /**
-         * Lookup table for turning Base64 alphabet positions (6 bits)
-         * into output bytes.
-         */
-        private static final byte ENCODE[] = {
-                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
-                'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
-                'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
-                'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/',
-        };
-
-        /**
-         * Lookup table for turning Base64 alphabet positions (6 bits)
-         * into output bytes.
-         */
-        private static final byte ENCODE_WEBSAFE[] = {
-                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
-                'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
-                'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
-                'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_',
-        };
-
-        final private byte[] tail;
-        /* package */ int tailLen;
-        private int count;
-
-        final public boolean do_padding;
-        final public boolean do_newline;
-        final public boolean do_cr;
-        final private byte[] alphabet;
-
-        public Encoder(int flags, byte[] output) {
-            this.output = output;
-
-            do_padding = (flags & NO_PADDING) == 0;
-            do_newline = (flags & NO_WRAP) == 0;
-            do_cr = (flags & CRLF) != 0;
-            alphabet = ((flags & URL_SAFE) == 0) ? ENCODE : ENCODE_WEBSAFE;
-
-            tail = new byte[2];
-            tailLen = 0;
-
-            count = do_newline ? LINE_GROUPS : -1;
-        }
-
-        /**
-         * @return an overestimate for the number of bytes {@code
-         * len} bytes could encode to.
-         */
-        public int maxOutputSize(int len) {
-            return len * 8/5 + 10;
-        }
-
-        public boolean process(byte[] input, int offset, int len, boolean finish) {
-            // Using local variables makes the encoder about 9% faster.
-            final byte[] alphabet = this.alphabet;
-            final byte[] output = this.output;
-            int op = 0;
-            int count = this.count;
-
-            int p = offset;
-            len += offset;
-            int v = -1;
-
-            // First we need to concatenate the tail of the previous call
-            // with any input bytes available now and see if we can empty
-            // the tail.
-
-            switch (tailLen) {
-                case 0:
-                    // There was no tail.
-                    break;
-
-                case 1:
-                    if (p+2 <= len) {
-                        // A 1-byte tail with at least 2 bytes of
-                        // input available now.
-                        v = ((tail[0] & 0xff) << 16) |
-                                ((input[p++] & 0xff) << 8) |
-                                (input[p++] & 0xff);
-                        tailLen = 0;
-                    };
-                    break;
-
-                case 2:
-                    if (p+1 <= len) {
-                        // A 2-byte tail with at least 1 byte of input.
-                        v = ((tail[0] & 0xff) << 16) |
-                                ((tail[1] & 0xff) << 8) |
-                                (input[p++] & 0xff);
-                        tailLen = 0;
-                    }
-                    break;
-            }
-
-            if (v != -1) {
-                output[op++] = alphabet[(v >> 18) & 0x3f];
-                output[op++] = alphabet[(v >> 12) & 0x3f];
-                output[op++] = alphabet[(v >> 6) & 0x3f];
-                output[op++] = alphabet[v & 0x3f];
-                if (--count == 0) {
-                    if (do_cr) output[op++] = '\r';
-                    output[op++] = '\n';
-                    count = LINE_GROUPS;
-                }
-            }
-
-            // At this point either there is no tail, or there are fewer
-            // than 3 bytes of input available.
-
-            // The main loop, turning 3 input bytes into 4 output bytes on
-            // each iteration.
-            while (p+3 <= len) {
-                v = ((input[p] & 0xff) << 16) |
-                        ((input[p+1] & 0xff) << 8) |
-                        (input[p+2] & 0xff);
-                output[op] = alphabet[(v >> 18) & 0x3f];
-                output[op+1] = alphabet[(v >> 12) & 0x3f];
-                output[op+2] = alphabet[(v >> 6) & 0x3f];
-                output[op+3] = alphabet[v & 0x3f];
-                p += 3;
-                op += 4;
-                if (--count == 0) {
-                    if (do_cr) output[op++] = '\r';
-                    output[op++] = '\n';
-                    count = LINE_GROUPS;
-                }
-            }
-
-            if (finish) {
-                // Finish up the tail of the input.  Note that we need to
-                // consume any bytes in tail before any bytes
-                // remaining in input; there should be at most two bytes
-                // total.
-
-                if (p-tailLen == len-1) {
-                    int t = 0;
-                    v = ((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 4;
-                    tailLen -= t;
-                    output[op++] = alphabet[(v >> 6) & 0x3f];
-                    output[op++] = alphabet[v & 0x3f];
-                    if (do_padding) {
-                        output[op++] = '=';
-                        output[op++] = '=';
-                    }
-                    if (do_newline) {
-                        if (do_cr) output[op++] = '\r';
-                        output[op++] = '\n';
-                    }
-                } else if (p-tailLen == len-2) {
-                    int t = 0;
-                    v = (((tailLen > 1 ? tail[t++] : input[p++]) & 0xff) << 10) |
-                            (((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 2);
-                    tailLen -= t;
-                    output[op++] = alphabet[(v >> 12) & 0x3f];
-                    output[op++] = alphabet[(v >> 6) & 0x3f];
-                    output[op++] = alphabet[v & 0x3f];
-                    if (do_padding) {
-                        output[op++] = '=';
-                    }
-                    if (do_newline) {
-                        if (do_cr) output[op++] = '\r';
-                        output[op++] = '\n';
-                    }
-                } else if (do_newline && op > 0 && count != LINE_GROUPS) {
-                    if (do_cr) output[op++] = '\r';
-                    output[op++] = '\n';
-                }
-
-                assert tailLen == 0;
-                assert p == len;
-            } else {
-                // Save the leftovers in tail to be consumed on the next
-                // call to encodeInternal.
-
-                if (p == len-1) {
-                    tail[tailLen++] = input[p];
-                } else if (p == len-2) {
-                    tail[tailLen++] = input[p];
-                    tail[tailLen++] = input[p+1];
-                }
-            }
-
-            this.op = op;
-            this.count = count;
-
-            return true;
-        }
-    }
-
-    private Base64() { }   // don't instantiate
-}
\ No newline at end of file
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/Interstitials.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/Interstitials.java
deleted file mode 100644
index a4e4d384..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/Interstitials.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package com.mopub.mobileads.util;
-
-import android.graphics.Color;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.Button;
-
-public class Interstitials {
-    private Interstitials(){}
-
-    public static boolean addCloseEventRegion(final ViewGroup viewGroup, final ViewGroup.LayoutParams layoutParams, final View.OnClickListener onClickListener) {
-        if (viewGroup == null || viewGroup.getContext() == null) {
-            return false;
-        }
-
-        // An area of the screen that will always lead to an expanded MRAID ad collapsing.
-        final Button closeEventRegion = new Button(viewGroup.getContext());
-        closeEventRegion.setVisibility(View.VISIBLE);
-        closeEventRegion.setBackgroundColor(Color.TRANSPARENT);
-        closeEventRegion.setOnClickListener(onClickListener);
-
-        viewGroup.addView(closeEventRegion, layoutParams);
-
-        return true;
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/Mraids.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/Mraids.java
deleted file mode 100644
index da58d1f5..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/Mraids.java
+++ /dev/null
@@ -1,50 +0,0 @@
-package com.mopub.mobileads.util;
-
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.net.Uri;
-import android.os.Environment;
-
-import com.mopub.common.util.IntentUtils;
-import com.mopub.common.util.VersionCode;
-import com.mopub.mobileads.MraidVideoPlayerActivity;
-
-import static android.Manifest.permission.WRITE_EXTERNAL_STORAGE;
-import static android.os.Environment.MEDIA_MOUNTED;
-
-public class Mraids {
-    public static final String ANDROID_CALENDAR_CONTENT_TYPE = "vnd.android.cursor.item/event";
-
-    public static boolean isTelAvailable(Context context) {
-        Intent telIntent = new Intent(Intent.ACTION_DIAL);
-        telIntent.setData(Uri.parse("tel:"));
-
-        return IntentUtils.deviceCanHandleIntent(context, telIntent);
-    }
-
-    public static boolean isSmsAvailable(Context context) {
-        Intent smsIntent = new Intent(Intent.ACTION_VIEW);
-        smsIntent.setData(Uri.parse("sms:"));
-
-        return IntentUtils.deviceCanHandleIntent(context, smsIntent);
-    }
-
-    public static boolean isStorePictureSupported(Context context) {
-        return MEDIA_MOUNTED.equals(Environment.getExternalStorageState())
-                && context.checkCallingOrSelfPermission(WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED;
-    }
-
-    public static boolean isCalendarAvailable(Context context) {
-        Intent calendarIntent = new Intent(Intent.ACTION_INSERT).setType(ANDROID_CALENDAR_CONTENT_TYPE);
-
-        return VersionCode.currentApiLevel().isAtLeast(VersionCode.ICE_CREAM_SANDWICH)
-                && IntentUtils.deviceCanHandleIntent(context, calendarIntent);
-    }
-
-    public static boolean isInlineVideoAvailable(Context context) {
-        Intent mraidVideoIntent = new Intent(context, MraidVideoPlayerActivity.class);
-
-        return IntentUtils.deviceCanHandleIntent(context, mraidVideoIntent);
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/Utils.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/Utils.java
deleted file mode 100644
index d96476f4..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/Utils.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package com.mopub.mobileads.util;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-
-import com.mopub.common.logging.MoPubLog;
-
-public class Utils {
-    private Utils() {}
-
-    public static boolean executeIntent(Context context, Intent intent, String errorMessage) {
-        try {
-            if (!(context instanceof Activity)) {
-                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-            }
-            context.startActivity(intent);
-        } catch (Exception e) {
-            MoPubLog.d((errorMessage != null)
-                    ? errorMessage
-                    : "Unable to start intent.");
-            return false;
-        }
-        return true;
-    }
-}
\ No newline at end of file
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/WebViews.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/WebViews.java
index f368ccd3..57eb0f0c 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/WebViews.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/util/WebViews.java
@@ -1,33 +1,55 @@
 package com.mopub.mobileads.util;
 
-import android.util.Log;
+import android.annotation.TargetApi;
+import android.os.Build.VERSION;
+import android.os.Build.VERSION_CODES;
+import android.support.annotation.NonNull;
 import android.webkit.JsPromptResult;
 import android.webkit.JsResult;
 import android.webkit.WebChromeClient;
 import android.webkit.WebView;
 
-import java.lang.reflect.Method;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Reflection.MethodBuilder;
 
 public class WebViews {
-    private static final String LOGTAG = "MoPub - WebViewsUtil";
+    @TargetApi(VERSION_CODES.HONEYCOMB)
+    public static void onResume(@NonNull WebView webView) {
+        if (VERSION.SDK_INT >= VERSION_CODES.HONEYCOMB) {
+            webView.onResume();
+            return;
+        }
 
-    public static void onPause(WebView webView) {
+        // Method is still available, but hidden. Invoke using reflection.
         try {
-            Method onPause = WebView.class.getDeclaredMethod("onPause");
-            onPause.invoke(webView);
+            new MethodBuilder(webView, "onResume").setAccessible().execute();
         } catch (Exception e) {
-            // can't call this before API level 11
-            return;
+            // no-op
         }
     }
 
-    public static void onResume(WebView webView) {
+    @TargetApi(VERSION_CODES.HONEYCOMB)
+    public static void onPause(@NonNull WebView webView, boolean isFinishing) {
+        // XXX
+        // We need to call WebView#stopLoading and WebView#loadUrl here due to an Android
+        // bug where the audio of an HTML5 video will continue to play after the activity has been
+        // destroyed. The web view must stop then load an invalid url during the onPause lifecycle
+        // event in order to stop the audio.
+        if (isFinishing) {
+            webView.stopLoading();
+            webView.loadUrl("");
+        }
+
+        if (VERSION.SDK_INT >= VERSION_CODES.HONEYCOMB) {
+            webView.onPause();
+            return;
+        }
+
+        // Method is still available, but hidden. Invoke using reflection.
         try {
-            Method onResume = WebView.class.getDeclaredMethod("onResume");
-            onResume.invoke(webView);
+            new MethodBuilder(webView, "onPause").setAccessible().execute();
         } catch (Exception e) {
-            // can't call this before API level 11
-            return;
+            // no-op
         }
     }
 
@@ -35,25 +57,29 @@ public static void setDisableJSChromeClient(WebView webView) {
         webView.setWebChromeClient(new WebChromeClient() {
             @Override
             public boolean onJsAlert(WebView view, String url, String message, JsResult result) {
-                Log.d(LOGTAG, message);
+                MoPubLog.d(message);
+                result.confirm();
                 return true;
             }
 
             @Override
             public boolean onJsConfirm(WebView view, String url, String message, JsResult result) {
-                Log.d(LOGTAG, message);
+                MoPubLog.d(message);
+                result.confirm();
                 return true;
             }
 
             @Override
             public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) {
-                Log.d(LOGTAG, message);
+                MoPubLog.d(message);
+                result.confirm();
                 return true;
             }
 
             @Override
             public boolean onJsBeforeUnload(WebView view, String url, String message, JsResult result) {
-                Log.d(LOGTAG, message);
+                MoPubLog.d(message);
+                result.confirm();
                 return true;
             }
         });
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastManager.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastManager.java
index ab6c0dce..c396547f 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastManager.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastManager.java
@@ -3,12 +3,16 @@
 import android.content.Context;
 import android.view.Display;
 import android.view.WindowManager;
+
 import com.mopub.common.CacheService;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.util.AsyncTasks;
 import com.mopub.mobileads.VastVideoDownloadTask;
 
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.List;
 
 import static com.mopub.mobileads.VastVideoDownloadTask.VastVideoDownloadTaskListener;
 import static com.mopub.mobileads.util.vast.VastXmlManagerAggregator.VastXmlManagerAggregatorListener;
@@ -44,10 +48,7 @@ public void prepareVastVideoConfiguration(final String vastXml, final VastManage
                 AsyncTasks.safeExecuteOnExecutor(mVastXmlManagerAggregator, vastXml);
             } catch (Exception e) {
                 MoPubLog.d("Failed to aggregate vast xml", e);
-
-                if (mVastManagerListener != null) {
-                    mVastManagerListener.onVastVideoConfigurationPrepared(null);
-                }
+                mVastManagerListener.onVastVideoConfigurationPrepared(null);
             }
         }
     }
@@ -63,9 +64,7 @@ public void cancel() {
     public void onAggregationComplete(final List<VastXmlManager> vastXmlManagers) {
         mVastXmlManagerAggregator = null;
         if (vastXmlManagers == null) {
-            if (mVastManagerListener != null) {
-                mVastManagerListener.onVastVideoConfigurationPrepared(null);
-            }
+            mVastManagerListener.onVastVideoConfigurationPrepared(null);
             return;
         }
 
@@ -73,9 +72,7 @@ public void onAggregationComplete(final List<VastXmlManager> vastXmlManagers) {
                 createVastVideoConfigurationFromXml(vastXmlManagers);
 
         if (updateDiskMediaFileUrl(vastVideoConfiguration)) {
-            if (mVastManagerListener != null) {
-                mVastManagerListener.onVastVideoConfigurationPrepared(vastVideoConfiguration);
-            }
+            mVastManagerListener.onVastVideoConfigurationPrepared(vastVideoConfiguration);
             return;
         }
 
@@ -84,13 +81,9 @@ public void onAggregationComplete(final List<VastXmlManager> vastXmlManagers) {
                     @Override
                     public void onComplete(boolean success) {
                         if (success && updateDiskMediaFileUrl(vastVideoConfiguration)) {
-                            if (mVastManagerListener != null) {
-                                mVastManagerListener.onVastVideoConfigurationPrepared(vastVideoConfiguration);
-                            }
+                            mVastManagerListener.onVastVideoConfigurationPrepared(vastVideoConfiguration);
                         } else {
-                            if (mVastManagerListener != null) {
-                                mVastManagerListener.onVastVideoConfigurationPrepared(null);
-                            }
+                            mVastManagerListener.onVastVideoConfigurationPrepared(null);
                         }
                     }
                 }
@@ -103,10 +96,7 @@ public void onComplete(boolean success) {
             );
         } catch (Exception e) {
             MoPubLog.d("Failed to download vast video", e);
-
-            if (mVastManagerListener != null) {
-                mVastManagerListener.onVastVideoConfigurationPrepared(null);
-            }
+            mVastManagerListener.onVastVideoConfigurationPrepared(null);
         }
     }
 
@@ -140,12 +130,11 @@ private VastVideoConfiguration createVastVideoConfigurationFromXml(final List<Va
         final List<VastXmlManager.ImageCompanionAdXmlManager> companionXmlManagers = new ArrayList<VastXmlManager.ImageCompanionAdXmlManager>();
         for (VastXmlManager xmlManager : xmlManagers) {
             vastVideoConfiguration.addImpressionTrackers(xmlManager.getImpressionTrackers());
-
-            vastVideoConfiguration.addStartTrackers(xmlManager.getVideoStartTrackers());
-            vastVideoConfiguration.addFirstQuartileTrackers(xmlManager.getVideoFirstQuartileTrackers());
-            vastVideoConfiguration.addMidpointTrackers(xmlManager.getVideoMidpointTrackers());
-            vastVideoConfiguration.addThirdQuartileTrackers(xmlManager.getVideoThirdQuartileTrackers());
+            vastVideoConfiguration.addAbsoluteTrackers(xmlManager.getAbsoluteProgressTrackers());
+            vastVideoConfiguration.addFractionalTrackers(xmlManager.getFractionalProgressTrackers());
             vastVideoConfiguration.addCompleteTrackers(xmlManager.getVideoCompleteTrackers());
+            vastVideoConfiguration.addCloseTrackers(xmlManager.getVideoCloseTrackers());
+            vastVideoConfiguration.addSkipTrackers(xmlManager.getVideoSkipTrackers());
 
             vastVideoConfiguration.addClickTrackers(xmlManager.getClickTrackers());
 
@@ -155,6 +144,13 @@ private VastVideoConfiguration createVastVideoConfigurationFromXml(final List<Va
 
             mediaXmlManagers.addAll(xmlManager.getMediaXmlManagers());
             companionXmlManagers.addAll(xmlManager.getCompanionAdXmlManagers());
+
+            // Load custom extensions
+            vastVideoConfiguration.setCustomCtaText(xmlManager.getCustomCtaText());
+            vastVideoConfiguration.setCustomSkipText(xmlManager.getCustomSkipText());
+            vastVideoConfiguration.setCustomCloseIconUrl(xmlManager.getCustomCloseIconUrl());
+            vastVideoConfiguration.setCustomForceOrientation(xmlManager.getCustomForceOrientation());
+            vastVideoConfiguration.setSkipOffset(xmlManager.getSkipOffset());
         }
 
         vastVideoConfiguration.setNetworkMediaFileUrl(getBestMediaFileUrl(mediaXmlManagers));
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastVideoConfiguration.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastVideoConfiguration.java
index aeae8b9f..ef638cd9 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastVideoConfiguration.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastVideoConfiguration.java
@@ -1,31 +1,45 @@
 package com.mopub.mobileads.util.vast;
 
+import android.support.annotation.Nullable;
+
+import com.mopub.common.util.DeviceUtils;
+import com.mopub.mobileads.VastAbsoluteProgressTracker;
+import com.mopub.mobileads.VastFractionalProgressTracker;
+
 import java.io.Serializable;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 public class VastVideoConfiguration implements Serializable {
-    private static final long serialVersionUID = 0L;
-
-    private ArrayList<String> mImpressionTrackers;
-    private ArrayList<String> mStartTrackers;
-    private ArrayList<String> mFirstQuartileTrackers;
-    private ArrayList<String> mMidpointTrackers;
-    private ArrayList<String> mThirdQuartileTrackers;
-    private ArrayList<String> mCompleteTrackers;
-    private ArrayList<String> mClickTrackers;
+    private static final long serialVersionUID = 1L;
+
+    private final ArrayList<String> mImpressionTrackers;
+    private final ArrayList<VastFractionalProgressTracker> mFractionalTrackers;
+    private final ArrayList<VastAbsoluteProgressTracker> mAbsoluteTrackers;
+    private final ArrayList<String> mCompleteTrackers;
+    private final ArrayList<String> mCloseTrackers;
+    private final ArrayList<String> mSkipTrackers;
+    private final ArrayList<String> mClickTrackers;
     private String mClickThroughUrl;
     private String mNetworkMediaFileUrl;
     private String mDiskMediaFileUrl;
+    private String mSkipOffset;
     private VastCompanionAd mVastCompanionAd;
 
+    // Custom extensions
+    private String mCustomCtaText;
+    private String mCustomSkipText;
+    private String mCustomCloseIconUrl;
+    private DeviceUtils.ForceOrientation mCustomForceOrientation = DeviceUtils.ForceOrientation.FORCE_LANDSCAPE; // Default is forcing landscape
+
     public VastVideoConfiguration() {
         mImpressionTrackers = new ArrayList<String>();
-        mStartTrackers = new ArrayList<String>();
-        mFirstQuartileTrackers = new ArrayList<String>();
-        mMidpointTrackers = new ArrayList<String>();
-        mThirdQuartileTrackers = new ArrayList<String>();
+        mFractionalTrackers = new ArrayList<VastFractionalProgressTracker>();
+        mAbsoluteTrackers = new ArrayList<VastAbsoluteProgressTracker>();
         mCompleteTrackers = new ArrayList<String>();
+        mCloseTrackers = new ArrayList<String>();
+        mSkipTrackers = new ArrayList<String>();
         mClickTrackers = new ArrayList<String>();
     }
 
@@ -37,24 +51,33 @@ public void addImpressionTrackers(final List<String> impressionTrackers) {
         mImpressionTrackers.addAll(impressionTrackers);
     }
 
-    public void addStartTrackers(final List<String> startTrackers) {
-        mStartTrackers.addAll(startTrackers);
+    /**
+     * Add trackers for percentage-based tracking. This includes all quartile trackers and any
+     * "progress" events with other percentages.
+     */
+    public void addFractionalTrackers(final List<VastFractionalProgressTracker> fractionalTrackers) {
+        mFractionalTrackers.addAll(fractionalTrackers);
+        Collections.sort(mFractionalTrackers);
     }
 
-    public void addFirstQuartileTrackers(final List<String> firstQuartileTrackers) {
-        mFirstQuartileTrackers.addAll(firstQuartileTrackers);
+    /**
+     * Add trackers for absolute tracking. This includes start trackers, which have an absolute threshold of 2 seconds.
+     */
+    public void addAbsoluteTrackers(final List<VastAbsoluteProgressTracker> absoluteTrackers) {
+        mAbsoluteTrackers.addAll(absoluteTrackers);
+        Collections.sort(mAbsoluteTrackers);
     }
 
-    public void addMidpointTrackers(final List<String> midpointTrackers) {
-        mMidpointTrackers.addAll(midpointTrackers);
+    public void addCompleteTrackers(final List<String> completeTrackers) {
+        mCompleteTrackers.addAll(completeTrackers);
     }
 
-    public void addThirdQuartileTrackers(final List<String> thirdQuartileTrackers) {
-        mThirdQuartileTrackers.addAll(thirdQuartileTrackers);
+    public void addCloseTrackers(final List<String> closeTrackers) {
+        mCloseTrackers.addAll(closeTrackers);
     }
 
-    public void addCompleteTrackers(final List<String> completeTrackers) {
-        mCompleteTrackers.addAll(completeTrackers);
+    public void addSkipTrackers(final List<String> skipTrackers) {
+        mSkipTrackers.addAll(skipTrackers);
     }
 
     public void addClickTrackers(final List<String> clickTrackers) {
@@ -77,6 +100,36 @@ public void setVastCompanionAd(final VastCompanionAd vastCompanionAd) {
         mVastCompanionAd = vastCompanionAd;
     }
 
+    public void setCustomCtaText(@Nullable final String customCtaText) {
+        if (customCtaText != null) {
+            mCustomCtaText = customCtaText;
+        }
+    }
+
+    public void setCustomSkipText(@Nullable final String customSkipText) {
+        if (customSkipText != null) {
+            mCustomSkipText = customSkipText;
+        }
+    }
+
+    public void setCustomCloseIconUrl(@Nullable final String customCloseIconUrl) {
+        if (customCloseIconUrl != null) {
+            mCustomCloseIconUrl = customCloseIconUrl;
+        }
+    }
+
+    public void setCustomForceOrientation(@Nullable final DeviceUtils.ForceOrientation customForceOrientation) {
+        if (customForceOrientation != null && customForceOrientation != DeviceUtils.ForceOrientation.UNDEFINED) {
+            mCustomForceOrientation = customForceOrientation;
+        }
+    }
+
+    public void setSkipOffset(@Nullable final String skipOffset) {
+        if (skipOffset != null) {
+            mSkipOffset = skipOffset;
+        }
+    }
+
     /**
      * Getters
      */
@@ -85,24 +138,24 @@ public void setVastCompanionAd(final VastCompanionAd vastCompanionAd) {
         return mImpressionTrackers;
     }
 
-    public List<String> getStartTrackers() {
-        return mStartTrackers;
+    public ArrayList<VastAbsoluteProgressTracker> getAbsoluteTrackers() {
+        return mAbsoluteTrackers;
     }
 
-    public List<String> getFirstQuartileTrackers() {
-        return mFirstQuartileTrackers;
+    public ArrayList<VastFractionalProgressTracker> getFractionalTrackers() {
+        return mFractionalTrackers;
     }
 
-    public List<String> getMidpointTrackers() {
-        return mMidpointTrackers;
+    public List<String> getCompleteTrackers() {
+        return mCompleteTrackers;
     }
 
-    public List<String> getThirdQuartileTrackers() {
-        return mThirdQuartileTrackers;
+    public List<String> getCloseTrackers() {
+        return mCloseTrackers;
     }
 
-    public List<String> getCompleteTrackers() {
-        return mCompleteTrackers;
+    public List<String> getSkipTrackers() {
+        return mSkipTrackers;
     }
 
     public List<String> getClickTrackers() {
@@ -124,4 +177,28 @@ public String getDiskMediaFileUrl() {
     public VastCompanionAd getVastCompanionAd() {
         return mVastCompanionAd;
     }
+
+    public String getCustomCtaText() {
+        return mCustomCtaText;
+    }
+
+    public String getCustomSkipText() {
+        return mCustomSkipText;
+    }
+
+    public String getCustomCloseIconUrl() {
+        return mCustomCloseIconUrl;
+    }
+
+    /**
+     * Get custom force orientation
+     * @return ForceOrientation enum (default is FORCE_LANDSCAPE)
+     */
+    public DeviceUtils.ForceOrientation getCustomForceOrientation() {
+        return mCustomForceOrientation;
+    }
+
+    public String getSkipOffset() {
+        return mSkipOffset;
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastXmlManager.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastXmlManager.java
index 8b098a7d..299288ed 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastXmlManager.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastXmlManager.java
@@ -1,16 +1,30 @@
 package com.mopub.mobileads.util.vast;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.DeviceUtils.ForceOrientation;
+import com.mopub.common.util.Strings;
+import com.mopub.mobileads.VastAbsoluteProgressTracker;
+import com.mopub.mobileads.VastFractionalProgressTracker;
+
 import org.w3c.dom.Document;
 import org.w3c.dom.Node;
 import org.w3c.dom.NodeList;
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
 
+import java.io.IOException;
+import java.io.StringReader;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
 import javax.xml.parsers.DocumentBuilder;
 import javax.xml.parsers.DocumentBuilderFactory;
 import javax.xml.parsers.ParserConfigurationException;
-import java.io.*;
-import java.util.*;
 
 class VastXmlManager {
     private static final String ROOT_TAG = "MPMoVideoXMLDocRoot";
@@ -26,18 +40,40 @@
     private static final String VAST_AD_TAG = "VASTAdTagURI";
     private static final String MP_IMPRESSION_TRACKER = "MP_TRACKING_URL";
     private static final String COMPANION = "Companion";
+    private static final String LINEAR = "Linear";
+
+    // Custom element names for VAST 3.0 extensions
+    private static final String CUSTOM_CTA_TEXT = "MoPubCtaText";
+    private static final String CUSTOM_SKIP_TEXT = "MoPubSkipText";
+    private static final String CUSTOM_CLOSE_ICON = "MoPubCloseIcon";
+    private static final String CUSTOM_FORCE_ORIENTATION = "MoPubForceOrientation";
 
     // Attribute names
     private static final String EVENT = "event";
     private static final String WIDTH = "width";
     private static final String HEIGHT = "height";
+    private static final String OFFSET = "offset";
+    private static final String SKIP_OFFSET = "skipoffset";
 
-    // Attibute values
+    // Event Attribute values
     private static final String START = "start";
     private static final String FIRST_QUARTILE = "firstQuartile";
     private static final String MIDPOINT = "midpoint";
     private static final String THIRD_QUARTILE = "thirdQuartile";
     private static final String COMPLETE = "complete";
+    private static final String CLOSE = "close";
+    private static final String PROGRESS = "progress";
+    private static final String SKIP = "skip";
+
+    private static final int START_TRACKER_THRESHOLD = 2000;
+    private static final float FIRST_QUARTER_MARKER = 0.25f;
+    private static final float MID_POINT_MARKER = 0.50f;
+    private static final float THIRD_QUARTER_MARKER = 0.75f;
+
+    // constants for custom extensions
+    private static final int MAX_CTA_TEXT_LENGTH = 15;
+    private static final int MAX_SKIP_TEXT_LENGTH = 8;
+
 
     // This class currently assumes an image type companion ad since that is what we are supporting
     class ImageCompanionAdXmlManager {
@@ -181,29 +217,114 @@ String getVastAdTagURI() {
         return impressionTrackers;
     }
 
-    List<String> getVideoStartTrackers() {
-        return getVideoTrackerByAttribute(START);
-    }
+    /**
+     * Return a sorted list of the video's percent-based progress-trackers. These are the
+     * quartile trackers and any "progress" nodes with percent-based offsets.
+     *
+     * Quartile trackers look like:
+     * {@code
+     * <Tracking event="firstQuartile">
+     *     <![CDATA[trackingURL]]>
+     * </Tracking>
+     * }
+     *
+     * Percent-based progress trackers look like:
+     * {@code
+     * <Tracking event="progress" offset="11%">
+     *     <![CDATA[trackingURL]]>
+     * </Tracking>
+     * }
+     */
+    @NonNull
+    List<VastFractionalProgressTracker> getFractionalProgressTrackers() {
+        // Add all the quartile trackers from VAST 2.0:
+        List<VastFractionalProgressTracker> percentTrackers = new ArrayList<VastFractionalProgressTracker>();
+        addQuartileTrackerWithFraction(percentTrackers, getVideoTrackerByAttribute(FIRST_QUARTILE), FIRST_QUARTER_MARKER);
+        addQuartileTrackerWithFraction(percentTrackers, getVideoTrackerByAttribute(MIDPOINT), MID_POINT_MARKER);
+        addQuartileTrackerWithFraction(percentTrackers, getVideoTrackerByAttribute(THIRD_QUARTILE), THIRD_QUARTER_MARKER);
+
+        // Get any other trackers with event="progress" offset="n%"
+        final List<Node> progressNodes = XmlUtils.getNodesWithElementAndAttribute(mVastDoc, VIDEO_TRACKER, EVENT, PROGRESS);
+        for (Node progressNode : progressNodes) {
+            final String offsetString = XmlUtils.getAttributeValue(progressNode, OFFSET).trim();
+            if (Strings.isPercentageTracker(offsetString)) {
+                String trackingUrl = XmlUtils.getNodeValue(progressNode).trim();
+                try {
+                    float trackingFraction = Float.parseFloat(offsetString.replace("%", "")) / 100f;
+                    percentTrackers.add(new VastFractionalProgressTracker(trackingUrl, trackingFraction));
+                } catch (NumberFormatException e) {
+                    MoPubLog.d(String.format("Failed to parse VAST progress tracker %s", offsetString));
+                }
+            }
+        }
 
-    List<String> getVideoFirstQuartileTrackers() {
-        return getVideoTrackerByAttribute(FIRST_QUARTILE);
+        // Sort the list so we can quickly index it in the video progress runnable.
+        Collections.sort(percentTrackers);
+        return percentTrackers;
     }
 
-    List<String> getVideoMidpointTrackers() {
-        return getVideoTrackerByAttribute(MIDPOINT);
-    }
+    /**
+     * Return a sorted list of the video's absolute progress trackers. This includes start trackers
+     * and any "progress" nodes with absolute offsets.
+     *
+     * Start trackers live in nodes like:
+     * {@code
+     * <Tracking event="start">
+     *     <![CDATA[trackingURL]]>
+     * </Tracking>
+     * }
+     * Absolute progress trackers look like:
+     * {@code
+     * <Tracking event="progress" offset="00:00:10.000">
+     *     <![CDATA[trackingURL]]>
+     * </Tracking>
+     * }
+     */
+    @NonNull
+    List<VastAbsoluteProgressTracker> getAbsoluteProgressTrackers() {
+        List<VastAbsoluteProgressTracker> trackers = new ArrayList<VastAbsoluteProgressTracker>();
+        // Start trackers are treated as absolute trackers with a 2s offset.
+        final List<String> startTrackers = getVideoTrackerByAttribute(START);
+        for (String url : startTrackers) {
+            trackers.add(new VastAbsoluteProgressTracker(url, START_TRACKER_THRESHOLD));
+        }
+
+        // Parse progress trackers and extract the absolute offsets of the form "HH:MM:SS[.mmm]"
+        final List<Node> progressNodes = XmlUtils.getNodesWithElementAndAttribute(mVastDoc, VIDEO_TRACKER, EVENT, PROGRESS);
+        for (Node progressNode : progressNodes) {
+            final String offSetString = XmlUtils.getAttributeValue(progressNode, OFFSET).trim();
+            if (Strings.isAbsoluteTracker(offSetString)) {
+                String trackingUrl = XmlUtils.getNodeValue(progressNode).trim();
+                try {
+                    Integer trackingMilliseconds = Strings.parseAbsoluteOffset(offSetString);
+                    if (trackingMilliseconds != null) {
+                        trackers.add(new VastAbsoluteProgressTracker(trackingUrl, trackingMilliseconds));
+                    }
+                } catch (NumberFormatException e) {
+                    MoPubLog.d(String.format("Failed to parse VAST progress tracker %s", offSetString));
+                }
+            }
+        }
 
-    List<String> getVideoThirdQuartileTrackers() {
-        return getVideoTrackerByAttribute(THIRD_QUARTILE);
+        // Sort the list so we can quickly index it in the video progress runnable.
+        Collections.sort(trackers);
+        return trackers;
     }
 
     List<String> getVideoCompleteTrackers() {
         return getVideoTrackerByAttribute(COMPLETE);
     }
 
+    List<String> getVideoCloseTrackers() {
+        return getVideoTrackerByAttribute(CLOSE);
+    }
+
+    List<String> getVideoSkipTrackers() {
+        return getVideoTrackerByAttribute(SKIP);
+    }
+
     String getClickThroughUrl() {
-        List<String> clickUrlWrapper = XmlUtils.getStringDataAsList(mVastDoc, CLICK_THROUGH);
-        return (clickUrlWrapper.size() > 0) ? clickUrlWrapper.get(0) : null;
+        return XmlUtils.getFirstMatchingStringData(mVastDoc, CLICK_THROUGH);
     }
 
     List<String> getClickTrackers() {
@@ -211,8 +332,58 @@ String getClickThroughUrl() {
     }
 
     String getMediaFileUrl() {
-        List<String> urlWrapper = XmlUtils.getStringDataAsList(mVastDoc, MEDIA_FILE);
-        return (urlWrapper.size() > 0) ? urlWrapper.get(0) : null;
+        return XmlUtils.getFirstMatchingStringData(mVastDoc, MEDIA_FILE);
+    }
+
+    @Nullable
+    String getCustomCtaText() {
+        String customCtaText = XmlUtils.getFirstMatchingStringData(mVastDoc, CUSTOM_CTA_TEXT);
+        if (customCtaText != null && customCtaText.length() <= MAX_CTA_TEXT_LENGTH) {
+            return customCtaText;
+        }
+
+        return null;
+    }
+
+    @Nullable
+    String getCustomSkipText() {
+        String customSkipText = XmlUtils.getFirstMatchingStringData(mVastDoc, CUSTOM_SKIP_TEXT);
+        if (customSkipText != null && customSkipText.length() <= MAX_SKIP_TEXT_LENGTH) {
+            return customSkipText;
+        }
+
+        return null;
+    }
+
+    @Nullable
+    String getCustomCloseIconUrl() {
+        return XmlUtils.getFirstMatchingStringData(mVastDoc, CUSTOM_CLOSE_ICON);
+    }
+
+    @NonNull
+    ForceOrientation getCustomForceOrientation() {
+        return ForceOrientation.getForceOrientation(
+                XmlUtils.getFirstMatchingStringData(mVastDoc, CUSTOM_FORCE_ORIENTATION));
+    }
+
+    @Nullable
+    String getSkipOffset() {
+        List<Node> linearNodeWrapper = XmlUtils.getNodesWithElementAndAttribute(mVastDoc, LINEAR, SKIP_OFFSET, null);
+        Node linearNode = (linearNodeWrapper.isEmpty()) ? null : linearNodeWrapper.get(0);
+        if (linearNode == null) {
+            return null;
+        }
+
+        final String skipOffsetString = XmlUtils.getAttributeValue(linearNode, SKIP_OFFSET);
+        if (skipOffsetString == null) {
+            return null;
+        }
+
+        if (skipOffsetString.trim().isEmpty()) {
+            return null;
+        }
+
+        return skipOffsetString.trim();
     }
 
     List<MediaXmlManager> getMediaXmlManagers() {
@@ -238,4 +409,10 @@ String getMediaFileUrl() {
     private List<String> getVideoTrackerByAttribute(final String attributeValue) {
         return XmlUtils.getStringDataAsList(mVastDoc, VIDEO_TRACKER, EVENT, attributeValue);
     }
+
+    private void addQuartileTrackerWithFraction(List<VastFractionalProgressTracker> trackers, List<String> urls, float fraction) {
+        for (String url : urls) {
+            trackers.add(new VastFractionalProgressTracker(url, fraction));
+        }
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastXmlManagerAggregator.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastXmlManagerAggregator.java
index e9d377ed..9248a3e8 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastXmlManagerAggregator.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastXmlManagerAggregator.java
@@ -79,7 +79,7 @@ String followVastRedirect(final AndroidHttpClient httpClient, final String redir
         if (redirectUrl != null && mTimesFollowedVastRedirect < MAX_TIMES_TO_FOLLOW_VAST_REDIRECT) {
             mTimesFollowedVastRedirect++;
 
-            final HttpGet httpget = new HttpGet(redirectUrl);
+            final HttpGet httpget = HttpClient.initializeHttpGet(redirectUrl);
             final HttpResponse response = httpClient.execute(httpget);
             final HttpEntity entity = response.getEntity();
             return (entity != null) ? Strings.fromStream(entity.getContent()) : null;
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/XmlUtils.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/XmlUtils.java
index 79e92584..9a69d13d 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/XmlUtils.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/XmlUtils.java
@@ -12,11 +12,30 @@
 class XmlUtils {
     private XmlUtils() {}
 
+    /**
+     * Gets the first direct child of the given node with a node named {@code nodeName}.
+     *
+     * Only direct children are checked.
+     */
     static Node getFirstMatchingChildNode(final Node node, final String nodeName) {
         return getFirstMatchingChildNode(node, nodeName, null, null);
     }
 
-    static Node getFirstMatchingChildNode(final Node node, final String nodeName, final String attributeName, final List<String> attributeValues) {
+    /**
+     * Gets the first direct child of the given node with a node named {@code nodeName} that has an
+     * attribute named {@code attributeName} with a value that matches one of {@code attributeValues}.
+     *
+     * Only direct children are checked.
+     *
+     * @param nodeName matching nodes must have this name.
+     * @param attributeName matching nodes must have an attribute with this name.
+     *                      Use null to match nodes with any attributes.
+     * @param attributeValues all matching child nodes' matching attribute will have a value that
+     *                        matches one of these values. Use null to match nodes with any attribute
+     *                        value.
+     */
+    static Node getFirstMatchingChildNode(final Node node, final String nodeName,
+            final String attributeName, final List<String> attributeValues) {
         if (node == null || nodeName == null) {
             return null;
         }
@@ -28,7 +47,21 @@ static Node getFirstMatchingChildNode(final Node node, final String nodeName, fi
         return null;
     }
 
-    static List<Node> getMatchingChildNodes(final Node node, final String nodeName, final String attributeName, final List<String> attributeValues) {
+    /**
+     * Return children of the {@code node} parameter with a matching {@code nodeName} &
+     * {@code attributeName} that matches at least one of the passed-in {@code attributeValues}.
+     * If {@code attributeValues} is empty, no nodes will match. To match names only,
+     * pass null for both {@code attributeName} and {@code attributeValues}.
+     *
+     * @param node the root node to look beneath.
+     * @param nodeName all child nodes will match this element.
+     * @param attributeName all matching child nodes will have an attribute of this name.
+     * @param attributeValues all matching child nodes' matching attribute will have a value that
+     *                        matches one of these values.
+     * @return child nodes that match all parameters
+     */
+    static List<Node> getMatchingChildNodes(final Node node, final String nodeName,
+            final String attributeName, final List<String> attributeValues) {
         if (node == null || nodeName == null) {
             return null;
         }
@@ -45,6 +78,10 @@ static Node getFirstMatchingChildNode(final Node node, final String nodeName, fi
         return nodes;
     }
 
+    /**
+     * Returns {@code true} iff the node has the attribute {@code attributeName} with a value that
+     * matches one of {@code attributeValues}.
+     */
     static boolean nodeMatchesAttributeFilter(final Node node, final String attributeName, final List<String> attributeValues) {
         if (attributeName == null || attributeValues == null) {
             return true;
@@ -95,35 +132,124 @@ static String getAttributeValue(final Node node, final String attributeName) {
         return null;
     }
 
-    static List<String> getStringDataAsList(final Document vastDoc, final String elementName) {
-        return getStringDataAsList(vastDoc, elementName, null, null);
-    }
-
-    static List<String> getStringDataAsList(final Document vastDoc, final String elementName, final String attributeName, final String attributeValue) {
-        final ArrayList<String> results = new ArrayList<String>();
+    /**
+     * Get a list of data from a {@code Document]'s elements that match the {@code elementName},
+     * {@code attributeName}, and {@code attributeValue} filters. Each node that matches these is
+     * processed by the {@code nodeProcessor} and all non-null results returned by the processor are
+     * returned.
+     *
+     * @param vastDoc The {@link org.w3c.dom.Document} we wish to extract data from.
+     * @param elementName Only elements with this name are processed.
+     * @param attributeName Only elements with this attribute are processed.
+     * @param attributeValue Only elements whose attribute with attributeName matches this value are processed.
+     * @param nodeProcessor Takes matching nodes and produces output data for that node.
+     * @return a {@code List<T>} with processed node data.
+     */
+    static <T> List<T> getListFromDocument(final Document vastDoc, final String elementName,
+            final String attributeName, final String attributeValue, NodeProcessor<T> nodeProcessor) {
+        final ArrayList<T> results = new ArrayList<T>();
 
         if (vastDoc == null) {
             return results;
         }
 
         final NodeList nodes = vastDoc.getElementsByTagName(elementName);
-
         if (nodes == null) {
             return results;
         }
 
+        List<String> attributeValues = attributeValue == null ? null : Arrays.asList(attributeValue);
+
         for (int i = 0; i < nodes.getLength(); i++) {
             final Node node = nodes.item(i);
 
-            if (node != null && nodeMatchesAttributeFilter(node, attributeName, Arrays.asList(attributeValue))) {
-                // since we parsed with coalescing set to true, CDATA is added as the child of the element
-                final String nodeValue = getNodeValue(node);
-                if (nodeValue != null) {
-                    results.add(nodeValue);
+            if (node != null && nodeMatchesAttributeFilter(node, attributeName, attributeValues)) {
+                T processed = nodeProcessor.process(node);
+                if (processed != null) {
+                    results.add(processed);
                 }
             }
         }
 
         return results;
     }
+
+    /**
+     * Get first matching data from a {@code Document]'s elements that match the {@code elementName},
+     * {@code attributeName}, and {@code attributeValue} filters. Nodes that match are processed by
+     * the {@code nodeProcessor} until the first non-null result returned by the processor is
+     * returned.
+     *
+     * @param vastDoc The {@link org.w3c.dom.Document} we wish to extract data from.
+     * @param elementName Only elements with this name are processed.
+     * @param attributeName Only elements with this attribute are processed.
+     * @param attributeValue Only elements whose attribute with attributeName matches this value are processed.
+     * @param nodeProcessor Takes matching nodes and produces output data for that node.
+     * @return node data of type {@code <T>} from first node that matches.
+     */
+    static <T> T getFirstMatchFromDocument(final Document vastDoc, final String elementName,
+            final String attributeName, final String attributeValue, NodeProcessor<T> nodeProcessor) {
+        if (vastDoc == null) {
+            return null;
+        }
+
+        final NodeList nodes = vastDoc.getElementsByTagName(elementName);
+        if (nodes == null) {
+            return null;
+        }
+
+        List<String> attributeValues = attributeValue == null ? null : Arrays.asList(attributeValue);
+
+        for (int i = 0; i < nodes.getLength(); i++) {
+            final Node node = nodes.item(i);
+
+            if (node != null && nodeMatchesAttributeFilter(node, attributeName, attributeValues)) {
+                T processed = nodeProcessor.process(node);
+                if (processed != null) {
+                    return processed;
+                }
+            }
+        }
+
+        return null;
+    }
+
+    static String getFirstMatchingStringData(final Document vastDoc, final String elementName) {
+        return getFirstMatchingStringData(vastDoc, elementName, null, null);
+    }
+
+    static String getFirstMatchingStringData(final Document vastDoc, final String elementName, final String attributeName, final String attributeValue) {
+        return getFirstMatchFromDocument(vastDoc, elementName, attributeName, attributeValue, new NodeProcessor<String>() {
+            @Override
+            public String process(final Node node) {
+                return getNodeValue(node);
+            }
+        });
+    }
+
+    static List<String> getStringDataAsList(final Document vastDoc, final String elementName) {
+        return getStringDataAsList(vastDoc, elementName, null, null);
+    }
+
+    static List<String> getStringDataAsList(final Document vastDoc, final String elementName, final String attributeName, final String attributeValue) {
+        return getListFromDocument(vastDoc, elementName, attributeName, attributeValue, new NodeProcessor<String>() {
+            @Override
+            public String process(final Node node) {
+                return getNodeValue(node);
+            }
+        });
+    }
+
+    static List<Node> getNodesWithElementAndAttribute(final Document vastDoc, final String elementName, final String attributeName, final String attributeValue) {
+       return getListFromDocument(vastDoc, elementName, attributeName, attributeValue, new NodeProcessor<Node>() {
+           @Override
+           public Node process(final Node node) {
+               return node;
+           }
+       });
+    }
+
+    public interface NodeProcessor<T> {
+        public T process(Node node);
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidBanner.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidBanner.java
new file mode 100644
index 00000000..558439d8
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidBanner.java
@@ -0,0 +1,105 @@
+package com.mopub.mraid;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.view.View;
+
+import com.mopub.common.AdReport;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.mobileads.AdViewController;
+import com.mopub.mobileads.CustomEventBanner;
+import com.mopub.mobileads.factories.MraidControllerFactory;
+import com.mopub.mraid.MraidController.MraidListener;
+
+import java.util.Map;
+
+import static com.mopub.common.DataKeys.AD_REPORT_KEY;
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
+import static com.mopub.mobileads.MoPubErrorCode.MRAID_LOAD_ERROR;
+
+class MraidBanner extends CustomEventBanner {
+
+    @Nullable private MraidController mMraidController;
+    @Nullable private CustomEventBannerListener mBannerListener;
+    @Nullable private MraidWebViewDebugListener mDebugListener;
+
+    @Override
+    protected void loadBanner(@NonNull Context context,
+                    @NonNull CustomEventBannerListener customEventBannerListener,
+                    @NonNull Map<String, Object> localExtras,
+                    @NonNull Map<String, String> serverExtras) {
+        mBannerListener = customEventBannerListener;
+
+        String htmlData;
+        if (extrasAreValid(serverExtras)) {
+            htmlData = serverExtras.get(HTML_RESPONSE_BODY_KEY);
+        } else {
+            mBannerListener.onBannerFailed(MRAID_LOAD_ERROR);
+            return;
+        }
+
+        try {
+            AdReport adReport = (AdReport) localExtras.get(AD_REPORT_KEY);
+            mMraidController = MraidControllerFactory.create(
+                    context, adReport, PlacementType.INLINE);
+        } catch (ClassCastException e) {
+            MoPubLog.w("MRAID banner creating failed:", e);
+            mBannerListener.onBannerFailed(MRAID_LOAD_ERROR);
+            return;
+        }
+
+        mMraidController.setDebugListener(mDebugListener);
+        mMraidController.setMraidListener(new MraidListener() {
+            @Override
+            public void onLoaded(View view) {
+                // Honoring the server dimensions forces the WebView to be the size of the banner
+                AdViewController.setShouldHonorServerDimensions(view);
+                mBannerListener.onBannerLoaded(view);
+            }
+
+            @Override
+            public void onFailedToLoad() {
+                mBannerListener.onBannerFailed(MRAID_LOAD_ERROR);
+            }
+
+            @Override
+            public void onExpand() {
+                mBannerListener.onBannerExpanded();
+                mBannerListener.onBannerClicked();
+            }
+
+            @Override
+            public void onOpen() {
+                mBannerListener.onBannerClicked();
+            }
+
+            @Override
+            public void onClose() {
+                mBannerListener.onBannerCollapsed();
+            }
+        });
+        mMraidController.loadContent(htmlData);
+    }
+
+    @Override
+    protected void onInvalidate() {
+        if (mMraidController != null) {
+            mMraidController.setMraidListener(null);
+            mMraidController.destroy();
+        }
+    }
+
+    private boolean extrasAreValid(Map<String, String> serverExtras) {
+        return serverExtras.containsKey(HTML_RESPONSE_BODY_KEY);
+    }
+
+    @VisibleForTesting
+    public void setDebugListener(@Nullable MraidWebViewDebugListener debugListener) {
+        mDebugListener = debugListener;
+        if (mMraidController != null) {
+            mMraidController.setDebugListener(debugListener);
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidBridge.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidBridge.java
new file mode 100644
index 00000000..1430763d
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidBridge.java
@@ -0,0 +1,613 @@
+package com.mopub.mraid;
+
+import android.content.ActivityNotFoundException;
+import android.content.Context;
+import android.content.Intent;
+import android.graphics.Color;
+import android.graphics.Rect;
+import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.View.OnTouchListener;
+import android.webkit.ConsoleMessage;
+import android.webkit.JsResult;
+import android.webkit.WebChromeClient;
+import android.webkit.WebView;
+import android.webkit.WebViewClient;
+
+import com.mopub.common.AdReport;
+import com.mopub.common.CloseableLayout.ClosePosition;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.mobileads.BaseWebView;
+import com.mopub.mobileads.ViewGestureDetector;
+import com.mopub.mobileads.ViewGestureDetector.UserClickListener;
+import com.mopub.mobileads.resource.MraidJavascript;
+import com.mopub.mraid.MraidBridge.MraidWebView.OnVisibilityChangedListener;
+import com.mopub.mraid.MraidNativeCommandHandler.MraidCommandFailureListener;
+
+import org.apache.http.NameValuePair;
+import org.apache.http.client.utils.URLEncodedUtils;
+import org.json.JSONObject;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.HashMap;
+import java.util.Map;
+
+public class MraidBridge {
+    private final AdReport mAdReport;
+
+    public interface MraidBridgeListener {
+        void onPageLoaded();
+
+        void onPageFailedToLoad();
+
+        void onVisibilityChanged(boolean isVisible);
+
+        boolean onJsAlert(@NonNull String message, @NonNull JsResult result);
+
+        boolean onConsoleMessage(@NonNull ConsoleMessage consoleMessage);
+
+        void onResize(int width, int height, int offsetX,
+                int offsetY, @NonNull ClosePosition closePosition, boolean allowOffscreen)
+                throws MraidCommandException;
+
+        void onExpand(URI uri, boolean shouldUseCustomClose) throws MraidCommandException;
+
+        void onClose();
+
+        void onUseCustomClose(boolean shouldUseCustomClose);
+
+        void onSetOrientationProperties(boolean allowOrientationChange, MraidOrientation
+                forceOrientation) throws MraidCommandException;
+
+        void onOpen(URI uri);
+
+        void onPlayVideo(URI uri);
+    }
+
+    private final String FILTERED_JAVASCRIPT_SOURCE = MraidJavascript.JAVASCRIPT_SOURCE
+            .replaceAll("(?m)^\\s+", "")
+            .replaceAll("(?m)^//.*(?=\\n)", "");
+
+    @NonNull private final PlacementType mPlacementType;
+
+    @NonNull private final MraidNativeCommandHandler mMraidNativeCommandHandler;
+
+    @Nullable private MraidBridgeListener mMraidBridgeListener;
+
+    @Nullable private MraidWebView mMraidWebView;
+
+    private boolean mIsClicked;
+
+    private boolean mHasLoaded;
+
+    MraidBridge(@Nullable AdReport adReport, @NonNull PlacementType placementType) {
+        this(adReport, placementType, new MraidNativeCommandHandler());
+    }
+
+    @VisibleForTesting
+    MraidBridge(@Nullable AdReport adReport, @NonNull PlacementType placementType,
+            @NonNull MraidNativeCommandHandler mraidNativeCommandHandler) {
+        mAdReport = adReport;
+        mPlacementType = placementType;
+        mMraidNativeCommandHandler = mraidNativeCommandHandler;
+    }
+
+    void setMraidBridgeListener(@Nullable MraidBridgeListener listener) {
+        mMraidBridgeListener = listener;
+    }
+
+    void attachView(@NonNull MraidWebView mraidWebView) {
+        mMraidWebView = mraidWebView;
+        mMraidWebView.getSettings().setJavaScriptEnabled(true);
+
+        mMraidWebView.loadUrl("javascript:" + FILTERED_JAVASCRIPT_SOURCE);
+        mMraidWebView.setScrollContainer(false);
+        mMraidWebView.setVerticalScrollBarEnabled(false);
+        mMraidWebView.setHorizontalScrollBarEnabled(false);
+        mMraidWebView.setBackgroundColor(Color.BLACK);
+
+        mMraidWebView.setWebViewClient(mMraidWebViewClient);
+
+        mMraidWebView.setWebChromeClient(new WebChromeClient() {
+            @Override
+            public boolean onJsAlert(final WebView view, final String url, final String message,
+                    final JsResult result) {
+                if (mMraidBridgeListener != null) {
+                    return mMraidBridgeListener.onJsAlert(message, result);
+                }
+                return super.onJsAlert(view, url, message, result);
+            }
+
+            @Override
+            public boolean onConsoleMessage(@NonNull final ConsoleMessage consoleMessage) {
+                if (mMraidBridgeListener != null) {
+                    return mMraidBridgeListener.onConsoleMessage(consoleMessage);
+                }
+                return super.onConsoleMessage(consoleMessage);
+            }
+
+            @Override
+            public void onShowCustomView(final View view, final CustomViewCallback callback) {
+                super.onShowCustomView(view, callback);
+            }
+        });
+
+        final ViewGestureDetector gestureDetector = new ViewGestureDetector(
+                mMraidWebView.getContext(), mMraidWebView, mAdReport);
+        gestureDetector.setUserClickListener(new UserClickListener() {
+            @Override
+            public void onUserClick() {
+                mIsClicked = true;
+            }
+
+            @Override
+            public void onResetUserClick() {
+                mIsClicked = false;
+            }
+
+            @Override
+            public boolean wasClicked() {
+                return mIsClicked;
+            }
+        });
+
+        mMraidWebView.setOnTouchListener(new OnTouchListener() {
+            @Override
+            public boolean onTouch(final View v, final MotionEvent event) {
+                gestureDetector.sendTouchEvent(event);
+
+                switch (event.getAction()) {
+                    case MotionEvent.ACTION_DOWN:
+                    case MotionEvent.ACTION_UP:
+                        if (!v.hasFocus()) {
+                            v.requestFocus();
+                        }
+                        break;
+                }
+                return false;
+            }
+        });
+
+        mMraidWebView.setVisibilityChangedListener(new OnVisibilityChangedListener() {
+            @Override
+            public void onVisibilityChanged(final boolean isVisible) {
+                if (mMraidBridgeListener != null) {
+                    mMraidBridgeListener.onVisibilityChanged(isVisible);
+                }
+            }
+        });
+    }
+
+    void detach() {
+        mMraidWebView = null;
+    }
+
+    public void setContentHtml(@NonNull String htmlData) {
+        if (mMraidWebView == null) {
+            MoPubLog.d("MRAID bridge called setContentHtml before WebView was attached");
+            return;
+        }
+
+        mHasLoaded = false;
+        mMraidWebView.loadDataWithBaseURL(null, htmlData, "text/html", "UTF-8", null);
+    }
+
+    public void setContentUrl(String url) {
+        if (mMraidWebView == null) {
+            MoPubLog.d("MRAID bridge called setContentHtml while WebView was not attached");
+            return;
+        }
+
+        mHasLoaded = false;
+        mMraidWebView.loadUrl(url);
+    }
+
+    void injectJavaScript(@NonNull String javascript) {
+        if (mMraidWebView == null) {
+            MoPubLog.d("Attempted to inject Javascript into MRAID WebView while was not "
+                    + "attached:\n\t" + javascript);
+            return;
+        }
+        MoPubLog.v("Injecting Javascript into MRAID WebView:\n\t" + javascript);
+        mMraidWebView.loadUrl("javascript:" + javascript);
+    }
+
+    private void fireErrorEvent(@NonNull MraidJavascriptCommand command, @NonNull String message) {
+        injectJavaScript("window.mraidbridge.notifyErrorEvent("
+                + JSONObject.quote(command.toJavascriptString()) + ", "
+                + JSONObject.quote(message) + ")");
+    }
+
+    private void fireNativeCommandCompleteEvent(@NonNull MraidJavascriptCommand command) {
+        injectJavaScript("window.mraidbridge.nativeCallComplete("
+                + JSONObject.quote(command.toJavascriptString()) + ")");
+    }
+
+    public static class MraidWebView extends BaseWebView {
+        public interface OnVisibilityChangedListener {
+            void onVisibilityChanged(boolean isVisible);
+        }
+
+        @Nullable private OnVisibilityChangedListener mOnVisibilityChangedListener;
+
+        private boolean mIsVisible;
+
+        public MraidWebView(Context context) {
+            super(context);
+            mIsVisible = getVisibility() == View.VISIBLE;
+        }
+
+        void setVisibilityChangedListener(@Nullable OnVisibilityChangedListener listener) {
+            mOnVisibilityChangedListener = listener;
+        }
+
+        @Override
+        protected void onVisibilityChanged(@NonNull View changedView, int visibility) {
+            super.onVisibilityChanged(changedView, visibility);
+            boolean newIsVisible = (visibility == View.VISIBLE);
+            if (newIsVisible != mIsVisible) {
+                mIsVisible = newIsVisible;
+                if (mOnVisibilityChangedListener != null) {
+                    mOnVisibilityChangedListener.onVisibilityChanged(mIsVisible);
+                }
+            }
+        }
+
+        public boolean isVisible() {
+            return mIsVisible;
+        }
+    }
+
+    private final WebViewClient mMraidWebViewClient = new WebViewClient() {
+        @Override
+        public void onReceivedError(WebView view, int errorCode, String description, String failingUrl) {
+            MoPubLog.d("Error: " + description);
+            super.onReceivedError(view, errorCode, description, failingUrl);
+        }
+
+        @Override
+        public boolean shouldOverrideUrlLoading(@NonNull WebView view, @NonNull String url) {
+            return handleShouldOverrideUrl(url);
+        }
+
+        @Override
+        public void onPageFinished(@NonNull WebView view, @NonNull String url) {
+            handlePageFinished();
+        }
+    };
+
+    @VisibleForTesting
+    boolean handleShouldOverrideUrl(@NonNull final String url) {
+        URI uri;
+        try {
+            uri = new URI(url);
+        } catch (URISyntaxException e) {
+            MoPubLog.w("Invalid MRAID URL: " + url);
+            fireErrorEvent(MraidJavascriptCommand.UNSPECIFIED, "Mraid command sent an invalid URL");
+            return true;
+        }
+
+        // Note that scheme will be null when we are passed a relative Uri
+        String scheme = uri.getScheme();
+        String host = uri.getHost();
+
+        if ("mopub".equals(scheme)) {
+            if ("failLoad".equals(host)) {
+                if (mPlacementType == PlacementType.INLINE && mMraidBridgeListener != null) {
+                    mMraidBridgeListener.onPageFailedToLoad();
+                }
+            }
+            return true;
+        }
+
+        if ("mraid".equals(scheme)) {
+            Map<String, String> params = new HashMap<String, String>();
+            for (NameValuePair pair : URLEncodedUtils.parse(uri, "UTF-8")) {
+                params.put(pair.getName(), pair.getValue());
+            }
+            MraidJavascriptCommand command = MraidJavascriptCommand.fromJavascriptString(host);
+            try {
+                runCommand(command, params);
+            } catch (MraidCommandException exception) {
+                fireErrorEvent(command, exception.getMessage());
+            }
+            fireNativeCommandCompleteEvent(command);
+            return true;
+        }
+
+        // This block handles all other URLs, including sms://, tel://,
+        // clicking a hyperlink, or setting window.location directly in Javascript. It checks for
+        // clicked in order to avoid interfering with automatically browser redirects.
+        if (mIsClicked) {
+            Intent intent = new Intent();
+            intent.setAction(Intent.ACTION_VIEW);
+            intent.setData(Uri.parse(url));
+            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+
+            try {
+                if (mMraidWebView == null) {
+                    MoPubLog.d("WebView was detached. Unable to load a URL");
+                    return true;
+                }
+                mMraidWebView.getContext().startActivity(intent);
+                return true;
+            } catch (ActivityNotFoundException e) {
+                MoPubLog.d("No activity found to handle this URL " + url);
+                return false;
+            }
+        }
+
+        return false;
+    }
+
+    @VisibleForTesting
+    private void handlePageFinished() {
+        // This can happen a second time if the ad does something that changes the window location,
+        // such as a redirect, changing window.location in Javascript, or programmatically clicking
+        // a hyperlink. Note that the handleShouldOverrideUrl method skips doing its own
+        // processing if the user hasn't clicked the ad.
+        if (mHasLoaded) {
+            return;
+        }
+
+        mHasLoaded = true;
+        if (mMraidBridgeListener != null) {
+            mMraidBridgeListener.onPageLoaded();
+        }
+    }
+
+    @VisibleForTesting
+    void runCommand(@NonNull final MraidJavascriptCommand command,
+            @NonNull Map<String, String> params)
+            throws MraidCommandException {
+        if (command.requiresClick(mPlacementType) && !mIsClicked) {
+            throw new MraidCommandException("Cannot execute this command unless the user clicks");
+        }
+
+        if (mMraidBridgeListener == null) {
+            throw new MraidCommandException("Invalid state to execute this command");
+        }
+
+        if (mMraidWebView == null) {
+            throw new MraidCommandException("The current WebView is being destroyed");
+        }
+
+        switch (command) {
+            case CLOSE:
+                mMraidBridgeListener.onClose();
+                break;
+            case RESIZE:
+                // All these params are required
+                int width = checkRange(parseSize(params.get("width")), 0, 100000);
+                int height = checkRange(parseSize(params.get("height")), 0, 100000);
+                int offsetX = checkRange(parseSize(params.get("offsetX")), -100000, 100000);
+                int offsetY = checkRange(parseSize(params.get("offsetY")), -100000, 100000);
+                ClosePosition closePosition = parseClosePosition(
+                        params.get("customClosePosition"), ClosePosition.TOP_RIGHT);
+                boolean allowOffscreen = parseBoolean(params.get("allowOffscreen"), true);
+                mMraidBridgeListener.onResize(
+                        width, height, offsetX, offsetY, closePosition, allowOffscreen);
+                break;
+            case EXPAND:
+                URI uri = parseURI(params.get("url"), null);
+                boolean shouldUseCustomClose = parseBoolean(params.get("shouldUseCustomClose"),
+                        false);
+                mMraidBridgeListener.onExpand(uri, shouldUseCustomClose);
+                break;
+            case USE_CUSTOM_CLOSE:
+                shouldUseCustomClose = parseBoolean(params.get("shouldUseCustomClose"), false);
+                mMraidBridgeListener.onUseCustomClose(shouldUseCustomClose);
+                break;
+            case OPEN:
+                uri = parseURI(params.get("url"));
+                mMraidBridgeListener.onOpen(uri);
+                break;
+            case SET_ORIENTATION_PROPERTIES:
+                boolean allowOrientationChange = parseBoolean(params.get("allowOrientationChange"));
+                MraidOrientation forceOrientation = parseOrientation(params.get("forceOrientation"));
+
+                mMraidBridgeListener.onSetOrientationProperties(allowOrientationChange,
+                        forceOrientation);
+                break;
+            case PLAY_VIDEO:
+                uri = parseURI(params.get("uri"));
+                mMraidBridgeListener.onPlayVideo(uri);
+                break;
+            case STORE_PICTURE:
+                uri = parseURI(params.get("uri"));
+                mMraidNativeCommandHandler.storePicture(mMraidWebView.getContext(), uri.toString(),
+                        new MraidCommandFailureListener() {
+                            @Override
+                            public void onFailure(final MraidCommandException exception) {
+                                fireErrorEvent(command, exception.getMessage());
+                            }
+                        });
+                break;
+
+            case CREATE_CALENDAR_EVENT:
+                mMraidNativeCommandHandler.createCalendarEvent(mMraidWebView.getContext(), params);
+                break;
+            case UNSPECIFIED:
+                throw new MraidCommandException("Unspecified MRAID Javascript command");
+        }
+    }
+
+    private ClosePosition parseClosePosition(@NonNull String text,
+            @NonNull ClosePosition defaultValue)
+            throws MraidCommandException {
+        if (TextUtils.isEmpty(text)) {
+            return defaultValue;
+        }
+
+        if (text.equals("top-left")) {
+            return ClosePosition.TOP_LEFT;
+        } else if (text.equals("top-right")) {
+            return ClosePosition.TOP_RIGHT;
+        } else if (text.equals("center")) {
+            return ClosePosition.CENTER;
+        } else if (text.equals("bottom-left")) {
+            return ClosePosition.BOTTOM_LEFT;
+        } else if (text.equals("bottom-right")) {
+            return ClosePosition.BOTTOM_RIGHT;
+        } else if (text.equals("top-center")) {
+            return ClosePosition.TOP_CENTER;
+        } else if (text.equals("bottom-center")) {
+            return ClosePosition.BOTTOM_CENTER;
+        } else {
+            throw new MraidCommandException("Invalid close position: " + text);
+        }
+    }
+
+    private int parseSize(@NonNull String text) throws MraidCommandException {
+        int result;
+        try {
+            result = Integer.parseInt(text, 10);
+        } catch (NumberFormatException e) {
+            throw new MraidCommandException("Invalid numeric parameter: " + text);
+        }
+        return result;
+    }
+
+    private MraidOrientation parseOrientation(String text) throws MraidCommandException {
+        if ("portrait".equals(text)) {
+            return MraidOrientation.PORTRAIT;
+        } else if ("landscape".equals(text)) {
+            return MraidOrientation.LANDSCAPE;
+        } else if ("none".equals(text)) {
+            return MraidOrientation.NONE;
+        } else {
+            throw new MraidCommandException("Invalid orientation: " + text);
+        }
+    }
+
+    private int checkRange(int value, int min, int max) throws MraidCommandException {
+        if (value < min || value > max) {
+            throw new MraidCommandException("Integer parameter out of range: " + value);
+        }
+        return value;
+    }
+
+    private boolean parseBoolean(
+            @Nullable String text, boolean defaultValue) throws MraidCommandException {
+        if (text == null) {
+            return defaultValue;
+        }
+        return parseBoolean(text);
+    }
+
+    private boolean parseBoolean(final String text) throws MraidCommandException {
+        if ("true".equals(text)) {
+            return true;
+        } else if ("false".equals(text)) {
+            return false;
+        }
+        throw new MraidCommandException("Invalid boolean parameter: " + text);
+    }
+
+    @NonNull
+    private URI parseURI(@Nullable String encodedText, URI defaultValue)
+            throws MraidCommandException {
+        if (encodedText == null) {
+            return defaultValue;
+        }
+        return parseURI(encodedText);
+    }
+
+    @NonNull
+    private URI parseURI(@Nullable String encodedText) throws MraidCommandException {
+        if (encodedText == null) {
+            throw new MraidCommandException("Parameter cannot be null");
+        }
+        try {
+            return new URI(encodedText);
+        } catch (URISyntaxException e) {
+            throw new MraidCommandException("Invalid URL parameter: " + encodedText);
+        }
+    }
+
+    void notifyViewability(boolean isViewable) {
+        injectJavaScript("mraidbridge.setIsViewable("
+                + isViewable
+                + ")");
+    }
+
+    void notifyPlacementType(PlacementType placementType) {
+        injectJavaScript("mraidbridge.setPlacementType("
+                + JSONObject.quote(placementType.toJavascriptString())
+                + ")");
+    }
+
+    void notifyViewState(ViewState state) {
+        injectJavaScript("mraidbridge.setState("
+                + JSONObject.quote(state.toJavascriptString())
+                + ")");
+    }
+
+    void notifySupports(boolean sms, boolean telephone, boolean calendar,
+            boolean storePicture, boolean inlineVideo) {
+        injectJavaScript("mraidbridge.setSupports("
+                + sms + "," + telephone + "," + calendar + "," + storePicture + "," + inlineVideo
+                + ")");
+    }
+
+    @NonNull
+    private String stringifyRect(Rect rect) {
+        return rect.left + "," + rect.top + "," + rect.width() + "," + rect.height();
+    }
+
+    @NonNull
+    private String stringifySize(Rect rect) {
+        return rect.width() + "," + rect.height();
+    }
+
+    public void notifyScreenMetrics(@NonNull final MraidScreenMetrics screenMetrics) {
+        injectJavaScript("mraidbridge.setScreenSize("
+                + stringifySize(screenMetrics.getScreenRectDips())
+                + ");mraidbridge.setMaxSize("
+                + stringifySize(screenMetrics.getRootViewRectDips())
+                + ");mraidbridge.setCurrentPosition("
+                + stringifyRect(screenMetrics.getCurrentAdRectDips())
+                + ");mraidbridge.setDefaultPosition("
+                + stringifyRect(screenMetrics.getDefaultAdRectDips())
+                + ")");
+        injectJavaScript("mraidbridge.notifySizeChangeEvent("
+                + stringifySize(screenMetrics.getCurrentAdRect())
+                + ")");
+    }
+
+    void notifyReady() {
+        injectJavaScript("mraidbridge.notifyReadyEvent();");
+    }
+
+    boolean isClicked() {
+        return mIsClicked;
+    }
+
+    boolean isVisible() {
+        return mMraidWebView != null && mMraidWebView.isVisible();
+    }
+
+    boolean isAttached() {
+        return mMraidWebView != null;
+    }
+
+    boolean isLoaded() {
+        return mHasLoaded;
+    }
+
+    @VisibleForTesting
+    MraidWebView getMraidWebView() {
+        return mMraidWebView;
+    }
+
+    @VisibleForTesting
+    void setClicked(boolean clicked) {
+        mIsClicked = clicked;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidCommandException.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidCommandException.java
new file mode 100644
index 00000000..3db8e050
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidCommandException.java
@@ -0,0 +1,19 @@
+package com.mopub.mraid;
+
+class MraidCommandException extends Exception {
+    MraidCommandException() {
+        super();
+    }
+
+    MraidCommandException(String detailMessage) {
+        super(detailMessage);
+    }
+
+    MraidCommandException(String detailMessage, Throwable throwable) {
+        super(detailMessage, throwable);
+    }
+
+    MraidCommandException(Throwable throwable) {
+        super(throwable);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidController.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidController.java
new file mode 100644
index 00000000..9e078090
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidController.java
@@ -0,0 +1,1162 @@
+package com.mopub.mraid;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.ActivityInfo;
+import android.content.pm.PackageManager;
+import android.graphics.Rect;
+import android.net.Uri;
+import android.os.Build.VERSION;
+import android.os.Build.VERSION_CODES;
+import android.os.Bundle;
+import android.os.Handler;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.DisplayMetrics;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.View.OnTouchListener;
+import android.view.ViewGroup;
+import android.view.ViewTreeObserver.OnPreDrawListener;
+import android.view.WindowManager;
+import android.webkit.ConsoleMessage;
+import android.webkit.JsResult;
+import android.widget.FrameLayout;
+import android.widget.FrameLayout.LayoutParams;
+
+import com.mopub.common.AdReport;
+import com.mopub.common.CloseableLayout;
+import com.mopub.common.CloseableLayout.ClosePosition;
+import com.mopub.common.CloseableLayout.OnCloseListener;
+import com.mopub.common.MoPubBrowser;
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.DeviceUtils;
+import com.mopub.common.util.Dips;
+import com.mopub.common.util.Intents;
+import com.mopub.common.util.Views;
+import com.mopub.exceptions.IntentNotResolvableException;
+import com.mopub.exceptions.UrlParseException;
+import com.mopub.mobileads.MraidVideoPlayerActivity;
+import com.mopub.mobileads.util.WebViews;
+import com.mopub.mraid.MraidBridge.MraidBridgeListener;
+import com.mopub.mraid.MraidBridge.MraidWebView;
+
+import java.lang.ref.WeakReference;
+import java.net.URI;
+
+import static android.content.pm.ActivityInfo.CONFIG_ORIENTATION;
+import static android.content.pm.ActivityInfo.CONFIG_SCREEN_SIZE;
+import static com.mopub.common.util.Utils.bitMaskContainsFlag;
+
+public class MraidController {
+    private final AdReport mAdReport;
+
+    public interface MraidListener {
+        public void onLoaded(View view);
+        public void onFailedToLoad();
+        public void onExpand();
+        public void onOpen();
+        public void onClose();
+    }
+
+    public interface UseCustomCloseListener {
+        public void useCustomCloseChanged(boolean useCustomClose);
+    }
+
+    /**
+     * Holds a weak reference to the activity if the context that is passed in is an activity.
+     * While this field is never null, the reference could become null. This reference starts out
+     * null if the passed-in context is not an activity.
+     */
+    @NonNull private final WeakReference<Activity> mWeakActivity;
+    @NonNull private final Context mContext;
+    @NonNull private final PlacementType mPlacementType;
+
+    // An ad container, which contains the ad web view in default state, but is empty when expanded.
+    @NonNull private final FrameLayout mDefaultAdContainer;
+
+    // Ad ad container which contains the ad view in expanded state.
+    @NonNull private final CloseableLayout mCloseableAdContainer;
+
+    // Root view, where we'll add the expanded ad
+    @Nullable private ViewGroup mRootView;
+
+    // Helper classes for updating screen values
+    @NonNull private final ScreenMetricsWaiter mScreenMetricsWaiter;
+    @NonNull private final MraidScreenMetrics mScreenMetrics;
+
+    // Current view state
+    @NonNull private ViewState mViewState = ViewState.LOADING;
+
+    // Listeners
+    @Nullable private MraidListener mMraidListener;
+    @Nullable private UseCustomCloseListener mOnCloseButtonListener;
+    @Nullable private MraidWebViewDebugListener mDebugListener;
+
+    // The WebView which will display the ad. "Two part" creatives, loaded via handleExpand(URL)
+    // are shown in a separate web view
+    @Nullable private MraidWebView mMraidWebView;
+    @Nullable private MraidWebView mTwoPartWebView;
+
+    // A bridge to handle all interactions with the WebView HTML and Javascript.
+    @NonNull private final MraidBridge mMraidBridge;
+    @NonNull private final MraidBridge mTwoPartBridge;
+
+    @NonNull private OrientationBroadcastReceiver mOrientationBroadcastReceiver =
+            new OrientationBroadcastReceiver();
+
+    // Stores the requested orientation for the Activity to which this controller's view belongs.
+    // This is needed to restore the Activity's requested orientation in the event that the view
+    // itself requires an orientation lock.
+    @Nullable private Integer mOriginalActivityOrientation;
+
+    private boolean mAllowOrientationChange = true;
+    private MraidOrientation mForceOrientation = MraidOrientation.NONE;
+
+    private final MraidNativeCommandHandler mMraidNativeCommandHandler;
+
+    private boolean mIsPaused;
+
+    public MraidController(@NonNull Context context, @Nullable AdReport adReport,
+            @NonNull PlacementType placementType) {
+        this(context, adReport, placementType,
+                new MraidBridge(adReport, placementType),
+                new MraidBridge(adReport, PlacementType.INTERSTITIAL),
+                new ScreenMetricsWaiter());
+    }
+
+    @VisibleForTesting
+    MraidController(@NonNull Context context, @Nullable AdReport adReport,
+            @NonNull PlacementType placementType,
+            @NonNull MraidBridge bridge, @NonNull MraidBridge twoPartBridge,
+            @NonNull ScreenMetricsWaiter screenMetricsWaiter) {
+        mContext = context.getApplicationContext();
+        Preconditions.checkNotNull(mContext);
+        mAdReport = adReport;
+        if (context instanceof Activity) {
+            mWeakActivity = new WeakReference<Activity>((Activity) context);
+        } else {
+            // Make sure mWeakActivity itself is never null, though the reference
+            // it's pointing to could be null.
+            mWeakActivity = new WeakReference<Activity>(null);
+        }
+
+        mPlacementType = placementType;
+        mMraidBridge = bridge;
+        mTwoPartBridge = twoPartBridge;
+        mScreenMetricsWaiter = screenMetricsWaiter;
+
+        mViewState = ViewState.LOADING;
+
+        DisplayMetrics displayMetrics = mContext.getResources().getDisplayMetrics();
+        mScreenMetrics = new MraidScreenMetrics(mContext, displayMetrics.density);
+        mDefaultAdContainer = new FrameLayout(mContext);
+        mCloseableAdContainer = new CloseableLayout(mContext);
+        mCloseableAdContainer.setOnCloseListener(new OnCloseListener() {
+            @Override
+            public void onClose() {
+                handleClose();
+            }
+        });
+
+        View dimmingView = new View(mContext);
+        dimmingView.setOnTouchListener(new OnTouchListener() {
+            public boolean onTouch(View v, MotionEvent event) {
+                return true;
+            }
+        });
+        mCloseableAdContainer.addView(dimmingView,
+                new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
+
+        mOrientationBroadcastReceiver.register(mContext);
+
+        mMraidBridge.setMraidBridgeListener(mMraidBridgeListener);
+        mTwoPartBridge.setMraidBridgeListener(mTwoPartBridgeListener);
+        mMraidNativeCommandHandler = new MraidNativeCommandHandler();
+    }
+
+    @SuppressWarnings("FieldCanBeLocal")
+    private final MraidBridgeListener mMraidBridgeListener = new MraidBridgeListener() {
+        @Override
+        public void onPageLoaded() {
+            handlePageLoad();
+        }
+
+        @Override
+        public void onPageFailedToLoad() {
+            if (mMraidListener != null) {
+                mMraidListener.onFailedToLoad();
+            }
+        }
+
+        @Override
+        public void onVisibilityChanged(final boolean isVisible) {
+            // The bridge only receives visibility events if there is no 2 part covering it
+            if (!mTwoPartBridge.isAttached()) {
+                mMraidBridge.notifyViewability(isVisible);
+            }
+        }
+
+        @Override
+        public boolean onJsAlert(@NonNull final String message, @NonNull final JsResult result) {
+            return handleJsAlert(message, result);
+        }
+
+        @Override
+        public boolean onConsoleMessage(@NonNull final ConsoleMessage consoleMessage) {
+            return handleConsoleMessage(consoleMessage);
+        }
+
+        @Override
+        public void onClose() {
+            handleClose();
+        }
+
+        @Override
+        public void onResize(final int width, final int height, final int offsetX,
+                final int offsetY, @NonNull final ClosePosition closePosition,
+                final boolean allowOffscreen) throws MraidCommandException {
+            handleResize(width, height, offsetX, offsetY, closePosition, allowOffscreen);
+        }
+
+        public void onExpand(@Nullable final URI uri, final boolean shouldUseCustomClose)
+                throws MraidCommandException {
+            handleExpand(uri, shouldUseCustomClose);
+        }
+
+        @Override
+        public void onUseCustomClose(final boolean shouldUseCustomClose) {
+            handleCustomClose(shouldUseCustomClose);
+        }
+
+        @Override
+        public void onSetOrientationProperties(final boolean allowOrientationChange,
+                final MraidOrientation forceOrientation) throws MraidCommandException {
+            handleSetOrientationProperties(allowOrientationChange, forceOrientation);
+        }
+
+        @Override
+        public void onOpen(@NonNull final URI uri) {
+            handleOpen(uri.toString());
+        }
+
+        @Override
+        public void onPlayVideo(@NonNull final URI uri) {
+            handleShowVideo(uri.toString());
+        }
+    };
+
+    @SuppressWarnings("FieldCanBeLocal")
+    private final MraidBridgeListener mTwoPartBridgeListener = new MraidBridgeListener() {
+        @Override
+        public void onPageLoaded() {
+            handleTwoPartPageLoad();
+        }
+
+        @Override
+        public void onPageFailedToLoad() {
+            // no-op for two-part expandables. An expandable failing to load should not trigger failover.
+        }
+
+        @Override
+        public void onVisibilityChanged(final boolean isVisible) {
+            // The original web view must see the 2-part bridges visibility
+            mMraidBridge.notifyViewability(isVisible);
+            mTwoPartBridge.notifyViewability(isVisible);
+        }
+
+        @Override
+        public boolean onJsAlert(@NonNull final String message, @NonNull final JsResult result) {
+            return handleJsAlert(message, result);
+        }
+
+        @Override
+        public boolean onConsoleMessage(@NonNull final ConsoleMessage consoleMessage) {
+            return handleConsoleMessage(consoleMessage);
+        }
+
+        @Override
+        public void onResize(final int width, final int height, final int offsetX,
+                final int offsetY, @NonNull final ClosePosition closePosition,
+                final boolean allowOffscreen) throws MraidCommandException {
+            throw new MraidCommandException("Not allowed to resize from an expanded state");
+        }
+
+        @Override
+        public void onExpand(@Nullable final URI uri, final boolean shouldUseCustomClose) {
+            // The MRAID spec dictates that this is ignored rather than firing an error
+        }
+
+        @Override
+        public void onClose() {
+            handleClose();
+        }
+
+        @Override
+        public void onUseCustomClose(final boolean shouldUseCustomClose) {
+            handleCustomClose(shouldUseCustomClose);
+        }
+
+        @Override
+        public void onSetOrientationProperties(final boolean allowOrientationChange,
+                final MraidOrientation forceOrientation) throws MraidCommandException {
+            handleSetOrientationProperties(allowOrientationChange, forceOrientation);
+        }
+
+        @Override
+        public void onOpen(final URI uri) {
+            handleOpen(uri.toString());
+        }
+
+        @Override
+        public void onPlayVideo(@NonNull final URI uri) {
+            handleShowVideo(uri.toString());
+        }
+    };
+
+    public void setMraidListener(@Nullable MraidListener mraidListener) {
+        mMraidListener = mraidListener;
+    }
+
+    public void setUseCustomCloseListener(@Nullable UseCustomCloseListener listener) {
+        mOnCloseButtonListener = listener;
+    }
+
+    public void setDebugListener(@Nullable MraidWebViewDebugListener debugListener) {
+        mDebugListener = debugListener;
+    }
+
+    public void loadContent(@NonNull String htmlData) {
+        Preconditions.checkState(mMraidWebView == null, "loadContent should only be called once");
+
+        mMraidWebView = new MraidWebView(mContext);
+        mMraidBridge.attachView(mMraidWebView);
+        mDefaultAdContainer.addView(mMraidWebView,
+                new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
+
+        // onPageLoaded gets fired once the html is loaded into the webView
+        mMraidBridge.setContentHtml(htmlData);
+    }
+
+    // onPageLoaded gets fired once the html is loaded into the webView.
+    private int getDisplayRotation() {
+        WindowManager wm = (WindowManager) mContext
+                .getSystemService(Context.WINDOW_SERVICE);
+        return wm.getDefaultDisplay().getRotation();
+    }
+
+    @VisibleForTesting
+    boolean handleConsoleMessage(@NonNull final ConsoleMessage consoleMessage) {
+        //noinspection SimplifiableIfStatement
+        if (mDebugListener != null) {
+            return mDebugListener.onConsoleMessage(consoleMessage);
+        }
+        return true;
+    }
+
+    @VisibleForTesting
+    boolean handleJsAlert(@NonNull final String message, @NonNull final JsResult result) {
+        if (mDebugListener != null) {
+            return mDebugListener.onJsAlert(message, result);
+        }
+        result.confirm();
+        return true;
+    }
+
+    @VisibleForTesting
+    static class ScreenMetricsWaiter {
+        static class WaitRequest {
+            @NonNull private final View[] mViews;
+            @NonNull private final Handler mHandler;
+            @Nullable private Runnable mSuccessRunnable;
+            int mWaitCount;
+
+            private WaitRequest(@NonNull Handler handler, @NonNull final View[] views) {
+                mHandler = handler;
+                mViews = views;
+            }
+
+            private void countDown() {
+                mWaitCount--;
+                if (mWaitCount == 0 && mSuccessRunnable != null) {
+                    mSuccessRunnable.run();
+                    mSuccessRunnable = null;
+                }
+            }
+
+            private final Runnable mWaitingRunnable = new Runnable() {
+                @Override
+                public void run() {
+                    for (final View view : mViews) {
+                        // Immediately count down for any views that already have a size
+                        if (view.getHeight() > 0 || view.getWidth() > 0) {
+                            countDown();
+                            continue;
+                        }
+
+                        // For views that didn't have a size, listen (once) for a preDraw. Note
+                        // that this doesn't leak because the ViewTreeObserver gets detached when
+                        // the view is no longer part of the view hierarchy.
+                        view.getViewTreeObserver().addOnPreDrawListener(new OnPreDrawListener() {
+                            @Override
+                            public boolean onPreDraw() {
+                                view.getViewTreeObserver().removeOnPreDrawListener(this);
+                                countDown();
+                                return true;
+                            }
+                        });
+                    }
+                }
+            };
+
+            void start(@NonNull Runnable successRunnable) {
+                mSuccessRunnable = successRunnable;
+                mWaitCount = mViews.length;
+                mHandler.post(mWaitingRunnable);
+            }
+
+            void cancel() {
+                mHandler.removeCallbacks(mWaitingRunnable);
+                mSuccessRunnable = null;
+            }
+        }
+
+        @NonNull private final Handler mHandler = new Handler();
+        @Nullable private WaitRequest mLastWaitRequest;
+
+        WaitRequest waitFor(@NonNull View... views) {
+            mLastWaitRequest = new WaitRequest(mHandler, views);
+            return mLastWaitRequest;
+        }
+
+        void cancelLastRequest() {
+            if (mLastWaitRequest != null) {
+                mLastWaitRequest.cancel();
+                mLastWaitRequest = null;
+            }
+        }
+    }
+
+    @Nullable
+    private View getCurrentWebView() {
+        return mTwoPartBridge.isAttached() ? mTwoPartWebView : mMraidWebView;
+    }
+
+    private boolean isInlineVideoAvailable() {
+        //noinspection SimplifiableIfStatement
+        final Activity activity = mWeakActivity.get();
+        if (activity == null || getCurrentWebView() == null) {
+            return false;
+        }
+
+        return mMraidNativeCommandHandler.isInlineVideoAvailable(activity, getCurrentWebView());
+    }
+
+    @VisibleForTesting
+    void handlePageLoad() {
+        setViewState(ViewState.DEFAULT, new Runnable() {
+            @Override
+            public void run() {
+                mMraidBridge.notifySupports(
+                        mMraidNativeCommandHandler.isSmsAvailable(mContext),
+                        mMraidNativeCommandHandler.isTelAvailable(mContext),
+                        MraidNativeCommandHandler.isCalendarAvailable(mContext),
+                        MraidNativeCommandHandler.isStorePictureSupported(mContext),
+                        isInlineVideoAvailable());
+                mMraidBridge.notifyPlacementType(mPlacementType);
+                mMraidBridge.notifyViewability(mMraidBridge.isVisible());
+                mMraidBridge.notifyReady();
+            }
+        });
+
+        // Call onLoaded immediately. This causes the container to get added to the view hierarchy
+        if (mMraidListener != null) {
+            mMraidListener.onLoaded(mDefaultAdContainer);
+        }
+    }
+
+    @VisibleForTesting
+    void handleTwoPartPageLoad() {
+        updateScreenMetricsAsync(new Runnable() {
+            @Override
+            public void run() {
+                mTwoPartBridge.notifySupports(
+                        mMraidNativeCommandHandler.isSmsAvailable(mContext),
+                        mMraidNativeCommandHandler.isTelAvailable(mContext),
+                        mMraidNativeCommandHandler.isCalendarAvailable(mContext),
+                        mMraidNativeCommandHandler.isStorePictureSupported(mContext),
+                        isInlineVideoAvailable());
+                mTwoPartBridge.notifyViewState(mViewState);
+                mTwoPartBridge.notifyPlacementType(mPlacementType);
+                mTwoPartBridge.notifyViewability(mTwoPartBridge.isVisible());
+                mTwoPartBridge.notifyReady();
+            }
+        });
+    }
+
+    /**
+     * Updates screen metrics, calling the successRunnable once they are available. The
+     * successRunnable will always be called asynchronously, ie on the next main thread loop.
+     */
+    private void updateScreenMetricsAsync(@Nullable final Runnable successRunnable) {
+        // Don't allow multiple metrics wait requests at once
+        mScreenMetricsWaiter.cancelLastRequest();
+
+        // Determine which web view should be used for the current ad position
+        final View currentWebView = getCurrentWebView();
+        if (currentWebView == null) {
+            return;
+        }
+
+        // Wait for the next draw pass on the default ad container and current web view
+        mScreenMetricsWaiter.waitFor(mDefaultAdContainer, currentWebView).start(
+                new Runnable() {
+                    @Override
+                    public void run() {
+                        DisplayMetrics displayMetrics = mContext.getResources().getDisplayMetrics();
+                        mScreenMetrics.setScreenSize(
+                                displayMetrics.widthPixels, displayMetrics.heightPixels);
+
+                        int[] location = new int[2];
+                        View rootView = getRootView();
+                        rootView.getLocationOnScreen(location);
+                        mScreenMetrics.setRootViewPosition(location[0], location[1],
+                                rootView.getWidth(),
+                                rootView.getHeight());
+
+                        mDefaultAdContainer.getLocationOnScreen(location);
+                        mScreenMetrics.setDefaultAdPosition(location[0], location[1],
+                                mDefaultAdContainer.getWidth(),
+                                mDefaultAdContainer.getHeight());
+
+                        currentWebView.getLocationOnScreen(location);
+                        mScreenMetrics.setCurrentAdPosition(location[0], location[1],
+                                currentWebView.getWidth(),
+                                currentWebView.getHeight());
+
+                        // Always notify both bridges of the new metrics
+                        mMraidBridge.notifyScreenMetrics(mScreenMetrics);
+                        if (mTwoPartBridge.isAttached()) {
+                            mTwoPartBridge.notifyScreenMetrics(mScreenMetrics);
+                        }
+
+                        if (successRunnable != null) {
+                            successRunnable.run();
+                        }
+                    }
+                });
+    }
+
+    void handleOrientationChange(int currentRotation) {
+        updateScreenMetricsAsync(null);
+    }
+
+    public void pause(boolean isFinishing) {
+        mIsPaused = true;
+
+        // This causes an inline video to pause if there is one playing
+        if (mMraidWebView != null) {
+            WebViews.onPause(mMraidWebView, isFinishing);
+        }
+        if (mTwoPartWebView != null) {
+            WebViews.onPause(mTwoPartWebView, isFinishing);
+        }
+    }
+
+    public void resume() {
+        mIsPaused = false;
+
+        // This causes an inline video to resume if it was playing previously
+        if (mMraidWebView != null) {
+            WebViews.onResume(mMraidWebView);
+        }
+        if (mTwoPartWebView != null) {
+            WebViews.onResume(mTwoPartWebView);
+        }
+    }
+
+    public void destroy() {
+        mScreenMetricsWaiter.cancelLastRequest();
+
+        try {
+            mOrientationBroadcastReceiver.unregister();
+        } catch (IllegalArgumentException e) {
+            if (!e.getMessage().contains("Receiver not registered")) {
+                throw e;
+            } // Else ignore this exception.
+        }
+
+        // Pause the controller to make sure the video gets stopped.
+        if (!mIsPaused) {
+            pause(true);
+        }
+
+        // Remove the closeable ad container from the view hierarchy, if necessary
+        Views.removeFromParent(mCloseableAdContainer);
+
+        // Calling destroy eliminates a memory leak on Gingerbread devices
+        mMraidBridge.detach();
+        if (mMraidWebView != null) {
+            mMraidWebView.destroy();
+            mMraidWebView = null;
+        }
+        mTwoPartBridge.detach();
+        if (mTwoPartWebView != null) {
+            mTwoPartWebView.destroy();
+            mTwoPartWebView = null;
+        }
+    }
+
+    private void setViewState(@NonNull ViewState viewState) {
+        setViewState(viewState, null);
+    }
+
+    private void setViewState(@NonNull ViewState viewState, @Nullable Runnable successRunnable) {
+        // Make sure this is a valid transition.
+        MoPubLog.d("MRAID state set to " + viewState);
+        mViewState = viewState;
+        mMraidBridge.notifyViewState(viewState);
+
+        // Changing state notifies the two part view, but only if it's loaded
+        if (mTwoPartBridge.isLoaded()) {
+            mTwoPartBridge.notifyViewState(viewState);
+        }
+
+        if (mMraidListener != null) {
+            if (viewState == ViewState.EXPANDED) {
+                mMraidListener.onExpand();
+            } else if (viewState == ViewState.HIDDEN) {
+                mMraidListener.onClose();
+            }
+        }
+
+        updateScreenMetricsAsync(successRunnable);
+    }
+
+    int clampInt(int min, int target, int max) {
+        return Math.max(min, Math.min(target, max));
+    }
+
+    @VisibleForTesting
+    void handleResize(final int widthDips, final int heightDips, final int offsetXDips,
+            final int offsetYDips, @NonNull final ClosePosition closePosition,
+            final boolean allowOffscreen)
+            throws MraidCommandException {
+        if (mMraidWebView == null) {
+            throw new MraidCommandException("Unable to resize after the WebView is destroyed");
+        }
+
+        // The spec says that there is no effect calling resize from loaded or hidden, but that
+        // calling it from expanded should raise an error.
+        if (mViewState == ViewState.LOADING
+                || mViewState == ViewState.HIDDEN) {
+            return;
+        } else if (mViewState == ViewState.EXPANDED) {
+            throw new MraidCommandException("Not allowed to resize from an already expanded ad");
+        }
+
+        if (mPlacementType == PlacementType.INTERSTITIAL) {
+            throw new MraidCommandException("Not allowed to resize from an interstitial ad");
+        }
+
+        // Translate coordinates to px and get the resize rect
+        int width = Dips.dipsToIntPixels(widthDips, mContext);
+        int height = Dips.dipsToIntPixels(heightDips, mContext);
+        int offsetX = Dips.dipsToIntPixels(offsetXDips, mContext);
+        int offsetY = Dips.dipsToIntPixels(offsetYDips, mContext);
+        int left = mScreenMetrics.getDefaultAdRect().left + offsetX;
+        int top = mScreenMetrics.getDefaultAdRect().top + offsetY;
+        Rect resizeRect = new Rect(left, top, left + width, top + height);
+
+        if (!allowOffscreen) {
+            // Require the entire ad to be on-screen.
+            Rect bounds = mScreenMetrics.getRootViewRect();
+            if (resizeRect.width() > bounds.width() || resizeRect.height() > bounds.height()) {
+                throw new MraidCommandException("resizeProperties specified a size ("
+                        + widthDips + ", " + heightDips + ") and offset ("
+                        + offsetXDips + ", " + offsetYDips + ") that doesn't allow the ad to"
+                        + " appear within the max allowed size ("
+                        + mScreenMetrics.getRootViewRectDips().width() + ", "
+                        + mScreenMetrics.getRootViewRectDips().height() + ")");
+            }
+
+            // Offset the resize rect so that it displays on the screen
+            int newLeft = clampInt(bounds.left, resizeRect.left, bounds.right - resizeRect.width());
+            int newTop = clampInt(bounds.top, resizeRect.top, bounds.bottom - resizeRect.height());
+            resizeRect.offsetTo(newLeft, newTop);
+        }
+
+        // The entire close region must always be visible.
+        Rect closeRect = new Rect();
+        mCloseableAdContainer.applyCloseRegionBounds(closePosition, resizeRect, closeRect);
+        if (!mScreenMetrics.getRootViewRect().contains(closeRect)) {
+            throw new MraidCommandException("resizeProperties specified a size ("
+                    + widthDips + ", " + heightDips + ") and offset ("
+                    + offsetXDips + ", " + offsetYDips + ") that doesn't allow the close"
+                    + " region to appear within the max allowed size ("
+                    + mScreenMetrics.getRootViewRectDips().width() + ", "
+                    + mScreenMetrics.getRootViewRectDips().height() + ")");
+        }
+
+        if (!resizeRect.contains(closeRect)) {
+            throw new MraidCommandException("resizeProperties specified a size ("
+                    + widthDips + ", " + height + ") and offset ("
+                    + offsetXDips + ", " + offsetYDips + ") that don't allow the close region to appear "
+                    + "within the resized ad.");
+        }
+
+        // Resized ads always rely on the creative's close button (as if useCustomClose were true)
+        mCloseableAdContainer.setCloseVisible(false);
+        mCloseableAdContainer.setClosePosition(closePosition);
+
+        // Put the ad in the closeable container and resize it
+        LayoutParams layoutParams = new LayoutParams(resizeRect.width(), resizeRect.height());
+        layoutParams.leftMargin = resizeRect.left - mScreenMetrics.getRootViewRect().left;
+        layoutParams.topMargin = resizeRect.top - mScreenMetrics.getRootViewRect().top;
+        if (mViewState == ViewState.DEFAULT) {
+            mDefaultAdContainer.removeView(mMraidWebView);
+            mDefaultAdContainer.setVisibility(View.INVISIBLE);
+            mCloseableAdContainer.addView(mMraidWebView,
+                    new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
+            getRootView().addView(mCloseableAdContainer, layoutParams);
+        } else if (mViewState == ViewState.RESIZED) {
+            mCloseableAdContainer.setLayoutParams(layoutParams);
+        }
+        mCloseableAdContainer.setClosePosition(closePosition);
+
+        setViewState(ViewState.RESIZED);
+    }
+
+    void handleExpand(@Nullable URI uri, boolean shouldUseCustomClose)
+            throws MraidCommandException {
+        if (mMraidWebView == null) {
+            throw new MraidCommandException("Unable to expand after the WebView is destroyed");
+        }
+
+        if (mPlacementType == PlacementType.INTERSTITIAL) {
+            return;
+        }
+
+        if (mViewState != ViewState.DEFAULT && mViewState != ViewState.RESIZED) {
+            return;
+        }
+
+        applyOrientation();
+
+        // For two part expands, create a new web view
+        boolean isTwoPart = (uri != null);
+        if (isTwoPart) {
+            // Of note: the two part ad will start off with its view state as LOADING, and will
+            // transition to EXPANDED once the page is fully loaded
+            mTwoPartWebView = new MraidWebView(mContext);
+            mTwoPartBridge.attachView(mTwoPartWebView);
+
+            // onPageLoaded gets fired once the html is loaded into the two part webView
+            mTwoPartBridge.setContentUrl(uri.toString());
+        }
+
+        // Make sure the correct webView is in the closeable  container and make it full screen
+        LayoutParams layoutParams = new LayoutParams(
+                LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
+        if (mViewState == ViewState.DEFAULT) {
+            if (isTwoPart) {
+                mCloseableAdContainer.addView(mTwoPartWebView, layoutParams);
+            } else {
+                mDefaultAdContainer.removeView(mMraidWebView);
+                mDefaultAdContainer.setVisibility(View.INVISIBLE);
+                mCloseableAdContainer.addView(mMraidWebView, layoutParams);
+            }
+            getRootView().addView(mCloseableAdContainer,
+                    new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
+        } else if (mViewState == ViewState.RESIZED) {
+            if (isTwoPart) {
+                // Move the ad back to the original container so that when we close the
+                // resized ad, it will be in the correct place
+                mCloseableAdContainer.removeView(mMraidWebView);
+                mDefaultAdContainer.addView(mMraidWebView, layoutParams);
+                mDefaultAdContainer.setVisibility(View.INVISIBLE);
+                mCloseableAdContainer.addView(mTwoPartWebView, layoutParams);
+            }
+            // If we were resized and not 2 part, nothing to do.
+        }
+        mCloseableAdContainer.setLayoutParams(layoutParams);
+        handleCustomClose(shouldUseCustomClose);
+
+        // Update to expanded once we have new screen metrics. This won't update the two-part ad,
+        // because it is not yet loaded.
+        setViewState(ViewState.EXPANDED);
+    }
+
+    @VisibleForTesting
+    void handleClose() {
+        if (mMraidWebView == null) {
+            // Doesn't throw an exception because the ad has been destroyed
+            return;
+        }
+
+        if (mViewState == ViewState.LOADING || mViewState == ViewState.HIDDEN) {
+            return;
+        }
+
+        // Unlock the orientation before changing the view hierarchy.
+        if (mViewState == ViewState.EXPANDED || mPlacementType == PlacementType.INTERSTITIAL) {
+            unApplyOrientation();
+        }
+
+        if (mViewState == ViewState.RESIZED || mViewState == ViewState.EXPANDED) {
+            if (mTwoPartBridge.isAttached() && mTwoPartWebView != null) {
+                // If we have a two part web view, simply remove it from the closeable container
+                mCloseableAdContainer.removeView(mTwoPartWebView);
+                mTwoPartBridge.detach();
+            } else {
+                // Move the web view from the closeable container back to the default container
+                mCloseableAdContainer.removeView(mMraidWebView);
+                mDefaultAdContainer.addView(mMraidWebView, new LayoutParams(
+                        LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
+                mDefaultAdContainer.setVisibility(View.VISIBLE);
+            }
+            getRootView().removeView(mCloseableAdContainer);
+
+            // Set the view state to default
+            setViewState(ViewState.DEFAULT);
+        } else if (mViewState == ViewState.DEFAULT) {
+            mDefaultAdContainer.setVisibility(View.INVISIBLE);
+            setViewState(ViewState.HIDDEN);
+        }
+    }
+
+    @NonNull
+    @TargetApi(VERSION_CODES.KITKAT)
+    private ViewGroup getRootView() {
+        if (mRootView == null) {
+            // This method should never be called this method before the container is ready, ie before
+            // handlePageLoad.
+            if (VERSION.SDK_INT >= VERSION_CODES.KITKAT) {
+                Preconditions.checkState(mDefaultAdContainer.isAttachedToWindow());
+            }
+
+            mRootView = (ViewGroup) mDefaultAdContainer.getRootView().findViewById(
+                    android.R.id.content);
+        }
+
+        return mRootView;
+    }
+
+    @VisibleForTesting
+    void handleShowVideo(@NonNull String videoUrl) {
+        MraidVideoPlayerActivity.startMraid(mContext, videoUrl);
+    }
+
+    @VisibleForTesting
+    void lockOrientation(final int screenOrientation) throws MraidCommandException {
+        final Activity activity = mWeakActivity.get();
+        if (activity == null || !shouldAllowForceOrientation(mForceOrientation)) {
+            throw new MraidCommandException("Attempted to lock orientation to unsupported value: " +
+                    mForceOrientation.name());
+        }
+
+        if (mOriginalActivityOrientation == null) {
+            mOriginalActivityOrientation = activity.getRequestedOrientation();
+        }
+
+        activity.setRequestedOrientation(screenOrientation);
+    }
+
+    @VisibleForTesting
+    void applyOrientation() throws MraidCommandException {
+        if (mForceOrientation == MraidOrientation.NONE) {
+            if (mAllowOrientationChange) {
+                // If screen orientation can be changed, an orientation of NONE means that any
+                // orientation lock should be removed
+                unApplyOrientation();
+            } else {
+                final Activity activity = mWeakActivity.get();
+                if (activity == null) {
+                    throw new MraidCommandException("Unable to set MRAID expand orientation to " +
+                            "'none'; expected passed in Activity Context.");
+                }
+
+                // If screen orientation cannot be changed and we can obtain the current
+                // screen orientation, locking it to the current orientation is a best effort
+                lockOrientation(DeviceUtils.getScreenOrientation(activity));
+            }
+        } else {
+            // Otherwise, we have a valid, non-NONE orientation. Lock the screen based on this value
+            lockOrientation(mForceOrientation.getActivityInfoOrientation());
+        }
+    }
+
+    @VisibleForTesting
+    void unApplyOrientation() {
+        final Activity activity = mWeakActivity.get();
+        if (activity != null && mOriginalActivityOrientation != null) {
+            activity.setRequestedOrientation(mOriginalActivityOrientation);
+        }
+        mOriginalActivityOrientation = null;
+    }
+
+    @TargetApi(VERSION_CODES.HONEYCOMB_MR2)
+    @VisibleForTesting
+    boolean shouldAllowForceOrientation(final MraidOrientation newOrientation) {
+        // NONE is the default and always allowed
+        if (newOrientation == MraidOrientation.NONE) {
+            return true;
+        }
+
+        final Activity activity = mWeakActivity.get();
+        // If we can't obtain an Activity, return false
+        if (activity == null) {
+            return false;
+        }
+
+        final ActivityInfo activityInfo;
+        try {
+            activityInfo = activity.getPackageManager().getActivityInfo(
+                    new ComponentName(activity, activity.getClass()), 0);
+        } catch (PackageManager.NameNotFoundException e) {
+            return false;
+        }
+
+        // If an orientation is explicitly declared in the manifest, allow forcing this orientation
+        final int activityOrientation = activityInfo.screenOrientation;
+        if (activityOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
+            return activityOrientation == newOrientation.getActivityInfoOrientation();
+        }
+
+        // Make sure the config changes won't tear down the activity when moving to this orientation
+        // The necessary configChanges must always include "orientation"
+        boolean containsNecessaryConfigChanges =
+                bitMaskContainsFlag(activityInfo.configChanges, CONFIG_ORIENTATION);
+
+        // And on API 13+, configChanges must also include "screenSize"
+        if (VERSION.SDK_INT >= VERSION_CODES.HONEYCOMB_MR2) {
+            containsNecessaryConfigChanges = containsNecessaryConfigChanges
+                    && bitMaskContainsFlag(activityInfo.configChanges, CONFIG_SCREEN_SIZE);
+        }
+
+        return containsNecessaryConfigChanges;
+    }
+
+    @VisibleForTesting
+    void handleCustomClose(boolean useCustomClose) {
+        boolean wasUsingCustomClose = !mCloseableAdContainer.isCloseVisible();
+        if (useCustomClose == wasUsingCustomClose) {
+            return;
+        }
+
+        mCloseableAdContainer.setCloseVisible(!useCustomClose);
+        if (mOnCloseButtonListener != null) {
+            mOnCloseButtonListener.useCustomCloseChanged(useCustomClose);
+        }
+    }
+
+    @NonNull
+    public FrameLayout getAdContainer() {
+        return mDefaultAdContainer;
+    }
+
+    /**
+     * Loads a javascript URL. Useful for running callbacks, such as javascript:webviewDidClose()
+     */
+    public void loadJavascript(@NonNull String javascript) {
+        mMraidBridge.injectJavaScript(javascript);
+    }
+
+    @VisibleForTesting
+    class OrientationBroadcastReceiver extends BroadcastReceiver {
+        @Nullable private Context mContext;
+
+        // -1 until this gets set at least once
+        private int mLastRotation = -1;
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (mContext == null) {
+                return;
+            }
+
+            if (Intent.ACTION_CONFIGURATION_CHANGED.equals(intent.getAction())) {
+                int orientation = getDisplayRotation();
+
+                if (orientation != mLastRotation) {
+                    mLastRotation = orientation;
+                    handleOrientationChange(mLastRotation);
+                }
+            }
+        }
+
+        public void register(@NonNull final Context context) {
+            Preconditions.checkNotNull(context);
+            mContext = context.getApplicationContext();
+            if (mContext != null) {
+                mContext.registerReceiver(this,
+                        new IntentFilter(Intent.ACTION_CONFIGURATION_CHANGED));
+            }
+        }
+
+        public void unregister() {
+            if (mContext != null) {
+                mContext.unregisterReceiver(this);
+                mContext = null;
+            }
+        }
+    }
+
+    @NonNull
+    public Context getContext() {
+        return mContext;
+    }
+
+    @VisibleForTesting
+    void handleSetOrientationProperties(final boolean allowOrientationChange,
+            final MraidOrientation forceOrientation) throws MraidCommandException {
+        if (!shouldAllowForceOrientation(forceOrientation)) {
+            throw new MraidCommandException(
+                    "Unable to force orientation to " + forceOrientation);
+        }
+
+        mAllowOrientationChange = allowOrientationChange;
+        mForceOrientation = forceOrientation;
+
+        if (mViewState == ViewState.EXPANDED || mPlacementType == PlacementType.INTERSTITIAL) {
+            applyOrientation();
+        }
+    }
+
+    /**
+     * Attempts to handle mopubnativebrowser links in the device browser, deep-links in the
+     * corresponding application, and all other links in the MoPub in-app browser.
+     */
+    @VisibleForTesting
+    void handleOpen(@NonNull final String url) {
+        MoPubLog.d("Opening url: " + url);
+
+        if (mMraidListener != null) {
+            mMraidListener.onOpen();
+        }
+
+        if (Intents.isAboutScheme(url)) {
+            MoPubLog.d("Link to about page ignored.");
+            return;
+        }
+
+        // MoPubNativeBrowser URLs
+        if (Intents.isNativeBrowserScheme(url)) {
+            try {
+                final Intent intent = Intents.intentForNativeBrowserScheme(url);
+                Intents.startActivity(mContext, intent);
+            } catch (UrlParseException e) {
+                MoPubLog.d("Unable to load mopub native browser url: " + url + ". "
+                        + e.getMessage());
+            } catch (IntentNotResolvableException e) {
+                MoPubLog.d("Unable to load mopub native browser url: " + url + ". "
+                        + e.getMessage());
+            }
+
+            return;
+        }
+
+        if (Intents.isHttpUrl(url)) {
+            final Bundle extras = new Bundle();
+            extras.putString(MoPubBrowser.DESTINATION_URL_KEY, url);
+
+            final Intent intent = Intents.getStartActivityIntent(mContext, MoPubBrowser.class,
+                    extras);
+            try {
+                Intents.startActivity(mContext, intent);
+            } catch (IntentNotResolvableException e) {
+                MoPubLog.d("Unable to launch intent for URL: " + url + ".");
+            }
+            return;
+        }
+
+        // Non-http(s) URLs like app deep links
+        if (Intents.canHandleApplicationUrl(mContext, url)) {
+            final Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
+
+            try {
+                Intents.startActivity(mContext, intent);
+            } catch (IntentNotResolvableException e) {
+                MoPubLog.d("Unable to resolve application url: " + url);
+            }
+            return;
+        }
+
+        MoPubLog.d("Link ignored. Unable to handle url: " + url);
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    @NonNull
+    ViewState getViewState() {
+        return mViewState;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    void setViewStateForTesting(@NonNull ViewState viewState) {
+        mViewState = viewState;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    @NonNull
+    CloseableLayout getExpandedAdContainer() {
+        return mCloseableAdContainer;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    void setRootView(FrameLayout rootView) {
+        mRootView = rootView;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    void setRootViewSize(int width, int height) {
+        mScreenMetrics.setRootViewPosition(0, 0, width, height);
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    Integer getOriginalActivityOrientation() {
+        return mOriginalActivityOrientation;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    boolean getAllowOrientationChange() {
+        return mAllowOrientationChange;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    MraidOrientation getForceOrientation() {
+        return mForceOrientation;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    void setOrientationBroadcastReceiver(OrientationBroadcastReceiver receiver) {
+        mOrientationBroadcastReceiver = receiver;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    MraidWebView getMraidWebView() {
+        return mMraidWebView;
+    }
+
+    @VisibleForTesting
+    @Deprecated // for testing
+    MraidWebView getTwoPartWebView() {
+        return mTwoPartWebView;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidInterstitial.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidInterstitial.java
new file mode 100644
index 00000000..f7e1ae39
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidInterstitial.java
@@ -0,0 +1,31 @@
+package com.mopub.mraid;
+
+
+import android.support.annotation.NonNull;
+
+import com.mopub.mobileads.MraidActivity;
+import com.mopub.mobileads.ResponseBodyInterstitial;
+
+import java.util.Map;
+
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
+
+class MraidInterstitial extends ResponseBodyInterstitial {
+    private String mHtmlData;
+
+    @Override
+    protected void extractExtras(Map<String, String> serverExtras) {
+        mHtmlData = serverExtras.get(HTML_RESPONSE_BODY_KEY);
+    }
+
+    @Override
+    protected void preRenderHtml(@NonNull CustomEventInterstitialListener
+            customEventInterstitialListener) {
+        MraidActivity.preRenderHtml(mContext, customEventInterstitialListener, mHtmlData);
+    }
+
+    @Override
+    public void showInterstitial() {
+        MraidActivity.start(mContext, mAdReport, mHtmlData, mBroadcastIdentifier);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidJavascriptCommand.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidJavascriptCommand.java
new file mode 100644
index 00000000..bb1b175e
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidJavascriptCommand.java
@@ -0,0 +1,70 @@
+package com.mopub.mraid;
+
+import android.support.annotation.NonNull;
+
+public enum MraidJavascriptCommand {
+    CLOSE("close"),
+    EXPAND("expand") {
+        @Override
+        boolean requiresClick(@NonNull final PlacementType placementType) {
+            return placementType == PlacementType.INLINE;
+        }
+    },
+    USE_CUSTOM_CLOSE("usecustomclose"),
+    OPEN("open") {
+        @Override
+        boolean requiresClick(@NonNull final PlacementType placementType) {
+            return true;
+        }
+    },
+    RESIZE("resize") {
+        @Override
+        boolean requiresClick(@NonNull final PlacementType placementType) {
+            return true;
+        }
+    },
+    SET_ORIENTATION_PROPERTIES("setOrientationProperties"),
+    PLAY_VIDEO("playVideo") {
+        @Override
+        boolean requiresClick(@NonNull final PlacementType placementType) {
+            return placementType == PlacementType.INLINE;
+        }
+    },
+    STORE_PICTURE("storePicture") {
+        @Override
+        boolean requiresClick(@NonNull final PlacementType placementType) {
+            return true;
+        }
+    },
+    CREATE_CALENDAR_EVENT("createCalendarEvent") {
+        @Override
+        boolean requiresClick(@NonNull final PlacementType placementType) {
+            return true;
+        }
+    },
+    UNSPECIFIED("");
+
+    @NonNull private final String mJavascriptString;
+
+    MraidJavascriptCommand(@NonNull String javascriptString) {
+        mJavascriptString = javascriptString;
+    }
+
+    static MraidJavascriptCommand fromJavascriptString(@NonNull String string) {
+        for (MraidJavascriptCommand command : MraidJavascriptCommand.values()) {
+            if (command.mJavascriptString.equals(string)) {
+                return command;
+            }
+        }
+
+        return UNSPECIFIED;
+    }
+
+    String toJavascriptString() {
+        return mJavascriptString;
+    }
+
+    boolean requiresClick(@NonNull PlacementType placementType) {
+        return false;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidNativeCommandHandler.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidNativeCommandHandler.java
new file mode 100644
index 00000000..bc0a2d82
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidNativeCommandHandler.java
@@ -0,0 +1,582 @@
+package com.mopub.mraid;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.content.ActivityNotFoundException;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.media.MediaScannerConnection;
+import android.net.Uri;
+import android.os.AsyncTask;
+import android.os.Build.VERSION_CODES;
+import android.os.Environment;
+import android.provider.CalendarContract;
+import android.support.annotation.NonNull;
+import android.view.View;
+import android.view.Window;
+import android.view.WindowManager;
+import android.widget.Toast;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.AsyncTasks;
+import com.mopub.common.util.Intents;
+import com.mopub.common.util.Streams;
+import com.mopub.common.util.Utils;
+import com.mopub.common.util.VersionCode;
+import com.mopub.mobileads.factories.HttpClientFactory;
+import com.mopub.network.HeaderUtils;
+
+import org.apache.http.Header;
+import org.apache.http.HttpResponse;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.methods.HttpGet;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.URI;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
+
+import static android.Manifest.permission.WRITE_EXTERNAL_STORAGE;
+import static android.os.Environment.MEDIA_MOUNTED;
+import static com.mopub.common.HttpClient.*;
+import static com.mopub.common.util.ResponseHeader.LOCATION;
+
+public class MraidNativeCommandHandler {
+    interface MraidCommandFailureListener {
+        void onFailure(MraidCommandException exception);
+    }
+
+    @VisibleForTesting
+    static final String MIME_TYPE_HEADER = "Content-Type";
+
+    private static final int MAX_NUMBER_DAYS_IN_MONTH = 31;
+    private static final String[] DATE_FORMATS = {
+            "yyyy-MM-dd'T'HH:mm:ssZZZZZ",
+            "yyyy-MM-dd'T'HH:mmZZZZZ"
+    };
+
+    public static final String ANDROID_CALENDAR_CONTENT_TYPE = "vnd.android.cursor.item/event";
+
+    void createCalendarEvent(final Context context, final Map<String, String> params)
+            throws MraidCommandException {
+        if (isCalendarAvailable(context)) {
+            try {
+                Map<String, Object> calendarParams = translateJSParamsToAndroidCalendarEventMapping(params);
+                Intent intent = new Intent(Intent.ACTION_INSERT).setType(ANDROID_CALENDAR_CONTENT_TYPE);
+                for (String key : calendarParams.keySet()) {
+                    Object value = calendarParams.get(key);
+                    if (value instanceof Long) {
+                        intent.putExtra(key, ((Long) value).longValue());
+                    } else if (value instanceof Integer) {
+                        intent.putExtra(key, ((Integer) value).intValue());
+                    } else {
+                        intent.putExtra(key, (String) value);
+                    }
+                }
+                intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+                context.startActivity(intent);
+            } catch (ActivityNotFoundException e) {
+                MoPubLog.d("no calendar app installed");
+                throw new MraidCommandException(
+                        "Action is unsupported on this device - no calendar app installed");
+            } catch (IllegalArgumentException e) {
+                MoPubLog.d("create calendar: invalid parameters " + e.getMessage());
+                throw new MraidCommandException(e);
+            } catch (Exception e) {
+                MoPubLog.d("could not create calendar event");
+                throw new MraidCommandException(e);
+            }
+        } else {
+            MoPubLog.d("unsupported action createCalendarEvent for devices pre-ICS");
+            throw new MraidCommandException("Action is " +
+                    "unsupported on this device (need Android version Ice Cream Sandwich or " +
+                    "above)");
+        }
+    }
+
+    void storePicture(@NonNull final Context context,
+            @NonNull final String imageUrl,
+            @NonNull MraidCommandFailureListener failureListener) throws MraidCommandException {
+        if (!isStorePictureSupported(context)) {
+            MoPubLog.d("Error downloading file - the device does not have an SD card mounted, or " +
+                    "the Android permission is not granted.");
+            throw new MraidCommandException("Error downloading file " +
+                    " - the device does not have an SD card mounted, " +
+                    "or the Android permission is not granted.");
+        }
+
+        if (context instanceof Activity) {
+            showUserDialog(context, imageUrl, failureListener);
+        } else {
+            Toast.makeText(context, "Downloading image to Picture gallery...", Toast.LENGTH_SHORT).show();
+            downloadImage(context, imageUrl, failureListener);
+        }
+    }
+
+    boolean isTelAvailable(Context context) {
+        Intent telIntent = new Intent(Intent.ACTION_DIAL);
+        telIntent.setData(Uri.parse("tel:"));
+
+        return Intents.deviceCanHandleIntent(context, telIntent);
+    }
+
+    boolean isSmsAvailable(Context context) {
+        Intent smsIntent = new Intent(Intent.ACTION_VIEW);
+        smsIntent.setData(Uri.parse("sms:"));
+
+        return Intents.deviceCanHandleIntent(context, smsIntent);
+    }
+
+    public static boolean isStorePictureSupported(Context context) {
+        return MEDIA_MOUNTED.equals(Environment.getExternalStorageState())
+                && context.checkCallingOrSelfPermission(WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED;
+    }
+
+    static boolean isCalendarAvailable(Context context) {
+        Intent calendarIntent = new Intent(Intent.ACTION_INSERT).setType(ANDROID_CALENDAR_CONTENT_TYPE);
+
+        return VersionCode.currentApiLevel().isAtLeast(VersionCode.ICE_CREAM_SANDWICH)
+                && Intents.deviceCanHandleIntent(context, calendarIntent);
+    }
+
+    /**
+     * Inline video support was added in 3.1. Returns true if the activity has hardware acceleration
+     * enabled in its foreground window and only if the View or any ParentView in the view tree
+     * has not had hardware acceleration explicitly turned off.
+     */
+    // TargetApi is needed to access hardware accelerated flags
+    @TargetApi(11)
+    boolean isInlineVideoAvailable(@NonNull Activity activity, @NonNull View view) {
+        // In addition to potential hardware acceleration problems, there is a problem in the WebKit
+        // HTML5VideoView implementation pre-Gingerbread that would result in HTML5VideoViewProxy
+        // holding on to an instance of the WebView even after the WebView is destroyed. For
+        // this reason, we never allow inline video on Gingerbread devices.
+        if (VersionCode.currentApiLevel().isBelow(VersionCode.HONEYCOMB_MR1)) {
+            return false;
+        }
+
+        // Hardware Acceleration
+        // Hardware acceleration for the application and activity is enabled by default
+        // in API >= 14 (Ice Cream Sandwich)
+        // http://developer.android.com/reference/android/R.attr.html#hardwareAccelerated
+        // http://developer.android.com/guide/topics/graphics/hardware-accel.html
+
+        // HTML5 Inline Video
+        // http://developer.android.com/about/versions/android-3.1.html
+
+        // Traverse up the View tree to determine if any views are being software rendered
+        // You can only disable hardware acceleration at the view level by setting the layer type
+        View tempView = view;
+        while (true) {
+            // View#isHardwareAccelerated does not reflect the layer type used to render the view
+            // therefore we have to check for both
+            if (!tempView.isHardwareAccelerated()
+                    || Utils.bitMaskContainsFlag(tempView.getLayerType(), View.LAYER_TYPE_SOFTWARE)) {
+                return false;
+            }
+
+            // If parent is not a view or parent is null then break
+            if (!(tempView.getParent() instanceof View)) {
+                break;
+            }
+
+            tempView = (View)tempView.getParent();
+        }
+
+        // Has hardware acceleration been enabled in the current window?
+        // Hardware acceleration can only be enabled for a window, not disabled
+        // This flag is automatically set by the system if the android:hardwareAccelerated
+        // XML attribute is set to true on an activity or on the application.
+        // http://developer.android.com/reference/android/view/WindowManager.LayoutParams.html#FLAG_HARDWARE_ACCELERATED
+        Window window = activity.getWindow();
+        if (window != null) {
+            if (Utils.bitMaskContainsFlag(window.getAttributes().flags,
+                    WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @TargetApi(VERSION_CODES.ICE_CREAM_SANDWICH)
+    private Map<String, Object> translateJSParamsToAndroidCalendarEventMapping(Map<String, String> params) {
+        Map<String, Object> validatedParamsMapping = new HashMap<String, Object>();
+        if (!params.containsKey("description") || !params.containsKey("start")) {
+            throw new IllegalArgumentException("Missing start and description fields");
+        }
+
+        validatedParamsMapping.put(CalendarContract.Events.TITLE, params.get("description"));
+
+        if (params.containsKey("start") && params.get("start") != null) {
+            Date startDateTime = parseDate(params.get("start"));
+            if (startDateTime != null) {
+                validatedParamsMapping.put(CalendarContract.EXTRA_EVENT_BEGIN_TIME, startDateTime.getTime());
+            } else {
+                throw new IllegalArgumentException("Invalid calendar event: start time is malformed. Date format expecting (yyyy-MM-DDTHH:MM:SS-xx:xx) or (yyyy-MM-DDTHH:MM-xx:xx) i.e. 2013-08-14T09:00:01-08:00");
+            }
+        } else {
+            throw new IllegalArgumentException("Invalid calendar event: start is null.");
+        }
+
+        if (params.containsKey("end") && params.get("end") != null) {
+            Date endDateTime = parseDate(params.get("end"));
+            if (endDateTime != null) {
+                validatedParamsMapping.put(CalendarContract.EXTRA_EVENT_END_TIME, endDateTime.getTime());
+            } else {
+                throw new IllegalArgumentException("Invalid calendar event: end time is malformed. Date format expecting (yyyy-MM-DDTHH:MM:SS-xx:xx) or (yyyy-MM-DDTHH:MM-xx:xx) i.e. 2013-08-14T09:00:01-08:00");
+            }
+        }
+
+        if (params.containsKey("location")) {
+            validatedParamsMapping.put(CalendarContract.Events.EVENT_LOCATION, params.get("location"));
+        }
+
+        if (params.containsKey("summary")) {
+            validatedParamsMapping.put(CalendarContract.Events.DESCRIPTION, params.get("summary"));
+        }
+
+        if (params.containsKey("transparency")) {
+            validatedParamsMapping.put(
+                    CalendarContract.Events.AVAILABILITY,
+                    params.get("transparency").equals("transparent") ?
+                            CalendarContract.Events.AVAILABILITY_FREE :
+                            CalendarContract.Events.AVAILABILITY_BUSY
+            );
+        }
+
+        validatedParamsMapping.put(CalendarContract.Events.RRULE, parseRecurrenceRule(params));
+
+        return validatedParamsMapping;
+    }
+
+    private Date parseDate(String dateTime) {
+        Date result = null;
+        for (final String DATE_FORMAT : DATE_FORMATS) {
+            try {
+                result = new SimpleDateFormat(DATE_FORMAT, Locale.US).parse(dateTime);
+                if (result != null) {
+                    break;
+                }
+            } catch (ParseException e) {
+                // an exception is okay, just try the next format and find the first one that works
+            }
+        }
+        return result;
+    }
+
+    private String parseRecurrenceRule(Map<String, String> params) throws IllegalArgumentException {
+        StringBuilder rule = new StringBuilder();
+        if (params.containsKey("frequency")) {
+            String frequency = params.get("frequency");
+            int interval = -1;
+            if (params.containsKey("interval")) {
+                interval = Integer.parseInt(params.get("interval"));
+            }
+            if ("daily".equals(frequency)) {
+                rule.append("FREQ=DAILY;");
+                if (interval != -1) {
+                    rule.append("INTERVAL=" + interval + ";");
+                }
+            } else if ("weekly".equals(frequency)) {
+                rule.append("FREQ=WEEKLY;");
+                if (interval != -1) {
+                    rule.append("INTERVAL=" + interval + ";");
+                }
+                if (params.containsKey("daysInWeek")) {
+                    String weekdays = translateWeekIntegersToDays(params.get("daysInWeek"));
+                    if (weekdays == null) {
+                        throw new IllegalArgumentException("invalid ");
+                    }
+                    rule.append("BYDAY=" + weekdays + ";");
+                }
+            } else if ("monthly".equals(frequency)) {
+                rule.append("FREQ=MONTHLY;");
+                if (interval != -1) {
+                    rule.append("INTERVAL=" + interval + ";");
+                }
+                if (params.containsKey("daysInMonth")) {
+                    String monthDays = translateMonthIntegersToDays(params.get("daysInMonth"));
+                    if (monthDays == null) {
+                        throw new IllegalArgumentException();
+                    }
+                    rule.append("BYMONTHDAY=" + monthDays + ";");
+                }
+            } else {
+                throw new IllegalArgumentException("frequency is only supported for daily, weekly, and monthly.");
+            }
+        }
+        return rule.toString();
+    }
+
+    private String translateWeekIntegersToDays(String expression) throws IllegalArgumentException {
+        StringBuilder daysResult = new StringBuilder();
+        boolean[] daysAlreadyCounted = new boolean[7];
+        String[] days = expression.split(",");
+        int dayNumber;
+        for (final String day : days) {
+            dayNumber = Integer.parseInt(day);
+            dayNumber = dayNumber == 7 ? 0 : dayNumber;
+            if (!daysAlreadyCounted[dayNumber]) {
+                daysResult.append(dayNumberToDayOfWeekString(dayNumber) + ",");
+                daysAlreadyCounted[dayNumber] = true;
+            }
+        }
+        if (days.length == 0) {
+            throw new IllegalArgumentException("must have at least 1 day of the week if specifying repeating weekly");
+        }
+        daysResult.deleteCharAt(daysResult.length() - 1);
+        return daysResult.toString();
+    }
+
+    private String translateMonthIntegersToDays(String expression) throws IllegalArgumentException {
+        StringBuilder daysResult = new StringBuilder();
+        boolean[] daysAlreadyCounted = new boolean[2 * MAX_NUMBER_DAYS_IN_MONTH + 1]; //for -31 to 31
+        String[] days = expression.split(",");
+        int dayNumber;
+        for (final String day : days) {
+            dayNumber = Integer.parseInt(day);
+            if (!daysAlreadyCounted[dayNumber + MAX_NUMBER_DAYS_IN_MONTH]) {
+                daysResult.append(dayNumberToDayOfMonthString(dayNumber) + ",");
+                daysAlreadyCounted[dayNumber + MAX_NUMBER_DAYS_IN_MONTH] = true;
+            }
+        }
+        if (days.length == 0) {
+            throw new IllegalArgumentException("must have at least 1 day of the month if specifying repeating weekly");
+        }
+        daysResult.deleteCharAt(daysResult.length() - 1);
+        return daysResult.toString();
+    }
+
+    private String dayNumberToDayOfWeekString(int number) throws IllegalArgumentException {
+        String dayOfWeek;
+        switch (number) {
+            case 0:
+                dayOfWeek = "SU";
+                break;
+            case 1:
+                dayOfWeek = "MO";
+                break;
+            case 2:
+                dayOfWeek = "TU";
+                break;
+            case 3:
+                dayOfWeek = "WE";
+                break;
+            case 4:
+                dayOfWeek = "TH";
+                break;
+            case 5:
+                dayOfWeek = "FR";
+                break;
+            case 6:
+                dayOfWeek = "SA";
+                break;
+            default:
+                throw new IllegalArgumentException("invalid day of week " + number);
+        }
+        return dayOfWeek;
+    }
+
+    private String dayNumberToDayOfMonthString(int number) throws IllegalArgumentException {
+        String dayOfMonth;
+        // https://android.googlesource.com/platform/frameworks/opt/calendar/+/504844526f1b7afec048c6d2976ffb332670d5ba/src/com/android/calendarcommon2/EventRecurrence.java
+        if (number != 0 && number >= -MAX_NUMBER_DAYS_IN_MONTH && number <= MAX_NUMBER_DAYS_IN_MONTH) {
+            dayOfMonth = "" + number;
+        } else {
+            throw new IllegalArgumentException("invalid day of month " + number);
+        }
+        return dayOfMonth;
+    }
+
+    void downloadImage(final Context context, final String uriString,
+            final MraidCommandFailureListener failureListener) {
+        final DownloadImageAsyncTask downloadImageAsyncTask = new DownloadImageAsyncTask(context,
+                new DownloadImageAsyncTask.DownloadImageAsyncTaskListener() {
+                    @Override
+                    public void onSuccess() {
+                        MoPubLog.d("Image successfully saved.");
+                    }
+
+                    @Override
+                    public void onFailure() {
+                        Toast.makeText(context, "Image failed to download.", Toast.LENGTH_SHORT).show();
+                        MoPubLog.d("Error downloading and saving image file.");
+                        failureListener.onFailure(new MraidCommandException("Error " +
+                                "downloading and saving image file."));
+                    }
+                });
+        AsyncTasks.safeExecuteOnExecutor(downloadImageAsyncTask, uriString);
+    }
+
+    private void showUserDialog(final Context context, final String imageUrl,
+            final MraidCommandFailureListener failureListener) {
+        AlertDialog.Builder alertDialogDownloadImage = new AlertDialog.Builder(context);
+        alertDialogDownloadImage
+                .setTitle("Save Image")
+                .setMessage("Download image to Picture gallery?")
+                .setNegativeButton("Cancel", null)
+                .setPositiveButton("Okay", new DialogInterface.OnClickListener() {
+                    @Override
+                    public void onClick(DialogInterface dialog, int which) {
+                        downloadImage(context, imageUrl, failureListener);
+                    }
+                })
+                .setCancelable(true)
+                .show();
+    }
+
+    private static class DownloadImageAsyncTask extends AsyncTask<String, Void, Boolean> {
+        interface DownloadImageAsyncTaskListener {
+            void onSuccess();
+
+            void onFailure();
+        }
+
+        private final Context mContext;
+        private final DownloadImageAsyncTaskListener mListener;
+
+        public DownloadImageAsyncTask(@NonNull final Context context,
+                @NonNull final DownloadImageAsyncTaskListener listener) {
+            super();
+            mContext = context.getApplicationContext();
+            mListener = listener;
+        }
+
+        @Override
+        protected Boolean doInBackground(@NonNull String[] params) {
+            Preconditions.checkState(params.length > 0);
+            Preconditions.checkNotNull(params[0]);
+
+            final File pictureStoragePath = getPictureStoragePath();
+
+            //noinspection ResultOfMethodCallIgnored
+            pictureStoragePath.mkdirs();
+
+            final String uriString = params[0];
+            URI uri = URI.create(uriString);
+
+            final HttpClient httpClient = HttpClientFactory.create();
+            final HttpGet httpGet = initializeHttpGet(uri.toString());
+
+            InputStream pictureInputStream = null;
+            OutputStream pictureOutputStream = null;
+            try {
+                final HttpResponse httpResponse = httpClient.execute(httpGet);
+                pictureInputStream = httpResponse.getEntity().getContent();
+
+                final String redirectLocation = HeaderUtils.extractHeader(httpResponse, LOCATION);
+                if (redirectLocation != null) {
+                    uri = URI.create(redirectLocation);
+                }
+
+                final String pictureFileName = getFileNameForUriAndHttpResponse(uri, httpResponse);
+                final File pictureFile = new File(pictureStoragePath, pictureFileName);
+                pictureOutputStream = new FileOutputStream(pictureFile);
+                Streams.copyContent(pictureInputStream, pictureOutputStream);
+
+                final String pictureFileFullPath = pictureFile.toString();
+                loadPictureIntoGalleryApp(pictureFileFullPath);
+
+                return true;
+            } catch (IOException e) {
+                return false;
+            } finally {
+                Streams.closeStream(pictureInputStream);
+                Streams.closeStream(pictureOutputStream);
+            }
+        }
+
+        @Override
+        protected void onPostExecute(final Boolean success) {
+            if (success != null && success) {
+                mListener.onSuccess();
+            } else {
+                mListener.onFailure();
+            }
+        }
+
+        private String getFileNameForUriAndHttpResponse(final URI uri, final HttpResponse response) {
+            final String path = uri.getPath();
+
+            if (path == null) {
+                return null;
+            }
+
+            String filename = new File(path).getName();
+
+            Header header = response.getFirstHeader(MIME_TYPE_HEADER);
+            if (header != null) {
+                String[] fields = header.getValue().split(";");
+                for (final String field : fields) {
+                    String extension;
+                    if (field.contains("image/")) {
+                        extension = "." + field.split("/")[1];
+                        if (!filename.endsWith(extension)) {
+                            filename += extension;
+                        }
+                        break;
+                    }
+                }
+            }
+
+            return filename;
+        }
+
+        private File getPictureStoragePath() {
+            return new File(Environment.getExternalStorageDirectory(), "Pictures");
+        }
+
+        private void loadPictureIntoGalleryApp(final String filename) {
+            MoPubMediaScannerConnectionClient mediaScannerConnectionClient =
+                    new MoPubMediaScannerConnectionClient(filename, null);
+            final MediaScannerConnection mediaScannerConnection =
+                    new MediaScannerConnection(mContext, mediaScannerConnectionClient);
+            mediaScannerConnectionClient.setMediaScannerConnection(mediaScannerConnection);
+            mediaScannerConnection.connect();
+        }
+    }
+
+    private static class MoPubMediaScannerConnectionClient
+            implements MediaScannerConnection.MediaScannerConnectionClient {
+        private final String mFilename;
+        private final String mMimeType;
+        private MediaScannerConnection mMediaScannerConnection;
+
+        private MoPubMediaScannerConnectionClient(String filename, String mimeType) {
+            mFilename = filename;
+            mMimeType = mimeType;
+        }
+
+        private void setMediaScannerConnection(MediaScannerConnection connection) {
+            mMediaScannerConnection = connection;
+        }
+
+        @Override
+        public void onMediaScannerConnected() {
+            if (mMediaScannerConnection != null) {
+                mMediaScannerConnection.scanFile(mFilename, mMimeType);
+            }
+        }
+
+        @Override
+        public void onScanCompleted(String path, Uri uri) {
+            if (mMediaScannerConnection != null) {
+                mMediaScannerConnection.disconnect();
+            }
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidOrientation.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidOrientation.java
new file mode 100644
index 00000000..5b2bdb56
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidOrientation.java
@@ -0,0 +1,19 @@
+package com.mopub.mraid;
+
+import android.content.pm.ActivityInfo;
+
+enum MraidOrientation {
+    PORTRAIT(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT),
+    LANDSCAPE(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE),
+    NONE(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
+
+    private final int mActivityInfoOrientation;
+
+    MraidOrientation(final int activityInfoOrientation) {
+        mActivityInfoOrientation = activityInfoOrientation;
+    }
+
+    int getActivityInfoOrientation() {
+        return mActivityInfoOrientation;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidScreenMetrics.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidScreenMetrics.java
new file mode 100644
index 00000000..972a0577
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidScreenMetrics.java
@@ -0,0 +1,118 @@
+package com.mopub.mraid;
+
+import android.content.Context;
+import android.graphics.Rect;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.util.Dips;
+
+/**
+ * Screen metrics needed by the MRAID container.
+ *
+ * Each rectangle is stored using both it's original and scaled coordinates to avoid allocating
+ * extra memory that would otherwise be needed to do these conversions.
+ */
+class MraidScreenMetrics {
+    @NonNull private final Context mContext;
+    @NonNull private final Rect mScreenRect;
+    @NonNull private final Rect mScreenRectDips;
+
+    @NonNull private final Rect mRootViewRect;
+    @NonNull private final Rect mRootViewRectDips;
+
+    @NonNull private final Rect mCurrentAdRect;
+    @NonNull private final Rect mCurrentAdRectDips;
+
+    @NonNull private final Rect mDefaultAdRect;
+    @NonNull private final Rect mDefaultAdRectDips;
+
+    private final float mDensity;
+
+    MraidScreenMetrics(Context context, float density) {
+        mContext = context.getApplicationContext();
+        mDensity = density;
+
+        mScreenRect = new Rect();
+        mScreenRectDips = new Rect();
+
+        mRootViewRect = new Rect();
+        mRootViewRectDips = new Rect();
+
+        mCurrentAdRect = new Rect();
+        mCurrentAdRectDips = new Rect();
+
+        mDefaultAdRect = new Rect();
+        mDefaultAdRectDips = new Rect();
+    }
+
+    private void convertToDips(Rect sourceRect, Rect outRect) {
+        outRect.set(Dips.pixelsToIntDips(sourceRect.left, mContext),
+                Dips.pixelsToIntDips(sourceRect.top, mContext),
+                Dips.pixelsToIntDips(sourceRect.right, mContext),
+                Dips.pixelsToIntDips(sourceRect.bottom, mContext));
+    }
+
+    public float getDensity() {
+        return mDensity;
+    }
+
+    void setScreenSize(int width, int height) {
+        mScreenRect.set(0, 0, width, height);
+        convertToDips(mScreenRect, mScreenRectDips);
+    }
+
+    @NonNull
+    Rect getScreenRect() {
+        return mScreenRect;
+    }
+
+    @NonNull
+    Rect getScreenRectDips() {
+        return mScreenRectDips;
+    }
+
+    void setRootViewPosition(int x, int y, int width, int height) {
+        mRootViewRect.set(x, y, x + width, y + height);
+        convertToDips(mRootViewRect, mRootViewRectDips);
+    }
+
+    @NonNull
+    Rect getRootViewRect() {
+        return mRootViewRect;
+    }
+
+    @NonNull
+    Rect getRootViewRectDips() {
+        return mRootViewRectDips;
+    }
+
+    void setCurrentAdPosition(int x, int y, int width, int height) {
+        mCurrentAdRect.set(x, y, x + width, y + height);
+        convertToDips(mCurrentAdRect, mCurrentAdRectDips);
+    }
+
+    @NonNull
+    Rect getCurrentAdRect() {
+        return mCurrentAdRect;
+    }
+
+    @NonNull
+    Rect getCurrentAdRectDips() {
+        return mCurrentAdRectDips;
+    }
+
+    void setDefaultAdPosition(int x, int y, int width, int height) {
+        mDefaultAdRect.set(x, y, x + width, y + height);
+        convertToDips(mDefaultAdRect, mDefaultAdRectDips);
+    }
+
+    @NonNull
+    Rect getDefaultAdRect() {
+        return mDefaultAdRect;
+    }
+
+    @NonNull
+    Rect getDefaultAdRectDips() {
+        return mDefaultAdRectDips;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidVideoViewController.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidVideoViewController.java
similarity index 80%
rename from mopub-sdk/src/main/java/com/mopub/mobileads/MraidVideoViewController.java
rename to mopub-sdk/src/main/java/com/mopub/mraid/MraidVideoViewController.java
index 06111b88..ddf7e408 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidVideoViewController.java
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidVideoViewController.java
@@ -1,4 +1,4 @@
-package com.mopub.mobileads;
+package com.mopub.mraid;
 
 import android.content.Context;
 import android.graphics.drawable.StateListDrawable;
@@ -8,7 +8,9 @@
 import android.widget.ImageButton;
 import android.widget.RelativeLayout;
 import android.widget.VideoView;
+
 import com.mopub.common.util.Dips;
+import com.mopub.mobileads.BaseVideoViewController;
 
 import static android.view.View.GONE;
 import static android.view.View.OnClickListener;
@@ -26,8 +28,9 @@
     private int mButtonPadding;
     private int mButtonSize;
 
-    MraidVideoViewController(final Context context, final Bundle bundle, final long broadcastIdentifier, final BaseVideoViewControllerListener baseVideoViewControllerListener) {
-        super(context, broadcastIdentifier, baseVideoViewControllerListener);
+    public MraidVideoViewController(final Context context, final Bundle bundle, final BaseVideoViewControllerListener baseVideoViewControllerListener) {
+        // No broadcast identifiers are used by MraidVideoViews.
+        super(context, null, baseVideoViewControllerListener);
 
         mVideoView = new VideoView(context);
         mVideoView.setOnCompletionListener(new MediaPlayer.OnCompletionListener() {
@@ -52,7 +55,7 @@ public boolean onError(MediaPlayer mediaPlayer, int what, int extra) {
     }
 
     @Override
-    void onCreate() {
+    protected void onCreate() {
         super.onCreate();
         mButtonSize = Dips.asIntPixels(CLOSE_BUTTON_SIZE, getContext());
         mButtonPadding = Dips.asIntPixels(CLOSE_BUTTON_PADDING, getContext());
@@ -62,25 +65,28 @@ void onCreate() {
     }
 
     @Override
-    VideoView getVideoView() {
+    protected VideoView getVideoView() {
         return mVideoView;
     }
 
     @Override
-    void onDestroy() {}
+    protected void onDestroy() {}
 
     @Override
-    void onPause() {}
+    protected void onPause() {}
 
     @Override
-    void onResume() {}
+    protected void onResume() {}
 
     private void createInterstitialCloseButton() {
         mCloseButton = new ImageButton(getContext());
         StateListDrawable states = new StateListDrawable();
-        states.addState(new int[] {-android.R.attr.state_pressed}, INTERSTITIAL_CLOSE_BUTTON_NORMAL.decodeImage(getContext()));
-        states.addState(new int[] {android.R.attr.state_pressed}, INTERSTITIAL_CLOSE_BUTTON_PRESSED.decodeImage(getContext()));
+        states.addState(new int[] {-android.R.attr.state_pressed}, INTERSTITIAL_CLOSE_BUTTON_NORMAL.createDrawable(
+                getContext()));
+        states.addState(new int[] {android.R.attr.state_pressed}, INTERSTITIAL_CLOSE_BUTTON_PRESSED.createDrawable(
+                getContext()));
         mCloseButton.setImageDrawable(states);
+        //noinspection deprecation
         mCloseButton.setBackgroundDrawable(null);
         mCloseButton.setOnClickListener(new OnClickListener() {
             public void onClick(View v) {
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidWebViewDebugListener.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidWebViewDebugListener.java
new file mode 100644
index 00000000..5d1d92c6
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidWebViewDebugListener.java
@@ -0,0 +1,25 @@
+package com.mopub.mraid;
+
+import android.support.annotation.NonNull;
+import android.webkit.ConsoleMessage;
+import android.webkit.JsResult;
+import android.webkit.WebChromeClient;
+import android.webkit.WebView;
+
+import com.mopub.common.VisibleForTesting;
+
+/**
+ * Debugging callback interface to make it easier for integration tests to debug MRAID ads.
+ */
+@VisibleForTesting
+public interface MraidWebViewDebugListener {
+    /**
+     * @see WebChromeClient#onJsAlert(WebView, String, String, JsResult)
+     */
+    boolean onJsAlert(@NonNull String message, @NonNull JsResult result);
+
+    /**
+     * @see WebChromeClient#onConsoleMessage(ConsoleMessage)
+     */
+    boolean onConsoleMessage(@NonNull ConsoleMessage consoleMessage);
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/PlacementType.java b/mopub-sdk/src/main/java/com/mopub/mraid/PlacementType.java
new file mode 100644
index 00000000..5d43c066
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/PlacementType.java
@@ -0,0 +1,12 @@
+package com.mopub.mraid;
+
+import java.util.Locale;
+
+public enum PlacementType {
+    INLINE,
+    INTERSTITIAL;
+
+    String toJavascriptString() {
+        return toString().toLowerCase(Locale.US);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/ViewState.java b/mopub-sdk/src/main/java/com/mopub/mraid/ViewState.java
new file mode 100644
index 00000000..40fc1cef
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/ViewState.java
@@ -0,0 +1,15 @@
+package com.mopub.mraid;
+
+import java.util.Locale;
+
+public enum ViewState {
+    LOADING,
+    DEFAULT,
+    RESIZED,
+    EXPANDED,
+    HIDDEN;
+
+    public String toJavascriptString() {
+        return toString().toLowerCase(Locale.US);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/AdapterHelper.java b/mopub-sdk/src/main/java/com/mopub/nativeads/AdapterHelper.java
index 6cc0ca94..28bd5620 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/AdapterHelper.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/AdapterHelper.java
@@ -2,9 +2,12 @@
 
 import android.app.Activity;
 import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 import android.view.ViewGroup;
 
+import com.mopub.common.Preconditions;
 import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
 
@@ -18,22 +21,17 @@
  */
 @Deprecated
 public final class AdapterHelper {
-    private final WeakReference<Activity> mActivity;
-    private final Context mApplicationContext;
+    @NonNull private final WeakReference<Activity> mActivity;
+    @NonNull private final Context mApplicationContext;
     private final int mStart;
     private final int mInterval;
 
     @Deprecated
-    public AdapterHelper(final Context context, final int start, final int interval) throws IllegalArgumentException {
-        if (context == null) {
-            throw new IllegalArgumentException("Illegal argument: Context was null.");
-        } else if (!(context instanceof Activity)) {
-            throw new IllegalArgumentException("Illegal argument: Context must be instance of Activity.");
-        } else if (start < 0) {
-            throw new IllegalArgumentException("Illegal argument: negative starting position.");
-        } else if (interval < 2) {
-            throw new IllegalArgumentException("Illegal argument: interval must be at least 2.");
-        }
+    public AdapterHelper(@NonNull final Context context, final int start, final int interval) {
+        Preconditions.checkNotNull(context, "Context cannot be null.");
+        Preconditions.checkArgument(context instanceof Activity, "Context must be an Activity.");
+        Preconditions.checkArgument(start >= 0, "start position must be non-negative");
+        Preconditions.checkArgument(interval >= 2, "interval must be at least 2");
 
         mActivity = new WeakReference<Activity>((Activity) context);
         mApplicationContext = context.getApplicationContext();
@@ -42,15 +40,16 @@ public AdapterHelper(final Context context, final int start, final int interval)
     }
 
     @Deprecated
-    public View getAdView(final View convertView,
-            final ViewGroup parent,
-            final NativeResponse nativeResponse,
-            final ViewBinder viewBinder,
-            final MoPubNativeListener moPubNativeListener) {
+    @NonNull
+    public View getAdView(@Nullable final View convertView,
+            @Nullable final ViewGroup parent,
+            @Nullable final NativeResponse nativeResponse,
+            @Nullable final ViewBinder viewBinder,
+            @Nullable @SuppressWarnings("unused") final MoPubNativeListener moPubNativeListener) {
         final Activity activity = mActivity.get();
         if (activity == null) {
-            MoPubLog.d("Weak reference to Activity Context in AdapterHelper became null. " +
-                    "Returning empty view.");
+            MoPubLog.w("Weak reference to Activity Context in"
+                    + " AdapterHelper became null. Returning empty view.");
             return new View(mApplicationContext);
         }
 
@@ -59,8 +58,7 @@ public View getAdView(final View convertView,
                 parent,
                 activity,
                 nativeResponse,
-                viewBinder,
-                moPubNativeListener
+                viewBinder
         );
     }
 
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/BaseForwardingNativeAd.java b/mopub-sdk/src/main/java/com/mopub/nativeads/BaseForwardingNativeAd.java
index 9f5b58cf..4f463ba5 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/BaseForwardingNativeAd.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/BaseForwardingNativeAd.java
@@ -1,16 +1,24 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
-import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
 import android.view.View;
 
+import com.mopub.common.Preconditions.NoThrow;
 import com.mopub.common.logging.MoPubLog;
+import com.mopub.network.Networking;
+import com.mopub.volley.VolleyError;
+import com.mopub.volley.toolbox.ImageLoader;
 
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
 
 import static com.mopub.nativeads.CustomEventNative.CustomEventNativeListener;
 import static com.mopub.nativeads.CustomEventNative.ImageListener;
@@ -22,26 +30,26 @@
         public void onAdImpressed();
         public void onAdClicked();
     }
-    private NativeEventListener mNativeEventListener;
+    @Nullable private NativeEventListener mNativeEventListener;
 
     static final double MIN_STAR_RATING = 0;
     static final double MAX_STAR_RATING = 5;
 
     // Basic fields
-    private String mMainImageUrl;
-    private String mIconImageUrl;
-    private String mClickDestinationUrl;
-    private String mCallToAction;
-    private String mTitle;
-    private String mText;
-    private Double mStarRating;
+    @Nullable private String mMainImageUrl;
+    @Nullable private String mIconImageUrl;
+    @Nullable private String mClickDestinationUrl;
+    @Nullable private String mCallToAction;
+    @Nullable private String mTitle;
+    @Nullable private String mText;
+    @Nullable private Double mStarRating;
 
     // Impression logistics
-    private final Set<String> mImpressionTrackers;
+    @NonNull private final Set<String> mImpressionTrackers;
     private int mImpressionMinTimeViewed;
 
     // Extras
-    private final Map<String, Object> mExtras;
+    @NonNull private final Map<String, Object> mExtras;
 
     // Event Logistics
     private boolean mIsOverridingClickTracker;
@@ -58,6 +66,7 @@
     /**
      * Returns the String url corresponding to the ad's main image.
      */
+    @Nullable
     @Override
     final public String getMainImageUrl() {
         return mMainImageUrl;
@@ -66,6 +75,7 @@ final public String getMainImageUrl() {
     /**
      * Returns the String url corresponding to the ad's icon image.
      */
+    @Nullable
     @Override
     final public String getIconImageUrl() {
         return mIconImageUrl;
@@ -78,6 +88,7 @@ final public String getIconImageUrl() {
      * and {@link BaseForwardingNativeAd#getImpressionMinTimeViewed()} for relevant
      * impression-tracking parameters.
      */
+    @NonNull
     @Override
     final public Set<String> getImpressionTrackers() {
         return new HashSet<String>(mImpressionTrackers);
@@ -86,6 +97,7 @@ final public String getIconImageUrl() {
     /**
      * Returns the String url that the device will attempt to resolve when the ad is clicked.
      */
+    @Nullable
     @Override
     final public String getClickDestinationUrl() {
         return mClickDestinationUrl;
@@ -94,6 +106,7 @@ final public String getClickDestinationUrl() {
     /**
      * Returns the Call To Action String (i.e. "Download" or "Learn More") associated with this ad.
      */
+    @Nullable
     @Override
     final public String getCallToAction() {
         return mCallToAction;
@@ -102,6 +115,7 @@ final public String getCallToAction() {
     /**
      * Returns the String corresponding to the ad's title.
      */
+    @Nullable
     @Override
     final public String getTitle() {
         return mTitle;
@@ -110,6 +124,7 @@ final public String getTitle() {
     /**
      * Returns the String corresponding to the ad's body text.
      */
+    @Nullable
     @Override
     final public String getText() {
         return mText;
@@ -120,6 +135,7 @@ final public String getText() {
      * advertised app. Note that this method may return null if the star rating was either never set
      * or invalid.
      */
+    @Nullable
     @Override
     final public Double getStarRating() {
         return mStarRating;
@@ -150,8 +166,12 @@ final public int getImpressionMinTimeViewed() {
      * Given a particular String key, return the associated Object value from the ad's extras map.
      * See {@link BaseForwardingNativeAd#getExtras()} for more information.
      */
+    @Nullable
     @Override
-    final public Object getExtra(final String key) {
+    final public Object getExtra(@NonNull final String key) {
+        if (!NoThrow.checkNotNull(key, "getExtra key is not allowed to be null")) {
+            return null;
+        }
         return mExtras.get(key);
     }
 
@@ -161,6 +181,7 @@ final public Object getExtra(final String key) {
      * with MoPub's direct-sold native ads or from mediated networks that pass back additional
      * fields.
      */
+    @NonNull
     @Override
     final public Map<String, Object> getExtras() {
         return new HashMap<String, Object>(mExtras);
@@ -190,35 +211,36 @@ final public boolean isOverridingClickTracker() {
 
     // Setters
     @Override
-    public final void setNativeEventListener(final NativeEventListener nativeEventListener) {
+    public final void setNativeEventListener(
+            @Nullable final NativeEventListener nativeEventListener) {
         mNativeEventListener = nativeEventListener;
     }
 
-    final void setMainImageUrl(final String mainImageUrl) {
+    final void setMainImageUrl(@Nullable final String mainImageUrl) {
         mMainImageUrl = mainImageUrl;
     }
 
-    final void setIconImageUrl(final String iconImageUrl) {
+    final void setIconImageUrl(@Nullable final String iconImageUrl) {
         mIconImageUrl = iconImageUrl;
     }
 
-    final void setClickDestinationUrl(final String clickDestinationUrl) {
+    final void setClickDestinationUrl(@Nullable final String clickDestinationUrl) {
         mClickDestinationUrl = clickDestinationUrl;
     }
 
-    final void setCallToAction(final String callToAction) {
+    final void setCallToAction(@Nullable final String callToAction) {
         mCallToAction = callToAction;
     }
 
-    final void setTitle(final String title) {
+    final void setTitle(@Nullable final String title) {
         mTitle = title;
     }
 
-    final void setText(final String text) {
+    final void setText(@Nullable final String text) {
         mText = text;
     }
 
-    final void setStarRating(final Double starRating) {
+    final void setStarRating(@Nullable final Double starRating) {
         if (starRating == null) {
             mStarRating = null;
         } else if (starRating >= MIN_STAR_RATING && starRating <= MAX_STAR_RATING) {
@@ -229,11 +251,17 @@ final void setStarRating(final Double starRating) {
         }
     }
 
-    final void addExtra(final String key, final Object value) {
+    final void addExtra(@NonNull final String key, @Nullable final Object value) {
+        if (!NoThrow.checkNotNull(key, "addExtra key is not allowed to be null")) {
+            return;
+        }
         mExtras.put(key, value);
     }
 
-    final void addImpressionTracker(final String url) {
+    final void addImpressionTracker(@NonNull final String url) {
+        if (!NoThrow.checkNotNull(url, "impressionTracker url is not allowed to be null")) {
+            return;
+        }
         mImpressionTrackers.add(url);
     }
 
@@ -259,7 +287,7 @@ final void setOverridingClickTracker(final boolean isOverridingClickTracker) {
      * This method is optional.
      */
     @Override
-    public void prepare(final View view) { }
+    public void prepare(@Nullable final View view) { }
 
     /**
      * Your base native ad subclass should implement this method if the network requires the developer
@@ -277,7 +305,7 @@ public void recordImpression() { }
      * This method is optional.
      */
     @Override
-    public void handleClick(final View view) { }
+    public void handleClick(@Nullable final View view) { }
 
     /**
      * Your base native ad subclass should implement this method if the network requires the developer
@@ -287,7 +315,7 @@ public void handleClick(final View view) { }
      * This method is optional.
      */
     @Override
-    public void clear(final View view) { }
+    public void clear(@Nullable final View view) { }
 
     /**
      * Your base native ad subclass should implement this method if the network requires the developer
@@ -307,7 +335,9 @@ public void destroy() { }
      * {@link BaseForwardingNativeAd#prepare}.
      */
     protected final void notifyAdImpressed() {
-        mNativeEventListener.onAdImpressed();
+        if (mNativeEventListener != null) {
+            mNativeEventListener.onAdImpressed();
+        }
     }
 
     /**
@@ -318,7 +348,9 @@ protected final void notifyAdImpressed() {
      * {@link BaseForwardingNativeAd#prepare}.
      */
     protected final void notifyAdClicked() {
-        mNativeEventListener.onAdClicked();
+        if (mNativeEventListener != null) {
+            mNativeEventListener.onAdClicked();
+        }
     }
 
     /**
@@ -326,19 +358,45 @@ protected final void notifyAdClicked() {
      * cache before calling {@link CustomEventNativeListener#onNativeAdLoaded}. Doing so will
      * force images to cache before displaying the ad.
      */
-    static void preCacheImages(final Context context,
-            final List<String> imageUrls,
-            final ImageListener imageListener) {
-        ImageService.get(context, imageUrls, new ImageService.ImageServiceListener() {
+    static void preCacheImages(@NonNull final Context context,
+            @NonNull final List<String> imageUrls,
+            @NonNull final ImageListener imageListener) {
+        final ImageLoader imageLoader = Networking.getImageLoader(context);
+        // These Atomics are only accessed on the main thread.
+        // We use Atomics here so we can change their values while keeping a reference for the inner class.
+        final AtomicInteger imageCounter = new AtomicInteger(imageUrls.size());
+        final AtomicBoolean anyFailures = new AtomicBoolean(false);
+        ImageLoader.ImageListener volleyImageListener = new ImageLoader.ImageListener() {
             @Override
-            public void onSuccess(final Map<String, Bitmap> bitmaps) {
-                imageListener.onImagesCached();
+            public void onResponse(final ImageLoader.ImageContainer imageContainer, final boolean isImmediate) {
+                // Image Loader returns a "default" response immediately. We want to ignore this
+                // unless the image is already cached.
+                if (imageContainer.getBitmap() != null) {
+                    final int count = imageCounter.decrementAndGet();
+                    if (count == 0 && !anyFailures.get()) {
+                        imageListener.onImagesCached();
+                    }
+                }
             }
 
             @Override
-            public void onFail() {
+            public void onErrorResponse(final VolleyError volleyError) {
+                MoPubLog.d("Failed to download a native ads image:", volleyError);
+                boolean anyPreviousErrors = anyFailures.getAndSet(true);
+                imageCounter.decrementAndGet();
+                if (!anyPreviousErrors) {
+                    imageListener.onImagesFailedToCache(NativeErrorCode.IMAGE_DOWNLOAD_FAILURE);
+                }
+            }
+        };
+
+        for (String url : imageUrls) {
+            if (TextUtils.isEmpty(url)) {
+                anyFailures.set(true);
                 imageListener.onImagesFailedToCache(NativeErrorCode.IMAGE_DOWNLOAD_FAILURE);
+                return;
             }
-        });
+            imageLoader.get(url, volleyImageListener);
+        }
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ClickDestinationResolutionListener.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ClickDestinationResolutionListener.java
new file mode 100644
index 00000000..1ef9c30c
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/ClickDestinationResolutionListener.java
@@ -0,0 +1,112 @@
+package com.mopub.nativeads;
+
+import android.content.Context;
+import android.content.Intent;
+import android.net.Uri;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.MoPubBrowser;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Intents;
+import com.mopub.exceptions.IntentNotResolvableException;
+import com.mopub.exceptions.UrlParseException;
+
+import java.lang.ref.WeakReference;
+import java.util.Iterator;
+
+class ClickDestinationResolutionListener implements UrlResolutionTask.UrlResolutionListener {
+    private final Context mContext;
+    private final Iterator<String> mUrlIterator;
+    private final WeakReference<SpinningProgressView> mSpinningProgressView;
+
+    public ClickDestinationResolutionListener(@NonNull final Context context,
+            @NonNull final Iterator<String> urlIterator,
+            @NonNull final SpinningProgressView spinningProgressView) {
+        mContext = context.getApplicationContext();
+        mUrlIterator = urlIterator;
+        mSpinningProgressView = new WeakReference<SpinningProgressView>(spinningProgressView);
+    }
+
+    /**
+     * Called upon user click, after the corresponding UrlResolutionTask has followed all redirects
+     * successfully. Attempts to open mopubnativebrowser links in the device browser, deep-links in
+     * the corresponding application, and all other links in the MoPub in-app browser. In the first
+     * two cases, malformed URLs will try to fallback to the next entry in mUrlIterator, and failing
+     * that, will no-op.
+     */
+    @Override
+    public void onSuccess(@NonNull final String resolvedUrl) {
+
+        if (Intents.isAboutScheme(resolvedUrl)) {
+            MoPubLog.d("Link to about page ignored.");
+            removeSpinningProgressView();
+            return;
+        }
+
+        // Handle MoPubNativeBrowser schemes
+        if (Intents.isNativeBrowserScheme(resolvedUrl)) {
+            try {
+                final Intent intent = Intents.intentForNativeBrowserScheme(resolvedUrl);
+                Intents.startActivity(mContext, intent);
+                removeSpinningProgressView();
+                return;
+            } catch (UrlParseException e) {
+                MoPubLog.d(e.getMessage());
+            } catch (IntentNotResolvableException e) {
+                MoPubLog.d("Could not handle intent for URI: " + resolvedUrl);
+            }
+
+            if (mUrlIterator.hasNext()) {
+                UrlResolutionTask.getResolvedUrl(mUrlIterator.next(), this);
+            } else {
+                removeSpinningProgressView();
+            }
+            return;
+        }
+
+        // Handle Android deeplinks
+        if (Intents.isDeepLink(resolvedUrl)) {
+            final Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(resolvedUrl));
+
+            // Open another Android app from the deep link
+            if (Intents.deviceCanHandleIntent(mContext, intent)) {
+                try {
+                    Intents.startActivity(mContext, intent);
+                    return;
+                } catch (IntentNotResolvableException e) {
+                    MoPubLog.d("Could not handle intent with URI: " + resolvedUrl);
+                } finally {
+                    removeSpinningProgressView();
+                }
+            }
+
+            if (mUrlIterator.hasNext()) {
+                UrlResolutionTask.getResolvedUrl(mUrlIterator.next(), this);
+            } else {
+                removeSpinningProgressView();
+            }
+            return;
+        }
+
+        removeSpinningProgressView();
+        if (Intents.isHttpUrl(resolvedUrl)) {
+            MoPubBrowser.open(mContext, resolvedUrl);
+            return;
+        }
+
+        MoPubLog.d("Link ignored. Unable to handle url: " + resolvedUrl);
+    }
+
+    @Override
+    public void onFailure() {
+        MoPubLog.d("Failed to resolve URL for click.");
+        removeSpinningProgressView();
+    }
+
+    private void removeSpinningProgressView() {
+        final SpinningProgressView spinningProgressView = mSpinningProgressView.get();
+        if (spinningProgressView != null) {
+            spinningProgressView.removeFromRoot();
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ClientPositioningSource.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ClientPositioningSource.java
index bcfea7c7..0809b8d2 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/ClientPositioningSource.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/ClientPositioningSource.java
@@ -1,6 +1,7 @@
 package com.mopub.nativeads;
 
 import android.os.Handler;
+import android.support.annotation.NonNull;
 
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
 
@@ -8,15 +9,16 @@
  * Returns a preset client positioning object.
  */
 class ClientPositioningSource implements PositioningSource {
-    private Handler mHandler = new Handler();
-    private final MoPubClientPositioning mPositioning;
+    @NonNull private final Handler mHandler = new Handler();
+    @NonNull private final MoPubClientPositioning mPositioning;
 
-    ClientPositioningSource(MoPubClientPositioning positioning) {
+    ClientPositioningSource(@NonNull MoPubClientPositioning positioning) {
         mPositioning = MoPubNativeAdPositioning.clone(positioning);
     }
 
     @Override
-    public void loadPositions(final String adUnitId, final PositioningListener listener) {
+    public void loadPositions(@NonNull final String adUnitId,
+            @NonNull final PositioningListener listener) {
         mHandler.post(new Runnable() {
             @Override
             public void run() {
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/Constants.java b/mopub-sdk/src/main/java/com/mopub/nativeads/Constants.java
deleted file mode 100644
index ad256b8b..00000000
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/Constants.java
+++ /dev/null
@@ -1,11 +0,0 @@
-package com.mopub.nativeads;
-
-public class Constants {
-    public static final String LOGTAG = "MoPub Native";
-
-    static final String NATIVE_HOST = "ads.mopub.com";
-    static final String NATIVE_HANDLER = "/m/ad";
-
-    static final String POSITIONING_HOST = "ads.mopub.com";
-    static final String POSITIONING_HANDLER = "/m/pos";
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNative.java b/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNative.java
index 03397057..8893bd1f 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNative.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNative.java
@@ -1,47 +1,53 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 
 import java.util.Map;
 
 /**
- * CustomEventNative is a base class for custom events that support native ads. By implementing
- * subclasses of CustomEventNative, you can enable the MoPub SDK to support a wider
- * variety of third-party ad networks, or execute any of your application code on demand.
+ * {@code CustomEventNative} is a base class for custom events that support native ads. By
+ * implementing subclasses of {@code CustomEventNative}, you can enable the MoPub SDK to support a
+ * wider variety of third-party ad networks, or execute any of your application code on demand.
  *
- * At runtime, the MoPub SDK will find and instantiate a CustomEventNative subclass as needed
- * and invoke its loadNativeAd() method.
+ * At runtime, the MoPub SDK will find and instantiate a {@code CustomEventNative} subclass as
+ * needed and invoke its {@link #loadNativeAd} method.
  */
 public abstract class CustomEventNative {
     /**
      * When the MoPub SDK receives a response indicating it should load a custom event, it will send
-     * this message to your custom event class. Your implementation of this method can either load
-     * a native ad from a third-party ad network, or execute any application code. It must also
-     * notify the provided CustomEventNativeListener Object of certain lifecycle events.
+     * this message to your custom event class. Your implementation of this method can either load a
+     * native ad from a third-party ad network, or execute any application code. It must also notify
+     * the provided {@link CustomEventNativeListener} Object of certain lifecycle events.
      *
-     * The localExtras parameter is a Map containing additional custom data that is set within
-     * your application by calling MoPubNative.setLocalExtras(Map<String, Object>). Note that the
-     * localExtras Map is a copy of the Map supplied to setLocalExtras().
-     *
-     * The serverExtras parameter is a Map containing additional custom data configurable on the
-     * MoPub website that you want to associate with a given custom event request. This data may be
-     * used to pass dynamic information, such as publisher IDs, without changes in application code.
+     * @param context The activity context.
+     * @param customEventNativeListener An Object that must be notified of certain lifecycle
+     * events.
+     * @param localExtras A Map containing additional custom data that is set within your
+     * application by calling {@link MoPubNative#setLocalExtras(Map<String, Object>)}. Note that the
+     * localExtras Map is a copy of the Map supplied to {@link MoPubNative#setLocalExtras(Map<String,
+     * Object>)}.
+     * @param serverExtras A Map containing additional custom data configurable on the MoPub website
+     * that you want to associate with a given custom event request. This data may be used to pass
+     * dynamic information, such as publisher IDs, without changes in application code.
      */
-    protected abstract void loadNativeAd(final Context context,
-            final CustomEventNativeListener customEventNativeListener,
-            final Map<String, Object> localExtras,
-            final Map<String, String> serverExtras);
+    protected abstract void loadNativeAd(@NonNull final Context context,
+            @NonNull final CustomEventNativeListener customEventNativeListener,
+            @NonNull final Map<String, Object> localExtras,
+            @NonNull final Map<String, String> serverExtras);
 
     public interface ImageListener {
         /**
-         * Called when images are successfully cached. If you haven't already called
-         * {@link CustomEventNativeListener#onNativeAdLoaded}, you should typically do so now.
+         * Called when images are successfully cached. If you haven't already called {@link
+         * CustomEventNativeListener#onNativeAdLoaded}, you should typically do so now.
          */
         void onImagesCached();
 
         /**
-         * Called when images failed to cache. You should typically call
-         * {@link CustomEventNativeListener#onNativeAdFailed} from this callback.
+         * Called when images failed to cache. You should typically call {@link
+         * CustomEventNativeListener#onNativeAdFailed} from this callback.
+         *
+         * @param errorCode An enum value with the relevant error message.
          */
         void onImagesFailedToCache(NativeErrorCode errorCode);
     }
@@ -51,6 +57,8 @@ protected abstract void loadNativeAd(final Context context,
          * Your custom event subclass must call this method when it successfully loads a native ad.
          * Failure to do so will disrupt the mediation waterfall and cause future ad requests to
          * stall.
+         *
+         * @param nativeAd The ad that was succesfully loaded.
          */
         void onNativeAdLoaded(NativeAdInterface nativeAd);
 
@@ -58,6 +66,8 @@ protected abstract void loadNativeAd(final Context context,
          * Your custom event subclass must call this method when it fails to load a native ad.
          * Failure to do so will disrupt the mediation waterfall and cause future ad requests to
          * stall.
+         *
+         * @param errorCode An enum value with the relevant error message.
          */
         void onNativeAdFailed(NativeErrorCode errorCode);
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNativeAdapter.java b/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNativeAdapter.java
index 224fa646..2f91b815 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNativeAdapter.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/CustomEventNativeAdapter.java
@@ -1,31 +1,25 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 
-import com.mopub.common.DownloadResponse;
-import com.mopub.common.HttpResponses;
-import com.mopub.common.util.Json;
+import com.mopub.common.DataKeys;
 import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.ResponseHeader;
 import com.mopub.nativeads.factories.CustomEventNativeFactory;
+import com.mopub.network.AdResponse;
 
-import java.util.HashMap;
 import java.util.Map;
 
 final class CustomEventNativeAdapter {
     private CustomEventNativeAdapter() {}
 
-    static final String RESPONSE_BODY_KEY = "response_body_key";
-
-    public static void loadNativeAd(final Context context,
-            final Map<String, Object> localExtras,
-            final DownloadResponse downloadResponse,
-            final CustomEventNative.CustomEventNativeListener customEventNativeListener) {
-
-        final String customEventNativeData = downloadResponse.getFirstHeader(ResponseHeader.CUSTOM_EVENT_DATA);
-        final String customEventNativeClassName = downloadResponse.getFirstHeader(ResponseHeader.CUSTOM_EVENT_NAME);
+    public static void loadNativeAd(@NonNull final Context context,
+            @NonNull final Map<String, Object> localExtras,
+            @NonNull final AdResponse adResponse,
+            @NonNull final CustomEventNative.CustomEventNativeListener customEventNativeListener) {
 
         final CustomEventNative customEventNative;
+        String customEventNativeClassName = adResponse.getCustomEventClassName();
         try {
             customEventNative = CustomEventNativeFactory.create(customEventNativeClassName);
         } catch (Exception e) {
@@ -34,21 +28,15 @@ public static void loadNativeAd(final Context context,
             return;
         }
 
-        Map<String, String> serverExtras = new HashMap<String, String>();
-        // Attempt to load the JSON extras into mServerExtras.
-        try {
-            serverExtras = Json.jsonStringToMap(customEventNativeData);
-        } catch (Exception e) {
-            MoPubLog.w("Failed to create Map from JSON: " + customEventNativeData, e);
+        if (adResponse.hasJson()) {
+            localExtras.put(DataKeys.JSON_BODY_KEY, adResponse.getJsonBody());
         }
 
-        serverExtras.put(RESPONSE_BODY_KEY, HttpResponses.asResponseString(downloadResponse));
-
         customEventNative.loadNativeAd(
                 context,
                 customEventNativeListener,
                 localExtras,
-                serverExtras
+                adResponse.getServerExtras()
         );
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ImageDiskTaskManager.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ImageDiskTaskManager.java
deleted file mode 100644
index f355fe69..00000000
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/ImageDiskTaskManager.java
+++ /dev/null
@@ -1,67 +0,0 @@
-package com.mopub.nativeads;
-
-import android.graphics.Bitmap;
-import com.mopub.common.CacheService;
-
-import java.util.*;
-
-import static com.mopub.common.CacheService.DiskLruCacheGetListener;
-
-class ImageDiskTaskManager extends TaskManager<Bitmap> {
-    private final List<String> mUrls;
-    private final int mMaxImageWidth;
-
-    ImageDiskTaskManager(final List<String> urls,
-            final TaskManagerListener<Bitmap> imageTaskManagerListener,
-            final int maxImageWidth)
-            throws IllegalArgumentException {
-        super(urls, imageTaskManagerListener);
-        mMaxImageWidth = maxImageWidth;
-        mUrls = urls;
-    }
-
-    @Override
-    void execute() {
-        if (mUrls.isEmpty()) {
-            mImageTaskManagerListener.onSuccess(mResults);
-        }
-
-        ImageDiskTaskListener imageDiskTaskListener = new ImageDiskTaskListener(mMaxImageWidth);
-        for (final String url : mUrls) {
-            CacheService.getFromDiskCacheAsync(url, imageDiskTaskListener);
-        }
-    }
-
-    void failAllTasks() {
-        if (mFailed.compareAndSet(false, true)) {
-            mImageTaskManagerListener.onFail();
-        }
-    }
-
-    private class ImageDiskTaskListener implements DiskLruCacheGetListener {
-
-        private final int mTargetWidth;
-
-        ImageDiskTaskListener(final int targetWidth) {
-            mTargetWidth = targetWidth;
-        }
-
-        @Override
-        public void onComplete(final String key, final byte[] content) {
-            if (key == null) {
-                failAllTasks();
-                return;
-            } else {
-                Bitmap bitmap = null;
-                if (content != null) {
-                     bitmap = ImageService.byteArrayToBitmap(content, mTargetWidth);
-                }
-                mResults.put(key, bitmap);
-            }
-
-            if (mCompletedCount.incrementAndGet() == mSize) {
-                mImageTaskManagerListener.onSuccess(mResults);
-            }
-        }
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ImageDownloadTaskManager.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ImageDownloadTaskManager.java
deleted file mode 100644
index b022aa2f..00000000
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/ImageDownloadTaskManager.java
+++ /dev/null
@@ -1,85 +0,0 @@
-package com.mopub.nativeads;
-
-import com.mopub.common.DownloadResponse;
-import com.mopub.common.DownloadTask;
-import com.mopub.common.util.AsyncTasks;
-import com.mopub.common.logging.MoPubLog;
-
-import org.apache.http.HttpStatus;
-import org.apache.http.client.methods.HttpGet;
-import org.apache.http.client.methods.HttpUriRequest;
-
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import static com.mopub.common.DownloadTask.DownloadTaskListener;
-import static java.util.Map.Entry;
-
-class ImageDownloadTaskManager extends TaskManager<DownloadResponse> {
-
-    private final Map<HttpUriRequest, DownloadTask> mDownloadTasks;
-    private final int mRequestedWidth;
-
-    ImageDownloadTaskManager(final List<String> urls,
-                             final TaskManagerListener<DownloadResponse> imageTaskManagerListener,
-                             final int requestedWidth)
-            throws IllegalArgumentException {
-        super(urls, imageTaskManagerListener);
-
-        mRequestedWidth = requestedWidth;
-
-        final DownloadTaskListener downloadTaskListener = new ImageDownloadTaskListener();
-        mDownloadTasks = new HashMap<HttpUriRequest, DownloadTask>(urls.size());
-        for (final String url : urls) {
-            final HttpGet httpGet = new HttpGet(url);
-            mDownloadTasks.put(httpGet, new DownloadTask(downloadTaskListener));
-        }
-    }
-
-    @Override
-    void execute() {
-        if (mDownloadTasks.isEmpty()) {
-            mImageTaskManagerListener.onSuccess(mResults);
-        }
-
-        for (final Entry<HttpUriRequest, DownloadTask> entry : mDownloadTasks.entrySet()) {
-            final HttpUriRequest httpUriRequest = entry.getKey();
-            final DownloadTask downloadTask = entry.getValue();
-
-            try {
-                AsyncTasks.safeExecuteOnExecutor(downloadTask, httpUriRequest);
-            } catch (Exception e) {
-                MoPubLog.d("Failed to download image", e);
-
-                mImageTaskManagerListener.onFail();
-            }
-        }
-    }
-
-    void failAllTasks() {
-        if (mFailed.compareAndSet(false, true)) {
-            for (final DownloadTask downloadTask : mDownloadTasks.values()) {
-                downloadTask.cancel(true);
-            }
-            mImageTaskManagerListener.onFail();
-        }
-    }
-
-    private class ImageDownloadTaskListener implements DownloadTaskListener {
-        @Override
-        public void onComplete(final String url, final DownloadResponse downloadResponse) {
-            if (downloadResponse == null || downloadResponse.getStatusCode() != HttpStatus.SC_OK) {
-                MoPubLog.d("Failed to download image: " + url);
-                failAllTasks();
-                return;
-            }
-
-            MoPubLog.d("Successfully downloaded image bye array: " + url);
-            mResults.put(url, downloadResponse);
-            if (mCompletedCount.incrementAndGet() == mSize) {
-                mImageTaskManagerListener.onSuccess(mResults);
-            }
-        }
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ImageService.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ImageService.java
deleted file mode 100644
index d020becc..00000000
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/ImageService.java
+++ /dev/null
@@ -1,287 +0,0 @@
-package com.mopub.nativeads;
-
-import android.annotation.TargetApi;
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.graphics.Point;
-import android.view.Display;
-import android.view.WindowManager;
-
-import com.mopub.common.CacheService;
-import com.mopub.common.DownloadResponse;
-import com.mopub.common.VisibleForTesting;
-import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.VersionCode;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import static android.graphics.BitmapFactory.Options;
-import static android.graphics.BitmapFactory.decodeByteArray;
-import static com.mopub.common.util.VersionCode.HONEYCOMB_MR2;
-import static com.mopub.nativeads.TaskManager.TaskManagerListener;
-import static java.util.Map.Entry;
-
-class ImageService {
-    private static final int TWO_MEGABYTES = 2097152;
-    private static int sTargetWidth = -1;
-
-    interface ImageServiceListener {
-        void onSuccess(Map<String, Bitmap> bitmaps);
-        void onFail();
-    }
-
-    @TargetApi(13)
-    @VisibleForTesting
-    static void initialize(Context context) {
-        if (sTargetWidth == -1) {
-            // Get Display Options
-            WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
-            Display display = wm.getDefaultDisplay();
-            Point size = new Point();
-            if (VersionCode.currentApiLevel().isBelow(HONEYCOMB_MR2)) {
-                size.set(display.getWidth(), display.getHeight());
-            } else {
-                display.getSize(size);
-            }
-
-            // Make our images no wider than the skinny side of the display.
-            sTargetWidth = Math.min(size.x, size.y);
-        }
-    }
-
-    static void get(final Context context, final List<String> urls, final ImageServiceListener imageServiceListener) {
-        initialize(context);
-        CacheService.initialize(context);
-        get(urls, imageServiceListener);
-    }
-
-    static void get(final List<String> urls, final ImageServiceListener imageServiceListener) {
-        final Map<String, Bitmap> cacheBitmaps = new HashMap<String, Bitmap>(urls.size());
-        final List<String> urlCacheMisses = getBitmapsFromMemoryCache(urls, cacheBitmaps);
-
-        if (urlCacheMisses.isEmpty()) {
-            imageServiceListener.onSuccess(cacheBitmaps);
-            return;
-        }
-
-        final ImageDiskTaskManager imageDiskTaskManager;
-        try {
-            imageDiskTaskManager = new ImageDiskTaskManager(
-                    urlCacheMisses,
-                    new ImageDiskTaskManagerListener(imageServiceListener, cacheBitmaps),
-                    sTargetWidth
-            );
-        } catch (IllegalArgumentException e) {
-            MoPubLog.d("Unable to initialize ImageDiskTaskManager", e);
-            imageServiceListener.onFail();
-            return;
-        }
-
-        imageDiskTaskManager.execute();
-    }
-
-
-
-    static void putBitmapInCache(final String key, final Bitmap bitmap) {
-        CacheService.putToBitmapCache(key, bitmap);
-    }
-
-    static void putDataInCache(final String key, final Bitmap bitmap, final byte[] byteData) {
-        CacheService.putToBitmapCache(key, bitmap);
-        CacheService.putToDiskCacheAsync(key, byteData);
-    }
-
-    static List<String> getBitmapsFromMemoryCache(final List<String> urls, final Map<String, Bitmap> hits) {
-        final List<String> cacheMisses = new ArrayList<String>();
-        for (final String url : urls) {
-            final Bitmap bitmap = getBitmapFromMemoryCache(url);
-
-            if (bitmap != null) {
-                hits.put(url, bitmap);
-            } else {
-                cacheMisses.add(url);
-            }
-        }
-
-        return cacheMisses;
-    }
-
-    static Bitmap getBitmapFromMemoryCache(final String key) {
-        return CacheService.getFromBitmapCache(key);
-    }
-
-    private static class ImageDiskTaskManagerListener implements TaskManagerListener<Bitmap> {
-        final private ImageServiceListener mImageServiceListener;
-        final private Map<String, Bitmap> mBitmaps;
-
-        ImageDiskTaskManagerListener(final ImageServiceListener imageServiceListener,
-                final Map<String, Bitmap> bitmaps) {
-            mImageServiceListener = imageServiceListener;
-            mBitmaps = bitmaps;
-        }
-
-        @Override
-        public void onSuccess(final Map<String, Bitmap> diskBitmaps) {
-            final List<String> urlDiskMisses = new ArrayList<String>();
-            for (final Entry <String, Bitmap> entry : diskBitmaps.entrySet()) {
-                if (entry.getValue() == null) {
-                    urlDiskMisses.add(entry.getKey());
-                } else {
-                    putBitmapInCache(entry.getKey(), entry.getValue());
-                    mBitmaps.put(entry.getKey(), entry.getValue());
-                }
-            }
-
-            if (urlDiskMisses.isEmpty()) {
-                mImageServiceListener.onSuccess(mBitmaps);
-            } else {
-
-                final ImageDownloadTaskManager imageDownloadTaskManager;
-                try {
-                    imageDownloadTaskManager = new ImageDownloadTaskManager(
-                            urlDiskMisses,
-                            new ImageDownloadResponseListener(mImageServiceListener, mBitmaps),
-                            sTargetWidth
-                    );
-                } catch (IllegalArgumentException e) {
-                    MoPubLog.d("Unable to initialize ImageDownloadTaskManager", e);
-                    mImageServiceListener.onFail();
-                    return;
-                }
-
-                imageDownloadTaskManager.execute();
-            }
-        }
-
-        @Override
-        public void onFail() {
-            mImageServiceListener.onFail();
-        }
-    }
-
-    private static class ImageDownloadResponseListener implements TaskManagerListener<DownloadResponse> {
-        private final ImageServiceListener mImageServiceListener;
-        private final Map<String, Bitmap> mBitmaps;
-
-        ImageDownloadResponseListener(final ImageServiceListener imageServiceListener,
-                final Map<String, Bitmap> bitmaps) {
-            mImageServiceListener = imageServiceListener;
-            mBitmaps = bitmaps;
-        }
-
-        @Override
-        public void onSuccess(final Map<String, DownloadResponse> responses) {
-            for (final Entry<String, DownloadResponse> entry : responses.entrySet()) {
-                final Bitmap bitmap = asBitmap(entry.getValue(), sTargetWidth);
-                final String key = entry.getKey();
-                if (bitmap == null) {
-                    MoPubLog.d("Error decoding image for url: " + entry.getKey());
-                    onFail();
-                    return;
-                }
-
-                putDataInCache(key, bitmap, entry.getValue().getByteArray());
-                mBitmaps.put(key, bitmap);
-            }
-            mImageServiceListener.onSuccess(mBitmaps);
-        }
-
-        @Override
-        public void onFail() {
-            mImageServiceListener.onFail();
-        }
-    }
-
-    public static Bitmap asBitmap(final DownloadResponse downloadResponse, final int requestedWidth) {
-        if (downloadResponse == null) {
-            return null;
-        }
-
-        final byte[] bytes = downloadResponse.getByteArray();
-        return byteArrayToBitmap(bytes, requestedWidth);
-    }
-
-    public static Bitmap byteArrayToBitmap(final byte[] bytes, final int requestedWidth) {
-        if (requestedWidth <= 0) {
-            return null;
-        }
-
-        Options options = new Options();
-        options.inJustDecodeBounds = true;
-        decodeByteArray(bytes, 0, bytes.length, options);
-        options.inSampleSize = calculateInSampleSize(options.outWidth, requestedWidth);
-
-        // If the bitmap will be very large, downsample more to avoid blowing up the heap.
-        while (getMemBytes(options) > TWO_MEGABYTES) {
-            options.inSampleSize *= 2;
-        }
-
-        options.inJustDecodeBounds = false;
-        Bitmap bitmap = decodeByteArray(bytes, 0, bytes.length, options);
-        if (bitmap == null) {
-            return null;
-        }
-
-        final int subsampleWidth = bitmap.getWidth();
-
-        // If needed, scale the bitmap so it's exactly the requested width.
-        if (subsampleWidth > requestedWidth) {
-            final int requestedHeight = (int)(bitmap.getHeight() * (double) requestedWidth / bitmap.getWidth());
-            Bitmap subsampledBitmap = bitmap;
-            bitmap = Bitmap.createScaledBitmap(subsampledBitmap, requestedWidth, requestedHeight, true);
-            subsampledBitmap.recycle();
-        }
-        
-        return bitmap;
-    }
-
-    /**
-     * Returns the size of the byte array that the bitmap described by the options object will consume.
-     */
-    public static long getMemBytes(Options options) {
-        long memBytes = 4 * (long) options.outWidth * (long) options.outHeight / options.inSampleSize / options.inSampleSize;
-        return memBytes;
-    }
-
-    /**
-     * Calculate the largest inSampleSize value that is a power of 2 and keeps the
-     * width greater than or equal to the requested width.
-     */
-    public static int calculateInSampleSize(final int nativeWidth, int requestedWidth) {
-        int inSampleSize = 1;
-
-        if (nativeWidth > requestedWidth) {
-            final int halfWidth = nativeWidth / 2;
-
-            while ((halfWidth / inSampleSize) >= requestedWidth) {
-                inSampleSize *= 2;
-            }
-        }
-
-        return inSampleSize;
-    }
-
-    // Testing, also performs disk IO
-    @Deprecated
-    static Bitmap getBitmapFromDiskCache(final String key) {
-        Bitmap bitmap = null;
-        byte[] bytes = CacheService.getFromDiskCache(key);
-        if (bytes != null) {
-            bitmap = byteArrayToBitmap(bytes, sTargetWidth);
-        }
-        return bitmap;
-    }
-
-    @VisibleForTesting
-    static void clear() {
-        sTargetWidth = -1;
-    }
-
-    @VisibleForTesting
-    static int getTargetWidth() {
-        return sTargetWidth;
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ImageViewService.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ImageViewService.java
deleted file mode 100644
index ef337e0c..00000000
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/ImageViewService.java
+++ /dev/null
@@ -1,87 +0,0 @@
-package com.mopub.nativeads;
-
-import android.graphics.Bitmap;
-import android.widget.ImageView;
-
-import com.mopub.common.VisibleForTesting;
-import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.Utils;
-
-import java.lang.ref.WeakReference;
-import java.util.Arrays;
-import java.util.Map;
-import java.util.WeakHashMap;
-
-import static com.mopub.nativeads.ImageService.ImageServiceListener;
-
-class ImageViewService {
-    // This is used instead of View.setTag, which causes a memory leak in 2.3
-    // and earlier: https://code.google.com/p/android/issues/detail?id=18273
-    private static final WeakHashMap<ImageView, Long> sImageViewRequestIds =
-            new WeakHashMap<ImageView, Long>();
-
-    private ImageViewService(){}
-
-    static void loadImageView(final String url, final ImageView imageView) {
-        if (imageView == null) {
-            MoPubLog.d("Attempted to load an image into a null ImageView");
-            return;
-        }
-
-        // Blank out previous image content while waiting for request to return
-        imageView.setImageDrawable(null);
-
-        if (url != null) {
-            // Unique id to identify this async image request
-            long uniqueId = Utils.generateUniqueId();
-            sImageViewRequestIds.put(imageView, uniqueId);
-
-            // Async call to get image from memory cache, disk and then network
-            ImageService.get(
-                    Arrays.asList(url),
-                    new MyImageViewServiceListener(url, imageView, uniqueId)
-            );
-        }
-    }
-
-    private static class MyImageViewServiceListener implements ImageServiceListener {
-        private final WeakReference<ImageView> mImageView;
-        private final String mUrl;
-        private final long mUniqueId;
-
-        MyImageViewServiceListener(final String url, final ImageView imageView, final long uniqueId) {
-            mUrl = url;
-            mImageView = new WeakReference<ImageView>(imageView);
-            mUniqueId = uniqueId;
-        }
-
-        @Override
-        public void onSuccess(final Map<String, Bitmap> bitmaps) {
-            final ImageView imageView = mImageView.get();
-            if (imageView == null || bitmaps == null || !bitmaps.containsKey(mUrl)) {
-                return;
-            }
-            final Long uniqueId = sImageViewRequestIds.get(imageView);
-            if (uniqueId != null && mUniqueId == uniqueId) {
-                imageView.setImageBitmap(bitmaps.get(mUrl));
-            }
-        }
-
-        @Override
-        public void onFail() {
-            MoPubLog.d("Failed to load image for ImageView");
-        }
-    }
-
-    @VisibleForTesting
-    @Deprecated
-    static Long getImageViewUniqueId(final ImageView imageView) {
-        return sImageViewRequestIds.get(imageView);
-    }
-
-    @VisibleForTesting
-    @Deprecated
-    static void setImageViewUniqueId(final ImageView imageView, final long uniqueId) {
-        sImageViewRequestIds.put(imageView, uniqueId);
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ImpressionTracker.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ImpressionTracker.java
index 35508618..176f0e65 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/ImpressionTracker.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/ImpressionTracker.java
@@ -2,6 +2,8 @@
 
 import android.content.Context;
 import android.os.Handler;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 
 import com.mopub.common.VisibleForTesting;
@@ -19,27 +21,27 @@
     private static final int PERIOD = 250;
 
     // Object tracking visibility of added views
-    private final VisibilityTracker mVisibilityTracker;
+    @NonNull private final VisibilityTracker mVisibilityTracker;
 
     // All views and responses being tracked for impressions
-    private final Map<View, NativeResponse> mTrackedViews;
+    @NonNull private final Map<View, NativeResponse> mTrackedViews;
 
     // Visible views being polled for time on screen before tracking impression
-    private final Map<View, TimestampWrapper<NativeResponse>> mPollingViews;
+    @NonNull private final Map<View, TimestampWrapper<NativeResponse>> mPollingViews;
 
     // Handler for polling visible views
-    private final Handler mPollHandler;
+    @NonNull private final Handler mPollHandler;
 
     // Runnable to run on each visibility loop
-    private final PollingRunnable mPollingRunnable;
+    @NonNull private final PollingRunnable mPollingRunnable;
 
     // Object to check actual visibility
-    private final VisibilityChecker mVisibilityChecker;
+    @NonNull private final VisibilityChecker mVisibilityChecker;
 
     // Listener for when a view becomes visible or non visible
-    private VisibilityTrackerListener mVisibilityTrackerListener;
+    @Nullable private VisibilityTrackerListener mVisibilityTrackerListener;
 
-    ImpressionTracker(final Context context) {
+    ImpressionTracker(@NonNull final Context context) {
         this(new WeakHashMap<View, NativeResponse>(),
                 new WeakHashMap<View, TimestampWrapper<NativeResponse>>(),
                 new VisibilityChecker(),
@@ -48,11 +50,11 @@
     }
 
     @VisibleForTesting
-    ImpressionTracker(final Map<View, NativeResponse> trackedViews,
-                      final Map<View, TimestampWrapper<NativeResponse>> pollingViews,
-                      final VisibilityChecker visibilityChecker,
-                      final VisibilityTracker visibilityTracker,
-                      final Handler handler) {
+    ImpressionTracker(@NonNull final Map<View, NativeResponse> trackedViews,
+            @NonNull final Map<View, TimestampWrapper<NativeResponse>> pollingViews,
+            @NonNull final VisibilityChecker visibilityChecker,
+            @NonNull final VisibilityTracker visibilityTracker,
+            @NonNull final Handler handler) {
         mTrackedViews = trackedViews;
         mPollingViews = pollingViews;
         mVisibilityChecker = visibilityChecker;
@@ -60,7 +62,7 @@
 
         mVisibilityTrackerListener = new VisibilityTrackerListener() {
             @Override
-            public void onVisibilityChanged(final List<View> visibleViews, final List<View> invisibleViews) {
+            public void onVisibilityChanged(@NonNull final List<View> visibleViews, @NonNull final List<View> invisibleViews) {
                 for (final View view : visibleViews) {
                     // It's possible for native response to be null if the view was GC'd from this class
                     // but not from VisibilityTracker
@@ -96,7 +98,7 @@ public void onVisibilityChanged(final List<View> visibleViews, final List<View>
     /**
      * Tracks the given view for impressions.
      */
-    void addView(final View view, final NativeResponse nativeResponse) {
+    void addView(final View view, @NonNull final NativeResponse nativeResponse) {
         // View is already associated with same native response
         if (mTrackedViews.get(view) == nativeResponse) {
             return;
@@ -153,7 +155,7 @@ private void removePollingView(final View view) {
     class PollingRunnable implements Runnable {
         // Create this once to avoid excessive garbage collection observed when calculating
         // these on each pass.
-        private final ArrayList<View> mRemovedViews;
+        @NonNull private final ArrayList<View> mRemovedViews;
 
         PollingRunnable() {
             mRemovedViews = new ArrayList<View>();
@@ -189,6 +191,7 @@ public void run() {
         }
     }
 
+    @Nullable
     @Deprecated
     @VisibleForTesting
     VisibilityTrackerListener getVisibilityTrackerListener() {
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdAdapter.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdAdapter.java
index ddd2aac8..23b71feb 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdAdapter.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdAdapter.java
@@ -2,6 +2,8 @@
 
 import android.content.Context;
 import android.database.DataSetObserver;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.Adapter;
@@ -9,12 +11,15 @@
 import android.widget.BaseAdapter;
 import android.widget.ListAdapter;
 import android.widget.ListView;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.Preconditions.NoThrow;
 import com.mopub.common.VisibleForTesting;
-import com.mopub.common.logging.MoPubLog;
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubServerPositioning;
 
-import java.util.*;
+import java.util.List;
+import java.util.WeakHashMap;
 
 import static android.widget.AdapterView.OnItemClickListener;
 import static android.widget.AdapterView.OnItemLongClickListener;
@@ -32,12 +37,12 @@
  * wish to avoid wrapping your original adapter, you can use {@code MoPubStreamAdPlacer} directly.
  */
 public class MoPubAdAdapter extends BaseAdapter {
-    private final WeakHashMap<View, Integer> mViewPositionMap;
-    private final Adapter mOriginalAdapter;
-    private final MoPubStreamAdPlacer mStreamAdPlacer;
-    private final VisibilityTracker mVisibilityTracker;
+    @NonNull private final WeakHashMap<View, Integer> mViewPositionMap;
+    @NonNull private final Adapter mOriginalAdapter;
+    @NonNull private final MoPubStreamAdPlacer mStreamAdPlacer;
+    @NonNull private final VisibilityTracker mVisibilityTracker;
 
-    private MoPubNativeAdLoadedListener mAdLoadedListener;
+    @Nullable private MoPubNativeAdLoadedListener mAdLoadedListener;
 
     /**
      * Creates a new MoPubAdAdapter object.
@@ -49,7 +54,7 @@
      * @param context The activity context.
      * @param originalAdapter Your original adapter.
      */
-    public MoPubAdAdapter(final Context context, final Adapter originalAdapter) {
+    public MoPubAdAdapter(@NonNull final Context context, @NonNull final Adapter originalAdapter) {
         this(context, originalAdapter, MoPubNativeAdPositioning.serverPositioning());
     }
 
@@ -61,9 +66,9 @@ public MoPubAdAdapter(final Context context, final Adapter originalAdapter) {
      * @param adPositioning A positioning object for specifying where ads will be placed in your
      * stream. See {@link MoPubNativeAdPositioning#serverPositioning()}.
      */
-    public MoPubAdAdapter(final Context context,
-            final Adapter originalAdapter,
-            final MoPubServerPositioning adPositioning) {
+    public MoPubAdAdapter(@NonNull final Context context,
+            @NonNull final Adapter originalAdapter,
+            @NonNull final MoPubServerPositioning adPositioning) {
         this(new MoPubStreamAdPlacer(context, adPositioning), originalAdapter,
                 new VisibilityTracker(context));
     }
@@ -76,17 +81,17 @@ public MoPubAdAdapter(final Context context,
      * @param adPositioning A positioning object for specifying where ads will be placed in your
      * stream. See {@link MoPubNativeAdPositioning#clientPositioning()}.
      */
-    public MoPubAdAdapter(final Context context,
-            final Adapter originalAdapter,
-            final MoPubClientPositioning adPositioning) {
+    public MoPubAdAdapter(@NonNull final Context context,
+            @NonNull final Adapter originalAdapter,
+            @NonNull final MoPubClientPositioning adPositioning) {
         this(new MoPubStreamAdPlacer(context, adPositioning), originalAdapter,
                 new VisibilityTracker(context));
     }
 
     @VisibleForTesting
-    MoPubAdAdapter(final MoPubStreamAdPlacer streamAdPlacer,
-            final Adapter originalAdapter,
-            final VisibilityTracker visibilityTracker) {
+    MoPubAdAdapter(@NonNull final MoPubStreamAdPlacer streamAdPlacer,
+            @NonNull final Adapter originalAdapter,
+            @NonNull final VisibilityTracker visibilityTracker) {
         mOriginalAdapter = originalAdapter;
         mStreamAdPlacer = streamAdPlacer;
         mViewPositionMap = new WeakHashMap<View, Integer>();
@@ -94,7 +99,7 @@ public MoPubAdAdapter(final Context context,
         mVisibilityTracker = visibilityTracker;
         mVisibilityTracker.setVisibilityTrackerListener(new VisibilityTrackerListener() {
             @Override
-            public void onVisibilityChanged(final List<View> visibleViews,
+            public void onVisibilityChanged(@NonNull final List<View> visibleViews,
                     final List<View> invisibleViews) {
                 handleVisibilityChange(visibleViews);
             }
@@ -153,9 +158,9 @@ void handleAdRemoved(final int position) {
      *
      * @param adRenderer The ad renderer.
      */
-    public final void registerAdRenderer(final MoPubAdRenderer adRenderer) {
-        if (adRenderer == null) {
-            MoPubLog.w("Tried to set a null ad renderer on the placer.");
+    public final void registerAdRenderer(@NonNull final MoPubAdRenderer adRenderer) {
+        if (!Preconditions.NoThrow.checkNotNull(
+                adRenderer, "Tried to set a null ad renderer on the placer.")) {
             return;
         }
         mStreamAdPlacer.registerAdRenderer(adRenderer);
@@ -173,7 +178,7 @@ public final void registerAdRenderer(final MoPubAdRenderer adRenderer) {
      *
      * @param listener The listener.
      */
-    public final void setAdLoadedListener(final MoPubNativeAdLoadedListener listener) {
+    public final void setAdLoadedListener(@Nullable final MoPubNativeAdLoadedListener listener) {
         mAdLoadedListener = listener;
     }
 
@@ -185,7 +190,7 @@ public final void setAdLoadedListener(final MoPubNativeAdLoadedListener listener
      *
      * @param adUnitId The ad unit ID to use when loading ads.
      */
-    public void loadAds(final String adUnitId) {
+    public void loadAds(@NonNull final String adUnitId) {
         mStreamAdPlacer.loadAds(adUnitId);
     }
 
@@ -203,8 +208,8 @@ public void loadAds(final String adUnitId) {
      * @param adUnitId The ad unit ID to use when loading ads.
      * @param requestParameters Targeting information to pass to the ad server.
      */
-    public void loadAds(final String adUnitId,
-            final RequestParameters requestParameters) {
+    public void loadAds(@NonNull final String adUnitId,
+            @Nullable final RequestParameters requestParameters) {
         mStreamAdPlacer.loadAds(adUnitId, requestParameters);
     }
 
@@ -280,6 +285,7 @@ public int getCount() {
      *
      * @inheritDoc
      */
+    @Nullable
     @Override
     public Object getItem(final int position) {
         final Object ad = mStreamAdPlacer.getAdData(position);
@@ -323,6 +329,7 @@ public boolean hasStableIds() {
      *
      * @inheritDoc
      */
+    @Nullable
     @Override
     public View getView(final int position, final View view, final ViewGroup viewGroup) {
         final View resultView;
@@ -377,7 +384,7 @@ public boolean isEmpty() {
         return mOriginalAdapter.isEmpty() && mStreamAdPlacer.getAdjustedCount(0) == 0;
     }
 
-    private void handleVisibilityChange(final List<View> visibleViews) {
+    private void handleVisibilityChange(@NonNull final List<View> visibleViews) {
         // Loop through all visible positions in order to build a max and min range, and then
         // place ads into that range.
         int min = Integer.MAX_VALUE;
@@ -451,7 +458,6 @@ public void removeItem(final int originalPosition) {
         mStreamAdPlacer.removeItem(originalPosition);
     }
 
-
     /**
      * Sets an on click listener for the given ListView, automatically adjusting the listener
      * callback positions based on ads in the adapter.
@@ -461,8 +467,17 @@ public void removeItem(final int originalPosition) {
      * @param listView The ListView for this adapter.
      * @param listener An on click listener.
      */
-    public void setOnClickListener(final ListView listView,
-            final OnItemClickListener listener) {
+    public void setOnClickListener(@NonNull final ListView listView,
+            @Nullable final OnItemClickListener listener) {
+        if (!NoThrow.checkNotNull(listView, "You called MoPubAdAdapter.setOnClickListener with a" +
+                " null ListView")) {
+            return;
+        }
+        if (listener == null) {
+            listView.setOnItemClickListener(null);
+            return;
+        }
+
         listView.setOnItemClickListener(new OnItemClickListener() {
             @Override
             public void onItemClick(final AdapterView<?> adapterView, final View view,
@@ -484,8 +499,17 @@ public void onItemClick(final AdapterView<?> adapterView, final View view,
      * @param listView The ListView for this adapter.
      * @param listener An an long click listener.
      */
-    public void setOnItemLongClickListener(final ListView listView,
-            final OnItemLongClickListener listener) {
+    public void setOnItemLongClickListener(@NonNull final ListView listView,
+            @Nullable final OnItemLongClickListener listener) {
+        if (!NoThrow.checkNotNull(listView, "You called MoPubAdAdapter." +
+                "setOnItemLongClickListener with a null ListView")) {
+            return;
+        }
+        if (listener == null) {
+            listView.setOnItemLongClickListener(null);
+            return;
+        }
+
         listView.setOnItemLongClickListener(new OnItemLongClickListener() {
             @Override
             public boolean onItemLongClick(final AdapterView<?> adapterView,
@@ -503,8 +527,17 @@ public boolean onItemLongClick(final AdapterView<?> adapterView,
      * @param listView The ListView for this adapter.
      * @param listener An an item selected listener.
      */
-    public void setOnItemSelectedListener(final ListView listView,
-            final OnItemSelectedListener listener) {
+    public void setOnItemSelectedListener(@NonNull final ListView listView,
+            @Nullable final OnItemSelectedListener listener) {
+        if (!NoThrow.checkNotNull(listView, "You called MoPubAdAdapter.setOnItemSelectedListener" +
+                " with a null ListView")) {
+            return;
+        }
+        if (listener == null) {
+            listView.setOnItemSelectedListener(null);
+            return;
+        }
+
         listView.setOnItemSelectedListener(new OnItemSelectedListener() {
             @Override
             public void onItemSelected(final AdapterView<?> adapterView,
@@ -529,7 +562,12 @@ public void onNothingSelected(final AdapterView<?> adapterView) {
      * @param listView The ListView for this adapter.
      * @param originalPosition The original content position before loading ads.
      */
-    public void setSelection(final ListView listView, final int originalPosition) {
+    public void setSelection(@NonNull final ListView listView, final int originalPosition) {
+        if (!NoThrow.checkNotNull(listView, "You called MoPubAdAdapter.setSelection with a null " +
+                "ListView")) {
+            return;
+        }
+
         listView.setSelection(mStreamAdPlacer.getAdjustedPosition(originalPosition));
     }
 
@@ -540,7 +578,13 @@ public void setSelection(final ListView listView, final int originalPosition) {
      * @param listView The ListView for this adapter.
      * @param originalPosition The original content position before loading ads.
      */
-    public void smoothScrollToPosition(final ListView listView, final int originalPosition) {
+    public void smoothScrollToPosition(@NonNull final ListView listView,
+            final int originalPosition) {
+        if (!NoThrow.checkNotNull(listView, "You called MoPubAdAdapter.smoothScrollToPosition " +
+                "with a null ListView")) {
+            return;
+        }
+
         listView.smoothScrollToPosition(mStreamAdPlacer.getAdjustedPosition(originalPosition));
     }
 
@@ -552,7 +596,7 @@ public void smoothScrollToPosition(final ListView listView, final int originalPo
      *
      * @param adUnitId The ad unit ID to use when loading ads.
      */
-    public void refreshAds(final ListView listView, String adUnitId) {
+    public void refreshAds(@NonNull final ListView listView, @NonNull String adUnitId) {
         refreshAds(listView, adUnitId, null);
     }
 
@@ -565,10 +609,10 @@ public void refreshAds(final ListView listView, String adUnitId) {
      * @param adUnitId The ad unit ID to use when loading ads.
      * @param requestParameters Targeting information to pass to the ad server.
      */
-    public void refreshAds(final ListView listView,
-            String adUnitId, RequestParameters requestParameters) {
-        if (listView.getAdapter() != this) {
-            MoPubLog.w("You called refreshAds on a ListView whose adapter is not an ad placer");
+    public void refreshAds(@NonNull final ListView listView,
+            @NonNull String adUnitId, @Nullable RequestParameters requestParameters) {
+        if (!NoThrow.checkNotNull(listView, "You called MoPubAdAdapter.refreshAds with a null " +
+                "ListView")) {
             return;
         }
 
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdRenderer.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdRenderer.java
index 87542fb1..ac2f0f29 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdRenderer.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdRenderer.java
@@ -1,6 +1,8 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 import android.view.ViewGroup;
 
@@ -9,8 +11,8 @@
  *
  * Normally you will use the subclass {@link com.mopub.nativeads.MoPubNativeAdRenderer} with {@link
  * com.mopub.nativeads.ViewBinder} to customize your ad view with your own layout. However, if you
- * wish to programmatically create or manage your ad view, you can implement {@code
- * }MoPubAdRenderer} directly.
+ * wish to programmatically create or manage your ad view, you can implement {@code MoPubAdRenderer}
+ * directly.
  *
  * @param <T> The ad payload type.
  */
@@ -19,21 +21,21 @@
      * Creates a new view to be used as an ad.
      *
      * This method is called when you call {@link com.mopub.nativeads.MoPubStreamAdPlacer#getAdView}
-     * when the convertView is null. You must return a valid view.
+     * and the convertView is null. You must return a valid view.
      *
+     * @param context The context. Useful for creating a view.
      * @param parent The parent that the view will eventually be attached to. You might use the
      * parent to determine layout parameters, but should return the view without attaching it to the
      * parent.
-     * @param context The context. Useful for creating a view.
      * @return A new ad view.
      */
-    View createAdView(Context context, ViewGroup parent);
+    View createAdView(@NonNull Context context, @Nullable ViewGroup parent);
 
     /**
      * Renders a view created by {@link #createAdView} by filling it with ad data.
      *
-     * @param view The ad View
+     * @param view The ad {@link View}
      * @param ad The ad data that should be bound to the view.
      */
-    void renderAdView(View view, T ad);
+    void renderAdView(@NonNull View view, @NonNull T ad);
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubCustomEventNative.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubCustomEventNative.java
index 93f1ad45..6c71875d 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubCustomEventNative.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubCustomEventNative.java
@@ -1,87 +1,87 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 
+import com.mopub.common.event.ErrorEvent;
+import com.mopub.common.event.MoPubEvents;
 import com.mopub.common.logging.MoPubLog;
 
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
-import org.json.JSONTokener;
 
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 
 import static com.mopub.common.util.Numbers.parseDouble;
-import static com.mopub.nativeads.CustomEventNativeAdapter.RESPONSE_BODY_KEY;
+import static com.mopub.common.DataKeys.JSON_BODY_KEY;
 import static com.mopub.nativeads.NativeResponse.Parameter;
 
 public class MoPubCustomEventNative extends CustomEventNative {
 
     @Override
-    protected void loadNativeAd(final Context context,
-            final CustomEventNativeListener customEventNativeListener,
-            final Map<String, Object> localExtras,
-            final Map<String, String> serverExtras) {
+    protected void loadNativeAd(@NonNull final Context context,
+            @NonNull final CustomEventNativeListener customEventNativeListener,
+            @NonNull final Map<String, Object> localExtras,
+            @NonNull final Map<String, String> serverExtras) {
+
+        Object json = localExtras.get(JSON_BODY_KEY);
+        // null or non-JSONObjects should not be passed in localExtras as JSON_BODY_KEY
+        if (!(json instanceof JSONObject)) {
+            customEventNativeListener.onNativeAdFailed(NativeErrorCode.INVALID_JSON);
+            return;
+        }
 
         final MoPubForwardingNativeAd moPubForwardingNativeAd =
                 new MoPubForwardingNativeAd(context.getApplicationContext(),
-                        serverExtras.get(RESPONSE_BODY_KEY),
+                        (JSONObject) json,
                         customEventNativeListener);
 
         try {
             moPubForwardingNativeAd.loadAd();
         } catch (IllegalArgumentException e) {
             customEventNativeListener.onNativeAdFailed(NativeErrorCode.UNSPECIFIED);
-            return;
-        } catch (JSONException e) {
-            customEventNativeListener.onNativeAdFailed(NativeErrorCode.INVALID_JSON);
-            return;
         }
     }
 
     static class MoPubForwardingNativeAd extends BaseForwardingNativeAd {
-        private final Context mContext;
-        private final String mJsonString;
-        private final CustomEventNativeListener mCustomEventNativeListener;
-
-        MoPubForwardingNativeAd(final Context context,
-                final String jsonString,
-                final CustomEventNativeListener customEventNativeListener) {
+        @NonNull private final Context mContext;
+        @NonNull private final CustomEventNativeListener mCustomEventNativeListener;
+        @NonNull private final JSONObject mJsonObject;
+
+        MoPubForwardingNativeAd(@NonNull final Context context,
+                @NonNull final JSONObject jsonBody,
+                @NonNull final CustomEventNativeListener customEventNativeListener) {
+            mJsonObject = jsonBody;
             mContext = context;
-            mJsonString = jsonString;
             mCustomEventNativeListener = customEventNativeListener;
         }
 
-        void loadAd() throws IllegalArgumentException, JSONException {
-            if (mJsonString == null) {
-                throw new IllegalArgumentException("Json String cannot be null");
-            }
-
-            final JSONTokener jsonTokener = new JSONTokener(mJsonString);
-            final JSONObject jsonObject = new JSONObject(jsonTokener);
-
-            if (!containsRequiredKeys(jsonObject)) {
+        void loadAd() throws IllegalArgumentException {
+            if (!containsRequiredKeys(mJsonObject)) {
                 throw new IllegalArgumentException("JSONObject did not contain required keys.");
             }
 
-            final Iterator<String> keys = jsonObject.keys();
+            final Iterator<String> keys = mJsonObject.keys();
             while (keys.hasNext()) {
                 final String key = keys.next();
                 final Parameter parameter = Parameter.from(key);
 
                 if (parameter != null) {
                     try {
-                        addInstanceVariable(parameter, jsonObject.opt(key));
+                        addInstanceVariable(parameter, mJsonObject.opt(key));
                     } catch (ClassCastException e) {
                         throw new IllegalArgumentException("JSONObject key (" + key + ") contained unexpected value.");
                     }
                 } else {
-                    addExtra(key, jsonObject.opt(key));
+                    addExtra(key, mJsonObject.opt(key));
                 }
             }
 
@@ -98,9 +98,8 @@ public void onImagesFailedToCache(final NativeErrorCode errorCode) {
             });
         }
 
-        private boolean containsRequiredKeys(final JSONObject jsonObject) {
+        private boolean containsRequiredKeys(@NonNull final JSONObject jsonObject) {
             final Set<String> keys = new HashSet<String>();
-
             final Iterator<String> jsonKeys = jsonObject.keys();
             while (jsonKeys.hasNext()) {
                 keys.add(jsonKeys.next());
@@ -109,7 +108,8 @@ private boolean containsRequiredKeys(final JSONObject jsonObject) {
             return keys.containsAll(Parameter.requiredKeys);
         }
 
-        private void addInstanceVariable(final Parameter key, final Object value) throws ClassCastException {
+        private void addInstanceVariable(@NonNull final Parameter key,
+                @Nullable final Object value) throws ClassCastException {
             try {
                 switch (key) {
                     case MAIN_IMAGE:
@@ -167,10 +167,11 @@ private void addImpressionTrackers(final Object impressionTrackers) throws Class
             }
         }
 
-        private boolean isImageKey(final String name) {
-            return name != null && name.toLowerCase().endsWith("image");
+        private boolean isImageKey(@Nullable final String name) {
+            return name != null && name.toLowerCase(Locale.US).endsWith("image");
         }
 
+        @NonNull
         List<String> getExtrasImageUrls() {
             final List<String> extrasBitmapUrls = new ArrayList<String>(getExtras().size());
             for (final Map.Entry<String, Object> entry : getExtras().entrySet()) {
@@ -182,6 +183,7 @@ private boolean isImageKey(final String name) {
             return extrasBitmapUrls;
         }
 
+        @NonNull
         List<String> getAllImageUrls() {
             final List<String> imageUrls = new ArrayList<String>();
             if (getMainImageUrl() != null) {
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNative.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNative.java
index 8c718eb4..04123976 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNative.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNative.java
@@ -1,35 +1,41 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
-import com.mopub.common.DownloadResponse;
-import com.mopub.common.DownloadTask;
-import com.mopub.common.GpsHelper;
-import com.mopub.common.HttpClient;
+
+import com.mopub.common.AdFormat;
+import com.mopub.common.Constants;
+import com.mopub.common.Preconditions;
 import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.AsyncTasks;
 import com.mopub.common.util.DeviceUtils;
 import com.mopub.common.util.ManifestUtils;
-import com.mopub.common.util.ResponseHeader;
-import org.apache.http.HttpStatus;
-import org.apache.http.client.methods.HttpGet;
-import org.apache.http.client.methods.HttpUriRequest;
+import com.mopub.mobileads.MoPubErrorCode;
+import com.mopub.network.AdRequest;
+import com.mopub.network.AdResponse;
+import com.mopub.network.MoPubNetworkError;
+import com.mopub.network.Networking;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.RequestQueue;
+import com.mopub.volley.VolleyError;
 
 import java.lang.ref.WeakReference;
-import java.util.*;
+import java.util.Map;
+import java.util.TreeMap;
 
-import static com.mopub.common.GpsHelper.GpsHelperListener;
 import static com.mopub.common.GpsHelper.fetchAdvertisingInfoAsync;
 import static com.mopub.nativeads.CustomEventNative.CustomEventNativeListener;
 import static com.mopub.nativeads.NativeErrorCode.CONNECTION_ERROR;
 import static com.mopub.nativeads.NativeErrorCode.EMPTY_AD_RESPONSE;
+import static com.mopub.nativeads.NativeErrorCode.INVALID_JSON;
 import static com.mopub.nativeads.NativeErrorCode.INVALID_REQUEST_URL;
 import static com.mopub.nativeads.NativeErrorCode.SERVER_ERROR_RESPONSE_CODE;
-import static com.mopub.nativeads.NativeErrorCode.UNEXPECTED_RESPONSE_CODE;
 import static com.mopub.nativeads.NativeErrorCode.UNSPECIFIED;
 
 public class MoPubNative {
+
     public interface MoPubNativeNetworkListener {
         public void onNativeLoad(final NativeResponse nativeResponse);
         public void onNativeFail(final NativeErrorCode errorCode);
@@ -38,7 +44,7 @@
     static final MoPubNativeNetworkListener EMPTY_NETWORK_LISTENER = new
             MoPubNativeNetworkListener() {
         @Override
-        public void onNativeLoad(final NativeResponse nativeResponse) {
+        public void onNativeLoad(@NonNull final NativeResponse nativeResponse) {
             // If this listener is invoked, it means that MoPubNative instance has been destroyed
             // so destroy any leftover incoming NativeResponses
             nativeResponse.destroy();
@@ -51,10 +57,10 @@ public void onNativeFail(final NativeErrorCode errorCode) {
     static final MoPubNativeEventListener EMPTY_EVENT_LISTENER = new
             MoPubNativeEventListener() {
         @Override
-        public void onNativeImpression(final View view) {
+        public void onNativeImpression(@Nullable final View view) {
         }
         @Override
-        public void onNativeClick(final View view) {
+        public void onNativeClick(@Nullable final View view) {
         }
     };
 
@@ -72,11 +78,15 @@ public void onNativeClick(final View view) {
     }
 
     // must be an activity context since 3rd party networks need it
-    private final WeakReference<Context> mContext;
-    private final String mAdUnitId;
-    private MoPubNativeNetworkListener mMoPubNativeNetworkListener;
-    private MoPubNativeEventListener mMoPubNativeEventListener;
-    private Map<String, Object> mLocalExtras;
+    @NonNull private final WeakReference<Context> mContext;
+    @NonNull private final String mAdUnitId;
+    @NonNull private MoPubNativeNetworkListener mMoPubNativeNetworkListener;
+    @NonNull private MoPubNativeEventListener mMoPubNativeEventListener;
+
+    // For small sets TreeMap, takes up less memory than HashMap
+    @NonNull private Map<String, Object> mLocalExtras = new TreeMap<String, Object>();
+    @NonNull private final AdRequest.Listener mVolleyListener;
+    @Nullable private AdRequest mNativeRequest;
 
     /**
      * @deprecated As of release 2.4, use {@link MoPubNative(Context, String,
@@ -84,23 +94,19 @@ public void onNativeClick(final View view) {
      * instead.
      */
     @Deprecated
-    public MoPubNative(final Context context,
-            final String adUnitId,
-            final MoPubNativeListener moPubNativeListener) {
-        this(context, adUnitId, (MoPubNativeNetworkListener)moPubNativeListener);
+    public MoPubNative(@NonNull final Context context,
+            @NonNull final String adUnitId,
+            @NonNull final MoPubNativeListener moPubNativeListener) {
+        this(context, adUnitId, (MoPubNativeNetworkListener) moPubNativeListener);
         setNativeEventListener(moPubNativeListener);
     }
 
-    public MoPubNative(final Context context,
-                final String adUnitId,
-                final MoPubNativeNetworkListener moPubNativeNetworkListener) {
-        if (context == null) {
-            throw new IllegalArgumentException("Context may not be null.");
-        } else if (adUnitId == null) {
-            throw new IllegalArgumentException("AdUnitId may not be null.");
-        } else if (moPubNativeNetworkListener == null) {
-            throw new IllegalArgumentException("MoPubNativeNetworkListener may not be null.");
-        }
+    public MoPubNative(@NonNull final Context context,
+                @NonNull final String adUnitId,
+                @NonNull final MoPubNativeNetworkListener moPubNativeNetworkListener) {
+        Preconditions.checkNotNull(context, "Context may not be null.");
+        Preconditions.checkNotNull(adUnitId, "AdUnitId may not be null.");
+        Preconditions.checkNotNull(moPubNativeNetworkListener, "MoPubNativeNetworkListener may not be null.");
 
         ManifestUtils.checkNativeActivitiesDeclared(context);
 
@@ -108,40 +114,55 @@ public MoPubNative(final Context context,
         mAdUnitId = adUnitId;
         mMoPubNativeNetworkListener = moPubNativeNetworkListener;
         mMoPubNativeEventListener = EMPTY_EVENT_LISTENER;
+        mVolleyListener = new AdRequest.Listener() {
+            @Override
+            public void onSuccess(@NonNull final AdResponse response) {
+                onAdLoad(response);
+            }
+
+            @Override
+            public void onErrorResponse(@NonNull final VolleyError volleyError) {
+                onAdError(volleyError);
+            }
+        };
 
         // warm up cache for google play services info
         fetchAdvertisingInfoAsync(context, null);
     }
 
-    public void setNativeEventListener(final MoPubNativeEventListener nativeEventListener) {
+    public void setNativeEventListener(@Nullable final MoPubNativeEventListener nativeEventListener) {
         mMoPubNativeEventListener = (nativeEventListener == null)
                 ? EMPTY_EVENT_LISTENER : nativeEventListener;
     }
 
     public void destroy() {
         mContext.clear();
+        if (mNativeRequest != null) {
+            mNativeRequest.cancel();
+            mNativeRequest = null;
+        }
         mMoPubNativeNetworkListener = EMPTY_NETWORK_LISTENER;
         mMoPubNativeEventListener = EMPTY_EVENT_LISTENER;
     }
 
-    public void setLocalExtras(final Map<String, Object> localExtras) {
-        mLocalExtras = new HashMap<String, Object>(localExtras);
+    public void setLocalExtras(@Nullable final Map<String, Object> localExtras) {
+        if (localExtras == null) {
+            mLocalExtras = new TreeMap<String, Object>();
+        } else {
+            mLocalExtras = new TreeMap<String, Object>(localExtras);
+        }
     }
 
     public void makeRequest() {
         makeRequest((RequestParameters)null);
     }
 
-    public void makeRequest(final RequestParameters requestParameters) {
+    public void makeRequest(@Nullable final RequestParameters requestParameters) {
         makeRequest(requestParameters, null);
     }
 
-    public void makeRequest(final RequestParameters requestParameters,
-            Integer sequenceNumber) {
-        makeRequest(new NativeGpsHelperListener(requestParameters, sequenceNumber));
-    }
-
-    void makeRequest(final NativeGpsHelperListener nativeGpsHelperListener) {
+    public void makeRequest(@Nullable final RequestParameters requestParameters,
+            @Nullable Integer sequenceNumber) {
         final Context context = getContextOrDestroy();
         if (context == null) {
             return;
@@ -152,18 +173,12 @@ void makeRequest(final NativeGpsHelperListener nativeGpsHelperListener) {
             return;
         }
 
-        // If we have access to Google Play Services (GPS) but the advertising info
-        // is not cached then guarantee we get it before building the ad request url
-        // in the callback, this is a requirement from Google
-        GpsHelper.fetchAdvertisingInfoAsync(
-                context,
-                nativeGpsHelperListener
-        );
+        loadNativeAd(requestParameters, sequenceNumber);
     }
 
-
-    private void loadNativeAd(final RequestParameters requestParameters,
-            final Integer sequenceNumber) {
+    private void loadNativeAd(
+            @Nullable final RequestParameters requestParameters,
+            @Nullable final Integer sequenceNumber) {
         final Context context = getContextOrDestroy();
         if (context == null) {
             return;
@@ -177,7 +192,7 @@ private void loadNativeAd(final RequestParameters requestParameters,
             generator.withSequenceNumber(sequenceNumber);
         }
 
-        final String endpointUrl = generator.generateUrlString(Constants.NATIVE_HOST);
+        final String endpointUrl = generator.generateUrlString(Constants.HOST);
 
         if (endpointUrl != null) {
             MoPubLog.d("Loading ad from: " + endpointUrl);
@@ -186,11 +201,7 @@ private void loadNativeAd(final RequestParameters requestParameters,
         requestNativeAd(endpointUrl);
     }
 
-    void loadNativeAd(final RequestParameters requestParameters) {
-        loadNativeAd(requestParameters, null);
-    }
-
-    void requestNativeAd(final String endpointUrl) {
+    void requestNativeAd(@Nullable final String endpointUrl) {
         final Context context = getContextOrDestroy();
         if (context == null) {
             return;
@@ -201,70 +212,86 @@ void requestNativeAd(final String endpointUrl) {
             return;
         }
 
-        final HttpGet httpGet;
-        try {
-            httpGet = HttpClient.initializeHttpGet(endpointUrl, context);
-        } catch (IllegalArgumentException e) {
-            mMoPubNativeNetworkListener.onNativeFail(INVALID_REQUEST_URL);
-            return;
-        }
-
-        downloadJson(httpGet);
+        mNativeRequest = new AdRequest(endpointUrl, AdFormat.NATIVE, mAdUnitId, context, mVolleyListener);
+        RequestQueue requestQueue = Networking.getRequestQueue(context);
+        requestQueue.add(mNativeRequest);
     }
 
-    private void downloadJson(final HttpUriRequest httpUriRequest) {
-        final DownloadTask jsonDownloadTask = new DownloadTask(new DownloadTask.DownloadTaskListener() {
-            @Override
-            public void onComplete(final String url, final DownloadResponse downloadResponse) {
-                if (downloadResponse == null) {
-                    mMoPubNativeNetworkListener.onNativeFail(UNSPECIFIED);
-                } else if (downloadResponse.getStatusCode() >= 500 &&
-                        downloadResponse.getStatusCode() < 600) {
-                    mMoPubNativeNetworkListener.onNativeFail(SERVER_ERROR_RESPONSE_CODE);
-                } else if (downloadResponse.getStatusCode() != HttpStatus.SC_OK) {
-                    mMoPubNativeNetworkListener.onNativeFail(UNEXPECTED_RESPONSE_CODE);
-                } else if (downloadResponse.getContentLength() == 0) {
-                    mMoPubNativeNetworkListener.onNativeFail(EMPTY_AD_RESPONSE);
-                } else {
-                    final CustomEventNativeListener customEventNativeListener = new CustomEventNativeListener() {
-                        @Override
-                        public void onNativeAdLoaded(final NativeAdInterface nativeAd) {
-                            final Context context = getContextOrDestroy();
-                            if (context == null) {
-                                return;
-                            }
-                            mMoPubNativeNetworkListener.onNativeLoad(new NativeResponse(context, downloadResponse, mAdUnitId, nativeAd, mMoPubNativeEventListener));
-                        }
-
-                        @Override
-                        public void onNativeAdFailed(final NativeErrorCode errorCode) {
-                            requestNativeAd(downloadResponse.getFirstHeader(ResponseHeader.FAIL_URL));
+    private void onAdLoad(@NonNull final AdResponse response) {
+        final Context context = getContextOrDestroy();
+        if (context == null) {
+            return;
+        }
+        final CustomEventNativeListener customEventNativeListener =
+                new CustomEventNativeListener() {
+                    @Override
+                    public void onNativeAdLoaded(@NonNull final NativeAdInterface nativeAd) {
+                        final Context context = getContextOrDestroy();
+                        if (context == null) {
+                            return;
                         }
-                    };
+                        mMoPubNativeNetworkListener.onNativeLoad(new NativeResponse(context,
+                                response.getImpressionTrackingUrl(),
+                                response.getClickTrackingUrl(),
+                                mAdUnitId,
+                                nativeAd,
+                                mMoPubNativeEventListener));
+                    }
 
-                    final Context context = getContextOrDestroy();
-                    if (context == null) {
-                        return;
+                    @Override
+                    public void onNativeAdFailed(final NativeErrorCode errorCode) {
+                        requestNativeAd(response.getFailoverUrl());
                     }
+                };
 
-                    CustomEventNativeAdapter.loadNativeAd(
-                            context,
-                            mLocalExtras,
-                            downloadResponse,
-                            customEventNativeListener
-                    );
-                }
-            }
-        });
 
-        try {
-            AsyncTasks.safeExecuteOnExecutor(jsonDownloadTask, httpUriRequest);
-        } catch (Exception e) {
-            MoPubLog.d("Failed to download json", e);
 
-            mMoPubNativeNetworkListener.onNativeFail(UNSPECIFIED);
-        }
+        CustomEventNativeAdapter.loadNativeAd(
+                context,
+                mLocalExtras,
+                response,
+                customEventNativeListener
+        );
+    }
 
+    @VisibleForTesting
+    void onAdError(@NonNull final VolleyError volleyError) {
+        MoPubLog.d("Native ad request failed.", volleyError);
+        if (volleyError instanceof MoPubNetworkError) {
+            MoPubNetworkError error = (MoPubNetworkError) volleyError;
+            switch (error.getReason()) {
+                case BAD_BODY:
+                    mMoPubNativeNetworkListener.onNativeFail(INVALID_JSON);
+                    return;
+                case BAD_HEADER_DATA:
+                    mMoPubNativeNetworkListener.onNativeFail(INVALID_JSON);
+                    return;
+                case WARMING_UP:
+                    // Used for the sample app to signal a toast.
+                    // This is not customer-facing except in the sample app.
+                    MoPubLog.c(MoPubErrorCode.WARMUP.toString());
+                    mMoPubNativeNetworkListener.onNativeFail(EMPTY_AD_RESPONSE);
+                    return;
+                case NO_FILL:
+                    mMoPubNativeNetworkListener.onNativeFail(EMPTY_AD_RESPONSE);
+                    return;
+                case UNSPECIFIED:
+                default:
+                    mMoPubNativeNetworkListener.onNativeFail(UNSPECIFIED);
+                    return;
+            }
+        } else {
+            // Process our other status code errors.
+            NetworkResponse response = volleyError.networkResponse;
+            if (response != null && response.statusCode >= 500 && response.statusCode < 600) {
+                mMoPubNativeNetworkListener.onNativeFail(SERVER_ERROR_RESPONSE_CODE);
+            } else if (response == null && !DeviceUtils.isNetworkAvailable(mContext.get())) {
+                MoPubLog.c(String.valueOf(MoPubErrorCode.NO_CONNECTION.toString()));
+                mMoPubNativeNetworkListener.onNativeFail(CONNECTION_ERROR);
+            } else {
+                mMoPubNativeNetworkListener.onNativeFail(UNSPECIFIED);
+            }
+        }
     }
 
     Context getContextOrDestroy() {
@@ -277,33 +304,14 @@ Context getContextOrDestroy() {
         return context;
     }
 
-    // Do not store this class as a member of MoPubNative; will result in circular reference
-    class NativeGpsHelperListener implements GpsHelperListener {
-        private final RequestParameters mRequestParameters;
-        private final Integer mSequenceNumber;
-
-        NativeGpsHelperListener(RequestParameters requestParameters, Integer sequenceNumber) {
-            mRequestParameters = requestParameters;
-            mSequenceNumber = sequenceNumber;
-        }
-
-        NativeGpsHelperListener(RequestParameters requestParameters) {
-            this(requestParameters, null);
-        }
-
-        @Override
-        public void onFetchAdInfoCompleted() {
-
-            loadNativeAd(mRequestParameters, mSequenceNumber);
-        }
-    }
-
+    @NonNull
     @VisibleForTesting
     @Deprecated
     MoPubNativeNetworkListener getMoPubNativeNetworkListener() {
         return mMoPubNativeNetworkListener;
     }
 
+    @NonNull
     @VisibleForTesting
     @Deprecated
     MoPubNativeEventListener getMoPubNativeEventListener() {
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdPositioning.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdPositioning.java
index 593439ee..d3e1b6c9 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdPositioning.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdPositioning.java
@@ -1,5 +1,7 @@
 package com.mopub.nativeads;
 
+import android.support.annotation.NonNull;
+
 import com.mopub.common.Preconditions;
 
 import java.util.ArrayList;
@@ -38,7 +40,7 @@
          */
         public static final int NO_REPEAT = Integer.MAX_VALUE;
 
-        private final ArrayList<Integer> mFixedPositions = new ArrayList<Integer>();
+        @NonNull private final ArrayList<Integer> mFixedPositions = new ArrayList<Integer>();
         private int mRepeatInterval = NO_REPEAT;
 
         public MoPubClientPositioning() {
@@ -50,6 +52,7 @@ public MoPubClientPositioning() {
          * @param position The ad position.
          * @return This object for easy use in chained setters.
          */
+        @NonNull
         public MoPubClientPositioning addFixedPosition(final int position) {
             if (!Preconditions.NoThrow.checkArgument(position >= 0)) {
                 return this;
@@ -68,6 +71,7 @@ public MoPubClientPositioning addFixedPosition(final int position) {
          *
          * @return Fixed ad positions.
          */
+        @NonNull
         List<Integer> getFixedPositions() {
             return mFixedPositions;
         }
@@ -79,6 +83,7 @@ public MoPubClientPositioning addFixedPosition(final int position) {
          * the constant NO_REPEAT.
          * @return This object for easy use in chained setters.
          */
+        @NonNull
         public MoPubClientPositioning enableRepeatingPositions(final int interval) {
             if (!Preconditions.NoThrow.checkArgument(
                     interval > 1, "Repeating interval must be greater than 1")) {
@@ -102,7 +107,10 @@ int getRepeatingInterval() {
         }
     }
 
-    static MoPubClientPositioning clone(MoPubClientPositioning positioning) {
+    @NonNull
+    static MoPubClientPositioning clone(@NonNull MoPubClientPositioning positioning) {
+        Preconditions.checkNotNull(positioning);
+
         MoPubClientPositioning clone = new MoPubClientPositioning();
         clone.mFixedPositions.addAll(positioning.mFixedPositions);
         clone.mRepeatInterval = positioning.mRepeatInterval;
@@ -113,6 +121,7 @@ static MoPubClientPositioning clone(MoPubClientPositioning positioning) {
      * Creates and returns a {@link MoPubClientPositioning} object.
      * @return A new positioning object.
      */
+    @NonNull
     public static MoPubClientPositioning clientPositioning() {
         return new MoPubClientPositioning();
     }
@@ -121,6 +130,7 @@ public static MoPubClientPositioning clientPositioning() {
      * Creates and returns a {@link MoPubServerPositioning} object.
      * @return A new positioning object.
      */
+    @NonNull
     public static MoPubServerPositioning serverPositioning() {
         return new MoPubServerPositioning();
     }
@@ -133,6 +143,7 @@ public static MoPubServerPositioning serverPositioning() {
      * the MoPub UI. If you still want to hard-code positioning information in your app,
      * use {@link #clientPositioning} instead of this builder.
      */
+    @NonNull
     @Deprecated
     public static Builder newBuilder() {
         return new Builder();
@@ -143,12 +154,14 @@ public static Builder newBuilder() {
      */
     @Deprecated
     public static final class Builder extends MoPubClientPositioning {
+        @NonNull
         @Override
         public Builder addFixedPosition(final int position) {
             super.addFixedPosition(position);
             return this;
         }
 
+        @NonNull
         @Override
         public Builder enableRepeatingPositions(final int interval) {
             super.enableRepeatingPositions(interval);
@@ -160,6 +173,7 @@ public Builder enableRepeatingPositions(final int interval) {
          *
          * @return A new positioning object.
          */
+        @NonNull
         @Deprecated
         public MoPubClientPositioning build() {
             return this;
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdRenderer.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdRenderer.java
index e33dd2c6..4fd91ecf 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdRenderer.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdRenderer.java
@@ -1,12 +1,13 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
 
 import com.mopub.common.VisibleForTesting;
-import com.mopub.common.logging.MoPubLog;
 
 import java.util.WeakHashMap;
 
@@ -16,60 +17,40 @@
  * An implementation of {@link com.mopub.nativeads.MoPubAdRenderer} for rendering native ads.
  */
 public class MoPubNativeAdRenderer implements MoPubAdRenderer<NativeResponse> {
-
-    private final ViewBinder mViewBinder;
+    @NonNull private final ViewBinder mViewBinder;
 
     // This is used instead of View.setTag, which causes a memory leak in 2.3
     // and earlier: https://code.google.com/p/android/issues/detail?id=18273
-    private final WeakHashMap<View, NativeViewHolder> mViewHolderMap;
+    @VisibleForTesting @NonNull final WeakHashMap<View, NativeViewHolder> mViewHolderMap;
 
     /**
      * Constructs a native ad renderer with a view binder.
      *
      * @param viewBinder The view binder to use when inflating and rendering an ad.
      */
-    public MoPubNativeAdRenderer(final ViewBinder viewBinder) {
+    public MoPubNativeAdRenderer(@NonNull final ViewBinder viewBinder) {
         mViewBinder = viewBinder;
         mViewHolderMap = new WeakHashMap<View, NativeViewHolder>();
     }
 
     @Override
-    public View createAdView(final Context context, final ViewGroup parent) {
+    @NonNull
+    public View createAdView(@NonNull final Context context, @Nullable final ViewGroup parent) {
         return LayoutInflater
                 .from(context)
                 .inflate(mViewBinder.layoutId, parent, false);
     }
 
     @Override
-    public void renderAdView(final View view, final NativeResponse nativeResponse) {
-        final NativeViewHolder nativeViewHolder = getOrCreateNativeViewHolder(view, mViewBinder);
-
-        if (nativeViewHolder == null) {
-            MoPubLog.d("Could not create NativeViewHolder.");
-            return;
-        }
-
-        populateConvertViewSubViews(view, nativeViewHolder, nativeResponse, mViewBinder);
-        view.setVisibility(VISIBLE);
-    }
-
-    @VisibleForTesting
-    NativeViewHolder getOrCreateNativeViewHolder(final View view, final ViewBinder viewBinder) {
-        // Create view holder and put it in the view tag
+    public void renderAdView(@NonNull final View view,
+            @NonNull final NativeResponse nativeResponse) {
         NativeViewHolder nativeViewHolder = mViewHolderMap.get(view);
         if (nativeViewHolder == null) {
-            nativeViewHolder = NativeViewHolder.fromViewBinder(view, viewBinder);
+            nativeViewHolder = NativeViewHolder.fromViewBinder(view, mViewBinder);
             mViewHolderMap.put(view, nativeViewHolder);
-            return nativeViewHolder;
         }
-        return nativeViewHolder;
-    }
-
-    private void populateConvertViewSubViews(final View view,
-            final NativeViewHolder nativeViewHolder,
-            final NativeResponse nativeResponse,
-            final ViewBinder viewBinder) {
         nativeViewHolder.update(nativeResponse);
-        nativeViewHolder.updateExtras(view, nativeResponse, viewBinder);
+        nativeViewHolder.updateExtras(view, nativeResponse, mViewBinder);
+        view.setVisibility(VISIBLE);
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubStreamAdPlacer.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubStreamAdPlacer.java
index 0234a56b..e89f5d88 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubStreamAdPlacer.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubStreamAdPlacer.java
@@ -2,17 +2,26 @@
 
 import android.content.Context;
 import android.os.Handler;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 import android.view.ViewGroup;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.Preconditions.NoThrow;
 import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubServerPositioning;
 import com.mopub.nativeads.PositioningSource.PositioningListener;
 
-import java.util.*;
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.WeakHashMap;
 
 /**
- * @code MoPubStreamAdPlacer facilitates loading ads and placing them into a content stream.
+ * {@code MoPubStreamAdPlacer} facilitates loading ads and placing them into a content stream.
  *
  * If you are inserting ads into a ListView, we recommend that you use a {@link MoPubAdAdapter}
  * instead of this class.
@@ -29,25 +38,39 @@
      * instead of an ad.
      */
     public static final int CONTENT_VIEW_TYPE = 0;
+    private final static MoPubNativeAdLoadedListener EMPTY_NATIVE_AD_LOADED_LISTENER =
+            new MoPubNativeAdLoadedListener() {
+                @Override
+                public void onAdLoaded(final int position) {
+                }
+
+                @Override
+                public void onAdRemoved(final int position) {
+                }
+            };
+
+    @NonNull private final Context mContext;
+    @NonNull private final Handler mPlacementHandler;
+    @NonNull private final Runnable mPlacementRunnable;
+    @NonNull private final PositioningSource mPositioningSource;
+    @NonNull private final NativeAdSource mAdSource;
+    @NonNull private final ImpressionTracker mImpressionTracker;
 
-    private final Context mContext;
-    private final Handler mPlacementHandler;
-    private final Runnable mPlacementRunnable;
-    private final PositioningSource mPositioningSource;
-    private final NativeAdSource mAdSource;
-    private final ImpressionTracker mImpressionTracker;
-    private final WeakHashMap<View, NativeResponse> mNativeResponseMap;
+    @NonNull private final HashMap<NativeResponse, WeakReference<View>> mViewMap;
+    @NonNull private final WeakHashMap<View, NativeResponse> mNativeResponseMap;
 
     private boolean mHasReceivedPositions;
-    private PlacementData mPendingPlacementData;
+    @NonNull private PlacementData mPendingPlacementData;
     private boolean mHasReceivedAds;
     private boolean mHasPlacedAds;
-    private PlacementData mPlacementData;
+    @NonNull private PlacementData mPlacementData;
     
-    private MoPubAdRenderer mAdRenderer;
-    private String mAdUnitId;
+    @Nullable private MoPubAdRenderer mAdRenderer;
+    @Nullable private String mAdUnitId;
+
+    @NonNull private MoPubNativeAdLoadedListener mAdLoadedListener =
+            EMPTY_NATIVE_AD_LOADED_LISTENER;
 
-    private MoPubNativeAdLoadedListener mAdLoadedListener;
     // The visible range is the range of items which we believe are visible, inclusive.
     // Placing ads near this range makes for a smoother user experience when scrolling up
     // or down.
@@ -69,7 +92,7 @@
      *
      * @param context The activity context.
      */
-    public MoPubStreamAdPlacer(final Context context) {
+    public MoPubStreamAdPlacer(@NonNull final Context context) {
         // MoPubClientPositioning is mutable, so we must take care not to hold a
         // reference to it that might be subsequently modified by the caller.
         this(context, MoPubNativeAdPositioning.serverPositioning());
@@ -82,7 +105,8 @@ public MoPubStreamAdPlacer(final Context context) {
      * @param adPositioning A positioning object for specifying where ads will be placed in your
      * stream. See {@link MoPubNativeAdPositioning#serverPositioning()}.
      */
-    public MoPubStreamAdPlacer(final Context context, final MoPubServerPositioning adPositioning) {
+    public MoPubStreamAdPlacer(@NonNull final Context context,
+            @NonNull final MoPubServerPositioning adPositioning) {
         this(context,
                 new NativeAdSource(),
                 new ImpressionTracker(context),
@@ -96,7 +120,8 @@ public MoPubStreamAdPlacer(final Context context, final MoPubServerPositioning a
      * @param adPositioning A positioning object for specifying where ads will be placed in your
      * stream. See {@link MoPubNativeAdPositioning#clientPositioning()}.
      */
-    public MoPubStreamAdPlacer(final Context context, final MoPubClientPositioning adPositioning) {
+    public MoPubStreamAdPlacer(@NonNull final Context context,
+            @NonNull final MoPubClientPositioning adPositioning) {
         // MoPubClientPositioning is mutable, so we must take care not to hold a
         // reference to it that might be subsequently modified by the caller.
         this(context,
@@ -106,16 +131,25 @@ public MoPubStreamAdPlacer(final Context context, final MoPubClientPositioning a
     }
 
     @VisibleForTesting
-    MoPubStreamAdPlacer(final Context context,
-            final NativeAdSource adSource,
-            final ImpressionTracker impressionTracker,
-            final PositioningSource positioningSource) {
+    MoPubStreamAdPlacer(@NonNull final Context context,
+            @NonNull final NativeAdSource adSource,
+            @NonNull final ImpressionTracker impressionTracker,
+            @NonNull final PositioningSource positioningSource) {
+        Preconditions.checkNotNull(context, "context is not allowed to be null");
+        Preconditions.checkNotNull(adSource, "adSource is not allowed to be null");
+        Preconditions.checkNotNull(impressionTracker, "impressionTracker is not allowed to be " +
+                "null");
+        Preconditions.checkNotNull(positioningSource, "positioningSource is not allowed to be " +
+                "null");
+
         mContext = context;
         mImpressionTracker = impressionTracker;
         mPositioningSource = positioningSource;
         mAdSource = adSource;
         mPlacementData = PlacementData.empty();
+
         mNativeResponseMap = new WeakHashMap<View, NativeResponse>();
+        mViewMap = new HashMap<NativeResponse, WeakReference<View>>();
 
         mPlacementHandler = new Handler();
         mPlacementRunnable = new Runnable() {
@@ -142,7 +176,10 @@ public void run() {
      *
      * @param adRenderer The ad renderer.
      */
-    public void registerAdRenderer(final MoPubAdRenderer adRenderer) {
+    public void registerAdRenderer(@NonNull final MoPubAdRenderer adRenderer) {
+        if (!NoThrow.checkNotNull(adRenderer, "Cannot register a null adRenderer")) {
+            return;
+        }
         mAdRenderer = adRenderer;
     }
 
@@ -158,8 +195,8 @@ public void registerAdRenderer(final MoPubAdRenderer adRenderer) {
      *
      * @param listener The listener.
      */
-    public void setAdLoadedListener(final MoPubNativeAdLoadedListener listener) {
-        mAdLoadedListener = listener;
+    public void setAdLoadedListener(@Nullable final MoPubNativeAdLoadedListener listener) {
+        mAdLoadedListener = (listener == null) ? EMPTY_NATIVE_AD_LOADED_LISTENER : listener;
     }
 
     /**
@@ -170,14 +207,14 @@ public void setAdLoadedListener(final MoPubNativeAdLoadedListener listener) {
      *
      * @param adUnitId The ad unit ID to use when loading ads.
      */
-    public void loadAds(final String adUnitId) {
+    public void loadAds(@NonNull final String adUnitId) {
         loadAds(adUnitId, /* requestParameters */ null);
     }
 
     /**
      * Start loading ads from the MoPub server, using the given request targeting information.
      *
-     * When loading ads, use {@link MoPubNativeAdLoadedListener#onAdLoaded(int)} will be called for
+     * When loading ads, {@link MoPubNativeAdLoadedListener#onAdLoaded(int)} will be called for
      * each ad that is added to the stream.
      *
      * To refresh ads in your stream, call {@code loadAds} again. When new ads load, they will
@@ -188,8 +225,17 @@ public void loadAds(final String adUnitId) {
      * @param adUnitId The ad unit ID to use when loading ads.
      * @param requestParameters Targeting information to pass to the ad server.
      */
-    public void loadAds(final String adUnitId,
-            final RequestParameters requestParameters) {
+    public void loadAds(@NonNull final String adUnitId,
+            @Nullable final RequestParameters requestParameters) {
+        if (!NoThrow.checkNotNull(adUnitId, "Cannot load ads with a null ad unit ID")) {
+            return;
+        }
+
+        if (mAdRenderer == null) {
+            MoPubLog.w("You must call registerAdRenderer before loading ads");
+            return;
+        }
+
         mAdUnitId = adUnitId;
 
         mHasPlacedAds = false;
@@ -198,12 +244,15 @@ public void loadAds(final String adUnitId,
 
         mPositioningSource.loadPositions(adUnitId, new PositioningListener() {
             @Override
-            public void onLoad(final MoPubClientPositioning positioning) {
+            public void onLoad(@NonNull final MoPubClientPositioning positioning) {
                 handlePositioningLoad(positioning);
             }
 
             @Override
             public void onFailed() {
+                // This will happen only if positions couldn't be loaded after several tries
+                MoPubLog.d("Unable to show ads because ad positions could not be loaded from " +
+                        "the MoPub ad server.");
             }
         });
 
@@ -218,7 +267,7 @@ public void onAdsAvailable() {
     }
 
     @VisibleForTesting
-    void handlePositioningLoad(final MoPubClientPositioning positioning) {
+    void handlePositioningLoad(@NonNull final MoPubClientPositioning positioning) {
         PlacementData placementData = PlacementData.fromAdPositioning(positioning);
         if (mHasReceivedAds) {
             placeInitialAds(placementData);
@@ -257,7 +306,7 @@ private void placeInitialAds(PlacementData placementData) {
      * Inserts ads that should appear in the given range.
      *
      * By default, the ad placer will place ads withing the first 10 positions in your stream,
-     * according the positions you've specified. You can should use this method as your user scrolls
+     * according to the positions you've specified. You can use this method as your user scrolls
      * through your stream to place ads into the currently visible range.
      *
      * This method takes advantage of a short-lived in memory ad cache, and will immediately place
@@ -333,6 +382,7 @@ public void destroy() {
      * @param position The position where to place an ad.
      * @return An object representing ad data.
      */
+    @Nullable
     public Object getAdData(final int position) {
         return mPlacementData.getPlacedAd(position);
     }
@@ -343,36 +393,46 @@ public Object getAdData(final int position) {
      * This method will attempt to reuse the convertView if it is not {@code null}, and will
      * otherwise create it. See {@link MoPubAdRenderer#createAdView(Context, ViewGroup)}.
      *
-     * @param position The position where to place an ad.
+     * @param position The position to place an ad into.
      * @param convertView A recycled view into which to render data, or {@code null}.
      * @param parent The parent that the view will eventually be attached to.
      * @return The newly placed ad view.
      */
-    public View getAdView(final int position, final View convertView, final ViewGroup parent) {
-        if (!isAd(position)) {
+    @Nullable
+    public View getAdView(final int position, @Nullable final View convertView,
+            @Nullable final ViewGroup parent) {
+        final NativeAdData adData = mPlacementData.getPlacedAd(position);
+        if (adData == null) {
             return null;
         }
 
-        final NativeAdData adData = mPlacementData.getPlacedAd(position);
         final MoPubAdRenderer adRenderer = adData.getAdRenderer();
         final View view = (convertView != null) ?
                 convertView : adRenderer.createAdView(mContext, parent);
 
         NativeResponse nativeResponse = adData.getAd();
-        if (!nativeResponse.equals(mNativeResponseMap.get(view))) {
+        WeakReference<View> mappedViewRef = mViewMap.get(nativeResponse);
+        View mappedView = null;
+        if (mappedViewRef != null) {
+            mappedView = mappedViewRef.get();
+        }
+        if (!view.equals(mappedView)) {
+            clearNativeResponse(mappedView);
             clearNativeResponse(view);
             prepareNativeResponse(nativeResponse, view);
+            //noinspection unchecked
             adRenderer.renderAdView(view, nativeResponse);
         }
+
         return view;
     }
 
     /**
-     * Removes ads in the given range from [startRange, endRange).
+     * Removes ads in the given range from [originalStartPosition, originalEndPosition).
      *
-     * @param originalStartPosition The start position to clear, expressed as the original content
+     * @param originalStartPosition The start position to clear (inclusive), expressed as the original content
      * position before ads were inserted.
-     * @param originalEndPosition The position after end position to clear, expressed as the
+     * @param originalEndPosition The position after end position to clear (exclusive), expressed as the
      * original content position before ads were inserted.
      * @return The number of ads removed.
      */
@@ -487,14 +547,17 @@ public int getAdjustedCount(final int originalCount) {
      *
      * You must call this method so that the placer knows where valid positions are to place ads.
      * After calling this method, the ad placer will call {@link
-     * MoPubNativeAdLoadedListener#onAdLoaded
-     * (int)} each time an ad is loaded in the stream.
+     * MoPubNativeAdLoadedListener#onAdLoaded (int)} each time an ad is loaded in the stream.
      *
      * @param originalCount The original number of items.
      */
     public void setItemCount(final int originalCount) {
         mItemCount = mPlacementData.getAdjustedCount(originalCount);
-        notifyNeedsPlacement();
+
+        // If we haven't already placed ads, we'll let ads get placed by the normal loadAds call
+        if (mHasPlacedAds) {
+            notifyNeedsPlacement();
+        }
     }
 
     /**
@@ -509,7 +572,7 @@ public void setItemCount(final int originalCount) {
      *
      * and you insert an item at position 2, your new stream will look like:
      *
-     * {@code Item0 Ad Item1 Item2 New Item Ad Item3}
+     * {@code Item0 Ad Item1 Item2 NewItem Ad Item3}
      *
      * @param originalPosition The position at which to add an item. If you have an adjusted
      * position, you will need to call {@link #getOriginalPosition} to get this value.
@@ -545,6 +608,14 @@ public void removeItem(final int originalPosition) {
      * Use this method if you are moving an item in your stream and want to have ad positions move
      * as well.
      *
+     * For example if your stream looks like:
+     *
+     * {@code Item0 Ad Item1 Item2 Ad Item3}
+     *
+     * and you move item at position 2 to position 3, your new stream will look like:
+     *
+     * {@code Item0 Ad Item1 Ad Item3 Item2}
+     *
      * @param originalPosition The position from which to move an item. If you have an adjusted
      * position, you will need to call {@link #getOriginalPosition} to get this value.
      * @param newPosition The new position, also expressed in terms of the original position.
@@ -580,8 +651,12 @@ private void placeAds() {
     }
 
     /**
-     * Attempts to place ads in the range (start, end], returning false if there is no ad available
+     * Attempts to place ads in the range [start, end], returning false if there is no ad available
      * to be placed.
+     *
+     * @param start The start of the range in which to place ads, inclusive.
+     * @param end The end of the range in which to place ads, exclusive.
+     * @return false if there is no ad available to be placed.
      */
     private boolean tryPlaceAdsInRange(final int start, final int end) {
         int position = start;
@@ -604,6 +679,9 @@ private boolean tryPlaceAdsInRange(final int start, final int end) {
     /**
      * Attempts to place an ad at the given position, returning false if there is no ad available to
      * be placed.
+     *
+     * @param position The position to place the ad at.
+     * @return false if there is no ad available to be placed.
      */
     private boolean tryPlaceAd(final int position) {
         final NativeResponse adResponse = mAdSource.dequeueAd();
@@ -615,25 +693,34 @@ private boolean tryPlaceAd(final int position) {
         mPlacementData.placeAd(position, adData);
         mItemCount++;
 
-        if (mAdLoadedListener != null) {
-            mAdLoadedListener.onAdLoaded(position);
-        }
+        mAdLoadedListener.onAdLoaded(position);
         return true;
     }
 
-    private NativeAdData createAdData(final int position, final NativeResponse adResponse) {
+    @NonNull
+    private NativeAdData createAdData(final int position, @NonNull final NativeResponse adResponse) {
+        Preconditions.checkNotNull(mAdUnitId);
+        Preconditions.checkNotNull(mAdRenderer);
+
+        //noinspection ConstantConditions
         return new NativeAdData(mAdUnitId, mAdRenderer, adResponse);
     }
 
-    private void clearNativeResponse(final View view) {
+    private void clearNativeResponse(@Nullable final View view) {
+        if (view == null) {
+            return;
+        }
         mImpressionTracker.removeView(view);
         final NativeResponse lastNativeResponse = mNativeResponseMap.get(view);
         if (lastNativeResponse != null) {
             lastNativeResponse.clear(view);
+            mNativeResponseMap.remove(view);
+            mViewMap.remove(lastNativeResponse);
         }
     }
 
-    private void prepareNativeResponse(final NativeResponse nativeResponse, final View view) {
+    private void prepareNativeResponse(@NonNull final NativeResponse nativeResponse, @NonNull final View view) {
+        mViewMap.put(nativeResponse, new WeakReference<View>(view));
         mNativeResponseMap.put(view, nativeResponse);
         if (!nativeResponse.isOverridingImpressionTracker()) {
             mImpressionTracker.addView(view, nativeResponse);
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdData.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdData.java
index d4623a35..1f110083 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdData.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdData.java
@@ -1,29 +1,34 @@
 package com.mopub.nativeads;
 
+import android.support.annotation.NonNull;
+
 /**
  * An object that represents placed ads in a {@link com.mopub.nativeads.MoPubStreamAdPlacer}
  */
 class NativeAdData {
-    private final String adUnitId;
-    private final MoPubAdRenderer adRenderer;
-    private final NativeResponse adResponse;
+    @NonNull private final String adUnitId;
+    @NonNull private final MoPubAdRenderer adRenderer;
+    @NonNull private final NativeResponse adResponse;
 
-    NativeAdData(final String adUnitId,
-            final MoPubAdRenderer adRenderer,
-            final NativeResponse adResponse) {
+    NativeAdData(@NonNull final String adUnitId,
+            @NonNull final MoPubAdRenderer adRenderer,
+            @NonNull final NativeResponse adResponse) {
         this.adUnitId = adUnitId;
         this.adRenderer = adRenderer;
         this.adResponse = adResponse;
     }
 
+    @NonNull
     String getAdUnitId() {
         return adUnitId;
     }
 
+    @NonNull
     MoPubAdRenderer getAdRenderer() {
         return adRenderer;
     }
 
+    @NonNull
     NativeResponse getAd() {
         return adResponse;
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdInterface.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdInterface.java
index d748a681..2b52e576 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdInterface.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdInterface.java
@@ -1,5 +1,7 @@
 package com.mopub.nativeads;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 
 import java.util.Map;
@@ -9,32 +11,52 @@
 
 interface NativeAdInterface {
     // Getters
+    @Nullable
     String getMainImageUrl();
+
+    @Nullable
     String getIconImageUrl();
+
+    @Nullable
     String getClickDestinationUrl();
+
+    @Nullable
     String getCallToAction();
+
+    @Nullable
     String getTitle();
+
+    @Nullable
     String getText();
+
+    @Nullable
     Double getStarRating();
 
+    @NonNull
     Set<String> getImpressionTrackers();
+
     int getImpressionMinPercentageViewed();
+
     int getImpressionMinTimeViewed();
 
     boolean isOverridingClickTracker();
+
     boolean isOverridingImpressionTracker();
 
     // Extras Getters
+    @Nullable
     Object getExtra(final String key);
+
+    @NonNull
     Map<String, Object> getExtras();
 
     // Setters
-    void setNativeEventListener(final NativeEventListener nativeEventListener);
+    void setNativeEventListener(@Nullable final NativeEventListener nativeEventListener);
 
     // Event Handlers
-    void prepare(final View view);
+    void prepare(@NonNull final View view);
     void recordImpression();
-    void handleClick(final View view);
-    void clear(final View view);
+    void handleClick(@Nullable final View view);
+    void clear(@NonNull final View view);
     void destroy();
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdSource.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdSource.java
index 29d8fda9..6e6a4fd8 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdSource.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdSource.java
@@ -3,6 +3,8 @@
 import android.content.Context;
 import android.os.Handler;
 import android.os.SystemClock;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 
 import com.mopub.common.VisibleForTesting;
 
@@ -34,21 +36,21 @@
     private static final int MAXIMUM_RETRY_TIME_MILLISECONDS = 5 * 60 * 1000; // 5 minutes.
     private static final double EXPONENTIAL_BACKOFF_FACTOR = 2.0;
 
-    private final List<TimestampWrapper<NativeResponse>> mNativeAdCache;
-    private final Handler mReplenishCacheHandler;
-    private final Runnable mReplenishCacheRunnable;
-    private final MoPubNativeNetworkListener mMoPubNativeNetworkListener;
+    @NonNull private final List<TimestampWrapper<NativeResponse>> mNativeAdCache;
+    @NonNull private final Handler mReplenishCacheHandler;
+    @NonNull private final Runnable mReplenishCacheRunnable;
+    @NonNull private final MoPubNativeNetworkListener mMoPubNativeNetworkListener;
 
     @VisibleForTesting boolean mRequestInFlight;
     @VisibleForTesting boolean mRetryInFlight;
     @VisibleForTesting int mSequenceNumber;
     @VisibleForTesting int mRetryTimeMilliseconds;
 
-    private AdSourceListener mAdSourceListener;
+    @Nullable private AdSourceListener mAdSourceListener;
 
     // We will need collections of these when we support multiple ad units.
-    private RequestParameters mRequestParameters;
-    private MoPubNative mMoPubNative;
+    @Nullable private RequestParameters mRequestParameters;
+    @Nullable private MoPubNative mMoPubNative;
 
     /**
      * A listener for when ads are available for dequeueing.
@@ -65,8 +67,8 @@
     }
 
     @VisibleForTesting
-    NativeAdSource(final List<TimestampWrapper<NativeResponse>> nativeAdCache,
-            final Handler replenishCacheHandler) {
+    NativeAdSource(@NonNull final List<TimestampWrapper<NativeResponse>> nativeAdCache,
+            @NonNull final Handler replenishCacheHandler) {
         mNativeAdCache = nativeAdCache;
         mReplenishCacheHandler = replenishCacheHandler;
         mReplenishCacheRunnable = new Runnable() {
@@ -80,7 +82,7 @@ public void run() {
         // Construct native URL and start filling the cache
         mMoPubNativeNetworkListener = new MoPubNativeNetworkListener() {
             @Override
-            public void onNativeLoad(final NativeResponse nativeResponse) {
+            public void onNativeLoad(@NonNull final NativeResponse nativeResponse) {
                 // This can be null if the ad source was cleared as the AsyncTask is posting
                 // back to the UI handler. Drop this response.
                 if (mMoPubNative == null) {
@@ -125,12 +127,12 @@ public void onNativeFail(final NativeErrorCode errorCode) {
      * Sets a adSourceListener for determining when ads are available.
      * @param adSourceListener An AdSourceListener.
      */
-    void setAdSourceListener(final AdSourceListener adSourceListener) {
+    void setAdSourceListener(@Nullable final AdSourceListener adSourceListener) {
         mAdSourceListener = adSourceListener;
     }
 
-    void loadAds(final Context context,
-            final String adUnitId,
+    void loadAds(@NonNull final Context context,
+            @NonNull final String adUnitId,
             final RequestParameters requestParameters) {
         loadAds(requestParameters, new MoPubNative(context, adUnitId, mMoPubNativeNetworkListener));
     }
@@ -179,6 +181,7 @@ void clear() {
      *
      * @return Ad ad item that should be rendered into a view.
      */
+    @Nullable
     NativeResponse dequeueAd() {
         final long now = SystemClock.uptimeMillis();
 
@@ -231,6 +234,7 @@ void setMoPubNative(final MoPubNative moPubNative) {
         mMoPubNative = moPubNative;
     }
 
+    @NonNull
     @Deprecated
     @VisibleForTesting
     MoPubNativeNetworkListener getMoPubNativeNetworkListener() {
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdViewHelper.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdViewHelper.java
index 969d27d6..2f1c838c 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdViewHelper.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdViewHelper.java
@@ -1,23 +1,30 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 import android.view.ViewGroup;
 
+import com.mopub.common.Preconditions;
 import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
 
 import java.util.WeakHashMap;
 
-import static android.view.View.GONE;
-import static com.mopub.nativeads.MoPubNative.MoPubNativeListener;
-
 /**
  * @deprecated As of release 2.4, use {@link com.mopub.nativeads.MoPubNativeAdRenderer} instead
  */
 @Deprecated
 class NativeAdViewHelper {
-    private NativeAdViewHelper() {}
+    private NativeAdViewHelper() {
+    }
+
+    @VisibleForTesting
+    enum ViewType {
+        EMPTY,
+        AD
+    }
 
     // Because the impression tracker requires tracking drawing views,
     // each context requires a separate impression tracker. To avoid leaking, keep weak references.
@@ -31,33 +38,34 @@ private NativeAdViewHelper() {}
             new WeakHashMap<View, NativeResponse>();
 
     @Deprecated
-    static View getAdView(View convertView,
-                          final ViewGroup parent,
-                          final Context context,
-                          final NativeResponse nativeResponse,
-                          final ViewBinder viewBinder,
-                          final MoPubNativeListener moPubNativeListener) {
+    @NonNull
+    static View getAdView(@Nullable View convertView,
+            @Nullable final ViewGroup parent,
+            @NonNull final Context context,
+            @Nullable final NativeResponse nativeResponse,
+            @Nullable final ViewBinder viewBinder) {
 
-        if (viewBinder == null) {
-            MoPubLog.d("ViewBinder is null, returning empty view.");
-            return new View(context);
-        }
+        Preconditions.NoThrow.checkNotNull(viewBinder, "ViewBinder is null.");
 
-        final MoPubNativeAdRenderer moPubNativeAdRenderer = new MoPubNativeAdRenderer(viewBinder);
-        if (convertView == null) {
-            convertView = moPubNativeAdRenderer.createAdView(context, parent);
+        if (convertView != null) {
+            clearNativeResponse(context, convertView);
         }
 
-        clearNativeResponse(context, convertView);
-
-        if (nativeResponse == null) {
-            // If we don't have content for the view, then hide the view for now
-            MoPubLog.d("NativeResponse is null, returning hidden view.");
-            convertView.setVisibility(GONE);
-        } else if (nativeResponse.isDestroyed()) {
-            MoPubLog.d("NativeResponse is destroyed, returning hidden view.");
-            convertView.setVisibility(GONE);
+        if (nativeResponse == null || nativeResponse.isDestroyed() || viewBinder == null) {
+            MoPubLog.d("nativeResponse or viewBinder null or invalid. Returning empty view");
+            // Only create a view if one hasn't been created already
+            if (convertView == null || !ViewType.EMPTY.equals(convertView.getTag())) {
+                convertView = new View(context);
+                convertView.setTag(ViewType.EMPTY);
+                convertView.setVisibility(View.GONE);
+            }
         } else {
+            final MoPubNativeAdRenderer moPubNativeAdRenderer = new MoPubNativeAdRenderer(viewBinder);
+            // Only create a view if one hasn't been created already
+            if (convertView == null || !ViewType.AD.equals(convertView.getTag())) {
+                convertView = moPubNativeAdRenderer.createAdView(context, parent);
+                convertView.setTag(ViewType.AD);
+            }
             prepareNativeResponse(context, convertView, nativeResponse);
             moPubNativeAdRenderer.renderAdView(convertView, nativeResponse);
         }
@@ -65,7 +73,8 @@ static View getAdView(View convertView,
         return convertView;
     }
 
-    private static void clearNativeResponse(final Context context, final View view) {
+    private static void clearNativeResponse(@NonNull final Context context,
+            @NonNull final View view) {
         getImpressionTracker(context).removeView(view);
         final NativeResponse nativeResponse = sNativeResponseMap.get(view);
         if (nativeResponse != null) {
@@ -73,9 +82,9 @@ private static void clearNativeResponse(final Context context, final View view)
         }
     }
 
-    private static void prepareNativeResponse(final Context context,
-            final View view,
-            final NativeResponse nativeResponse) {
+    private static void prepareNativeResponse(@NonNull final Context context,
+            @NonNull final View view,
+            @NonNull final NativeResponse nativeResponse) {
         sNativeResponseMap.put(view, nativeResponse);
         if (!nativeResponse.isOverridingImpressionTracker()) {
             getImpressionTracker(context).addView(view, nativeResponse);
@@ -83,7 +92,7 @@ private static void prepareNativeResponse(final Context context,
         nativeResponse.prepare(view);
     }
 
-    private static ImpressionTracker getImpressionTracker(final Context context) {
+    private static ImpressionTracker getImpressionTracker(@NonNull final Context context) {
         ImpressionTracker impressionTracker = sImpressionTrackerMap.get(context);
         if (impressionTracker == null) {
             impressionTracker = new ImpressionTracker(context);
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeErrorCode.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeErrorCode.java
index 7999f22f..0dd85382 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeErrorCode.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeErrorCode.java
@@ -1,5 +1,7 @@
 package com.mopub.nativeads;
 
+import android.support.annotation.NonNull;
+
 public enum NativeErrorCode {
     EMPTY_AD_RESPONSE("Server returned empty response."),
     INVALID_JSON("Unable to parse JSON response from server."),
@@ -24,6 +26,7 @@ private NativeErrorCode(String message) {
         this.message = message;
     }
 
+    @NonNull
     @Override
     public final String toString() {
         return message;
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeResponse.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeResponse.java
index c0eeb9ed..e332c6cf 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeResponse.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeResponse.java
@@ -1,22 +1,21 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
-import android.content.Intent;
-import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ImageView;
 
-import com.mopub.common.DownloadResponse;
-import com.mopub.common.HttpClient;
-import com.mopub.common.MoPubBrowser;
 import com.mopub.common.VisibleForTesting;
+import com.mopub.common.event.BaseEvent;
 import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.IntentUtils;
-import com.mopub.common.util.ResponseHeader;
 import com.mopub.nativeads.MoPubNative.MoPubNativeEventListener;
+import com.mopub.network.Networking;
+import com.mopub.network.TrackingRequest;
+import com.mopub.volley.VolleyError;
+import com.mopub.volley.toolbox.ImageLoader;
 
-import java.lang.ref.SoftReference;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashSet;
@@ -36,8 +35,6 @@
 import static com.mopub.nativeads.NativeResponse.Parameter.STAR_RATING;
 import static com.mopub.nativeads.NativeResponse.Parameter.TEXT;
 import static com.mopub.nativeads.NativeResponse.Parameter.TITLE;
-import static com.mopub.nativeads.UrlResolutionTask.UrlResolutionListener;
-import static com.mopub.nativeads.UrlResolutionTask.getResolvedUrl;
 
 public class NativeResponse {
     enum Parameter {
@@ -54,15 +51,16 @@
         CALL_TO_ACTION("ctatext", false),
         STAR_RATING("starrating", false);
 
-        final String name;
+        @NonNull final String name;
         final boolean required;
 
-        Parameter(final String name, boolean required) {
+        Parameter(@NonNull final String name, boolean required) {
             this.name = name;
             this.required = required;
         }
 
-        static Parameter from(final String name) {
+        @Nullable
+        static Parameter from(@NonNull final String name) {
             for (final Parameter parameter : values()) {
                 if (parameter.name.equals(name)) {
                     return parameter;
@@ -72,6 +70,7 @@ static Parameter from(final String name) {
             return null;
         }
 
+        @NonNull
         @VisibleForTesting
         static final Set<String> requiredKeys = new HashSet<String>();
         static {
@@ -83,24 +82,26 @@ static Parameter from(final String name) {
         }
     }
 
-    private final Context mContext;
-    private MoPubNativeEventListener mMoPubNativeEventListener;
-    private final NativeAdInterface mNativeAd;
+    @NonNull private final Context mContext;
+    @NonNull private final ImageLoader mImageLoader;
+    @NonNull private MoPubNativeEventListener mMoPubNativeEventListener;
+    @NonNull private final NativeAdInterface mNativeAd;
 
     // Impression and click trackers for the MoPub adserver
-    private final Set<String> mMoPubImpressionTrackers;
-    private final String mMoPubClickTracker;
-    private final String mAdUnitId;
+    @NonNull private final Set<String> mMoPubImpressionTrackers;
+    @NonNull private final String mMoPubClickTracker;
+    @NonNull private final String mAdUnitId;
 
     private boolean mRecordedImpression;
     private boolean mIsClicked;
     private boolean mIsDestroyed;
 
-    public NativeResponse(final Context context,
-            final DownloadResponse downloadResponse,
-            final String adUnitId,
-            final NativeAdInterface nativeAd,
-            final MoPubNativeEventListener moPubNativeEventListener) {
+    public NativeResponse(@NonNull final Context context,
+            @NonNull final String impressionUrl,
+            @NonNull final String clickUrl,
+            @NonNull final String adUnitId,
+            @NonNull final NativeAdInterface nativeAd,
+            @NonNull final MoPubNativeEventListener moPubNativeEventListener) {
         mContext = context.getApplicationContext();
         mAdUnitId = adUnitId;
         mMoPubNativeEventListener = moPubNativeEventListener;
@@ -118,8 +119,9 @@ public void onAdClicked() {
         });
 
         mMoPubImpressionTrackers = new HashSet<String>();
-        mMoPubImpressionTrackers.add(downloadResponse.getFirstHeader(ResponseHeader.IMPRESSION_URL));
-        mMoPubClickTracker = downloadResponse.getFirstHeader(ResponseHeader.CLICKTHROUGH_URL);
+        mMoPubImpressionTrackers.add(impressionUrl);
+        mMoPubClickTracker = clickUrl;
+        mImageLoader = Networking.getImageLoader(context);
     }
 
     @Override
@@ -141,36 +143,44 @@ public String toString() {
         return stringBuilder.toString();
     }
 
+   @NonNull
    public String getAdUnitId() {
        return mAdUnitId;
    }
 
     // Interface Methods
     // Getters
+    @Nullable
     public String getMainImageUrl() {
         return mNativeAd.getMainImageUrl();
     }
 
+    @Nullable
     public String getIconImageUrl() {
         return mNativeAd.getIconImageUrl();
     }
 
+    @Nullable
     public String getClickDestinationUrl() {
         return mNativeAd.getClickDestinationUrl();
     }
 
+    @Nullable
     public String getCallToAction() {
         return mNativeAd.getCallToAction();
     }
 
+    @Nullable
     public String getTitle() {
         return mNativeAd.getTitle();
     }
 
+    @Nullable
     public String getText() {
         return mNativeAd.getText();
     }
 
+    @NonNull
     public List<String> getImpressionTrackers() {
         final Set<String> allImpressionTrackers = new HashSet<String>();
         allImpressionTrackers.addAll(mMoPubImpressionTrackers);
@@ -178,10 +188,12 @@ public String getText() {
         return new ArrayList<String>(allImpressionTrackers);
     }
 
+    @NonNull
     public String getClickTracker() {
         return mMoPubClickTracker;
     }
 
+    @Nullable
     public Double getStarRating() {
         return mNativeAd.getStarRating();
     }
@@ -195,10 +207,12 @@ public int getImpressionMinPercentageViewed() {
     }
 
     // Extras Getters
+    @Nullable
     public Object getExtra(final String key) {
         return mNativeAd.getExtra(key);
     }
 
+    @NonNull
     public Map<String, Object> getExtras() {
         return mNativeAd.getExtras();
     }
@@ -212,7 +226,7 @@ public boolean isOverridingClickTracker() {
     }
 
     // Event Handlers
-    public void prepare(final View view) {
+    public void prepare(@NonNull final View view) {
         if (isDestroyed()) {
             return;
         }
@@ -224,13 +238,14 @@ public void prepare(final View view) {
         mNativeAd.prepare(view);
     }
 
-    public void recordImpression(final View view) {
+    public void recordImpression(@Nullable final View view) {
         if (getRecordedImpression() || isDestroyed()) {
             return;
         }
 
         for (final String impressionTracker : getImpressionTrackers()) {
-            HttpClient.makeTrackingHttpRequest(impressionTracker, mContext);
+            TrackingRequest.makeTrackingHttpRequest(
+                    impressionTracker, mContext, BaseEvent.Name.IMPRESSION_REQUEST);
         }
 
         mNativeAd.recordImpression();
@@ -239,13 +254,14 @@ public void recordImpression(final View view) {
         mMoPubNativeEventListener.onNativeImpression(view);
     }
 
-    public void handleClick(final View view) {
+    public void handleClick(@Nullable final View view) {
         if (isDestroyed()) {
             return;
         }
 
         if (!isClicked()) {
-            HttpClient.makeTrackingHttpRequest(mMoPubClickTracker, mContext);
+            TrackingRequest.makeTrackingHttpRequest(
+                    mMoPubClickTracker, mContext, BaseEvent.Name.CLICK_REQUEST);
         }
 
         openClickDestinationUrl(view);
@@ -255,7 +271,7 @@ public void handleClick(final View view) {
         mMoPubNativeEventListener.onNativeClick(view);
     }
 
-    public void clear(final View view) {
+    public void clear(@NonNull final View view) {
         setOnClickListener(view, null);
 
         mNativeAd.clear(view);
@@ -273,11 +289,11 @@ public void destroy() {
     }
 
     // Non Interface Public Methods
-    public void loadMainImage(final ImageView imageView) {
+    public void loadMainImage(@Nullable final ImageView imageView) {
         loadImageView(getMainImageUrl(), imageView);
     }
 
-    public void loadIconImage(final ImageView imageView) {
+    public void loadIconImage(@Nullable final ImageView imageView) {
         loadImageView(getIconImageUrl(), imageView);
     }
 
@@ -301,11 +317,34 @@ public boolean isDestroyed() {
     }
 
     // Helpers
-    private void loadImageView(final String url, final ImageView imageView) {
-        ImageViewService.loadImageView(url, imageView);
+    private void loadImageView(@Nullable final String url, @Nullable final ImageView imageView) {
+        if (imageView == null) {
+            return;
+        }
+
+        if (url == null) {
+            imageView.setImageDrawable(null);
+        } else {
+            mImageLoader.get(url, new ImageLoader.ImageListener() {
+                @Override
+                public void onResponse(final ImageLoader.ImageContainer imageContainer,
+                        final boolean isImmediate) {
+                    if (!isImmediate) {
+                        MoPubLog.d("Image was not loaded immediately into your ad view. You should call preCacheImages as part of your custom event loading process.");
+                    }
+                    imageView.setImageBitmap(imageContainer.getBitmap());
+                }
+
+                @Override
+                public void onErrorResponse(final VolleyError volleyError) {
+                    MoPubLog.d("Failed to load image.", volleyError);
+                    imageView.setImageDrawable(null);
+                }
+            });
+        }
     }
 
-    private void openClickDestinationUrl(final View view) {
+    private void openClickDestinationUrl(@Nullable final View view) {
         if (getClickDestinationUrl() == null) {
             return;
         }
@@ -317,16 +356,13 @@ private void openClickDestinationUrl(final View view) {
         }
 
         final Iterator<String> urlIterator = Arrays.asList(getClickDestinationUrl()).iterator();
-        final ClickDestinationUrlResolutionListener urlResolutionListener = new ClickDestinationUrlResolutionListener(
-                mContext,
-                urlIterator,
-                spinningProgressView
-        );
-
-        getResolvedUrl(urlIterator.next(), urlResolutionListener);
+        final ClickDestinationResolutionListener urlResolutionListener =
+                new ClickDestinationResolutionListener(mContext, urlIterator, spinningProgressView);
+        UrlResolutionTask.getResolvedUrl(urlIterator.next(), urlResolutionListener);
     }
 
-    private void setOnClickListener(final View view, final OnClickListener onClickListener) {
+    private void setOnClickListener(@NonNull final View view,
+            @Nullable final OnClickListener onClickListener) {
         view.setOnClickListener(onClickListener);
         if ((view instanceof ViewGroup)) {
             ViewGroup viewGroup = (ViewGroup)view;
@@ -335,68 +371,21 @@ private void setOnClickListener(final View view, final OnClickListener onClickLi
         }
     }
 
-    private static class ClickDestinationUrlResolutionListener implements UrlResolutionListener {
-        private final Context mContext;
-        private final Iterator<String> mUrlIterator;
-        private final SoftReference<SpinningProgressView> mSpinningProgressView;
-
-        public ClickDestinationUrlResolutionListener(final Context context,
-                final Iterator<String> urlIterator,
-                final SpinningProgressView spinningProgressView) {
-            mContext = context.getApplicationContext();
-            mUrlIterator = urlIterator;
-            mSpinningProgressView = new SoftReference<SpinningProgressView>(spinningProgressView);
-        }
-
-        @Override
-        public void onSuccess(final String resolvedUrl) {
-            final Intent intent = new Intent(Intent.ACTION_VIEW);
-            intent.setData(Uri.parse(resolvedUrl));
-            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-
-            if (IntentUtils.isDeepLink(resolvedUrl) && IntentUtils.deviceCanHandleIntent(mContext, intent)) {
-                // Open another Android app from deep link
-                mContext.startActivity(intent);
-            } else if (mUrlIterator.hasNext()) {
-                // If we can't handle a deep link then try the fallback url
-                getResolvedUrl(mUrlIterator.next(), this);
-                return;
-            } else {
-                // If we can't open the deep link and there are no backup links
-                // Or the link is a browser link then handle it here
-                MoPubBrowser.open(mContext, resolvedUrl);
-            }
-
-            removeSpinningProgressView();
-        }
-
-        @Override
-        public void onFailure() {
-            MoPubLog.d("Failed to resolve URL for click.");
-            removeSpinningProgressView();
-        }
-
-        private void removeSpinningProgressView() {
-            final SpinningProgressView spinningProgressView = mSpinningProgressView.get();
-            if (spinningProgressView != null) {
-                spinningProgressView.removeFromRoot();
-            }
-        }
-    }
-
     @VisibleForTesting
     class NativeViewClickListener implements OnClickListener {
         @Override
-        public void onClick(final View view) {
+        public void onClick(@NonNull final View view) {
             handleClick(view);
         }
     }
 
+    @Nullable
     @Deprecated
     public String getSubtitle() {
         return mNativeAd.getText();
     }
 
+    @NonNull
     @VisibleForTesting
     @Deprecated
     MoPubNativeEventListener getMoPubNativeEventListener() {
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeUrlGenerator.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeUrlGenerator.java
index 3957024a..bb9e97b1 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeUrlGenerator.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeUrlGenerator.java
@@ -1,30 +1,31 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
-import android.location.Location;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.text.TextUtils;
+
 import com.mopub.common.AdUrlGenerator;
 import com.mopub.common.ClientMetadata;
-import com.mopub.common.LocationService;
-import com.mopub.common.MoPub;
-import com.mopub.common.util.DateAndTime;
-import com.mopub.common.util.Strings;
+import com.mopub.common.Constants;
 
 class NativeUrlGenerator extends AdUrlGenerator {
-    private String mDesiredAssets;
-    private String mSequenceNumber;
+    @Nullable private String mDesiredAssets;
+    @Nullable private String mSequenceNumber;
 
     NativeUrlGenerator(Context context) {
         super(context);
     }
 
+    @NonNull
     @Override
     public NativeUrlGenerator withAdUnitId(final String adUnitId) {
         mAdUnitId = adUnitId;
         return this;
     }
 
-    NativeUrlGenerator withRequest(final RequestParameters requestParameters) {
+    @NonNull
+    NativeUrlGenerator withRequest(@Nullable final RequestParameters requestParameters) {
         if (requestParameters != null) {
             mKeywords = requestParameters.getKeywords();
             mLocation = requestParameters.getLocation();
@@ -33,6 +34,7 @@ NativeUrlGenerator withRequest(final RequestParameters requestParameters) {
         return this;
     }
 
+    @NonNull
     NativeUrlGenerator withSequenceNumber(final int sequenceNumber) {
         mSequenceNumber = String.valueOf(sequenceNumber);
         return this;
@@ -40,49 +42,10 @@ NativeUrlGenerator withSequenceNumber(final int sequenceNumber) {
 
     @Override
     public String generateUrlString(final String serverHostname) {
-        initUrlString(serverHostname, Constants.NATIVE_HANDLER);
-
-        setAdUnitId(mAdUnitId);
-
-        setKeywords(mKeywords);
-
-        Location location = mLocation;
-        if (location == null) {
-            location = LocationService.getLastKnownLocation(mContext,
-                    MoPub.getLocationPrecision(),
-                    MoPub.getLocationAwareness());
-        }
-        setLocation(location);
+        initUrlString(serverHostname, Constants.AD_HANDLER);
 
         ClientMetadata clientMetadata = ClientMetadata.getInstance(mContext);
-        setSdkVersion(clientMetadata.getSdkVersion());
-
-        setDeviceInfo(clientMetadata.getDeviceManufacturer(),
-                clientMetadata.getDeviceModel(),
-                clientMetadata.getDeviceProduct());
-
-        setUdid(clientMetadata.getAdvertisingId());
-
-        setDoNotTrack(clientMetadata.isDoNotTrackSet());
-
-        setTimezone(DateAndTime.getTimeZoneOffsetString());
-
-        setOrientation(clientMetadata.getOrientationString());
-
-        setDensity(clientMetadata.getDensity());
-
-        String networkOperator = clientMetadata.getNetworkOperator();
-        setMccCode(networkOperator);
-        setMncCode(networkOperator);
-
-        setIsoCountryCode(clientMetadata.getIsoCountryCode());
-        setCarrierName(clientMetadata.getNetworkOperatorName());
-
-        setNetworkType(clientMetadata.getActiveNetworkType());
-
-        setAppVersion(clientMetadata.getAppVersion());
-
-        setTwitterAppInstalledFlag();
+        addBaseParams(clientMetadata);
 
         setDesiredAssets();
 
@@ -98,7 +61,7 @@ private void setSequenceNumber() {
     }
 
     private void setDesiredAssets() {
-        if (mDesiredAssets != null && !Strings.isEmpty(mDesiredAssets)) {
+        if (!TextUtils.isEmpty(mDesiredAssets)) {
             addParam("assets", mDesiredAssets);
         }
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeViewHolder.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeViewHolder.java
index 0ca2dc4a..a7b99ef0 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeViewHolder.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeViewHolder.java
@@ -1,22 +1,29 @@
 package com.mopub.nativeads;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 import android.widget.ImageView;
 import android.widget.TextView;
 
+import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
 
 class NativeViewHolder {
-    TextView titleView;
-    TextView textView;
-    TextView callToActionView;
-    ImageView mainImageView;
-    ImageView iconImageView;
+    @Nullable TextView titleView;
+    @Nullable TextView textView;
+    @Nullable TextView callToActionView;
+    @Nullable ImageView mainImageView;
+    @Nullable ImageView iconImageView;
+
+    @VisibleForTesting
+    static final NativeViewHolder EMPTY_VIEW_HOLDER = new NativeViewHolder();
 
     // Use fromViewBinder instead of a constructor
     private NativeViewHolder() {}
 
-    static NativeViewHolder fromViewBinder(final View view, final ViewBinder viewBinder) {
+    @NonNull
+    static NativeViewHolder fromViewBinder(@NonNull final View view, @NonNull final ViewBinder viewBinder) {
         final NativeViewHolder nativeViewHolder = new NativeViewHolder();
 
         try {
@@ -25,26 +32,24 @@ static NativeViewHolder fromViewBinder(final View view, final ViewBinder viewBin
             nativeViewHolder.callToActionView = (TextView) view.findViewById(viewBinder.callToActionId);
             nativeViewHolder.mainImageView = (ImageView) view.findViewById(viewBinder.mainImageId);
             nativeViewHolder.iconImageView = (ImageView) view.findViewById(viewBinder.iconImageId);
-        } catch (ClassCastException e) {
-            MoPubLog.d("Could not cast View from id in ViewBinder to expected View type", e);
-            return null;
+            return nativeViewHolder;
+        } catch (ClassCastException exception) {
+            MoPubLog.w("Could not cast from id in ViewBinder to expected View type", exception);
+            return EMPTY_VIEW_HOLDER;
         }
-
-        return nativeViewHolder;
     }
 
-    void update(final NativeResponse nativeResponse) {
+    void update(@NonNull final NativeResponse nativeResponse) {
         addTextView(titleView, nativeResponse.getTitle());
         addTextView(textView, nativeResponse.getText());
         addTextView(callToActionView, nativeResponse.getCallToAction());
-
         nativeResponse.loadMainImage(mainImageView);
         nativeResponse.loadIconImage(iconImageView);
     }
 
-    void updateExtras(final View outerView,
-                      final NativeResponse nativeResponse,
-                      final ViewBinder viewBinder) {
+    void updateExtras(@NonNull final View outerView,
+                      @NonNull final NativeResponse nativeResponse,
+                      @NonNull final ViewBinder viewBinder) {
         for (final String key : viewBinder.extras.keySet()) {
             final int resourceId = viewBinder.extras.get(key);
             final View view = outerView.findViewById(resourceId);
@@ -66,7 +71,7 @@ void updateExtras(final View outerView,
         }
     }
 
-    private void addTextView(final TextView textView, final String contents) {
+    private void addTextView(@Nullable final TextView textView, @Nullable final String contents) {
         if (textView == null) {
             MoPubLog.d("Attempted to add text (" + contents + ") to null TextView.");
             return;
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/PlacementData.java b/mopub-sdk/src/main/java/com/mopub/nativeads/PlacementData.java
index cb4e21df..bba220d6 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/PlacementData.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/PlacementData.java
@@ -1,5 +1,8 @@
 package com.mopub.nativeads;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
 
@@ -127,24 +130,25 @@
 
     // Initialize all of these to their max capacity. This prevents garbage collection when
     // reallocating the list, which causes noticeable stuttering when scrolling on some devices.
-    private final int[] mDesiredOriginalPositions = new int[MAX_ADS];
-    private final int[] mDesiredInsertionPositions = new int[MAX_ADS];
+    @NonNull private final int[] mDesiredOriginalPositions = new int[MAX_ADS];
+    @NonNull private final int[] mDesiredInsertionPositions = new int[MAX_ADS];
     private int mDesiredCount = 0;
-    private final int[] mOriginalAdPositions = new int[MAX_ADS];
-    private final int[] mAdjustedAdPositions = new int[MAX_ADS];
-    private final NativeAdData[] mAdDataObjects = new NativeAdData[MAX_ADS];
+    @NonNull private final int[] mOriginalAdPositions = new int[MAX_ADS];
+    @NonNull private final int[] mAdjustedAdPositions = new int[MAX_ADS];
+    @NonNull private final NativeAdData[] mAdDataObjects = new NativeAdData[MAX_ADS];
     private int mPlacedCount = 0;
 
     /**
      * @param desiredInsertionPositions Insertion positions, expressed as original positions
      */
-    private PlacementData(final int[] desiredInsertionPositions) {
+    private PlacementData(@NonNull final int[] desiredInsertionPositions) {
         mDesiredCount = Math.min(desiredInsertionPositions.length, MAX_ADS);
         System.arraycopy(desiredInsertionPositions, 0, mDesiredInsertionPositions, 0, mDesiredCount);
         System.arraycopy(desiredInsertionPositions, 0, mDesiredOriginalPositions, 0, mDesiredCount);
     }
 
-    static PlacementData fromAdPositioning(final MoPubClientPositioning adPositioning) {
+    @NonNull
+    static PlacementData fromAdPositioning(@NonNull final MoPubClientPositioning adPositioning) {
         final List<Integer> fixed = adPositioning.getFixedPositions();
         final int interval = adPositioning.getRepeatingInterval();
 
@@ -168,6 +172,7 @@ static PlacementData fromAdPositioning(final MoPubClientPositioning adPositionin
         return new PlacementData(desiredInsertionPositions);
     }
 
+    @NonNull
     static PlacementData empty() {
         return new PlacementData(new int[] {});
     }
@@ -265,6 +270,7 @@ boolean isPlacedAd(final int position) {
      * Returns the ad data associated with the given ad position, or {@code null} if there is
      * no ad at this position.
      */
+    @Nullable
     NativeAdData getPlacedAd(final int position) {
         final int index = binarySearch(mAdjustedAdPositions, 0, mPlacedCount, position);
         if (index < 0) {
@@ -277,6 +283,7 @@ NativeAdData getPlacedAd(final int position) {
      * Returns all placed ad positions. This method allocates new memory on every invocation. Do
      * not call it from performance critical code.
      */
+    @NonNull
     int[] getPlacedAdPositions() {
         int[] positions = new int[mPlacedCount];
         System.arraycopy(mAdjustedAdPositions, 0, positions, 0, mPlacedCount);
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/PositioningRequest.java b/mopub-sdk/src/main/java/com/mopub/nativeads/PositioningRequest.java
new file mode 100644
index 00000000..9446d7a5
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/PositioningRequest.java
@@ -0,0 +1,127 @@
+package com.mopub.nativeads;
+
+import android.support.annotation.NonNull;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.network.MoPubNetworkError;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.Response;
+import com.mopub.volley.VolleyError;
+import com.mopub.volley.toolbox.HttpHeaderParser;
+import com.mopub.volley.toolbox.JsonRequest;
+
+import org.apache.http.HttpStatus;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.UnsupportedEncodingException;
+
+import static com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
+
+public class PositioningRequest extends JsonRequest<MoPubClientPositioning> {
+    private static final String FIXED_KEY = "fixed";
+    private static final String SECTION_KEY = "section";
+    private static final String POSITION_KEY = "position";
+    private static final String REPEATING_KEY = "repeating";
+    private static final String INTERVAL_KEY = "interval";
+
+    // Max value to avoid bad integer math calculations. This is 2 ^ 16.
+    private static final int MAX_VALUE = 1 << 16;
+
+    public PositioningRequest(final String url,
+            final Response.Listener<MoPubClientPositioning> listener,
+            final Response.ErrorListener errorListener) {
+        super(Method.GET, url, null, listener, errorListener);
+    }
+
+    // This is done just for unit testing visibolity.
+    @Override
+    protected void deliverResponse(final MoPubClientPositioning response) {
+        super.deliverResponse(response);
+    }
+
+    @Override
+    protected Response<MoPubClientPositioning> parseNetworkResponse(final NetworkResponse response) {
+        if (response.statusCode != HttpStatus.SC_OK) {
+            return Response.error(new VolleyError(response));
+        }
+
+        if (response.data.length == 0) {
+            return Response.error(new VolleyError("Empty positioning response", new JSONException("Empty response")));
+        }
+
+        try {
+            String jsonString = new String(response.data,
+                    HttpHeaderParser.parseCharset(response.headers));
+
+            return Response.success(parseJson(jsonString), HttpHeaderParser.parseCacheHeaders(response));
+        } catch (UnsupportedEncodingException e) {
+            return Response.error(new VolleyError("Couldn't parse JSON from Charset", e));
+        } catch (JSONException e) {
+            return Response.error(new VolleyError("JSON Parsing Error", e));
+        } catch (MoPubNetworkError e) {
+            return Response.error(e);
+        }
+    }
+
+    @NonNull
+    @VisibleForTesting
+    MoPubClientPositioning parseJson(@NonNull String jsonString) throws  JSONException, MoPubNetworkError {
+        JSONObject jsonObject = new JSONObject(jsonString);
+
+        // If the server returns an error explicitly, throw an exception with the message.
+        String error = jsonObject.optString("error", null);
+        if (error != null) {
+            if (error.equalsIgnoreCase("WARMING_UP")) {
+                throw new MoPubNetworkError(MoPubNetworkError.Reason.WARMING_UP);
+            }
+            throw new JSONException(error);
+        }
+
+        // Parse fixed and repeating rules.
+        JSONArray fixed = jsonObject.optJSONArray(FIXED_KEY);
+        JSONObject repeating = jsonObject.optJSONObject(REPEATING_KEY);
+        if (fixed == null && repeating == null) {
+            throw new JSONException("Must contain fixed or repeating positions");
+        }
+
+        MoPubClientPositioning positioning = new MoPubClientPositioning();
+        if (fixed != null) {
+            parseFixedJson(fixed, positioning);
+        }
+        if (repeating != null) {
+            parseRepeatingJson(repeating, positioning);
+        }
+        return positioning;
+    }
+
+    private void parseFixedJson(@NonNull final JSONArray fixed,
+            @NonNull final MoPubClientPositioning positioning) throws JSONException {
+        for (int i = 0; i < fixed.length(); ++i) {
+            JSONObject positionObject = fixed.getJSONObject(i);
+            int section = positionObject.optInt(SECTION_KEY, 0);
+            if (section < 0) {
+                throw new JSONException("Invalid section " + section + " in JSON response");
+            }
+            if (section > 0) {
+                // Ignore sections > 0.
+                continue;
+            }
+            int position = positionObject.getInt(POSITION_KEY);
+            if (position < 0 || position > MAX_VALUE) {
+                throw new JSONException("Invalid position " + position + " in JSON response");
+            }
+            positioning.addFixedPosition(position);
+        }
+    }
+
+    private void parseRepeatingJson(@NonNull final JSONObject repeatingObject,
+            @NonNull final MoPubClientPositioning positioning) throws JSONException {
+        int interval = repeatingObject.getInt(INTERVAL_KEY);
+        if (interval < 2 || interval > MAX_VALUE) {
+            throw new JSONException("Invalid interval " + interval + " in JSON response");
+        }
+        positioning.enableRepeatingPositions(interval);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/PositioningSource.java b/mopub-sdk/src/main/java/com/mopub/nativeads/PositioningSource.java
index 354ea6df..c26b1e33 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/PositioningSource.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/PositioningSource.java
@@ -1,8 +1,7 @@
 package com.mopub.nativeads;
 
-import android.os.Handler;
+import android.support.annotation.NonNull;
 
-import com.mopub.common.VisibleForTesting;
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
 
 /**
@@ -11,11 +10,11 @@
 interface PositioningSource {
 
     interface PositioningListener {
-        void onLoad(MoPubClientPositioning positioning);
+        void onLoad(@NonNull MoPubClientPositioning positioning);
 
         void onFailed();
     }
 
-    void loadPositions(String adUnitId, PositioningListener listener);
+    void loadPositions(@NonNull String adUnitId, @NonNull PositioningListener listener);
 
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/PositioningUrlGenerator.java b/mopub-sdk/src/main/java/com/mopub/nativeads/PositioningUrlGenerator.java
index e1a1ad6e..f9b0fafb 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/PositioningUrlGenerator.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/PositioningUrlGenerator.java
@@ -1,27 +1,30 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 
 import com.mopub.common.BaseUrlGenerator;
 import com.mopub.common.ClientMetadata;
+import com.mopub.common.Constants;
 
 class PositioningUrlGenerator extends BaseUrlGenerator {
     private static final String POSITIONING_API_VERSION = "1";
 
-    private final Context mContext;
-    private String mAdUnitId;
+    @NonNull private final Context mContext;
+    @NonNull private String mAdUnitId;
 
-    public PositioningUrlGenerator(Context context) {
+    public PositioningUrlGenerator(@NonNull Context context) {
         mContext = context;
     }
 
-    public PositioningUrlGenerator withAdUnitId(final String adUnitId) {
+    @NonNull
+    public PositioningUrlGenerator withAdUnitId(@NonNull final String adUnitId) {
         mAdUnitId = adUnitId;
         return this;
     }
 
     @Override
-    public String generateUrlString(final String serverHostname) {
+    public String generateUrlString(@NonNull final String serverHostname) {
         initUrlString(serverHostname, Constants.POSITIONING_HANDLER);
 
         setAdUnitId(mAdUnitId);
@@ -36,18 +39,18 @@ public String generateUrlString(final String serverHostname) {
                 clientMetadata.getDeviceModel(),
                 clientMetadata.getDeviceProduct());
 
-        setUdid(clientMetadata.getAdvertisingId());
-
         setAppVersion(clientMetadata.getAppVersion());
 
+        appendAdvertisingInfoTemplates();
+
         return getFinalUrlString();
     }
 
-    private void setAdUnitId(String adUnitId) {
+    private void setAdUnitId(@NonNull String adUnitId) {
         addParam("id", adUnitId);
     }
 
-    private void setSdkVersion(String sdkVersion) {
+    private void setSdkVersion(@NonNull String sdkVersion) {
         addParam("nsv", sdkVersion);
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/RequestParameters.java b/mopub-sdk/src/main/java/com/mopub/nativeads/RequestParameters.java
index fea4fb4c..d6edb69c 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/RequestParameters.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/RequestParameters.java
@@ -1,11 +1,13 @@
 package com.mopub.nativeads;
 
 import android.location.Location;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.text.TextUtils;
 
 import java.util.EnumSet;
 
-public final class RequestParameters {
+public class RequestParameters {
 
     public enum NativeAdAsset {
         TITLE("title"),
@@ -17,56 +19,63 @@
 
         private final String mAssetName;
 
-        private NativeAdAsset(String assetName) {
+        private NativeAdAsset(@NonNull String assetName) {
             mAssetName = assetName;
         }
 
+        @NonNull
         @Override
         public String toString() {
             return mAssetName;
         }
     }
 
-    private final String mKeywords;
-    private final Location mLocation;
-    private final EnumSet<NativeAdAsset> mDesiredAssets;
+    @Nullable private final String mKeywords;
+    @Nullable private final Location mLocation;
+    @Nullable private final EnumSet<NativeAdAsset> mDesiredAssets;
 
     public final static class Builder {
         private String keywords;
         private Location location;
         private EnumSet<NativeAdAsset> desiredAssets;
 
+        @NonNull
         public final Builder keywords(String keywords) {
             this.keywords = keywords;
             return this;
         }
 
+        @NonNull
         public final Builder location(Location location) {
             this.location = location;
             return this;
         }
 
         // Specify set of assets used by this ad request. If not set, this defaults to all assets
+        @NonNull
         public final Builder desiredAssets(final EnumSet<NativeAdAsset> desiredAssets) {
             this.desiredAssets = EnumSet.copyOf(desiredAssets);
             return this;
         }
 
+        @NonNull
         public final RequestParameters build() {
             return new RequestParameters(this);
         }
     }
 
-    private RequestParameters(Builder builder) {
+    private RequestParameters(@NonNull Builder builder) {
         mKeywords = builder.keywords;
         mLocation = builder.location;
         mDesiredAssets = builder.desiredAssets;
     }
 
+    @Nullable
     public final String getKeywords() {
         return mKeywords;
     }
 
+    @Nullable
     public final Location getLocation() {
         return mLocation;
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ServerPositioningSource.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ServerPositioningSource.java
index 55049bd4..4d4658cb 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/ServerPositioningSource.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/ServerPositioningSource.java
@@ -2,23 +2,20 @@
 
 import android.content.Context;
 import android.os.Handler;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 
-import com.mopub.common.DownloadResponse;
-import com.mopub.common.DownloadTask;
-import com.mopub.common.DownloadTask.DownloadTaskListener;
-import com.mopub.common.HttpClient;
-import com.mopub.common.HttpResponses;
-import com.mopub.common.Preconditions;
+import com.mopub.common.Constants;
 import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.AsyncTasks;
+import com.mopub.common.util.DeviceUtils;
+import com.mopub.mobileads.MoPubErrorCode;
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
-
-import org.apache.http.HttpStatus;
-import org.apache.http.client.methods.HttpGet;
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
+import com.mopub.network.MoPubNetworkError;
+import com.mopub.network.Networking;
+import com.mopub.volley.RequestQueue;
+import com.mopub.volley.Response;
+import com.mopub.volley.VolleyError;
 
 /**
  * Requests positioning information from the MoPub ad server.
@@ -55,39 +52,22 @@
     @VisibleForTesting
     static int MAXIMUM_RETRY_TIME_MILLISECONDS = 5 * 60 * 1000; // 5 minutes.
 
-    private static final String FIXED_KEY = "fixed";
-    private static final String SECTION_KEY = "section";
-    private static final String POSITION_KEY = "position";
-    private static final String REPEATING_KEY = "repeating";
-    private static final String INTERVAL_KEY = "interval";
-
-    // Max value to avoid bad integer math calculations. This is 2 ^ 16.
-    private static final int MAX_VALUE = 1 << 16;
-
-    private final Context mContext;
-
-    private final DownloadTaskProvider mDownloadTaskProvider;
+    @NonNull private final Context mContext;
 
     // Handler and runnable for retrying after a failed response.
-    private final Handler mRetryHandler;
-    private final Runnable mRetryRunnable;
+    @NonNull private final Handler mRetryHandler;
+    @NonNull private final Runnable mRetryRunnable;
+    private final Response.Listener<MoPubClientPositioning> mPositioningListener;
+    private final Response.ErrorListener mErrorListener;
 
-    // Only exists while a request is in flight.
-    private DownloadTask mDownloadTask;
-
-    private PositioningListener mListener;
+    @Nullable private PositioningListener mListener;
     private int mRetryCount;
-    private String mRetryUrl;
-
-    ServerPositioningSource(final Context context) {
-        this(context, new DownloadTaskProvider());
-    }
+    @Nullable private String mRetryUrl;
+    @Nullable private PositioningRequest mRequest;
 
-    @VisibleForTesting
-    ServerPositioningSource(final Context context,
-            final DownloadTaskProvider downloadTaskProvider) {
+    ServerPositioningSource(@NonNull final Context context) {
         mContext = context.getApplicationContext();
-        mDownloadTaskProvider = downloadTaskProvider;
+
         mRetryHandler = new Handler();
         mRetryRunnable = new Runnable() {
             @Override
@@ -95,14 +75,37 @@ public void run() {
                 requestPositioningInternal();
             }
         };
+
+        mPositioningListener = new Response.Listener<MoPubClientPositioning>() {
+            @Override
+            public void onResponse(final MoPubClientPositioning clientPositioning) {
+                handleSuccess(clientPositioning);
+            }
+        };
+
+        mErrorListener = new Response.ErrorListener() {
+            @Override
+            public void onErrorResponse(final VolleyError error) {
+                // Don't log a stack trace when we're just warming up.
+                if (!(error instanceof MoPubNetworkError) ||
+                        ((MoPubNetworkError) error).getReason().equals(MoPubNetworkError.Reason.WARMING_UP)) {
+                    MoPubLog.e("Failed to load positioning data", error);
+                    if (error.networkResponse == null && !DeviceUtils.isNetworkAvailable(mContext)) {
+                        MoPubLog.c(String.valueOf(MoPubErrorCode.NO_CONNECTION.toString()));
+                    }
+                }
+
+                handleFailure();
+            }
+        };
     }
 
     @Override
-    public void loadPositions(String adUnitId, PositioningListener listener) {
+    public void loadPositions(@NonNull String adUnitId, @NonNull PositioningListener listener) {
         // If a request is in flight, remove it.
-        if (mDownloadTask != null) {
-            mDownloadTask.cancel(true);
-            mDownloadTask = null;
+        if (mRequest != null) {
+            mRequest.cancel();
+            mRequest = null;
         }
 
         // If a retry is pending remove it.
@@ -114,55 +117,22 @@ public void loadPositions(String adUnitId, PositioningListener listener) {
         mListener = listener;
         mRetryUrl = new PositioningUrlGenerator(mContext)
                 .withAdUnitId(adUnitId)
-                .generateUrlString(Constants.POSITIONING_HOST);
+                .generateUrlString(Constants.HOST);
         requestPositioningInternal();
     }
 
     private void requestPositioningInternal() {
         MoPubLog.d("Loading positioning from: " + mRetryUrl);
-        mDownloadTask = mDownloadTaskProvider.get(mTaskListener);
-        final HttpGet httpGet = HttpClient.initializeHttpGet(mRetryUrl, mContext);
-        AsyncTasks.safeExecuteOnExecutor(mDownloadTask, httpGet);
-    }
 
-    private DownloadTaskListener mTaskListener = new DownloadTask.DownloadTaskListener() {
-        @Override
-        public void onComplete(final String url, final DownloadResponse downloadResponse) {
-            // Will be null only if cancelled.
-            if (downloadResponse == null) {
-                return;
-            }
-
-            mDownloadTask = null;
-            if (downloadResponse.getStatusCode() != HttpStatus.SC_OK) {
-                MoPubLog.e("Invalid positioning download response ");
-                handleFailure();
-                return;
-            }
-
-            String responseText = HttpResponses.asResponseString(downloadResponse);
-            MoPubClientPositioning positioning;
-            try {
-                positioning = parseJsonResponse(responseText);
-            } catch (JSONException exception) {
-                MoPubLog.e("Error parsing JSON: ", exception);
-                handleFailure();
-                return;
-            }
-
-            handleSuccess(positioning);
-        }
-    };
-
-    @VisibleForTesting
-    static class DownloadTaskProvider {
-        DownloadTask get(DownloadTaskListener listener) {
-            return new DownloadTask(listener);
-        }
+        mRequest = new PositioningRequest(mRetryUrl, mPositioningListener, mErrorListener);
+        final RequestQueue requestQueue = Networking.getRequestQueue(mContext);
+        requestQueue.add(mRequest);
     }
 
-    private void handleSuccess(MoPubClientPositioning positioning) {
-        mListener.onLoad(positioning);
+    private void handleSuccess(@NonNull MoPubClientPositioning positioning) {
+        if (mListener != null) {
+            mListener.onLoad(positioning);
+        }
         mListener = null;
         mRetryCount = 0;
     }
@@ -172,7 +142,9 @@ private void handleFailure() {
         int delay = (int) (DEFAULT_RETRY_TIME_MILLISECONDS * multiplier);
         if (delay >= MAXIMUM_RETRY_TIME_MILLISECONDS) {
             MoPubLog.d("Error downloading positioning information");
-            mListener.onFailed();
+            if (mListener != null) {
+                mListener.onFailed();
+            }
             mListener = null;
             return;
         }
@@ -180,62 +152,4 @@ private void handleFailure() {
         mRetryCount++;
         mRetryHandler.postDelayed(mRetryRunnable, delay);
     }
-
-    @VisibleForTesting
-    MoPubClientPositioning parseJsonResponse(String json) throws JSONException {
-        if (json == null || json.equals("")) {
-            throw new JSONException("Empty response");
-        }
-
-        // If the server returns an error explicitly, throw an error with the message.
-        JSONObject jsonObject = new JSONObject(json);
-        String error = jsonObject.optString("error", null);
-        if (error != null) {
-            throw new JSONException(error);
-        }
-
-        // Parse fixed and repeating rules.
-        JSONArray fixed = jsonObject.optJSONArray(FIXED_KEY);
-        JSONObject repeating = jsonObject.optJSONObject(REPEATING_KEY);
-        MoPubClientPositioning positioning = new MoPubClientPositioning();
-        if (fixed == null && repeating == null) {
-            throw new JSONException("Must contain fixed or repeating positions");
-        }
-        if (fixed != null) {
-            parseFixedJson(fixed, positioning);
-        }
-        if (repeating != null) {
-            parseRepeatingJson(repeating, positioning);
-        }
-        return positioning;
-    }
-
-    private void parseFixedJson(final JSONArray fixed,
-            final MoPubClientPositioning positioning) throws JSONException {
-        for (int i = 0; i < fixed.length(); ++i) {
-            JSONObject positionObject = fixed.getJSONObject(i);
-            int section = positionObject.optInt(SECTION_KEY, 0);
-            if (section < 0) {
-                throw new JSONException("Invalid section " + section + " in JSON response");
-            }
-            if (section > 0) {
-                // Ignore sections > 0.
-                continue;
-            }
-            int position = positionObject.getInt(POSITION_KEY);
-            if (position < 0 || position > MAX_VALUE) {
-                throw new JSONException("Invalid position " + position + " in JSON response");
-            }
-            positioning.addFixedPosition(position);
-        }
-    }
-
-    private void parseRepeatingJson(final JSONObject repeatingObject,
-            final MoPubClientPositioning positioning) throws JSONException {
-        int interval = repeatingObject.getInt(INTERVAL_KEY);
-        if (interval < 2 || interval > MAX_VALUE) {
-            throw new JSONException("Invalid interval " + interval + " in JSON response");
-        }
-        positioning.enableRepeatingPositions(interval);
-    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/SpinningProgressView.java b/mopub-sdk/src/main/java/com/mopub/nativeads/SpinningProgressView.java
index 2b442392..9fa5d9ff 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/SpinningProgressView.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/SpinningProgressView.java
@@ -2,22 +2,25 @@
 
 import android.content.Context;
 import android.graphics.Color;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.Gravity;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.LinearLayout;
 import android.widget.ProgressBar;
 
+import com.mopub.common.Preconditions;
 import com.mopub.common.util.Dips;
 import com.mopub.common.util.Views;
 
 import static android.widget.RelativeLayout.LayoutParams.MATCH_PARENT;
 
 class SpinningProgressView extends ViewGroup {
-    private final ProgressBar mProgressBar;
+    @NonNull private final ProgressBar mProgressBar;
     private int mProgressIndicatorRadius;
 
-    SpinningProgressView(final Context context) {
+    SpinningProgressView(@NonNull final Context context) {
         super(context);
 
         final LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(MATCH_PARENT, MATCH_PARENT);
@@ -49,10 +52,8 @@ protected void onLayout(boolean changed, int left, int top, int right, int botto
 
     }
 
-    boolean addToRoot(final View view) {
-        if (view == null) {
-            return false;
-        }
+    boolean addToRoot(@NonNull final View view) {
+        Preconditions.checkNotNull(view);
 
         final View rootView = view.getRootView();
 
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/TaskManager.java b/mopub-sdk/src/main/java/com/mopub/nativeads/TaskManager.java
index 443a9875..a13163c7 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/TaskManager.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/TaskManager.java
@@ -1,5 +1,11 @@
 package com.mopub.nativeads;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.Preconditions.NoThrow;
+
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
@@ -8,27 +14,24 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 abstract class TaskManager<T> {
-    protected final TaskManagerListener<T> mImageTaskManagerListener;
+    @NonNull protected final TaskManagerListener<T> mImageTaskManagerListener;
     protected final int mSize;
-    protected final Map<String, T> mResults;
+    @NonNull protected final Map<String, T> mResults;
 
-    protected final AtomicInteger mCompletedCount;
-    protected final AtomicBoolean mFailed;
+    @NonNull protected final AtomicInteger mCompletedCount;
+    @NonNull protected final AtomicBoolean mFailed;
 
     interface TaskManagerListener<T> {
-        void onSuccess(final Map<String, T> images);
+        void onSuccess(@NonNull final Map<String, T> images);
         void onFail();
     }
 
-    TaskManager(final List<String> urls, final TaskManagerListener<T> imageTaskManagerListener)
+    TaskManager(@NonNull final List<String> urls,
+            @NonNull final TaskManagerListener<T> imageTaskManagerListener)
             throws IllegalArgumentException {
-        if (urls == null) {
-            throw new IllegalArgumentException("Urls list cannot be null");
-        } else if (urls.contains(null)) {
-            throw new IllegalArgumentException("Urls list cannot contain null");
-        } else if (imageTaskManagerListener == null) {
-            throw new IllegalArgumentException("ImageTaskManagerListener cannot be null");
-        }
+        Preconditions.checkNotNull(urls, "Urls list cannot be null");
+        Preconditions.checkNotNull(imageTaskManagerListener, "ImageTaskManagerListener cannot be null");
+        Preconditions.checkState(!urls.contains(null), "Urls list cannot contain null");
 
         mSize = urls.size();
 
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/TimestampWrapper.java b/mopub-sdk/src/main/java/com/mopub/nativeads/TimestampWrapper.java
index 3bed271a..9d4d588b 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/TimestampWrapper.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/TimestampWrapper.java
@@ -1,12 +1,13 @@
 package com.mopub.nativeads;
 
 import android.os.SystemClock;
+import android.support.annotation.NonNull;
 
 class TimestampWrapper<T> {
-    final T mInstance;
+    @NonNull final T mInstance;
     long mCreatedTimestamp;
 
-    TimestampWrapper(final T instance) {
+    TimestampWrapper(@NonNull final T instance) {
         mInstance = instance;
         mCreatedTimestamp = SystemClock.uptimeMillis();
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/UrlResolutionTask.java b/mopub-sdk/src/main/java/com/mopub/nativeads/UrlResolutionTask.java
index 119b4ed8..9c690202 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/UrlResolutionTask.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/UrlResolutionTask.java
@@ -1,10 +1,12 @@
 package com.mopub.nativeads;
 
 import android.os.AsyncTask;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 
-import com.mopub.common.util.AsyncTasks;
-import com.mopub.common.util.IntentUtils;
 import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.AsyncTasks;
+import com.mopub.common.util.Intents;
 
 import java.io.IOException;
 import java.net.HttpURLConnection;
@@ -14,13 +16,14 @@
     private static final int REDIRECT_LIMIT = 10;
 
     interface UrlResolutionListener {
-        void onSuccess(String resolvedUrl);
+        void onSuccess(@NonNull String resolvedUrl);
         void onFailure();
     }
 
-    private final UrlResolutionListener mListener;
+    @NonNull private final UrlResolutionListener mListener;
 
-    public static void getResolvedUrl(final String urlString, final UrlResolutionListener listener) {
+    public static void getResolvedUrl(@NonNull final String urlString,
+            @NonNull final UrlResolutionListener listener) {
         final UrlResolutionTask urlResolutionTask = new UrlResolutionTask(listener);
 
         try {
@@ -32,12 +35,13 @@ public static void getResolvedUrl(final String urlString, final UrlResolutionLis
         }
     }
 
-    UrlResolutionTask(UrlResolutionListener listener) {
+    UrlResolutionTask(@NonNull UrlResolutionListener listener) {
         mListener = listener;
     }
 
+    @Nullable
     @Override
-    protected String doInBackground(String... urls) {
+    protected String doInBackground(@Nullable String... urls) {
         if (urls == null || urls.length == 0) {
             return null;
         }
@@ -50,7 +54,7 @@ protected String doInBackground(String... urls) {
             while (locationUrl != null && redirectCount < REDIRECT_LIMIT) {
                 // if location url is not http(s), assume it's an Android deep link
                 // this scheme will fail URL validation so we have to check early
-                if (!IntentUtils.isHttpUrl(locationUrl)) {
+                if (!Intents.isHttpUrl(locationUrl)) {
                     return locationUrl;
                 }
 
@@ -66,7 +70,8 @@ protected String doInBackground(String... urls) {
         return previousUrl;
     }
 
-    private String getRedirectLocation(final String urlString) throws IOException {
+    @Nullable
+    private String getRedirectLocation(@NonNull final String urlString) throws IOException {
         final URL url = new URL(urlString);
 
         HttpURLConnection httpUrlConnection = null;
@@ -89,7 +94,7 @@ private String getRedirectLocation(final String urlString) throws IOException {
     }
 
     @Override
-    protected void onPostExecute(final String resolvedUrl) {
+    protected void onPostExecute(@Nullable final String resolvedUrl) {
         super.onPostExecute(resolvedUrl);
 
         if (isCancelled() || resolvedUrl == null) {
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ViewBinder.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ViewBinder.java
index e8309c70..0fe30f84 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/ViewBinder.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/ViewBinder.java
@@ -1,9 +1,12 @@
 package com.mopub.nativeads;
 
+import android.support.annotation.NonNull;
+
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
 
-public final class ViewBinder {
+public class ViewBinder {
     public final static class Builder {
         private final int layoutId;
         private int titleId;
@@ -11,48 +14,56 @@
         private int callToActionId;
         private int mainImageId;
         private int iconImageId;
-        private Map<String, Integer> extras;
+        @NonNull private Map<String, Integer> extras = Collections.emptyMap();
 
         public Builder(final int layoutId) {
             this.layoutId = layoutId;
             this.extras = new HashMap<String, Integer>();
         }
 
+        @NonNull
         public final Builder titleId(final int titleId) {
             this.titleId = titleId;
             return this;
         }
 
+        @NonNull
         public final Builder textId(final int textId) {
             this.textId = textId;
             return this;
         }
 
+        @NonNull
         public final Builder callToActionId(final int callToActionId) {
             this.callToActionId = callToActionId;
             return this;
         }
 
+        @NonNull
         public final Builder mainImageId(final int mainImageId) {
             this.mainImageId = mainImageId;
             return this;
         }
 
+        @NonNull
         public final Builder iconImageId(final int iconImageId) {
             this.iconImageId = iconImageId;
             return this;
         }
 
+        @NonNull
         public final Builder addExtras(final Map<String, Integer> resourceIds) {
             this.extras = new HashMap<String, Integer>(resourceIds);
             return this;
         }
 
+        @NonNull
         public final Builder addExtra(final String key, final int resourceId) {
             this.extras.put(key, resourceId);
             return this;
         }
 
+        @NonNull
         public final ViewBinder build() {
             return new ViewBinder(this);
         }
@@ -64,9 +75,9 @@ public final ViewBinder build() {
     final int callToActionId;
     final int mainImageId;
     final int iconImageId;
-    final Map<String, Integer> extras;
+    @NonNull final Map<String, Integer> extras;
 
-    private ViewBinder(final Builder builder) {
+    private ViewBinder(@NonNull final Builder builder) {
         this.layoutId = builder.layoutId;
         this.titleId = builder.titleId;
         this.textId = builder.textId;
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/VisibilityTracker.java b/mopub-sdk/src/main/java/com/mopub/nativeads/VisibilityTracker.java
index 7ff0842a..b98a4481 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/VisibilityTracker.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/VisibilityTracker.java
@@ -5,6 +5,8 @@
 import android.graphics.Rect;
 import android.os.Handler;
 import android.os.SystemClock;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.View;
 import android.view.ViewTreeObserver;
 
@@ -33,7 +35,7 @@
     @VisibleForTesting static final int NUM_ACCESSES_BEFORE_TRIMMING = 50;
 
     // Temporary array of trimmed views so that we don't allocate this on every trim.
-    private final ArrayList<View> mTrimmedViews;
+    @NonNull private final ArrayList<View> mTrimmedViews;
 
     // Incrementing access counter. Use a long to support very long-lived apps.
     private long mAccessCounter = 0;
@@ -43,8 +45,8 @@
         void onVisibilityChanged(List<View> visibleViews, List<View> invisibleViews);
     }
 
-    @VisibleForTesting OnPreDrawListener mOnPreDrawListener;
-    @VisibleForTesting final WeakReference<View> mRootView;
+    @Nullable @VisibleForTesting OnPreDrawListener mOnPreDrawListener;
+    @NonNull @VisibleForTesting final WeakReference<View> mRootView;
 
     static class TrackingInfo {
         int mMinViewablePercent;
@@ -52,24 +54,24 @@
     }
 
     // Views that are being tracked, mapped to the min viewable percentage
-    private final Map<View, TrackingInfo> mTrackedViews;
+    @NonNull private final Map<View, TrackingInfo> mTrackedViews;
 
     // Object to check actual visibility
-    private final VisibilityChecker mVisibilityChecker;
+    @NonNull private final VisibilityChecker mVisibilityChecker;
 
     // Callback listener
-    private VisibilityTrackerListener mVisibilityTrackerListener;
+    @Nullable private VisibilityTrackerListener mVisibilityTrackerListener;
 
     // Runnable to run on each visibility loop
-    private final VisibilityRunnable mVisibilityRunnable;
+    @NonNull private final VisibilityRunnable mVisibilityRunnable;
 
     // Handler for visibility
-    private final Handler mVisibilityHandler;
+    @NonNull private final Handler mVisibilityHandler;
 
     // Whether the visibility runnable is scheduled
     private boolean mIsVisibilityScheduled;
 
-    public VisibilityTracker(final Context context) {
+    public VisibilityTracker(@NonNull final Context context) {
         this(context,
                 new WeakHashMap<View, TrackingInfo>(10),
                 new VisibilityChecker(),
@@ -77,10 +79,10 @@ public VisibilityTracker(final Context context) {
     }
 
     @VisibleForTesting
-    VisibilityTracker(final Context context,
-            final Map<View, TrackingInfo> trackedViews,
-            final VisibilityChecker visibilityChecker,
-            final Handler visibilityHandler) {
+    VisibilityTracker(@NonNull final Context context,
+            @NonNull final Map<View, TrackingInfo> trackedViews,
+            @NonNull final VisibilityChecker visibilityChecker,
+            @NonNull final Handler visibilityHandler) {
         mTrackedViews = trackedViews;
         mVisibilityChecker = visibilityChecker;
         mVisibilityHandler = visibilityHandler;
@@ -105,14 +107,15 @@ public boolean onPreDraw() {
         }
     }
 
-    void setVisibilityTrackerListener(final VisibilityTrackerListener visibilityTrackerListener) {
+    void setVisibilityTrackerListener(
+            @Nullable final VisibilityTrackerListener visibilityTrackerListener) {
         mVisibilityTrackerListener = visibilityTrackerListener;
     }
 
     /**
      * Tracks the given view for visibility.
      */
-    void addView(final View view, final int minPercentageViewed) {
+    void addView(@NonNull final View view, final int minPercentageViewed) {
         // Find the view if already tracked
         TrackingInfo trackingInfo = mTrackedViews.get(view);
         if (trackingInfo == null) {
@@ -147,7 +150,7 @@ private void trimTrackedViews(long minAccessOrder) {
     /**
      * Stops tracking a view, cleaning any pending tracking
      */
-    void removeView(final View view) {
+    void removeView(@NonNull final View view) {
         mTrackedViews.remove(view);
     }
 
@@ -190,8 +193,8 @@ void scheduleVisibilityCheck() {
     class VisibilityRunnable implements Runnable {
         // Set of views that are visible or invisible. We create these once to avoid excessive
         // garbage collection observed when calculating these on each pass.
-        private final ArrayList<View> mVisibleViews;
-        private final ArrayList<View> mInvisibleViews;
+        @NonNull private final ArrayList<View> mVisibleViews;
+        @NonNull private final ArrayList<View> mInvisibleViews;
 
         VisibilityRunnable() {
             mInvisibleViews = new ArrayList<View>();
@@ -236,7 +239,7 @@ boolean hasRequiredTimeElapsed(final long startTimeMillis, final int minTimeView
         /**
          * Whether the view is at least certain % visible
          */
-        boolean isVisible(final View view, final int minPercentageViewed) {
+        boolean isVisible(@Nullable final View view, final int minPercentageViewed) {
             // ListView & GridView both call detachFromParent() for views that can be recycled for
             // new data. This is one of the rare instances where a view will have a null parent for
             // an extended period of time and will not be the main window.
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/factories/CustomEventNativeFactory.java b/mopub-sdk/src/main/java/com/mopub/nativeads/factories/CustomEventNativeFactory.java
index 019b5338..92fec2e1 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/factories/CustomEventNativeFactory.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/factories/CustomEventNativeFactory.java
@@ -1,5 +1,9 @@
 package com.mopub.nativeads.factories;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.Preconditions;
 import com.mopub.nativeads.CustomEventNative;
 import com.mopub.nativeads.MoPubCustomEventNative;
 
@@ -8,7 +12,7 @@
 public class CustomEventNativeFactory {
     protected static CustomEventNativeFactory instance = new CustomEventNativeFactory();
 
-    public static CustomEventNative create(final String className) throws Exception {
+    public static CustomEventNative create(@Nullable final String className) throws Exception {
         if (className != null) {
             final Class<? extends CustomEventNative> nativeClass = Class.forName(className)
                     .asSubclass(CustomEventNative.class);
@@ -19,11 +23,18 @@ public static CustomEventNative create(final String className) throws Exception
     }
 
     @Deprecated // for testing
-    public static void setInstance(final CustomEventNativeFactory customEventNativeFactory) {
+    public static void setInstance(
+            @NonNull final CustomEventNativeFactory customEventNativeFactory) {
+        Preconditions.checkNotNull(customEventNativeFactory);
+
         instance = customEventNativeFactory;
     }
 
-    protected CustomEventNative internalCreate(final Class<? extends CustomEventNative> nativeClass) throws Exception {
+    @NonNull
+    protected CustomEventNative internalCreate(
+            @NonNull final Class<? extends CustomEventNative> nativeClass) throws Exception {
+        Preconditions.checkNotNull(nativeClass);
+
         final Constructor<?> nativeConstructor = nativeClass.getDeclaredConstructor((Class[]) null);
         nativeConstructor.setAccessible(true);
         return (CustomEventNative) nativeConstructor.newInstance();
diff --git a/mopub-sdk/src/main/java/com/mopub/network/AdRequest.java b/mopub-sdk/src/main/java/com/mopub/network/AdRequest.java
new file mode 100644
index 00000000..53fdbc30
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/AdRequest.java
@@ -0,0 +1,296 @@
+package com.mopub.network;
+
+import android.content.Context;
+import android.location.Location;
+import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import com.mopub.common.AdFormat;
+import com.mopub.common.AdType;
+import com.mopub.common.DataKeys;
+import com.mopub.common.LocationService;
+import com.mopub.common.MoPub;
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.event.BaseEvent;
+import com.mopub.common.event.Event;
+import com.mopub.common.event.MoPubEvents;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Json;
+import com.mopub.common.util.ResponseHeader;
+import com.mopub.mobileads.AdTypeTranslator;
+import com.mopub.volley.DefaultRetryPolicy;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.Request;
+import com.mopub.volley.Response;
+import com.mopub.volley.toolbox.HttpHeaderParser;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.UnsupportedEncodingException;
+import java.util.Locale;
+import java.util.Map;
+import java.util.TreeMap;
+
+import static com.mopub.network.HeaderUtils.extractBooleanHeader;
+import static com.mopub.network.HeaderUtils.extractHeader;
+import static com.mopub.network.HeaderUtils.extractIntegerHeader;
+
+public class AdRequest extends Request<AdResponse> {
+
+    @NonNull private final AdRequest.Listener mListener;
+    @NonNull private final AdFormat mAdFormat;
+    @Nullable private final String mAdUnitId;
+    @NonNull private final Context mContext;
+
+    public interface Listener extends Response.ErrorListener {
+        public void onSuccess(AdResponse response);
+    }
+
+    public AdRequest(@NonNull final String url,
+            @NonNull final AdFormat adFormat,
+            @Nullable final String adUnitId,
+            @NonNull Context context,
+            @NonNull final Listener listener) {
+        super(Method.GET, url, listener);
+        Preconditions.checkNotNull(adFormat);
+        Preconditions.checkNotNull(listener);
+        mAdUnitId = adUnitId;
+        mListener = listener;
+        mAdFormat = adFormat;
+        mContext = context.getApplicationContext();
+        DefaultRetryPolicy retryPolicy = new DefaultRetryPolicy(
+                DefaultRetryPolicy.DEFAULT_TIMEOUT_MS,
+                DefaultRetryPolicy.DEFAULT_MAX_RETRIES,
+                DefaultRetryPolicy.DEFAULT_BACKOFF_MULT);
+        setRetryPolicy(retryPolicy);
+        setShouldCache(false);
+    }
+
+    @NonNull
+    public Listener getListener() {
+        return mListener;
+    }
+
+    @Override
+    public Map<String, String> getHeaders() {
+        TreeMap<String, String> headers = new TreeMap<String, String>();
+
+        // Use default locale first for language code
+        String languageCode = Locale.getDefault().getLanguage();
+
+        // If user's preferred locale is different from default locale, override language code
+        Locale userLocale = mContext.getResources().getConfiguration().locale;
+        if (userLocale != null) {
+            if (! userLocale.getLanguage().trim().isEmpty()) {
+                languageCode = userLocale.getLanguage().trim();
+            }
+        }
+
+        // Do not add header if language is empty
+        if (! languageCode.isEmpty()) {
+            headers.put(ResponseHeader.ACCEPT_LANGUAGE.getKey(), languageCode);
+        }
+
+        return headers;
+    }
+
+    @Override
+    protected Response<AdResponse> parseNetworkResponse(final NetworkResponse networkResponse) {
+        // NOTE: We never get status codes outside of {[200, 299], 304}. Those errors are sent to the
+        // error listener.
+
+        Map<String, String> headers = networkResponse.headers;
+        if (extractBooleanHeader(headers, ResponseHeader.WARMUP, false)) {
+            return Response.error(new MoPubNetworkError("Ad Unit is warming up.", MoPubNetworkError.Reason.WARMING_UP));
+        }
+
+
+        Location location = LocationService.getLastKnownLocation(mContext,
+                MoPub.getLocationPrecision(),
+                MoPub.getLocationAwareness());
+
+        AdResponse.Builder builder = new AdResponse.Builder();
+        builder.setAdUnitId(mAdUnitId);
+
+        String adTypeString = extractHeader(headers, ResponseHeader.AD_TYPE);
+        String fullAdTypeString = extractHeader(headers, ResponseHeader.FULL_AD_TYPE);
+        builder.setAdType(adTypeString);
+        builder.setFullAdType(fullAdTypeString);
+
+        // In the case of a CLEAR response, the REFRESH_TIME header must still be respected. Ensure
+        // that it is parsed and passed along to the MoPubNetworkError.
+        final Integer refreshTimeSeconds = extractIntegerHeader(headers, ResponseHeader.REFRESH_TIME);
+        final Integer refreshTimeMilliseconds = refreshTimeSeconds == null
+                ? null
+                : refreshTimeSeconds * 1000;
+        builder.setRefreshTimeMilliseconds(refreshTimeMilliseconds);
+
+        if (AdType.CLEAR.equals(adTypeString)) {
+            final AdResponse adResponse = builder.build();
+            logScribeEvent(adResponse, networkResponse, location);
+            return Response.error(
+                    new MoPubNetworkError(
+                            "No ads found for ad unit.",
+                            MoPubNetworkError.Reason.NO_FILL,
+                            refreshTimeMilliseconds
+                    )
+            );
+        }
+
+        builder.setNetworkType(extractHeader(headers, ResponseHeader.NETWORK_TYPE));
+
+        String redirectUrl = extractHeader(headers, ResponseHeader.REDIRECT_URL);
+        builder.setRedirectUrl(redirectUrl);
+
+        String clickTrackingUrl = extractHeader(headers, ResponseHeader.CLICK_TRACKING_URL);
+        builder.setClickTrackingUrl(clickTrackingUrl);
+
+        builder.setImpressionTrackingUrl(extractHeader(headers, ResponseHeader.IMPRESSION_URL));
+
+        String failUrl = extractHeader(headers, ResponseHeader.FAIL_URL);
+        builder.setFailoverUrl(failUrl);
+
+        String requestId = getRequestId(failUrl);
+        builder.setRequestId(requestId);
+
+        boolean isScrollable = extractBooleanHeader(headers, ResponseHeader.SCROLLABLE, false);
+        builder.setScrollable(isScrollable);
+
+        builder.setDimensions(extractIntegerHeader(headers, ResponseHeader.WIDTH),
+                extractIntegerHeader(headers, ResponseHeader.HEIGHT));
+
+        Integer adTimeoutDelaySeconds = extractIntegerHeader(headers, ResponseHeader.AD_TIMEOUT);
+        builder.setAdTimeoutDelayMilliseconds(
+                adTimeoutDelaySeconds == null
+                        ? null
+                        : adTimeoutDelaySeconds * 1000);
+
+        // Response Body encoding / decoding
+        String responseBody = parseStringBody(networkResponse);
+        builder.setResponseBody(responseBody);
+        if (AdType.NATIVE.equals(adTypeString)) {
+            try {
+                builder.setJsonBody(new JSONObject(responseBody));
+            } catch (JSONException e) {
+                return Response.error(
+                        new MoPubNetworkError("Failed to decode body JSON for native ad format",
+                                e, MoPubNetworkError.Reason.BAD_BODY));
+            }
+        }
+
+        // Derive custom event fields
+        String customEventClassName = AdTypeTranslator.getCustomEventName(mAdFormat, adTypeString,
+                fullAdTypeString, headers);
+        builder.setCustomEventClassName(customEventClassName);
+
+        // Process server extras if they are present:
+        String customEventData = extractHeader(headers, ResponseHeader.CUSTOM_EVENT_DATA);
+
+        // Some server-supported custom events (like Millennial banners) use a different header field
+        if (TextUtils.isEmpty(customEventData)) {
+            customEventData = extractHeader(headers, ResponseHeader.NATIVE_PARAMS);
+        }
+        try {
+            builder.setServerExtras(Json.jsonStringToMap(customEventData));
+        } catch (JSONException e) {
+            return Response.error(
+                    new MoPubNetworkError("Failed to decode server extras for custom event data.",
+                            e, MoPubNetworkError.Reason.BAD_HEADER_DATA));
+        }
+
+        // Some MoPub-specific custom events get their serverExtras from the response itself:
+        if (eventDataIsInResponseBody(adTypeString, fullAdTypeString)) {
+            Map<String, String> eventDataMap = new TreeMap<String, String>();
+            eventDataMap.put(DataKeys.HTML_RESPONSE_BODY_KEY, responseBody);
+            eventDataMap.put(DataKeys.SCROLLABLE_KEY, Boolean.toString(isScrollable));
+            eventDataMap.put(DataKeys.CREATIVE_ORIENTATION_KEY, extractHeader(headers, ResponseHeader.ORIENTATION));
+            if (redirectUrl != null) {
+                eventDataMap.put(DataKeys.REDIRECT_URL_KEY, redirectUrl);
+            }
+            if (clickTrackingUrl != null) {
+                eventDataMap.put(DataKeys.CLICKTHROUGH_URL_KEY, clickTrackingUrl);
+            }
+            builder.setServerExtras(eventDataMap);
+        }
+
+        AdResponse adResponse = builder.build();
+        logScribeEvent(adResponse, networkResponse, location);
+
+        return Response.success(builder.build(),  // Cast needed for Response generic.
+                HttpHeaderParser.parseCacheHeaders(networkResponse));
+    }
+
+    private boolean eventDataIsInResponseBody(@Nullable String adType,
+            @Nullable String fullAdType) {
+        return "mraid".equals(adType) || "html".equals(adType) ||
+                ("interstitial".equals(adType) && "vast".equals(fullAdType));
+    }
+
+    // Based on Volley's StringResponse class.
+    protected String parseStringBody(NetworkResponse response) {
+        String parsed;
+        try {
+            parsed = new String(response.data, HttpHeaderParser.parseCharset(response.headers));
+        } catch (UnsupportedEncodingException e) {
+            parsed = new String(response.data);
+        }
+        return parsed;
+    }
+
+    @Override
+    protected void deliverResponse(final AdResponse adResponse) {
+        mListener.onSuccess(adResponse);
+    }
+
+    @Nullable
+    @VisibleForTesting
+    String getRequestId(@Nullable String failUrl) {
+        if (failUrl == null) {
+            return null;
+        }
+
+        String requestId = null;
+        Uri uri = Uri.parse(failUrl);
+        try {
+            requestId = uri.getQueryParameter("request_id");
+        } catch (UnsupportedOperationException e) {
+            MoPubLog.d("Unable to obtain request id from fail url.");
+        }
+
+        return requestId;
+    }
+
+    @VisibleForTesting
+    void logScribeEvent(@NonNull AdResponse adResponse, @NonNull NetworkResponse networkResponse,
+            @Nullable Location location) {
+        Preconditions.checkNotNull(adResponse);
+        Preconditions.checkNotNull(networkResponse);
+
+        MoPubEvents.log(
+                new Event.Builder(BaseEvent.Name.AD_REQUEST, BaseEvent.Category.REQUESTS,
+                        BaseEvent.SamplingRate.AD_REQUEST.getSamplingRate())
+                        .withAdUnitId(mAdUnitId)
+                        .withAdCreativeId(adResponse.getDspCreativeId())
+                        .withAdType(adResponse.getAdType())
+                        .withAdNetworkType(adResponse.getNetworkType())
+                        .withAdWidthPx(adResponse.getWidth() != null
+                                ? adResponse.getWidth().doubleValue()
+                                : null)
+                        .withAdHeightPx(adResponse.getHeight() != null
+                                ? adResponse.getHeight().doubleValue()
+                                : null)
+                        .withGeoLat(location != null ? location.getLatitude() : null)
+                        .withGeoLon(location != null ? location.getLongitude() : null)
+                        .withGeoAccuracy(location != null ? (double) location.getAccuracy() : null)
+                        .withPerformanceDurationMs((double) networkResponse.networkTimeMs)
+                        .withRequestId(adResponse.getRequestId())
+                        .withRequestStatusCode(networkResponse.statusCode)
+                        .withRequestUri(getUrl())
+                        .build()
+        );
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/AdResponse.java b/mopub-sdk/src/main/java/com/mopub/network/AdResponse.java
new file mode 100644
index 00000000..8c7bc330
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/AdResponse.java
@@ -0,0 +1,336 @@
+package com.mopub.network;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.util.DateAndTime;
+
+import org.json.JSONObject;
+
+import java.io.Serializable;
+import java.util.Map;
+import java.util.TreeMap;
+
+public class AdResponse implements Serializable {
+    private static final long serialVersionUID = 1L;
+
+    @Nullable
+    private final String mAdType;
+
+    @Nullable
+    private final String mAdUnitId;
+
+    @Nullable
+    private final String mFullAdType;
+    @Nullable
+    private final String mNetworkType;
+
+    @Nullable
+    private final String mRedirectUrl;
+    @Nullable
+    private final String mClickTrackingUrl;
+    @Nullable
+    private final String mImpressionTrackingUrl;
+    @Nullable
+    private final String mFailoverUrl;
+    @Nullable
+    private final String mRequestId;
+
+    @Nullable
+    private final Integer mWidth;
+    @Nullable
+    private final Integer mHeight;
+    @Nullable
+    private final Integer mAdTimeoutDelayMillis;
+    @Nullable
+    private final Integer mRefreshTimeMillis;
+    @Nullable
+    private final String mDspCreativeId;
+
+    private final boolean mScrollable;
+
+    @Nullable
+    private final String mResponseBody;
+    @Nullable
+    private final JSONObject mJsonBody;
+
+    @Nullable
+    private final String mCustomEventClassName;
+    @NonNull
+    private final Map<String, String> mServerExtras;
+
+    private final long mTimestamp;
+
+    private AdResponse(@NonNull Builder builder) {
+
+        mAdType = builder.adType;
+        mAdUnitId = builder.adUnitId;
+        mFullAdType = builder.fullAdType;
+        mNetworkType = builder.networkType;
+        mRedirectUrl = builder.redirectUrl;
+        mClickTrackingUrl = builder.clickTrackingUrl;
+        mImpressionTrackingUrl = builder.impressionTrackingUrl;
+        mFailoverUrl = builder.failoverUrl;
+        mRequestId = builder.requestId;
+        mWidth = builder.width;
+        mHeight = builder.height;
+        mAdTimeoutDelayMillis = builder.adTimeoutDelayMillis;
+        mRefreshTimeMillis = builder.refreshTimeMillis;
+        mDspCreativeId = builder.dspCreativeId;
+        mScrollable = builder.scrollable;
+        mResponseBody = builder.responseBody;
+        mJsonBody = builder.jsonBody;
+        mCustomEventClassName = builder.customEventClassName;
+        mServerExtras = builder.serverExtras;
+        mTimestamp = DateAndTime.now().getTime();
+    }
+
+    public boolean hasJson() {
+        return mJsonBody != null;
+    }
+
+    @Nullable
+    public JSONObject getJsonBody() {
+        return mJsonBody;
+    }
+
+    @Nullable
+    public String getStringBody() {
+        return mResponseBody;
+    }
+
+    @Nullable
+    public String getAdType() {
+        return mAdType;
+    }
+
+    @Nullable
+    public String getFullAdType() {
+        return mFullAdType;
+    }
+
+    @Nullable
+    public String getAdUnitId() {
+        return mAdUnitId;
+    }
+
+    @Nullable
+    public String getNetworkType() {
+        return mNetworkType;
+    }
+
+    @Nullable
+    public String getRedirectUrl() {
+        return mRedirectUrl;
+    }
+
+    @Nullable
+    public String getClickTrackingUrl() {
+        return mClickTrackingUrl;
+    }
+
+    @Nullable
+    public String getImpressionTrackingUrl() {
+        return mImpressionTrackingUrl;
+    }
+
+    @Nullable
+    public String getFailoverUrl() {
+        return mFailoverUrl;
+    }
+
+    @Nullable
+    public String getRequestId() {
+        return mRequestId;
+    }
+
+    public boolean isScrollable() {
+        return mScrollable;
+    }
+
+    @Nullable
+    public Integer getWidth() {
+        return mWidth;
+    }
+
+    @Nullable
+    public Integer getHeight() {
+        return mHeight;
+    }
+
+    @Nullable
+    public Integer getAdTimeoutMillis() {
+        return mAdTimeoutDelayMillis;
+    }
+
+    @Nullable
+    public Integer getRefreshTimeMillis() {
+        return mRefreshTimeMillis;
+    }
+
+    @Nullable
+    public String getDspCreativeId() {
+        return mDspCreativeId;
+    }
+
+    @Nullable
+    public String getCustomEventClassName() {
+        return mCustomEventClassName;
+    }
+
+    @NonNull
+    public Map<String, String> getServerExtras() {
+        // Strings are immutable, so this works as a "deep" copy.
+        return new TreeMap<String, String>(mServerExtras);
+    }
+
+    public long getTimestamp() {
+        return mTimestamp;
+    }
+
+    public Builder toBuilder() {
+        return new Builder()
+                .setAdType(mAdType)
+                .setNetworkType(mNetworkType)
+                .setRedirectUrl(mRedirectUrl)
+                .setClickTrackingUrl(mClickTrackingUrl)
+                .setImpressionTrackingUrl(mImpressionTrackingUrl)
+                .setFailoverUrl(mFailoverUrl)
+                .setDimensions(mWidth, mHeight)
+                .setAdTimeoutDelayMilliseconds(mAdTimeoutDelayMillis)
+                .setRefreshTimeMilliseconds(mRefreshTimeMillis)
+                .setDspCreativeId(mDspCreativeId)
+                .setScrollable(mScrollable)
+                .setResponseBody(mResponseBody)
+                .setJsonBody(mJsonBody)
+                .setCustomEventClassName(mCustomEventClassName)
+                .setServerExtras(mServerExtras);
+    }
+
+    public static class Builder {
+        private String adType;
+        private String adUnitId;
+        private String fullAdType;
+        private String networkType;
+
+        private String redirectUrl;
+        private String clickTrackingUrl;
+        private String impressionTrackingUrl;
+        private String failoverUrl;
+        private String requestId;
+
+        private Integer width;
+        private Integer height;
+        private Integer adTimeoutDelayMillis;
+        private Integer refreshTimeMillis;
+        private String dspCreativeId;
+
+        private boolean scrollable = false;
+
+        private String responseBody;
+        private JSONObject jsonBody;
+
+        private String customEventClassName;
+        private Map<String, String> serverExtras = new TreeMap<String, String>();
+
+        public Builder setAdType(@Nullable final String adType) {
+            this.adType = adType;
+            return this;
+        }
+
+        public Builder setAdUnitId(@Nullable final String adUnitId) {
+            this.adUnitId = adUnitId;
+            return this;
+        }
+
+        public Builder setFullAdType(@Nullable final String fullAdType) {
+            this.fullAdType = fullAdType;
+            return this;
+        }
+
+        public Builder setNetworkType(@Nullable final String networkType) {
+            this.networkType = networkType;
+            return this;
+        }
+
+        public Builder setRedirectUrl(@Nullable final String redirectUrl) {
+            this.redirectUrl = redirectUrl;
+            return this;
+        }
+
+        public Builder setClickTrackingUrl(@Nullable final String clickTrackingUrl) {
+            this.clickTrackingUrl = clickTrackingUrl;
+            return this;
+        }
+
+        public Builder setImpressionTrackingUrl(@Nullable final String impressionTrackingUrl) {
+            this.impressionTrackingUrl = impressionTrackingUrl;
+            return this;
+        }
+
+        public Builder setFailoverUrl(@Nullable final String failoverUrl) {
+            this.failoverUrl = failoverUrl;
+            return this;
+        }
+
+        public Builder setRequestId(@Nullable final String requestId) {
+            this.requestId = requestId;
+            return this;
+        }
+
+        public Builder setDimensions(@Nullable final Integer width,
+                @Nullable final Integer height) {
+            this.width = width;
+            this.height = height;
+            return this;
+        }
+
+        public Builder setAdTimeoutDelayMilliseconds(@Nullable final Integer adTimeoutDelayMilliseconds) {
+            this.adTimeoutDelayMillis = adTimeoutDelayMilliseconds;
+            return this;
+        }
+
+        public Builder setRefreshTimeMilliseconds(@Nullable final Integer refreshTimeMilliseconds) {
+            this.refreshTimeMillis = refreshTimeMilliseconds;
+            return this;
+        }
+
+        public Builder setScrollable(@Nullable final Boolean scrollable) {
+            this.scrollable = scrollable == null ? this.scrollable : scrollable;
+            return this;
+        }
+
+        public Builder setDspCreativeId(@Nullable final String dspCreativeId) {
+            this.dspCreativeId = dspCreativeId;
+            return this;
+        }
+
+        public Builder setResponseBody(@Nullable final String responseBody) {
+            this.responseBody = responseBody;
+            return this;
+        }
+
+        public Builder setJsonBody(@Nullable final JSONObject jsonBody) {
+            this.jsonBody = jsonBody;
+            return this;
+        }
+
+        public Builder setCustomEventClassName(@Nullable final String customEventClassName) {
+            this.customEventClassName = customEventClassName;
+            return this;
+        }
+
+        public Builder setServerExtras(@Nullable final Map<String, String> serverExtras) {
+            if (serverExtras == null) {
+                this.serverExtras = new TreeMap<String, String>();
+            } else {
+                this.serverExtras = new TreeMap<String, String>(serverExtras);
+            }
+            return this;
+        }
+
+        public AdResponse build() {
+            return new AdResponse(this);
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/BackoffPolicy.java b/mopub-sdk/src/main/java/com/mopub/network/BackoffPolicy.java
new file mode 100644
index 00000000..fa17fee8
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/BackoffPolicy.java
@@ -0,0 +1,43 @@
+package com.mopub.network;
+
+import com.mopub.volley.VolleyError;
+
+/**
+ * The backoff policy for a request.
+ */
+public abstract class BackoffPolicy {
+    protected int mBackoffMs;
+    protected int mBackoffMultiplier;
+    protected int mDefaultBackoffTimeMs;
+    protected int mMaxBackoffTimeMs;
+    protected int mRetryCount;
+    protected int mMaxRetries;
+
+    /**
+     * Prepares for the next request attempt by updating the backoff time.
+     *
+     * @param volleyError The error code of the last request attempt.
+     */
+    public abstract void backoff(VolleyError volleyError) throws VolleyError;
+
+    /**
+     * Returns the current backoff time in ms.
+     */
+    public int getBackoffMs() {
+        return mBackoffMs;
+    }
+
+    /**
+     * Returns the current retry count.
+     */
+    public int getRetryCount() {
+        return mRetryCount;
+    }
+
+    /**
+     * Returns true if this policy has attempts remaining, false otherwise.
+     */
+    public boolean hasAttemptRemaining() {
+        return mRetryCount < mMaxRetries;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/CustomSSLSocketFactory.java b/mopub-sdk/src/main/java/com/mopub/network/CustomSSLSocketFactory.java
new file mode 100644
index 00000000..21c48ac1
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/CustomSSLSocketFactory.java
@@ -0,0 +1,95 @@
+package com.mopub.network;
+
+import android.net.SSLCertificateSocketFactory;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.Socket;
+import java.net.UnknownHostException;
+
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+
+/**
+ * An {@link javax.net.ssl.SSLSocketFactory} that supports TLS settings for the MoPub ad servers.
+ */
+public class CustomSSLSocketFactory extends SSLSocketFactory {
+
+    private SSLSocketFactory mCertificateSocketFactory;
+
+    private CustomSSLSocketFactory() {}
+
+    public static CustomSSLSocketFactory getDefault(final int handshakeTimeoutMillis) {
+        CustomSSLSocketFactory factory = new CustomSSLSocketFactory();
+        factory.mCertificateSocketFactory = SSLCertificateSocketFactory.getDefault(handshakeTimeoutMillis, null);
+
+        return factory;
+    }
+
+    // Forward all methods. Enable TLS 1.1 and 1.2 before returning.
+
+    // SocketFactory overrides
+    @Override
+    public Socket createSocket() throws IOException {
+        final Socket socket = mCertificateSocketFactory.createSocket();
+        enableTlsIfAvailable(socket);
+        return socket;
+    }
+
+    @Override
+    public Socket createSocket(final String host, final int i) throws IOException, UnknownHostException {
+        final Socket socket = mCertificateSocketFactory.createSocket(host, i);
+        enableTlsIfAvailable(socket);
+        return socket;
+    }
+
+    @Override
+    public Socket createSocket(final String host, final int port, final InetAddress localhost, final int localPort) throws IOException, UnknownHostException {
+        final Socket socket = mCertificateSocketFactory.createSocket(host, port, localhost, localPort);
+        enableTlsIfAvailable(socket);
+        return socket;
+    }
+
+    @Override
+    public Socket createSocket(final InetAddress address, final int port) throws IOException {
+        final Socket socket = mCertificateSocketFactory.createSocket(address, port);
+        enableTlsIfAvailable(socket);
+        return socket;
+    }
+
+    @Override
+    public Socket createSocket(final InetAddress address, final int port, final InetAddress localhost, final int localPort) throws IOException {
+        final Socket socket = mCertificateSocketFactory.createSocket(address, port, localhost, localPort);
+        enableTlsIfAvailable(socket);
+        return socket;
+    }
+
+    // SSLSocketFactory overrides
+
+    @Override
+    public String[] getDefaultCipherSuites() {
+        return mCertificateSocketFactory.getDefaultCipherSuites();
+    }
+
+    @Override
+    public String[] getSupportedCipherSuites() {
+        return mCertificateSocketFactory.getSupportedCipherSuites();
+    }
+
+    @Override
+    public Socket createSocket(final Socket socketParam, final String host, final int port, final boolean autoClose) throws IOException {
+        Socket socket = mCertificateSocketFactory.createSocket(socketParam, host, port, autoClose);
+        enableTlsIfAvailable(socket);
+        return socket;
+    }
+
+    private void enableTlsIfAvailable(Socket socket) {
+        if (socket instanceof SSLSocket) {
+            SSLSocket sslSocket = (SSLSocket) socket;
+            String[] supportedProtocols = sslSocket.getSupportedProtocols();
+            // Make sure all supported protocols are enabled. Android does not enable TLSv1.1 or
+            // TLSv1.2 by default.
+            sslSocket.setEnabledProtocols(supportedProtocols);
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/HttpResponses.java b/mopub-sdk/src/main/java/com/mopub/network/HeaderUtils.java
similarity index 55%
rename from mopub-sdk/src/main/java/com/mopub/mobileads/util/HttpResponses.java
rename to mopub-sdk/src/main/java/com/mopub/network/HeaderUtils.java
index 3167787d..27eb863f 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/HttpResponses.java
+++ b/mopub-sdk/src/main/java/com/mopub/network/HeaderUtils.java
@@ -1,4 +1,6 @@
-package com.mopub.mobileads.util;
+package com.mopub.network;
+
+import android.support.annotation.Nullable;
 
 import com.mopub.common.util.ResponseHeader;
 
@@ -7,32 +9,34 @@
 
 import java.text.NumberFormat;
 import java.util.Locale;
+import java.util.Map;
+
+public class HeaderUtils {
+    @Nullable
+    public static String extractHeader(Map<String, String> headers, ResponseHeader responseHeader) {
+        return headers.get(responseHeader.getKey());
+    }
+
+    public static Integer extractIntegerHeader(Map<String, String> headers, ResponseHeader responseHeader) {
+        return formatIntHeader(extractHeader(headers, responseHeader));
+    }
+
+    public static boolean extractBooleanHeader(Map<String, String> headers, ResponseHeader responseHeader, boolean defaultValue) {
+        return formatBooleanHeader(extractHeader(headers, responseHeader), defaultValue);
+    }
 
-public class HttpResponses {
     public static String extractHeader(HttpResponse response, ResponseHeader responseHeader) {
         Header header = response.getFirstHeader(responseHeader.getKey());
         return header != null ? header.getValue() : null;
     }
 
     public static boolean extractBooleanHeader(HttpResponse response, ResponseHeader responseHeader, boolean defaultValue) {
-        String header = extractHeader(response, responseHeader);
-        if (header == null) {
-            return defaultValue;
-        }
-        return header.equals("1");
+        return formatBooleanHeader(extractHeader(response, responseHeader), defaultValue);
     }
 
     public static Integer extractIntegerHeader(HttpResponse response, ResponseHeader responseHeader) {
-        NumberFormat numberFormat = NumberFormat.getInstance(Locale.US);
-        numberFormat.setParseIntegerOnly(true);
-
         String headerValue = extractHeader(response, responseHeader);
-        try {
-            Number value = numberFormat.parse(headerValue.trim());
-            return value.intValue();
-        } catch (Exception e) {
-            return null;
-        }
+        return formatIntHeader(headerValue);
     }
 
     public static int extractIntHeader(HttpResponse response, ResponseHeader responseHeader, int defaultValue) {
@@ -43,4 +47,23 @@ public static int extractIntHeader(HttpResponse response, ResponseHeader respons
 
         return headerValue;
     }
+
+    private static boolean formatBooleanHeader(@Nullable String headerValue, boolean defaultValue) {
+        if (headerValue == null) {
+            return defaultValue;
+        }
+        return headerValue.equals("1");
+    }
+
+    private static Integer formatIntHeader(String headerValue) {
+        NumberFormat numberFormat = NumberFormat.getInstance(Locale.US);
+        numberFormat.setParseIntegerOnly(true);
+
+        try {
+            Number value = numberFormat.parse(headerValue.trim());
+            return value.intValue();
+        } catch (Exception e) {
+            return null;
+        }
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/network/MaxWidthImageLoader.java b/mopub-sdk/src/main/java/com/mopub/network/MaxWidthImageLoader.java
new file mode 100644
index 00000000..6927dd96
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/MaxWidthImageLoader.java
@@ -0,0 +1,38 @@
+package com.mopub.network;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.graphics.Point;
+import android.os.Build;
+import android.view.Display;
+import android.view.WindowManager;
+
+import com.mopub.volley.RequestQueue;
+
+public class MaxWidthImageLoader extends com.mopub.volley.toolbox.ImageLoader {
+    private final int mMaxImageWidth;
+
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)
+    public MaxWidthImageLoader(final RequestQueue queue, final Context context, final ImageCache imageCache) {
+        super(queue, imageCache);
+
+        // Get Display Options
+        WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
+        Display display = wm.getDefaultDisplay();
+        Point size = new Point();
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB_MR2) {
+            size.set(display.getWidth(), display.getHeight());
+        } else {
+            display.getSize(size);
+        }
+
+        // Make our images no wider than the skinny side of the display.
+        mMaxImageWidth = Math.min(size.x, size.y);
+    }
+
+    @Override
+    public ImageContainer get(final String requestUrl, final ImageListener listener) {
+        return super.get(requestUrl, listener, mMaxImageWidth, 0 /* no height limit */);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/MoPubNetworkError.java b/mopub-sdk/src/main/java/com/mopub/network/MoPubNetworkError.java
new file mode 100644
index 00000000..43becf67
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/MoPubNetworkError.java
@@ -0,0 +1,66 @@
+package com.mopub.network;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.VolleyError;
+
+public class MoPubNetworkError extends VolleyError {
+    public enum Reason {
+        WARMING_UP,
+        NO_FILL,
+        BAD_HEADER_DATA,
+        BAD_BODY,
+        TRACKING_FAILURE,
+        UNSPECIFIED
+    }
+
+    @NonNull private final Reason mReason;
+    @Nullable private final Integer mRefreshTimeMillis;
+
+    public MoPubNetworkError(@NonNull Reason reason) {
+        super();
+        mReason = reason;
+        mRefreshTimeMillis = null;
+    }
+
+    public MoPubNetworkError(@NonNull NetworkResponse networkResponse, @NonNull Reason reason) {
+        super(networkResponse);
+        mReason = reason;
+        mRefreshTimeMillis = null;
+    }
+
+    public MoPubNetworkError(@NonNull Throwable cause, @NonNull Reason reason) {
+        super(cause);
+        mReason = reason;
+        mRefreshTimeMillis = null;
+    }
+
+    public MoPubNetworkError(@NonNull String message, @NonNull Reason reason) {
+        this(message, reason, null);
+    }
+
+    public MoPubNetworkError(@NonNull String message, @NonNull Throwable cause, @NonNull Reason reason) {
+        super(message, cause);
+        mReason = reason;
+        mRefreshTimeMillis = null;
+    }
+
+    public MoPubNetworkError(@NonNull String message, @NonNull Reason reason,
+            @Nullable Integer refreshTimeMillis) {
+        super(message);
+        mReason = reason;
+        mRefreshTimeMillis = refreshTimeMillis;
+    }
+
+    @NonNull
+    public Reason getReason() {
+        return mReason;
+    }
+
+    @Nullable
+    public Integer getRefreshTimeMillis() {
+        return mRefreshTimeMillis;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/MoPubRequestQueue.java b/mopub-sdk/src/main/java/com/mopub/network/MoPubRequestQueue.java
new file mode 100644
index 00000000..9b5d4592
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/MoPubRequestQueue.java
@@ -0,0 +1,166 @@
+package com.mopub.network;
+
+import android.os.Handler;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.volley.Cache;
+import com.mopub.volley.Network;
+import com.mopub.volley.Request;
+import com.mopub.volley.RequestQueue;
+import com.mopub.volley.ResponseDelivery;
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+/**
+ * MoPub's custom implementation of the Google Volley RequestQueue.
+ * This subclass provides convenience methods for adding a delayed request to run at a time in
+ * the future. This is useful for our backoff policy architecture.
+ *
+ * We've overridden certain implementation methods but have kept the contract of the
+ * original method consistent.
+ */
+public class MoPubRequestQueue extends RequestQueue {
+
+    private static final int CAPACITY = 10;
+
+    @NonNull
+    private final Map<Request<?>, DelayedRequestHelper> mDelayedRequests;
+
+    MoPubRequestQueue(Cache cache, Network network, int threadPoolSize, ResponseDelivery delivery) {
+        super(cache, network, threadPoolSize, delivery);
+        mDelayedRequests = new HashMap<Request<?>, DelayedRequestHelper>(CAPACITY);
+    }
+
+    MoPubRequestQueue(Cache cache, Network network, int threadPoolSize) {
+        super(cache, network, threadPoolSize);
+        mDelayedRequests = new HashMap<Request<?>, DelayedRequestHelper>(CAPACITY);
+    }
+
+    MoPubRequestQueue(Cache cache, Network network) {
+        super(cache, network);
+        mDelayedRequests = new HashMap<Request<?>, DelayedRequestHelper>(CAPACITY);
+    }
+
+    /**
+     * Convenience method for adding a request with a time delay to the request queue.
+     *
+     * @param request The request.
+     * @param delayMs The delay in ms for adding the request to the request queue.
+     */
+    public void addDelayedRequest(@NonNull Request<?> request, int delayMs) {
+        Preconditions.checkNotNull(request);
+        addDelayedRequest(request, new DelayedRequestHelper(request, delayMs));
+    }
+
+    @VisibleForTesting
+    void addDelayedRequest(@NonNull Request<?> request, @NonNull DelayedRequestHelper delayedRequestHelper) {
+        Preconditions.checkNotNull(delayedRequestHelper);
+
+        if (mDelayedRequests.containsKey(request)) {
+            cancel(request);
+        }
+
+        delayedRequestHelper.start();
+        mDelayedRequests.put(request, delayedRequestHelper);
+    }
+
+    /**
+     * Override of cancelAll method to ensure delayed requests are cancelled as well.
+     */
+    @Override
+    public void cancelAll(@NonNull RequestFilter filter) {
+        Preconditions.checkNotNull(filter);
+
+        super.cancelAll(filter);
+
+        Iterator<Map.Entry<Request<?>, DelayedRequestHelper>> iterator = mDelayedRequests.entrySet().iterator();
+        while (iterator.hasNext()) {
+            Map.Entry<Request<?>, DelayedRequestHelper> entry = iterator.next();
+            if (filter.apply(entry.getKey())) {
+                // Here we cancel both the request and the handler from posting the delayed runnable
+                entry.getKey().cancel();
+                entry.getValue().cancel();
+                iterator.remove();
+            }
+        }
+    }
+
+    /**
+     * Override of cancelAll method to ensure delayed requests are cancelled as well.
+     */
+    @Override
+    public void cancelAll(@NonNull final Object tag) {
+        Preconditions.checkNotNull(tag);
+
+        super.cancelAll(tag);
+
+        cancelAll(new RequestFilter() {
+            @Override
+            public boolean apply(Request<?> request) {
+                return request.getTag() == tag;
+            }
+        });
+    }
+
+    /**
+     * Convenience method to cancel a single request.
+     *
+     * @param request The request to cancel.
+     */
+    public void cancel(@NonNull final Request<?> request) {
+        Preconditions.checkNotNull(request);
+
+        cancelAll(new RequestFilter() {
+            @Override
+            public boolean apply(Request<?> _request) {
+                return request == _request;
+            }
+        });
+    }
+
+    /**
+     * This helper class is used to package the supporting objects a request needs to
+     * run at a delayed time and cancel if needed.
+     */
+    class DelayedRequestHelper {
+        final int mDelayMs;
+        @NonNull final Handler mHandler;
+        @NonNull final Runnable mDelayedRunnable;
+
+        DelayedRequestHelper(@NonNull final Request<?> request, int delayMs) {
+            this(request, delayMs, new Handler());
+        }
+
+        @VisibleForTesting
+        DelayedRequestHelper(@NonNull final Request<?> request, int delayMs, @NonNull Handler handler) {
+            mDelayMs = delayMs;
+            mHandler = handler;
+            mDelayedRunnable = new Runnable() {
+                @Override
+                public void run() {
+                    mDelayedRequests.remove(request);
+                    MoPubRequestQueue.this.add(request);
+                }
+            };
+        }
+
+        void start() {
+            mHandler.postDelayed(mDelayedRunnable, mDelayMs);
+        }
+
+        void cancel() {
+            mHandler.removeCallbacks(mDelayedRunnable);
+        }
+    }
+
+    @NonNull
+    @Deprecated
+    @VisibleForTesting
+    Map<Request<?>, DelayedRequestHelper> getDelayedRequests() {
+        return mDelayedRequests;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/Networking.java b/mopub-sdk/src/main/java/com/mopub/network/Networking.java
new file mode 100644
index 00000000..ed087c69
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/Networking.java
@@ -0,0 +1,178 @@
+package com.mopub.network;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.v4.util.LruCache;
+import android.webkit.WebView;
+
+import com.mopub.common.ClientMetadata;
+import com.mopub.common.Constants;
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.util.DeviceUtils;
+import com.mopub.volley.Cache;
+import com.mopub.volley.Network;
+import com.mopub.volley.RequestQueue;
+import com.mopub.volley.toolbox.BasicNetwork;
+import com.mopub.volley.toolbox.DiskBasedCache;
+import com.mopub.volley.toolbox.HttpStack;
+import com.mopub.volley.toolbox.HurlStack;
+import com.mopub.volley.toolbox.ImageLoader;
+
+import java.io.File;
+
+import javax.net.ssl.SSLSocketFactory;
+
+public class Networking {
+    @VisibleForTesting
+    static final String CACHE_DIRECTORY_NAME = "mopub-volley-cache";
+
+
+    // These are volatile so that double-checked locking works.
+    // See http://en.wikipedia.org/wiki/Double-checked_locking#Usage_in_Java
+    // for more information.
+    private volatile static MoPubRequestQueue sRequestQueue;
+    private volatile static String sUserAgent;
+    private volatile static MaxWidthImageLoader sMaxWidthImageLoader;
+    public static boolean sUseHttps = false;
+
+    @Nullable
+    public static MoPubRequestQueue getRequestQueue() {
+        return sRequestQueue;
+    }
+
+    @NonNull
+    public static MoPubRequestQueue getRequestQueue(@NonNull Context context) {
+        MoPubRequestQueue requestQueue = sRequestQueue;
+        // Double-check locking to initialize.
+        if (requestQueue == null) {
+            synchronized (Networking.class) {
+                requestQueue = sRequestQueue;
+                if (requestQueue == null) {
+
+                    // Guarantee ClientMetadata is set up.
+                    final ClientMetadata clientMetadata = ClientMetadata.getInstance(context);
+                    final HurlStack.UrlRewriter urlRewriter = new PlayServicesUrlRewriter(clientMetadata.getDeviceId(), context);
+                    final SSLSocketFactory socketFactory = CustomSSLSocketFactory.getDefault(Constants.TEN_SECONDS_MILLIS);
+
+                    final String userAgent = Networking.getUserAgent(context.getApplicationContext());
+                    HttpStack httpStack = new RequestQueueHttpStack(userAgent, urlRewriter, socketFactory);
+
+                    Network network = new BasicNetwork(httpStack);
+                    File volleyCacheDir = new File(context.getCacheDir().getPath() + File.separator
+                            + CACHE_DIRECTORY_NAME);
+                    Cache cache = new DiskBasedCache(volleyCacheDir, (int) DeviceUtils.diskCacheSizeBytes(volleyCacheDir, Constants.TEN_MB));
+                    requestQueue = new MoPubRequestQueue(cache, network);
+                    sRequestQueue = requestQueue;
+                    requestQueue.start();
+                }
+            }
+        }
+
+        return requestQueue;
+    }
+
+    @NonNull
+    public static ImageLoader getImageLoader(@NonNull Context context) {
+        MaxWidthImageLoader imageLoader = sMaxWidthImageLoader;
+        // Double-check locking to initialize.
+        if (imageLoader == null) {
+            synchronized (Networking.class) {
+                imageLoader = sMaxWidthImageLoader;
+                if (imageLoader == null) {
+                    RequestQueue queue = getRequestQueue(context);
+                    int cacheSize = DeviceUtils.memoryCacheSizeBytes(context);
+                    final LruCache<String, Bitmap> imageCache = new LruCache<String, Bitmap>(cacheSize) {
+                        @Override
+                        protected int sizeOf(String key, Bitmap value) {
+                            if (value != null) {
+                                return value.getRowBytes() * value.getHeight();
+                            }
+
+                            return super.sizeOf(key, value);
+                        }
+                    };
+                    imageLoader = new MaxWidthImageLoader(queue, context, new MaxWidthImageLoader.ImageCache() {
+                        @Override
+                        public Bitmap getBitmap(final String key) {
+                            return imageCache.get(key);
+                        }
+
+                        @Override
+                        public void putBitmap(final String key, final Bitmap bitmap) {
+                            imageCache.put(key, bitmap);
+                        }
+                    });
+                    sMaxWidthImageLoader = imageLoader;
+                }
+            }
+        }
+        return imageLoader;
+    }
+
+    /**
+     * Caches and returns the WebView user agent to be used across all SDK requests. This is
+     * important because advertisers expect the same user agent across all request, impression, and
+     * click events.
+     */
+    @NonNull
+    public static String getUserAgent(@NonNull Context context) {
+        Preconditions.checkNotNull(context);
+
+        String userAgent = sUserAgent;
+        if (userAgent == null) {
+            synchronized (Networking.class) {
+                userAgent = sUserAgent;
+                if (userAgent == null) {
+                    // As of Android 4.4, WebViews may only be instantiated on the UI thread
+                    if (Looper.myLooper() == Looper.getMainLooper()) {
+                        userAgent = new WebView(context).getSettings().getUserAgentString();
+                    } else {
+                        // In the exceptional case where we can't access the WebView user agent,
+                        // fall back to the System-specific user agent.
+                        userAgent = System.getProperty("http.agent");
+                    }
+                    sUserAgent = userAgent;
+                }
+            }
+        }
+
+        return userAgent;
+    }
+
+    @VisibleForTesting
+    public static synchronized void clearForTesting() {
+        sRequestQueue = null;
+        sMaxWidthImageLoader = null;
+        sUserAgent = null;
+    }
+
+    @VisibleForTesting
+    public static synchronized void setRequestQueueForTesting(MoPubRequestQueue queue) {
+        sRequestQueue = queue;
+    }
+
+    @VisibleForTesting
+    public static synchronized void setImageLoaderForTesting(MaxWidthImageLoader imageLoader) {
+        sMaxWidthImageLoader = imageLoader;
+    }
+
+    @VisibleForTesting
+    public static synchronized void setUserAgentForTesting(String userAgent) {
+        sUserAgent = userAgent;
+    }
+
+    /**
+     * Set whether to use HTTPS for communication with MoPub ad servers.
+     */
+    public static void useHttps(boolean useHttps) {
+        sUseHttps = useHttps;
+    }
+
+    public static boolean useHttps() {
+        return sUseHttps;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/PlayServicesUrlRewriter.java b/mopub-sdk/src/main/java/com/mopub/network/PlayServicesUrlRewriter.java
new file mode 100644
index 00000000..42438bbd
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/PlayServicesUrlRewriter.java
@@ -0,0 +1,51 @@
+package com.mopub.network;
+
+import android.content.Context;
+import android.net.Uri;
+
+import com.mopub.common.GpsHelper;
+import com.mopub.volley.toolbox.HurlStack;
+
+/**
+ * Url Rewriter that replaces MoPub templates for Google Advertising ID and Do Not Track settings
+ * when a request is queued for dispatch by the HurlStack in Volley.
+ */
+public class PlayServicesUrlRewriter implements HurlStack.UrlRewriter {
+    private static final String IFA_PREFIX = "ifa:";
+
+    public static final String UDID_TEMPLATE = "mp_tmpl_advertising_id";
+    public static final String DO_NOT_TRACK_TEMPLATE = "mp_tmpl_do_not_track";
+
+    private final String deviceIdentifier;
+    private final Context applicationContext;
+
+    public PlayServicesUrlRewriter(String deviceId, Context context) {
+        deviceIdentifier = deviceId;
+        applicationContext = context.getApplicationContext();
+    }
+
+    @Override
+    public String rewriteUrl(final String url) {
+        if (!url.contains(UDID_TEMPLATE) && !url.contains(DO_NOT_TRACK_TEMPLATE)) {
+            return url;
+        }
+
+        String prefix = "";
+        GpsHelper.AdvertisingInfo advertisingInfo = new GpsHelper.AdvertisingInfo(deviceIdentifier, false);
+
+        // Attempt to fetch the Google Play Services fields
+        if (GpsHelper.isPlayServicesAvailable(applicationContext)) {
+            // We can do this synchronously because urlRewrite happens in a background thread.
+            GpsHelper.AdvertisingInfo playServicesAdInfo = GpsHelper.fetchAdvertisingInfoSync(applicationContext);
+            if (playServicesAdInfo != null) {
+                prefix = IFA_PREFIX;
+                advertisingInfo = playServicesAdInfo;
+            }
+        }
+
+        // Fill in the templates
+        String toReturn = url.replace(UDID_TEMPLATE, Uri.encode(prefix + advertisingInfo.advertisingId));
+        toReturn = toReturn.replace(DO_NOT_TRACK_TEMPLATE, advertisingInfo.limitAdTracking ? "1" : "0");
+        return toReturn;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/RequestManager.java b/mopub-sdk/src/main/java/com/mopub/network/RequestManager.java
new file mode 100644
index 00000000..ba535bf8
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/RequestManager.java
@@ -0,0 +1,104 @@
+package com.mopub.network;
+
+import android.os.Handler;
+import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.volley.Request;
+
+/**
+ * This class is responsible for managing the lifecycle of a request with a backoff policy. This
+ * class currently manages a single request at a time. The API allows for it to support multiple
+ * simultaneous requests in the future.
+ *
+ * Subclasses are responsible for implementing the createRequest method that will create a new
+ * instance of subclass's specific request type.
+ * The subclass is also responsible for listening to success and error responses from its specific
+ * request type.
+ *
+ * @param <T> The type of request factory to generate new requests for each retry.
+ */
+public abstract class RequestManager<T extends RequestManager.RequestFactory> {
+
+    // This interface is used to bound type T of the RequestManager
+    public interface RequestFactory{}
+
+    @Nullable protected Request<?> mCurrentRequest;
+    @Nullable protected T mRequestFactory;
+    @Nullable protected BackoffPolicy mBackoffPolicy;
+    @NonNull protected Handler mHandler;
+
+    public RequestManager(@NonNull Looper looper) {
+        mHandler = new Handler(looper);
+    }
+
+    @NonNull
+    abstract Request<?> createRequest();
+
+    public boolean isAtCapacity() {
+        return mCurrentRequest != null;
+    }
+
+    /**
+     * This method first cancels existing requests in flight and then begins the request
+     * lifecycle for the new request.
+     *
+     * @param requestFactory Factory that constructs a new request for each request retry from the
+     *                       backoff policy.
+     * @param backoffPolicy The request to cancel.
+     */
+    public void makeRequest(@NonNull T requestFactory, @NonNull BackoffPolicy backoffPolicy) {
+        Preconditions.checkNotNull(requestFactory);
+        Preconditions.checkNotNull(backoffPolicy);
+
+        cancelRequest();
+        mRequestFactory = requestFactory;
+        mBackoffPolicy = backoffPolicy;
+        makeRequestInternal();
+    }
+
+    /**
+     * Cancels the request in flight.
+     */
+    public void cancelRequest() {
+        MoPubRequestQueue requestQueue = Networking.getRequestQueue();
+        if (requestQueue != null && mCurrentRequest != null) {
+            requestQueue.cancel(mCurrentRequest);
+        }
+        clearRequest();
+    }
+
+    @VisibleForTesting
+    void makeRequestInternal() {
+        mCurrentRequest = createRequest();
+        MoPubRequestQueue requestQueue = Networking.getRequestQueue();
+        if (requestQueue == null) {
+            MoPubLog.d("MoPubRequest queue is null. Clearing request.");
+            clearRequest();
+            return;
+        }
+
+        if (mBackoffPolicy.getRetryCount() == 0) {
+            requestQueue.add(mCurrentRequest);
+        } else {
+            requestQueue.addDelayedRequest(mCurrentRequest, mBackoffPolicy.getBackoffMs());
+        }
+    }
+
+    @VisibleForTesting
+    void clearRequest() {
+        mCurrentRequest = null;
+        mRequestFactory = null;
+        mBackoffPolicy = null;
+    }
+
+    @Deprecated
+    @VisibleForTesting
+    Request<?> getCurrentRequest() {
+        return mCurrentRequest;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/RequestQueueHttpStack.java b/mopub-sdk/src/main/java/com/mopub/network/RequestQueueHttpStack.java
new file mode 100644
index 00000000..f2df816c
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/RequestQueueHttpStack.java
@@ -0,0 +1,54 @@
+package com.mopub.network;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.util.ResponseHeader;
+import com.mopub.volley.AuthFailureError;
+import com.mopub.volley.Request;
+import com.mopub.volley.toolbox.HurlStack;
+
+import org.apache.http.HttpResponse;
+
+import java.io.IOException;
+import java.util.Map;
+import java.util.TreeMap;
+
+import javax.net.ssl.SSLSocketFactory;
+
+/**
+ * Modified Volley HurlStack with explicitly specified User-Agent.
+ *
+ * Used by Networking's singleton RequestQueue to ensure all network requests use WebView's
+ * User-Agent.
+ */
+public class RequestQueueHttpStack extends HurlStack {
+    @NonNull private final String mUserAgent;
+
+    public RequestQueueHttpStack(@NonNull final String userAgent) {
+        this(userAgent, null);
+    }
+
+    public RequestQueueHttpStack(@NonNull final String userAgent, @Nullable final UrlRewriter urlRewriter) {
+        this(userAgent, urlRewriter, null);
+    }
+
+    public RequestQueueHttpStack(@NonNull final String userAgent, @Nullable final UrlRewriter urlRewriter,
+                                 @Nullable final SSLSocketFactory sslSocketFactory) {
+        super(urlRewriter, sslSocketFactory);
+
+        mUserAgent = userAgent;
+    }
+
+    @Override
+    public HttpResponse performRequest(@NonNull final Request<?> request,
+            @Nullable Map<String, String> additionalHeaders) throws IOException, AuthFailureError {
+        if (additionalHeaders == null) {
+            additionalHeaders = new TreeMap<String, String>();
+        }
+
+        additionalHeaders.put(ResponseHeader.USER_AGENT.getKey(), mUserAgent);
+
+        return super.performRequest(request, additionalHeaders);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/network/ScribeBackoffPolicy.java b/mopub-sdk/src/main/java/com/mopub/network/ScribeBackoffPolicy.java
new file mode 100644
index 00000000..5b5b3732
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/ScribeBackoffPolicy.java
@@ -0,0 +1,54 @@
+package com.mopub.network;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.NoConnectionError;
+import com.mopub.volley.VolleyError;
+
+/**
+ * The backoff policy for making requests to the Scribe service.
+ */
+public class ScribeBackoffPolicy extends BackoffPolicy {
+    private static final int DEFAULT_BACKOFF_TIME_MS = 60 * 1000;
+    private static final int MAX_RETRIES = 5;
+    private static final int BACKOFF_MULTIPLIER = 2;
+
+    public ScribeBackoffPolicy() {
+        this(DEFAULT_BACKOFF_TIME_MS, MAX_RETRIES, BACKOFF_MULTIPLIER);
+    }
+
+    @VisibleForTesting
+    ScribeBackoffPolicy(int defaultBackoffTimeMs, int maxRetries, int backoffMultiplier) {
+        mDefaultBackoffTimeMs = defaultBackoffTimeMs;
+        mMaxRetries = maxRetries;
+        mBackoffMultiplier = backoffMultiplier;
+    }
+
+    @Override
+    public void backoff(VolleyError volleyError) throws VolleyError {
+        if (!hasAttemptRemaining()) {
+            throw volleyError;
+        }
+
+        if (volleyError instanceof NoConnectionError) {
+            updateBackoffTime();
+            return;
+        }
+
+        NetworkResponse networkResponse = volleyError.networkResponse;
+        if (networkResponse != null &&
+                (networkResponse.statusCode == 503  || networkResponse.statusCode == 504)) {
+            updateBackoffTime();
+            return;
+        }
+
+        throw volleyError;
+    }
+
+    private void updateBackoffTime() {
+        double multiplier = Math.pow(mBackoffMultiplier, mRetryCount);
+        mBackoffMs = (int) (mDefaultBackoffTimeMs * multiplier);
+        mRetryCount++;
+    }
+}
+
diff --git a/mopub-sdk/src/main/java/com/mopub/network/ScribeRequest.java b/mopub-sdk/src/main/java/com/mopub/network/ScribeRequest.java
new file mode 100644
index 00000000..f04bcdf0
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/ScribeRequest.java
@@ -0,0 +1,83 @@
+package com.mopub.network;
+
+import android.support.annotation.NonNull;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.event.BaseEvent;
+import com.mopub.common.event.EventSerializer;
+import com.mopub.volley.DefaultRetryPolicy;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.Request;
+import com.mopub.volley.Response;
+import com.mopub.volley.toolbox.HttpHeaderParser;
+
+import org.json.JSONArray;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * A POST request for logging custom events to the Scribe service.
+ */
+public class ScribeRequest extends Request<Void> {
+
+    public interface Listener extends Response.ErrorListener {
+        public void onResponse();
+    }
+
+    public interface ScribeRequestFactory extends RequestManager.RequestFactory {
+        public ScribeRequest createRequest(ScribeRequest.Listener listener);
+    }
+
+    @NonNull private final List<BaseEvent> mEvents;
+    @NonNull private final EventSerializer mEventSerializer;
+    @NonNull private final ScribeRequest.Listener mListener;
+
+    public ScribeRequest(@NonNull String url,
+            @NonNull List<BaseEvent> events,
+            @NonNull EventSerializer eventSerializer,
+            @NonNull Listener listener) {
+        super(Method.POST, url, listener);
+
+        mEvents = events;
+        mEventSerializer = eventSerializer;
+        mListener = listener;
+
+        setShouldCache(false);
+
+        // This retry policy applies to socket timeouts only
+        setRetryPolicy(new DefaultRetryPolicy());
+    }
+
+    /**
+     * This is method runs on the background thread
+     */
+    @Override
+    protected Map<String,String> getParams() {
+        JSONArray jsonArray = mEventSerializer.serializeAsJson(mEvents);
+        Map<String,String> params = new HashMap<String, String>();
+        params.put("log", jsonArray.toString());
+        return params;
+    }
+
+    @Override
+    protected Response<Void> parseNetworkResponse(NetworkResponse networkResponse) {
+        // NOTE: We never get status codes outside of {[200, 299], 304}. Those errors are sent to the
+        // error listener.
+        return Response.success(null, HttpHeaderParser.parseCacheHeaders(networkResponse));
+    }
+
+    @Override
+    protected void deliverResponse(Void aVoid) {
+        mListener.onResponse();
+    }
+
+    @NonNull
+    @Deprecated
+    @VisibleForTesting
+    public List<BaseEvent> getEvents() {
+        return mEvents;
+    }
+}
+
diff --git a/mopub-sdk/src/main/java/com/mopub/network/ScribeRequestManager.java b/mopub-sdk/src/main/java/com/mopub/network/ScribeRequestManager.java
new file mode 100644
index 00000000..e1b3fc45
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/ScribeRequestManager.java
@@ -0,0 +1,59 @@
+package com.mopub.network;
+
+import android.os.Looper;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.volley.Request;
+import com.mopub.volley.VolleyError;
+
+import static com.mopub.network.ScribeRequest.ScribeRequestFactory;
+
+/**
+ * Request manager to manage scribe requests. This class implements the specific Scribe
+ * request listener.
+ */
+public class ScribeRequestManager extends RequestManager<ScribeRequestFactory> implements ScribeRequest.Listener {
+
+    public ScribeRequestManager(final Looper looper) {
+        super(looper);
+    }
+
+    // RequestManager
+    @NonNull
+    @Override
+    Request<?> createRequest() {
+        return mRequestFactory.createRequest(this);
+    }
+
+    // ScribeRequest.Listener
+    @Override
+    public void onResponse() {
+        MoPubLog.d("Successfully scribed events");
+        // Get back to the dedicated event logging thread before touching shared resources
+        mHandler.post(new Runnable() {
+            @Override
+            public void run() {
+                clearRequest();
+            }
+        });
+    }
+
+    @Override
+    public void onErrorResponse(final VolleyError volleyError) {
+        // Post back to the dedicated event logging thread before touching shared resources
+        mHandler.post(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    mBackoffPolicy.backoff(volleyError);
+                    makeRequestInternal();
+                } catch (VolleyError e) {
+                    MoPubLog.d("Failed to Scribe events: " + volleyError);
+                    clearRequest();
+                }
+            }
+        });
+    }
+}
+
diff --git a/mopub-sdk/src/main/java/com/mopub/network/TrackingRequest.java b/mopub-sdk/src/main/java/com/mopub/network/TrackingRequest.java
new file mode 100644
index 00000000..4570a183
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/network/TrackingRequest.java
@@ -0,0 +1,129 @@
+package com.mopub.network;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
+import com.mopub.common.event.BaseEvent;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.volley.DefaultRetryPolicy;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.Request;
+import com.mopub.volley.RequestQueue;
+import com.mopub.volley.Response;
+import com.mopub.volley.VolleyError;
+import com.mopub.volley.toolbox.HttpHeaderParser;
+
+import java.util.Arrays;
+
+public class TrackingRequest extends Request<Void> {
+
+    public interface Listener extends Response.ErrorListener {
+        public void onResponse(@NonNull String url);
+    }
+
+    @Nullable private final TrackingRequest.Listener mListener;
+
+    private TrackingRequest(@NonNull final String url, @Nullable final Listener listener) {
+        super(Method.GET, url, listener);
+        mListener = listener;
+        setShouldCache(false);
+        setRetryPolicy(new DefaultRetryPolicy(
+                DefaultRetryPolicy.DEFAULT_TIMEOUT_MS,
+                DefaultRetryPolicy.DEFAULT_MAX_RETRIES,
+                DefaultRetryPolicy.DEFAULT_BACKOFF_MULT));
+    }
+
+    @Override
+    protected Response<Void> parseNetworkResponse(final NetworkResponse networkResponse) {
+        if (networkResponse.statusCode != 200) {
+            return Response.error(
+                    new MoPubNetworkError("Failed to log tracking request. Response code: "
+                            + networkResponse.statusCode + " for url: " + getUrl(),
+                            MoPubNetworkError.Reason.TRACKING_FAILURE));
+        }
+        return Response.success(null, HttpHeaderParser.parseCacheHeaders(networkResponse));
+    }
+
+    @Override
+    public void deliverResponse(final Void aVoid) {
+        if (mListener != null) {
+            mListener.onResponse(getUrl());
+        }
+    }
+
+    ///////////////////////////////////////////////////////////////
+    // Static helper methods that can be used as utilities:
+    //////////////////////////////////////////////////////////////
+
+    public static void makeTrackingHttpRequest(final Iterable<String> urls, final Context context) {
+        makeTrackingHttpRequest(urls, context, null, null);
+    }
+
+    public static void makeTrackingHttpRequest(final Iterable<String> urls,
+            final Context context,
+            final BaseEvent.Name name) {
+        makeTrackingHttpRequest(urls, context, null, name);
+    }
+
+    public static void makeTrackingHttpRequest(final Iterable<String> urls,
+            final Context context,
+            @Nullable final Listener listener,
+            final BaseEvent.Name name) {
+        if (urls == null || context == null) {
+            return;
+        }
+
+        final RequestQueue requestQueue = Networking.getRequestQueue(context);
+        for (final String url : urls) {
+            if (TextUtils.isEmpty(url)) {
+                continue;
+            }
+
+            final TrackingRequest.Listener internalListener = new TrackingRequest.Listener() {
+                @Override
+                public void onResponse(@NonNull String url) {
+                    MoPubLog.d("Successfully hit tracking endpoint: " + url);
+                    if (listener != null) {
+                        listener.onResponse(url);
+                    }
+                }
+
+                @Override
+                public void onErrorResponse(final VolleyError volleyError) {
+                    MoPubLog.d("Failed to hit tracking endpoint: " + url);
+                    if (listener != null) {
+                        listener.onErrorResponse(volleyError);
+                    }
+                }
+            };
+            final TrackingRequest trackingRequest = new TrackingRequest(url, internalListener);
+            requestQueue.add(trackingRequest);
+        }
+    }
+
+    public static void makeTrackingHttpRequest(final String url,
+            final Context context) {
+        makeTrackingHttpRequest(url, context, null, null);
+    }
+
+    public static void makeTrackingHttpRequest(final String url,
+            final Context context, @Nullable Listener listener) {
+        makeTrackingHttpRequest(url, context, listener, null);
+    }
+
+    public static void makeTrackingHttpRequest(final String url,
+            final Context context, final BaseEvent.Name name) {
+        makeTrackingHttpRequest(url, context, null, name);
+    }
+
+    public static void makeTrackingHttpRequest(final String url,
+            final Context context,
+            @Nullable Listener listener,
+            final BaseEvent.Name name) {
+        if (url != null) {
+            makeTrackingHttpRequest(Arrays.asList(url), context, listener, name);
+        }
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/AdReportTest.java b/mopub-sdk/src/test/java/com/mopub/common/AdReportTest.java
new file mode 100644
index 00000000..6bdefe59
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/AdReportTest.java
@@ -0,0 +1,104 @@
+package com.mopub.common;
+
+import android.os.Build;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.test.support.TestDateAndTime;
+import com.mopub.network.AdResponse;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.stub;
+
+@RunWith(SdkTestRunner.class)
+public class AdReportTest {
+
+    public AdReport subject;
+    @Mock
+    ClientMetadata mockClientMetadata;
+    @Mock
+    AdResponse mockAdResponse;
+    private Date now;
+
+    @Before
+    public void setup() {
+        now = new Date();
+        TestDateAndTime.getInstance().setNow(now);
+    }
+
+    @Test
+    public void testToString_shouldProperlyConstructParametersTextFile() throws Exception {
+        String expectedParameters =
+                "sdk_version : 1.15.2.2\n" +
+                        "creative_id : \n" +
+                        "platform_version : "+ Integer.toString(Build.VERSION.SDK_INT) +"\n" +
+                        "device_model : android\n" +
+                        "ad_unit_id : testAdUnit\n" +
+                        "device_locale : en_US\n" +
+                        "device_id : UDID\n" +
+                        "network_type : unknown\n" +
+                        "platform : android\n" +
+                        "timestamp : " + getCurrentDateTime() + "\n" +
+                        "ad_type : interstitial\n" +
+                        "ad_size : {480, 320}\n";
+
+        stub(mockClientMetadata.getSdkVersion()).toReturn("1.15.2.2");
+        stub(mockAdResponse.getDspCreativeId()).toReturn("");
+        stub(mockClientMetadata.getDeviceModel()).toReturn("android");
+        stub(mockClientMetadata.getDeviceLocale()).toReturn(Locale.US);
+        stub(mockClientMetadata.getDeviceId()).toReturn("UDID");
+        stub(mockAdResponse.getNetworkType()).toReturn("unknown");
+
+        stub(mockAdResponse.getTimestamp()).toReturn(now.getTime());
+        stub(mockAdResponse.getAdType()).toReturn("interstitial");
+        stub(mockAdResponse.getWidth()).toReturn(480);
+        stub(mockAdResponse.getHeight()).toReturn(320);
+
+        subject = new AdReport("testAdUnit", mockClientMetadata, mockAdResponse);
+        assertThat(subject.toString()).isEqualTo(expectedParameters);
+    }
+
+    @Test
+    public void constructor_shouldHandleInvalidAdConfigurationValues() throws Exception {
+        String expectedParameters =
+                "sdk_version : null\n" +
+                        "creative_id : null\n" +
+                        "platform_version : "+ Integer.toString(Build.VERSION.SDK_INT) +"\n" +
+                        "device_model : null\n" +
+                        "ad_unit_id : testAdUnit\n" +
+                        "device_locale : null\n" +
+                        "device_id : null\n" +
+                        "network_type : null\n" +
+                        "platform : android\n" +
+                        "timestamp : null" + "\n" +
+                        "ad_type : null\n" +
+                        "ad_size : {0, 0}\n";
+
+        stub(mockClientMetadata.getSdkVersion()).toReturn(null);
+        stub(mockAdResponse.getDspCreativeId()).toReturn(null);
+        stub(mockClientMetadata.getDeviceLocale()).toReturn(null);
+        stub(mockClientMetadata.getDeviceId()).toReturn(null);
+        stub(mockAdResponse.getNetworkType()).toReturn(null);
+
+        stub(mockAdResponse.getTimestamp()).toReturn(-1L);
+        stub(mockAdResponse.getAdType()).toReturn(null);
+        stub(mockAdResponse.getWidth()).toReturn(null);
+        stub(mockAdResponse.getHeight()).toReturn(null);
+
+        subject = new AdReport("testAdUnit", mockClientMetadata, mockAdResponse);
+        assertThat(subject.toString()).isEqualTo(expectedParameters);
+    }
+
+    private String getCurrentDateTime() {
+        SimpleDateFormat dateFormat = new SimpleDateFormat("M/d/yy hh:mm:ss a z", Locale.US);
+        return dateFormat.format(now);
+    }
+}
\ No newline at end of file
diff --git a/mopub-sdk/src/test/java/com/mopub/common/CacheServiceTest.java b/mopub-sdk/src/test/java/com/mopub/common/CacheServiceTest.java
index f7f5abd4..025cd79d 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/CacheServiceTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/CacheServiceTest.java
@@ -1,12 +1,9 @@
 package com.mopub.common;
 
 import android.app.Activity;
-import android.graphics.Bitmap;
-import android.support.v4.util.LruCache;
 
 import com.mopub.common.test.support.SdkTestRunner;
 
-import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -39,8 +36,6 @@
 
     @Before
     public void setUp() throws Exception {
-        CacheService.clearAndNullCaches();
-
         context = new Activity();
         key1 = "http://www.mopub.com/";
         data1 = "image_data_1";
@@ -59,24 +54,16 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
         }).when(diskCacheGetListener).onComplete(anyString(), any(byte[].class));
     }
 
-    @After
-    public void tearDown() throws Exception {
-        CacheService.clearAndNullCaches();
-    }
-
     @Test
-    public void initializeCaches_withValidContext_shouldCreateNewCachesIdempotently() throws Exception {
+    public void initializeCache_withValidContext_shouldCreateNewCachesIdempotently() throws Exception {
         assertThat(CacheService.getDiskLruCache()).isNull();
 
         CacheService.initialize(context);
         DiskLruCache diskLruCache = CacheService.getDiskLruCache();
         assertThat(diskLruCache).isNotNull();
-        LruCache<String, Bitmap> memoryLruCache = CacheService.getBitmapLruCache();
-        assertThat(memoryLruCache).isNotNull();
 
         CacheService.initialize(context);
         assertThat(diskLruCache).isEqualTo(CacheService.getDiskLruCache());
-        assertThat(memoryLruCache).isEqualTo(CacheService.getBitmapLruCache());
     }
     
     @Test
@@ -165,8 +152,6 @@ public static void assertDiskCacheIsEmpty() {
     }
 
     public static void assertCachesAreEmpty() {
-        assertThat(CacheService.getBitmapLruCache()).isNotNull();
-        assertThat(CacheService.getBitmapLruCache().size()).isEqualTo(0);
         assertDiskCacheIsEmpty();
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/ClientMetadataTest.java b/mopub-sdk/src/test/java/com/mopub/common/ClientMetadataTest.java
index 44c6fedb..ba6fcd75 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/ClientMetadataTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/ClientMetadataTest.java
@@ -62,11 +62,11 @@ public void testCachedData_shouldBeAvailable() {
 
         final ClientMetadata clientMetadata = ClientMetadata.getInstance(activityContext);
         // Telephony manager data.
-        assertThat(clientMetadata.getNetworkOperator()).isEqualTo("testNetworkOperator");
+        assertThat(clientMetadata.getNetworkOperatorForUrl()).isEqualTo("testNetworkOperator");
         assertThat(clientMetadata.getNetworkOperatorName()).isEqualTo("testNetworkOperatorName");
         assertThat(clientMetadata.getIsoCountryCode()).isEqualTo("1");
 
         // Other cached data.
-        assertThat(clientMetadata.getAdvertisingId()).isNotNull().isNotEmpty();
+        assertThat(clientMetadata.getDeviceId()).isNotNull().isNotEmpty();
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/CloseableLayoutTest.java b/mopub-sdk/src/test/java/com/mopub/common/CloseableLayoutTest.java
new file mode 100644
index 00000000..5c5f35e1
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/CloseableLayoutTest.java
@@ -0,0 +1,222 @@
+package com.mopub.common;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.graphics.Canvas;
+import android.graphics.Rect;
+import android.os.Build.VERSION_CODES;
+import android.view.MotionEvent;
+
+import com.mopub.common.CloseableLayout.ClosePosition;
+import com.mopub.common.CloseableLayout.OnCloseListener;
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+@RunWith(SdkTestRunner.class)
+public class CloseableLayoutTest {
+    private CloseableLayout subject;
+
+    @Mock private OnCloseListener mockCloseListener;
+
+    private MotionEvent closeRegionDown;
+    private MotionEvent closeRegionUp;
+    private MotionEvent closeRegionCancel;
+    private MotionEvent contentRegionDown;
+    private MotionEvent contentRegionUp;
+    private MotionEvent contentRegionCancel;
+
+    @Before
+    public void setup() {
+        Activity activity = Robolectric.buildActivity(Activity.class).create().get();
+        subject = new CloseableLayout(activity);
+        subject.setClosePosition(ClosePosition.TOP_RIGHT);
+
+        // Fake the close bounds, which allows us to set up close regions
+        subject.setCloseBounds(new Rect(100, 10, 110, 20));
+        closeRegionDown = MotionEvent.obtain(
+                100, 200, MotionEvent.ACTION_DOWN, 100, 10, 0);
+        closeRegionUp = MotionEvent.obtain(
+                100, 200, MotionEvent.ACTION_UP, 100, 10, 0);
+        closeRegionCancel = MotionEvent.obtain(
+                100, 200, MotionEvent.ACTION_CANCEL, 100, 10, 0);
+        contentRegionDown = MotionEvent.obtain(
+                100, 200, MotionEvent.ACTION_DOWN, 0, 0, 0);
+        contentRegionUp = MotionEvent.obtain(
+                100, 200, MotionEvent.ACTION_UP, 0, 0, 0);
+        contentRegionCancel = MotionEvent.obtain(
+                100, 200, MotionEvent.ACTION_CANCEL, 0, 0, 0);
+    }
+
+    @Test
+    public void setOnCloseListener_thenTouchCloseRegion_shouldCallOnClick() {
+        subject.setOnCloseListener(mockCloseListener);
+        subject.onTouchEvent(closeRegionDown);
+        subject.onTouchEvent(closeRegionUp);
+
+        verify(mockCloseListener).onClose();
+    }
+
+    @Test
+    public void setOnCloseListener_thenTouchContentRegion_shouldNotCallCloseListener() {
+        subject.setOnCloseListener(mockCloseListener);
+        subject.onTouchEvent(contentRegionDown);
+        subject.onTouchEvent(contentRegionUp);
+
+        verify(mockCloseListener, never()).onClose();
+    }
+
+    @Test
+    public void setCloseVisible_shouldToggleCloseDrawable() {
+        subject.setCloseVisible(false);
+        assertThat(subject.isCloseVisible()).isFalse();
+
+        subject.setCloseVisible(true);
+        assertThat(subject.isCloseVisible()).isTrue();
+    }
+
+    // setLeft, setTop, setRight, and setBottom, are not available before honeycomb. This
+    // annotation just supresses a warning.
+    @TargetApi(VERSION_CODES.HONEYCOMB)
+    @Test
+    public void draw_shouldUpdateCloseBounds() {
+        subject.setLeft(0);
+        subject.setTop(0);
+        subject.setRight(100);
+        subject.setBottom(200);
+        subject.onSizeChanged(100, 200, 0, 0);
+
+        int expectedTop = 0;
+        int expectedLeft = (int) (100 - CloseableLayout.CLOSE_REGION_SIZE_DP);
+        Canvas canvas = new Canvas();
+        subject.draw(canvas);
+        Rect closeBounds = subject.getCloseBounds();
+        assertThat(closeBounds.top).isEqualTo(expectedTop);
+        assertThat(closeBounds.bottom).isEqualTo(
+                (int) (expectedTop + CloseableLayout.CLOSE_REGION_SIZE_DP));
+        assertThat(closeBounds.left).isEqualTo(expectedLeft);
+        assertThat(closeBounds.right).isEqualTo(
+                (int) (expectedLeft + CloseableLayout.CLOSE_REGION_SIZE_DP));
+    }
+
+    @Test
+    public void draw_withoutCloseBoundsChanged_shouldNotUpdateCloseBounds() {
+        Canvas canvas = new Canvas();
+        subject.draw(canvas);
+        Rect originalCloseBounds = subject.getCloseBounds();
+
+        subject.setCloseBounds(new Rect(40, 41, 42, 43));
+        subject.setCloseBoundChanged(false);
+        subject.draw(canvas);
+
+        assertThat(subject.getCloseBounds()).isEqualTo(originalCloseBounds);
+    }
+
+    @Test
+    public void onInterceptTouchEvent_closeRegionDown_shouldReturnTrue() {
+        boolean intercepted = subject.onInterceptTouchEvent(closeRegionDown);
+        assertThat(intercepted).isTrue();
+    }
+
+    @Test public void onInterceptTouchEvent_contentRegionDown_returnsTrue() {
+        boolean intercepted = subject.onInterceptTouchEvent(contentRegionDown);
+        assertThat(intercepted).isFalse();
+    }
+
+    @Test
+    public void
+    onTouchEvent_closeRegionDown_thenCloseRegionUp_shouldTogglePressedStateAfterDelay() {
+        assertThat(subject.isClosePressed()).isFalse();
+
+        subject.onTouchEvent(closeRegionDown);
+        assertThat(subject.isClosePressed()).isTrue();
+
+        subject.onTouchEvent(closeRegionUp);
+        assertThat(subject.isClosePressed()).isTrue();
+
+        Robolectric.getUiThreadScheduler().advanceToLastPostedRunnable();
+        assertThat(subject.isClosePressed()).isFalse();
+    }
+
+    @Test
+    public void onTouchEvent_closeRegionDown_thenCloseRegionCancel_shouldTogglePressedState() {
+        subject.onTouchEvent(closeRegionDown);
+        subject.onTouchEvent(closeRegionCancel);
+        assertThat(subject.isClosePressed()).isFalse();
+    }
+
+    @Test
+    public void onTouchEvent_closeRegionDown_thenContentRegionCancel_shouldTogglePressedState() {
+        subject.onTouchEvent(closeRegionDown);
+        subject.onTouchEvent(contentRegionCancel);
+        assertThat(subject.isClosePressed()).isFalse();
+    }
+
+    @Test
+    public void pointInCloseBounds_noSlop_shouldReturnValidValues() {
+        Rect bounds = new Rect();
+        bounds.left = 10;
+        bounds.right = 20;
+        bounds.top = 100;
+        bounds.bottom = 200;
+        subject.setCloseBounds(bounds);
+
+        assertThat(subject.pointInCloseBounds(9, 99, 0)).isFalse();
+        assertThat(subject.pointInCloseBounds(9, 100, 0)).isFalse();
+        assertThat(subject.pointInCloseBounds(9, 199, 0)).isFalse();
+        assertThat(subject.pointInCloseBounds(9, 200, 0)).isFalse();
+        assertThat(subject.pointInCloseBounds(10, 99, 0)).isFalse();
+        assertThat(subject.pointInCloseBounds(10, 100, 0)).isTrue();
+        assertThat(subject.pointInCloseBounds(10, 199, 0)).isTrue();
+        assertThat(subject.pointInCloseBounds(10, 200, 0)).isFalse();
+
+        assertThat(subject.pointInCloseBounds(19, 99, 0)).isFalse();
+        assertThat(subject.pointInCloseBounds(19, 100, 0)).isTrue();
+        assertThat(subject.pointInCloseBounds(19, 199, 0)).isTrue();
+        assertThat(subject.pointInCloseBounds(19, 200, 0)).isFalse();
+        assertThat(subject.pointInCloseBounds(20, 99, 0)).isFalse();
+        assertThat(subject.pointInCloseBounds(20, 100, 0)).isFalse();
+        assertThat(subject.pointInCloseBounds(20, 199, 0)).isFalse();
+        assertThat(subject.pointInCloseBounds(20, 200, 0)).isFalse();
+
+    }
+
+    @Test
+    public void pointInCloseBounds_slop_shouldReturnValidValues() {
+        int slop = 3;
+
+        // Same as above, but adjust given 3 px slop
+        Rect bounds = new Rect();
+        bounds.left = 13;
+        bounds.right = 17;
+        bounds.top = 103;
+        bounds.bottom = 197;
+        subject.setCloseBounds(bounds);
+
+        assertThat(subject.pointInCloseBounds(9, 99, slop)).isFalse();
+        assertThat(subject.pointInCloseBounds(9, 100, slop)).isFalse();
+        assertThat(subject.pointInCloseBounds(9, 199, slop)).isFalse();
+        assertThat(subject.pointInCloseBounds(9, 200, slop)).isFalse();
+        assertThat(subject.pointInCloseBounds(10, 99, slop)).isFalse();
+        assertThat(subject.pointInCloseBounds(10, 100, slop)).isTrue();
+        assertThat(subject.pointInCloseBounds(10, 199, slop)).isTrue();
+        assertThat(subject.pointInCloseBounds(10, 200, slop)).isFalse();
+
+        assertThat(subject.pointInCloseBounds(19, 99, slop)).isFalse();
+        assertThat(subject.pointInCloseBounds(19, 100, slop)).isTrue();
+        assertThat(subject.pointInCloseBounds(19, 199, slop)).isTrue();
+        assertThat(subject.pointInCloseBounds(19, 200, slop)).isFalse();
+        assertThat(subject.pointInCloseBounds(20, 99, slop)).isFalse();
+        assertThat(subject.pointInCloseBounds(20, 100, slop)).isFalse();
+        assertThat(subject.pointInCloseBounds(20, 199, slop)).isFalse();
+        assertThat(subject.pointInCloseBounds(20, 200, slop)).isFalse();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/CreativeOrientationTest.java b/mopub-sdk/src/test/java/com/mopub/common/CreativeOrientationTest.java
new file mode 100644
index 00000000..0ea85803
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/CreativeOrientationTest.java
@@ -0,0 +1,43 @@
+package com.mopub.common;
+
+import org.junit.Test;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+public class CreativeOrientationTest {
+
+    @Test
+    public void fromHeader_nullParam_shouldBeUndefined() {
+        assertThat(CreativeOrientation.fromHeader(null)).isEqualTo(CreativeOrientation.UNDEFINED);
+    }
+
+    @Test
+    public void fromHeader_emptyParam_shouldBeUndefined() {
+        assertThat(CreativeOrientation.fromHeader("")).isEqualTo(CreativeOrientation.UNDEFINED);
+    }
+
+    @Test
+    public void fromHeader_withGarbage_shouldBeUndefined() {
+        assertThat(CreativeOrientation.fromHeader("p0rtr41t")).isEqualTo(CreativeOrientation.UNDEFINED);
+    }
+
+    @Test
+    public void fromHeader_lParam_shouldBeLandscape() {
+        assertThat(CreativeOrientation.fromHeader("l")).isEqualTo(CreativeOrientation.LANDSCAPE);
+    }
+
+    @Test
+    public void fromHeader_uppercaseL_shouldBeLandscape() {
+        assertThat(CreativeOrientation.fromHeader("L")).isEqualTo(CreativeOrientation.LANDSCAPE);
+    }
+
+    @Test
+    public void fromHeader_pParam_shouldBePortrait() {
+        assertThat(CreativeOrientation.fromHeader("p")).isEqualTo(CreativeOrientation.PORTRAIT);
+    }
+
+    @Test
+    public void fromHeader_uppercaseP_shouldBePortrait() {
+        assertThat(CreativeOrientation.fromHeader("P")).isEqualTo(CreativeOrientation.PORTRAIT);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/DownloadResponseTest.java b/mopub-sdk/src/test/java/com/mopub/common/DownloadResponseTest.java
index 741db09f..b0de5153 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/DownloadResponseTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/DownloadResponseTest.java
@@ -4,29 +4,44 @@
 import com.mopub.common.util.ResponseHeader;
 import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
 
+import org.apache.http.HttpResponse;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
 import java.util.Locale;
 
+import static org.fest.assertions.api.Assertions.assertThat;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
 public class DownloadResponseTest {
 
     DownloadResponse subject;
-    TestHttpResponseWithHeaders mockHttpResponse;
+    TestHttpResponseWithHeaders testHttpResponse;
 
     @Before
     public void setup() throws Exception {
-        mockHttpResponse = new TestHttpResponseWithHeaders(200, "abcde".getBytes());
-        mockHttpResponse.addHeader(ResponseHeader.CUSTOM_EVENT_NAME.getKey(), "testCustomEvent");
-        mockHttpResponse.addHeader(ResponseHeader.CLICKTHROUGH_URL.getKey().toLowerCase(Locale.US), "http://example.com/");
-        mockHttpResponse.addHeader(ResponseHeader.FAIL_URL.getKey().toUpperCase(Locale.US), "http://mopub.com/");
-        subject = new DownloadResponse(mockHttpResponse);
+        testHttpResponse = new TestHttpResponseWithHeaders(200, "abcde".getBytes());
+        testHttpResponse.addHeader(ResponseHeader.CUSTOM_EVENT_NAME.getKey(), "testCustomEvent");
+        testHttpResponse.addHeader(ResponseHeader.CLICK_TRACKING_URL.getKey().toLowerCase(Locale.US), "http://example.com/");
+        testHttpResponse.addHeader(ResponseHeader.FAIL_URL.getKey().toUpperCase(Locale.US), "http://mopub.com/");
+        subject = new DownloadResponse(testHttpResponse);
+    }
+
+    @Test
+    public void constructor_withNullHttpEntity_shouldNotThrowNullPointerException() throws Exception {
+        HttpResponse mockHttpResponse = mock(HttpResponse.class);
+        when(mockHttpResponse.getEntity()).thenReturn(null);
+        when(mockHttpResponse.getStatusLine()).thenReturn(testHttpResponse.new TestStatusLine());
+
+        DownloadResponse downloadResponse = new DownloadResponse(mockHttpResponse);
+        assertThat(downloadResponse.getContentLength()).isEqualTo(0);
+        assertThat(downloadResponse.getByteArray()).isEmpty();
     }
 
     @Test
@@ -47,7 +62,7 @@ public void testGetContentLength() throws Exception {
     @Test
     public void testGetFirstHeader_caseInsensitive() throws Exception {
         assertEquals("testCustomEvent", subject.getFirstHeader(ResponseHeader.CUSTOM_EVENT_NAME));
-        assertEquals("http://example.com/", subject.getFirstHeader(ResponseHeader.CLICKTHROUGH_URL));
+        assertEquals("http://example.com/", subject.getFirstHeader(ResponseHeader.CLICK_TRACKING_URL));
         assertEquals("http://mopub.com/", subject.getFirstHeader(ResponseHeader.FAIL_URL));
         assertNull(subject.getFirstHeader(ResponseHeader.CUSTOM_EVENT_DATA));
     }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/DownloadTaskTest.java b/mopub-sdk/src/test/java/com/mopub/common/DownloadTaskTest.java
index cfa1702f..bbe1b484 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/DownloadTaskTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/DownloadTaskTest.java
@@ -18,7 +18,9 @@
 
 import static junit.framework.Assert.fail;
 import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 
 @RunWith(SdkTestRunner.class)
@@ -45,27 +47,26 @@ public void setUp() {
         mTestResponse = "TEST RESPONSE";
         mTestHttpResponseWithHeaders = new TestHttpResponseWithHeaders(200, mTestResponse);
         mTestHttpResponseWithHeaders.addHeader(ResponseHeader.IMPRESSION_URL.getKey(), "moPubImpressionTrackerUrl");
-        mTestHttpResponseWithHeaders.addHeader(ResponseHeader.CLICKTHROUGH_URL.getKey(), "moPubClickTrackerUrl");
+        mTestHttpResponseWithHeaders.addHeader(ResponseHeader.CLICK_TRACKING_URL.getKey(), "moPubClickTrackerUrl");
 
         mFakeHttpLayer = Robolectric.getFakeHttpLayer();
     }
 
     @Test
-    public void execute_whenDownloadTaskAndHttpClientCompleteSuccessfully_shouldReturn200HttpResponse() {
+    public void whenDownloadTaskAndHttpClientCompleteSuccessfully_shouldReturn200HttpResponse() {
         mFakeHttpLayer.addPendingHttpResponse(mTestHttpResponseWithHeaders);
         mDownloadTask.execute(httpGet);
 
-        verify(mockDownloadTaskListener).onComplete(eq(httpGet.getURI().toString()),
-                responseCaptor.capture());
+        verify(mockDownloadTaskListener).onComplete(eq(httpGet.getURI().toString()), responseCaptor.capture());
         DownloadResponse response = responseCaptor.getValue();
         assertThat(response.getStatusCode()).isEqualTo(200);
         assertThat(response.getFirstHeader(ResponseHeader.IMPRESSION_URL)).isEqualTo("moPubImpressionTrackerUrl");
-        assertThat(response.getFirstHeader(ResponseHeader.CLICKTHROUGH_URL)).isEqualTo("moPubClickTrackerUrl");
+        assertThat(response.getFirstHeader(ResponseHeader.CLICK_TRACKING_URL)).isEqualTo("moPubClickTrackerUrl");
         assertThat(HttpResponses.asResponseString(response)).isEqualTo(mTestResponse);
     }
 
     @Test
-    public void execute_whenDownloadTaskCompletesSuccessfullyAndHttpClientTimesOut_shouldReturn599HttpResponse() {
+    public void whenDownloadTaskCompletesSuccessfullyAndHttpClientTimesOut_shouldReturn599HttpResponse() {
         mFakeHttpLayer.addPendingHttpResponse(599, "");
         mDownloadTask.execute(httpGet);
 
@@ -77,40 +78,35 @@ public void execute_whenDownloadTaskCompletesSuccessfullyAndHttpClientTimesOut_s
     }
 
     @Test
-    public void execute_whenDownloadTaskIsCancelledBeforeExecute_shouldReturnNullHttpReponseAndNullUrl() {
+    public void whenDownloadTaskIsCancelledBeforeExecute_shouldNotCallOnComplete() {
         mFakeHttpLayer.addPendingHttpResponse(200, mTestResponse);
         mDownloadTask.cancel(true);
         mDownloadTask.execute(httpGet);
 
-        verify(mockDownloadTaskListener).onComplete(null, null);
+        verify(mockDownloadTaskListener, never()).onComplete(
+                any(String.class), any(DownloadResponse.class));
     }
 
     @Ignore("pending")
     @Test
-        // need a way to reliably cancel task during doInBackground
-    public void execute_whenDownloadTaskIsCancelledDuringDoInBackground_shouldReturnNullHttpReponse() {
-    }
-
-    @Ignore("pending")
-    @Test
-    public void execute_whenHttpUriRequestThrowsIOException_shouldCancelTaskAndReturnNullHttpResponse() {
+    public void whenHttpUriRequestThrowsIOException_shouldCancelTaskAndReturnNullHttpResponse() {
         // need a way to force HttpUriRequest to throw on execute
     }
 
     @Test
-    public void execute_whenHttpUriRequestIsNull_shouldReturnNullHttpReponseAndNullUrl() {
+    public void whenHttpUriRequestIsNull_shouldReturnNullHttpReponseAndNullUrl() {
         mDownloadTask.execute((HttpUriRequest) null);
         verify(mockDownloadTaskListener).onComplete(null, null);
     }
 
     @Test
-    public void execute_whenHttpUriRequestIsNullArray_shouldReturnNullHttpReponseAndNullUrl() {
+    public void whenHttpUriRequestIsNullArray_shouldReturnNullHttpReponseAndNullUrl() {
         mDownloadTask.execute((HttpUriRequest[]) null);
         verify(mockDownloadTaskListener).onComplete(null, null);
     }
 
     @Test
-    public void execute_whenHttpUriRequestIsArray_shouldOnlyReturnFirstResponse() {
+    public void whenHttpUriRequestIsArray_shouldOnlyReturnFirstResponse() {
         mFakeHttpLayer.addPendingHttpResponse(200, mTestResponse);
         mFakeHttpLayer.addPendingHttpResponse(500, "");
         mDownloadTask.execute(httpGet, new HttpGet("http://www.twitter.com/"));
@@ -123,13 +119,8 @@ public void execute_whenHttpUriRequestIsArray_shouldOnlyReturnFirstResponse() {
         assertThat(HttpResponses.asResponseString(response)).isEqualTo(mTestResponse);
     }
 
-    @Test
-    public void downLoadTask_whenConstructedWithNullListener_shouldThrowIllegalArgumentException() {
-        try {
-            new DownloadTask(null);
-            fail("DownloadTask didn't throw IllegalArgumentException when constructed with null");
-        } catch (IllegalArgumentException e) {
-            // passed
-        }
+    @Test(expected = IllegalArgumentException.class)
+    public void constructor_withNullListener_shouldThrowIllegalArgumentException() {
+        new DownloadTask(null);
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/GpsHelperTest.java b/mopub-sdk/src/test/java/com/mopub/common/GpsHelperTest.java
index a35aa96f..f5b8a175 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/GpsHelperTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/GpsHelperTest.java
@@ -300,7 +300,7 @@ private void safeAcquireSemaphore() throws Exception {
 
     static public void verifyClientMetadata(Context context, TestAdInfo adInfo) {
         ClientMetadata clientMetadata = ClientMetadata.getInstance(context);
-        assertThat(clientMetadata.getAdvertisingId()).isEqualTo("ifa:" + adInfo.getId());
+        assertThat(clientMetadata.getDeviceId()).isEqualTo("ifa:" + adInfo.getId());
         assertThat(clientMetadata.isDoNotTrackSet()).isEqualTo(adInfo.isLimitAdTrackingEnabled());
     }
 
diff --git a/mopub-sdk/src/test/java/com/mopub/common/HttpClientTest.java b/mopub-sdk/src/test/java/com/mopub/common/HttpClientTest.java
index 48f721bb..c00f14fb 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/HttpClientTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/HttpClientTest.java
@@ -4,7 +4,6 @@
 import android.webkit.WebView;
 
 import com.mopub.common.util.ResponseHeader;
-import com.mopub.common.util.test.support.CommonUtils;
 
 import org.apache.http.HttpRequest;
 import org.apache.http.client.methods.HttpGet;
@@ -17,8 +16,9 @@
 import org.robolectric.tester.org.apache.http.RequestMatcher;
 import org.robolectric.tester.org.apache.http.TestHttpResponse;
 
+import static com.mopub.common.HttpClient.getWebViewUserAgent;
 import static com.mopub.common.HttpClient.initializeHttpGet;
-import static junit.framework.Assert.fail;
+import static com.mopub.common.HttpClient.urlEncode;
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(RobolectricTestRunner.class)
@@ -29,7 +29,7 @@
 
     @Before
     public void setup() {
-        context = new Activity();
+        context = Robolectric.buildActivity(Activity.class).create().get();
         userAgent = new WebView(context).getSettings().getUserAgentString();
 
         Robolectric.addHttpResponseRule(new RequestMatcher() {
@@ -69,50 +69,86 @@ public void initializeHttpGet_shouldPopulateStaticWebViewUserAgent() throws Exce
     }
 
     @Test
-    public void initializeHttpGet_withNullUrl_shouldThrowNullPointerException() throws Exception {
-        try {
-            HttpGet httpGet = initializeHttpGet(null, context);
-            fail("Expecting null pointer expection to be thrown");
-        } catch (NullPointerException e) {
-            // pass
-        }
+    public void initializeHttpGet_withNullContext_shouldNotSetUserAgent() throws Exception {
+        HttpGet httpGet = initializeHttpGet("http://www.mopub.com/");
+        assertThat(httpGet.getFirstHeader(ResponseHeader.USER_AGENT.getKey())).isNull();
     }
 
     @Test
-    public void initializeHttpGet_withNullContext_shouldNotPopulateUserAgentHeader() throws Exception {
-        HttpGet httpGet = initializeHttpGet(url, null);
+    public void initializeHttpGet_shouldProperlyEncodeUrl() throws Exception {
+        HttpGet httpGet = initializeHttpGet("http://host:80/doc|search?q=green robots#over 6\"");
+        assertThat(httpGet.getURI().toString())
+                .isEqualTo("http://host:80/doc%7Csearch?q=green%20robots#over%206%22");
+    }
 
-        assertThat(httpGet.getURI().toURL().toString()).isEqualTo(url);
-        assertThat(httpGet.getFirstHeader(ResponseHeader.USER_AGENT.getKey())).isNull();
+    @Test(expected = IllegalArgumentException.class)
+    public void initializeHttpGet_withImproperlyEncodedUrl_shouldThrowIllegalArgumentException() throws Exception {
+        initializeHttpGet("http://user:passwrd@host:80/doc%7ZZZC");
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void initializeHttpGet_withMalformedUrl_shouldThrowIllegalArgumentException() throws Exception {
+        initializeHttpGet("bad://host:80/doc|search?q=green robots#over 6\"");
     }
 
     @Test
-    public void makeTrackingHttpRequest_shouldMakeTrackingHttpRequestWithWebViewUserAgent() throws Exception {
-        HttpClient.makeTrackingHttpRequest(url, context);
+    public void urlEncode_shouldProperlyEncodeUrls() throws Exception {
+        // Example url borrowed from: http://developer.android.com/reference/java/net/URI.html
+        assertThat(urlEncode("http://user:passwrd@host:80/doc|search?q=green robots#over 6\""))
+                .isEqualTo("http://user:passwrd@host:80/doc%7Csearch?q=green%20robots#over%206%22");
+
+        assertThat(urlEncode("http://www.example.com/?key=value\"\"&key2=value2?"))
+                .isEqualTo("http://www.example.com/?key=value%22%22&key2=value2?");
 
-        Robolectric.getBackgroundScheduler().unPause();
-        Thread.sleep(500);
+        assertThat(urlEncode("http://user:passwrd@host:80/doc?q=green#robots"))
+                .isEqualTo("http://user:passwrd@host:80/doc?q=green#robots");
 
-        CommonUtils.assertHttpRequestsMade(userAgent, url);
+        assertThat(urlEncode("http://rtr.innovid.com/r1.5460f51c393410.96367393;cb=[timestamp]"))
+                .isEqualTo("http://rtr.innovid.com/r1.5460f51c393410.96367393;cb=%5Btimestamp%5D");
     }
 
     @Test
-    public void makeTrackingHttpRequest_withNullUrl_shouldNotMakeTrackingHttpRequest() throws Exception {
-        HttpClient.makeTrackingHttpRequest((String) null, context);
+    public void urlEncode_withProperlyEncodedUrl_shouldReturnUrlWithSameEncoding() throws Exception {
+        assertThat(urlEncode("http://user:passwrd@host:80/doc%7Csearch?q=green%20robots#over%206%22"))
+                .isEqualTo("http://user:passwrd@host:80/doc%7Csearch?q=green%20robots#over%206%22");
 
-        Robolectric.getBackgroundScheduler().unPause();
-        Thread.sleep(500);
+        assertThat(urlEncode("https://www.mywebsite.com%2Fd+ocs%2Fenglish%2Fsite%2Fmybook.do%3Fkey%3Dvalue%3B%23fragment"))
+                .isEqualTo("https://www.mywebsite.com%2Fd+ocs%2Fenglish%2Fsite%2Fmybook.do%3Fkey%3Dvalue%3B%23fragment");
+    }
 
-        CommonUtils.assertHttpRequestsMade(null);
+    @Test(expected = Exception.class)
+    public void urlEncode_withImproperlyEncodedUrl_shouldThowException() throws Exception {
+        urlEncode("http://user:passwrd@host:80/doc%7ZZZC");
+    }
+
+
+    @Test(expected = Exception.class)
+    public void urlEncode_withImproperlyEncodedUrlScheme_shouldThowException() throws Exception {
+        // From: http://developer.android.com/reference/java/net/URI.html
+        // A URI's host, port and scheme are not eligible for encoding and must not contain illegal characters.
+        urlEncode("https%3A%2F%2Fwww.mywebsite.com%2Fdocs%2Fenglish%2Fsite%2Fmybook.do%3Fkey%3Dvalue%3B%23fragment");
+    }
+
+    @Test(expected = Exception.class)
+    public void urlEncode_withMalformedUrl_shouldThrowException() throws Exception {
+        urlEncode("derp://www.mopub.com/");
     }
 
     @Test
-    public void makeTrackingHttpRequest_withNullContext_shouldNotMakeTrackingHttpRequest() throws Exception {
-        HttpClient.makeTrackingHttpRequest(url, null);
+    public void getWebViewUserAgent_whenUserAgentNotSet_shouldReturnDefault() {
+        assertThat(getWebViewUserAgent("test")).isEqualTo("test");
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void initializeHttpGet_withNullUrl_shouldThrowNullPointerException() throws Exception {
+        initializeHttpGet(null, context);
+    }
 
-        Robolectric.getBackgroundScheduler().unPause();
-        Thread.sleep(500);
+    @Test
+    public void initializeHttpGet_withNullContext_shouldNotPopulateUserAgentHeader() throws Exception {
+        HttpGet httpGet = initializeHttpGet(url, null);
 
-        CommonUtils.assertHttpRequestsMade(null);
+        assertThat(httpGet.getURI().toURL().toString()).isEqualTo(url);
+        assertThat(httpGet.getFirstHeader(ResponseHeader.USER_AGENT.getKey())).isNull();
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/MoPubBrowserTest.java b/mopub-sdk/src/test/java/com/mopub/common/MoPubBrowserTest.java
new file mode 100644
index 00000000..b28038c6
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/MoPubBrowserTest.java
@@ -0,0 +1,71 @@
+package com.mopub.common;
+
+import android.annotation.TargetApi;
+import android.os.Build;
+import android.webkit.CookieSyncManager;
+import android.webkit.WebView;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+@RunWith(SdkTestRunner.class)
+public class MoPubBrowserTest {
+
+    private MoPubBrowser subject;
+    private WebView mockWebView;
+
+    @Before
+    public void setUp() {
+        subject = new MoPubBrowser();
+        CookieSyncManager.createInstance(subject);
+
+        mockWebView = mock(WebView.class);
+        subject.setWebView(mockWebView);
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
+    @Test
+    public void onPause_withIsFinishingTrue_shouldStopLoading_shouldLoadBlankUrl_shouldPauseWebView() throws Exception {
+        // We have to manually call #onPause here after #finish since the activity is not being managed by Android
+        // Even if the activity was being managed by Android we would likely have to call onPause since the test would
+        // complete before the UI thread had a chance to invoke the lifecycle events
+        subject.finish();
+        subject.onPause();
+
+        verify(mockWebView).stopLoading();
+        verify(mockWebView).loadUrl("");
+        verify(mockWebView).onPause();
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
+    @Test
+    public void onPause_withIsFinishingFalse_shouldPauseWebView() throws Exception {
+        subject.onPause();
+
+        verify(mockWebView, never()).stopLoading();
+        verify(mockWebView, never()).loadUrl("");
+        verify(mockWebView).onPause();
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
+    @Test
+    public void onResume_shouldResumeWebView() throws Exception {
+        subject.onResume();
+
+        verify(mockWebView).onResume();
+    }
+
+    @Test
+    public void onDestroy_shouldDestroyWebView() throws Exception {
+        subject.onDestroy();
+
+        verify(mockWebView).destroy();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/VolleyRequestMatcher.java b/mopub-sdk/src/test/java/com/mopub/common/VolleyRequestMatcher.java
new file mode 100644
index 00000000..8afeb57d
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/VolleyRequestMatcher.java
@@ -0,0 +1,33 @@
+package com.mopub.common;
+
+import android.support.annotation.Nullable;
+
+import com.mopub.volley.Request;
+
+import org.mockito.ArgumentMatcher;
+
+/**
+ * A Mockito Request Matcher, used in tests to allow verifying that Volley Requests match a given
+ * url.
+ *
+ * "verify(mock).add(argThat(VolleyRequestMatcher.isUrl("testUrl")));"
+ */
+public class VolleyRequestMatcher extends ArgumentMatcher<Request> {
+
+     @Nullable private final String mUrl;
+
+     private VolleyRequestMatcher(@Nullable final String url) {
+         mUrl = url;
+     }
+
+     public static VolleyRequestMatcher isUrl(@Nullable String url) {
+         return new VolleyRequestMatcher(url);
+     }
+
+     @Override
+     public boolean matches(final Object that) {
+         return that instanceof Request
+                 && ((this.mUrl == null && ((Request) that).getUrl() == null)
+                    || ((Request) that).getUrl().equals(mUrl));
+     }
+ }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/BaseEventTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/BaseEventTest.java
new file mode 100644
index 00000000..55a087f4
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/BaseEventTest.java
@@ -0,0 +1,244 @@
+package com.mopub.common.event;
+
+import com.mopub.common.ClientMetadata;
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class BaseEventTest {
+
+    private BaseEvent subject;
+    @Mock private ClientMetadata mockClientMetaData;
+
+    @Before
+    public void setUp() {
+        when(mockClientMetaData.getSdkVersion()).thenReturn("sdk_version");
+        when(mockClientMetaData.getAppName()).thenReturn("app_name");
+        when(mockClientMetaData.getAppPackageName()).thenReturn("app_package_name");
+        when(mockClientMetaData.getAppVersion()).thenReturn("app_version");
+        when(mockClientMetaData.getDeviceId()).thenReturn("client_device_id");
+        when(mockClientMetaData.isDoNotTrackSet()).thenReturn(true);
+        when(mockClientMetaData.getDeviceManufacturer()).thenReturn("device_manufacturer");
+        when(mockClientMetaData.getDeviceModel()).thenReturn("device_model");
+        when(mockClientMetaData.getDeviceProduct()).thenReturn("device_product");
+        when(mockClientMetaData.getDeviceOsVersion()).thenReturn("device_os_version");
+        when(mockClientMetaData.getDeviceScreenWidthDip()).thenReturn(1337);
+        when(mockClientMetaData.getDeviceScreenHeightDip()).thenReturn(70707);
+        when(mockClientMetaData.getActiveNetworkType()).thenReturn(ClientMetadata.MoPubNetworkType.WIFI);
+        when(mockClientMetaData.getNetworkOperator()).thenReturn("network_operator");
+        when(mockClientMetaData.getNetworkOperatorName()).thenReturn("network_operator_name");
+        when(mockClientMetaData.getIsoCountryCode()).thenReturn("network_iso_country_code");
+        when(mockClientMetaData.getSimOperator()).thenReturn("network_sim_operator");
+        when(mockClientMetaData.getSimOperatorName()).thenReturn("network_sim_operator_name");
+        when(mockClientMetaData.getSimIsoCountryCode()).thenReturn("network_sim_iso_country_code");
+        ClientMetadata.setInstance(mockClientMetaData);
+
+        subject = new Event.Builder(BaseEvent.Name.AD_REQUEST, BaseEvent.Category.REQUESTS, 0.10000123)
+                .withSdkProduct(BaseEvent.SdkProduct.NATIVE)
+                .withAdUnitId("8cf00598d3664adaaeccd800e46afaca")
+                .withAdCreativeId("3c2b887e2c2a4cd0ae6a925440a62f0d")
+                .withAdType("html")
+                .withAdNetworkType("admob")
+                .withAdWidthPx(320.0)
+                .withAdHeightPx(50.0)
+                .withGeoLat(37.7833)
+                .withGeoLon(-122.4183333)
+                .withGeoAccuracy(10.0)
+                .withPerformanceDurationMs(100.0)
+                .withRequestId("b550796074da4559a27c5072dcba2b27")
+                .withRequestStatusCode(200)
+                .withRequestUri("http://ads.mopub.com/m/ad?id=8cf00598d3664adaaeccd800e46afaca")
+                .withRequestRetries(0)
+                .build();
+    }
+
+    @After
+    public void tearDown() {
+        ClientMetadata.setInstance(null);
+    }
+
+    @Test
+    public void ScribeCategory_shouldHaveExpectedValues() throws Exception {
+        // We're testing this since our backend data definitions depend on these values matching
+        assertThat(BaseEvent.ScribeCategory.EXCHANGE_CLIENT_EVENT.getCategory())
+                .isEqualTo("exchange_client_event");
+        assertThat(BaseEvent.ScribeCategory.EXCHANGE_CLIENT_ERROR.getCategory())
+                .isEqualTo("exchange_client_error");
+    }
+
+    @Test
+    public void SdkProduct_shouldHaveExpectedValues() throws Exception {
+        // We're testing this since our backend data definitions depend on these values matching
+        assertThat(BaseEvent.SdkProduct.NONE.getType())
+                .isEqualTo(0);
+        assertThat(BaseEvent.SdkProduct.WEB_VIEW.getType())
+                .isEqualTo(1);
+        assertThat(BaseEvent.SdkProduct.NATIVE.getType())
+                .isEqualTo(2);
+    }
+
+    @Test
+    public void AppPlatform_shouldHaveExpectedValues() throws Exception {
+        // We're testing this since our backend data definitions depend on these values matching
+        assertThat(BaseEvent.AppPlatform.NONE.getType())
+                .isEqualTo(0);
+        assertThat(BaseEvent.AppPlatform.IOS.getType())
+                .isEqualTo(1);
+        assertThat(BaseEvent.AppPlatform.ANDROID.getType())
+                .isEqualTo(2);
+        assertThat(BaseEvent.AppPlatform.MOBILE_WEB.getType())
+                .isEqualTo(3);
+    }
+
+    @Test
+    public void Name_shouldHaveExpectedValues() throws Exception {
+        // We're testing this since our backend data definitions depend on these values matching
+        assertThat(BaseEvent.Name.AD_REQUEST.getName())
+                .isEqualTo("ad_request");
+        assertThat(BaseEvent.Name.IMPRESSION_REQUEST.getName())
+                .isEqualTo("impression_request");
+        assertThat(BaseEvent.Name.CLICK_REQUEST.getName())
+                .isEqualTo("click_request");
+    }
+
+    @Test
+    public void Category_shouldHaveExpectedValues() throws Exception {
+        // We're testing this since our backend data definitions depend on these values matching
+        assertThat(BaseEvent.Category.REQUESTS.getCategory())
+                .isEqualTo("requests");
+    }
+
+    @Test
+    public void SamplingRate_shouldHaveExpectedValues() throws Exception {
+        // We're testing this since our backend data definitions depend on these values matching
+        assertThat(BaseEvent.SamplingRate.AD_REQUEST.getSamplingRate()).isEqualTo(0.1);
+    }
+
+    @Test
+    public void constructor_shouldCorrectlyAssignFieldsFromBuilder() throws Exception {
+        assertThat(subject.getSdkProduct()).isEqualTo(BaseEvent.SdkProduct.NATIVE);
+        assertThat(subject.getAdUnitId()).isEqualTo("8cf00598d3664adaaeccd800e46afaca");
+        assertThat(subject.getAdCreativeId()).isEqualTo("3c2b887e2c2a4cd0ae6a925440a62f0d");
+        assertThat(subject.getAdType()).isEqualTo("html");
+        assertThat(subject.getAdNetworkType()).isEqualTo("admob");
+        assertThat(subject.getAdWidthPx()).isEqualTo(320.0);
+        assertThat(subject.getAdHeightPx()).isEqualTo(50.0);
+        assertThat(subject.getGeoLat()).isEqualTo(37.7833);
+        assertThat(subject.getGeoLon()).isEqualTo(-122.4183333);
+        assertThat(subject.getGeoAccuracy()).isEqualTo(10.0);
+        assertThat(subject.getPerformanceDurationMs()).isEqualTo(100.0);
+        assertThat(subject.getRequestId()).isEqualTo("b550796074da4559a27c5072dcba2b27");
+        assertThat(subject.getRequestStatusCode()).isEqualTo(200);
+        assertThat(subject.getRequestUri()).isEqualTo("http://ads.mopub.com/m/ad?id=8cf00598d3664adaaeccd800e46afaca");
+        assertThat(subject.getRequestRetries()).isEqualTo(0);
+        assertThat(subject.getSamplingRate()).isEqualTo(0.10000123);
+    }
+
+    @Test
+    public void getSdkVersion_shouldReturnClientMetaDataSdkVersion() throws Exception {
+        assertThat(subject.getSdkVersion()).isEqualTo("sdk_version");
+    }
+
+    @Test
+    public void getAppName_shouldReturnClientMetaDataAppName() throws Exception {
+        assertThat(subject.getAppName()).isEqualTo("app_name");
+    }
+
+    @Test
+    public void getAppPackageName_shouldReturnClientMetaDataAppPackageName() throws Exception {
+        assertThat(subject.getAppPackageName()).isEqualTo("app_package_name");
+    }
+
+    @Test
+    public void getAppVersion_shouldReturnClientMetaDataAppVersion() throws Exception {
+        assertThat(subject.getAppVersion()).isEqualTo("app_version");
+    }
+
+    @Test
+    public void getClientAdvertisingId_shouldReturnClientMetaDataDeviceId() throws Exception {
+        assertThat(subject.getClientAdvertisingId()).isEqualTo("client_device_id");
+    }
+
+    @Test
+    public void getObfuscatedClientAdvertisingId_shouldReturnObfuscatedDeviceId() throws Exception {
+        assertThat(subject.getObfuscatedClientAdvertisingId()).isEqualTo("ifa:XXXX");
+    }
+
+    @Test
+    public void getClientDoNotTrack_shouldReturnClientMetaDataDoNotTrack() throws Exception {
+        assertThat(subject.getClientDoNotTrack()).isEqualTo(true);
+    }
+
+    @Test
+    public void getDeviceManufacturer_shouldReturnClientMetaDataDeviceManufacturer() throws Exception {
+        assertThat(subject.getDeviceManufacturer()).isEqualTo("device_manufacturer");
+    }
+
+    @Test
+    public void getDeviceModel_shouldReturnClientMetaDataDeviceModel() throws Exception {
+        assertThat(subject.getDeviceModel()).isEqualTo("device_model");
+    }
+
+    @Test
+    public void getDeviceProduct_shouldReturnClientMetaDataDeviceProduct() throws Exception {
+        assertThat(subject.getDeviceProduct()).isEqualTo("device_product");
+    }
+
+    @Test
+    public void getDeviceOsVersion_shouldReturnClientMetaDataDeviceOsVersion() throws Exception {
+        assertThat(subject.getDeviceOsVersion()).isEqualTo("device_os_version");
+    }
+
+    @Test
+    public void getDeviceScreenWidthDip_shouldReturnClientMetaDataDeviceScreenWidthDip() throws Exception {
+        assertThat(subject.getDeviceScreenWidthDip()).isEqualTo(1337);
+    }
+
+    @Test
+    public void getDeviceScreenHeightDip_shouldReturnClientMetaDataDeviceScreenHeightDip() throws Exception {
+        assertThat(subject.getDeviceScreenHeightDip()).isEqualTo(70707);
+    }
+
+    @Test
+    public void getNetworkType_shouldReturnClientMetaDataActiveNetworkType() throws Exception {
+        assertThat(subject.getNetworkType()).isEqualTo(ClientMetadata.MoPubNetworkType.WIFI);
+    }
+
+    @Test
+    public void getNetworkOperatorCode_shouldReturnClientMetaDataNetworkOperator() throws Exception {
+        assertThat(subject.getNetworkOperatorCode()).isEqualTo("network_operator");
+    }
+
+    @Test
+    public void getNetworkOperatorName_shouldReturnClientMetaDataNetworkOperatorName() throws Exception {
+        assertThat(subject.getNetworkOperatorName()).isEqualTo("network_operator_name");
+    }
+
+    @Test
+    public void getNetworkIsoCountryCode_shouldReturnClientMetaDataNetworkIsoCountryCode() throws Exception {
+        assertThat(subject.getNetworkIsoCountryCode()).isEqualTo("network_iso_country_code");
+    }
+
+    @Test
+    public void getNetworkSimCode_shouldReturnClientMetaDataNetworkSimOperator() throws Exception {
+        assertThat(subject.getNetworkSimCode()).isEqualTo("network_sim_operator");
+    }
+
+    @Test
+    public void getNetworkSimOperatorName_shouldReturnClientMetaDataNetworkSimOperatorName() throws Exception {
+        assertThat(subject.getNetworkSimOperatorName()).isEqualTo("network_sim_operator_name");
+    }
+
+    @Test
+    public void getNetworkSimIsoCountryCode_shouldReturnClientMetaDataNetworkSimIsoCountryCode() throws Exception {
+        assertThat(subject.getNetworkSimIsoCountryCode()).isEqualTo("network_sim_iso_country_code");
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/ErrorEventTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/ErrorEventTest.java
new file mode 100644
index 00000000..05cd07f6
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/ErrorEventTest.java
@@ -0,0 +1,74 @@
+package com.mopub.common.event;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+public class ErrorEventTest {
+
+    private ErrorEvent subject;
+
+    @Before
+    public void setUp() {
+        subject = new ErrorEvent.Builder(BaseEvent.Name.AD_REQUEST, BaseEvent.Category.REQUESTS, 0.10000123)
+                .withErrorExceptionClassName("error_exception_class_name")
+                .withErrorMessage("error_message")
+                .withErrorStackTrace("error_stack_trace")
+                .withErrorFileName("error_file_name")
+                .withErrorClassName("error_class_name")
+                .withErrorMethodName("error_method_name")
+                .withErrorLineNumber(123)
+                .build();
+    }
+
+    @Test
+    public void constructor_shouldCorrectlyAssignFieldsFromBuilder() throws Exception {
+        assertThat(subject.getName()).isEqualTo(BaseEvent.Name.AD_REQUEST);
+        assertThat(subject.getCategory()).isEqualTo(BaseEvent.Category.REQUESTS);
+        assertThat(subject.getSamplingRate()).isEqualTo(0.10000123);
+        assertThat(subject.getScribeCategory()).isEqualTo(BaseEvent.ScribeCategory.EXCHANGE_CLIENT_ERROR);
+        assertThat(subject.getErrorExceptionClassName()).isEqualTo("error_exception_class_name");
+        assertThat(subject.getErrorMessage()).isEqualTo("error_message");
+        assertThat(subject.getErrorStackTrace()).isEqualTo("error_stack_trace");
+        assertThat(subject.getErrorFileName()).isEqualTo("error_file_name");
+        assertThat(subject.getErrorClassName()).isEqualTo("error_class_name");
+        assertThat(subject.getErrorMethodName()).isEqualTo("error_method_name");
+        assertThat(subject.getErrorLineNumber()).isEqualTo(123);
+    }
+
+    @Test
+    public void builder_withException_shouldCorrectlyPopulateErrorFields() throws Exception {
+        Exception exception;
+        try {
+            throw new ClassCastException("bad cast");
+        } catch (Exception e)  {
+            exception = e;
+        }
+
+        subject = new ErrorEvent.Builder(BaseEvent.Name.AD_REQUEST, BaseEvent.Category.REQUESTS, 0.10000123)
+                .withException(exception)
+                .build();
+
+        assertThat(subject.getName()).isEqualTo(BaseEvent.Name.AD_REQUEST);
+        assertThat(subject.getCategory()).isEqualTo(BaseEvent.Category.REQUESTS);
+        assertThat(subject.getScribeCategory()).isEqualTo(BaseEvent.ScribeCategory.EXCHANGE_CLIENT_ERROR);
+        assertThat(subject.getErrorExceptionClassName()).isEqualTo("java.lang.ClassCastException");
+        assertThat(subject.getErrorMessage()).isEqualTo("bad cast");
+
+        // We can't reliably check the stack trace since it changes from one run to another
+//        assertThat(subject.getErrorStackTrace()).isEqualTo();
+
+        assertThat(subject.getErrorFileName()).isEqualTo("ErrorEventTest.java");
+        assertThat(subject.getErrorClassName()).isEqualTo("com.mopub.common.event.ErrorEventTest");
+        assertThat(subject.getErrorMethodName()).isEqualTo("builder_withException_shouldCorrectlyPopulateErrorFields");
+
+        // Ideally we check the actual line number here, but since this file is continuously
+        // changing, it makes the test brittle to do so
+        assertThat(subject.getErrorLineNumber()).isNotNull();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/EventDispatcherTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/EventDispatcherTest.java
new file mode 100644
index 00000000..1c32fd16
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/EventDispatcherTest.java
@@ -0,0 +1,64 @@
+package com.mopub.common.event;
+
+import android.app.Activity;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.Message;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+
+@RunWith(SdkTestRunner.class)
+public class EventDispatcherTest {
+
+    private EventDispatcher subject;
+    private List<EventRecorder> recorders;
+    @Mock private EventRecorder mockEventRecorder1;
+    @Mock private EventRecorder mockEventRecorder2;
+    @Mock private HandlerThread mockHandlerThread;
+
+    @Before
+    public void setUp() {
+        recorders = new ArrayList<EventRecorder>();
+        recorders.add(mockEventRecorder1);
+        recorders.add(mockEventRecorder2);
+    }
+
+    @Test
+    public void handler_handleMessage_shouldCallRecordOnAllRecorders() throws Exception {
+        Message message = new Message();
+        message.obj = mock(Event.class);
+
+        subject = new EventDispatcher(recorders, Looper.getMainLooper());
+        subject.getHandlerCallback().handleMessage(message);
+
+        verify(mockEventRecorder1).record(eq((Event) message.obj));
+        verify(mockEventRecorder2).record(eq((Event) message.obj));
+    }
+
+    @Test
+    public void handler_handleMessage_withNonBaseEventTypeMessageShouldNotRecordOnAnyRecorders() throws Exception {
+        Message message = new Message();
+        message.obj = mock(Activity.class);
+
+        subject = new EventDispatcher(recorders, Looper.getMainLooper());
+        subject.getHandlerCallback().handleMessage(message);
+
+        verify(mockEventRecorder1, never()).record(any(BaseEvent.class));
+        verify(mockEventRecorder2, never()).record(any(BaseEvent.class));
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/EventHandlerTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/EventHandlerTest.java
deleted file mode 100644
index 8c2d338c..00000000
--- a/mopub-sdk/src/test/java/com/mopub/common/event/EventHandlerTest.java
+++ /dev/null
@@ -1,57 +0,0 @@
-package com.mopub.common.event;
-
-import android.os.HandlerThread;
-import android.os.Message;
-
-import com.mopub.common.ClientMetadata;
-import com.mopub.common.test.support.SdkTestRunner;
-
-import org.apache.http.HttpStatus;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
-
-@RunWith(SdkTestRunner.class)
-public class EventHandlerTest {
-
-    private EventRecorder testRecorder;
-    private MoPubEvents.EventDispatcher subject;
-    private HandlerThread testHandlerThread;
-
-    @Before
-    public void setup() {
-        // Set up test event recorders and test handler thread.
-        List<EventRecorder> recorders = new ArrayList<EventRecorder>();
-        testRecorder = mock(EventRecorder.class);
-        recorders.add(testRecorder);
-        testHandlerThread = new HandlerThread("mopub-test-events");
-        subject = new MoPubEvents.EventDispatcher(recorders, testHandlerThread);
-        // The test runner uses a mock dispatcher that does nothing.
-        MoPubEvents.setEventDispatcher(subject);
-    }
-
-    @Test
-    public void createEvent_testCallbackCallsHandler() throws Exception {
-        Message message = new Message();
-        message.obj = new Event(BaseEvent.Type.DATA_ERROR, "Test URL", ClientMetadata.getInstance());
-        subject.mHandlerCallback.handleMessage(message);
-        verify(testRecorder).recordEvent(eq((Event) message.obj));
-    }
-
-    @Test
-    public void createTimedEvent_testCallbackCallsHandler() throws Exception {
-        Message message = new Message();
-        message.obj = new TimedEvent(BaseEvent.Type.DATA_ERROR, "Test URL", ClientMetadata.getInstance(), null);
-        ((TimedEvent) message.obj).stop(HttpStatus.SC_OK);
-        subject.mHandlerCallback.handleMessage(message);
-        verify(testRecorder).recordTimedEvent((TimedEvent) eq(message.obj));
-    }
-}
\ No newline at end of file
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/EventSamplerTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/EventSamplerTest.java
new file mode 100644
index 00000000..d6494a11
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/EventSamplerTest.java
@@ -0,0 +1,45 @@
+package com.mopub.common.event;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+
+import java.util.Random;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class EventSamplerTest {
+
+    private EventSampler subject;
+    @Mock Random mockRandom;
+    @Mock BaseEvent mockBaseEvent;
+
+    @Before
+    public void setUp() {
+        subject = new EventSampler(mockRandom);
+        when(mockBaseEvent.getSamplingRate()).thenReturn(0.10);
+    }
+
+    @Test
+    public void sample_withRandomNumberLessThan10Percent_shouldReturnTrue() throws Exception {
+        when(mockRandom.nextDouble()).thenReturn(0.09);
+
+        boolean result = subject.sample(mockBaseEvent);
+
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void sample_withRandomNumberGreaterOrEqualTo10Percent_shouldReturnFalse() throws Exception {
+        when(mockRandom.nextDouble()).thenReturn(0.10);
+
+        boolean result = subject.sample(mockBaseEvent);
+
+        assertThat(result).isFalse();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/EventSerializerTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/EventSerializerTest.java
new file mode 100644
index 00000000..22a6bebc
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/EventSerializerTest.java
@@ -0,0 +1,211 @@
+package com.mopub.common.event;
+
+import android.app.Activity;
+
+import com.mopub.common.ClientMetadata;
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.json.JSONArray;
+import org.json.JSONObject;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+
+import java.util.ArrayList;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class EventSerializerTest {
+
+    private EventSerializer subject;
+    private Activity context;
+
+    @Mock private Event mockEvent;
+    @Mock private ErrorEvent mockErrorEvent;
+
+    @Before
+    public void setUp() {
+        subject = new EventSerializer();
+
+        // initialize client meta data with context
+        context = Robolectric.buildActivity(Activity.class).create().get();
+        ClientMetadata.getInstance(context);
+
+        populateBaseEventFields(mockEvent);
+        populateBaseEventFields(mockErrorEvent);
+
+        when(mockErrorEvent.getErrorExceptionClassName()).thenReturn("error_exception_class_name");
+        when(mockErrorEvent.getErrorMessage()).thenReturn("error_message");
+        when(mockErrorEvent.getErrorStackTrace()).thenReturn("error_stack_trace");
+        when(mockErrorEvent.getErrorFileName()).thenReturn("error_file_name");
+        when(mockErrorEvent.getErrorClassName()).thenReturn("error_class_name");
+        when(mockErrorEvent.getErrorMethodName()).thenReturn("error_method_name");
+        when(mockErrorEvent.getErrorLineNumber()).thenReturn(123);
+    }
+
+    @Test
+    public void serializeAsJson_withAllEventFieldsPopulated_shouldCorrectJsonRepresentation() throws Exception {
+        ArrayList<BaseEvent> events = new ArrayList<BaseEvent>();
+        events.add(mockEvent);
+        JSONArray jsonArray = subject.serializeAsJson(events);
+        assertThat(jsonArray.length()).isEqualTo(1);
+
+        JSONObject jsonObject = jsonArray.getJSONObject(0);
+        validateBaseEventFields(jsonObject);
+    }
+
+    @Test
+    public void serializeAsJson_withAllErrorEventFieldsPopulated_shouldCorrectJsonRepresentation() throws Exception {
+        ArrayList<BaseEvent> events = new ArrayList<BaseEvent>();
+        events.add(mockErrorEvent);
+        JSONArray jsonArray = subject.serializeAsJson(events);
+        assertThat(jsonArray.length()).isEqualTo(1);
+
+        JSONObject jsonObject = jsonArray.getJSONObject(0);
+        validateBaseEventFields(jsonObject);
+
+        assertThat(jsonObject.getString("error_exception_class_name")).isEqualTo("error_exception_class_name");
+        assertThat(jsonObject.getString("error_message")).isEqualTo("error_message");
+        assertThat(jsonObject.getString("error_stack_trace")).isEqualTo("error_stack_trace");
+        assertThat(jsonObject.getString("error_file_name")).isEqualTo("error_file_name");
+        assertThat(jsonObject.getString("error_class_name")).isEqualTo("error_class_name");
+        assertThat(jsonObject.getString("error_method_name")).isEqualTo("error_method_name");
+        assertThat(jsonObject.getInt("error_line_number")).isEqualTo(123);
+    }
+
+    @Test
+    public void serializeAsJson_shouldReturnJsonArrayOfEvents() throws Exception {
+        when(mockEvent.getName()).thenReturn(BaseEvent.Name.AD_REQUEST);
+        when(mockEvent.getCategory()).thenReturn(BaseEvent.Category.REQUESTS);
+        when(mockErrorEvent.getName()).thenReturn(BaseEvent.Name.IMPRESSION_REQUEST);
+        when(mockErrorEvent.getCategory()).thenReturn(BaseEvent.Category.REQUESTS);
+
+        ArrayList<BaseEvent> events = new ArrayList<BaseEvent>();
+        events.add(mockEvent);
+        events.add(mockErrorEvent);
+
+        JSONArray jsonArray = subject.serializeAsJson(events);
+        assertThat(jsonArray.length()).isEqualTo(2);
+
+        JSONObject jsonObject1 = jsonArray.getJSONObject(0);
+        assertThat(jsonObject1.getString("name")).isEqualTo(BaseEvent.Name.AD_REQUEST.getName());
+        assertThat(jsonObject1.getString("name_category")).isEqualTo("requests");
+
+        JSONObject jsonObject2 = jsonArray.getJSONObject(1);
+        assertThat(jsonObject2.getString("name")).isEqualTo("impression_request");
+        assertThat(jsonObject2.getString("name_category")).isEqualTo("requests");
+    }
+
+    private void populateBaseEventFields(BaseEvent mockBaseEvent) {
+        when(mockBaseEvent.getScribeCategory()).thenReturn(BaseEvent.ScribeCategory.EXCHANGE_CLIENT_EVENT);
+        when(mockBaseEvent.getName()).thenReturn(BaseEvent.Name.AD_REQUEST);
+        when(mockBaseEvent.getCategory()).thenReturn(BaseEvent.Category.REQUESTS);
+        when(mockBaseEvent.getSdkProduct()).thenReturn(BaseEvent.SdkProduct.NATIVE);
+        when(mockBaseEvent.getSdkVersion()).thenReturn("3.5.0");
+        when(mockBaseEvent.getAdUnitId()).thenReturn("8cf00598d3664adaaeccd800e46afaca");
+        when(mockBaseEvent.getAdCreativeId()).thenReturn("3c2b887e2c2a4cd0ae6a925440a62f0d");
+        when(mockBaseEvent.getAdType()).thenReturn("html");
+        when(mockBaseEvent.getAdNetworkType()).thenReturn("admob");
+        when(mockBaseEvent.getAdWidthPx()).thenReturn(320.0);
+        when(mockBaseEvent.getAdHeightPx()).thenReturn(50.0);
+        when(mockBaseEvent.getAppPlatform()).thenReturn(BaseEvent.AppPlatform.ANDROID);
+        when(mockBaseEvent.getAppName()).thenReturn("MoPub Sample App");
+        when(mockBaseEvent.getAppPackageName()).thenReturn("com.mopub.simpleadsdemo");
+        when(mockBaseEvent.getAppVersion()).thenReturn("1.0");
+        when(mockBaseEvent.getObfuscatedClientAdvertisingId()).thenCallRealMethod();
+        when(mockBaseEvent.getClientAdvertisingId()).thenReturn("38400000-8cf0-11bd-b23e-10b96e40000d");
+        when(mockBaseEvent.getClientDoNotTrack()).thenReturn(false);
+        when(mockBaseEvent.getDeviceManufacturer()).thenReturn("LGE");
+        when(mockBaseEvent.getDeviceModel()).thenReturn("Nexus 5");
+        when(mockBaseEvent.getDeviceProduct()).thenReturn("hammerhead");
+        when(mockBaseEvent.getDeviceOsVersion()).thenReturn("5.0");
+        when(mockBaseEvent.getDeviceScreenWidthDip()).thenReturn(1080);
+        when(mockBaseEvent.getDeviceScreenHeightDip()).thenReturn(1920);
+        when(mockBaseEvent.getGeoLat()).thenReturn(37.7833);
+        when(mockBaseEvent.getGeoLon()).thenReturn(-122.4183333);
+        when(mockBaseEvent.getGeoAccuracy()).thenReturn(10.0);
+        when(mockBaseEvent.getPerformanceDurationMs()).thenReturn(100.0);
+        when(mockBaseEvent.getNetworkType()).thenReturn(ClientMetadata.MoPubNetworkType.WIFI);
+        when(mockBaseEvent.getNetworkOperatorCode()).thenReturn("310410");
+        when(mockBaseEvent.getNetworkOperatorName()).thenReturn("AT&T");
+        when(mockBaseEvent.getNetworkIsoCountryCode()).thenReturn("US");
+        when(mockBaseEvent.getNetworkSimCode()).thenReturn("network_sim_code");
+        when(mockBaseEvent.getNetworkSimOperatorName()).thenReturn("network_operator_name");
+        when(mockBaseEvent.getNetworkSimIsoCountryCode()).thenReturn("US");
+        when(mockBaseEvent.getRequestId()).thenReturn("b550796074da4559a27c5072dcba2b27");
+        when(mockBaseEvent.getRequestStatusCode()).thenReturn(200);
+        when(mockBaseEvent.getRequestUri()).thenReturn("http://ads.mopub.com/m/ad?id=8cf00598d3664adaaeccd800e46afaca");
+        when(mockBaseEvent.getRequestRetries()).thenReturn(0);
+        when(mockBaseEvent.getTimestampUtcMs()).thenReturn(1416447053472L);
+    }
+
+    private void validateBaseEventFields(JSONObject jsonObject) throws Exception {
+        assertThat(jsonObject.getString("_category_")).isEqualTo("exchange_client_event");
+        assertThat(jsonObject.getLong("ts")).isEqualTo(1416447053472L);
+
+        // Name Details
+        assertThat(jsonObject.getString("name")).isEqualTo(BaseEvent.Name.AD_REQUEST.getName());
+        assertThat(jsonObject.getString("name_category")).isEqualTo(BaseEvent.Category.REQUESTS.getCategory());
+
+        // SDK Details
+        assertThat(jsonObject.getInt("sdk_product")).isEqualTo(BaseEvent.SdkProduct.NATIVE.getType());
+        assertThat(jsonObject.getString("sdk_version")).isEqualTo("3.5.0");
+
+        // Ad Details
+        assertThat(jsonObject.getString("ad_unit_id")).isEqualTo("8cf00598d3664adaaeccd800e46afaca");
+        assertThat(jsonObject.getString("ad_creative_id")).isEqualTo("3c2b887e2c2a4cd0ae6a925440a62f0d");
+        assertThat(jsonObject.getString("ad_type")).isEqualTo("html");
+        assertThat(jsonObject.getString("ad_network_type")).isEqualTo("admob");
+        assertThat(jsonObject.getDouble("ad_width_px")).isEqualTo(320.0);
+        assertThat(jsonObject.getDouble("ad_height_px")).isEqualTo(50.0);
+
+        // App Details
+        assertThat(jsonObject.getInt("app_platform")).isEqualTo(2);
+        assertThat(jsonObject.getString("app_name")).isEqualTo("MoPub Sample App");
+        assertThat(jsonObject.getString("app_package_name")).isEqualTo("com.mopub.simpleadsdemo");
+        assertThat(jsonObject.getString("app_version")).isEqualTo("1.0");
+
+        // Client Details
+        assertThat(jsonObject.getString("client_advertising_id")).isEqualTo("ifa:XXXX");
+        assertThat(jsonObject.getBoolean("client_do_not_track")).isEqualTo(false);
+
+        // Device Details
+        assertThat(jsonObject.getString("device_manufacturer")).isEqualTo("LGE");
+        assertThat(jsonObject.getString("device_model")).isEqualTo("Nexus 5");
+        assertThat(jsonObject.getString("device_product")).isEqualTo("hammerhead");
+        assertThat(jsonObject.getString("device_os_version")).isEqualTo("5.0");
+        assertThat(jsonObject.getInt("device_screen_width_px")).isEqualTo(1080);
+        assertThat(jsonObject.getInt("device_screen_height_px")).isEqualTo(1920);
+
+        // Geo Details
+        assertThat(jsonObject.getDouble("geo_lat")).isEqualTo(37.7833);
+        assertThat(jsonObject.getDouble("geo_lon")).isEqualTo(-122.4183333);
+        assertThat(jsonObject.getDouble("geo_accuracy_radius_meters")).isEqualTo(10.0);
+
+        // Performance Details
+        assertThat(jsonObject.getDouble("perf_duration_ms")).isEqualTo(100.0);
+
+        // Network Details
+        assertThat(jsonObject.getInt("network_type")).isEqualTo(ClientMetadata.MoPubNetworkType.WIFI.getId());
+        assertThat(jsonObject.getString("network_operator_code")).isEqualTo("310410");
+        assertThat(jsonObject.getString("network_operator_name")).isEqualTo("AT&T");
+        assertThat(jsonObject.getString("network_iso_country_code")).isEqualTo("US");
+        assertThat(jsonObject.getString("network_sim_code")).isEqualTo("network_sim_code");
+        assertThat(jsonObject.getString("network_sim_operator_name")).isEqualTo("network_operator_name");
+        assertThat(jsonObject.getString("network_sim_iso_country_code")).isEqualTo("US");
+
+        // Request Details
+        assertThat(jsonObject.getString("req_id")).isEqualTo("b550796074da4559a27c5072dcba2b27");
+        assertThat(jsonObject.getInt("req_status_code")).isEqualTo(200);
+        assertThat(jsonObject.getString("req_uri")).isEqualTo("http://ads.mopub.com/m/ad?id=8cf00598d3664adaaeccd800e46afaca");
+        assertThat(jsonObject.getInt("req_retries")).isEqualTo(0);
+
+        // Timestamp Details
+        assertThat(jsonObject.getLong("timestamp_client")).isEqualTo(1416447053472L);
+    }
+}
+
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/EventTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/EventTest.java
new file mode 100644
index 00000000..6a3e58f2
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/EventTest.java
@@ -0,0 +1,28 @@
+package com.mopub.common.event;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+public class EventTest {
+
+    private Event subject;
+
+    @Before
+    public void setUp() {
+        subject = new Event.Builder(BaseEvent.Name.AD_REQUEST, BaseEvent.Category.REQUESTS, 0.10000123).build();
+    }
+
+    @Test
+    public void constructor_shouldCorrectlyAssignScribeCategoryFromBuilder() {
+        assertThat(subject.getName()).isEqualTo(BaseEvent.Name.AD_REQUEST);
+        assertThat(subject.getCategory()).isEqualTo(BaseEvent.Category.REQUESTS);
+        assertThat(subject.getSamplingRate()).isEqualTo(0.10000123);
+        assertThat(subject.getScribeCategory()).isEqualTo(BaseEvent.ScribeCategory.EXCHANGE_CLIENT_EVENT);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/MoPubEventsTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/MoPubEventsTest.java
new file mode 100644
index 00000000..d555f34e
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/MoPubEventsTest.java
@@ -0,0 +1,51 @@
+package com.mopub.common.event;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.ArrayList;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+
+@RunWith(SdkTestRunner.class)
+public class MoPubEventsTest {
+
+    @Before
+    public void setUp() {
+        MoPubEvents.setEventDispatcher(null);
+    }
+
+    @Test
+    public void getDispatcher_shouldReturnSingletonEventDispatcherWithScribeEventRecorder() throws Exception {
+        EventDispatcher eventDispatcher = MoPubEvents.getDispatcher();
+        EventDispatcher eventDispatcher2 = MoPubEvents.getDispatcher();
+
+        assertThat(eventDispatcher).isEqualTo(eventDispatcher2);
+
+        Iterable<EventRecorder> eventRecorderIterable = eventDispatcher.getEventRecorders();
+        ArrayList<EventRecorder> eventRecorders = new ArrayList<EventRecorder>();
+        for (EventRecorder recorder : eventRecorderIterable) {
+            eventRecorders.add(recorder);
+        }
+
+        assertThat(eventRecorders.size()).isEqualTo(1);
+        assertThat(eventRecorders.get(0)).isInstanceOf(ScribeEventRecorder.class);
+    }
+
+    @Test
+    public void log_shouldDispatchEvent() throws Exception {
+        EventDispatcher mockEventDispatcher = mock(EventDispatcher.class);
+        MoPubEvents.setEventDispatcher(mockEventDispatcher);
+
+        Event mockEvent = mock(Event.class);
+        MoPubEvents.log(mockEvent);
+
+        verify(mockEventDispatcher).dispatch(mockEvent);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/ScribeEventRecorderTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/ScribeEventRecorderTest.java
new file mode 100644
index 00000000..5681be25
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/ScribeEventRecorderTest.java
@@ -0,0 +1,210 @@
+package com.mopub.common.event;
+
+import android.os.Handler;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.network.ScribeBackoffPolicy;
+import com.mopub.network.ScribeRequest;
+import com.mopub.network.ScribeRequestManager;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+
+import java.util.List;
+import java.util.Queue;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyLong;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class ScribeEventRecorderTest {
+
+    private ScribeEventRecorder subject;
+    @Mock private EventSampler mockEventSampler;
+    @Mock private Queue<BaseEvent> mockQueue;
+    @Mock private EventSerializer mockEventSerializer;
+    @Mock private ScribeRequestManager mockScribeRequestManager;
+    @Mock private Handler mockHandler;
+    @Mock private Event mockEvent;
+
+    @Before
+    public void setUp() {
+        subject = new ScribeEventRecorder(
+                mockEventSampler,
+                mockQueue,
+                mockEventSerializer,
+                mockScribeRequestManager,
+                mockHandler
+        );
+
+        when(mockEventSampler.sample(any(Event.class))).thenReturn(true);
+    }
+
+    @Test
+    public void record_shouldSampleEvent() throws Exception {
+        subject.record(mockEvent);
+        verify(mockEventSampler).sample(mockEvent);
+    }
+
+    @Test
+    public void record_withQueueSizeBelowSendThreshold_shouldQueueEvent_shouldNotSendEvents_shouldScheduleNextPoll() throws Exception {
+        when(mockQueue.size()).thenReturn(99);
+
+        subject.record(mockEvent);
+
+        verify(mockQueue).add(mockEvent);
+        verify(mockScribeRequestManager, never()).makeRequest(any(ScribeRequest.ScribeRequestFactory.class), any(ScribeBackoffPolicy.class));
+        verify(mockHandler).postDelayed(any(ScribeEventRecorder.PollingRunnable.class), eq(Long.valueOf(120000)));
+    }
+
+    @Test
+    public void record_withQueueSizeAtSendThreshold_shouldQueueEvent_shouldSendEvents_shouldScheduleNextPoll() throws Exception {
+        when(mockQueue.size()).thenReturn(100);
+        when(mockQueue.peek()).thenReturn(mockEvent);
+        when(mockQueue.poll()).thenReturn(mockEvent);
+
+        subject.record(mockEvent);
+
+        verify(mockQueue).add(mockEvent);
+        verify(mockScribeRequestManager).makeRequest(any(ScribeRequest.ScribeRequestFactory.class), any(ScribeBackoffPolicy.class));
+        verify(mockHandler).postDelayed(any(ScribeEventRecorder.PollingRunnable.class), eq(Long.valueOf(120000)));
+    }
+
+    @Test
+    public void record_withQueueSizeAtQueueLimit_shouldNotQueueEvent_shouldNotSendEvents_shouldNotScheduleNextPoll() throws Exception {
+        when(mockQueue.size()).thenReturn(500);
+
+        subject.record(mockEvent);
+
+        verify(mockQueue, never()).add(mockEvent);
+        verify(mockScribeRequestManager, never()).makeRequest(any(ScribeRequest.ScribeRequestFactory.class), any(ScribeBackoffPolicy.class));
+        verify(mockHandler, never()).postDelayed(any(ScribeEventRecorder.PollingRunnable.class), anyLong());
+    }
+
+    @Test
+    public void sendEvents_shouldDequeueEvents_shouldAddRequestToScribeRequestManager() throws Exception {
+        when(mockQueue.size()).thenReturn(1);
+        when(mockQueue.peek()).thenReturn(mockEvent).thenReturn(null);
+        when(mockQueue.poll()).thenReturn(mockEvent).thenReturn(null);
+        doAnswer(new Answer() {
+            @Override
+            public Object answer(InvocationOnMock invocation) throws Throwable {
+                ScribeRequest scribeRequest = ((ScribeRequest.ScribeRequestFactory) invocation.getArguments()[0]).createRequest(null);
+                assertThat(scribeRequest.getUrl()).isEqualTo("https://analytics.mopub.com/i/jot/exchange_client_event");
+                assertThat(scribeRequest.getEvents()).containsOnly(mockEvent);
+                return null;
+            }
+        }).when(mockScribeRequestManager).makeRequest(any(ScribeRequest.ScribeRequestFactory.class), any(ScribeBackoffPolicy.class));
+
+        subject.sendEvents();
+
+        verify(mockQueue, times(2)).peek();
+        verify(mockQueue, times(1)).poll();
+        verify(mockScribeRequestManager).makeRequest(any(ScribeRequest.ScribeRequestFactory.class), any(ScribeBackoffPolicy.class));
+    }
+
+    @Test
+    public void sendEvents_withRequestInFlightShouldReturnFast() throws Exception {
+        when(mockScribeRequestManager.isAtCapacity()).thenReturn(true);
+
+        subject.sendEvents();
+
+        verify(mockQueue, never()).poll();
+        verify(mockScribeRequestManager, never()).makeRequest(any(ScribeRequest.ScribeRequestFactory.class), any(ScribeBackoffPolicy.class));
+    }
+    
+    @Test
+    public void dequeEvents_withQueueSizeGreaterThanEventSendThreshhold_shouldDequeueUpToEventSendThreshhold() throws Exception {
+        when(mockQueue.size()).thenReturn(101);
+        when(mockQueue.peek()).thenReturn(mockEvent);
+        when(mockQueue.poll()).thenReturn(mockEvent);
+
+        List<BaseEvent> events = subject.dequeueEvents();
+
+        verify(mockQueue, times(101)).peek();
+        verify(mockQueue, times(100)).poll();
+        assertThat(events.size()).isEqualTo(100);
+    }
+
+    @Test
+    public void dequeEvents_withQueueSizeLessThanEventSendThreshhold_shouldDequeueQueueSize() throws Exception {
+        when(mockQueue.size()).thenReturn(99);
+
+        when(mockQueue.peek()).thenAnswer(new Answer<BaseEvent>() {
+            int i;
+            @Override
+            public BaseEvent answer(InvocationOnMock invocation) throws Throwable {
+                return i++ < 99 ? mockEvent : null;
+            }
+        });
+
+        when(mockQueue.poll()).thenAnswer(new Answer<BaseEvent>() {
+            int i;
+            @Override
+            public BaseEvent answer(InvocationOnMock invocation) throws Throwable {
+                return i++ < 99 ? mockEvent : null;
+            }
+        });
+
+        List<BaseEvent> events = subject.dequeueEvents();
+
+        verify(mockQueue, times(100)).peek();
+        verify(mockQueue, times(99)).poll();
+        assertThat(events.size()).isEqualTo(99);
+    }
+
+    @Test
+    public void scheduleNextPoll_shouldPostDelayedPollingRunnable() throws Exception {
+        when(mockHandler.hasMessages(0)).thenReturn(false);
+        when(mockQueue.isEmpty()).thenReturn(false);
+
+        subject.scheduleNextPoll();
+
+        verify(mockHandler).postDelayed(any(ScribeEventRecorder.PollingRunnable.class), eq(Long.valueOf(120000)));
+    }
+
+    @Test
+    public void scheduleNextPoll_withPollScheduled_shouldNotPostDelayedPollingRunnable() throws Exception {
+        when(mockHandler.hasMessages(0)).thenReturn(true);
+        when(mockQueue.isEmpty()).thenReturn(false);
+
+        subject.scheduleNextPoll();
+
+        verify(mockHandler, never()).postDelayed(any(ScribeEventRecorder.PollingRunnable.class), anyLong());
+    }
+
+    @Test
+    public void scheduleNextPoll_withEmptyRequestQueue_shouldNotPostDelayedPollingRunnable() throws Exception {
+        when(mockHandler.hasMessages(0)).thenReturn(false);
+        when(mockQueue.isEmpty()).thenReturn(true);
+
+        subject.scheduleNextPoll();
+
+        verify(mockHandler, never()).postDelayed(any(ScribeEventRecorder.PollingRunnable.class), anyLong());
+    }
+
+    @Test
+    public void PollingRunnable_run_shouldSendEvents_shouldScheduleNextPoll() throws Exception {
+        when(mockQueue.size()).thenReturn(100);
+        when(mockQueue.peek()).thenReturn(mockEvent);
+        when(mockQueue.poll()).thenReturn(mockEvent);
+
+        ScribeEventRecorder.PollingRunnable pollingRunnable = subject.new PollingRunnable();
+        pollingRunnable.run();
+
+        verify(mockScribeRequestManager).makeRequest(any(ScribeRequest.ScribeRequestFactory.class), any(ScribeBackoffPolicy.class));
+        verify(mockHandler).postDelayed(any(ScribeEventRecorder.PollingRunnable.class), eq(Long.valueOf(120000)));
+    }
+}
+
diff --git a/mopub-sdk/src/test/java/com/mopub/common/test/support/SdkTestRunner.java b/mopub-sdk/src/test/java/com/mopub/common/test/support/SdkTestRunner.java
index d17a79d8..7c03ac03 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/test/support/SdkTestRunner.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/test/support/SdkTestRunner.java
@@ -1,7 +1,9 @@
 package com.mopub.common.test.support;
 
+import com.mopub.common.CacheService;
 import com.mopub.common.ClientMetadata;
 import com.mopub.common.MoPub;
+import com.mopub.common.event.EventDispatcher;
 import com.mopub.common.event.MoPubEvents;
 import com.mopub.common.factories.MethodBuilderFactory;
 import com.mopub.common.util.AsyncTasks;
@@ -9,7 +11,6 @@
 import com.mopub.common.util.test.support.ShadowAsyncTasks;
 import com.mopub.common.util.test.support.TestDateAndTime;
 import com.mopub.common.util.test.support.TestMethodBuilderFactory;
-import com.mopub.mobileads.factories.AdFetcherFactory;
 import com.mopub.mobileads.factories.AdViewControllerFactory;
 import com.mopub.mobileads.factories.CustomEventBannerAdapterFactory;
 import com.mopub.mobileads.factories.CustomEventBannerFactory;
@@ -19,11 +20,9 @@
 import com.mopub.mobileads.factories.HtmlInterstitialWebViewFactory;
 import com.mopub.mobileads.factories.HttpClientFactory;
 import com.mopub.mobileads.factories.MoPubViewFactory;
-import com.mopub.mobileads.factories.MraidViewFactory;
+import com.mopub.mobileads.factories.MraidControllerFactory;
 import com.mopub.mobileads.factories.VastManagerFactory;
 import com.mopub.mobileads.factories.VastVideoDownloadTaskFactory;
-import com.mopub.mobileads.factories.ViewGestureDetectorFactory;
-import com.mopub.mobileads.test.support.TestAdFetcherFactory;
 import com.mopub.mobileads.test.support.TestAdViewControllerFactory;
 import com.mopub.mobileads.test.support.TestCustomEventBannerAdapterFactory;
 import com.mopub.mobileads.test.support.TestCustomEventBannerFactory;
@@ -33,24 +32,22 @@
 import com.mopub.mobileads.test.support.TestHtmlInterstitialWebViewFactory;
 import com.mopub.mobileads.test.support.TestHttpClientFactory;
 import com.mopub.mobileads.test.support.TestMoPubViewFactory;
-import com.mopub.mobileads.test.support.TestMraidViewFactory;
+import com.mopub.mobileads.test.support.TestMraidControllerFactory;
 import com.mopub.mobileads.test.support.TestVastManagerFactory;
 import com.mopub.mobileads.test.support.TestVastVideoDownloadTaskFactory;
-import com.mopub.mobileads.test.support.TestViewGestureDetectorFactory;
 import com.mopub.nativeads.factories.CustomEventNativeFactory;
 import com.mopub.nativeads.test.support.TestCustomEventNativeFactory;
 
 import org.junit.runners.model.InitializationError;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.DefaultTestLifecycle;
+import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.TestLifecycle;
 import org.robolectric.bytecode.ClassInfo;
 import org.robolectric.bytecode.Setup;
 import org.robolectric.util.RobolectricBackgroundExecutorService;
 
-import java.lang.reflect.Method;
-
 import static com.mopub.common.MoPub.LocationAwareness;
 import static org.mockito.Mockito.mock;
 
@@ -79,36 +76,34 @@ public boolean shouldInstrument(ClassInfo classInfo) {
     public static class TestLifeCycleWithInjection extends DefaultTestLifecycle {
         @Override
         public void prepareTest(Object test) {
-            AdFetcherFactory.setInstance(new TestAdFetcherFactory());
+            ClientMetadata.clearForTesting();
+
             HttpClientFactory.setInstance(new TestHttpClientFactory());
             DateAndTime.setInstance(new TestDateAndTime());
             CustomEventBannerFactory.setInstance(new TestCustomEventBannerFactory());
             CustomEventInterstitialFactory.setInstance(new TestCustomEventInterstitialFactory());
             CustomEventBannerAdapterFactory.setInstance(new TestCustomEventBannerAdapterFactory());
-            MraidViewFactory.setInstance(new TestMraidViewFactory());
             MoPubViewFactory.setInstance(new TestMoPubViewFactory());
             CustomEventInterstitialAdapterFactory.setInstance(new TestCustomEventInterstitialAdapterFactory());
             HtmlBannerWebViewFactory.setInstance(new TestHtmlBannerWebViewFactory());
             HtmlInterstitialWebViewFactory.setInstance(new TestHtmlInterstitialWebViewFactory());
             AdViewControllerFactory.setInstance(new TestAdViewControllerFactory());
-            ViewGestureDetectorFactory.setInstance(new TestViewGestureDetectorFactory());
             VastManagerFactory.setInstance(new TestVastManagerFactory());
             VastVideoDownloadTaskFactory.setInstance(new TestVastVideoDownloadTaskFactory());
             MethodBuilderFactory.setInstance(new TestMethodBuilderFactory());
             CustomEventNativeFactory.setInstance(new TestCustomEventNativeFactory());
+            MraidControllerFactory.setInstance(new TestMraidControllerFactory());
+
             ShadowAsyncTasks.reset();
-            MoPubEvents.setEventDispatcher(mock(MoPubEvents.EventDispatcher.class));
+            MoPubEvents.setEventDispatcher(mock(EventDispatcher.class));
             MoPub.setLocationAwareness(LocationAwareness.NORMAL);
             MoPub.setLocationPrecision(6);
 
             MockitoAnnotations.initMocks(test);
 
             AsyncTasks.setExecutor(new RobolectricBackgroundExecutorService());
-        }
-
-        @Override
-        public void afterTest(final Method method) {
-            ClientMetadata.clearForTesting();
+            CacheService.clearAndNullCaches();
+            Robolectric.getFakeHttpLayer().clearPendingHttpResponses();
         }
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/AsyncTasksTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/AsyncTasksTest.java
index 89473924..2bfebb20 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/util/AsyncTasksTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/AsyncTasksTest.java
@@ -1,7 +1,6 @@
 package com.mopub.common.util;
 
 import android.os.AsyncTask;
-import android.os.Build;
 import android.os.Build.VERSION_CODES;
 import android.os.Handler;
 import android.os.Looper;
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/DeviceUtilsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/DeviceUtilsTest.java
new file mode 100644
index 00000000..b7f25039
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/DeviceUtilsTest.java
@@ -0,0 +1,119 @@
+package com.mopub.common.util;
+
+import android.app.Activity;
+import android.content.pm.ActivityInfo;
+import android.content.res.Configuration;
+import android.content.res.Resources;
+import android.view.Surface;
+
+import com.mopub.common.CreativeOrientation;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.nativeads.test.support.MoPubShadowDisplay;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+public class DeviceUtilsTest {
+
+    private Activity testActivity;
+    private Resources testResources;
+
+    @Before
+    public void setup() {
+        testActivity = Robolectric.buildActivity(Activity.class).create().get();
+        testResources = testActivity.getResources();
+    }
+
+    @Test
+    public void getOrientation_whenReverseLandscape_shouldReturnReverseLandscape() {
+        testResources.getConfiguration().orientation = Configuration.ORIENTATION_LANDSCAPE;
+        MoPubShadowDisplay.setStaticRotation(Surface.ROTATION_270);
+
+        assertThat(DeviceUtils.getScreenOrientation(testActivity)).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE);
+    }
+
+    @Test
+    public void getOrientation_whenLandscape_shouldReturnLandscape() {
+        testResources.getConfiguration().orientation = Configuration.ORIENTATION_LANDSCAPE;
+        MoPubShadowDisplay.setStaticRotation(Surface.ROTATION_90);
+
+        assertThat(DeviceUtils.getScreenOrientation(testActivity)).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
+    }
+
+    @Test
+    public void getOrientation_whenPortrait_shouldReturnPortrait() {
+        testResources.getConfiguration().orientation = Configuration.ORIENTATION_PORTRAIT;
+        MoPubShadowDisplay.setStaticRotation(Surface.ROTATION_0);
+
+        assertThat(DeviceUtils.getScreenOrientation(testActivity)).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+    }
+
+    @Test
+    public void getOrientation_whenReversePortrait_shouldReturnReversePortrait() {
+        testResources.getConfiguration().orientation = Configuration.ORIENTATION_PORTRAIT;
+        MoPubShadowDisplay.setStaticRotation(Surface.ROTATION_180);
+
+        assertThat(DeviceUtils.getScreenOrientation(testActivity)).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT);
+    }
+    
+    @Test
+    public void lockOrientation_toLandscapeWhenLandscape_shouldRemainTheSame() throws Exception {
+        testResources.getConfiguration().orientation = Configuration.ORIENTATION_LANDSCAPE;
+        MoPubShadowDisplay.setStaticRotation(Surface.ROTATION_90);
+
+        DeviceUtils.lockOrientation(testActivity, CreativeOrientation.LANDSCAPE);
+        assertThat(testActivity.getRequestedOrientation()).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
+    }
+
+    @Test
+    public void lockOrientation_toLandscapeWhenReverseLandscape_shouldBeReverseLandscape() {
+
+        testResources.getConfiguration().orientation = Configuration.ORIENTATION_LANDSCAPE;
+        MoPubShadowDisplay.setStaticRotation(Surface.ROTATION_180);  // Reverse landscape
+
+        DeviceUtils.lockOrientation(testActivity, CreativeOrientation.LANDSCAPE);
+        assertThat(testActivity.getRequestedOrientation()).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE);
+    }
+
+    @Test
+    public void lockOrientation_toLandscapeWhenPortrait_shouldBeLandscape() {
+        testResources.getConfiguration().orientation = Configuration.ORIENTATION_PORTRAIT;
+        MoPubShadowDisplay.setStaticRotation(Surface.ROTATION_180);  // Reverse portrait
+
+        DeviceUtils.lockOrientation(testActivity, CreativeOrientation.LANDSCAPE);
+        assertThat(testActivity.getRequestedOrientation()).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
+    }
+
+    @Test
+    public void lockOrientation_toPortraitWhenPortrait_shouldRemainPortrait() {
+
+        testResources.getConfiguration().orientation = Configuration.ORIENTATION_PORTRAIT;
+        MoPubShadowDisplay.setStaticRotation(Surface.ROTATION_0);
+
+        DeviceUtils.lockOrientation(testActivity, CreativeOrientation.PORTRAIT);
+        assertThat(testActivity.getRequestedOrientation()).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+    }
+
+    @Test
+    public void lockOrientation_toPortraitWhenReversePortrait_shouldRemainReversePortrait() {
+        testResources.getConfiguration().orientation = Configuration.ORIENTATION_PORTRAIT;
+        MoPubShadowDisplay.setStaticRotation(Surface.ROTATION_180);
+
+        DeviceUtils.lockOrientation(testActivity, CreativeOrientation.PORTRAIT);
+        assertThat(testActivity.getRequestedOrientation()).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT);
+    }
+
+    @Test
+    public void lockOrientation_toPortraitWhenLandscape_shouldBeLandscape() {
+        testResources.getConfiguration().orientation = Configuration.ORIENTATION_LANDSCAPE;
+        MoPubShadowDisplay.setStaticRotation(Surface.ROTATION_0);  // Reverse landscape
+
+        DeviceUtils.lockOrientation(testActivity, CreativeOrientation.PORTRAIT);
+        assertThat(testActivity.getRequestedOrientation()).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/DipsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/DipsTest.java
new file mode 100644
index 00000000..c0d46973
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/DipsTest.java
@@ -0,0 +1,42 @@
+package com.mopub.common.util;
+
+import android.app.Activity;
+import android.content.res.Resources;
+import android.util.DisplayMetrics;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class DipsTest {
+
+    @Mock private Activity activity;
+    @Mock private Resources resources;
+
+    @Before
+    public void setUp() {
+        DisplayMetrics displayMetrics = new DisplayMetrics();
+        displayMetrics.widthPixels = 480;
+        displayMetrics.heightPixels = 800;
+        displayMetrics.density = 2;
+        when(activity.getResources()).thenReturn(resources);
+        when(resources.getDisplayMetrics()).thenReturn(displayMetrics);
+    }
+
+    @Test
+    public void screenWidthAsIntDips_shouldReturnTheWidthAsDips() throws Exception {
+        assertThat(Dips.screenWidthAsIntDips(activity)).isEqualTo(240);
+    }
+
+    @Test
+    public void screenHeightAsIntDips_shouldReturnTheHeightAsDips() throws Exception {
+        assertThat(Dips.screenHeightAsIntDips(activity)).isEqualTo(400);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/DrawablesTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/DrawablesTest.java
index 269b6577..3c8af8cd 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/util/DrawablesTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/DrawablesTest.java
@@ -11,8 +11,14 @@
 @RunWith(RobolectricTestRunner.class)
 public class DrawablesTest {
     @Test
-    public void decodeImage_shouldCacheDrawables() throws Exception {
-        assertThat(Drawables.BACKGROUND.decodeImage(new Activity()))
-                .isSameAs(Drawables.BACKGROUND.decodeImage(new Activity()));
+    public void createDrawable_shouldNotCacheDrawables() throws Exception {
+        assertThat(Drawables.BACKGROUND.createDrawable(new Activity()))
+                .isNotSameAs(Drawables.BACKGROUND.createDrawable(new Activity()));
+    }
+
+    @Test
+    public void getBitmap_shouldCacheBitmap() throws Exception {
+        assertThat(Drawables.BACKGROUND.getBitmap())
+                .isSameAs(Drawables.BACKGROUND.getBitmap());
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/FilesTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/FilesTest.java
index ca2e55c0..0b65e22e 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/util/FilesTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/FilesTest.java
@@ -8,7 +8,7 @@
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 
-import java.io.*;
+import java.io.File;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/IntentUtilsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/IntentsTest.java
similarity index 53%
rename from mopub-sdk/src/test/java/com/mopub/common/util/IntentUtilsTest.java
rename to mopub-sdk/src/test/java/com/mopub/common/util/IntentsTest.java
index 2630da5e..ee879eae 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/util/IntentUtilsTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/IntentsTest.java
@@ -9,15 +9,17 @@
 import android.os.Bundle;
 
 import com.mopub.common.MoPubBrowser;
+import com.mopub.exceptions.IntentNotResolvableException;
+import com.mopub.exceptions.UrlParseException;
 
+import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
 
 import java.util.ArrayList;
-import java.util.HashSet;
 import java.util.List;
-import java.util.Set;
 
 import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
 import static org.fest.assertions.api.Assertions.assertThat;
@@ -26,12 +28,29 @@
 import static org.mockito.Mockito.stub;
 
 @RunWith(RobolectricTestRunner.class)
-public class IntentUtilsTest {
+public class IntentsTest {
+    private Activity activityContext;
+    private Context applicationContext;
+
+    @Before
+    public void setUp() {
+        activityContext = Robolectric.buildActivity(Activity.class).create().get();
+        applicationContext = activityContext.getApplicationContext();
+    }
+
+    @Test
+    public void startActivity_withActivityContext_shouldStartActivityWithNoNewFlags() throws IntentNotResolvableException {
+        Intents.startActivity(activityContext, new Intent());
+
+        final Intent intent = Robolectric.getShadowApplication().peekNextStartedActivity();
+        assertThat(Utils.bitMaskContainsFlag(intent.getFlags(), FLAG_ACTIVITY_NEW_TASK)).isFalse();
+    }
+
     @Test
     public void getStartActivityIntent_withActivityContext_shouldReturnIntentWithoutNewTaskFlag() throws Exception {
         Context context = new Activity();
 
-        final Intent intent = IntentUtils.getStartActivityIntent(context, MoPubBrowser.class, null);
+        final Intent intent = Intents.getStartActivityIntent(context, MoPubBrowser.class, null);
 
         assertThat(intent.getComponent().getClassName()).isEqualTo(MoPubBrowser.class.getName());
         assertThat(Utils.bitMaskContainsFlag(intent.getFlags(), FLAG_ACTIVITY_NEW_TASK)).isFalse();
@@ -42,7 +61,7 @@ public void getStartActivityIntent_withActivityContext_shouldReturnIntentWithout
     public void getStartActivityIntent_withApplicationContext_shouldReturnIntentWithNewTaskFlag() throws Exception {
         Context context = new Activity().getApplicationContext();
 
-        final Intent intent = IntentUtils.getStartActivityIntent(context, MoPubBrowser.class, null);
+        final Intent intent = Intents.getStartActivityIntent(context, MoPubBrowser.class, null);
 
         assertThat(intent.getComponent().getClassName()).isEqualTo(MoPubBrowser.class.getName());
         assertThat(Utils.bitMaskContainsFlag(intent.getFlags(), FLAG_ACTIVITY_NEW_TASK)).isTrue();
@@ -55,7 +74,7 @@ public void getStartActivityIntent_withBundle_shouldReturnIntentWithExtras() thr
         Bundle bundle = new Bundle();
         bundle.putString("arbitrary key", "even more arbitrary value");
 
-        final Intent intent = IntentUtils.getStartActivityIntent(context, MoPubBrowser.class, bundle);
+        final Intent intent = Intents.getStartActivityIntent(context, MoPubBrowser.class, bundle);
 
         assertThat(intent.getComponent().getClassName()).isEqualTo(MoPubBrowser.class.getName());
         assertThat(Utils.bitMaskContainsFlag(intent.getFlags(), FLAG_ACTIVITY_NEW_TASK)).isFalse();
@@ -76,7 +95,7 @@ public void deviceCanHandleIntent_whenActivityCanResolveIntent_shouldReturnTrue(
 
         stub(packageManager.queryIntentActivities(eq(specificIntent), eq(0))).toReturn(resolveInfos);
 
-        assertThat(IntentUtils.deviceCanHandleIntent(context, specificIntent)).isTrue();
+        assertThat(Intents.deviceCanHandleIntent(context, specificIntent)).isTrue();
     }
 
     @Test
@@ -95,19 +114,38 @@ public void deviceCanHandleIntent_whenActivityCanNotResolveIntent_shouldReturnFa
         otherIntent.setData(Uri.parse("other:"));
         stub(packageManager.queryIntentActivities(eq(specificIntent), eq(0))).toReturn(resolveInfos);
 
-        assertThat(IntentUtils.deviceCanHandleIntent(context, otherIntent)).isFalse();
+        assertThat(Intents.deviceCanHandleIntent(context, otherIntent)).isFalse();
     }
 
     @Test
-    public void generateUniqueId_withMultipleInvocations_shouldReturnUniqueValues() throws Exception {
-        final int expectedIdCount = 100;
+    public void intentForNativeBrowserScheme_shouldProperlyHandleEncodedUrls() throws UrlParseException {
+        Intent intent;
 
-        Set<Long> ids = new HashSet<Long>(expectedIdCount);
-        for (int i = 0; i < expectedIdCount; i++) {
-            final long id = Utils.generateUniqueId();
-            ids.add(id);
-        }
+        intent = Intents.intentForNativeBrowserScheme("mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.example.com");
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        assertThat(intent.getDataString()).isEqualTo("http://www.example.com");
+
+        intent = Intents.intentForNativeBrowserScheme("mopubnativebrowser://navigate?url=http://www.example.com/?query=1&two=2");
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        assertThat(intent.getDataString()).isEqualTo("http://www.example.com/?query=1");
+
+        intent = Intents.intentForNativeBrowserScheme("mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.example.com%2F%3Fquery%3D1%26two%3D2");
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        assertThat(intent.getDataString()).isEqualTo("http://www.example.com/?query=1&two=2");
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForNativeBrowserScheme_whenNotMoPubNativeBrowser_shouldThrowException() throws UrlParseException {
+        Intents.intentForNativeBrowserScheme("mailto://navigate?url=http://www.example.com");
+    }
+
+    @Test(expected = UrlParseException.class)
+    public void intentForNativeBrowserScheme_whenNotNavigate_shouldThrowException() throws UrlParseException {
+        Intents.intentForNativeBrowserScheme("mopubnativebrowser://getout?url=http://www.example.com");
+    }
 
-        assertThat(ids).hasSize(expectedIdCount);
+    @Test(expected = UrlParseException.class)
+    public void intentForNativeBrowserScheme_whenUrlParameterMissing_shouldThrowException() throws UrlParseException {
+        Intents.intentForNativeBrowserScheme("mopubnativebrowser://navigate");
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/ManifestUtilsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/ManifestUtilsTest.java
index d40ac3d2..99a9c3f8 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/util/ManifestUtilsTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/ManifestUtilsTest.java
@@ -1,10 +1,13 @@
 package com.mopub.common.util;
 
+import android.annotation.TargetApi;
 import android.app.Activity;
 import android.content.Context;
 import android.content.Intent;
+import android.content.pm.ActivityInfo;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.ResolveInfo;
+import android.os.Build;
 
 import com.mopub.common.MoPubBrowser;
 import com.mopub.mobileads.MoPubActivity;
@@ -15,14 +18,22 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowLog;
 import org.robolectric.shadows.ShadowToast;
 
 import java.util.List;
 
 import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.when;
@@ -30,14 +41,14 @@
 @RunWith(RobolectricTestRunner.class)
 public class ManifestUtilsTest {
     private Context context;
-    private ResolveInfo resolveInfo;
     private List<Class<? extends Activity>> requiredWebViewSdkActivities;
     private List<Class<? extends Activity>> requiredNativeSdkActivities;
 
+    @Mock private ResolveInfo mockResolveInfo;
+
     @Before
     public void setUp() throws Exception {
         context = spy(new Activity());
-        resolveInfo = mock(ResolveInfo.class);
 
         requiredWebViewSdkActivities = ManifestUtils.getRequiredWebViewSdkActivities();
         requiredNativeSdkActivities = ManifestUtils.getRequiredNativeSdkActivities();
@@ -48,6 +59,8 @@ public void setUp() throws Exception {
     @After
     public void tearDown() throws Exception {
         setDebugMode(false);
+        // This may have been set to a mock during testing. Reset this class back to normal
+        ManifestUtils.setFlagCheckUtil(new ManifestUtils.FlagCheckUtil());
     }
 
     @Test
@@ -80,10 +93,10 @@ public void checkNativeSdkActivitiesDeclared_shouldIncludeOneActivityDeclaration
 
     @Test
     public void displayWarningForMissingActivities_withAllActivitiesDeclared_shouldNotShowLogOrToast() throws Exception {
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), resolveInfo);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidActivity.class), resolveInfo);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidVideoPlayerActivity.class), resolveInfo);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubBrowser.class), resolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidActivity.class), mockResolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidVideoPlayerActivity.class), mockResolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubBrowser.class), mockResolveInfo);
 
         ShadowLog.setupLogging();
         setDebugMode(true);
@@ -96,9 +109,9 @@ public void displayWarningForMissingActivities_withAllActivitiesDeclared_shouldN
 
     @Test
      public void displayWarningForMissingActivities_withOneMissingActivity_shouldLogOnlyThatOne() throws Exception {
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), resolveInfo);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidActivity.class), resolveInfo);
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidVideoPlayerActivity.class), resolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidActivity.class), mockResolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidVideoPlayerActivity.class), mockResolveInfo);
         // Here, we leave out MoPubBrowser on purpose
 
         ShadowLog.setupLogging();
@@ -113,6 +126,23 @@ public void displayWarningForMissingActivities_withOneMissingActivity_shouldLogO
         );
     }
 
+    @Test
+    public void displayWarningForMissingActivities_withAllMissingActivities_shouldLogMessage() throws Exception {
+        setDebugMode(true);
+        ShadowLog.setupLogging();
+
+        ManifestUtils.displayWarningForMissingActivities(context, requiredWebViewSdkActivities);
+
+        final List<ShadowLog.LogItem> logs = ShadowLog.getLogs();
+
+        assertLogIncludes(
+                "com.mopub.mobileads.MoPubActivity",
+                "com.mopub.mobileads.MraidActivity",
+                "com.mopub.mobileads.MraidVideoPlayerActivity",
+                "com.mopub.common.MoPubBrowser"
+        );
+    }
+
     @Test
     public void displayWarningForMissingActivities_withMissingActivities_withDebugTrue_shouldShowToast() throws Exception {
         setDebugMode(true);
@@ -121,7 +151,7 @@ public void displayWarningForMissingActivities_withMissingActivities_withDebugTr
 
         assertThat(ShadowToast.getLatestToast()).isNotNull();
         final String toastText = ShadowToast.getTextOfLatestToast();
-        assertThat(toastText).isEqualTo("ERROR: YOUR MOPUB INTEGRATION IS INCOMPLETE.\nCheck logcat and update your AndroidManifest.xml with the correct activities.");
+        assertThat(toastText).isEqualTo("ERROR: YOUR MOPUB INTEGRATION IS INCOMPLETE.\nCheck logcat and update your AndroidManifest.xml with the correct activities and configuration.");
     }
 
     @Test
@@ -132,22 +162,178 @@ public void displayWarningForMissingActivities_withMissingActivities_withDebugFa
 
         assertThat(ShadowToast.getLatestToast()).isNull();
     }
-    
+
+    @SuppressWarnings("unchecked")
+    @TargetApi(13)
     @Test
-    public void displayWarningForMissingActivities_withMissingActivities_withDebugTrue_shouldLogMessage() throws Exception {
-        setDebugMode(true);
+    public void displayWarningForMisconfiguredActivities_withAllActivitiesConfigured_shouldNotLogOrShowToast() throws Exception {
+        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN))).thenReturn(true);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(true);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(true);
+        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
+
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidActivity.class), mockResolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidVideoPlayerActivity.class), mockResolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubBrowser.class), mockResolveInfo);
+
         ShadowLog.setupLogging();
+        setDebugMode(true);
 
-        ManifestUtils.displayWarningForMissingActivities(context, requiredWebViewSdkActivities);
+        ManifestUtils.displayWarningForMisconfiguredActivities(context, requiredWebViewSdkActivities);
 
-        final List<ShadowLog.LogItem> logs = ShadowLog.getLogs();
+        assertThat(ShadowToast.getLatestToast()).isNull();
+        assertThat(ShadowLog.getLogs()).isEmpty();
+    }
 
-        assertLogIncludes(
-                "com.mopub.mobileads.MoPubActivity",
+    @SuppressWarnings("unchecked")
+    @TargetApi(13)
+    @Test
+    public void displayWarningForMisconfiguredActivities_withOneMisconfiguredActivity_shouldLogOnlyThatOne() throws Exception {
+        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
+
+        // Misconfigure the first activity; only return false if the activity is MoPubActivity
+        doAnswer(new Answer() {
+            @Override
+            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+                Object[] args = invocationOnMock.getArguments();
+                return MoPubActivity.class != args[0];
+            }
+        }).when(mockActivitiyConfigCheck).hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN));
+
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(true);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(true);
+        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
+
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidActivity.class), mockResolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MraidVideoPlayerActivity.class), mockResolveInfo);
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubBrowser.class), mockResolveInfo);
+
+        ShadowLog.setupLogging();
+
+        ManifestUtils.displayWarningForMisconfiguredActivities(context, requiredWebViewSdkActivities);
+
+        assertLogIncludes("com.mopub.mobileads.MoPubActivity");
+        assertLogIncludes("The android:configChanges param for activity " + MoPubActivity.class.getName() + " must include keyboardHidden.");
+        assertLogDoesntInclude(
                 "com.mopub.mobileads.MraidActivity",
                 "com.mopub.mobileads.MraidVideoPlayerActivity",
                 "com.mopub.common.MoPubBrowser"
         );
+        assertLogDoesntInclude("The android:configChanges param for activity " + MoPubActivity.class.getName() + " must include orientation.");
+        assertLogDoesntInclude("The android:configChanges param for activity " + MoPubActivity.class.getName() + " must include screenSize.");
+    }
+
+    @SuppressWarnings("unchecked")
+    @TargetApi(13)
+    @Test
+    public void displayWarningForMisconfiguredActivities_withOneMisconfiguredActivity_withMissingAllConfigChangesValues_shouldLogAllConfigChangesValues() throws Exception {
+        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
+
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN))).thenReturn(false);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(false);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(false);
+        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
+
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+
+        ShadowLog.setupLogging();
+
+        ManifestUtils.displayWarningForMisconfiguredActivities(context, requiredWebViewSdkActivities);
+
+        assertLogIncludes("The android:configChanges param for activity " + MoPubActivity.class.getName() + " must include keyboardHidden.");
+        assertLogIncludes("The android:configChanges param for activity " + MoPubActivity.class.getName() + " must include orientation.");
+        assertLogIncludes("The android:configChanges param for activity " + MoPubActivity.class.getName() + " must include screenSize.");
+    }
+
+    @SuppressWarnings("unchecked")
+    @Config(reportSdk = Build.VERSION_CODES.HONEYCOMB_MR1)
+    @TargetApi(13)
+    @Test
+    public void displayWarningForMisconfiguredActivities_withMissingScreenSize_withApiLessThan13_shouldNotLogOrShowToast() throws Exception {
+        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN))).thenReturn(true);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(true);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(false);
+        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
+
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+
+        ShadowLog.setupLogging();
+        setDebugMode(true);
+
+        ManifestUtils.displayWarningForMisconfiguredActivities(context, requiredWebViewSdkActivities);
+
+        assertThat(ShadowToast.getLatestToast()).isNull();
+        assertThat(ShadowLog.getLogs()).isEmpty();
+    }
+
+    @SuppressWarnings("unchecked")
+    @TargetApi(13)
+    @Test
+    public void displayWarningForMisconfiguredActivities_withMissingScreenSize_withTargetApiLessThan13_shouldNotLogOrShowToast() throws Exception {
+        // Set target API to < 13
+        ApplicationInfo applicationInfo = context.getApplicationInfo();
+        applicationInfo.targetSdkVersion = Build.VERSION_CODES.HONEYCOMB_MR1;
+        when(context.getApplicationInfo()).thenReturn(applicationInfo);
+
+        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN))).thenReturn(true);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(true);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(false);
+        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
+
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+
+        ShadowLog.setupLogging();
+        setDebugMode(true);
+
+        ManifestUtils.displayWarningForMisconfiguredActivities(context, requiredWebViewSdkActivities);
+
+        assertThat(ShadowToast.getLatestToast()).isNull();
+        assertThat(ShadowLog.getLogs()).isEmpty();
+    }
+
+    @SuppressWarnings("unchecked")
+    @TargetApi(13)
+    @Test
+    public void displayWarningForMisconfiguredActivities_withMisconfiguredActivities_withDebugTrue_shouldShowToast() throws Exception {
+        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN))).thenReturn(false);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(false);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(false);
+        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
+
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+
+        setDebugMode(true);
+
+        ManifestUtils.displayWarningForMisconfiguredActivities(context, requiredWebViewSdkActivities);
+
+        assertThat(ShadowToast.getLatestToast()).isNotNull();
+        final String toastText = ShadowToast.getTextOfLatestToast();
+        assertThat(toastText).isEqualTo("ERROR: YOUR MOPUB INTEGRATION IS INCOMPLETE.\nCheck logcat and update your AndroidManifest.xml with the correct activities and configuration.");
+    }
+
+    @SuppressWarnings("unchecked")
+    @TargetApi(13)
+    @Test
+    public void displayWarningForMisconfiguredActivities_withMisconfiguredActivities_withDebugFalse_shouldNotShowToast() throws Exception {
+        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN))).thenReturn(false);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(false);
+        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(false);
+        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
+
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
+
+        setDebugMode(false);
+
+        ManifestUtils.displayWarningForMissingActivities(context, requiredWebViewSdkActivities);
+
+        assertThat(ShadowToast.getLatestToast()).isNull();
     }
 
     @Test
@@ -164,6 +350,7 @@ public void isDebuggable_whenApplicationIsNotDebuggable_shouldReturnFalse() thro
         assertThat(ManifestUtils.isDebuggable(context)).isFalse();
     }
 
+    @SuppressWarnings("unchecked")
     @Test
     public void getRequiredWebViewSdkActivities_shouldIncludeRequiredActivities() throws Exception {
         assertThat(requiredWebViewSdkActivities).containsOnly(
@@ -174,6 +361,7 @@ public void getRequiredWebViewSdkActivities_shouldIncludeRequiredActivities() th
         );
     }
 
+    @SuppressWarnings("unchecked")
     @Test
     public void getRequiredNativeSdkActivities_shouldIncludeRequiredActivities() throws Exception {
         assertThat(requiredNativeSdkActivities).containsOnly(
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/ReflectionTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/ReflectionTest.java
index 2b73cf80..bf0ddd79 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/util/ReflectionTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/ReflectionTest.java
@@ -2,6 +2,7 @@
 
 import android.app.Activity;
 import android.view.View;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -145,14 +146,15 @@ public void execute_withStaticMethod_shouldPass() throws Exception {
         assertThat(methodBuilder.execute()).isEqualTo("20");
     }
 
-//    @Test
-//    public void execute_withAccessibility_shouldRunPrivateMethods() throws Exception {
-//        methodBuilder = new MethodBuilder(string, "foldCase");
-//        methodBuilder.addParam(char.class, 'a');
-//        methodBuilder.setAccessible();
-//
-//        char result = (Character) methodBuilder.execute();
-//
-//        assertThat(result).isEqualTo('a');
-//    }
+    @Test
+    public void execute_withAccessibility_shouldRunPrivateMethods() throws Exception {
+        methodBuilder = new MethodBuilder(string, "indexOfSupplementary");
+        methodBuilder.addParam(int.class, (int)'a');
+        methodBuilder.addParam(int.class, 0);
+        methodBuilder.setAccessible();
+
+        int result = (Integer) methodBuilder.execute();
+
+        assertThat(result).isEqualTo(-1);
+    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/StringsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/StringsTest.java
deleted file mode 100644
index 1f2279c6..00000000
--- a/mopub-sdk/src/test/java/com/mopub/common/util/StringsTest.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package com.mopub.common.util;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-
-@RunWith(RobolectricTestRunner.class)
-public class StringsTest {
-    @Test
-    public void isEmpty_shouldReturnValidResponse() throws Exception {
-        assertThat(Strings.isEmpty("")).isTrue();
-
-        assertThat(Strings.isEmpty("test")).isFalse();
-
-        assertThat(Strings.isEmpty(null)).isFalse();
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/UtilsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/UtilsTest.java
new file mode 100644
index 00000000..384e40b8
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/UtilsTest.java
@@ -0,0 +1,27 @@
+package com.mopub.common.util;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.HashSet;
+import java.util.Set;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+public class UtilsTest {
+    @Test
+    public void generateUniqueId_withMultipleInvocations_shouldReturnUniqueValues() throws Exception {
+        final int expectedIdCount = 100;
+
+        Set<Long> ids = new HashSet<Long>(expectedIdCount);
+        for (int i = 0; i < expectedIdCount; i++) {
+            final long id = Utils.generateUniqueId();
+            ids.add(id);
+        }
+
+        assertThat(ids).hasSize(expectedIdCount);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/ViewsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/ViewsTest.java
index 7f09ebcc..9c48181e 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/util/ViewsTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/ViewsTest.java
@@ -2,6 +2,7 @@
 
 import android.app.Activity;
 import android.content.Context;
+import android.content.res.Resources;
 import android.view.View;
 import android.widget.RelativeLayout;
 import android.widget.TextView;
@@ -18,12 +19,15 @@
     private Context context;
     private View subject;
     private RelativeLayout parent;
+    private Activity testActivity;
+    private Resources testResources;
 
     @Before
     public void setup() {
         context = new Activity();
         subject = new View(context);
         parent = new RelativeLayout(context);
+
     }
 
     @Test
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/test/support/CommonUtils.java b/mopub-sdk/src/test/java/com/mopub/common/util/test/support/CommonUtils.java
deleted file mode 100644
index b83bf83d..00000000
--- a/mopub-sdk/src/test/java/com/mopub/common/util/test/support/CommonUtils.java
+++ /dev/null
@@ -1,30 +0,0 @@
-package com.mopub.common.util.test.support;
-
-import org.apache.http.HttpRequest;
-import org.robolectric.Robolectric;
-
-import static com.mopub.common.util.ResponseHeader.USER_AGENT;
-import static org.fest.assertions.api.Assertions.assertThat;
-
-public class CommonUtils {
-    public static void assertHttpRequestsMade(final String userAgent, final String... urls) {
-        final int numberOfReceivedHttpRequests = Robolectric.getFakeHttpLayer().getSentHttpRequestInfos().size();
-        assertThat(numberOfReceivedHttpRequests).isEqualTo(urls.length);
-
-        for (final String url : urls) {
-            assertThat(Robolectric.httpRequestWasMade(url)).isTrue();
-        }
-
-        if (userAgent != null) {
-            while (true) {
-                final HttpRequest httpRequest = Robolectric.getNextSentHttpRequest();
-                if (httpRequest == null) {
-                    break;
-                }
-
-                assertThat(httpRequest.getFirstHeader(USER_AGENT.getKey()).getValue())
-                        .isEqualTo(userAgent);
-            }
-        }
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertGestureListenerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertGestureListenerTest.java
index 961ee9c0..09ae4f1d 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertGestureListenerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertGestureListenerTest.java
@@ -4,12 +4,14 @@
 import android.view.MotionEvent;
 import android.view.View;
 
+import com.mopub.common.AdReport;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.mobileads.test.support.GestureUtils;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
 
 import static com.mopub.mobileads.AdAlertGestureListener.ZigZagState.FAILED;
 import static com.mopub.mobileads.AdAlertGestureListener.ZigZagState.FINISHED;
@@ -17,13 +19,14 @@
 import static com.mopub.mobileads.AdAlertGestureListener.ZigZagState.GOING_RIGHT;
 import static com.mopub.mobileads.AdAlertGestureListener.ZigZagState.UNSET;
 import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.stub;
 
 @RunWith(SdkTestRunner.class)
 public class AdAlertGestureListenerTest {
-
-    private View view;
+    @Mock
+    private View mockView;
+    @Mock
+    private AdReport mockAdReport;
     private AdAlertGestureListener subject;
     private float threshold;
     private static final float INITIAL_X = 20;
@@ -31,17 +34,14 @@
     private float savedX;
     private float savedY;
     private MotionEvent actionDown;
-    private AdConfiguration adConfiguration;
-    private Context context;
+    @Mock
+    private Context mockContext;
 
     @Before
     public void setup() {
-        view = mock(View.class);
-        adConfiguration = mock(AdConfiguration.class);
-        context = mock(Context.class);
-        stub(view.getContext()).toReturn(context);
+        stub(mockView.getContext()).toReturn(mockContext);
 
-        subject = new AdAlertGestureListener(view, adConfiguration);
+        subject = new AdAlertGestureListener(mockView, mockAdReport);
 
         savedX = INITIAL_X;
         savedY = INITIAL_Y;
@@ -52,22 +52,22 @@ public void setup() {
 
     @Test
     public void constructor_shouldSetThresholdToOneThirdOfViewsWidth() throws Exception {
-        stub(view.getWidth()).toReturn(150);
-        subject = new AdAlertGestureListener(view, adConfiguration);
+        stub(mockView.getWidth()).toReturn(150);
+        subject = new AdAlertGestureListener(mockView, mockAdReport);
         assertThat(subject.getMinimumDipsInZigZag()).isEqualTo(50);
     }
 
     @Test
     public void constructor_whenViewWidthIsWiderThanThreeTimesMaxThreshold_shouldSetThresholdTo100() throws Exception {
-        stub(view.getWidth()).toReturn(500);
-        subject = new AdAlertGestureListener(view, adConfiguration);
+        stub(mockView.getWidth()).toReturn(500);
+        subject = new AdAlertGestureListener(mockView, mockAdReport);
         assertThat(subject.getMinimumDipsInZigZag()).isEqualTo(100);
     }
 
     @Test
     public void constructor_whenViewWidthIs0_shouldSetThresholdTo100() throws Exception {
-        stub(view.getWidth()).toReturn(0);
-        subject = new AdAlertGestureListener(view, adConfiguration);
+        stub(mockView.getWidth()).toReturn(0);
+        subject = new AdAlertGestureListener(mockView, mockAdReport);
         assertThat(subject.getMinimumDipsInZigZag()).isEqualTo(100);
     }
 
@@ -114,7 +114,7 @@ public void onScroll_withInitialLeftThenRightMovement_BeforeZigCompletes_MovesOu
         assertZigZagState(GOING_RIGHT);
         assertThat(subject.getNumberOfZigzags()).isEqualTo(0);
 
-        simulateScroll(savedX, INITIAL_Y + 52);
+        simulateScroll(savedX, INITIAL_Y + 102);
         assertZigZagState(FAILED);
     }
 
@@ -130,7 +130,7 @@ public void onScroll_withInitialLeftThenRightMovement_BeforeZigCompletes_MovesOu
         assertZigZagState(GOING_RIGHT);
         assertThat(subject.getNumberOfZigzags()).isEqualTo(0);
 
-        simulateScroll(savedX, INITIAL_Y - 51);
+        simulateScroll(savedX, INITIAL_Y - 101);
         assertZigZagState(FAILED);
     }
 
@@ -145,7 +145,7 @@ public void onScroll_withZigZagZigZagZigZagZig_BeforeNextZagCompletes_MovesOutOf
         assertZigZagState(GOING_RIGHT);
         assertThat(subject.getNumberOfZigzags()).isEqualTo(3);
 
-        simulateScroll(savedX, INITIAL_Y + 51);
+        simulateScroll(savedX, INITIAL_Y + 101);
         assertZigZagState(FAILED);
     }
 
@@ -160,14 +160,14 @@ public void onScroll_withZigZagZigZagZigZagZig_BeforeNextZagCompletes_MovesOutOf
         assertZigZagState(GOING_LEFT);
         assertThat(subject.getNumberOfZigzags()).isEqualTo(3);
 
-        simulateScroll(savedX, INITIAL_Y - 51);
+        simulateScroll(savedX, INITIAL_Y - 101);
         assertZigZagState(FAILED);
     }
 
     @Test
     public void onScroll_withStateFailed_withAnyMotion_shouldStayFailed() throws Exception {
         simulateScroll(savedX, INITIAL_Y + 49);
-        simulateScroll(savedX, INITIAL_Y + 51);
+        simulateScroll(savedX, INITIAL_Y + 101);
         assertZigZagState(FAILED);
 
         performZigZag();
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertReporterTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertReporterTest.java
index ce36a6e8..89cf32d8 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertReporterTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertReporterTest.java
@@ -8,12 +8,15 @@
 import android.view.View;
 import android.widget.TextView;
 
+import com.mopub.common.AdReport;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.common.util.test.support.TestDateAndTime;
 
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
 import org.robolectric.Robolectric;
 
 import java.io.File;
@@ -26,15 +29,21 @@
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.stub;
+import static org.mockito.Mockito.verify;
 
 @RunWith(SdkTestRunner.class)
 public class AdAlertReporterTest {
     private final static String EMAIL_ADDRESS = "creative-review@mopub.com";
     private AdAlertReporter subject;
-    private Context context;
-    private View view;
-    private AdConfiguration adConfiguration;
+    @Mock
+    private AdReport mockAdReport;
+    @Mock
+    private Context mockContext;
+    @Mock
+    private View mockView;
     private Intent emailIntent;
     private Bitmap bitmap;
     private ArrayList<Uri> emailAttachments;
@@ -42,15 +51,10 @@
 
     @Before
     public void setup() {
-        context = mock(Context.class);
-
         bitmap = Bitmap.createBitmap(10, 10, Bitmap.Config.ARGB_8888);
 
-        view = mock(View.class);
-        stub(view.getRootView()).toReturn(view);
-        stub(view.getDrawingCache()).toReturn(bitmap);
-
-        adConfiguration = mock(AdConfiguration.class);
+        stub(mockView.getRootView()).toReturn(mockView);
+        stub(mockView.getDrawingCache()).toReturn(bitmap);
 
         now = new Date();
         TestDateAndTime.getInstance().setNow(now);
@@ -58,7 +62,7 @@ public void setup() {
 
     @Test
     public void constructor_shouldCreateSendToIntentWithEmailAddress() throws Exception {
-        subject = new AdAlertReporter(context, view, adConfiguration);
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
         emailIntent = subject.getEmailIntent();
 
         assertThat(emailIntent.getAction()).isEqualTo(Intent.ACTION_SEND_MULTIPLE);
@@ -69,7 +73,7 @@ public void constructor_shouldCreateSendToIntentWithEmailAddress() throws Except
 
     @Test
     public void constructor_shouldCreateIntentWithDatestampInSubject() throws Exception {
-        subject = new AdAlertReporter(context, view, adConfiguration);
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
         emailIntent = subject.getEmailIntent();
 
         String emailSubject = emailIntent.getStringExtra(Intent.EXTRA_SUBJECT);
@@ -79,7 +83,7 @@ public void constructor_shouldCreateIntentWithDatestampInSubject() throws Except
         assertThat(title).isEqualTo("New creative violation report");
 
         String dateTimeString = subjectParts[1];
-        SimpleDateFormat dateFormat = new SimpleDateFormat("M/d/yy hh:mm:ss a z");
+        SimpleDateFormat dateFormat = new SimpleDateFormat("M/d/yy hh:mm:ss a z", Locale.US);
 
         Date date = dateFormat.parse(dateTimeString);
 
@@ -91,23 +95,11 @@ public void constructor_shouldCreateIntentWithImageStringAndParametersAndRespons
         TextView textView = mock(TextView.class);
         Bitmap sampleBitmap = Bitmap.createBitmap(10, 10, Bitmap.Config.ALPHA_8);
         stub(textView.getDrawingCache()).toReturn(sampleBitmap);
-        stub(view.getRootView()).toReturn(textView);
-
-        stub(adConfiguration.getResponseString()).toReturn("<html>a valid response</html>");
-        stub(adConfiguration.getDspCreativeId()).toReturn("");
-        stub(adConfiguration.getPlatformVersion()).toReturn(1);
-        stub(adConfiguration.getDeviceModel()).toReturn("android");
-        stub(adConfiguration.getAdUnitId()).toReturn("abc");
-        stub(adConfiguration.getDeviceLocale()).toReturn("US");
-        stub(adConfiguration.getHashedUdid()).toReturn("UDID");
-        stub(adConfiguration.getNetworkType()).toReturn("unknown");
-        stub(adConfiguration.getPlatform()).toReturn("android");
-        stub(adConfiguration.getTimeStamp()).toReturn(now.getTime());
-        stub(adConfiguration.getAdType()).toReturn("interstitial");
-        stub(adConfiguration.getWidth()).toReturn(480);
-        stub(adConfiguration.getHeight()).toReturn(320);
-
-        subject = new AdAlertReporter(context, view, adConfiguration);
+        stub(mockView.getRootView()).toReturn(textView);
+
+        stub(mockAdReport.toString()).toReturn("Ad Report data - this is a long list of newlined params.");
+        stub(mockAdReport.getResponseString()).toReturn("Test ad string.");
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
 
         emailIntent = subject.getEmailIntent();
         String emailSubject = emailIntent.getStringExtra(Intent.EXTRA_TEXT);
@@ -125,9 +117,9 @@ public void constructor_shouldCreateIntentWithImageStringAndParametersAndRespons
 
     @Test
     public void constructor_shouldAddBitmapToAttachmentArray() throws Exception {
-        stub(context.getFilesDir()).toReturn(new File("filesDir"));
-        stub(context.openFileOutput(any(String.class), any(int.class))).toReturn(mock(FileOutputStream.class));
-        subject = new AdAlertReporter(context, view, adConfiguration);
+        stub(mockContext.getFilesDir()).toReturn(new File("filesDir"));
+        stub(mockContext.openFileOutput(any(String.class), any(int.class))).toReturn(mock(FileOutputStream.class));
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
 
         emailAttachments = subject.getEmailAttachments();
         Uri fileUri = Uri.fromFile(new File("filesDir/mp_adalert_screenshot.png"));
@@ -137,9 +129,9 @@ public void constructor_shouldAddBitmapToAttachmentArray() throws Exception {
 
     @Test
     public void constructor_shouldAddParametersTextFileToAttachmentArray() throws Exception {
-        stub(context.getFilesDir()).toReturn(new File("filesDir"));
-        stub(context.openFileOutput(any(String.class), any(int.class))).toReturn(mock(FileOutputStream.class));
-        subject = new AdAlertReporter(context, view, adConfiguration);
+        stub(mockContext.getFilesDir()).toReturn(new File("filesDir"));
+        stub(mockContext.openFileOutput(any(String.class), any(int.class))).toReturn(mock(FileOutputStream.class));
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
 
         emailAttachments = subject.getEmailAttachments();
         Uri fileUri = Uri.fromFile(new File("filesDir/mp_adalert_parameters.txt"));
@@ -148,100 +140,29 @@ public void constructor_shouldAddParametersTextFileToAttachmentArray() throws Ex
     }
 
     @Test
-    public void constructor_shouldProperlyConstructParametersTextFile() throws Exception {
-        String expectedParameters =
-                "sdk_version : 1.15.2.2\n" +
-                "creative_id : \n" +
-                "platform_version : 1\n" +
-                "device_model : android\n" +
-                "ad_unit_id : abc\n" +
-                "device_locale : US\n" +
-                "device_id : UDID\n" +
-                "network_type : unknown\n" +
-                "platform : android\n" +
-                "timestamp : " + getCurrentDateTime() + "\n" +
-                "ad_type : interstitial\n" +
-                "ad_size : {480, 320}\n";
-
-        stub(adConfiguration.getSdkVersion()).toReturn("1.15.2.2");
-        stub(adConfiguration.getDspCreativeId()).toReturn("");
-        stub(adConfiguration.getPlatformVersion()).toReturn(1);
-        stub(adConfiguration.getDeviceModel()).toReturn("android");
-        stub(adConfiguration.getAdUnitId()).toReturn("abc");
-        stub(adConfiguration.getDeviceLocale()).toReturn("US");
-        stub(adConfiguration.getHashedUdid()).toReturn("UDID");
-        stub(adConfiguration.getNetworkType()).toReturn("unknown");
-        stub(adConfiguration.getPlatform()).toReturn("android");
-        stub(adConfiguration.getTimeStamp()).toReturn(now.getTime());
-        stub(adConfiguration.getAdType()).toReturn("interstitial");
-        stub(adConfiguration.getWidth()).toReturn(480);
-        stub(adConfiguration.getHeight()).toReturn(320);
-
-        subject = new AdAlertReporter(context, view, adConfiguration);
-
-        assertThat(subject.getParameters()).isEqualTo(expectedParameters);
-    }
-
-    @Test
-    public void constructor_withInvalidAdConfigurationValues_shouldReturnSomethingSensible() throws Exception {
-        String expectedParameters =
-                "sdk_version : null\n" +
-                "creative_id : null\n" +
-                "platform_version : -1\n" +
-                "device_model : null\n" +
-                "ad_unit_id : null\n" +
-                "device_locale : null\n" +
-                "device_id : null\n" +
-                "network_type : null\n" +
-                "platform : null\n" +
-                "timestamp : null" + "\n" +
-                "ad_type : null\n" +
-                "ad_size : {-1, -1}\n";
-
-        stub(adConfiguration.getSdkVersion()).toReturn(null);
-        stub(adConfiguration.getDspCreativeId()).toReturn(null);
-        stub(adConfiguration.getPlatformVersion()).toReturn(-1);
-        stub(adConfiguration.getDeviceModel()).toReturn(null);
-        stub(adConfiguration.getAdUnitId()).toReturn(null);
-        stub(adConfiguration.getDeviceLocale()).toReturn(null);
-        stub(adConfiguration.getHashedUdid()).toReturn(null);
-        stub(adConfiguration.getNetworkType()).toReturn(null);
-        stub(adConfiguration.getPlatform()).toReturn(null);
-        stub(adConfiguration.getTimeStamp()).toReturn(-1l);
-        stub(adConfiguration.getAdType()).toReturn(null);
-        stub(adConfiguration.getWidth()).toReturn(-1);
-        stub(adConfiguration.getHeight()).toReturn(-1);
-
-        subject = new AdAlertReporter(context, view, adConfiguration);
-
-        assertThat(subject.getParameters()).isEqualTo(expectedParameters);
-    }
-
-    @Test
-    public void constructor_whenAdConfigurationIsNull_shouldReturnEmptyString() throws Exception {
-        subject = new AdAlertReporter(context, view, null);
+    public void constructor_whenAdReportIsNull_shouldReturnEmptyString() throws Exception {
+        subject = new AdAlertReporter(mockContext, mockView, null);
 
         assertThat(subject.getParameters()).isEmpty();
         assertThat(subject.getResponse()).isEmpty();
     }
 
     @Test
-    public void constructor_shouldReturnCorrectResponseString() throws Exception {
+    public void constructor_shouldSetCorrectResponseString() throws Exception {
         String expectedResponse = "response";
 
-        stub(adConfiguration.getResponseString()).toReturn(expectedResponse);
-        subject = new AdAlertReporter(context, view, adConfiguration);
+        stub(mockAdReport.getResponseString()).toReturn(expectedResponse);
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
 
         assertThat(subject.getResponse()).isEqualTo(expectedResponse);
     }
 
     @Test
     public void constructor_shouldAddMarkupTextFileToAttachmentArray() throws Exception {
-        stub(adConfiguration.getResponseString()).toReturn(" ");
-
-        stub(context.getFilesDir()).toReturn(new File("filesDir"));
-        stub(context.openFileOutput(any(String.class), any(int.class))).toReturn(mock(FileOutputStream.class));
-        subject = new AdAlertReporter(context, view, adConfiguration);
+        stub(mockAdReport.getResponseString()).toReturn("anything!");
+        stub(mockContext.getFilesDir()).toReturn(new File("filesDir"));
+        stub(mockContext.openFileOutput(any(String.class), any(int.class))).toReturn(mock(FileOutputStream.class));
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
 
         emailAttachments = subject.getEmailAttachments();
         Uri fileUri = Uri.fromFile(new File("filesDir/mp_adalert_markup.html"));
@@ -251,11 +172,10 @@ public void constructor_shouldAddMarkupTextFileToAttachmentArray() throws Except
 
     @Test
     public void send_shouldAddAttachmentsToIntent() throws Exception {
-        stub(adConfiguration.getResponseString()).toReturn("response!");
-        stub(context.getFilesDir()).toReturn(new File("filesDir"));
-        stub(context.openFileOutput(any(String.class), any(int.class))).toReturn(mock(FileOutputStream.class));
-
-        subject = new AdAlertReporter(context, view, adConfiguration);
+        stub(mockContext.getFilesDir()).toReturn(new File("filesDir"));
+        stub(mockContext.openFileOutput(any(String.class), any(int.class))).toReturn(mock(FileOutputStream.class));
+        stub(mockAdReport.getResponseString()).toReturn("anything!");
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
         subject.send();
 
         emailIntent = subject.getEmailIntent();
@@ -269,9 +189,8 @@ public void send_shouldAddAttachmentsToIntent() throws Exception {
 
     @Test
     public void send_shouldCreateEmailChooserIntent() throws Exception {
-        stub(adConfiguration.getResponseString()).toReturn("response!");
 
-        subject = new AdAlertReporter(new Activity(), view, adConfiguration);
+        subject = new AdAlertReporter(Robolectric.buildActivity(Activity.class).create().get(), mockView, mockAdReport);
         subject.send();
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
@@ -280,56 +199,52 @@ public void send_shouldCreateEmailChooserIntent() throws Exception {
         assertThat(intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
     }
 
+    @Ignore("pending")
     @Test
     public void getScreenshot_whenIsDrawingCacheEnabled_shouldKeepDrawingCacheEnabled() throws Exception {
-//        reset(view);
-//        stub(view.getRootView()).toReturn(view);
-//        stub(view.isDrawingCacheEnabled()).toReturn(true);
-//
-//        subject = new AdAlertReporter(context, view, adConfiguration);
-//
-//        verify(view, never()).setDrawingCacheEnabled(false);
+        reset(mockView);
+        stub(mockView.getRootView()).toReturn(mockView);
+        stub(mockView.isDrawingCacheEnabled()).toReturn(true);
+
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
+
+        verify(mockView, never()).setDrawingCacheEnabled(false);
     }
 
+    @Ignore("pending")
     @Test
     public void getScreenshot_whenIsDrawingCacheDisabled_shouldKeepDrawingCacheDisabled() throws Exception {
-//        reset(view);
-//        stub(view.getRootView()).toReturn(view);
-//        stub(view.isDrawingCacheEnabled()).toReturn(false);
-//
-//        subject = new AdAlertReporter(context, view, adConfiguration);
-//
-//        verify(view).setDrawingCacheEnabled(false);
+        reset(mockView);
+        stub(mockView.getRootView()).toReturn(mockView);
+        stub(mockView.isDrawingCacheEnabled()).toReturn(false);
+
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
+
+        verify(mockView).setDrawingCacheEnabled(false);
     }
 
     @Test
     public void getScreenshot_whenViewIsNull_shouldPass() throws Exception {
-        subject = new AdAlertReporter(context, null, adConfiguration);
+        subject = new AdAlertReporter(mockContext, null, mockAdReport);
 
         // pass
     }
 
     @Test
     public void getScreenshot_whenRootViewIsNull_shouldPass() throws Exception {
-        stub(view.getRootView()).toReturn(null);
+        stub(mockView.getRootView()).toReturn(null);
 
-        subject = new AdAlertReporter(context, view, adConfiguration);
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
 
         // pass
     }
 
     @Test
     public void getScreenshot_whenRootViewDrawingCacheIsNull_shouldPass() throws Exception {
-        stub(view.getDrawingCache()).toReturn(null);
+        stub(mockView.getDrawingCache()).toReturn(null);
 
-        subject = new AdAlertReporter(context, view, adConfiguration);
+        subject = new AdAlertReporter(mockContext, mockView, mockAdReport);
 
         // pass
     }
-
-    private String getCurrentDateTime() {
-        SimpleDateFormat dateFormat = new SimpleDateFormat("M/d/yy hh:mm:ss a z");
-        return dateFormat.format(now);
-    }
 }
-
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdConfigurationTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdConfigurationTest.java
deleted file mode 100644
index f238ba05..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/AdConfigurationTest.java
+++ /dev/null
@@ -1,277 +0,0 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.content.Context;
-import android.os.Build;
-
-import com.mopub.common.MoPub;
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.test.support.TestDateAndTime;
-import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-
-import java.util.*;
-
-import static com.mopub.mobileads.AdViewController.MINIMUM_REFRESH_TIME_MILLISECONDS;
-import static com.mopub.common.util.ResponseHeader.AD_TIMEOUT;
-import static com.mopub.common.util.ResponseHeader.AD_TYPE;
-import static com.mopub.common.util.ResponseHeader.CLICKTHROUGH_URL;
-import static com.mopub.common.util.ResponseHeader.DSP_CREATIVE_ID;
-import static com.mopub.common.util.ResponseHeader.FAIL_URL;
-import static com.mopub.common.util.ResponseHeader.HEIGHT;
-import static com.mopub.common.util.ResponseHeader.IMPRESSION_URL;
-import static com.mopub.common.util.ResponseHeader.NETWORK_TYPE;
-import static com.mopub.common.util.ResponseHeader.REDIRECT_URL;
-import static com.mopub.common.util.ResponseHeader.REFRESH_TIME;
-import static com.mopub.common.util.ResponseHeader.WIDTH;
-import static org.fest.assertions.api.Assertions.assertThat;
-
-@RunWith(SdkTestRunner.class)
-public class AdConfigurationTest {
-    private AdConfiguration subject;
-    private Context context;
-    private TestHttpResponseWithHeaders httpResponse;
-
-    @Before
-    public void setUp() throws Exception {
-        context = new Activity();
-
-        subject = new AdConfiguration(context);
-
-        httpResponse = new TestHttpResponseWithHeaders(200, "I ain't got no-body");
-    }
-
-    @Test
-    public void constructor_shouldSetDefaults() throws Exception {
-        assertThat(subject.getAdUnitId()).isNull();
-        assertThat(subject.getResponseString()).isNull();
-        assertThat(subject.getAdType()).isNull();
-        assertThat(subject.getNetworkType()).isNull();
-        assertThat(subject.getRedirectUrl()).isNull();
-        assertThat(subject.getClickthroughUrl()).isNull();
-        assertThat(subject.getImpressionUrl()).isNull();
-        assertThat(subject.getTimeStamp()).isEqualTo(TestDateAndTime.now().getTime());
-        assertThat(subject.getWidth()).isEqualTo(0);
-        assertThat(subject.getHeight()).isEqualTo(0);
-        assertThat(subject.getAdTimeoutDelay()).isNull();
-        assertThat(subject.getRefreshTimeMilliseconds()).isEqualTo(60000);
-        assertThat(subject.getFailUrl()).isNull();
-        assertThat(subject.getDspCreativeId()).isNull();
-    }
-
-    @Test
-    public void constructor_shouldSetHashedUdid() throws Exception {
-        // this is sha1 of null
-        assertThat(subject.getHashedUdid()).isEqualTo("da39a3ee5e6b4b0d3255bfef95601890afd80709");
-    }
-
-    @Test
-    public void constructor_withNullContext_shouldNotSetHashedUdid() throws Exception {
-        subject = new AdConfiguration(null);
-
-        assertThat(subject.getHashedUdid()).isNull();
-    }
-
-    @Test
-    public void constructor_shouldSetUserAgent() throws Exception {
-        assertThat(subject.getUserAgent()).isEqualTo("Mozilla/5.0 (Linux; U; Android 4.0.3; ko-kr; LG-L160L Build/IML74K) AppleWebkit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30");
-    }
-
-    @Test
-    public void constructor_withNullContext_shouldSetUserAgent() throws Exception {
-        subject = new AdConfiguration(null);
-
-        assertThat(subject.getUserAgent()).isNull();
-    }
-
-    @Test
-    public void constructor_shouldSetDeviceLocale() throws Exception {
-        Robolectric.getShadowApplication().getResources().getConfiguration().locale = Locale.FRANCE;
-
-        subject = new AdConfiguration(context);
-
-        assertThat(subject.getDeviceLocale()).isEqualTo("fr_FR");
-    }
-
-    @Test
-    public void constructor_withNullContext_shouldNotSetDeviceLocale() throws Exception {
-        Robolectric.getShadowApplication().getResources().getConfiguration().locale = Locale.FRANCE;
-
-        subject = new AdConfiguration(null);
-
-        assertThat(subject.getDeviceLocale()).isNull();
-    }
-
-    @Test
-    public void constructor_shouldSetDeviceModelAndPlatformVersionAndSdkVersion() throws Exception {
-        assertThat(subject.getDeviceModel()).isNotNull();
-        assertThat(subject.getPlatformVersion()).isEqualTo(Build.VERSION.SDK_INT);
-        assertThat(subject.getSdkVersion()).isEqualTo(MoPub.SDK_VERSION);
-    }
-
-    @Test
-    public void constructor_shouldSetBroadcastIdentifier() throws Exception {
-        assertThat(subject.getBroadcastIdentifier()).isGreaterThan(0);
-    }
-
-    @Test
-    public void addHttpResponse_shouldSetFields() throws Exception {
-        Date now = new Date();
-        TestDateAndTime.getInstance().setNow(now);
-
-        httpResponse.addHeader(AD_TYPE.getKey(), "this is an ad type");
-        httpResponse.addHeader(NETWORK_TYPE.getKey(), "network type!");
-        httpResponse.addHeader(REDIRECT_URL.getKey(), "redirect url");
-        httpResponse.addHeader(CLICKTHROUGH_URL.getKey(), "clickthrough url");
-        httpResponse.addHeader(FAIL_URL.getKey(), "fail url");
-        httpResponse.addHeader(IMPRESSION_URL.getKey(), "impression url");
-        httpResponse.addHeader(WIDTH.getKey(), "320  ");
-        httpResponse.addHeader(HEIGHT.getKey(), "  50");
-        httpResponse.addHeader(AD_TIMEOUT.getKey(), "  12  ");
-        httpResponse.addHeader(REFRESH_TIME.getKey(), "70");
-        httpResponse.addHeader(DSP_CREATIVE_ID.getKey(), "1534363");
-
-        subject.addHttpResponse(httpResponse);
-
-        assertThat(subject.getAdType()).isEqualTo("this is an ad type");
-        assertThat(subject.getNetworkType()).isEqualTo("network type!");
-        assertThat(subject.getRedirectUrl()).isEqualTo("redirect url");
-        assertThat(subject.getClickthroughUrl()).isEqualTo("clickthrough url");
-        assertThat(subject.getFailUrl()).isEqualTo("fail url");
-        assertThat(subject.getImpressionUrl()).isEqualTo("impression url");
-        assertThat(subject.getTimeStamp()).isEqualTo(now.getTime());
-        assertThat(subject.getWidth()).isEqualTo(320);
-        assertThat(subject.getHeight()).isEqualTo(50);
-        assertThat(subject.getAdTimeoutDelay()).isEqualTo(12);
-        assertThat(subject.getRefreshTimeMilliseconds()).isEqualTo(70000);
-        assertThat(subject.getDspCreativeId()).isEqualTo("1534363");
-    }
-
-    @Test
-    public void addHttpResponse_withMissingWidthHeader_shouldSetWidthTo0() throws Exception {
-        httpResponse.addHeader(HEIGHT.getKey(), "25");
-
-        subject.addHttpResponse(httpResponse);
-
-        assertThat(subject.getWidth()).isEqualTo(0);
-    }
-
-    @Test
-    public void addHttpResponse_withMissingHeightHeader_shouldSetHeightTo0() throws Exception {
-        subject.addHttpResponse(httpResponse);
-
-        assertThat(subject.getHeight()).isEqualTo(0);
-    }
-
-    @Test
-    public void addHttpResponse_withFloatTimeoutDelay_shouldTruncateTimeoutDelay() throws Exception {
-        httpResponse.addHeader("X-AdTimeout", "3.14");
-        subject.addHttpResponse(httpResponse);
-        assertThat(subject.getAdTimeoutDelay()).isEqualTo(3);
-
-        httpResponse = new TestHttpResponseWithHeaders(200, "I ain't got no-body");
-        httpResponse.addHeader("X-AdTimeout", "-3.14");
-        subject.addHttpResponse(httpResponse);
-        assertThat(subject.getAdTimeoutDelay()).isEqualTo(-3);
-    }
-
-    @Test
-    public void addHttpResponse_withInvalidTimeoutDelay_shouldSetAdTimeoutDelayToNull() throws Exception {
-        // no X-AdTimeout header
-        subject.addHttpResponse(httpResponse);
-        assertThat(subject.getAdTimeoutDelay()).isNull();
-
-        httpResponse = new TestHttpResponseWithHeaders(200, "I ain't got no-body");
-        httpResponse.addHeader("X-AdTimeout", "not a number, i promise");
-        subject.addHttpResponse(httpResponse);
-        assertThat(subject.getAdTimeoutDelay()).isNull();
-    }
-
-    @Test
-    public void addHttpResponse_shouldSetRefreshTimeToMinimumOf10Seconds() throws Exception {
-        httpResponse.addHeader("X-Refreshtime", "0");
-
-        subject.addHttpResponse(httpResponse);
-        assertThat(subject.getRefreshTimeMilliseconds()).isEqualTo(MINIMUM_REFRESH_TIME_MILLISECONDS);
-    }
-
-    @Test
-    public void addHttpResponse_whenRefreshTimeNotSpecified_shouldResetRefreshTimeTo0Seconds() throws Exception {
-        httpResponse.addHeader("X-Refreshtime", "5");
-        subject.addHttpResponse(httpResponse);
-
-        assertThat(subject.getRefreshTimeMilliseconds()).isEqualTo(MINIMUM_REFRESH_TIME_MILLISECONDS);
-        httpResponse = new TestHttpResponseWithHeaders(200, "I ain't got no-body");
-        // no X-Refreshtime header
-        subject.addHttpResponse(httpResponse);
-
-        assertThat(subject.getRefreshTimeMilliseconds()).isEqualTo(0);
-    }
-
-    @Test
-    public void cleanup_shouldClearAllFields() throws Exception {
-        Date now = new Date();
-        TestDateAndTime.getInstance().setNow(now);
-
-        httpResponse.addHeader(AD_TYPE.getKey(), "this is an ad type");
-        httpResponse.addHeader(NETWORK_TYPE.getKey(), "network type!");
-        httpResponse.addHeader(REDIRECT_URL.getKey(), "redirect url");
-        httpResponse.addHeader(CLICKTHROUGH_URL.getKey(), "clickthrough url");
-        httpResponse.addHeader(FAIL_URL.getKey(), "fail url");
-        httpResponse.addHeader(IMPRESSION_URL.getKey(), "impression url");
-        httpResponse.addHeader(WIDTH.getKey(), "320  ");
-        httpResponse.addHeader(HEIGHT.getKey(), "  50");
-        httpResponse.addHeader(AD_TIMEOUT.getKey(), "  12  ");
-        httpResponse.addHeader(REFRESH_TIME.getKey(), "70");
-        httpResponse.addHeader(DSP_CREATIVE_ID.getKey(), "1534363");
-
-        subject.addHttpResponse(httpResponse);
-        subject.cleanup();
-
-        assertThat(subject.getBroadcastIdentifier()).isEqualTo(0);
-        assertThat(subject.getAdUnitId()).isNull();
-        assertThat(subject.getResponseString()).isNull();
-        assertThat(subject.getAdType()).isNull();
-        assertThat(subject.getNetworkType()).isNull();
-        assertThat(subject.getRedirectUrl()).isNull();
-        assertThat(subject.getClickthroughUrl()).isNull();
-        assertThat(subject.getImpressionUrl()).isNull();
-        assertThat(subject.getTimeStamp()).isEqualTo(TestDateAndTime.now().getTime());
-        assertThat(subject.getWidth()).isEqualTo(0);
-        assertThat(subject.getHeight()).isEqualTo(0);
-        assertThat(subject.getAdTimeoutDelay()).isNull();
-        assertThat(subject.getRefreshTimeMilliseconds()).isEqualTo(60000);
-        assertThat(subject.getFailUrl()).isNull();
-        assertThat(subject.getDspCreativeId()).isNull();
-    }
-
-    @Test
-    public void extractFromMap_shouldReturnValidAdConfiguration() throws Exception {
-        Map<String, Object> map = new HashMap<String, Object>();
-        map.put(AdFetcher.AD_CONFIGURATION_KEY, subject);
-
-        AdConfiguration returnValue = AdConfiguration.extractFromMap(map);
-
-        assertThat(returnValue).isEqualTo(subject);
-    }
-
-    @Test
-    public void extractFromMap_withNullMap_shouldReturnNull() throws Exception {
-        AdConfiguration returnValue = AdConfiguration.extractFromMap(null);
-
-        assertThat(returnValue).isEqualTo(null);
-    }
-
-    @Test
-    public void extractFromMap_withNonAdConfigurationObjectInMap_shouldReturnNull() throws Exception {
-        Map<String, Object> map = new HashMap<String, Object>();
-        map.put(AdFetcher.AD_CONFIGURATION_KEY, "not_an_ad_configuration");
-
-        AdConfiguration returnValue = AdConfiguration.extractFromMap(map);
-
-        assertThat(returnValue).isEqualTo(null);
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdFetcherTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdFetcherTest.java
deleted file mode 100644
index 22cf06bc..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/AdFetcherTest.java
+++ /dev/null
@@ -1,126 +0,0 @@
-package com.mopub.mobileads;
-
-import android.os.Build;
-import android.os.Build.VERSION_CODES;
-
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.mobileads.factories.AdFetchTaskFactory;
-import com.mopub.mobileads.test.support.TestAdFetchTaskFactory;
-import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
-
-import org.apache.http.HttpResponse;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.annotation.Config;
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.concurrent.Executor;
-
-import static com.mopub.common.util.ResponseHeader.AD_TYPE;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_DATA;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_NAME;
-import static com.mopub.common.util.ResponseHeader.FULL_AD_TYPE;
-import static com.mopub.common.util.ResponseHeader.NATIVE_PARAMS;
-import static com.mopub.common.util.VersionCode.GINGERBREAD;
-import static com.mopub.common.util.VersionCode.ICE_CREAM_SANDWICH;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.stub;
-import static org.mockito.Mockito.verify;
-
-@RunWith(SdkTestRunner.class)
-public class AdFetcherTest {
-    private AdFetcher subject;
-    private AdViewController adViewController;
-    private MoPubView moPubView;
-    private HttpResponse response;
-
-    @Before
-    public void setup() {
-        adViewController = mock(AdViewController.class);
-        moPubView = mock(MoPubView.class);
-        stub(adViewController.getMoPubView()).toReturn(moPubView);
-
-        subject = new AdFetcher(adViewController, "expected userAgent");
-        response = new TestHttpResponseWithHeaders(200, "yahoo!!!");
-    }
-
-    @Test
-    public void shouldSendResponseToAdView() {
-        Robolectric.addPendingHttpResponse(response);
-
-        subject.fetchAdForUrl("url");
-
-        verify(adViewController).configureUsingHttpResponse(eq(response));
-    }
-
-    @Test
-    public void fetchAdForUrl_shouldRouteMillennialBannerToCustomEventHandling() throws Exception {
-        String json = "{\"adWidth\": 320, \"adHeight\": 50, \"adUnitID\": \"44310\"}";
-        stub(adViewController.getAdConfiguration()).toReturn(mock(AdConfiguration.class));
-        response.addHeader(AD_TYPE.getKey(), "millennial_native");
-        response.addHeader(NATIVE_PARAMS.getKey(), json);
-        Robolectric.addPendingHttpResponse(response);
-
-        subject.fetchAdForUrl("ignored_url");
-
-        Map<String, String> paramsMap = new HashMap<String, String>();
-        paramsMap.put(CUSTOM_EVENT_NAME.getKey(), "com.mopub.mobileads.MillennialBanner");
-        paramsMap.put(CUSTOM_EVENT_DATA.getKey(), json);
-
-        verify(moPubView).loadCustomEvent(eq(paramsMap));
-    }
-
-    @Test
-    public void fetchAdForUrl_shouldRouteMillennialInterstitialToCustomEventHandling() throws Exception {
-        AdViewController interstitialAdViewController = mock(AdViewController.class);
-        MoPubInterstitial.MoPubInterstitialView moPubInterstitialView = mock(MoPubInterstitial.MoPubInterstitialView.class);
-        stub(interstitialAdViewController.getMoPubView()).toReturn(moPubInterstitialView);
-        stub(interstitialAdViewController.getAdConfiguration()).toReturn(mock(AdConfiguration.class));
-        subject = new AdFetcher(interstitialAdViewController, "expected userAgent");
-
-        String json = "{\"adWidth\": 320, \"adHeight\": 480, \"adUnitID\": \"44310\"}";
-        response.addHeader(AD_TYPE.getKey(), "interstitial");
-        response.addHeader(FULL_AD_TYPE.getKey(), "millennial_full");
-        response.addHeader(NATIVE_PARAMS.getKey(), json);
-        Robolectric.addPendingHttpResponse(response);
-
-        subject.fetchAdForUrl("ignored_url");
-
-        Map<String, String> paramsMap = new HashMap<String, String>();
-        paramsMap.put(CUSTOM_EVENT_NAME.getKey(), "com.mopub.mobileads.MillennialInterstitial");
-        paramsMap.put(CUSTOM_EVENT_DATA.getKey(), json);
-
-        verify(moPubInterstitialView).loadCustomEvent(eq(paramsMap));
-    }
-
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
-    @Test
-    public void fetchAdForUrl_atLeastIcs_shouldExecuteUsingAnExecutor() throws Exception {
-        AdFetchTaskFactory.setInstance(new TestAdFetchTaskFactory());
-        AdFetchTask adFetchTask = TestAdFetchTaskFactory.getSingletonMock();
-
-        subject.fetchAdForUrl("some url");
-
-        verify(adFetchTask).executeOnExecutor(any(Executor.class), eq("some url"));
-        verify(adFetchTask, never()).execute(anyString());
-    }
-
-    @Config(reportSdk = VERSION_CODES.GINGERBREAD_MR1)
-    @Test
-    public void fetchAdForUrl_beforeHoneycomb_shouldExecuteWithoutAnExecutor() throws Exception {
-        AdFetchTaskFactory.setInstance(new TestAdFetchTaskFactory());
-        AdFetchTask adFetchTask = TestAdFetchTaskFactory.getSingletonMock();
-
-        subject.fetchAdForUrl("some url");
-
-        verify(adFetchTask, never()).executeOnExecutor(any(Executor.class), anyString());
-        verify(adFetchTask).execute(eq("some url"));
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdLoadTaskTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdLoadTaskTest.java
deleted file mode 100644
index a14bf614..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/AdLoadTaskTest.java
+++ /dev/null
@@ -1,193 +0,0 @@
-package com.mopub.mobileads;
-
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.mobileads.test.support.JsonUtils;
-import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
-
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpResponse;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import static com.mopub.common.util.ResponseHeader.AD_TYPE;
-import static com.mopub.common.util.ResponseHeader.CLICKTHROUGH_URL;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_DATA;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_NAME;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_SELECTOR;
-import static com.mopub.common.util.ResponseHeader.NATIVE_PARAMS;
-import static com.mopub.common.util.ResponseHeader.REDIRECT_URL;
-import static com.mopub.common.util.ResponseHeader.SCROLLABLE;
-import static com.mopub.mobileads.AdTypeTranslator.CustomEventType.GOOGLE_PLAY_SERVICES_BANNER;
-import static com.mopub.mobileads.AdTypeTranslator.CustomEventType.HTML_BANNER;
-import static com.mopub.mobileads.AdTypeTranslator.CustomEventType.HTML_INTERSTITIAL;
-import static com.mopub.mobileads.AdTypeTranslator.CustomEventType.MRAID_BANNER;
-import static com.mopub.mobileads.AdTypeTranslator.CustomEventType.MRAID_INTERSTITIAL;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.stub;
-
-@RunWith(SdkTestRunner.class)
-public class AdLoadTaskTest {
-
-    private AdViewController adViewController;
-    private HttpResponse response;
-    private String standardExpectedJson;
-
-    @Before
-    public void setup() {
-        adViewController = mock(AdViewController.class);
-        AdConfiguration adConfiguration = mock(AdConfiguration.class);
-        stub(adViewController.getAdConfiguration()).toReturn(adConfiguration);
-        response = new TestHttpResponseWithHeaders(200, "");
-        standardExpectedJson = "{\"Scrollable\":\"false\",\"Redirect-Url\":\"redirect\",\"Clickthrough-Url\":\"clickthrough\",\"Html-Response-Body\":\"%3Chtml%3E%3C%2Fhtml%3E\"}";
-    }
-
-    @Test
-    public void fromHttpResponse_whenCustomEvent_shouldGetNameAndData() throws Exception {
-        String expectedCustomData = "Custom data";
-        response.addHeader(AD_TYPE.getKey(), "custom");
-        String expectedCustomEventName = "custom event name";
-        response.addHeader(CUSTOM_EVENT_NAME.getKey(), expectedCustomEventName);
-        response.addHeader(CUSTOM_EVENT_DATA.getKey(), expectedCustomData);
-
-        AdLoadTask.CustomEventAdLoadTask customEventTask = (AdLoadTask.CustomEventAdLoadTask) AdLoadTask.fromHttpResponse(response, adViewController);
-        assertThat(customEventTask.getParamsMap().get(CUSTOM_EVENT_NAME.getKey())).isEqualTo(expectedCustomEventName);
-        assertThat(customEventTask.getParamsMap().get(CUSTOM_EVENT_DATA.getKey())).isEqualTo(expectedCustomData);
-    }
-
-    @Test
-    public void fromHttpResponse_whenNoCustomEventName_shouldCreateLegacyCustomEventAdLoadTaskWithAHeader() throws Exception {
-        String expectedCustomData = "Custom data";
-        String expectedHeaderValue = "some stuff";
-        response.addHeader(AD_TYPE.getKey(), "custom");
-        response.addHeader(CUSTOM_EVENT_DATA.getKey(), expectedCustomData);
-        response.addHeader(CUSTOM_SELECTOR.getKey(), expectedHeaderValue);
-
-        AdLoadTask.LegacyCustomEventAdLoadTask customEventTask = (AdLoadTask.LegacyCustomEventAdLoadTask) AdLoadTask.fromHttpResponse(response, adViewController);
-        Header taskHeader = customEventTask.getHeader();
-        assertThat(taskHeader).isNotNull();
-        assertThat(taskHeader.getName()).isEqualTo(CUSTOM_SELECTOR.getKey());
-        assertThat(taskHeader.getValue()).isEqualTo(expectedHeaderValue);
-    }
-
-    @Test
-    public void fromHttpResponse_whenMraidBanner_shouldCreateAnEncodedJsonString() throws Exception {
-        String htmlData = "<html></html>";
-        response = new TestHttpResponseWithHeaders(200, htmlData);
-        addExpectedResponseHeaders("mraid");
-
-        AdLoadTask.CustomEventAdLoadTask customEventTask = (AdLoadTask.CustomEventAdLoadTask) AdLoadTask.fromHttpResponse(response, adViewController);
-        assertThat(customEventTask.getParamsMap().get(CUSTOM_EVENT_NAME.getKey())).isEqualTo(MRAID_BANNER.toString());
-
-        String actualJsonData = customEventTask.getParamsMap().get(CUSTOM_EVENT_DATA.getKey());
-        JsonUtils.assertJsonStringMapsEqual(actualJsonData, standardExpectedJson);
-    }
-
-    @Test
-    public void fromHttpResponse_whenMraidInterstitial_shouldCreateAnEncodedJsonString() throws Exception {
-        String htmlData = "<html></html>";
-        response = new TestHttpResponseWithHeaders(200, htmlData);
-        addExpectedResponseHeaders("mraid");
-        stub(adViewController.getMoPubView()).toReturn(mock(MoPubInterstitial.MoPubInterstitialView.class));
-
-        AdLoadTask.CustomEventAdLoadTask customEventTask = (AdLoadTask.CustomEventAdLoadTask) AdLoadTask.fromHttpResponse(response, adViewController);
-        assertThat(customEventTask.getParamsMap().get(CUSTOM_EVENT_NAME.getKey())).isEqualTo(MRAID_INTERSTITIAL.toString());
-
-        String actualJsonData = customEventTask.getParamsMap().get(CUSTOM_EVENT_DATA.getKey());
-        JsonUtils.assertJsonStringMapsEqual(actualJsonData, standardExpectedJson);
-    }
-
-    @Test
-    public void fromHttpResponse_whenCustomEventDelegate_shouldConvertAdMobToCustomEvent() throws Exception {
-        String expectedNativeParams = "{\"this is a json\":\"map\",\"whee\":\"look at me\"}";
-        response.addHeader(AD_TYPE.getKey(), "admob_native");
-        response.addHeader(NATIVE_PARAMS.getKey(), expectedNativeParams);
-
-        AdLoadTask.CustomEventAdLoadTask customEventTask = (AdLoadTask.CustomEventAdLoadTask) AdLoadTask.fromHttpResponse(response, adViewController);
-        assertThat(customEventTask.getParamsMap().get(CUSTOM_EVENT_NAME.getKey())).isEqualTo(GOOGLE_PLAY_SERVICES_BANNER.toString());
-
-        String actualNativeParams = customEventTask.getParamsMap().get(CUSTOM_EVENT_DATA.getKey());
-        JsonUtils.assertJsonStringMapsEqual(actualNativeParams, expectedNativeParams);
-    }
-
-    @Test
-    public void fromHttpResponse_whenHtmlBanner_shouldConvertToCustomEventBanner() throws Exception {
-        String htmlData = "<html></html>";
-        response = new TestHttpResponseWithHeaders(200, htmlData);
-        addExpectedResponseHeaders("html");
-
-        AdLoadTask.CustomEventAdLoadTask customEventTask = (AdLoadTask.CustomEventAdLoadTask) AdLoadTask.fromHttpResponse(response, adViewController);
-        assertThat(customEventTask.getParamsMap().get(CUSTOM_EVENT_NAME.getKey())).isEqualTo(HTML_BANNER.toString());
-
-        String actualJsonData = customEventTask.getParamsMap().get(CUSTOM_EVENT_DATA.getKey());
-        JsonUtils.assertJsonStringMapsEqual(actualJsonData, standardExpectedJson);
-    }
-
-    @Test
-    public void fromHttpResponse_whenHtmlInterstitial_shouldConvertToCustomEventInterstitial() throws Exception {
-        String htmlData = "<html></html>";
-        response = new TestHttpResponseWithHeaders(200, htmlData);
-        addExpectedResponseHeaders("html");
-        stub(adViewController.getMoPubView()).toReturn(mock(MoPubInterstitial.MoPubInterstitialView.class));
-
-        AdLoadTask.CustomEventAdLoadTask customEventTask = (AdLoadTask.CustomEventAdLoadTask) AdLoadTask.fromHttpResponse(response, adViewController);
-        assertThat(customEventTask.getParamsMap().get(CUSTOM_EVENT_NAME.getKey())).isEqualTo(HTML_INTERSTITIAL.toString());
-
-        String actualJsonData = customEventTask.getParamsMap().get(CUSTOM_EVENT_DATA.getKey());
-        JsonUtils.assertJsonStringMapsEqual(actualJsonData, standardExpectedJson);
-    }
-
-    @Test
-    public void fromHttpResponse_whenEntityIsNull_shouldCreateMinimumJsonString() throws Exception {
-        String htmlData = "<html></html>";
-        String expectedJson = "{\"Scrollable\":\"false\",\"Html-Response-Body\":\"\"}";
-        response = new TestHttpResponseWithHeaders(200, htmlData) {
-            @Override
-            public HttpEntity getEntity() {
-                return null;
-            }
-        };
-        response.addHeader(AD_TYPE.getKey(), "html");
-
-        AdLoadTask.CustomEventAdLoadTask customEventTask = (AdLoadTask.CustomEventAdLoadTask) AdLoadTask.fromHttpResponse(response, adViewController);
-        assertThat(customEventTask.getParamsMap().get(CUSTOM_EVENT_NAME.getKey())).isEqualTo(HTML_BANNER.toString());
-
-        String actualJsonData = customEventTask.getParamsMap().get(CUSTOM_EVENT_DATA.getKey());
-        JsonUtils.assertJsonStringMapsEqual(actualJsonData, expectedJson);
-    }
-
-    @Test
-    public void fromHttpResponse_whenScrollableIsOne_shouldBeReflectedInJson() throws Exception {
-        String expectedJson = "{\"Scrollable\":\"true\",\"Html-Response-Body\":\"\"}";
-        response.addHeader(SCROLLABLE.getKey(), "1");
-        response.addHeader(AD_TYPE.getKey(), "html");
-
-
-        AdLoadTask.CustomEventAdLoadTask customEventTask = (AdLoadTask.CustomEventAdLoadTask) AdLoadTask.fromHttpResponse(response, adViewController);
-        assertThat(customEventTask.getParamsMap().get(CUSTOM_EVENT_NAME.getKey())).isEqualTo(HTML_BANNER.toString());
-
-        String actualJsonData = customEventTask.getParamsMap().get(CUSTOM_EVENT_DATA.getKey());
-        JsonUtils.assertJsonStringMapsEqual(actualJsonData, expectedJson);
-    }
-
-    @Test
-    public void fromHttpResponse_whenScrollableIsNotSpecified_shouldDefaultToFalseInJson() throws Exception {
-        String expectedJson = "{\"Scrollable\":\"false\",\"Html-Response-Body\":\"\"}";
-        response.addHeader(AD_TYPE.getKey(), "html");
-
-        AdLoadTask.CustomEventAdLoadTask customEventTask = (AdLoadTask.CustomEventAdLoadTask) AdLoadTask.fromHttpResponse(response, adViewController);
-        assertThat(customEventTask.getParamsMap().get(CUSTOM_EVENT_NAME.getKey())).isEqualTo(HTML_BANNER.toString());
-
-        String actualJsonData = customEventTask.getParamsMap().get(CUSTOM_EVENT_DATA.getKey());
-        JsonUtils.assertJsonStringMapsEqual(actualJsonData, expectedJson);
-    }
-
-    private void addExpectedResponseHeaders(String adType) {
-        response.addHeader(SCROLLABLE.getKey(), "0");
-        response.addHeader(AD_TYPE.getKey(), adType);
-        response.addHeader(REDIRECT_URL.getKey(), "redirect");
-        response.addHeader(CLICKTHROUGH_URL.getKey(), "clickthrough");
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdLoaderTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdLoaderTest.java
new file mode 100644
index 00000000..8f8639da
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/AdLoaderTest.java
@@ -0,0 +1,140 @@
+package com.mopub.mobileads;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.network.AdResponse;
+
+import org.fest.assertions.core.Condition;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.anyMapOf;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.verifyZeroInteractions;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class AdLoaderTest {
+
+    @Mock
+    private AdViewController adViewController;
+    @Mock
+    private MoPubView moPubView;
+    private AdResponse adResponse;
+    private Map<String, String> serverExtras;
+
+    @Before
+    public void setup() {
+        adResponse = new AdResponse.Builder()
+                .setResponseBody("<html></html>")
+                .setClickTrackingUrl("clickthrough")
+                .setRedirectUrl("redirect")
+                .setScrollable(false)
+                .build();
+        serverExtras = new HashMap<String, String>();
+        serverExtras.put("test", "hi");
+        when(adViewController.getMoPubView()).thenReturn(moPubView);
+    }
+
+    @Test
+    public void fromAdResponse_whenCustomEvent_shouldCreateAdLoadTask() throws Exception {
+        adResponse = adResponse.toBuilder()
+                .setAdType("custom")
+                .setCustomEventClassName("custom event name")
+                .setServerExtras(serverExtras)
+                .build();
+
+
+        AdLoader.CustomEventAdLoader customEventTask = (AdLoader.CustomEventAdLoader) AdLoader.fromAdResponse(adResponse, adViewController);
+        assertThat(customEventTask).isNotNull();
+        assertThat(customEventTask.getServerExtras()).isEqualTo(serverExtras);
+    }
+
+
+    @Test
+    public void fromAdResponse_whenHtml_shouldBeModernAdLoadTask() {
+        adResponse = adResponse.toBuilder()
+                .setAdType("html")
+                .setCustomEventClassName("com.mopub.mobileads.HtmlBanner")
+                .setServerExtras(serverExtras)
+                .build();
+
+        AdLoader.CustomEventAdLoader customEventTask = (AdLoader.CustomEventAdLoader) AdLoader.fromAdResponse(adResponse, adViewController);
+        assertThat(customEventTask).isNotNull();
+        assertThat(customEventTask.getServerExtras()).has(new Condition<Map<String, String>>() {
+            @Override
+            public boolean matches(final Map<String, String> stringStringMap) {
+                return stringStringMap.containsKey("test");
+            }
+        });
+    }
+
+    @Test
+    public void fromAdResponse_whenCustomMethod_shouldReturnNull() {
+        adResponse = adResponse.toBuilder()
+                .setCustomEventClassName(null)
+                .build();
+
+        assertThat(AdLoader.fromAdResponse(adResponse, adViewController)).isNull();
+    }
+
+    @Test
+    public void load_shouldCallAdViewController() {
+        adResponse = adResponse.toBuilder()
+                .setAdType("custom")
+                .setCustomEventClassName("custom event name")
+                .setServerExtras(serverExtras)
+                .build();
+
+
+        AdLoader.CustomEventAdLoader customEventTask = (AdLoader.CustomEventAdLoader) AdLoader.fromAdResponse(adResponse, adViewController);
+
+        customEventTask.load();
+        verify(adViewController).getMoPubView();
+        verify(moPubView).loadCustomEvent(eq("custom event name"), anyMapOf(String.class, String.class));
+    }
+
+    @Test
+    public void load_controllerDestroyed_shouldDoNothing() {
+        when(adViewController.isDestroyed()).thenReturn(true);
+
+        adResponse = adResponse.toBuilder()
+                .setAdType("custom")
+                .setCustomEventClassName("custom event name")
+                .setServerExtras(serverExtras)
+                .build();
+
+
+        AdLoader.CustomEventAdLoader customEventTask = (AdLoader.CustomEventAdLoader) AdLoader.fromAdResponse(adResponse, adViewController);
+
+        customEventTask.load();
+        verify(adViewController).isDestroyed();
+        verifyNoMoreInteractions(adViewController);
+        verifyZeroInteractions(moPubView);
+    }
+
+    @Test
+    public void load_withNullMoPubView_shouldDoNothing() throws Exception {
+        when(adViewController.getMoPubView()).thenReturn(null);
+
+        adResponse = adResponse.toBuilder()
+                .setAdType("custom")
+                .setCustomEventClassName("custom event name")
+                .setServerExtras(serverExtras)
+                .build();
+
+        AdLoader.CustomEventAdLoader customEventTask = (AdLoader.CustomEventAdLoader) AdLoader.fromAdResponse(adResponse, adViewController);
+
+        customEventTask.load();
+
+        verify(adViewController).getMoPubView();
+        verifyZeroInteractions(moPubView);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdRequestStatusMappingTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdRequestStatusMappingTest.java
new file mode 100644
index 00000000..b82dcbe8
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/AdRequestStatusMappingTest.java
@@ -0,0 +1,127 @@
+package com.mopub.mobileads;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+public class AdRequestStatusMappingTest {
+    private AdRequestStatusMapping subject;
+    private String key1;
+
+    @Before
+    public void setUp() {
+        subject = new AdRequestStatusMapping();
+        key1 = "adUnitId1";
+    }
+
+    @Test
+    public void markFail_shouldNullOutAllValues() {
+        subject.markFail(key1);
+
+        assertThat(subject.getFailoverUrl(key1)).isNull();
+        assertThat(subject.getImpressionTrackerUrlString(key1)).isNull();
+        assertThat(subject.getClickTrackerUrlString(key1)).isNull();
+
+        assertThat(subject.canPlay(key1)).isFalse();
+        assertThat(subject.isLoading(key1)).isFalse();
+    }
+
+    @Test
+    public void markLoading_shouldNotUpdateUrls_shouldSetIsLoadingTrue() {
+        subject.markLoading(key1);
+
+        assertThat(subject.getFailoverUrl(key1)).isNull();
+        assertThat(subject.getImpressionTrackerUrlString(key1)).isNull();
+        assertThat(subject.getClickTrackerUrlString(key1)).isNull();
+
+        assertThat(subject.canPlay(key1)).isFalse();
+        assertThat(subject.isLoading(key1)).isTrue();
+    }
+
+    @Test
+    public void markLoaded_shouldUpdateUrls_shouldSetCanPlayTrue() {
+        subject.markLoaded(key1, "fail", "imp", "click");
+
+        assertThat(subject.getFailoverUrl(key1)).isEqualTo("fail");
+        assertThat(subject.getImpressionTrackerUrlString(key1)).isEqualTo("imp");
+        assertThat(subject.getClickTrackerUrlString(key1)).isEqualTo("click");
+
+        assertThat(subject.canPlay(key1)).isTrue();
+        assertThat(subject.isLoading(key1)).isFalse();
+    }
+
+    @Test
+    public void markLoaded_withNullValues_shouldUpdateUrls_shouldSetCanPlayTrue() {
+        subject.markLoaded(key1, null, null, null);
+
+        assertThat(subject.getFailoverUrl(key1)).isNull();
+        assertThat(subject.getImpressionTrackerUrlString(key1)).isNull();
+        assertThat(subject.getClickTrackerUrlString(key1)).isNull();
+
+        assertThat(subject.canPlay(key1)).isTrue();
+        assertThat(subject.isLoading(key1)).isFalse();
+    }
+
+    @Test
+    public void markPlayed_afterLoaded_shouldKeepExistingUrls_shouldSetCanPlayFalse() {
+        subject.markLoaded(key1, "fail", "imp", "click");
+        subject.markPlayed(key1);
+
+        assertThat(subject.getFailoverUrl(key1)).isEqualTo("fail");
+        assertThat(subject.getImpressionTrackerUrlString(key1)).isEqualTo("imp");
+        assertThat(subject.getClickTrackerUrlString(key1)).isEqualTo("click");
+
+        assertThat(subject.canPlay(key1)).isFalse();
+        assertThat(subject.isLoading(key1)).isFalse();
+    }
+
+    @Test
+    public void markPlayed_beforeLoaded_shouldSetUrlsNull_shouldSetCanPlayFalse() {
+        subject.markPlayed(key1);
+
+        assertThat(subject.getFailoverUrl(key1)).isNull();
+        assertThat(subject.getImpressionTrackerUrlString(key1)).isNull();
+        assertThat(subject.getClickTrackerUrlString(key1)).isNull();
+
+        assertThat(subject.canPlay(key1)).isFalse();
+        assertThat(subject.isLoading(key1)).isFalse();
+    }
+
+    @Test
+    public void clearImpression_shouldResetImpressionUrl() {
+        subject.markLoaded(key1, "fail", "imp", "click");
+        subject.clearImpressionUrl(key1);
+
+        assertThat(subject.getFailoverUrl(key1)).isEqualTo("fail");
+        assertThat(subject.getImpressionTrackerUrlString(key1)).isNull();
+        assertThat(subject.getClickTrackerUrlString(key1)).isEqualTo("click");
+    }
+
+    @Test
+    public void clearclick_shouldResetClickurl() {
+        subject.markLoaded(key1, "fail", "imp", "click");
+        subject.clearClickUrl(key1);
+
+        assertThat(subject.getFailoverUrl(key1)).isEqualTo("fail");
+        assertThat(subject.getImpressionTrackerUrlString(key1)).isEqualTo("imp");
+        assertThat(subject.getClickTrackerUrlString(key1)).isNull();
+    }
+
+    @Test
+    public void allAccessors_withInvalidKey_shouldReturnDefaultsAndNotThrowExceptions() {
+        assertThat(subject.getFailoverUrl(key1)).isNull();
+        assertThat(subject.getImpressionTrackerUrlString(key1)).isNull();
+        assertThat(subject.getClickTrackerUrlString(key1)).isNull();
+
+        assertThat(subject.canPlay(key1)).isFalse();
+        assertThat(subject.isLoading(key1)).isFalse();
+
+        subject.clearImpressionUrl(key1);
+        subject.clearClickUrl(key1);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdTypeTranslatorTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdTypeTranslatorTest.java
index fb137103..1461d2c8 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/AdTypeTranslatorTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/AdTypeTranslatorTest.java
@@ -3,12 +3,17 @@
 import android.app.Activity;
 import android.content.Context;
 
+import com.mopub.common.AdFormat;
+import com.mopub.common.AdType;
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.ResponseHeader;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import java.util.HashMap;
+
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.stub;
@@ -19,6 +24,7 @@
     private MoPubView moPubView;
     private MoPubInterstitial.MoPubInterstitialView moPubInterstitialView;
     private Context context;
+    HashMap<String, String> headers;
 
     @Before
     public void setUp() throws Exception {
@@ -28,75 +34,99 @@ public void setUp() throws Exception {
         context = new Activity();
         stub(moPubView.getContext()).toReturn(context);
         stub(moPubInterstitialView.getContext()).toReturn(context);
+
+        headers = new HashMap<String, String>();
     }
 
     @Test
-    public void getAdMobBannerReturnsGooglePlayServicesBanner() throws Exception {
-        customEventName = AdTypeTranslator.getCustomEventNameForAdType(moPubView, "admob_native", null);
+    public void getCustomEventName_shouldBeGoogleBanner() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, "admob_native", null, headers);
 
         assertThat(customEventName).isEqualTo("com.mopub.mobileads.GooglePlayServicesBanner");
     }
 
     @Test
-    public void getAdMobInterstitialReturnsGooglePlayServicesInterstitial() throws Exception {
-        customEventName = AdTypeTranslator.getCustomEventNameForAdType(moPubInterstitialView, "interstitial", "admob_full");
+    public void getCustomEventName_shouldBeGoogleInterstitial() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, "interstitial", "admob_full", headers);
 
         assertThat(customEventName).isEqualTo("com.mopub.mobileads.GooglePlayServicesInterstitial");
     }
 
     @Test
-    public void getMillennialBanner() throws Exception {
-        customEventName = AdTypeTranslator.getCustomEventNameForAdType(moPubView, "millennial_native", null);
+    public void getCustomEventName_shouldBeMillenialBanner() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, "millennial_native", null, headers);
 
         assertThat(customEventName).isEqualTo("com.mopub.mobileads.MillennialBanner");
     }
 
     @Test
-    public void getMillennnialInterstitial() throws Exception {
-        customEventName = AdTypeTranslator.getCustomEventNameForAdType(moPubInterstitialView, "interstitial", "millennial_full");
+    public void getCustomEventName_shouldBeMillennialIntersitial() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.INTERSTITIAL, "interstitial", "millennial_full", headers);
 
         assertThat(customEventName).isEqualTo("com.mopub.mobileads.MillennialInterstitial");
     }
 
     @Test
-    public void getMraidBanner() throws Exception {
-        customEventName = AdTypeTranslator.getCustomEventNameForAdType(moPubView, "mraid", null);
+    public void getCustomEventName_shouldBeMraidBanner() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, AdType.MRAID, null, headers);
 
-        assertThat(customEventName).isEqualTo("com.mopub.mobileads.MraidBanner");
+        assertThat(customEventName).isEqualTo("com.mopub.mraid.MraidBanner");
     }
 
     @Test
-    public void getMraidInterstitial() throws Exception {
-        customEventName = AdTypeTranslator.getCustomEventNameForAdType(moPubInterstitialView, "mraid", null);
+    public void getCustomEventName_shouldBeMraidInterstitial() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.INTERSTITIAL, AdType.MRAID, null, headers);
 
-        assertThat(customEventName).isEqualTo("com.mopub.mobileads.MraidInterstitial");
+        assertThat(customEventName).isEqualTo("com.mopub.mraid.MraidInterstitial");
     }
 
     @Test
-    public void getHtmlBanner() throws Exception {
-        customEventName = AdTypeTranslator.getCustomEventNameForAdType(moPubView, "html", null);
+    public void getCustomEventName_shouldBeHtmlBanner() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, "html", null, headers);
 
         assertThat(customEventName).isEqualTo("com.mopub.mobileads.HtmlBanner");
     }
 
     @Test
-    public void getHtmlInterstitial() throws Exception {
-        customEventName = AdTypeTranslator.getCustomEventNameForAdType(moPubInterstitialView, "html", null);
+    public void getCustomEventName_shouldBeHtmlInterstitial() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.INTERSTITIAL, "html", null, headers);
 
         assertThat(customEventName).isEqualTo("com.mopub.mobileads.HtmlInterstitial");
     }
 
     @Test
-    public void getVastInterstitial() throws Exception {
-        customEventName = AdTypeTranslator.getCustomEventNameForAdType(moPubInterstitialView, "interstitial", "vast");
+    public void getCustomEventName_shouldBeVastInterstitial() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.INTERSTITIAL, "interstitial", "vast", headers);
 
         assertThat(customEventName).isEqualTo("com.mopub.mobileads.VastVideoInterstitial");
     }
 
     @Test
-    public void getCustomEventNameForAdType_whenSendingNonsense_shouldReturnNull() throws Exception {
-        customEventName = AdTypeTranslator.getCustomEventNameForAdType(null, null, null);
+    public void getCustomEventName_shouldBeCustomClassName() {
+        headers.put(ResponseHeader.CUSTOM_EVENT_NAME.getKey(), "com.example.CustomClass");
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, AdType.CUSTOM, null, headers);
+
+        assertThat(customEventName).isEqualTo("com.example.CustomClass");
+    }
+
+    @Test
+    public void getCustomEventName_whenNameNotInHeaders_shouldBeNull() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, AdType.CUSTOM, null, headers);
+
+        assertThat(customEventName).isNull();
+    }
+
+    @Test
+    public void getCustomEventName_withNativeFormat_shouldBeMoPubNative() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.NATIVE, AdType.NATIVE, null, headers);
 
+        assertThat(customEventName).isEqualTo("com.mopub.nativeads.MoPubCustomEventNative");
+    }
+
+    @Test
+    public void getCustomEventName_whenInvalidAdTypeAndInvalidFullAdType_shouldReturnNull() {
+        customEventName = AdTypeTranslator.getCustomEventName(AdFormat.BANNER, "garbage", "garbage",
+                headers);
         assertThat(customEventName).isNull();
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdViewControllerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdViewControllerTest.java
index e6473af7..aad6cc28 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/AdViewControllerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/AdViewControllerTest.java
@@ -1,84 +1,94 @@
 package com.mopub.mobileads;
 
+import android.Manifest;
 import android.app.Activity;
 import android.content.Context;
-import android.location.Location;
 import android.net.ConnectivityManager;
-import android.os.Build;
 import android.view.Gravity;
 import android.view.View;
-import android.webkit.WebView;
 import android.widget.FrameLayout;
-import com.mopub.common.GpsHelper;
-import com.mopub.common.GpsHelperTest;
-import com.mopub.common.MoPub;
-import com.mopub.common.SharedPreferencesHelper;
+
+import com.mopub.common.AdFormat;
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.Reflection;
 import com.mopub.common.util.test.support.TestMethodBuilderFactory;
-import com.mopub.mobileads.factories.HttpClientFactory;
-import com.mopub.mobileads.test.support.TestAdFetcherFactory;
-import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
 import com.mopub.mobileads.test.support.ThreadUtils;
-import org.apache.http.HttpRequest;
-import org.apache.http.HttpResponse;
-import org.apache.http.client.HttpClient;
-import org.apache.http.conn.ClientConnectionManager;
+import com.mopub.network.AdRequest;
+import com.mopub.network.AdResponse;
+import com.mopub.network.MoPubNetworkError;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.NoConnectionError;
+import com.mopub.volley.Request;
+import com.mopub.volley.VolleyError;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
 import org.robolectric.Robolectric;
-import org.robolectric.tester.org.apache.http.FakeHttpLayer;
 
-import java.lang.reflect.InvocationTargetException;
+import java.util.Collections;
 
-import static android.Manifest.permission.ACCESS_NETWORK_STATE;
-import static com.mopub.common.util.Reflection.MethodBuilder;
-import static com.mopub.mobileads.AdViewController.DEFAULT_REFRESH_TIME_MILLISECONDS;
-import static com.mopub.mobileads.MoPubErrorCode.INTERNAL_ERROR;
-import static com.mopub.mobileads.MoPubErrorCode.NO_FILL;
-import static com.mopub.mobileads.test.support.ThreadUtils.NETWORK_DELAY;
+import static com.mopub.common.VolleyRequestMatcher.isUrl;
 import static org.fest.assertions.api.Assertions.assertThat;
-import static org.fest.assertions.api.Fail.fail;
 import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyString;
+import static org.mockito.Matchers.argThat;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.stub;
+import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyZeroInteractions;
 import static org.mockito.Mockito.when;
-import static org.robolectric.Robolectric.application;
 import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(SdkTestRunner.class)
 public class AdViewControllerTest {
+
+    private static final int[] HTML_ERROR_CODES = new int[]{400, 401, 402, 403, 404, 405, 407, 408,
+            409, 410, 411, 412, 413, 414, 415, 416, 417, 500, 501, 502, 503, 504, 505};
+
     private AdViewController subject;
-    private MoPubView moPubView;
-    private HttpResponse response;
-    private HttpClient httpClient;
-    private AdFetcher adFetcher;
-    private MethodBuilder methodBuilder;
-    private Activity context;
+    @Mock
+    private MoPubView mockMoPubView;
+    @Mock
+    private MoPubRequestQueue mockRequestQueue;
+    private Reflection.MethodBuilder methodBuilder;
+
+    private AdResponse response;
+    private Activity activity;
 
     @Before
     public void setup() {
-        context = new Activity();
-        shadowOf(context).grantPermissions(ACCESS_NETWORK_STATE);
+        activity = Robolectric.buildActivity(Activity.class).create().get();
+        shadowOf(activity).grantPermissions(android.Manifest.permission.ACCESS_NETWORK_STATE);
 
-        moPubView = mock(MoPubView.class);
-        stub(moPubView.getContext()).toReturn(context);
+        when(mockMoPubView.getAdFormat()).thenReturn(AdFormat.BANNER);
+        when(mockMoPubView.getContext()).thenReturn(activity);
+        Networking.setRequestQueueForTesting(mockRequestQueue);
 
-        httpClient = HttpClientFactory.create();
+        subject = new AdViewController(activity, mockMoPubView);
 
-        subject = new AdViewController(context, moPubView);
-        response = new TestHttpResponseWithHeaders(200, "I ain't got no-body");
-        adFetcher = TestAdFetcherFactory.getSingletonMock();
         methodBuilder = TestMethodBuilderFactory.getSingletonMock();
         reset(methodBuilder);
+        response = new AdResponse.Builder()
+                .setCustomEventClassName("customEvent")
+                .setClickTrackingUrl("clickUrl")
+                .setImpressionTrackingUrl("impressionUrl")
+                .setRedirectUrl("redirectUrl")
+                .setScrollable(false)
+                .setDimensions(320, 50)
+                .setAdType("html")
+                .setFailoverUrl("failUrl")
+                .setResponseBody("testResponseBody")
+                .setServerExtras(Collections.<String, String>emptyMap())
+                .build();
     }
 
     @After
@@ -87,64 +97,108 @@ public void tearDown() throws Exception {
     }
 
     @Test
-    public void scheduleRefreshTimerIfEnabled_shouldCancelOldRefreshAndScheduleANewOne() throws Exception {
-        response.addHeader("X-Refreshtime", "30");
-        subject.configureUsingHttpResponse(response);
+    public void cleanup_shouldNotHoldViewOrUrlGenerator() {
+        subject.cleanup();
+
+        assertThat(subject.getMoPubView()).isNull();
+        assertThat(subject.generateAdUrl()).isNull();
+    }
+
+    @Test
+    public void adDidFail_shouldScheduleRefreshTimer_shouldCallMoPubViewAdFailed() throws Exception {
         Robolectric.pauseMainLooper();
         assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
 
-        subject.scheduleRefreshTimerIfEnabled();
+        subject.adDidFail(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
 
         assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+        verify(mockMoPubView).adFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
+    }
 
-        subject.scheduleRefreshTimerIfEnabled();
+    @Test
+    public void adDidFail_withNullMoPubView_shouldNotScheduleRefreshTimer_shouldNotCallMoPubViewAdFailed() throws Exception {
+        Robolectric.pauseMainLooper();
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
 
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+        // This sets the MoPubView to null
+        subject.cleanup();
+        subject.adDidFail(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
+
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+        verify(mockMoPubView, never()).adFailed(any(MoPubErrorCode.class));
     }
 
-    @Test
-    public void scheduleRefreshTimer_shouldNotScheduleRefreshIfAutorefreshIsOff() throws Exception {
-        response.addHeader("X-Refreshtime", "30");
-        subject.configureUsingHttpResponse(response);
 
+    @Test
+    public void scheduleRefreshTimer_shouldNotScheduleIfRefreshTimeIsNull() throws Exception {
+        response = response.toBuilder().setRefreshTimeMilliseconds(null).build();
+        subject.onAdLoadSuccess(response);
         Robolectric.pauseMainLooper();
         assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
 
-        subject.forceSetAutorefreshEnabled(false);
-
         subject.scheduleRefreshTimerIfEnabled();
 
         assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
     }
 
     @Test
-    public void scheduleRefreshTimer_whenAdViewControllerNotConfiguredByResponse_shouldHaveDefaultRefreshTime() throws Exception {
+    public void scheduleRefreshTimer_shouldNotScheduleIfRefreshTimeIsZero() {
+        response = response.toBuilder().setRefreshTimeMilliseconds(0).build();
+        subject.onAdLoadSuccess(response);
         Robolectric.pauseMainLooper();
         assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
 
         subject.scheduleRefreshTimerIfEnabled();
+
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+    }
+
+    @Test
+    public void scheduleRefreshTimerIfEnabled_shouldCancelOldRefreshAndScheduleANewOne() throws Exception {
+        response = response.toBuilder().setRefreshTimeMilliseconds(30).build();
+        subject.onAdLoadSuccess(response);
+        Robolectric.pauseMainLooper();
         assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
 
-        Robolectric.idleMainLooper(DEFAULT_REFRESH_TIME_MILLISECONDS - 1);
+        subject.scheduleRefreshTimerIfEnabled();
+
         assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
 
-        Robolectric.idleMainLooper(1);
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+        subject.scheduleRefreshTimerIfEnabled();
+
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
     }
 
     @Test
-    public void scheduleRefreshTimer_shouldNotScheduleRefreshIfRefreshTimeIsZero() throws Exception {
-//        response.addHeader("X-Refreshtime", "0");
-        subject.configureUsingHttpResponse(response);
+    public void scheduleRefreshTimer_shouldNotScheduleRefreshIfAutorefreshIsOff() throws Exception {
+        response = response.toBuilder().setRefreshTimeMilliseconds(30).build();
+        subject.onAdLoadSuccess(response);
+
         Robolectric.pauseMainLooper();
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+
+        subject.forceSetAutorefreshEnabled(false);
 
+        subject.scheduleRefreshTimerIfEnabled();
+
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
+    }
+
+    @Test
+    public void scheduleRefreshTimer_whenAdViewControllerNotConfiguredByResponse_shouldHaveDefaultRefreshTime() throws Exception {
+        Robolectric.pauseMainLooper();
         assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
 
         subject.scheduleRefreshTimerIfEnabled();
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
 
+        Robolectric.idleMainLooper(AdViewController.DEFAULT_REFRESH_TIME_MILLISECONDS - 1);
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
+
+        Robolectric.idleMainLooper(1);
         assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
     }
-    
+
     @Test
     public void forceSetAutoRefreshEnabled_shouldSetAutoRefreshSetting() throws Exception {
         assertThat(subject.getAutorefreshEnabled()).isTrue();
@@ -167,7 +221,7 @@ public void pauseRefresh_shouldDisableAutorefresh() throws Exception {
     @Test
     public void unpauseRefresh_afterUnpauseRefresh_shouldEnableRefresh() throws Exception {
         subject.pauseRefresh();
-        
+
         subject.unpauseRefresh();
         assertThat(subject.getAutorefreshEnabled()).isTrue();
     }
@@ -186,6 +240,7 @@ public void pauseAndUnpauseRefresh_withRefreshForceDisabled_shouldAlwaysHaveRefr
 
     @Test
     public void enablingAutoRefresh_afterLoadAd_shouldScheduleNewRefreshTimer() throws Exception {
+
         final AdViewController adViewControllerSpy = spy(subject);
 
         adViewControllerSpy.loadAd();
@@ -203,9 +258,8 @@ public void enablingAutoRefresh_withoutCallingLoadAd_shouldNotScheduleNewRefresh
 
     @Test
     public void disablingAutoRefresh_shouldCancelRefreshTimers() throws Exception {
-        response.addHeader("X-Refreshtime", "30");
-        subject.configureUsingHttpResponse(response);
-
+        response = response.toBuilder().setRefreshTimeMilliseconds(30).build();
+        subject.onAdLoadSuccess(response);
         Robolectric.pauseMainLooper();
 
         subject.loadAd();
@@ -217,208 +271,55 @@ public void disablingAutoRefresh_shouldCancelRefreshTimers() throws Exception {
     }
 
     @Test
-    public void trackImpression_shouldHttpGetTheImpressionUrl() throws Exception {
-        response.addHeader("X-Imptracker", "http://trackingUrl");
-        subject.configureUsingHttpResponse(response);
-        String expectedUserAgent = new WebView(context).getSettings().getUserAgentString();
-        FakeHttpLayer fakeHttpLayer = Robolectric.getFakeHttpLayer();
-        fakeHttpLayer.addPendingHttpResponse(200, "");
-
-        assertThat(expectedUserAgent).isNotNull();
-
+    public void trackImpression_shouldAddToRequestQueue() throws Exception {
+        subject.onAdLoadSuccess(response);
         subject.trackImpression();
-        ThreadUtils.pause(NETWORK_DELAY); // does this make the test flaky?
-
-        HttpRequest request = fakeHttpLayer.getLastSentHttpRequestInfo().getHttpRequest();
-        assertThat(request.getFirstHeader("User-Agent").getValue()).isEqualTo(expectedUserAgent);
-        assertThat(request.getRequestLine().getUri()).isEqualTo("http://trackingUrl");
-
-        ClientConnectionManager connectionManager = httpClient.getConnectionManager();
-        try {
-            new MethodBuilder(connectionManager, "assertStillUp").setAccessible().execute();
-            fail("should have thrown an exception");
-        } catch (InvocationTargetException expected) {
-            assertThat(expected.getCause()).isInstanceOf(IllegalStateException.class);
-        }
+
+        verify(mockRequestQueue).add(argThat(isUrl("impressionUrl")));
     }
 
-    // this test for impressionUrl is unnecessary (since we're catching the NullPointerException)
     @Test
-    public void trackImpression_shouldDoNothingIfImpressionUrlNotSpecified() throws Exception {
-        subject.configureUsingHttpResponse(response);
-        FakeHttpLayer fakeHttpLayer = Robolectric.getFakeHttpLayer();
-        fakeHttpLayer.addPendingHttpResponse(200, "");
-
+    public void trackImpression_noAdResponse_shouldNotAddToQueue() {
         subject.trackImpression();
-        Thread.sleep(300); // does this make the test flaky?
 
-        assertThat(fakeHttpLayer.getLastSentHttpRequestInfo()).isNull();
+        verifyZeroInteractions(mockRequestQueue);
     }
 
     @Test
     public void registerClick_shouldHttpGetTheClickthroughUrl() throws Exception {
-        response.addHeader("X-Clickthrough", "http://clickUrl");
-        subject.configureUsingHttpResponse(response);
-        String expectedUserAgent = new WebView(context).getSettings().getUserAgentString();
-        FakeHttpLayer fakeHttpLayer = Robolectric.getFakeHttpLayer();
-        fakeHttpLayer.addPendingHttpResponse(200, "");
-
-        assertThat(expectedUserAgent).isNotNull();
+        subject.onAdLoadSuccess(response);
 
         subject.registerClick();
-        Thread.sleep(200); // does this make the test flaky?
-
-        HttpRequest request = fakeHttpLayer.getLastSentHttpRequestInfo().getHttpRequest();
-        assertThat(request.getFirstHeader("User-Agent").getValue()).isEqualTo(expectedUserAgent);
-        assertThat(request.getRequestLine().getUri()).isEqualTo("http://clickUrl");
-
-        ClientConnectionManager connectionManager = httpClient.getConnectionManager();
-        try {
-            new MethodBuilder(connectionManager, "assertStillUp").setAccessible().execute();
-            fail("should have thrown an exception");
-        } catch (InvocationTargetException expected) {
-            assertThat(expected.getCause()).isInstanceOf(IllegalStateException.class);
-        }
+        verify(mockRequestQueue).add(argThat(isUrl("clickUrl")));
     }
 
-    // this test for clickthroughUrl is unnecessary (since we're catching the NullPointerException)
     @Test
-    public void trackImpression_shouldDoNothingIfClickthroughUrlNotSpecified() throws Exception {
-        subject.configureUsingHttpResponse(response);
-        FakeHttpLayer fakeHttpLayer = Robolectric.getFakeHttpLayer();
-        fakeHttpLayer.addPendingHttpResponse(200, "");
-
+    public void registerClick_NoAdResponse_shouldNotAddToQueue() {
         subject.registerClick();
-        Thread.sleep(50); // does this make the test flaky?
-
-        assertThat(fakeHttpLayer.getLastSentHttpRequestInfo()).isNull();
+        verifyZeroInteractions(mockRequestQueue);
     }
 
     @Test
-    public void generateAdUrl_shouldIncludeMinFields() throws Exception {
-        String expectedAdUrl = "http://ads.mopub.com/m/ad" +
-                "?v=6" +
-                "&nv=" + MoPub.SDK_VERSION +
-                "&dn=" + Build.MANUFACTURER +
-                "%2C" + Build.MODEL +
-                "%2C" + Build.PRODUCT +
-                "&udid=sha%3A" +
-                "&z=-0700" +
-                "&o=u" +
-                "&sc_a=1.0" +
-                "&mr=1" +
-                "&ct=3" +
-                "&av=1.0" +
-                "&android_perms_ext_storage=0";
-
-        String adUrl = subject.generateAdUrl();
-
-        assertThat(adUrl).isEqualTo(expectedAdUrl);
-    }
-
-    @Test
-    public void loadAd_shouldNotLoadUrlIfAdUnitIdIsNull() throws Exception {
-        FakeHttpLayer fakeHttpLayer = Robolectric.getFakeHttpLayer();
-
-        subject.loadAd();
-
-        assertThat(fakeHttpLayer.getLastSentHttpRequestInfo()).isNull();
+    public void fetchAd_withNullMoPubView_shouldNotMakeRequest() throws Exception {
+        subject.cleanup();
+        subject.fetchAd("adUrl");
+        verify(mockRequestQueue, never()).add(any(AdRequest.class));
     }
 
     @Test
-    public void loadAd_shouldScheduleRefreshIfNoNetworkConnectivity() throws Exception {
-        FakeHttpLayer fakeHttpLayer = Robolectric.getFakeHttpLayer();
-        Robolectric.pauseMainLooper();
-        ConnectivityManager connectivityManager = (ConnectivityManager) application.getSystemService(Context.CONNECTIVITY_SERVICE);
+    public void loadAd_shouldNotLoadWithoutConnectivity() throws Exception {
+        ConnectivityManager connectivityManager = (ConnectivityManager) Robolectric.application.getSystemService(Context.CONNECTIVITY_SERVICE);
         shadowOf(connectivityManager.getActiveNetworkInfo()).setConnectionStatus(false);
-        response.addHeader("X-Refreshtime", "30");
-        subject.configureUsingHttpResponse(response);
-        subject.setAdUnitId("adUnitId");
-
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
-
-        subject.loadAd();
-
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
-        assertThat(fakeHttpLayer.getLastSentHttpRequestInfo()).isNull();
-    }
-
-    @Test
-    public void loadAd_whenGooglePlayServicesIsLinkedAndAdInfoIsNotCached_shouldCacheAdInfoBeforeFetchingAd() throws Exception {
-        SharedPreferencesHelper.getSharedPreferences(context).edit().clear().commit();
-        GpsHelperTest.verifyCleanClientMetadata(context);
 
-        GpsHelper.setClassNamesForTesting();
-        GpsHelperTest.TestAdInfo adInfo = new GpsHelperTest.TestAdInfo();
-
-        when(methodBuilder.setStatic(any(Class.class))).thenReturn(methodBuilder);
-        when(methodBuilder.addParam(any(Class.class), any())).thenReturn(methodBuilder);
-        when(methodBuilder.execute()).thenReturn(
-                GpsHelper.GOOGLE_PLAY_SUCCESS_CODE,
-                adInfo,
-                adInfo.ADVERTISING_ID,
-                adInfo.LIMIT_AD_TRACKING_ENABLED
-        );
-
-        final AdViewController.AdViewControllerGpsHelperListener mockAdViewControllerGpsHelperListener
-                = mock(AdViewController.AdViewControllerGpsHelperListener.class);
-        subject.setGpsHelperListener(mockAdViewControllerGpsHelperListener);
-        subject.setAdUnitId("adUnitId");
-        subject.setLocation(new Location(""));
-        subject.loadAd();
-        Thread.sleep(500);
-
-        verify(mockAdViewControllerGpsHelperListener).onFetchAdInfoCompleted();
-        GpsHelperTest.verifyClientMetadata(context, adInfo);
-    }
-
-    @Test
-    public void loadAd_whenGooglePlayServicesIsNotLinked_shouldFetchAdFast() throws Exception {
-        GpsHelperTest.verifyCleanClientMetadata(context);
-
-        GpsHelper.setClassNamesForTesting();
-        when(methodBuilder.setStatic(any(Class.class))).thenReturn(methodBuilder);
-        when(methodBuilder.addParam(any(Class.class), any())).thenReturn(methodBuilder);
-        // return error code so it fails
-        when(methodBuilder.execute()).thenReturn(GpsHelper.GOOGLE_PLAY_SUCCESS_CODE + 1);
-
-        final AdViewController.AdViewControllerGpsHelperListener mockAdViewControllerGpsHelperListener
-                = mock(AdViewController.AdViewControllerGpsHelperListener.class);
-        subject.setGpsHelperListener(mockAdViewControllerGpsHelperListener);
-        subject.setAdUnitId("adUnitId");
-        subject.setLocation(new Location(""));
         subject.loadAd();
-        // no need to sleep since it run the callback without an async task
-
-        verify(mockAdViewControllerGpsHelperListener).onFetchAdInfoCompleted();
-        GpsHelperTest.verifyCleanClientMetadata(context);
+        verifyZeroInteractions(mockRequestQueue);
     }
 
     @Test
-    public void loadAd_whenGooglePlayServicesIsLinkedAndAdInfoIsCached_shouldFetchAdFast() throws Exception {
-        GpsHelperTest.TestAdInfo adInfo = new GpsHelperTest.TestAdInfo();
-        GpsHelperTest.populateAndVerifyClientMetadata(context, adInfo);
-        GpsHelper.setClassNamesForTesting();
-
-        when(methodBuilder.setStatic(any(Class.class))).thenReturn(methodBuilder);
-        when(methodBuilder.addParam(any(Class.class), any())).thenReturn(methodBuilder);
-        when(methodBuilder.execute()).thenReturn(
-                GpsHelper.GOOGLE_PLAY_SUCCESS_CODE,
-                adInfo,
-                adInfo.mAdId,
-                adInfo.mLimitAdTrackingEnabled
-        );
-
-        final AdViewController.AdViewControllerGpsHelperListener mockAdViewControllerGpsHelperListener
-                = mock(AdViewController.AdViewControllerGpsHelperListener.class);
-        subject.setGpsHelperListener(mockAdViewControllerGpsHelperListener);
-        subject.setAdUnitId("adUnitId");
-        subject.setLocation(new Location(""));
+    public void loadAd_shouldNotLoadUrlIfAdUnitIdIsNull() throws Exception {
         subject.loadAd();
-        // no need to sleep since it run the callback without an async task
 
-        verify(mockAdViewControllerGpsHelperListener).onFetchAdInfoCompleted();
-        GpsHelperTest.verifyClientMetadata(context, adInfo);
+        verifyZeroInteractions(mockRequestQueue);
     }
 
     @Test
@@ -426,28 +327,17 @@ public void loadNonJavascript_shouldFetchAd() throws Exception {
         String url = "http://www.guy.com";
         subject.loadNonJavascript(url);
 
-        verify(adFetcher).fetchAdForUrl(eq(url));
+        verify(mockRequestQueue).add(argThat(isUrl(url)));
     }
 
     @Test
     public void loadNonJavascript_whenAlreadyLoading_shouldNotFetchAd() throws Exception {
         String url = "http://www.guy.com";
         subject.loadNonJavascript(url);
-        reset(adFetcher);
+        reset(mockRequestQueue);
         subject.loadNonJavascript(url);
 
-        verify(adFetcher, never()).fetchAdForUrl(anyString());
-    }
-
-    @Test
-    public void loadNonJavascript_shouldClearTheFailUrl() throws Exception {
-        subject.setFailUrl("blarg:");
-        subject.loadNonJavascript("http://www.goodness.com");
-        reset(adFetcher);
-        subject.loadFailUrl(null);
-
-        verify(adFetcher, never()).fetchAdForUrl(anyString());
-        verify(moPubView).adFailed(eq(NO_FILL));
+        verify(mockRequestQueue, never()).add(any(Request.class));
     }
 
     @Test
@@ -461,20 +351,19 @@ public void reload_shouldReuseOldUrl() throws Exception {
         String url = "http://www.guy.com";
         subject.loadNonJavascript(url);
         subject.setNotLoading();
-        reset(adFetcher);
+        reset(mockRequestQueue);
         subject.reload();
 
-        verify(adFetcher).fetchAdForUrl(eq(url));
+        verify(mockRequestQueue).add(argThat(isUrl(url)));
     }
 
     @Test
     public void loadFailUrl_shouldLoadFailUrl() throws Exception {
-        String failUrl = "http://www.bad.man";
-        subject.setFailUrl(failUrl);
-        subject.loadFailUrl(INTERNAL_ERROR);
+        subject.onAdLoadSuccess(response);
+        subject.loadFailUrl(MoPubErrorCode.INTERNAL_ERROR);
 
-        verify(adFetcher).fetchAdForUrl(eq(failUrl));
-        verify(moPubView, never()).adFailed(any(MoPubErrorCode.class));
+        verify(mockRequestQueue).add(argThat(isUrl("failUrl")));
+        verify(mockMoPubView, never()).adFailed(any(MoPubErrorCode.class));
     }
 
     @Test
@@ -485,20 +374,18 @@ public void loadFailUrl_shouldAcceptNullErrorCode() throws Exception {
 
     @Test
     public void loadFailUrl_whenFailUrlIsNull_shouldCallAdDidFail() throws Exception {
-        subject.setFailUrl(null);
-        subject.loadFailUrl(INTERNAL_ERROR);
+        response.toBuilder().setFailoverUrl(null).build();
+        subject.loadFailUrl(MoPubErrorCode.INTERNAL_ERROR);
 
-        verify(moPubView).adFailed(eq(NO_FILL));
-        verify(adFetcher, never()).fetchAdForUrl(anyString());
+        verify(mockMoPubView).adFailed(eq(MoPubErrorCode.NO_FILL));
+        verifyZeroInteractions(mockRequestQueue);
     }
 
     @Test
     public void setAdContentView_whenCalledFromWrongUiThread_shouldStillSetContentView() throws Exception {
-        response.addHeader("X-Width", "320");
-        response.addHeader("X-Height", "50");
         final View view = mock(View.class);
         AdViewController.setShouldHonorServerDimensions(view);
-        subject.configureUsingHttpResponse(response);
+        subject.onAdLoadSuccess(response);
 
         new Thread(new Runnable() {
             @Override
@@ -509,9 +396,9 @@ public void run() {
         ThreadUtils.pause(100);
         Robolectric.runUiThreadTasks();
 
-        verify(moPubView).removeAllViews();
+        verify(mockMoPubView).removeAllViews();
         ArgumentCaptor<FrameLayout.LayoutParams> layoutParamsCaptor = ArgumentCaptor.forClass(FrameLayout.LayoutParams.class);
-        verify(moPubView).addView(eq(view), layoutParamsCaptor.capture());
+        verify(mockMoPubView).addView(eq(view), layoutParamsCaptor.capture());
         FrameLayout.LayoutParams layoutParams = layoutParamsCaptor.getValue();
 
         assertThat(layoutParams.width).isEqualTo(320);
@@ -521,11 +408,9 @@ public void run() {
 
     @Test
     public void setAdContentView_whenCalledAfterCleanUp_shouldNotRemoveViewsAndAddView() throws Exception {
-        response.addHeader("X-Width", "320");
-        response.addHeader("X-Height", "50");
         final View view = mock(View.class);
         AdViewController.setShouldHonorServerDimensions(view);
-        subject.configureUsingHttpResponse(response);
+        subject.onAdLoadSuccess(response);
 
         subject.cleanup();
         new Thread(new Runnable() {
@@ -537,23 +422,21 @@ public void run() {
         ThreadUtils.pause(10);
         Robolectric.runUiThreadTasks();
 
-        verify(moPubView, never()).removeAllViews();
-        verify(moPubView, never()).addView(any(View.class), any(FrameLayout.LayoutParams.class));
+        verify(mockMoPubView, never()).removeAllViews();
+        verify(mockMoPubView, never()).addView(any(View.class), any(FrameLayout.LayoutParams.class));
     }
 
     @Test
     public void setAdContentView_whenHonorServerDimensionsAndHasDimensions_shouldSizeAndCenterView() throws Exception {
-        response.addHeader("X-Width", "320");
-        response.addHeader("X-Height", "50");
         View view = mock(View.class);
         AdViewController.setShouldHonorServerDimensions(view);
-        subject.configureUsingHttpResponse(response);
+        subject.onAdLoadSuccess(response);
 
         subject.setAdContentView(view);
 
-        verify(moPubView).removeAllViews();
+        verify(mockMoPubView).removeAllViews();
         ArgumentCaptor<FrameLayout.LayoutParams> layoutParamsCaptor = ArgumentCaptor.forClass(FrameLayout.LayoutParams.class);
-        verify(moPubView).addView(eq(view), layoutParamsCaptor.capture());
+        verify(mockMoPubView).addView(eq(view), layoutParamsCaptor.capture());
         FrameLayout.LayoutParams layoutParams = layoutParamsCaptor.getValue();
 
         assertThat(layoutParams.width).isEqualTo(320);
@@ -563,15 +446,16 @@ public void setAdContentView_whenHonorServerDimensionsAndHasDimensions_shouldSiz
 
     @Test
     public void setAdContentView_whenHonorServerDimensionsAndDoesntHaveDimensions_shouldWrapAndCenterView() throws Exception {
+        response = response.toBuilder().setDimensions(null, null).build();
         View view = mock(View.class);
         AdViewController.setShouldHonorServerDimensions(view);
-        subject.configureUsingHttpResponse(response);
+        subject.onAdLoadSuccess(response);
 
         subject.setAdContentView(view);
 
-        verify(moPubView).removeAllViews();
+        verify(mockMoPubView).removeAllViews();
         ArgumentCaptor<FrameLayout.LayoutParams> layoutParamsCaptor = ArgumentCaptor.forClass(FrameLayout.LayoutParams.class);
-        verify(moPubView).addView(eq(view), layoutParamsCaptor.capture());
+        verify(mockMoPubView).addView(eq(view), layoutParamsCaptor.capture());
         FrameLayout.LayoutParams layoutParams = layoutParamsCaptor.getValue();
 
         assertThat(layoutParams.width).isEqualTo(FrameLayout.LayoutParams.WRAP_CONTENT);
@@ -581,20 +465,172 @@ public void setAdContentView_whenHonorServerDimensionsAndDoesntHaveDimensions_sh
 
     @Test
     public void setAdContentView_whenNotServerDimensions_shouldWrapAndCenterView() throws Exception {
-        response.addHeader("X-Width", "320");
-        response.addHeader("X-Height", "50");
-        subject.configureUsingHttpResponse(response);
+        subject.onAdLoadSuccess(response);
         View view = mock(View.class);
 
         subject.setAdContentView(view);
 
-        verify(moPubView).removeAllViews();
+        verify(mockMoPubView).removeAllViews();
         ArgumentCaptor<FrameLayout.LayoutParams> layoutParamsCaptor = ArgumentCaptor.forClass(FrameLayout.LayoutParams.class);
-        verify(moPubView).addView(eq(view), layoutParamsCaptor.capture());
+        verify(mockMoPubView).addView(eq(view), layoutParamsCaptor.capture());
         FrameLayout.LayoutParams layoutParams = layoutParamsCaptor.getValue();
 
         assertThat(layoutParams.width).isEqualTo(FrameLayout.LayoutParams.WRAP_CONTENT);
         assertThat(layoutParams.height).isEqualTo(FrameLayout.LayoutParams.WRAP_CONTENT);
         assertThat(layoutParams.gravity).isEqualTo(Gravity.CENTER);
     }
+
+    @Test
+    public void onAdLoadSuccess_withResponseContainingRefreshTime_shouldSetNewRefreshTime() {
+        assertThat(subject.getRefreshTimeMillis()).isEqualTo(60000);
+
+        response = response.toBuilder().setRefreshTimeMilliseconds(100000).build();
+        subject.onAdLoadSuccess(response);
+
+        assertThat(subject.getRefreshTimeMillis()).isEqualTo(100000);
+    }
+
+    @Test
+    public void onAdLoadSuccess_withResponseNotContainingRefreshTime_shoulSetRefreshTimeToNull() {
+        response = response.toBuilder().setRefreshTimeMilliseconds(null).build();
+        subject.onAdLoadSuccess(response);
+
+        assertThat(subject.getRefreshTimeMillis()).isNull();
+    }
+
+    @Test
+    public void onAdLoadError_withMoPubNetworkErrorIncludingRefreshTime_shouldSetNewRefreshTime() {
+        subject.setRefreshTimeMillis(54321);
+
+        subject.onAdLoadError(
+                new MoPubNetworkError(
+                        "network error with specified refresh time",
+                        MoPubNetworkError.Reason.NO_FILL,
+                        1000)
+        );
+
+        assertThat(subject.getRefreshTimeMillis()).isEqualTo(1000);
+    }
+
+    @Test
+    public void onAdLoadError_withMoPubNetworkErrorNotIncludingRefreshTime_shouldNotModifyRefreshTime() {
+        subject.setRefreshTimeMillis(12345);
+
+        subject.onAdLoadError(
+                new MoPubNetworkError(
+                        "network error that does not specify refresh time",
+                        MoPubNetworkError.Reason.UNSPECIFIED)
+        );
+
+        assertThat(subject.getRefreshTimeMillis()).isEqualTo(12345);
+    }
+
+    @Test
+    public void onAdLoadError_withVolleyErrorThatIsNotAnInstanceOfMoPubNetworkError_shouldNotModifyRefreshTime() {
+        subject.onAdLoadError(new VolleyError("message"));
+
+        assertThat(subject.getRefreshTimeMillis()).isEqualTo(60000);
+    }
+
+    @Test
+    public void onAdLoadError_withErrorReasonWarmingUp_shouldReturnErrorCodeWarmup_shouldCallMoPubViewAdFailed() {
+        final VolleyError expectedInternalError = new MoPubNetworkError(
+                MoPubNetworkError.Reason.WARMING_UP);
+
+        subject.onAdLoadError(expectedInternalError);
+
+        verify(mockMoPubView).adFailed(MoPubErrorCode.WARMUP);
+    }
+
+    @Test
+    public void onAdLoadError_whenNoNetworkConnection_shouldReturnErrorCodeNoConnection_shouldCallMoPubViewAdFailed() {
+        subject.onAdLoadError(new NoConnectionError());
+
+        // DeviceUtils#isNetworkAvailable conveniently returns false due to
+        // not having the network permission.
+        verify(mockMoPubView).adFailed(MoPubErrorCode.NO_CONNECTION);
+    }
+
+    @Test
+    public void onAdLoadError_withInvalidServerResponse_shouldReturnErrorCodeServerError_shouldCallMoPubViewAdFailed_shouldIncrementBackoffPower() {
+        for (int htmlErrorCode : HTML_ERROR_CODES) {
+            final int oldBackoffPower = subject.mBackoffPower;
+            final NetworkResponse errorNetworkResponse = new NetworkResponse(htmlErrorCode, null,
+                    null, true, 0);
+            final VolleyError volleyError = new VolleyError(errorNetworkResponse);
+
+            subject.onAdLoadError(volleyError);
+
+            assertThat(subject.mBackoffPower).isEqualTo(oldBackoffPower + 1);
+        }
+        verify(mockMoPubView, times(HTML_ERROR_CODES.length)).adFailed(MoPubErrorCode.SERVER_ERROR);
+    }
+
+    @Test
+    public void getErrorCodeFromVolleyError_whenNoConnection_shouldReturnErrorCodeNoConnection() {
+        final VolleyError noConnectionError = new NoConnectionError();
+
+        // DeviceUtils#isNetworkAvailable conveniently returns false due to
+        // not having the internet permission.
+        final MoPubErrorCode errorCode = AdViewController.getErrorCodeFromVolleyError(
+                noConnectionError, activity);
+
+        assertThat(errorCode).isEqualTo(MoPubErrorCode.NO_CONNECTION);
+    }
+
+    @Test
+    public void getErrorCodeFromVolleyError_withNullResponse_whenConnectionValid_shouldReturnErrorCodeUnspecified() {
+        final VolleyError noConnectionError = new NoConnectionError();
+
+        shadowOf(activity).grantPermissions(Manifest.permission.INTERNET);
+        final MoPubErrorCode errorCode = AdViewController.getErrorCodeFromVolleyError(
+                noConnectionError, activity);
+
+        assertThat(errorCode).isEqualTo(MoPubErrorCode.UNSPECIFIED);
+    }
+
+    @Test
+    public void getErrorCodeFromVolleyError_withInvalidServerResponse_shouldReturnErrorCodeServerError() {
+        for (int htmlErrorCode : HTML_ERROR_CODES) {
+            final NetworkResponse errorNetworkResponse = new NetworkResponse(htmlErrorCode, null,
+                    null, true, 0);
+            final VolleyError volleyError = new VolleyError(errorNetworkResponse);
+
+            final MoPubErrorCode errorCode = AdViewController.getErrorCodeFromVolleyError(
+                    volleyError, activity);
+
+            assertThat(errorCode).isEqualTo(MoPubErrorCode.SERVER_ERROR);
+        }
+    }
+
+    @Test
+    public void getErrorCodeFromVolleyError_withErrorReasonWarmingUp_shouldReturnErrorCodeWarmingUp() {
+        final VolleyError networkError = new MoPubNetworkError(MoPubNetworkError.Reason.WARMING_UP);
+
+        final MoPubErrorCode errorCode = AdViewController.getErrorCodeFromVolleyError(
+                networkError, activity);
+
+        assertThat(errorCode).isEqualTo(MoPubErrorCode.WARMUP);
+    }
+
+    @Test
+    public void getErrorCodeFromVolleyError_withErrorReasonNoFill_shouldReturnErrorCodeNoFill() {
+        final VolleyError networkError = new MoPubNetworkError(MoPubNetworkError.Reason.NO_FILL);
+
+        final MoPubErrorCode errorCode = AdViewController.getErrorCodeFromVolleyError(
+                networkError, activity);
+
+        assertThat(errorCode).isEqualTo(MoPubErrorCode.NO_FILL);
+    }
+
+    @Test
+    public void getErrorCodeFromVolleyError_withErrorReasonBadHeaderData_shouldReturnErrorCodeUnspecified() {
+        final VolleyError networkError = new MoPubNetworkError(
+                MoPubNetworkError.Reason.BAD_HEADER_DATA);
+
+        final MoPubErrorCode errorCode = AdViewController.getErrorCodeFromVolleyError(
+                networkError, activity);
+
+        assertThat(errorCode).isEqualTo(MoPubErrorCode.UNSPECIFIED);
+    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseHtmlWebViewTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseHtmlWebViewTest.java
index 0453e1bb..18e64903 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseHtmlWebViewTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseHtmlWebViewTest.java
@@ -1,24 +1,23 @@
 package com.mopub.mobileads;
 
 import android.app.Activity;
-import android.os.Build;
 import android.os.Build.VERSION_CODES;
 import android.view.MotionEvent;
 import android.view.View;
 import android.view.ViewGroup;
 
+import com.mopub.common.AdReport;
 import com.mopub.common.test.support.SdkTestRunner;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
 import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowWebView;
 
 import static android.webkit.WebSettings.PluginState;
-import static com.mopub.common.util.VersionCode.HONEYCOMB_MR2;
-import static com.mopub.common.util.VersionCode.ICE_CREAM_SANDWICH;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
@@ -28,15 +27,15 @@
 @RunWith(SdkTestRunner.class)
 public class BaseHtmlWebViewTest {
 
+    @Mock
+    AdReport mockAdReport;
     private BaseHtmlWebView subject;
     private MotionEvent touchDown;
     private MotionEvent touchUp;
-    private AdConfiguration adConfiguration;
 
     @Before
     public void setUp() throws Exception {
-        adConfiguration = mock(AdConfiguration.class);
-        subject = new BaseHtmlWebView(new Activity(), adConfiguration);
+        subject = new BaseHtmlWebView(Robolectric.buildActivity(Activity.class).create().get(), mockAdReport);
 
         touchDown = createMotionEvent(MotionEvent.ACTION_DOWN);
         touchUp = createMotionEvent(MotionEvent.ACTION_UP);
@@ -45,7 +44,7 @@ public void setUp() throws Exception {
     @Config(reportSdk = VERSION_CODES.JELLY_BEAN_MR2)
     @Test
     public void pluginState_atLeastJellybeanMr2_shouldDefaultToOff_shouldNeverBeEnabled()  {
-        subject = new BaseHtmlWebView(new Activity(), adConfiguration);
+        subject = new BaseHtmlWebView(Robolectric.buildActivity(Activity.class).create().get(), mockAdReport);
         assertThat(subject.getSettings().getPluginState()).isEqualTo(PluginState.OFF);
 
         subject.enablePlugins(true);
@@ -55,7 +54,7 @@ public void pluginState_atLeastJellybeanMr2_shouldDefaultToOff_shouldNeverBeEnab
     @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void pluginState_atLeastIcsButBelowJellybeanMr2_shouldDefaultToOn_shouldAllowToggling() {
-        subject = new BaseHtmlWebView(new Activity(), adConfiguration);
+        subject = new BaseHtmlWebView(Robolectric.buildActivity(Activity.class).create().get(), mockAdReport);
         assertThat(subject.getSettings().getPluginState()).isEqualTo(PluginState.ON);
 
         subject.enablePlugins(false);
@@ -68,7 +67,7 @@ public void pluginState_atLeastIcsButBelowJellybeanMr2_shouldDefaultToOn_shouldA
     @Config(reportSdk = VERSION_CODES.GINGERBREAD_MR1)
     @Test
     public void pluginState_beforeIcs_shouldDefaultToOff_shouldAllowToggling() {
-        subject = new BaseHtmlWebView(new Activity(), adConfiguration);
+        subject = new BaseHtmlWebView(Robolectric.buildActivity(Activity.class).create().get(), mockAdReport);
         assertThat(subject.getSettings().getPluginState()).isEqualTo(PluginState.OFF);
 
         subject.enablePlugins(true);
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseInterstitialActivityTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseInterstitialActivityTest.java
index cf7d6c34..f5eefa09 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseInterstitialActivityTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseInterstitialActivityTest.java
@@ -1,160 +1,86 @@
 package com.mopub.mobileads;
 
 import android.app.Activity;
-import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
-import android.graphics.drawable.StateListDrawable;
 import android.view.View;
 import android.view.ViewGroup;
-import android.widget.ImageButton;
-import android.widget.RelativeLayout;
-import org.fest.assertions.api.ANDROID;
-import org.junit.Ignore;
+import android.widget.FrameLayout;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
 import org.junit.Test;
+import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
-import org.robolectric.shadows.ShadowLocalBroadcastManager;
-
-import static com.mopub.common.util.Drawables.INTERSTITIAL_CLOSE_BUTTON_NORMAL;
-import static com.mopub.common.util.Drawables.INTERSTITIAL_CLOSE_BUTTON_PRESSED;
-import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
-import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
-import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
-import static com.mopub.mobileads.EventForwardingBroadcastReceiver.getHtmlInterstitialIntentFilter;
-import static com.mopub.mobileads.EventForwardingBroadcastReceiverTest.getIntentForActionAndIdentifier;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.stub;
-import static org.mockito.Mockito.verify;
-import static org.robolectric.Robolectric.shadowOf;
-
-@Ignore
-public class BaseInterstitialActivityTest {
-    public static final String EXPECTED_SOURCE = "expected source";
 
-    protected BaseInterstitialActivity subject;
-    protected BroadcastReceiver broadcastReceiver;
-    protected AdConfiguration adConfiguration;
-    protected long testBroadcastIdentifier;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
+import static org.fest.assertions.api.Assertions.assertThat;
 
-    public void setup() {
-        broadcastReceiver = mock(BroadcastReceiver.class);
-        testBroadcastIdentifier = 2222;
+@RunWith(SdkTestRunner.class)
+public class BaseInterstitialActivityTest {
+    private BaseInterstitialActivity subject;
+    private long broadcastIdentifier;
+
+    // Make a concrete version of the abstract class for testing purposes.
+    private static class TestInterstitialActivity extends BaseInterstitialActivity {
+        View view;
+
+        @Override
+        public View getAdView() {
+            if (view == null) {
+                view = new View(this);
+            }
+            return view;
+        }
     }
 
-    @Test
-    public void onCreate_shouldBroadcastInterstitialShow() throws Exception {
-        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_SHOW, testBroadcastIdentifier);
-        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
-
-        subject.onCreate(null);
-
-        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
+    @Before
+    public void setup() {
+        broadcastIdentifier = 2222;
     }
 
     @Test
     public void onCreate_shouldCreateView() throws Exception {
-        subject.onCreate(null);
-
+        subject = Robolectric.buildActivity(TestInterstitialActivity.class).create().get();
         View adView = getContentView(subject).getChildAt(0);
 
         assertThat(adView).isNotNull();
     }
 
-    @Test
-    public void onCreate_shouldShowInterstitialCloseButton() throws Exception {
-        subject.onCreate(null);
-
-        ImageButton closeButton = getCloseButton();
-
-        Robolectric.clickOn(closeButton);
-
-        ANDROID.assertThat(subject).isFinishing();
-    }
-
-    @Test
-    public void onCreate_shouldMakeCloseButtonVisible() throws Exception {
-        subject.onCreate(null);
-
-        ImageButton closeButton = getCloseButton();
-
-        ANDROID.assertThat(closeButton).isVisible();
-        StateListDrawable states = (StateListDrawable) closeButton.getDrawable();
-
-        int[] unpressedState = new int[] {-android.R.attr.state_pressed};
-        assertThat(shadowOf(states).getDrawableForState(unpressedState))
-                .isEqualTo(INTERSTITIAL_CLOSE_BUTTON_NORMAL.decodeImage(new Activity()));
-        int[] pressedState = new int[] {android.R.attr.state_pressed};
-        assertThat(shadowOf(states).getDrawableForState(pressedState))
-                .isEqualTo(INTERSTITIAL_CLOSE_BUTTON_PRESSED.decodeImage(new Activity()));
-    }
-
-    @Test
-    public void canShowAndHideTheCloseButton() throws Exception {
-        subject.onCreate(null);
-        ANDROID.assertThat(getCloseButton()).isVisible();
-
-        subject.hideInterstitialCloseButton();
-        ANDROID.assertThat(getCloseButton()).isInvisible();
-
-        subject.showInterstitialCloseButton();
-        ANDROID.assertThat(getCloseButton()).isVisible();
-    }
-
     @Test
     public void onDestroy_shouldCleanUpContentView() throws Exception {
-        subject.onCreate(null);
-        subject.onDestroy();
+        subject = Robolectric.buildActivity(TestInterstitialActivity.class).create().destroy().get();
 
         assertThat(getContentView(subject).getChildCount()).isEqualTo(0);
     }
 
     @Test
-    public void onDestroy_shouldBroadcastInterstitialDismiss() throws Exception {
-        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_DISMISS, testBroadcastIdentifier);
-        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
-
-        subject.onCreate(null);
-        subject.onDestroy();
-
-        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
-    }
-
-    @Test
-    public void getAdConfiguration_shouldReturnAdConfigurationFromIntent() throws Exception {
-        Intent intent = new Intent();
-        intent.putExtra(AD_CONFIGURATION_KEY, adConfiguration);
-
-        subject.onCreate(null);
-        subject.setIntent(intent);
-
-        assertThat(subject.getAdConfiguration()).isNotNull();
+    public void getBroadcastIdentifier_shouldReturnBroadcastIdFromIntent() throws Exception {
+        Context context = Robolectric.buildActivity(Activity.class).create().get();
+        Intent intent = new Intent(context, TestInterstitialActivity.class);
+        intent.putExtra(BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
+
+        subject = Robolectric.buildActivity(TestInterstitialActivity.class)
+                .withIntent(intent)
+                .create().get();
+        assertThat(subject.getBroadcastIdentifier()).isEqualTo(2222L);
     }
 
     @Test
-    public void getAdConfiguration_withMissingOrWrongAdConfiguration_shouldReturnNull() throws Exception {
-        Intent intent = new Intent();
-        // This intent is missing an AdConfiguration extra.
-
-        subject.onCreate(null);
-        subject.setIntent(intent);
+    public void getBroadcastIdentifier_withMissingBroadCastId_shouldReturnNull() throws Exception {
+        Context context = Robolectric.buildActivity(Activity.class).create().get();
+        Intent intent = new Intent(context, TestInterstitialActivity.class);
+        // This intent is missing a broadcastidentifier extra.
 
-        assertThat(subject.getAdConfiguration()).isNull();
-    }
-
-    protected ImageButton getCloseButton() {
-        return (ImageButton) getContentView(subject).getChildAt(1);
-    }
+        subject = Robolectric.buildActivity(TestInterstitialActivity.class)
+                .withIntent(intent)
+                .create().get();
 
-    protected RelativeLayout getContentView(BaseInterstitialActivity subject) {
-        return (RelativeLayout) ((ViewGroup) subject.findViewById(android.R.id.content)).getChildAt(0);
+        assertThat(subject.getBroadcastIdentifier()).isNull();
     }
 
-    protected void resetMockedView(View view) {
-        reset(view);
-        stub(view.getLayoutParams()).toReturn(new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.WRAP_CONTENT, RelativeLayout.LayoutParams.WRAP_CONTENT));
+    protected FrameLayout getContentView(BaseInterstitialActivity subject) {
+        return (FrameLayout) ((ViewGroup) subject.findViewById(android.R.id.content)).getChildAt(0);
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseVideoPlayerActivitiyTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseVideoPlayerActivityTest.java
similarity index 64%
rename from mopub-sdk/src/test/java/com/mopub/mobileads/BaseVideoPlayerActivitiyTest.java
rename to mopub-sdk/src/test/java/com/mopub/mobileads/BaseVideoPlayerActivityTest.java
index 5663115e..bd7a88b1 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseVideoPlayerActivitiyTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseVideoPlayerActivityTest.java
@@ -12,71 +12,66 @@
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 
-import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
 import static com.mopub.mobileads.BaseVideoPlayerActivity.VIDEO_URL;
 import static com.mopub.mobileads.BaseVideoPlayerActivity.startMraid;
 import static com.mopub.mobileads.BaseVideoPlayerActivity.startVast;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
 import static org.mockito.Mockito.withSettings;
 
 @RunWith(SdkTestRunner.class)
-public class BaseVideoPlayerActivitiyTest {
+public class BaseVideoPlayerActivityTest {
     private static final String MRAID_VIDEO_URL = "http://mraidVideo";
 
-    private AdConfiguration adConfiguration;
     private long testBroadcastIdentifier;
     private VastVideoConfiguration vastVideoConfiguration;
 
     @Before
     public void setup() throws Exception {
-        adConfiguration = mock(AdConfiguration.class, withSettings().serializable());
         vastVideoConfiguration = mock(VastVideoConfiguration.class, withSettings().serializable());
-
         testBroadcastIdentifier = 1234;
-        when(adConfiguration.getBroadcastIdentifier()).thenReturn(testBroadcastIdentifier);
     }
 
     @Test
     public void startMraid_shouldStartMraidVideoPlayerActivity() throws Exception {
-        startMraid(new Activity(), MRAID_VIDEO_URL, adConfiguration);
-        assertMraidVideoPlayerActivityStarted(MraidVideoPlayerActivity.class, MRAID_VIDEO_URL, adConfiguration);
+        startMraid(new Activity(), MRAID_VIDEO_URL);
+        assertMraidVideoPlayerActivityStarted(MraidVideoPlayerActivity.class, MRAID_VIDEO_URL);
     }
 
     @Test
     public void startVast_shouldStartMraidVideoPlayerActivity() throws Exception {
-        startVast(new Activity(), vastVideoConfiguration, adConfiguration);
-        assertVastVideoPlayerActivityStarted(MraidVideoPlayerActivity.class, vastVideoConfiguration, adConfiguration);
+        startVast(new Activity(), vastVideoConfiguration, testBroadcastIdentifier);
+        assertVastVideoPlayerActivityStarted(MraidVideoPlayerActivity.class, vastVideoConfiguration, testBroadcastIdentifier);
     }
 
     static void assertVastVideoPlayerActivityStarted(final Class clazz,
             final VastVideoConfiguration vastVideoConfiguration,
-            final AdConfiguration adConfiguration) {
+            final long broadcastIdentifier) {
         final Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertIntentAndAdConfigurationAreCorrect(intent, clazz, adConfiguration);
+        assertIntentAndBroadcastIdentifierAreCorrect(intent, clazz, broadcastIdentifier);
 
         final VastVideoConfiguration expectedVastVideoConfiguration =
                 (VastVideoConfiguration) intent.getSerializableExtra(VastVideoViewController.VAST_VIDEO_CONFIGURATION);
         assertThat(expectedVastVideoConfiguration).isEqualsToByComparingFields(vastVideoConfiguration);
     }
 
-    static void assertMraidVideoPlayerActivityStarted(final Class clazz,
-            final String url,
-            final AdConfiguration adConfiguration) {
+    public static void assertMraidVideoPlayerActivityStarted(final Class clazz, final String url) {
         final Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertIntentAndAdConfigurationAreCorrect(intent, clazz, adConfiguration);
+        assertIntentAndBroadcastIdentifierAreCorrect(intent, clazz, null);
 
         assertThat(intent.getStringExtra(VIDEO_URL)).isEqualTo(url);
     }
 
-    static void assertIntentAndAdConfigurationAreCorrect(final Intent intent,
+    static void assertIntentAndBroadcastIdentifierAreCorrect(final Intent intent,
             final Class clazz,
-            final AdConfiguration adConfiguration) {
+            final Long expectedBroadcastId) {
         assertThat(intent.getComponent().getClassName()).isEqualTo(clazz.getCanonicalName());
         assertThat(Utils.bitMaskContainsFlag(intent.getFlags(), Intent.FLAG_ACTIVITY_NEW_TASK)).isTrue();
 
-        final AdConfiguration expectedAdConfiguration = (AdConfiguration) intent.getSerializableExtra(AD_CONFIGURATION_KEY);
-        assertThat(expectedAdConfiguration).isEqualsToByComparingFields(adConfiguration);
+        if (expectedBroadcastId != null) {
+            final long actualBroadcastId = (Long) intent.getSerializableExtra(BROADCAST_IDENTIFIER_KEY);
+            assertThat(actualBroadcastId).isEqualTo(expectedBroadcastId);
+        }
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseWebViewTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseWebViewTest.java
index a6c36a4d..4865c737 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseWebViewTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseWebViewTest.java
@@ -2,7 +2,6 @@
 
 
 import android.app.Activity;
-import android.os.Build;
 import android.os.Build.VERSION_CODES;
 import android.view.ViewGroup;
 import android.webkit.WebSettings;
@@ -12,12 +11,9 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowWebView;
 
-import static com.mopub.common.util.VersionCode.JELLY_BEAN_MR1;
-import static com.mopub.common.util.VersionCode.JELLY_BEAN_MR2;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventAdLoadTaskTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventAdLoaderTest.java
similarity index 52%
rename from mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventAdLoadTaskTest.java
rename to mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventAdLoaderTest.java
index 944e8378..c3dbf03d 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventAdLoadTaskTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventAdLoaderTest.java
@@ -16,11 +16,12 @@
 import static org.mockito.Mockito.verify;
 
 @RunWith(SdkTestRunner.class)
-public class CustomEventAdLoadTaskTest {
+public class CustomEventAdLoaderTest {
 
     private AdViewController adViewController;
-    private AdLoadTask.CustomEventAdLoadTask subject;
-    private Map<String, String> paramsMap;
+    private AdLoader.CustomEventAdLoader subject;
+    private String customEventName;
+    private Map<String, String> serverExtras;
     private MoPubView moPubView;
 
     @Before
@@ -28,23 +29,25 @@ public void setup() {
         moPubView = mock(MoPubView.class);
         adViewController = mock(AdViewController.class);
         stub(adViewController.getMoPubView()).toReturn(moPubView);
-        paramsMap = new HashMap<String, String>();
-        subject = new AdLoadTask.CustomEventAdLoadTask(adViewController, paramsMap);
+        customEventName = "testCustomEvent";
+        serverExtras = new HashMap<String, String>();
+        subject = new AdLoader.CustomEventAdLoader(adViewController,
+                customEventName, serverExtras);
     }
 
     @Test
     public void execute_shouldCallLoadCustomEvent() throws Exception {
-        subject.execute();
+        subject.load();
 
         verify(adViewController).setNotLoading();
-        verify(moPubView).loadCustomEvent(eq(paramsMap));
+        verify(moPubView).loadCustomEvent(eq(customEventName), eq(serverExtras));
     }
 
     @Test
     public void execute_whenAdViewControllerIsNull_shouldDoNothing() throws Exception {
-        subject = new AdLoadTask.CustomEventAdLoadTask(null, paramsMap);
+        subject = new AdLoader.CustomEventAdLoader(null, customEventName, serverExtras);
 
-        subject.execute();
+        subject.load();
         // pass
     }
 
@@ -52,28 +55,29 @@ public void execute_whenAdViewControllerIsNull_shouldDoNothing() throws Exceptio
     public void execute_whenAdViewControllerIsDestroyed_shouldDoNothing() throws Exception {
         stub(adViewController.isDestroyed()).toReturn(true);
 
-        subject.execute();
+        subject.load();
 
         verify(adViewController, never()).setNotLoading();
-        verify(moPubView, never()).loadCustomEvent(eq(paramsMap));
+        verify(moPubView, never()).loadCustomEvent(eq(customEventName), eq(serverExtras));
     }
 
     @Test
-    public void execute_whenParamsMapIsNull_shouldLoadNullParamsMap() throws Exception {
-        subject = new AdLoadTask.CustomEventAdLoadTask(adViewController, null);
+    public void execute_whenCustomEventIsNull_shouldDoNothing() {
+        subject = new AdLoader.CustomEventAdLoader(adViewController, null, serverExtras);
 
-        subject.execute();
+        subject.load();
 
-        verify(adViewController).setNotLoading();
-        verify(moPubView).loadCustomEvent((Map<String, String>) eq(null));
+        verify(adViewController, never()).setNotLoading();
+        verify(moPubView, never()).loadCustomEvent((String) eq(null), eq(serverExtras));
     }
 
     @Test
-    public void execute_afterCleanup_shouldLoadNullParamsMap() throws Exception {
-        subject.cleanup();
-        subject.execute();
+    public void execute_whenParamsMapIsNull_shouldLoadNullParamsMap() throws Exception {
+        subject = new AdLoader.CustomEventAdLoader(adViewController, customEventName, null);
+
+        subject.load();
 
         verify(adViewController).setNotLoading();
-        verify(moPubView).loadCustomEvent((Map<String, String>) eq(null));
+        verify(moPubView).loadCustomEvent(eq(customEventName), (Map<String, String>) eq(null));
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventBannerAdapterTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventBannerAdapterTest.java
index d99e6508..884ac9a0 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventBannerAdapterTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventBannerAdapterTest.java
@@ -5,12 +5,15 @@
 import android.location.Location;
 import android.view.View;
 
+import com.mopub.common.AdReport;
+import com.mopub.common.DataKeys;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.mobileads.factories.CustomEventBannerFactory;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
@@ -18,7 +21,6 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
 import static com.mopub.mobileads.CustomEventBanner.CustomEventBannerListener;
 import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_TIMEOUT;
@@ -30,33 +32,56 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.stub;
 import static org.mockito.Mockito.verify;
-
+import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
 public class CustomEventBannerAdapterTest {
     private CustomEventBannerAdapter subject;
+    @Mock
     private MoPubView moPubView;
+    @Mock
+    private AdReport mockAdReport;
     private static final String CLASS_NAME = "arbitrary_banner_adapter_class_name";
-    private static final String JSON_PARAMS = "{\"key\":\"value\",\"a different key\":\"a different value\"}";
+    private static final long BROADCAST_IDENTIFIER = 123;
+    private Map<String, String> serverExtras;
     private CustomEventBanner banner;
+    private Map<String,Object> localExtras;
     private Map<String,Object> expectedLocalExtras;
     private HashMap<String,String> expectedServerExtras;
 
     @Before
     public void setUp() throws Exception {
-        moPubView = mock(MoPubView.class);
-        stub(moPubView.getAdTimeoutDelay()).toReturn(null);
 
-        subject = new CustomEventBannerAdapter(moPubView, CLASS_NAME, JSON_PARAMS);
+        when(moPubView.getAdTimeoutDelay()).thenReturn(null);
+        when(moPubView.getAdWidth()).thenReturn(320);
+        when(moPubView.getAdHeight()).thenReturn(50);
+
+        localExtras = new HashMap<String, Object>();
+        when(moPubView.getLocalExtras()).thenReturn(localExtras);
+
+        serverExtras = new HashMap<String, String>();
+        serverExtras.put("key", "value");
+        serverExtras.put("another_key", "another_value");
+        subject = new CustomEventBannerAdapter(moPubView, CLASS_NAME, serverExtras, BROADCAST_IDENTIFIER, mockAdReport);
 
         expectedLocalExtras = new HashMap<String, Object>();
+        expectedLocalExtras.put(DataKeys.AD_REPORT_KEY, mockAdReport);
+        expectedLocalExtras.put("broadcastIdentifier", BROADCAST_IDENTIFIER);
+        expectedLocalExtras.put(DataKeys.AD_WIDTH, 320);
+        expectedLocalExtras.put(DataKeys.AD_HEIGHT, 50);
+
         expectedServerExtras = new HashMap<String, String>();
 
         banner = CustomEventBannerFactory.create(CLASS_NAME);
     }
 
+    @Test
+    public void constructor_shouldPopulateLocalExtrasWithAdWidthAndHeight() throws Exception {
+        assertThat(localExtras.get("com_mopub_ad_width")).isEqualTo(320);
+        assertThat(localExtras.get("com_mopub_ad_height")).isEqualTo(50);
+    }
+
     @Test
     public void timeout_shouldSignalFailureAndInvalidateWithDefaultDelay() throws Exception {
         subject.loadAd();
@@ -72,7 +97,7 @@ public void timeout_shouldSignalFailureAndInvalidateWithDefaultDelay() throws Ex
 
     @Test
     public void timeout_withNegativeAdTimeoutDelay_shouldSignalFailureAndInvalidateWithDefaultDelay() throws Exception {
-        stub(moPubView.getAdTimeoutDelay()).toReturn(-1);
+        when(moPubView.getAdTimeoutDelay()).thenReturn(-1);
 
         subject.loadAd();
 
@@ -87,7 +112,7 @@ public void timeout_withNegativeAdTimeoutDelay_shouldSignalFailureAndInvalidateW
 
     @Test
     public void timeout_withNonNullAdTimeoutDelay_shouldSignalFailureAndInvalidateWithCustomDelay() throws Exception {
-        stub(moPubView.getAdTimeoutDelay()).toReturn(77);
+       when(moPubView.getAdTimeoutDelay()).thenReturn(77);
 
         subject.loadAd();
 
@@ -100,18 +125,6 @@ public void timeout_withNonNullAdTimeoutDelay_shouldSignalFailureAndInvalidateWi
         assertThat(subject.isInvalidated()).isTrue();
     }
 
-    @Test
-    public void loadAd_shouldHaveEmptyServerExtrasOnInvalidJsonParams() throws Exception {
-        subject = new CustomEventBannerAdapter(moPubView, CLASS_NAME, "{this is terrible JSON");
-        subject.loadAd();
-
-        verify(banner).loadBanner(
-                any(Context.class),
-                eq(subject),
-                eq(expectedLocalExtras),
-                eq(expectedServerExtras)
-        );
-    }
 
     @Test
     public void loadAd_shouldPropagateLocationInLocalExtras() throws Exception {
@@ -119,8 +132,8 @@ public void loadAd_shouldPropagateLocationInLocalExtras() throws Exception {
         expectedLocation.setLongitude(10.0);
         expectedLocation.setLongitude(20.1);
 
-        stub(moPubView.getLocation()).toReturn(expectedLocation);
-        subject = new CustomEventBannerAdapter(moPubView, CLASS_NAME, null);
+        when(moPubView.getLocation()).thenReturn(expectedLocation);
+        subject = new CustomEventBannerAdapter(moPubView, CLASS_NAME, new HashMap<String, String>(), BROADCAST_IDENTIFIER, mockAdReport);
         subject.loadAd();
 
         expectedLocalExtras.put("location", moPubView.getLocation());
@@ -134,11 +147,11 @@ public void loadAd_shouldPropagateLocationInLocalExtras() throws Exception {
     }
 
     @Test
-    public void loadAd_shouldPropagateJsonParamsInServerExtras() throws Exception {
+    public void loadAd_shouldPropagateServerExtrasToLoadBanner() throws Exception {
         subject.loadAd();
 
         expectedServerExtras.put("key", "value");
-        expectedServerExtras.put("a different key", "a different value");
+        expectedServerExtras.put("another_key", "another_value");
 
         verify(banner).loadBanner(
                 any(Context.class),
@@ -212,7 +225,7 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
                 .when(banner)
                 .loadBanner(
                         any(Context.class),
-                        any(CustomEventBanner.CustomEventBannerListener.class),
+                        any(CustomEventBannerListener.class),
                         any(Map.class),
                         any(Map.class)
                 );
@@ -226,7 +239,7 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
     public void onBannerLoaded_shouldSignalMoPubView() throws Exception {
         View view = new View(new Activity());
         subject.onBannerLoaded(view);
-        
+
         verify(moPubView).nativeAdLoaded();
         verify(moPubView).setAdContentView(eq(view));
         verify(moPubView).trackNativeImpression();
@@ -266,14 +279,14 @@ public void onBannerExpanded_shouldPauseRefreshAndCallAdPresentOverlay() throws
 
     @Test
     public void onBannerCollapsed_shouldRestoreRefreshSettingAndCallAdClosed() throws Exception {
-        stub(moPubView.getAutorefreshEnabled()).toReturn(true);
+        when(moPubView.getAutorefreshEnabled()).thenReturn(true);
         subject.onBannerExpanded();
         reset(moPubView);
         subject.onBannerCollapsed();
         verify(moPubView).setAutorefreshEnabled(eq(true));
         verify(moPubView).adClosed();
 
-        stub(moPubView.getAutorefreshEnabled()).toReturn(false);
+        when(moPubView.getAutorefreshEnabled()).thenReturn(false);
         subject.onBannerExpanded();
         reset(moPubView);
         subject.onBannerCollapsed();
@@ -328,19 +341,4 @@ public void invalidate_shouldCauseBannerListenerMethodsToDoNothing() throws Exce
         verify(moPubView, never()).adClosed();
         verify(moPubView, never()).registerClick();
     }
-
-    @Test
-    public void init_whenPassedHtmlData_shouldPutItInLocalExtras() throws Exception {
-        String expectedHtmlData = "expected html data";
-        expectedServerExtras.put(HTML_RESPONSE_BODY_KEY, expectedHtmlData);
-        subject = new CustomEventBannerAdapter(moPubView, CLASS_NAME, "{\"Html-Response-Body\":\"expected html data\"}");
-        subject.loadAd();
-
-        verify(banner).loadBanner(
-                any(Context.class),
-                eq(subject),
-                eq(expectedLocalExtras),
-                eq(expectedServerExtras)
-        );
-    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventInterstitialAdapterTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventInterstitialAdapterTest.java
index cdf1ad36..3649c405 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventInterstitialAdapterTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventInterstitialAdapterTest.java
@@ -3,17 +3,22 @@
 import android.content.Context;
 import android.location.Location;
 
+import com.mopub.common.AdReport;
+import com.mopub.common.DataKeys;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.mobileads.factories.CustomEventInterstitialFactory;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
 
-import java.util.*;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.TreeMap;
 
 import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
 import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR;
@@ -29,30 +34,37 @@
 import static org.mockito.Mockito.stub;
 import static org.mockito.Mockito.verify;
 
-
 @RunWith(SdkTestRunner.class)
 public class CustomEventInterstitialAdapterTest {
+    private static long BROADCAST_IDENTIFER = 123;
     private CustomEventInterstitialAdapter subject;
-    private MoPubInterstitial moPubInterstitial;
+    @Mock
+    private MoPubInterstitial mockMoPubInterstitial;
     private CustomEventInterstitial interstitial;
     private Map<String, Object> expectedLocalExtras;
     private HashMap<String, String> expectedServerExtras;
-    private AdViewController adViewController;
+    @Mock
+    private AdViewController mockAdViewController;
+    @Mock
+    private AdReport mockAdReport;
     private MoPubInterstitial.MoPubInterstitialView moPubInterstitialView;
     private static final String CLASS_NAME = "arbitrary_interstitial_adapter_class_name";
-    private static final String JSON_PARAMS = "{\"key\":\"value\",\"a different key\":\"a different value\"}";
+    private Map<String, String> serverExtras;
     private CustomEventInterstitialAdapter.CustomEventInterstitialAdapterListener interstitialAdapterListener;
 
     @Before
     public void setUp() throws Exception {
-        moPubInterstitial = mock(MoPubInterstitial.class);
-        stub(moPubInterstitial.getAdTimeoutDelay()).toReturn(null);
+
+        stub(mockMoPubInterstitial.getAdTimeoutDelay()).toReturn(null);
         moPubInterstitialView = mock(MoPubInterstitial.MoPubInterstitialView.class);
-        adViewController = mock(AdViewController.class);
-        stub(moPubInterstitialView.getAdViewController()).toReturn(adViewController);
-        stub(moPubInterstitial.getMoPubInterstitialView()).toReturn(moPubInterstitialView);
+        stub(moPubInterstitialView.getAdViewController()).toReturn(mockAdViewController);
+        stub(mockAdViewController.getAdReport()).toReturn(mockAdReport);
+        stub(mockMoPubInterstitial.getMoPubInterstitialView()).toReturn(moPubInterstitialView);
 
-        subject = new CustomEventInterstitialAdapter(moPubInterstitial, CLASS_NAME, JSON_PARAMS);
+        serverExtras = new HashMap<String, String>();
+        serverExtras.put("key", "value");
+
+        subject = new CustomEventInterstitialAdapter(mockMoPubInterstitial, CLASS_NAME, serverExtras, BROADCAST_IDENTIFER, mockAdViewController.getAdReport());
 
         expectedLocalExtras = new HashMap<String, Object>();
         expectedServerExtras = new HashMap<String, String>();
@@ -68,8 +80,8 @@ public void constructor_withInvalidClassName_shouldCallOnCustomEventInterstitial
         // Remove testing mock and use the real thing
         CustomEventInterstitialFactory.setInstance(new CustomEventInterstitialFactory());
 
-        new CustomEventInterstitialAdapter(moPubInterstitial, "bad_class_name_11i234jb", null);
-        verify(moPubInterstitial).onCustomEventInterstitialFailed(ADAPTER_NOT_FOUND);
+        new CustomEventInterstitialAdapter(mockMoPubInterstitial, "bad_class_name_11i234jb", new TreeMap<String, String>(), BROADCAST_IDENTIFER, mockAdViewController.getAdReport());
+        verify(mockMoPubInterstitial).onCustomEventInterstitialFailed(ADAPTER_NOT_FOUND);
     }
 
     @Test
@@ -86,7 +98,7 @@ public void timeout_shouldSignalFailureAndInvalidateWithDefaultDelay() throws Ex
 
     @Test
     public void timeout_withNegativeAdTimeoutDelay_shouldSignalFailureAndInvalidateWithDefaultDelay() throws Exception {
-        stub(moPubInterstitial.getAdTimeoutDelay()).toReturn(-1);
+        stub(mockMoPubInterstitial.getAdTimeoutDelay()).toReturn(-1);
 
         subject.loadInterstitial();
         Robolectric.idleMainLooper(CustomEventInterstitialAdapter.DEFAULT_INTERSTITIAL_TIMEOUT_DELAY - 1);
@@ -100,7 +112,7 @@ public void timeout_withNegativeAdTimeoutDelay_shouldSignalFailureAndInvalidateW
 
     @Test
     public void timeout_withNonNullAdTimeoutDelay_shouldSignalFailureAndInvalidateWithCustomDelay() throws Exception {
-        stub(moPubInterstitial.getAdTimeoutDelay()).toReturn(77);
+        stub(mockMoPubInterstitial.getAdTimeoutDelay()).toReturn(77);
 
         subject.loadInterstitial();
         Robolectric.idleMainLooper(77000 - 1);
@@ -112,31 +124,18 @@ public void timeout_withNonNullAdTimeoutDelay_shouldSignalFailureAndInvalidateWi
         assertThat(subject.isInvalidated()).isTrue();
     }
 
-    @Test
-    public void loadInterstitial_shouldHaveEmptyServerExtrasOnInvalidJsonParams() throws Exception {
-        subject = new CustomEventInterstitialAdapter(moPubInterstitial, CLASS_NAME, "{this is terrible JSON");
-        subject.loadInterstitial();
-        expectedLocalExtras.put("Ad-Configuration", null);
-
-        verify(interstitial).loadInterstitial(
-                any(Context.class),
-                eq(subject),
-                eq(expectedLocalExtras),
-                eq(expectedServerExtras)
-        );
-    }
-
     @Test
     public void loadInterstitial_shouldPropagateLocationInLocalExtras() throws Exception {
         Location expectedLocation = new Location("");
         expectedLocation.setLongitude(10.0);
         expectedLocation.setLongitude(20.1);
-        stub(moPubInterstitial.getLocation()).toReturn(expectedLocation);
-        subject = new CustomEventInterstitialAdapter(moPubInterstitial, CLASS_NAME, null);
+        stub(mockMoPubInterstitial.getLocation()).toReturn(expectedLocation);
+        subject = new CustomEventInterstitialAdapter(mockMoPubInterstitial, CLASS_NAME, new HashMap<String, String>(), BROADCAST_IDENTIFER, mockAdViewController.getAdReport());
         subject.loadInterstitial();
 
-        expectedLocalExtras.put("Ad-Configuration", null);
-        expectedLocalExtras.put("location", moPubInterstitial.getLocation());
+        expectedLocalExtras.put("broadcastIdentifier", BROADCAST_IDENTIFER);
+        expectedLocalExtras.put(DataKeys.AD_REPORT_KEY, mockAdReport);
+        expectedLocalExtras.put("location", mockMoPubInterstitial.getLocation());
 
         verify(interstitial).loadInterstitial(
                 any(Context.class),
@@ -147,11 +146,11 @@ public void loadInterstitial_shouldPropagateLocationInLocalExtras() throws Excep
     }
 
     @Test
-    public void loadInterstitial_shouldPropagateJsonParamsInServerExtras() throws Exception {
+    public void loadInterstitial_shouldPropagateServerExtrasToInterstitial() throws Exception {
         subject.loadInterstitial();
-        expectedLocalExtras.put("Ad-Configuration", null);
+        expectedLocalExtras.put("broadcastIdentifier", BROADCAST_IDENTIFER);
+        expectedLocalExtras.put(DataKeys.AD_REPORT_KEY, mockAdReport);
         expectedServerExtras.put("key", "value");
-        expectedServerExtras.put("a different key", "a different value");
 
         verify(interstitial).loadInterstitial(
                 any(Context.class),
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/EventForwardingBroadcastReceiverTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/EventForwardingBroadcastReceiverTest.java
index d0dfea10..e028844b 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/EventForwardingBroadcastReceiverTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/EventForwardingBroadcastReceiverTest.java
@@ -5,6 +5,7 @@
 import android.content.IntentFilter;
 import android.support.v4.content.LocalBroadcastManager;
 
+import com.mopub.common.DataKeys;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.mobileads.factories.CustomEventInterstitialAdapterFactory;
 
@@ -15,9 +16,11 @@
 import org.junit.runner.RunWith;
 import org.robolectric.shadows.ShadowLocalBroadcastManager;
 
-import java.util.*;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
 
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
 import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_CLICK;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
@@ -48,7 +51,7 @@ public void setUp() throws Exception {
         context = new Activity();
     }
 
-    @Ignore("pending")
+    @Ignore("Difficult with the number of test factories and mocking involved.")
     @Test
     public void twoDifferentInterstitials_shouldNotHearEachOthersBroadcasts() throws Exception {
         final MoPubInterstitial interstitialA = new MoPubInterstitial(context, "adunitid");
@@ -59,11 +62,14 @@ public void twoDifferentInterstitials_shouldNotHearEachOthersBroadcasts() throws
         final InterstitialAdListener listenerB = mock(InterstitialAdListener.class);
         interstitialB.setInterstitialAdListener(listenerB);
 
+        Map<String, String> serverExtras = new HashMap<String, String>();
+        serverExtras.put(DataKeys.HTML_RESPONSE_BODY_KEY, "response");
         final CustomEventInterstitialAdapter customEventInterstitialAdapter =
                 CustomEventInterstitialAdapterFactory.create(
                         interstitialA,
                         "com.mopub.mobileads.HtmlInterstitial",
-                        "{" + HTML_RESPONSE_BODY_KEY + ":response}");
+                        serverExtras, broadcastIdentifier, null);
+
 
         customEventInterstitialAdapter.loadInterstitial();
         verify(listenerA).onInterstitialLoaded(interstitialA);
@@ -205,7 +211,7 @@ public void unregister_shouldNotLeakTheContext() throws Exception {
         verify(customEventInterstitialListener).onInterstitialShown();
     }
 
-    static Intent getIntentForActionAndIdentifier(final String action, final long broadcastIdentifier) {
+    public static Intent getIntentForActionAndIdentifier(final String action, final long broadcastIdentifier) {
         final Intent intent = new Intent(action);
         intent.putExtra("broadcastIdentifier", broadcastIdentifier);
         return intent;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlBannerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlBannerTest.java
index d541d73d..4b7f81c9 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlBannerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlBannerTest.java
@@ -1,16 +1,14 @@
 package com.mopub.mobileads;
 
 import android.app.Activity;
-import android.net.Uri;
 import android.view.Gravity;
 import android.widget.FrameLayout;
 
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.mobileads.test.support.TestHtmlBannerWebViewFactory;
-import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
 import com.mopub.mobileads.test.support.TestMoPubViewFactory;
+import com.mopub.network.AdResponse;
 
-import org.apache.http.HttpResponse;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -19,10 +17,10 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import static com.mopub.mobileads.AdFetcher.CLICKTHROUGH_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
-import static com.mopub.mobileads.AdFetcher.REDIRECT_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.SCROLLABLE_KEY;
+import static com.mopub.common.DataKeys.CLICKTHROUGH_URL_KEY;
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
+import static com.mopub.common.DataKeys.REDIRECT_URL_KEY;
+import static com.mopub.common.DataKeys.SCROLLABLE_KEY;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_INVALID_STATE;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.anyString;
@@ -52,7 +50,7 @@ public void setup() {
         localExtras = new HashMap<String, Object>();
         serverExtras = new HashMap<String, String>();
         responseBody = "expected response body";
-        serverExtras.put(HTML_RESPONSE_BODY_KEY, Uri.encode(responseBody));
+        serverExtras.put(HTML_RESPONSE_BODY_KEY, responseBody);
         serverExtras.put(SCROLLABLE_KEY, "false");
     }
 
@@ -109,10 +107,9 @@ public void loadBanner_shouldCauseServerDimensionsToBeHonoredWhenLayingOutView()
         stub(moPubView.getContext()).toReturn(context);
         AdViewController adViewController = new AdViewController(context, moPubView);
 
-        HttpResponse response = new TestHttpResponseWithHeaders(200, "I ain't got no-body");
-        response.addHeader("X-Width", "320");
-        response.addHeader("X-Height", "50");
-        adViewController.configureUsingHttpResponse(response);
+
+        AdResponse adResponse = new AdResponse.Builder().setDimensions(320, 50).build();
+        adViewController.onAdLoadSuccess(adResponse);
 
         adViewController.setAdContentView(htmlBannerWebView);
         ArgumentCaptor<FrameLayout.LayoutParams> layoutParamsCaptor = ArgumentCaptor.forClass(FrameLayout.LayoutParams.class);
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlBannerWebViewTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlBannerWebViewTest.java
index aaf8a188..aea2d409 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlBannerWebViewTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlBannerWebViewTest.java
@@ -3,11 +3,14 @@
 import android.app.Activity;
 import android.webkit.WebViewClient;
 
+import com.mopub.common.AdReport;
 import com.mopub.common.test.support.SdkTestRunner;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
 
 import static com.mopub.mobileads.CustomEventBanner.CustomEventBannerListener;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_INVALID_STATE;
@@ -19,17 +22,17 @@
 
 @RunWith(SdkTestRunner.class)
 public class HtmlBannerWebViewTest {
-
-    private AdConfiguration adConfiguration;
     private HtmlBannerWebView subject;
+    @Mock
+    private AdReport mockAdReport;
     private CustomEventBannerListener customEventBannerListener;
     private String clickthroughUrl;
     private String redirectUrl;
 
     @Before
     public void setup() throws Exception {
-        adConfiguration = mock(AdConfiguration.class);
-        subject = new HtmlBannerWebView(new Activity(), adConfiguration);
+        subject = new HtmlBannerWebView(Robolectric.buildActivity(Activity.class).create().get(),
+                mockAdReport);
         customEventBannerListener = mock(CustomEventBannerListener.class);
         clickthroughUrl = "clickthroughUrl";
         redirectUrl = "redirectUrl";
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlInterstitialTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlInterstitialTest.java
index 6d606330..19d7184e 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlInterstitialTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlInterstitialTest.java
@@ -2,12 +2,12 @@
 
 import android.app.Activity;
 import android.content.Intent;
-import android.net.Uri;
 
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.mobileads.test.support.TestHtmlInterstitialWebViewFactory;
 
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
@@ -16,23 +16,21 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
-import static com.mopub.mobileads.AdFetcher.CLICKTHROUGH_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
-import static com.mopub.mobileads.AdFetcher.REDIRECT_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.SCROLLABLE_KEY;
 import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiverTest.getIntentForActionAndIdentifier;
+import static com.mopub.common.DataKeys.CLICKTHROUGH_URL_KEY;
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
+import static com.mopub.common.DataKeys.REDIRECT_URL_KEY;
+import static com.mopub.common.DataKeys.SCROLLABLE_KEY;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_INVALID_STATE;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.anyString;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.stub;
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.withSettings;
 
 @RunWith(SdkTestRunner.class)
 public class HtmlInterstitialTest extends ResponseBodyInterstitialTest {
@@ -54,14 +52,13 @@ public void setUp() throws Exception {
         customEventInterstitialListener = mock(CustomEventInterstitialListener.class);
         localExtras = new HashMap<String, Object>();
         serverExtras = new HashMap<String, String>();
-        serverExtras.put(HTML_RESPONSE_BODY_KEY, Uri.encode(expectedResponse));
+        serverExtras.put(HTML_RESPONSE_BODY_KEY, expectedResponse);
 
         broadcastIdentifier = 2222;
-        final AdConfiguration adConfiguration = mock(AdConfiguration.class, withSettings().serializable());
-        stub(adConfiguration.getBroadcastIdentifier()).toReturn(broadcastIdentifier);
-        localExtras.put(AD_CONFIGURATION_KEY, adConfiguration);
+        localExtras.put(BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
     }
 
+    @Ignore("pending")
     @Test
     public void loadInterstitial_shouldNotifyCustomEventInterstitialListenerOnLoaded() throws Exception {
         subject.loadInterstitial(context, customEventInterstitialListener, localExtras, serverExtras);
@@ -119,12 +116,12 @@ public void showInterstitial_shouldStartMoPubActivityWithAllExtras() throws Exce
     public void loadInterstitial_shouldConnectListenerToBroadcastReceiver() throws Exception {
         subject.loadInterstitial(context, customEventInterstitialListener, localExtras, serverExtras);
 
-        Intent intent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_SHOW, subject.mAdConfiguration.getBroadcastIdentifier());
+        Intent intent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_SHOW, broadcastIdentifier);
         ShadowLocalBroadcastManager.getInstance(context).sendBroadcast(intent);
 
         verify(customEventInterstitialListener).onInterstitialShown();
 
-        intent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_DISMISS, subject.mAdConfiguration.getBroadcastIdentifier());
+        intent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_DISMISS, broadcastIdentifier);
         ShadowLocalBroadcastManager.getInstance(context).sendBroadcast(intent);
 
         verify(customEventInterstitialListener).onInterstitialDismissed();
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlInterstitialWebViewTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlInterstitialWebViewTest.java
index ebd3b8f8..4d1763d8 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlInterstitialWebViewTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlInterstitialWebViewTest.java
@@ -1,48 +1,40 @@
 package com.mopub.mobileads;
 
 import android.app.Activity;
-import android.os.Build;
-import android.os.Build.VERSION_CODES;
 import android.webkit.WebViewClient;
 
+import com.mopub.common.AdReport;
 import com.mopub.common.test.support.SdkTestRunner;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
 import org.robolectric.Robolectric;
-import org.robolectric.annotation.Config;
-
-import java.lang.reflect.Method;
 
 import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
 import static com.mopub.mobileads.HtmlInterstitialWebView.HtmlInterstitialWebViewListener;
-import static com.mopub.mobileads.HtmlInterstitialWebView.MOPUB_JS_INTERFACE_NAME;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_INVALID_STATE;
-import static com.mopub.common.util.VersionCode.GINGERBREAD_MR1;
-import static com.mopub.common.util.VersionCode.HONEYCOMB;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.verify;
 import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(SdkTestRunner.class)
 public class HtmlInterstitialWebViewTest {
 
+    @Mock AdReport mockAdReport;
     private HtmlInterstitialWebView subject;
     private CustomEventInterstitialListener customEventInterstitialListener;
     private String clickthroughUrl;
     private boolean isScrollable;
     private String redirectUrl;
-    private AdConfiguration adConfiguration;
 
     @Before
     public void setUp() throws Exception {
-        adConfiguration = mock(AdConfiguration.class);
-        subject = new HtmlInterstitialWebView(new Activity(), adConfiguration);
+        subject = new HtmlInterstitialWebView(Robolectric.buildActivity(Activity.class).create().get(),
+                mockAdReport);
         customEventInterstitialListener = mock(CustomEventInterstitialListener.class);
         isScrollable = false;
         clickthroughUrl = "clickthroughUrl";
@@ -69,56 +61,4 @@ public void htmlBannerWebViewListener_shouldForwardCalls() throws Exception {
         listenerSubject.onClicked();
         verify(customEventInterstitialListener).onInterstitialClicked();
     }
-
-    @Test
-    public void init_shouldAddJavascriptInterface() throws Exception {
-        subject.init(customEventInterstitialListener, isScrollable, clickthroughUrl, redirectUrl);
-
-        Object javascriptInterface = shadowOf(subject).getJavascriptInterface(MOPUB_JS_INTERFACE_NAME);
-        assertThat(javascriptInterface).isNotNull();
-
-        Method fireFinishLoad = javascriptInterface.getClass().getDeclaredMethod("fireFinishLoad");
-        Robolectric.pauseMainLooper();
-        boolean returnValue = (Boolean) fireFinishLoad.invoke(javascriptInterface);
-        assertThat(returnValue).isTrue();
-        verify(customEventInterstitialListener, never()).onInterstitialShown();
-
-        Robolectric.unPauseMainLooper();
-        verify(customEventInterstitialListener).onInterstitialLoaded();
-    }
-
-    @Config(reportSdk = VERSION_CODES.HONEYCOMB)
-    @Test
-    public void destroy_atLeastHoneycomb_shouldRemoveJavascriptInterface() {
-        HtmlInterstitialWebView spySubject = spy(subject);
-
-        spySubject.destroy();
-
-        verify(spySubject).removeJavascriptInterface(MOPUB_JS_INTERFACE_NAME);
-    }
-
-    @Config(reportSdk = VERSION_CODES.GINGERBREAD_MR1)
-    @Test
-    public void destroy_beforeHoneycomb_shouldNotRemoveJavascriptInterface() {
-        HtmlInterstitialWebView spySubject = spy(subject);
-
-        spySubject.destroy();
-
-        verify(spySubject, never()).removeJavascriptInterface(MOPUB_JS_INTERFACE_NAME);
-    }
-
-    @Test
-    public void destroy_shouldPreventJavascriptInterfaceFromNotifyingListener() throws Exception{
-        subject.init(customEventInterstitialListener, isScrollable, clickthroughUrl, redirectUrl);
-
-        Object javascriptInterface = shadowOf(subject).getJavascriptInterface(MOPUB_JS_INTERFACE_NAME);
-        assertThat(javascriptInterface).isNotNull();
-
-        subject.setIsDestroyed(true);
-
-        Method fireFinishLoad = javascriptInterface.getClass().getDeclaredMethod("fireFinishLoad");
-        fireFinishLoad.invoke(javascriptInterface);
-
-        verify(customEventInterstitialListener, never()).onInterstitialLoaded();
-    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlWebViewClientTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlWebViewClientTest.java
index 7f395a4c..e40ffee5 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlWebViewClientTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlWebViewClientTest.java
@@ -7,6 +7,7 @@
 import android.content.pm.ResolveInfo;
 import android.net.Uri;
 import android.webkit.WebView;
+
 import com.mopub.common.MoPubBrowser;
 import com.mopub.common.test.support.SdkTestRunner;
 
@@ -25,22 +26,26 @@
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.stub;
-import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
 public class HtmlWebViewClientTest {
 
+    private static final String CLICKTHROUGH_URL = "http://clickthrough";
+
     private HtmlWebViewClient subject;
     private HtmlWebViewListener htmlWebViewListener;
     private BaseHtmlWebView htmlWebView;
+    private Context context;
 
     @Before
     public void setUp() throws Exception {
         htmlWebViewListener = mock(HtmlWebViewListener.class);
         htmlWebView = mock(BaseHtmlWebView.class);
-        stub(htmlWebView.getContext()).toReturn(new Activity());
-        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, "clickthrough", "redirect");
+        context = Robolectric.buildActivity(Activity.class).create().get().getApplicationContext();
+        when(htmlWebView.getContext()).thenReturn(context);
+        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, CLICKTHROUGH_URL, "redirect");
     }
 
     @Test
@@ -142,7 +147,8 @@ public void shouldOverrideUrlLoading_withCustomApplicationIntent_withUserClick_a
 
         assertThat(didOverrideUrl).isTrue();
         verify(htmlWebViewListener).onClicked();
-        assertActivityStarted();
+        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(intent).isNotNull();
     }
 
     @Test
@@ -159,7 +165,7 @@ public void shouldOverrideUrlLoading_withCustomApplicationIntent_withoutUserClic
     }
 
     @Test
-    public void shouldOverrideUrlLoading_withCustomApplicationIntent_withUserClick_butCanNotHandleCustomIntent_shouldDefaultToMoPubBrowser() throws Exception {
+    public void shouldOverrideUrlLoading_withCustomApplicationIntent_withUserClick_butCanNotHandleCustomIntent_shouldFailSilently() throws Exception {
         String customUrl = "myintent://something";
         stub(htmlWebView.wasClicked()).toReturn(true);
         subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
@@ -167,10 +173,9 @@ public void shouldOverrideUrlLoading_withCustomApplicationIntent_withUserClick_b
         boolean didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, customUrl);
 
         assertThat(didOverrideUrl).isTrue();
-        verify(htmlWebViewListener).onClicked();
+        verify(htmlWebViewListener, never()).onClicked();
         Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedIntent).isNotNull();
-        assertThat(startedIntent.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
+        assertThat(startedIntent).isNull();
     }
 
     @Test
@@ -183,7 +188,7 @@ public void shouldOverrideUrlLoading_withHttpUrl_withUserClick_shouldOpenBrowser
         assertThat(didOverrideUrl).isTrue();
         verify(htmlWebViewListener).onClicked();
 
-        Intent startedActivity = assertActivityStarted();
+        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(startedActivity.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
         assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(validUrl);
         assertThat(startedActivity.getData()).isNull();
@@ -198,7 +203,6 @@ public void shouldOverrideUrlLoading_withHttpUrl_withoutUserClick_shouldNotOpenB
 
         assertThat(didOverrideUrl).isTrue();
         verify(htmlWebViewListener, never()).onClicked();
-
         assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
     }
 
@@ -209,7 +213,7 @@ public void shouldOverrideUrlLoading_withClickTrackingRedirect_withUserClick_sho
 
         subject.shouldOverrideUrlLoading(htmlWebView, validUrl);
 
-        Intent startedActivity = assertActivityStarted();
+        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(validUrl);
     }
 
@@ -224,16 +228,14 @@ public void shouldOverrideUrlLoading_withClickTrackingRedirect_withoutUserClick_
     }
 
     @Test
-    public void shouldOverrideUrlLoading_withEmptyUrl_withUserClick_shouldLoadAboutBlank() throws Exception {
+    public void shouldOverrideUrlLoading_withEmptyUrl_withUserClick_shouldFailSilently() throws Exception {
         stub(htmlWebView.wasClicked()).toReturn(true);
         subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
 
         subject.shouldOverrideUrlLoading(htmlWebView, "");
 
-        Intent startedActivity = assertActivityStarted();
-        assertThat(startedActivity.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
-        assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo("about:blank");
-        assertThat(startedActivity.getData()).isNull();
+        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(startedActivity).isNull();
     }
 
     @Test
@@ -251,12 +253,14 @@ public void shouldOverrideUrlLoading_withNativeBrowserScheme_withUserClick_shoul
         stub(htmlWebView.wasClicked()).toReturn(true);
         subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
 
-        subject.shouldOverrideUrlLoading(htmlWebView, "mopubnativebrowser://navigate?url=http://mopub.com");
+        boolean shouldOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView,
+                "mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.mopub.com");
 
-        Intent startedActivity = assertActivityStarted();
-        assertThat(isWebsiteUrl(startedActivity.getData().toString()));
-        assertThat(startedActivity.getAction()).isEqualTo("android.intent.action.VIEW");
+        assertThat(shouldOverrideUrl).isTrue();
         verify(htmlWebViewListener).onClicked();
+        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(startedActivity.getAction()).isEqualTo("android.intent.action.VIEW");
+        assertThat(startedActivity.getData().toString()).isEqualTo("http://www.mopub.com");
     }
 
     @Test
@@ -264,8 +268,10 @@ public void shouldOverrideUrlLoading_withNativeBrowserScheme_withoutUserClick_sh
         stub(htmlWebView.wasClicked()).toReturn(false);
         subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
 
-        subject.shouldOverrideUrlLoading(htmlWebView, "mopubnativebrowser://navigate?url=http://mopub.com");
+        boolean shouldOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView,
+                "mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.mopub.com");
 
+        assertThat(shouldOverrideUrl).isTrue();
         verify(htmlWebViewListener, never()).onClicked();
         assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
     }
@@ -273,39 +279,43 @@ public void shouldOverrideUrlLoading_withNativeBrowserScheme_withoutUserClick_sh
     @Test
     public void shouldOverrideUrlLoading_withNativeBrowserScheme_butOpaqueUri_withUserClick_shouldNotBeHandledByNativeBrowser() throws Exception {
         stub(htmlWebView.wasClicked()).toReturn(true);
-        String opaqueNativeBrowserUriString = "mopubnativebrowser:navigate?url=http://mopub.com";
+        String opaqueNativeBrowserUriString = "mopubnativebrowser:navigate?url=http%3A%2F%2Fwww.mopub.com";
         subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
 
-        subject.shouldOverrideUrlLoading(htmlWebView, opaqueNativeBrowserUriString);
+        boolean shouldOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, opaqueNativeBrowserUriString);
 
-        Intent startedActivity = assertActivityStarted();
-        assertThat(startedActivity.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
-        assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(opaqueNativeBrowserUriString);
-        assertThat(startedActivity.getData()).isNull();
-        verify(htmlWebViewListener).onClicked();
+        assertThat(shouldOverrideUrl).isTrue();
+        verify(htmlWebViewListener, never()).onClicked();
+        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(startedActivity).isNull();
     }
 
     @Test
     public void shouldOverrideUrlLoading_withNativeBrowserScheme_butOpaqueUri_withoutUserClick_shouldNotLoad() throws Exception {
         stub(htmlWebView.wasClicked()).toReturn(false);
-        String opaqueNativeBrowserUriString = "mopubnativebrowser:navigate?url=http://mopub.com";
+        String opaqueNativeBrowserUriString = "mopubnativebrowser:navigate?url=http%3A%2F%2Fwww.mopub.com";
         subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
 
-        subject.shouldOverrideUrlLoading(htmlWebView, opaqueNativeBrowserUriString);
+        boolean shouldOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, opaqueNativeBrowserUriString);
+
+        assertThat(shouldOverrideUrl).isTrue();
+        verify(htmlWebViewListener, never()).onClicked();
 
         assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
     }
 
     @Test
-    public void shouldOverrideUrlLoading_withNativeBrowserScheme_withInvalidHostSchemeUrl_withUserClick_shouldNotInvokeNativeBrowser() throws Exception {
+    public void shouldOverrideUrlLoading_withNativeBrowserScheme_withInvalidHostSchemeUrl_withUserClick_shouldFailSilently() throws Exception {
         stub(htmlWebView.wasClicked()).toReturn(true);
         subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
 
-        subject.shouldOverrideUrlLoading(htmlWebView, "something://blah?url=invalid");
+        boolean shouldOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, "something://blah?url=invalid");
 
-        Intent startedActivity = assertActivityStarted();
-        assertThat(startedActivity.getAction()).isNotEqualTo("android.intent.action.VIEW");
-        verify(htmlWebViewListener).onClicked();
+        assertThat(shouldOverrideUrl).isTrue();
+        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(startedActivity).isNull();
+
+        verify(htmlWebViewListener, never()).onClicked();
     }
 
     @Test
@@ -313,13 +323,21 @@ public void shouldOverrideUrlLoading_withNativeBrowserScheme_withInvalidHostSche
         stub(htmlWebView.wasClicked()).toReturn(false);
         subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
 
-        subject.shouldOverrideUrlLoading(htmlWebView, "something://blah?url=invalid");
+        boolean shouldOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, "something://blah?url=invalid");
 
+        assertThat(shouldOverrideUrl).isTrue();
+        verify(htmlWebViewListener, never()).onClicked();
         assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
     }
 
-    private boolean isWebsiteUrl(String url){
-        return url.startsWith("http://") || url.startsWith("https://");
+    @Test
+    public void shouldOverrideUrlLoading_withAboutBlankUrl_shouldFailSilently() {
+        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
+
+        subject.shouldOverrideUrlLoading(htmlWebView, "about:blank");
+
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+        verify(htmlWebViewListener, never()).onClicked();
     }
 
     @Test
@@ -379,7 +397,7 @@ public void onPageStarted_whenLoadedUrlStartsWithRedirectAndHasClickthrough_with
     }
 
     @Test
-    public void onPageStarted_whenLoadedUrlStartsWithRedirectAndHasClickthrough_withUserClick_whenMoPubBrowserCannotHandleIntent_shouldOpenInNativeBrowser() throws Exception {
+    public void onPageStarted_whenLoadedUrlStartsWithRedirectAndHasClickthrough_withUserClick_whenMoPubBrowserCannotHandleIntent_shouldFailSilently() throws Exception {
         Context mockContext = mock(Context.class);
         stub(htmlWebView.wasClicked()).toReturn(true);
         stub(htmlWebView.getContext()).toReturn(mockContext);
@@ -390,17 +408,15 @@ public void onPageStarted_whenLoadedUrlStartsWithRedirectAndHasClickthrough_with
                 .doNothing()
                 .when(mockContext).startActivity(any(Intent.class));
 
-        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, "clickthrough", "redirect");
+        subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, CLICKTHROUGH_URL, "redirect");
         subject.onPageStarted(htmlWebView, url, null);
 
         ArgumentCaptor<Intent> intentArgumentCaptor = ArgumentCaptor.forClass(Intent.class);
-        verify(mockContext, times(2)).startActivity(intentArgumentCaptor.capture());
+        verify(mockContext).startActivity(intentArgumentCaptor.capture());
 
-        Intent intent = intentArgumentCaptor.getAllValues().get(1);
-        assertThat(intent.getAction()).isEqualTo("android.intent.action.VIEW");
-        assertThat(intent.getData().toString()).isEqualTo("about:blank");
-        assertThat(intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
-        verify(htmlWebViewListener, times(1)).onClicked();
+        Intent intent = intentArgumentCaptor.getValue();
+        assertThat(intent.getData()).isNull();
+        verify(htmlWebViewListener, never()).onClicked();
     }
 
     @Test
@@ -451,6 +467,8 @@ public void launchIntentForUserClick_whenNoMatchingActivity_shouldNotStartActivi
 
         verify(htmlWebView, never()).onResetUserClick();
         assertThat(result).isFalse();
+
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
     }
 
     @Test
@@ -470,7 +488,7 @@ private void assertPhoneUrlStartedCorrectIntent(String url) {
 
         stub(htmlWebView.wasClicked()).toReturn(true);
         didOverrideUrl = subject.shouldOverrideUrlLoading(htmlWebView, url);
-        Intent startedActivity = assertActivityStarted();
+        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(startedActivity.getAction()).isEqualTo(Intent.ACTION_VIEW);
         assertThat(startedActivity.getData().toString()).isEqualTo(url);
         assertThat(didOverrideUrl).isTrue();
@@ -484,11 +502,4 @@ private void assertPhoneUrlStartedCorrectIntent(String url) {
         verify(htmlWebViewListener, never()).onClicked();
         reset(htmlWebViewListener);
     }
-
-    private Intent assertActivityStarted() {
-        Intent startedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedActivity).isNotNull();
-        assertThat(startedActivity.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
-        return startedActivity;
-    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubActivityTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubActivityTest.java
index 0903b56d..86621686 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubActivityTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubActivityTest.java
@@ -4,28 +4,37 @@
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
+import android.content.pm.ActivityInfo;
 import android.view.View;
+import android.view.ViewGroup;
 import android.webkit.WebViewClient;
-import android.widget.RelativeLayout;
+import android.widget.FrameLayout;
+
+import com.mopub.common.AdReport;
+import com.mopub.common.CreativeOrientation;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.mobileads.test.support.TestHtmlInterstitialWebViewFactory;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
 import org.robolectric.Robolectric;
 import org.robolectric.shadows.ShadowLocalBroadcastManager;
 
-import static com.mopub.mobileads.AdFetcher.CLICKTHROUGH_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
-import static com.mopub.mobileads.AdFetcher.REDIRECT_URL_KEY;
-import static com.mopub.mobileads.AdFetcher.SCROLLABLE_KEY;
+import static com.mopub.common.DataKeys.CLICKTHROUGH_URL_KEY;
+import static com.mopub.common.DataKeys.CREATIVE_ORIENTATION_KEY;
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
+import static com.mopub.common.DataKeys.REDIRECT_URL_KEY;
+import static com.mopub.common.DataKeys.SCROLLABLE_KEY;
 import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_CLICK;
+import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_FAIL;
+import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.getHtmlInterstitialIntentFilter;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiverTest.getIntentForActionAndIdentifier;
-import static com.mopub.mobileads.HtmlInterstitialWebView.MoPubUriJavascriptFireFinishLoadListener;
 import static com.mopub.mobileads.MoPubErrorCode.UNSPECIFIED;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
@@ -33,54 +42,63 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.stub;
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.withSettings;
+import static org.mockito.Mockito.when;
 import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(SdkTestRunner.class)
-public class MoPubActivityTest extends BaseInterstitialActivityTest {
-    public static final String EXPECTED_HTML_DATA = "htmlData";
-    public static final boolean EXPECTED_IS_SCROLLABLE = true;
-    public static final String EXPECTED_REDIRECT_URL = "redirectUrl";
-    public static final String EXPECTED_CLICKTHROUGH_URL = "http://expected_url";
+public class MoPubActivityTest {
+    private static final String EXPECTED_HTML_DATA = "htmlData";
+    private static final boolean EXPECTED_IS_SCROLLABLE = true;
+    @Mock private AdReport mockAdReport;
+    private static final String EXPECTED_REDIRECT_URL = "redirectUrl";
+    private static final String EXPECTED_CLICKTHROUGH_URL = "http://expected_url";
+    private static final CreativeOrientation EXPECTED_ORIENTATION = CreativeOrientation.PORTRAIT;
+
+    @Mock private BroadcastReceiver broadcastReceiver;
+    private long testBroadcastIdentifier = 2222;
 
     private HtmlInterstitialWebView htmlInterstitialWebView;
-    private Activity context;
     private CustomEventInterstitialListener customEventInterstitialListener;
 
+    private MoPubActivity subject;
+
     @Before
     public void setUp() throws Exception {
-        super.setup();
-
-        adConfiguration = mock(AdConfiguration.class, withSettings().serializable());
-        stub(adConfiguration.getBroadcastIdentifier()).toReturn(testBroadcastIdentifier);
-
-        Intent moPubActivityIntent = createMoPubActivityIntent(EXPECTED_HTML_DATA, EXPECTED_IS_SCROLLABLE, EXPECTED_REDIRECT_URL, EXPECTED_CLICKTHROUGH_URL, adConfiguration);
         htmlInterstitialWebView = TestHtmlInterstitialWebViewFactory.getSingletonMock();
         resetMockedView(htmlInterstitialWebView);
-        subject = Robolectric.buildActivity(MoPubActivity.class).withIntent(moPubActivityIntent).create().get();
 
-        context = new Activity();
+        Context context = Robolectric.buildActivity(Activity.class).create().get();
+        Intent moPubActivityIntent = MoPubActivity.createIntent(context,
+                EXPECTED_HTML_DATA, mockAdReport, EXPECTED_IS_SCROLLABLE,
+                EXPECTED_REDIRECT_URL,
+                EXPECTED_CLICKTHROUGH_URL, EXPECTED_ORIENTATION, testBroadcastIdentifier);
+
+        subject = Robolectric.buildActivity(MoPubActivity.class).withIntent(moPubActivityIntent).create().get();
         customEventInterstitialListener = mock(CustomEventInterstitialListener.class);
 
-        reset(htmlInterstitialWebView);
         resetMockedView(htmlInterstitialWebView);
     }
 
+    @Test
+    public void onCreate_shouldHaveLockedOrientation() {
+        // Since robolectric doesn't set a requested orientation, verifying that we have a value tells us that one was set.
+        assertThat(subject.getRequestedOrientation()).isIn(ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT,
+                ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+    }
+
     @Test
     public void preRenderHtml_shouldPreloadTheHtml() throws Exception {
         String htmlData = "this is nonsense";
-        MoPubActivity.preRenderHtml(context, customEventInterstitialListener, htmlData);
+        MoPubActivity.preRenderHtml(subject, mockAdReport, customEventInterstitialListener, htmlData);
 
         verify(htmlInterstitialWebView).enablePlugins(eq(false));
-        verify(htmlInterstitialWebView).addMoPubUriJavascriptInterface(any(MoPubUriJavascriptFireFinishLoadListener.class));
         verify(htmlInterstitialWebView).loadHtmlResponse(htmlData);
     }
 
     @Test
     public void preRenderHtml_shouldHaveAWebViewClientThatForwardsFinishLoad() throws Exception {
-        MoPubActivity.preRenderHtml(context, customEventInterstitialListener, null);
+        MoPubActivity.preRenderHtml(subject, mockAdReport, customEventInterstitialListener, null);
 
         ArgumentCaptor<WebViewClient> webViewClientCaptor = ArgumentCaptor.forClass(WebViewClient.class);
         verify(htmlInterstitialWebView).setWebViewClient(webViewClientCaptor.capture());
@@ -94,7 +112,7 @@ public void preRenderHtml_shouldHaveAWebViewClientThatForwardsFinishLoad() throw
 
     @Test
     public void preRenderHtml_shouldHaveAWebViewClientThatForwardsFailLoad() throws Exception {
-        MoPubActivity.preRenderHtml(context, customEventInterstitialListener, null);
+        MoPubActivity.preRenderHtml(subject, mockAdReport, customEventInterstitialListener, null);
 
         ArgumentCaptor<WebViewClient> webViewClientCaptor = ArgumentCaptor.forClass(WebViewClient.class);
         verify(htmlInterstitialWebView).setWebViewClient(webViewClientCaptor.capture());
@@ -106,36 +124,23 @@ public void preRenderHtml_shouldHaveAWebViewClientThatForwardsFailLoad() throws
         verify(customEventInterstitialListener).onInterstitialFailed(any(MoPubErrorCode.class));
     }
 
-    @Test
-    public void preRenderHtml_shouldHaveAMoPubUriInterfaceThatForwardsOnInterstitialLoaded() throws Exception {
-        MoPubActivity.preRenderHtml(context, customEventInterstitialListener, null);
-
-        ArgumentCaptor<MoPubUriJavascriptFireFinishLoadListener> moPubUriJavascriptFireFinishLoadListenerCaptor = ArgumentCaptor.forClass(MoPubUriJavascriptFireFinishLoadListener.class);
-        verify(htmlInterstitialWebView).addMoPubUriJavascriptInterface(moPubUriJavascriptFireFinishLoadListenerCaptor.capture());
-        MoPubUriJavascriptFireFinishLoadListener moPubUriJavascriptFireFinishLoadListener = moPubUriJavascriptFireFinishLoadListenerCaptor.getValue();
-
-        moPubUriJavascriptFireFinishLoadListener.onInterstitialLoaded();
-
-        verify(customEventInterstitialListener).onInterstitialLoaded();
-    }
-
     @Test
     public void onCreate_shouldSetContentView() throws Exception {
         subject.onCreate(null);
 
-        assertThat(getContentView(subject).getChildCount()).isEqualTo(2);
+        assertThat(getContentView().getChildCount()).isEqualTo(1);
     }
 
     @Test
     public void onCreate_shouldLayoutWebView() throws Exception {
         subject.onCreate(null);
 
-        ArgumentCaptor<RelativeLayout.LayoutParams> captor = ArgumentCaptor.forClass(RelativeLayout.LayoutParams.class);
+        ArgumentCaptor<FrameLayout.LayoutParams> captor = ArgumentCaptor.forClass(FrameLayout.LayoutParams.class);
         verify(htmlInterstitialWebView).setLayoutParams(captor.capture());
-        RelativeLayout.LayoutParams actualLayoutParams = captor.getValue();
+        FrameLayout.LayoutParams actualLayoutParams = captor.getValue();
 
-        assertThat(actualLayoutParams.width).isEqualTo(RelativeLayout.LayoutParams.MATCH_PARENT);
-        assertThat(actualLayoutParams.height).isEqualTo(RelativeLayout.LayoutParams.MATCH_PARENT);
+        assertThat(actualLayoutParams.width).isEqualTo(FrameLayout.LayoutParams.MATCH_PARENT);
+        assertThat(actualLayoutParams.height).isEqualTo(FrameLayout.LayoutParams.MATCH_PARENT);
     }
 
     @Test
@@ -156,7 +161,7 @@ public void onDestroy_shouldDestroyMoPubView() throws Exception {
         subject.onDestroy();
 
         verify(htmlInterstitialWebView).destroy();
-        assertThat(getContentView(subject).getChildCount()).isEqualTo(0);
+        assertThat(getContentView().getChildCount()).isEqualTo(0);
     }
 
     @Test
@@ -169,13 +174,14 @@ public void onDestroy_shouldFireJavascriptWebviewDidClose() throws Exception {
 
     @Test
     public void start_shouldStartMoPubActivityWithCorrectParameters() throws Exception {
-        MoPubActivity.start(subject, "expectedResponse", true, "redirectUrl", "clickthroughUrl", adConfiguration);
+        MoPubActivity.start(subject, "expectedResponse", mockAdReport, true, "redirectUrl", "clickthroughUrl", CreativeOrientation.PORTRAIT, testBroadcastIdentifier);
 
         Intent nextStartedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(nextStartedActivity.getStringExtra(HTML_RESPONSE_BODY_KEY)).isEqualTo("expectedResponse");
         assertThat(nextStartedActivity.getBooleanExtra(SCROLLABLE_KEY, false)).isTrue();
         assertThat(nextStartedActivity.getStringExtra(REDIRECT_URL_KEY)).isEqualTo("redirectUrl");
         assertThat(nextStartedActivity.getStringExtra(CLICKTHROUGH_URL_KEY)).isEqualTo("clickthroughUrl");
+        assertThat(nextStartedActivity.getSerializableExtra(CREATIVE_ORIENTATION_KEY)).isEqualTo(CreativeOrientation.PORTRAIT);
         assertThat(nextStartedActivity.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
         assertThat(nextStartedActivity.getComponent().getClassName()).isEqualTo("com.mopub.mobileads.MoPubActivity");
     }
@@ -253,8 +259,36 @@ public void broadcastingInterstitialListener_onInterstitialClicked_shouldBroadca
         verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
     }
 
-    private Intent createMoPubActivityIntent(String htmlData, boolean isScrollable, String redirectUrl, String clickthroughUrl, AdConfiguration adConfiguration) {
-        return MoPubActivity.createIntent(new Activity(), htmlData, isScrollable, redirectUrl, clickthroughUrl, adConfiguration);
+    @Test
+    public void onCreate_shouldBroadcastInterstitialShow() throws Exception {
+        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_SHOW, testBroadcastIdentifier);
+        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
+
+        subject.onCreate(null);
+
+        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
+    }
+
+    @Test
+    public void onDestroy_shouldBroadcastInterstitialDismiss() throws Exception {
+        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_DISMISS, testBroadcastIdentifier);
+        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
+
+        subject.onCreate(null);
+        subject.onDestroy();
+
+        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
+    }
+
+    private FrameLayout getContentView() {
+        return (FrameLayout) ((ViewGroup) subject.findViewById(android.R.id.content)).getChildAt(0);
+    }
+
+    protected void resetMockedView(View view) {
+        reset(view);
+        when(view.getLayoutParams()).thenReturn(
+                new FrameLayout.LayoutParams(FrameLayout.LayoutParams.WRAP_CONTENT,
+                        FrameLayout.LayoutParams.WRAP_CONTENT));
     }
 }
 
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubBrowserControllerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubBrowserControllerTest.java
deleted file mode 100644
index 4f685a00..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubBrowserControllerTest.java
+++ /dev/null
@@ -1,95 +0,0 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.ResolveInfo;
-import android.net.Uri;
-
-import com.mopub.common.MoPubBrowser;
-import com.mopub.common.test.support.SdkTestRunner;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
-@RunWith(SdkTestRunner.class)
-public class MoPubBrowserControllerTest {
-    private MoPubBrowserController subject;
-    private MraidView mraidView;
-    private Context context;
-    private MraidView.MraidListener mraidListener;
-
-    @Before
-    public void setUp() throws Exception {
-        context = new Activity();
-        mraidView = new MraidView(context, null);
-        mraidListener = mock(MraidView.MraidListener.class);
-        mraidView.setMraidListener(mraidListener);
-
-        subject = new MoPubBrowserController(mraidView);
-    }
-
-    @Test
-    public void open_withApplicationUrl_shouldStartNewIntent() throws Exception {
-        String applicationUrl = "amzn://blah";
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(Intent.ACTION_VIEW, Uri.parse(applicationUrl)), new ResolveInfo());
-
-        subject.open(applicationUrl);
-
-        Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedIntent).isNotNull();
-        assertThat(startedIntent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
-        assertThat(startedIntent.getComponent()).isNull();
-    }
-
-    @Test
-    public void open_withHttpApplicationUrl_shouldStartMoPubBrowser() throws Exception {
-        String applicationUrl = "http://blah";
-
-        subject.open(applicationUrl);
-
-        Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedIntent).isNotNull();
-        assertThat(startedIntent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
-        assertThat(startedIntent.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
-    }
-
-    @Test
-    public void open_withApplicationUrlThatCantBeHandled_shouldDefaultToMoPubBrowser() throws Exception {
-        String applicationUrl = "canthandleme://blah";
-
-        subject.open(applicationUrl);
-
-        Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedIntent).isNotNull();
-        assertThat(startedIntent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
-        assertThat(startedIntent.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
-        assertThat(startedIntent.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(applicationUrl);
-    }
-
-    @Test
-    public void open_withHttpApplicationUrl_shouldCallMraidListenerOnOpenCallback() throws Exception {
-        String applicationUrl = "http://blah";
-        Robolectric.packageManager.addResolveInfoForIntent(new Intent(Intent.ACTION_VIEW, Uri.parse(applicationUrl)), new ResolveInfo());
-
-        subject.open(applicationUrl);
-
-        verify(mraidListener).onOpen(eq(mraidView));
-    }
-
-    @Test
-    public void open_withApplicationUrl_shouldCallMraidListenerOnOpenCallback() throws Exception {
-        String applicationUrl = "app://blah";
-
-        subject.open(applicationUrl);
-
-        verify(mraidListener).onOpen(eq(mraidView));
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubConversionTrackerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubConversionTrackerTest.java
index 3ca84fce..6052109a 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubConversionTrackerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubConversionTrackerTest.java
@@ -1,37 +1,35 @@
 package com.mopub.mobileads;
 
 import android.app.Activity;
-import android.provider.Settings;
 
-import com.mopub.common.GpsHelper;
-import com.mopub.common.GpsHelperTest;
 import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.Reflection.MethodBuilder;
-import com.mopub.common.util.Utils;
-import com.mopub.common.util.test.support.TestMethodBuilderFactory;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.network.TrackingRequest;
+import com.mopub.volley.RequestQueue;
+import com.mopub.volley.VolleyError;
 
-import org.apache.http.HttpRequest;
-import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.tester.org.apache.http.FakeHttpLayer;
-import org.robolectric.tester.org.apache.http.HttpRequestInfo;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Captor;
+import org.mockito.Mock;
 
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.fest.assertions.api.Assertions.fail;
 import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.when;
-import static org.robolectric.Robolectric.application;
+import static org.mockito.Mockito.verify;
 
 @RunWith(SdkTestRunner.class)
 public class MoPubConversionTrackerTest {
     private MoPubConversionTracker subject;
     private Activity context;
-    private FakeHttpLayer fakeHttpLayer;
-    private MethodBuilder methodBuilder;
+    @Mock
+    MoPubRequestQueue mockRequestQueue;
+    @Captor
+    ArgumentCaptor<TrackingRequest> requestCaptor;
+
     private String expectedUdid;
     private boolean dnt = false;
     private static final String TEST_UDID = "20b013c721c";
@@ -40,101 +38,31 @@
     public void setUp() throws Exception {
         subject = new MoPubConversionTracker();
         context = new Activity();
-        fakeHttpLayer = Robolectric.getFakeHttpLayer();
-        methodBuilder = TestMethodBuilderFactory.getSingletonMock();
-        Settings.Secure.putString(application.getContentResolver(), Settings.Secure.ANDROID_ID, TEST_UDID);
-        expectedUdid = "sha%3A" + Utils.sha1(TEST_UDID);
-    }
-
-    @After
-    public void tearDown() throws Exception {
-        reset(methodBuilder);
+        Networking.setRequestQueueForTesting(mockRequestQueue);
     }
 
     @Test
-    public void reportAppOpen_onValidHttpResponse_isIdempotent() throws Exception {
-        fakeHttpLayer.addPendingHttpResponse(200, "doesn't matter what this is as long as it's not nothing");
-        subject.reportAppOpen(context);
-        assertRequestMade(true);
-
-        fakeHttpLayer.addPendingHttpResponse(200, "doesn't matter what this is as long as it's not nothing");
+    public void reportAppOpen_Twice_shouldCallOnlyOnce() {
         subject.reportAppOpen(context);
-        assertRequestMade(false);
-    }
+        verify(mockRequestQueue).add(requestCaptor.capture());
 
-    @Test
-    public void reportAppOpen_onInvalidStatusCode_shouldMakeSecondRequest() throws Exception {
-        fakeHttpLayer.addPendingHttpResponse(404, "doesn't matter what this is as long as it's not nothing");
-        subject.reportAppOpen(context);
-        assertRequestMade(true);
+        reset(mockRequestQueue);
+        requestCaptor.getValue().deliverResponse(null);
 
-        fakeHttpLayer.addPendingHttpResponse(404, "doesn't matter what this is as long as it's not nothing");
         subject.reportAppOpen(context);
-        assertRequestMade(true);
+        verify(mockRequestQueue, never()).add(any(TrackingRequest.class));
     }
 
     @Test
-    public void reportAppOpen_onEmptyResponse_shouldMakeSecondRequest() throws Exception {
-        fakeHttpLayer.addPendingHttpResponse(200, "");
+    public void reportAppOpen_fails_shouldCallAgain() {
         subject.reportAppOpen(context);
-        assertRequestMade(true);
+        verify(mockRequestQueue).add(requestCaptor.capture());
 
-        fakeHttpLayer.addPendingHttpResponse(200, "");
-        subject.reportAppOpen(context);
-        assertRequestMade(true);
-    }
+        reset(mockRequestQueue);
+        requestCaptor.getValue().deliverError(new VolleyError());
 
-    @Test
-    public void reportAppOpen_whenGooglePlayServicesIsLinkedAndAdInfoIsNotCached_shouldUseAdInfoParams() throws Exception {
-        GpsHelper.setClassNamesForTesting();
-        GpsHelperTest.verifyCleanClientMetadata(context);
-        GpsHelperTest.TestAdInfo adInfo = new GpsHelperTest.TestAdInfo();
-
-        when(methodBuilder.setStatic(any(Class.class))).thenReturn(methodBuilder);
-        when(methodBuilder.addParam(any(Class.class), any())).thenReturn(methodBuilder);
-        when(methodBuilder.execute()).thenReturn(
-                GpsHelper.GOOGLE_PLAY_SUCCESS_CODE,
-                adInfo,
-                adInfo.mAdId,
-                adInfo.mLimitAdTrackingEnabled,
-                GpsHelper.GOOGLE_PLAY_SUCCESS_CODE
-        );
-
-        expectedUdid = "ifa%3A" + adInfo.mAdId;
-        dnt = true;
-
-        fakeHttpLayer.addPendingHttpResponse(200, "doesn't matter what this is as long as it's not nothing");
         subject.reportAppOpen(context);
-        Thread.sleep(500); // extra sleep since there are 2 async tasks
-        assertRequestMade(true);
-    }
-
-    private void assertRequestMade(boolean shouldRequestBeMade) throws Exception {
-        StringBuilder stringBuilder = new StringBuilder("http://ads.mopub.com/m/open")
-                .append("?v=6")
-                .append("&id=").append("com.mopub.mobileads")
-                .append("&udid=").append(expectedUdid);
-
-        if (dnt) {
-            stringBuilder.append("&dnt=1");
-        }
-
-        String expectedUrl = stringBuilder.append("&av=")
-                .append("1.0")
-                .toString();
-
-        Thread.sleep(500);
-        HttpRequestInfo lastSentHttpRequestInfo = fakeHttpLayer.getLastSentHttpRequestInfo();
-        if (lastSentHttpRequestInfo == null) {
-            if (shouldRequestBeMade) {
-                fail("No request info in the http layer");
-            }
-            return;
-        }
-        HttpRequest request = lastSentHttpRequestInfo.getHttpRequest();
-        fakeHttpLayer.clearRequestInfos();
-        String actualUrl = request.getRequestLine().getUri();
-        assertThat(actualUrl).isEqualTo(expectedUrl);
+        verify(mockRequestQueue).add(any(TrackingRequest.class));
     }
 }
 
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubInterstitialTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubInterstitialTest.java
index 9bc34a61..f1ae01ae 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubInterstitialTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubInterstitialTest.java
@@ -7,16 +7,17 @@
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.mobileads.test.support.TestAdViewControllerFactory;
 import com.mopub.mobileads.test.support.TestCustomEventInterstitialAdapterFactory;
+
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
 import java.math.BigDecimal;
-import java.util.*;
+import java.util.HashMap;
+import java.util.Map;
 
 import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_DATA;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_HTML_DATA;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_NAME;
 import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
 import static com.mopub.mobileads.MoPubErrorCode.CANCELLED;
 import static com.mopub.mobileads.MoPubErrorCode.INTERNAL_ERROR;
@@ -37,11 +38,12 @@
     private static final String CLICKTHROUGH_URL_VALUE = "expected_clickthrough_url";
     private Activity activity;
     private MoPubInterstitial subject;
-    private Map<String, String> paramsMap;
+    private Map<String, String> serverExtras;
     private CustomEventInterstitialAdapter customEventInterstitialAdapter;
     private MoPubInterstitial.InterstitialAdListener interstitialAdListener;
     private MoPubInterstitial.MoPubInterstitialView interstitialView;
     private AdViewController adViewController;
+    private String customEventClassName;
 
     @Before
     public void setUp() throws Exception {
@@ -52,9 +54,9 @@ public void setUp() throws Exception {
 
         interstitialView = mock(MoPubInterstitial.MoPubInterstitialView.class);
 
-        paramsMap = new HashMap<String, String>();
-        paramsMap.put(CUSTOM_EVENT_NAME.getKey(), "class name");
-        paramsMap.put(CUSTOM_EVENT_DATA.getKey(), "class data");
+        customEventClassName = "class name";
+        serverExtras = new HashMap<String, String>();
+        serverExtras.put("testExtra", "class data");
 
         customEventInterstitialAdapter = TestCustomEventInterstitialAdapterFactory.getSingletonMock();
         reset(customEventInterstitialAdapter);
@@ -131,11 +133,11 @@ public void setLocalExtrasTest() throws Exception {
     @Test
     public void loadCustomEvent_shouldCreateAndLoadCustomEventInterstitialAdapter() throws Exception {
         MoPubInterstitial.MoPubInterstitialView moPubInterstitialView = subject.new MoPubInterstitialView(activity);
-        moPubInterstitialView.loadCustomEvent(paramsMap);
+        moPubInterstitialView.loadCustomEvent(customEventClassName, serverExtras);
 
         assertThat(TestCustomEventInterstitialAdapterFactory.getLatestMoPubInterstitial()).isSameAs(subject);
         assertThat(TestCustomEventInterstitialAdapterFactory.getLatestClassName()).isEqualTo("class name");
-        assertThat(TestCustomEventInterstitialAdapterFactory.getLatestClassData()).isEqualTo("class data");
+        assertThat(TestCustomEventInterstitialAdapterFactory.getLatestServerExtras().get("testExtra")).isEqualTo("class data");
     }
 
     @Test
@@ -276,6 +278,7 @@ public void loadingCustomEventInterstitial_shouldBecomeReadyToShowCustomEventAd(
         assertShowsCustomEventInterstitial(true);
     }
 
+    @Ignore("pending")
     @Test
     public void dismissingHtmlInterstitial_shouldNotBecomeReadyToShowHtmlAd() throws Exception {
 //        EventForwardingBroadcastReceiver broadcastReceiver = new EventForwardingBroadcastReceiver(subject.mInterstitialAdListener);
@@ -303,17 +306,15 @@ public void dismissingCustomEventInterstitial_shouldNotBecomeReadyToShowCustomEv
     }
 
     @Test
-    public void loadCustomEvent_shouldInitializeCustomEventBannerAdapter() throws Exception {
+    public void loadCustomEvent_shouldInitializeCustomEventInterstitialAdapter() throws Exception {
         MoPubInterstitial.MoPubInterstitialView moPubInterstitialView = subject.new MoPubInterstitialView(activity);
 
-        paramsMap.put(CUSTOM_EVENT_NAME.getKey(), "name");
-        paramsMap.put(CUSTOM_EVENT_DATA.getKey(), "data");
-        paramsMap.put(CUSTOM_EVENT_HTML_DATA.getKey(), "html");
-        moPubInterstitialView.loadCustomEvent(paramsMap);
+        serverExtras.put("testExtra", "data");
+        moPubInterstitialView.loadCustomEvent("name", serverExtras);
 
         assertThat(TestCustomEventInterstitialAdapterFactory.getLatestMoPubInterstitial()).isEqualTo(subject);
         assertThat(TestCustomEventInterstitialAdapterFactory.getLatestClassName()).isEqualTo("name");
-        assertThat(TestCustomEventInterstitialAdapterFactory.getLatestClassData()).isEqualTo("data");
+        assertThat(TestCustomEventInterstitialAdapterFactory.getLatestServerExtras().get("testExtra")).isEqualTo("data");
 
         verify(customEventInterstitialAdapter).setAdapterListener(eq(subject));
         verify(customEventInterstitialAdapter).loadInterstitial();
@@ -323,7 +324,7 @@ public void loadCustomEvent_shouldInitializeCustomEventBannerAdapter() throws Ex
     public void loadCustomEvent_whenParamsMapIsNull_shouldCallLoadFailUrl() throws Exception {
         MoPubInterstitial.MoPubInterstitialView moPubInterstitialView = subject.new MoPubInterstitialView(activity);
 
-        moPubInterstitialView.loadCustomEvent(null);
+        moPubInterstitialView.loadCustomEvent(null, null);
 
         verify(adViewController).loadFailUrl(eq(ADAPTER_NOT_FOUND));
         verify(customEventInterstitialAdapter, never()).invalidate();
@@ -341,15 +342,13 @@ public void adFailed_shouldNotifyInterstitialAdListener() throws Exception {
     private void loadCustomEvent() {
         MoPubInterstitial.MoPubInterstitialView moPubInterstitialView = subject.new MoPubInterstitialView(activity);
 
-        paramsMap.put(CUSTOM_EVENT_NAME.getKey(), "name");
-        paramsMap.put(CUSTOM_EVENT_DATA.getKey(), "data");
-        paramsMap.put(CUSTOM_EVENT_HTML_DATA.getKey(), "html");
-        moPubInterstitialView.loadCustomEvent(paramsMap);
+        serverExtras.put(CUSTOM_EVENT_DATA.getKey(), "data");
+        moPubInterstitialView.loadCustomEvent("name", serverExtras);
     }
 
     private void assertShowsCustomEventInterstitial(boolean shouldBeReady) {
         MoPubInterstitial.MoPubInterstitialView moPubInterstitialView = subject.new MoPubInterstitialView(activity);
-        moPubInterstitialView.loadCustomEvent(paramsMap);
+        moPubInterstitialView.loadCustomEvent(customEventClassName, serverExtras);
 
         assertThat(subject.isReady()).isEqualTo(shouldBeReady);
         assertThat(subject.show()).isEqualTo(shouldBeReady);
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubRewardedVideoManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubRewardedVideoManagerTest.java
new file mode 100644
index 00000000..5df6312a
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubRewardedVideoManagerTest.java
@@ -0,0 +1,272 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.AdType;
+import com.mopub.common.LifecycleListener;
+import com.mopub.common.MoPubReward;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.network.AdRequest;
+import com.mopub.network.AdResponse;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.volley.VolleyError;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
+
+import java.util.Map;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class MoPubRewardedVideoManagerTest {
+
+    @Mock
+    MoPubRequestQueue mockRequestQueue;
+    @Mock
+    MoPubRewardedVideoListener mockVideoListener;
+
+    AdRequest.Listener requestListener;
+    private AdRequest request;
+    private boolean mLoaded;
+
+    @Before
+    public void setup() {
+        MoPubRewardedVideoManager.init(Robolectric.buildActivity(Activity.class).create().get());
+        MoPubRewardedVideoManager.setVideoListener(mockVideoListener);
+
+        when(mockRequestQueue.add(any(AdRequest.class))).then(new Answer<Object>() {
+            @Override
+            public Object answer(final InvocationOnMock invocationOnMock) throws Throwable {
+                request = ((AdRequest) invocationOnMock.getArguments()[0]);
+                requestListener = request.getListener();
+                return null;
+            }
+        });
+
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+    }
+
+    @After
+    public void tearDown() {
+        // Unpause the main looper in case a test terminated while the looper was paused.
+        Robolectric.unPauseMainLooper();
+    }
+
+    @Test
+    public void callbackMethods_withNullListener_shouldNotError() {
+        // Clients can set RVM null.
+        MoPubRewardedVideoManager.setVideoListener(null);
+
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName("com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        Robolectric.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit");
+        // Triggers a call to MoPubRewardedVideoManager.onRewardedVideoLoadSuccess
+        requestListener.onSuccess(testResponse);
+
+        Robolectric.unPauseMainLooper();
+
+        MoPubRewardedVideoManager.onRewardedVideoClicked(TestCustomEvent.class, "id!");
+        MoPubRewardedVideoManager.onRewardedVideoStarted(TestCustomEvent.class, "id!");
+        MoPubRewardedVideoManager.onRewardedVideoClosed(TestCustomEvent.class, "id!");
+        MoPubRewardedVideoManager.onRewardedVideoCompleted(TestCustomEvent.class, "id!", MoPubReward.success("test", 111));
+
+        // The test passed because none of the above calls thew an exception even though the listener is null.
+    }
+
+    @Test
+    public void onAdSuccess_noCEFound_shouldCallFailCallback() throws Exception {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setAdType(AdType.CUSTOM)
+                .setCustomEventClassName("doesn't_Exist")
+                .build();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit");
+
+        requestListener.onSuccess(testResponse);
+
+        verify(mockVideoListener).onRewardedVideoLoadFailure(eq("testAdUnit"), eq(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR));
+        verifyNoMoreInteractions(mockVideoListener);
+    }
+
+    @Test
+    public void onAdSuccess_noCEFound_shouldLoadFailUrl() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setAdType(AdType.CUSTOM)
+                .setCustomEventClassName("doesn't_Exist")
+                .setFailoverUrl("fail.url")
+                .build();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit");
+
+        assertThat(request.getUrl()).contains("testAdUnit");
+        requestListener.onSuccess(testResponse);
+        assertThat(request.getUrl()).isEqualTo("fail.url");
+        // Clear up the static state :(
+        requestListener.onErrorResponse(new VolleyError("reset"));
+    }
+
+    @Test
+    public void onAdSuccess_shouldInstantiateCustomEvent_andLoad() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName("com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        Robolectric.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit");
+        requestListener.onSuccess(testResponse);
+
+        Robolectric.unPauseMainLooper();
+
+        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isTrue();
+        verify(mockVideoListener).onRewardedVideoLoadSuccess(eq("testAdUnit"));
+        verifyNoMoreInteractions(mockVideoListener);
+    }
+
+    @Test
+    public void playVideo_shouldSetHasVideoFalse() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName("com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        Robolectric.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit");
+        requestListener.onSuccess(testResponse);
+
+        Robolectric.unPauseMainLooper();
+
+        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isTrue();
+        MoPubRewardedVideoManager.showVideo("testAdUnit");
+        verify(mockVideoListener).onRewardedVideoLoadSuccess(eq("testAdUnit"));
+        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isFalse();
+        verify(mockVideoListener).onRewardedVideoStarted(eq("testAdUnit"));
+    }
+    
+    @Test
+    public void playVideo_whenNotHasVideo_shouldFail() {
+        AdResponse testResponse = new AdResponse.Builder()
+                .setCustomEventClassName("com.mopub.mobileads.MoPubRewardedVideoManagerTest$NoVideoCustomEvent")
+                .setAdType(AdType.CUSTOM)
+                .build();
+
+        // Robolectric executes its handlers immediately, so if we want the async behavior we see
+        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
+        Robolectric.pauseMainLooper();
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit");
+        requestListener.onSuccess(testResponse);
+
+        Robolectric.unPauseMainLooper();
+
+        verify(mockVideoListener).onRewardedVideoLoadFailure(eq("testAdUnit"), eq(MoPubErrorCode.NETWORK_NO_FILL));
+
+        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isFalse();
+        MoPubRewardedVideoManager.showVideo("testAdUnit");
+        verify(mockVideoListener).onRewardedVideoLoadFailure(eq("testAdUnit"), eq(MoPubErrorCode.VIDEO_NOT_AVAILABLE));
+    }
+
+    @Test
+    public void onAdFailure_shouldCallFailCallback() {
+        VolleyError e = new VolleyError("testError!");
+
+        MoPubRewardedVideoManager.loadVideo("testAdUnit");
+
+        assertThat(request.getUrl()).contains("testAdUnit");
+        requestListener.onErrorResponse(e);
+        verify(mockVideoListener).onRewardedVideoLoadFailure(anyString(), any(MoPubErrorCode.class));
+        verifyNoMoreInteractions(mockVideoListener);
+    }
+
+    public static class TestCustomEvent extends CustomEventRewardedVideo {
+        protected boolean mPlayable = false;
+
+        @Nullable
+        @Override
+        protected CustomEventRewardedVideoListener getVideoListenerForSdk() {
+            return null;
+        }
+
+        @Nullable
+        @Override
+        protected LifecycleListener getLifecycleListener() {
+            return null;
+        }
+
+        @NonNull
+        @Override
+        protected String getAdNetworkId() {
+            return "id!";
+        }
+
+        @Override
+        protected void onInvalidate() {
+            mPlayable = false;
+        }
+
+        @Override
+        protected boolean checkAndInitializeSdk(@NonNull final Activity launcherActivity,
+                @NonNull final Map<String, Object> localExtras,
+                @NonNull final Map<String, String> serverExtras) throws Exception {
+            return false;
+        }
+
+        @Override
+        protected void loadWithSdkInitialized(@NonNull final Activity activity,
+                @NonNull final Map<String, Object> localExtras,
+                @NonNull final Map<String, String> serverExtras) throws Exception {
+            // Do nothing because robolectric handlers execute immediately.
+            mPlayable = true;
+            MoPubRewardedVideoManager.onRewardedVideoLoadSuccess(TestCustomEvent.class, "id!");
+        }
+
+        @Override
+        protected boolean hasVideoAvailable() {
+            return mPlayable;
+        }
+
+        @Override
+        protected void showVideo() {
+            MoPubRewardedVideoManager.onRewardedVideoStarted(TestCustomEvent.class, "id!");
+        }
+    }
+
+    public static class NoVideoCustomEvent extends TestCustomEvent {
+        @Override
+        protected void loadWithSdkInitialized(@NonNull final Activity activity,
+                @NonNull final Map<String, Object> localExtras,
+                @NonNull final Map<String, String> serverExtras) throws Exception {
+            mPlayable = false;
+            MoPubRewardedVideoManager.onRewardedVideoLoadFailure(NoVideoCustomEvent.class, "id!", MoPubErrorCode.NETWORK_NO_FILL);
+        }
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubViewTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubViewTest.java
index 57095db9..cffcf3dc 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubViewTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubViewTest.java
@@ -21,9 +21,6 @@
 import java.util.List;
 import java.util.Map;
 
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_DATA;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_HTML_DATA;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_NAME;
 import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.eq;
@@ -176,21 +173,18 @@ public void nativeAdLoaded_shouldScheduleRefreshTimer() throws Exception {
 
     @Test
     public void loadCustomEvent_shouldInitializeCustomEventBannerAdapter() throws Exception {
-        paramsMap.put(CUSTOM_EVENT_NAME.getKey(), "name");
-        paramsMap.put(CUSTOM_EVENT_DATA.getKey(), "data");
-        paramsMap.put(CUSTOM_EVENT_HTML_DATA.getKey(), "html");
-        subject.loadCustomEvent(paramsMap);
+        subject.loadCustomEvent("name", paramsMap);
 
         assertThat(TestCustomEventBannerAdapterFactory.getLatestMoPubView()).isEqualTo(subject);
         assertThat(TestCustomEventBannerAdapterFactory.getLatestClassName()).isEqualTo("name");
-        assertThat(TestCustomEventBannerAdapterFactory.getLatestClassData()).isEqualTo("data");
+        assertThat(TestCustomEventBannerAdapterFactory.getLatestClassData()).isEqualTo(paramsMap);
 
         verify(customEventBannerAdapter).loadAd();
     }
 
     @Test
     public void loadCustomEvent_whenParamsMapIsNull_shouldCallLoadFailUrl() throws Exception {
-        subject.loadCustomEvent(null);
+        subject.loadCustomEvent(null, null);
 
         verify(adViewController).loadFailUrl(eq(ADAPTER_NOT_FOUND));
         verify(customEventBannerAdapter, never()).invalidate();
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidActivityTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidActivityTest.java
index cbe31354..84737b46 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidActivityTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidActivityTest.java
@@ -1,125 +1,146 @@
 package com.mopub.mobileads;
 
-import android.app.Activity;
+import android.content.BroadcastReceiver;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
-import android.graphics.Color;
-import android.os.Build;
 import android.os.Build.VERSION_CODES;
 import android.view.View;
+import android.view.ViewGroup;
 import android.view.WindowManager;
 import android.webkit.WebViewClient;
-import android.widget.Button;
-import android.widget.ImageButton;
-import android.widget.RelativeLayout;
+import android.widget.FrameLayout;
 
 import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.Dips;
-import com.mopub.mobileads.test.support.TestMraidViewFactory;
+import com.mopub.mraid.MraidBridge;
+import com.mopub.mraid.MraidBridge.MraidWebView;
+import com.mopub.mraid.MraidController;
+import com.mopub.mraid.MraidController.MraidListener;
 
 import org.fest.assertions.api.ANDROID;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
 import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowLocalBroadcastManager;
+import org.robolectric.util.ActivityController;
 
-import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_CLICK;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
+import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.getHtmlInterstitialIntentFilter;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiverTest.getIntentForActionAndIdentifier;
-import static com.mopub.mobileads.MraidView.MraidListener;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.stub;
+import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.withSettings;
 import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(SdkTestRunner.class)
-public class MraidActivityTest extends BaseInterstitialActivityTest {
+public class MraidActivityTest {
+    static final String EXPECTED_SOURCE = "expected source";
 
-    private MraidView mraidView;
-    private CustomEventInterstitial.CustomEventInterstitialListener customEventInterstitialListener;
-    private Activity context;
+    @Mock MraidWebView mraidWebView;
+    @Mock MraidBridge mraidBridge;
+    @Mock MraidController mraidController;
+    @Mock CustomEventInterstitial.CustomEventInterstitialListener
+            customEventInterstitialListener;
+    @Mock BroadcastReceiver broadcastReceiver;
+
+    long testBroadcastIdentifier = 2222;
+
+    ActivityController<TestMraidActivity> activityController;
+    TestMraidActivity subject;
+
+    // Make a concrete version of the abstract class for testing purposes.
+    private static class TestMraidActivity extends MraidActivity {
+        View mraidWebView;
+
+        @Override
+        public View getAdView() {
+            return mraidWebView;
+        }
+    }
 
     @Before
     public void setUp() throws Exception {
-        super.setup();
-        context = new Activity();
-        Intent mraidActivityIntent = createMraidActivityIntent(EXPECTED_SOURCE);
-        mraidView = TestMraidViewFactory.getSingletonMock();
-        resetMockedView(mraidView);
-        subject = Robolectric.buildActivity(MraidActivity.class).withIntent(mraidActivityIntent).create().get();
-        resetMockedView(mraidView);
-        customEventInterstitialListener = mock(CustomEventInterstitial.CustomEventInterstitialListener.class);
+        activityController = Robolectric.buildActivity(TestMraidActivity.class).start();
+        subject = activityController.get();
+        subject.mraidWebView = mraidWebView;
+        activityController.create();
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void preRenderHtml_shouldDisablePluginsSetListenersAndLoadHtml() throws Exception {
-        MraidActivity.preRenderHtml(null, customEventInterstitialListener, "3:27");
+        MraidActivity.preRenderHtml(subject, customEventInterstitialListener, "3:27");
 
-        verify(mraidView).enablePlugins(eq(false));
-        verify(mraidView).setMraidListener(any(MraidListener.class));
-        verify(mraidView).setWebViewClient(any(WebViewClient.class));
-        verify(mraidView).loadHtmlData(eq("3:27"));
+        verify(mraidWebView).enablePlugins(eq(false));
+        verify(mraidController).setMraidListener(any(MraidListener.class));
+        verify(mraidWebView).setWebViewClient(any(WebViewClient.class));
+        verify(mraidBridge).setContentHtml(eq("3:27"));
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void preRenderHtml_shouldCallCustomEventInterstitialOnInterstitialLoaded_whenMraidListenerOnReady() throws Exception {
-        MraidActivity.preRenderHtml(null, customEventInterstitialListener, "");
+        MraidActivity.preRenderHtml(subject, customEventInterstitialListener, "");
 
         ArgumentCaptor<MraidListener> mraidListenerArgumentCaptorr = ArgumentCaptor.forClass(MraidListener.class);
-        verify(mraidView).setMraidListener(mraidListenerArgumentCaptorr.capture());
+        verify(mraidController).setMraidListener(mraidListenerArgumentCaptorr.capture());
         MraidListener mraidListener = mraidListenerArgumentCaptorr.getValue();
 
-        mraidListener.onReady(null);
+        mraidListener.onLoaded(null);
 
         verify(customEventInterstitialListener).onInterstitialLoaded();
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void preRenderHtml_shouldCallCustomEventInterstitialOnInterstitialFailed_whenMraidListenerOnFailure() throws Exception {
-        MraidActivity.preRenderHtml(null, customEventInterstitialListener, "");
+        MraidActivity.preRenderHtml(subject, customEventInterstitialListener, "");
 
         ArgumentCaptor<MraidListener> mraidListenerArgumentCaptorr = ArgumentCaptor.forClass(MraidListener.class);
-        verify(mraidView).setMraidListener(mraidListenerArgumentCaptorr.capture());
+        verify(mraidController).setMraidListener(mraidListenerArgumentCaptorr.capture());
         MraidListener mraidListener = mraidListenerArgumentCaptorr.getValue();
 
-        mraidListener.onFailure(null);
+        mraidListener.onFailedToLoad();
 
         verify(customEventInterstitialListener).onInterstitialFailed(null);
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void preRenderHtml_whenWebViewClientShouldOverrideUrlLoading_shouldReturnTrue() throws Exception {
-        MraidActivity.preRenderHtml(null, customEventInterstitialListener, "");
+        MraidActivity.preRenderHtml(subject, customEventInterstitialListener, "");
 
         ArgumentCaptor<WebViewClient> webViewClientArgumentCaptor = ArgumentCaptor.forClass(WebViewClient.class);
-        verify(mraidView).setWebViewClient(webViewClientArgumentCaptor.capture());
+        verify(mraidWebView).setWebViewClient(webViewClientArgumentCaptor.capture());
         WebViewClient webViewClient = webViewClientArgumentCaptor.getValue();
 
         boolean consumeUrlLoading = webViewClient.shouldOverrideUrlLoading(null, null);
 
         assertThat(consumeUrlLoading).isTrue();
         verify(customEventInterstitialListener, never()).onInterstitialLoaded();
-        verify(customEventInterstitialListener, never()).onInterstitialFailed(any(MoPubErrorCode.class));
+        verify(customEventInterstitialListener, never()).onInterstitialFailed(
+                any(MoPubErrorCode.class));
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void preRenderHtml_shouldCallCustomEventInterstitialOnInterstitialLoaded_whenWebViewClientOnPageFinished() throws Exception {
-        MraidActivity.preRenderHtml(null, customEventInterstitialListener, "");
+        MraidActivity.preRenderHtml(subject, customEventInterstitialListener, "");
 
         ArgumentCaptor<WebViewClient> webViewClientArgumentCaptor = ArgumentCaptor.forClass(WebViewClient.class);
-        verify(mraidView).setWebViewClient(webViewClientArgumentCaptor.capture());
+        verify(mraidWebView).setWebViewClient(webViewClientArgumentCaptor.capture());
         WebViewClient webViewClient = webViewClientArgumentCaptor.getValue();
 
         webViewClient.onPageFinished(null, null);
@@ -127,52 +148,41 @@ public void preRenderHtml_shouldCallCustomEventInterstitialOnInterstitialLoaded_
         verify(customEventInterstitialListener).onInterstitialLoaded();
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void onCreate_shouldSetContentView() throws Exception {
         subject.onCreate(null);
 
-        assertThat(getContentView(subject).getChildCount()).isEqualTo(3);
+        assertThat(getContentView().getChildCount()).isEqualTo(1);
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void onCreate_shouldSetupAnMraidView() throws Exception {
         subject.onCreate(null);
 
-        assertThat(getContentView(subject).getChildAt(0)).isSameAs(mraidView);
-        verify(mraidView).setMraidListener(any(MraidListener.class));
-        verify(mraidView).setOnCloseButtonStateChange(any(MraidView.OnCloseButtonStateChangeListener.class));
+        assertThat(getContentView().getChildAt(0)).isSameAs(mraidWebView);
+        verify(mraidController).setMraidListener(any(MraidListener.class));
 
-        verify(mraidView).loadHtmlData(EXPECTED_SOURCE);
+        verify(mraidBridge).setContentHtml(EXPECTED_SOURCE);
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void onCreate_shouldSetLayoutOfMraidView() throws Exception {
         subject.onCreate(null);
 
-        ArgumentCaptor<RelativeLayout.LayoutParams> captor = ArgumentCaptor.forClass(RelativeLayout.LayoutParams.class);
-        verify(mraidView).setLayoutParams(captor.capture());
-        RelativeLayout.LayoutParams actualLayoutParams = captor.getValue();
+        ArgumentCaptor<FrameLayout.LayoutParams> captor = ArgumentCaptor.forClass(
+                FrameLayout.LayoutParams.class);
+        verify(mraidWebView).setLayoutParams(captor.capture());
+        FrameLayout.LayoutParams actualLayoutParams = captor.getValue();
 
-        assertThat(actualLayoutParams.width).isEqualTo(RelativeLayout.LayoutParams.MATCH_PARENT);
-        assertThat(actualLayoutParams.height).isEqualTo(RelativeLayout.LayoutParams.MATCH_PARENT);
-    }
-
-    @Test
-    public void onCreate_shouldAddCloseEventRegion() throws Exception {
-        subject.onCreate(null);
-
-        final Button closeEventRegion = (Button) getContentView(subject).getChildAt(2);
-        assertThat(closeEventRegion.getVisibility()).isEqualTo(View.VISIBLE);
-        assertThat(shadowOf(closeEventRegion).getBackgroundColor()).isEqualTo(Color.TRANSPARENT);
-        assertThat(Dips.pixelsToIntDips((float) closeEventRegion.getLayoutParams().width, context)).isEqualTo(50);
-        assertThat(Dips.pixelsToIntDips((float) closeEventRegion.getLayoutParams().height, context)).isEqualTo(50);
-        assertThat(((RelativeLayout.LayoutParams)closeEventRegion.getLayoutParams()).getRules()[RelativeLayout.ALIGN_PARENT_TOP])
-                .isEqualTo(RelativeLayout.TRUE);
-        assertThat(((RelativeLayout.LayoutParams)closeEventRegion.getLayoutParams()).getRules()[RelativeLayout.ALIGN_PARENT_RIGHT])
-                .isEqualTo(RelativeLayout.TRUE);
+        assertThat(actualLayoutParams.width).isEqualTo(FrameLayout.LayoutParams.MATCH_PARENT);
+        assertThat(actualLayoutParams.height).isEqualTo(FrameLayout.LayoutParams.MATCH_PARENT);
     }
 
     @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Ignore("Mraid 2.0")
     @Test
     public void onCreate_atLeastIcs_shouldSetHardwareAcceleratedFlag() throws Exception {
         subject.onCreate(null);
@@ -182,6 +192,7 @@ public void onCreate_atLeastIcs_shouldSetHardwareAcceleratedFlag() throws Except
     }
 
     @Config(reportSdk = VERSION_CODES.HONEYCOMB_MR2)
+    @Ignore("Mraid 2.0")
     @Test
     public void onCreate_beforeIcs_shouldNotSetHardwareAcceleratedFlag() throws Exception {
         subject.onCreate(null);
@@ -190,146 +201,117 @@ public void onCreate_beforeIcs_shouldNotSetHardwareAcceleratedFlag() throws Exce
         assertThat(hardwareAccelerated).isFalse();
     }
 
-    @Test
-    public void closeEventRegion_shouldFinishActivityWhenClicked() throws Exception {
-        subject.onCreate(null);
-
-        final Button closeEventRegion = (Button) getContentView(subject).getChildAt(2);
-        assertThat(closeEventRegion.performClick()).isTrue();
-        assertThat(subject.isFinishing()).isTrue();
-    }
-
+    @Ignore("Mraid 2.0")
     @Test
     public void onDestroy_DestroyMraidView() throws Exception {
         Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_DISMISS, subject.getBroadcastIdentifier());
-        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
+        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver,
+                getHtmlInterstitialIntentFilter());
 
-        subject.onCreate(null);
         subject.onDestroy();
 
         verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
-        verify(mraidView).destroy();
-        assertThat(getContentView(subject).getChildCount()).isEqualTo(0);
+        verify(mraidWebView).destroy();
+        assertThat(getContentView().getChildCount()).isEqualTo(0);
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void getAdView_shouldSetupOnReadyListener() throws Exception {
-        subject.onCreate(null);
-        resetMockedView(mraidView);
+        reset(mraidWebView);
         ArgumentCaptor<MraidListener> captor = ArgumentCaptor.forClass(MraidListener.class);
         View actualAdView = subject.getAdView();
 
-        assertThat(actualAdView).isSameAs(mraidView);
-        verify(mraidView).setMraidListener(captor.capture());
+        assertThat(actualAdView).isSameAs(mraidWebView);
+        verify(mraidController).setMraidListener(captor.capture());
 
         subject.hideInterstitialCloseButton();
-        captor.getValue().onReady(null);
-        ImageButton closeButton = (ImageButton) getContentView(subject).getChildAt(1);
-        assertThat(closeButton).isNotNull();
+        captor.getValue().onLoaded(null);
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void baseMraidListenerOnReady_shouldFireJavascriptWebViewDidAppear() throws Exception {
-        subject.onCreate(null);
-        resetMockedView(mraidView);
+        reset(mraidWebView);
         ArgumentCaptor<MraidListener> captor = ArgumentCaptor.forClass(MraidListener.class);
         View actualAdView = subject.getAdView();
 
-        assertThat(actualAdView).isSameAs(mraidView);
-        verify(mraidView).setMraidListener(captor.capture());
+        assertThat(actualAdView).isSameAs(mraidWebView);
+        verify(mraidController).setMraidListener(captor.capture());
 
         MraidListener baseMraidListener = captor.getValue();
-        baseMraidListener.onReady(null);
+        baseMraidListener.onLoaded(null);
 
-        verify(mraidView).loadUrl(eq("javascript:webviewDidAppear();"));
+        verify(mraidWebView).loadUrl(eq("javascript:webviewDidAppear();"));
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void baseMraidListenerOnClose_shouldFireJavascriptWebViewDidClose() throws Exception {
-        subject.onCreate(null);
-        resetMockedView(mraidView);
+        reset(mraidWebView);
         ArgumentCaptor<MraidListener> captor = ArgumentCaptor.forClass(MraidListener.class);
         View actualAdView = subject.getAdView();
 
-        assertThat(actualAdView).isSameAs(mraidView);
-        verify(mraidView).setMraidListener(captor.capture());
+        assertThat(actualAdView).isSameAs(mraidWebView);
+        verify(mraidController).setMraidListener(captor.capture());
 
         MraidListener baseMraidListener = captor.getValue();
-        baseMraidListener.onClose(null, null);
+        baseMraidListener.onClose();
 
-        verify(mraidView).loadUrl(eq("javascript:webviewDidClose();"));
+        verify(mraidWebView).loadUrl(eq("javascript:webviewDidClose();"));
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void baseMraidListenerOnOpen_shouldBroadcastClickEvent() throws Exception {
         Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_CLICK, testBroadcastIdentifier);
-        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
+        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver,
+                getHtmlInterstitialIntentFilter());
 
-        subject.onCreate(null);
-        resetMockedView(mraidView);
+        reset(mraidWebView);
 
         ArgumentCaptor<MraidListener> captor = ArgumentCaptor.forClass(MraidListener.class);
         View actualAdView = subject.getAdView();
 
-        assertThat(actualAdView).isSameAs(mraidView);
-        verify(mraidView).setMraidListener(captor.capture());
+        assertThat(actualAdView).isSameAs(mraidWebView);
+        verify(mraidController).setMraidListener(captor.capture());
 
         MraidListener baseMraidListener = captor.getValue();
-        baseMraidListener.onOpen(null);
+        baseMraidListener.onOpen();
 
         verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
     }
 
-    @Test
-    public void getAdView_shouldSetupOnCloseButtonStateChangeListener() throws Exception {
-        subject.onCreate(null);
-        resetMockedView(mraidView);
-        ArgumentCaptor<MraidView.OnCloseButtonStateChangeListener> captor = ArgumentCaptor.forClass(MraidView.OnCloseButtonStateChangeListener.class);
-        View actualAdView = subject.getAdView();
-
-        assertThat(actualAdView).isSameAs(mraidView);
-        verify(mraidView).setOnCloseButtonStateChange(captor.capture());
-        MraidView.OnCloseButtonStateChangeListener listener = captor.getValue();
-
-        ANDROID.assertThat(getCloseButton()).isVisible();
-
-        listener.onCloseButtonStateChange(null, false);
-        ANDROID.assertThat(getCloseButton()).isNotVisible();
-
-        listener.onCloseButtonStateChange(null, true);
-        ANDROID.assertThat(getCloseButton()).isVisible();
-    }
-
+    @Ignore("Mraid 2.0")
     @Test
     public void getAdView_shouldSetupOnCloseListener() throws Exception {
-        subject.onCreate(null);
-        resetMockedView(mraidView);
+        reset(mraidWebView);
         ArgumentCaptor<MraidListener> captor = ArgumentCaptor.forClass(MraidListener.class);
         View actualAdView = subject.getAdView();
 
-        assertThat(actualAdView).isSameAs(mraidView);
-        verify(mraidView).setMraidListener(captor.capture());
+        assertThat(actualAdView).isSameAs(mraidWebView);
+        verify(mraidController).setMraidListener(captor.capture());
 
-        captor.getValue().onClose(null, null);
+        captor.getValue().onClose();
 
         ANDROID.assertThat(subject).isFinishing();
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void onPause_shouldOnPauseMraidView() throws Exception {
-        subject.onCreate(null);
-        ((MraidActivity)subject).onPause();
+        activityController.pause();
 
-        verify(mraidView).onPause();
+        verify(mraidWebView).onPause();
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void onResume_shouldResumeMraidView() throws Exception {
         subject.onCreate(null);
-        ((MraidActivity)subject).onPause();
-        ((MraidActivity)subject).onResume();
+        Robolectric.shadowOf(subject).pauseAndThenResume();
 
-        verify(mraidView).onResume();
+        verify(mraidWebView).onResume();
     }
 
     private Intent createMraidActivityIntent(String expectedSource) {
@@ -337,10 +319,32 @@ private Intent createMraidActivityIntent(String expectedSource) {
         mraidActivityIntent.setComponent(new ComponentName("", ""));
         mraidActivityIntent.putExtra(HTML_RESPONSE_BODY_KEY, expectedSource);
 
-        adConfiguration = mock(AdConfiguration.class, withSettings().serializable());
-        stub(adConfiguration.getBroadcastIdentifier()).toReturn(testBroadcastIdentifier);
-        mraidActivityIntent.putExtra(AD_CONFIGURATION_KEY, adConfiguration);
+        mraidActivityIntent.putExtra(BROADCAST_IDENTIFIER_KEY, testBroadcastIdentifier);
 
         return mraidActivityIntent;
     }
+
+    @Ignore("Mraid 2.0")
+    @Test
+    public void onCreate_shouldBroadcastInterstitialShow() throws Exception {
+        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_SHOW, testBroadcastIdentifier);
+        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
+
+        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
+    }
+
+    @Ignore("Mraid 2.0")
+    @Test
+    public void onDestroy_shouldBroadcastInterstitialDismiss() throws Exception {
+        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_DISMISS, testBroadcastIdentifier);
+        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver, getHtmlInterstitialIntentFilter());
+
+        subject.onDestroy();
+
+        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
+    }
+
+    private FrameLayout getContentView() {
+        return (FrameLayout) ((ViewGroup) subject.findViewById(android.R.id.content)).getChildAt(0);
+    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidBannerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidBannerTest.java
deleted file mode 100644
index 05aa59de..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidBannerTest.java
+++ /dev/null
@@ -1,125 +0,0 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.mobileads.test.support.TestMraidViewFactory;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.ArgumentCaptor;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
-import static com.mopub.mobileads.CustomEventBanner.CustomEventBannerListener;
-import static com.mopub.mobileads.MoPubErrorCode.MRAID_LOAD_ERROR;
-import static com.mopub.mobileads.MraidView.MraidListener;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-
-@RunWith(SdkTestRunner.class)
-public class MraidBannerTest {
-    private MraidBanner subject;
-    private MraidView mraidView;
-    private Activity context;
-    private Map<String, Object> localExtras;
-    private Map<String, String> serverExtras;
-    private CustomEventBannerListener bannerListener;
-    private static final String INPUT_HTML_DATA = "%3Chtml%3E%3C%2Fhtml%3E";
-    private static final String EXPECTED_HTML_DATA = "<html></html>";
-
-    @Before
-    public void setUp() throws Exception {
-        subject = new MraidBanner();
-        mraidView = TestMraidViewFactory.getSingletonMock();
-
-        context = new Activity();
-        bannerListener = mock(CustomEventBanner.CustomEventBannerListener.class);
-        localExtras = new HashMap<String, Object>();
-        serverExtras = new HashMap<String, String>();
-        serverExtras.put(HTML_RESPONSE_BODY_KEY, INPUT_HTML_DATA);
-    }
-
-    @Test
-    public void loadBanner_whenExtrasAreMalformed_shouldNotifyBannerListenerAndReturn() throws Exception {
-        serverExtras.remove(HTML_RESPONSE_BODY_KEY);
-
-        subject.loadBanner(context, bannerListener, localExtras, serverExtras);
-
-        verify(bannerListener).onBannerFailed(eq(MRAID_LOAD_ERROR));
-        verify(mraidView, never()).loadHtmlData(any(String.class));
-        verify(mraidView, never()).setMraidListener(any(MraidListener.class));
-    }
-
-    @Test
-    public void loadBanner_shouldLoadHtmlDataAndInitializeListeners() throws Exception {
-        subject.loadBanner(context, bannerListener, localExtras, serverExtras);
-
-        verify(mraidView).loadHtmlData(EXPECTED_HTML_DATA);
-
-        verify(mraidView).setMraidListener(any(MraidListener.class));
-    }
-
-    @Test
-    public void invalidate_shouldDestroyMraidView() throws Exception {
-        subject.loadBanner(context, bannerListener, localExtras, serverExtras);
-        subject.onInvalidate();
-
-        verify(mraidView).destroy();
-    }
-
-    @Test
-    public void bannerMraidListener_onReady_shouldNotifyBannerLoaded() throws Exception {
-        MraidListener mraidListener = captureMraidListener();
-        mraidListener.onReady(null);
-
-        verify(bannerListener).onBannerLoaded(eq(mraidView));
-    }
-
-    @Test
-    public void bannerMraidListener_onFailure_shouldNotifyBannerFailed() throws Exception {
-        MraidListener mraidListener = captureMraidListener();
-        mraidListener.onFailure(null);
-
-        verify(bannerListener).onBannerFailed(eq(MRAID_LOAD_ERROR));
-    }
-
-    @Test
-    public void bannerMraidListener_onExpand_shouldNotifyBannerExpandedAndClicked() throws Exception {
-        MraidListener mraidListener = captureMraidListener();
-        mraidListener.onExpand(null);
-
-        verify(bannerListener).onBannerExpanded();
-        verify(bannerListener).onBannerClicked();
-    }
-
-    @Test
-    public void bannerMraidListener_onOpen_shouldNotifyBannerClicked() throws Exception {
-        MraidListener mraidListener = captureMraidListener();
-        mraidListener.onOpen(null);
-
-        verify(bannerListener).onBannerClicked();
-    }
-
-    @Test
-    public void bannerMraidListener_onClose_shouldNotifyBannerCollapsed() throws Exception {
-        MraidListener mraidListener = captureMraidListener();
-        mraidListener.onClose(null, null);
-
-        verify(bannerListener).onBannerCollapsed();
-    }
-
-    private MraidListener captureMraidListener() {
-        subject.loadBanner(context, bannerListener, localExtras, serverExtras);
-        ArgumentCaptor<MraidListener> listenerCaptor = ArgumentCaptor.forClass(MraidListener.class);
-        verify(mraidView).setMraidListener(listenerCaptor.capture());
-
-        return listenerCaptor.getValue();
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandFactoryTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandFactoryTest.java
deleted file mode 100644
index 8a164b71..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandFactoryTest.java
+++ /dev/null
@@ -1,80 +0,0 @@
-package com.mopub.mobileads;
-
-import com.mopub.common.test.support.SdkTestRunner;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import java.util.Map;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-
-@RunWith(SdkTestRunner.class)
-public class MraidCommandFactoryTest {
-    private MraidCommandFactory subject;
-    private Map params;
-    private MraidView mraidView;
-
-    @Before
-    public void setUp() throws Exception {
-        subject = new MraidCommandFactory();
-        params = mock(Map.class);
-        mraidView = mock(MraidView.class);
-
-    }
-
-    @Test
-    public void create_withCommandName_shouldInstantiateCorrectSubclass() throws Exception {
-        assertMraidCommandFactoryCreatesCorrectMraidCommandSubclass("close", MraidCommandClose.class);
-        assertMraidCommandFactoryCreatesCorrectMraidCommandSubclass("expand", MraidCommandExpand.class);
-        assertMraidCommandFactoryCreatesCorrectMraidCommandSubclass("usecustomclose", MraidCommandUseCustomClose.class);
-        assertMraidCommandFactoryCreatesCorrectMraidCommandSubclass("open", MraidCommandOpen.class);
-        assertMraidCommandFactoryCreatesCorrectMraidCommandSubclass("resize", MraidCommandResize.class);
-        assertMraidCommandFactoryCreatesCorrectMraidCommandSubclass("getResizeProperties", MraidCommandGetResizeProperties.class);
-        assertMraidCommandFactoryCreatesCorrectMraidCommandSubclass("setResizeProperties", MraidCommandSetResizeProperties.class);
-        assertMraidCommandFactoryCreatesCorrectMraidCommandSubclass("playVideo", MraidCommandPlayVideo.class);
-        assertMraidCommandFactoryCreatesCorrectMraidCommandSubclass("storePicture", MraidCommandStorePicture.class);
-        assertMraidCommandFactoryCreatesCorrectMraidCommandSubclass("getCurrentPosition", MraidCommandGetCurrentPosition.class);
-        assertMraidCommandFactoryCreatesCorrectMraidCommandSubclass("getDefaultPosition", MraidCommandGetDefaultPosition.class);
-        assertMraidCommandFactoryCreatesCorrectMraidCommandSubclass("getMaxSize", MraidCommandGetMaxSize.class);
-        assertMraidCommandFactoryCreatesCorrectMraidCommandSubclass("getScreenSize", MraidCommandGetScreenSize.class);
-        assertMraidCommandFactoryCreatesCorrectMraidCommandSubclass("createCalendarEvent", MraidCommandCreateCalendarEvent.class);
-    }
-
-    @Test
-    public void create_withInvalidCommandString_shouldReturnNull() throws Exception {
-        MraidCommand command = MraidCommandFactory.create("dog", params, mraidView);
-
-        assertThat(command).isNull();
-    }
-
-    @Test
-    public void create_withNullCommandString_shouldReturnNull() throws Exception {
-        MraidCommand command = MraidCommandFactory.create(null, params, mraidView);
-
-        assertThat(command).isNull();
-    }
-
-    @Test
-    public void create_withNullParams_shouldNotBlowUp() throws Exception {
-        MraidCommand command = MraidCommandFactory.create("close", null, mraidView);
-
-        // pass
-    }
-
-    @Test
-    public void create_withNullMraidView_shouldNotBlowUp() throws Exception {
-        MraidCommand command = MraidCommandFactory.create("close", params, null);
-
-        // pass
-    }
-
-    private void assertMraidCommandFactoryCreatesCorrectMraidCommandSubclass(String command, Class type) {
-        MraidCommand mraidCommand = MraidCommandFactory.create(command, params, mraidView);
-
-        assertThat(mraidCommand).isNotNull();
-        assertThat(mraidCommand).isInstanceOf(type);
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandPlayVideoTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandPlayVideoTest.java
deleted file mode 100644
index 44908b00..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandPlayVideoTest.java
+++ /dev/null
@@ -1,53 +0,0 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.mobileads.test.support.TestMraidViewFactory;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import static com.mopub.mobileads.BaseVideoPlayerActivitiyTest.assertMraidVideoPlayerActivityStarted;
-import static com.mopub.mobileads.MraidCommandPlayVideo.URI_KEY;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.stub;
-import static org.mockito.Mockito.withSettings;
-
-@RunWith(SdkTestRunner.class)
-public class MraidCommandPlayVideoTest {
-    public static final String EXPECTED_URI = "http://expected.uri";
-
-    private MraidCommandPlayVideo subject;
-    private MraidView mraidView;
-    private long testBroadcastIdentifier;
-    private AdConfiguration adConfiguration;
-
-    @Before
-    public void setup() {
-        Map<String, String> params = new HashMap<String, String>();
-
-        params.put(URI_KEY, EXPECTED_URI);
-
-        mraidView = TestMraidViewFactory.getSingletonMock();
-        stub(mraidView.getContext()).toReturn(new Activity());
-        MraidDisplayController displayController = new MraidDisplayController(mraidView, null, null);
-        stub(mraidView.getDisplayController()).toReturn(displayController);
-        subject = new MraidCommandPlayVideo(params, mraidView);
-
-        testBroadcastIdentifier = 2121;
-        adConfiguration = mock(AdConfiguration.class, withSettings().serializable());
-        stub(adConfiguration.getBroadcastIdentifier()).toReturn(testBroadcastIdentifier);
-        stub(mraidView.getAdConfiguration()).toReturn(adConfiguration);
-    }
-
-    @Test
-    public void execute_shouldPlayVideo() throws Exception {
-        subject.execute();
-        assertMraidVideoPlayerActivityStarted(MraidVideoPlayerActivity.class, EXPECTED_URI, adConfiguration);
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandResizeTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandResizeTest.java
deleted file mode 100644
index 1a9063c3..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandResizeTest.java
+++ /dev/null
@@ -1,54 +0,0 @@
-package com.mopub.mobileads;
-
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.mobileads.test.support.TestMraidViewFactory;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import java.util.HashMap;
-
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.GET_RESIZE_PROPERTIES;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.RESIZE;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.SET_RESIZE_PROPERTIES;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.verify;
-
-@RunWith(SdkTestRunner.class)
-public class MraidCommandResizeTest {
-    private MraidCommandResize subjectResize;
-    private MraidCommandGetResizeProperties subjectGetResizeProperties;
-    private MraidCommandSetResizeProperties subjectSetResizeProperties;
-    private MraidView mraidView;
-    @Before
-    public void setup() {
-        mraidView = TestMraidViewFactory.getSingletonMock();
-        subjectResize = new MraidCommandResize(new HashMap<String, String>(), mraidView);
-        subjectGetResizeProperties = new MraidCommandGetResizeProperties(new HashMap<String, String>(), mraidView);
-        subjectSetResizeProperties = new MraidCommandSetResizeProperties(new HashMap<String, String>(), mraidView);
-    }
-
-    @Test
-    public void mraidCommandResizeExecute_shouldFireErrorEvent() throws Exception {
-        reset(mraidView);
-        subjectResize.execute();
-        verify(mraidView).fireErrorEvent(eq(RESIZE), any(String.class));
-    }
-
-    @Test
-    public void mraidCommandSetResizePropertiesExecute_shouldFireErrorEvent() throws Exception {
-        reset(mraidView);
-        subjectSetResizeProperties.execute();
-        verify(mraidView).fireErrorEvent(eq(SET_RESIZE_PROPERTIES), any(String.class));
-    }
-
-    @Test
-    public void mraidCommandGetResizePropertiesExecute_shouldFireErrorEvent() throws Exception {
-        reset(mraidView);
-        subjectGetResizeProperties.execute();
-        verify(mraidView).fireErrorEvent(eq(GET_RESIZE_PROPERTIES), any(String.class));
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandStorePictureTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandStorePictureTest.java
deleted file mode 100644
index 3fad21a5..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandStorePictureTest.java
+++ /dev/null
@@ -1,76 +0,0 @@
-package com.mopub.mobileads;
-
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.mobileads.test.support.FileUtils;
-import com.mopub.mobileads.test.support.TestMraidViewFactory;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import static com.mopub.mobileads.MraidCommand.URI_KEY;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.STORE_PICTURE;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.stub;
-import static org.mockito.Mockito.verify;
-
-@RunWith(SdkTestRunner.class)
-public class MraidCommandStorePictureTest {
-
-    public static final String EXPECTED_FILE = "file://tmp/expectedFile.jpg";
-    private MraidCommandStorePicture subject;
-    private MraidView mraidView;
-    private Map<String,String> params;
-    private MraidDisplayController mraidDisplayController;
-
-    @Before
-    public void setUp() {
-        FileUtils.copyFile("etc/expectedFile.jpg", "/tmp/expectedFile.jpg");
-
-        mraidView = TestMraidViewFactory.getSingletonMock();
-        mraidDisplayController = mock(MraidDisplayController.class);
-        stub(mraidView.getDisplayController()).toReturn(mraidDisplayController);
-
-        params = new HashMap<String, String>();
-        subject = new MraidCommandStorePicture(params, mraidView);
-    }
-
-    @Test
-    public void execute_withImageUri_shouldShowUserDownloadImageAlert() throws Exception {
-        params.put(URI_KEY, EXPECTED_FILE);
-
-        subject.execute();
-
-        verify(mraidDisplayController).showUserDownloadImageAlert(eq(EXPECTED_FILE));
-    }
-
-    @Test
-    public void execute_withEmptyUriKey_shouldFireErrorEvent() throws Exception {
-        params.put(URI_KEY, "");
-
-        subject.execute();
-
-        verify(mraidView).fireErrorEvent(
-                eq(STORE_PICTURE),
-                anyString());
-        verify(mraidDisplayController, never()).showUserDownloadImageAlert(anyString());
-    }
-
-    @Test
-     public void execute_withMissingUriKey_shouldFireErrorEvent() throws Exception {
-        // don't add URI_KEY to params
-
-        subject.execute();
-
-        verify(mraidView).fireErrorEvent(
-                eq(STORE_PICTURE),
-                anyString());
-        verify(mraidDisplayController, never()).showUserDownloadImageAlert(anyString());
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandTest.java
deleted file mode 100644
index e4b7682e..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandTest.java
+++ /dev/null
@@ -1,143 +0,0 @@
-package com.mopub.mobileads;
-
-import org.junit.Test;
-
-import java.util.Map;
-
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.CLOSE;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.CREATE_CALENDAR_EVENT;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.EXPAND;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.GET_CURRENT_POSITION;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.GET_DEFAULT_POSITION;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.GET_MAX_SIZE;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.GET_RESIZE_PROPERTIES;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.GET_SCREEN_SIZE;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.OPEN;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.PLAY_VIDEO;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.RESIZE;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.SET_RESIZE_PROPERTIES;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.STORE_PICTURE;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.USECUSTOMCLOSE;
-import static com.mopub.mobileads.MraidCommandFactory.create;
-import static com.mopub.mobileads.MraidView.PlacementType;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-
-public class MraidCommandTest {
-    @Test
-    public void createCommand_shouldReturnTheRightKindOfCommand() throws Exception {
-        assertThat(create("bogus", null, null)).isNull();
-
-        assertThat(create(CLOSE.getCommand(), null, null)).isInstanceOf(MraidCommandClose.class);
-        assertThat(create(CLOSE.getCommand(), null, null)).isNotSameAs(create("close", null, null));
-
-        assertThat(create(EXPAND.getCommand(), null, null)).isInstanceOf(MraidCommandExpand.class);
-        assertThat(create(USECUSTOMCLOSE.getCommand(), null, null)).isInstanceOf(MraidCommandUseCustomClose.class);
-        assertThat(create(OPEN.getCommand(), null, null)).isInstanceOf(MraidCommandOpen.class);
-        assertThat(create(RESIZE.getCommand(), null, null)).isInstanceOf(MraidCommandResize.class);
-        assertThat(create(SET_RESIZE_PROPERTIES.getCommand(), null, null)).isInstanceOf(MraidCommandSetResizeProperties.class);
-        assertThat(create(GET_RESIZE_PROPERTIES.getCommand(), null, null)).isInstanceOf(MraidCommandGetResizeProperties.class);
-        assertThat(create(PLAY_VIDEO.getCommand(), null, null)).isInstanceOf(MraidCommandPlayVideo.class);
-        assertThat(create(STORE_PICTURE.getCommand(), null, null)).isInstanceOf(MraidCommandStorePicture.class);
-        assertThat(create(GET_CURRENT_POSITION.getCommand(), null, null)).isInstanceOf(MraidCommandGetCurrentPosition.class);
-        assertThat(create(GET_DEFAULT_POSITION.getCommand(), null, null)).isInstanceOf(MraidCommandGetDefaultPosition.class);
-        assertThat(create(GET_MAX_SIZE.getCommand(), null, null)).isInstanceOf(MraidCommandGetMaxSize.class);
-        assertThat(create(GET_SCREEN_SIZE.getCommand(), null, null)).isInstanceOf(MraidCommandGetScreenSize.class);
-        assertThat(create(CREATE_CALENDAR_EVENT.getCommand(), null, null)).isInstanceOf(MraidCommandCreateCalendarEvent.class);
-    }
-
-    @Test
-    public void createCommand_shouldPassParameters() throws Exception {
-        MraidView expectedView = mock(MraidView.class);
-        Map<String, String> expectedMap = mock(Map.class);
-
-        MraidCommand command = create(EXPAND.getCommand(), expectedMap, expectedView);
-        assertThat(command.mParams).isEqualTo(expectedMap);
-        assertThat(command.mView).isEqualTo(expectedView);
-    }
-
-
-    @Test
-    public void createCommand_close_shouldSetDependentOnUserClick() throws Exception {
-        assertThat(create(CLOSE.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INLINE)).isFalse();
-        assertThat(create(CLOSE.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INTERSTITIAL)).isFalse();
-    }
-
-    @Test
-    public void createCommand_expand_shouldSetDependentOnUserClick() throws Exception {
-        assertThat(create(EXPAND.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INLINE)).isTrue();
-        assertThat(create(EXPAND.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INTERSTITIAL)).isFalse();
-    }
-
-    @Test
-    public void createCommand_useCustomClose_shouldSetDependentOnUserClick() throws Exception {
-        assertThat(create(USECUSTOMCLOSE.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INLINE)).isFalse();
-        assertThat(create(USECUSTOMCLOSE.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INTERSTITIAL)).isFalse();
-    }
-
-    @Test
-    public void createCommand_open_shouldSetDependentOnUserClick() throws Exception {
-        assertThat(create(OPEN.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INLINE)).isTrue();
-        assertThat(create(OPEN.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INTERSTITIAL)).isTrue();
-    }
-
-    @Test
-    public void createCommand_resize_shouldSetDependentOnUserClick() throws Exception {
-        assertThat(create(RESIZE.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INLINE)).isFalse();
-        assertThat(create(RESIZE.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INTERSTITIAL)).isFalse();
-    }
-
-    @Test
-    public void createCommand_setResizeProperties_shouldSetDependentOnUserClick() throws Exception {
-        assertThat(create(SET_RESIZE_PROPERTIES.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INLINE)).isFalse();
-        assertThat(create(SET_RESIZE_PROPERTIES.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INTERSTITIAL)).isFalse();
-    }
-
-    @Test
-    public void createCommand_getResizeProperties_shouldSetDependentOnUserClick() throws Exception {
-        assertThat(create(GET_RESIZE_PROPERTIES.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INLINE)).isFalse();
-        assertThat(create(GET_RESIZE_PROPERTIES.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INTERSTITIAL)).isFalse();
-    }
-
-    @Test
-    public void createCommand_playVideo_shouldSetDependentOnUserClick() throws Exception {
-        assertThat(create(PLAY_VIDEO.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INLINE)).isTrue();
-        assertThat(create(PLAY_VIDEO.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INTERSTITIAL)).isFalse();
-    }
-
-    @Test
-    public void createCommand_storePicture_shouldSetDependentOnUserClick() throws Exception {
-        assertThat(create(STORE_PICTURE.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INLINE)).isTrue();
-        assertThat(create(STORE_PICTURE.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INTERSTITIAL)).isTrue();
-    }
-
-    @Test
-    public void createCommand_getCurrentPosition_shouldSetDependentOnUserClick() throws Exception {
-        assertThat(create(GET_CURRENT_POSITION.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INLINE)).isFalse();
-        assertThat(create(GET_CURRENT_POSITION.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INTERSTITIAL)).isFalse();
-    }
-
-    @Test
-    public void createCommand_getDefaultPosition_shouldSetDependentOnUserClick() throws Exception {
-        assertThat(create(GET_DEFAULT_POSITION.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INLINE)).isFalse();
-        assertThat(create(GET_DEFAULT_POSITION.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INTERSTITIAL)).isFalse();
-    }
-
-    @Test
-    public void createCommand_getMaxSize_shouldSetDependentOnUserClick() throws Exception {
-        assertThat(create(GET_MAX_SIZE.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INLINE)).isFalse();
-        assertThat(create(GET_MAX_SIZE.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INTERSTITIAL)).isFalse();
-    }
-
-    @Test
-    public void createCommand_getScreenSize_shouldSetDependentOnUserClick() throws Exception {
-        assertThat(create(GET_SCREEN_SIZE.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INLINE)).isFalse();
-        assertThat(create(GET_SCREEN_SIZE.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INTERSTITIAL)).isFalse();
-    }
-
-    @Test
-    public void createCommand_createCalendarEvent_shouldSetDependentOnUserClick() throws Exception {
-        assertThat(create(CREATE_CALENDAR_EVENT.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INLINE)).isTrue();
-        assertThat(create(CREATE_CALENDAR_EVENT.getCommand(), null, null).isCommandDependentOnUserClick(PlacementType.INTERSTITIAL)).isTrue();
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidSupportsPropertyTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidSupportsPropertyTest.java
deleted file mode 100644
index 56ab537d..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidSupportsPropertyTest.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package com.mopub.mobileads;
-
-import org.junit.Test;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-
-public class MraidSupportsPropertyTest {
-
-    @Test
-    public void MraidSupportsProperty_toJsonPair_should_returnTheSupportsJsonObject() throws Exception {
-        MraidSupportsProperty property =
-                new MraidSupportsProperty()
-                        .withSms(true)
-                        .withTel(true)
-                        .withCalendar(false)
-                        .withStorePicture(false)
-                        .withInlineVideo(false);
-        assertThat(property.toJsonPair()).isEqualTo("supports: {" +
-                "sms: true, " +
-                "tel: true, " +
-                "calendar: false, " +
-                "storePicture: false, " +
-                "inlineVideo: false}");
-    }
-
-    @Test
-    public void MraidSupportsProperty_toJSONPair_should_returnAllDefaultPairValuesAsFalse() throws Exception {
-        MraidSupportsProperty property =
-                new MraidSupportsProperty().withCalendar(true).withInlineVideo(true);
-        assertThat(property.toJsonPair()).isEqualTo("supports: {" +
-                "sms: false, " +
-                "tel: false, " +
-                "calendar: true, " +
-                "storePicture: false, " +
-                "inlineVideo: true}");
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidVideoPlayerActivityTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidVideoPlayerActivityTest.java
index d8a9ca17..05bc9bc7 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidVideoPlayerActivityTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidVideoPlayerActivityTest.java
@@ -11,6 +11,7 @@
 import com.mopub.common.MoPubBrowser;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.mobileads.util.vast.VastVideoConfiguration;
+import com.mopub.mraid.MraidVideoViewController;
 
 import org.junit.Before;
 import org.junit.Ignore;
@@ -19,12 +20,11 @@
 import org.robolectric.Robolectric;
 import org.robolectric.shadows.ShadowActivity;
 
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-import static org.mockito.Mockito.withSettings;
 import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(SdkTestRunner.class)
@@ -44,10 +44,7 @@ public void setup() {
         intent = new Intent(context, MraidVideoPlayerActivity.class);
 
         testBroadcastIdentifier = 1001;
-        AdConfiguration adConfiguration = mock(AdConfiguration.class, withSettings().serializable());
-        when(adConfiguration.getBroadcastIdentifier()).thenReturn(testBroadcastIdentifier);
-        intent.putExtra(AdFetcher.AD_CONFIGURATION_KEY, adConfiguration);
-
+        intent.putExtra(BROADCAST_IDENTIFIER_KEY, testBroadcastIdentifier);
         baseVideoViewController = mock(BaseVideoViewController.class);
     }
 
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidViewTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidViewTest.java
deleted file mode 100644
index b8e54fe5..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidViewTest.java
+++ /dev/null
@@ -1,345 +0,0 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.view.View;
-import android.view.ViewGroup;
-import android.webkit.WebViewClient;
-
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.mobileads.resource.MraidJavascript;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.ArgumentCaptor;
-import org.robolectric.Robolectric;
-import org.robolectric.shadows.ShadowWebView;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verify;
-import static org.robolectric.Robolectric.shadowOf;
-
-@RunWith(SdkTestRunner.class)
-public class MraidViewTest {
-    private Context context;
-    private AdConfiguration adConfiguration;
-    private MraidDisplayController mraidDisplayController;
-
-    private MraidView bannerSubject;
-    private MraidView interstitialSubject;
-    private WebViewClient bannerWebViewClient;
-    private WebViewClient interstitialWebViewClient;
-
-    @Before
-    public void setUp() throws Exception {
-        context = new Activity();
-        adConfiguration = mock(AdConfiguration.class);
-        mraidDisplayController = mock(MraidDisplayController.class);
-
-        bannerSubject = new MraidView(context, adConfiguration);
-        bannerSubject.setMraidDisplayController(mraidDisplayController);
-        bannerWebViewClient = bannerSubject.getMraidWebViewClient();
-
-        interstitialSubject = new MraidView(context, adConfiguration, MraidView.ExpansionStyle.ENABLED, MraidView.NativeCloseButtonStyle.ALWAYS_VISIBLE, MraidView.PlacementType.INTERSTITIAL);
-        interstitialSubject.setMraidDisplayController(mraidDisplayController);
-        interstitialWebViewClient = interstitialSubject.getMraidWebViewClient();
-    }
-
-    @Test
-    public void viewSetToVisibleBeforeReady_shouldNotTriggerMRAIDEvent() throws Exception {
-        MraidView mraidViewSpy = spy(bannerSubject);
-        mraidViewSpy.setHasFiredReadyEvent(false);
-        mraidViewSpy.setVisibility(View.INVISIBLE);
-
-        mraidViewSpy.setVisibility(View.VISIBLE);
-
-        assertThat(mraidViewSpy.getIsVisible()).isTrue();
-
-        verify(mraidViewSpy, never()).fireChangeEventForProperty(any(MraidViewableProperty.class));
-    }
-
-    @Test
-    public void viewSetToVisibleAfterReady_shouldTriggerMRAIDEvent() throws Exception {
-        MraidView mraidViewSpy = spy(bannerSubject);
-        mraidViewSpy.setHasFiredReadyEvent(true);
-        mraidViewSpy.setVisibility(View.INVISIBLE);
-        reset(mraidViewSpy);
-
-        mraidViewSpy.setVisibility(View.VISIBLE);
-
-        assertThat(mraidViewSpy.getIsVisible()).isTrue();
-
-        MraidViewableProperty mraidViewableProperty = captureAndVerifyViewablePropertyChangeEventFired(mraidViewSpy);
-        assertThat(mraidViewableProperty.toJsonPair()).isEqualTo("viewable: true");
-    }
-
-    @Test
-    public void viewSetToVisibleAndThenInvisibleAfterReady_shouldTriggerTwoMRAIDEvents() throws Exception {
-        MraidView mraidViewSpy = spy(bannerSubject);
-        mraidViewSpy.setHasFiredReadyEvent(true);
-        mraidViewSpy.setVisibility(View.INVISIBLE);
-        reset(mraidViewSpy);
-
-        mraidViewSpy.setVisibility(View.VISIBLE);
-
-        MraidViewableProperty mraidViewableProperty = captureAndVerifyViewablePropertyChangeEventFired(mraidViewSpy);
-        assertThat(mraidViewableProperty.toJsonPair()).isEqualTo("viewable: true");
-        reset(mraidViewSpy);
-
-        mraidViewSpy.setVisibility(View.INVISIBLE);
-
-        assertThat(mraidViewSpy.getIsVisible()).isFalse();
-
-        mraidViewableProperty = captureAndVerifyViewablePropertyChangeEventFired(mraidViewSpy);
-        assertThat(mraidViewableProperty.toJsonPair()).isEqualTo("viewable: false");
-    }
-
-    @Test
-    public void viewSetToVisibleAndThenGoneAfterReady_shouldTriggerTwoMRAIDEvents() throws Exception {
-        MraidView mraidViewSpy = spy(bannerSubject);
-        mraidViewSpy.setHasFiredReadyEvent(true);
-        mraidViewSpy.setVisibility(View.INVISIBLE);
-        reset(mraidViewSpy);
-
-        mraidViewSpy.setVisibility(View.VISIBLE);
-
-        MraidViewableProperty mraidViewableProperty = captureAndVerifyViewablePropertyChangeEventFired(mraidViewSpy);
-        assertThat(mraidViewableProperty.toJsonPair()).isEqualTo("viewable: true");
-        reset(mraidViewSpy);
-
-        mraidViewSpy.setVisibility(View.GONE);
-
-        assertThat(mraidViewSpy.getIsVisible()).isFalse();
-
-        mraidViewableProperty = captureAndVerifyViewablePropertyChangeEventFired(mraidViewSpy);
-        assertThat(mraidViewableProperty.toJsonPair()).isEqualTo("viewable: false");
-    }
-
-    @Test
-    public void viewSetToVisibleAndThenInvisibleAndThenVisibleAfterReady_shouldTriggerThreeMRAIDEvents() throws Exception {
-        MraidView mraidViewSpy = spy(bannerSubject);
-        mraidViewSpy.setHasFiredReadyEvent(true);
-        mraidViewSpy.setVisibility(View.INVISIBLE);
-        reset(mraidViewSpy);
-
-        mraidViewSpy.setVisibility(View.VISIBLE);
-
-        MraidViewableProperty mraidViewableProperty = captureAndVerifyViewablePropertyChangeEventFired(mraidViewSpy);
-        assertThat(mraidViewableProperty.toJsonPair()).isEqualTo("viewable: true");
-        reset(mraidViewSpy);
-
-        mraidViewSpy.setVisibility(View.INVISIBLE);
-
-        mraidViewableProperty = captureAndVerifyViewablePropertyChangeEventFired(mraidViewSpy);
-        assertThat(mraidViewableProperty.toJsonPair()).isEqualTo("viewable: false");
-        reset(mraidViewSpy);
-
-        mraidViewSpy.setVisibility(View.VISIBLE);
-
-        assertThat(mraidViewSpy.getIsVisible()).isTrue();
-
-        mraidViewableProperty = captureAndVerifyViewablePropertyChangeEventFired(mraidViewSpy);
-        assertThat(mraidViewableProperty.toJsonPair()).isEqualTo("viewable: true");
-    }
-
-    @Test
-    public void loadHtmlData_whenDataIsNull_shouldNotBlowUp() throws Exception {
-        MraidView mraidViewSpy = spy(bannerSubject);
-
-        mraidViewSpy.loadHtmlData(null);
-
-        // pass
-
-        verify(mraidViewSpy, never()).loadDataWithBaseURL(anyString(), anyString(), anyString(), anyString(), anyString());
-    }
-
-    @Test
-    public void loadHtmlData_shouldSendSimpleHtmlToLoadDataWithBaseUrl() throws Exception {
-        MraidView mraidViewSpy = spy(bannerSubject);
-        String htmlData = "<html></html>";
-
-        mraidViewSpy.loadHtmlData(htmlData);
-
-        verify(mraidViewSpy).loadDataWithBaseURL(anyString(), eq(htmlData), eq("text/html"), eq("UTF-8"), anyString());
-    }
-
-
-    @Test
-    public void loadHtmlData_whenHtmlContainsHeadTag_shouldIncludeMraidJs() throws Exception {
-        MraidView mraidViewSpy = spy(bannerSubject);
-        String htmlData = "<html><head></head></html>";
-        String expectedResult = "<html><head><script>" + MraidJavascript.JAVASCRIPT_SOURCE + "</script></head></html>";
-
-        mraidViewSpy.loadHtmlData(htmlData);
-
-        verify(mraidViewSpy).loadDataWithBaseURL(anyString(), eq(expectedResult), eq("text/html"), eq("UTF-8"), anyString());
-    }
-
-    @Test
-    public void loadHtmlData_whenMissingHtmlBoilerplate_shouldAddItAndIncludeMraidJs() throws Exception {
-        MraidView mraidViewSpy = spy(bannerSubject);
-        String htmlData = "<a href='www.goat.com'>CLICK THIS LINK</a>";
-        String expectedResult = "<html><head><script>" + MraidJavascript.JAVASCRIPT_SOURCE + "</script></head>" +
-                "<body style='margin:0;padding:0;'><a href='www.goat.com'>CLICK THIS LINK</a></body></html>";
-
-        mraidViewSpy.loadHtmlData(htmlData);
-
-        verify(mraidViewSpy).loadDataWithBaseURL(anyString(), eq(expectedResult), eq("text/html"), eq("UTF-8"), anyString());
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withMraidCommandCreateCalendarEvent_forBanners_withUserClick_shouldOpenNewCalendarIntent() throws Exception {
-        String url = "mraid://createCalendarEvent?description=hi&start=1";
-        Map<String, String> expectedParams = new HashMap<String, String>(2);
-        expectedParams.put("description", "hi");
-        expectedParams.put("start", "1");
-
-        bannerSubject.onUserClick();
-
-        bannerWebViewClient.shouldOverrideUrlLoading(null, url);
-
-        verify(mraidDisplayController).createCalendarEvent(eq(expectedParams));
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withMraidCommandCreateCalendarEvent_forInterstitials_withUserClick_shouldOpenNewCalendarIntent() throws Exception {
-        String url = "mraid://createCalendarEvent?description=hi&start=1";
-        Map<String, String> expectedParams = new HashMap<String, String>(2);
-        expectedParams.put("description", "hi");
-        expectedParams.put("start", "1");
-
-        interstitialSubject.onUserClick();
-        interstitialWebViewClient.shouldOverrideUrlLoading(null, url);
-
-        verify(mraidDisplayController).createCalendarEvent(eq(expectedParams));
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withMraidCommandCreateCalendarEvent_forBanners_withoutUserClick_shouldNotOpenNewIntent() throws Exception {
-        String url = "mraid://createCalendarEvent?description=Mayan%20Apocalypse%2FEnd%20of%20World&start=2013-08-16T20%3A00-04%3A00&interval=1&frequency=daily";
-
-        assertThat(bannerSubject.wasClicked()).isFalse();
-        bannerWebViewClient.shouldOverrideUrlLoading(null, url);
-
-        verify(mraidDisplayController, never()).createCalendarEvent(any(Map.class));
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withMraidCommandCreateCalendarEvent_forInterstitials_withoutUserClick_shouldNotOpenNewIntent() throws Exception {
-        String url = "mraid://createCalendarEvent?description=Mayan%20Apocalypse%2FEnd%20of%20World&start=2013-08-16T20%3A00-04%3A00&interval=1&frequency=daily";
-
-        interstitialWebViewClient.shouldOverrideUrlLoading(null, url);
-
-        verify(mraidDisplayController, never()).createCalendarEvent(any(Map.class));
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withMraidCommandPlayVideo_forBanners_withOutUserClick_shouldNotOpenNewIntent() throws Exception {
-        String url = "mraid://playVideo?uri=something";
-
-        bannerWebViewClient.shouldOverrideUrlLoading(null, url);
-
-        verify(mraidDisplayController, never()).showVideo(anyString());
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withMraidCommandPlayVideo_forBanners_withUserClick_shouldOpenNewIntent() throws Exception {
-        String url = "mraid://playVideo?uri=something";
-
-        bannerSubject.onUserClick();
-
-        bannerWebViewClient.shouldOverrideUrlLoading(null, url);
-
-        verify(mraidDisplayController).showVideo(eq("something"));
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withMraidCommandPlayVideo_forInterstitials_shouldOpenNewIntent() throws Exception {
-        String url = "mraid://playVideo?uri=something";
-
-        assertThat(interstitialSubject.wasClicked()).isFalse();
-        interstitialWebViewClient.shouldOverrideUrlLoading(null, url);
-
-        verify(mraidDisplayController).showVideo(eq("something"));
-
-        reset(mraidDisplayController);
-        interstitialSubject.onUserClick();
-        interstitialWebViewClient.shouldOverrideUrlLoading(null, url);
-
-        verify(mraidDisplayController).showVideo(eq("something"));
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withRedirectUrl_withoutUserClick_shouldNotOpenNewIntentAndReturnFalse() throws Exception {
-        String url = "http://www.blah.com";
-
-        boolean consumeUrlLoading = bannerWebViewClient.shouldOverrideUrlLoading(null, url);
-
-        Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedIntent).isNull();
-        assertThat(consumeUrlLoading).isFalse();
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withRedirectUrl_withUserClick_shouldOpenNewIntent() throws Exception {
-        String url = "http://www.blah.com";
-        bannerSubject.onUserClick();
-
-        boolean consumeUrlLoading = bannerWebViewClient.shouldOverrideUrlLoading(null, url);
-
-        Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedIntent).isNotNull();
-        assertThat(consumeUrlLoading).isTrue();
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withRelativeUrl_andUserClick_shouldReturnTrue() throws Exception {
-        String relativeUrl = "www.blah.com";
-        bannerSubject.onUserClick();
-
-        boolean consumeUrlLoading = bannerWebViewClient.shouldOverrideUrlLoading(null, relativeUrl);
-
-        Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(startedIntent).isNotNull();
-        assertThat(consumeUrlLoading).isTrue();
-    }
-
-    @Test
-    public void shouldOverrideUrlLoading_withRelativeUrl_andNoUserClick_shouldReturnFalse() throws Exception {
-        String relativeUrl = "www.blah.com";
-
-        boolean consumeUrlLoading = bannerWebViewClient.shouldOverrideUrlLoading(null, relativeUrl);
-
-        assertThat(consumeUrlLoading).isFalse();
-    }
-
-    @Test
-    public void destroy_shouldRemoveSelfFromParent_beforeCallingDestroy() throws Exception {
-        ViewGroup parent = mock(ViewGroup.class);
-        ShadowWebView shadow = shadowOf(bannerSubject);
-        shadow.setMyParent(parent);
-
-        bannerSubject.destroy();
-
-        verify(parent).removeView(eq(bannerSubject));
-        assertThat(shadow.wasDestroyCalled()).isTrue();
-    }
-
-    private MraidViewableProperty captureAndVerifyViewablePropertyChangeEventFired(MraidView mraidView) {
-        ArgumentCaptor<MraidViewableProperty> mraidViewablePropertyCaptor = ArgumentCaptor.forClass(MraidViewableProperty.class);
-        verify(mraidView).fireChangeEventForProperty(mraidViewablePropertyCaptor.capture());
-        return mraidViewablePropertyCaptor.getValue();
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/TaskTrackerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/TaskTrackerTest.java
deleted file mode 100644
index 604fed40..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/TaskTrackerTest.java
+++ /dev/null
@@ -1,66 +0,0 @@
-package com.mopub.mobileads;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-
-public class TaskTrackerTest {
-
-    private TaskTracker taskTracker;
-
-    @Before
-    public void setUp() throws Exception {
-        taskTracker = new TaskTracker();
-    }
-
-    @Test
-    public void newTaskStarted_shouldIncrementIdsFromNegativeOne() throws Exception {
-        assertThat(taskTracker.getCurrentTaskId()).isEqualTo(-1);
-
-        taskTracker.newTaskStarted();
-
-        assertThat(taskTracker.getCurrentTaskId()).isEqualTo(0);
-    }
-
-    @Test
-    public void isMostCurrentTask_onFirstTask_whenSecondTaskIsCompleted_shouldBeFalse() throws Exception {
-        taskTracker.newTaskStarted();
-        taskTracker.newTaskStarted();
-        taskTracker.markTaskCompleted(taskTracker.getCurrentTaskId());
-
-        assertThat(taskTracker.isMostCurrentTask(0)).isFalse();
-    }
-
-    @Test
-    public void isMostCurrentTask_onFirstTask_whenSecondTaskIsNotCompleted_shouldBeTrue() throws Exception {
-        taskTracker.newTaskStarted();
-        taskTracker.newTaskStarted();
-
-        assertThat(taskTracker.isMostCurrentTask(0)).isTrue();
-    }
-
-    @Test
-    public void mostCurrentTaskIsLastCompletedTaskOrLater() throws Exception {
-        taskTracker.newTaskStarted();
-        taskTracker.newTaskStarted();
-        taskTracker.newTaskStarted();
-        taskTracker.markTaskCompleted(1);
-
-        assertThat(taskTracker.isMostCurrentTask(0)).isFalse();
-        assertThat(taskTracker.isMostCurrentTask(1)).isTrue();
-        assertThat(taskTracker.isMostCurrentTask(2)).isTrue();
-    }
-
-    @Test
-    public void markTaskCompleted_shouldKeepTrackOfMostCurrentTaskRegardlessOfCompletionOrder() throws Exception {
-        taskTracker.newTaskStarted();
-        taskTracker.newTaskStarted();
-        taskTracker.newTaskStarted();
-        taskTracker.markTaskCompleted(1);
-        taskTracker.markTaskCompleted(0);
-
-        assertThat(taskTracker.isMostCurrentTask(0)).isFalse();
-        assertThat(taskTracker.isMostCurrentTask(1)).isTrue();
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/ToolbarWidgetTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/ToolbarWidgetTest.java
new file mode 100644
index 00000000..68131ed0
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/ToolbarWidgetTest.java
@@ -0,0 +1,121 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.view.View;
+import android.widget.ImageView;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.resource.CloseButtonDrawable;
+import com.mopub.network.MaxWidthImageLoader;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.volley.VolleyError;
+import com.mopub.volley.toolbox.ImageLoader;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Captor;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+
+import static android.view.Gravity.CENTER_VERTICAL;
+import static android.view.Gravity.RIGHT;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@Config(manifest = Config.NONE)
+@RunWith(SdkTestRunner.class)
+
+public class ToolbarWidgetTest {
+    private Context context;
+    private ToolbarWidget subject;
+
+    private static final String ICON_IMAGE_URL = "iconimageurl";
+
+    @Mock
+    MoPubRequestQueue mockRequestQueue;
+    @Mock
+    private MaxWidthImageLoader mockImageLoader;
+    @Mock
+    private ImageLoader.ImageContainer mockImageContainer;
+    @Mock
+    private Bitmap mockBitmap;
+    @Captor
+    private ArgumentCaptor<ImageLoader.ImageListener> imageCaptor;
+
+    @Before
+    public void setUp() throws Exception {
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+        Networking.setImageLoaderForTesting(mockImageLoader);
+        context = Robolectric.buildActivity(Activity.class).create().get();
+    }
+
+    private void initializeSubject() {
+        subject = new ToolbarWidget.Builder(context)
+                .weight(1f)
+                .widgetGravity(CENTER_VERTICAL | RIGHT)
+                .defaultText("Close")
+                .drawable(new CloseButtonDrawable())
+                .visibility(View.GONE)
+                .build();
+    }
+
+    @Test
+    public void updateImage_imageListenerOnResponse_shouldUseImageBitmap() throws Exception {
+        initializeSubject();
+
+        when(mockImageContainer.getBitmap()).thenReturn(mockBitmap);
+
+        subject.updateImage(ICON_IMAGE_URL);
+
+        verify(mockImageLoader).get(eq(ICON_IMAGE_URL), imageCaptor.capture());
+        ImageLoader.ImageListener listener = imageCaptor.getValue();
+        listener.onResponse(mockImageContainer, true);
+        assertThat(((BitmapDrawable) subject.getImageViewDrawable()).getBitmap()).isEqualTo(mockBitmap);
+    }
+
+    @Test
+    public void updateImage_imageListenerOnResponseWhenReturnedBitMapIsNull_shouldUseDefaultCloseButtonDrawable() throws Exception {
+        initializeSubject();
+
+        final ImageView imageViewSpy = spy(subject.getImageView());
+        subject.setImageView(imageViewSpy);
+
+        when(mockImageContainer.getBitmap()).thenReturn(null);
+
+        subject.updateImage(ICON_IMAGE_URL);
+
+        verify(mockImageLoader).get(eq(ICON_IMAGE_URL), imageCaptor.capture());
+        ImageLoader.ImageListener listener = imageCaptor.getValue();
+        listener.onResponse(mockImageContainer, true);
+        verify(imageViewSpy, never()).setImageBitmap(any(Bitmap.class));
+        assertThat(subject.getImageViewDrawable()).isInstanceOf(CloseButtonDrawable.class);
+    }
+
+    @Test
+    public void updateImage_imageListenerOnErrorResponse_shouldUseDefaultCloseButtonDrawable() throws Exception {
+        initializeSubject();
+
+        final ImageView imageViewSpy = spy(subject.getImageView());
+        subject.setImageView(imageViewSpy);
+
+        subject.updateImage(ICON_IMAGE_URL);
+
+        verify(mockImageLoader).get(eq(ICON_IMAGE_URL), imageCaptor.capture());
+        ImageLoader.ImageListener listener = imageCaptor.getValue();
+        listener.onErrorResponse(new VolleyError());
+        verify(imageViewSpy, never()).setImageBitmap(any(Bitmap.class));
+        assertThat(subject.getImageViewDrawable()).isInstanceOf(CloseButtonDrawable.class);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoDownloadTaskTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoDownloadTaskTest.java
index aa9f1786..dd69502f 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoDownloadTaskTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoDownloadTaskTest.java
@@ -55,11 +55,6 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
         subject = new VastVideoDownloadTask(mVastVideoDownloadTaskListener);
     }
 
-    @After
-    public void tearDown() throws Exception {
-        CacheService.clearAndNullCaches();
-    }
-
     @Test
     public void execute_shouldAddToCacheAndSignalDownloadSuccess() throws Exception {
         subject.execute(videoUrl);
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoInterstitialTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoInterstitialTest.java
index ba4a9454..9c9ad74e 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoInterstitialTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoInterstitialTest.java
@@ -3,10 +3,9 @@
 import android.app.Activity;
 import android.content.Context;
 import android.content.Intent;
-import android.net.Uri;
 
-import com.mopub.common.CacheService;
 import com.mopub.common.CacheServiceTest;
+import com.mopub.common.DataKeys;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
 import com.mopub.mobileads.test.support.TestVastManagerFactory;
@@ -26,8 +25,8 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
 import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
@@ -41,7 +40,6 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.stub;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.withSettings;
 
@@ -57,7 +55,6 @@
     private String videoUrl;
     private VastVideoDownloadTask vastVideoDownloadTask;
     private long broadcastIdentifier;
-    private AdConfiguration adConfiguration;
 
     @Before
     public void setUp() throws Exception {
@@ -72,20 +69,17 @@ public void setUp() throws Exception {
         customEventInterstitialListener = mock(CustomEventInterstitialListener.class);
         localExtras = new HashMap<String, Object>();
         serverExtras = new HashMap<String, String>();
-        serverExtras.put(AdFetcher.HTML_RESPONSE_BODY_KEY, Uri.encode(expectedResponse));
+        serverExtras.put(DataKeys.HTML_RESPONSE_BODY_KEY, expectedResponse);
 
         response = new TestHttpResponseWithHeaders(200, expectedResponse);
 
         broadcastIdentifier = 2222;
-        adConfiguration = mock(AdConfiguration.class, withSettings().serializable());
-        stub(adConfiguration.getBroadcastIdentifier()).toReturn(broadcastIdentifier);
-        localExtras.put(AD_CONFIGURATION_KEY, adConfiguration);
+        localExtras.put(BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
     }
 
     @After
     public void tearDown() throws Exception {
         reset(vastVideoDownloadTask);
-        CacheService.clearAndNullCaches();
     }
 
     @Test
@@ -151,10 +145,10 @@ public void showInterstitial_shouldStartVideoPlayerActivityWithAllValidTrackers(
         VastCompanionAd vastCompanionAd = mock(VastCompanionAd.class, withSettings().serializable());
         VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
         vastVideoConfiguration.setNetworkMediaFileUrl(videoUrl);
-        vastVideoConfiguration.addStartTrackers(Arrays.asList("start"));
-        vastVideoConfiguration.addFirstQuartileTrackers(Arrays.asList("first"));
-        vastVideoConfiguration.addMidpointTrackers(Arrays.asList("mid"));
-        vastVideoConfiguration.addThirdQuartileTrackers(Arrays.asList("third"));
+        vastVideoConfiguration.addAbsoluteTrackers(Arrays.asList(new VastAbsoluteProgressTracker("start", 2000)));
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("first", 0.25f),
+                new VastFractionalProgressTracker("mid", 0.5f),
+                new VastFractionalProgressTracker("third", 0.75f)));
         vastVideoConfiguration.addCompleteTrackers(Arrays.asList("complete"));
         vastVideoConfiguration.addImpressionTrackers(Arrays.asList("imp"));
         vastVideoConfiguration.setClickThroughUrl("clickThrough");
@@ -165,10 +159,10 @@ public void showInterstitial_shouldStartVideoPlayerActivityWithAllValidTrackers(
         ((VastVideoInterstitial) subject).onVastVideoConfigurationPrepared(vastVideoConfiguration);
 
         subject.showInterstitial();
-        BaseVideoPlayerActivitiyTest.assertVastVideoPlayerActivityStarted(
+        BaseVideoPlayerActivityTest.assertVastVideoPlayerActivityStarted(
                 MraidVideoPlayerActivity.class,
                 vastVideoConfiguration,
-                adConfiguration
+                broadcastIdentifier
                 );
     }
 
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoToolbarTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoToolbarTest.java
index f29f0a54..af65fd49 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoToolbarTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoToolbarTest.java
@@ -2,6 +2,7 @@
 
 import android.app.Activity;
 import android.content.Context;
+import android.graphics.drawable.Drawable;
 import android.view.View;
 import android.widget.TextView;
 
@@ -49,7 +50,7 @@ public void constructor_shouldAddWidgetsToToolbar() throws Exception {
         assertThat(subject.getCountdownWidget().getParent()).isEqualTo(subject);
         assertThat(subject.getCloseButtonWidget().getParent()).isEqualTo(subject);
     }
-    
+
     @Test
     public void constructor_shouldOnlyStartWithDurationWidgetsVisible() throws Exception {
         assertThat(subject.getDurationWidget().getVisibility()).isEqualTo(View.VISIBLE);
@@ -83,21 +84,44 @@ public void setLearnButtonOnTouchListener_shouldPropagateToLearnButtonWidget() t
     }
 
     @Test
-    public void getDisplaySeconds_shouldReturnLongMillisecondsAsRoundedUpStringSeconds() throws Exception {
-        assertThat(subject.getDisplaySeconds(0)).isEqualTo("0");
+    public void convertMillisecondsToSecondsRoundedUp_shouldReturnLongMillisecondsAsRoundedUpLongSeconds() throws Exception {
+        assertThat(subject.convertMillisecondsToSecondsRoundedUp(0)).isEqualTo(0);
 
-        assertThat(subject.getDisplaySeconds(1)).isEqualTo("1");
-        assertThat(subject.getDisplaySeconds(999)).isEqualTo("1");
-        assertThat(subject.getDisplaySeconds(1000)).isEqualTo("1");
+        assertThat(subject.convertMillisecondsToSecondsRoundedUp(1)).isEqualTo(1);
+        assertThat(subject.convertMillisecondsToSecondsRoundedUp(999)).isEqualTo(1);
+        assertThat(subject.convertMillisecondsToSecondsRoundedUp(1000)).isEqualTo(1);
 
-        assertThat(subject.getDisplaySeconds(1001)).isEqualTo("2");
-        assertThat(subject.getDisplaySeconds(100000)).isEqualTo("100");
+        assertThat(subject.convertMillisecondsToSecondsRoundedUp(1001)).isEqualTo(2);
+        assertThat(subject.convertMillisecondsToSecondsRoundedUp(100000)).isEqualTo(100);
     }
-    
+
+    @Test
+    public void formatTime_shouldReturnLongMillisecondsAsFormattedString() {
+        assertThat(subject.formatTime(-8999)).isEqualTo("-8 seconds");
+        assertThat(subject.formatTime(-9000)).isEqualTo("-9 seconds");
+        assertThat(subject.formatTime(-9001)).isEqualTo("-9 seconds");
+        assertThat(subject.formatTime(0)).isEqualTo("0 seconds");
+
+        assertThat(subject.formatTime(1)).isEqualTo("1 second");
+        assertThat(subject.formatTime(1000)).isEqualTo("1 second");
+        assertThat(subject.formatTime(1005)).isEqualTo("2 seconds");
+
+        assertThat(subject.formatTime(59999)).isEqualTo("60 seconds");
+        assertThat(subject.formatTime(60000)).isEqualTo("60 seconds");
+        assertThat(subject.formatTime(60001)).isEqualTo("61 seconds");
+        assertThat(subject.formatTime(853437)).isEqualTo("854 seconds");
+
+        assertThat(subject.formatTime(3599999)).isEqualTo("3600 seconds");
+        assertThat(subject.formatTime(3600000)).isEqualTo("3600 seconds");
+        assertThat(subject.formatTime(3600001)).isEqualTo("3601 seconds");
+        assertThat(subject.formatTime(3660001)).isEqualTo("3661 seconds");
+        assertThat(subject.formatTime(65784693)).isEqualTo("65785 seconds");
+    }
+
     @Test
     public void updateCountdownWidget_shouldUpdateTextDrawablesDisplayNumber() throws Exception {
-        final TextDrawable countdownImageSpy = spy(subject.getCountdownWidget().getImageViewDrawable());
-        subject.getCountdownWidget().setImageViewDrawable(countdownImageSpy);
+        final TextDrawable countdownImageSpy = spy((TextDrawable) subject.getCountdownWidget().getImageViewDrawable());
+        subject.getCountdownWidget().setImageViewDrawable((Drawable) countdownImageSpy);
 
         subject.updateCountdownWidget(1002);
 
@@ -154,7 +178,7 @@ public void updateDurationWidget_whenBelowThresholdForHidingVideoDuration_should
         // 200ms of remaining video is the cut off for switching to "Thanks for watching"
         subject.updateDurationWidget(200);
 
-        assertThat(durationWidgetTextView.getText()).isEqualTo("Ends in 1 seconds");
+        assertThat(durationWidgetTextView.getText()).isEqualTo("Ends in 1 second");
 
         subject.updateDurationWidget(199);
 
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewControllerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewControllerTest.java
index 0b414074..33eab605 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewControllerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewControllerTest.java
@@ -5,6 +5,7 @@
 import android.content.Intent;
 import android.graphics.Color;
 import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
 import android.graphics.drawable.GradientDrawable;
 import android.graphics.drawable.LayerDrawable;
 import android.media.MediaPlayer;
@@ -15,13 +16,20 @@
 import android.webkit.WebView;
 import android.widget.ImageView;
 import android.widget.VideoView;
+
 import com.mopub.common.MoPubBrowser;
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.DeviceUtils.ForceOrientation;
 import com.mopub.common.util.Dips;
 import com.mopub.common.util.Drawables;
+import com.mopub.mobileads.resource.CloseButtonDrawable;
 import com.mopub.mobileads.test.support.GestureUtils;
 import com.mopub.mobileads.util.vast.VastCompanionAd;
 import com.mopub.mobileads.util.vast.VastVideoConfiguration;
+import com.mopub.network.MaxWidthImageLoader;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+
 import org.apache.http.HttpRequest;
 import org.apache.maven.artifact.ant.shaded.ReflectionUtils;
 import org.junit.After;
@@ -30,6 +38,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
 import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowLocalBroadcastManager;
@@ -37,14 +46,18 @@
 import org.robolectric.tester.org.apache.http.RequestMatcher;
 import org.robolectric.tester.org.apache.http.TestHttpResponse;
 
-import java.io.*;
-import java.util.*;
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Arrays;
 
-import static android.media.MediaPlayer.OnPreparedListener;
+import static android.content.pm.ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
+import static android.content.pm.ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
 import static android.view.ViewGroup.LayoutParams.MATCH_PARENT;
 import static com.mopub.common.MoPubBrowser.DESTINATION_URL_KEY;
-import static com.mopub.common.util.test.support.CommonUtils.assertHttpRequestsMade;
+import static com.mopub.common.VolleyRequestMatcher.isUrl;
+import static com.mopub.common.util.ResponseHeader.USER_AGENT;
 import static com.mopub.mobileads.BaseVideoViewController.BaseVideoViewControllerListener;
+import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_CLICK;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_FAIL;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
@@ -53,21 +66,33 @@
 import static com.mopub.mobileads.VastVideoViewController.DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON;
 import static com.mopub.mobileads.VastVideoViewController.MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON;
 import static com.mopub.mobileads.VastVideoViewController.VAST_VIDEO_CONFIGURATION;
+import static com.mopub.volley.toolbox.ImageLoader.ImageListener;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.argThat;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.stub;
 import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.verifyZeroInteractions;
 import static org.robolectric.Robolectric.shadowOf;
 
+@Config(manifest = Config.NONE)
 @RunWith(SdkTestRunner.class)
 public class VastVideoViewControllerTest {
-    public static final int NETWORK_DELAY = 500;
-    private MediaPlayer mediaPlayer;
+    public static final int NETWORK_DELAY = 100;
+
+    private static final String COMPANION_IMAGE_URL = "companion_image_url";
+    private static final String COMPANION_CLICK_TRACKING_URL_1 = "companion_click_tracking_url_1";
+    private static final String COMPANION_CLICK_TRACKING_URL_2 = "companion_click_tracking_url_2";
+    private static final String COMPANION_CLICK_DESTINATION_URL = "http://companion_click_destination_url";
+    private static final String CLICKTHROUGH_URL = "http://clickthrough_url";
+
     private Context context;
     private Bundle bundle;
     private long testBroadcastIdentifier;
@@ -77,9 +102,17 @@
     private int expectedBrowserRequestCode;
     private String expectedUserAgent;
 
+    @Mock
+    MoPubRequestQueue mockRequestQueue;
+    @Mock
+    MaxWidthImageLoader mockImageLoader;
+    @Mock
+    private MediaPlayer mockMediaPlayer;
+
     @Before
     public void setUp() throws Exception {
-        mediaPlayer = mock(MediaPlayer.class);
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+        Networking.setImageLoaderForTesting(mockImageLoader);
         context = new Activity();
         bundle = new Bundle();
         testBroadcastIdentifier = 1111;
@@ -89,21 +122,22 @@ public void setUp() throws Exception {
         VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
         vastVideoConfiguration.setNetworkMediaFileUrl("video_url");
         vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addStartTrackers(Arrays.asList("start"));
-        vastVideoConfiguration.addFirstQuartileTrackers(Arrays.asList("first"));
-        vastVideoConfiguration.addMidpointTrackers(Arrays.asList("mid"));
-        vastVideoConfiguration.addThirdQuartileTrackers(Arrays.asList("third"));
+        vastVideoConfiguration.addAbsoluteTrackers(Arrays.asList(new VastAbsoluteProgressTracker("start", 2000)));
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("first", 0.25f),
+                new VastFractionalProgressTracker("mid", 0.5f), new VastFractionalProgressTracker("third", 0.75f)));
         vastVideoConfiguration.addCompleteTrackers(Arrays.asList("complete"));
+        vastVideoConfiguration.addCloseTrackers(Arrays.asList("close"));
+        vastVideoConfiguration.addSkipTrackers(Arrays.asList("skip"));
         vastVideoConfiguration.addImpressionTrackers(Arrays.asList("imp"));
-        vastVideoConfiguration.setClickThroughUrl("clickThrough");
+        vastVideoConfiguration.setClickThroughUrl(CLICKTHROUGH_URL);
         vastVideoConfiguration.addClickTrackers(Arrays.asList("click_1", "click_2"));
 
         VastCompanionAd vastCompanionAd = new VastCompanionAd(
                 300,
                 250,
-                "companion_image_url",
-                "companion_click_destination_url",
-                new ArrayList<String>(Arrays.asList("companion_click_tracking_url_1", "companion_click_tracking_url_2"))
+                COMPANION_IMAGE_URL,
+                COMPANION_CLICK_DESTINATION_URL,
+                new ArrayList<String>(Arrays.asList(COMPANION_CLICK_TRACKING_URL_1, COMPANION_CLICK_TRACKING_URL_2))
         );
         vastVideoConfiguration.setVastCompanionAd(vastCompanionAd);
 
@@ -115,6 +149,7 @@ public void setUp() throws Exception {
         Robolectric.getBackgroundScheduler().pause();
         Robolectric.clearPendingHttpResponses();
 
+        // Used to give responses to Vast Download Tasks.
         Robolectric.addHttpResponseRule(new RequestMatcher() {
             @Override
             public boolean matches(HttpRequest request) {
@@ -131,32 +166,10 @@ public boolean matches(HttpRequest request) {
     public void tearDown() throws Exception {
         Robolectric.getUiThreadScheduler().reset();
         Robolectric.getBackgroundScheduler().reset();
-        Robolectric.clearPendingHttpResponses();
 
         ShadowLocalBroadcastManager.getInstance(context).unregisterReceiver(broadcastReceiver);
     }
 
-    @Test
-    public void constructor_shouldPingImpressionTrackers() throws Exception {
-        // XXX this test needs to be at the top of the constructor tests since it checks for async
-        // http requests. If it's below any other constructor tests, there is a chance outstanding
-        // async requests will not run until this tests starts, thus polluting the http requests
-
-        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
-        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addStartTrackers(Arrays.asList("start"));
-        vastVideoConfiguration.addImpressionTrackers(Arrays.asList("imp"));
-        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
-
-        initializeSubject();
-
-        Robolectric.getUiThreadScheduler().unPause();
-        Robolectric.getBackgroundScheduler().unPause();
-        Thread.sleep(NETWORK_DELAY);
-
-        assertHttpRequestsMade(expectedUserAgent, "imp");
-    }
-
     @Test
     public void constructor_shouldAddVastVideoToolbarToLayout() throws Exception {
         initializeSubject();
@@ -197,14 +210,15 @@ public void constructor_shouldAddThatchedBackgroundWithGradientToLayout() throws
         initializeSubject();
         ViewGroup viewGroup = subject.getLayout();
         LayerDrawable layerDrawable = (LayerDrawable) viewGroup.getBackground();
-        assertThat(layerDrawable.getDrawable(0)).isEqualTo(Drawables.THATCHED_BACKGROUND.decodeImage(context));
+        assertThat(layerDrawable.getDrawable(0)).isEqualTo(Drawables.THATCHED_BACKGROUND.createDrawable(
+                context));
         assertThat(layerDrawable.getDrawable(1)).isEqualTo(
                 new GradientDrawable(
                         GradientDrawable.Orientation.TOP_BOTTOM,
                         new int[]{Color.argb(0, 0, 0, 0), Color.argb(255, 0, 0, 0)})
         );
     }
-    
+
     @Test
     public void constructor_withMissingVastVideoConfiguration_shouldThrowIllegalStateException() throws Exception {
         bundle.clear();
@@ -228,15 +242,75 @@ public void constructor_withNullVastVideoConfigurationDiskMediaFileUrl_shouldThr
     }
 
     @Test
-    public void onCreate_shouldBroadcastInterstitialShow() throws Exception {
-        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_SHOW, testBroadcastIdentifier);
+    public void constructor_whenCustomCtaTextNotSpecified_shouldUseDefaultCtaText() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
 
         initializeSubject();
 
-        subject.onCreate();
-        Robolectric.getUiThreadScheduler().unPause();
+        assertThat(getVastVideoToolbar().getLearnMoreWidget().getTextViewText()).isEqualTo("Learn More");
+    }
 
-        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
+    @Test
+    public void constructor_whenCustomCtaTextSpecified_shouldUseCustomCtaText() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setCustomCtaText("custom CTA text");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+
+        assertThat(getVastVideoToolbar().getLearnMoreWidget().getTextViewText()).isEqualTo("custom CTA text");
+    }
+
+    @Test
+    public void constructor_whenCustomSkipTextNotSpecified_shouldUseDefaultSkipText() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+
+        assertThat(getVastVideoToolbar().getCloseButtonWidget().getTextViewText()).isEqualTo("Close");
+    }
+
+    @Test
+    public void constructor_whenCustomSkipTextSpecified_shouldUseCustomSkipText() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setCustomSkipText("custom skip text");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+
+        assertThat(getVastVideoToolbar().getCloseButtonWidget().getTextViewText()).isEqualTo("custom skip text");
+    }
+
+    @Test
+    public void constructor_whenCustomCloseIconNotSpecified_shouldUseDefaultCloseIcon() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+
+        Drawable imageViewDrawable = getVastVideoToolbar().getCloseButtonWidget().getImageViewDrawable();
+
+        // Default close icon is an instance of CloseButtonDrawable
+        assertThat(imageViewDrawable).isInstanceOf(CloseButtonDrawable.class);
+    }
+
+    @Test
+    public void constructor_whenCustomCloseIconSpecified_shouldUseCustomCloseIcon() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setCustomCloseIconUrl("http://ton.twitter.com/exchange-media/images/v4/star_icon_3x_1.png");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+
+        verify(mockImageLoader).get(eq("http://ton.twitter.com/exchange-media/images/v4/star_icon_3x_1.png"), any(ImageListener.class));
     }
 
     @Test
@@ -254,6 +328,76 @@ public void onCreate_withCompanionAd_shouldDownloadCompanionAd() throws Exceptio
         assertThat(shadowOf(((BitmapDrawable) imageView.getDrawable()).getBitmap()).getCreatedFromBytes()).isEqualTo("body".getBytes());
     }
 
+    @Test
+    public void onCreate_shouldFireImpressionTracker() throws Exception {
+        initializeSubject();
+
+        subject.onCreate();
+        verify(mockRequestQueue).add(argThat(isUrl("imp")));
+    }
+
+    @Test
+    public void onCreate_shouldBroadcastInterstitialShow() throws Exception {
+        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_SHOW, testBroadcastIdentifier);
+
+        initializeSubject();
+
+        Robolectric.getUiThreadScheduler().unPause();
+        subject.onCreate();
+        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
+    }
+
+    @Test
+    public void onCreate_whenCustomForceOrientationNotSpecified_shouldForceLandscapeOrientation() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        subject.onCreate();
+
+        verify(baseVideoViewControllerListener).onSetRequestedOrientation(SCREEN_ORIENTATION_LANDSCAPE);
+    }
+
+    @Test
+    public void onCreate_whenCustomForceOrientationIsDeviceOrientation_shouldNotForceLandscapeOrientation() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setCustomForceOrientation(ForceOrientation.DEVICE_ORIENTATION);
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        subject.onCreate();
+
+        verify(baseVideoViewControllerListener, never()).onSetRequestedOrientation(anyInt());
+    }
+
+    @Test
+    public void onCreate_whenCustomForceOrientationIsPortraitOrientation_shouldForcePortraitOrientation() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setCustomForceOrientation(ForceOrientation.FORCE_PORTRAIT);
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        subject.onCreate();
+
+        verify(baseVideoViewControllerListener).onSetRequestedOrientation(SCREEN_ORIENTATION_PORTRAIT);
+    }
+
+    @Test
+    public void onCreate_whenCustomForceOrientationIsLandscapeOrientation_shouldForceLandscapeOrientation() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setCustomForceOrientation(ForceOrientation.FORCE_LANDSCAPE);
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+        subject.onCreate();
+
+        verify(baseVideoViewControllerListener).onSetRequestedOrientation(SCREEN_ORIENTATION_LANDSCAPE);
+    }
+
     @Test
     public void onComplete_withNullDownloadResponse_shouldNotSetCompanionAdImageBitmap() throws Exception {
         initializeSubject();
@@ -279,15 +423,12 @@ public void onClick_withCompanionAd_shouldFireCompanionAdClickTrackersAndStartMo
         Thread.sleep(NETWORK_DELAY);
 
         assertThat(imageView.performClick()).isTrue();
-        Thread.sleep(NETWORK_DELAY);
 
-        assertHttpRequestsMade(
-                expectedUserAgent,
-                "companion_image_url",
-                "imp",
-                "companion_click_tracking_url_1",
-                "companion_click_tracking_url_2"
-        );
+        // This request is still made by the older http stack.
+        assertHttpRequestsMade(expectedUserAgent, COMPANION_IMAGE_URL);
+
+        verify(mockRequestQueue).add(argThat(isUrl(COMPANION_CLICK_TRACKING_URL_1)));
+        verify(mockRequestQueue).add(argThat(isUrl(COMPANION_CLICK_TRACKING_URL_2)));
 
         ArgumentCaptor<Bundle> bundleCaptor = ArgumentCaptor.forClass(Bundle.class);
         verify(baseVideoViewControllerListener).onStartActivityForResult(
@@ -296,7 +437,7 @@ public void onClick_withCompanionAd_shouldFireCompanionAdClickTrackersAndStartMo
                 bundleCaptor.capture()
         );
 
-        assertThat(bundleCaptor.getValue().get(DESTINATION_URL_KEY)).isEqualTo("companion_click_destination_url");
+        assertThat(bundleCaptor.getValue().get(DESTINATION_URL_KEY)).isEqualTo(COMPANION_CLICK_DESTINATION_URL);
     }
 
     @Test
@@ -345,14 +486,13 @@ public void onActivityResult_withIncorrectResultCode_shouldNotCallFinish() throw
         verify(baseVideoViewControllerListener, never()).onFinish();
     }
 
-
     @Test
     public void onTouch_withTouchUp_whenVideoLessThan16Seconds_andClickBeforeEnd_shouldDoNothing() throws Exception {
-        stub(mediaPlayer.getDuration()).toReturn(15999);
-        stub(mediaPlayer.getCurrentPosition()).toReturn(15990);
+        stub(mockMediaPlayer.getDuration()).toReturn(15999);
+        stub(mockMediaPlayer.getCurrentPosition()).toReturn(15990);
 
         initializeSubject();
-        setMediaPlayer(mediaPlayer);
+        setMockMediaPlayer(mockMediaPlayer);
         getShadowVideoView().getOnPreparedListener().onPrepared(null);
 
         Robolectric.getUiThreadScheduler().unPause();
@@ -365,13 +505,13 @@ public void onTouch_withTouchUp_whenVideoLessThan16Seconds_andClickBeforeEnd_sho
 
     @Test
     public void onTouch_withTouchUp_whenVideoLessThan16Seconds_andClickAfterEnd_shouldStartMoPubBrowser() throws Exception {
-        stub(mediaPlayer.getDuration()).toReturn(15999);
-        stub(mediaPlayer.getCurrentPosition()).toReturn(16000);
+        stub(mockMediaPlayer.getDuration()).toReturn(15999);
+        stub(mockMediaPlayer.getCurrentPosition()).toReturn(15999);
 
         initializeSubject();
         subject.onResume();
 
-        setMediaPlayer(mediaPlayer);
+        setMockMediaPlayer(mockMediaPlayer);
         getShadowVideoView().getOnPreparedListener().onPrepared(null);
 
         Robolectric.getUiThreadScheduler().unPause();
@@ -385,18 +525,18 @@ public void onTouch_withTouchUp_whenVideoLessThan16Seconds_andClickAfterEnd_shou
                 bundleCaptor.capture()
         );
 
-        assertThat(bundleCaptor.getValue().get(DESTINATION_URL_KEY)).isEqualTo("clickThrough");
+        assertThat(bundleCaptor.getValue().get(DESTINATION_URL_KEY)).isEqualTo(CLICKTHROUGH_URL);
     }
 
     @Test
     public void onTouch_withTouchUp_whenVideoLongerThan16Seconds_andClickBefore5Seconds_shouldDoNothing() throws Exception {
-        stub(mediaPlayer.getDuration()).toReturn(100000);
-        stub(mediaPlayer.getCurrentPosition()).toReturn(4999);
+        stub(mockMediaPlayer.getDuration()).toReturn(100000);
+        stub(mockMediaPlayer.getCurrentPosition()).toReturn(4999);
 
         initializeSubject();
         subject.onResume();
 
-        setMediaPlayer(mediaPlayer);
+        setMockMediaPlayer(mockMediaPlayer);
         getShadowVideoView().getOnPreparedListener().onPrepared(null);
 
         Robolectric.getUiThreadScheduler().unPause();
@@ -409,13 +549,13 @@ public void onTouch_withTouchUp_whenVideoLongerThan16Seconds_andClickBefore5Seco
 
     @Test
     public void onTouch_withTouchUp_whenVideoLongerThan16Seconds_andClickAfter5Seconds_shouldStartMoPubBrowser() throws Exception {
-        stub(mediaPlayer.getDuration()).toReturn(100000);
-        stub(mediaPlayer.getCurrentPosition()).toReturn(5001);
+        stub(mockMediaPlayer.getDuration()).toReturn(100000);
+        stub(mockMediaPlayer.getCurrentPosition()).toReturn(5001);
 
         initializeSubject();
         subject.onResume();
 
-        setMediaPlayer(mediaPlayer);
+        setMockMediaPlayer(mockMediaPlayer);
         getShadowVideoView().getOnPreparedListener().onPrepared(null);
 
         Robolectric.getUiThreadScheduler().unPause();
@@ -429,7 +569,7 @@ public void onTouch_withTouchUp_whenVideoLongerThan16Seconds_andClickAfter5Secon
                 bundleCaptor.capture()
         );
 
-        assertThat(bundleCaptor.getValue().get(DESTINATION_URL_KEY)).isEqualTo("clickThrough");
+        assertThat(bundleCaptor.getValue().get(DESTINATION_URL_KEY)).isEqualTo(CLICKTHROUGH_URL);
     }
 
     @Test
@@ -444,11 +584,8 @@ public void onTouch_whenCloseButtonVisible_shouldPingClickThroughTrackers() thro
         subject.setCloseButtonVisible(true);
 
         getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(0, 0));
-        Robolectric.getUiThreadScheduler().unPause();
-        Robolectric.getBackgroundScheduler().unPause();
-        Thread.sleep(NETWORK_DELAY);
-
-        assertHttpRequestsMade(expectedUserAgent, "click_1", "click_2");
+        verify(mockRequestQueue).add(argThat(isUrl("click_1")));
+        verify(mockRequestQueue).add(argThat(isUrl("click_2")));
     }
 
     @Test
@@ -463,9 +600,6 @@ public void onTouch_whenCloseButtonNotVisible_shouldNotPingClickThroughTrackers(
         subject.setCloseButtonVisible(false);
 
         getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(0, 0));
-        Robolectric.getBackgroundScheduler().unPause();
-        Thread.sleep(NETWORK_DELAY);
-
         assertThat(Robolectric.httpRequestWasMade()).isFalse();
     }
 
@@ -493,13 +627,10 @@ public void onTouch_withActionTouchDown_shouldConsumeMotionEvent() throws Except
     public void onPrepared_whenDurationIsLessThanMaxVideoDurationForCloseButton_shouldSetShowCloseButtonDelayToDuration() throws Exception {
         initializeSubject();
 
-        stub(mediaPlayer.getDuration()).toReturn(1000);
-        setMediaPlayer(mediaPlayer);
+        stub(mockMediaPlayer.getDuration()).toReturn(1000);
+        setMockMediaPlayer(mockMediaPlayer);
 
-        // this callback is typically called when the media filed is loaded and ready to play
-        // invoke this manually since we are using a mock url and don't want to wait
-        final OnPreparedListener onPreparedListener = getShadowVideoView().getOnPreparedListener();
-        onPreparedListener.onPrepared(null);
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
 
         assertThat(subject.getShowCloseButtonDelay()).isEqualTo(1000);
     }
@@ -508,12 +639,210 @@ public void onPrepared_whenDurationIsLessThanMaxVideoDurationForCloseButton_shou
     public void onPrepared_whenDurationIsGreaterThanMaxVideoDurationForCloseButton_shouldNotSetShowCloseButtonDelay() throws Exception {
         initializeSubject();
 
-        stub(mediaPlayer.getDuration()).toReturn(MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
-        setMediaPlayer(mediaPlayer);
+        stub(mockMediaPlayer.getDuration()).toReturn(MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
+        setMockMediaPlayer(mockMediaPlayer);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
+    }
+
+    @Test
+    public void onPrepared_whenPercentSkipOffsetSpecified_shouldSetShowCloseButtonDelayToSkipOffset() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("25%");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+
+        stub(mockMediaPlayer.getDuration()).toReturn(10 * 1000);
+        setMockMediaPlayer(mockMediaPlayer);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(2500);
+        assertThat(subject.getHasSkipOffset()).isTrue();
+    }
+
+    @Test
+    public void onPrepared_whenAbsoluteSkipOffsetSpecified_shouldSetShowCloseButtonDelayToSkipOffset() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("00:00:03");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+
+        stub(mockMediaPlayer.getDuration()).toReturn(10 * 1000);
+        setMockMediaPlayer(mockMediaPlayer);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(3000);
+        assertThat(subject.getHasSkipOffset()).isTrue();
+    }
+
+    @Test
+    public void onPrepared_whenAbsoluteSkipOffsetWithMillisecondsSpecified_shouldSetShowCloseButtonDelayToSkipOffset() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("00:00:03.141");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+
+        stub(mockMediaPlayer.getDuration()).toReturn(10 * 1000);
+        setMockMediaPlayer(mockMediaPlayer);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(3141);
+        assertThat(subject.getHasSkipOffset()).isTrue();
+    }
+
+    @Test
+    public void onPrepared_whenSkipOffsetIsNull_shouldNotSetShowCloseButtonDelay() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset(null);
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+
+        stub(mockMediaPlayer.getDuration()).toReturn(MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
+        setMockMediaPlayer(mockMediaPlayer);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
+        assertThat(subject.getHasSkipOffset()).isFalse();
+    }
+
+    @Test
+    public void onPrepared_whenSkipOffsetHasInvalidAbsoluteFormat_shouldNotSetShowCloseButtonDelay() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("123:4:56.7");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+
+        stub(mockMediaPlayer.getDuration()).toReturn(MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
+        setMockMediaPlayer(mockMediaPlayer);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
+        assertThat(subject.getHasSkipOffset()).isFalse();
+    }
+
+    @Test
+    public void onPrepared_whenSkipOffsetHasInvalidPercentFormat_shouldNotSetShowCloseButtonDelay() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("101%");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+
+        stub(mockMediaPlayer.getDuration()).toReturn(MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
+        setMockMediaPlayer(mockMediaPlayer);
 
         getShadowVideoView().getOnPreparedListener().onPrepared(null);
 
         assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
+        assertThat(subject.getHasSkipOffset()).isFalse();
+    }
+
+    @Test
+    public void onPrepared_whenSkipOffsetHasInvalidFractionalPercentFormat_shouldNotSetShowCloseButtonDelay() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("3.14%");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+
+        stub(mockMediaPlayer.getDuration()).toReturn(MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
+        setMockMediaPlayer(mockMediaPlayer);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
+        assertThat(subject.getHasSkipOffset()).isFalse();
+    }
+
+    @Test
+    public void onPrepared_whenSkipOffsetIsNegative_shouldNotSetShowCloseButtonDelay() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("-00:00:03");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+
+        stub(mockMediaPlayer.getDuration()).toReturn(MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
+        setMockMediaPlayer(mockMediaPlayer);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
+        assertThat(subject.getHasSkipOffset()).isFalse();
+    }
+
+    @Test
+    public void onPrepared_whenSkipOffsetIsZero_shouldSetShowCloseButtonDelayToZero() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("00:00:00");
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+
+        stub(mockMediaPlayer.getDuration()).toReturn(MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
+        setMockMediaPlayer(mockMediaPlayer);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(0);
+        assertThat(subject.getHasSkipOffset()).isTrue();
+    }
+
+    @Test
+    public void onPrepared_whenSkipOffsetIsLongerThanDurationForShortVideo_shouldNotSetShowCloseButtonDelay() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("00:00:11");   // 11s
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+
+        stub(mockMediaPlayer.getDuration()).toReturn(10 * 1000);    // 10s: short video
+        setMockMediaPlayer(mockMediaPlayer);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(10 * 1000);
+        assertThat(subject.getHasSkipOffset()).isFalse();
+    }
+
+    @Test
+    public void onPrepared_whenSkipOffsetIsLongerThanDurationForLongVideo_shouldNotSetShowCloseButtonDelay() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("00:00:21");   // 21s
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+
+        stub(mockMediaPlayer.getDuration()).toReturn(20 * 1000);    // 20s: long video
+        setMockMediaPlayer(mockMediaPlayer);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
+        assertThat(subject.getHasSkipOffset()).isFalse();
     }
 
     @Test
@@ -526,21 +855,57 @@ public void onCompletion_shouldMarkVideoAsFinished() throws Exception {
     }
 
     @Test
-    public void onCompletion_shouldPingCompletionTrackers() throws Exception {
+    public void onCompletion_whenAllTrackersTracked_whenNoPlaybackErrors_shouldPingCompletionTrackersOnlyOnce() throws Exception {
         VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
         vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        VastAbsoluteProgressTracker testTracker = new VastAbsoluteProgressTracker("testUrl", 123);
+        vastVideoConfiguration.addAbsoluteTrackers(Arrays.asList(testTracker));
         vastVideoConfiguration.addCompleteTrackers(Arrays.asList("complete_1", "complete_2"));
         bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
 
         initializeSubject();
+        testTracker.setTracked();
 
         getShadowVideoView().getOnCompletionListener().onCompletion(null);
+        verify(mockRequestQueue).add(argThat(isUrl("complete_1")));
+        verify(mockRequestQueue).add(argThat(isUrl("complete_2")));
 
-        Robolectric.getUiThreadScheduler().unPause();
-        Robolectric.getBackgroundScheduler().unPause();
-        Thread.sleep(NETWORK_DELAY);
+        // Completion trackers should still only be hit once
+        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+        verify(mockRequestQueue).add(argThat(isUrl("complete_1")));
+        verify(mockRequestQueue).add(argThat(isUrl("complete_2")));
+    }
+
+    @Test
+    public void onCompletion_whenSomeTrackersRemain_shouldNotPingCompletionTrackers() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.addCompleteTrackers(Arrays.asList("complete_1", "complete_2"));
+        VastAbsoluteProgressTracker testTracker = new VastAbsoluteProgressTracker("testUrl", 123);
+        // Never track the testTracker, so completion trackers should not be fired.
+        vastVideoConfiguration.addAbsoluteTrackers(Arrays.asList(testTracker));
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        initializeSubject();
+
+        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+        verify(mockRequestQueue, never()).add(argThat(isUrl("complete_1")));
+        verify(mockRequestQueue, never()).add(argThat(isUrl("complete_2")));
+    }
+
+    @Test
+    public void onCompletion_whenPlaybackError_shouldNotPingCompletionTrackers() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.addCompleteTrackers(Arrays.asList("complete_1", "complete_2"));
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
 
-        assertHttpRequestsMade(expectedUserAgent, "complete_1", "complete_2");
+        initializeSubject();
+        subject.setVideoError();
+
+        getShadowVideoView().getOnCompletionListener().onCompletion(null);
+        verify(mockRequestQueue, never()).add(argThat(isUrl("complete_1")));
+        verify(mockRequestQueue, never()).add(argThat(isUrl("complete_2")));
     }
 
     @Test
@@ -613,6 +978,7 @@ public void onError_shouldFireVideoErrorAndReturnFalse() throws Exception {
 
         assertThat(result).isFalse();
         verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
+        assertThat(subject.getVideoError()).isTrue();
     }
 
     @Test
@@ -724,221 +1090,262 @@ public void retryMediaPlayer_withExceptionThrown_shouldReturnFalseAndIncrementRe
         assertThat(subject.getVideoRetries()).isEqualTo(1);
     }
 
+    @Test
+    public void handleClick_shouldMakeRequestsToClickTrackingUrls() {
+        initializeSubject();
+        subject.handleClick(Arrays.asList("clicktracker1", "clicktracker2"), CLICKTHROUGH_URL);
+
+        verify(mockRequestQueue).add(argThat(isUrl("clicktracker1")));
+        verify(mockRequestQueue).add(argThat(isUrl("clicktracker2")));
+    }
+
+    @Test
+    public void handleClick_withNullClickTrackers_shouldNotThrowAnException() {
+        initializeSubject();
+        subject.handleClick(null, CLICKTHROUGH_URL);
+
+        // pass
+    }
+
+    @Test
+    public void handleClick_withNullClickThroughUrl_shouldNotBroadcastClickOrOpenNewActivity() {
+        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_CLICK, testBroadcastIdentifier);
+
+        initializeSubject();
+        subject.handleClick(Arrays.asList("clicktracker"), null);
+
+        Robolectric.getUiThreadScheduler().unPause();
+        verify(broadcastReceiver, never()).onReceive(any(Context.class), eq(expectedIntent));
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+    }
+
+    @Test
+    public void handleClick_withMoPubNativeBrowserClickThroughUrl_shouldOpenExternalBrowser() {
+        initializeSubject();
+
+        subject.handleClick(Arrays.asList("clicktracker"),
+                "mopubnativebrowser://navigate?url=http%3A%2F%2Fwww.mopub.com");
+
+        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(intent.getDataString()).isEqualTo("http://www.mopub.com");
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
+    }
+
+    @Test
+    public void handleClick_withMalformedMoPubNativeBrowserClickThroughUrl_shouldNotOpenANewActivity() {
+        initializeSubject();
+
+        // url2 is an invalid query parameter
+        subject.handleClick(Arrays.asList("clicktracker"),
+                "mopubnativebrowser://navigate?url2=http%3A%2F%2Fwww.mopub.com");
+
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+    }
+
+    @Test
+    public void handleClick_withAboutBlankClickThroughUrl_shouldFailSilently() {
+        initializeSubject();
+
+        subject.handleClick(Arrays.asList("clicktracker"), "about:blank");
+
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+    }
+
     @Test
     public void videoProgressCheckerRunnableRun_shouldFireOffAllProgressTrackers() throws Exception {
-        stub(mediaPlayer.getDuration()).toReturn(9001);
-        stub(mediaPlayer.getCurrentPosition()).toReturn(9002);
+        stub(mockMediaPlayer.getDuration()).toReturn(9002);
+        stub(mockMediaPlayer.getCurrentPosition()).toReturn(9002);
 
         VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
         vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addFirstQuartileTrackers(Arrays.asList("first"));
-        vastVideoConfiguration.addMidpointTrackers(Arrays.asList("second"));
-        vastVideoConfiguration.addThirdQuartileTrackers(Arrays.asList("third"));
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("first", 0.25f),
+                new VastFractionalProgressTracker("second", 0.5f),
+                new VastFractionalProgressTracker("third", 0.75f)));
+
         bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
 
         initializeSubject();
         subject.onResume();
-        setMediaPlayer(mediaPlayer);
+        setMockMediaPlayer(mockMediaPlayer);
 
         // this runs the videoProgressChecker
         Robolectric.getUiThreadScheduler().unPause();
-        Robolectric.getBackgroundScheduler().unPause();
-        Thread.sleep(NETWORK_DELAY);
 
-        assertHttpRequestsMade(expectedUserAgent, "first", "second", "third");
+        verify(mockRequestQueue).add(argThat(isUrl("first")));
+        verify(mockRequestQueue).add(argThat(isUrl("second")));
+        verify(mockRequestQueue).add(argThat(isUrl("third")));
     }
 
     @Test
     public void videoProgressCheckerRunnableRun_whenDurationIsInvalid_shouldNotMakeAnyNetworkCalls() throws Exception {
-        stub(mediaPlayer.getDuration()).toReturn(0);
-        stub(mediaPlayer.getCurrentPosition()).toReturn(100);
+        stub(mockMediaPlayer.getDuration()).toReturn(0);
+        stub(mockMediaPlayer.getCurrentPosition()).toReturn(100);
 
         VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
         vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
         bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
 
         initializeSubject();
-        setMediaPlayer(mediaPlayer);
+        setMockMediaPlayer(mockMediaPlayer);
         subject.onResume();
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
 
         Robolectric.getUiThreadScheduler().runOneTask();
         // make sure the repeated task hasn't run yet
         assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
-
-        Thread.sleep(NETWORK_DELAY);
-
-        assertThat(Robolectric.httpRequestWasMade()).isFalse();
+        verifyZeroInteractions(mockRequestQueue);
     }
 
     @Test
-    public void videoProgressCheckerRunnableRun_whenCurrentTimeLessThanOneSecond_shouldNotFireStartTracker() throws Exception {
+    public void videoProgressCheckerRunnableRun_whenCurrentTimeLessThanTwoSeconds_shouldNotFireStartTracker() throws Exception {
         VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
         vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addStartTrackers(Arrays.asList("start"));
+        vastVideoConfiguration.addAbsoluteTrackers(Arrays.asList(new VastAbsoluteProgressTracker("start", 2000)));
         bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
 
-        stub(mediaPlayer.getDuration()).toReturn(100000);
-        stub(mediaPlayer.getCurrentPosition()).toReturn(999);
+        stub(mockMediaPlayer.getDuration()).toReturn(100000);
+        stub(mockMediaPlayer.getCurrentPosition()).toReturn(1999);
 
         initializeSubject();
         subject.onResume();
-        setMediaPlayer(mediaPlayer);
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
+        setMockMediaPlayer(mockMediaPlayer);
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
 
         Robolectric.getUiThreadScheduler().runOneTask();
         // make sure the repeated task hasn't run yet
         assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
 
-        Thread.sleep(NETWORK_DELAY);
-
         // Since it has not yet been a second, we expect that the start tracker has not been fired
-        assertHttpRequestsMade(expectedUserAgent);
-        Robolectric.getFakeHttpLayer().clearRequestInfos();
+        verifyZeroInteractions(mockRequestQueue);
 
         // run checker another time
         assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
         Robolectric.getUiThreadScheduler().runOneTask();
 
-        Thread.sleep(NETWORK_DELAY);
-
-        assertThat(Robolectric.httpRequestWasMade()).isFalse();
+        verifyZeroInteractions(mockRequestQueue);
     }
 
     @Test
-    public void videoProgressCheckerRunnableRun_whenCurrentTimeGreaterThanOneSecond_shouldFireStartTracker() throws Exception {
+    public void videoProgressCheckerRunnableRun_whenCurrentTimeGreaterThanTwoSeconds_shouldFireStartTracker() throws Exception {
         VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
         vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addStartTrackers(Arrays.asList("start"));
+        vastVideoConfiguration.addAbsoluteTrackers(Arrays.asList(new VastAbsoluteProgressTracker("start", 2000)));
+        vastVideoConfiguration.addAbsoluteTrackers(Arrays.asList(new VastAbsoluteProgressTracker("later", 3000)));
         bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
 
-        stub(mediaPlayer.getDuration()).toReturn(100000);
-        stub(mediaPlayer.getCurrentPosition()).toReturn(1000);
+        stub(mockMediaPlayer.getDuration()).toReturn(100000);
+        stub(mockMediaPlayer.getCurrentPosition()).toReturn(2000);
 
         initializeSubject();
         subject.onResume();
-        setMediaPlayer(mediaPlayer);
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
+        setMockMediaPlayer(mockMediaPlayer);
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
 
         Robolectric.getUiThreadScheduler().unPause();
-        Robolectric.getBackgroundScheduler().unPause();
 
-        Thread.sleep(NETWORK_DELAY);
-
-        assertHttpRequestsMade(expectedUserAgent, "start");
-        Robolectric.getFakeHttpLayer().clearRequestInfos();
+        verify(mockRequestQueue).add(argThat(isUrl("start")));
 
         // run checker another time
         assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
         Robolectric.getUiThreadScheduler().runOneTask();
 
-        Thread.sleep(NETWORK_DELAY);
-
-        assertThat(Robolectric.httpRequestWasMade()).isFalse();
+        verifyNoMoreInteractions(mockRequestQueue);
     }
 
     @Test
     public void videoProgressCheckerRunnableRun_whenProgressIsPastFirstQuartile_shouldOnlyPingFirstQuartileTrackersOnce() throws Exception {
-        stub(mediaPlayer.getDuration()).toReturn(100);
-        stub(mediaPlayer.getCurrentPosition()).toReturn(26);
+        stub(mockMediaPlayer.getDuration()).toReturn(100);
+        stub(mockMediaPlayer.getCurrentPosition()).toReturn(26);
 
         VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
         vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addFirstQuartileTrackers(Arrays.asList("first"));
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("first", 0.25f)));
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("don't call", 0.28f)));
         bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
 
         initializeSubject();
         subject.onResume();
-        setMediaPlayer(mediaPlayer);
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
+        setMockMediaPlayer(mockMediaPlayer);
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
 
         Robolectric.getUiThreadScheduler().unPause();
-        Robolectric.getBackgroundScheduler().unPause();
-        Thread.sleep(NETWORK_DELAY);
 
-        assertHttpRequestsMade(expectedUserAgent, "first");
-        Robolectric.getFakeHttpLayer().clearRequestInfos();
+        verify(mockRequestQueue).add(argThat(isUrl("first")));
 
         // run checker another time
         Robolectric.getUiThreadScheduler().runOneTask();
-        Thread.sleep(NETWORK_DELAY);
 
-        assertThat(Robolectric.httpRequestWasMade()).isFalse();
+        verifyNoMoreInteractions(mockRequestQueue);
     }
 
     @Test
     public void videoProgressCheckerRunnableRun_whenProgressIsPastMidQuartile_shouldPingFirstQuartileTrackers_andMidQuartileTrackersBothOnlyOnce() throws Exception {
-        stub(mediaPlayer.getDuration()).toReturn(100);
-        stub(mediaPlayer.getCurrentPosition()).toReturn(51);
+        stub(mockMediaPlayer.getDuration()).toReturn(100);
+        stub(mockMediaPlayer.getCurrentPosition()).toReturn(51);
 
         VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
         vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addFirstQuartileTrackers(Arrays.asList("first"));
-        vastVideoConfiguration.addMidpointTrackers(Arrays.asList("second"));
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("first", 0.25f)));
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("second", 0.5f)));
         bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
 
         initializeSubject();
         subject.onResume();
-        setMediaPlayer(mediaPlayer);
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
+        setMockMediaPlayer(mockMediaPlayer);
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
 
         Robolectric.getUiThreadScheduler().unPause();
-        Robolectric.getBackgroundScheduler().unPause();
-        Thread.sleep(NETWORK_DELAY);
 
-        assertHttpRequestsMade(expectedUserAgent, "first", "second");
-        Robolectric.getFakeHttpLayer().clearRequestInfos();
+        verify(mockRequestQueue).add(argThat(isUrl("first")));
+        verify(mockRequestQueue).add(argThat(isUrl("second")));
 
         Robolectric.getUiThreadScheduler().runOneTask();
-        Thread.sleep(NETWORK_DELAY);
 
-        assertThat(Robolectric.httpRequestWasMade()).isFalse();
+        verifyNoMoreInteractions(mockRequestQueue);
     }
 
     @Test
     public void videoProgressCheckerRunnableRun_whenProgressIsPastThirdQuartile_shouldPingFirstQuartileTrackers_andMidQuartileTrackers_andThirdQuartileTrackersAllOnlyOnce() throws Exception {
-        stub(mediaPlayer.getDuration()).toReturn(100);
-        stub(mediaPlayer.getCurrentPosition()).toReturn(76);
+        stub(mockMediaPlayer.getDuration()).toReturn(100);
+        stub(mockMediaPlayer.getCurrentPosition()).toReturn(76);
 
         VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
         vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addFirstQuartileTrackers(Arrays.asList("first"));
-        vastVideoConfiguration.addMidpointTrackers(Arrays.asList("second"));
-        vastVideoConfiguration.addThirdQuartileTrackers(Arrays.asList("third"));
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("first", 0.25f)));
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("second", 0.5f)));
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("third", 0.75f)));
         bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
 
         initializeSubject();
         subject.onResume();
-        setMediaPlayer(mediaPlayer);
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(2);
+        setMockMediaPlayer(mockMediaPlayer);
+        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
 
         Robolectric.getUiThreadScheduler().unPause();
-        Robolectric.getBackgroundScheduler().unPause();
-        Thread.sleep(NETWORK_DELAY);
 
-        assertHttpRequestsMade(expectedUserAgent, "first", "second", "third");
-        Robolectric.getFakeHttpLayer().clearRequestInfos();
+        verify(mockRequestQueue).add(argThat(isUrl("first")));
+        verify(mockRequestQueue).add(argThat(isUrl("second")));
+        verify(mockRequestQueue).add(argThat(isUrl("third")));
 
         Robolectric.getUiThreadScheduler().runOneTask();
-        Thread.sleep(NETWORK_DELAY);
 
-        assertThat(Robolectric.httpRequestWasMade()).isFalse();
+        verifyNoMoreInteractions(mockRequestQueue);
     }
 
     @Test
     public void videoProgressCheckerRunnableRun_asVideoPlays_shouldPingAllThreeTrackersIndividuallyOnce() throws Exception {
-        stub(mediaPlayer.getDuration()).toReturn(100);
+        stub(mockMediaPlayer.getDuration()).toReturn(100);
 
         VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
         vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfiguration.addFirstQuartileTrackers(Arrays.asList("first"));
-        vastVideoConfiguration.addMidpointTrackers(Arrays.asList("second"));
-        vastVideoConfiguration.addThirdQuartileTrackers(Arrays.asList("third"));
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("first", 0.25f)));
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("second", 0.5f)));
+        vastVideoConfiguration.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("third", 0.75f)));
         bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
 
         initializeSubject();
         subject.onResume();
-        setMediaPlayer(mediaPlayer);
+        setMockMediaPlayer(mockMediaPlayer);
 
         // before any trackers are fired
         fastForwardMediaPlayerAndAssertRequestMade(1);
@@ -966,12 +1373,12 @@ public void videoProgressCheckerRunnableRun_asVideoPlays_shouldPingAllThreeTrack
 
     @Test
     public void videoProgressCheckerRunnableRun_whenCurrentPositionIsGreaterThanShowCloseButtonDelay_shouldShowCloseButton() throws Exception {
-        stub(mediaPlayer.getDuration()).toReturn(5002);
-        stub(mediaPlayer.getCurrentPosition()).toReturn(5001);
+        stub(mockMediaPlayer.getDuration()).toReturn(5002);
+        stub(mockMediaPlayer.getCurrentPosition()).toReturn(5001);
 
         initializeSubject();
         subject.onResume();
-        setMediaPlayer(mediaPlayer);
+        setMockMediaPlayer(mockMediaPlayer);
 
         assertThat(subject.isShowCloseButtonEventFired()).isFalse();
         Robolectric.getUiThreadScheduler().unPause();
@@ -979,6 +1386,59 @@ public void videoProgressCheckerRunnableRun_whenCurrentPositionIsGreaterThanShow
         assertThat(subject.isShowCloseButtonEventFired()).isTrue();
     }
 
+    @Test
+    public void videoProgressCheckerRunnableRun_whenCurrentPositionIsGreaterThanSkipOffset_shouldShowCloseButton() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("25%");    // skipoffset is at 2.5s
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        // duration is 10s
+        stub(mockMediaPlayer.getDuration()).toReturn(10 * 1000);
+
+        // current position is 1 ms after skipoffset
+        stub(mockMediaPlayer.getCurrentPosition()).toReturn(2501);
+
+        initializeSubject();
+        subject.onResume();
+        setMockMediaPlayer(mockMediaPlayer);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(2500);
+        assertThat(subject.getHasSkipOffset()).isTrue();
+
+        assertThat(subject.isShowCloseButtonEventFired()).isFalse();
+        Robolectric.getUiThreadScheduler().unPause();
+
+        assertThat(subject.isShowCloseButtonEventFired()).isTrue();
+    }
+
+    @Test
+    public void videoProgressCheckerRunnableRun_whenCurrentPositionIsLessThanSkipOffset_shouldNotShowCloseButton() throws Exception {
+        VastVideoConfiguration vastVideoConfiguration = new VastVideoConfiguration();
+        vastVideoConfiguration.setDiskMediaFileUrl("disk_video_path");
+        vastVideoConfiguration.setSkipOffset("00:00:03");   // skipoffset is at 3s
+        bundle.putSerializable(VAST_VIDEO_CONFIGURATION, vastVideoConfiguration);
+
+        stub(mockMediaPlayer.getDuration()).toReturn(10 * 1000);    // duration is 10s
+        stub(mockMediaPlayer.getCurrentPosition()).toReturn(2999);  // current position is 1ms before skipoffset
+
+        initializeSubject();
+        subject.onResume();
+        setMockMediaPlayer(mockMediaPlayer);
+
+        getShadowVideoView().getOnPreparedListener().onPrepared(null);
+
+        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(3000);
+        assertThat(subject.getHasSkipOffset()).isTrue();
+
+        assertThat(subject.isShowCloseButtonEventFired()).isFalse();
+        Robolectric.getUiThreadScheduler().unPause();
+
+        assertThat(subject.isShowCloseButtonEventFired()).isFalse();
+    }
+
     @Test
     public void onPause_shouldStopProgressChecker() throws Exception {
         initializeSubject();
@@ -1040,16 +1500,16 @@ public void onResume_shouldResetVideoRetryCountToZero() throws Exception {
     @Ignore("pending")
     @Test
     public void onResume_shouldSeekToPrePausedPosition() throws Exception {
-        stub(mediaPlayer.getDuration()).toReturn(10000);
-        stub(mediaPlayer.getCurrentPosition()).toReturn(7000);
+        stub(mockMediaPlayer.getDuration()).toReturn(10000);
+        stub(mockMediaPlayer.getCurrentPosition()).toReturn(7000);
 
         initializeSubject();
-        setMediaPlayer(mediaPlayer);
+        setMockMediaPlayer(mockMediaPlayer);
         final VideoView videoView = spy(subject.getVideoView());
 
         subject.onPause();
 
-        stub(mediaPlayer.getCurrentPosition()).toReturn(1000);
+        stub(mockMediaPlayer.getCurrentPosition()).toReturn(1000);
 
         subject.onResume();
         verify(videoView).seekTo(eq(7000));
@@ -1071,13 +1531,29 @@ public void backButtonEnabled_whenCloseButtonIsVisible_shouldReturnTrue() throws
         assertThat(subject.backButtonEnabled()).isTrue();
     }
 
+    @Test
+    public void onClickCloseButton_whenCloseButtonIsVisible_shouldFireCloseTrackers() {
+        initializeSubject();
+
+        subject.setCloseButtonVisible(true);
+
+        // We don't have direct access to the CloseButtonWidget's close event, so we manually
+        // invoke its onTouchListener's onTouch callback with a fake MotionEvent.ACTION_UP action.
+        View.OnTouchListener closeButtonOnTouchListener =
+                shadowOf(getVastVideoToolbar().getCloseButtonWidget()).getOnTouchListener();
+        closeButtonOnTouchListener.onTouch(null, GestureUtils.createActionUp(0, 0));
+
+        verify(mockRequestQueue).add(argThat(isUrl("close")));
+        verify(mockRequestQueue).add(argThat(isUrl("skip")));
+    }
+
     private void initializeSubject() {
         subject = new VastVideoViewController(context, bundle, testBroadcastIdentifier, baseVideoViewControllerListener);
     }
 
-    private void setMediaPlayer(final MediaPlayer mediaPlayer) throws IllegalAccessException {
+    private void setMockMediaPlayer(final MediaPlayer mockMediaPlayer) throws IllegalAccessException {
         final VideoView videoView = subject.getVideoView();
-        ReflectionUtils.setVariableValueInObject(videoView, "mMediaPlayer", mediaPlayer);
+        ReflectionUtils.setVariableValueInObject(videoView, "mMediaPlayer", mockMediaPlayer);
 
         int state = (Integer) ReflectionUtils.getValueIncludingSuperclasses("STATE_PLAYING", videoView);
 
@@ -1085,15 +1561,13 @@ private void setMediaPlayer(final MediaPlayer mediaPlayer) throws IllegalAccessE
     }
 
     private void fastForwardMediaPlayerAndAssertRequestMade(int time, String... urls) throws Exception {
-        stub(mediaPlayer.getCurrentPosition()).toReturn(time);
+        stub(mockMediaPlayer.getCurrentPosition()).toReturn(time);
         Robolectric.getUiThreadScheduler().unPause();
         Robolectric.getBackgroundScheduler().unPause();
         Thread.sleep(NETWORK_DELAY);
 
-        if (urls == null) {
-            assertThat(Robolectric.getNextSentHttpRequest()).isNull();
-        } else {
-            assertHttpRequestsMade(expectedUserAgent, urls);
+        for (String url : urls) {
+            verify(mockRequestQueue).add(argThat(isUrl(url)));
         }
 
         Robolectric.getFakeHttpLayer().clearRequestInfos();
@@ -1116,4 +1590,25 @@ private VastVideoToolbar getVastVideoToolbar() {
     private ShadowVideoView getShadowVideoView() {
         return shadowOf(subject.getVideoView());
     }
+
+    public static void assertHttpRequestsMade(final String userAgent, final String... urls) {
+        final int numberOfReceivedHttpRequests = Robolectric.getFakeHttpLayer().getSentHttpRequestInfos().size();
+        assertThat(numberOfReceivedHttpRequests).isEqualTo(urls.length);
+
+        for (final String url : urls) {
+            assertThat(Robolectric.httpRequestWasMade(url)).isTrue();
+        }
+
+        if (userAgent != null) {
+            while (true) {
+                final HttpRequest httpRequest = Robolectric.getNextSentHttpRequest();
+                if (httpRequest == null) {
+                    break;
+                }
+
+                assertThat(httpRequest.getFirstHeader(USER_AGENT.getKey()).getValue())
+                        .isEqualTo(userAgent);
+            }
+        }
+    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/ViewGestureDetectorTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/ViewGestureDetectorTest.java
index cbc01aae..0c0935ef 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/ViewGestureDetectorTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/ViewGestureDetectorTest.java
@@ -4,11 +4,13 @@
 import android.view.MotionEvent;
 import android.view.View;
 
+import com.mopub.common.AdReport;
 import com.mopub.common.test.support.SdkTestRunner;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
 import org.robolectric.shadows.ShadowGestureDetector;
 
 import static com.mopub.mobileads.ViewGestureDetector.UserClickListener;
@@ -25,7 +27,7 @@
     private ViewGestureDetector subject;
     private AdAlertGestureListener adAlertGestureListener;
     private View view;
-    private AdConfiguration adConfiguration;
+    @Mock AdReport mockAdReport;
 
     @Before
     public void setUp() throws Exception {
@@ -35,15 +37,14 @@ public void setUp() throws Exception {
         stub(view.getHeight()).toReturn(50);
 
         adAlertGestureListener = mock(AdAlertGestureListener.class);
-        adConfiguration = mock(AdConfiguration.class);
 
-        subject = new ViewGestureDetector(context, view, adConfiguration);
+        subject = new ViewGestureDetector(context, view, mockAdReport);
         subject.setAdAlertGestureListener(adAlertGestureListener);
     }
 
     @Test
     public void constructor_shouldDisableLongPressAndSetGestureListener() throws Exception {
-        subject = new ViewGestureDetector(context, view, adConfiguration);
+        subject = new ViewGestureDetector(context, view, mockAdReport);
 
         ShadowGestureDetector shadowGestureDetector = shadowOf(subject);
 
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/WebViewAdUrlGeneratorTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/WebViewAdUrlGeneratorTest.java
index 7fa291fc..b373590a 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/WebViewAdUrlGeneratorTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/WebViewAdUrlGeneratorTest.java
@@ -3,7 +3,10 @@
 import android.app.Activity;
 import android.content.Context;
 import android.content.res.Configuration;
+import android.content.res.Resources;
+import android.graphics.Point;
 import android.location.Location;
+import android.location.LocationManager;
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
 import android.net.Uri;
@@ -11,26 +14,33 @@
 import android.provider.Settings;
 import android.telephony.TelephonyManager;
 import android.text.TextUtils;
+import android.util.DisplayMetrics;
+import android.view.Display;
+import android.view.WindowManager;
 
-import com.mopub.common.AdUrlGenerator;
 import com.mopub.common.ClientMetadata;
 import com.mopub.common.GpsHelper;
 import com.mopub.common.GpsHelperTest;
 import com.mopub.common.MoPub;
-import com.mopub.common.SharedPreferencesHelper;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.common.util.Reflection.MethodBuilder;
 import com.mopub.common.util.Utils;
 import com.mopub.common.util.test.support.TestMethodBuilderFactory;
 import com.mopub.mobileads.test.support.MoPubShadowTelephonyManager;
+import com.mopub.mraid.MraidNativeCommandHandler;
+import com.mopub.network.Networking;
+import com.mopub.network.PlayServicesUrlRewriter;
 
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.mockito.Mockito;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowConnectivityManager;
+import org.robolectric.shadows.ShadowLocationManager;
 import org.robolectric.shadows.ShadowNetworkInfo;
 
 import static android.Manifest.permission.ACCESS_NETWORK_STATE;
@@ -43,13 +53,13 @@
 import static android.net.ConnectivityManager.TYPE_MOBILE_SUPL;
 import static android.net.ConnectivityManager.TYPE_WIFI;
 import static android.telephony.TelephonyManager.NETWORK_TYPE_UNKNOWN;
-import static com.mopub.common.AdUrlGenerator.TwitterAppInstalledStatus;
 import static com.mopub.common.ClientMetadata.MoPubNetworkType;
-import static com.mopub.common.util.Strings.isEmpty;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.when;
 import static org.robolectric.Robolectric.application;
 import static org.robolectric.Robolectric.shadowOf;
@@ -58,8 +68,12 @@
 @Config(shadows = {MoPubShadowTelephonyManager.class})
 public class WebViewAdUrlGeneratorTest {
 
-    private WebViewAdUrlGenerator subject;
     private static final String TEST_UDID = "20b013c721c";
+    private static final int TEST_SCREEN_WIDTH = 42;
+    private static final int TEST_SCREEN_HEIGHT = 1337;
+    private static final float TEST_DENSITY = 1.0f;
+
+    private WebViewAdUrlGenerator subject;
     private String expectedUdid;
     private Configuration configuration;
     private MoPubShadowTelephonyManager shadowTelephonyManager;
@@ -69,20 +83,51 @@
 
     @Before
     public void setup() {
-        context = new Activity();
+        context = spy(Robolectric.buildActivity(Activity.class).create().get());
         shadowOf(context).grantPermissions(ACCESS_NETWORK_STATE);
-        subject = new WebViewAdUrlGenerator(context);
+
+        // Set the expected screen dimensions to arbitrary numbers
+        final Resources spyResources = spy(context.getResources());
+        final DisplayMetrics mockDisplayMetrics = mock(DisplayMetrics.class);
+        mockDisplayMetrics.widthPixels = TEST_SCREEN_WIDTH;
+        mockDisplayMetrics.heightPixels = TEST_SCREEN_HEIGHT;
+        mockDisplayMetrics.density = TEST_DENSITY;
+        when(spyResources.getDisplayMetrics()).thenReturn(mockDisplayMetrics);
+        when(context.getResources()).thenReturn(spyResources);
+
+        // Only do this on Android 17+ because getRealSize doesn't exist before then.
+        // This is the default pathway.
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
+            final WindowManager mockWindowManager = mock(WindowManager.class);
+            final Display mockDisplay = mock(Display.class);
+            doAnswer(new Answer() {
+                @Override
+                public Object answer(final InvocationOnMock invocationOnMock) throws Throwable {
+                    final Point point = (Point) invocationOnMock.getArguments()[0];
+                    point.x = TEST_SCREEN_WIDTH;
+                    point.y = TEST_SCREEN_HEIGHT;
+                    return null;
+                }
+            }).when(mockDisplay).getRealSize(any(Point.class));
+            when(mockWindowManager.getDefaultDisplay()).thenReturn(mockDisplay);
+            final Context spyApplicationContext = spy(context.getApplicationContext());
+            when(spyApplicationContext.getSystemService(Context.WINDOW_SERVICE)).thenReturn(mockWindowManager);
+            when(context.getApplicationContext()).thenReturn(spyApplicationContext);
+        }
+
+        subject = new WebViewAdUrlGenerator(context,
+                new MraidNativeCommandHandler().isStorePictureSupported(context));
         Settings.Secure.putString(application.getContentResolver(), Settings.Secure.ANDROID_ID, TEST_UDID);
         expectedUdid = "sha%3A" + Utils.sha1(TEST_UDID);
         configuration = application.getResources().getConfiguration();
         shadowTelephonyManager = (MoPubShadowTelephonyManager) shadowOf((TelephonyManager) application.getSystemService(Context.TELEPHONY_SERVICE));
         shadowConnectivityManager = shadowOf((ConnectivityManager) application.getSystemService(Context.CONNECTIVITY_SERVICE));
         methodBuilder = TestMethodBuilderFactory.getSingletonMock();
+        Networking.useHttps(false);
     }
 
     @After
     public void tearDown() throws Exception {
-        AdUrlGenerator.setTwitterAppInstalledStatus(TwitterAppInstalledStatus.UNKNOWN);
         reset(methodBuilder);
     }
 
@@ -95,6 +140,13 @@ public void generateAdUrl_shouldIncludeMinimumFields() throws Exception {
         assertThat(adUrl).isEqualTo(expectedAdUrl);
     }
 
+    @Test
+    public void generateAdUrl_withHttpsScheme() throws Exception {
+        Networking.useHttps(true);
+        String adUrl = generateMinimumUrlString();
+        assertThat(adUrl).startsWith("https://");
+    }
+
     @Test
     public void generateAdUrl_shouldRunMultipleTimes() throws Exception {
         String expectedAdUrl = new AdUrlBuilder(expectedUdid).build();
@@ -110,7 +162,7 @@ public void generateAdUrl_shouldIncludeAllFields() throws Exception {
         final String expectedAdUrl = new AdUrlBuilder(expectedUdid)
                 .withAdUnitId("adUnitId")
                 .withQuery("key%3Avalue")
-                .withLatLon("20.1%2C30.0", "1")
+                .withLatLon("20.1%2C30.0", "1", "101325")
                 .withMcc("123")
                 .withMnc("456")
                 .withCountryIso("expected%20country")
@@ -126,6 +178,7 @@ public void generateAdUrl_shouldIncludeAllFields() throws Exception {
         location.setLatitude(20.1);
         location.setLongitude(30.0);
         location.setAccuracy(1.23f); // should get rounded to "1"
+        location.setTime(System.currentTimeMillis() - 101325);
 
         String adUrl = subject
                 .withAdUnitId("adUnitId")
@@ -133,6 +186,9 @@ public void generateAdUrl_shouldIncludeAllFields() throws Exception {
                 .withLocation(location)
                 .generateUrlString("ads.mopub.com");
 
+        // Only compare the seconds since millis can be off
+        adUrl = adUrl.replaceFirst("llf=101[0-9]{3}", "llf=101325");
+
         assertThat(adUrl).isEqualTo(expectedAdUrl);
     }
 
@@ -283,45 +339,6 @@ public void generateAdUrl_whenNoNetworkPermission_shouldGenerateUnknownNetworkTy
         assertThat(adUrl).isEqualTo(urlBuilder.withNetworkType(MoPubNetworkType.UNKNOWN).build());
     }
 
-    @Test
-    public void generateAdUrl_whenTwitterIsNotInstalled_shouldProcessAndNotSetTwitterInstallStatusOnFirstRequest() throws Exception {
-        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
-
-        WebViewAdUrlGenerator spySubject = Mockito.spy(subject);
-        AdUrlGenerator.setTwitterAppInstalledStatus(TwitterAppInstalledStatus.UNKNOWN);
-        doReturn(TwitterAppInstalledStatus.NOT_INSTALLED).when(spySubject).getTwitterAppInstallStatus();
-
-        String adUrl = spySubject.generateUrlString("ads.mopub.com");
-
-        assertThat(adUrl).isEqualTo(urlBuilder.withTwitterAppInstalledStatus(TwitterAppInstalledStatus.NOT_INSTALLED).build());
-    }
-
-    @Test
-    public void generateAdUrl_whenTwitterIsInstalled_shouldProcessAndSetTwitterInstallStatusOnFirstRequest() throws Exception {
-        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
-
-        WebViewAdUrlGenerator spySubject = Mockito.spy(subject);
-        AdUrlGenerator.setTwitterAppInstalledStatus(TwitterAppInstalledStatus.UNKNOWN);
-        doReturn(TwitterAppInstalledStatus.INSTALLED).when(spySubject).getTwitterAppInstallStatus();
-
-        String adUrl = spySubject.generateUrlString("ads.mopub.com");
-
-        assertThat(adUrl).isEqualTo(urlBuilder.withTwitterAppInstalledStatus(TwitterAppInstalledStatus.INSTALLED).build());
-    }
-
-    @Test
-    public void generateAdUrl_shouldNotProcessTwitterInstallStatusIfStatusIsAlreadySet() throws Exception {
-        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
-
-        WebViewAdUrlGenerator spySubject = Mockito.spy(subject);
-        AdUrlGenerator.setTwitterAppInstalledStatus(TwitterAppInstalledStatus.NOT_INSTALLED);
-        doReturn(TwitterAppInstalledStatus.INSTALLED).when(spySubject).getTwitterAppInstallStatus();
-
-        String adUrl = spySubject.generateUrlString("ads.mopub.com");
-
-        assertThat(adUrl).isEqualTo(urlBuilder.withTwitterAppInstalledStatus(TwitterAppInstalledStatus.NOT_INSTALLED).build());
-    }
-
     @Test
     public void generateAdUrl_shouldTolerateNullActiveNetwork() throws Exception {
         AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
@@ -332,6 +349,8 @@ public void generateAdUrl_shouldTolerateNullActiveNetwork() throws Exception {
         assertThat(adUrl).isEqualTo(urlBuilder.withNetworkType(MoPubNetworkType.UNKNOWN).build());
     }
 
+
+
     @Test
     public void generateAdUrl_whenGooglePlayServicesIsLinkedAndAdInfoIsCached_shouldUseAdInfoParams() throws Exception {
         GpsHelper.setClassNamesForTesting();
@@ -340,11 +359,8 @@ public void generateAdUrl_whenGooglePlayServicesIsLinkedAndAdInfoIsCached_should
         when(methodBuilder.execute()).thenReturn(GpsHelper.GOOGLE_PLAY_SUCCESS_CODE);
 
         GpsHelperTest.TestAdInfo adInfo = new GpsHelperTest.TestAdInfo();
-        SharedPreferencesHelper.getSharedPreferences(context)
-                .edit()
-                .putString(GpsHelper.ADVERTISING_ID_KEY, adInfo.ADVERTISING_ID)
-                .putBoolean(GpsHelper.IS_LIMIT_AD_TRACKING_ENABLED_KEY, adInfo.LIMIT_AD_TRACKING_ENABLED)
-                .commit();
+        final ClientMetadata clientMetadata = ClientMetadata.getInstance(context);
+        clientMetadata.setAdvertisingInfo(adInfo.mAdId, adInfo.mLimitAdTrackingEnabled);
 
         expectedUdid = "ifa%3A" + adInfo.ADVERTISING_ID;
         String expectedAdUrl = new AdUrlBuilder(expectedUdid)
@@ -353,29 +369,138 @@ public void generateAdUrl_whenGooglePlayServicesIsLinkedAndAdInfoIsCached_should
         assertThat(generateMinimumUrlString()).isEqualTo(expectedAdUrl);
     }
 
+    @Test
+    public void generateAdUrl_whenLocationServiceGpsProviderHasMostRecentLocation_shouldUseLocationServiceValue() {
+        Location locationFromDeveloper = new Location("");
+        locationFromDeveloper.setLatitude(42);
+        locationFromDeveloper.setLongitude(-42);
+        locationFromDeveloper.setAccuracy(3.5f);
+        locationFromDeveloper.setTime(1000);
+
+        // Mock out the LocationManager's last known location to be more recent than the
+        // developer-supplied location.
+        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
+                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
+        Location locationFromSdk = new Location("");
+        locationFromSdk.setLatitude(37);
+        locationFromSdk.setLongitude(-122);
+        locationFromSdk.setAccuracy(5.0f);
+        locationFromSdk.setTime(2000);
+        shadowLocationManager.setLastKnownLocation(LocationManager.GPS_PROVIDER, locationFromSdk);
+
+        String adUrl = subject.withLocation(locationFromDeveloper)
+                .generateUrlString("ads.mopub.com");
+        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isEqualTo("37.0,-122.0");
+        assertThat(getParameterFromRequestUrl(adUrl, "lla")).isEqualTo("5");
+        assertThat(getParameterFromRequestUrl(adUrl, "llsdk")).isEqualTo("1");
+    }
+
+    @Test
+    public void generateAdUrl_whenDeveloperSuppliesMoreRecentLocationThanLocationService_shouldUseDeveloperSuppliedLocation() {
+        Location locationFromDeveloper = new Location("");
+        locationFromDeveloper.setLatitude(42);
+        locationFromDeveloper.setLongitude(-42);
+        locationFromDeveloper.setAccuracy(3.5f);
+        locationFromDeveloper.setTime(1000);
+
+        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
+                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
+
+        // Mock out the LocationManager's last known location to be older than the
+        // developer-supplied location.
+        Location olderLocation = new Location("");
+        olderLocation.setLatitude(40);
+        olderLocation.setLongitude(-105);
+        olderLocation.setAccuracy(8.0f);
+        olderLocation.setTime(500);
+        shadowLocationManager.setLastKnownLocation(LocationManager.GPS_PROVIDER, olderLocation);
+
+        String adUrl = subject.withLocation(locationFromDeveloper)
+                .generateUrlString("ads.mopub.com");
+        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isEqualTo("42.0,-42.0");
+        assertThat(getParameterFromRequestUrl(adUrl, "lla")).isEqualTo("3");
+        assertThat(getParameterFromRequestUrl(adUrl, "llsdk")).isEmpty();
+    }
+
+    @Test
+    public void generateAdUrl_whenLocationServiceNetworkProviderHasMostRecentLocation_shouldUseLocationServiceValue() {
+        Location locationFromDeveloper = new Location("");
+        locationFromDeveloper.setLatitude(42);
+        locationFromDeveloper.setLongitude(-42);
+        locationFromDeveloper.setAccuracy(3.5f);
+        locationFromDeveloper.setTime(1000);
+
+        // Mock out the LocationManager's last known location to be more recent than the
+        // developer-supplied location.
+        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
+                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
+        Location locationFromSdk = new Location("");
+        locationFromSdk.setLatitude(38);
+        locationFromSdk.setLongitude(-123);
+        locationFromSdk.setAccuracy(5.0f);
+        locationFromSdk.setTime(2000);
+        shadowLocationManager.setLastKnownLocation(LocationManager.NETWORK_PROVIDER,
+                locationFromSdk);
+
+        String adUrl = subject.withLocation(locationFromDeveloper)
+                .generateUrlString("ads.mopub.com");
+        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isEqualTo("38.0,-123.0");
+        assertThat(getParameterFromRequestUrl(adUrl, "lla")).isEqualTo("5");
+        assertThat(getParameterFromRequestUrl(adUrl, "llsdk")).isEqualTo("1");
+    }
+
+    @Test
+    public void generateAdUrl_withNullPackageName_withEmptyPackageName_shouldNotIncludeBundleKey() {
+        when(context.getPackageName()).thenReturn(null).thenReturn("");
+
+        final String adUrlNullPackageName = generateMinimumUrlString();
+        final String adUrlEmptyPackageName = generateMinimumUrlString();
+
+        assertThat(adUrlNullPackageName).doesNotContain("&bundle=");
+        assertThat(adUrlEmptyPackageName).doesNotContain("&bundle=");
+    }
+
     @Test
     public void enableLocationTracking_shouldIncludeLocationInUrl() {
         MoPub.setLocationAwareness(MoPub.LocationAwareness.NORMAL);
         String adUrl = generateMinimumUrlString();
-        assertThat(getLocationFromRequestUrl(adUrl)).isNotNull();
+        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isNotNull();
     }
 
     @Test
     public void disableLocationCollection_shouldNotIncludeLocationInUrl() {
         MoPub.setLocationAwareness(MoPub.LocationAwareness.DISABLED);
         String adUrl = generateMinimumUrlString();
-        assertThat(getLocationFromRequestUrl(adUrl)).isNullOrEmpty();
+        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isNullOrEmpty();
+    }
+
+    @Test
+    public void disableLocationCollection_whenLocationServiceHasMostRecentLocation_shouldNotIncludeLocationInUrl() {
+        MoPub.setLocationAwareness(MoPub.LocationAwareness.DISABLED);
+
+        // Mock out the LocationManager's last known location.
+        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
+                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
+        Location locationFromSdk = new Location("");
+        locationFromSdk.setLatitude(37);
+        locationFromSdk.setLongitude(-122);
+        locationFromSdk.setAccuracy(5.0f);
+        locationFromSdk.setTime(2000);
+        shadowLocationManager.setLastKnownLocation(LocationManager.GPS_PROVIDER, locationFromSdk);
+
+        String adUrl = generateMinimumUrlString();
+        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isNullOrEmpty();
     }
 
-    private String getLocationFromRequestUrl(String requestString) {
+    private String getParameterFromRequestUrl(String requestString, String key) {
         Uri requestUri = Uri.parse(requestString);
-        String location = requestUri.getQueryParameter("ll");
+        String parameter = requestUri.getQueryParameter(key);
 
-        if (TextUtils.isEmpty(location)) {
+        if (TextUtils.isEmpty(parameter)) {
             return "";
         }
 
-        return location;
+        return parameter;
     }
 
     private NetworkInfo createNetworkInfo(int type) {
@@ -394,13 +519,13 @@ private String generateMinimumUrlString() {
         private String query = "";
         private String latLon = "";
         private String locationAccuracy = "";
+        private String latLonLastUpdated = "";
         private String mnc = "";
         private String mcc = "";
         private String countryIso = "";
         private String carrierName = "";
         private String dnt = "";
         private MoPubNetworkType networkType = MoPubNetworkType.MOBILE;
-        private TwitterAppInstalledStatus twitterAppInstalledStatus = TwitterAppInstalledStatus.UNKNOWN;
         private int externalStoragePermission;
 
         public AdUrlBuilder(String expectedUdid) {
@@ -415,23 +540,26 @@ public String build() {
                     "&dn=" + Build.MANUFACTURER +
                     "%2C" + Build.MODEL +
                     "%2C" + Build.PRODUCT +
-                    "&udid=" + expectedUdid +
-                    paramIfNotEmpty("dnt", dnt) +
+                    "&bundle=" + "com.mopub.mobileads" +
+
                     paramIfNotEmpty("q", query) +
-                    (isEmpty(latLon) ? "" : "&ll=" + latLon + "&lla=" + locationAccuracy) +
+                    (TextUtils.isEmpty(latLon) ? "" :
+                            "&ll=" + latLon + "&lla=" + locationAccuracy + "&llf=" + latLonLastUpdated) +
                     "&z=-0700" +
                     "&o=u" +
+                    "&w=" + TEST_SCREEN_WIDTH +
+                    "&h=" + TEST_SCREEN_HEIGHT +
                     "&sc_a=1.0" +
-                    "&mr=1" +
                     paramIfNotEmpty("mcc", mcc) +
                     paramIfNotEmpty("mnc", mnc) +
                     paramIfNotEmpty("iso", countryIso) +
                     paramIfNotEmpty("cn", carrierName) +
                     "&ct=" + networkType +
                     "&av=1.0" +
-                    "&android_perms_ext_storage=" + externalStoragePermission +
-                    ((twitterAppInstalledStatus == TwitterAppInstalledStatus.INSTALLED) ? "&ts=1" : "");
-
+                    "&udid=" + PlayServicesUrlRewriter.UDID_TEMPLATE +
+                    "&dnt=" + PlayServicesUrlRewriter.DO_NOT_TRACK_TEMPLATE +
+                    "&mr=1" +
+                    "&android_perms_ext_storage=" + externalStoragePermission;
         }
 
         public AdUrlBuilder withAdUnitId(String adUnitId) {
@@ -444,9 +572,11 @@ public AdUrlBuilder withQuery(String query) {
             return this;
         }
 
-        public AdUrlBuilder withLatLon(String latLon, String locationAccuracy) {
+        public AdUrlBuilder withLatLon(String latLon, String locationAccuracy,
+                String latLonLastUpdated) {
             this.latLon = latLon;
             this.locationAccuracy = locationAccuracy;
+            this.latLonLastUpdated = latLonLastUpdated;
             return this;
         }
 
@@ -480,11 +610,6 @@ public AdUrlBuilder withExternalStoragePermission(boolean enabled) {
             return this;
         }
 
-        public AdUrlBuilder withTwitterAppInstalledStatus(TwitterAppInstalledStatus status) {
-            this.twitterAppInstalledStatus = status;
-            return this;
-        }
-
         public AdUrlBuilder withDnt(boolean dnt) {
             if (dnt) {
                 this.dnt = "1";
@@ -493,7 +618,7 @@ public AdUrlBuilder withDnt(boolean dnt) {
         }
 
         private String paramIfNotEmpty(String key, String value) {
-            if (isEmpty(value)) {
+            if (TextUtils.isEmpty(value)) {
                 return "";
             } else {
                 return "&" + key + "=" + value;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestAdFetchTaskFactory.java b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestAdFetchTaskFactory.java
deleted file mode 100644
index 599de6b1..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestAdFetchTaskFactory.java
+++ /dev/null
@@ -1,25 +0,0 @@
-package com.mopub.mobileads.test.support;
-
-import com.mopub.mobileads.AdFetchTask;
-import com.mopub.mobileads.AdViewController;
-import com.mopub.mobileads.TaskTracker;
-import com.mopub.mobileads.factories.AdFetchTaskFactory;
-
-import static org.mockito.Mockito.mock;
-
-public class TestAdFetchTaskFactory extends AdFetchTaskFactory {
-    private AdFetchTask mockAdFetchTask = mock(AdFetchTask.class);
-
-    public static AdFetchTask getSingletonMock() {
-        return getTestFactory().mockAdFetchTask;
-    }
-
-    private static TestAdFetchTaskFactory getTestFactory() {
-        return ((TestAdFetchTaskFactory) AdFetchTaskFactory.instance);
-    }
-
-    @Override
-    protected AdFetchTask internalCreate(TaskTracker taskTracker, AdViewController adViewController, String userAgent, int timeoutMilliseconds) {
-        return mockAdFetchTask;
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestAdFetcherFactory.java b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestAdFetcherFactory.java
deleted file mode 100644
index d36df69b..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestAdFetcherFactory.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package com.mopub.mobileads.test.support;
-
-import com.mopub.mobileads.AdFetcher;
-import com.mopub.mobileads.AdViewController;
-import com.mopub.mobileads.factories.AdFetcherFactory;
-
-import static org.mockito.Mockito.mock;
-
-public class TestAdFetcherFactory extends AdFetcherFactory {
-    private AdFetcher mockAdFetcher = mock(AdFetcher.class);
-
-    public static AdFetcher getSingletonMock() {
-        return getTestFactory().mockAdFetcher;
-    }
-
-    private static TestAdFetcherFactory getTestFactory() {
-        return ((TestAdFetcherFactory) AdFetcherFactory.instance);
-    }
-
-    @Override
-    public AdFetcher internalCreate(AdViewController adViewController, String userAgent) {
-        return mockAdFetcher;
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestCustomEventBannerAdapterFactory.java b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestCustomEventBannerAdapterFactory.java
index a26bf457..b6301488 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestCustomEventBannerAdapterFactory.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestCustomEventBannerAdapterFactory.java
@@ -1,16 +1,21 @@
 package com.mopub.mobileads.test.support;
 
+import android.support.annotation.NonNull;
+
+import com.mopub.common.AdReport;
 import com.mopub.mobileads.CustomEventBannerAdapter;
 import com.mopub.mobileads.MoPubView;
 import com.mopub.mobileads.factories.CustomEventBannerAdapterFactory;
 
+import java.util.Map;
+
 import static org.mockito.Mockito.mock;
 
 public class TestCustomEventBannerAdapterFactory extends CustomEventBannerAdapterFactory {
     private CustomEventBannerAdapter mockCustomEventBannerAdapter = mock(CustomEventBannerAdapter.class);
     private MoPubView moPubView;
     private String className;
-    private String classData;
+    private Map<String, String> classData;
 
     public static CustomEventBannerAdapter getSingletonMock() {
         return getTestFactory().mockCustomEventBannerAdapter;
@@ -21,10 +26,14 @@ private static TestCustomEventBannerAdapterFactory getTestFactory() {
     }
 
     @Override
-    protected CustomEventBannerAdapter internalCreate(MoPubView moPubView, String className, String classData) {
+    protected CustomEventBannerAdapter internalCreate(@NonNull final MoPubView moPubView,
+            @NonNull final String className,
+            @NonNull final Map<String, String> serverExtras,
+            final long broadcastIdentifier,
+            @NonNull final AdReport adReport) {
         this.moPubView = moPubView;
         this.className = className;
-        this.classData = classData;
+        this.classData = serverExtras;
         return mockCustomEventBannerAdapter;
     }
 
@@ -36,7 +45,7 @@ public static String getLatestClassName() {
         return getTestFactory().className;
     }
 
-    public static String getLatestClassData() {
+    public static Map<String, String> getLatestClassData() {
         return getTestFactory().classData;
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestCustomEventInterstitialAdapterFactory.java b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestCustomEventInterstitialAdapterFactory.java
index 10893134..a392ad53 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestCustomEventInterstitialAdapterFactory.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestCustomEventInterstitialAdapterFactory.java
@@ -1,16 +1,19 @@
 package com.mopub.mobileads.test.support;
 
+import com.mopub.common.AdReport;
 import com.mopub.mobileads.CustomEventInterstitialAdapter;
 import com.mopub.mobileads.MoPubInterstitial;
 import com.mopub.mobileads.factories.CustomEventInterstitialAdapterFactory;
 
+import java.util.Map;
+
 import static org.mockito.Mockito.mock;
 
 public class TestCustomEventInterstitialAdapterFactory extends CustomEventInterstitialAdapterFactory{
     private CustomEventInterstitialAdapter mockCustomEventInterstitalAdapter = mock(CustomEventInterstitialAdapter.class);
     private MoPubInterstitial latestMoPubInterstitial;
     private String latestClassName;
-    private String latestClassData;
+    private Map<String, String> latestClassData;
 
     public static CustomEventInterstitialAdapter getSingletonMock() {
         return getTestFactory().mockCustomEventInterstitalAdapter;
@@ -28,15 +31,15 @@ public static String getLatestClassName() {
         return getTestFactory().latestClassName;
     }
 
-    public static String getLatestClassData() {
+    public static Map<String, String> getLatestServerExtras() {
         return getTestFactory().latestClassData;
     }
 
     @Override
-    protected CustomEventInterstitialAdapter internalCreate(MoPubInterstitial moPubInterstitial, String className, String classData) {
+    protected CustomEventInterstitialAdapter internalCreate(MoPubInterstitial moPubInterstitial, String className, Map<String, String> serverExtras, long broadcastIdentifier, AdReport adReport) {
         latestMoPubInterstitial = moPubInterstitial;
         latestClassName = className;
-        latestClassData = classData;
+        latestClassData = serverExtras;
         return mockCustomEventInterstitalAdapter;
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestHtmlBannerWebViewFactory.java b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestHtmlBannerWebViewFactory.java
index 0909e309..84c91fc5 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestHtmlBannerWebViewFactory.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestHtmlBannerWebViewFactory.java
@@ -3,7 +3,7 @@
 import android.content.Context;
 import android.webkit.WebSettings;
 
-import com.mopub.mobileads.AdConfiguration;
+import com.mopub.common.AdReport;
 import com.mopub.mobileads.HtmlBannerWebView;
 import com.mopub.mobileads.factories.HtmlBannerWebViewFactory;
 
@@ -17,6 +17,7 @@
     private boolean latestIsScrollable;
     private String latestRedirectUrl;
     private String latestClickthroughUrl;
+    private AdReport latestAdReport;
 
     public TestHtmlBannerWebViewFactory() {
         WebSettings webSettings = mock(WebSettings.class);
@@ -34,15 +35,17 @@ private static TestHtmlBannerWebViewFactory getTestFactory() {
 
     @Override
     public HtmlBannerWebView internalCreate(
-            Context context, CustomEventBannerListener
-            customEventBannerListener,
+            Context context,
+            AdReport adReport,
+            CustomEventBannerListener customEventBannerListener,
             boolean isScrollable,
             String redirectUrl,
-            String clickthroughUrl, AdConfiguration adConfiguration) {
+            String clickthroughUrl) {
         latestListener = customEventBannerListener;
         latestIsScrollable = isScrollable;
         latestRedirectUrl = redirectUrl;
         latestClickthroughUrl = clickthroughUrl;
+        latestAdReport = adReport;
         return mockHtmlBannerWebView;
     }
 
@@ -61,4 +64,8 @@ public static String getLatestRedirectUrl() {
     public static String getLatestClickthroughUrl() {
         return getTestFactory().latestClickthroughUrl;
     }
+
+    public static AdReport getLatestAdReport() {
+        return getTestFactory().latestAdReport;
+    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestHtmlInterstitialWebViewFactory.java b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestHtmlInterstitialWebViewFactory.java
index d5fea284..c9dc4c47 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestHtmlInterstitialWebViewFactory.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestHtmlInterstitialWebViewFactory.java
@@ -2,7 +2,7 @@
 
 import android.content.Context;
 
-import com.mopub.mobileads.AdConfiguration;
+import com.mopub.common.AdReport;
 import com.mopub.mobileads.HtmlInterstitialWebView;
 import com.mopub.mobileads.factories.HtmlInterstitialWebViewFactory;
 
@@ -16,7 +16,6 @@
     private boolean latestIsScrollable;
     private String latestRedirectUrl;
     private String latestClickthroughUrl;
-    private AdConfiguration latestAdConfiguration;
 
     public static HtmlInterstitialWebView getSingletonMock() {
         return getTestFactory().mockHtmlInterstitialWebView;
@@ -27,12 +26,11 @@ private static TestHtmlInterstitialWebViewFactory getTestFactory() {
     }
 
     @Override
-    public HtmlInterstitialWebView internalCreate(Context context, CustomEventInterstitialListener customEventInterstitialListener, boolean isScrollable, String redirectUrl, String clickthroughUrl, AdConfiguration adConfiguration) {
+    public HtmlInterstitialWebView internalCreate(Context context, AdReport adReport, CustomEventInterstitialListener customEventInterstitialListener, boolean isScrollable, String redirectUrl, String clickthroughUrl) {
         latestListener = customEventInterstitialListener;
         latestIsScrollable = isScrollable;
         latestRedirectUrl = redirectUrl;
         latestClickthroughUrl = clickthroughUrl;
-        latestAdConfiguration = adConfiguration;
         return getTestFactory().mockHtmlInterstitialWebView;
     }
 
@@ -50,8 +48,4 @@ public static String getLatestRedirectUrl() {
     public static String getLatestClickthroughUrl() {
         return getTestFactory().latestClickthroughUrl;
     }
-
-    public static AdConfiguration getLatestAdConfiguration() {
-        return getTestFactory().latestAdConfiguration;
-    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestMraidControllerFactory.java b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestMraidControllerFactory.java
new file mode 100644
index 00000000..511499fe
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestMraidControllerFactory.java
@@ -0,0 +1,30 @@
+package com.mopub.mobileads.test.support;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.AdReport;
+import com.mopub.mobileads.factories.MraidControllerFactory;
+import com.mopub.mraid.MraidController;
+import com.mopub.mraid.PlacementType;
+
+import static org.mockito.Mockito.mock;
+
+public class TestMraidControllerFactory extends MraidControllerFactory {
+    private MraidController mockMraidController = mock(MraidController.class);
+
+    public static MraidController getSingletonMock() {
+        return getTestFactory().mockMraidController;
+    }
+
+    private static TestMraidControllerFactory getTestFactory() {
+        return ((TestMraidControllerFactory) MraidControllerFactory.instance);
+    }
+
+    @Override
+    protected MraidController internalCreate(@NonNull final Context context,
+            @NonNull AdReport adReport,
+            @NonNull final PlacementType placementType) {
+        return mockMraidController;
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestMraidViewFactory.java b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestMraidViewFactory.java
deleted file mode 100644
index 005ac90d..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestMraidViewFactory.java
+++ /dev/null
@@ -1,31 +0,0 @@
-package com.mopub.mobileads.test.support;
-
-import android.content.Context;
-
-import com.mopub.mobileads.AdConfiguration;
-import com.mopub.mobileads.MraidView;
-import com.mopub.mobileads.factories.MraidViewFactory;
-
-import static org.mockito.Mockito.mock;
-
-public class TestMraidViewFactory extends MraidViewFactory {
-    private final MraidView mockMraidView = mock(MraidView.class);
-
-    public static MraidView getSingletonMock() {
-        return getTestFactory().mockMraidView;
-    }
-
-    private static TestMraidViewFactory getTestFactory() {
-        return (TestMraidViewFactory) instance;
-    }
-
-    @Override
-    protected MraidView internalCreate(Context context, AdConfiguration adConfiguration) {
-        return mockMraidView;
-    }
-
-    @Override
-    protected MraidView internalCreate(Context context, AdConfiguration adConfiguration, MraidView.ExpansionStyle expansionStyle, MraidView.NativeCloseButtonStyle buttonStyle, MraidView.PlacementType placementType) {
-        return mockMraidView;
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestViewGestureDetectorFactory.java b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestViewGestureDetectorFactory.java
deleted file mode 100644
index 1bce3891..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestViewGestureDetectorFactory.java
+++ /dev/null
@@ -1,27 +0,0 @@
-package com.mopub.mobileads.test.support;
-
-import android.content.Context;
-import android.view.View;
-
-import com.mopub.mobileads.AdConfiguration;
-import com.mopub.mobileads.ViewGestureDetector;
-import com.mopub.mobileads.factories.ViewGestureDetectorFactory;
-
-import static org.mockito.Mockito.mock;
-
-public class TestViewGestureDetectorFactory extends ViewGestureDetectorFactory {
-    private ViewGestureDetector mockViewGestureDetector = mock(ViewGestureDetector.class);
-
-    public static ViewGestureDetector getSingletonMock() {
-        return getTestFactory().mockViewGestureDetector;
-    }
-
-    private static TestViewGestureDetectorFactory getTestFactory() {
-        return ((TestViewGestureDetectorFactory) instance);
-    }
-
-    @Override
-    protected ViewGestureDetector internalCreate(Context context, View view, AdConfiguration adConfiguration) {
-        return mockViewGestureDetector;
-    }
-}
\ No newline at end of file
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/InterstitialsTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/util/InterstitialsTest.java
deleted file mode 100644
index 56f21194..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/util/InterstitialsTest.java
+++ /dev/null
@@ -1,76 +0,0 @@
-package com.mopub.mobileads.util;
-
-import android.app.Activity;
-import android.graphics.Color;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.Button;
-import android.widget.LinearLayout;
-import android.widget.RelativeLayout;
-
-import com.mopub.common.util.Dips;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-
-import static com.mopub.mobileads.util.Interstitials.addCloseEventRegion;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-import static org.robolectric.Robolectric.shadowOf;
-
-@RunWith(RobolectricTestRunner.class)
-public class InterstitialsTest {
-
-    private Activity context;
-    private RelativeLayout.LayoutParams defaultLayoutParams;
-
-    @Before
-    public void setup() {
-        context = new Activity();
-        defaultLayoutParams = new RelativeLayout.LayoutParams(50, 50);
-    }
-
-    @Test
-    public void addCloseEventRegion_withNullViewGroup_shouldReturnFalse() throws Exception {
-        boolean result = addCloseEventRegion(null, defaultLayoutParams, null);
-
-        assertThat(result).isFalse();
-    }
-
-    @Test
-    public void addCloseEventRegion_withViewGroupButNoContext_shouldReturnFalse() throws Exception {
-        ViewGroup viewGroup = mock(ViewGroup.class);
-        when(viewGroup.getContext()).thenReturn(null);
-
-        boolean result = addCloseEventRegion(viewGroup, defaultLayoutParams, null);
-
-        assertThat(result).isFalse();
-    }
-
-    @Test
-    public void addCloseEventRegion_shouldAddTransparentButVisibleButton() throws Exception {
-        final LinearLayout linearLayout = new LinearLayout(context);
-
-        addCloseEventRegion(linearLayout, defaultLayoutParams, null);
-
-        final Button closeEventRegion = (Button) linearLayout.getChildAt(0);
-        assertThat(closeEventRegion.getVisibility()).isEqualTo(View.VISIBLE);
-        assertThat(shadowOf(closeEventRegion).getBackgroundColor()).isEqualTo(Color.TRANSPARENT);
-        assertThat(Dips.pixelsToIntDips((float) closeEventRegion.getLayoutParams().width, context)).isEqualTo(50);
-        assertThat(Dips.pixelsToIntDips((float)closeEventRegion.getLayoutParams().height, context)).isEqualTo(50);
-    }
-
-    @Test
-    public void addCloseEventRegion_shouldUsePassedInClickListener() throws Exception {
-        final LinearLayout linearLayout = new LinearLayout(context);
-        final View.OnClickListener onClickListener = mock(View.OnClickListener.class);
-
-        addCloseEventRegion(linearLayout, defaultLayoutParams, onClickListener);
-
-        final Button closeEventRegion = (Button) linearLayout.getChildAt(0);
-        assertThat(shadowOf(closeEventRegion).getOnClickListener()).isEqualTo(onClickListener);
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/MraidsTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/util/MraidsTest.java
deleted file mode 100644
index 6e24109d..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/util/MraidsTest.java
+++ /dev/null
@@ -1,186 +0,0 @@
-package com.mopub.mobileads.util;
-
-import android.Manifest;
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.content.pm.ResolveInfo;
-import android.os.Build;
-import android.os.Build.VERSION_CODES;
-import android.os.Environment;
-
-import com.mopub.common.test.support.SdkTestRunner;
-
-import org.hamcrest.BaseMatcher;
-import org.hamcrest.Description;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.annotation.Config;
-import org.robolectric.shadows.ShadowEnvironment;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import static com.mopub.common.util.VersionCode.HONEYCOMB_MR2;
-import static com.mopub.common.util.VersionCode.ICE_CREAM_SANDWICH;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.argThat;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.stub;
-
-@RunWith(SdkTestRunner.class)
-public class MraidsTest {
-    Context context;
-
-    @Before
-    public void setup() {
-        context = new Activity();
-    }
-
-    @Test
-    public void isTelAvailable_whenCanAcceptIntent_shouldReturnTrue() throws Exception {
-        context = createMockContextWithSpecificIntentData("tel", null, null, "android.intent.action.DIAL");
-
-        assertThat(Mraids.isTelAvailable(context)).isTrue();
-    }
-
-    @Test
-    public void isTelAvailable_whenCanNotAcceptIntent_shouldReturnFalse() throws Exception {
-        context = createMockContextWithSpecificIntentData("", null, null, "android.intent.action.DIAL");
-
-        assertThat(Mraids.isTelAvailable(context)).isFalse();
-    }
-
-    @Test
-    public void isSmsAvailable_whenCanAcceptIntent_shouldReturnTrue() throws Exception {
-        context = createMockContextWithSpecificIntentData("sms", null, null, "android.intent.action.VIEW");
-
-        assertThat(Mraids.isSmsAvailable(context)).isTrue();
-    }
-
-    @Test
-    public void isSmsAvailable_whenCanNotAcceptIntent_shouldReturnFalse() throws Exception {
-        context = createMockContextWithSpecificIntentData("", null, null, "android.intent.action.VIEW");
-
-        assertThat(Mraids.isSmsAvailable(context)).isFalse();
-    }
-
-    @Test
-    public void isStorePictureAvailable_whenPermissionDeclaredAndMediaMounted_shouldReturnTrue() throws Exception {
-        Robolectric.getShadowApplication().grantPermissions(Manifest.permission.WRITE_EXTERNAL_STORAGE);
-        ShadowEnvironment.setExternalStorageState(Environment.MEDIA_MOUNTED);
-
-        assertThat(Mraids.isStorePictureSupported(context)).isTrue();
-    }
-
-    @Test
-    public void isStorePictureAvailable_whenPermissionDenied_shouldReturnFalse() throws Exception {
-        Robolectric.getShadowApplication().denyPermissions(Manifest.permission.WRITE_EXTERNAL_STORAGE);
-        ShadowEnvironment.setExternalStorageState(Environment.MEDIA_MOUNTED);
-
-        assertThat(Mraids.isStorePictureSupported(context)).isFalse();
-    }
-
-    @Test
-    public void isStorePictureAvailable_whenMediaUnmounted_shouldReturnFalse() throws Exception {
-        Robolectric.getShadowApplication().grantPermissions(Manifest.permission.WRITE_EXTERNAL_STORAGE);
-        ShadowEnvironment.setExternalStorageState(Environment.MEDIA_UNMOUNTED);
-
-        assertThat(Mraids.isStorePictureSupported(context)).isFalse();
-    }
-
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
-    @Test
-    public void isCalendarAvailable_atLeastIcs_shouldReturnTrue() throws Exception {
-        context = createMockContextWithSpecificIntentData(null, null, Mraids.ANDROID_CALENDAR_CONTENT_TYPE, "android.intent.action.INSERT");
-        assertThat(Mraids.isCalendarAvailable(context)).isTrue();
-    }
-
-    @Config(reportSdk = VERSION_CODES.HONEYCOMB_MR2)
-    @Test
-    public void isCalendarAvailable_beforeIcs_shouldReturnFalse() throws Exception {
-        context = createMockContextWithSpecificIntentData(null, null, Mraids.ANDROID_CALENDAR_CONTENT_TYPE, "android.intent.action.INSERT");
-        assertThat(Mraids.isCalendarAvailable(context)).isFalse();
-    }
-
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
-    @Test
-    public void isCalendarAvailable_atLeastIcs_butCanNotAcceptIntent_shouldReturnFalse() throws
-            Exception {
-        context = createMockContextWithSpecificIntentData(null, null, "vnd.android.cursor.item/NOPE", "android.intent.action.INSERT");
-        assertThat(Mraids.isCalendarAvailable(context)).isFalse();
-    }
-
-    @Test
-    public void isInlineVideoAvailable_whenCanAcceptMraidVideoPlayerActivityIntent_shouldReturnTrue() throws Exception {
-        context = createMockContextWithSpecificIntentData(null, "com.mopub.mobileads.MraidVideoPlayerActivity", null, null);
-
-        assertThat(Mraids.isInlineVideoAvailable(context)).isTrue();
-    }
-
-    @Test
-    public void isInlineVideoAvailable_whenCanNotAcceptMraidVideoPlayerActivityIntent_shouldReturnFalse() throws Exception {
-        context = createMockContextWithSpecificIntentData(null, "com.mopub.mobileads.DO_NOT_ACCEPT", null, null);
-
-        assertThat(Mraids.isInlineVideoAvailable(context)).isFalse();
-    }
-
-    public static Context createMockContextWithSpecificIntentData(final String scheme, final String componentName, final String type, final String action) {
-        Context context = mock(Context.class);
-        PackageManager packageManager = mock(PackageManager.class);
-
-        List<ResolveInfo> resolveInfos = new ArrayList<ResolveInfo>();
-        resolveInfos.add(new ResolveInfo());
-
-        stub(context.getPackageManager()).toReturn(packageManager);
-
-        BaseMatcher intentWithSpecificData = new BaseMatcher() {
-            // check that the specific intent has the special data, i.e. "tel:", or a component name, or string type, based on a particular data
-
-            @Override
-            public boolean matches(Object item) {
-                if (item != null && item instanceof Intent ){
-                    boolean result = action != null || type != null || componentName != null || scheme != null;
-                    if (action != null) {
-                        if (((Intent) item).getAction() != null) {
-                            result = result && action.equals(((Intent) item).getAction());
-                        }
-                    }
-
-                    if (type != null) {
-                        if (((Intent) item).getType() != null) {
-                            result = result && type.equals(((Intent) item).getType());
-                        }
-                    }
-
-                    if (componentName != null) {
-                        if (((Intent) item).getComponent() != null) {
-                            result = result && componentName.equals(((Intent) item).getComponent().getClassName());
-                        }
-                    }
-
-                    if (scheme != null) {
-                        if (((Intent) item).getData() != null) {
-                            result = result && scheme.equals(((Intent) item).getData().getScheme());
-                        }
-                    }
-                    return result;
-                }
-                return false;
-            }
-
-            @Override
-            public void describeTo(Description description) {
-
-            }
-        };
-
-        // It is okay to query with specific intent or nothing, because by default, none of the query would normally any resolveInfo anyways
-        stub(packageManager.queryIntentActivities((Intent) argThat(intentWithSpecificData), eq(0))).toReturn(resolveInfos);
-        return context;
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/WebViewsTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/util/WebViewsTest.java
new file mode 100644
index 00000000..712eef93
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/util/WebViewsTest.java
@@ -0,0 +1,42 @@
+package com.mopub.mobileads.util;
+
+import android.annotation.TargetApi;
+import android.os.Build;
+import android.webkit.WebView;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+@RunWith(SdkTestRunner.class)
+public class WebViewsTest {
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
+    @Test
+    public void pause_withIsFinishingTrue_shouldStopLoading_shouldLoadBlankUrl_shouldPauseWebView() throws Exception {
+        WebView mockWebView = mock(WebView.class);
+
+        WebViews.onPause(mockWebView, true);
+
+        verify(mockWebView).stopLoading();
+        verify(mockWebView).loadUrl("");
+        verify(mockWebView).onPause();
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
+    @Test
+    public void pause_withIsFinishingFalse_shouldPauseWebView() throws Exception {
+        WebView mockWebView = mock(WebView.class);
+
+        WebViews.onPause(mockWebView, false);
+
+        verify(mockWebView, never()).stopLoading();
+        verify(mockWebView, never()).loadUrl("");
+        verify(mockWebView).onPause();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastManagerTest.java
index 4e1faf55..3e02db37 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastManagerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastManagerTest.java
@@ -7,14 +7,15 @@
 
 import com.mopub.common.CacheService;
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.DeviceUtils;
 
-import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
 import org.robolectric.tester.org.apache.http.FakeHttpLayer;
 
 import java.util.ArrayList;
@@ -29,10 +30,12 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+@Config(manifest = Config.NONE)
 @RunWith(SdkTestRunner.class)
 public class VastManagerTest {
-    static final String TEST_VAST_XML_STRING = "<VAST version='2.0'><Ad id='62833'><Wrapper><AdSystem>Tapad</AdSystem><VASTAdTagURI>http://dsp.x-team.staging.mopub.com/xml</VASTAdTagURI><Impression>http://myTrackingURL/wrapper/impression1</Impression><Impression>http://myTrackingURL/wrapper/impression2</Impression><Creatives><Creative AdID='62833'><Linear><TrackingEvents><Tracking event='creativeView'>http://myTrackingURL/wrapper/creativeView</Tracking><Tracking event='start'>http://myTrackingURL/wrapper/start</Tracking><Tracking event='midpoint'>http://myTrackingURL/wrapper/midpoint</Tracking><Tracking event='firstQuartile'>http://myTrackingURL/wrapper/firstQuartile</Tracking><Tracking event='thirdQuartile'>http://myTrackingURL/wrapper/thirdQuartile</Tracking><Tracking event='complete'>http://myTrackingURL/wrapper/complete</Tracking><Tracking event='mute'>http://myTrackingURL/wrapper/mute</Tracking><Tracking event='unmute'>http://myTrackingURL/wrapper/unmute</Tracking><Tracking event='pause'>http://myTrackingURL/wrapper/pause</Tracking><Tracking event='resume'>http://myTrackingURL/wrapper/resume</Tracking><Tracking event='fullscreen'>http://myTrackingURL/wrapper/fullscreen</Tracking></TrackingEvents><VideoClicks><ClickTracking>http://myTrackingURL/wrapper/click</ClickTracking></VideoClicks><MediaFiles><MediaFile delivery='progressive' bitrate='416' width='300' height='250' type='video/mp4'><![CDATA[https://s3.amazonaws.com/mopub-vast/tapad-video1.mp4]]></MediaFile></MediaFiles></Linear></Creative><Creative AdID=\"601364-Companion\"> <CompanionAds><Companion width=\"9000\"></Companion> </CompanionAds></Creative></Creatives></Wrapper></Ad></VAST><MP_TRACKING_URLS><MP_TRACKING_URL>http://www.mopub.com/imp1</MP_TRACKING_URL><MP_TRACKING_URL>http://www.mopub.com/imp2</MP_TRACKING_URL></MP_TRACKING_URLS>";
-    static final String TEST_NESTED_VAST_XML_STRING = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><VAST version='2.0'><Ad id='57722'><InLine><AdSystem version='1.0'>Tapad</AdSystem><AdTitle><![CDATA[PKW6T_LIV_DSN_Audience_TAPAD_3rd Party Audience Targeting_Action Movi]]></AdTitle><Description/><Impression><![CDATA[http://rtb-test.dev.tapad.com:8080/creative/imp.png?ts=1374099035457&svid=1&creative_id=30731&ctx_type=InApp&ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&liverail_cp=1]]></Impression><Creatives><Creative sequence='1' id='57722'><Linear><Duration>00:00:15</Duration><VideoClicks><ClickThrough><![CDATA[http://rtb-test.dev.tapad.com:8080/click?ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&crid=30731&ta_action_id=click&ts=1374099035458&redirect=http%3A%2F%2Ftapad.com]]></ClickThrough></VideoClicks><MediaFiles><MediaFile delivery='progressive' bitrate='416' width='800' height='480' type='video/mp4'><![CDATA[https://s3.amazonaws.com/mopub-vast/tapad-video.mp4]]></MediaFile></MediaFiles></Linear></Creative><Creative AdID=\"601364-Companion\"><CompanionAds><Companion id=\"valid\" height=\"250\" width=\"300\"><StaticResource creativeType=\"image/jpeg\">http://demo.tremormedia.com/proddev/vast/Blistex1.jpg</StaticResource><TrackingEvents><Tracking event=\"creativeView\">http://myTrackingURL/firstCompanionCreativeView</Tracking><Tracking event=\"creativeView\">http://myTrackingURL/secondCompanionCreativeView</Tracking></TrackingEvents><CompanionClickThrough>http://www.tremormedia.com</CompanionClickThrough></Companion></CompanionAds></Creative></Creatives></InLine></Ad></VAST>";
+    static final String EXTENSIONS_SNIPPET_PLACEHOLDER = "<![CDATA[EXTENSIONS_SNIPPET]]>";
+    static final String TEST_VAST_XML_STRING = "<VAST version='2.0'><Ad id='62833'><Wrapper><AdSystem>Tapad</AdSystem><VASTAdTagURI>http://dsp.x-team.staging.mopub.com/xml</VASTAdTagURI><Impression>http://myTrackingURL/wrapper/impression1</Impression><Impression>http://myTrackingURL/wrapper/impression2</Impression><Creatives><Creative AdID='62833'><Linear><TrackingEvents><Tracking event='creativeView'>http://myTrackingURL/wrapper/creativeView</Tracking><Tracking event='start'>http://myTrackingURL/wrapper/start</Tracking><Tracking event='midpoint'>http://myTrackingURL/wrapper/midpoint</Tracking><Tracking event='progress' offset='00:00:03.100'>http://myTrackingURL/wrapper/progress</Tracking><Tracking event='firstQuartile'>http://myTrackingURL/wrapper/firstQuartile</Tracking><Tracking event='thirdQuartile'>http://myTrackingURL/wrapper/thirdQuartile</Tracking><Tracking event='complete'>http://myTrackingURL/wrapper/complete</Tracking><Tracking event='close'>http://myTrackingURL/wrapper/close</Tracking><Tracking event='skip'>http://myTrackingURL/wrapper/skip</Tracking><Tracking event='mute'>http://myTrackingURL/wrapper/mute</Tracking><Tracking event='unmute'>http://myTrackingURL/wrapper/unmute</Tracking><Tracking event='pause'>http://myTrackingURL/wrapper/pause</Tracking><Tracking event='resume'>http://myTrackingURL/wrapper/resume</Tracking><Tracking event='fullscreen'>http://myTrackingURL/wrapper/fullscreen</Tracking></TrackingEvents><VideoClicks><ClickTracking>http://myTrackingURL/wrapper/click</ClickTracking></VideoClicks><MediaFiles><MediaFile delivery='progressive' bitrate='416' width='300' height='250' type='video/mp4'><![CDATA[https://s3.amazonaws.com/mopub-vast/tapad-video1.mp4]]></MediaFile></MediaFiles></Linear></Creative><Creative AdID=\"601364-Companion\"> <CompanionAds><Companion width=\"9000\"></Companion> </CompanionAds></Creative></Creatives><![CDATA[EXTENSIONS_SNIPPET]]></Wrapper></Ad></VAST><MP_TRACKING_URLS><MP_TRACKING_URL>http://www.mopub.com/imp1</MP_TRACKING_URL><MP_TRACKING_URL>http://www.mopub.com/imp2</MP_TRACKING_URL></MP_TRACKING_URLS>";
+    static final String TEST_NESTED_VAST_XML_STRING = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><VAST version='2.0'><Ad id='57722'><InLine><AdSystem version='1.0'>Tapad</AdSystem><AdTitle><![CDATA[PKW6T_LIV_DSN_Audience_TAPAD_3rd Party Audience Targeting_Action Movi]]></AdTitle><Description/><Impression><![CDATA[http://rtb-test.dev.tapad.com:8080/creative/imp.png?ts=1374099035457&svid=1&creative_id=30731&ctx_type=InApp&ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&liverail_cp=1]]></Impression><Creatives><Creative sequence='1' id='57722'><Linear><TrackingEvents><Tracking event='close'>http://myTrackingURL/wrapper/nested_close</Tracking><Tracking event='skip'>http://myTrackingURL/wrapper/nested_skip</Tracking></TrackingEvents><Duration>00:00:15</Duration><VideoClicks><ClickThrough><![CDATA[http://rtb-test.dev.tapad.com:8080/click?ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&crid=30731&ta_action_id=click&ts=1374099035458&redirect=http%3A%2F%2Ftapad.com]]></ClickThrough></VideoClicks><MediaFiles><MediaFile delivery='progressive' bitrate='416' width='800' height='480' type='video/mp4'><![CDATA[https://s3.amazonaws.com/mopub-vast/tapad-video.mp4]]></MediaFile></MediaFiles></Linear></Creative><Creative AdID=\"601364-Companion\"><CompanionAds><Companion id=\"valid\" height=\"250\" width=\"300\"><StaticResource creativeType=\"image/jpeg\">http://demo.tremormedia.com/proddev/vast/Blistex1.jpg</StaticResource><TrackingEvents><Tracking event=\"creativeView\">http://myTrackingURL/firstCompanionCreativeView</Tracking><Tracking event=\"creativeView\">http://myTrackingURL/secondCompanionCreativeView</Tracking></TrackingEvents><CompanionClickThrough>http://www.tremormedia.com</CompanionClickThrough></Companion></CompanionAds></Creative></Creatives><![CDATA[EXTENSIONS_SNIPPET]]></InLine></Ad></VAST>";
     static final String TEST_VAST_BAD_NEST_URL_XML_STRING = "<VAST version='2.0'><Ad id='62833'><Wrapper><AdSystem>Tapad</AdSystem><VASTAdTagURI>http://dsp.x-team.staging.mopub.com/xml\"$|||</VASTAdTagURI><Impression>http://myTrackingURL/wrapper/impression1</Impression><Impression>http://myTrackingURL/wrapper/impression2</Impression><Creatives><Creative AdID='62833'><Linear><TrackingEvents><Tracking event='creativeView'>http://myTrackingURL/wrapper/creativeView</Tracking><Tracking event='start'>http://myTrackingURL/wrapper/start</Tracking><Tracking event='midpoint'>http://myTrackingURL/wrapper/midpoint</Tracking><Tracking event='firstQuartile'>http://myTrackingURL/wrapper/firstQuartile</Tracking><Tracking event='thirdQuartile'>http://myTrackingURL/wrapper/thirdQuartile</Tracking><Tracking event='complete'>http://myTrackingURL/wrapper/complete</Tracking><Tracking event='mute'>http://myTrackingURL/wrapper/mute</Tracking><Tracking event='unmute'>http://myTrackingURL/wrapper/unmute</Tracking><Tracking event='pause'>http://myTrackingURL/wrapper/pause</Tracking><Tracking event='resume'>http://myTrackingURL/wrapper/resume</Tracking><Tracking event='fullscreen'>http://myTrackingURL/wrapper/fullscreen</Tracking></TrackingEvents><VideoClicks><ClickTracking>http://myTrackingURL/wrapper/click</ClickTracking></VideoClicks></Linear></Creative></Creatives></Wrapper></Ad></VAST><MP_TRACKING_URLS><MP_TRACKING_URL>http://www.mopub.com/imp1</MP_TRACKING_URL><MP_TRACKING_URL>http://www.mopub.com/imp2</MP_TRACKING_URL></MP_TRACKING_URLS>";
 
     private VastManager subject;
@@ -44,7 +47,7 @@
 
     @Before
     public void setup() {
-        context = new Activity();
+        context = Robolectric.buildActivity(Activity.class).create().get();
         CacheService.initializeDiskCache(context);
         subject = new VastManager(context);
         mFakeHttpLayer = Robolectric.getFakeHttpLayer();
@@ -62,12 +65,6 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
         }).when(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
     }
 
-    @After
-    public void tearDown() {
-        Robolectric.getFakeHttpLayer().clearPendingHttpResponses();
-        CacheService.clearAndNullCaches();
-    }
-
     private void prepareVastVideoConfiguration() {
         subject.prepareVastVideoConfiguration(TEST_VAST_XML_STRING, vastManagerListener);
 
@@ -93,11 +90,24 @@ public void prepareVastVideoConfiguration_shouldNotifyTheListenerAndContainTheCo
 
         assertThat(vastVideoConfiguration.getClickThroughUrl()).isEqualTo("http://rtb-test.dev.tapad.com:8080/click?ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&crid=30731&ta_action_id=click&ts=1374099035458&redirect=http%3A%2F%2Ftapad.com");
         assertThat(vastVideoConfiguration.getImpressionTrackers().size()).isEqualTo(5);
-        assertThat(vastVideoConfiguration.getStartTrackers().size()).isEqualTo(1);
-        assertThat(vastVideoConfiguration.getFirstQuartileTrackers().size()).isEqualTo(1);
-        assertThat(vastVideoConfiguration.getMidpointTrackers().size()).isEqualTo(1);
-        assertThat(vastVideoConfiguration.getThirdQuartileTrackers().size()).isEqualTo(1);
+
+        // Verify quartile trackers
+        assertThat(vastVideoConfiguration.getFractionalTrackers().size()).isEqualTo(3);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(0).trackingFraction()).isEqualTo(0.25f);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(1).trackingFraction()).isEqualTo(0.5f);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(2).trackingFraction()).isEqualTo(0.75f);
+
+        // Verify start tracker.
+        assertThat(vastVideoConfiguration.getAbsoluteTrackers().size()).isEqualTo(2);
+        assertThat(vastVideoConfiguration.getAbsoluteTrackers().get(0).getTrackingMilliseconds()).isEqualTo(2000);
+        assertThat(vastVideoConfiguration.getAbsoluteTrackers().get(1).getTrackingMilliseconds()).isEqualTo(3100);
+
         assertThat(vastVideoConfiguration.getCompleteTrackers().size()).isEqualTo(1);
+
+        // We specifically added a close tracker and a skip tracker to the nested vast test case as well,
+        // therefore there are two expected trackers total for each type.
+        assertThat(vastVideoConfiguration.getCloseTrackers().size()).isEqualTo(2);
+        assertThat(vastVideoConfiguration.getSkipTrackers().size()).isEqualTo(2);
         assertThat(vastVideoConfiguration.getClickTrackers().size()).isEqualTo(1);
 
         final VastCompanionAd vastCompanionAd = vastVideoConfiguration.getVastCompanionAd();
@@ -129,11 +139,30 @@ public void prepareVastVideoConfiguration_shouldHandleMultipleRedirects() throws
 
         assertThat(vastVideoConfiguration.getClickThroughUrl()).isEqualTo("http://rtb-test.dev.tapad.com:8080/click?ta_pinfo=JnRhX2JpZD1iNDczNTQwMS1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmaXA9OTguMTE2LjEyLjk0JnNzcD1MSVZFUkFJTCZ0YV9iaWRkZXJfaWQ9NTEzJTNBMzA1NSZjdHg9MTMzMSZ0YV9jYW1wYWlnbl9pZD01MTMmZGM9MTAwMjAwMzAyOSZ1YT1Nb3ppbGxhJTJGNS4wKyUyOE1hY2ludG9zaCUzQitJbnRlbCtNYWMrT1MrWCsxMF84XzMlMjkrQXBwbGVXZWJLaXQlMkY1MzcuMzYrJTI4S0hUTUwlMkMrbGlrZStHZWNrbyUyOStDaHJvbWUlMkYyNy4wLjE0NTMuMTE2K1NhZmFyaSUyRjUzNy4zNiZjcHQ9VkFTVCZkaWQ9ZDgyNWZjZDZlNzM0YTQ3ZTE0NWM4ZTkyNzMwMjYwNDY3YjY1NjllMSZpZD1iNDczNTQwMC1lZjJkLTExZTItYTNkNS0yMjAwMGE4YzEwOWQmcGlkPUNPTVBVVEVSJnN2aWQ9MSZicD0zNS4wMCZjdHhfdHlwZT1BJnRpZD0zMDU1JmNyaWQ9MzA3MzE%3D&crid=30731&ta_action_id=click&ts=1374099035458&redirect=http%3A%2F%2Ftapad.com");
         assertThat(vastVideoConfiguration.getImpressionTrackers().size()).isEqualTo(13);
-        assertThat(vastVideoConfiguration.getStartTrackers().size()).isEqualTo(3);
-        assertThat(vastVideoConfiguration.getFirstQuartileTrackers().size()).isEqualTo(3);
-        assertThat(vastVideoConfiguration.getMidpointTrackers().size()).isEqualTo(3);
-        assertThat(vastVideoConfiguration.getThirdQuartileTrackers().size()).isEqualTo(3);
+
+        assertThat(vastVideoConfiguration.getAbsoluteTrackers().size()).isEqualTo(6);
+        assertThat(vastVideoConfiguration.getAbsoluteTrackers().get(0).getTrackingMilliseconds()).isEqualTo(2000);
+        assertThat(vastVideoConfiguration.getAbsoluteTrackers().get(1).getTrackingMilliseconds()).isEqualTo(2000);
+        assertThat(vastVideoConfiguration.getAbsoluteTrackers().get(2).getTrackingMilliseconds()).isEqualTo(2000);
+        assertThat(vastVideoConfiguration.getAbsoluteTrackers().get(3).getTrackingMilliseconds()).isEqualTo(3100);
+        assertThat(vastVideoConfiguration.getAbsoluteTrackers().get(4).getTrackingMilliseconds()).isEqualTo(3100);
+        assertThat(vastVideoConfiguration.getAbsoluteTrackers().get(5).getTrackingMilliseconds()).isEqualTo(3100);
+
+
+        assertThat(vastVideoConfiguration.getFractionalTrackers().size()).isEqualTo(9);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(0).trackingFraction()).isEqualTo(0.25f);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(1).trackingFraction()).isEqualTo(0.25f);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(2).trackingFraction()).isEqualTo(0.25f);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(3).trackingFraction()).isEqualTo(0.5f);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(4).trackingFraction()).isEqualTo(0.5f);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(5).trackingFraction()).isEqualTo(0.5f);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(6).trackingFraction()).isEqualTo(0.75f);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(7).trackingFraction()).isEqualTo(0.75f);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().get(8).trackingFraction()).isEqualTo(0.75f);
+
         assertThat(vastVideoConfiguration.getCompleteTrackers().size()).isEqualTo(3);
+        assertThat(vastVideoConfiguration.getCloseTrackers().size()).isEqualTo(4);
+        assertThat(vastVideoConfiguration.getSkipTrackers().size()).isEqualTo(4);
         assertThat(vastVideoConfiguration.getClickTrackers().size()).isEqualTo(3);
 
         final VastCompanionAd vastCompanionAd = vastVideoConfiguration.getVastCompanionAd();
@@ -145,7 +174,6 @@ public void prepareVastVideoConfiguration_shouldHandleMultipleRedirects() throws
                 .containsOnly("http://myTrackingURL/firstCompanionCreativeView", "http://myTrackingURL/secondCompanionCreativeView");
     }
 
-
     @Test
     public void prepareVastVideoConfiguration_shouldReturnCorrectVastValuesWhenAVastRedirectFails() throws Exception {
         // Vast redirect response
@@ -164,7 +192,309 @@ public void prepareVastVideoConfiguration_shouldReturnCorrectVastValuesWhenAVast
 
         assertThat(vastVideoConfiguration.getClickThroughUrl()).isEqualTo(null);
         assertThat(vastVideoConfiguration.getImpressionTrackers().size()).isEqualTo(4);
-        assertThat(vastVideoConfiguration.getFirstQuartileTrackers().size()).isEqualTo(1);
+        assertThat(vastVideoConfiguration.getFractionalTrackers().size()).isEqualTo(3);
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withNoExtensions_shouldContainTheCorrectDefaultExtensionValues() throws Exception {
+        // Vast redirect response to XML without VAST extensions
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+
+        assertThat(vastVideoConfiguration.getCustomCtaText()).isNull();
+        assertThat(vastVideoConfiguration.getCustomSkipText()).isNull();
+        assertThat(vastVideoConfiguration.getCustomCloseIconUrl()).isNull();
+        assertThat(vastVideoConfiguration.getCustomForceOrientation()).isEqualTo(DeviceUtils.ForceOrientation.FORCE_LANDSCAPE);
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withExtensionsUnderWrapper_shouldContainTheCorrectCustomExtensionValues() throws Exception {
+        // Vast redirect response to XML without extensions
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        // Add extensions under Wrapper element in TEST_VAST_XML_STRING
+        subject.prepareVastVideoConfiguration(
+                TEST_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubCtaText>custom CTA text</MoPubCtaText>" +
+                                "<MoPubSkipText>skip</MoPubSkipText>" +
+                                "<MoPubCloseIcon>http://ton.twitter.com/exchange-media/images/v4/star_icon_3x.png</MoPubCloseIcon>" +
+                                "<MoPubForceOrientation>device</MoPubForceOrientation>" +
+                            "</Extension>" +
+                        "</Extensions>"),
+                vastManagerListener);
+
+        Robolectric.runBackgroundTasks();
+        Robolectric.runUiThreadTasks();
+        semaphore.acquire();
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+
+        // Verify custom extensions
+        assertThat(vastVideoConfiguration.getCustomCtaText()).isEqualTo("custom CTA text");
+        assertThat(vastVideoConfiguration.getCustomSkipText()).isEqualTo("skip");
+        assertThat(vastVideoConfiguration.getCustomCloseIconUrl()).isEqualTo("http://ton.twitter.com/exchange-media/images/v4/star_icon_3x.png");
+        assertThat(vastVideoConfiguration.getCustomForceOrientation()).isEqualTo(DeviceUtils.ForceOrientation.DEVICE_ORIENTATION);
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withExtensionsUnderInline_shouldContainTheCorrectCustomExtensionValues() throws Exception {
+        // Vast redirect response to XML with extensions under Inline element
+        mFakeHttpLayer.addPendingHttpResponse(200,
+                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubCtaText>custom CTA text</MoPubCtaText>" +
+                                "<MoPubSkipText>skip</MoPubSkipText>" +
+                                "<MoPubCloseIcon>http://ton.twitter.com/exchange-media/images/v4/star_icon_3x.png</MoPubCloseIcon>" +
+                                "<MoPubForceOrientation>device</MoPubForceOrientation>" +
+                            "</Extension>" +
+                        "</Extensions>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+
+        // Verify custom extensions
+        assertThat(vastVideoConfiguration.getCustomCtaText()).isEqualTo("custom CTA text");
+        assertThat(vastVideoConfiguration.getCustomSkipText()).isEqualTo("skip");
+        assertThat(vastVideoConfiguration.getCustomCloseIconUrl()).isEqualTo("http://ton.twitter.com/exchange-media/images/v4/star_icon_3x.png");
+        assertThat(vastVideoConfiguration.getCustomForceOrientation()).isEqualTo(DeviceUtils.ForceOrientation.DEVICE_ORIENTATION);
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withExtensionsUnderBothWrapperAndInline_shouldContainLastParsedCustomExtensionValues() throws Exception {
+        // Vast redirect response to XML with extensions under Inline element in TEST_NESTED_VAST_XML_STRING, will be parsed last
+        mFakeHttpLayer.addPendingHttpResponse(200,
+                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubCtaText>CTA 2</MoPubCtaText>" +
+                                "<MoPubSkipText>skip 2</MoPubSkipText>" +
+                                "<MoPubCloseIcon>http://ton.twitter.com/exchange-media/images/v4/star_icon_3x_2.png</MoPubCloseIcon>" +
+                                "<MoPubForceOrientation>landscape</MoPubForceOrientation>" +
+                            "</Extension>" +
+                        "</Extensions>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        // Also add extensions under Wrapper element in TEST_VAST_XML_STRING
+        subject.prepareVastVideoConfiguration(
+                TEST_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubCtaText>CTA 1</MoPubCtaText>" +
+                                "<MoPubSkipText>skip 1</MoPubSkipText>" +
+                                "<MoPubCloseIcon>http://ton.twitter.com/exchange-media/images/v4/star_icon_3x_1.png</MoPubCloseIcon>" +
+                                "<MoPubForceOrientation>device orientation</MoPubForceOrientation>" +
+                            "</Extension>" +
+                        "</Extensions>"),
+                vastManagerListener);
+
+        Robolectric.runBackgroundTasks();
+        Robolectric.runUiThreadTasks();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+
+        // Verify custom extension values are the ones last parsed in TEST_NESTED_VAST_XML_STRING
+        assertThat(vastVideoConfiguration.getCustomCtaText()).isEqualTo("CTA 2");
+        assertThat(vastVideoConfiguration.getCustomSkipText()).isEqualTo("skip 2");
+        assertThat(vastVideoConfiguration.getCustomCloseIconUrl()).isEqualTo("http://ton.twitter.com/exchange-media/images/v4/star_icon_3x_2.png");
+        assertThat(vastVideoConfiguration.getCustomForceOrientation()).isEqualTo(DeviceUtils.ForceOrientation.FORCE_LANDSCAPE);
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withCustomCtaTextAsSingleSpace_shouldReturnEmptyString() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200,
+                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubCtaText> </MoPubCtaText>" +     // single space, i.e. no text
+                            "</Extension>" +
+                        "</Extensions>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+        assertThat(vastVideoConfiguration.getCustomCtaText()).isEmpty();
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withCustomCtaTextLongerThan15Chars_shouldReturnNull() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200,
+                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubCtaText>1234567890123456</MoPubCtaText>" +     // 16 chars
+                            "</Extension>" +
+                        "</Extensions>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+        assertThat(vastVideoConfiguration.getCustomCtaText()).isNull();
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withCustomSkipTextLongerThan8Chars_shouldReturnNull() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200,
+                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubSkipText>123456789</MoPubSkipText>" +     // 9 chars
+                            "</Extension>" +
+                        "</Extensions>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+        assertThat(vastVideoConfiguration.getCustomSkipText()).isNull();
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withInvalidCustomForceOrientation_shouldReturnDefaultForceLandscapeOrientation() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200,
+                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubForceOrientation>abcd</MoPubForceOrientation>" +   // invalid value
+                            "</Extension>" +
+                        "</Extensions>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+        assertThat(vastVideoConfiguration.getCustomForceOrientation()).isEqualTo(DeviceUtils.ForceOrientation.FORCE_LANDSCAPE);
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withCustomForceOrientationInMixedCaseAndUntrimmed_shouldReturnCustomForceOrientation() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200,
+                TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
+                        "<Extensions>" +
+                            "<Extension type=\"MoPub\">" +
+                                "<MoPubForceOrientation> PortRAIT  </MoPubForceOrientation>" +
+                            "</Extension>" +
+                        "</Extensions>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+        assertThat(vastVideoConfiguration.getCustomForceOrientation()).isEqualTo(DeviceUtils.ForceOrientation.FORCE_PORTRAIT);
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withValidPercentSkipOffset_shouldReturnCorrectValue() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset='25%'>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+
+        assertThat(vastVideoConfiguration.getSkipOffset()).isEqualTo("25%");
+    }
+
+
+    @Test
+    public void prepareVastVideoConfiguration_withValidAbsoluteSkipOffset_shouldReturnCorrectValue() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset='  00:03:14 '>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+
+        assertThat(vastVideoConfiguration.getSkipOffset()).isEqualTo("00:03:14");
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withValidAbsoluteSkipOffsetWithExtraSpace_shouldReturnCorrectTrimmedValue() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset='  00:03:14.159 '>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+
+        assertThat(vastVideoConfiguration.getSkipOffset()).isEqualTo("00:03:14.159");
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withSkipOffsets_shouldReturnLastParsedValue() throws Exception {
+        // Vast redirect response with skipoffset in percent format
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset='25%'>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        // Also add a skipoffset in absolute format
+        subject.prepareVastVideoConfiguration(
+                TEST_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset='00:03:14'>"),
+                vastManagerListener);
+
+        Robolectric.runBackgroundTasks();
+        Robolectric.runUiThreadTasks();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+
+        // Verify that the last parsed skipoffset value is returned
+        assertThat(vastVideoConfiguration.getSkipOffset()).isEqualTo("25%");
+    }
+
+    @Test
+    public void prepareVastVideoConfiguration_withEmptySkipOffset_shouldReturnNull() throws Exception {
+        // Vast redirect response
+        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset=' '>"));
+        // Video download response
+        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+
+        prepareVastVideoConfiguration();
+        semaphore.acquire();
+
+        verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfiguration.class));
+
+        assertThat(vastVideoConfiguration.getSkipOffset()).isNull();
     }
 
     @Test
@@ -220,7 +550,6 @@ public void prepareVastVideoConfiguration_withVideoInDiskCache_shouldNotDownload
 
     @Test
     public void prepareVastVideoConfiguration_withUninitializedDiskCache_shouldReturnNull() throws Exception {
-        CacheService.clearAndNullCaches();
         mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
 
         prepareVastVideoConfiguration();
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastVideoConfigurationTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastVideoConfigurationTest.java
new file mode 100644
index 00000000..6f78a9a0
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastVideoConfigurationTest.java
@@ -0,0 +1,53 @@
+package com.mopub.mobileads.util.vast;
+
+import com.mopub.mobileads.VastAbsoluteProgressTracker;
+import com.mopub.mobileads.VastFractionalProgressTracker;
+
+import org.junit.Test;
+
+import java.util.ArrayList;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+public class VastVideoConfigurationTest {
+
+    @Test
+    public void testAddFractionalTrackers_multipleTimes_shouldBeSorted() throws Exception {
+        ArrayList<VastFractionalProgressTracker> testSet1 = new ArrayList<VastFractionalProgressTracker>();
+        testSet1.add(new VastFractionalProgressTracker("test1a", 0.24f));
+        testSet1.add(new VastFractionalProgressTracker("test1b", 0.5f));
+        testSet1.add(new VastFractionalProgressTracker("test1c", 0.91f));
+
+        ArrayList<VastFractionalProgressTracker> testSet2 = new ArrayList<VastFractionalProgressTracker>();
+        testSet2.add(new VastFractionalProgressTracker("test2a", 0.14f));
+        testSet2.add(new VastFractionalProgressTracker("test2b", 0.6f));
+        testSet2.add(new VastFractionalProgressTracker("test2c", 0.71f));
+
+        VastVideoConfiguration subject = new VastVideoConfiguration();
+
+        subject.addFractionalTrackers(testSet1);
+        subject.addFractionalTrackers(testSet2);
+
+        assertThat(subject.getFractionalTrackers()).isSorted();
+    }
+
+    @Test
+    public void testAddAbsoluteTrackers_multipleTimes_shouldBesSorted() throws Exception {
+        ArrayList<VastAbsoluteProgressTracker> testSet1 = new ArrayList<VastAbsoluteProgressTracker>();
+        testSet1.add(new VastAbsoluteProgressTracker("test1a", 1000));
+        testSet1.add(new VastAbsoluteProgressTracker("test1b", 10000));
+        testSet1.add(new VastAbsoluteProgressTracker("test1c", 50000));
+
+        ArrayList<VastAbsoluteProgressTracker> testSet2 = new ArrayList<VastAbsoluteProgressTracker>();
+        testSet2.add(new VastAbsoluteProgressTracker("test2a", 1100));
+        testSet2.add(new VastAbsoluteProgressTracker("test2b", 9000));
+        testSet2.add(new VastAbsoluteProgressTracker("test2c", 62000));
+
+        VastVideoConfiguration subject = new VastVideoConfiguration();
+
+        subject.addAbsoluteTrackers(testSet1);
+        subject.addAbsoluteTrackers(testSet2);
+
+        assertThat(subject.getAbsoluteTrackers()).isSorted();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastXmlManagerAggregatorTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastXmlManagerAggregatorTest.java
index f7ddc3f2..bcdb76eb 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastXmlManagerAggregatorTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastXmlManagerAggregatorTest.java
@@ -65,7 +65,7 @@ public void processVast_shouldNotFollowRedirectsOnceTheLimitHasBeenReached() thr
         assertThat(vastXmlManagers.get(0).getMediaFileUrl()).isEqualTo("https://s3.amazonaws.com/mopub-vast/tapad-video1.mp4");
         assertThat(vastXmlManagers.get(0).getClickThroughUrl()).isEqualTo(null);
         assertThat(vastXmlManagers.get(0).getImpressionTrackers().size()).isEqualTo(4);
-        assertThat(vastXmlManagers.get(0).getVideoFirstQuartileTrackers().size()).isEqualTo(1);
+        assertThat(vastXmlManagers.get(0).getFractionalProgressTrackers().size()).isEqualTo(3);
     }
 
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastXmlManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastXmlManagerTest.java
index dd7bb02b..c71d444f 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastXmlManagerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/VastXmlManagerTest.java
@@ -1,6 +1,9 @@
 package com.mopub.mobileads.util.vast;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.DeviceUtils.ForceOrientation;
+import com.mopub.mobileads.VastAbsoluteProgressTracker;
+import com.mopub.mobileads.VastFractionalProgressTracker;
 
 import org.junit.Before;
 import org.junit.Test;
@@ -37,7 +40,7 @@
             "                    <VASTAdTagURI><![CDATA[ http://0.dsp.dev1.mopub.com/xml ]]></VASTAdTagURI>" +
             "                    <Creatives>" +
             "                        <Creative sequence=\"1\" AdID=\"\">" +
-            "                            <Linear>" +
+            "                            <Linear skipoffset=\"25%\">" +
             "                                <Duration>00:00:58</Duration>" +
             "                                <TrackingEvents>" +
             "                                    <Tracking event=\"start\">" +
@@ -45,6 +48,40 @@
             "                                        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
             "                                        ]]>" +
             "                                    </Tracking>" +
+            "                                    <Tracking event=\"progress\" offset=\"13%\">" +
+            "                                        <![CDATA[" +
+            "                                        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
+            "                                        ]]>" +
+            "                                    </Tracking>" +
+            "                                    <Tracking event=\"progress\" offset=\"01:01:10.300\">" +
+            "                                        <![CDATA[" +
+            "                                        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
+            "                                        ]]>" +
+            "                                    </Tracking>" +
+            // Invalid tracking due to ambiguous offset.
+            "                                    <Tracking event=\"progress\" offset=\"01:01\">" +
+            "                                        <![CDATA[" +
+            "                                        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
+            "                                        ]]>" +
+            "                                    </Tracking>" +
+            // Invalid tracking due to a too-high percentage offset.
+            "                                    <Tracking event=\"progress\" offset=\"113%\">" +
+            "                                        <![CDATA[" +
+            "                                        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
+            "                                        ]]>" +
+            "                                    </Tracking>" +
+            // Invalid tracking due to a negative percentage offset.
+            "                                    <Tracking event=\"progress\" offset=\"-113%\">" +
+            "                                        <![CDATA[" +
+            "                                        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
+            "                                        ]]>" +
+            "                                    </Tracking>" +
+            // Invalid tracking due to a non-number offset
+            "                                    <Tracking event=\"progress\" offset=\"ten seconds\">" +
+            "                                        <![CDATA[" +
+            "                                        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
+            "                                        ]]>" +
+            "                                    </Tracking>" +
             "                                    <Tracking event=\"midpoint\">" +
             "                                        <![CDATA[" +
             "                                        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=18;ecn1=1;etm1=0;" +
@@ -85,6 +122,26 @@
             "                                        http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.5;sz=1x1;ord=2922389?" +
             "                                        ]]>" +
             "                                    </Tracking>" +
+            "                                    <Tracking event=\"close\">" +
+            "                                        <![CDATA[" +
+            "                                        http://www.mopub.com/close?q=ignatius" +
+            "                                        ]]>" +
+            "                                    </Tracking>" +
+            "                                    <Tracking event=\"close\">" +
+            "                                        <![CDATA[" +
+            "                                        http://www.mopub.com/close?q=j3" +
+            "                                        ]]>" +
+            "                                    </Tracking>" +
+            "                                    <Tracking event=\"skip\">" +
+            "                                        <![CDATA[" +
+            "                                        http://www.mopub.com/skip?q=ignatius" +
+            "                                        ]]>" +
+            "                                    </Tracking>" +
+            "                                    <Tracking event=\"skip\">" +
+            "                                        <![CDATA[" +
+            "                                        http://www.mopub.com/skip?q=j3" +
+            "                                        ]]>" +
+            "                                    </Tracking>" +
             "                                    <Tracking event=\"mute\">" +
             "                                        <![CDATA[" +
             "                                        http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=16;ecn1=1;etm1=0;" +
@@ -236,6 +293,12 @@
             "                                </DeliveryData>" +
             "                            </AdServingData>" +
             "                        </Extension>" +
+            "                        <Extension type=\"MoPub\">" +
+            "                           <MoPubCtaText>custom CTA text</MoPubCtaText>" +
+            "                           <MoPubSkipText>skip</MoPubSkipText>" +
+            "                           <MoPubCloseIcon>http://ton.twitter.com/exchange-media/images/v4/star_icon_3x.png</MoPubCloseIcon>" +
+            "                           <MoPubForceOrientation>device</MoPubForceOrientation>" +
+            "                        </Extension>" +
             "                    </Extensions>" +
             "                </InLine>" +
             "            </Ad>" +
@@ -298,66 +361,80 @@ public void getImpressionTrackers_shouldReturnTheCorrectValue() {
     }
 
     @Test
-    public void getVideoStartTrackers_shouldReturnTheCorrectValue() {
-        List<String> trackers = mXmlManager.getVideoStartTrackers();
+    public void getAbsoluteTrackers_shouldReturnCorrectValues() {
+        List<VastAbsoluteProgressTracker> trackers = mXmlManager.getAbsoluteProgressTrackers();
 
-        assertThat(trackers.size()).isEqualTo(1);
+        assertThat(trackers.size()).isEqualTo(2);
 
-        String tracker1 = trackers.get(0);
+        VastAbsoluteProgressTracker tracker0 = trackers.get(0);
+        assertThat(tracker0.getTrackingMilliseconds()).isEqualTo(2000);
+        assertThat(tracker0.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;");
 
-        assertThat(tracker1).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;");
+        VastAbsoluteProgressTracker tracker1 = trackers.get(1);
+        assertThat(tracker1.getTrackingMilliseconds()).isEqualTo(3670300);
+        assertThat(tracker1.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;");
     }
 
     @Test
-    public void getVideoFirstQuartileTrackers_shouldReturnTheCorrectValue() {
-        List<String> trackers = mXmlManager.getVideoFirstQuartileTrackers();
+    public void getFractionalTrackers_shouldReturnCorrectValues() {
+        List<VastFractionalProgressTracker> trackers = mXmlManager.getFractionalProgressTrackers();
 
-        assertThat(trackers.size()).isEqualTo(2);
+        assertThat(trackers.size()).isEqualTo(7);
 
-        String tracker1 = trackers.get(0);
-        String tracker2 = trackers.get(1);
+        VastFractionalProgressTracker tracker0 = trackers.get(0);
+        assertThat(tracker0.trackingFraction()).isEqualTo(0.13f);
+        assertThat(tracker0.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;");
 
-        assertThat(tracker1).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=26;ecn1=1;etm1=0;");
-        assertThat(tracker2).isEqualTo("http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.2;sz=1x1;ord=2922389?");
-    }
+        VastFractionalProgressTracker tracker1 = trackers.get(1);
+        assertThat(tracker1.trackingFraction()).isEqualTo(0.25f);
+        assertThat(tracker1.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=26;ecn1=1;etm1=0;");
 
-    @Test
-    public void getVideoMidpointTrackers_shouldReturnTheCorrectValue() {
-        List<String> trackers = mXmlManager.getVideoMidpointTrackers();
+        VastFractionalProgressTracker tracker2 = trackers.get(2);
+        assertThat(tracker2.trackingFraction()).isEqualTo(0.25f);
+        assertThat(tracker2.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.2;sz=1x1;ord=2922389?");
 
-        assertThat(trackers.size()).isEqualTo(2);
+        VastFractionalProgressTracker tracker3 = trackers.get(3);
+        assertThat(tracker3.trackingFraction()).isEqualTo(0.5f);
+        assertThat(tracker3.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=18;ecn1=1;etm1=0;");
 
-        String tracker1 = trackers.get(0);
-        String tracker2 = trackers.get(1);
+        VastFractionalProgressTracker tracker4 = trackers.get(4);
+        assertThat(tracker4.trackingFraction()).isEqualTo(0.5f);
+        assertThat(tracker4.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.3;sz=1x1;ord=2922389?");
+
+        VastFractionalProgressTracker tracker5 = trackers.get(5);
+        assertThat(tracker5.trackingFraction()).isEqualTo(0.75f);
+        assertThat(tracker5.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=27;ecn1=1;etm1=0;");
 
-        assertThat(tracker1).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=18;ecn1=1;etm1=0;");
-        assertThat(tracker2).isEqualTo("http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.3;sz=1x1;ord=2922389?");
+        VastFractionalProgressTracker tracker6 = trackers.get(6);
+        assertThat(tracker6.trackingFraction()).isEqualTo(0.75f);
+        assertThat(tracker6.getTrackingUrl()).isEqualTo("http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.4;sz=1x1;ord=2922389?");
     }
 
     @Test
-    public void getVideoThirdQuartileTrackers_shouldReturnTheCorrectValue() {
-        List<String> trackers = mXmlManager.getVideoThirdQuartileTrackers();
+    public void getVideoCompleteTrackers_shouldReturnTheCorrectValue() {
+        List<String> trackers = mXmlManager.getVideoCompleteTrackers();
 
         assertThat(trackers.size()).isEqualTo(2);
 
         String tracker1 = trackers.get(0);
         String tracker2 = trackers.get(1);
 
-        assertThat(tracker1).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=27;ecn1=1;etm1=0;");
-        assertThat(tracker2).isEqualTo("http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.4;sz=1x1;ord=2922389?");
+        assertThat(tracker1).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=13;ecn1=1;etm1=0;");
+        assertThat(tracker2).isEqualTo("http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.5;sz=1x1;ord=2922389?");
     }
 
     @Test
-    public void getVideoCompleteTrackers_shouldReturnTheCorrectValue() {
-        List<String> trackers = mXmlManager.getVideoCompleteTrackers();
+    public void getVideoCloseTrackers_shouldReturnTheCorrectValue() {
+        List<String> trackers = mXmlManager.getVideoCloseTrackers();
 
-        assertThat(trackers.size()).isEqualTo(2);
+        assertThat(trackers).containsExactly("http://www.mopub.com/close?q=ignatius", "http://www.mopub.com/close?q=j3");
+    }
 
-        String tracker1 = trackers.get(0);
-        String tracker2 = trackers.get(1);
+    @Test
+    public void getVideoSkipTrackers_shouldReturnTheCorrectValue() {
+        List<String> trackers = mXmlManager.getVideoSkipTrackers();
 
-        assertThat(tracker1).isEqualTo("http://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=13;ecn1=1;etm1=0;");
-        assertThat(tracker2).isEqualTo("http://ad.doubleclick.net/ad/N270.Process_Other/B3473145.5;sz=1x1;ord=2922389?");
+        assertThat(trackers).containsExactly("http://www.mopub.com/skip?q=ignatius", "http://www.mopub.com/skip?q=j3");
     }
 
     @Test
@@ -444,6 +521,41 @@ public void getMediaFileUrl_shouldReturnTheCorrectValue() {
         assertThat(url).isEqualTo("http://s3.amazonaws.com/uploads.hipchat.com/10627/429509/t8hqeqf98nvtir7/big_buck_bunny.mp4");
     }
 
+    @Test
+    public void getCustomCtaText_shouldReturnTheCorrectValue() {
+        String customCtaText = mXmlManager.getCustomCtaText();
+
+        assertThat(customCtaText).isEqualTo("custom CTA text");
+    }
+
+    @Test
+    public void getCustomSkipText_shouldReturnTheCorrectValue() {
+        String customSkipText = mXmlManager.getCustomSkipText();
+
+        assertThat(customSkipText).isEqualTo("skip");
+    }
+
+    @Test
+    public void getCustomCloseIconUrl_shouldReturnTheCorrectValue() {
+        String customCloseIconUrl = mXmlManager.getCustomCloseIconUrl();
+
+        assertThat(customCloseIconUrl).isEqualTo("http://ton.twitter.com/exchange-media/images/v4/star_icon_3x.png");
+    }
+
+    @Test
+    public void getCustomForceOrientation_shouldReturnTheCorrectValue() {
+        ForceOrientation customForceOrientation = mXmlManager.getCustomForceOrientation();
+
+        assertThat(customForceOrientation).isEqualTo(ForceOrientation.DEVICE_ORIENTATION);
+    }
+
+    @Test
+    public void getSkipOffset_shouldReturnTheCorrectValue() {
+        String skipOffset = mXmlManager.getSkipOffset();
+
+        assertThat(skipOffset).isEqualTo("25%");
+    }
+
     @Test
     public void getVastAdTagURI_shouldReturnTheCorrectValue() {
         String url = mXmlManager.getVastAdTagURI();
@@ -487,11 +599,11 @@ public void parsingVastWithMalformedNodes_shouldNotCauseProblems() {
         }
 
         assertThat(badManager.getMediaFileUrl()).isEqualTo(null);
-        assertThat(badManager.getVideoMidpointTrackers().size()).isEqualTo(0);
+        assertThat(badManager.getFractionalProgressTrackers().size()).isEqualTo(0);
         assertThat(badManager.getImpressionTrackers().size()).isEqualTo(0);
 
-        List<String> startTrackers = badManager.getVideoStartTrackers();
+        List<VastAbsoluteProgressTracker> startTrackers = badManager.getAbsoluteProgressTrackers();
         assertThat(startTrackers.size()).isEqualTo(1);
-        assertThat(startTrackers.get(0)).isEqualTo("good");
+        assertThat(startTrackers.get(0).getTrackingUrl()).isEqualTo("good");
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/XmlUtilsTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/XmlUtilsTest.java
new file mode 100644
index 00000000..866b84c3
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/util/vast/XmlUtilsTest.java
@@ -0,0 +1,240 @@
+package com.mopub.mobileads.util.vast;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+import org.w3c.dom.Document;
+import org.w3c.dom.Node;
+import org.xml.sax.InputSource;
+
+import java.io.StringReader;
+import java.text.DateFormat;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+import java.util.Locale;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@Config(manifest = Config.NONE)
+@RunWith(SdkTestRunner.class)
+public class XmlUtilsTest {
+
+    // From Microsoft's sample xml documents page: https://msdn.microsoft.com/en-us/library/bb387026.aspx
+    private String testXml = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n" +
+            "<aw:PurchaseOrders xmlns:aw=\"http://www.adventure-works.com\">\n" +
+            "  <aw:PurchaseOrder aw:PurchaseOrderNumber=\"99503\" aw:OrderDate=\"1999-10-20\">\n" +
+            "    <aw:Address aw:Type=\"Shipping\">\n" +
+            "      <aw:Name>Ellen Adams</aw:Name>\n" +
+            "      <aw:Street>123 Maple Street</aw:Street>\n" +
+            "      <aw:City>Mill Valley</aw:City>\n" +
+            "      <aw:State>CA</aw:State>\n" +
+            "      <aw:Zip>10999</aw:Zip>\n" +
+            "      <aw:Country>USA</aw:Country>\n" +
+            "    </aw:Address>\n" +
+            "    <aw:Address aw:Type=\"Billing\">\n" +
+            "      <aw:Name>Tai Yee</aw:Name>\n" +
+            "      <aw:Street>8 Oak Avenue</aw:Street>\n" +
+            "      <aw:City>Old Town</aw:City>\n" +
+            "      <aw:State>PA</aw:State>\n" +
+            "      <aw:Zip>95819</aw:Zip>\n" +
+            "      <aw:Country>USA</aw:Country>\n" +
+            "    </aw:Address>\n" +
+            "    <aw:DeliveryNotes>Please leave packages in shed by driveway.</aw:DeliveryNotes>\n" +
+            "    <aw:Items>\n" +
+            "      <aw:Item aw:PartNumber=\"898-AZ\">\n" +
+            "        <aw:ProductName>Lawnmower</aw:ProductName>\n" +
+            "        <aw:Quantity>1</aw:Quantity>\n" +
+            "        <aw:USPrice>148.95</aw:USPrice>\n" +
+            "        <aw:Comment>Confirm this is electric</aw:Comment>\n" +
+            "      </aw:Item>\n" +
+            "      <aw:Item aw:PartNumber=\"926-AA\">\n" +
+            "        <aw:ProductName>Baby Monitor</aw:ProductName>\n" +
+            "        <aw:Quantity>2</aw:Quantity>\n" +
+            "        <aw:USPrice>39.98</aw:USPrice>\n" +
+            "        <aw:ShipDate>1999-05-21</aw:ShipDate>\n" +
+            "      </aw:Item>\n" +
+            "    </aw:Items>\n" +
+            "  </aw:PurchaseOrder>\n" +
+            "  <aw:PurchaseOrder aw:PurchaseOrderNumber=\"99505\" aw:OrderDate=\"1999-10-22\">\n" +
+            "    <aw:Address aw:Type=\"Shipping\">\n" +
+            "      <aw:Name>Cristian Osorio</aw:Name>\n" +
+            "      <aw:Street>456 Main Street</aw:Street>\n" +
+            "      <aw:City>Buffalo</aw:City>\n" +
+            "      <aw:State>NY</aw:State>\n" +
+            "      <aw:Zip>98112</aw:Zip>\n" +
+            "      <aw:Country>USA</aw:Country>\n" +
+            "    </aw:Address>\n" +
+            "    <aw:Address aw:Type=\"Billing\">\n" +
+            "      <aw:Name>Cristian Osorio</aw:Name>\n" +
+            "      <aw:Street>456 Main Street</aw:Street>\n" +
+            "      <aw:City>Buffalo</aw:City>\n" +
+            "      <aw:State>NY</aw:State>\n" +
+            "      <aw:Zip>98112</aw:Zip>\n" +
+            "      <aw:Country>USA</aw:Country>\n" +
+            "    </aw:Address>\n" +
+            "    <aw:DeliveryNotes>Please notify me before shipping.</aw:DeliveryNotes>\n" +
+            "    <aw:Items>\n" +
+            "      <aw:Item aw:PartNumber=\"456-NM\">\n" +
+            "        <aw:ProductName>Power Supply</aw:ProductName>\n" +
+            "        <aw:Quantity>1</aw:Quantity>\n" +
+            "        <aw:USPrice>45.99</aw:USPrice>\n" +
+            "      </aw:Item>\n" +
+            "    </aw:Items>\n" +
+            "  </aw:PurchaseOrder>\n" +
+            "  <aw:PurchaseOrder aw:PurchaseOrderNumber=\"99504\" aw:OrderDate=\"1999-10-22\">\n" +
+            "    <aw:Address aw:Type=\"Shipping\">\n" +
+            "      <aw:Name>Jessica Arnold</aw:Name>\n" +
+            "      <aw:Street>4055 Madison Ave</aw:Street>\n" +
+            "      <aw:City>Seattle</aw:City>\n" +
+            "      <aw:State>WA</aw:State>\n" +
+            "      <aw:Zip>98112</aw:Zip>\n" +
+            "      <aw:Country>USA</aw:Country>\n" +
+            "    </aw:Address>\n" +
+            "    <aw:Address aw:Type=\"Billing\">\n" +
+            "      <aw:Name>Jessica Arnold</aw:Name>\n" +
+            "      <aw:Street>4055 Madison Ave</aw:Street>\n" +
+            "      <aw:City>Buffalo</aw:City>\n" +
+            "      <aw:State>NY</aw:State>\n" +
+            "      <aw:Zip>98112</aw:Zip>\n" +
+            "      <aw:Country>USA</aw:Country>\n" +
+            "    </aw:Address>\n" +
+            "    <aw:Items>\n" +
+            "      <aw:Item aw:PartNumber=\"898-AZ\">\n" +
+            "        <aw:ProductName>Computer Keyboard</aw:ProductName>\n" +
+            "        <aw:Quantity>1</aw:Quantity>\n" +
+            "        <aw:USPrice>29.99</aw:USPrice>\n" +
+            "        <aw:Comment>this thing breaks all the time</aw:Comment>\n" +
+            "      </aw:Item>\n" +
+            "      <aw:Item aw:PartNumber=\"898-AM\">\n" +
+            "        <aw:ProductName>Wireless Mouse</aw:ProductName>\n" +
+            "        <aw:Quantity>1</aw:Quantity>\n" +
+            "        <aw:USPrice>14.99</aw:USPrice>\n" +
+            "      </aw:Item>\n" +
+            "    </aw:Items>\n" +
+            "  </aw:PurchaseOrder>\n" +
+            "</aw:PurchaseOrders>";
+    private Document testDoc;
+    private Node purchaseOrderNode;
+
+
+    @Before
+    public void setUp() throws Exception {
+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
+        documentBuilderFactory.setCoalescing(true);
+        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
+        testDoc = documentBuilder.parse(new InputSource(new StringReader(testXml)));
+        purchaseOrderNode = testDoc.getFirstChild();
+    }
+
+    @Test
+    public void getFirstMatchingNode_shouldReturnValue() {
+        Node resultNode = XmlUtils.getFirstMatchingChildNode(purchaseOrderNode, "aw:PurchaseOrder");
+        assertThat(resultNode).isNotNull();
+    }
+
+    @Test
+    public void getFirstMatchingChildNode_shouldFindNode() throws Exception {
+        ArrayList<String> testList = new ArrayList<String>();
+        testList.add("1999-10-22");
+        Node resultNode = XmlUtils.getFirstMatchingChildNode(purchaseOrderNode, "aw:PurchaseOrder", "aw:OrderDate", testList);
+        assertThat(resultNode).isNotNull();
+        assertThat(resultNode.getNodeName()).isEqualTo("aw:PurchaseOrder");
+        assertThat(resultNode.getAttributes().getNamedItem("aw:OrderDate").getNodeValue()).isEqualTo("1999-10-22");
+    }
+
+    @Test
+    public void getFirstMatchingChildNode_withUnmatchedAttribute_shouldNotFindNode() throws Exception {
+        ArrayList<String> testList = new ArrayList<String>();
+        testList.add("1999-10-");
+        Node resultNode = XmlUtils.getFirstMatchingChildNode(purchaseOrderNode, "aw:PurchaseOrder", "aw:OrderDate", testList);
+        assertThat(resultNode).isNull();
+    }
+
+    @Test
+    public void getMatchingChildNodes_withNullAttributeValues_shouldReturnMultiple() throws Exception {
+        List<Node> results = XmlUtils.getMatchingChildNodes(purchaseOrderNode, "aw:PurchaseOrder", "aw:OrderDate", null);
+        assertThat(results.size()).isEqualTo(3);
+    }
+
+    @Test
+    public void getMatchingChildNodes_withEmptyAttributeValues_shouldReturnNone() {
+        List<Node> results = XmlUtils.getMatchingChildNodes(purchaseOrderNode, "aw:PurchaseOrder", "aw:OrderDate", new ArrayList<String>());
+        assertThat(results).isEmpty();
+    }
+
+    @Test
+    public void testGetListFromDocument() throws Exception {
+        // Get all the "aw:PurchaseOrder" nodes. If any of them have an "aw:OrderDate" attribute, extract a Date.
+        List<Date> orderDates = XmlUtils.getListFromDocument(testDoc, "aw:PurchaseOrder", "aw:OrderDate", null, new XmlUtils.NodeProcessor<Date>() {
+            DateFormat formatter = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
+
+            @Override
+            public Date process(final Node node) {
+                try {
+                    return formatter.parse(node.getAttributes().getNamedItem("aw:OrderDate").getNodeValue());
+                } catch (ParseException e) {
+                    return null;
+                }
+            }
+        });
+
+        assertThat(orderDates.size()).isEqualTo(3);
+        assertThat(orderDates.get(0).getYear()).isEqualTo(99);
+        assertThat(orderDates.get(0).getMonth()).isEqualTo(9);
+        assertThat(orderDates.get(0).getDate()).isEqualTo(20);
+
+        assertThat(orderDates.get(1).getYear()).isEqualTo(99);
+        assertThat(orderDates.get(1).getMonth()).isEqualTo(9);
+        assertThat(orderDates.get(1).getDate()).isEqualTo(22);
+
+        assertThat(orderDates.get(2).getYear()).isEqualTo(99);
+        assertThat(orderDates.get(2).getMonth()).isEqualTo(9);
+        assertThat(orderDates.get(2).getDate()).isEqualTo(22);
+    }
+
+    @Test
+    public void testGetFirstMatchFromDocument() throws Exception {
+        // Get the first "aw:PurchaseOrder" nodes. If it has an "aw:OrderDate" attribute, extract a Date.
+        Date orderDate = XmlUtils.getFirstMatchFromDocument(testDoc, "aw:PurchaseOrder", "aw:OrderDate", null, new XmlUtils.NodeProcessor<Date>() {
+            DateFormat formatter = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
+
+            @Override
+            public Date process(final Node node) {
+                try {
+                    return formatter.parse(node.getAttributes().getNamedItem("aw:OrderDate").getNodeValue());
+                } catch (ParseException e) {
+                    return null;
+                }
+            }
+        });
+
+        assertThat(orderDate).isNotNull();
+        assertThat(orderDate.getYear()).isEqualTo(99);
+        assertThat(orderDate.getMonth()).isEqualTo(9);
+        assertThat(orderDate.getDate()).isEqualTo(20);
+    }
+
+    @Test
+    public void testGetStringDataAsList_shouldFindDeepNested() throws Exception {
+        final List<String> strings = XmlUtils.getStringDataAsList(testDoc, "aw:Comment", null, null);
+        assertThat(strings.size()).isEqualTo(2);
+        assertThat(strings.get(0)).isEqualTo("Confirm this is electric");
+        assertThat(strings.get(1)).isEqualTo("this thing breaks all the time");
+    }
+
+    @Test
+    public void testGetFirstMatchingStringData_shouldFindFirstMatch() throws Exception {
+        final String firstMatch = XmlUtils.getFirstMatchingStringData(testDoc, "aw:Comment", null, null);
+        assertThat(firstMatch).isNotNull();
+        assertThat(firstMatch).isEqualTo("Confirm this is electric");
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mraid/MraidBannerTest.java b/mopub-sdk/src/test/java/com/mopub/mraid/MraidBannerTest.java
new file mode 100644
index 00000000..79d601c8
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mraid/MraidBannerTest.java
@@ -0,0 +1,117 @@
+package com.mopub.mraid;
+
+import android.app.Activity;
+import android.content.Context;
+import android.view.View;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.test.support.TestMraidControllerFactory;
+import com.mopub.mraid.MraidController.MraidListener;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
+import static com.mopub.mobileads.CustomEventBanner.CustomEventBannerListener;
+import static com.mopub.mobileads.MoPubErrorCode.MRAID_LOAD_ERROR;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.verify;
+
+@RunWith(SdkTestRunner.class)
+public class MraidBannerTest {
+    private static final String INPUT_HTML_DATA = "%3Chtml%3E%3C%2Fhtml%3E";
+
+    MraidController mockMraidController;
+    @Mock CustomEventBannerListener mockBannerListener;
+
+    private Context context;
+    private Map<String, Object> localExtras;
+    private Map<String, String> serverExtras;
+
+    private MraidBanner subject;
+
+    @Before
+    public void setUp() {
+        subject = new MraidBanner();
+        mockMraidController = TestMraidControllerFactory.getSingletonMock();
+
+        context = new Activity();
+        localExtras = new HashMap<String, Object>();
+        localExtras.put("broadcastIdentifier", 123L);
+        serverExtras = new HashMap<String, String>();
+        serverExtras.put(HTML_RESPONSE_BODY_KEY, INPUT_HTML_DATA);
+    }
+
+    @Test
+    public void loadBanner_whenExtrasAreMalformed_shouldNotifyBannerListenerFailureAndReturn() {
+        serverExtras.remove(HTML_RESPONSE_BODY_KEY);
+
+        subject.loadBanner(context, mockBannerListener, localExtras, serverExtras);
+
+        verify(mockBannerListener).onBannerFailed(eq(MRAID_LOAD_ERROR));
+    }
+
+    @Test
+    public void invalidate_shouldDestroyMraidController() {
+        subject.loadBanner(context, mockBannerListener, localExtras, serverExtras);
+        subject.onInvalidate();
+
+        verify(mockMraidController).destroy();
+    }
+
+    @Test
+    public void bannerMraidListener_onReady_shouldNotifyBannerLoaded() {
+        MraidListener mraidListener = captureMraidListener();
+        mraidListener.onLoaded(null);
+
+        verify(mockBannerListener).onBannerLoaded(any(View.class));
+    }
+
+    @Test
+    public void bannerMraidListener_onFailure_shouldNotifyBannerFailed() {
+        MraidListener mraidListener = captureMraidListener();
+        mraidListener.onFailedToLoad();
+
+        verify(mockBannerListener).onBannerFailed(eq(MRAID_LOAD_ERROR));
+    }
+
+    @Test
+    public void bannerMraidListener_onExpand_shouldNotifyBannerExpandedAndClicked() {
+        MraidListener mraidListener = captureMraidListener();
+        mraidListener.onExpand();
+
+        verify(mockBannerListener).onBannerExpanded();
+        verify(mockBannerListener).onBannerClicked();
+    }
+
+    @Test
+    public void bannerMraidListener_onOpen_shouldNotifyBannerClicked() {
+        MraidListener mraidListener = captureMraidListener();
+        mraidListener.onOpen();
+
+        verify(mockBannerListener).onBannerClicked();
+    }
+
+    @Test
+    public void bannerMraidListener_onClose_shouldNotifyBannerCollapsed() {
+        MraidListener mraidListener = captureMraidListener();
+        mraidListener.onClose();
+
+        verify(mockBannerListener).onBannerCollapsed();
+    }
+
+    private MraidListener captureMraidListener() {
+        subject.loadBanner(context, mockBannerListener, localExtras, serverExtras);
+        ArgumentCaptor<MraidListener> listenerCaptor = ArgumentCaptor.forClass(MraidListener.class);
+        verify(mockMraidController).setMraidListener(listenerCaptor.capture());
+
+        return listenerCaptor.getValue();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mraid/MraidBridgeTest.java b/mopub-sdk/src/test/java/com/mopub/mraid/MraidBridgeTest.java
new file mode 100644
index 00000000..de6f3239
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mraid/MraidBridgeTest.java
@@ -0,0 +1,290 @@
+package com.mopub.mraid;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.webkit.WebViewClient;
+
+import com.mopub.common.AdReport;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mraid.MraidBridge.MraidBridgeListener;
+import com.mopub.mraid.MraidBridge.MraidWebView;
+import com.mopub.mraid.MraidNativeCommandHandler.MraidCommandFailureListener;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Answers;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Captor;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+
+import java.net.URI;
+import java.util.HashMap;
+import java.util.Map;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyMapOf;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.startsWith;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class MraidBridgeTest {
+    @Mock MraidNativeCommandHandler mockNativeCommandHandler;
+    @Mock MraidBridgeListener mockBridgeListener;
+    @Mock AdReport mockAdReport;
+    @Mock(answer = Answers.RETURNS_DEEP_STUBS) MraidWebView mockBannerWebView;
+    @Mock(answer = Answers.RETURNS_DEEP_STUBS) MraidWebView mockInterstitialWebView;
+    @Captor ArgumentCaptor<WebViewClient> bannerWebViewClientCaptor;
+
+    private Activity activity;
+    private MraidBridge subjectBanner;
+    private MraidBridge subjectInterstitial;
+
+    @Before
+    public void setUp() {
+        activity = Robolectric.buildActivity(Activity.class).create().get();
+
+        subjectBanner = new MraidBridge(mockAdReport, PlacementType.INLINE, mockNativeCommandHandler);
+        subjectBanner.setMraidBridgeListener(mockBridgeListener);
+        subjectBanner.attachView(mockBannerWebView);
+
+        subjectInterstitial = new MraidBridge(mockAdReport, PlacementType.INTERSTITIAL, mockNativeCommandHandler);
+        subjectInterstitial.setMraidBridgeListener(mockBridgeListener);
+        subjectInterstitial.attachView(mockInterstitialWebView);
+
+        verify(mockBannerWebView).setWebViewClient(bannerWebViewClientCaptor.capture());
+        reset(mockBannerWebView);
+    }
+
+    @Test
+    public void attachView_thenDetach_shouldSetMRaidWebView_thenShouldClear() {
+        assertThat(subjectBanner.getMraidWebView()).isEqualTo(mockBannerWebView);
+
+        subjectBanner.detach();
+        assertThat(subjectBanner.getMraidWebView()).isNull();
+    }
+
+    @Test
+    public void attachView_thenOnPageFinished_shouldFireReady() {
+        bannerWebViewClientCaptor.getValue().onPageFinished(mockBannerWebView, "fake://url");
+
+        verify(mockBridgeListener).onPageLoaded();
+    }
+
+    @Test
+    public void attachView_thenOnPageFinished_twice_shouldNotFireReadySecondTime() {
+        bannerWebViewClientCaptor.getValue().onPageFinished(mockBannerWebView, "fake://url");
+        bannerWebViewClientCaptor.getValue().onPageFinished(mockBannerWebView, "fake://url2");
+
+        verify(mockBridgeListener, times(1)).onPageLoaded();
+    }
+
+    @Test
+    public void attachView_thenSetContentHtml_shouldCallLoadDataWithBaseURL() {
+        subjectBanner.setContentHtml("test-html");
+
+        verify(mockBannerWebView).loadDataWithBaseURL(
+                null, "test-html", "text/html", "UTF-8", null);
+    }
+
+    @Test
+    public void handleShouldOverrideUrl_invalidUrl_shouldFireErrorEvent() {
+        boolean result = subjectBanner.handleShouldOverrideUrl("bad bad bad");
+
+        verify(mockBannerWebView).loadUrl(startsWith(
+                "javascript:window.mraidbridge.notifyErrorEvent"));
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void handleShouldOverrideUrl_mopubNonFailLoadUrl_shouldNeverLoadUrl_shouldReturnTrue() {
+        boolean result = subjectBanner.handleShouldOverrideUrl("mopub://special-mopub-command");
+
+        verify(mockBannerWebView, never()).loadUrl(anyString());
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void handleShouldOverrideUrl_mopubFailLoadUrl_whenBanner_shouldNotifyListenerOfOnPageFailedToLoad_shouldReturnTrue() {
+        boolean result = subjectBanner.handleShouldOverrideUrl("mopub://failLoad");
+
+        verify(mockBridgeListener).onPageFailedToLoad();
+        verify(mockBannerWebView, never()).loadUrl(anyString());
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void handleShouldOverrideUrl_mopubFailLoadUrl_whenInterstitial_shouldNotNotifyListenerOfOnPageFailedToLoad_shouldReturnTrue() {
+        boolean result = subjectInterstitial.handleShouldOverrideUrl("mopub://failLoad");
+
+        verify(mockBridgeListener, never()).onPageFailedToLoad();
+        verify(mockBannerWebView, never()).loadUrl(anyString());
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void handleShouldOverrideUrl_mraidUrl_invalid_shouldFireErrorEvent_shouldReturnTrue() {
+        boolean result = subjectBanner.handleShouldOverrideUrl("mraid://bad-command");
+
+        verify(mockBannerWebView).loadUrl(startsWith(
+                "javascript:window.mraidbridge.notifyErrorEvent"));
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void handleShouldOverrideUrl_smsUrl_notClicked_shouldReturnFalse() {
+        boolean result = subjectBanner.handleShouldOverrideUrl("sms://123456789");
+
+        assertThat(result).isFalse();
+    }
+
+    @Test
+    public void handleShouldOverrideUrl_smsUrl_clicked_shouldStartActivity() {
+        subjectBanner.setClicked(true);
+        reset(mockBannerWebView);
+        when(mockBannerWebView.getContext()).thenReturn(activity);
+
+        boolean result = subjectBanner.handleShouldOverrideUrl("sms://123456789");
+
+        Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(startedIntent).isNotNull();
+        assertThat(startedIntent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
+        assertThat(startedIntent.getComponent()).isNull();
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void handleShouldOverrideUrl_normalUrl_shouldReturnFalse() {
+        boolean result = subjectBanner.handleShouldOverrideUrl("http://www.mopub.com");
+
+        assertThat(result).isFalse();
+    }
+
+    @Test(expected = MraidCommandException.class)
+    public void runCommand_requiresClick_notClicked_shouldThrowException()
+            throws MraidCommandException {
+        subjectBanner = new MraidBridge(mockAdReport, PlacementType.INLINE);
+        subjectBanner.attachView(mockBannerWebView);
+        subjectBanner.setClicked(false);
+        Map<String, String> params = new HashMap<String, String>();
+        params.put("uri", "http://valid-url");
+
+        subjectBanner.runCommand(MraidJavascriptCommand.PLAY_VIDEO, params);
+    }
+
+    public void runCommand_requiresClick_clicked_shouldNotThrowException()
+            throws MraidCommandException {
+        subjectBanner.setClicked(true);
+        Map<String, String> params = new HashMap<String, String>();
+        params.put("uri", "http://valid-url");
+
+        subjectBanner.runCommand(MraidJavascriptCommand.PLAY_VIDEO, params);
+    }
+
+    @Test(expected = MraidCommandException.class)
+    public void runCommand_interstitial_requiresClick_notClicked_shouldThrowException()
+            throws MraidCommandException {
+        subjectInterstitial.setClicked(false);
+        Map<String, String> params = new HashMap<String, String>();
+        params.put("uri", "http://valid-url");
+
+        subjectInterstitial.runCommand(MraidJavascriptCommand.OPEN, params);
+    }
+
+    @Test
+    public void runCommand_interstitial_requiresClick_clicked_shouldNotThrowException()
+            throws MraidCommandException {
+        subjectInterstitial.setClicked(true);
+        Map<String, String> params = new HashMap<String, String>();
+        params.put("url", "http://valid-url");
+
+        subjectInterstitial.runCommand(MraidJavascriptCommand.OPEN, params);
+    }
+
+    @Test
+    public void runCommand_close_shouldCallListener()
+            throws MraidCommandException {
+        Map<String, String> params = new HashMap<String, String>();
+        
+        subjectBanner.runCommand(MraidJavascriptCommand.CLOSE, params);
+
+        verify(mockBridgeListener).onClose();
+    }
+
+    @Test
+    public void runCommand_expand_shouldCallListener()
+            throws MraidCommandException {
+        subjectBanner.setClicked(true);
+        Map<String, String> params = new HashMap<String, String>();
+        params.put("shouldUseCustomClose", "true");
+
+        subjectBanner.runCommand(MraidJavascriptCommand.EXPAND, params);
+
+        verify(mockBridgeListener).onExpand(null, true);
+    }
+
+    @Test
+    public void runCommand_expand_withUrl_shouldCallListener()
+            throws MraidCommandException {
+        subjectBanner.setClicked(true);
+        Map<String, String> params = new HashMap<String, String>();
+        params.put("url", "http://valid-url");
+        params.put("shouldUseCustomClose", "true");
+
+        subjectBanner.runCommand(MraidJavascriptCommand.EXPAND, params);
+
+        ArgumentCaptor<URI> uriCaptor = ArgumentCaptor.forClass(URI.class);
+        verify(mockBridgeListener).onExpand(
+                uriCaptor.capture(), eq(true));
+        assertThat(uriCaptor.getValue().toString()).isEqualTo("http://valid-url");
+    }
+
+    @Test
+    public void runCommand_playVideo_shouldCallListener()
+            throws MraidCommandException {
+        subjectBanner.setClicked(true);
+        Map<String, String> params = new HashMap<String, String>();
+        params.put("uri", "http://valid-url");
+
+        subjectBanner.runCommand(MraidJavascriptCommand.PLAY_VIDEO, params);
+
+        ArgumentCaptor<URI> uriCaptor = ArgumentCaptor.forClass(URI.class);
+        verify(mockBridgeListener).onPlayVideo(uriCaptor.capture());
+        assertThat(uriCaptor.getValue().toString()).isEqualTo("http://valid-url");
+    }
+
+    @Test
+    public void runCommand_storePicture_shouldCallListener()
+            throws MraidCommandException {
+        subjectBanner.setClicked(true);
+        Map<String, String> params = new HashMap<String, String>();
+        params.put("uri", "http://valid-url");
+
+        subjectBanner.runCommand(MraidJavascriptCommand.STORE_PICTURE, params);
+
+        verify(mockNativeCommandHandler).storePicture(any(Context.class), eq("http://valid-url"),
+                any(MraidCommandFailureListener.class));
+    }
+
+    @Test
+    public void runCommand_createCalendarEvent_shouldCallListener()
+            throws MraidCommandException {
+        subjectBanner.setClicked(true);
+        Map<String, String> params = new HashMap<String, String>();
+        params.put("eventName", "Dinner at my house");
+
+        subjectBanner.runCommand(MraidJavascriptCommand.CREATE_CALENDAR_EVENT, params);
+
+        verify(mockNativeCommandHandler).createCalendarEvent(any(Context.class),
+                anyMapOf(String.class, String.class));
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mraid/MraidControllerTest.java b/mopub-sdk/src/test/java/com/mopub/mraid/MraidControllerTest.java
new file mode 100644
index 00000000..bc6fce11
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mraid/MraidControllerTest.java
@@ -0,0 +1,1040 @@
+package com.mopub.mraid;
+
+import android.app.Activity;
+import android.content.ComponentName;
+import android.content.Intent;
+import android.content.pm.ActivityInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.net.Uri;
+import android.os.Build;
+import android.view.View;
+import android.widget.FrameLayout;
+
+import com.mopub.common.AdReport;
+import com.mopub.common.CloseableLayout.ClosePosition;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.Utils;
+import com.mopub.mobileads.BaseVideoPlayerActivityTest;
+import com.mopub.mobileads.MraidVideoPlayerActivity;
+import com.mopub.mraid.MraidBridge.MraidBridgeListener;
+import com.mopub.mraid.MraidBridge.MraidWebView;
+import com.mopub.mraid.MraidController.MraidListener;
+import com.mopub.mraid.MraidController.OrientationBroadcastReceiver;
+import com.mopub.mraid.MraidController.ScreenMetricsWaiter;
+import com.mopub.mraid.MraidController.ScreenMetricsWaiter.WaitRequest;
+import com.mopub.mraid.MraidController.UseCustomCloseListener;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Captor;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+
+import java.net.URI;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.fest.assertions.api.Assertions.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyBoolean;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class MraidControllerTest {
+    private long broadcastIdentifier = 123;
+    @Mock private AdReport mockAdReport;
+    @Mock private MraidBridge mockBridge;
+    @Mock private MraidBridge mockTwoPartBridge;
+    @Mock private ScreenMetricsWaiter mockScreenMetricsWaiter;
+    @Mock private WaitRequest mockWaitRequest;
+    @Mock private MraidListener mockMraidListener;
+    @Mock private UseCustomCloseListener mockUseCustomCloseListener;
+    @Mock private OrientationBroadcastReceiver mockOrientationBroadcastReceiver;
+    @Captor private ArgumentCaptor<MraidBridgeListener> bridgeListenerCaptor;
+    @Captor private ArgumentCaptor<MraidBridgeListener> twoPartBridgeListenerCaptor;
+
+    private Activity activity;
+    private FrameLayout rootView;
+
+    private MraidController subject;
+
+    @Before
+    public void setUp() {
+        Robolectric.setDisplayMetricsDensity(1.0f);
+
+        activity = spy(Robolectric.buildActivity(Activity.class).create().get());
+        activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+
+        rootView = new FrameLayout(activity);
+        when(mockBridge.isVisible()).thenReturn(true);
+
+        // By default, immediately fulfill a screen metrics wait request. Individual tests can
+        // reset this, if desired.
+        when(mockScreenMetricsWaiter.waitFor(Mockito.<View>anyVararg()))
+                .thenReturn(mockWaitRequest);
+        doAnswer(new Answer<Void>() {
+            @Override
+            public Void answer(final InvocationOnMock invocation) throws Throwable {
+                Runnable runnable = (Runnable) invocation.getArguments()[0];
+                runnable.run();
+                return null;
+            }
+        }).when(mockWaitRequest).start(any(Runnable.class));
+
+        subject = new MraidController(
+                activity, mockAdReport, PlacementType.INLINE,
+                mockBridge, mockTwoPartBridge, mockScreenMetricsWaiter);
+        subject.setMraidListener(mockMraidListener);
+        subject.setOrientationBroadcastReceiver(mockOrientationBroadcastReceiver);
+        subject.setRootView(rootView);
+        subject.loadContent("fake_html_data");
+
+        verify(mockBridge).setMraidBridgeListener(bridgeListenerCaptor.capture());
+        verify(mockTwoPartBridge).setMraidBridgeListener(twoPartBridgeListenerCaptor.capture());
+    }
+
+    @Test
+    public void constructor_shouldSetStateToLoading() {
+        ViewState state = subject.getViewState();
+
+        assertThat(state).isEqualTo(ViewState.LOADING);
+    }
+
+    @Test
+    public void bridgeOnReady_shouldSetStateToDefault_shouldCallListener() {
+        bridgeListenerCaptor.getValue().onPageLoaded();
+
+        ViewState state = subject.getViewState();
+
+        assertThat(state).isEqualTo(ViewState.DEFAULT);
+        verify(mockMraidListener).onLoaded(any(View.class));
+    }
+
+    @Test
+    public void handlePageLoad_shouldNotifyBridgeOfVisibilityPlacementScreenSizeAndSupports() {
+        when(mockBridge.isVisible()).thenReturn(true);
+
+        subject.handlePageLoad();
+
+        verify(mockBridge).notifyViewability(true);
+        verify(mockBridge).notifyPlacementType(PlacementType.INLINE);
+        verify(mockBridge).notifyScreenMetrics(any(MraidScreenMetrics.class));
+
+        // The actual values here are supplied by the Mraids class, which has separate tests.
+        verify(mockBridge).notifySupports(false, false, false, false, false);
+    }
+
+    @Test
+    public void handlePageLoad_shouldCancelLastRequest() {
+        subject.handlePageLoad();
+
+        verify(mockScreenMetricsWaiter).cancelLastRequest();
+    }
+
+    @Test
+    public void handlePageLoad_thenDestroy_shouldCancelLastRequest() {
+        subject.handlePageLoad();
+        subject.destroy();
+
+        verify(mockScreenMetricsWaiter, times(2)).cancelLastRequest();
+    }
+
+    @Test
+    public void onPageFailedToLoad_shouldNotifyListener() {
+        bridgeListenerCaptor.getValue().onPageFailedToLoad();
+
+        verify(mockMraidListener).onFailedToLoad();
+    }
+
+    @Test
+    public void onPageFailedToLoad_withTwoPartBridge_shouldNotNotifyListener() {
+        twoPartBridgeListenerCaptor.getValue().onPageFailedToLoad();
+
+        verify(mockMraidListener, never()).onFailedToLoad();
+    }
+
+    @Test
+    public void bridgeOnVisibilityChanged_withTwoPartBridgeAttached_shouldNotNotifyVisibility() {
+        when(mockTwoPartBridge.isAttached()).thenReturn(true);
+
+        bridgeListenerCaptor.getValue().onVisibilityChanged(true);
+        bridgeListenerCaptor.getValue().onVisibilityChanged(false);
+
+        verify(mockBridge, never()).notifyViewability(anyBoolean());
+        verify(mockTwoPartBridge, never()).notifyViewability(anyBoolean());
+    }
+
+    @Test
+    public void handleResize_shouldBeIgnoredWhenLoadingOrHidden() throws MraidCommandException {
+        subject.setViewStateForTesting(ViewState.LOADING);
+        subject.handleResize(100, 200, 0, 0, ClosePosition.TOP_RIGHT, true);
+        assertThat(subject.getViewState()).isEqualTo(ViewState.LOADING);
+
+        subject.setViewStateForTesting(ViewState.HIDDEN);
+        subject.handleResize(100, 200, 0, 0, ClosePosition.TOP_RIGHT, true);
+        assertThat(subject.getViewState()).isEqualTo(ViewState.HIDDEN);
+    }
+
+    @Test(expected = MraidCommandException.class)
+    public void handleResize_shouldThrowExceptionWhenExpanded() throws MraidCommandException {
+        subject.setViewStateForTesting(ViewState.EXPANDED);
+        subject.handleResize(100, 200, 0, 0, ClosePosition.TOP_RIGHT, true);
+    }
+
+    @Test(expected = MraidCommandException.class)
+    public void handleResize_shouldThrowExceptionForInterstitial() throws MraidCommandException {
+        MraidListener listener = mock(MraidListener.class);
+        subject = new MraidController(activity, mockAdReport, PlacementType.INTERSTITIAL,
+                mockBridge, mockTwoPartBridge, mockScreenMetricsWaiter);
+        subject.setMraidListener(listener);
+        subject.setRootView(rootView);
+
+        // Move to DEFAULT state
+        subject.loadContent("fake_html_data");
+        subject.handlePageLoad();
+
+        subject.handleResize(100, 200, 0, 0, ClosePosition.TOP_RIGHT, true);
+    }
+
+    @Test
+    public void handleResize_shouldMoveWebViewToResizedContainer_shouldSetResizedState()
+            throws MraidCommandException {
+        // Move to DEFAULT state
+        subject.handlePageLoad();
+        subject.setRootViewSize(100, 100);
+
+        subject.handleResize(100, 100, 0, 0, ClosePosition.TOP_RIGHT, true);
+        assertThat(subject.getExpandedAdContainer().getChildCount()).isEqualTo(2);
+        assertThat(subject.getAdContainer().getChildCount()).isEqualTo(0);
+        assertThat(subject.getViewState()).isEqualTo(ViewState.RESIZED);
+    }
+
+    @Test
+    public void handleResize_noAllowOffscreen_smallView_shouldResize()
+            throws MraidCommandException {
+        // Move to DEFAULT state
+        subject.handlePageLoad();
+        subject.setRootViewSize(100, 100);
+
+        subject.handleResize(50, 50, 0, 0, ClosePosition.TOP_RIGHT, /* allowOffscreen */ false);
+        assertThat(subject.getViewState()).isEqualTo(ViewState.RESIZED);
+    }
+
+    @Test(expected = MraidCommandException.class)
+    public void handleResize_noAllowOffscreen_largeView_shouldThrowException()
+            throws MraidCommandException {
+        // Move to DEFAULT state
+        subject.handlePageLoad();
+        subject.setRootViewSize(100, 100);
+
+        subject.handleResize(101, 101, 0, 0, ClosePosition.TOP_RIGHT, /* allowOffscreen */ false);
+    }
+
+    @Test(expected = MraidCommandException.class)
+    public void handleResize_allowOffscreen_largeView_closeButtonTopRight_shouldThrowException()
+            throws MraidCommandException {
+        // Move to DEFAULT state
+        subject.handlePageLoad();
+        subject.setRootViewSize(100, 100);
+
+        subject.handleResize(150, 150, 0, 0, ClosePosition.TOP_RIGHT, /* allowOffscreen */ true);
+    }
+
+    @Test
+    public void handleResize_allowOffscreen_closeButtonTopLeft_shouldNotThrowException()
+            throws MraidCommandException {
+        // Move to DEFAULT state
+        subject.handlePageLoad();
+        subject.setRootViewSize(100, 100);
+
+        subject.handleResize(150, 150, 0, 0, ClosePosition.TOP_LEFT, /* allowOffscreen */ true);
+        assertThat(subject.getViewState()).isEqualTo(ViewState.RESIZED);
+    }
+
+    @Test(expected = MraidCommandException.class)
+    public void handleResize_allowOffscreen_largeOffset_closeButtonBottomRight_shouldThrowException()
+            throws MraidCommandException {
+        // Move to DEFAULT state
+        subject.handlePageLoad();
+        subject.setRootViewSize(100, 1000);
+
+        // Throws an exception because the close button overlaps the edge
+        subject.handleResize(100, 100, 25, 25, ClosePosition.BOTTOM_RIGHT, /* allowOffscreen */
+                true);
+    }
+
+    @Test
+    public void handleResize_allowOffscreen_largeOffset_closeButtonBottomLeft_shouldNotThrowException()
+            throws MraidCommandException {
+        // Move to DEFAULT state
+        subject.handlePageLoad();
+        subject.setRootViewSize(100, 1000);
+
+        subject.handleResize(100, 100, 25, 25, ClosePosition.BOTTOM_LEFT, /* allowOffscreen */
+                true);
+        assertThat(subject.getViewState()).isEqualTo(ViewState.RESIZED);
+    }
+
+    @Test(expected = MraidCommandException.class)
+    public void handleResize_heightSmallerThan50Dips_shouldFail() throws MraidCommandException {
+        subject.handlePageLoad();
+        subject.setRootViewSize(100, 100);
+        subject.handleResize(100, 49, 25, 25, ClosePosition.BOTTOM_LEFT, /* allowOffscreen */
+                false);
+    }
+
+    @Test(expected = MraidCommandException.class)
+    public void handleResize_widthSmallerThan50Dips_shouldFail() throws MraidCommandException {
+        subject.handlePageLoad();
+        subject.setRootViewSize(100, 100);
+        subject.handleResize(49, 100, 25, 25, ClosePosition.BOTTOM_LEFT, /* allowOffscreen */
+                false);
+    }
+
+    @Test
+    public void handleClose_fromResizedState_shouldMoveWebViewToOriginalContainer_shouldNotFireOnClose()
+            throws MraidCommandException {
+        // Move to RESIZED state
+        subject.handlePageLoad();
+        subject.setRootViewSize(100, 100);
+        subject.handleResize(100, 100, 0, 0, ClosePosition.TOP_RIGHT, false);
+
+        subject.handleClose();
+
+        assertThat(subject.getExpandedAdContainer().getChildCount()).isEqualTo(1);
+        assertThat(subject.getAdContainer().getChildCount()).isEqualTo(1);
+        assertThat(subject.getViewState()).isEqualTo(ViewState.DEFAULT);
+        verify(mockMraidListener, never()).onClose();
+    }
+
+    @Test(expected = MraidCommandException.class)
+    public void handleExpand_afterDestroy_shouldThrowException() throws MraidCommandException {
+        subject.destroy();
+        subject.handleExpand(null, false);
+    }
+
+    @Test
+    public void handleExpand_shouldBeIgnoredForInterstitial() throws MraidCommandException {
+        MraidListener listener = mock(MraidListener.class);
+        subject = new MraidController(activity, mockAdReport, PlacementType.INTERSTITIAL,
+                mockBridge, mockTwoPartBridge, mockScreenMetricsWaiter);
+        subject.setMraidListener(listener);
+        subject.setRootView(rootView);
+
+        // Move to DEFAULT state
+        subject.loadContent("fake_html_data");
+        subject.handlePageLoad();
+
+        subject.handleExpand(null, false);
+
+        assertThat(subject.getViewState()).isEqualTo(ViewState.DEFAULT);
+        verify(listener, never()).onExpand();
+    }
+
+    @Test
+    public void handleExpand_shouldBeIgnoredWhenLoadingHiddenOrExpanded()
+            throws MraidCommandException {
+        subject.setViewStateForTesting(ViewState.LOADING);
+        subject.handleExpand(null, false);
+        assertThat(subject.getViewState()).isEqualTo(ViewState.LOADING);
+        verify(mockMraidListener, never()).onExpand();
+
+        subject.setViewStateForTesting(ViewState.HIDDEN);
+        subject.handleExpand(null, false);
+        assertThat(subject.getViewState()).isEqualTo(ViewState.HIDDEN);
+        verify(mockMraidListener, never()).onExpand();
+
+        subject.setViewStateForTesting(ViewState.EXPANDED);
+        subject.handleExpand(null, false);
+        assertThat(subject.getViewState()).isEqualTo(ViewState.EXPANDED);
+        verify(mockMraidListener, never()).onExpand();
+    }
+
+    @Test
+    public void handleExpand_withNoUrl_shouldMoveWebViewToExpandedContainer_shouldCallOnExpand()
+            throws MraidCommandException {
+        // Move to DEFAULT state
+        subject.handlePageLoad();
+
+        subject.handleExpand(null, false);
+
+        assertThat(subject.getExpandedAdContainer().getChildCount()).isEqualTo(2);
+        assertThat(subject.getAdContainer().getChildCount()).isEqualTo(0);
+        verify(mockMraidListener).onExpand();
+    }
+
+    @Test
+    public void handleExpand_withTwoPartUrl_shouldAttachTwoPartBridge_shouldCallOnExpand()
+            throws MraidCommandException {
+        // Move to DEFAULT state
+        subject.handlePageLoad();
+
+        subject.handleExpand(URI.create("http://two-part-url"), false);
+
+        verify(mockTwoPartBridge).setMraidBridgeListener(any(MraidBridgeListener.class));
+        verify(mockTwoPartBridge).attachView(any(MraidWebView.class));
+        verify(mockTwoPartBridge).setContentUrl(URI.create("http://two-part-url").toString());
+
+        assertThat(subject.getExpandedAdContainer().getChildCount()).isEqualTo(2);
+        assertThat(subject.getAdContainer().getChildCount()).isEqualTo(1);
+        verify(mockMraidListener).onExpand();
+        assertThat(subject.getViewState()).isEqualTo(ViewState.EXPANDED);
+    }
+
+    @Test
+    public void handleClose_afterDestroy_shouldNotFireOnClose() {
+        subject.destroy();
+        subject.handleClose();
+
+        verify(mockMraidListener, never()).onClose();
+    }
+
+    @Test
+    public void handleClose_fromExpandedState_shouldMoveWebViewToOriginalContainer_shouldNotFireOnClose() throws MraidCommandException {
+        // Move to EXPANDED state
+        subject.handlePageLoad();
+        subject.handleExpand(null, false);
+
+        subject.handleClose();
+
+        assertThat(subject.getExpandedAdContainer().getChildCount()).isEqualTo(1);
+        assertThat(subject.getAdContainer().getChildCount()).isEqualTo(1);
+        assertThat(subject.getViewState()).isEqualTo(ViewState.DEFAULT);
+        verify(mockMraidListener, never()).onClose();
+    }
+
+    @Test
+    public void handleClose_fromTwoPartExpandedState_shouldDetachTwoPartBridge_shouldMoveWebViewToOriginalContainer_shouldNotFireOnClose()
+            throws MraidCommandException {
+        URI uri = URI.create("http://two-part-url");
+
+        // Move to two part EXPANDED state
+        subject.handlePageLoad();
+        subject.handleExpand(uri, false);
+        when(mockTwoPartBridge.isAttached()).thenReturn(true);
+
+        subject.handleClose();
+
+        verify(mockTwoPartBridge).detach();
+        assertThat(subject.getExpandedAdContainer().getChildCount()).isEqualTo(1);
+        assertThat(subject.getAdContainer().getChildCount()).isEqualTo(1);
+        assertThat(subject.getViewState()).isEqualTo(ViewState.DEFAULT);
+
+        verify(mockMraidListener, never()).onClose();
+    }
+
+    @Test
+    public void handleClose_fromDefaultState_shouldHideAdContainer_shouldCallOnClose() {
+        // Move to DEFAULT state
+        subject.handlePageLoad();
+        assertThat(subject.getViewState()).isEqualTo(ViewState.DEFAULT);
+
+        subject.handleClose();
+
+        assertThat(subject.getAdContainer().getVisibility()).isEqualTo(View.INVISIBLE);
+        assertThat(subject.getViewState()).isEqualTo(ViewState.HIDDEN);
+
+        verify(mockMraidListener).onClose();
+    }
+
+    @Test
+    public void handleShowVideo_shouldStartVideoPlayerActivity() {
+        subject.handleShowVideo("http://video");
+        BaseVideoPlayerActivityTest.assertMraidVideoPlayerActivityStarted(
+                MraidVideoPlayerActivity.class, "http://video");
+    }
+
+    @Test
+    public void handleCustomClose_shouldUpdateExpandedContainer() {
+        subject.handleCustomClose(true);
+        assertThat(subject.getExpandedAdContainer().isCloseVisible()).isFalse();
+
+        subject.handleCustomClose(false);
+        assertThat(subject.getExpandedAdContainer().isCloseVisible()).isTrue();
+    }
+
+    @Test
+    public void handleCustomClose_shouldCallCustomCloseChangedListener() {
+        subject.setUseCustomCloseListener(mockUseCustomCloseListener);
+
+        subject.handleCustomClose(true);
+        verify(mockUseCustomCloseListener).useCustomCloseChanged(true);
+
+        reset(mockUseCustomCloseListener);
+        subject.handleCustomClose(false);
+        verify(mockUseCustomCloseListener).useCustomCloseChanged(false);
+    }
+
+    @Test
+    public void handleOpen_withMoPubNativeBrowserUrl_shouldOpenExternalBrowser() {
+        subject.handleOpen("mopubnativebrowser://navigate?url=https%3A%2F%2Fwww.example.com");
+
+        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(intent.getDataString()).isEqualTo("https://www.example.com");
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
+    }
+
+    @Test
+    public void handleOpen_withMalformedMoPubNativeBrowserUrl_shouldNotStartNewActivity() {
+        // invalid host parameter 'nav'
+        subject.handleOpen("mopubnativebrowser://nav?url=https%3A%2F%2Fwww.example.com");
+
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+    }
+
+    @Test
+    public void handleOpen_withApplicationUrl_shouldStartNewIntent() {
+        String applicationUrl = "amzn://blah";
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(Intent.ACTION_VIEW, Uri
+                .parse(applicationUrl)), new ResolveInfo());
+
+        subject.handleOpen(applicationUrl);
+
+        Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(startedIntent).isNotNull();
+        // Since we are not using an Activity context, we should have FLAG_ACTIVITY_NEW_TASK
+        assertThat(Utils.bitMaskContainsFlag(startedIntent.getFlags(),
+                Intent.FLAG_ACTIVITY_NEW_TASK)).isTrue();
+        assertThat(startedIntent.getComponent()).isNull();
+
+        verify(mockMraidListener).onOpen();
+    }
+
+    @Test
+    public void handleOpen_withHttpApplicationUrl_shouldStartMoPubBrowser() {
+        String applicationUrl = "http://blah";
+
+        subject.handleOpen(applicationUrl);
+
+        Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(startedIntent).isNotNull();
+        // Since we are not using an Activity context, we should have FLAG_ACTIVITY_NEW_TASK
+        assertThat(Utils.bitMaskContainsFlag(startedIntent.getFlags(),
+                Intent.FLAG_ACTIVITY_NEW_TASK)).isTrue();
+        assertThat(startedIntent.getComponent().getClassName())
+                .isEqualTo("com.mopub.common.MoPubBrowser");
+
+        verify(mockMraidListener).onOpen();
+    }
+
+    @Test
+    public void handleOpen_withApplicationUrlThatCantBeHandled_shouldDefaultToMoPubBrowser()
+            throws Exception {
+        String applicationUrl = "canthandleme://blah";
+
+        subject.handleOpen(applicationUrl);
+
+        Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(startedIntent).isNull();
+
+        verify(mockMraidListener).onOpen();
+    }
+
+    @Test
+    public void handleOpen_withAboutBlankUrl_shouldFailSilently() {
+        final String url = "about:blank";
+
+        subject.handleOpen(url);
+
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+    }
+
+    @Test
+    public void orientationBroadcastReceiver_whenUnregistered_shouldIgnoreOnReceive() {
+        Intent intent = mock(Intent.class);
+        when(intent.getAction()).thenReturn("some bogus action which we hope never to see");
+
+        MraidController.OrientationBroadcastReceiver receiver =
+                subject.new OrientationBroadcastReceiver();
+        receiver.register(activity);
+        receiver.unregister();
+        receiver.onReceive(activity, intent);
+
+        verify(intent, never()).getAction();
+    }
+
+    @Test
+    public void orientationProperties_shouldDefaultToAllowChangeTrueAndForceOrientationNone() {
+        // These are the default values provided by the MRAID spec
+        assertThat(subject.getAllowOrientationChange()).isTrue();
+        assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.NONE);
+    }
+
+    @Test
+    public void handleSetOrientationProperties_withForcedOrientation_shouldUpdateProperties() throws MraidCommandException, PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        subject.handleSetOrientationProperties(false, MraidOrientation.LANDSCAPE);
+
+        assertThat(subject.getAllowOrientationChange()).isFalse();
+        assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.LANDSCAPE);
+    }
+
+    @Test
+    public void handleSetOrientationProperties_withOrientationNone_withApplicationContext_shouldUpdateProperties() throws MraidCommandException, PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        subject = new MraidController(
+                activity.getApplicationContext(), mockAdReport, PlacementType.INLINE,
+                mockBridge, mockTwoPartBridge, mockScreenMetricsWaiter);
+
+        subject.handleSetOrientationProperties(false, MraidOrientation.NONE);
+
+        assertThat(subject.getAllowOrientationChange()).isFalse();
+        assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.NONE);
+    }
+
+    @Test
+    public void handleSetOrientationProperties_withForcedOrientation_withApplicationContext_shouldThrowMraidCommandExceptionAndNotUpdateProperties() throws PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        subject = new MraidController(
+                activity.getApplicationContext(), mockAdReport, PlacementType.INLINE,
+                mockBridge, mockTwoPartBridge, mockScreenMetricsWaiter);
+
+        try {
+            subject.handleSetOrientationProperties(false, MraidOrientation.LANDSCAPE);
+            fail("Expected MraidCommandException");
+        } catch (MraidCommandException e) {
+            // pass
+        }
+
+        assertThat(subject.getAllowOrientationChange()).isTrue();
+        assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.NONE);
+    }
+
+    @Test
+    public void handleSetOrientationProperties_withActivityInfoNotFound_shouldThrowMraidCommandException() throws PackageManager.NameNotFoundException {
+        setMockActivityInfo(false, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        try {
+            subject.handleSetOrientationProperties(false, MraidOrientation.LANDSCAPE);
+            fail("Expected MraidCommandException");
+        } catch (MraidCommandException e) {
+            // pass
+        }
+
+        assertThat(subject.getAllowOrientationChange()).isTrue();
+        assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.NONE);
+    }
+
+    @Test
+    public void handleSetOrientationProperties_whenTryingToSetToOrientationDeclaredInManifest_shouldUpdateProperties() throws Exception {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_PORTRAIT,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        subject.handleSetOrientationProperties(true, MraidOrientation.PORTRAIT);
+
+        assertThat(subject.getAllowOrientationChange()).isTrue();
+        assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.PORTRAIT);
+    }
+
+    @Test
+    public void handleSetOrientationProperties_whenTryingToSetToOrientationDifferentFromManifest_shouldThrowMraidCommandException() throws Exception {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_PORTRAIT,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        try {
+            subject.handleSetOrientationProperties(true, MraidOrientation.LANDSCAPE);
+            fail("Expected MraidCommandException");
+        } catch (MraidCommandException e) {
+            // pass
+        }
+
+        assertThat(subject.getAllowOrientationChange()).isTrue();
+        assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.NONE);
+    }
+
+    @Test
+    public void handleSetOrientationProperties_withForcedOrientation_withMissingConfigChangeOrientation_shouldThrowMraidCommandException() throws Exception {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                /* missing CONFIG_ORIENTATION */ ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        try {
+            subject.handleSetOrientationProperties(true, MraidOrientation.PORTRAIT);
+            fail("Expected MraidCommandException");
+        } catch (MraidCommandException e) {
+            // pass
+        }
+
+        assertThat(subject.getAllowOrientationChange()).isTrue();
+        assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.NONE);
+    }
+
+    @Config(reportSdk = Build.VERSION_CODES.HONEYCOMB_MR1)
+    @Test
+    public void handleSetOrientationProperties_beforeHoneycombMr2_withMissingConfigChangeScreenSize_shouldUpdateProperties() throws Exception {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION);
+
+        subject.handleSetOrientationProperties(false, MraidOrientation.LANDSCAPE);
+
+        assertThat(subject.getAllowOrientationChange()).isFalse();
+        assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.LANDSCAPE);
+    }
+
+    @Config(reportSdk = Build.VERSION_CODES.HONEYCOMB_MR2)
+    @Test
+    public void handleSetOrientationProperties_atLeastHoneycombMr2_withMissingConfigChangeScreenSize_shouldThrowMraidCommandException() throws Exception {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION);
+
+        try {
+            subject.handleSetOrientationProperties(false, MraidOrientation.LANDSCAPE);
+            fail("Expected MraidCommandException");
+        } catch (MraidCommandException e) {
+            // pass
+        }
+
+        assertThat(subject.getAllowOrientationChange()).isTrue();
+        assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.NONE);
+    }
+
+    @Test
+    public void handleSetOrientationProperties_forExpandedBanner_shouldImmediatelyChangeScreenOrientation() throws MraidCommandException, PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        subject.handlePageLoad();
+        subject.handleExpand(null, false);
+
+        subject.handleSetOrientationProperties(true, MraidOrientation.LANDSCAPE);
+
+        assertThat(activity.getRequestedOrientation()).isEqualTo(ActivityInfo
+                .SCREEN_ORIENTATION_LANDSCAPE);
+    }
+
+    @Test
+    public void handleSetOrientationProperties_forExpandedBanner_beforeExpandIsCalled_shouldChangeScreenOrientationUponExpand() throws MraidCommandException, PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        subject.handlePageLoad();
+        subject.handleSetOrientationProperties(true, MraidOrientation.LANDSCAPE);
+
+        assertThat(activity.getRequestedOrientation()).isEqualTo(ActivityInfo
+                .SCREEN_ORIENTATION_PORTRAIT);
+
+        subject.handleExpand(null, false);
+
+        assertThat(activity.getRequestedOrientation()).isEqualTo(ActivityInfo
+                .SCREEN_ORIENTATION_LANDSCAPE);
+    }
+
+    @Test
+    public void handleSetOrientationProperties_forDefaultBanner_shouldNotChangeScreenOrientation() throws MraidCommandException, PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        subject.handlePageLoad();
+        // don't expand the banner
+
+        subject.handleSetOrientationProperties(true, MraidOrientation.LANDSCAPE);
+
+        assertThat(activity.getRequestedOrientation()).isEqualTo(ActivityInfo
+                .SCREEN_ORIENTATION_PORTRAIT);
+    }
+
+    @Test
+    public void handleSetOrientationProperties_forInterstitial_shouldChangeScreenOrientation() throws MraidCommandException, PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        subject = new MraidController(
+                activity, mockAdReport, PlacementType.INTERSTITIAL,
+                mockBridge, mockTwoPartBridge, mockScreenMetricsWaiter);
+
+        assertThat(activity.getRequestedOrientation()).isEqualTo(ActivityInfo
+                .SCREEN_ORIENTATION_PORTRAIT);
+
+        subject.handlePageLoad();
+        subject.handleSetOrientationProperties(true, MraidOrientation.LANDSCAPE);
+
+        assertThat(activity.getRequestedOrientation()).isEqualTo(ActivityInfo
+                .SCREEN_ORIENTATION_LANDSCAPE);
+    }
+
+    @Test
+    public void shouldAllowForceOrientation_withNoneOrientation_shouldReturnTrue() throws PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        final boolean result = subject.shouldAllowForceOrientation(MraidOrientation.NONE);
+
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void shouldAllowForceOrientation_withApplicationContext_shouldReturnFalse() throws PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        subject = new MraidController(
+                activity.getApplicationContext(), mockAdReport, PlacementType.INLINE,
+                mockBridge, mockTwoPartBridge, mockScreenMetricsWaiter);
+
+        final boolean result = subject.shouldAllowForceOrientation(MraidOrientation.PORTRAIT);
+
+        assertThat(result).isFalse();
+    }
+
+    @Test(expected = MraidCommandException.class)
+    public void lockOrientation_withApplicationContext_shouldThrowMraidCommandException() throws MraidCommandException, PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        subject = new MraidController(
+                activity.getApplicationContext(), mockAdReport, PlacementType.INLINE,
+                mockBridge, mockTwoPartBridge, mockScreenMetricsWaiter);
+
+        subject.lockOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
+    }
+
+    @Test
+    public void lockOrientation_withActivityContext_shouldInitializeOriginalActivityOrientationAndCallActivitySetOrientation() throws MraidCommandException, PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        assertThat(subject.getOriginalActivityOrientation()).isNull();
+        assertThat(activity.getRequestedOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+
+        subject.lockOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+
+        assertThat(subject.getOriginalActivityOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+        assertThat(activity.getRequestedOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+    }
+
+    @Test
+    public void lockOrientation_subsequentTimes_shouldNotModifyOriginalActivityOrientation() throws MraidCommandException, PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        subject.lockOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+
+        assertThat(subject.getOriginalActivityOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+
+        subject.lockOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
+
+        assertThat(subject.getOriginalActivityOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+    }
+
+    @Test
+    public void applyOrientation_withLockedOrientation_withForceOrientationNone_withAllowOrientationChangeTrue_shouldResetOrientation() throws MraidCommandException, PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        assertThat(activity.getRequestedOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+
+        subject.lockOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
+
+        assertThat(activity.getRequestedOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
+
+        subject.handleSetOrientationProperties(true, MraidOrientation.NONE);
+        subject.applyOrientation();
+
+        assertThat(activity.getRequestedOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+    }
+
+    @Test
+    public void applyOrientation_withNoLockedOrientation_withForceOrientationNone_withAllowOrientationChangeTrue_shouldDoNothing() throws MraidCommandException, PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        assertThat(activity.getRequestedOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+
+        subject.handleSetOrientationProperties(true, MraidOrientation.NONE);
+        subject.applyOrientation();
+
+        assertThat(activity.getRequestedOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+    }
+
+    @Test
+    public void applyOrientation_withForcedOrientationTrue_shouldSetRequestedOrientationToForcedOrienation() throws MraidCommandException, PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        subject.handleSetOrientationProperties(true, MraidOrientation.LANDSCAPE);
+        subject.applyOrientation();
+
+        assertThat(activity.getRequestedOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
+    }
+
+    @Test
+    public void applyOrientation_withForcedOrientationFalse_shouldSetRequestedOrientationToForcedOrienation() throws MraidCommandException, PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        subject.handleSetOrientationProperties(false, MraidOrientation.LANDSCAPE);
+        subject.applyOrientation();
+
+        assertThat(activity.getRequestedOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
+    }
+
+    @Test
+    public void unapplyOrientation_withALockedOrientation_shouldReturnToOriginalOrientationAndResetOriginalActivityOrientation() throws MraidCommandException, PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        assertThat(subject.getOriginalActivityOrientation()).isNull();
+        assertThat(activity.getRequestedOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+
+        subject.lockOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
+
+        assertThat(subject.getOriginalActivityOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+        assertThat(activity.getRequestedOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
+
+        subject.unApplyOrientation();
+
+        assertThat(subject.getOriginalActivityOrientation()).isNull();
+        assertThat(activity.getRequestedOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+    }
+
+    @Test
+    public void unapplyOrientation_withoutLockedOrientation_shouldNotChangeRequestedOrientation()
+            throws PackageManager.NameNotFoundException {
+        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
+                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
+
+        assertThat(subject.getOriginalActivityOrientation()).isNull();
+        assertThat(activity.getRequestedOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+
+        subject.unApplyOrientation();
+
+        assertThat(subject.getOriginalActivityOrientation()).isNull();
+        assertThat(activity.getRequestedOrientation())
+                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+    }
+
+    @Test
+    public void destroy_shouldCancelLastMetricsRequest_shouldUnregisterBroadcastReceiver_shouldDetachAllBridges() {
+        subject.destroy();
+
+        verify(mockScreenMetricsWaiter).cancelLastRequest();
+        verify(mockOrientationBroadcastReceiver).unregister();
+        verify(mockBridge).detach();
+        verify(mockTwoPartBridge).detach();
+    }
+
+    @Test
+    public void destroy_withDefaultState_shouldSetMraidWebViewsToNull() {
+        subject.setViewStateForTesting(ViewState.DEFAULT);
+        assertThat(subject.getMraidWebView()).isNotNull();
+        // The two-part WebView is null by default
+        assertThat(subject.getTwoPartWebView()).isNull();
+
+        subject.destroy();
+
+        assertThat(subject.getMraidWebView()).isNull();
+        assertThat(subject.getTwoPartWebView()).isNull();
+    }
+
+    @Test
+    public void destroy_withExpandedState_shouldSetMraidWebViewsToNull()
+            throws MraidCommandException {
+        // Necessary to set up the webview before expanding. Also moves the state to DEFAULT.
+        subject.handlePageLoad();
+        assertThat(subject.getViewState()).isEqualTo(ViewState.DEFAULT);
+        subject.handleExpand(URI.create("http://two-part-url"), false);
+
+        assertThat(subject.getMraidWebView()).isNotNull();
+        assertThat(subject.getTwoPartWebView()).isNotNull();
+
+        subject.destroy();
+
+        assertThat(subject.getMraidWebView()).isNull();
+        assertThat(subject.getTwoPartWebView()).isNull();
+    }
+
+    @Test
+    public void destroy_afterDestroy_shouldNotThrowAnException() {
+        subject.destroy();
+        subject.destroy();
+
+        assertThat(subject.getMraidWebView()).isNull();
+        assertThat(subject.getTwoPartWebView()).isNull();
+    }
+
+    @Test
+    public void destroy_fromExpandedState_shouldRemoveCloseableAdContainerFromContentView()
+            throws MraidCommandException {
+        subject.handlePageLoad();
+        subject.handleExpand(null, false);
+
+        assertThat(rootView.getChildCount()).isEqualTo(1);
+
+        subject.destroy();
+
+        assertThat(rootView.getChildCount()).isEqualTo(0);
+    }
+
+    @Test
+    public void destroy_fromResizedState_shouldRemoveCloseableAdContainerFromContentView()
+            throws MraidCommandException {
+        subject.handlePageLoad();
+        subject.setRootViewSize(100, 100);
+        subject.handleResize(100, 100, 0, 0, ClosePosition.TOP_RIGHT, true);
+
+        assertThat(rootView.getChildCount()).isEqualTo(1);
+
+        subject.destroy();
+
+        assertThat(rootView.getChildCount()).isEqualTo(0);
+    }
+
+    private void setMockActivityInfo(final boolean activityInfoFound, int screenOrientation,
+            int configChanges) throws PackageManager.NameNotFoundException {
+        final ActivityInfo mockActivityInfo = mock(ActivityInfo.class);
+
+        mockActivityInfo.screenOrientation = screenOrientation;
+        mockActivityInfo.configChanges = configChanges;
+
+        final PackageManager mockPackageManager = mock(PackageManager.class);
+        doAnswer(new Answer() {
+            @Override
+            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+                if (!activityInfoFound) {
+                    throw new PackageManager.NameNotFoundException("");
+                }
+
+                return mockActivityInfo;
+            }
+        }).when(mockPackageManager).getActivityInfo(any(ComponentName.class), anyInt());
+
+        when(activity.getPackageManager()).thenReturn(mockPackageManager);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidInterstitialTest.java b/mopub-sdk/src/test/java/com/mopub/mraid/MraidInterstitialTest.java
similarity index 72%
rename from mopub-sdk/src/test/java/com/mopub/mobileads/MraidInterstitialTest.java
rename to mopub-sdk/src/test/java/com/mopub/mraid/MraidInterstitialTest.java
index d6da03a2..5424e6f2 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidInterstitialTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mraid/MraidInterstitialTest.java
@@ -1,82 +1,89 @@
-package com.mopub.mobileads;
+package com.mopub.mraid;
 
 import android.app.Activity;
 import android.content.Context;
 import android.content.Intent;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.ResponseBodyInterstitialTest;
 
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
 import org.robolectric.shadows.ShadowActivity;
 import org.robolectric.shadows.ShadowLocalBroadcastManager;
 
 import java.util.HashMap;
 import java.util.Map;
 
-import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
-import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
 import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_CLICK;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiverTest.getIntentForActionAndIdentifier;
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_INVALID_STATE;
 import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.stub;
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.withSettings;
 import static org.robolectric.Robolectric.shadowOf_;
 
 @RunWith(SdkTestRunner.class)
 public class MraidInterstitialTest extends ResponseBodyInterstitialTest {
-    private CustomEventInterstitialListener customEventInterstitialListener;
-    private Map<String,Object> localExtras;
-    private Map<String,String> serverExtras;
-    private Context context;
-    private static final String INPUT_HTML_DATA = "%3Chtml%3E%3C%2Fhtml%3E";
     private static final String EXPECTED_HTML_DATA = "<html></html>";
     private long broadcastIdentifier;
 
+    @Mock CustomEventInterstitialListener customEventInterstitialListener;
+
+    private Map<String, Object> localExtras;
+    private Map<String, String> serverExtras;
+    private Context context;
+
     @Before
     public void setUp() throws Exception {
-        subject = new MraidInterstitial();
-        context = new Activity();
-        customEventInterstitialListener = mock(CustomEventInterstitialListener.class);
+        broadcastIdentifier = 2222;
+
         localExtras = new HashMap<String, Object>();
         serverExtras = new HashMap<String, String>();
-        serverExtras.put(HTML_RESPONSE_BODY_KEY, INPUT_HTML_DATA);
+        serverExtras.put(HTML_RESPONSE_BODY_KEY, EXPECTED_HTML_DATA);
+        localExtras.put(BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
 
-        broadcastIdentifier = 2222;
-        final AdConfiguration adConfiguration = mock(AdConfiguration.class, withSettings().serializable());
-        stub(adConfiguration.getBroadcastIdentifier()).toReturn(broadcastIdentifier);
-        localExtras.put(AD_CONFIGURATION_KEY, adConfiguration);
+        context = Robolectric.buildActivity(Activity.class).create().get();
+
+        subject = new MraidInterstitial();
     }
 
     @Test
-    public void loadInterstitial_withMalformedServerExtras_shouldNotifyInterstitialFailed() throws Exception {
+    public void loadInterstitial_withMalformedServerExtras_shouldNotifyInterstitialFailed()
+            throws Exception {
         serverExtras.remove(HTML_RESPONSE_BODY_KEY);
-        subject.loadInterstitial(context, customEventInterstitialListener, localExtras, serverExtras);
+        subject.loadInterstitial(context, customEventInterstitialListener, localExtras,
+                serverExtras);
 
         verify(customEventInterstitialListener).onInterstitialFailed(NETWORK_INVALID_STATE);
         verify(customEventInterstitialListener, never()).onInterstitialLoaded();
     }
 
+    @Ignore
     @Test
     public void loadInterstitial_shouldNotifyInterstitialLoaded() throws Exception {
-        subject.loadInterstitial(context, customEventInterstitialListener, localExtras, serverExtras);
+        subject.loadInterstitial(context, customEventInterstitialListener, localExtras,
+                serverExtras);
 
-//        verify(customEventInterstitialListener).onInterstitialLoaded();
+        verify(customEventInterstitialListener).onInterstitialLoaded();
     }
 
     @Test
     public void loadInterstitial_shouldConnectListenerToBroadcastReceiver() throws Exception {
-        subject.loadInterstitial(context, customEventInterstitialListener, localExtras, serverExtras);
+        subject.loadInterstitial(context, customEventInterstitialListener, localExtras,
+                serverExtras);
 
-        Intent intent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_SHOW, broadcastIdentifier);
+        Intent intent =
+                getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_SHOW, broadcastIdentifier);
         ShadowLocalBroadcastManager.getInstance(context).sendBroadcast(intent);
 
         verify(customEventInterstitialListener).onInterstitialShown();
@@ -94,21 +101,23 @@ public void loadInterstitial_shouldConnectListenerToBroadcastReceiver() throws E
 
     @Test
     public void showInterstitial_shouldStartActivityWithIntent() throws Exception {
-        subject.loadInterstitial(context, customEventInterstitialListener, localExtras, serverExtras);
+        subject.loadInterstitial(context, customEventInterstitialListener, localExtras,
+                serverExtras);
         subject.showInterstitial();
 
         ShadowActivity shadowActivity = shadowOf_(context);
         Intent intent = shadowActivity.getNextStartedActivityForResult().intent;
 
-        assertThat(intent.getComponent().getPackageName()).isEqualTo("com.mopub.mobileads");
-        assertThat(intent.getComponent().getClassName()).isEqualTo("com.mopub.mobileads.MraidActivity");
+        assertThat(intent.getComponent().getClassName())
+                .isEqualTo("com.mopub.mobileads.MraidActivity");
         assertThat(intent.getExtras().get(HTML_RESPONSE_BODY_KEY)).isEqualTo(EXPECTED_HTML_DATA);
         assertThat(intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
     }
 
     @Test
     public void onInvalidate_shouldDisconnectListenerToBroadcastReceiver() throws Exception {
-        subject.loadInterstitial(context, customEventInterstitialListener, localExtras, serverExtras);
+        subject.loadInterstitial(context, customEventInterstitialListener, localExtras,
+                serverExtras);
         subject.onInvalidate();
 
         Intent intent;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidDisplayControllerTest.java b/mopub-sdk/src/test/java/com/mopub/mraid/MraidNativeCommandHandlerTest.java
similarity index 52%
rename from mopub-sdk/src/test/java/com/mopub/mobileads/MraidDisplayControllerTest.java
rename to mopub-sdk/src/test/java/com/mopub/mraid/MraidNativeCommandHandlerTest.java
index 035a693f..533d66b3 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidDisplayControllerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mraid/MraidNativeCommandHandlerTest.java
@@ -1,35 +1,35 @@
-package com.mopub.mobileads;
+package com.mopub.mraid;
 
 import android.Manifest;
+import android.annotation.TargetApi;
 import android.app.Activity;
 import android.app.AlertDialog;
 import android.content.Context;
 import android.content.Intent;
-import android.graphics.Color;
-import android.os.Build.VERSION_CODES;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.os.Build;
 import android.os.Environment;
 import android.provider.CalendarContract;
-import android.view.Gravity;
 import android.view.View;
-import android.view.ViewGroup;
-import android.widget.Button;
-import android.widget.FrameLayout;
-import android.widget.ImageView;
-import android.widget.RelativeLayout;
+import android.view.WindowManager;
+import android.widget.LinearLayout;
 
 import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.Dips;
 import com.mopub.mobileads.test.support.FileUtils;
 import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
-import com.mopub.mobileads.test.support.TestMraidViewFactory;
 import com.mopub.mobileads.test.support.ThreadUtils;
-import com.mopub.mobileads.util.MraidsTest;
+import com.mopub.mraid.MraidNativeCommandHandler.MraidCommandFailureListener;
+
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpUriRequest;
+import org.hamcrest.BaseMatcher;
+import org.hamcrest.Description;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
@@ -39,265 +39,65 @@
 import org.robolectric.shadows.ShadowLog;
 import org.robolectric.shadows.ShadowToast;
 
-import java.io.*;
+import java.io.File;
 import java.net.URI;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
 
 import static android.content.DialogInterface.BUTTON_NEGATIVE;
 import static android.content.DialogInterface.BUTTON_POSITIVE;
-import static com.mopub.mobileads.BaseVideoPlayerActivitiyTest.assertMraidVideoPlayerActivityStarted;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.CREATE_CALENDAR_EVENT;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.GET_CURRENT_POSITION;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.GET_DEFAULT_POSITION;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.GET_MAX_SIZE;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.GET_SCREEN_SIZE;
-import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.STORE_PICTURE;
-import static com.mopub.mobileads.MraidCommandStorePicture.MIME_TYPE_HEADER;
-import static com.mopub.mobileads.util.Mraids.ANDROID_CALENDAR_CONTENT_TYPE;
-import static java.io.File.*;
+import static com.mopub.mraid.MraidNativeCommandHandler.ANDROID_CALENDAR_CONTENT_TYPE;
+import static java.io.File.separator;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.argThat;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.isA;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.stub;
-import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
-import static org.mockito.Mockito.withSettings;
 import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(SdkTestRunner.class)
-public class MraidDisplayControllerTest {
+public class MraidNativeCommandHandlerTest {
     private static final String IMAGE_URI_VALUE = "file://tmp/expectedFile.jpg";
     private static final int TIME_TO_PAUSE_FOR_NETWORK = 300;
-    private static final String VIDEO_URL = "http://video";
-    public static final String FAKE_IMAGE_DATA = "imageFileData";
+    private static final String FAKE_IMAGE_DATA = "imageFileData";
     //XXX: Robolectric or JUNIT doesn't support the correct suffix ZZZZZ in the parse pattern, so replacing xx:xx with xxxx for time.
-    public static final String CALENDAR_START_TIME = "2013-08-14T20:00:00-0000";
-
-    private MraidView mraidView;
-    private MraidDisplayController subject;
-    private View rootView;
-    private FrameLayout contentView;
-    private MoPubView moPubView;
-    private FrameLayout adContainerLayout;
-    private RelativeLayout expansionLayout;
-    private FrameLayout placeholderView;
+    private static final String CALENDAR_START_TIME = "2013-08-14T20:00:00-0000";
+
+
+    @Mock MraidCommandFailureListener mraidCommandFailureListener;
+    private MraidNativeCommandHandler subject;
+    private Context context;
+    private Map<String, String> params;
+
     private File expectedFile;
     private File pictureDirectory;
     private File fileWithoutExtension;
     private TestHttpResponseWithHeaders response;
-    private Map<String, String> params;
-    private AdConfiguration adConfiguration;
-    private long testBroadcastIdentifier;
 
 
     @Before
-    public void setup() {
-        mraidView = TestMraidViewFactory.getSingletonMock();
-        moPubView = mock(MoPubView.class);
-        rootView = mock(View.class);
-        contentView = mock(FrameLayout.class);
-        adContainerLayout = mock(FrameLayout.class);
-        expansionLayout = mock(RelativeLayout.class);
-        placeholderView = mock(FrameLayout.class);
-        params = new HashMap<String, String>();
-
-        resetMockMraidView(new Activity());
-        stub(rootView.findViewById(eq(android.R.id.content))).toReturn(contentView);
-        stub(contentView.getContext()).toReturn(new Activity());
-
-        subject = new TestMraidDisplayController(mraidView, null, null);
-
-        testBroadcastIdentifier = 1235;
-        adConfiguration = mock(AdConfiguration.class, withSettings().serializable());
-        stub(adConfiguration.getBroadcastIdentifier()).toReturn(testBroadcastIdentifier);
-        stub(mraidView.getAdConfiguration()).toReturn(adConfiguration);
+    public void setUp() throws Exception {
+        subject = new MraidNativeCommandHandler();
+        context = Robolectric.buildActivity(Activity.class).create().get();
 
         FileUtils.copyFile("etc/expectedFile.jpg", "/tmp/expectedFile.jpg");
         expectedFile = new File(Environment.getExternalStorageDirectory(), "Pictures" + separator + "expectedFile.jpg");
         pictureDirectory = new File(Environment.getExternalStorageDirectory(), "Pictures");
         fileWithoutExtension = new File(pictureDirectory, "file");
-
-        ShadowEnvironment.setExternalStorageState(Environment.MEDIA_MOUNTED);
-        Robolectric.getShadowApplication().grantPermissions(Manifest.permission.WRITE_EXTERNAL_STORAGE);
-    }
-
-    @Test
-    public void initialization_shouldSetupStartingState() throws Exception {
-        assertThat(subject.getMraidView()).isSameAs(mraidView);
-    }
-
-    @Test
-    public void initializeJavaScriptState_shouldSetMraidSupportsProperties() throws Exception {
-        subject.initializeJavaScriptState();
-        verify(mraidView).fireChangeEventForProperty(isA(MraidSupportsProperty.class));
-    }
-
-    @Test
-    public void initializeSupportedFunctionsProperty_whenPhoneIsAvailable_shouldReportPhoneAvailable() throws Exception {
-        Context mockContext = createMockContextWithSpecificIntentData("tel", null, null, "android.intent.action.DIAL");
-
-        resetMockMraidView(mockContext);
-        subject.initializeSupportedFunctionsProperty();
-
-        MraidSupportsProperty mraidSupportsProperty = captureMraidSupportProperties();
-
-        assertThat(mraidSupportsProperty.toJsonPair()).contains("tel: true");
-    }
-
-    @Test
-    public void initializeSupportedFunctionsProperty_whenPhoneNotAvailable_shouldReportPhoneNotAvailable() throws Exception {
-        Context mockContext = createMockContextWithSpecificIntentData("", null, null, "android.intent.action.DIAL");
-
-        resetMockMraidView(mockContext);
-        subject.initializeSupportedFunctionsProperty();
-
-        MraidSupportsProperty mraidSupportsProperty = captureMraidSupportProperties();
-
-        assertThat(mraidSupportsProperty.toJsonPair()).contains("tel: false");
-    }
-
-    @Test
-    public void initializeSupportedFunctionsProperty_whenSmsIsAvailable_shouldReportSmsAvailable() throws Exception {
-        Context mockContext = createMockContextWithSpecificIntentData("sms", null, null, "android.intent.action.VIEW");
-
-        resetMockMraidView(mockContext);
-        subject.initializeSupportedFunctionsProperty();
-
-        MraidSupportsProperty mraidSupportsProperty = captureMraidSupportProperties();
-
-        assertThat(mraidSupportsProperty.toJsonPair()).contains("sms: true");
-    }
-
-    @Test
-    public void initializeSupportedFunctionsProperty_whenSmsNotAvailable_shouldReportSmsNotAvailable() throws Exception {
-        Context mockContext = createMockContextWithSpecificIntentData("", null, null, "android.intent.action.VIEW");
-
-        resetMockMraidView(mockContext);
-        subject.initializeSupportedFunctionsProperty();
-
-        MraidSupportsProperty mraidSupportsProperty = captureMraidSupportProperties();
-
-        assertThat(mraidSupportsProperty.toJsonPair()).contains("sms: false");
-    }
-
-    @Test
-    public void initializeSupportedFunctionsProperty_whenWriteExternalStoragePermissionNotGranted_shouldReportStorePictureNotAvailable() throws Exception {
-        Robolectric.getShadowApplication().denyPermissions(Manifest.permission.WRITE_EXTERNAL_STORAGE);
-
-        resetMockMraidView(new Activity());
-        subject.initializeSupportedFunctionsProperty();
-
-        MraidSupportsProperty mraidSupportsProperty = captureMraidSupportProperties();
-
-        assertThat(mraidSupportsProperty.toJsonPair()).contains("storePicture: false");
-    }
-
-    @Test
-    public void initializeSupportedFunctionsProperty_whenSDCardNotMounted_shouldReportStorePictureNotAvailable() throws Exception {
-        ShadowEnvironment.setExternalStorageState(Environment.MEDIA_UNMOUNTED);
-
-        resetMockMraidView(new Activity());
-        subject.initializeSupportedFunctionsProperty();
-
-        MraidSupportsProperty mraidSupportsProperty = captureMraidSupportProperties();
-
-        assertThat(mraidSupportsProperty.toJsonPair()).contains("storePicture: false");
-    }
-
-    @Test
-    public void initializeSupportedFunctionsProperty_whenSDCardMounted_andWriteExternalStoragePermissionGranted_shouldReportStorePictureAvailable() throws Exception {
-        resetMockMraidView(new Activity());
-        subject.initializeSupportedFunctionsProperty();
-
-        MraidSupportsProperty mraidSupportsProperty = captureMraidSupportProperties();
-
-        assertThat(mraidSupportsProperty.toJsonPair()).contains("storePicture: true");
-    }
-
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
-    @Test
-    public void initializeSupportedFunctionsProperty_atLeastIcs_shouldReportCalendarAvailable() throws Exception {
-        Context mockContext = createMockContextWithSpecificIntentData(null, null, ANDROID_CALENDAR_CONTENT_TYPE, "android.intent.action.INSERT");
-        resetMockMraidView(mockContext);
-
-        subject.initializeSupportedFunctionsProperty();
-
-        MraidSupportsProperty mraidSupportsProperty = captureMraidSupportProperties();
-
-        assertThat(mraidSupportsProperty.toJsonPair()).contains("calendar: true");
-    }
-
-    @Config(reportSdk = VERSION_CODES.HONEYCOMB_MR2)
-    @Test
-    public void initializeSupportedFunctionsProperty_beforeIcs_shouldNotReportCalendarAvailable() throws Exception {
-        resetMockMraidView(new Activity());
-        subject.initializeSupportedFunctionsProperty();
-
-        MraidSupportsProperty mraidSupportsProperty = captureMraidSupportProperties();
-
-        assertThat(mraidSupportsProperty.toJsonPair()).contains("calendar: false");
-    }
-
-    @Test
-    public void initializeSupportedFunctionsProperty_whenMraidVideoPlayerActivityDeclared_shouldReportInlineVideoAvailable() throws Exception {
-        Context mockContext = createMockContextWithSpecificIntentData(null, "com.mopub.mobileads.MraidVideoPlayerActivity", null, null);
-
-        resetMockMraidView(mockContext);
-        subject.initializeSupportedFunctionsProperty();
-
-        MraidSupportsProperty mraidSupportsProperty = captureMraidSupportProperties();
-
-        assertThat(mraidSupportsProperty.toJsonPair()).contains("inlineVideo: true");
-    }
-
-    @Test
-    public void initializeSupportedFunctionsProperty_MraidVideoPlayerActivityNotDeclared_shouldReportInlineVideoNotAvailable() throws Exception {
-        resetMockMraidView(new Activity());
-        subject.initializeSupportedFunctionsProperty();
-
-        MraidSupportsProperty mraidSupportsProperty = captureMraidSupportProperties();
-
-        assertThat(mraidSupportsProperty.toJsonPair()).contains("inlineVideo: false");
-    }
-
-    @Test
-    public void expand_shouldSwapWithPlaceholderView() throws Exception {
-        stub(moPubView.getChildAt(eq(0))).toReturn(mraidView);
-        subject.expand(null, 320, 50, false, false);
-
-        verify(moPubView).addView(any(FrameLayout.class), eq(0), any(ViewGroup.LayoutParams.class));
-        verify(moPubView).removeView(eq(mraidView));
-        verify(adContainerLayout, times(2)).addView(any(ImageView.class), any(FrameLayout.LayoutParams.class));
-    }
-
-    @Test
-    public void close_shouldUnexpandView() throws Exception {
-        subject.expand(null, 320, 50, false, false);
-        stub(placeholderView.getParent()).toReturn(moPubView);
-
-        subject.close();
-
-        verify(adContainerLayout).removeAllViewsInLayout();
-        verify(expansionLayout).removeAllViewsInLayout();
-        verify(contentView).removeView(eq(expansionLayout));
-        verify(moPubView).addView(eq(mraidView), any(int.class));
-        verify(moPubView).removeView(eq(placeholderView));
-        verify(moPubView).invalidate();
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void showUserDownloadImageAlert_withActivityContext_shouldDisplayAlertDialog() throws Exception {
-        stub(mraidView.getContext()).toReturn(new Activity());
-        subject = new TestMraidDisplayController(mraidView, null, null);
         response = new TestHttpResponseWithHeaders(200, FAKE_IMAGE_DATA);
 
-        subject.showUserDownloadImageAlert(IMAGE_URI_VALUE);
+        subject.storePicture(context, IMAGE_URI_VALUE, mraidCommandFailureListener);
 
         AlertDialog alertDialog = ShadowAlertDialog.getLatestAlertDialog();
         ShadowAlertDialog shadowAlertDialog = shadowOf(alertDialog);
@@ -312,14 +112,13 @@ public void showUserDownloadImageAlert_withActivityContext_shouldDisplayAlertDia
         assertThat(alertDialog.getButton(BUTTON_NEGATIVE)).isNotNull();
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void showUserDownloadImageAlert_whenOkayClicked_shouldDownloadImage() throws Exception {
-        stub(mraidView.getContext()).toReturn(new Activity());
-        subject = new TestMraidDisplayController(mraidView, null, null);
         response = new TestHttpResponseWithHeaders(200, FAKE_IMAGE_DATA);
         Robolectric.addPendingHttpResponse(response);
 
-        subject.showUserDownloadImageAlert(IMAGE_URI_VALUE);
+        subject.storePicture(context, IMAGE_URI_VALUE, mraidCommandFailureListener);
 
         ShadowAlertDialog.getLatestAlertDialog().getButton(BUTTON_POSITIVE).performClick();
         ThreadUtils.pause(TIME_TO_PAUSE_FOR_NETWORK);
@@ -328,13 +127,12 @@ public void showUserDownloadImageAlert_whenOkayClicked_shouldDownloadImage() thr
         assertThat(expectedFile.length()).isEqualTo(FAKE_IMAGE_DATA.length());
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void showUserDownloadImageAlert_whenCancelClicked_shouldDismissDialog() throws Exception {
-        stub(mraidView.getContext()).toReturn(new Activity());
-        subject = new TestMraidDisplayController(mraidView, null, null);
         response = new TestHttpResponseWithHeaders(200, FAKE_IMAGE_DATA);
 
-        subject.showUserDownloadImageAlert(IMAGE_URI_VALUE);
+        subject.storePicture(context, IMAGE_URI_VALUE, mraidCommandFailureListener);
 
         AlertDialog alertDialog = ShadowAlertDialog.getLatestAlertDialog();
         ShadowAlertDialog shadowAlertDialog = shadowOf(alertDialog);
@@ -346,16 +144,15 @@ public void showUserDownloadImageAlert_whenCancelClicked_shouldDismissDialog() t
         assertThat(expectedFile.length()).isEqualTo(0);
     }
 
+    @Ignore("MRAID 2.0")
     @Test
     public void showUserDownloadImageAlert_withAppContext_shouldToastAndDownloadImage() throws Exception {
-        stub(mraidView.getContext()).toReturn(Robolectric.application);
-        subject = new TestMraidDisplayController(mraidView, null, null);
         response = new TestHttpResponseWithHeaders(200, FAKE_IMAGE_DATA);
         Robolectric.addPendingHttpResponse(response);
 
         assertThat(ShadowToast.shownToastCount()).isEqualTo(0);
 
-        subject.showUserDownloadImageAlert(IMAGE_URI_VALUE);
+        subject.storePicture(context.getApplicationContext(), IMAGE_URI_VALUE, mraidCommandFailureListener);
         ThreadUtils.pause(TIME_TO_PAUSE_FOR_NETWORK);
 
         assertThat(ShadowToast.shownToastCount()).isEqualTo(1);
@@ -367,16 +164,15 @@ public void showUserDownloadImageAlert_withAppContext_shouldToastAndDownloadImag
         assertThat(expectedFile.length()).isEqualTo(FAKE_IMAGE_DATA.length());
     }
 
+    @Ignore("MRAID 2.0")
     @Test
     public void showUserDownloadImageAlert_withAppContext_whenDownloadImageFails_shouldDisplayFailureToastAndNotDownloadImage() throws Exception {
-        stub(mraidView.getContext()).toReturn(Robolectric.application);
-        subject = new TestMraidDisplayController(mraidView, null, null);
         response = new TestHttpResponseWithHeaders(200, FAKE_IMAGE_DATA);
         Robolectric.addPendingHttpResponse(response);
 
         assertThat(ShadowToast.shownToastCount()).isEqualTo(0);
 
-        subject.showUserDownloadImageAlert("this is an invalid image url and cannot be downloaded");
+        subject.storePicture(context, "this is an invalid image url and cannot be downloaded", mraidCommandFailureListener);
         ThreadUtils.pause(TIME_TO_PAUSE_FOR_NETWORK);
 
         assertThat(ShadowToast.shownToastCount()).isEqualTo(1);
@@ -391,17 +187,19 @@ public void showUserDownloadImageAlert_withAppContext_whenDownloadImageFails_sho
         assertThat(expectedFile.length()).isEqualTo(0);
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void showUserDownloadImageAlert_whenStorePictureNotSupported_shouldFireErrorEvent_andNotToastNorAlertDialog() throws Exception {
         Robolectric.getShadowApplication().denyPermissions(Manifest.permission.WRITE_EXTERNAL_STORAGE);
 
-        subject.showUserDownloadImageAlert("http://image.jpg");
+        subject.storePicture(context, "http://image.jpg", mraidCommandFailureListener);
 
         assertThat(ShadowToast.shownToastCount()).isEqualTo(0);
         assertThat(ShadowAlertDialog.getLatestAlertDialog()).isNull();
-        verify(mraidView).fireErrorEvent(eq(STORE_PICTURE), any(String.class));
+        verify(mraidCommandFailureListener).onFailure(any(MraidCommandException.class));
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void showUserDownloadImageAlert_withMimeTypeAndNoFileExtension_shouldSavePictureWithMimeType() throws Exception {
         String fileNameWithNoExtension = "https://www.somewhere.com/images/blah/file";
@@ -413,6 +211,7 @@ public void showUserDownloadImageAlert_withMimeTypeAndNoFileExtension_shouldSave
                 ".jpg");
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void showUserDownloadImageAlert_withMultipleContentTypesAndNoFileExtension_shouldSavePictureWithMimeType() throws Exception {
         String fileNameWithNoExtension = "https://www.somewhere.com/images/blah/file";
@@ -424,6 +223,7 @@ public void showUserDownloadImageAlert_withMultipleContentTypesAndNoFileExtensio
                 ".png");
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void showUserDownloadImageAlert_withMimeTypeAndFileExtension_shouldSavePictureWithFileExtension() throws Exception {
         String fileNameWithExtension = "https://www.somewhere.com/images/blah/file.extension";
@@ -437,6 +237,7 @@ public void showUserDownloadImageAlert_withMimeTypeAndFileExtension_shouldSavePi
         assertThat((expectedFile.getName()).endsWith(".extension.extension")).isFalse();
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void showUserDownloadImageAlert_withHttpUri_shouldRequestPictureFromNetwork() throws Exception {
         response = new TestHttpResponseWithHeaders(200, "OK");
@@ -446,69 +247,15 @@ public void showUserDownloadImageAlert_withHttpUri_shouldRequestPictureFromNetwo
         assertThat(latestRequest.getURI()).isEqualTo(URI.create("https://www.google.com/images/srpr/logo4w.png"));
     }
 
-    @Test
-    public void orientationBroadcastReceiver_whenUnregistered_shouldIgnoreOnReceive() throws Exception {
-        Intent intent = mock(Intent.class);
-        stub(intent.getAction()).toReturn("some bogus action which we hope never to see");
-        Context context = new Activity();
-        MraidDisplayController.OrientationBroadcastReceiver receiver = subject.new OrientationBroadcastReceiver();
-        receiver.register(context);
-
-        receiver.unregister();
-        receiver.onReceive(context, intent);
-
-        verify(intent, never()).getAction();
-    }
-
-    @Test
-    public void showVideo_shouldStartVideoPlayerActivity() throws Exception {
-        subject.showVideo(VIDEO_URL);
-        assertMraidVideoPlayerActivityStarted(MraidVideoPlayerActivity.class, VIDEO_URL, adConfiguration);
-    }
-
-    @Test
-    public void getCurrentPosition_shouldFireErrorEvent() throws Exception {
-        resetMockMraidView(new Activity());
-
-        subject.getCurrentPosition();
-
-        verify(mraidView).fireErrorEvent(eq(GET_CURRENT_POSITION), any(String.class));
-    }
-
-    @Test
-    public void getDefaultPosition_shouldFireErrorEvent() throws Exception {
-        resetMockMraidView(new Activity());
-
-        subject.getDefaultPosition();
-
-        verify(mraidView).fireErrorEvent(eq(GET_DEFAULT_POSITION), any(String.class));
-    }
-
-    @Test
-    public void getMaxSize_shouldFireErrorEvent() throws Exception {
-        resetMockMraidView(new Activity());
-
-        subject.getMaxSize();
-
-        verify(mraidView).fireErrorEvent(eq(GET_MAX_SIZE), any(String.class));
-    }
-    @Test
-    public void getScreenSize_shouldFireErrorEvent() throws Exception {
-        resetMockMraidView(new Activity());
-
-        subject.getScreenSize();
-
-        verify(mraidView).fireErrorEvent(eq(GET_SCREEN_SIZE), any(String.class));
-    }
-
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Ignore("Mraid 2.0")
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withMinimumValidParams_atLeastICS_shouldCreateEventIntent() throws Exception {
         setupCalendarParams();
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
-        verify(mraidView, never()).fireErrorEvent(eq(CREATE_CALENDAR_EVENT), any(String.class));
+        verify(mraidCommandFailureListener, never()).onFailure(any(MraidCommandException.class));
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
 
@@ -518,15 +265,16 @@ public void createCalendarEvent_withMinimumValidParams_atLeastICS_shouldCreateEv
         assertThat(intent.getLongExtra(CalendarContract.EXTRA_EVENT_BEGIN_TIME, -1)).isNotEqualTo(-1);
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Ignore("Mraid 2.0")
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withoutSecondsOnStartDate_atLeastICS_shouldCreateEventIntent() throws Exception {
         setupCalendarParams();
         params.put("start", "2012-12-21T00:00-0500");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
-        verify(mraidView, never()).fireErrorEvent(eq(CREATE_CALENDAR_EVENT), any(String.class));
+        verify(mraidCommandFailureListener, never()).onFailure(any(MraidCommandException.class));
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
 
@@ -536,13 +284,14 @@ public void createCalendarEvent_withoutSecondsOnStartDate_atLeastICS_shouldCreat
         assertThat(intent.getLongExtra(CalendarContract.EXTRA_EVENT_BEGIN_TIME, -1)).isNotEqualTo(-1);
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Ignore("Mraid 2.0")
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withDailyRecurrence_shouldCreateCalendarIntent() throws Exception {
         setupCalendarParams();
         params.put("frequency", "daily");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(intent.getType()).isEqualTo(ANDROID_CALENDAR_CONTENT_TYPE);
@@ -550,71 +299,77 @@ public void createCalendarEvent_withDailyRecurrence_shouldCreateCalendarIntent()
         assertThat(intent.getStringExtra(CalendarContract.Events.RRULE)).isEqualTo("FREQ=DAILY;");
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Ignore("Mraid 2.0")
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withDailyRecurrence_withInterval_shouldCreateCalendarIntent() throws Exception {
         setupCalendarParams();
         params.put("frequency", "daily");
         params.put("interval", "2");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(intent.getStringExtra(CalendarContract.Events.RRULE)).isEqualTo("FREQ=DAILY;INTERVAL=2;");
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Ignore("Mraid 2.0")
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withWeeklyRecurrence_shouldCreateCalendarIntent() throws Exception {
         setupCalendarParams();
         params.put("frequency", "weekly");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(intent.getStringExtra(CalendarContract.Events.RRULE)).isEqualTo("FREQ=WEEKLY;");
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Ignore("Mraid 2.0")
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withWeeklyRecurrence_withInterval_withOutWeekday_shouldCreateCalendarIntent() throws Exception {
         setupCalendarParams();
         params.put("frequency", "weekly");
         params.put("interval", "7");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(intent.getStringExtra(CalendarContract.Events.RRULE)).isEqualTo("FREQ=WEEKLY;INTERVAL=7;");
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Ignore("Mraid 2.0")
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withWeeklyRecurrence_onAllWeekDays_shouldCreateCalendarIntent() throws Exception {
         setupCalendarParams();
         params.put("frequency", "weekly");
         params.put("daysInWeek", "0,1,2,3,4,5,6");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(intent.getStringExtra(CalendarContract.Events.RRULE)).isEqualTo("FREQ=WEEKLY;BYDAY=SU,MO,TU,WE,TH,FR,SA;");
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Ignore("Mraid 2.0")
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withWeeklyRecurrence_onDuplicateWeekDays_shouldCreateCalendarIntent() throws Exception {
         setupCalendarParams();
         params.put("frequency", "weekly");
         params.put("daysInWeek", "3,2,3,3,7,0");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(intent.getStringExtra(CalendarContract.Events.RRULE)).isEqualTo("FREQ=WEEKLY;BYDAY=WE,TU,SU;");
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Ignore("Mraid 2.0")
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withWeeklyRecurrence_withInterval_withWeekDay_shouldCreateCalendarIntent() throws Exception {
         setupCalendarParams();
@@ -622,13 +377,14 @@ public void createCalendarEvent_withWeeklyRecurrence_withInterval_withWeekDay_sh
         params.put("interval", "1");
         params.put("daysInWeek", "1");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(intent.getStringExtra(CalendarContract.Events.RRULE)).isEqualTo("FREQ=WEEKLY;INTERVAL=1;BYDAY=MO;");
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Ignore("Mraid 2.0")
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withDailyRecurrence_withWeeklyRecurrence_withMonthlyOccurence_shouldCreateDailyCalendarIntent() throws Exception {
         setupCalendarParams();
@@ -638,57 +394,61 @@ public void createCalendarEvent_withDailyRecurrence_withWeeklyRecurrence_withMon
         params.put("interval", "2");
         params.put("daysInWeek", "1");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(intent.getStringExtra(CalendarContract.Events.RRULE)).isEqualTo("FREQ=DAILY;INTERVAL=2;");
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Ignore("Mraid 2.0")
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withMonthlyRecurrence_withOutInterval_shouldCreateCalendarIntent() throws Exception {
         setupCalendarParams();
         params.put("frequency", "monthly");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(intent.getStringExtra(CalendarContract.Events.RRULE)).isEqualTo("FREQ=MONTHLY;");
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Ignore("Mraid 2.0")
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withMonthlyRecurrence_withInterval_shouldCreateCalendarIntent() throws Exception {
         setupCalendarParams();
         params.put("frequency", "monthly");
         params.put("interval", "2");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(intent.getStringExtra(CalendarContract.Events.RRULE)).isEqualTo("FREQ=MONTHLY;INTERVAL=2;");
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Ignore("Mraid 2.0")
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void createCalendarEvent_withMonthlyRecurrence_withOutInterval_withDaysOfMonth_shouldCreateCalendarIntent() throws Exception {
         setupCalendarParams();
         params.put("frequency", "monthly");
         params.put("daysInMonth", "2,-15");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(intent.getStringExtra(CalendarContract.Events.RRULE)).isEqualTo("FREQ=MONTHLY;BYMONTHDAY=2,-15;");
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void createCalendarEvent_withMonthlyRecurrence_withInvalidDaysOfMonth_shouldNotCreateCalendarIntent() throws Exception {
         setupCalendarParams();
         params.put("frequency", "monthly");
         params.put("daysInMonth", "55");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
 
@@ -696,13 +456,14 @@ public void createCalendarEvent_withMonthlyRecurrence_withInvalidDaysOfMonth_sho
         assertThat(ShadowLog.getLogs().size()).isEqualTo(1);
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void createCalendarEvent_withWeeklyRecurrence_withInvalidDaysOfWeek_shouldNotCreateCalendarIntent() throws Exception {
         setupCalendarParams();
         params.put("frequency", "weekly");
         params.put("daysInWeek", "-1,20");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
 
@@ -710,50 +471,50 @@ public void createCalendarEvent_withWeeklyRecurrence_withInvalidDaysOfWeek_shoul
         assertThat(ShadowLog.getLogs().size()).isEqualTo(1);
     }
 
-    @Config(reportSdk = VERSION_CODES.HONEYCOMB_MR2)
+    @Ignore("Mraid 2.0")
+    @Config(reportSdk = Build.VERSION_CODES.HONEYCOMB_MR2)
     @Test
     public void createCalendarEvent_beforeIcs_shouldFireErrorEvent() throws Exception {
-        resetMockMraidView(new Activity());
+        subject.createCalendarEvent(context, params);
 
-        subject.createCalendarEvent(params);
-
-        verify(mraidView).fireErrorEvent(eq(CREATE_CALENDAR_EVENT), any(String.class));
+        verify(mraidCommandFailureListener).onFailure(any(MraidCommandException.class));
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void createCalendarEvent_withInvalidDate_shouldFireErrorEvent() throws Exception {
-        resetMockMraidView(new Activity());
         params.put("start", "2013-08-14T09:00.-08:00");
         params.put("description", "Some Event");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
-        verify(mraidView).fireErrorEvent(eq(CREATE_CALENDAR_EVENT), any(String.class));
+        verify(mraidCommandFailureListener).onFailure(any(MraidCommandException.class));
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void createCalendarEvent_withMissingParameters_shouldFireErrorEvent() throws Exception {
-        resetMockMraidView(new Activity());
         //it needs a start time
         params.put("description", "Some Event");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
-        verify(mraidView).fireErrorEvent(eq(CREATE_CALENDAR_EVENT), any(String.class));
+        verify(mraidCommandFailureListener).onFailure(any(MraidCommandException.class));
     }
 
+    @Ignore("Mraid 2.0")
     @Test
     public void createCalendarEvent_withNullDate_shouldFireErrorEvent() throws Exception {
-        resetMockMraidView(new Activity());
         params.put("start", null);
         params.put("description", "Some Event");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
-        verify(mraidView).fireErrorEvent(eq(CREATE_CALENDAR_EVENT), any(String.class));
+        verify(mraidCommandFailureListener).onFailure(any(MraidCommandException.class));
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Ignore("Mraid 2.0")
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void
     createCalendarEvent_withValidParamsAllExceptRecurrence_atLeastICS_shouldCreateEventIntent() throws Exception {
@@ -763,7 +524,7 @@ public void createCalendarEvent_withNullDate_shouldFireErrorEvent() throws Excep
         params.put("summary", "some description actually");
         params.put("transparency", "transparent");
 
-        subject.createCalendarEvent(params);
+        subject.createCalendarEvent(context, params);
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
 
@@ -778,48 +539,219 @@ public void createCalendarEvent_withNullDate_shouldFireErrorEvent() throws Excep
     }
 
     @Test
-    public void addCloseEventRegion_shouldAddCloseEventRegionToFrameLayout() throws Exception {
-        Activity activity = new Activity();
-        FrameLayout frameLayout = new FrameLayout(activity);
-        subject.addCloseEventRegion(frameLayout);
+    public void isTelAvailable_whenCanAcceptIntent_shouldReturnTrue() throws Exception {
+        context = createMockContextWithSpecificIntentData("tel", null, null, "android.intent.action.DIAL");
+
+        assertThat(subject.isTelAvailable(context)).isTrue();
+    }
+
+    @Test
+    public void isTelAvailable_whenCanNotAcceptIntent_shouldReturnFalse() throws Exception {
+        context = createMockContextWithSpecificIntentData("", null, null, "android.intent.action.DIAL");
+
+        assertThat(subject.isTelAvailable(context)).isFalse();
+    }
+
+    @Test
+    public void isSmsAvailable_whenCanAcceptIntent_shouldReturnTrue() throws Exception {
+        context = createMockContextWithSpecificIntentData("sms", null, null, "android.intent.action.VIEW");
+
+        assertThat(subject.isSmsAvailable(context)).isTrue();
+    }
+
+    @Test
+    public void isSmsAvailable_whenCanNotAcceptIntent_shouldReturnFalse() throws Exception {
+        context = createMockContextWithSpecificIntentData("", null, null, "android.intent.action.VIEW");
+
+        assertThat(subject.isSmsAvailable(context)).isFalse();
+    }
+
+    @Test
+    public void isStorePictureAvailable_whenPermissionDeclaredAndMediaMounted_shouldReturnTrue() throws Exception {
+        Robolectric.getShadowApplication().grantPermissions(Manifest.permission.WRITE_EXTERNAL_STORAGE);
+        ShadowEnvironment.setExternalStorageState(Environment.MEDIA_MOUNTED);
+
+        assertThat(subject.isStorePictureSupported(context)).isTrue();
+    }
+
+    @Test
+    public void isStorePictureAvailable_whenPermissionDenied_shouldReturnFalse() throws Exception {
+        Robolectric.getShadowApplication().denyPermissions(Manifest.permission.WRITE_EXTERNAL_STORAGE);
+        ShadowEnvironment.setExternalStorageState(Environment.MEDIA_MOUNTED);
+
+        assertThat(subject.isStorePictureSupported(context)).isFalse();
+    }
+
+    @Test
+    public void isStorePictureAvailable_whenMediaUnmounted_shouldReturnFalse() throws Exception {
+        Robolectric.getShadowApplication().grantPermissions(Manifest.permission.WRITE_EXTERNAL_STORAGE);
+        ShadowEnvironment.setExternalStorageState(Environment.MEDIA_UNMOUNTED);
+
+        assertThat(subject.isStorePictureSupported(context)).isFalse();
+    }
+
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Test
+    public void isCalendarAvailable_atLeastIcs_shouldReturnTrue() throws Exception {
+        context = createMockContextWithSpecificIntentData(null, null, ANDROID_CALENDAR_CONTENT_TYPE, "android.intent.action.INSERT");
+        assertThat(subject.isCalendarAvailable(context)).isTrue();
+    }
+
+    @Config(reportSdk = Build.VERSION_CODES.HONEYCOMB_MR2)
+    @Test
+    public void isCalendarAvailable_beforeIcs_shouldReturnFalse() throws Exception {
+        context = createMockContextWithSpecificIntentData(null, null, ANDROID_CALENDAR_CONTENT_TYPE, "android.intent.action.INSERT");
+        assertThat(subject.isCalendarAvailable(context)).isFalse();
+    }
+
+    @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+    @Test
+    public void isCalendarAvailable_atLeastIcs_butCanNotAcceptIntent_shouldReturnFalse() throws
+            Exception {
+        context = createMockContextWithSpecificIntentData(null, null, "vnd.android.cursor.item/NOPE", "android.intent.action.INSERT");
+        assertThat(subject.isCalendarAvailable(context)).isFalse();
+    }
+
+    @TargetApi(11)
+    @Test
+    public void isInlineVideoAvailable_whenViewsAreHardwareAccelerated_whenWindowIsHardwareAccelerated_whenApiLevelIsAtLeastHoneycombMR1_shouldReturnTrue() throws Exception {
+        Activity activity = Robolectric.buildActivity(Activity.class).create().get();
+        activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
+
+        View mockView = mock(View.class);
+        when(mockView.isHardwareAccelerated()).thenReturn(true);
+        when(mockView.getLayerType()).thenReturn(View.LAYER_TYPE_HARDWARE);
+
+        assertThat(subject.isInlineVideoAvailable(activity, mockView)).isTrue();
+    }
+
+    @TargetApi(11)
+    @Test
+    public void isInlineVideoAvailable_whenViewsAreHardwareAccelerated_whenWindowIsNotHardwareAccelerated_whenApiLevelIsAtLeastHoneycombMR1_shouldReturnFalse() throws Exception {
+        Activity activity = Robolectric.buildActivity(Activity.class).create().get();
+
+        View mockView = mock(View.class);
+        when(mockView.isHardwareAccelerated()).thenReturn(true);
+        when(mockView.getLayerType()).thenReturn(View.LAYER_TYPE_HARDWARE);
+
+        assertThat(subject.isInlineVideoAvailable(activity, mockView)).isFalse();
+    }
+
+    @Config(reportSdk = Build.VERSION_CODES.HONEYCOMB)
+    @TargetApi(11)
+    @Test
+    public void isInlineVideoAvailable_whenViewsAreHardwareAccelerated_whenWindowIsHardwareAccelerated_whenApiLevelIsLessThanHoneycombMR1_shouldReturnFalse() throws Exception {
+        Activity activity = Robolectric.buildActivity(Activity.class).create().get();
+        activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
+
+        View mockView = mock(View.class);
+        when(mockView.isHardwareAccelerated()).thenReturn(true);
+        when(mockView.getLayerType()).thenReturn(View.LAYER_TYPE_HARDWARE);
+
+        assertThat(subject.isInlineVideoAvailable(activity, mockView)).isFalse();
+    }
+
+    @TargetApi(11)
+    @Test
+    public void isInlineVideoAvailable_whenViewsAreNotHardwareAccelerated_whenWindowIsHardwareAccelerated_whenApiLevelIsAtLeastHoneycombMR1_shouldReturnFalse() throws Exception {
+        Activity activity = Robolectric.buildActivity(Activity.class).create().get();
+        activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
 
-        final Button closeEventRegion = (Button) frameLayout.getChildAt(0);
-        assertThat(closeEventRegion.getVisibility()).isEqualTo(View.VISIBLE);
-        assertThat(shadowOf(closeEventRegion).getBackgroundColor()).isEqualTo(Color.TRANSPARENT);
-        assertThat(shadowOf(closeEventRegion).getOnClickListener()).isEqualTo(subject.getCloseOnClickListener());
-        assertThat(Dips.pixelsToIntDips((float)closeEventRegion.getLayoutParams().width, activity)).isEqualTo(50);
-        assertThat(Dips.pixelsToIntDips((float)closeEventRegion.getLayoutParams().height, activity)).isEqualTo(50);
-        assertThat(((FrameLayout.LayoutParams)closeEventRegion.getLayoutParams()).gravity).isEqualTo(Gravity.TOP | Gravity.RIGHT);
+        View mockView = mock(View.class);
+        when(mockView.isHardwareAccelerated()).thenReturn(false);
+        when(mockView.getLayerType()).thenReturn(View.LAYER_TYPE_HARDWARE);
+
+        assertThat(subject.isInlineVideoAvailable(activity, mockView)).isFalse();
     }
 
-    private void resetMockMraidView(Context context) {
-        reset(mraidView);
-        stub(mraidView.getContext()).toReturn(context);
-        when(mraidView.getParent()).thenReturn(moPubView).thenReturn(null);
-        stub(mraidView.getRootView()).toReturn(rootView);
-        stub(mraidView.getAdConfiguration()).toReturn(adConfiguration);
+    @TargetApi(11)
+    @Test
+    public void isInlineVideoAvailable_whenViewParentIsNotHardwareAccelerated_whenWindowIsHardwareAccelerated_whenApiLevelIsAtLeastHoneycombMR1_shouldReturnFalse() throws Exception {
+        Activity activity = Robolectric.buildActivity(Activity.class).create().get();
+        activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
+
+        // ViewParent
+        LinearLayout mockLinearLayout = mock(LinearLayout.class);
+        when(mockLinearLayout.isHardwareAccelerated()).thenReturn(false);
+        when(mockLinearLayout.getLayerType()).thenReturn(View.LAYER_TYPE_HARDWARE);
+
+        // View
+        View mockView = mock(View.class);
+        when(mockView.isHardwareAccelerated()).thenReturn(true);
+        when(mockView.getLayerType()).thenReturn(View.LAYER_TYPE_HARDWARE);
+        when(mockView.getParent()).thenReturn(mockLinearLayout);
+
+        assertThat(subject.isInlineVideoAvailable(activity, mockView)).isFalse();
     }
 
-    private MraidSupportsProperty captureMraidSupportProperties() {
-        ArgumentCaptor<MraidSupportsProperty> propertiesCaptor = ArgumentCaptor.forClass(MraidSupportsProperty.class);
-        verify(mraidView).fireChangeEventForProperty(propertiesCaptor.capture());
-        return propertiesCaptor.getValue();
+    private static Context createMockContextWithSpecificIntentData(final String scheme, final String componentName, final String type, final String action) {
+        Context context = mock(Context.class);
+        PackageManager packageManager = mock(PackageManager.class);
+
+        List<ResolveInfo> resolveInfos = new ArrayList<ResolveInfo>();
+        resolveInfos.add(new ResolveInfo());
+
+        stub(context.getPackageManager()).toReturn(packageManager);
+
+        BaseMatcher intentWithSpecificData = new BaseMatcher() {
+            // check that the specific intent has the special data, i.e. "tel:", or a component name, or string type, based on a particular data
+
+            @Override
+            public boolean matches(Object item) {
+                if (item != null && item instanceof Intent ){
+                    boolean result = action != null || type != null || componentName != null || scheme != null;
+                    if (action != null) {
+                        if (((Intent) item).getAction() != null) {
+                            result = result && action.equals(((Intent) item).getAction());
+                        }
+                    }
+
+                    if (type != null) {
+                        if (((Intent) item).getType() != null) {
+                            result = result && type.equals(((Intent) item).getType());
+                        }
+                    }
+
+                    if (componentName != null) {
+                        if (((Intent) item).getComponent() != null) {
+                            result = result && componentName.equals(((Intent) item).getComponent().getClassName());
+                        }
+                    }
+
+                    if (scheme != null) {
+                        if (((Intent) item).getData() != null) {
+                            result = result && scheme.equals(((Intent) item).getData().getScheme());
+                        }
+                    }
+                    return result;
+                }
+                return false;
+            }
+
+            @Override
+            public void describeTo(Description description) {
+
+            }
+        };
+
+        // It is okay to query with specific intent or nothing, because by default, none of the query would normally any resolveInfo anyways
+        stub(packageManager.queryIntentActivities((Intent) argThat(intentWithSpecificData), eq(0))).toReturn(resolveInfos);
+        return context;
     }
 
-    private void downloadImageForPendingResponse(String uri, HttpResponse response){
+    private void downloadImageForPendingResponse(String uri, HttpResponse response) throws Exception {
         Robolectric.addPendingHttpResponse(response);
 
-        stub(mraidView.getContext()).toReturn(Robolectric.application);
-        subject = new TestMraidDisplayController(mraidView, null, null);
-        subject.showUserDownloadImageAlert(uri);
+        subject.storePicture(context, uri, mraidCommandFailureListener);
 
         ThreadUtils.pause(TIME_TO_PAUSE_FOR_NETWORK);
     }
 
-    private void assertThatMimeTypeWasAddedCorrectly(String originalFileName, String contentType, String expectedFileName, String expectedExtension) {
+    private void assertThatMimeTypeWasAddedCorrectly(String originalFileName, String contentType,
+            String expectedFileName, String expectedExtension) throws Exception {
         expectedFile = new File(pictureDirectory, expectedFileName);
         response = new TestHttpResponseWithHeaders(200, FAKE_IMAGE_DATA);
-        response.addHeader(MIME_TYPE_HEADER, contentType);
+        response.addHeader(MraidNativeCommandHandler.MIME_TYPE_HEADER, contentType);
 
         downloadImageForPendingResponse(originalFileName, response);
 
@@ -830,7 +762,8 @@ private void assertThatMimeTypeWasAddedCorrectly(String originalFileName, String
 
     private void setupCalendarParams() {
         //we need mock Context so that we can validate that isCalendarAvailable() is true
-        Context mockContext = createMockContextWithSpecificIntentData(null, null, ANDROID_CALENDAR_CONTENT_TYPE, "android.intent.action.INSERT");
+        Context mockContext = createMockContextWithSpecificIntentData(null,
+                null, ANDROID_CALENDAR_CONTENT_TYPE, "android.intent.action.INSERT");
 
         //but a mock context does't know how to startActivity(), so we stub it to use ShadowContext for starting activity
         doAnswer(new Answer<Void>() {
@@ -844,34 +777,7 @@ public Void answer(InvocationOnMock invocation) throws Throwable {
             }
         }).when(mockContext).startActivity(any(Intent.class));
 
-        resetMockMraidView(mockContext);
         params.put("description", "Some Event");
         params.put("start", CALENDAR_START_TIME);
     }
-
-    private Context createMockContextWithSpecificIntentData(final String scheme, final String componentName, final String type, final String action) {
-        return MraidsTest.createMockContextWithSpecificIntentData(scheme, componentName, type, action);
-    }
-
-    private class TestMraidDisplayController extends MraidDisplayController {
-        public TestMraidDisplayController(MraidView mraidView, MraidView.ExpansionStyle expStyle,
-                                          MraidView.NativeCloseButtonStyle buttonStyle) {
-            super(mraidView, expStyle, buttonStyle);
-        }
-
-        @Override
-        FrameLayout createAdContainerLayout() {
-            return adContainerLayout;
-        }
-
-        @Override
-        RelativeLayout createExpansionLayout() {
-            return expansionLayout;
-        }
-
-        @Override
-        FrameLayout createPlaceholderView() {
-            return placeholderView;
-        }
-    }
-}
+}
\ No newline at end of file
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidVideoViewControllerTest.java b/mopub-sdk/src/test/java/com/mopub/mraid/MraidVideoViewControllerTest.java
similarity index 78%
rename from mopub-sdk/src/test/java/com/mopub/mobileads/MraidVideoViewControllerTest.java
rename to mopub-sdk/src/test/java/com/mopub/mraid/MraidVideoViewControllerTest.java
index 80b115ef..213e84d8 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidVideoViewControllerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mraid/MraidVideoViewControllerTest.java
@@ -1,12 +1,12 @@
-package com.mopub.mobileads;
+package com.mopub.mraid;
 
 import android.app.Activity;
 import android.content.Context;
-import android.content.Intent;
 import android.os.Bundle;
 import android.widget.ImageButton;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.EventForwardingBroadcastReceiver;
 
 import org.apache.http.HttpRequest;
 import org.junit.After;
@@ -14,7 +14,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
-import org.robolectric.shadows.ShadowImageButton;
+import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowLocalBroadcastManager;
 import org.robolectric.shadows.ShadowVideoView;
 import org.robolectric.tester.org.apache.http.RequestMatcher;
@@ -24,22 +24,18 @@
 import static android.view.View.VISIBLE;
 import static com.mopub.mobileads.BaseVideoPlayerActivity.VIDEO_URL;
 import static com.mopub.mobileads.BaseVideoViewController.BaseVideoViewControllerListener;
-import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_FAIL;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.getHtmlInterstitialIntentFilter;
-import static com.mopub.mobileads.EventForwardingBroadcastReceiverTest.getIntentForActionAndIdentifier;
 import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(SdkTestRunner.class)
+@Config(manifest=Config.NONE)
 public class MraidVideoViewControllerTest {
     private Context context;
     private Bundle bundle;
-    private long testBroadcastIdentifier;
     private MraidVideoViewController subject;
     private BaseVideoViewControllerListener baseVideoViewControllerListener;
     private EventForwardingBroadcastReceiver broadcastReceiver;
@@ -48,8 +44,6 @@
     public void setUp() throws Exception {
         context = new Activity();
         bundle = new Bundle();
-        testBroadcastIdentifier = 1111;
-        broadcastReceiver = mock(EventForwardingBroadcastReceiver.class);
         baseVideoViewControllerListener = mock(BaseVideoViewControllerListener.class);
 
         bundle.putString(VIDEO_URL, "http://video_url");
@@ -96,7 +90,8 @@ public void onCreate_shouldCreateAndHideCloseButton() throws Exception {
         ImageButton closeButton = getCloseButton();
 
         assertThat(closeButton).isNotNull();
-        assertThat(getShadowImageButton(closeButton).getOnClickListener()).isNotNull();
+
+        assertThat(shadowOf(closeButton).getOnClickListener()).isNotNull();
         assertThat(closeButton.getVisibility()).isEqualTo(GONE);
     }
 
@@ -112,9 +107,7 @@ public void closeButton_onClick_shouldCallBaseVideoControllerListenerOnFinish()
         initializeSubject();
         subject.onCreate();
 
-        ImageButton closeButton = getCloseButton();
-
-        getShadowImageButton(closeButton).getOnClickListener().onClick(null);
+        getCloseButton().performClick();
         verify(baseVideoViewControllerListener).onFinish();
     }
 
@@ -162,32 +155,15 @@ public void onErrorListener_shouldShowCloseButton() throws Exception {
         assertThat(getCloseButton().getVisibility()).isEqualTo(VISIBLE);
     }
 
-    @Test
-    public void onErrorListener_shouldBroadcastInterstitialError() throws Exception {
-        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_FAIL, testBroadcastIdentifier);
-
-        initializeSubject();
-        subject.onCreate();
-
-        assertThat(getShadowVideoView().getOnErrorListener().onError(null, 0, 0)).isEqualTo(false);
-        Robolectric.getUiThreadScheduler().unPause();
-
-        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
-    }
-
     private void initializeSubject() {
-        subject = new MraidVideoViewController(context, bundle, testBroadcastIdentifier, baseVideoViewControllerListener);
+        subject = new MraidVideoViewController(context, bundle, baseVideoViewControllerListener);
     }
 
     private ShadowVideoView getShadowVideoView() {
         return shadowOf(subject.getVideoView());
     }
 
-    protected ImageButton getCloseButton() {
+    ImageButton getCloseButton() {
         return (ImageButton) subject.getLayout().getChildAt(1);
     }
-
-    private ShadowImageButton getShadowImageButton(ImageButton imageButton) {
-        return (ShadowImageButton) shadowOf(imageButton);
-    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/AdapterHelperTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/AdapterHelperTest.java
index fe8f94c7..c8199d78 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/AdapterHelperTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/AdapterHelperTest.java
@@ -1,6 +1,7 @@
 package com.mopub.nativeads;
 
 import android.app.Activity;
+import android.content.Context;
 
 import com.mopub.common.test.support.SdkTestRunner;
 
@@ -9,7 +10,7 @@
 import org.junit.runner.RunWith;
 
 import static org.fest.assertions.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
+import static org.mockito.Mockito.mock;
 
 @RunWith(SdkTestRunner.class)
 public class AdapterHelperTest {
@@ -20,31 +21,29 @@
     private int interval;
 
     @Before
-    public void setUp() throws Exception {
+    public void setUp() {
         context = new Activity();
         start = 1;
         interval = 2;
         subject = new AdapterHelper(context, start, interval);
     }
 
-    @Test
-    public void constructor_whenPassedAnApplicationContext_shouldThrowIllegalArgumentException() throws Exception {
-        try {
-            new AdapterHelper(context.getApplicationContext(), start, interval);
-            fail("Expected IllegalArgumentException to be thrown");
-        } catch (IllegalArgumentException e) {
-            assertThat(e.getMessage()).isEqualTo("Illegal argument: Context must be instance of Activity.");
-        }
+    @Test(expected = IllegalArgumentException.class)
+    public void constructor_whenPassedAnApplicationContext_shouldThrowIllegalArgumentException() {
+        new AdapterHelper(context.getApplicationContext(), start, interval);
     }
 
     @Test
-    public void getAdView_withNullActivityContext_shouldReturnEmptyViewWithApplicationContext() throws Exception {
+    public void getAdView_withNullActivityContext_shouldReturnEmptyViewWithApplicationContext() {
         subject.clearActivityContext();
-        assertThat(subject.getAdView(null, null, null, null, null).getContext()).isEqualTo(context.getApplication());
+        Context viewContext = subject.getAdView(null, null, mock(NativeResponse.class),
+                mock(ViewBinder.class),
+                null).getContext();
+        assertThat(viewContext).isEqualTo(context.getApplication());
     }
 
     @Test
-    public void adapterHelper_withContentRowCountOf10_shouldCalculateCorrectly() throws Exception {
+    public void adapterHelper_withContentRowCountOf10_shouldCalculateCorrectly() {
         contentRowCount = 10;
 
         start = 0;
@@ -158,7 +157,7 @@ public void adapterHelper_withContentRowCountOf10_shouldCalculateCorrectly() thr
     }
 
     @Test
-    public void adapterHelper_withContentRowCountOf1_shouldCalculateCorrectly() throws Exception {
+    public void adapterHelper_withContentRowCountOf1_shouldCalculateCorrectly() {
         contentRowCount = 1;
         start = 0;
         interval = 2;
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/ClickDestinationResolutionListenerTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/ClickDestinationResolutionListenerTest.java
new file mode 100644
index 00000000..e0bf1b9e
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/ClickDestinationResolutionListenerTest.java
@@ -0,0 +1,145 @@
+package com.mopub.nativeads;
+
+import android.app.Activity;
+import android.content.Intent;
+import android.content.pm.ResolveInfo;
+import android.net.Uri;
+
+import com.mopub.common.MoPubBrowser;
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.robolectric.Robolectric;
+
+import java.util.Iterator;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class ClickDestinationResolutionListenerTest {
+
+    private Activity context;
+    private Iterator mockIterator;
+    private SpinningProgressView mockSpinningProgressView;
+    private ClickDestinationResolutionListener subject;
+
+    @Before
+    public void setUp() throws Exception {
+        context = spy(Robolectric.buildActivity(Activity.class).create().get());
+        when(context.getApplicationContext()).thenReturn(context);
+        mockIterator = mock(Iterator.class);
+        mockSpinningProgressView = mock(SpinningProgressView.class);
+
+        subject = new ClickDestinationResolutionListener(context, mockIterator,
+                mockSpinningProgressView);
+    }
+
+    @Test
+    public void onSuccess_withMoPubNativeBrowserUrl_shouldOpenExternalBrowserAndHideProgressView() {
+        subject.onSuccess("mopubnativebrowser://navigate?url=https%3A%2F%2Fwww.example.com");
+
+        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(intent.getDataString()).isEqualTo("https://www.example.com");
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        verify(mockSpinningProgressView).removeFromRoot();
+    }
+
+    @Test
+    public void onSuccess_withMalformedMoPubNativeBrowserUrl_shouldHideProgressViewButNotOpenExternalBrowser() {
+        // url2 is the wrong query parameter
+        subject.onSuccess("mopubnativebrowser://navigate?url2=https%3A%2F%2Fwww.example.com");
+
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+        verify(mockSpinningProgressView).removeFromRoot();
+    }
+
+    @Test
+    public void onSuccess_withDeepLinkThatIsResolvable_shouldStartActionViewIntent_shouldRemoveSpinningProgressView() {
+        String deepLinkUrl = "appscheme://host";
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(Intent.ACTION_VIEW,
+                Uri.parse(deepLinkUrl)), new ResolveInfo());
+
+        subject.onSuccess(deepLinkUrl);
+
+        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        assertThat(intent.getDataString()).isEqualTo("appscheme://host");
+        verify(mockSpinningProgressView).removeFromRoot();
+    }
+
+    @Test
+    public void onSuccess_withDeepLinkThatIsUnresolvable_shouldNotStartNewIntent_shouldRemoveSpinningProgressView() {
+        String deepLinkUrl = "appscheme://host";
+        // don't add any relevant ResolveInfos to the Robolectric packageManager
+
+        subject.onSuccess(deepLinkUrl);
+
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+        verify(mockSpinningProgressView).removeFromRoot();
+    }
+
+    @Test
+    public void onSuccess_withAppStoreUrl_shouldStartAppStoreIntent_shouldRemoveSpinningProgressView() {
+        String appStoreUrl = "play.google.com";
+        Robolectric.packageManager.addResolveInfoForIntent(new Intent(Intent.ACTION_VIEW,
+                Uri.parse(appStoreUrl)), new ResolveInfo());
+
+        subject.onSuccess(appStoreUrl);
+
+        Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
+        assertThat(intent.getDataString()).isEqualTo("play.google.com");
+        verify(mockSpinningProgressView).removeFromRoot();
+    }
+
+    @Test
+    public void onSuccess_withHttpUrl_showOpenInMoPubBrowser_shouldRemoveSpinningProgressViewFromRoot() {
+        String httpUrl = "http://www.dotcom.com";
+
+        subject.onSuccess(httpUrl);
+
+        ArgumentCaptor<Intent> intentCaptor = ArgumentCaptor.forClass(Intent.class);
+        verify(context).startActivity(intentCaptor.capture());
+
+        Intent intent = intentCaptor.getValue();
+
+        assertThat(intent.getComponent().getPackageName()).isEqualTo("com.mopub.mobileads");
+        assertThat(intent.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
+        assertThat(intent.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(httpUrl);
+        verify(mockSpinningProgressView).removeFromRoot();
+    }
+
+    @Test
+    public void onSuccess_withHttpsUrl_showOpenInMoPubBrowser_shouldRemoveSpinningProgressViewFromRoot() {
+        String httpsUrl = "https://www.comdot.com";
+
+        subject.onSuccess(httpsUrl);
+
+        ArgumentCaptor<Intent> intentCaptor = ArgumentCaptor.forClass(Intent.class);
+        verify(context).startActivity(intentCaptor.capture());
+
+        Intent intent = intentCaptor.getValue();
+
+        assertThat(intent.getComponent().getPackageName()).isEqualTo("com.mopub.mobileads");
+        assertThat(intent.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
+        assertThat(intent.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(httpsUrl);
+        verify(mockSpinningProgressView).removeFromRoot();
+    }
+
+    @Test
+    public void onSuccess_withAboutBlankUrl_shouldFailSilently_shouldRemoveSpinningProgressView() {
+        String url = "about:blank";
+
+        subject.onSuccess(url);
+
+        assertThat(Robolectric.getShadowApplication().getNextStartedActivity()).isNull();
+        verify(mockSpinningProgressView).removeFromRoot();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/CustomEventNativeAdapterTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/CustomEventNativeAdapterTest.java
index 85fe6d61..6a067014 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/CustomEventNativeAdapterTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/CustomEventNativeAdapterTest.java
@@ -2,11 +2,10 @@
 
 import android.app.Activity;
 
-import com.mopub.common.DownloadResponse;
-import com.mopub.common.util.ResponseHeader;
-import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
+import com.mopub.common.AdType;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.nativeads.test.support.TestCustomEventNativeFactory;
+import com.mopub.network.AdResponse;
 
 import org.junit.Before;
 import org.junit.Test;
@@ -15,6 +14,7 @@
 import java.util.HashMap;
 
 import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
@@ -23,12 +23,11 @@
 public class CustomEventNativeAdapterTest {
 
     private Activity context;
-    private DownloadResponse downloadResponse;
     private HashMap<String, Object> localExtras;
     private CustomEventNative.CustomEventNativeListener mCustomEventNativeListener;
     private CustomEventNative mCustomEventNative;
     private HashMap<String, String> serverExtras;
-    private TestHttpResponseWithHeaders testHttpResponseWithHeaders;
+    private AdResponse testAdResponse;
 
     @Before
     public void setUp() throws Exception {
@@ -37,12 +36,13 @@ public void setUp() throws Exception {
         localExtras = new HashMap<String, Object>();
         serverExtras = new HashMap<String, String>();
         serverExtras.put("key", "value");
-        serverExtras.put(CustomEventNativeAdapter.RESPONSE_BODY_KEY, "body");
 
-        testHttpResponseWithHeaders = new TestHttpResponseWithHeaders(200, "body");
-        testHttpResponseWithHeaders.addHeader(ResponseHeader.CUSTOM_EVENT_DATA.getKey(), "{ \"key\" : \"value\" }");
-        testHttpResponseWithHeaders.addHeader(ResponseHeader.CUSTOM_EVENT_NAME.getKey(), "com.mopub.nativeads.MoPubCustomEventNative");
-        downloadResponse = new DownloadResponse(testHttpResponseWithHeaders);
+        testAdResponse = new AdResponse.Builder()
+                .setAdType(AdType.NATIVE)
+                .setCustomEventClassName("com.mopub.nativeads.MoPubCustomEventNative")
+                .setResponseBody("body")
+                .setServerExtras(serverExtras)
+                .build();
 
         mCustomEventNativeListener = mock(CustomEventNative.CustomEventNativeListener.class);
 
@@ -51,7 +51,7 @@ public void setUp() throws Exception {
 
     @Test
     public void loadNativeAd_withValidInput_shouldCallLoadNativeAdOnTheCustomEvent() throws Exception {
-        CustomEventNativeAdapter.loadNativeAd(context, localExtras, downloadResponse, mCustomEventNativeListener);
+        CustomEventNativeAdapter.loadNativeAd(context, localExtras, testAdResponse, mCustomEventNativeListener);
         verify(mCustomEventNative).loadNativeAd(context, mCustomEventNativeListener, localExtras, serverExtras);
         verify(mCustomEventNativeListener, never()).onNativeAdFailed(any(NativeErrorCode.class));
         verify(mCustomEventNativeListener, never()).onNativeAdLoaded(any(NativeAdInterface.class));
@@ -59,10 +59,11 @@ public void loadNativeAd_withValidInput_shouldCallLoadNativeAdOnTheCustomEvent()
 
     @Test
     public void loadNativeAd_withInvalidClassName_shouldNotifyListenerOfOnNativeAdFailedAndReturn() throws Exception {
-        testHttpResponseWithHeaders.addHeader(ResponseHeader.CUSTOM_EVENT_NAME.getKey(), "com.mopub.baaad.invalidinvalid123143");
-        downloadResponse = new DownloadResponse(testHttpResponseWithHeaders);
+        testAdResponse = testAdResponse.toBuilder()
+                .setCustomEventClassName("com.mopub.baaad.invalidinvalid123143")
+                .build();
 
-        CustomEventNativeAdapter.loadNativeAd(context, localExtras, downloadResponse, mCustomEventNativeListener);
+        CustomEventNativeAdapter.loadNativeAd(context, localExtras, testAdResponse, mCustomEventNativeListener);
         verify(mCustomEventNativeListener).onNativeAdFailed(NativeErrorCode.NATIVE_ADAPTER_NOT_FOUND);
         verify(mCustomEventNativeListener, never()).onNativeAdLoaded(any(NativeAdInterface.class));
         verify(mCustomEventNative, never()).loadNativeAd(context, mCustomEventNativeListener, localExtras, serverExtras);
@@ -70,12 +71,12 @@ public void loadNativeAd_withInvalidClassName_shouldNotifyListenerOfOnNativeAdFa
 
     @Test
     public void loadNativeAd_withInvalidCustomEventNativeData_shouldNotAddToServerExtras() throws Exception {
-        testHttpResponseWithHeaders.addHeader(ResponseHeader.CUSTOM_EVENT_DATA.getKey(), "{ \"bad json");
-        downloadResponse = new DownloadResponse(testHttpResponseWithHeaders);
-        serverExtras.remove("key");
+        testAdResponse = testAdResponse.toBuilder()
+                .setServerExtras(null)
+                .build();
 
-        CustomEventNativeAdapter.loadNativeAd(context, localExtras, downloadResponse, mCustomEventNativeListener);
-        verify(mCustomEventNative).loadNativeAd(context, mCustomEventNativeListener, localExtras, serverExtras);
+        CustomEventNativeAdapter.loadNativeAd(context, localExtras, testAdResponse, mCustomEventNativeListener);
+        verify(mCustomEventNative).loadNativeAd(eq(context), eq(mCustomEventNativeListener), eq(localExtras), eq(new HashMap<String, String>()));
         verify(mCustomEventNativeListener, never()).onNativeAdFailed(any(NativeErrorCode.class));
         verify(mCustomEventNativeListener, never()).onNativeAdLoaded(any(NativeAdInterface.class));
     }
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/ImageDiskTaskManagerTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/ImageDiskTaskManagerTest.java
deleted file mode 100644
index 6d6e7195..00000000
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/ImageDiskTaskManagerTest.java
+++ /dev/null
@@ -1,162 +0,0 @@
-package com.mopub.nativeads;
-
-import android.app.Activity;
-import android.content.Context;
-import android.graphics.Bitmap;
-
-import com.mopub.common.CacheService;
-import com.mopub.common.CacheServiceTest;
-import com.mopub.common.test.support.SdkTestRunner;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.Robolectric;
-import org.robolectric.tester.org.apache.http.FakeHttpLayer;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.Semaphore;
-
-import static com.mopub.nativeads.TaskManager.TaskManagerListener;
-import static junit.framework.Assert.fail;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.anyMap;
-import static org.mockito.Mockito.doAnswer;
-
-@RunWith(SdkTestRunner.class)
-public class ImageDiskTaskManagerTest {
-
-    @Mock private TaskManagerListener<Bitmap> imageTaskManagerListener;
-    private Semaphore semaphore;
-    private Map<String, Bitmap> bitmaps;
-    private FakeHttpLayer fakeHttpLayer;
-    private String url1;
-    private String url2;
-    private String url3;
-    private String imageData1;
-    private String imageData2;
-    private String imageData3;
-    private List<String> list;
-    private Context context;
-    private static final int TEST_WIDTH = 400;
-
-    @Before
-    public void setUp() throws Exception {
-        context = new Activity();
-        semaphore = new Semaphore(0);
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                Object[] args = invocationOnMock.getArguments();
-                Map<String, Bitmap> bitmaps = (Map)args[0];
-                ImageDiskTaskManagerTest.this.bitmaps = bitmaps;
-                semaphore.release();
-                return null;
-            }
-        }).when(imageTaskManagerListener).onSuccess(anyMap());
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                semaphore.release();
-                return null;
-            }
-        }).when(imageTaskManagerListener).onFail();
-
-        fakeHttpLayer = Robolectric.getFakeHttpLayer();
-        url1 = "http://www.mopub.com/";
-        url2 = "http://www.twitter.com";
-        url3 = "http://www.guydot.com";
-        imageData1 = "image_data_1";
-        imageData2 = "image_data_2";
-        imageData3 = "image_data_3";
-
-        list = new ArrayList<String>();
-        list.add(url1);
-        list.add(url2);
-    }
-
-    @After
-    public void tearDown() throws Exception {
-        CacheService.clearAndNullCaches();
-    }
-
-    @Test
-    public void constructor_withNullUrlsList_shouldThrowIllegalArgumentException() throws Exception {
-        try {
-            new ImageDiskTaskManager(null, imageTaskManagerListener, TEST_WIDTH);
-            fail("Should have thrown IllegalArgumentException");
-        } catch (IllegalArgumentException e) {
-            // pass
-        }
-    }
-
-    @Test
-    public void constructor_withNullInUrlsList_shouldThrowIllegalArgumentException() throws Exception {
-        List<String> myList = new ArrayList<String>();
-        myList.add(null);
-        try {
-            new ImageDiskTaskManager(myList, imageTaskManagerListener, TEST_WIDTH);
-            fail("Should have thrown IllegalArgumentException");
-        } catch (IllegalArgumentException e) {
-            // pass
-        }
-    }
-
-    @Test
-    public void constructor_withNullImageTaskManagerListener_shouldThrowIllegalArgumentException() throws Exception {
-        try {
-            new ImageDiskTaskManager(list, null, TEST_WIDTH);
-            fail("Should have thrown IllegalArgumentException");
-        } catch (IllegalArgumentException e) {
-            // pass
-        }
-    }
-
-    @Test
-    public void execute_withEmptyDiskCache_shouldReturnNullsInMap() throws Exception {
-        new ImageDiskTaskManager(list, imageTaskManagerListener, TEST_WIDTH).execute();
-        semaphore.acquire();
-
-        assertThat(bitmaps.size()).isEqualTo(2);
-        assertThat(bitmaps.containsKey(url1)).isTrue();
-        assertThat(bitmaps.containsKey(url2)).isTrue();
-        assertThat(bitmaps.get(url1)).isNull();
-        assertThat(bitmaps.get(url2)).isNull();
-    }
-
-    @Test
-    public void execute_withPopulatedDiskCache_shouldReturnImagesInMap() throws Exception {
-        CacheService.initialize(context);
-        CacheServiceTest.assertCachesAreEmpty();
-        CacheService.putToDiskCache(url1, imageData1.getBytes());
-        CacheService.putToDiskCache(url2, imageData2.getBytes());
-
-        new ImageDiskTaskManager(list, imageTaskManagerListener, TEST_WIDTH).execute();
-        semaphore.acquire();
-
-        assertThat(bitmaps.size()).isEqualTo(2);
-        assertThat(bitmaps.get(url1)).isNotNull();
-        assertThat(bitmaps.get(url2)).isNotNull();
-    }
-
-    @Test
-    public void execute_withPartiallyPopulatedDiskCache_shouldReturnSomeImagesInMap() throws Exception {
-        CacheService.initialize(context);
-        CacheServiceTest.assertCachesAreEmpty();
-        CacheService.putToDiskCache(url1, imageData1.getBytes());
-
-        new ImageDiskTaskManager(list, imageTaskManagerListener, TEST_WIDTH).execute();
-        semaphore.acquire();
-
-        assertThat(bitmaps.size()).isEqualTo(2);
-        assertThat(bitmaps.get(url1)).isNotNull();
-        assertThat(bitmaps.containsKey(url2)).isTrue();
-        assertThat(bitmaps.get(url2)).isNull();
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/ImageDownloadTaskManagerTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/ImageDownloadTaskManagerTest.java
deleted file mode 100644
index b9664d43..00000000
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/ImageDownloadTaskManagerTest.java
+++ /dev/null
@@ -1,259 +0,0 @@
-package com.mopub.nativeads;
-
-import com.mopub.common.DownloadResponse;
-import com.mopub.common.test.support.SdkTestRunner;
-
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpResponse;
-import org.apache.http.params.BasicHttpParams;
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.Robolectric;
-import org.robolectric.tester.org.apache.http.FakeHttpLayer;
-import org.robolectric.tester.org.apache.http.TestHttpResponse;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Map;
-import java.util.concurrent.Semaphore;
-
-import static com.mopub.nativeads.TaskManager.TaskManagerListener;
-import static junit.framework.Assert.fail;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.anyMap;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-@RunWith(SdkTestRunner.class)
-public class ImageDownloadTaskManagerTest {
-
-    private ImageDownloadTaskManager subject;
-    @Mock private TaskManagerListener<DownloadResponse> mMockImageTaskManagerListener;
-    private Semaphore semaphore;
-    private Map<String, DownloadResponse> networkImages;
-    private int testMaxWidth;
-    private FakeHttpLayer fakeHttpLayer;
-    private String url1;
-    private String url2;
-
-    @Before
-    public void setUp() throws Exception {
-        semaphore = new Semaphore(0);
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                Object[] args = invocationOnMock.getArguments();
-                Map<String, DownloadResponse> map = (Map)args[0];
-                ImageDownloadTaskManagerTest.this.networkImages = map;
-                semaphore.release();
-                return null;
-            }
-        }).when(mMockImageTaskManagerListener).onSuccess(anyMap());
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                semaphore.release();
-                return null;
-            }
-        }).when(mMockImageTaskManagerListener).onFail();
-        testMaxWidth = 30;
-
-        fakeHttpLayer = Robolectric.getFakeHttpLayer();
-        url1 = "http://www.mopub.com/";
-        url2 = "http://www.twitter.com";
-    }
-
-    @Test
-    public void constructor_withValidUrlListAndListener_shouldReturnNewImageDownloadTaskManager() throws Exception {
-        subject = new ImageDownloadTaskManager(
-                Arrays.asList(url1, url2),
-                mMockImageTaskManagerListener,
-                testMaxWidth
-        );
-    }
-
-    @Test
-    public void constructor_withEmptyUrlListAndListener_shouldReturnNewImageDownloadTaskManager() throws Exception {
-        subject = new ImageDownloadTaskManager(
-                new ArrayList<String>(),
-                mMockImageTaskManagerListener,
-                testMaxWidth
-        );
-    }
-
-    @Test
-    public void constructor_withInvalidUrlList_shouldThrowIllegalArgumentException() throws Exception {
-        try {
-            subject = new ImageDownloadTaskManager(
-                    Arrays.asList("BAD URL", url2),
-                    mMockImageTaskManagerListener,
-                    testMaxWidth
-            );
-            fail("ImageDownloadTaskManager didn't throw an illegal argument exception");
-        } catch (IllegalArgumentException e) {
-            // pass
-        }
-
-        try {
-            subject = new ImageDownloadTaskManager(
-                    Arrays.asList(url1, null),
-                    mMockImageTaskManagerListener,
-                    testMaxWidth
-            );
-            fail("ImageDownloadTaskManager didn't throw an illegal argument exception");
-        } catch (IllegalArgumentException e) {
-            // pass
-        }
-    }
-
-    @Test
-    public void constructor_withAnyNullParams_shouldThrowIllegalArgumentException() throws Exception {
-        try {
-            subject = new ImageDownloadTaskManager(
-                    null,
-                    mMockImageTaskManagerListener,
-                    testMaxWidth
-            );
-            fail("ImageDownloadTaskManager didn't throw an illegal argument exception");
-        } catch (IllegalArgumentException e) {
-            // pass
-        }
-
-        try {
-            subject = new ImageDownloadTaskManager(
-                    Arrays.asList(url1, url2),
-                    null,
-                    testMaxWidth
-            );
-            fail("ImageDownloadTaskManager didn't throw an illegal argument exception");
-        } catch (IllegalArgumentException e) {
-            // pass
-        }
-    }
-
-    @Test
-    public void execute_withValidUrlListAndListenerAndHttpResponses_shouldReturnMapOfUrlToDownloadResponse() throws Exception {
-        subject = new ImageDownloadTaskManager(
-                Arrays.asList(url1, url2),
-                mMockImageTaskManagerListener,
-                testMaxWidth
-        );
-
-        String imageData1 = "image_data_1";
-        String imageData2 = "image_data_2";
-        fakeHttpLayer.addPendingHttpResponse(200, imageData1);
-        fakeHttpLayer.addPendingHttpResponse(200, imageData2);
-
-        subject.execute();
-        semaphore.acquire();
-
-        assertThat(networkImages.keySet()).containsOnly(url1, url2);
-
-        // These statements will fail if the objects are not of the correct type.
-        DownloadResponse bitmap1 = networkImages.get(url1);
-        DownloadResponse bitmap2 = networkImages.get(url2);
-
-        verify(mMockImageTaskManagerListener).onSuccess(anyMap());
-        verify(mMockImageTaskManagerListener, never()).onFail();
-    }
-
-    @Test
-    public void execute_withEmptyUrlList_shouldReturnEmptyMap() throws Exception {
-        subject = new ImageDownloadTaskManager(
-                new ArrayList<String>(),
-                mMockImageTaskManagerListener,
-                testMaxWidth
-        );
-
-        subject.execute();
-        semaphore.acquire();
-
-        assertThat(networkImages.isEmpty()).isTrue();
-        verify(mMockImageTaskManagerListener).onSuccess(anyMap());
-        verify(mMockImageTaskManagerListener, never()).onFail();
-    }
-
-    @Test
-    public void execute_withSingleNon200Response_shouldFailAllTasks() throws Exception {
-        subject = new ImageDownloadTaskManager(
-                Arrays.asList(url1, url1, url1, url1, url1),
-                mMockImageTaskManagerListener,
-                testMaxWidth
-        );
-
-        fakeHttpLayer.addPendingHttpResponse(200, "");
-        fakeHttpLayer.addPendingHttpResponse(200, "");
-        fakeHttpLayer.addPendingHttpResponse(200, "");
-        fakeHttpLayer.addPendingHttpResponse(200, "");
-        fakeHttpLayer.addPendingHttpResponse(599, "");
-
-        subject.execute();
-        semaphore.acquire();
-
-        verify(mMockImageTaskManagerListener, never()).onSuccess(anyMap());
-        verify(mMockImageTaskManagerListener).onFail();
-    }
-
-    @Test
-    public void execute_withMultipleNon200Response_shouldFailAllTasks() throws Exception {
-        subject = new ImageDownloadTaskManager(
-                Arrays.asList(url1, url1, url1, url1, url1),
-                mMockImageTaskManagerListener,
-                testMaxWidth
-        );
-
-        fakeHttpLayer.addPendingHttpResponse(599, "");
-        fakeHttpLayer.addPendingHttpResponse(599, "");
-        fakeHttpLayer.addPendingHttpResponse(599, "");
-        fakeHttpLayer.addPendingHttpResponse(599, "");
-        fakeHttpLayer.addPendingHttpResponse(599, "");
-
-        subject.execute();
-        semaphore.acquire();
-
-        verify(mMockImageTaskManagerListener, never()).onSuccess(anyMap());
-        verify(mMockImageTaskManagerListener).onFail();
-    }
-
-    @Ignore("need to fix concurrency logic")
-    @Test
-    public void execute_withSingleInvalidHttpResponse_shouldFailAllTasks() throws Exception {
-        subject = new ImageDownloadTaskManager(
-                Arrays.asList(url1, url1, url1, url1, url1),
-                mMockImageTaskManagerListener,
-                testMaxWidth
-        );
-
-        fakeHttpLayer.addPendingHttpResponse(200, "");
-        fakeHttpLayer.addPendingHttpResponse(200, "");
-        fakeHttpLayer.addPendingHttpResponse(200, "");
-        fakeHttpLayer.addPendingHttpResponse(200, "");
-        fakeHttpLayer.addPendingHttpResponse(createMockHttpResponseThatThrowsOnGetContent());
-
-        subject.execute();
-        semaphore.acquire();
-
-        verify(mMockImageTaskManagerListener, never()).onSuccess(anyMap());
-        verify(mMockImageTaskManagerListener).onFail();
-    }
-
-    private static HttpResponse createMockHttpResponseThatThrowsOnGetContent() throws IOException {
-        HttpEntity mockHttpEntity = mock(HttpEntity.class);
-        when(mockHttpEntity.getContent()).thenThrow(new IOException());
-
-        TestHttpResponse mockHttpResponse = mock(TestHttpResponse.class);
-        when(mockHttpResponse.getStatusLine()).thenReturn(mockHttpResponse.new TestStatusLine());
-        when(mockHttpResponse.getParams()).thenReturn(new BasicHttpParams());
-        when(mockHttpResponse.getEntity()).thenReturn(mockHttpEntity);
-        return mockHttpResponse;
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/ImageServiceTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/ImageServiceTest.java
deleted file mode 100644
index f1298d06..00000000
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/ImageServiceTest.java
+++ /dev/null
@@ -1,406 +0,0 @@
-package com.mopub.nativeads;
-
-import android.app.Activity;
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-
-import com.mopub.common.CacheService;
-import com.mopub.common.CacheServiceTest;
-import com.mopub.common.DownloadResponse;
-import com.mopub.nativeads.test.support.MoPubShadowBitmap;
-import com.mopub.nativeads.test.support.MoPubShadowDisplay;
-import com.mopub.common.test.support.SdkTestRunner;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.Robolectric;
-import org.robolectric.annotation.Config;
-import org.robolectric.tester.org.apache.http.FakeHttpLayer;
-
-import java.io.ByteArrayInputStream;
-import java.io.InputStream;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.Semaphore;
-
-import static com.mopub.nativeads.ImageService.ImageServiceListener;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.anyMap;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.when;
-import static org.robolectric.Robolectric.shadowOf;
-
-@RunWith(SdkTestRunner.class)
-@Config(shadows={MoPubShadowBitmap.class, MoPubShadowDisplay.class})
-public class ImageServiceTest {
-    private ImageServiceListener imageServiceListener;
-    private Semaphore semaphore;
-    private Map<String, Bitmap> bitmaps;
-    private FakeHttpLayer fakeHttpLayer;
-    private String url1;
-    private String url2;
-    private String url3;
-    private String imageData1;
-    private String imageData2;
-    private String imageData3;
-    private Context context;
-    private Bitmap image2;
-    private Bitmap image1;
-    private DownloadResponse downloadResponse;
-
-    @Before
-    public void setUp() throws Exception {
-        semaphore = new Semaphore(0);
-        imageServiceListener = mock(ImageServiceListener.class);
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                Object[] args = invocationOnMock.getArguments();
-                Map<String, Bitmap> bitmaps = (Map)args[0];
-                ImageServiceTest.this.bitmaps = bitmaps;
-                semaphore.release();
-                return null;
-            }
-        }).when(imageServiceListener).onSuccess(anyMap());
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                semaphore.release();
-                return null;
-            }
-        }).when(imageServiceListener).onFail();
-
-        downloadResponse = mock(DownloadResponse.class);
-        fakeHttpLayer = Robolectric.getFakeHttpLayer();
-        url1 = "http://www.mopub.com/";
-        url2 = "http://www.twitter.com";
-        url3 = "http://www.guydot.com";
-        imageData1 = "image_data_1";
-        imageData2 = "image_data_2";
-        imageData3 = "image_data_3";
-        image1 = BitmapFactory.decodeByteArray(imageData1.getBytes(), 0, imageData1.getBytes().length);
-        image2 = BitmapFactory.decodeByteArray(imageData2.getBytes(), 0, imageData2.getBytes().length);
-        context = new Activity();
-
-        ImageService.initialize(context);
-    }
-
-    @After
-    public void tearDown() throws Exception {
-        CacheService.clearAndNullCaches();
-    }
-
-    @Test
-    public void get_shouldInitializeCaches() throws Exception {
-        CacheService.clearAndNullCaches();
-        assertThat(CacheService.getBitmapLruCache()).isNull();
-        assertThat(CacheService.getDiskLruCache()).isNull();
-
-        ImageService.get(context, new ArrayList<String>(), imageServiceListener);
-
-        assertThat(CacheService.getBitmapLruCache()).isNotNull();
-        assertThat(CacheService.getDiskLruCache()).isNotNull();
-    }
-
-    @Test
-    public void get_shouldGetDisplaySize() {
-        ImageService.clear();
-        assertThat(ImageService.getTargetWidth()).isEqualTo(-1);
-
-        ImageService.get(context, new ArrayList<String>(), imageServiceListener);
-        assertThat(ImageService.getTargetWidth()).isGreaterThan(-1);
-    }
-
-    @Test
-    public void get_withImageInMemoryCache_shouldReturnImage() throws Exception {
-        CacheService.initialize(context);
-        CacheServiceTest.assertCachesAreEmpty();
-        CacheService.putToBitmapCache(url1, image1);
-
-        ImageService.get(context, Arrays.asList(url1), imageServiceListener);
-        // no need for semaphore since memory cache is synchronous
-
-        assertThat(shadowOf(bitmaps.get(url1)).getDescription())
-                .isEqualTo("Bitmap for image_data_1");
-    }
-
-    @Test
-    public void get_withImageInDiskCache_shouldReturnImage() throws Exception {
-        CacheService.initialize(context);
-        CacheServiceTest.assertCachesAreEmpty();
-        CacheService.putToDiskCache(url1, imageData1.getBytes());
-
-        ImageService.get(context, Arrays.asList(url1), imageServiceListener);
-        semaphore.acquire();
-
-        assertThat(fakeHttpLayer.getLastSentHttpRequestInfo()).isNull();
-        assertThat(shadowOf(bitmaps.get(url1)).getDescription())
-                .isEqualTo("Bitmap for image_data_1");
-    }
-
-    @Test
-    public void get_withEmptyCaches_shouldGetImageFromNetwork() throws Exception {
-        CacheService.initialize(context);
-        CacheServiceTest.assertCachesAreEmpty();
-
-        fakeHttpLayer.addPendingHttpResponse(200, imageData1);
-
-        ImageService.get(context, Arrays.asList(url1), imageServiceListener);
-        semaphore.acquire();
-
-        assertThat(shadowOf(bitmaps.get(url1)).getDescription())
-                .isEqualTo("Bitmap for image_data_1");
-    }
-
-    @Test
-    public void get_withImagesInMemoryCacheAndDiskCache_shouldReturnBothImages() throws Exception {
-        CacheService.initialize(context);
-        CacheServiceTest.assertCachesAreEmpty();
-
-        CacheService.putToBitmapCache(url1, image1);
-        CacheService.putToDiskCache(url2, imageData2.getBytes());
-
-        ImageService.get(context, Arrays.asList(url1, url2), imageServiceListener);
-        semaphore.acquire();
-
-        assertThat(bitmaps.get(url1)).isEqualTo(image1);
-        assertThat(fakeHttpLayer.getLastSentHttpRequestInfo()).isNull();
-        assertThat(shadowOf(bitmaps.get(url2)).getDescription())
-                .isEqualTo("Bitmap for image_data_2");
-    }
-
-    @Test
-    public void get_withImagesInMemoryAndNetwork_shouldReturnBothImages() throws Exception {
-        CacheService.initialize(context);
-        CacheServiceTest.assertCachesAreEmpty();
-
-        CacheService.putToBitmapCache(url1, image1);
-        fakeHttpLayer.addPendingHttpResponse(200, imageData2);
-
-        ImageService.get(context, Arrays.asList(url1, url2), imageServiceListener);
-        semaphore.acquire();
-
-        assertThat(shadowOf(bitmaps.get(url1)).getCreatedFromBytes()).isEqualTo(imageData1.getBytes());
-        assertThat(fakeHttpLayer.getLastSentHttpRequestInfo().getHttpHost().toString()).isEqualTo(url2);
-        assertThat(shadowOf(bitmaps.get(url2)).getDescription())
-                .isEqualTo("Bitmap for image_data_2");
-    }
-
-    @Test
-    public void get_withImagesInDiskAndNetwork_shouldReturnBothImages() throws Exception {
-        CacheService.initialize(context);
-        CacheServiceTest.assertCachesAreEmpty();
-
-        CacheService.putToDiskCache(url1, imageData1.getBytes());
-        fakeHttpLayer.addPendingHttpResponse(200, imageData2);
-
-        ImageService.get(context, Arrays.asList(url1, url2), imageServiceListener);
-        semaphore.acquire();
-
-        assertThat(shadowOf(bitmaps.get(url1)).getDescription())
-                .isEqualTo("Bitmap for image_data_1");
-        assertThat(fakeHttpLayer.getLastSentHttpRequestInfo().getHttpHost().toString()).isEqualTo(url2);
-        assertThat(shadowOf(bitmaps.get(url2)).getDescription())
-                .isEqualTo("Bitmap for image_data_2");
-    }
-
-    @Test
-    public void get_withImagesInMemoryAndDiskAndNetwork_shouldReturnAllImages() throws Exception {
-        CacheService.initialize(context);
-        CacheServiceTest.assertCachesAreEmpty();
-
-        CacheService.putToBitmapCache(url1, image1);
-        CacheService.putToDiskCache(url2, imageData2.getBytes());
-        fakeHttpLayer.addPendingHttpResponse(200, imageData3);
-
-        ImageService.get(context, Arrays.asList(url1, url2, url3), imageServiceListener);
-        semaphore.acquire();
-
-        assertThat(shadowOf(bitmaps.get(url1)).getCreatedFromBytes()).isEqualTo(imageData1.getBytes());
-        assertThat(shadowOf(bitmaps.get(url2)).getDescription())
-                .isEqualTo("Bitmap for image_data_2");
-        assertThat(shadowOf(bitmaps.get(url3)).getDescription())
-                .isEqualTo("Bitmap for image_data_3");
-    }
-
-    @Test
-    public void get_withSameKeysInMemoryAndDiskCache_shouldReturnValueFromMemoryCache() throws Exception {
-        CacheService.initialize(context);
-        CacheServiceTest.assertCachesAreEmpty();
-
-        CacheService.putToBitmapCache(url1, image2);
-        CacheService.putToDiskCache(url1, imageData1.getBytes());
-
-        ImageService.get(context, Arrays.asList(url1), imageServiceListener);
-        semaphore.acquire();
-
-        assertThat(shadowOf(bitmaps.get(url1)).getCreatedFromBytes()).isEqualTo(imageData2.getBytes());
-    }
-
-    @Test
-    public void get_withSameKeysInMemoryAndNetwork_shouldReturnValueFromMemoryCache() throws Exception {
-        CacheService.initialize(context);
-        CacheServiceTest.assertCachesAreEmpty();
-
-        CacheService.putToBitmapCache(url1, image2);
-        fakeHttpLayer.addPendingHttpResponse(200, imageData1);
-
-        ImageService.get(context, Arrays.asList(url1), imageServiceListener);
-        semaphore.acquire();
-
-        assertThat(shadowOf(bitmaps.get(url1)).getCreatedFromBytes()).isEqualTo(imageData2.getBytes());
-    }
-
-    @Test
-    public void get_withSameKeysInDiskAndNetwork_shouldReturnValueFromDiskCache() throws Exception {
-        CacheService.initialize(context);
-        CacheServiceTest.assertCachesAreEmpty();
-
-        CacheService.putToDiskCache(url1, imageData2.getBytes());
-        fakeHttpLayer.addPendingHttpResponse(200, imageData1);
-
-        ImageService.get(context, Arrays.asList(url1), imageServiceListener);
-        semaphore.acquire();
-
-        assertThat(fakeHttpLayer.getLastSentHttpRequestInfo()).isNull();
-        assertThat(shadowOf(bitmaps.get(url1)).getDescription())
-                .isEqualTo("Bitmap for image_data_2");
-    }
-
-    @Test
-    public void get_withNetworkFailure_shouldFail() throws Exception {
-        CacheService.initialize(context);
-        CacheServiceTest.assertCachesAreEmpty();
-
-        CacheService.putToBitmapCache(url1, image1);
-        CacheService.putToDiskCache(url2, imageData2.getBytes());
-        fakeHttpLayer.addPendingHttpResponse(500, imageData3);
-
-        ImageService.get(context, Arrays.asList(url1, url2, url3), imageServiceListener);
-        semaphore.acquire();
-
-        assertThat(bitmaps).isNull();
-    }
-
-    @Test
-    public void get_withMultipleNetworkSuccessAndOneFailure_shouldFail() throws Exception {
-        CacheService.initialize(context);
-        CacheServiceTest.assertCachesAreEmpty();
-
-        fakeHttpLayer.addPendingHttpResponse(200, imageData1);
-        fakeHttpLayer.addPendingHttpResponse(200, imageData2);
-        fakeHttpLayer.addPendingHttpResponse(500, imageData3);
-
-        ImageService.get(context, Arrays.asList(url1, url2, url3), imageServiceListener);
-        semaphore.acquire();
-
-        assertThat(bitmaps).isNull();
-    }
-
-    @Test
-    public void putDataInCache_populatesCaches() throws Exception {
-        CacheService.initialize(context);
-
-        Bitmap bitmap1 = BitmapFactory.decodeStream(getInputStreamFromString(imageData1));
-        Bitmap bitmap2 = BitmapFactory.decodeStream(getInputStreamFromString(imageData2));
-
-        assertThat(ImageService.getBitmapFromDiskCache(url1)).isNull();
-        assertThat(ImageService.getBitmapFromDiskCache(url2)).isNull();
-        assertThat(ImageService.getBitmapFromMemoryCache(url1)).isNull();
-        assertThat(ImageService.getBitmapFromMemoryCache(url2)).isNull();
-
-        ImageService.putDataInCache(url1, bitmap1, imageData1.getBytes());
-        ImageService.putDataInCache(url2, bitmap2, imageData2.getBytes());
-
-        Thread.sleep(500); // disk cache put is async
-
-        assertThat(shadowOf(ImageService.getBitmapFromDiskCache(url1)).getDescription())
-                .isEqualTo("Bitmap for image_data_1");
-        assertThat(shadowOf(ImageService.getBitmapFromDiskCache(url2)).getDescription())
-                .isEqualTo("Bitmap for image_data_2");
-        assertThat(ImageService.getBitmapFromMemoryCache(url1)).isEqualTo(bitmap1);
-        assertThat(ImageService.getBitmapFromMemoryCache(url2)).isEqualTo(bitmap2);
-    }
-
-    @Test
-    public void getBitmapsFromMemoryCache_withEmptyCacheAndTwoUrls_returnsNoCacheHitsAndTwoCacheMisses() throws Exception {
-        CacheService.initialize(context);
-        assertThat(CacheService.getBitmapLruCache().size()).isEqualTo(0);
-
-        Map<String, Bitmap> cacheHits = new HashMap<String, Bitmap>(2);
-        List<String> cacheMisses =
-                ImageService.getBitmapsFromMemoryCache(Arrays.asList(url1, url2), cacheHits);
-
-        assertThat(cacheHits).isEmpty();
-        assertThat(cacheMisses).containsOnly(url1, url2);
-    }
-
-    @Test
-    public void getBitmapsFromMemoryCache_withOneCacheEntryAndTwoUrls_returnsOneCacheHitAndOneCacheMiss() throws Exception {
-        CacheService.initialize(context);
-
-        assertThat(CacheService.getBitmapLruCache().size()).isEqualTo(0);
-
-        CacheService.putToBitmapCache(url1, image1);
-
-        Map<String, Bitmap> cacheHits = new HashMap<String, Bitmap>(2);
-        List<String> cacheMisses =
-                ImageService.getBitmapsFromMemoryCache(Arrays.asList(url1, url2), cacheHits);
-
-        assertThat(cacheHits.keySet()).containsOnly(url1);
-        assertThat(cacheMisses).containsOnly(url2);
-    }
-
-    @Test
-    public void asBitmap_withMaxSize_shouldReturnBitmap() {
-
-        String imageData = "fake_bitmap_data";
-        when(downloadResponse.getByteArray()).thenReturn(imageData.getBytes());
-
-        final Bitmap bitmap = ImageService.asBitmap(downloadResponse, 30);
-
-        assertThat(bitmap).isNotNull();
-        assertThat(bitmap).isInstanceOf(Bitmap.class);
-    }
-
-    @Test
-    public void asBitmap_withNullResponse_shouldReturnNull() throws Exception {
-        final Bitmap bitmap = ImageService.asBitmap(null, 30);
-
-        assertThat(bitmap).isNull();
-    }
-
-    @Test
-    public void calculateInSampleSize_withImageSmallerThanRequested_shouldBe1() {
-        int nativeWidth = 1024;
-        assertThat(ImageService.calculateInSampleSize(nativeWidth, 2046)).isEqualTo(1);
-    }
-
-    @Test
-    public void calculateInSampleSize_withImageSlightlyBiggerThanRequest_shouldBe1() {
-        int nativeWidth = 1024;
-        assertThat(ImageService.calculateInSampleSize(nativeWidth, 800)).isEqualTo(1);
-
-    }
-
-    @Test
-    public void calculateInSampleSize_withImageMuchBiggerThanRequest_shouldBe4() {
-        int nativeWidth = 2048;
-        int nativeHeight = 1024;
-        assertThat(ImageService.calculateInSampleSize(nativeWidth, 512)).isEqualTo(4);
-    }
-
-    private static InputStream getInputStreamFromString(final String string) {
-        return spy(new ByteArrayInputStream(string.getBytes()));
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/ImageViewServiceTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/ImageViewServiceTest.java
deleted file mode 100644
index 54ea511d..00000000
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/ImageViewServiceTest.java
+++ /dev/null
@@ -1,202 +0,0 @@
-package com.mopub.nativeads;
-
-import android.app.Activity;
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.graphics.drawable.BitmapDrawable;
-import android.widget.ImageView;
-
-import com.mopub.common.CacheService;
-import com.mopub.common.CacheServiceTest;
-import com.mopub.nativeads.test.support.MoPubShadowBitmap;
-import com.mopub.nativeads.test.support.MoPubShadowDisplay;
-import com.mopub.common.test.support.SdkTestRunner;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.annotation.Config;
-import org.robolectric.tester.org.apache.http.FakeHttpLayer;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.robolectric.Robolectric.shadowOf;
-
-@RunWith(SdkTestRunner.class)
-@Config(shadows={MoPubShadowBitmap.class, MoPubShadowDisplay.class})
-public class ImageViewServiceTest {
-
-    private ImageView imageView;
-    private String url1;
-    private String url2;
-    private String imageData1;
-    private String imageData2;
-    private FakeHttpLayer fakeHttpLayer;
-    private Bitmap image1;
-
-    @Before
-    public void setUp() throws Exception {
-        Context context = new Activity();
-        imageView = new ImageView(context);
-        CacheService.initialize(context);
-        ImageService.initialize(context);
-        url1 = "http://www.mopub.com/";
-        url2 = "http://www.twitter.com/";
-        imageData1 = "image_data_1";
-        imageData2 = "image_data_2";
-        image1 = BitmapFactory.decodeByteArray(imageData1.getBytes(), 0, imageData1.getBytes().length);
-        fakeHttpLayer = Robolectric.getFakeHttpLayer();
-    }
-
-    @After
-    public void tearDown() throws Exception {
-        CacheService.clearAndNullCaches();
-    }
-
-    @Test
-    public void loadImageView_withImageInMemoryCache_shouldLoadImageData() throws Exception {
-        CacheServiceTest.assertCachesAreEmpty();
-        CacheService.putToBitmapCache(url1, image1);
-
-        assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNull();
-
-        ImageViewService.loadImageView(url1, imageView);
-
-        assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNotNull();
-        assertThat(shadowOf(getBitmapFromImageView(imageView)).getCreatedFromBytes())
-                .isEqualTo(imageData1.getBytes());
-    }
-
-    @Test
-    public void loadImageView_withImageInDiskCache_shouldLoadImageDataAsync() throws Exception {
-        CacheServiceTest.assertCachesAreEmpty();
-        CacheService.putToDiskCache(url1, imageData1.getBytes());
-        assertThat(CacheService.containsKeyDiskCache(url1)).isTrue();
-
-        assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNull();
-
-        ImageViewService.loadImageView(url1, imageView);
-        Thread.sleep(500);
-
-        assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNotNull();
-        assertThat(shadowOf(getBitmapFromImageView(imageView)).getDescription())
-                .isEqualTo("Bitmap for image_data_1");
-    }
-
-    @Test
-    public void loadImageView_withImageInNetwork_shouldLoadImageDataAsync() throws Exception {
-        CacheServiceTest.assertCachesAreEmpty();
-        fakeHttpLayer.addPendingHttpResponse(200, imageData1);
-
-        assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNull();
-        assertThat(imageView.getDrawable()).isNull();
-
-        ImageViewService.loadImageView(url1, imageView);
-        Thread.sleep(500);
-
-        assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNotNull();
-        assertThat(shadowOf(getBitmapFromImageView(imageView)).getDescription())
-                .isEqualTo("Bitmap for image_data_1");
-    }
-
-    @Test
-    public void loadImageView_withImageInNetworkAndUniqueIdChanges_shouldNotLoadImageData() throws Exception {
-        CacheServiceTest.assertCachesAreEmpty();
-        assertThat(imageView.getDrawable()).isNull();
-        fakeHttpLayer.addPendingHttpResponse(200, imageData1);
-
-        assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNull();
-
-        Robolectric.getBackgroundScheduler().pause();
-        ImageViewService.loadImageView(url1, imageView);
-
-        // Change unique id before running async task to simulate another image load
-        ImageViewService.setImageViewUniqueId(imageView, -1);
-
-        Robolectric.getBackgroundScheduler().runOneTask();
-        Robolectric.getBackgroundScheduler().unPause();
-        Thread.sleep(500);
-
-        assertThat(imageView.getDrawable()).isNull();
-    }
-
-    @Test
-    public void loadImageView_withImageInNetworkAndUniqueIdIsNull_shouldNotLoadImageData() throws Exception {
-        CacheServiceTest.assertCachesAreEmpty();
-        assertThat(imageView.getDrawable()).isNull();
-        fakeHttpLayer.addPendingHttpResponse(200, imageData1);
-
-        assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNull();
-
-        Robolectric.getBackgroundScheduler().pause();
-        ImageViewService.loadImageView(url1, imageView);
-
-        // Change unique id before running async task to simulate another image load
-        ImageViewService.setImageViewUniqueId(imageView, -1);
-
-        Robolectric.getBackgroundScheduler().runOneTask();
-        Robolectric.getBackgroundScheduler().unPause();
-        Thread.sleep(500);
-
-        assertThat(imageView.getDrawable()).isNull();
-    }
-
-    @Test
-    public void loadImageView_withTwoNetworkRequests_shouldLoadSecondImageData() throws Exception {
-        CacheServiceTest.assertCachesAreEmpty();
-        assertThat(imageView.getDrawable()).isNull();
-        fakeHttpLayer.addPendingHttpResponse(200, imageData1);
-        fakeHttpLayer.addPendingHttpResponse(200, imageData2);
-
-        assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNull();
-
-        Robolectric.getBackgroundScheduler().pause();
-        ImageViewService.loadImageView(url1, imageView);
-        ImageViewService.loadImageView(url2, imageView);
-
-        Robolectric.getBackgroundScheduler().runOneTask();
-        Robolectric.getBackgroundScheduler().runOneTask();
-        Robolectric.getBackgroundScheduler().unPause();
-        Thread.sleep(500);
-
-        assertThat(shadowOf(getBitmapFromImageView(imageView)).getDescription())
-                .isEqualTo("Bitmap for image_data_2");
-    }
-
-    @Test
-    public void loadImageView_shouldClearDrawable() throws Exception {
-        CacheServiceTest.assertCachesAreEmpty();
-        assertThat(imageView.getDrawable()).isNull();
-        fakeHttpLayer.addPendingHttpResponse(200, imageData1);
-        fakeHttpLayer.addPendingHttpResponse(200, imageData2);
-
-        assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNull();
-
-        ImageViewService.loadImageView(url1, imageView);
-        Thread.sleep(500);
-        assertThat(shadowOf(getBitmapFromImageView(imageView)).getDescription())
-                .isEqualTo("Bitmap for image_data_1");
-
-        Robolectric.getBackgroundScheduler().pause();
-        ImageViewService.loadImageView(url2, imageView);
-        assertThat(imageView.getDrawable()).isNull();
-    }
-
-    @Test
-    public void loadImageView_withEmptyCachesAndNetworkFailure_shouldNotLoadImageDataAsync() throws Exception {
-        CacheServiceTest.assertCachesAreEmpty();
-        fakeHttpLayer.addPendingHttpResponse(500, imageData1);
-
-        ImageViewService.loadImageView(url1, imageView);
-        Thread.sleep(500);
-
-        assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNotNull();
-        assertThat(imageView.getDrawable()).isNull();
-    }
-
-    static Bitmap getBitmapFromImageView(final ImageView imageView) {
-        return ((BitmapDrawable)imageView.getDrawable()).getBitmap();
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubAdAdapterTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubAdAdapterTest.java
index 880c3ba1..34fc4be5 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubAdAdapterTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubAdAdapterTest.java
@@ -1,116 +1,199 @@
 package com.mopub.nativeads;
 
+import android.app.Activity;
 import android.database.DataSetObserver;
 import android.view.View;
 import android.view.ViewGroup;
-import android.widget.BaseAdapter;
+import android.widget.AdapterView;
+import android.widget.AdapterView.OnItemClickListener;
+import android.widget.AdapterView.OnItemLongClickListener;
+import android.widget.AdapterView.OnItemSelectedListener;
+import android.widget.ArrayAdapter;
+import android.widget.ListView;
 
 import com.mopub.common.test.support.SdkTestRunner;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
 import org.mockito.Mock;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 
 import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.AdditionalMatchers.leq;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 @Config(manifest=Config.NONE)
 @RunWith(SdkTestRunner.class)
 public class MoPubAdAdapterTest {
+    private static final int AD_POSITION = 1;
 
     @Mock
-    public BaseAdapter mockOriginalAdapter;
+    private MoPubStreamAdPlacer mockStreamAdPlacer;
     @Mock
-    public MoPubStreamAdPlacer mockStreamAdPlacer;
+    private NativeAdData mockNativeAdData;
     @Mock
-    public Object mockItem;
+    private View mockAdView;
     @Mock
-    public NativeAdData mockAd;
+    private VisibilityTracker mockVisibilityTracker;
     @Mock
-    public View mockAdView;
+    private MoPubNativeAdLoadedListener mockAdLoadedListener;
     @Mock
-    public View mockItemView;
+    private DataSetObserver mockDataSetObserver;
     @Mock
-    public VisibilityTracker mockVisibilityTracker;
+    private RequestParameters mockRequestParameters;
     @Mock
-    public MoPubNativeAdLoadedListener mockAdLoadedListener;
+    private MoPubAdRenderer mockAdRenderer;
     @Mock
-    public DataSetObserver mockDataSetObserver;
+    private ListView mockListView;
+    @Mock
+    private OnItemClickListener mockOnItemClickListener;
+    @Mock
+    private OnItemLongClickListener mockOnItemLongClickListener;
+    @Mock
+    private OnItemSelectedListener mockOnItemSelectedListener;
+    @Mock
+    private View mockItemView;
 
-    public MoPubAdAdapter subject;
+    private long originalItemId = 0;
+    private boolean originalHasStableIds = false;
 
-    private static final int AD_POSITION = 4;
+    private int originalItemViewType = 0;
+    private int originalViewTypeCount = 1;
+    private boolean originalItemsAreEnabled = false;
+    private ArrayAdapter<String> originalAdapter;
+    private MoPubAdAdapter subject;
 
     @Before
     public void setup() {
+        // Set up original adapter with 2 items
+        Activity activity = Robolectric.buildActivity(Activity.class).create().get();
+        originalAdapter = new ArrayAdapter<String>(activity, android.R.layout.simple_list_item_1) {
+            @Override
+            public boolean isEnabled(final int position) {
+                return originalItemsAreEnabled;
+            }
 
-        // Mock setup code.
-        when(mockOriginalAdapter.getViewTypeCount()).thenReturn(1);
-        when(mockOriginalAdapter.getCount()).thenReturn(30);
-        when(mockOriginalAdapter.getItem(leq(29))).thenReturn(mockItem);
-        when(mockOriginalAdapter.getView(anyInt(), any(View.class), any(ViewGroup.class))).thenReturn(mockItemView);
+            @Override
+            public long getItemId(final int position) {
+                return originalItemId;
+            }
 
-        when(mockStreamAdPlacer.getAdData(AD_POSITION)).thenReturn(mockAd);
-        when(mockStreamAdPlacer.getAdView(eq(AD_POSITION), any(View.class), any(ViewGroup.class))).thenReturn(mockAdView);
+            @Override
+            public boolean hasStableIds() {
+                return originalHasStableIds;
+            }
 
-        // Mock some adjustment behavior for tests.
-        when(mockStreamAdPlacer.getOriginalPosition(eq(1))).thenReturn(1);
-        when(mockStreamAdPlacer.getOriginalPosition(eq(8))).thenReturn(7);
-        when(mockStreamAdPlacer.getAdjustedCount(eq(30))).thenReturn(31);
+            @Override
+            public int getItemViewType(final int position) {
+                return originalItemViewType;
+            }
 
-        subject = new MoPubAdAdapter(mockStreamAdPlacer, mockOriginalAdapter, mockVisibilityTracker);
-    }
+            @Override
+            public int getViewTypeCount() {
+                return originalViewTypeCount;
+            }
+        };
+        originalAdapter.add("ITEM 1");
+        originalAdapter.add("ITEM 2");
 
-    @Test
-    public void getItem_shouldCallAdPlacer() throws Exception {
-        assertThat(subject.getItem(AD_POSITION)).isEqualTo(mockAd);
-        verify(mockStreamAdPlacer, never()).getOriginalPosition(AD_POSITION);
-        verify(mockStreamAdPlacer).getAdData(AD_POSITION);
+        subject = new MoPubAdAdapter(mockStreamAdPlacer, originalAdapter, mockVisibilityTracker);
+
+        // Reset because the constructor interacts with the stream ad placer, and we don't want
+        // to worry about verifying those changes in tests.
+        reset(mockStreamAdPlacer);
+
+        // Mock some simple adjustment behavior for tests. This is creating an ad placer that
+        // emulates a content item followed by an ad item, then another content item.
+        when(mockStreamAdPlacer.getAdData(AD_POSITION)).thenReturn(mockNativeAdData);
+        when(mockStreamAdPlacer.getAdView(eq(AD_POSITION), any(View.class), any(ViewGroup.class))).thenReturn(mockAdView);
+        when(mockStreamAdPlacer.isAd(anyInt())).thenAnswer(new Answer<Boolean>() {
+            @Override
+            public Boolean answer(final InvocationOnMock invocation) throws Throwable {
+                int position = (Integer)invocation.getArguments()[0];
+                return position == AD_POSITION;
+            }
+        });
+        when(mockStreamAdPlacer.getOriginalPosition(anyInt())).thenAnswer(new Answer<Integer>() {
+            @Override
+            public Integer answer(final InvocationOnMock invocation) throws Throwable {
+                int originalPosition = (Integer)invocation.getArguments()[0];
+                return originalPosition < AD_POSITION ? originalPosition : originalPosition - 1;
+            }
+        });
+        when(mockStreamAdPlacer.getAdViewType(anyInt())).thenAnswer(new Answer<Integer>() {
+            @Override
+            public Integer answer(final InvocationOnMock invocation) throws Throwable {
+                int originalPosition = (Integer)invocation.getArguments()[0];
+                return originalPosition == AD_POSITION ? 1 : MoPubStreamAdPlacer.CONTENT_VIEW_TYPE;
+            }
+        });
+        when(mockStreamAdPlacer.getAdjustedPosition(anyInt())).thenAnswer(new Answer<Integer>() {
+            @Override
+            public Integer answer(final InvocationOnMock invocation) throws Throwable {
+                int originalPosition = (Integer)invocation.getArguments()[0];
+                return originalPosition < AD_POSITION ? originalPosition : originalPosition + 1;
+            }
+        });
+        when(mockStreamAdPlacer.getAdjustedCount(anyInt())).thenAnswer(new Answer<Integer>() {
+            @Override
+            public Integer answer(final InvocationOnMock invocation) throws Throwable {
+                int originalCount = (Integer)invocation.getArguments()[0];
+                return originalCount < AD_POSITION ? originalCount : originalCount + 1;
+            }
+        });
     }
 
     @Test
-    public void getItem_shouldCallOriginalAdapter() throws Exception {
-        assertThat(subject.getItem(1)).isEqualTo(mockItem);
-        verify(mockStreamAdPlacer).getOriginalPosition(1);
-        verify(mockOriginalAdapter).getItem(1);
+    public void originalAdapterChange_shouldNotifyDataSetChanged() {
+        subject.registerDataSetObserver(mockDataSetObserver);
 
-        assertThat(subject.getItem(8)).isEqualTo(mockItem);
-        verify(mockStreamAdPlacer).getOriginalPosition(8);
-        verify(mockOriginalAdapter).getItem(7);
+        originalAdapter.notifyDataSetChanged();
+
+        verify(mockDataSetObserver).onChanged();
     }
 
     @Test
-    public void getCount_shouldCallAdPlacer() throws Exception {
-        assertThat(subject.getCount()).isEqualTo(31);
-        verify(mockStreamAdPlacer).getAdjustedCount(30);
+    public void originalAdapterInvalidated_shouldNotifyDataSetInvalidated() {
+        subject.registerDataSetObserver(mockDataSetObserver);
+
+        originalAdapter.notifyDataSetInvalidated();
+
+        verify(mockDataSetObserver).onInvalidated();
     }
 
     @Test
-    public void getItemIdForAd_shouldBeNegative() throws Exception {
-        assertThat(subject.getItemId(AD_POSITION)).isLessThan(0);
+    public void registerAdRenderer_shouldCallRegisterAdRendererOnAdPlacer() {
+        subject.registerAdRenderer(mockAdRenderer);
+
+        verify(mockStreamAdPlacer).registerAdRenderer(mockAdRenderer);
     }
-    
+
     @Test
-    public void destroy_shouldDestroyStreamAdPlacer_shouldDestroyVisibilityTracker() {
-        subject.destroy();
-        verify(mockStreamAdPlacer).destroy();
-        verify(mockVisibilityTracker).destroy();
+    public void registerAdRenderer_withNull_shouldNotCallAdPlacer() {
+        subject.registerAdRenderer(null);
+
+        verify(mockStreamAdPlacer, never()).registerAdRenderer(any(MoPubAdRenderer.class));
     }
 
+
     @Test
     public void setAdLoadedListener_handleAdLoaded_shouldCallCallback_shouldCallObserver() {
         subject.setAdLoadedListener(mockAdLoadedListener);
         subject.registerDataSetObserver(mockDataSetObserver);
 
         subject.handleAdLoaded(8);
+
         verify(mockAdLoadedListener).onAdLoaded(8);
         verify(mockDataSetObserver).onChanged();
     }
@@ -121,25 +204,325 @@ public void setAdLoadedListener_handleAdRemoved_shouldCallCallback_shouldCallObs
         subject.registerDataSetObserver(mockDataSetObserver);
 
         subject.handleAdRemoved(10);
+
         verify(mockAdLoadedListener).onAdRemoved(10);
         verify(mockDataSetObserver).onChanged();
     }
 
     @Test
-    public void insertItem_shouldCallInsertItemOnStreamAdPlacer() throws Exception {
+    public void loadAds_shouldCallLoadAdsOnAdPlacer() {
+        subject.loadAds("AD_UNIT_ID");
+
+        verify(mockStreamAdPlacer).loadAds("AD_UNIT_ID");
+
+        subject.loadAds("AD_UNIT_ID", mockRequestParameters);
+
+        verify(mockStreamAdPlacer).loadAds("AD_UNIT_ID", mockRequestParameters);
+    }
+
+    @Test
+    public void isAd_shouldCallIsAdOnAdPlacer() {
+        boolean isAd = subject.isAd(AD_POSITION);
+
+        assertThat(isAd).isTrue();
+
+        isAd = subject.isAd(AD_POSITION + 1);
+
+        assertThat(isAd).isFalse();
+
+        verify(mockStreamAdPlacer, times(2)).isAd(anyInt());
+    }
+
+    @Test
+    public void clearAds_shouldCallClearAdsOnAdPlacer() {
+        subject.clearAds();
+
+        verify(mockStreamAdPlacer).clearAds();
+    }
+
+    @Test
+    public void destroy_shouldDestroyStreamAdPlacer_shouldDestroyVisibilityTracker() {
+        subject.destroy();
+
+        verify(mockStreamAdPlacer).destroy();
+        verify(mockVisibilityTracker).destroy();
+    }
+
+    @Test
+    public void isEnabled_adPosition_shouldReturnTrue() {
+        boolean isEnabled = subject.isEnabled(AD_POSITION);
+
+        assertThat(isEnabled).isTrue();
+    }
+
+    @Test
+    public void isEnabled_withNonAdPosition_shouldUseOriginalAdapter() {
+        originalItemsAreEnabled = false;
+        boolean isEnabled = subject.isEnabled(AD_POSITION + 1);
+
+        assertThat(isEnabled).isFalse();
+
+        originalItemsAreEnabled = true;
+        isEnabled = subject.isEnabled(AD_POSITION + 1);
+
+        assertThat(isEnabled).isTrue();
+    }
+
+    @Test
+    public void getItem_withAdPosition_shouldReturnAd_shouldGetAdDataOnCallAdPlacer() {
+        Object actualItem = subject.getItem(AD_POSITION);
+
+        assertThat(actualItem).isEqualTo(mockNativeAdData);
+
+        verify(mockStreamAdPlacer).getAdData(AD_POSITION);
+    }
+
+    @Test
+    public void getItem_withNonAdPosition_shouldCallGetOriginalPositionOnAdPlacer() {
+        Object actualItem = subject.getItem(AD_POSITION + 1);
+
+        assertThat(actualItem).isNotEqualTo(mockNativeAdData);
+
+        verify(mockStreamAdPlacer).getOriginalPosition(AD_POSITION + 1);
+    }
+
+    @Test
+    public void getCount_shouldCallGetAdjustedCountOnAdPlacer() {
+        int actualCount = subject.getCount();
+
+        assertThat(actualCount).isEqualTo(3);
+
+        verify(mockStreamAdPlacer).getAdjustedCount(anyInt());
+    }
+
+    @Test
+    public void getItemId_withAdPosition_shouldBeNegative() {
+        long itemId = subject.getItemId(AD_POSITION);
+
+        assertThat(itemId).isLessThan(0);
+    }
+
+    @Test
+    public void getItemId_withNonAdPosition_shouldUseOriginalAdapterId() {
+        originalItemId = 42;
+        long itemId = subject.getItemId(AD_POSITION + 1);
+
+        assertThat(itemId).isEqualTo(42);
+    }
+
+    @Test
+    public void hasStableIds_shouldUseOriginalAdapterValue() {
+        originalHasStableIds = false;
+        boolean hasStableIds = subject.hasStableIds();
+
+        assertThat(hasStableIds).isFalse();
+
+        originalHasStableIds = true;
+        hasStableIds = subject.hasStableIds();
+
+        assertThat(hasStableIds).isTrue();
+    }
+
+    @Test
+    public void getView_withAdPosition_shouldReturnAdView_shouldTrackVisibility() {
+        View view = subject.getView(AD_POSITION, null, null);
+
+        assertThat(view).isEqualTo(mockAdView);
+
+        verify(mockVisibilityTracker).addView(eq(mockAdView), anyInt());
+    }
+
+    @Test
+    public void getView_withNonAdPosition_shouldOriginalAdapterView_shouldTrackVisibility() {
+        View view = subject.getView(AD_POSITION + 1, null, null);
+
+        assertThat(view).isNotEqualTo(mockAdView);
+
+        verify(mockVisibilityTracker).addView(any(View.class), anyInt());
+    }
+
+    @Test
+    public void getItemViewType_withAdPosition_shouldReturnOneGreaterThanViewType() {
+        originalItemViewType = 0;
+
+        int itemViewType = subject.getItemViewType(AD_POSITION);
+        assertThat(itemViewType).isEqualTo(originalItemViewType + 1);
+    }
+
+    @Test
+    public void getItemViewType_withNonAdPosition_shouldUseOriginalAdapterId() {
+        originalItemViewType = 0;
+
+        int itemViewType = subject.getItemViewType(AD_POSITION + 1);
+        assertThat(itemViewType).isEqualTo(originalItemViewType);
+    }
+
+    @Test
+    public void getViewTypeCount_shouldReturnOriginalViewTypeCountPlusOne() {
+        originalViewTypeCount = 1;
+
+        int viewTypeCount = subject.getViewTypeCount();
+        assertThat(viewTypeCount).isEqualTo(1);
+
+        originalViewTypeCount = 2;
+
+        viewTypeCount = subject.getViewTypeCount();
+        assertThat(viewTypeCount).isEqualTo(2);
+    }
+
+    @Test
+    public void isEmpty_shouldUseOriginalAdapterValue() {
+        boolean isEmpty = subject.isEmpty();
+
+        assertThat(isEmpty).isFalse();
+
+        originalAdapter.clear();
+
+        isEmpty = subject.isEmpty();
+
+        assertThat(isEmpty).isTrue();
+    }
+
+    @Test
+    public void getOriginalPosition_shouldCallStreamAdPlacer() {
+        subject.getOriginalPosition(5);
+
+        verify(mockStreamAdPlacer).getOriginalPosition(5);
+    }
+
+    @Test
+    public void getAdjustedPosition_shouldCallStreamAdPlacer() {
+        subject.getAdjustedPosition(5);
+
+        verify(mockStreamAdPlacer).getAdjustedPosition(5);
+    }
+
+    @Test
+    public void insertItem_shouldCallInsertItemOnStreamAdPlacer() {
         subject.insertItem(5);
+
         verify(mockStreamAdPlacer).insertItem(5);
     }
 
     @Test
-    public void removeItem_shouldCallRemoveItemOnStreamAdPlacer() throws Exception {
+    public void removeItem_shouldCallRemoveItemOnStreamAdPlacer() {
         subject.removeItem(5);
+
         verify(mockStreamAdPlacer).removeItem(5);
     }
 
     @Test
-    public void getOriginalPosition_shouldCallGetOriginalPositionOnStreamAdPlacer() throws Exception {
-        subject.getOriginalPosition(5);
-        verify(mockStreamAdPlacer).getOriginalPosition(5);
+    public void setOnItemClickListener_withAdPosition_shouldNotCallListener() {
+        subject.setOnClickListener(mockListView, mockOnItemClickListener);
+
+        ArgumentCaptor<OnItemClickListener> listenerCaptor =
+                ArgumentCaptor.forClass(OnItemClickListener.class);
+        verify(mockListView).setOnItemClickListener(listenerCaptor.capture());
+
+        OnItemClickListener listener = listenerCaptor.getValue();
+        listener.onItemClick(mockListView, mockItemView, AD_POSITION, 0);
+
+        verify(mockOnItemClickListener, never()).onItemClick(
+                any(AdapterView.class), any(View.class), anyInt(), anyInt());
+    }
+
+    @Test
+    public void setOnItemClickListener_withNonAdPosition_shouldCallListener() {
+        subject.setOnClickListener(mockListView, mockOnItemClickListener);
+
+        ArgumentCaptor<OnItemClickListener> listenerCaptor =
+                ArgumentCaptor.forClass(OnItemClickListener.class);
+        verify(mockListView).setOnItemClickListener(listenerCaptor.capture());
+
+        OnItemClickListener listener = listenerCaptor.getValue();
+        listener.onItemClick(mockListView, mockItemView, AD_POSITION + 1, 0);
+
+        verify(mockOnItemClickListener).onItemClick(
+                mockListView, mockItemView, AD_POSITION, 0);
+    }
+
+    @Test
+    public void setOnItemLongClickListener_withAdPosition_shouldNotCallListener() {
+        subject.setOnItemLongClickListener(mockListView, mockOnItemLongClickListener);
+
+        ArgumentCaptor<OnItemLongClickListener> listenerCaptor =
+                ArgumentCaptor.forClass(OnItemLongClickListener.class);
+        verify(mockListView).setOnItemLongClickListener(listenerCaptor.capture());
+
+        OnItemLongClickListener listener = listenerCaptor.getValue();
+        listener.onItemLongClick(mockListView, mockItemView, AD_POSITION, 0);
+
+        verify(mockOnItemLongClickListener, never()).onItemLongClick(
+                any(AdapterView.class), any(View.class), anyInt(), anyInt());
+    }
+
+    @Test
+    public void setOnItemLongClickListener_withNonAdPosition_shouldCallListener() {
+        subject.setOnItemLongClickListener(mockListView, mockOnItemLongClickListener);
+
+        ArgumentCaptor<OnItemLongClickListener> listenerCaptor =
+                ArgumentCaptor.forClass(OnItemLongClickListener.class);
+        verify(mockListView).setOnItemLongClickListener(listenerCaptor.capture());
+
+        OnItemLongClickListener listener = listenerCaptor.getValue();
+        listener.onItemLongClick(mockListView, mockItemView, AD_POSITION + 1, 0);
+
+        verify(mockOnItemLongClickListener).onItemLongClick(
+                mockListView, mockItemView, AD_POSITION, 0);
+    }
+
+    @Test
+    public void setOnItemSelectedListener_withAdPosition_shouldNotCallListener() {
+        subject.setOnItemSelectedListener(mockListView, mockOnItemSelectedListener);
+
+        ArgumentCaptor<OnItemSelectedListener> listenerCaptor =
+                ArgumentCaptor.forClass(OnItemSelectedListener.class);
+        verify(mockListView).setOnItemSelectedListener(listenerCaptor.capture());
+
+        OnItemSelectedListener listener = listenerCaptor.getValue();
+        listener.onItemSelected(mockListView, mockItemView, AD_POSITION, 0);
+
+        verify(mockOnItemSelectedListener, never()).onItemSelected(
+                any(AdapterView.class), any(View.class), anyInt(), anyInt());
+    }
+
+    @Test
+    public void setOnItemSelectedListener_withNonAdPosition_shouldCallListener() {
+        subject.setOnItemSelectedListener(mockListView, mockOnItemSelectedListener);
+
+        ArgumentCaptor<OnItemSelectedListener> listenerCaptor =
+                ArgumentCaptor.forClass(OnItemSelectedListener.class);
+        verify(mockListView).setOnItemSelectedListener(listenerCaptor.capture());
+
+        OnItemSelectedListener listener = listenerCaptor.getValue();
+        listener.onItemSelected(mockListView, mockItemView, AD_POSITION + 1, 0);
+
+        verify(mockOnItemSelectedListener).onItemSelected(
+                mockListView, mockItemView, AD_POSITION, 0);
+    }
+
+    @Test
+    public void setSelection_shouldCallSetSelectionOnListView() {
+        subject.setSelection(mockListView, AD_POSITION);
+
+        // Since the original position is the ad position, the adjusted position is 1 higher
+        verify(mockListView).setSelection(AD_POSITION + 1);
+    }
+
+    @Test
+    public void smoothScrollToPosition_shouldCallSmooethScrollToPositionOnListView() {
+        subject.smoothScrollToPosition(mockListView, AD_POSITION);
+
+        // Since the original position is the ad position, the adjusted position is 1 higher
+        verify(mockListView).smoothScrollToPosition(AD_POSITION + 1);
+    }
+
+    @Test
+    public void refreshAds_shouldLoadAdsOnAdPlacer() {
+        when(mockListView.getAdapter()).thenReturn(subject);
+
+        subject.refreshAds(mockListView, "AD_UNIT_ID", mockRequestParameters);
+
+        verify(mockStreamAdPlacer).loadAds("AD_UNIT_ID", mockRequestParameters);
     }
-}
\ No newline at end of file
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubCustomEventNativeTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubCustomEventNativeTest.java
index 9f67e204..361e8fce 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubCustomEventNativeTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubCustomEventNativeTest.java
@@ -2,6 +2,7 @@
 
 import android.app.Activity;
 
+import com.mopub.common.DataKeys;
 import com.mopub.common.test.support.SdkTestRunner;
 
 import org.json.JSONArray;
@@ -45,7 +46,7 @@ public void setUp() throws Exception {
         fakeJsonObject.put("iconimage", "iconimageurl");
         fakeJsonObject.put("extraimage", "extraimageurl");
 
-        serverExtras.put(CustomEventNativeAdapter.RESPONSE_BODY_KEY, fakeJsonObject.toString());
+        localExtras.put(DataKeys.JSON_BODY_KEY, fakeJsonObject);
 
         mCustomEventNativeListener = mock(CustomEventNativeListener.class);
     }
@@ -55,21 +56,12 @@ public void tearDown() throws Exception {
         reset(mCustomEventNativeListener);
     }
 
-    @Test
-    public void loadNativeAd_withInvalidResponseBody_shouldNotifyListenerOfOnNativeAdFailed() throws Exception {
-        serverExtras.put(CustomEventNativeAdapter.RESPONSE_BODY_KEY, "{ \"bad json");
-
-        subject.loadNativeAd(context, mCustomEventNativeListener, localExtras, serverExtras);
-        verify(mCustomEventNativeListener, never()).onNativeAdLoaded(any(MoPubCustomEventNative.MoPubForwardingNativeAd.class));
-        verify(mCustomEventNativeListener).onNativeAdFailed(NativeErrorCode.INVALID_JSON);
-    }
-
     @Test
     public void loadNativeAd_withNullResponseBody_shouldNotifyListenerOfOnNativeAdFailed() throws Exception {
-        serverExtras.put(CustomEventNativeAdapter.RESPONSE_BODY_KEY, null);
+        localExtras.remove(DataKeys.JSON_BODY_KEY);
 
         subject.loadNativeAd(context, mCustomEventNativeListener, localExtras, serverExtras);
         verify(mCustomEventNativeListener, never()).onNativeAdLoaded(any(MoPubCustomEventNative.MoPubForwardingNativeAd.class));
-        verify(mCustomEventNativeListener).onNativeAdFailed(NativeErrorCode.UNSPECIFIED);
+        verify(mCustomEventNativeListener).onNativeAdFailed(NativeErrorCode.INVALID_JSON);
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubForwardingNativeAdTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubForwardingNativeAdTest.java
index 7ae673b8..668842d0 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubForwardingNativeAdTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubForwardingNativeAdTest.java
@@ -1,24 +1,26 @@
 package com.mopub.nativeads;
 
 import android.app.Activity;
+import android.graphics.Bitmap;
 
 import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.test.support.CommonUtils;
 import com.mopub.nativeads.test.support.MoPubShadowBitmap;
 import com.mopub.nativeads.test.support.MoPubShadowDisplay;
+import com.mopub.network.MaxWidthImageLoader;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.volley.VolleyError;
+import com.mopub.volley.toolbox.ImageLoader;
 
-import org.apache.http.HttpRequest;
 import org.json.JSONArray;
 import org.json.JSONObject;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
+import org.mockito.Mock;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
 import org.robolectric.annotation.Config;
-import org.robolectric.tester.org.apache.http.FakeHttpLayer;
-import org.robolectric.tester.org.apache.http.RequestMatcher;
-import org.robolectric.tester.org.apache.http.TestHttpResponse;
 
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -28,12 +30,17 @@
 
 import static com.mopub.nativeads.NativeResponse.Parameter;
 import static com.mopub.nativeads.NativeResponse.Parameter.requiredKeys;
+import static com.mopub.volley.toolbox.ImageLoader.ImageListener;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.fest.assertions.api.Assertions.fail;
 import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.stub;
 import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
 @Config(shadows={MoPubShadowBitmap.class, MoPubShadowDisplay.class})
@@ -42,27 +49,25 @@
     private JSONObject fakeJsonObject;
     private MoPubCustomEventNative.MoPubForwardingNativeAd subject;
     private Activity context;
+
+    @Mock
     private CustomEventNative.CustomEventNativeListener mockCustomEventNativeListener;
-    private FakeHttpLayer fakeHttpLayer;
+    @Mock
+    private MoPubRequestQueue mockRequestQueue;
+    @Mock
+    private MaxWidthImageLoader mockImageLoader;
+    @Mock
+    private ImageLoader.ImageContainer mockImageContainer;
 
     @Before
     public void setUp() throws Exception {
         context = new Activity();
-        mockCustomEventNativeListener = mock(CustomEventNative.CustomEventNativeListener.class);
         fakeJsonObject = new JSONObject();
         fakeJsonObject.put("imptracker", new JSONArray("[\"url1\", \"url2\"]"));
         fakeJsonObject.put("clktracker", "expected clicktracker");
-
-        fakeHttpLayer = Robolectric.getFakeHttpLayer();
-        fakeHttpLayer.addHttpResponseRule(
-                new RequestMatcher() {
-                    @Override
-                    public boolean matches(HttpRequest request) {
-                        return true;
-                    }
-                },
-                new TestHttpResponse(200, "body")
-        );
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+        Networking.setImageLoaderForTesting(mockImageLoader);
+        stub(mockImageContainer.getBitmap()).toReturn(mock(Bitmap.class));
     }
 
     @Test
@@ -93,7 +98,7 @@ public void loadAd_whenMissingRequiredKeys_shouldThrowIllegalArgumentException()
         fakeJsonObject.remove("imptracker");
 
         try {
-            subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject.toString(), mockCustomEventNativeListener);
+            subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
             subject.loadAd();
             fail("Expected IllegalArgumentException");
         } catch (IllegalArgumentException e) {
@@ -106,7 +111,7 @@ public void loadAd_whenRequiredKeyOfWrongType_shouldThrowIllegalArgumentExceptio
         fakeJsonObject.put("imptracker", 12345);
 
         try {
-            subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject.toString(), mockCustomEventNativeListener);
+            subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
             subject.loadAd();
             fail("Expected IllegalArgumentException");
         } catch (IllegalArgumentException e) {
@@ -116,7 +121,7 @@ public void loadAd_whenRequiredKeyOfWrongType_shouldThrowIllegalArgumentExceptio
 
     @Test
     public void loadAd_shouldSetRequiredExpectedFields() throws Exception {
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject.toString(), mockCustomEventNativeListener);
+        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
         subject.loadAd();
         assertThat(subject.getImpressionTrackers()).containsOnly("url1", "url2");
     }
@@ -134,7 +139,7 @@ public void loadAd_shouldSetOptionalExpectedFields() throws Exception {
         fakeJsonObject.put("ctatext", "expected ctatext");
         fakeJsonObject.put("starrating", 5.0);
 
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject.toString(), mockCustomEventNativeListener);
+        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
         subject.loadAd();
 
         assertThat(subject.getTitle()).isEqualTo("expected title");
@@ -154,7 +159,7 @@ public void loadAd_shouldSetOptionalExpectedFields() throws Exception {
     public void loadAd_withIntegerStarRating_shouldSetStarRating() throws Exception {
         fakeJsonObject.put("starrating", 3);
 
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject.toString(), mockCustomEventNativeListener);
+        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
         subject.loadAd();
 
         assertThat(subject.getStarRating()).isEqualTo(3.0);
@@ -164,7 +169,7 @@ public void loadAd_withIntegerStarRating_shouldSetStarRating() throws Exception
     public void loadAd_withStringStarRating_shouldSetStarRating() throws Exception {
         fakeJsonObject.put("starrating", "2.3");
 
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject.toString(), mockCustomEventNativeListener);
+        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
         subject.loadAd();
 
         assertThat(subject.getStarRating()).isEqualTo(2.3);
@@ -174,7 +179,7 @@ public void loadAd_withStringStarRating_shouldSetStarRating() throws Exception {
     public void loadAd_withInvalidStringStarRating_shouldNotSetStarRating() throws Exception {
         fakeJsonObject.put("starrating", "this is not a number");
 
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject.toString(), mockCustomEventNativeListener);
+        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
         subject.loadAd();
 
         assertThat(subject.getStarRating()).isNull();
@@ -184,7 +189,7 @@ public void loadAd_withInvalidStringStarRating_shouldNotSetStarRating() throws E
     public void loadAd_withInvalidlyTypedStarRating_shouldNotSetStarRating() throws Exception {
         fakeJsonObject.put("starrating", new Activity());
 
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject.toString(), mockCustomEventNativeListener);
+        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
         subject.loadAd();
 
         assertThat(subject.getStarRating()).isNull();
@@ -202,7 +207,7 @@ public void loadAd_whenImpressionTrackersContainsNonStrings_willCoerceToString()
         impressionTrackers.put(2.12);
         fakeJsonObject.put("imptracker", impressionTrackers);
 
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject.toString(), mockCustomEventNativeListener);
+        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
         subject.loadAd();
 
         assertThat(subject.getImpressionTrackers()).containsOnly("url1", "null", "2.12");
@@ -223,7 +228,7 @@ public void loadAd_shouldSetExtraFields() throws Exception {
         fakeJsonObject.put("key3", new JSONArray(array));
         fakeJsonObject.put("key4", new JSONObject(map));
 
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject.toString(), mockCustomEventNativeListener);
+        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
         subject.loadAd();
 
         assertThat(subject.getExtra("key1")).isEqualTo("yay json");
@@ -238,10 +243,22 @@ public void loadAd_shouldDownloadImages_shouldNotifyListenerOfOnNativeAdLoaded()
         fakeJsonObject.put("iconimage", "iconimageurl");
         fakeJsonObject.put("extraimage", "extraimageurl");
 
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject.toString(), mockCustomEventNativeListener);
+        when(mockImageLoader.get(anyString(), any(ImageListener.class)))
+                .then(new Answer<Void>() {
+                    @Override
+                    public Void answer(final InvocationOnMock invocationOnMock) throws Throwable {
+                        ImageListener listener = ((ImageListener) invocationOnMock.getArguments()[1]);
+                        listener.onResponse(mockImageContainer, false);
+                        return null;
+                    }
+                });
+
+        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
         subject.loadAd();
 
-        CommonUtils.assertHttpRequestsMade(null, "mainimageurl", "iconimageurl", "extraimageurl");
+        verify(mockImageLoader).get(eq("mainimageurl"), any(ImageListener.class));
+        verify(mockImageLoader).get(eq("iconimageurl"), any(ImageListener.class));
+        verify(mockImageLoader).get(eq("extraimageurl"), any(ImageListener.class));
 
         verify(mockCustomEventNativeListener).onNativeAdLoaded(subject);
         verify(mockCustomEventNativeListener, never()).onNativeAdFailed(any(NativeErrorCode.class));
@@ -253,23 +270,23 @@ public void loadAd_withFailedImageDownload_shouldNotDownloadImages_shouldNotifyL
         fakeJsonObject.put("iconimage", "iconimageurl");
         fakeJsonObject.put("extraimage", "extraimageurl");
 
-        fakeHttpLayer.clearHttpResponseRules();
-        fakeHttpLayer.addPendingHttpResponse(500, "body");
+        when(mockImageLoader.get(anyString(), any(ImageListener.class)))
+                .then(new Answer<Void>() {
+                    @Override
+                    public Void answer(final InvocationOnMock invocationOnMock) throws Throwable {
+                        ImageListener listener = ((ImageListener) invocationOnMock.getArguments()[1]);
+                        listener.onErrorResponse(new VolleyError());
+                        return null;
+                    }
+                });
 
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject.toString(), mockCustomEventNativeListener);
+        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
         subject.loadAd();
 
         verify(mockCustomEventNativeListener, never()).onNativeAdLoaded(subject);
         verify(mockCustomEventNativeListener).onNativeAdFailed(NativeErrorCode.IMAGE_DOWNLOAD_FAILURE);
     }
 
-    @Ignore("pending")
-    @Test
-    public void loadMainAndIconImages_shouldAsyncLoadImages() throws Exception {
-        // no easy way to test this since nothing can be mocked
-        // also not a critical test since it directly calls another service
-    }
-
     @Test
     public void getExtrasImageUrls_whenExtrasContainsImages_shouldReturnImageUrls() throws Exception {
         // getExtrasImageUrls requires the key to end with a case-insensitive "image" to be counted as an image
@@ -278,7 +295,7 @@ public void getExtrasImageUrls_whenExtrasContainsImages_shouldReturnImageUrls()
         fakeJsonObject.put("otherIMAGE", "image_url_2");
         fakeJsonObject.put("more filler", "ignored");
         fakeJsonObject.put("lastimage", "image_url_3");
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject.toString(), mockCustomEventNativeListener);
+        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
         subject.loadAd();
 
         assertThat(subject.getExtrasImageUrls()).containsOnly("image_url_1", "image_url_2", "image_url_3");
@@ -291,7 +308,7 @@ public void getExtrasImageUrls_whenExtrasDoesNotContainImageKeys_shouldReturnEmp
         fakeJsonObject.put("imageAtFront", "ignored");
         fakeJsonObject.put("middle_image_in_key", "ignored");
         fakeJsonObject.put("other", "ignored");
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject.toString(), mockCustomEventNativeListener);
+        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
         subject.loadAd();
 
         assertThat(subject.getExtrasImageUrls()).isEmpty();
@@ -302,7 +319,7 @@ public void getAllImageUrls_withExtraImagesAndMainAndIconImages_shouldReturnAllU
         fakeJsonObject.put("mainimage", "mainImageUrl");
         fakeJsonObject.put("iconimage", "iconImageUrl");
         fakeJsonObject.put("extraimage", "extraImageUrl");
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject.toString(), mockCustomEventNativeListener);
+        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
         subject.loadAd();
 
         assertThat(subject.getAllImageUrls()).containsOnly(
@@ -316,7 +333,7 @@ public void getAllImageUrls_withExtraImagesAndMainAndIconImages_shouldReturnAllU
     public void getAllImageUrls_withOnlyExtrasImages_shouldNotIncludeMainOrIconImages() throws Exception {
         fakeJsonObject.put("extra1_image", "expected extra1_image");
         fakeJsonObject.put("extra2_image", "expected extra2_image");
-        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject.toString(), mockCustomEventNativeListener);
+        subject = new MoPubCustomEventNative.MoPubForwardingNativeAd(context, fakeJsonObject, mockCustomEventNativeListener);
         subject.loadAd();
 
         assertThat(subject.getAllImageUrls()).containsOnly("expected extra1_image", "expected extra2_image");
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeAdRendererTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeAdRendererTest.java
index 0bcebf6d..ff855e7e 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeAdRendererTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeAdRendererTest.java
@@ -8,11 +8,8 @@
 import android.widget.RelativeLayout;
 import android.widget.TextView;
 
-import com.mopub.common.DownloadResponse;
 import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.ResponseHeader;
 import com.mopub.common.util.Utils;
-import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
 
 import org.junit.Before;
 import org.junit.Rule;
@@ -20,7 +17,6 @@
 import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 
-import static com.mopub.nativeads.MoPubNative.MoPubNativeListener;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
 
@@ -53,10 +49,11 @@ public void setUp() throws Exception {
         mNativeAd.setCallToAction("test call to action");
         mNativeAd.setClickDestinationUrl("destinationUrl");
 
-        final TestHttpResponseWithHeaders testHttpResponseWithHeaders = new TestHttpResponseWithHeaders(200, "");
-        testHttpResponseWithHeaders.addHeader(ResponseHeader.CLICKTHROUGH_URL.getKey(), "clickTrackerUrl");
-        final DownloadResponse downloadResponse = new DownloadResponse(testHttpResponseWithHeaders);
-        nativeResponse = new NativeResponse(context, downloadResponse, "test ID", mNativeAd, mock(MoPubNativeListener.class));
+        nativeResponse = new NativeResponse(context,
+                "impressionTrackerUrl",
+                "clickTrackerUrl",
+                "test ID", mNativeAd,
+                mock(MoPubNative.MoPubNativeListener.class));
 
         titleView = new TextView(context);
         titleView.setId((int) Utils.generateUniqueId());
@@ -124,8 +121,7 @@ public void renderAdView_shouldReturnPopulatedView() {
         // not testing images due to testing complexity
     }
 
-    @Test
-    public void renderAdView_withFailedViewBinder_shouldReturnFast() {
+    public void renderAdView_withFailedViewBinder_shouldReturnEmptyViews() {
         viewBinder = new ViewBinder.Builder(relativeLayout.getId())
                 .titleId(titleView.getId())
                 .textId(badView.getId())
@@ -137,30 +133,31 @@ public void renderAdView_withFailedViewBinder_shouldReturnFast() {
         subject = new MoPubNativeAdRenderer(viewBinder);
         subject.renderAdView(relativeLayout, nativeResponse);
 
-        assertThat(((TextView)relativeLayout.findViewById(titleView.getId())).getText()).isEqualTo("");
-        assertThat(((TextView)relativeLayout.findViewById(textView.getId())).getText()).isEqualTo(
-                "");
-        assertThat(((TextView)relativeLayout.findViewById(callToActionView.getId())).getText()).isEqualTo(
-                "");
+        assertThat(((TextView)relativeLayout.findViewById(titleView.getId())).getText())
+                .isEqualTo("");
+        assertThat(((TextView)relativeLayout.findViewById(textView.getId())).getText())
+                .isEqualTo("");
+        assertThat(((TextView)relativeLayout.findViewById(callToActionView.getId())).getText())
+                .isEqualTo("");
     }
 
     @Test
-    public void getOrCreateNativeViewHolder_withNoViewHolder_shouldCreateNativeViewHolder() {
-        final NativeViewHolder viewHolder =
-                subject.getOrCreateNativeViewHolder(relativeLayout, viewBinder);
+    public void renderAdView_withNoViewHolder_shouldCreateNativeViewHolder() {
+        subject.renderAdView(relativeLayout, nativeResponse);
 
-        final NativeViewHolder expectedViewHolder =
-                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
+        NativeViewHolder expectedViewHolder = NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
+        NativeViewHolder viewHolder = subject.mViewHolderMap.get(relativeLayout);
         compareNativeViewHolders(expectedViewHolder, viewHolder);
     }
 
     @Test
     public void getOrCreateNativeViewHolder_withViewHolder_shouldNotReCreateNativeViewHolder() {
-        final NativeViewHolder viewHolder =
-                subject.getOrCreateNativeViewHolder(relativeLayout, viewBinder);
+        subject.renderAdView(relativeLayout, nativeResponse);
+        NativeViewHolder expectedViewHolder = subject.mViewHolderMap.get(relativeLayout);
+        subject.renderAdView(relativeLayout, nativeResponse);
 
-        assertThat(subject.getOrCreateNativeViewHolder(relativeLayout, viewBinder))
-                .isEqualTo(viewHolder);
+        NativeViewHolder viewHolder = subject.mViewHolderMap.get(relativeLayout);
+        assertThat(viewHolder).isEqualTo(expectedViewHolder);
     }
 
     static private void compareNativeViewHolders(final NativeViewHolder actualViewHolder,
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeTest.java
index ad2d8969..0fbdfebc 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeTest.java
@@ -1,19 +1,22 @@
 package com.mopub.nativeads;
 
 import android.app.Activity;
-import com.mopub.common.DownloadTask;
-import com.mopub.common.GpsHelper;
-import com.mopub.common.GpsHelperTest;
-import com.mopub.common.SharedPreferencesHelper;
+
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.common.util.test.support.ShadowAsyncTasks;
 import com.mopub.common.util.test.support.TestMethodBuilderFactory;
+import com.mopub.mobileads.MoPubErrorCode;
 import com.mopub.nativeads.MoPubNative.MoPubNativeEventListener;
 import com.mopub.nativeads.MoPubNative.MoPubNativeNetworkListener;
-import org.apache.http.client.methods.HttpGet;
+import com.mopub.network.MoPubNetworkError;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.volley.NoConnectionError;
+import com.mopub.volley.Request;
+import com.mopub.volley.VolleyError;
+
 import org.junit.After;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
@@ -21,19 +24,24 @@
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLog;
 
-import java.util.*;
-import java.util.concurrent.*;
+import java.net.MalformedURLException;
+import java.util.List;
+import java.util.concurrent.Semaphore;
+import java.util.logging.Level;
+import java.util.logging.LogManager;
 
 import static android.Manifest.permission.ACCESS_NETWORK_STATE;
 import static android.Manifest.permission.INTERNET;
+import static com.mopub.common.VolleyRequestMatcher.isUrl;
 import static com.mopub.common.util.Reflection.MethodBuilder;
 import static com.mopub.nativeads.MoPubNative.EMPTY_EVENT_LISTENER;
 import static com.mopub.nativeads.MoPubNative.EMPTY_NETWORK_LISTENER;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
+import static org.mockito.Matchers.argThat;
+import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.verify;
@@ -46,14 +54,15 @@
     private MoPubNative subject;
     private MethodBuilder methodBuilder;
     private Activity context;
-    private MoPubNative.NativeGpsHelperListener nativeGpsHelperListener;
     private Semaphore semaphore;
     private static final String adUnitId = "test_adunit_id";
-    
+
     @Mock private MoPubNativeEventListener mockEventListener;
 
     @Mock private MoPubNativeNetworkListener mockNetworkListener;
-    
+    @Mock private MoPubRequestQueue mockRequestQueue;
+
+
     @Before
     public void setup() {
         context = new Activity();
@@ -61,15 +70,8 @@ public void setup() {
         shadowOf(context).grantPermissions(INTERNET);
         subject = new MoPubNative(context, adUnitId, mockNetworkListener);
         methodBuilder = TestMethodBuilderFactory.getSingletonMock();
-        nativeGpsHelperListener = mock(MoPubNative.NativeGpsHelperListener.class);
+        Networking.setRequestQueueForTesting(mockRequestQueue);
         semaphore = new Semaphore(0);
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                semaphore.release();
-                return null;
-            }
-        }).when(nativeGpsHelperListener).onFetchAdInfoCompleted();
     }
 
     @After
@@ -77,87 +79,6 @@ public void tearDown() {
         reset(methodBuilder);
     }
 
-    @Ignore("fix concurrency issues")
-    @Test
-    public void
-    makeRequest_whenGooglePlayServicesIsLinkedAndAdInfoIsNotCached_shouldCacheAdInfoBeforeFetchingAd() throws Exception {
-        SharedPreferencesHelper.getSharedPreferences(context).edit().clear().commit();
-        GpsHelperTest.verifyCleanClientMetadata(context);
-
-        GpsHelper.setClassNamesForTesting();
-        GpsHelperTest.TestAdInfo adInfo = new GpsHelperTest.TestAdInfo();
-
-        when(methodBuilder.setStatic(any(Class.class))).thenReturn(methodBuilder);
-        when(methodBuilder.addParam(any(Class.class), any())).thenReturn(methodBuilder);
-        when(methodBuilder.execute()).thenReturn(
-                GpsHelper.GOOGLE_PLAY_SUCCESS_CODE,
-                adInfo,
-                adInfo.ADVERTISING_ID,
-                adInfo.LIMIT_AD_TRACKING_ENABLED
-        );
-
-        subject.makeRequest(nativeGpsHelperListener);
-        semaphore.acquire();
-
-        verify(nativeGpsHelperListener).onFetchAdInfoCompleted();
-        GpsHelperTest.verifyClientMetadata(context, adInfo);
-    }
-
-    @Test
-    public void makeRequest_whenGooglePlayServicesIsNotLinked_shouldFetchAdFast() throws Exception {
-        SharedPreferencesHelper.getSharedPreferences(context).edit().clear().commit();
-        GpsHelperTest.verifyCleanClientMetadata(context);
-
-        GpsHelper.setClassNamesForTesting();
-        when(methodBuilder.setStatic(any(Class.class))).thenReturn(methodBuilder);
-        when(methodBuilder.addParam(any(Class.class), any())).thenReturn(methodBuilder);
-
-        // return error code so it fails
-        when(methodBuilder.execute()).thenReturn(GpsHelper.GOOGLE_PLAY_SUCCESS_CODE + 1);
-
-        subject.makeRequest(nativeGpsHelperListener);
-        // no need to sleep since it run the callback without an async task
-
-        verify(nativeGpsHelperListener).onFetchAdInfoCompleted();
-        GpsHelperTest.verifyCleanClientMetadata(context);
-    }
-
-    @Test
-    public void makeRequest_whenGooglePlayServicesIsNotLinked_withNullContext_shouldReturnFast() throws Exception {
-        subject.destroy();
-
-        GpsHelper.setClassNamesForTesting();
-        when(methodBuilder.setStatic(any(Class.class))).thenReturn(methodBuilder);
-        when(methodBuilder.addParam(any(Class.class), any())).thenReturn(methodBuilder);
-
-        // return error code so it fails
-        when(methodBuilder.execute()).thenReturn(GpsHelper.GOOGLE_PLAY_SUCCESS_CODE + 1);
-
-        subject.makeRequest(nativeGpsHelperListener);
-        // no need to sleep since it run the callback without an async task
-
-        verify(nativeGpsHelperListener, never()).onFetchAdInfoCompleted();
-    }
-
-    @Test
-    public void makeRequest_whenGooglePlayServicesIsLinkedAndAdInfoIsCached_shouldFetchAdFast() throws Exception {
-        GpsHelperTest.TestAdInfo adInfo = new GpsHelperTest.TestAdInfo();
-        GpsHelperTest.populateAndVerifyClientMetadata(context, adInfo);
-        GpsHelper.setClassNamesForTesting();
-
-        when(methodBuilder.setStatic(any(Class.class))).thenReturn(methodBuilder);
-        when(methodBuilder.addParam(any(Class.class), any())).thenReturn(methodBuilder);
-        when(methodBuilder.execute()).thenReturn(
-                GpsHelper.GOOGLE_PLAY_SUCCESS_CODE
-        );
-
-        subject.makeRequest(nativeGpsHelperListener);
-        // no need to sleep since it run the callback without an async task
-
-        verify(nativeGpsHelperListener).onFetchAdInfoCompleted();
-        GpsHelperTest.verifyClientMetadata(context, adInfo);
-    }
-
     @Test
     public void destroy_shouldSetListenersToEmptyAndClearContext() {
         assertThat(subject.getContextOrDestroy()).isSameAs(context);
@@ -182,64 +103,91 @@ public void setNativeEventListener_shouldSetListener() {
         assertThat(subject.getMoPubNativeEventListener()).isSameAs(EMPTY_EVENT_LISTENER);
     }
 
-    @Ignore("pending")
-    @Test
-    public void loadNativeAd_shouldQueueAsyncDownloadTask() {
-        Robolectric.getUiThreadScheduler().pause();
-
-        subject.loadNativeAd(null);
-
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
-    }
-
     @Test
     public void loadNativeAd_shouldReturnFast() {
         Robolectric.getUiThreadScheduler().pause();
 
         subject.destroy();
-        subject.loadNativeAd(null);
+        subject.makeRequest();
 
         assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
     }
 
     @Test
-    public void requestNativeAd_withValidUrl_shouldStartDownloadTaskWithUrl() {
-        Robolectric.getUiThreadScheduler().pause();
-        Robolectric.addPendingHttpResponse(200, "body");
+    public void requestNativeAd_shouldFireNetworkRequest() {
 
         subject.requestNativeAd("http://www.mopub.com");
 
         verify(mockNetworkListener, never()).onNativeFail(any(NativeErrorCode.class));
-        assertThat(wasDownloadTaskExecuted()).isTrue();
-
-        List<?> latestParams = ShadowAsyncTasks.getLatestParams();
-        assertThat(latestParams).hasSize(1);
-        HttpGet httpGet = (HttpGet) latestParams.get(0);
-        assertThat(httpGet.getURI().toString()).isEqualTo("http://www.mopub.com");
+        verify(mockRequestQueue).add(argThat(isUrl("http://www.mopub.com")));
     }
 
     @Test
-    public void requestNativeAd_withInvalidUrl_shouldFireNativeFailAndNotStartAsyncTask() {
-        Robolectric.getUiThreadScheduler().pause();
-
+    public void requestNativeAd_whenReqeustQueueDeliversUnknownError_shouldFireNativeFail() {
+
+        when(mockRequestQueue.add(any(Request.class)))
+                .then(new Answer<Void>() {
+                    @Override
+                    public Void answer(final InvocationOnMock invocationOnMock) throws Throwable {
+                        ((Request) invocationOnMock.getArguments()[0]).deliverError(new VolleyError(new MalformedURLException()));
+                        return null;
+                    }
+                });
         subject.requestNativeAd("//\\//\\::::");
 
         verify(mockNetworkListener).onNativeFail(any(NativeErrorCode.class));
-        assertThat(wasDownloadTaskExecuted()).isFalse();
     }
 
     @Test
-    public void requestNativeAd_withNullUrl_shouldFireNativeFailAndNotStartAsyncTask() {
+    public void requestNativeAd_withNullUrl_shouldFireNativeFail() {
         Robolectric.getUiThreadScheduler().pause();
 
         subject.requestNativeAd(null);
 
         verify(mockNetworkListener).onNativeFail(any(NativeErrorCode.class));
-        assertThat(wasDownloadTaskExecuted()).isFalse();
+        verify(mockRequestQueue, never()).add(any(Request.class));
     }
 
-    private boolean wasDownloadTaskExecuted() {
-        return ShadowAsyncTasks.wasCalled() &&
-                (ShadowAsyncTasks.getLatestAsyncTask() instanceof DownloadTask);
+    @Test
+    public void onAdError_shouldNotifyListener() {
+        subject.onAdError(new MoPubNetworkError(MoPubNetworkError.Reason.BAD_BODY));
+
+        verify(mockNetworkListener).onNativeFail(eq(NativeErrorCode.INVALID_JSON));
+    }
+
+    @Test
+    public void onAdError_whenNotMoPubError_shouldNotifyListener() {
+        subject.onAdError(new VolleyError("generic"));
+
+        verify(mockNetworkListener).onNativeFail(eq(NativeErrorCode.UNSPECIFIED));
+    }
+
+    @Test
+    public void onAdError_withVolleyErrorWarmingUp_shouldLogMoPubErrorCodeWarmup_shouldNotifyListener() {
+        LogManager.getLogManager().getLogger("com.mopub").setLevel(Level.ALL);
+
+        subject.onAdError(new MoPubNetworkError(MoPubNetworkError.Reason.WARMING_UP));
+
+        final List<ShadowLog.LogItem> allLogMessages = ShadowLog.getLogs();
+        final ShadowLog.LogItem latestLogMessage = allLogMessages.get(allLogMessages.size() - 1);
+
+        // All log messages end with a newline character.
+        assertThat(latestLogMessage.msg.trim()).isEqualTo(MoPubErrorCode.WARMUP.toString());
+        verify(mockNetworkListener).onNativeFail(eq(NativeErrorCode.EMPTY_AD_RESPONSE));
+    }
+
+    @Test
+    public void onAdError_withNoConnection_shouldLogMoPubErrorCodeNoConnection_shouldNotifyListener() {
+        LogManager.getLogManager().getLogger("com.mopub").setLevel(Level.ALL);
+        shadowOf(context).denyPermissions(INTERNET);
+
+        subject.onAdError(new NoConnectionError());
+
+        final List<ShadowLog.LogItem> allLogMessages = ShadowLog.getLogs();
+        final ShadowLog.LogItem latestLogMessage = allLogMessages.get(allLogMessages.size() - 1);
+
+        // All log messages end with a newline character.
+        assertThat(latestLogMessage.msg.trim()).isEqualTo(MoPubErrorCode.NO_CONNECTION.toString());
+        verify(mockNetworkListener).onNativeFail(eq(NativeErrorCode.CONNECTION_ERROR));
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubStreamAdPlacerTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubStreamAdPlacerTest.java
index 06f09512..ac6f2be1 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubStreamAdPlacerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubStreamAdPlacerTest.java
@@ -7,11 +7,13 @@
 
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
+import com.mopub.nativeads.PositioningSource.PositioningListener;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Answers;
+import org.mockito.ArgumentCaptor;
 import org.mockito.Mock;
 import org.robolectric.Robolectric;
 
@@ -22,6 +24,7 @@
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
@@ -84,6 +87,9 @@ public void isAd_loadAds_withoutLoadingPositions_hasNoAds() {
     @Test
     public void isAd_loadAds_thenLoadPositions_hasAds() {
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
+
         subject.handleAdsAvailable();
         subject.handlePositioningLoad(positioning);
         subject.setItemCount(4);
@@ -93,6 +99,9 @@ public void isAd_loadAds_thenLoadPositions_hasAds() {
     @Test
     public void isAd_loadPositions_thenLoadAds_hasAds() {
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
+
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
         subject.setItemCount(4);
@@ -108,6 +117,8 @@ public void getOriginalPosition_adjustsPositions() {
         assertThat(subject.getOriginalPosition(4)).isEqualTo(4);
 
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
         subject.setItemCount(4);
@@ -133,6 +144,8 @@ public void getAdjustedPosition_adjustsPositions() {
         assertThat(subject.getAdjustedPosition(4)).isEqualTo(4);
 
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
         subject.setItemCount(4);
@@ -158,6 +171,8 @@ public void getOriginalCount_adjustsPositions() {
         assertThat(subject.getOriginalCount(4)).isEqualTo(4);
 
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
         subject.setItemCount(4);
@@ -183,6 +198,8 @@ public void getAdjustedCount_adjustsPositions() {
         assertThat(subject.getAdjustedCount(4)).isEqualTo(4);
 
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
         subject.setItemCount(4);
@@ -202,6 +219,8 @@ public void getAdjustedCount_adjustsPositions() {
     @Test
     public void placeAds_shouldCallListener() {
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
         subject.setItemCount(4);
@@ -219,6 +238,8 @@ public void placeAds_shouldCallListener() {
     @Test
     public void placeAdsInRange_shouldPlaceAfter() {
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
 
@@ -239,6 +260,8 @@ public void placeAdsInRange_shouldPlaceAfter() {
     @Test
     public void placeAdsInRange_shouldCallListener() {
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
 
@@ -259,6 +282,8 @@ public void placeAdsInRange_shouldCallListener() {
     @Test
     public void placeAdsInRange_aboveItemCount_shouldNotInsert() {
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
 
@@ -278,12 +303,14 @@ public void getAdView_withNoAds_returnsNull() {
     @Test
     public void loadAds_shouldClearAds_afterFirstAdLoads() {
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
         subject.setItemCount(2);
         subject.placeAdsInRange(0, 1);
 
-        subject.loadAds("test_ad-unit-id");
+        subject.loadAds("test-ad-unit-id");
 
         // Ad should still exist until a new ad is available
         checkAdPositions(1);
@@ -297,12 +324,27 @@ public void loadAds_shouldClearAds_afterFirstAdLoads() {
         checkAdPositions(1);
     }
 
+    @Test
+    public void loadAds_withFailingPositioningSource_shouldNotLoadAds() {
+        ArgumentCaptor<PositioningListener> listenerCaptor =
+                ArgumentCaptor.forClass(PositioningListener.class);
+
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
+        verify(mockPositioningSource).loadPositions(
+                eq("test-ad-unit-id"), listenerCaptor.capture());
+        listenerCaptor.getValue().onFailed();
+        verify(mockAdLoadedListener, never()).onAdLoaded(anyInt());
+    }
+
     @Test
     public void destroy_shouldClearAdSource_shouldDestroyImpressionTracker_shouldDestroyResponse() {
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
 
         subject = new MoPubStreamAdPlacer(context,
                 mockAdSource, mockImpressionTracker, mockPositioningSource);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
         subject.setItemCount(2);  // Places 1 ad
@@ -320,6 +362,8 @@ public void getAdView_withNullConvertView_callsRenderer_addsToImpressionTracker(
         when(mockAdRenderer.createAdView(any(Context.class), any(ViewGroup.class)))
                 .thenReturn(view);
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
         subject.setItemCount(100);
@@ -334,6 +378,8 @@ public void getAdView_withNullConvertView_callsRenderer_addsToImpressionTracker(
     public void getAdView_withConvertView_callsRenderer_addsToImpressionTracker() {
         View convertView = new View(context);
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
         subject.setItemCount(4);
@@ -349,6 +395,8 @@ public void getAdView_shouldRemoveViewFromImpressionTracker_shouldClearPreviousN
         NativeResponse mockNativeResponse = mock(NativeResponse.class);
         View mockView = mock(View.class);
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse, mockNativeResponse, stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
         subject.setItemCount(100);
@@ -371,6 +419,8 @@ public void getAdView_shouldRemoveViewFromImpressionTracker_shouldClearPreviousN
     public void getAdView_withNetworkImpressionTracker_shouldNotAddViewToImpressionTracker_shouldPrepareNativeResponse() throws Exception {
         View mockView = mock(View.class);
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
         subject.setItemCount(100);
@@ -386,6 +436,8 @@ public void getAdView_withNetworkImpressionTracker_shouldNotAddViewToImpressionT
     public void getAdView_withoutNetworkImpressionTracker_shouldAddViewToImpressionTracker_shouldPrepareNativeResponse() throws Exception {
         View mockView = mock(View.class);
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
         subject.setItemCount(100);
@@ -403,6 +455,8 @@ public void destroy_shouldClearAdSource_shouldDestroyImpressionTracker_shouldRes
 
         subject = new MoPubStreamAdPlacer(context,
                 mockAdSource, mockImpressionTracker, mockPositioningSource);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         subject.handleAdsAvailable();
         subject.setItemCount(2);  // Places 1 ad
@@ -417,6 +471,8 @@ public void destroy_shouldClearAdSource_shouldDestroyImpressionTracker_shouldRes
     @Test
     public void modifyClientPositioning_afterConstructingAdPlacer_shouldNotModifyAdPositions() {
         when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.loadAds("test-ad-unit-id");
         subject.handlePositioningLoad(positioning);
         positioning.enableRepeatingPositions(5);
 
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdViewHelperTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdViewHelperTest.java
index 4d4b3e9f..2443a4d4 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdViewHelperTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdViewHelperTest.java
@@ -15,6 +15,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
+import org.robolectric.Robolectric;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
@@ -40,7 +41,7 @@
 
     @Before
     public void setUp() throws Exception {
-        context = new Activity();
+        context = Robolectric.buildActivity(Activity.class).create().get();
         relativeLayout = new RelativeLayout(context);
         relativeLayout.setId((int) Utils.generateUniqueId());
         viewGroup = new LinearLayout(context);
@@ -60,6 +61,7 @@ public void setUp() throws Exception {
         relativeLayout.addView(titleView);
         relativeLayout.addView(textView);
         relativeLayout.addView(callToActionView);
+        relativeLayout.setTag(NativeAdViewHelper.ViewType.AD);
 
         viewBinder = new ViewBinder.Builder(relativeLayout.getId())
                 .titleId(titleView.getId())
@@ -77,54 +79,40 @@ public void getAdView_shouldReturnPopulatedView() throws Exception {
         when(mockNativeResponse1.getText()).thenReturn("test text");
         when(mockNativeResponse1.getCallToAction()).thenReturn("test call to action");
 
-        View view = NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse1, viewBinder, null);
+        View view = NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse1, viewBinder);
 
         assertThat(((TextView)view.findViewById(titleView.getId())).getText()).isEqualTo("test title");
         assertThat(((TextView)view.findViewById(textView.getId())).getText()).isEqualTo("test text");
         assertThat(((TextView)view.findViewById(callToActionView.getId())).getText()).isEqualTo("test call to action");
+        assertThat(view.getTag()).isEqualTo(NativeAdViewHelper.ViewType.AD);
 
         // not testing images due to testing complexity
     }
 
     @Test
-    public void getAdView_withNullViewBinder_shouldReturnEmptyView() throws Exception {
-        View view = NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse1, null, null);
+    public void getAdView_withDestroyedNativeResponse_shouldReturnEmptyAndGoneConvertView() throws Exception {
+        when(mockNativeResponse1.isDestroyed()).thenReturn(true);
+        View view = NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse1, viewBinder);
 
-        assertThat(view).isNotNull();
         assertThat(view).isNotEqualTo(relativeLayout);
-    }
-
-    @Test
-    public void getAdView_withNullNativeResponse_shouldReturnGONEConvertView() throws Exception {
-        View view = NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, null, viewBinder, null);
-
-        assertThat(view).isEqualTo(relativeLayout);
+        assertThat(view.getTag()).isEqualTo(NativeAdViewHelper.ViewType.EMPTY);
         assertThat(view.getVisibility()).isEqualTo(View.GONE);
     }
 
-    @Test
-    public void getAdView_withDestroyedNativeResponse_shouldReturnGONEConvertView() throws Exception {
-        when(mockNativeResponse1.isDestroyed()).thenReturn(true);
-        View view = NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse1, viewBinder, null);
-
-        assertThat(view).isEqualTo(relativeLayout);
-        assertThat(view.getVisibility()).isEqualTo(View.GONE);
-    }
-    
     @Test
     public void getAdView_shouldRemoveViewFromImpressionTracker_shouldClearPreviousNativeResponse() throws Exception {
         NativeAdViewHelper.sImpressionTrackerMap.put(context, mockImpressionTracker);
 
-        NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse1, viewBinder, null);
+        NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse1, viewBinder);
         verify(mockImpressionTracker).removeView(relativeLayout);
 
         // Second call should clear the first NativeResponse
-        NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse2, viewBinder, null);
+        NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse2, viewBinder);
         verify(mockImpressionTracker, times(2)).removeView(relativeLayout);
         verify(mockNativeResponse1).clear(relativeLayout);
 
         // Third call should clear the second NativeResponse
-        NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse1, viewBinder, null);
+        NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse1, viewBinder);
         verify(mockImpressionTracker, times(3)).removeView(relativeLayout);
         verify(mockNativeResponse2).clear(relativeLayout);
     }
@@ -134,7 +122,7 @@ public void getAdView_withNetworkImpressionTracker_shouldNotAddViewToImpressionT
         NativeAdViewHelper.sImpressionTrackerMap.put(context, mockImpressionTracker);
         when(mockNativeResponse1.isOverridingImpressionTracker()).thenReturn(true);
 
-        NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse1, viewBinder, null);
+        NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse1, viewBinder);
 
         verify(mockImpressionTracker, never()).addView(any(View.class), any(NativeResponse.class));
         verify(mockNativeResponse1).prepare(relativeLayout);
@@ -145,7 +133,7 @@ public void getAdView_withoutNetworkImpressionTracker_shouldAddViewToImpressionT
         NativeAdViewHelper.sImpressionTrackerMap.put(context, mockImpressionTracker);
         when(mockNativeResponse1.isOverridingImpressionTracker()).thenReturn(false);
 
-        NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse1, viewBinder, null);
+        NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, mockNativeResponse1, viewBinder);
 
         verify(mockImpressionTracker).addView(relativeLayout, mockNativeResponse1);
         verify(mockNativeResponse1).prepare(relativeLayout);
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeResponseTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeResponseTest.java
index a1cef1c5..af562b2c 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeResponseTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeResponseTest.java
@@ -1,24 +1,25 @@
 package com.mopub.nativeads;
 
 import android.app.Activity;
+import android.support.annotation.NonNull;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.Button;
 import android.widget.LinearLayout;
 import android.widget.RelativeLayout;
 
-import com.mopub.common.DownloadResponse;
 import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.ResponseHeader;
 import com.mopub.common.util.Utils;
-import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.volley.Request;
+import com.mopub.volley.RequestQueue;
 
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.tester.org.apache.http.HttpRequestInfo;
+import org.mockito.Mock;
 
 import java.util.List;
 import java.util.Map;
@@ -29,7 +30,9 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyZeroInteractions;
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
@@ -44,7 +47,9 @@
     private NativeAdInterface mMockNativeAd;
     private boolean baseNativeAdRecordedImpression;
     private boolean baseNativeAdIsClicked;
-    private DownloadResponse downloadResponse;
+    @Mock
+    private MoPubRequestQueue mockRequestQueue;
+
 
     @Before
     public void setUp() throws Exception {
@@ -56,7 +61,7 @@ public void recordImpression() {
             }
 
             @Override
-            public void handleClick(final View view) {
+            public void handleClick(@NonNull final View view) {
                 baseNativeAdIsClicked = true;
             }
         };
@@ -73,23 +78,27 @@ public void handleClick(final View view) {
 
         view = new LinearLayout(context);
 
-        final TestHttpResponseWithHeaders testHttpResponseWithHeaders = new TestHttpResponseWithHeaders(200, "");
-        testHttpResponseWithHeaders.addHeader(ResponseHeader.IMPRESSION_URL.getKey(), "moPubImpressionTrackerUrl");
-        testHttpResponseWithHeaders.addHeader(ResponseHeader.CLICKTHROUGH_URL.getKey(), "moPubClickTrackerUrl");
-        downloadResponse = new DownloadResponse(testHttpResponseWithHeaders);
+        Networking.setRequestQueueForTesting(mockRequestQueue);
 
         moPubNativeListener = mock(MoPubNative.MoPubNativeListener.class);
 
-        subject = new NativeResponse(context, downloadResponse, "adunit_id", mNativeAd, moPubNativeListener);
+        subject = new NativeResponse(context,
+                "moPubImpressionTrackerUrl",
+                "moPubClickTrackerUrl",
+                "adunit_id", mNativeAd, moPubNativeListener);
 
         mMockNativeAd = mock(NativeAdInterface.class);
-        subjectWMockBaseNativeAd = new NativeResponse(context, downloadResponse, "adunit_id", mMockNativeAd, moPubNativeListener);
+        subjectWMockBaseNativeAd = new NativeResponse(context,
+                "moPubImpressionTrackerUrl",
+                "moPubClickTrackerUrl",
+                "adunit_id", mMockNativeAd, moPubNativeListener);
     }
 
     @Test
     public void constructor_shouldSetNativeEventListenerOnNativeAdInterface() {
         reset(mMockNativeAd);
-        subject = new NativeResponse(context, downloadResponse, "adunit_id", mMockNativeAd, moPubNativeListener);
+        subject = new NativeResponse(context, "moPubImpressionTrackerUrl", "moPubClickTrackerUrl",
+                "adunit_id", mMockNativeAd, moPubNativeListener);
         verify(mMockNativeAd).setNativeEventListener(any(BaseForwardingNativeAd.NativeEventListener.class));
     }
 
@@ -205,33 +214,28 @@ public void prepare_shouldAttachClickListenersToViewTree() {
 
     @Test
     public void recordImpression_shouldRecordImpressionsAndCallIntoBaseNativeAdAndNotifyListenerIdempotently() {
-        Robolectric.getFakeHttpLayer().addPendingHttpResponse(200, "ok");
-        Robolectric.getFakeHttpLayer().addPendingHttpResponse(200, "ok");
         assertThat(subject.getRecordedImpression()).isFalse();
 
         subject.recordImpression(view);
 
         assertThat(subject.getRecordedImpression()).isTrue();
 
-        List<HttpRequestInfo> httpRequestInfos = Robolectric.getFakeHttpLayer().getSentHttpRequestInfos();
-        assertThat(httpRequestInfos.size()).isEqualTo(2);
-        assertThat(httpRequestInfos.get(0).getHttpRequest().getRequestLine().getUri()).isEqualTo("moPubImpressionTrackerUrl");
-        assertThat(httpRequestInfos.get(1).getHttpRequest().getRequestLine().getUri()).isEqualTo("impressionUrl");
-
         assertThat(baseNativeAdRecordedImpression).isTrue();
         verify(moPubNativeListener).onNativeImpression(view);
+        // There are two impression trackers here.
+        verify(mockRequestQueue, times(2)).add(any(Request.class));
 
         // reset state
         baseNativeAdRecordedImpression = false;
-        Robolectric.getFakeHttpLayer().clearRequestInfos();
         reset(moPubNativeListener);
+        reset(mockRequestQueue);
 
         // verify impression tracking doesn't fire again
         subject.recordImpression(view);
         assertThat(subject.getRecordedImpression()).isTrue();
-        assertThat(Robolectric.getFakeHttpLayer().getSentHttpRequestInfos()).isEmpty();
         assertThat(baseNativeAdRecordedImpression).isFalse();
         verify(moPubNativeListener, never()).onNativeImpression(view);
+        verify(mockRequestQueue, never()).add(any(Request.class));
     }
 
     @Test
@@ -239,38 +243,34 @@ public void recordImpression_whenDestroyed_shouldReturnFast() {
         subject.destroy();
         subject.recordImpression(view);
         assertThat(subject.getRecordedImpression()).isFalse();
-        assertThat(Robolectric.getFakeHttpLayer().getSentHttpRequestInfos()).isEmpty();
         assertThat(baseNativeAdRecordedImpression).isFalse();
         verify(moPubNativeListener, never()).onNativeImpression(view);
+        verify(mockRequestQueue, never()).add(any(Request.class));
     }
 
     @Test
     public void handleClick_withNoBaseNativeAdClickDestinationUrl_shouldRecordClickAndCallIntoBaseNativeAdAndNotifyListener() {
-        Robolectric.getFakeHttpLayer().addPendingHttpResponse(200, "ok");
         assertThat(subject.isClicked()).isFalse();
 
         subject.handleClick(view);
 
         assertThat(subject.isClicked()).isTrue();
 
-        List<HttpRequestInfo> httpRequestInfos = Robolectric.getFakeHttpLayer().getSentHttpRequestInfos();
-        assertThat(httpRequestInfos.size()).isEqualTo(1);
-        assertThat(httpRequestInfos.get(0).getHttpRequest().getRequestLine().getUri()).isEqualTo("moPubClickTrackerUrl");
-
         assertThat(baseNativeAdIsClicked).isTrue();
         verify(moPubNativeListener).onNativeClick(view);
+        verify(mockRequestQueue).add(any(Request.class));
 
         // reset state
         baseNativeAdIsClicked = false;
-        Robolectric.getFakeHttpLayer().clearRequestInfos();
         reset(moPubNativeListener);
+        reset(mockRequestQueue);
 
         // second time, tracking does not fire
         subject.handleClick(view);
         assertThat(subject.isClicked()).isTrue();
-        assertThat(Robolectric.getFakeHttpLayer().getSentHttpRequestInfos()).isEmpty();
         assertThat(baseNativeAdRecordedImpression).isFalse();
         verify(moPubNativeListener).onNativeClick(view);
+        verifyZeroInteractions(mockRequestQueue);
     }
 
     @Ignore("pending")
@@ -284,9 +284,9 @@ public void handleClick_whenDestroyed_shouldReturnFast() {
         subject.destroy();
         subject.handleClick(view);
         assertThat(subject.isClicked()).isFalse();
-        assertThat(Robolectric.getFakeHttpLayer().getSentHttpRequestInfos()).isEmpty();
         assertThat(baseNativeAdIsClicked).isFalse();
         verify(moPubNativeListener, never()).onNativeClick(view);
+        verifyZeroInteractions(mockRequestQueue);
     }
 
     @Test
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeUrlGeneratorTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeUrlGeneratorTest.java
index 5d96c9b0..9fb64e46 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeUrlGeneratorTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeUrlGeneratorTest.java
@@ -2,9 +2,17 @@
 
 import android.app.Activity;
 import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Point;
+import android.location.Location;
+import android.location.LocationManager;
 import android.net.Uri;
+import android.os.Build;
 import android.telephony.TelephonyManager;
 import android.text.TextUtils;
+import android.util.DisplayMetrics;
+import android.view.Display;
+import android.view.WindowManager;
 
 import com.mopub.common.MoPub;
 import com.mopub.mobileads.test.support.MoPubShadowTelephonyManager;
@@ -13,7 +21,11 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLocationManager;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -22,26 +34,64 @@
 
 import static android.Manifest.permission.ACCESS_NETWORK_STATE;
 import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
+import static org.robolectric.Robolectric.application;
 import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(SdkTestRunner.class)
 @Config(shadows = {MoPubShadowTelephonyManager.class})
 public class NativeUrlGeneratorTest {
     public static final String AD_UNIT_ID = "1234";
+    private static final int TEST_SCREEN_WIDTH = 999;
+    private static final int TEST_SCREEN_HEIGHT = 888;
+    private static final float TEST_DENSITY = 1.0f;
     private Activity context;
     private NativeUrlGenerator subject;
     private MoPubShadowTelephonyManager shadowTelephonyManager;
 
     @Before
     public void setup() {
-        context = new Activity();
+        context = spy(Robolectric.buildActivity(Activity.class).create().get());
         shadowOf(context).grantPermissions(ACCESS_NETWORK_STATE);
         shadowTelephonyManager = (MoPubShadowTelephonyManager)
                 shadowOf((TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE));
+
+        // Set the expected screen dimensions to arbitrary numbers
+        final Resources spyResources = spy(context.getResources());
+        final DisplayMetrics mockDisplayMetrics = mock(DisplayMetrics.class);
+        mockDisplayMetrics.widthPixels = TEST_SCREEN_WIDTH;
+        mockDisplayMetrics.heightPixels = TEST_SCREEN_HEIGHT;
+        mockDisplayMetrics.density = TEST_DENSITY;
+        when(spyResources.getDisplayMetrics()).thenReturn(mockDisplayMetrics);
+        when(context.getResources()).thenReturn(spyResources);
+
+        // Only do this on Android 17+ because getRealSize doesn't exist before then.
+        // This is the default pathway.
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
+            final WindowManager mockWindowManager = mock(WindowManager.class);
+            final Display mockDisplay = mock(Display.class);
+            doAnswer(new Answer() {
+                @Override
+                public Object answer(final InvocationOnMock invocationOnMock) throws Throwable {
+                    final Point point = (Point) invocationOnMock.getArguments()[0];
+                    point.x = TEST_SCREEN_WIDTH;
+                    point.y = TEST_SCREEN_HEIGHT;
+                    return null;
+                }
+            }).when(mockDisplay).getRealSize(any(Point.class));
+            when(mockWindowManager.getDefaultDisplay()).thenReturn(mockDisplay);
+            final Context spyApplicationContext = spy(context.getApplicationContext());
+            when(spyApplicationContext.getSystemService(Context.WINDOW_SERVICE)).thenReturn(mockWindowManager);
+            when(context.getApplicationContext()).thenReturn(spyApplicationContext);
+        }
     }
 
     @Test
-    public void generateNativeAdUrl_shouldIncludeDesiredAssetIfSet() throws Exception {
+    public void generateUrlString_shouldIncludeDesiredAssetIfSet() throws Exception {
         EnumSet<RequestParameters.NativeAdAsset> assetsSet = EnumSet.of(RequestParameters.NativeAdAsset.TITLE);
         RequestParameters requestParameters = new RequestParameters.Builder().desiredAssets(assetsSet).build();
 
@@ -55,7 +105,7 @@ public void generateNativeAdUrl_shouldIncludeDesiredAssetIfSet() throws Exceptio
     }
 
     @Test
-    public void generateNativeAdUrl_shouldIncludeDesiredAssetsIfSet() throws Exception {
+    public void generateUrlString_shouldIncludeDesiredAssetsIfSet() throws Exception {
         EnumSet<RequestParameters.NativeAdAsset> assetsSet = EnumSet.of(RequestParameters.NativeAdAsset.TITLE, RequestParameters.NativeAdAsset.TEXT, RequestParameters.NativeAdAsset.ICON_IMAGE);
         RequestParameters requestParameters = new RequestParameters.Builder().desiredAssets(assetsSet).build();
 
@@ -69,7 +119,7 @@ public void generateNativeAdUrl_shouldIncludeDesiredAssetsIfSet() throws Excepti
     }
 
     @Test
-    public void generateNativeAdUrl_shouldNotIncludeDesiredAssetsIfNotSet() throws Exception {
+    public void generateUrlString_shouldNotIncludeDesiredAssetsIfNotSet() throws Exception {
         subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
 
         String requestString = generateMinimumUrlString();
@@ -79,7 +129,7 @@ public void generateNativeAdUrl_shouldNotIncludeDesiredAssetsIfNotSet() throws E
     }
 
     @Test
-    public void generateNativeAdUrl_shouldNotIncludeDesiredAssetsIfNoAssetsAreSet() throws Exception {
+    public void generateUrlString_shouldNotIncludeDesiredAssetsIfNoAssetsAreSet() throws Exception {
         EnumSet<RequestParameters.NativeAdAsset> assetsSet = EnumSet.noneOf(RequestParameters.NativeAdAsset.class);
         RequestParameters requestParameters = new RequestParameters.Builder().desiredAssets(assetsSet).build();
 
@@ -92,7 +142,7 @@ public void generateNativeAdUrl_shouldNotIncludeDesiredAssetsIfNoAssetsAreSet()
     }
 
     @Test
-    public void generateNativeAdUrl_needsButDoesNotHaveReadPhoneState_shouldNotContainOperatorName() {
+    public void generateUrlString_needsButDoesNotHaveReadPhoneState_shouldNotContainOperatorName() {
         shadowTelephonyManager.setNeedsReadPhoneState(true);
         shadowTelephonyManager.setReadPhoneStatePermission(false);
         shadowTelephonyManager.setNetworkOperatorName("TEST_CARRIER");
@@ -102,9 +152,9 @@ public void generateNativeAdUrl_needsButDoesNotHaveReadPhoneState_shouldNotConta
 
         assertThat(getNetworkOperatorNameFromRequestUrl(requestString)).isNullOrEmpty();
     }
-    
+
     @Test
-    public void generateNativeAdUrl_needsAndHasReadPhoneState_shouldContainOperatorName() {
+    public void generateUrlString_needsAndHasReadPhoneState_shouldContainOperatorName() {
         shadowTelephonyManager.setNeedsReadPhoneState(true);
         shadowTelephonyManager.setReadPhoneStatePermission(true);
         shadowTelephonyManager.setNetworkOperatorName("TEST_CARRIER");
@@ -116,7 +166,7 @@ public void generateNativeAdUrl_needsAndHasReadPhoneState_shouldContainOperatorN
     }
 
     @Test
-    public void generateNativeAdUrl_doesNotNeedReadPhoneState_shouldContainOperatorName() {
+    public void generateUrlString_doesNotNeedReadPhoneState_shouldContainOperatorName() {
         shadowTelephonyManager.setNeedsReadPhoneState(false);
         shadowTelephonyManager.setReadPhoneStatePermission(false);
         shadowTelephonyManager.setNetworkOperatorName("TEST_CARRIER");
@@ -127,13 +177,136 @@ public void generateNativeAdUrl_doesNotNeedReadPhoneState_shouldContainOperatorN
         assertThat(getNetworkOperatorNameFromRequestUrl(requestString)).isEqualTo("TEST_CARRIER");
     }
 
+    @Test
+    public void generateUrlString_whenLocationServiceGpsProviderHasMostRecentLocation_shouldUseLocationServiceValue() {
+        Location locationFromDeveloper = new Location("");
+        locationFromDeveloper.setLatitude(42);
+        locationFromDeveloper.setLongitude(-42);
+        locationFromDeveloper.setAccuracy(3.5f);
+        locationFromDeveloper.setTime(1000);
+
+        // Mock out the LocationManager's last known location to be more recent than the
+        // developer-supplied location.
+        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
+                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
+        Location locationFromSdk = new Location("");
+        locationFromSdk.setLatitude(37);
+        locationFromSdk.setLongitude(-122);
+        locationFromSdk.setAccuracy(5.0f);
+        locationFromSdk.setTime(System.currentTimeMillis() - 555555);
+        shadowLocationManager.setLastKnownLocation(LocationManager.GPS_PROVIDER, locationFromSdk);
+
+        RequestParameters requestParameters = new RequestParameters.Builder()
+                .location(locationFromDeveloper)
+                .build();
+        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
+        String adUrl = subject.withRequest(requestParameters)
+                .generateUrlString("ads.mopub.com");
+        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isEqualTo("37.0,-122.0");
+        assertThat(getParameterFromRequestUrl(adUrl, "lla")).isEqualTo("5");
+        assertThat(getParameterFromRequestUrl(adUrl, "llsdk")).isEqualTo("1");
+        // Only test to the full second (as there may be small differences)
+        assertThat(getParameterFromRequestUrl(adUrl, "llf")).startsWith("555");
+        assertThat(getParameterFromRequestUrl(adUrl, "llf").length()).isEqualTo(6);
+    }
+
+    @Test
+    public void generateUrlString_whenDeveloperSuppliesMoreRecentLocationThanLocationService_shouldUseDeveloperSuppliedLocation() {
+        Location locationFromDeveloper = new Location("");
+        locationFromDeveloper.setLatitude(42);
+        locationFromDeveloper.setLongitude(-42);
+        locationFromDeveloper.setAccuracy(3.5f);
+        locationFromDeveloper.setTime(System.currentTimeMillis() - 777777);
+
+        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
+                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
+
+        // Mock out the LocationManager's last known location to be older than the
+        // developer-supplied location.
+        Location olderLocation = new Location("");
+        olderLocation.setLatitude(40);
+        olderLocation.setLongitude(-105);
+        olderLocation.setAccuracy(8.0f);
+        olderLocation.setTime(System.currentTimeMillis() - 888888);
+        shadowLocationManager.setLastKnownLocation(LocationManager.GPS_PROVIDER, olderLocation);
+
+        RequestParameters requestParameters = new RequestParameters.Builder()
+                .location(locationFromDeveloper)
+                .build();
+        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
+        String adUrl = subject.withRequest(requestParameters)
+                .generateUrlString("ads.mopub.com");
+        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isEqualTo("42.0,-42.0");
+        assertThat(getParameterFromRequestUrl(adUrl, "lla")).isEqualTo("3");
+        assertThat(getParameterFromRequestUrl(adUrl, "llsdk")).isEmpty();
+        // Only test to the full second (as there may be small differences)
+        assertThat(getParameterFromRequestUrl(adUrl, "llf")).startsWith("777");
+        assertThat(getParameterFromRequestUrl(adUrl, "llf").length()).isEqualTo(6);
+    }
+
+    @Test
+    public void generateUrlString_whenLocationServiceNetworkProviderHasMostRecentLocation_shouldUseLocationServiceValue() {
+        Location locationFromDeveloper = new Location("");
+        locationFromDeveloper.setLatitude(42);
+        locationFromDeveloper.setLongitude(-42);
+        locationFromDeveloper.setAccuracy(3.5f);
+        locationFromDeveloper.setTime(1000);
+
+        // Mock out the LocationManager's last known location to be more recent than the
+        // developer-supplied location.
+        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
+                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
+        Location locationFromSdk = new Location("");
+        locationFromSdk.setLatitude(38);
+        locationFromSdk.setLongitude(-123);
+        locationFromSdk.setAccuracy(5.0f);
+        locationFromSdk.setTime(System.currentTimeMillis() - 123456);
+        shadowLocationManager.setLastKnownLocation(LocationManager.NETWORK_PROVIDER,
+                locationFromSdk);
+
+        RequestParameters requestParameters = new RequestParameters.Builder()
+                .location(locationFromDeveloper)
+                .build();
+        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
+        String adUrl = subject.withRequest(requestParameters)
+                .generateUrlString("ads.mopub.com");
+        assertThat(getParameterFromRequestUrl(adUrl, "ll")).isEqualTo("38.0,-123.0");
+        assertThat(getParameterFromRequestUrl(adUrl, "lla")).isEqualTo("5");
+        assertThat(getParameterFromRequestUrl(adUrl, "llsdk")).isEqualTo("1");
+        // Only test to the full second (as there may be small differences)
+        assertThat(getParameterFromRequestUrl(adUrl, "llf")).startsWith("123");
+        assertThat(getParameterFromRequestUrl(adUrl, "llf").length()).isEqualTo(6);
+    }
+
+    @Test
+    public void generateUrlString_withOnlyAdUnitSet_shouldReturnMinimumUrl() {
+        subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
+        final String adUrl = generateMinimumUrlString();
+
+        assertThat(adUrl).isEqualTo(
+                "http://ads.mopub.com/m/ad?id=" +
+                        AD_UNIT_ID +
+                        "&nsv=3.6.1" +
+                        "&dn=unknown%2Cunknown%2Cunknown" +
+                        "&bundle=com.mopub.mobileads" +
+                        "&z=-0700" +
+                        "&o=u" +
+                        "&w=" +
+                        TEST_SCREEN_WIDTH +
+                        "&h=" +
+                        TEST_SCREEN_HEIGHT +
+                        "&sc_a=" +
+                        TEST_DENSITY +
+                        "&ct=3&av=1.0&udid=mp_tmpl_advertising_id&dnt=mp_tmpl_do_not_track");
+    }
+
     @Test
     public void enableLocation_shouldIncludeLocationInUrl() {
         MoPub.setLocationAwareness(MoPub.LocationAwareness.NORMAL);
         subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
 
         String requestString = generateMinimumUrlString();
-        assertThat(getLocationFromRequestUrl(requestString)).isNotNull();
+        assertThat(getParameterFromRequestUrl(requestString, "ll")).isNotNull();
     }
 
     @Test
@@ -142,7 +315,26 @@ public void disableLocation_shouldNotIncludeLocationInUrl() {
         subject = new NativeUrlGenerator(context).withAdUnitId(AD_UNIT_ID);
 
         String requestString = generateMinimumUrlString();
-        assertThat(getLocationFromRequestUrl(requestString)).isNullOrEmpty();
+        assertThat(getParameterFromRequestUrl(requestString, "ll")).isNullOrEmpty();
+    }
+
+    @Test
+    public void disableLocationCollection_whenLocationServiceHasMostRecentLocation_shouldNotIncludeLocationInUrl() {
+        MoPub.setLocationAwareness(MoPub.LocationAwareness.DISABLED);
+        subject = new NativeUrlGenerator(context);
+
+        // Mock out the LocationManager's last known location.
+        ShadowLocationManager shadowLocationManager = Robolectric.shadowOf(
+                (LocationManager) application.getSystemService(Context.LOCATION_SERVICE));
+        Location locationFromSdk = new Location("");
+        locationFromSdk.setLatitude(37);
+        locationFromSdk.setLongitude(-122);
+        locationFromSdk.setAccuracy(5.0f);
+        locationFromSdk.setTime(2000);
+        shadowLocationManager.setLastKnownLocation(LocationManager.GPS_PROVIDER, locationFromSdk);
+
+        String requestString = generateMinimumUrlString();
+        assertThat(getParameterFromRequestUrl(requestString, "ll")).isNullOrEmpty();
     }
 
     private List<String> getDesiredAssetsListFromRequestUrlString(String requestString) {
@@ -164,15 +356,15 @@ private String getNetworkOperatorNameFromRequestUrl(String requestString) {
         return networkOperatorName;
     }
 
-    private String getLocationFromRequestUrl(String requestString) {
+    private String getParameterFromRequestUrl(String requestString, String key) {
         Uri requestUri = Uri.parse(requestString);
-        String location = requestUri.getQueryParameter("ll");
+        String parameter = requestUri.getQueryParameter(key);
 
-        if (TextUtils.isEmpty(location)) {
+        if (TextUtils.isEmpty(parameter)) {
             return "";
         }
 
-        return location;
+        return parameter;
     }
 
     private String generateMinimumUrlString() {
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeViewHolderTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeViewHolderTest.java
index 52e22017..1be4c674 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeViewHolderTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeViewHolderTest.java
@@ -4,6 +4,7 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
+import android.graphics.drawable.BitmapDrawable;
 import android.view.ViewGroup;
 import android.widget.Button;
 import android.widget.ImageView;
@@ -11,24 +12,28 @@
 import android.widget.RelativeLayout;
 import android.widget.TextView;
 
-import com.mopub.common.CacheService;
-import com.mopub.common.DownloadResponse;
-import com.mopub.common.util.Utils;
-import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
-import com.mopub.nativeads.test.support.MoPubShadowBitmap;
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.Utils;
+import com.mopub.network.MaxWidthImageLoader;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.volley.RequestQueue;
+import com.mopub.volley.toolbox.ImageLoader;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.Config;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Captor;
+import org.mockito.Mock;
 
 import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
-import static org.robolectric.Robolectric.shadowOf;
+import static org.mockito.Mockito.stub;
+import static org.mockito.Mockito.verify;
 
 @RunWith(SdkTestRunner.class)
-@Config(shadows={MoPubShadowBitmap.class})
 public class NativeViewHolderTest {
     private Context context;
     private RelativeLayout relativeLayout;
@@ -55,8 +60,30 @@
     private Bitmap extrasImage2;
     private Bitmap extrasImage;
 
+    private static final String IMPRESSION_URL = "http://example.com";
+    private static final String CLICK_URL = "http://test.com";
+    private static final String AD_UNIT_ID = "http://blah.org";
+
+    @Mock
+    private MoPubRequestQueue mockRequestQueue;
+    @Mock
+    private MaxWidthImageLoader mockImageLoader;
+    @Mock
+    private ImageLoader.ImageContainer mockImageContainer;
+    @Mock
+    private Bitmap mockBitmap;
+
+    @Captor
+    private ArgumentCaptor<ImageLoader.ImageListener> mainImageCaptor;
+    @Captor
+    private ArgumentCaptor<ImageLoader.ImageListener> iconImageCaptor;
+
+
     @Before
     public void setUp() throws Exception {
+
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+        Networking.setImageLoaderForTesting(mockImageLoader);
         context = new Activity();
         relativeLayout = new RelativeLayout(context);
         relativeLayout.setId((int) Utils.generateUniqueId());
@@ -163,9 +190,6 @@ public void fromViewBinder_withNonExistantIds_shouldLeaveFieldsNull() throws Exc
     @Test
     public void update_shouldAddValuesToViews() throws Exception {
         // Setup for cache state for image gets
-        CacheService.initialize(context);
-        CacheService.putToBitmapCache(mainImageUrl, mainImage);
-        CacheService.putToBitmapCache(iconImageUrl, iconImage);
 
         BaseForwardingNativeAd nativeAd = new BaseForwardingNativeAd() {};
         nativeAd.setTitle("titletext");
@@ -174,8 +198,8 @@ public void update_shouldAddValuesToViews() throws Exception {
         nativeAd.setIconImageUrl("iconimageurl");
         nativeAd.setCallToAction("cta");
 
-        final DownloadResponse downloadResponse = new DownloadResponse(new TestHttpResponseWithHeaders(200, ""));
-        nativeResponse = new NativeResponse(context, downloadResponse, "adunit_id", nativeAd, null);
+        nativeResponse = new NativeResponse(context,
+                IMPRESSION_URL, CLICK_URL, AD_UNIT_ID, nativeAd, null);
 
         viewBinder = new ViewBinder.Builder(relativeLayout.getId())
                 .titleId(titleView.getId())
@@ -193,10 +217,15 @@ public void update_shouldAddValuesToViews() throws Exception {
         assertThat(titleView.getText()).isEqualTo("titletext");
         assertThat(textView.getText()).isEqualTo("texttext");
         assertThat(callToActionView.getText()).isEqualTo("cta");
-        assertThat(shadowOf(ImageViewServiceTest.getBitmapFromImageView(mainImageView))
-                .getCreatedFromBytes()).isEqualTo(mainImageData.getBytes());
-        assertThat(shadowOf(ImageViewServiceTest.getBitmapFromImageView(iconImageView))
-                .getCreatedFromBytes()).isEqualTo(iconImageData.getBytes());
+        verify(mockImageLoader).get(eq("mainimageurl"), mainImageCaptor.capture());
+        verify(mockImageLoader).get(eq("iconimageurl"), iconImageCaptor.capture());
+
+        stub(mockImageContainer.getBitmap()).toReturn(mockBitmap);
+        mainImageCaptor.getValue().onResponse(mockImageContainer, true);
+        iconImageCaptor.getValue().onResponse(mockImageContainer, true);
+
+        assertThat(((BitmapDrawable) mainImageView.getDrawable()).getBitmap()).isEqualTo(mockBitmap);
+        assertThat(((BitmapDrawable) iconImageView.getDrawable()).getBitmap()).isEqualTo(mockBitmap);
     }
 
     @Test
@@ -209,8 +238,8 @@ public void update_withMissingNativeResponseFields_shouldClearPreviousValues() t
         iconImageView.setImageBitmap(BitmapFactory.decodeByteArray("previousiconimagedata".getBytes(), 0, "previousiconimagedata".getBytes().length));
 
         // Only required fields in native response
-        final DownloadResponse downloadResponse = new DownloadResponse(new TestHttpResponseWithHeaders(200, ""));
-        nativeResponse = new NativeResponse(context, downloadResponse, "adunit_id", mock(BaseForwardingNativeAd.class), null);
+        nativeResponse = new NativeResponse(context,
+                IMPRESSION_URL, CLICK_URL, AD_UNIT_ID, mock(BaseForwardingNativeAd.class), null);
 
         viewBinder = new ViewBinder.Builder(relativeLayout.getId())
                 .titleId(titleView.getId())
@@ -240,8 +269,9 @@ public void update_withDifferentViewBinder_shouldNotClearPreviousValues() throws
 
         BaseForwardingNativeAd nativeAd = new BaseForwardingNativeAd() {};
         nativeAd.setCallToAction("cta");
-        final DownloadResponse downloadResponse = new DownloadResponse(new TestHttpResponseWithHeaders(200, ""));
-        nativeResponse = new NativeResponse(context, downloadResponse, "adunit_id", nativeAd, null);
+
+        nativeResponse = new NativeResponse(context,
+                IMPRESSION_URL, CLICK_URL, AD_UNIT_ID, nativeAd, null);
 
         viewBinder = new ViewBinder.Builder(relativeLayout.getId())
                 .callToActionId(callToActionView.getId())
@@ -260,16 +290,14 @@ public void update_withDifferentViewBinder_shouldNotClearPreviousValues() throws
     @Test
     public void updateExtras_shouldAddValuesToViews() throws Exception {
         // Setup for cache state for image gets
-        CacheService.initialize(context);
-        CacheService.putToBitmapCache("extrasimageurl", extrasImage);
-        CacheService.putToBitmapCache("extrasimageurl2", extrasImage2);
 
         BaseForwardingNativeAd nativeAd = new BaseForwardingNativeAd() {};
         nativeAd.addExtra("extrastext", "extrastexttext");
         nativeAd.addExtra("extrasimage", "extrasimageurl");
         nativeAd.addExtra("extrasimage2", "extrasimageurl2");
-        final DownloadResponse downloadResponse = new DownloadResponse(new TestHttpResponseWithHeaders(200, ""));
-        nativeResponse = new NativeResponse(context, downloadResponse, "adunit_id", nativeAd, null);
+
+        nativeResponse = new NativeResponse(context,
+                IMPRESSION_URL, CLICK_URL, AD_UNIT_ID, nativeAd, null);
 
         viewBinder = new ViewBinder.Builder(relativeLayout.getId())
                 .addExtra("extrastext", extrasTextView.getId())
@@ -283,10 +311,16 @@ public void updateExtras_shouldAddValuesToViews() throws Exception {
         nativeViewHolder.updateExtras(relativeLayout, nativeResponse, viewBinder);
 
         assertThat(extrasTextView.getText()).isEqualTo("extrastexttext");
-        assertThat(shadowOf(ImageViewServiceTest.getBitmapFromImageView(extrasImageView))
-                .getCreatedFromBytes()).isEqualTo("extrasimagedata".getBytes());
-        assertThat(shadowOf(ImageViewServiceTest.getBitmapFromImageView(extrasImageView2))
-                .getCreatedFromBytes()).isEqualTo("extrasimagedata2".getBytes());
+
+        verify(mockImageLoader).get(eq("extrasimageurl"), mainImageCaptor.capture());
+        verify(mockImageLoader).get(eq("extrasimageurl2"), iconImageCaptor.capture());
+
+        stub(mockImageContainer.getBitmap()).toReturn(mockBitmap);
+        mainImageCaptor.getValue().onResponse(mockImageContainer, true);
+        iconImageCaptor.getValue().onResponse(mockImageContainer, true);
+
+        assertThat(((BitmapDrawable) extrasImageView.getDrawable()).getBitmap()).isEqualTo(mockBitmap);
+        assertThat(((BitmapDrawable) extrasImageView2.getDrawable()).getBitmap()).isEqualTo(mockBitmap);
     }
 
     @Test
@@ -295,8 +329,8 @@ public void updateExtras_withMissingExtrasValues_shouldClearPreviousValues() thr
         extrasImageView.setImageBitmap(BitmapFactory.decodeByteArray("previousextrasimagedata".getBytes(), 0, "previousextrasimagedata".getBytes().length));
         extrasImageView2.setImageBitmap(BitmapFactory.decodeByteArray("previousextrasimagedata2".getBytes(), 0, "previousextrasimagedata2".getBytes().length));
 
-        final DownloadResponse downloadResponse = new DownloadResponse(new TestHttpResponseWithHeaders(200, ""));
-        nativeResponse = new NativeResponse(context, downloadResponse, "adunit_id", new BaseForwardingNativeAd(){}, null);
+        nativeResponse = new NativeResponse(context,
+                IMPRESSION_URL, CLICK_URL, AD_UNIT_ID, new BaseForwardingNativeAd(){}, null);
 
         viewBinder = new ViewBinder.Builder(relativeLayout.getId())
                 .addExtra("extrastext", extrasTextView.getId())
@@ -308,10 +342,6 @@ public void updateExtras_withMissingExtrasValues_shouldClearPreviousValues() thr
                 NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
 
         assertThat(extrasTextView.getText()).isEqualTo("previousextrastext");
-        assertThat(shadowOf(ImageViewServiceTest.getBitmapFromImageView(extrasImageView))
-                .getCreatedFromBytes()).isEqualTo("previousextrasimagedata".getBytes());
-        assertThat(shadowOf(ImageViewServiceTest.getBitmapFromImageView(extrasImageView2))
-                .getCreatedFromBytes()).isEqualTo("previousextrasimagedata2".getBytes());
 
         nativeViewHolder.updateExtras(relativeLayout, nativeResponse, viewBinder);
 
@@ -326,8 +356,8 @@ public void updateExtras_withMismatchingViewTypes_shouldSetTextViewToImageUrlAnd
         nativeAd.addExtra("extrastext", "extrastexttext");
         nativeAd.addExtra("extrasimage", "extrasimageurl");
 
-        final DownloadResponse downloadResponse = new DownloadResponse(new TestHttpResponseWithHeaders(200, ""));
-        nativeResponse = new NativeResponse(context, downloadResponse, "adunit_id", nativeAd, null);
+        nativeResponse = new NativeResponse(context,
+                IMPRESSION_URL, CLICK_URL, AD_UNIT_ID, nativeAd, null);
 
         viewBinder = new ViewBinder.Builder(relativeLayout.getId())
                 .addExtra("extrastext", extrasImageView.getId())
@@ -342,12 +372,12 @@ public void updateExtras_withMismatchingViewTypes_shouldSetTextViewToImageUrlAnd
 
         nativeViewHolder.updateExtras(relativeLayout, nativeResponse, viewBinder);
 
+        // Volley's imageloader will set this to a bitmapdrawable with no bitmap
         assertThat(extrasTextView.getText()).isEqualTo("extrasimageurl");
         assertThat(extrasImageView.getDrawable()).isNull();
     }
 
-    @Test
-    public void fromViewBinder_withMixedViewTypes_shouldReturnNull() throws Exception {
+    public void fromViewBinder_withMixedViewTypes_shouldReturnEmptyViewHolder() throws Exception {
         viewBinder = new ViewBinder.Builder(relativeLayout.getId())
                 .titleId(mainImageView.getId())
                 .textId(textView.getId())
@@ -355,7 +385,6 @@ public void fromViewBinder_withMixedViewTypes_shouldReturnNull() throws Exceptio
 
         NativeViewHolder nativeViewHolder =
                 NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
-
-        assertThat(nativeViewHolder).isNull();
+        assertThat(nativeViewHolder).isEqualTo(NativeViewHolder.EMPTY_VIEW_HOLDER);
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/PositioningRequestTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/PositioningRequestTest.java
new file mode 100644
index 00000000..c67dd6cf
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/PositioningRequestTest.java
@@ -0,0 +1,144 @@
+package com.mopub.nativeads;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.network.MoPubNetworkError;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.Response;
+import com.mopub.volley.VolleyError;
+
+import org.json.JSONException;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+
+import java.util.TreeMap;
+
+import static junit.framework.Assert.fail;
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+public class PositioningRequestTest {
+
+    String url = "http://example.com";
+    @Mock
+    Response.Listener<MoPubNativeAdPositioning.MoPubClientPositioning> mockListener;
+    @Mock
+    Response.ErrorListener mockErrorListener;
+
+    NetworkResponse mockNetworkResponse;
+    PositioningRequest subject;
+
+    @Before
+    public void setup() {
+        subject = new PositioningRequest(url, mockListener, mockErrorListener);
+    }
+
+    @Test
+    public void parseNetworkResponse_shouldReturnPositioning() {
+        mockNetworkResponse = new NetworkResponse(200, "{fixed: []}".getBytes(), new TreeMap<String, String>(), false);
+        assertThat(subject.parseNetworkResponse(mockNetworkResponse).result)
+                .isExactlyInstanceOf(MoPubNativeAdPositioning.MoPubClientPositioning.class);
+    }
+    
+    @Test
+    public void parseNetworkResponse_shouldReturnError() {
+        mockNetworkResponse = new NetworkResponse(200, "garbage".getBytes(), new TreeMap<String, String>(), false);
+        assertThat(subject.parseNetworkResponse(mockNetworkResponse).error)
+                .isExactlyInstanceOf(VolleyError.class);
+    }
+    
+    @Test
+    public void parseJson_noFixedPositions_shouldReturnEmptyPositioning() throws Exception {
+        MoPubNativeAdPositioning.MoPubClientPositioning positioning = subject.parseJson(
+                "{fixed: []}");
+        assertThat(positioning.getFixedPositions()).isEmpty();
+        assertThat(positioning.getRepeatingInterval()).isEqualTo(MoPubNativeAdPositioning.MoPubClientPositioning.NO_REPEAT);
+    }
+
+    @Test
+    public void parseJson_oneFixedPosition_shouldReturnValidPositioning() throws Exception {
+        MoPubNativeAdPositioning.MoPubClientPositioning positioning = subject.parseJson(
+                "{fixed: [{position: 2}]}");
+        assertThat(positioning.getFixedPositions()).containsOnly(2);
+        assertThat(positioning.getRepeatingInterval()).isEqualTo(MoPubNativeAdPositioning.MoPubClientPositioning.NO_REPEAT);
+    }
+
+    @Test
+    public void parseJson_twoFixedPositions_shouldReturnValidPositioning() throws Exception {
+        MoPubNativeAdPositioning.MoPubClientPositioning positioning = subject.parseJson(
+                "{fixed: [{position: 1}, {position: 8}]}");
+        assertThat(positioning.getFixedPositions()).containsExactly(1, 8);
+        assertThat(positioning.getRepeatingInterval()).isEqualTo(MoPubNativeAdPositioning.MoPubClientPositioning.NO_REPEAT);
+    }
+
+    @Test
+    public void parseJson_twoFixedPositions_shouldIgnoreNonZeroSection() throws Exception {
+        MoPubNativeAdPositioning.MoPubClientPositioning positioning = subject.parseJson(
+                "{fixed: [{section: 0, position: 5}, {section: 1, position: 8}]}");
+        assertThat(positioning.getFixedPositions()).containsOnly(5);
+        assertThat(positioning.getRepeatingInterval()).isEqualTo(MoPubNativeAdPositioning.MoPubClientPositioning.NO_REPEAT);
+    }
+
+    @Test
+    public void parseJson_invalidFixedPosition_shouldThrowException() throws Exception {
+        // Must have either fixed or repeating positions.
+        checkException("", "Empty response");
+        checkException("{}", "Must contain fixed or repeating positions");
+        checkException("{\"error\":\"WARMING_UP\"}", "WARMING_UP");
+
+        // Position is required.
+        checkException("{fixed: [{}]}", "JSONObject[\"position\"] not found.");
+        checkException("{fixed: [{section: 0}]}", "JSONObject[\"position\"] not found.");
+
+        // Section is optional, but if it exists must be > 0
+        checkException("{fixed: [{section: -1, position: 8}]}", "Invalid section -1 in JSON response");
+
+        // Positions must be between [0 and 2 ^ 16).
+        checkException("{fixed: [{position: -1}]}", "Invalid position -1 in JSON response");
+        checkException("{fixed: [{position: 1}, {position: -8}]}",
+                "Invalid position -8 in JSON response");
+        checkException("{fixed: [{position: 1}, {position: 66000}]}",
+                "Invalid position 66000 in JSON response");
+    }
+
+    @Test
+    public void parseJson_repeatingInterval_shouldReturnValidPositioning() throws Exception {
+        MoPubNativeAdPositioning.MoPubClientPositioning positioning = subject.parseJson(
+                "{repeating: {interval: 2}}");
+        assertThat(positioning.getFixedPositions()).isEmpty();
+        assertThat(positioning.getRepeatingInterval()).isEqualTo(2);
+    }
+
+    @Test
+    public void parseJson_invalidRepeating_shouldThrowException() throws Exception {
+        checkException("{repeating: }", "Missing value at character 12");
+        checkException("{repeating: {}}", "JSONObject[\"interval\"] not found.");
+
+        // Intervals must be between [2 and 2 ^ 16).
+        checkException("{repeating: {interval: -1}}", "Invalid interval -1 in JSON response");
+        checkException("{repeating: {interval: 0}}", "Invalid interval 0 in JSON response");
+        checkException("{repeating: {interval: 1}}", "Invalid interval 1 in JSON response");
+        checkException("{repeating: {interval: 66000}}",
+                "Invalid interval 66000 in JSON response");
+    }
+
+    @Test
+    public void parseJson_fixedAndRepeating_shouldReturnValidPositioning() throws Exception {
+        MoPubNativeAdPositioning.MoPubClientPositioning positioning = subject.parseJson(
+                "{fixed: [{position: 0}, {position: 1}], repeating: {interval: 2}}");
+        assertThat(positioning.getFixedPositions()).containsExactly(0, 1);
+        assertThat(positioning.getRepeatingInterval()).isEqualTo(2);
+    }
+
+    private void checkException(String json, String expectedMessage) throws Exception {
+        try {
+            subject.parseJson(json);
+        } catch (JSONException e) {
+            return;
+        } catch (MoPubNetworkError e) {
+            return;
+        }
+        fail("Should have received an exception");
+    }
+}
\ No newline at end of file
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/ServerPositioningSourceTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/ServerPositioningSourceTest.java
index 2930217b..49ce986e 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/ServerPositioningSourceTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/ServerPositioningSourceTest.java
@@ -4,16 +4,17 @@
 import android.os.Build.VERSION_CODES;
 
 import com.mopub.common.DownloadResponse;
-import com.mopub.common.DownloadTask;
-import com.mopub.common.DownloadTask.DownloadTaskListener;
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.MoPubErrorCode;
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
 import com.mopub.nativeads.PositioningSource.PositioningListener;
-import com.mopub.nativeads.ServerPositioningSource.DownloadTaskProvider;
+import com.mopub.network.MoPubRequestQueue;
+import com.mopub.network.Networking;
+import com.mopub.volley.NoConnectionError;
+import com.mopub.volley.Request;
+import com.mopub.volley.VolleyError;
 
 import org.apache.http.HttpStatus;
-import org.apache.http.client.methods.HttpGet;
-import org.json.JSONException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -22,29 +23,33 @@
 import org.mockito.Mock;
 import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLog;
 
-import java.util.concurrent.Executor;
+import java.util.List;
+import java.util.logging.Level;
+import java.util.logging.LogManager;
 
-import static junit.framework.Assert.fail;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyBoolean;
+import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 @RunWith(SdkTestRunner.class)
 public class ServerPositioningSourceTest {
-    @Mock DownloadTaskProvider mockDownloadTaskProvider;
-    @Mock DownloadTaskListener mockDownloadTaskListener;
-    @Mock DownloadTask mockDownloadTask;
     @Mock PositioningListener mockPositioningListener;
-    @Captor ArgumentCaptor<DownloadTaskListener> taskListenerCaptor;
+    @Captor ArgumentCaptor<PositioningRequest> positionRequestCaptor;
     @Mock DownloadResponse mockValidResponse;
     @Mock DownloadResponse mockNotFoundResponse;
     @Mock DownloadResponse mockInvalidJsonResponse;
     @Mock DownloadResponse mockWarmingUpJsonResponse;
+
+    @Mock
+    MoPubRequestQueue mockRequestQueue;
+
     @Captor ArgumentCaptor<MoPubClientPositioning> positioningCaptor;
 
     ServerPositioningSource subject;
@@ -52,10 +57,9 @@
     @Before
     public void setUp() {
         Activity activity = Robolectric.buildActivity(Activity.class).create().get();
-        subject = new ServerPositioningSource(activity, mockDownloadTaskProvider);
+        subject = new ServerPositioningSource(activity);
 
-        when(mockDownloadTaskProvider.get(any(DownloadTaskListener.class)))
-                .thenReturn(mockDownloadTask);
+        Networking.setRequestQueueForTesting(mockRequestQueue);
 
         when(mockValidResponse.getStatusCode()).thenReturn(HttpStatus.SC_OK);
         when(mockValidResponse.getByteArray()).thenReturn("{fixed: []}".getBytes());
@@ -70,106 +74,73 @@ public void setUp() {
         when(mockNotFoundResponse.getStatusCode()).thenReturn(HttpStatus.SC_NOT_FOUND);
     }
 
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
-    @Test
-    public void loadPositions_atLeastIcs_shouldExecuteDownloadTask() {
-        subject.loadPositions("test_ad_unit", mockPositioningListener);
-        verify(mockDownloadTask).executeOnExecutor(any(Executor.class), any(HttpGet.class));
-    }
-
-    @Config(reportSdk = VERSION_CODES.GINGERBREAD_MR1)
     @Test
-    public void loadPositions_beforeIcs_shouldExecuteDownloadTask() {
+    public void loadPositions_shouldAddToRequestQueue() {
         subject.loadPositions("test_ad_unit", mockPositioningListener);
-        verify(mockDownloadTask).execute(any(HttpGet.class));
+        verify(mockRequestQueue).add(any(Request.class));
     }
 
     @Test
-    public void loadPositionsTwice_shouldCancelPreviousDownloadTask_shouldNotCallListener() {
+    public void loadPositionsTwice_shouldCancelPreviousRequest_shouldNotCallListener() {
         subject.loadPositions("test_ad_unit", mockPositioningListener);
-        verify(mockDownloadTaskProvider).get(taskListenerCaptor.capture());
-
         subject.loadPositions("test_ad_unit", mockPositioningListener);
-        verify(mockDownloadTask).cancel(true);
+        verify(mockRequestQueue, times(2)).add(any(Request.class));
 
-        // Cancelling completes the download tasks with a null response.
-        taskListenerCaptor.getValue().onComplete("some_url", null);
         verify(mockPositioningListener, never()).onFailed();
         verify(mockPositioningListener, never()).onLoad(any(MoPubClientPositioning.class));
     }
 
     @Test
-    public void loadPositionsTwice_withPendingRetry_shouldNotCancelPreviousDownloadTask() {
+    public void loadPositionsTwice_afterSuccess_shouldNotCancelPreviousRequest() {
         subject.loadPositions("test_ad_unit", mockPositioningListener);
-
-        verify(mockDownloadTaskProvider).get(taskListenerCaptor.capture());
-        taskListenerCaptor.getValue().onComplete("some_url", mockValidResponse);
+        verify(mockRequestQueue).add(positionRequestCaptor.capture());
+        reset(mockRequestQueue);
 
         subject.loadPositions("test_ad_unit", mockPositioningListener);
-        verify(mockDownloadTask, never()).cancel(anyBoolean());
+        verify(mockRequestQueue).add(any(Request.class));
     }
 
     @Test
     public void loadPositions_thenComplete_withValidResponse_shouldCallOnLoadListener() {
         subject.loadPositions("test_ad_unit", mockPositioningListener);
 
-        verify(mockDownloadTaskProvider).get(taskListenerCaptor.capture());
-        taskListenerCaptor.getValue().onComplete("some_url", mockValidResponse);
+        verify(mockRequestQueue).add(positionRequestCaptor.capture());
 
-        verify(mockPositioningListener).onLoad(positioningCaptor.capture());
-        MoPubClientPositioning positioning = positioningCaptor.getValue();
-        assertThat(positioning.getFixedPositions()).isEmpty();
-        assertThat(positioning.getRepeatingInterval()).isEqualTo(MoPubClientPositioning.NO_REPEAT);
-    }
-
-    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
-    @Test
-    public void loadPositions_thenComplete_withNotFoundResponse_shouldRetry() {
-        subject.loadPositions("test_ad_unit", mockPositioningListener);
-        
-        verify(mockDownloadTaskProvider).get(taskListenerCaptor.capture());
-        taskListenerCaptor.getValue().onComplete("some_url", mockNotFoundResponse);
+        final PositioningRequest value = positionRequestCaptor.getValue();
+        final MoPubClientPositioning response = new MoPubClientPositioning().enableRepeatingPositions(3);
+        value.deliverResponse(response);
 
-        Robolectric.getUiThreadScheduler().advanceToLastPostedRunnable();
-        verify(mockDownloadTask, times(2))
-                .executeOnExecutor(any(Executor.class), any(HttpGet.class));
+        verify(mockPositioningListener).onLoad(eq(response));
     }
 
+    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
-    public void loadPositions_thenComplete_withWarmingUpResponse_shouldRetry() {
+    public void loadPositions_thenComplete_withErrorResponse_shouldRetry() throws Exception {
         subject.loadPositions("test_ad_unit", mockPositioningListener);
 
-        verify(mockDownloadTaskProvider).get(taskListenerCaptor.capture());
-        taskListenerCaptor.getValue().onComplete("some_url", mockWarmingUpJsonResponse);
+        verify(mockRequestQueue).add(positionRequestCaptor.capture());
+        reset(mockRequestQueue);
+        // We get VolleyErrors for invalid JSON, 404s, 5xx, and {"error": "WARMING_UP"}
+        positionRequestCaptor.getValue().deliverError(new VolleyError("Some test error"));
 
         Robolectric.getUiThreadScheduler().advanceToLastPostedRunnable();
-        verify(mockDownloadTask, times(2))
-                .executeOnExecutor(any(Executor.class), any(HttpGet.class));
+        verify(mockRequestQueue).add(any(Request.class));
     }
 
-    @Test
-    public void loadPositions_thenComplete_withInvalidJsonResponse_shouldRetry() {
-        subject.loadPositions("test_ad_unit", mockPositioningListener);
-
-        verify(mockDownloadTaskProvider).get(taskListenerCaptor.capture());
-        taskListenerCaptor.getValue().onComplete("some_url", mockInvalidJsonResponse);
-
-        Robolectric.getUiThreadScheduler().advanceToLastPostedRunnable();
-        verify(mockDownloadTask, times(2))
-                .executeOnExecutor(any(Executor.class), any(HttpGet.class));
-    }
 
+    @Config(reportSdk = VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
     public void loadPositions_withPendingRetry_shouldNotRetry() {
         subject.loadPositions("test_ad_unit", mockPositioningListener);
 
-        verify(mockDownloadTaskProvider).get(taskListenerCaptor.capture());
-        taskListenerCaptor.getValue().onComplete("some_url", mockInvalidJsonResponse);
+        verify(mockRequestQueue).add(positionRequestCaptor.capture());
+        reset(mockRequestQueue);
+        positionRequestCaptor.getValue().deliverError(new VolleyError("testError"));
 
         subject.loadPositions("test_ad_unit", mockPositioningListener);
         Robolectric.getUiThreadScheduler().advanceToLastPostedRunnable();
-        verify(mockDownloadTask, times(2))
-                .executeOnExecutor(any(Executor.class), any(HttpGet.class));
+        // If a retry happened, we'd have two here.
+        verify(mockRequestQueue).add(any(Request.class));
     }
 
     @Test
@@ -178,110 +149,24 @@ public void loadPositions_thenFailAfterMaxRetryTime_shouldCallFailureHandler() {
 
         subject.loadPositions("test_ad_unit", mockPositioningListener);
 
-        verify(mockDownloadTaskProvider).get(taskListenerCaptor.capture());
-        taskListenerCaptor.getValue().onComplete("some_url", mockInvalidJsonResponse);
-
-        Robolectric.getUiThreadScheduler().advanceToLastPostedRunnable();
+        verify(mockRequestQueue).add(positionRequestCaptor.capture());
+        positionRequestCaptor.getValue().deliverError(new VolleyError("test error"));
         verify(mockPositioningListener).onFailed();
     }
 
     @Test
-    public void parseJsonResponse_noFixedPositions_shouldReturnEmptyPositioning()
-            throws JSONException {
-        MoPubClientPositioning positioning = subject.parseJsonResponse(
-                "{fixed: []}");
-        assertThat(positioning.getFixedPositions()).isEmpty();
-        assertThat(positioning.getRepeatingInterval()).isEqualTo(MoPubClientPositioning.NO_REPEAT);
-    }
-
-    @Test
-    public void parseJsonResponse_oneFixedPosition_shouldReturnValidPositioning()
-            throws JSONException {
-        MoPubClientPositioning positioning = subject.parseJsonResponse(
-                "{fixed: [{position: 2}]}");
-        assertThat(positioning.getFixedPositions()).containsOnly(2);
-        assertThat(positioning.getRepeatingInterval()).isEqualTo(MoPubClientPositioning.NO_REPEAT);
-    }
-
-    @Test
-    public void parseJsonResponse_twoFixedPositions_shouldReturnValidPositioning()
-            throws JSONException {
-        MoPubClientPositioning positioning = subject.parseJsonResponse(
-                "{fixed: [{position: 1}, {position: 8}]}");
-        assertThat(positioning.getFixedPositions()).containsExactly(1, 8);
-        assertThat(positioning.getRepeatingInterval()).isEqualTo(MoPubClientPositioning.NO_REPEAT);
-    }
-
-    @Test
-    public void parseJsonResponse_twoFixedPositions_shouldIgnoreNonZeroSection()
-            throws JSONException {
-        MoPubClientPositioning positioning = subject.parseJsonResponse(
-                "{fixed: [{section: 0, position: 5}, {section: 1, position: 8}]}");
-        assertThat(positioning.getFixedPositions()).containsOnly(5);
-        assertThat(positioning.getRepeatingInterval()).isEqualTo(MoPubClientPositioning.NO_REPEAT);
-    }
+    public void loadPositions_withNoConnection_shouldLogMoPubErrorCodeNoConnection_shouldCallFailureHandler() {
+        LogManager.getLogManager().getLogger("com.mopub").setLevel(Level.ALL);
 
-    @Test
-    public void parseJsonResponse_invalidFixedPosition_shouldThrowException() {
-        // Must have either fixed or repeating positions.
-        checkException(null, "Empty response");
-        checkException("", "Empty response");
-        checkException("{}", "Must contain fixed or repeating positions");
-        checkException("{\"error\":\"WARMING_UP\"}", "WARMING_UP");
-
-        // Position is required.
-        checkException("{fixed: [{}]}", "JSONObject[\"position\"] not found.");
-        checkException("{fixed: [{section: 0}]}", "JSONObject[\"position\"] not found.");
-
-        // Section is optional, but if it exists must be > 0
-        checkException("{fixed: [{section: -1, position: 8}]}", "Invalid section -1 in JSON response");
-
-        // Positions must be between [0 and 2 ^ 16).
-        checkException("{fixed: [{position: -1}]}", "Invalid position -1 in JSON response");
-        checkException("{fixed: [{position: 1}, {position: -8}]}",
-                "Invalid position -8 in JSON response");
-        checkException("{fixed: [{position: 1}, {position: 66000}]}",
-                "Invalid position 66000 in JSON response");
-    }
-
-    @Test
-    public void parseJsonResponse_repeatingInterval_shouldReturnValidPositioning()
-            throws JSONException {
-        MoPubClientPositioning positioning = subject.parseJsonResponse(
-                "{repeating: {interval: 2}}");
-        assertThat(positioning.getFixedPositions()).isEmpty();
-        assertThat(positioning.getRepeatingInterval()).isEqualTo(2);
-    }
-
-    @Test
-    public void parseJsonResponse_invalidRepeating_shouldThrowException() {
-        checkException("{repeating: }", "Missing value at character 12");
-        checkException("{repeating: {}}", "JSONObject[\"interval\"] not found.");
-
-        // Intervals must be between [2 and 2 ^ 16).
-        checkException("{repeating: {interval: -1}}", "Invalid interval -1 in JSON response");
-        checkException("{repeating: {interval: 0}}", "Invalid interval 0 in JSON response");
-        checkException("{repeating: {interval: 1}}", "Invalid interval 1 in JSON response");
-        checkException("{repeating: {interval: 66000}}",
-                "Invalid interval 66000 in JSON response");
-    }
+        subject.loadPositions("test_ad_unit", mockPositioningListener);
 
-    @Test
-    public void parseJsonResponse_fixedAndRepeating_shouldReturnValidPositioning()
-            throws JSONException {
-        MoPubClientPositioning positioning = subject.parseJsonResponse(
-                "{fixed: [{position: 0}, {position: 1}], repeating: {interval: 2}}");
-        assertThat(positioning.getFixedPositions()).containsExactly(0, 1);
-        assertThat(positioning.getRepeatingInterval()).isEqualTo(2);
-    }
+        verify(mockRequestQueue).add(positionRequestCaptor.capture());
+        positionRequestCaptor.getValue().deliverError(new NoConnectionError());
+        verify(mockPositioningListener).onFailed();
 
-    private void checkException(String json, String expectedMessage) {
-        try {
-            subject.parseJsonResponse(json);
-        } catch (JSONException e) {
-            assertThat(e.getMessage()).isEqualTo(expectedMessage);
-            return;
-        }
-        fail("Should have received an exception");
+        final List<ShadowLog.LogItem> allLogMessages = ShadowLog.getLogs();
+        final ShadowLog.LogItem latestLogMessage = allLogMessages.get(allLogMessages.size() - 2);
+        // All log messages end with a newline character.
+        assertThat(latestLogMessage.msg.trim()).isEqualTo(MoPubErrorCode.NO_CONNECTION.toString());
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/test/support/MoPubShadowDisplay.java b/mopub-sdk/src/test/java/com/mopub/nativeads/test/support/MoPubShadowDisplay.java
index 9b38d956..47ab9573 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/test/support/MoPubShadowDisplay.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/test/support/MoPubShadowDisplay.java
@@ -2,7 +2,9 @@
 
 import android.graphics.Point;
 import android.view.Display;
+import android.view.Surface;
 
+import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.shadows.ShadowDisplay;
 
@@ -13,4 +15,15 @@
     public void getSize(Point size) {
         size.set(getWidth(), getHeight());
     }
+
+    private static int sRotation = Surface.ROTATION_0;
+
+    @Implementation
+    public int getRotation() {
+        return sRotation;
+    }
+
+    public static void setStaticRotation(int rotation) {
+        sRotation = rotation;
+    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/test/support/TestCustomEventNativeFactory.java b/mopub-sdk/src/test/java/com/mopub/nativeads/test/support/TestCustomEventNativeFactory.java
index 3132f10d..f8122bb9 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/test/support/TestCustomEventNativeFactory.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/test/support/TestCustomEventNativeFactory.java
@@ -1,5 +1,7 @@
 package com.mopub.nativeads.test.support;
 
+import android.support.annotation.NonNull;
+
 import com.mopub.nativeads.CustomEventNative;
 import com.mopub.nativeads.factories.CustomEventNativeFactory;
 
@@ -17,7 +19,7 @@ private static TestCustomEventNativeFactory getTestFactory() {
     }
 
     @Override
-    protected CustomEventNative internalCreate(final Class<? extends CustomEventNative> nativeClass) {
+    protected CustomEventNative internalCreate(@NonNull final Class<? extends CustomEventNative> nativeClass) {
         return instance;
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/network/AdRequestTest.java b/mopub-sdk/src/test/java/com/mopub/network/AdRequestTest.java
new file mode 100644
index 00000000..08b25a5a
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/network/AdRequestTest.java
@@ -0,0 +1,362 @@
+package com.mopub.network;
+
+import android.app.Activity;
+import android.location.Location;
+
+import com.mopub.common.AdFormat;
+import com.mopub.common.AdType;
+import com.mopub.common.DataKeys;
+import com.mopub.common.event.BaseEvent;
+import com.mopub.common.event.EventDispatcher;
+import com.mopub.common.event.MoPubEvents;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.ResponseHeader;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.Response;
+
+import org.json.JSONException;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
+
+import java.nio.charset.Charset;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
+import java.util.TreeMap;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class AdRequestTest {
+
+    @Mock private AdRequest.Listener mockListener;
+    @Mock private AdResponse mockAdResponse;
+    @Mock private EventDispatcher mockEventDispatcher;
+
+    private AdRequest subject;
+    private HashMap<String, String> defaultHeaders;
+    private Activity activity;
+    private String adUnitId;
+
+    @Before
+    public void setup() {
+        activity = Robolectric.buildActivity(Activity.class).create().get();
+        adUnitId = "testAdUnitId";
+        subject = new AdRequest("testUrl", AdFormat.NATIVE, adUnitId, activity, mockListener);
+        defaultHeaders = new HashMap<String, String>();
+        defaultHeaders.put(ResponseHeader.SCROLLABLE.getKey(), "0");
+        defaultHeaders.put(ResponseHeader.REDIRECT_URL.getKey(), "redirect");
+        defaultHeaders.put(ResponseHeader.CLICK_TRACKING_URL.getKey(), "click_tracking");
+        defaultHeaders.put(ResponseHeader.IMPRESSION_URL.getKey(), "impression");
+        defaultHeaders.put(ResponseHeader.FAIL_URL.getKey(), "fail_url");
+        defaultHeaders.put(ResponseHeader.REFRESH_TIME.getKey(), "30");
+
+        MoPubEvents.setEventDispatcher(mockEventDispatcher);
+    }
+
+    @After
+    public void teardown() {
+        MoPubEvents.setEventDispatcher(null);
+    }
+
+    @Test
+    public void parseNetworkResponse_stringBody_shouldSucceed() throws Exception {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.HTML);
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        assertThat(response.result).isNotNull();
+        assertThat(response.result.getStringBody()).isEqualTo("abc");
+    }
+
+    @Test
+    public void parseNetworkResponse_withStringBody_shouldLogScribeEvent() throws Exception {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.HTML);
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        subject.parseNetworkResponse(testResponse);
+
+        verify(mockEventDispatcher).dispatch(any(BaseEvent.class));
+    }
+
+    @Test
+    public void parseNetworkResponse_withServerExtrasInResponseBody_shouldSucceed() throws Exception {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.HTML);
+        defaultHeaders.put(ResponseHeader.FULL_AD_TYPE.getKey(), "anything");
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        // Check the server extras
+        final Map<String, String> serverExtras = response.result.getServerExtras();
+        assertThat(serverExtras).isNotNull();
+        assertThat(serverExtras).isNotEmpty();
+        assertThat(serverExtras.get(DataKeys.SCROLLABLE_KEY)).isEqualToIgnoringCase("false");
+        assertThat(serverExtras.get(DataKeys.REDIRECT_URL_KEY)).isEqualToIgnoringCase("redirect");
+        assertThat(serverExtras.get(DataKeys.CLICKTHROUGH_URL_KEY)).isEqualToIgnoringCase("click_tracking");
+    }
+
+    @Test
+    public void parseNetworkResponse_nonJsonStringBodyForNative_jsonParseShouldFail() {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.NATIVE);
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        assertThat(response.error).isNotNull();
+        assertThat(response.error).isExactlyInstanceOf(MoPubNetworkError.class);
+        assertThat(((MoPubNetworkError) response.error).getReason()).isEqualTo(MoPubNetworkError.Reason.BAD_BODY);
+    }
+
+    @Test
+    public void parseNetworkResponse_nonJsonStringBodyForNative_shouldNotLogScribeEvent() {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.NATIVE);
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        subject.parseNetworkResponse(testResponse);
+
+        verify(mockEventDispatcher, never()).dispatch(any(BaseEvent.class));
+    }
+
+    @Test
+    public void parseNetworkResponse_withWarmupHeaderTrue_shouldError() {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.NATIVE);
+        defaultHeaders.put(ResponseHeader.WARMUP.getKey(), "1");
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        assertThat(response.error).isNotNull();
+        assertThat(response.error).isInstanceOf(MoPubNetworkError.class);
+        assertThat(((MoPubNetworkError) response.error).getReason()).isEqualTo(MoPubNetworkError.Reason.WARMING_UP);
+    }
+
+    @Test
+    public void parseNetworkResponse_withWarmupHeaderTrue_shouldNotLogScribeEvent() {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.NATIVE);
+        defaultHeaders.put(ResponseHeader.WARMUP.getKey(), "1");
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        subject.parseNetworkResponse(testResponse);
+
+        verify(mockEventDispatcher, never()).dispatch(any(BaseEvent.class));
+    }
+
+    @Test
+    public void parseNetworkResponse_withRefreshTime_shouldIncludeRefreshTimeInResult() {
+        defaultHeaders.put(ResponseHeader.REFRESH_TIME.getKey(), "13");
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+        assertThat(response.result.getRefreshTimeMillis()).isEqualTo(13000);
+    }
+
+    @Test
+    public void parseNetworkResponse_withoutRefreshTime_shouldNotIncludeRefreshTime() {
+        defaultHeaders.remove(ResponseHeader.REFRESH_TIME.getKey());
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+        assertThat(response.result.getRefreshTimeMillis()).isNull();
+    }
+    
+    @Test
+    public void parseNetworkResponse_withClearAdType_withRefreshTimeHeader_shouldErrorAndIncludeRefreshTime() {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.CLEAR);
+
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        assertThat(response.error).isNotNull();
+        assertThat(response.error).isInstanceOf(MoPubNetworkError.class);
+        final MoPubNetworkError moPubNetworkError = (MoPubNetworkError) response.error;
+        assertThat(moPubNetworkError.getReason()).isEqualTo(MoPubNetworkError.Reason.NO_FILL);
+        assertThat(moPubNetworkError.getRefreshTimeMillis()).isEqualTo(30000);
+    }
+
+    @Test
+    public void parseNetworkResponse_withClearAdType_withNoRefreshTimeHeader_shouldErrorAndNotIncludeRefreshTime() {
+        defaultHeaders.remove(ResponseHeader.REFRESH_TIME.getKey());
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.CLEAR);
+
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        assertThat(response.error).isNotNull();
+        assertThat(response.error).isInstanceOf(MoPubNetworkError.class);
+        final MoPubNetworkError moPubNetworkError = (MoPubNetworkError) response.error;
+        assertThat(moPubNetworkError.getReason()).isEqualTo(MoPubNetworkError.Reason.NO_FILL);
+        assertThat(moPubNetworkError.getRefreshTimeMillis()).isNull();
+    }
+
+    @Test
+    public void parseNetworkResponse_withClearAdType_shouldLogScribeEvent() {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.CLEAR);
+
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+        subject.parseNetworkResponse(testResponse);
+
+        verify(mockEventDispatcher).dispatch(any(BaseEvent.class));
+    }
+
+    @Test
+    public void parseNetworkResponse_withBadJSON_shouldReturnError() {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.NATIVE);
+        NetworkResponse badNativeNetworkResponse = new NetworkResponse(200,
+                "{[abc}".getBytes(Charset.defaultCharset()),
+                defaultHeaders, false);
+        subject = new AdRequest("testUrl", AdFormat.NATIVE, "testAdUnitId", activity, mockListener);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(badNativeNetworkResponse);
+
+        assertThat(response.error).isNotNull();
+        assertThat(response.error.getCause()).isExactlyInstanceOf(JSONException.class);
+    }
+
+    @Test
+    public void deliverResponse_shouldCallListenerOnSuccess() throws Exception {
+        subject.deliverResponse(mockAdResponse);
+        verify(mockListener).onSuccess(mockAdResponse);
+    }
+
+    @Test
+    public void getRequestId_shouldParseAndReturnRequestIdFromFailUrl() throws Exception {
+        String requestId = subject.getRequestId("http://ads.mopub.com/m/ad?id=8cf00598d3664adaaeccd800e46afaca&exclude=043fde1fe2f9470c9aa67fec262a0596&request_id=7fd6dd3bf1c84f87876b4740c1dd7baa&fail=1");
+
+        assertThat(requestId).isEqualTo("7fd6dd3bf1c84f87876b4740c1dd7baa");
+    }
+
+    @Test
+    public void getRequestId_withNullFailUrl_shouldReturnNull() throws Exception {
+        assertThat(subject.getRequestId(null)).isNull();
+    }
+
+    @Test
+    public void getRequestId_withUrlWithNoRequestIdParam_shouldReturnNull() throws Exception {
+        assertThat(subject.getRequestId("http://ads.mopub.com/m/ad?id=8cf00598d3664adaaeccd800e46afaca")).isNull();
+    }
+
+    @Test
+    public void getHeaders_withDefaultLocale_shouldReturnDefaultLanguageCode() throws Exception {
+        Map<String, String> expectedHeaders = new TreeMap<String, String>();
+        expectedHeaders.put(ResponseHeader.ACCEPT_LANGUAGE.getKey(), "en");
+
+        assertThat(subject.getHeaders()).isEqualTo(expectedHeaders);
+    }
+
+    @Test
+    public void getHeaders_withUserPreferredLocale_shouldReturnUserPreferredLanguageCode() throws Exception {
+        Map<String, String> expectedHeaders = new TreeMap<String, String>();
+        expectedHeaders.put(ResponseHeader.ACCEPT_LANGUAGE.getKey(), "fr");
+
+        // Assume user-preferred locale is fr_CA
+        activity.getResources().getConfiguration().locale = Locale.CANADA_FRENCH;
+
+        assertThat(subject.getHeaders()).isEqualTo(expectedHeaders);
+    }
+
+    @Test
+    public void getHeaders_withUserPreferredLocaleAsNull_shouldReturnDefaultLanguageCode() throws Exception {
+        Map<String, String> expectedHeaders = new TreeMap<String, String>();
+        expectedHeaders.put(ResponseHeader.ACCEPT_LANGUAGE.getKey(), "en");
+
+        // Assume user-preferred locale is null
+        activity.getResources().getConfiguration().locale = null;
+
+        assertThat(subject.getHeaders()).isEqualTo(expectedHeaders);
+    }
+
+    @Test
+    public void getHeaders_withUserPreferredLanguageAsEmptyString_shouldReturnDefaultLanguageCode() throws Exception {
+        Map<String, String> expectedHeaders = new TreeMap<String, String>();
+        expectedHeaders.put(ResponseHeader.ACCEPT_LANGUAGE.getKey(), "en");
+
+        // Assume user-preferred locale's language code is empty string after trimming
+        activity.getResources().getConfiguration().locale = new Locale(" ");
+
+        assertThat(subject.getHeaders()).isEqualTo(expectedHeaders);
+    }
+
+    @Test
+    public void getHeaders_withLocaleLanguageAsEmptyString_shouldNotAddLanguageHeader() throws Exception {
+        Map<String, String> expectedHeaders = Collections.emptyMap();
+
+        // Assume default locale's language code is empty string
+        Locale.setDefault(new Locale(""));
+
+        // Assume user-preferred locale's language code is empty string after trimming
+        activity.getResources().getConfiguration().locale = new Locale(" ");
+
+        assertThat(subject.getHeaders()).isEqualTo(expectedHeaders);
+    }
+
+    @Test
+    public void logScribeEvent_shouldLogEvent() throws Exception {
+        AdResponse mockAdResponse = mock(AdResponse.class);
+        when(mockAdResponse.getDspCreativeId()).thenReturn("dsp_creative_id");
+        when(mockAdResponse.getAdType()).thenReturn("html");
+        when(mockAdResponse.getNetworkType()).thenReturn("network_type");
+        when(mockAdResponse.getWidth()).thenReturn(320);
+        when(mockAdResponse.getHeight()).thenReturn(50);
+        when(mockAdResponse.getRequestId()).thenReturn("ac298c522b0e412b85ff81e4b9b51f03");
+
+        NetworkResponse networkResponse = new NetworkResponse(200, null, null, false, 300);
+
+        Location mockLocation = mock(Location.class);
+        when(mockLocation.getLatitude()).thenReturn(37.7833);
+        when(mockLocation.getLongitude()).thenReturn(-122.4167);
+        when(mockLocation.getAccuracy()).thenReturn((float) 2000.0);
+
+        doAnswer(new Answer() {
+            @Override
+            public Object answer(InvocationOnMock invocation) throws Throwable {
+                Object[] args = invocation.getArguments();
+                BaseEvent baseEvent = (BaseEvent) args[0];
+                assertThat(baseEvent.getName()).isEqualTo(BaseEvent.Name.AD_REQUEST);
+                assertThat(baseEvent.getCategory()).isEqualTo(BaseEvent.Category.REQUESTS);
+                assertThat(baseEvent.getSamplingRate()).isEqualTo(0.1);
+                assertThat(baseEvent.getAdUnitId()).isEqualTo(adUnitId);
+                assertThat(baseEvent.getAdCreativeId()).isEqualTo("dsp_creative_id");
+                assertThat(baseEvent.getAdType()).isEqualTo("html");
+                assertThat(baseEvent.getAdNetworkType()).isEqualTo("network_type");
+                assertThat(baseEvent.getAdWidthPx()).isEqualTo(320);
+                assertThat(baseEvent.getAdHeightPx()).isEqualTo(50);
+                assertThat(baseEvent.getGeoLat()).isEqualTo(37.7833);
+                assertThat(baseEvent.getGeoLon()).isEqualTo(-122.4167);
+                assertThat(baseEvent.getGeoAccuracy()).isEqualTo(2000.0);
+                assertThat(baseEvent.getPerformanceDurationMs()).isEqualTo(300);
+                assertThat(baseEvent.getRequestId()).isEqualTo("ac298c522b0e412b85ff81e4b9b51f03");
+                assertThat(baseEvent.getRequestStatusCode()).isEqualTo(200);
+                assertThat(baseEvent.getRequestUri()).isEqualTo("testUrl");
+                return null;
+            }
+        }).when(mockEventDispatcher).dispatch(any(BaseEvent.class));
+
+        subject.logScribeEvent(mockAdResponse, networkResponse, mockLocation);
+
+        verify(mockEventDispatcher).dispatch(any(BaseEvent.class));
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/HttpResponsesTest.java b/mopub-sdk/src/test/java/com/mopub/network/HeaderUtilsTest.java
similarity index 59%
rename from mopub-sdk/src/test/java/com/mopub/mobileads/util/HttpResponsesTest.java
rename to mopub-sdk/src/test/java/com/mopub/network/HeaderUtilsTest.java
index 54981b2e..f91576ec 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/util/HttpResponsesTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/network/HeaderUtilsTest.java
@@ -1,4 +1,4 @@
-package com.mopub.mobileads.util;
+package com.mopub.network;
 
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
@@ -12,7 +12,7 @@
 import static org.fest.assertions.api.Assertions.assertThat;
 
 @RunWith(SdkTestRunner.class)
-public class HttpResponsesTest {
+public class HeaderUtilsTest {
     private TestHttpResponseWithHeaders response;
 
     @Before
@@ -23,71 +23,71 @@ public void setup() {
     @Test
     public void extractBooleanHeader_whenValueIsZero_shouldReturnFalse() throws Exception {
         response.addHeader(SCROLLABLE.getKey(), "0");
-        assertThat(HttpResponses.extractBooleanHeader(response, SCROLLABLE, false)).isFalse();
+        assertThat(HeaderUtils.extractBooleanHeader(response, SCROLLABLE, false)).isFalse();
 
         response.addHeader(SCROLLABLE.getKey(), "0");
-        assertThat(HttpResponses.extractBooleanHeader(response, SCROLLABLE, true)).isFalse();
+        assertThat(HeaderUtils.extractBooleanHeader(response, SCROLLABLE, true)).isFalse();
     }
 
     @Test
     public void extractBooleanHeader_whenValueIsOne_shouldReturnTrue() throws Exception {
         response.addHeader(SCROLLABLE.getKey(), "1");
-        assertThat(HttpResponses.extractBooleanHeader(response, SCROLLABLE, false)).isTrue();
+        assertThat(HeaderUtils.extractBooleanHeader(response, SCROLLABLE, false)).isTrue();
 
         response.addHeader(SCROLLABLE.getKey(), "1");
-        assertThat(HttpResponses.extractBooleanHeader(response, SCROLLABLE, true)).isTrue();
+        assertThat(HeaderUtils.extractBooleanHeader(response, SCROLLABLE, true)).isTrue();
     }
 
     @Test
     public void extractBooleanHeader_shouldReturnDefaultValue() throws Exception {
         // no header added to response
 
-        assertThat(HttpResponses.extractBooleanHeader(response, SCROLLABLE, false)).isFalse();
-        assertThat(HttpResponses.extractBooleanHeader(response, SCROLLABLE, true)).isTrue();
+        assertThat(HeaderUtils.extractBooleanHeader(response, SCROLLABLE, false)).isFalse();
+        assertThat(HeaderUtils.extractBooleanHeader(response, SCROLLABLE, true)).isTrue();
     }
 
     @Test
     public void extractIntegerHeader_shouldReturnIntegerValue() throws Exception {
         response.addHeader(AD_TIMEOUT.getKey(), "10");
-        assertThat(HttpResponses.extractIntegerHeader(response, AD_TIMEOUT)).isEqualTo(10);
+        assertThat(HeaderUtils.extractIntegerHeader(response, AD_TIMEOUT)).isEqualTo(10);
 
         response.addHeader(AD_TIMEOUT.getKey(), "0");
-        assertThat(HttpResponses.extractIntegerHeader(response, AD_TIMEOUT)).isEqualTo(0);
+        assertThat(HeaderUtils.extractIntegerHeader(response, AD_TIMEOUT)).isEqualTo(0);
 
         response.addHeader(AD_TIMEOUT.getKey(), "-2");
-        assertThat(HttpResponses.extractIntegerHeader(response, AD_TIMEOUT)).isEqualTo(-2);
+        assertThat(HeaderUtils.extractIntegerHeader(response, AD_TIMEOUT)).isEqualTo(-2);
     }
 
     @Test
     public void extractIntegerHeader_withDoubleValue_shouldTruncateValue() throws Exception {
         response.addHeader(AD_TIMEOUT.getKey(), "3.14");
-        assertThat(HttpResponses.extractIntegerHeader(response, AD_TIMEOUT)).isEqualTo(3);
+        assertThat(HeaderUtils.extractIntegerHeader(response, AD_TIMEOUT)).isEqualTo(3);
 
         response.addHeader(AD_TIMEOUT.getKey(), "-3.14");
-        assertThat(HttpResponses.extractIntegerHeader(response, AD_TIMEOUT)).isEqualTo(-3);
+        assertThat(HeaderUtils.extractIntegerHeader(response, AD_TIMEOUT)).isEqualTo(-3);
     }
 
     @Test
     public void extractIntegerHeader_whenNoHeaderPresent_shouldReturnNull() throws Exception {
         // no header added to response
-        assertThat(HttpResponses.extractIntegerHeader(response, AD_TIMEOUT)).isNull();
+        assertThat(HeaderUtils.extractIntegerHeader(response, AD_TIMEOUT)).isNull();
 
         response.addHeader(AD_TIMEOUT.getKey(), null);
-        assertThat(HttpResponses.extractIntegerHeader(response, AD_TIMEOUT)).isNull();
+        assertThat(HeaderUtils.extractIntegerHeader(response, AD_TIMEOUT)).isNull();
     }
 
     @Test
     public void extractIntegerHeader_withNonsenseStringValue_shouldReturnNull() throws Exception {
         response.addHeader(AD_TIMEOUT.getKey(), "llama!!guy");
-        assertThat(HttpResponses.extractIntegerHeader(response, AD_TIMEOUT)).isNull();
+        assertThat(HeaderUtils.extractIntegerHeader(response, AD_TIMEOUT)).isNull();
     }
 
     @Test
     public void extractIntHeader_withInvalidHeader_shouldUseDefaultValue() throws Exception {
         response.addHeader(AD_TIMEOUT.getKey(), "5");
-        assertThat(HttpResponses.extractIntHeader(response, AD_TIMEOUT, 10)).isEqualTo(5);
+        assertThat(HeaderUtils.extractIntHeader(response, AD_TIMEOUT, 10)).isEqualTo(5);
 
         response.addHeader(AD_TIMEOUT.getKey(), "five!");
-        assertThat(HttpResponses.extractIntHeader(response, AD_TIMEOUT, 10)).isEqualTo(10);
+        assertThat(HeaderUtils.extractIntHeader(response, AD_TIMEOUT, 10)).isEqualTo(10);
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/network/MoPubRequestQueueTest.java b/mopub-sdk/src/test/java/com/mopub/network/MoPubRequestQueueTest.java
new file mode 100644
index 00000000..441ed4c2
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/network/MoPubRequestQueueTest.java
@@ -0,0 +1,203 @@
+package com.mopub.network;
+
+import android.app.Activity;
+import android.os.Handler;
+
+import com.mopub.common.ClientMetadata;
+import com.mopub.common.Constants;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.DeviceUtils;
+import com.mopub.volley.Cache;
+import com.mopub.volley.Network;
+import com.mopub.volley.Request;
+import com.mopub.volley.RequestQueue;
+import com.mopub.volley.toolbox.BasicNetwork;
+import com.mopub.volley.toolbox.DiskBasedCache;
+import com.mopub.volley.toolbox.HttpStack;
+import com.mopub.volley.toolbox.HurlStack;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+
+import java.io.File;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class MoPubRequestQueueTest {
+
+    private MoPubRequestQueue subject;
+    private MoPubRequestQueue.DelayedRequestHelper delayedRequestHelper;
+    @Mock private ScribeRequest mockScribeRequest;
+    @Mock private MoPubRequestQueue.DelayedRequestHelper mockDelayedRequestHelper;
+    @Mock private Handler mockHandler;
+
+    @Before
+    public void setUp() {
+        // NOTE: It's possible to start a new test with a queue set from a previous test suite
+        // Make sure we get a fresh one
+        Networking.setRequestQueueForTesting(null);
+
+        Activity activity = Robolectric.buildActivity(Activity.class).create().get();
+
+        // Construct our dependencies & build the object
+        final ClientMetadata clientMetadata = ClientMetadata.getInstance(activity);
+        final HurlStack.UrlRewriter urlRewriter = new PlayServicesUrlRewriter(clientMetadata.getDeviceId(), activity);
+        // No Custom SSL Factory
+
+        final String userAgent = Networking.getUserAgent(activity.getApplicationContext());
+        HttpStack httpStack = new RequestQueueHttpStack(userAgent, urlRewriter);
+
+        Network network = new BasicNetwork(httpStack);
+        File volleyCacheDir = new File(activity.getCacheDir().getPath() + File.separator
+                + Networking.CACHE_DIRECTORY_NAME);
+        Cache cache = new DiskBasedCache(volleyCacheDir, (int) DeviceUtils.diskCacheSizeBytes(volleyCacheDir, Constants.TEN_MB));
+        subject = new MoPubRequestQueue(cache, network);
+        subject.start();
+
+        delayedRequestHelper = subject.new DelayedRequestHelper(mockScribeRequest, 100, mockHandler);
+    }
+
+    @After
+    public void tearDown() {
+        // NOTE: Make sure that we clear the queue after the last test in the test suite runs so
+        // that the next test suite starts fresh
+        Networking.setRequestQueueForTesting(null);
+    }
+
+    @Test
+    public void addDelayedRequest_shouldStartDelayedRequestHelper_shouldPutRequestInMap() throws Exception {
+        subject.addDelayedRequest(mockScribeRequest, mockDelayedRequestHelper);
+
+        verify(mockDelayedRequestHelper).start();
+        assertThat(subject.getDelayedRequests().get(mockScribeRequest)).isEqualTo(mockDelayedRequestHelper);
+        assertThat(subject.getDelayedRequests().entrySet()).hasSize(1);
+    }
+
+    @Test
+    public void addDelayedRequest_shouldCancelPreexistingRequest() throws Exception {
+        subject.addDelayedRequest(mockScribeRequest, mockDelayedRequestHelper);
+
+        verify(mockDelayedRequestHelper, never()).cancel();
+        verify(mockScribeRequest, never()).cancel();
+
+        subject.addDelayedRequest(mockScribeRequest, mockDelayedRequestHelper);
+
+        verify(mockDelayedRequestHelper).cancel();
+        verify(mockScribeRequest).cancel();
+    }
+
+    @Test
+    public void addDelayedRequest_withUniqueRequest_shouldNotCancelOtherRequests() throws Exception {
+        ScribeRequest mockScribeRequest2 = mock(ScribeRequest.class);
+        MoPubRequestQueue.DelayedRequestHelper mockDelayedRequestHelper2 = mock(MoPubRequestQueue.DelayedRequestHelper.class);
+        subject.addDelayedRequest(mockScribeRequest, mockDelayedRequestHelper);
+        subject.addDelayedRequest(mockScribeRequest2, mockDelayedRequestHelper2);
+
+        verify(mockDelayedRequestHelper, never()).cancel();
+        verify(mockScribeRequest, never()).cancel();
+
+        verify(mockDelayedRequestHelper2).start();
+        assertThat(subject.getDelayedRequests().get(mockScribeRequest)).isEqualTo(mockDelayedRequestHelper);
+        assertThat(subject.getDelayedRequests().get(mockScribeRequest2)).isEqualTo(mockDelayedRequestHelper2);
+        assertThat(subject.getDelayedRequests().entrySet()).hasSize(2);
+    }
+
+    @Test
+    public void cancelAll_shouldCancelAllRequestsInTheDelayedRequestMapThatPassTheFilter() throws Exception {
+        ScribeRequest mockScribeRequest2 = mock(ScribeRequest.class);
+        MoPubRequestQueue.DelayedRequestHelper mockDelayedRequestHelper2 = mock(MoPubRequestQueue.DelayedRequestHelper.class);
+        subject.addDelayedRequest(mockScribeRequest, mockDelayedRequestHelper);
+        subject.addDelayedRequest(mockScribeRequest2, mockDelayedRequestHelper2);
+
+
+        subject.cancelAll(new RequestQueue.RequestFilter() {
+            @Override
+            public boolean apply(Request<?> request) {
+                return request == mockScribeRequest;
+            }
+        });
+
+        verify(mockDelayedRequestHelper).cancel();
+        verify(mockScribeRequest).cancel();
+
+        verify(mockDelayedRequestHelper2, never()).cancel();
+        verify(mockScribeRequest2, never()).cancel();
+
+        assertThat(subject.getDelayedRequests().entrySet()).hasSize(1);
+        assertThat(subject.getDelayedRequests().get(mockScribeRequest2)).isEqualTo(mockDelayedRequestHelper2);
+    }
+
+    @Test
+    public void cancelAll_shouldCancelAllRequestsWithMatchingObjectTag() throws Exception {
+        ScribeRequest mockScribeRequest2 = mock(ScribeRequest.class);
+        MoPubRequestQueue.DelayedRequestHelper mockDelayedRequestHelper2 = mock(MoPubRequestQueue.DelayedRequestHelper.class);
+        subject.addDelayedRequest(mockScribeRequest, mockDelayedRequestHelper);
+        subject.addDelayedRequest(mockScribeRequest2, mockDelayedRequestHelper2);
+
+        when(mockScribeRequest.getTag()).thenReturn(1);
+        when(mockScribeRequest2.getTag()).thenReturn(2);
+
+        subject.cancelAll(1);
+
+        verify(mockDelayedRequestHelper).cancel();
+        verify(mockScribeRequest).cancel();
+
+        verify(mockDelayedRequestHelper2, never()).cancel();
+        verify(mockScribeRequest2, never()).cancel();
+
+        assertThat(subject.getDelayedRequests().entrySet()).hasSize(1);
+        assertThat(subject.getDelayedRequests().get(mockScribeRequest2)).isEqualTo(mockDelayedRequestHelper2);
+    }
+
+    @Test
+    public void cancel_shouldCancelMatchingRequest() throws Exception {
+        ScribeRequest mockScribeRequest2 = mock(ScribeRequest.class);
+        MoPubRequestQueue.DelayedRequestHelper mockDelayedRequestHelper2 = mock(MoPubRequestQueue.DelayedRequestHelper.class);
+        subject.addDelayedRequest(mockScribeRequest, mockDelayedRequestHelper);
+        subject.addDelayedRequest(mockScribeRequest2, mockDelayedRequestHelper2);
+
+        subject.cancel(mockScribeRequest);
+
+        verify(mockDelayedRequestHelper).cancel();
+        verify(mockScribeRequest).cancel();
+
+        verify(mockDelayedRequestHelper2, never()).cancel();
+        verify(mockScribeRequest2, never()).cancel();
+
+        assertThat(subject.getDelayedRequests().entrySet()).hasSize(1);
+        assertThat(subject.getDelayedRequests().get(mockScribeRequest2)).isEqualTo(mockDelayedRequestHelper2);
+    }
+    
+    @Test
+    public void DelayedRequestHelper_start_shouldPostDelayedRunnable() throws Exception {
+        delayedRequestHelper.start();
+        verify(mockHandler).postDelayed(delayedRequestHelper.mDelayedRunnable, 100);
+    }
+
+    @Test
+    public void DelayedRequestHelper_cancel_shouldCancelDelayedRunnable() throws Exception {
+        delayedRequestHelper.cancel();
+        verify(mockHandler).removeCallbacks(delayedRequestHelper.mDelayedRunnable);
+    }
+
+    @Test
+    public void DelayedRequestHelper_Runnable_run_shouldRemoveRequestFromDelayedRequestsMap_shouldAddRequestToQueue() throws Exception {
+        subject.addDelayedRequest(mockScribeRequest, 100);
+        assertThat(subject.getDelayedRequests().entrySet().size()).isEqualTo(1);
+        MoPubRequestQueue.DelayedRequestHelper delayedRequestHelper = subject.getDelayedRequests().get(mockScribeRequest);
+
+        delayedRequestHelper.mDelayedRunnable.run();
+
+        assertThat(subject.getDelayedRequests().entrySet()).isEmpty();
+        verify(mockScribeRequest).setRequestQueue(subject);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/network/NetworkingTest.java b/mopub-sdk/src/test/java/com/mopub/network/NetworkingTest.java
new file mode 100644
index 00000000..2013dcde
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/network/NetworkingTest.java
@@ -0,0 +1,69 @@
+package com.mopub.network;
+
+import android.app.Activity;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+
+import java.util.concurrent.Semaphore;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+public class NetworkingTest {
+    private Activity context;
+    static String sUserAgent;
+
+    @Before
+    public void setUp() {
+        context = Robolectric.buildActivity(Activity.class).create().get();
+    }
+
+    @After
+    public void tearDown() {
+        Networking.clearForTesting();
+        sUserAgent = null;
+    }
+
+    @Test
+    public void getUserAgent_usesCachedUserAgent() {
+        Networking.setUserAgentForTesting("some cached user agent");
+        String userAgent = Networking.getUserAgent(context);
+
+        assertThat(userAgent).isEqualTo("some cached user agent");
+    }
+
+    @Test
+    public void getUserAgent_fromMainThread_shouldIncludeAndroid() throws InterruptedException {
+        context.runOnUiThread(new Runnable() {
+            @Override
+            public void run() {
+                String userAgent = Networking.getUserAgent(context);
+                assertThat(userAgent).containsIgnoringCase("android");
+            }
+        });
+    }
+
+    @Test
+    public void getUserAgent_fromBackgroundThread_shouldIncludeAndroid() throws InterruptedException {
+        System.setProperty("http.agent", "system level user agent");
+
+        final Semaphore semaphore = new Semaphore(0);
+
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                sUserAgent = Networking.getUserAgent(context);
+                semaphore.release();
+            }
+        }).start();
+
+        semaphore.acquire();
+        assertThat(sUserAgent).isEqualTo("system level user agent");
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/network/PlayServicesUrlRewriterTest.java b/mopub-sdk/src/test/java/com/mopub/network/PlayServicesUrlRewriterTest.java
new file mode 100644
index 00000000..a5225b99
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/network/PlayServicesUrlRewriterTest.java
@@ -0,0 +1,68 @@
+package com.mopub.network;
+
+import android.app.Activity;
+import android.content.Context;
+
+import com.mopub.common.GpsHelper;
+import com.mopub.common.GpsHelperTest;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.Reflection;
+import com.mopub.common.util.test.support.TestMethodBuilderFactory;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class PlayServicesUrlRewriterTest {
+
+    private Reflection.MethodBuilder methodBuilder;
+    private PlayServicesUrlRewriter subject;
+
+    @Before
+    public void setUp() throws Exception {
+        Context context = Robolectric.buildActivity(Activity.class).create().get();
+        GpsHelper.setClassNamesForTesting();
+        methodBuilder = TestMethodBuilderFactory.getSingletonMock();
+        reset(methodBuilder);
+        subject = new PlayServicesUrlRewriter("sha:testDeviceID", context);
+    }
+
+    @Test
+    public void rewriteUrl_whenPlayServicesPresent_shouldUsePlayServicesValue() throws Exception {
+        GpsHelperTest.TestAdInfo adInfo = new GpsHelperTest.TestAdInfo();
+        when(methodBuilder.setStatic(any(Class.class))).thenReturn(methodBuilder);
+        when(methodBuilder.addParam(any(Class.class), any())).thenReturn(methodBuilder);
+        when(methodBuilder.execute()).thenReturn(
+                GpsHelper.GOOGLE_PLAY_SUCCESS_CODE,
+                adInfo,
+                adInfo.ADVERTISING_ID,
+                adInfo.LIMIT_AD_TRACKING_ENABLED
+        );
+
+        assertThat(subject.rewriteUrl("http://ads.mopub.com/m/ad?ad_id=abcece&udid=mp_tmpl_advertising_id&dnt=mp_tmpl_do_not_track"))
+                .isEqualToIgnoringCase("http://ads.mopub.com/m/ad?ad_id=abcece&udid=ifa%3A38400000-8cf0-11bd-b23e-10b96e40000d&dnt=1");
+    }
+
+    @Test
+    public void rewriteUrl_whenPlayServicesNotPresent_shouldUseDeviceValue() throws Exception {
+        when(methodBuilder.setStatic(any(Class.class))).thenReturn(methodBuilder);
+        when(methodBuilder.addParam(any(Class.class), any())).thenReturn(methodBuilder);
+        // return error code so it fails
+        when(methodBuilder.execute()).thenReturn(GpsHelper.GOOGLE_PLAY_SUCCESS_CODE + 1);
+
+        assertThat(subject.rewriteUrl("http://ads.mopub.com/m/ad?ad_id=abcece&udid=mp_tmpl_advertising_id&dnt=mp_tmpl_do_not_track"))
+                .isEqualToIgnoringCase("http://ads.mopub.com/m/ad?ad_id=abcece&udid=sha%3AtestDeviceId&dnt=0");
+    }
+
+    @Test
+    public void rewriteUrl_noTemplates_shouldReturnIdentical() throws Exception {
+        assertThat(subject.rewriteUrl("http://ads.mopub.com/m/ad")).isEqualTo("http://ads.mopub.com/m/ad");
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/network/RequestManagerTest.java b/mopub-sdk/src/test/java/com/mopub/network/RequestManagerTest.java
new file mode 100644
index 00000000..8cadcfaf
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/network/RequestManagerTest.java
@@ -0,0 +1,138 @@
+package com.mopub.network;
+
+import android.os.Looper;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.volley.Request;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class RequestManagerTest {
+
+    private ScribeRequestManager subject;
+    @Mock private ScribeRequest.ScribeRequestFactory mockScribeRequestFactory;
+    @Mock private ScribeBackoffPolicy mockScribeBackoffPolicy;
+    @Mock private ScribeRequest mockScribeRequest;
+    @Mock private MoPubRequestQueue mockRequestQueue;
+
+    @Before
+    public void setUp() {
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+
+        subject = new ScribeRequestManager(Looper.getMainLooper());
+        when(mockScribeRequestFactory.createRequest(subject)).thenReturn(mockScribeRequest);
+    }
+
+    @Test
+    public void makeRequest_shouldAddRequestToQueue() throws Exception {
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+
+        verify(mockRequestQueue).add(mockScribeRequest);
+    }
+
+
+    @Test
+    public void makeRequest_shouldCancelTheCurrentRequest() throws Exception {
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+        Request<?> request = subject.getCurrentRequest();
+
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+
+        verify(mockRequestQueue).cancel(request);
+    }
+
+    @Test
+    public void cancelRequest_shouldCancelRequestInQueue_shouldClearRequest() throws Exception {
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+        subject.cancelRequest();
+
+        verify(mockRequestQueue).cancel(mockScribeRequest);
+        assertThat(subject.getCurrentRequest()).isNull();
+    }
+
+    @Test
+    public void cancelRequest_withNullRequestQueue_shouldOnlyClearCurrentRequest() throws Exception {
+        Networking.setRequestQueueForTesting(null);
+
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+        subject.cancelRequest();
+
+        verify(mockRequestQueue, never()).cancel(mockScribeRequest);
+        assertThat(subject.getCurrentRequest()).isNull();
+    }
+
+    @Test
+    public void cancelRequest_withNullCurrentRequest_shouldOnlyClearCurrentRequest() throws Exception {
+        subject.cancelRequest();
+
+        verify(mockRequestQueue, never()).cancel(mockScribeRequest);
+        assertThat(subject.getCurrentRequest()).isNull();
+    }
+
+    @Test
+    public void makeRequestInternal_shouldAddNewRequestToQueue() throws Exception {
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+        reset(mockRequestQueue);
+
+        ScribeRequest previousRequest = (ScribeRequest) subject.getCurrentRequest();
+        ScribeRequest nextRequest = mock(ScribeRequest.class);
+        when(mockScribeRequestFactory.createRequest(subject)).thenReturn(nextRequest);
+
+        subject.makeRequestInternal();
+
+        verify(mockRequestQueue).add(nextRequest);
+        verify(mockRequestQueue, never()).addDelayedRequest(any(Request.class), anyInt());
+        assertThat(previousRequest).isNotEqualTo(nextRequest);
+    }
+
+    @Test
+    public void makeRequestInternal_withRetryCountGreaterThan0_shouldAddNewDelayedRequestToQueue() throws Exception {
+        when(mockScribeBackoffPolicy.getRetryCount()).thenReturn(1);
+        when(mockScribeBackoffPolicy.getBackoffMs()).thenReturn(100);
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+        reset(mockRequestQueue);
+
+        ScribeRequest previousRequest = (ScribeRequest) subject.getCurrentRequest();
+        ScribeRequest nextRequest = mock(ScribeRequest.class);
+        when(mockScribeRequestFactory.createRequest(subject)).thenReturn(nextRequest);
+
+        subject.makeRequestInternal();
+
+        verify(mockRequestQueue).addDelayedRequest(nextRequest, 100);
+        verify(mockRequestQueue, never()).add(any(Request.class));
+        assertThat(previousRequest).isNotEqualTo(nextRequest);
+    }
+
+    @Test
+    public void makeRequestInternal_withNullRequestQueue_shouldClearCurrentRequest_shouldNotAddRequestToQueue() throws Exception {
+        Networking.setRequestQueueForTesting(null);
+
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+
+        verify(mockRequestQueue, never()).add(any(Request.class));
+        verify(mockRequestQueue, never()).addDelayedRequest(any(Request.class), anyInt());
+        assertThat(subject.getCurrentRequest()).isNull();
+    }
+
+    @Test
+    public void clearRequest_shouldSetCurrentRequestToNull() throws Exception {
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+        assertThat(subject.getCurrentRequest()).isNotNull();
+        subject.clearRequest();
+        assertThat(subject.getCurrentRequest()).isNull();
+    }
+}
+
diff --git a/mopub-sdk/src/test/java/com/mopub/network/ScribeBackoffPolicyTest.java b/mopub-sdk/src/test/java/com/mopub/network/ScribeBackoffPolicyTest.java
new file mode 100644
index 00000000..56a07c86
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/network/ScribeBackoffPolicyTest.java
@@ -0,0 +1,129 @@
+package com.mopub.network;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.NoConnectionError;
+import com.mopub.volley.VolleyError;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.fest.assertions.api.Assertions.fail;
+
+@RunWith(SdkTestRunner.class)
+public class ScribeBackoffPolicyTest {
+
+    private ScribeBackoffPolicy subject;
+
+    @Before
+    public void setUp() {
+        subject = new ScribeBackoffPolicy();
+    }
+
+    @Test
+    public void backoff_with503Error_shouldUpdateBackoffTime() throws Exception {
+        NetworkResponse networkResponse = new NetworkResponse(503, null, null, false);
+        VolleyError volleyError = new VolleyError(networkResponse);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(0);
+        assertThat(subject.getRetryCount()).isEqualTo(0);
+
+        subject.backoff(volleyError);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(60000);
+        assertThat(subject.getRetryCount()).isEqualTo(1);
+    }
+
+    @Test
+    public void backoff_with504Error_shouldUpdateBackoffTime() throws Exception {
+        NetworkResponse networkResponse = new NetworkResponse(504, null, null, false);
+        VolleyError volleyError = new VolleyError(networkResponse);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(0);
+        assertThat(subject.getRetryCount()).isEqualTo(0);
+
+        subject.backoff(volleyError);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(60000);
+        assertThat(subject.getRetryCount()).isEqualTo(1);
+    }
+
+    @Test
+    public void backoff_withNoConnectionError_shouldUpdateBackoffTime() throws Exception {
+        VolleyError volleyError = new NoConnectionError();
+
+        assertThat(subject.getBackoffMs()).isEqualTo(0);
+        assertThat(subject.getRetryCount()).isEqualTo(0);
+
+        subject.backoff(volleyError);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(60000);
+        assertThat(subject.getRetryCount()).isEqualTo(1);
+    }
+
+    @Test(expected = VolleyError.class)
+    public void backoff_withOtherErrorType_shouldRethrowException() throws Exception {
+        NetworkResponse networkResponse = new NetworkResponse(500, null, null, false);
+        VolleyError volleyError = new VolleyError(networkResponse);
+
+        subject.backoff(volleyError);
+    }
+
+    @Test
+    public void backoff_shouldUpdateBackoffTime5TimesMax() throws Exception {
+        VolleyError volleyError = new NoConnectionError();
+
+        assertThat(subject.getBackoffMs()).isEqualTo(0);
+        assertThat(subject.getRetryCount()).isEqualTo(0);
+        assertThat(subject.hasAttemptRemaining()).isTrue();
+
+        subject.backoff(volleyError);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(60000);
+        assertThat(subject.getRetryCount()).isEqualTo(1);
+        assertThat(subject.hasAttemptRemaining()).isTrue();
+
+        subject.backoff(volleyError);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(120000);
+        assertThat(subject.getRetryCount()).isEqualTo(2);
+        assertThat(subject.hasAttemptRemaining()).isTrue();
+
+        subject.backoff(volleyError);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(240000);
+        assertThat(subject.getRetryCount()).isEqualTo(3);
+        assertThat(subject.hasAttemptRemaining()).isTrue();
+
+        subject.backoff(volleyError);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(480000);
+        assertThat(subject.getRetryCount()).isEqualTo(4);
+        assertThat(subject.hasAttemptRemaining()).isTrue();
+
+        subject.backoff(volleyError);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(960000);
+        assertThat(subject.getRetryCount()).isEqualTo(5);
+        assertThat(subject.hasAttemptRemaining()).isFalse();
+    }
+
+    @Test(expected = NoConnectionError.class)
+    public void backoff_withNoAttemptsRemaining_shouldRethrowVolleyException() throws Exception {
+        VolleyError volleyError = new NoConnectionError();
+
+        try {
+            subject.backoff(volleyError);
+            subject.backoff(volleyError);
+            subject.backoff(volleyError);
+            subject.backoff(volleyError);
+            subject.backoff(volleyError);
+        } catch (Exception e) {
+            fail("Exception should not be thrown from above backoffs.");
+        }
+
+        subject.backoff(volleyError);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/network/ScribeRequestManagerTest.java b/mopub-sdk/src/test/java/com/mopub/network/ScribeRequestManagerTest.java
new file mode 100644
index 00000000..854b26a8
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/network/ScribeRequestManagerTest.java
@@ -0,0 +1,77 @@
+package com.mopub.network;
+
+import android.os.Looper;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.volley.NoConnectionError;
+import com.mopub.volley.Request;
+import com.mopub.volley.VolleyError;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class ScribeRequestManagerTest {
+
+    private ScribeRequestManager subject;
+    @Mock private ScribeRequest.ScribeRequestFactory mockScribeRequestFactory;
+    @Mock private ScribeBackoffPolicy mockScribeBackoffPolicy;
+    @Mock private ScribeRequest mockScribeRequest;
+    @Mock private MoPubRequestQueue mockRequestQueue;
+
+    @Before
+    public void setUp() {
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+
+        subject = new ScribeRequestManager(Looper.getMainLooper());
+        when(mockScribeRequestFactory.createRequest(subject)).thenReturn(mockScribeRequest);
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+    }
+
+    @Test
+    public void createRequest_shouldCreateNewScribeRequest() throws Exception {
+        Request request = subject.createRequest();
+        assertThat(request).isEqualTo(mockScribeRequest);
+    }
+
+    @Test
+    public void onResponse_shouldClearRequest() throws Exception {
+        subject.onResponse();
+        assertThat(subject.getCurrentRequest()).isNull();
+    }
+
+    @Test
+    public void onErrorResponse_withBackoffApplied_shouldCallBackoff_shouldMakeDelayedRequest() throws Exception {
+        when(mockScribeBackoffPolicy.getRetryCount()).thenReturn(1);
+        when(mockScribeBackoffPolicy.getBackoffMs()).thenReturn(100);
+
+        VolleyError volleyError = new NoConnectionError();
+        subject.onErrorResponse(volleyError);
+
+        verify(mockScribeBackoffPolicy).backoff(volleyError);
+        verify(mockRequestQueue).addDelayedRequest(mockScribeRequest, 100);
+    }
+
+    @Test
+    public void onErrorResponse_withBackoffNotApplied_shouldClearRequest() throws Exception {
+        reset(mockRequestQueue);
+
+        VolleyError volleyError = new NoConnectionError();
+        doThrow(new VolleyError()).when(mockScribeBackoffPolicy).backoff(volleyError);
+
+        subject.onErrorResponse(volleyError);
+
+        verify(mockScribeBackoffPolicy).backoff(volleyError);
+        verify(mockRequestQueue, never()).add(mockScribeRequest);
+        assertThat(subject.getCurrentRequest()).isNull();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/network/ScribeRequestTest.java b/mopub-sdk/src/test/java/com/mopub/network/ScribeRequestTest.java
new file mode 100644
index 00000000..7bf2d5bb
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/network/ScribeRequestTest.java
@@ -0,0 +1,83 @@
+package com.mopub.network;
+
+import android.app.Activity;
+
+import com.mopub.common.event.BaseEvent;
+import com.mopub.common.event.EventSerializer;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.volley.DefaultRetryPolicy;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.Response;
+
+import org.json.JSONArray;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+
+import java.nio.charset.Charset;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class ScribeRequestTest {
+
+    private ScribeRequest subject;
+    @Mock private List<BaseEvent> mockEvents;
+    @Mock private EventSerializer mockEventSerializer;
+    @Mock private ScribeRequest.Listener mockListener;
+
+    @Before
+    public void setUp() {
+        Activity activity = Robolectric.buildActivity(Activity.class).create().get();
+        Networking.getRequestQueue(activity);
+
+        subject = new ScribeRequest("url", mockEvents, mockEventSerializer, mockListener);
+    }
+
+    @Test
+    public void constructor_shouldSetShouldCacheToFalse() throws Exception {
+        assertThat(subject.shouldCache()).isFalse();
+    }
+
+    @Test
+    public void constructor_shouldSetRetryPolicyToDefaultRetryPolicy() throws Exception {
+        assertThat(subject.getRetryPolicy()).isExactlyInstanceOf(DefaultRetryPolicy.class);
+    }
+
+    @Test
+    public void getParams_returnJsonSerializedEventsInMap() throws Exception {
+        JSONArray mockJsonArray = mock(JSONArray.class);
+        when(mockJsonArray.toString()).thenReturn("jsonArrayToString");
+        when(mockEventSerializer.serializeAsJson(mockEvents)).thenReturn(mockJsonArray);
+
+        Map<String, String> params = subject.getParams();
+
+        verify(mockEventSerializer).serializeAsJson(mockEvents);
+        assertThat(params.keySet().size()).isEqualTo(1);
+        assertThat(params.get("log")).isEqualTo("jsonArrayToString");
+    }
+    
+    @Test
+    public void parseNetworkResponse_shouldReturnSuccessResponse() throws Exception {
+        NetworkResponse networkResponse = new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), new HashMap<String, String>(), false);
+
+        Response<Void> response = subject.parseNetworkResponse(networkResponse);
+
+        assertThat(response.isSuccess()).isTrue();
+    }
+
+    @Test
+    public void deliverResponse_shouldNotifyListener() throws Exception {
+        subject.deliverResponse(null);
+
+        verify(mockListener).onResponse();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/network/TrackingRequestTest.java b/mopub-sdk/src/test/java/com/mopub/network/TrackingRequestTest.java
new file mode 100644
index 00000000..eb601572
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/network/TrackingRequestTest.java
@@ -0,0 +1,54 @@
+package com.mopub.network;
+
+import android.app.Activity;
+import android.content.Context;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+@RunWith(SdkTestRunner.class)
+public class TrackingRequestTest {
+
+    @Mock
+    private MoPubRequestQueue mockRequestQueue;
+    private Context context;
+    private String url;
+
+
+    @Before
+    public void setup() {
+        context = (Context) Robolectric.buildActivity(Activity.class).create().get();
+        url = "testUrl";
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+    }
+
+    @Test
+    public void makeTrackingHttpRequest_shouldMakeTrackingHttpRequestWithWebViewUserAgent() throws Exception {
+        TrackingRequest.makeTrackingHttpRequest(url, context);
+
+        verify(mockRequestQueue).add(any(TrackingRequest.class));
+    }
+
+    @Test
+    public void makeTrackingHttpRequest_withNullUrl_shouldNotMakeTrackingHttpRequest() throws Exception {
+        TrackingRequest.makeTrackingHttpRequest((String) null, context);
+
+        verify(mockRequestQueue, never()).add(any(TrackingRequest.class));
+    }
+
+    @Test
+    public void makeTrackingHttpRequest_withNullContext_shouldNotMakeTrackingHttpRequest() throws Exception {
+        TrackingRequest.makeTrackingHttpRequest(url, null);
+
+        verify(mockRequestQueue, never()).add(any(TrackingRequest.class));
+    }
+}
diff --git a/mopub-sdk/src/test/resources/org.robolectric.Config.properties b/mopub-sdk/src/test/resources/org.robolectric.Config.properties
new file mode 100644
index 00000000..dd670b09
--- /dev/null
+++ b/mopub-sdk/src/test/resources/org.robolectric.Config.properties
@@ -0,0 +1 @@
+shadows=com.mopub.nativeads.test.support.MoPubShadowDisplay,com.mopub.nativeads.test.support.MoPubShadowBitmap
\ No newline at end of file
diff --git a/pom.xml b/pom.xml
index 7d637a7c..be233e50 100644
--- a/pom.xml
+++ b/pom.xml
@@ -16,6 +16,12 @@
     <packaging>pom</packaging>
 
     <repositories>
+        <repository>
+            <id>jcenter</id>
+            <name>JCenter</name>
+            <url>http://jcenter.bintray.com</url>
+        </repository>
+
         <repository>
             <id>andsupport</id>
             <name>Android Support</name>
@@ -32,7 +38,5 @@
     <modules>
         <module>mopub-sdk</module>
         <module>mopub-sample</module>
-        <module>robotium-sample</module>
-        <module>robotium-tests</module>
     </modules>
-</project>
\ No newline at end of file
+</project>
diff --git a/robotium-sample/pom.xml b/robotium-sample/pom.xml
index 3481483f..468cbf9b 100644
--- a/robotium-sample/pom.xml
+++ b/robotium-sample/pom.xml
@@ -22,7 +22,7 @@
             <groupId>com.mopub.mobileads</groupId>
             <artifactId>mopub-sdk</artifactId>
             <version>1.0.0-SNAPSHOT</version>
-            <type>jar</type>
+            <type>aar</type>
         </dependency>
 
 
@@ -86,13 +86,15 @@
                 </configuration>
             </plugin>
             <plugin>
-                <groupId>com.jayway.maven.plugins.android.generation2</groupId>
+                <groupId>com.simpligility.maven.plugins</groupId>
                 <artifactId>android-maven-plugin</artifactId>
-                <version>3.8.2</version>
+                <version>4.2.0</version>
                 <configuration>
+                    <androidManifestFile>AndroidManifest.xml</androidManifestFile>
+                    <resourceDirectory>res</resourceDirectory>
                     <sdk>
                         <!-- platform or api level (api level 4 = platform 1.6)-->
-                        <platform>19</platform>
+                        <platform>22</platform>
                     </sdk>
                     <undeployBeforeDeploy>true</undeployBeforeDeploy>
                 </configuration>
diff --git a/robotium-tests/pom.xml b/robotium-tests/pom.xml
index c3710758..99a113ce 100644
--- a/robotium-tests/pom.xml
+++ b/robotium-tests/pom.xml
@@ -27,8 +27,8 @@
 
         <dependency>
             <groupId>com.google.android.gms</groupId>
-            <artifactId>play-services</artifactId>
-            <version>5.0.89</version>
+            <artifactId>play-services-ads</artifactId>
+            <version>7.0.0</version>
             <type>aar</type>
         </dependency>
 
@@ -62,17 +62,16 @@
                 </configuration>
             </plugin>
             <plugin>
-                <groupId>com.jayway.maven.plugins.android.generation2</groupId>
+                <groupId>com.simpligility.maven.plugins</groupId>
                 <artifactId>android-maven-plugin</artifactId>
-                <version>3.8.2</version>
+                <version>4.2.0</version>
                 <configuration>
+                    <androidManifestFile>AndroidManifest.xml</androidManifestFile>
+                    <resourceDirectory>res</resourceDirectory>
                     <sdk>
                         <!-- platform or api level (api level 4 = platform 1.6)-->
-                        <platform>19</platform>
+                        <platform>22</platform>
                     </sdk>
-                    <test>
-                        <skip>true</skip>
-                    </test>
                     <undeployBeforeDeploy>true</undeployBeforeDeploy>
                 </configuration>
                 <extensions>true</extensions>
