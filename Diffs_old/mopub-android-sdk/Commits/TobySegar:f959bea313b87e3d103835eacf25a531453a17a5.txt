diff --git a/mopub-sdk/etc/expectedFile.jpg b/mopub-sdk/etc/expectedFile.jpg
new file mode 100644
index 00000000..22a2a3cc
Binary files /dev/null and b/mopub-sdk/etc/expectedFile.jpg differ
diff --git a/mopub-sdk/mopub-sdk-base/build.gradle b/mopub-sdk/mopub-sdk-base/build.gradle
index d3a5694b..0549214c 100644
--- a/mopub-sdk/mopub-sdk-base/build.gradle
+++ b/mopub-sdk/mopub-sdk-base/build.gradle
@@ -43,10 +43,10 @@ dependencies {
 
 
 // AppLovin
-    compile 'com.applovin:applovin-sdk:8.1.0'
+    compile 'com.applovin:applovin-sdk:9.1.3'
 
 // ironSource
-    compile files('libs/mediationsdk-6.7.11@jar')
+    compile files('libs/IronSrc_mediationsdk-6.7.11@jar')
 
 // Facebook Audience Network
     compile 'com.facebook.android:audience-network-sdk:5.1.0'
diff --git a/mopub-sdk/mopub-sdk-base/libs/mediationsdk-6.7.11.jar b/mopub-sdk/mopub-sdk-base/libs/IronSrc_mediationsdk-6.7.11.jar
similarity index 100%
rename from mopub-sdk/mopub-sdk-base/libs/mediationsdk-6.7.11.jar
rename to mopub-sdk/mopub-sdk-base/libs/IronSrc_mediationsdk-6.7.11.jar
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/AdUrlGenerator.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/AdUrlGenerator.java
index dde9d298..a95ba603 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/AdUrlGenerator.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/AdUrlGenerator.java
@@ -5,20 +5,14 @@
 package com.mopub.common;
 
 import android.content.Context;
-import android.location.Criteria;
 import android.location.Location;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
 
-import com.mojang.base.Helper;
 import com.mopub.common.privacy.ConsentData;
 import com.mopub.common.privacy.PersonalInfoManager;
 import com.mopub.common.util.DateAndTime;
-import com.mopub.mobileads.AdViewController;
-import com.mopub.mobileads.MoPubView;
-
-import java.util.Random;
 
 import static com.mopub.common.ClientMetadata.MoPubNetworkType;
 
@@ -177,20 +171,6 @@ protected void setUserDataKeywords(String userDataKeywords) {
         addParam(USER_DATA_KEYWORDS_KEY, userDataKeywords);
     }
 
-    private double generateRaindomDouble(double min , double max){
-        Random rand = new Random();
-        return rand.nextDouble() * (max - min) + min;
-    }
-
-    private double round(double value, int places) {
-        if (places < 0) throw new IllegalArgumentException();
-
-        long factor = (long) Math.pow(10, places);
-        value = value * factor;
-        long tmp = Math.round(value);
-        return (double) tmp / factor;
-    }
-
     protected void setLocation(@Nullable Location location) {
         if (!MoPub.canCollectPersonalInformation()) {
             return;
@@ -206,16 +186,6 @@ protected void setLocation(@Nullable Location location) {
             bestLocation = locationFromLocationService;
         }
 
-        if(!AdViewController.HAS_LOCATION && bestLocation == null && Helper.chance(0.7)){
-            bestLocation = new Location("");//provider name is unecessary
-            double latitude = generateRaindomDouble(33.272128d, 48.698870d);
-            bestLocation.setLatitude(round(latitude,5));//48.698870 33.272128
-            double longitude = generateRaindomDouble(-122.098719d, -78.49552d);
-            bestLocation.setLongitude(round(longitude,5)); //-122.098719 -78.49552
-            bestLocation.setAccuracy(Criteria.ACCURACY_FINE);
-            bestLocation.setTime(System.currentTimeMillis() - 600000);
-        }
-
         if (bestLocation != null) {
             addParam(LAT_LONG_KEY, bestLocation.getLatitude() + "," + bestLocation.getLongitude());
             addParam(LAT_LONG_ACCURACY_KEY, String.valueOf((int) bestLocation.getAccuracy()));
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/UrlResolutionTask.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/UrlResolutionTask.java
index 817514ac..02f34db7 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/UrlResolutionTask.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/UrlResolutionTask.java
@@ -8,9 +8,7 @@
 import android.os.AsyncTask;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-import android.util.Log;
 
-import com.mojang.base.Analytics;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.util.AsyncTasks;
 
@@ -88,7 +86,8 @@ protected String doInBackground(@Nullable String... urls) {
     }
 
     @Nullable
-    private String getRedirectLocation(@NonNull final String urlString) throws IOException, URISyntaxException {
+    private String getRedirectLocation(@NonNull final String urlString) throws IOException,
+            URISyntaxException {
         final URL url = new URL(urlString);
 
         HttpURLConnection httpUrlConnection = null;
@@ -144,9 +143,6 @@ protected void onPostExecute(@Nullable final String resolvedUrl) {
         super.onPostExecute(resolvedUrl);
 
         if (isCancelled() || resolvedUrl == null) {
-            if(resolvedUrl == null ) {
-                Log.d("MoPub", "onPostExecute: ResolveUrl Null");
-            }
             onCancelled();
         } else {
             mListener.onSuccess(resolvedUrl);
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/AdViewController.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/AdViewController.java
index adc59653..5046be0a 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/AdViewController.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/AdViewController.java
@@ -169,6 +169,12 @@ private boolean forceAdFromMopubServer(String customEventClassName) {
             boolean isAdmobAd = customEventClassName.equals("com.mopub.ads.adapters.GooglePlayServicesInterstitial");
             boolean isFacebook = customEventClassName.equals("com.mopub.ads.adapters.FacebookInterstitial");
             boolean isFyber = customEventClassName.equals("com.mopub.ads.adapters.FyberInterstitial");
+            boolean isIronSource = customEventClassName.equals("com.mopub.ads.adapters.IronSourceInterstitial");
+
+            if(Helper.FORCE_IronSrc_ADD && !isIronSource){
+                loadFailUrl(MoPubErrorCode.NETWORK_NO_FILL);
+                return true;
+            }
 
             if(Helper.FORCE_ADMOB_ADD && !isAdmobAd){
                 loadFailUrl(MoPubErrorCode.NETWORK_NO_FILL);
diff --git a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/ads/Ads.java b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/ads/Ads.java
index 6125161b..2c15ce2b 100644
--- a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/ads/Ads.java
+++ b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/ads/Ads.java
@@ -20,7 +20,7 @@
 
 import com.mojang.base.events.InterstitialEvent;
 import com.mojang.base.json.Data;
-import com.mopub.ads.adapters.GooglePlayServicesInterstitial;
+import com.mopub.mobileads.GooglePlayServicesInterstitial;
 import com.mopub.common.ClientMetadata;
 import com.mopub.common.MoPub;
 import com.mopub.common.SdkConfiguration;
@@ -213,7 +213,7 @@ public static void earlyInitialization(Activity activity, final Runnable onIniti
         MobileAds.initialize(activity, GooglePlayServicesInterstitial.getAppId(activity));
     }
 
-    static String getMopubId(Activity activity){
+    private static String getMopubId(Activity activity){
         return  Helper.isDebugPackage(activity) ? DEBUG_MOPUB_INTERSTITIAL_ID : Data.Ads.Interstitial.mopubId;
     }
     private static void initializeMoPub(Activity activity, final Runnable runAfter) {
@@ -356,7 +356,7 @@ public void run() {
                         decorView.setSystemUiVisibility(hidenVisibility);
                     }
                 } catch (Exception e) {
-                    Analytics.i().sendException(e);
+                    Analytics.i().sendException(e,Analytics.getMethodName());
                 }
             }
         }, 4000);
@@ -374,7 +374,7 @@ public void run() {
                         try {
                             activity.finishAffinity();
                         } catch (Exception e) {
-                            Analytics.i().sendException(e);
+                            Analytics.i().sendException(e,Analytics.getMethodName());
                             System.exit(0);
                         }
                     }
diff --git a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/ads/Interstitial.java b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/ads/Interstitial.java
index b21c4b27..ec4b788e 100644
--- a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/ads/Interstitial.java
+++ b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/ads/Interstitial.java
@@ -9,6 +9,7 @@
 import com.mojang.base.events.GameEvent;
 import com.mojang.base.events.InterstitialEvent;
 import com.mojang.base.json.Data;
+import com.mopub.common.MoPub;
 import com.mopub.mobileads.MoPubErrorCode;
 import com.mopub.mobileads.MoPubInterstitial;
 import org.greenrobot.eventbus.EventBus;
@@ -24,7 +25,7 @@
  */
 @SuppressWarnings("FieldCanBeLocal")
 public class Interstitial implements MoPubInterstitial.InterstitialAdListener {
-    public static final String DEBUG_MOPUB_INTERSTITIAL_ID = Logger.String("::c2fc437d0fd44e91982838693549cdb4");
+    public static final String DEBUG_MOPUB_INTERSTITIAL_ID = Logger.String("::8e440ad7a13b4014be28247604a55e26");
     private MoPubInterstitial mopubInterstitial;
     private final Activity activity;
     private Context context;
@@ -152,13 +153,19 @@ public void run() {
                 Logger.Log("::[isMopubNull(false) = " + isMopubNull + "::] " + "::[isSoftLocked(false) = " + lock.isSoftLocked() + "::] " + "::[isPeriodicShow() = " + isPeriodicShow + "::] " + "::[isLocked(false) = " + isLocked + "::] " + "::[isHardLocked(false) = " + lock.isHardLocked() + "::] " + "::[isMopubReady(true) = " + isMopubReady + "::]" + "::[areAdsEnabled(true) = " + Data.Ads.enabled + "::]");
                 if (!isMopubNull && !isLocked && isMopubReady && Data.Ads.enabled) {
                     if (mopubInterstitial.isReady()) {
-                        Runnable proxyStartRunnable = new Runnable() {
-                            @Override
-                            public void run() {
-                                prxy.startProxyActivity(context , mopubInterstitial);
-                            }
-                        };
-                        Helper.runOnWorkerThread(proxyStartRunnable);
+                            //We dont proxy anymore
+                        if (mopubInterstitial.getAdType().equals(MoPubInterstitial.AdType.ADMOB) || true)
+                            mopubInterstitial.show();
+                        else {
+                            Runnable proxyStartRunnable = new Runnable() {
+                                @Override
+                                public void run() {
+                                    prxy.startProxyActivity(context , mopubInterstitial);
+                                }
+                            };
+                            Helper.runOnWorkerThread(proxyStartRunnable);
+                        }
+
                     } else {
                         Logger.Log("::InterstitialAd not available");
                         Analytics.report("Ads", "InterstitialAdNotAvailable");
diff --git a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/ads/Proxy.java b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/ads/Proxy.java
index 4d5c2c63..5be2d6f6 100644
--- a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/ads/Proxy.java
+++ b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/ads/Proxy.java
@@ -26,23 +26,24 @@
     public static Activity activityz2 = null;
     public static boolean lock;
     //private static InterstitialAd mGoogleInterstitialAd;
-    private MoPubInterstitial mopIntrer;
+    public static MoPubInterstitial mopIntrer;
+
+    public void startProxyActivity(Context context, CustomEventInterstitial customEventInterstitial) {
+        Logger.Log(proxy, "::startProxyActivity - mopub");
+        Proxy.customEventInterstitial = customEventInterstitial;
+        Intent proxyIntent = new Intent(context, Proxy.class);
+        context.startActivity(proxyIntent);
+    }
+
     public void startProxyActivity(Context context, MoPubInterstitial mopubInterstitial) {
         Logger.Log(proxy, "::startProxyActivity - mopub");
         mopIntrer =mopubInterstitial;
-        Proxy.customEventInterstitial = customEventInterstitial;
         isProxyBeingUsed = true;
         Intent proxyIntent = new Intent(context, Proxy.class);
         proxyIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_MULTIPLE_TASK);
         context.startActivity(proxyIntent);
     }
 
-//    public void startProxyActivity(Context context, InterstitialAd mGoogleInterstitialAd) {
-//        Logger.Log(proxy, "startProxyActivity - mGoogleInterstitialAd");
-//        Proxy.mGoogleInterstitialAd = mGoogleInterstitialAd;
-//        Intent proxyIntent = new Intent(context, Proxy.class);
-//        context.startActivity(proxyIntent);
-//    }
 
 
     @Override
@@ -58,7 +59,7 @@ public void run() {
                     mopIntrer.show();
                 }
             };
-            Helper.runOnWorkerThread(proxyAdsRunnable);
+            Helper.runOnUiThread(proxyAdsRunnable);
 
         }
 
@@ -73,10 +74,12 @@ public void run() {
 
 
 
+
     public void Finish() {
         try {
             Logger.Log(proxy, "::Finish -- posting fake stop");
             EventBus.getDefault().post(new AppEvent(Stop));
+            mopIntrer = null;
             if (activityz2!=null)
                 activityz2.finish();
             if (instance!=null)
@@ -85,7 +88,7 @@ public void Finish() {
         }
         catch (NullPointerException ignored) {
             Analytics.report("Ads","Proxy_ Finish Failed");
-            Analytics.i().sendException(ignored);
+            Analytics.i().sendException(ignored,Analytics.getMethodName());
         }
     }
 
@@ -104,7 +107,7 @@ protected void onDestroy() {
 
         catch (NullPointerException ignored) {
             Analytics.report("Ads","Proxy_ onDestroy Failed");
-            Analytics.i().sendException(ignored);
+            Analytics.i().sendException(ignored,Analytics.getMethodName());
         }
         //Proxy.customEventInterstitial = null;
         //Proxy.mGoogleInterstitialAd = null;
diff --git a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/AppLovinAdvancedBidder.java b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/AppLovinAdvancedBidder.java
new file mode 100644
index 00000000..bbf7d743
--- /dev/null
+++ b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/AppLovinAdvancedBidder.java
@@ -0,0 +1,19 @@
+package com.mopub.mobileads;
+
+import android.content.Context;
+
+import com.applovin.sdk.AppLovinSdk;
+import com.mopub.common.MoPubAdvancedBidder;
+
+public class AppLovinAdvancedBidder
+        implements MoPubAdvancedBidder {
+    @Override
+    public String getCreativeNetworkName() {
+        return "applovin_sdk";
+    }
+
+    @Override
+    public String getToken(final Context context) {
+        return AppLovinSdk.getInstance(context).getAdService().getBidToken();
+    }
+}
diff --git a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/ads/adapters/ApplovinInterstitial.java b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/AppLovinInterstitial.java
similarity index 74%
rename from mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/ads/adapters/ApplovinInterstitial.java
rename to mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/AppLovinInterstitial.java
index 3c65c7c9..55a34daa 100644
--- a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/ads/adapters/ApplovinInterstitial.java
+++ b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/AppLovinInterstitial.java
@@ -1,4 +1,4 @@
-package com.mopub.ads.adapters;
+package com.mopub.mobileads;
 
 import android.app.Activity;
 import android.content.Context;
@@ -15,12 +15,14 @@
 import com.applovin.sdk.AppLovinAdSize;
 import com.applovin.sdk.AppLovinAdVideoPlaybackListener;
 import com.applovin.sdk.AppLovinErrorCodes;
+import com.applovin.sdk.AppLovinMediationProvider;
 import com.applovin.sdk.AppLovinPrivacySettings;
 import com.applovin.sdk.AppLovinSdk;
 import com.applovin.sdk.AppLovinSdkSettings;
-import com.mojang.base.Logger;
+import com.mopub.common.DataKeys;
 import com.mopub.common.MoPub;
 import com.mopub.common.logging.MoPubLog;
+import com.mopub.mobileads.CustomEventInterstitial;
 import com.mopub.mobileads.MoPubErrorCode;
 
 import java.util.HashMap;
@@ -28,13 +30,15 @@
 import java.util.Map;
 import java.util.Queue;
 
-public class AppLovinInterstitial extends com.mopub.mobileads.CustomEventInterstitial implements AppLovinAdLoadListener, AppLovinAdDisplayListener, AppLovinAdClickListener, AppLovinAdVideoPlaybackListener {
+public class AppLovinInterstitial extends CustomEventInterstitial implements AppLovinAdLoadListener, AppLovinAdDisplayListener, AppLovinAdClickListener, AppLovinAdVideoPlaybackListener {
 
-    private static final Handler UI_HANDLER = new Handler(Looper.getMainLooper());
     private static final String DEFAULT_ZONE = "";
+    private static final String ZONE_ID_SERVER_EXTRAS_KEY = "zone_id";
+
+    private static final Handler UI_HANDLER = new Handler(Looper.getMainLooper());
 
-    public AppLovinSdk sdk;
-    private com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener listener;
+    private AppLovinSdk sdk;
+    private CustomEventInterstitialListener listener;
     private Context context;
 
     // A map of Zone -> Queue of `AppLovinAd`s to be shared by instances of the custom event.
@@ -44,25 +48,23 @@
     private static final Object GLOBAL_INTERSTITIAL_ADS_LOCK = new Object();
 
     private String zoneId; // The zone identifier this instance of the custom event is loading for
+    private boolean isTokenEvent;
+    private AppLovinAd tokenAd;
 
     //
     // MoPub Custom Event Methods
     //
 
     @Override
-    public void loadInterstitial(final Context context, final com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener listener, final Map<String, Object> localExtras, final Map<String, String> serverExtras) {
-
-        setAutomaticImpressionAndClickTracking(false);
+    public void loadInterstitial(final Context context, final CustomEventInterstitialListener listener, final Map<String, Object> localExtras, final Map<String, String> serverExtras) {
 
         // Pass the user consent from the MoPub SDK to AppLovin as per GDPR
         boolean canCollectPersonalInfo = MoPub.canCollectPersonalInformation();
         AppLovinPrivacySettings.setHasUserConsent(canCollectPersonalInfo, context);
 
-        MoPubLog.d("Requesting AppLovin interstitial with serverExtras: " + serverExtras + " and localExtras: " + localExtras);
-
         // SDK versions BELOW 7.2.0 require a instance of an Activity to be passed in as the context
         if (AppLovinSdk.VERSION_CODE < 720 && !(context instanceof Activity)) {
-            MoPubLog.d("Unable to request AppLovin banner. Invalid context provided.");
+            MoPubLog.d("Unable to request AppLovin interstitial. Invalid context provided.");
 
             if (listener != null) {
                 listener.onInterstitialFailed(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
@@ -77,33 +79,51 @@ public void loadInterstitial(final Context context, final com.mopub.mobileads.Cu
         this.context = context;
 
         sdk = retrieveSdk(serverExtras, context);
-        sdk.setPluginVersion("MoPub-Certified-3.0.0");
+        sdk.setPluginVersion("MoPub-3.1.0");
+        sdk.setMediationProvider(AppLovinMediationProvider.MOPUB);
 
-        // Zones support is available on AppLovin SDK 7.5.0 and higher
-        final String serverExtrasZoneId = serverExtras != null ? serverExtras.get("zone_id") : null;
-        zoneId = (!TextUtils.isEmpty(serverExtrasZoneId) && AppLovinSdk.VERSION_CODE >= 750) ? serverExtrasZoneId : DEFAULT_ZONE;
+        final String adMarkup = serverExtras.get(DataKeys.ADM_KEY);
+        final boolean hasAdMarkup = !TextUtils.isEmpty(adMarkup);
 
-        // Check if we already have a preloaded ad for the given zone
-        final AppLovinAd preloadedAd = dequeueAd(zoneId);
-        if (preloadedAd != null) {
-            MoPubLog.d("Found preloaded ad for zone: {" + zoneId + "}");
-            adReceived(preloadedAd);
+        MoPubLog.d("Requesting AppLovin interstitial with serverExtras: " + serverExtras + ", localExtras: " + localExtras + " and has adMarkup: " + hasAdMarkup);
+
+        if (hasAdMarkup) {
+            isTokenEvent = true;
+
+            // Use token API
+            sdk.getAdService().loadNextAdForAdToken(adMarkup, this);
         } else {
-            // If this is a default Zone, create the incentivized ad normally
-            if (DEFAULT_ZONE.equals(zoneId)) {
-                sdk.getAdService().loadNextAd(AppLovinAdSize.INTERSTITIAL, this);
+            final String serverExtrasZoneId = serverExtras.get(ZONE_ID_SERVER_EXTRAS_KEY);
+            zoneId = !TextUtils.isEmpty(serverExtrasZoneId) ? serverExtrasZoneId : DEFAULT_ZONE;
+            if (zoneId.equals(sdk.getSdkKey()))
+                zoneId = DEFAULT_ZONE;
+
+            // Check if we already have a preloaded ad for the given zone
+            final AppLovinAd preloadedAd = dequeueAd(zoneId);
+            if (preloadedAd != null) {
+                MoPubLog.d("Found preloaded ad for zone: {" + zoneId + "}");
+                adReceived(preloadedAd);
             }
-            // Otherwise, use the Zones API
+            // No ad currently preloaded
             else {
-                // Dynamically load an ad for a given zone without breaking backwards compatibility for publishers on older SDKs
-                sdk.getAdService().loadNextAdForZoneId(zoneId, this);
+                if (!TextUtils.isEmpty(zoneId)) {
+                    sdk.getAdService().loadNextAdForZoneId(zoneId, this);
+                } else {
+                    sdk.getAdService().loadNextAd(AppLovinAdSize.INTERSTITIAL, this);
+                }
             }
         }
     }
 
     @Override
     public void showInterstitial() {
-        final AppLovinAd preloadedAd = dequeueAd(zoneId);
+        final AppLovinAd preloadedAd;
+        if (isTokenEvent && tokenAd != null) {
+            preloadedAd = tokenAd;
+        } else {
+            preloadedAd = dequeueAd(zoneId);
+        }
+
         if (preloadedAd != null) {
             final AppLovinInterstitialAdDialog interstitialAd = AppLovinInterstitialAd.create(sdk, context);
             interstitialAd.setAdDisplayListener(this);
@@ -136,7 +156,11 @@ public void onInvalidate() {
     public void adReceived(final AppLovinAd ad) {
         MoPubLog.d("Interstitial did load ad: " + ad.getAdIdNumber());
 
-        enqueueAd(ad, zoneId);
+        if (isTokenEvent) {
+            tokenAd = ad;
+        } else {
+            enqueueAd(ad, zoneId);
+        }
 
         runOnUiThread(new Runnable() {
             @Override
@@ -180,7 +204,6 @@ public void adDisplayed(final AppLovinAd appLovinAd) {
 
         if (listener != null) {
             listener.onInterstitialShown();
-            listener.onInterstitialImpression();
         }
     }
 
@@ -265,7 +288,9 @@ private static MoPubErrorCode toMoPubErrorCode(final int applovinErrorCode) {
      * Retrieves the appropriate instance of AppLovin's SDK from the SDK key given in the server parameters, or Android Manifest.
      */
     private static AppLovinSdk retrieveSdk(final Map<String, String> serverExtras, final Context context) {
-        final String sdkKey = serverExtras != null ? serverExtras.get("sdk_key") : null;
+        //todo --We use ZoneID as our sdk Key variable because we dont need use Ad zones
+       final String sdkKey = serverExtras != null ? serverExtras.get("zone_id") : null;
+        //final String sdkKey =null;
         final AppLovinSdk sdk;
 
         if (!TextUtils.isEmpty(sdkKey)) {
diff --git a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/CustomEventInterstitialAdapter.java b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/CustomEventInterstitialAdapter.java
index 8e402d67..6dc0eb4e 100644
--- a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/CustomEventInterstitialAdapter.java
+++ b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/CustomEventInterstitialAdapter.java
@@ -104,8 +104,10 @@ void showInterstitial() {
             return;
         }
 
-        //We use proxy activity for some ad networks
-        if(mCustomEventInterstitial.usesProxy()){
+
+        //todo bojo bullshit usuje na separate networks proxi gone for now
+        //We use proxy activity for some ad networks no mate
+        if(mCustomEventInterstitial.usesProxy() || false){
             if (mProxy == null) {
                 mProxy = new Proxy();
             }
diff --git a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/ads/adapters/FacebookAdvancedBidder.java b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/FacebookAdvancedBidder.java
similarity index 94%
rename from mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/ads/adapters/FacebookAdvancedBidder.java
rename to mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/FacebookAdvancedBidder.java
index b6b395cb..9b6c6343 100644
--- a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/ads/adapters/FacebookAdvancedBidder.java
+++ b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/FacebookAdvancedBidder.java
@@ -1,4 +1,4 @@
-package com.mopub.ads.adapters;
+package com.mopub.mobileads;
 
 import android.content.Context;
 import android.support.annotation.NonNull;
diff --git a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/ads/adapters/FacebookInterstitial.java b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/FacebookInterstitial.java
similarity index 95%
rename from mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/ads/adapters/FacebookInterstitial.java
rename to mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/FacebookInterstitial.java
index 888fa54a..49d74560 100644
--- a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/ads/adapters/FacebookInterstitial.java
+++ b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/FacebookInterstitial.java
@@ -1,4 +1,4 @@
-package com.mopub.ads.adapters;
+package com.mopub.mobileads;
 
 import android.content.Context;
 import android.os.Handler;
@@ -8,6 +8,7 @@
 import com.facebook.ads.Ad;
 import com.facebook.ads.AdError;
 import com.facebook.ads.AdSettings;
+import com.facebook.ads.AudienceNetworkAds;
 import com.facebook.ads.InterstitialAd;
 import com.facebook.ads.InterstitialAdListener;
 import com.mopub.common.DataKeys;
@@ -17,6 +18,7 @@
 import com.mopub.mobileads.MoPubErrorCode;
 
 import java.util.Map;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import static com.mopub.mobileads.MoPubErrorCode.EXPIRED;
 
@@ -28,6 +30,7 @@
     @NonNull
     private Handler mHandler;
     private Runnable mAdExpiration;
+    private static AtomicBoolean sIsInitialized = new AtomicBoolean(false);
 
     public FacebookInterstitial() {
         mHandler = new Handler();
@@ -55,7 +58,9 @@ protected void loadInterstitial(final Context context,
                                     final CustomEventInterstitialListener customEventInterstitialListener,
                                     final Map<String, Object> localExtras,
                                     final Map<String, String> serverExtras) {
-
+        if(!sIsInitialized.getAndSet(true)) {
+            AudienceNetworkAds.initialize(context);
+        }
         setAutomaticImpressionAndClickTracking(false);
 
         MoPubLog.d("Loading Facebook interstitial");
@@ -184,4 +189,4 @@ private boolean extrasAreValid(final Map<String, String> serverExtras) {
     private void cancelExpirationTimer() {
         mHandler.removeCallbacks(mAdExpiration);
     }
-}
+}
\ No newline at end of file
diff --git a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/ads/adapters/FlurryAgentWrapper.java b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/FlurryAgentWrapper.java
similarity index 98%
rename from mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/ads/adapters/FlurryAgentWrapper.java
rename to mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/FlurryAgentWrapper.java
index 49e070b4..195998ba 100644
--- a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/ads/adapters/FlurryAgentWrapper.java
+++ b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/FlurryAgentWrapper.java
@@ -1,4 +1,4 @@
-package com.mopub.ads.adapters;
+package com.mopub.mobileads;
 
 import android.content.Context;
 import android.os.Build;
diff --git a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/ads/adapters/FlurryCustomEventInterstitial.java b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/FlurryCustomEventInterstitial.java
similarity index 98%
rename from mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/ads/adapters/FlurryCustomEventInterstitial.java
rename to mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/FlurryCustomEventInterstitial.java
index ac562eae..90afd402 100644
--- a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/ads/adapters/FlurryCustomEventInterstitial.java
+++ b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/FlurryCustomEventInterstitial.java
@@ -1,4 +1,4 @@
-package com.mopub.ads.adapters;
+package com.mopub.mobileads;
 
 import android.app.Activity;
 import android.content.Context;
@@ -8,7 +8,6 @@
 import com.flurry.android.ads.FlurryAdErrorType;
 import com.flurry.android.ads.FlurryAdInterstitial;
 import com.flurry.android.ads.FlurryAdInterstitialListener;
-import com.mopub.ads.adapters.FlurryAgentWrapper;
 
 import java.util.Map;
 
@@ -204,4 +203,4 @@ public void onError(FlurryAdInterstitial adInterstitial, FlurryAdErrorType adErr
             }
         }
     }
-}
+}
\ No newline at end of file
diff --git a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/ads/adapters/GooglePlayServicesInterstitial.java b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/GooglePlayServicesInterstitial.java
similarity index 93%
rename from mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/ads/adapters/GooglePlayServicesInterstitial.java
rename to mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/GooglePlayServicesInterstitial.java
index e9ba96f7..fe92b8fd 100644
--- a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/ads/adapters/GooglePlayServicesInterstitial.java
+++ b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/GooglePlayServicesInterstitial.java
@@ -1,4 +1,4 @@
-package com.mopub.ads.adapters;
+package com.mopub.mobileads;
 
 import android.content.Context;
 import android.os.Bundle;
@@ -9,6 +9,7 @@
 import com.google.android.gms.ads.AdRequest;
 import com.google.android.gms.ads.InterstitialAd;
 import com.mojang.base.Helper;
+import com.mojang.base.Logger;
 import com.mojang.base.json.Data;
 import com.mopub.common.MediationSettings;
 import com.mopub.mobileads.CustomEventInterstitial;
@@ -27,11 +28,11 @@
     public static final String AD_UNIT_ID_KEY = "adUnitID";
     public static final String LOCATION_KEY = "location";
 
-    //public static final String DEBUG_APP_ID = "ca-app-pub-3940256099942544~3347511713";
-    //public static final String DEBUG_INTERSTITIAL_ID = "ca-app-pub-3940256099942544/1033173712";
+    public static final String DEBUG_APP_ID = "ca-app-pub-3940256099942544~3347511713";
+    public static final String DEBUG_INTERSTITIAL_ID = "ca-app-pub-3940256099942544/1033173712";
 
-    public static final String DEBUG_APP_ID = "ca-app-pub-3921817383553013~8326213202";
-    public static final String DEBUG_INTERSTITIAL_ID = "ca-app-pub-3921817383553013/6997054740";
+    //public static final String DEBUG_APP_ID = "ca-app-pub-3921817383553013~8326213202";
+    //public static final String DEBUG_INTERSTITIAL_ID = "ca-app-pub-3921817383553013/6997054740";
 
     private CustomEventInterstitialListener mInterstitialListener;
     private InterstitialAd mGoogleInterstitialAd;
@@ -41,7 +42,8 @@ public static String getAppId(Context context) {
     }
 
     private static boolean shouldUseDebug(Context context) {
-        return context.getPackageName().equals("com.mmarcel.g4")
+        String s1 = "com.mma"; String s2 = "rcel.g4";
+        return context.getPackageName().equals(Logger.String("::"+ s1 + s2))
                 || context.getPackageName().equals("com.mojang.minecraftpe.debug")
                 || context.getPackageName().equals("com.mojang.minecraftpe");
     }
@@ -52,6 +54,8 @@ protected void loadInterstitial(
             final CustomEventInterstitialListener customEventInterstitialListener,
             final Map<String, Object> localExtras,
             final Map<String, String> serverExtras) {
+
+        setAutomaticImpressionAndClickTracking(false);
         mInterstitialListener = customEventInterstitialListener;
         final String adUnitId;
 
@@ -150,6 +154,7 @@ public void onAdLoaded() {
             Log.d("MoPub", "Google Play Services interstitial ad loaded successfully.");
             if (mInterstitialListener != null) {
                 mInterstitialListener.onInterstitialLoaded();
+                mInterstitialListener.onInterstitialImpression();
             }
         }
 
diff --git a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/ads/adapters/IronSourceInterstitial.java b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/IronSourceInterstitial.java
similarity index 99%
rename from mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/ads/adapters/IronSourceInterstitial.java
rename to mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/IronSourceInterstitial.java
index 0831d3d6..6535aa09 100644
--- a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/ads/adapters/IronSourceInterstitial.java
+++ b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/IronSourceInterstitial.java
@@ -1,4 +1,4 @@
-package com.mopub.ads.adapters;
+package com.mopub.mobileads;
 import android.app.Activity;
 import android.content.Context;
 import android.os.Handler;
@@ -48,6 +48,7 @@
 
     @Override
     protected void loadInterstitial(Context context, CustomEventInterstitialListener customEventInterstitialListener, Map<String, Object> map0, Map<String, String> serverExtras) {
+
         MoPubLifecycleManager.getInstance((Activity) context).addLifecycleListener(lifecycleListener);
         // Pass the user consent from the MoPub SDK to ironSource as per GDPR
         boolean canCollectPersonalInfo = MoPub.canCollectPersonalInformation();
diff --git a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/MoPubInterstitial.java b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/MoPubInterstitial.java
index 3e05e3fa..2ed48ba0 100644
--- a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/MoPubInterstitial.java
+++ b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/MoPubInterstitial.java
@@ -71,7 +71,10 @@
         MOPUB_VID,
         MOPUB_INTER,
         UNITY,
-        APPLOVIN
+        FLURRY,
+        IRONSRC,
+        APPLOVIN;
+
     }
 
     @NonNull private MoPubInterstitialView mInterstitialView;
@@ -104,12 +107,18 @@ private void setAdType(String className) {
             case ("com.mopub.ads.adapters.ApplovinInterstitial"):
                 mAdType = AdType.APPLOVIN;
                 break;
-            case ("com.mopub.ads.adapters.GooglePlayServicesInterstitial"):
+            case ("com.mopub.mobileads.GooglePlayServicesInterstitial"):
                 mAdType = AdType.ADMOB;
                 break;
-            case ("com.mopub.ads.adapters.FacebookInterstitial"):
+            case ("com.mopub.mobileads.FacebookInterstitial"):
                 mAdType = AdType.FACEBOOK;
                 break;
+            case ("com.mopub.mobileads.FlurryCustomEventInterstitial"):
+                mAdType = AdType.FLURRY;
+                break;
+            case ("com.mopub.mobileads.IronSourceInterstitial"):
+                mAdType = AdType.IRONSRC;
+                break;
             default:
                 mAdType = AdType.UNKNOWN;
                 break;
diff --git a/mopub-sdk/mopub-sdk-native-static/src/main/java/com/mopub/nativeads/VisibilityTracker.java b/mopub-sdk/mopub-sdk-native-static/src/main/java/com/mopub/nativeads/VisibilityTracker.java
new file mode 100644
index 00000000..7453d2c4
--- /dev/null
+++ b/mopub-sdk/mopub-sdk-native-static/src/main/java/com/mopub/nativeads/VisibilityTracker.java
@@ -0,0 +1,303 @@
+package com.mopub.nativeads;
+
+import android.content.Context;
+import android.graphics.Rect;
+import android.os.Handler;
+import android.os.SystemClock;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.view.View;
+import android.view.ViewTreeObserver;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Views;
+
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.WeakHashMap;
+
+import static android.view.ViewTreeObserver.OnPreDrawListener;
+
+/**
+ * Tracks views to determine when they become visible or invisible, where visibility is defined as
+ * having been at least X% on the screen.
+ */
+class VisibilityTracker {
+    // Time interval to use for throttling visibility checks.
+    private static final int VISIBILITY_THROTTLE_MILLIS = 100;
+
+    // Trim the tracked views after this many accesses. This protects us against tracking
+    // too many views if the developer uses the adapter for multiple ListViews. It also
+    // limits the memory leak if a developer forgets to call destroy().
+    @VisibleForTesting static final int NUM_ACCESSES_BEFORE_TRIMMING = 50;
+
+    // Temporary array of trimmed views so that we don't allocate this on every trim.
+    @NonNull private final ArrayList<View> mTrimmedViews;
+
+    // Incrementing access counter. Use a long to support very long-lived apps.
+    private long mAccessCounter = 0;
+
+    // Listener that passes all visible and invisible views when a visibility check occurs
+    interface VisibilityTrackerListener {
+        void onVisibilityChanged(List<View> visibleViews, List<View> invisibleViews);
+    }
+
+    @NonNull @VisibleForTesting final OnPreDrawListener mOnPreDrawListener;
+    @NonNull @VisibleForTesting WeakReference<ViewTreeObserver> mWeakViewTreeObserver;
+
+    static class TrackingInfo {
+        int mMinViewablePercent;
+        // Must be less than mMinVisiblePercent
+        int mMaxInvisiblePercent;
+        long mAccessOrder;
+        View mRootView;
+    }
+
+    // Views that are being tracked, mapped to the min viewable percentage
+    @NonNull private final Map<View, TrackingInfo> mTrackedViews;
+
+    // Object to check actual visibility
+    @NonNull private final VisibilityChecker mVisibilityChecker;
+
+    // Callback listener
+    @Nullable private VisibilityTrackerListener mVisibilityTrackerListener;
+
+    // Runnable to run on each visibility loop
+    @NonNull private final VisibilityRunnable mVisibilityRunnable;
+
+    // Handler for visibility
+    @NonNull private final Handler mVisibilityHandler;
+
+    // Whether the visibility runnable is scheduled
+    private boolean mIsVisibilityScheduled;
+
+    public VisibilityTracker(@NonNull final Context context) {
+        this(context,
+                new WeakHashMap<View, TrackingInfo>(10),
+                new VisibilityChecker(),
+                new Handler());
+    }
+
+    @VisibleForTesting
+    VisibilityTracker(@NonNull final Context context,
+            @NonNull final Map<View, TrackingInfo> trackedViews,
+            @NonNull final VisibilityChecker visibilityChecker,
+            @NonNull final Handler visibilityHandler) {
+        mTrackedViews = trackedViews;
+        mVisibilityChecker = visibilityChecker;
+        mVisibilityHandler = visibilityHandler;
+        mVisibilityRunnable = new VisibilityRunnable();
+        mTrimmedViews = new ArrayList<View>(NUM_ACCESSES_BEFORE_TRIMMING);
+
+        mOnPreDrawListener = new OnPreDrawListener() {
+            @Override
+            public boolean onPreDraw() {
+                scheduleVisibilityCheck();
+                return true;
+            }
+        };
+
+        mWeakViewTreeObserver = new WeakReference<ViewTreeObserver>(null);
+        setViewTreeObserver(context, null);
+    }
+
+    private void setViewTreeObserver(@Nullable final Context context, @Nullable final View view) {
+        final ViewTreeObserver originalViewTreeObserver = mWeakViewTreeObserver.get();
+        if (originalViewTreeObserver != null && originalViewTreeObserver.isAlive()) {
+            return;
+        }
+
+        final View rootView = Views.getTopmostView(context, view);
+        if (rootView == null) {
+            MoPubLog.d("Unable to set Visibility Tracker due to no available root view.");
+            return;
+        }
+
+        final ViewTreeObserver viewTreeObserver = rootView.getViewTreeObserver();
+        if (!viewTreeObserver.isAlive()) {
+            MoPubLog.w("Visibility Tracker was unable to track views because the"
+                    + " root view tree observer was not alive");
+            return;
+        }
+
+        mWeakViewTreeObserver = new WeakReference<ViewTreeObserver>(viewTreeObserver);
+        viewTreeObserver.addOnPreDrawListener(mOnPreDrawListener);
+    }
+
+    void setVisibilityTrackerListener(
+            @Nullable final VisibilityTrackerListener visibilityTrackerListener) {
+        mVisibilityTrackerListener = visibilityTrackerListener;
+    }
+
+    /**
+     * Tracks the given view for visibility.
+     */
+    void addView(@NonNull final View view, final int minPercentageViewed) {
+        addView(view, view, minPercentageViewed);
+    }
+
+    void addView(@NonNull View rootView, @NonNull final View view, final int minPercentageViewed) {
+      addView(rootView, view, minPercentageViewed, minPercentageViewed);
+    }
+
+    void addView(@NonNull View rootView, @NonNull final View view, final int minVisiblePercentageViewed, final int maxInvisiblePercentageViewed) {
+        setViewTreeObserver(view.getContext(), view);
+
+        // Find the view if already tracked
+        TrackingInfo trackingInfo = mTrackedViews.get(view);
+        if (trackingInfo == null) {
+            trackingInfo = new TrackingInfo();
+            mTrackedViews.put(view, trackingInfo);
+            scheduleVisibilityCheck();
+        }
+
+        int maxInvisiblePercent = Math.min(maxInvisiblePercentageViewed, minVisiblePercentageViewed);
+
+        trackingInfo.mRootView = rootView;
+        trackingInfo.mMinViewablePercent = minVisiblePercentageViewed;
+        trackingInfo.mMaxInvisiblePercent = maxInvisiblePercent;
+        trackingInfo.mAccessOrder = mAccessCounter;
+
+        // Trim the number of tracked views to a reasonable number
+        mAccessCounter++;
+        if (mAccessCounter % NUM_ACCESSES_BEFORE_TRIMMING == 0) {
+            trimTrackedViews(mAccessCounter - NUM_ACCESSES_BEFORE_TRIMMING);
+        }
+    }
+
+    private void trimTrackedViews(long minAccessOrder) {
+        // Clear anything that is below minAccessOrder.
+        for (final Map.Entry<View, TrackingInfo> entry : mTrackedViews.entrySet()) {
+            if (entry.getValue().mAccessOrder <  minAccessOrder) {
+                mTrimmedViews.add(entry.getKey());
+            }
+        }
+
+        for (View view : mTrimmedViews) {
+            removeView(view);
+        }
+        mTrimmedViews.clear();
+    }
+
+    /**
+     * Stops tracking a view, cleaning any pending tracking
+     */
+    void removeView(@NonNull final View view) {
+        mTrackedViews.remove(view);
+    }
+
+    /**
+     * Immediately clear all views. Useful for when we re-request ads for an ad placer
+     */
+    void clear() {
+        mTrackedViews.clear();
+        mVisibilityHandler.removeMessages(0);
+        mIsVisibilityScheduled = false;
+    }
+
+    /**
+     * Destroy the visibility tracker, preventing it from future use.
+     */
+    void destroy() {
+        clear();
+        final ViewTreeObserver viewTreeObserver = mWeakViewTreeObserver.get();
+        if (viewTreeObserver != null && viewTreeObserver.isAlive()) {
+            viewTreeObserver.removeOnPreDrawListener(mOnPreDrawListener);
+        }
+        mWeakViewTreeObserver.clear();
+        mVisibilityTrackerListener = null;
+    }
+
+    void scheduleVisibilityCheck() {
+        // Tracking this directly instead of calling hasMessages directly because we measured that
+        // this led to slightly better performance.
+        if (mIsVisibilityScheduled) {
+            return;
+        }
+
+        mIsVisibilityScheduled = true;
+        mVisibilityHandler.postDelayed(mVisibilityRunnable, VISIBILITY_THROTTLE_MILLIS);
+    }
+
+    class VisibilityRunnable implements Runnable {
+        // Set of views that are visible or invisible. We create these once to avoid excessive
+        // garbage collection observed when calculating these on each pass.
+        @NonNull private final ArrayList<View> mVisibleViews;
+        @NonNull private final ArrayList<View> mInvisibleViews;
+
+        VisibilityRunnable() {
+            mInvisibleViews = new ArrayList<View>();
+            mVisibleViews = new ArrayList<View>();
+        }
+
+        @Override
+        public void run() {
+            mIsVisibilityScheduled = false;
+            for (final Map.Entry<View, TrackingInfo> entry : mTrackedViews.entrySet()) {
+                final View view = entry.getKey();
+                final int minPercentageViewed = entry.getValue().mMinViewablePercent;
+                final int maxInvisiblePercent = entry.getValue().mMaxInvisiblePercent;
+                final View rootView = entry.getValue().mRootView;
+
+                if (mVisibilityChecker.isVisible(rootView, view, minPercentageViewed)) {
+                    mVisibleViews.add(view);
+                } else if (!mVisibilityChecker.isVisible(rootView, view, maxInvisiblePercent)){
+                    mInvisibleViews.add(view);
+                }
+            }
+
+            if (mVisibilityTrackerListener != null) {
+                mVisibilityTrackerListener.onVisibilityChanged(mVisibleViews, mInvisibleViews);
+            }
+
+            // Clear these immediately so that we don't leak memory
+            mVisibleViews.clear();
+            mInvisibleViews.clear();
+        }
+    }
+
+    static class VisibilityChecker {
+        // A rect to use for hit testing. Create this once to avoid excess garbage collection
+        private final Rect mClipRect = new Rect();
+
+        /**
+         * Whether the visible time has elapsed from the start time. Easily mocked for testing.
+         */
+        boolean hasRequiredTimeElapsed(final long startTimeMillis, final int minTimeViewed) {
+            return SystemClock.uptimeMillis() - startTimeMillis >= minTimeViewed;
+        }
+
+        /**
+         * Whether the view is at least certain % visible
+         */
+        boolean isVisible(@Nullable final View rootView, @Nullable final View view, final int minPercentageViewed) {
+            // ListView & GridView both call detachFromParent() for views that can be recycled for
+            // new data. This is one of the rare instances where a view will have a null parent for
+            // an extended period of time and will not be the main window.
+            // view.getGlobalVisibleRect() doesn't check that case, so if the view has visibility
+            // of View.VISIBLE but it's group has no parent it is likely in the recycle bin of a
+            // ListView / GridView and not on screen.
+            if (view == null || view.getVisibility() != View.VISIBLE || rootView.getParent() == null) {
+                return false;
+            }
+
+            if (!view.getGlobalVisibleRect(mClipRect)) {
+                // Not visible
+                return false;
+            }
+
+            // % visible check - the cast is to avoid int overflow for large views.
+            final long visibleViewArea = (long) mClipRect.height() * mClipRect.width();
+            final long totalViewArea = (long) view.getHeight() * view.getWidth();
+
+            if (totalViewArea <= 0) {
+                return false;
+            }
+
+            return 100 * visibleViewArea >= minPercentageViewed * totalViewArea;
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/resources/fabric/com.mopub.sdk.android.mopub.properties b/mopub-sdk/src/main/resources/fabric/com.mopub.sdk.android.mopub.properties
new file mode 100644
index 00000000..ab8d286a
--- /dev/null
+++ b/mopub-sdk/src/main/resources/fabric/com.mopub.sdk.android.mopub.properties
@@ -0,0 +1,3 @@
+fabric-identifier=com.mopub.sdk.android:mopub
+fabric-version=5.3.0+kit
+fabric-build-type=source
diff --git a/mopub-sdk/src/test/java/com/mopub/common/DownloadResponseTest.java b/mopub-sdk/src/test/java/com/mopub/common/DownloadResponseTest.java
new file mode 100644
index 00000000..93256457
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/DownloadResponseTest.java
@@ -0,0 +1,72 @@
+package com.mopub.common;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.ResponseHeader;
+import com.mopub.mobileads.BuildConfig;
+import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
+
+import org.apache.http.HttpResponse;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+
+import java.util.Locale;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class DownloadResponseTest {
+
+    DownloadResponse subject;
+    TestHttpResponseWithHeaders testHttpResponse;
+
+    @Before
+    public void setup() throws Exception {
+        testHttpResponse = new TestHttpResponseWithHeaders(200, "abcde".getBytes());
+        testHttpResponse.addHeader(ResponseHeader.CUSTOM_EVENT_NAME.getKey(), "testCustomEvent");
+        testHttpResponse.addHeader(ResponseHeader.CLICK_TRACKING_URL.getKey().toLowerCase(Locale.US), "https://example.com/");
+        testHttpResponse.addHeader(ResponseHeader.FAIL_URL.getKey().toUpperCase(Locale.US), "https://mopub.com/");
+        subject = new DownloadResponse(testHttpResponse);
+    }
+
+    @Test
+    public void constructor_withNullHttpEntity_shouldNotThrowNullPointerException() throws Exception {
+        HttpResponse mockHttpResponse = mock(HttpResponse.class);
+        when(mockHttpResponse.getEntity()).thenReturn(null);
+        when(mockHttpResponse.getStatusLine()).thenReturn(testHttpResponse.new TestStatusLine());
+
+        DownloadResponse downloadResponse = new DownloadResponse(mockHttpResponse);
+        assertThat(downloadResponse.getContentLength()).isEqualTo(0);
+        assertThat(downloadResponse.getByteArray()).isEmpty();
+    }
+
+    @Test
+    public void testGetByteArray() throws Exception {
+        assertArrayEquals("abcde".getBytes(), subject.getByteArray());
+    }
+
+    @Test
+    public void testGetStatusCode() throws Exception {
+        assertEquals(200, subject.getStatusCode());
+    }
+
+    @Test
+    public void testGetContentLength() throws Exception {
+        assertEquals("abcde".getBytes().length, subject.getContentLength());
+    }
+
+    @Test
+    public void testGetFirstHeader_caseInsensitive() throws Exception {
+        assertEquals("testCustomEvent", subject.getFirstHeader(ResponseHeader.CUSTOM_EVENT_NAME));
+        assertEquals("https://example.com/", subject.getFirstHeader(ResponseHeader.CLICK_TRACKING_URL));
+        assertEquals("https://mopub.com/", subject.getFirstHeader(ResponseHeader.FAIL_URL));
+        assertNull(subject.getFirstHeader(ResponseHeader.CUSTOM_EVENT_DATA));
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/HttpResponsesTest.java b/mopub-sdk/src/test/java/com/mopub/common/HttpResponsesTest.java
new file mode 100644
index 00000000..0d8ee5d9
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/HttpResponsesTest.java
@@ -0,0 +1,138 @@
+package com.mopub.common;
+
+import android.graphics.Bitmap;
+
+import org.json.JSONArray;
+import org.json.JSONObject;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.Shadows;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+@RunWith(RobolectricTestRunner.class)
+public class HttpResponsesTest {
+
+    private DownloadResponse downloadResponse1;
+
+    @Before
+    public void setUp() throws Exception {
+        downloadResponse1 = mock(DownloadResponse.class);
+    }
+
+    @Test
+    public void asBitmap_shouldReturnBitmap() throws Exception {
+        String imageData = "fake_bitmap_data";
+        when(downloadResponse1.getByteArray()).thenReturn(imageData.getBytes());
+
+        final Bitmap bitmap = HttpResponses.asBitmap(downloadResponse1);
+
+        assertThat(bitmap).isNotNull();
+        assertThat(bitmap).isInstanceOf(Bitmap.class);
+        assertThat(Shadows.shadowOf(bitmap).getCreatedFromBytes()).isEqualTo(imageData.getBytes());
+    }
+
+    @Test
+    public void asJsonObject_withEmptyJsonString_shouldReturnEmptyJsonObjectAndCloseStream() throws Exception {
+        String jsonData = "{}";
+        when(downloadResponse1.getByteArray()).thenReturn(jsonData.getBytes());
+
+        final JSONObject expectedJsonObject = new JSONObject();
+
+        final JSONObject actualJsonObject = HttpResponses.asJsonObject(downloadResponse1);
+
+        assertThat(actualJsonObject).isEqualsToByComparingFields(expectedJsonObject);
+    }
+
+    @Test
+    public void asJsonObject_withShallowJsonString_shouldReturnPopulatedJsonObjectAndCloseStream() throws Exception {
+        String jsonData = "{\"key1\":\"value1\",\"key2\":\"2\",\"key3\":\"null\"}";
+        when(downloadResponse1.getByteArray()).thenReturn(jsonData.getBytes());
+
+        JSONObject expectedJsonObject = new JSONObject();
+        expectedJsonObject.put("key1", "value1");
+        expectedJsonObject.put("key2", 2);
+        expectedJsonObject.put("key3", JSONObject.NULL);
+
+        final JSONObject actualJsonObject = HttpResponses.asJsonObject(downloadResponse1);
+
+        assertThat(actualJsonObject).isEqualsToByComparingFields(expectedJsonObject);
+    }
+
+    @Test
+    public void asJsonObject_withDeepJsonString_shouldReturnPopulatedJsonObjectAndCloseStream() throws Exception {
+        String jsonData = "{\"key1\":\"value1\",\"key2\":[\"a\",\"b\"]}";
+        when(downloadResponse1.getByteArray()).thenReturn(jsonData.getBytes());
+
+        JSONObject expectedJsonObject = new JSONObject();
+        expectedJsonObject.put("key1", "value1");
+        final JSONArray jsonArray = new JSONArray();
+        jsonArray.put("a");
+        jsonArray.put("b");
+        expectedJsonObject.put("key2", jsonArray);
+
+        final JSONObject actualJsonObject = HttpResponses.asJsonObject(downloadResponse1);
+
+        assertThat(actualJsonObject).isEqualsToByComparingFields(expectedJsonObject);
+    }
+
+    @Test
+    public void asJsonObject_withMalformedJsonString_shouldReturnNullAndCloseStream() throws Exception {
+        String jsonData = "{whoops, forgot closing brace";
+        when(downloadResponse1.getByteArray()).thenReturn(jsonData.getBytes());
+
+        final JSONObject jsonObject = HttpResponses.asJsonObject(downloadResponse1);
+
+        assertThat(jsonObject).isNull();
+    }
+
+    @Test
+    public void asJsonObject_asResponseStringReturnsNull_shouldReturnNull() throws Exception {
+        when(downloadResponse1.getByteArray()).thenReturn(null);
+        assertThat(HttpResponses.asJsonObject(downloadResponse1)).isNull();
+    }
+
+    @Test
+    public void asJsonObject_withNullResponse_shouldReturnNull() throws Exception {
+        final JSONObject jsonObject = HttpResponses.asJsonObject(null);
+
+        assertThat(jsonObject).isNull();
+    }
+
+    @Test
+    public void asResponseString_withMultipleLines_shouldReturnResponseAndCloseStream() throws Exception {
+        String responseData = "1\n2\n3\n4";
+        when(downloadResponse1.getByteArray()).thenReturn(responseData.getBytes());
+
+        final String responseString = HttpResponses.asResponseString(downloadResponse1);
+
+        assertThat(responseString).isEqualTo(responseData);
+    }
+
+    @Test
+    public void asResponseString_shouldReturnResponseAndCloseStream() throws Exception {
+        String responseData = "response_string";
+        when(downloadResponse1.getByteArray()).thenReturn(responseData.getBytes());
+
+        final String responseString = HttpResponses.asResponseString(downloadResponse1);
+
+        assertThat(responseString).isEqualTo(responseData);
+    }
+
+    @Test
+    public void asResponseString_newStringThrowsException_shouldReturnNull() throws Exception {
+        when(downloadResponse1.getByteArray()).thenReturn(null);
+        assertThat(HttpResponses.asResponseString(downloadResponse1)).isNull();
+    }
+
+    @Test
+    public void asResponseString_withNullResponse_shouldReturnNull() throws Exception {
+        final String responseString = HttpResponses.asResponseString(null);
+
+        assertThat(responseString).isNull();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/BaseEventTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/BaseEventTest.java
new file mode 100644
index 00000000..a5c0d99f
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/BaseEventTest.java
@@ -0,0 +1,247 @@
+package com.mopub.common.event;
+
+import com.mopub.common.ClientMetadata;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.annotation.Config;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class BaseEventTest {
+
+    private BaseEvent subject;
+    @Mock private ClientMetadata mockClientMetaData;
+
+    @Before
+    public void setUp() {
+        when(mockClientMetaData.getSdkVersion()).thenReturn("sdk_version");
+        when(mockClientMetaData.getAppName()).thenReturn("app_name");
+        when(mockClientMetaData.getAppPackageName()).thenReturn("app_package_name");
+        when(mockClientMetaData.getAppVersion()).thenReturn("app_version");
+        when(mockClientMetaData.getDeviceId()).thenReturn("client_device_id");
+        when(mockClientMetaData.isDoNotTrackSet()).thenReturn(true);
+        when(mockClientMetaData.getDeviceManufacturer()).thenReturn("device_manufacturer");
+        when(mockClientMetaData.getDeviceModel()).thenReturn("device_model");
+        when(mockClientMetaData.getDeviceProduct()).thenReturn("device_product");
+        when(mockClientMetaData.getDeviceOsVersion()).thenReturn("device_os_version");
+        when(mockClientMetaData.getDeviceScreenWidthDip()).thenReturn(1337);
+        when(mockClientMetaData.getDeviceScreenHeightDip()).thenReturn(70707);
+        when(mockClientMetaData.getActiveNetworkType()).thenReturn(ClientMetadata.MoPubNetworkType.WIFI);
+        when(mockClientMetaData.getNetworkOperator()).thenReturn("network_operator");
+        when(mockClientMetaData.getNetworkOperatorName()).thenReturn("network_operator_name");
+        when(mockClientMetaData.getIsoCountryCode()).thenReturn("network_iso_country_code");
+        when(mockClientMetaData.getSimOperator()).thenReturn("network_sim_operator");
+        when(mockClientMetaData.getSimOperatorName()).thenReturn("network_sim_operator_name");
+        when(mockClientMetaData.getSimIsoCountryCode()).thenReturn("network_sim_iso_country_code");
+        ClientMetadata.setInstance(mockClientMetaData);
+
+        subject = new Event.Builder(BaseEvent.Name.AD_REQUEST, BaseEvent.Category.REQUESTS, 0.10000123)
+                .withSdkProduct(BaseEvent.SdkProduct.NATIVE)
+                .withAdUnitId("8cf00598d3664adaaeccd800e46afaca")
+                .withAdCreativeId("3c2b887e2c2a4cd0ae6a925440a62f0d")
+                .withAdType("html")
+                .withAdNetworkType("admob")
+                .withAdWidthPx(320.0)
+                .withAdHeightPx(50.0)
+                .withGeoLat(37.7833)
+                .withGeoLon(-122.4183333)
+                .withGeoAccuracy(10.0)
+                .withPerformanceDurationMs(100.0)
+                .withRequestId("b550796074da4559a27c5072dcba2b27")
+                .withRequestStatusCode(200)
+                .withRequestUri("https://ads.mopub.com/m/ad?id=8cf00598d3664adaaeccd800e46afaca")
+                .withRequestRetries(0)
+                .build();
+    }
+
+    @After
+    public void tearDown() {
+        ClientMetadata.setInstance(null);
+    }
+
+    @Test
+    public void ScribeCategory_shouldHaveExpectedValues() throws Exception {
+        // We're testing this since our backend data definitions depend on these values matching
+        assertThat(BaseEvent.ScribeCategory.EXCHANGE_CLIENT_EVENT.getCategory())
+                .isEqualTo("exchange_client_event");
+        assertThat(BaseEvent.ScribeCategory.EXCHANGE_CLIENT_ERROR.getCategory())
+                .isEqualTo("exchange_client_error");
+    }
+
+    @Test
+    public void SdkProduct_shouldHaveExpectedValues() throws Exception {
+        // We're testing this since our backend data definitions depend on these values matching
+        assertThat(BaseEvent.SdkProduct.NONE.getType())
+                .isEqualTo(0);
+        assertThat(BaseEvent.SdkProduct.WEB_VIEW.getType())
+                .isEqualTo(1);
+        assertThat(BaseEvent.SdkProduct.NATIVE.getType())
+                .isEqualTo(2);
+    }
+
+    @Test
+    public void AppPlatform_shouldHaveExpectedValues() throws Exception {
+        // We're testing this since our backend data definitions depend on these values matching
+        assertThat(BaseEvent.AppPlatform.NONE.getType())
+                .isEqualTo(0);
+        assertThat(BaseEvent.AppPlatform.IOS.getType())
+                .isEqualTo(1);
+        assertThat(BaseEvent.AppPlatform.ANDROID.getType())
+                .isEqualTo(2);
+        assertThat(BaseEvent.AppPlatform.MOBILE_WEB.getType())
+                .isEqualTo(3);
+    }
+
+    @Test
+    public void Name_shouldHaveExpectedValues() throws Exception {
+        // We're testing this since our backend data definitions depend on these values matching
+        assertThat(BaseEvent.Name.AD_REQUEST.getName())
+                .isEqualTo("ad_request");
+        assertThat(BaseEvent.Name.IMPRESSION_REQUEST.getName())
+                .isEqualTo("impression_request");
+        assertThat(BaseEvent.Name.CLICK_REQUEST.getName())
+                .isEqualTo("click_request");
+    }
+
+    @Test
+    public void Category_shouldHaveExpectedValues() throws Exception {
+        // We're testing this since our backend data definitions depend on these values matching
+        assertThat(BaseEvent.Category.REQUESTS.getCategory())
+                .isEqualTo("requests");
+    }
+
+    @Test
+    public void SamplingRate_shouldHaveExpectedValues() throws Exception {
+        // We're testing this since our backend data definitions depend on these values matching
+        assertThat(BaseEvent.SamplingRate.AD_REQUEST.getSamplingRate()).isEqualTo(0.1);
+    }
+
+    @Test
+    public void constructor_shouldCorrectlyAssignFieldsFromBuilder() throws Exception {
+        assertThat(subject.getSdkProduct()).isEqualTo(BaseEvent.SdkProduct.NATIVE);
+        assertThat(subject.getAdUnitId()).isEqualTo("8cf00598d3664adaaeccd800e46afaca");
+        assertThat(subject.getAdCreativeId()).isEqualTo("3c2b887e2c2a4cd0ae6a925440a62f0d");
+        assertThat(subject.getAdType()).isEqualTo("html");
+        assertThat(subject.getAdNetworkType()).isEqualTo("admob");
+        assertThat(subject.getAdWidthPx()).isEqualTo(320.0);
+        assertThat(subject.getAdHeightPx()).isEqualTo(50.0);
+        assertThat(subject.getGeoLat()).isEqualTo(37.7833);
+        assertThat(subject.getGeoLon()).isEqualTo(-122.4183333);
+        assertThat(subject.getGeoAccuracy()).isEqualTo(10.0);
+        assertThat(subject.getPerformanceDurationMs()).isEqualTo(100.0);
+        assertThat(subject.getRequestId()).isEqualTo("b550796074da4559a27c5072dcba2b27");
+        assertThat(subject.getRequestStatusCode()).isEqualTo(200);
+        assertThat(subject.getRequestUri()).isEqualTo("https://ads.mopub.com/m/ad?id=8cf00598d3664adaaeccd800e46afaca");
+        assertThat(subject.getRequestRetries()).isEqualTo(0);
+        assertThat(subject.getSamplingRate()).isEqualTo(0.10000123);
+    }
+
+    @Test
+    public void getSdkVersion_shouldReturnClientMetaDataSdkVersion() throws Exception {
+        assertThat(subject.getSdkVersion()).isEqualTo("sdk_version");
+    }
+
+    @Test
+    public void getAppName_shouldReturnClientMetaDataAppName() throws Exception {
+        assertThat(subject.getAppName()).isEqualTo("app_name");
+    }
+
+    @Test
+    public void getAppPackageName_shouldReturnClientMetaDataAppPackageName() throws Exception {
+        assertThat(subject.getAppPackageName()).isEqualTo("app_package_name");
+    }
+
+    @Test
+    public void getAppVersion_shouldReturnClientMetaDataAppVersion() throws Exception {
+        assertThat(subject.getAppVersion()).isEqualTo("app_version");
+    }
+
+    @Test
+    public void getClientAdvertisingId_shouldReturnClientMetaDataDeviceId() throws Exception {
+        assertThat(subject.getClientAdvertisingId()).isEqualTo("client_device_id");
+    }
+
+    @Test
+    public void getObfuscatedClientAdvertisingId_shouldReturnObfuscatedDeviceId() throws Exception {
+        assertThat(subject.getObfuscatedClientAdvertisingId()).isEqualTo("ifa:XXXX");
+    }
+
+    @Test
+    public void getClientDoNotTrack_shouldReturnClientMetaDataDoNotTrack() throws Exception {
+        assertThat(subject.getClientDoNotTrack()).isEqualTo(true);
+    }
+
+    @Test
+    public void getDeviceManufacturer_shouldReturnClientMetaDataDeviceManufacturer() throws Exception {
+        assertThat(subject.getDeviceManufacturer()).isEqualTo("device_manufacturer");
+    }
+
+    @Test
+    public void getDeviceModel_shouldReturnClientMetaDataDeviceModel() throws Exception {
+        assertThat(subject.getDeviceModel()).isEqualTo("device_model");
+    }
+
+    @Test
+    public void getDeviceProduct_shouldReturnClientMetaDataDeviceProduct() throws Exception {
+        assertThat(subject.getDeviceProduct()).isEqualTo("device_product");
+    }
+
+    @Test
+    public void getDeviceOsVersion_shouldReturnClientMetaDataDeviceOsVersion() throws Exception {
+        assertThat(subject.getDeviceOsVersion()).isEqualTo("device_os_version");
+    }
+
+    @Test
+    public void getDeviceScreenWidthDip_shouldReturnClientMetaDataDeviceScreenWidthDip() throws Exception {
+        assertThat(subject.getDeviceScreenWidthDip()).isEqualTo(1337);
+    }
+
+    @Test
+    public void getDeviceScreenHeightDip_shouldReturnClientMetaDataDeviceScreenHeightDip() throws Exception {
+        assertThat(subject.getDeviceScreenHeightDip()).isEqualTo(70707);
+    }
+
+    @Test
+    public void getNetworkType_shouldReturnClientMetaDataActiveNetworkType() throws Exception {
+        assertThat(subject.getNetworkType()).isEqualTo(ClientMetadata.MoPubNetworkType.WIFI);
+    }
+
+    @Test
+    public void getNetworkOperatorCode_shouldReturnClientMetaDataNetworkOperator() throws Exception {
+        assertThat(subject.getNetworkOperatorCode()).isEqualTo("network_operator");
+    }
+
+    @Test
+    public void getNetworkOperatorName_shouldReturnClientMetaDataNetworkOperatorName() throws Exception {
+        assertThat(subject.getNetworkOperatorName()).isEqualTo("network_operator_name");
+    }
+
+    @Test
+    public void getNetworkIsoCountryCode_shouldReturnClientMetaDataNetworkIsoCountryCode() throws Exception {
+        assertThat(subject.getNetworkIsoCountryCode()).isEqualTo("network_iso_country_code");
+    }
+
+    @Test
+    public void getNetworkSimCode_shouldReturnClientMetaDataNetworkSimOperator() throws Exception {
+        assertThat(subject.getNetworkSimCode()).isEqualTo("network_sim_operator");
+    }
+
+    @Test
+    public void getNetworkSimOperatorName_shouldReturnClientMetaDataNetworkSimOperatorName() throws Exception {
+        assertThat(subject.getNetworkSimOperatorName()).isEqualTo("network_sim_operator_name");
+    }
+
+    @Test
+    public void getNetworkSimIsoCountryCode_shouldReturnClientMetaDataNetworkSimIsoCountryCode() throws Exception {
+        assertThat(subject.getNetworkSimIsoCountryCode()).isEqualTo("network_sim_iso_country_code");
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/ErrorEventTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/ErrorEventTest.java
new file mode 100644
index 00000000..957552b1
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/ErrorEventTest.java
@@ -0,0 +1,77 @@
+package com.mopub.common.event;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class ErrorEventTest {
+
+    private ErrorEvent subject;
+
+    @Before
+    public void setUp() {
+        subject = new ErrorEvent.Builder(BaseEvent.Name.AD_REQUEST, BaseEvent.Category.REQUESTS, 0.10000123)
+                .withErrorExceptionClassName("error_exception_class_name")
+                .withErrorMessage("error_message")
+                .withErrorStackTrace("error_stack_trace")
+                .withErrorFileName("error_file_name")
+                .withErrorClassName("error_class_name")
+                .withErrorMethodName("error_method_name")
+                .withErrorLineNumber(123)
+                .build();
+    }
+
+    @Test
+    public void constructor_shouldCorrectlyAssignFieldsFromBuilder() throws Exception {
+        assertThat(subject.getName()).isEqualTo(BaseEvent.Name.AD_REQUEST);
+        assertThat(subject.getCategory()).isEqualTo(BaseEvent.Category.REQUESTS);
+        assertThat(subject.getSamplingRate()).isEqualTo(0.10000123);
+        assertThat(subject.getScribeCategory()).isEqualTo(BaseEvent.ScribeCategory.EXCHANGE_CLIENT_ERROR);
+        assertThat(subject.getErrorExceptionClassName()).isEqualTo("error_exception_class_name");
+        assertThat(subject.getErrorMessage()).isEqualTo("error_message");
+        assertThat(subject.getErrorStackTrace()).isEqualTo("error_stack_trace");
+        assertThat(subject.getErrorFileName()).isEqualTo("error_file_name");
+        assertThat(subject.getErrorClassName()).isEqualTo("error_class_name");
+        assertThat(subject.getErrorMethodName()).isEqualTo("error_method_name");
+        assertThat(subject.getErrorLineNumber()).isEqualTo(123);
+    }
+
+    @Test
+    public void builder_withException_shouldCorrectlyPopulateErrorFields() throws Exception {
+        Exception exception;
+        try {
+            throw new ClassCastException("bad cast");
+        } catch (Exception e)  {
+            exception = e;
+        }
+
+        subject = new ErrorEvent.Builder(BaseEvent.Name.AD_REQUEST, BaseEvent.Category.REQUESTS, 0.10000123)
+                .withException(exception)
+                .build();
+
+        assertThat(subject.getName()).isEqualTo(BaseEvent.Name.AD_REQUEST);
+        assertThat(subject.getCategory()).isEqualTo(BaseEvent.Category.REQUESTS);
+        assertThat(subject.getScribeCategory()).isEqualTo(BaseEvent.ScribeCategory.EXCHANGE_CLIENT_ERROR);
+        assertThat(subject.getErrorExceptionClassName()).isEqualTo("java.lang.ClassCastException");
+        assertThat(subject.getErrorMessage()).isEqualTo("bad cast");
+
+        // We can't reliably check the stack trace since it changes from one run to another
+//        assertThat(subject.getErrorStackTrace()).isEqualTo();
+
+        assertThat(subject.getErrorFileName()).isEqualTo("ErrorEventTest.java");
+        assertThat(subject.getErrorClassName()).isEqualTo("com.mopub.common.event.ErrorEventTest");
+        assertThat(subject.getErrorMethodName()).isEqualTo("builder_withException_shouldCorrectlyPopulateErrorFields");
+
+        // Ideally we check the actual line number here, but since this file is continuously
+        // changing, it makes the test brittle to do so
+        assertThat(subject.getErrorLineNumber()).isNotNull();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/EventDispatcherTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/EventDispatcherTest.java
new file mode 100644
index 00000000..9b3fef29
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/EventDispatcherTest.java
@@ -0,0 +1,67 @@
+package com.mopub.common.event;
+
+import android.app.Activity;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.Message;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.annotation.Config;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class EventDispatcherTest {
+
+    private EventDispatcher subject;
+    private List<EventRecorder> recorders;
+    @Mock private EventRecorder mockEventRecorder1;
+    @Mock private EventRecorder mockEventRecorder2;
+    @Mock private HandlerThread mockHandlerThread;
+
+    @Before
+    public void setUp() {
+        recorders = new ArrayList<EventRecorder>();
+        recorders.add(mockEventRecorder1);
+        recorders.add(mockEventRecorder2);
+    }
+
+    @Test
+    public void handler_handleMessage_shouldCallRecordOnAllRecorders() throws Exception {
+        Message message = new Message();
+        message.obj = mock(Event.class);
+
+        subject = new EventDispatcher(recorders, Looper.getMainLooper());
+        subject.getHandlerCallback().handleMessage(message);
+
+        verify(mockEventRecorder1).record(eq((Event) message.obj));
+        verify(mockEventRecorder2).record(eq((Event) message.obj));
+    }
+
+    @Test
+    public void handler_handleMessage_withNonBaseEventTypeMessageShouldNotRecordOnAnyRecorders() throws Exception {
+        Message message = new Message();
+        message.obj = mock(Activity.class);
+
+        subject = new EventDispatcher(recorders, Looper.getMainLooper());
+        subject.getHandlerCallback().handleMessage(message);
+
+        verify(mockEventRecorder1, never()).record(any(BaseEvent.class));
+        verify(mockEventRecorder2, never()).record(any(BaseEvent.class));
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/EventSamplerTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/EventSamplerTest.java
new file mode 100644
index 00000000..b4b2d15e
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/EventSamplerTest.java
@@ -0,0 +1,89 @@
+package com.mopub.common.event;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.stubbing.OngoingStubbing;
+import org.robolectric.annotation.Config;
+
+import java.util.Random;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class EventSamplerTest {
+
+    private EventSampler subject;
+    @Mock Random mockRandom;
+    @Mock BaseEvent mockBaseEvent;
+
+    @Before
+    public void setUp() {
+        subject = new EventSampler(mockRandom);
+        when(mockBaseEvent.getSamplingRate()).thenReturn(0.10);
+    }
+
+    @Test
+    public void sample_withRandomNumberLessThan10Percent_shouldReturnTrue() throws Exception {
+        when(mockRandom.nextDouble()).thenReturn(0.09);
+
+        boolean result = subject.sample(mockBaseEvent);
+
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void sample_withRandomNumberGreaterOrEqualTo10Percent_shouldReturnFalse() throws Exception {
+        when(mockRandom.nextDouble()).thenReturn(0.10);
+
+        boolean result = subject.sample(mockBaseEvent);
+
+        assertThat(result).isFalse();
+    }
+
+    @Test
+    public void sample_withSameRequestId_shouldReturnSameValueRegardlessOfSampleRate() throws Exception {
+        when(mockRandom.nextDouble()).thenReturn(0.09).thenReturn(0.999);
+        when(mockBaseEvent.getRequestId()).thenReturn("rid");
+
+        boolean firstResult = subject.sample(mockBaseEvent);
+        assertThat(firstResult).isTrue();
+
+        boolean secondResult = subject.sample(mockBaseEvent);
+        assertThat(secondResult).isTrue();
+    }
+
+    @Test
+    public void sample_withDifferentRequestId_shouldReturnResultBasedOnSampleRate() throws Exception {
+        when(mockRandom.nextDouble()).thenReturn(0.09).thenReturn(0.999);
+        when(mockBaseEvent.getRequestId()).thenReturn("rid1").thenReturn("rid2");
+
+        boolean firstResult = subject.sample(mockBaseEvent);
+        assertThat(firstResult).isTrue();
+
+        boolean secondResult = subject.sample(mockBaseEvent);
+        assertThat(secondResult).isFalse();
+    }
+
+    @Test
+    public void sample_withTooManyEvents_shouldHoldAMaximumNumberOfRequestIds() {
+        when(mockRandom.nextDouble()).thenReturn(0.001);
+        OngoingStubbing<String> ongoingStubbing = when(mockBaseEvent.getRequestId()).thenReturn(
+                "rid0");
+        for (int i = 1; i < EventSampler.MAX_SIZE * 3; i++) {
+            ongoingStubbing = ongoingStubbing.thenReturn("rid" + i);
+        }
+
+        for (int i = 0; i < EventSampler.MAX_SIZE * 3; i++) {
+            subject.sample(mockBaseEvent);
+        }
+
+        assertThat(subject.getCacheSize()).isEqualTo(EventSampler.MAX_SIZE);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/EventSerializerTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/EventSerializerTest.java
new file mode 100644
index 00000000..34d030ba
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/EventSerializerTest.java
@@ -0,0 +1,216 @@
+package com.mopub.common.event;
+
+import android.app.Activity;
+import android.content.Context;
+
+import com.mopub.common.ClientMetadata;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
+
+import org.json.JSONArray;
+import org.json.JSONObject;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+
+import java.util.ArrayList;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class EventSerializerTest {
+
+    private EventSerializer subject;
+
+    @Mock private Event mockEvent;
+    @Mock private ErrorEvent mockErrorEvent;
+
+    @Before
+    public void setUp() {
+        subject = new EventSerializer();
+
+        // initialize client meta data with context
+        Context context = Robolectric.buildActivity(Activity.class).create().get();
+        ClientMetadata.getInstance(context);
+
+        populateBaseEventFields(mockEvent);
+        populateBaseEventFields(mockErrorEvent);
+
+        when(mockErrorEvent.getErrorExceptionClassName()).thenReturn("error_exception_class_name");
+        when(mockErrorEvent.getErrorMessage()).thenReturn("error_message");
+        when(mockErrorEvent.getErrorStackTrace()).thenReturn("error_stack_trace");
+        when(mockErrorEvent.getErrorFileName()).thenReturn("error_file_name");
+        when(mockErrorEvent.getErrorClassName()).thenReturn("error_class_name");
+        when(mockErrorEvent.getErrorMethodName()).thenReturn("error_method_name");
+        when(mockErrorEvent.getErrorLineNumber()).thenReturn(123);
+    }
+
+    @Test
+    public void serializeAsJson_withAllEventFieldsPopulated_shouldCorrectJsonRepresentation() throws Exception {
+        ArrayList<BaseEvent> events = new ArrayList<BaseEvent>();
+        events.add(mockEvent);
+        JSONArray jsonArray = subject.serializeAsJson(events);
+        assertThat(jsonArray.length()).isEqualTo(1);
+
+        JSONObject jsonObject = jsonArray.getJSONObject(0);
+        validateBaseEventFields(jsonObject);
+    }
+
+    @Test
+    public void serializeAsJson_withAllErrorEventFieldsPopulated_shouldCorrectJsonRepresentation() throws Exception {
+        ArrayList<BaseEvent> events = new ArrayList<BaseEvent>();
+        events.add(mockErrorEvent);
+        JSONArray jsonArray = subject.serializeAsJson(events);
+        assertThat(jsonArray.length()).isEqualTo(1);
+
+        JSONObject jsonObject = jsonArray.getJSONObject(0);
+        validateBaseEventFields(jsonObject);
+
+        assertThat(jsonObject.getString("error_exception_class_name")).isEqualTo("error_exception_class_name");
+        assertThat(jsonObject.getString("error_message")).isEqualTo("error_message");
+        assertThat(jsonObject.getString("error_stack_trace")).isEqualTo("error_stack_trace");
+        assertThat(jsonObject.getString("error_file_name")).isEqualTo("error_file_name");
+        assertThat(jsonObject.getString("error_class_name")).isEqualTo("error_class_name");
+        assertThat(jsonObject.getString("error_method_name")).isEqualTo("error_method_name");
+        assertThat(jsonObject.getInt("error_line_number")).isEqualTo(123);
+    }
+
+    @Test
+    public void serializeAsJson_shouldReturnJsonArrayOfEvents() throws Exception {
+        when(mockEvent.getName()).thenReturn(BaseEvent.Name.AD_REQUEST);
+        when(mockEvent.getCategory()).thenReturn(BaseEvent.Category.REQUESTS);
+        when(mockErrorEvent.getName()).thenReturn(BaseEvent.Name.IMPRESSION_REQUEST);
+        when(mockErrorEvent.getCategory()).thenReturn(BaseEvent.Category.REQUESTS);
+
+        ArrayList<BaseEvent> events = new ArrayList<BaseEvent>();
+        events.add(mockEvent);
+        events.add(mockErrorEvent);
+
+        JSONArray jsonArray = subject.serializeAsJson(events);
+        assertThat(jsonArray.length()).isEqualTo(2);
+
+        JSONObject jsonObject1 = jsonArray.getJSONObject(0);
+        assertThat(jsonObject1.getString("name")).isEqualTo(BaseEvent.Name.AD_REQUEST.getName());
+        assertThat(jsonObject1.getString("name_category")).isEqualTo("requests");
+
+        JSONObject jsonObject2 = jsonArray.getJSONObject(1);
+        assertThat(jsonObject2.getString("name")).isEqualTo("impression_request");
+        assertThat(jsonObject2.getString("name_category")).isEqualTo("requests");
+    }
+
+    private void populateBaseEventFields(BaseEvent mockBaseEvent) {
+        when(mockBaseEvent.getScribeCategory()).thenReturn(BaseEvent.ScribeCategory.EXCHANGE_CLIENT_EVENT);
+        when(mockBaseEvent.getName()).thenReturn(BaseEvent.Name.AD_REQUEST);
+        when(mockBaseEvent.getCategory()).thenReturn(BaseEvent.Category.REQUESTS);
+        when(mockBaseEvent.getSdkProduct()).thenReturn(BaseEvent.SdkProduct.NATIVE);
+        when(mockBaseEvent.getSdkVersion()).thenReturn("3.5.0");
+        when(mockBaseEvent.getAdUnitId()).thenReturn("8cf00598d3664adaaeccd800e46afaca");
+        when(mockBaseEvent.getAdCreativeId()).thenReturn("3c2b887e2c2a4cd0ae6a925440a62f0d");
+        when(mockBaseEvent.getAdType()).thenReturn("html");
+        when(mockBaseEvent.getAdNetworkType()).thenReturn("admob");
+        when(mockBaseEvent.getAdWidthPx()).thenReturn(320.0);
+        when(mockBaseEvent.getAdHeightPx()).thenReturn(50.0);
+        when(mockBaseEvent.getDspCreativeId()).thenReturn("jack!fake234");
+        when(mockBaseEvent.getAppPlatform()).thenReturn(BaseEvent.AppPlatform.ANDROID);
+        when(mockBaseEvent.getAppName()).thenReturn("MoPub Sample App");
+        when(mockBaseEvent.getAppPackageName()).thenReturn("com.mopub.simpleadsdemo");
+        when(mockBaseEvent.getAppVersion()).thenReturn("1.0");
+        when(mockBaseEvent.getObfuscatedClientAdvertisingId()).thenCallRealMethod();
+        when(mockBaseEvent.getClientAdvertisingId()).thenReturn("38400000-8cf0-11bd-b23e-10b96e40000d");
+        when(mockBaseEvent.getClientDoNotTrack()).thenReturn(false);
+        when(mockBaseEvent.getDeviceManufacturer()).thenReturn("LGE");
+        when(mockBaseEvent.getDeviceModel()).thenReturn("Nexus 5");
+        when(mockBaseEvent.getDeviceProduct()).thenReturn("hammerhead");
+        when(mockBaseEvent.getDeviceOsVersion()).thenReturn("5.0");
+        when(mockBaseEvent.getDeviceScreenWidthDip()).thenReturn(1080);
+        when(mockBaseEvent.getDeviceScreenHeightDip()).thenReturn(1920);
+        when(mockBaseEvent.getGeoLat()).thenReturn(37.7833);
+        when(mockBaseEvent.getGeoLon()).thenReturn(-122.4183333);
+        when(mockBaseEvent.getGeoAccuracy()).thenReturn(10.0);
+        when(mockBaseEvent.getPerformanceDurationMs()).thenReturn(100.0);
+        when(mockBaseEvent.getNetworkType()).thenReturn(ClientMetadata.MoPubNetworkType.WIFI);
+        when(mockBaseEvent.getNetworkOperatorCode()).thenReturn("310410");
+        when(mockBaseEvent.getNetworkOperatorName()).thenReturn("AT&T");
+        when(mockBaseEvent.getNetworkIsoCountryCode()).thenReturn("US");
+        when(mockBaseEvent.getNetworkSimCode()).thenReturn("network_sim_code");
+        when(mockBaseEvent.getNetworkSimOperatorName()).thenReturn("network_operator_name");
+        when(mockBaseEvent.getNetworkSimIsoCountryCode()).thenReturn("US");
+        when(mockBaseEvent.getRequestId()).thenReturn("b550796074da4559a27c5072dcba2b27");
+        when(mockBaseEvent.getRequestStatusCode()).thenReturn(200);
+        when(mockBaseEvent.getRequestUri()).thenReturn("https://ads.mopub.com/m/ad?id=8cf00598d3664adaaeccd800e46afaca");
+        when(mockBaseEvent.getRequestRetries()).thenReturn(0);
+        when(mockBaseEvent.getTimestampUtcMs()).thenReturn(1416447053472L);
+    }
+
+    private void validateBaseEventFields(JSONObject jsonObject) throws Exception {
+        assertThat(jsonObject.getString("_category_")).isEqualTo("exchange_client_event");
+        assertThat(jsonObject.getLong("ts")).isEqualTo(1416447053472L);
+
+        // Name Details
+        assertThat(jsonObject.getString("name")).isEqualTo(BaseEvent.Name.AD_REQUEST.getName());
+        assertThat(jsonObject.getString("name_category")).isEqualTo(BaseEvent.Category.REQUESTS.getCategory());
+
+        // SDK Details
+        assertThat(jsonObject.getInt("sdk_product")).isEqualTo(BaseEvent.SdkProduct.NATIVE.getType());
+        assertThat(jsonObject.getString("sdk_version")).isEqualTo("3.5.0");
+
+        // Ad Details
+        assertThat(jsonObject.getString("ad_unit_id")).isEqualTo("8cf00598d3664adaaeccd800e46afaca");
+        assertThat(jsonObject.getString("ad_creative_id")).isEqualTo("3c2b887e2c2a4cd0ae6a925440a62f0d");
+        assertThat(jsonObject.getString("ad_type")).isEqualTo("html");
+        assertThat(jsonObject.getString("ad_network_type")).isEqualTo("admob");
+        assertThat(jsonObject.getDouble("ad_width_px")).isEqualTo(320.0);
+        assertThat(jsonObject.getDouble("ad_height_px")).isEqualTo(50.0);
+        assertThat(jsonObject.getString("dsp_creative_id")).isEqualTo("jack!fake234");
+
+        // App Details
+        assertThat(jsonObject.getInt("app_platform")).isEqualTo(2);
+        assertThat(jsonObject.getString("app_name")).isEqualTo("MoPub Sample App");
+        assertThat(jsonObject.getString("app_package_name")).isEqualTo("com.mopub.simpleadsdemo");
+        assertThat(jsonObject.getString("app_version")).isEqualTo("1.0");
+
+        // Client Details
+        assertThat(jsonObject.getString("client_advertising_id")).isEqualTo("ifa:XXXX");
+        assertThat(jsonObject.getBoolean("client_do_not_track")).isEqualTo(false);
+
+        // Device Details
+        assertThat(jsonObject.getString("device_manufacturer")).isEqualTo("LGE");
+        assertThat(jsonObject.getString("device_model")).isEqualTo("Nexus 5");
+        assertThat(jsonObject.getString("device_product")).isEqualTo("hammerhead");
+        assertThat(jsonObject.getString("device_os_version")).isEqualTo("5.0");
+        assertThat(jsonObject.getInt("device_screen_width_px")).isEqualTo(1080);
+        assertThat(jsonObject.getInt("device_screen_height_px")).isEqualTo(1920);
+
+        // Geo Details
+        assertThat(jsonObject.getDouble("geo_lat")).isEqualTo(37.7833);
+        assertThat(jsonObject.getDouble("geo_lon")).isEqualTo(-122.4183333);
+        assertThat(jsonObject.getDouble("geo_accuracy_radius_meters")).isEqualTo(10.0);
+
+        // Performance Details
+        assertThat(jsonObject.getDouble("perf_duration_ms")).isEqualTo(100.0);
+
+        // Network Details
+        assertThat(jsonObject.getInt("network_type")).isEqualTo(ClientMetadata.MoPubNetworkType.WIFI.getId());
+        assertThat(jsonObject.getString("network_operator_code")).isEqualTo("310410");
+        assertThat(jsonObject.getString("network_operator_name")).isEqualTo("AT&T");
+        assertThat(jsonObject.getString("network_iso_country_code")).isEqualTo("US");
+        assertThat(jsonObject.getString("network_sim_code")).isEqualTo("network_sim_code");
+        assertThat(jsonObject.getString("network_sim_operator_name")).isEqualTo("network_operator_name");
+        assertThat(jsonObject.getString("network_sim_iso_country_code")).isEqualTo("US");
+
+        // Request Details
+        assertThat(jsonObject.getString("req_id")).isEqualTo("b550796074da4559a27c5072dcba2b27");
+        assertThat(jsonObject.getInt("req_status_code")).isEqualTo(200);
+        assertThat(jsonObject.getString("req_uri")).isEqualTo("https://ads.mopub.com/m/ad?id=8cf00598d3664adaaeccd800e46afaca");
+        assertThat(jsonObject.getInt("req_retries")).isEqualTo(0);
+
+        // Timestamp Details
+        assertThat(jsonObject.getLong("timestamp_client")).isEqualTo(1416447053472L);
+    }
+}
+
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/EventTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/EventTest.java
new file mode 100644
index 00000000..3384f75e
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/EventTest.java
@@ -0,0 +1,31 @@
+package com.mopub.common.event;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class EventTest {
+
+    private Event subject;
+
+    @Before
+    public void setUp() {
+        subject = new Event.Builder(BaseEvent.Name.AD_REQUEST, BaseEvent.Category.REQUESTS, 0.10000123).build();
+    }
+
+    @Test
+    public void constructor_shouldCorrectlyAssignScribeCategoryFromBuilder() {
+        assertThat(subject.getName()).isEqualTo(BaseEvent.Name.AD_REQUEST);
+        assertThat(subject.getCategory()).isEqualTo(BaseEvent.Category.REQUESTS);
+        assertThat(subject.getSamplingRate()).isEqualTo(0.10000123);
+        assertThat(subject.getScribeCategory()).isEqualTo(BaseEvent.ScribeCategory.EXCHANGE_CLIENT_EVENT);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/MoPubEventsTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/MoPubEventsTest.java
new file mode 100644
index 00000000..2bf68573
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/MoPubEventsTest.java
@@ -0,0 +1,54 @@
+package com.mopub.common.event;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+
+import java.util.ArrayList;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class MoPubEventsTest {
+
+    @Before
+    public void setUp() {
+        MoPubEvents.setEventDispatcher(null);
+    }
+
+    @Test
+    public void getDispatcher_shouldReturnSingletonEventDispatcherWithScribeEventRecorder() throws Exception {
+        EventDispatcher eventDispatcher = MoPubEvents.getDispatcher();
+        EventDispatcher eventDispatcher2 = MoPubEvents.getDispatcher();
+
+        assertThat(eventDispatcher).isEqualTo(eventDispatcher2);
+
+        Iterable<EventRecorder> eventRecorderIterable = eventDispatcher.getEventRecorders();
+        ArrayList<EventRecorder> eventRecorders = new ArrayList<EventRecorder>();
+        for (EventRecorder recorder : eventRecorderIterable) {
+            eventRecorders.add(recorder);
+        }
+
+        assertThat(eventRecorders.size()).isEqualTo(1);
+        assertThat(eventRecorders.get(0)).isInstanceOf(ScribeEventRecorder.class);
+    }
+
+    @Test
+    public void log_shouldDispatchEvent() throws Exception {
+        EventDispatcher mockEventDispatcher = mock(EventDispatcher.class);
+        MoPubEvents.setEventDispatcher(mockEventDispatcher);
+
+        Event mockEvent = mock(Event.class);
+        MoPubEvents.log(mockEvent);
+
+        verify(mockEventDispatcher).dispatch(mockEvent);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/event/ScribeEventRecorderTest.java b/mopub-sdk/src/test/java/com/mopub/common/event/ScribeEventRecorderTest.java
new file mode 100644
index 00000000..7305cc7b
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/event/ScribeEventRecorderTest.java
@@ -0,0 +1,213 @@
+package com.mopub.common.event;
+
+import android.os.Handler;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
+import com.mopub.network.ScribeBackoffPolicy;
+import com.mopub.network.ScribeRequest;
+import com.mopub.network.ScribeRequestManager;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.annotation.Config;
+
+import java.util.List;
+import java.util.Queue;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyLong;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class ScribeEventRecorderTest {
+
+    private ScribeEventRecorder subject;
+    @Mock private EventSampler mockEventSampler;
+    @Mock private Queue<BaseEvent> mockQueue;
+    @Mock private EventSerializer mockEventSerializer;
+    @Mock private ScribeRequestManager mockScribeRequestManager;
+    @Mock private Handler mockHandler;
+    @Mock private Event mockEvent;
+
+    @Before
+    public void setUp() {
+        subject = new ScribeEventRecorder(
+                mockEventSampler,
+                mockQueue,
+                mockEventSerializer,
+                mockScribeRequestManager,
+                mockHandler
+        );
+
+        when(mockEventSampler.sample(any(Event.class))).thenReturn(true);
+    }
+
+    @Test
+    public void record_shouldSampleEvent() throws Exception {
+        subject.record(mockEvent);
+        verify(mockEventSampler).sample(mockEvent);
+    }
+
+    @Test
+    public void record_withQueueSizeBelowSendThreshold_shouldQueueEvent_shouldNotSendEvents_shouldScheduleNextPoll() throws Exception {
+        when(mockQueue.size()).thenReturn(99);
+
+        subject.record(mockEvent);
+
+        verify(mockQueue).add(mockEvent);
+        verify(mockScribeRequestManager, never()).makeRequest(any(ScribeRequest.ScribeRequestFactory.class), any(ScribeBackoffPolicy.class));
+        verify(mockHandler).postDelayed(any(ScribeEventRecorder.PollingRunnable.class), eq(Long.valueOf(120000)));
+    }
+
+    @Test
+    public void record_withQueueSizeAtSendThreshold_shouldQueueEvent_shouldSendEvents_shouldScheduleNextPoll() throws Exception {
+        when(mockQueue.size()).thenReturn(100);
+        when(mockQueue.peek()).thenReturn(mockEvent);
+        when(mockQueue.poll()).thenReturn(mockEvent);
+
+        subject.record(mockEvent);
+
+        verify(mockQueue).add(mockEvent);
+        verify(mockScribeRequestManager).makeRequest(any(ScribeRequest.ScribeRequestFactory.class), any(ScribeBackoffPolicy.class));
+        verify(mockHandler).postDelayed(any(ScribeEventRecorder.PollingRunnable.class), eq(Long.valueOf(120000)));
+    }
+
+    @Test
+    public void record_withQueueSizeAtQueueLimit_shouldNotQueueEvent_shouldNotSendEvents_shouldNotScheduleNextPoll() throws Exception {
+        when(mockQueue.size()).thenReturn(500);
+
+        subject.record(mockEvent);
+
+        verify(mockQueue, never()).add(mockEvent);
+        verify(mockScribeRequestManager, never()).makeRequest(any(ScribeRequest.ScribeRequestFactory.class), any(ScribeBackoffPolicy.class));
+        verify(mockHandler, never()).postDelayed(any(ScribeEventRecorder.PollingRunnable.class), anyLong());
+    }
+
+    @Test
+    public void sendEvents_shouldDequeueEvents_shouldAddRequestToScribeRequestManager() throws Exception {
+        when(mockQueue.size()).thenReturn(1);
+        when(mockQueue.peek()).thenReturn(mockEvent).thenReturn(null);
+        when(mockQueue.poll()).thenReturn(mockEvent).thenReturn(null);
+        doAnswer(new Answer() {
+            @Override
+            public Object answer(InvocationOnMock invocation) throws Throwable {
+                ScribeRequest scribeRequest = ((ScribeRequest.ScribeRequestFactory) invocation.getArguments()[0]).createRequest(null);
+                assertThat(scribeRequest.getUrl()).isEqualTo("https://analytics.mopub.com/i/jot/exchange_client_event");
+                assertThat(scribeRequest.getEvents()).containsOnly(mockEvent);
+                return null;
+            }
+        }).when(mockScribeRequestManager).makeRequest(any(ScribeRequest.ScribeRequestFactory.class), any(ScribeBackoffPolicy.class));
+
+        subject.sendEvents();
+
+        verify(mockQueue, times(2)).peek();
+        verify(mockQueue, times(1)).poll();
+        verify(mockScribeRequestManager).makeRequest(any(ScribeRequest.ScribeRequestFactory.class), any(ScribeBackoffPolicy.class));
+    }
+
+    @Test
+    public void sendEvents_withRequestInFlightShouldReturnFast() throws Exception {
+        when(mockScribeRequestManager.isAtCapacity()).thenReturn(true);
+
+        subject.sendEvents();
+
+        verify(mockQueue, never()).poll();
+        verify(mockScribeRequestManager, never()).makeRequest(any(ScribeRequest.ScribeRequestFactory.class), any(ScribeBackoffPolicy.class));
+    }
+    
+    @Test
+    public void dequeEvents_withQueueSizeGreaterThanEventSendThreshhold_shouldDequeueUpToEventSendThreshhold() throws Exception {
+        when(mockQueue.size()).thenReturn(101);
+        when(mockQueue.peek()).thenReturn(mockEvent);
+        when(mockQueue.poll()).thenReturn(mockEvent);
+
+        List<BaseEvent> events = subject.dequeueEvents();
+
+        verify(mockQueue, times(101)).peek();
+        verify(mockQueue, times(100)).poll();
+        assertThat(events.size()).isEqualTo(100);
+    }
+
+    @Test
+    public void dequeEvents_withQueueSizeLessThanEventSendThreshhold_shouldDequeueQueueSize() throws Exception {
+        when(mockQueue.size()).thenReturn(99);
+
+        when(mockQueue.peek()).thenAnswer(new Answer<BaseEvent>() {
+            int i;
+            @Override
+            public BaseEvent answer(InvocationOnMock invocation) throws Throwable {
+                return i++ < 99 ? mockEvent : null;
+            }
+        });
+
+        when(mockQueue.poll()).thenAnswer(new Answer<BaseEvent>() {
+            int i;
+            @Override
+            public BaseEvent answer(InvocationOnMock invocation) throws Throwable {
+                return i++ < 99 ? mockEvent : null;
+            }
+        });
+
+        List<BaseEvent> events = subject.dequeueEvents();
+
+        verify(mockQueue, times(100)).peek();
+        verify(mockQueue, times(99)).poll();
+        assertThat(events.size()).isEqualTo(99);
+    }
+
+    @Test
+    public void scheduleNextPoll_shouldPostDelayedPollingRunnable() throws Exception {
+        when(mockHandler.hasMessages(0)).thenReturn(false);
+        when(mockQueue.isEmpty()).thenReturn(false);
+
+        subject.scheduleNextPoll();
+
+        verify(mockHandler).postDelayed(any(ScribeEventRecorder.PollingRunnable.class), eq(Long.valueOf(120000)));
+    }
+
+    @Test
+    public void scheduleNextPoll_withPollScheduled_shouldNotPostDelayedPollingRunnable() throws Exception {
+        when(mockHandler.hasMessages(0)).thenReturn(true);
+        when(mockQueue.isEmpty()).thenReturn(false);
+
+        subject.scheduleNextPoll();
+
+        verify(mockHandler, never()).postDelayed(any(ScribeEventRecorder.PollingRunnable.class), anyLong());
+    }
+
+    @Test
+    public void scheduleNextPoll_withEmptyRequestQueue_shouldNotPostDelayedPollingRunnable() throws Exception {
+        when(mockHandler.hasMessages(0)).thenReturn(false);
+        when(mockQueue.isEmpty()).thenReturn(true);
+
+        subject.scheduleNextPoll();
+
+        verify(mockHandler, never()).postDelayed(any(ScribeEventRecorder.PollingRunnable.class), anyLong());
+    }
+
+    @Test
+    public void PollingRunnable_run_shouldSendEvents_shouldScheduleNextPoll() throws Exception {
+        when(mockQueue.size()).thenReturn(100);
+        when(mockQueue.peek()).thenReturn(mockEvent);
+        when(mockQueue.poll()).thenReturn(mockEvent);
+
+        ScribeEventRecorder.PollingRunnable pollingRunnable = subject.new PollingRunnable();
+        pollingRunnable.run();
+
+        verify(mockScribeRequestManager).makeRequest(any(ScribeRequest.ScribeRequestFactory.class), any(ScribeBackoffPolicy.class));
+        verify(mockHandler).postDelayed(any(ScribeEventRecorder.PollingRunnable.class), eq(Long.valueOf(120000)));
+    }
+}
+
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdRequestStatusMappingTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdRequestStatusMappingTest.java
new file mode 100644
index 00000000..bc66ea83
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/AdRequestStatusMappingTest.java
@@ -0,0 +1,129 @@
+package com.mopub.mobileads;
+
+import com.mopub.common.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class AdRequestStatusMappingTest {
+    private AdRequestStatusMapping subject;
+    private String key1;
+
+    @Before
+    public void setUp() {
+        subject = new AdRequestStatusMapping();
+        key1 = "adUnitId1";
+    }
+
+    @Test
+    public void markFail_shouldNullOutAllValues() {
+        subject.markFail(key1);
+
+        assertThat(subject.getFailoverUrl(key1)).isNull();
+        assertThat(subject.getImpressionTrackerUrlString(key1)).isNull();
+        assertThat(subject.getClickTrackerUrlString(key1)).isNull();
+
+        assertThat(subject.canPlay(key1)).isFalse();
+        assertThat(subject.isLoading(key1)).isFalse();
+    }
+
+    @Test
+    public void markLoading_shouldNotUpdateUrls_shouldSetIsLoadingTrue() {
+        subject.markLoading(key1);
+
+        assertThat(subject.getFailoverUrl(key1)).isNull();
+        assertThat(subject.getImpressionTrackerUrlString(key1)).isNull();
+        assertThat(subject.getClickTrackerUrlString(key1)).isNull();
+
+        assertThat(subject.canPlay(key1)).isFalse();
+        assertThat(subject.isLoading(key1)).isTrue();
+    }
+
+    @Test
+    public void markLoaded_shouldUpdateUrls_shouldSetCanPlayTrue() {
+        subject.markLoaded(key1, "fail", "imp", "click");
+
+        assertThat(subject.getFailoverUrl(key1)).isEqualTo("fail");
+        assertThat(subject.getImpressionTrackerUrlString(key1)).isEqualTo("imp");
+        assertThat(subject.getClickTrackerUrlString(key1)).isEqualTo("click");
+
+        assertThat(subject.canPlay(key1)).isTrue();
+        assertThat(subject.isLoading(key1)).isFalse();
+    }
+
+    @Test
+    public void markLoaded_withNullValues_shouldUpdateUrls_shouldSetCanPlayTrue() {
+        subject.markLoaded(key1, null, null, null);
+
+        assertThat(subject.getFailoverUrl(key1)).isNull();
+        assertThat(subject.getImpressionTrackerUrlString(key1)).isNull();
+        assertThat(subject.getClickTrackerUrlString(key1)).isNull();
+
+        assertThat(subject.canPlay(key1)).isTrue();
+        assertThat(subject.isLoading(key1)).isFalse();
+    }
+
+    @Test
+    public void markPlayed_afterLoaded_shouldKeepExistingUrls_shouldSetCanPlayFalse() {
+        subject.markLoaded(key1, "fail", "imp", "click");
+        subject.markPlayed(key1);
+
+        assertThat(subject.getFailoverUrl(key1)).isEqualTo("fail");
+        assertThat(subject.getImpressionTrackerUrlString(key1)).isEqualTo("imp");
+        assertThat(subject.getClickTrackerUrlString(key1)).isEqualTo("click");
+
+        assertThat(subject.canPlay(key1)).isFalse();
+        assertThat(subject.isLoading(key1)).isFalse();
+    }
+
+    @Test
+    public void markPlayed_beforeLoaded_shouldSetUrlsNull_shouldSetCanPlayFalse() {
+        subject.markPlayed(key1);
+
+        assertThat(subject.getFailoverUrl(key1)).isNull();
+        assertThat(subject.getImpressionTrackerUrlString(key1)).isNull();
+        assertThat(subject.getClickTrackerUrlString(key1)).isNull();
+
+        assertThat(subject.canPlay(key1)).isFalse();
+        assertThat(subject.isLoading(key1)).isFalse();
+    }
+
+    @Test
+    public void clearImpression_shouldResetImpressionUrl() {
+        subject.markLoaded(key1, "fail", "imp", "click");
+        subject.clearImpressionUrl(key1);
+
+        assertThat(subject.getFailoverUrl(key1)).isEqualTo("fail");
+        assertThat(subject.getImpressionTrackerUrlString(key1)).isNull();
+        assertThat(subject.getClickTrackerUrlString(key1)).isEqualTo("click");
+    }
+
+    @Test
+    public void clearclick_shouldResetClickurl() {
+        subject.markLoaded(key1, "fail", "imp", "click");
+        subject.clearClickUrl(key1);
+
+        assertThat(subject.getFailoverUrl(key1)).isEqualTo("fail");
+        assertThat(subject.getImpressionTrackerUrlString(key1)).isEqualTo("imp");
+        assertThat(subject.getClickTrackerUrlString(key1)).isNull();
+    }
+
+    @Test
+    public void allAccessors_withInvalidKey_shouldReturnDefaultsAndNotThrowExceptions() {
+        assertThat(subject.getFailoverUrl(key1)).isNull();
+        assertThat(subject.getImpressionTrackerUrlString(key1)).isNull();
+        assertThat(subject.getClickTrackerUrlString(key1)).isNull();
+
+        assertThat(subject.canPlay(key1)).isFalse();
+        assertThat(subject.isLoading(key1)).isFalse();
+
+        subject.clearImpressionUrl(key1);
+        subject.clearClickUrl(key1);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestHttpResponseWithHeaders.java b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestHttpResponseWithHeaders.java
new file mode 100644
index 00000000..8c3229b5
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestHttpResponseWithHeaders.java
@@ -0,0 +1,37 @@
+package com.mopub.mobileads.test.support;
+
+import org.apache.http.Header;
+import org.apache.http.message.BasicHeader;
+import org.robolectric.shadows.httpclient.TestHttpResponse;
+
+import java.util.HashMap;
+import java.util.Map;
+
+public class TestHttpResponseWithHeaders extends TestHttpResponse {
+    private Map<String, Header> headers;
+
+    public TestHttpResponseWithHeaders(int statusCode, String responseBody) {
+        super(statusCode, responseBody);
+        headers = new HashMap<String, Header>();
+    }
+
+    public TestHttpResponseWithHeaders(int statusCode, byte[] responseBody) {
+        super(statusCode, responseBody);
+        headers = new HashMap<String, Header>();
+    }
+
+    @Override
+    public void addHeader(String name, String value) {
+        headers.put(name, new BasicHeader(name, value));
+    }
+
+    @Override
+    public Header getFirstHeader(String name) {
+        return headers.get(name);
+    }
+
+    @Override
+    public Header[] getAllHeaders() {
+        return headers.values().toArray(new Header[headers.size()]);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/VisibilityTrackerTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/VisibilityTrackerTest.java
new file mode 100644
index 00000000..2c6be2a7
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/VisibilityTrackerTest.java
@@ -0,0 +1,371 @@
+package com.mopub.nativeads;
+
+import android.app.Activity;
+import android.graphics.Rect;
+import android.os.Handler;
+import android.os.SystemClock;
+import android.view.View;
+import android.view.ViewParent;
+import android.view.ViewTreeObserver;
+import android.view.Window;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
+import com.mopub.nativeads.VisibilityTracker.TrackingInfo;
+
+import org.fest.util.Lists;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowSystemClock;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.WeakHashMap;
+
+import static android.view.ViewTreeObserver.OnPreDrawListener;
+import static com.mopub.nativeads.VisibilityTracker.VisibilityChecker;
+import static com.mopub.nativeads.VisibilityTracker.VisibilityTrackerListener;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class VisibilityTrackerTest {
+    private static final int MIN_PERCENTAGE_VIEWED = 50;
+
+    private Activity activity;
+    private VisibilityTracker subject;
+    private Map<View, TrackingInfo> trackedViews;
+    private VisibilityChecker visibilityChecker;
+
+    @Mock private VisibilityTrackerListener visibilityTrackerListener;
+    @Mock private View view;
+    @Mock private View view2;
+    @Mock private Handler visibilityHandler;
+
+    @Before
+    public void setUp() throws Exception {
+        trackedViews = new WeakHashMap<View, TrackingInfo>();
+        visibilityChecker = new VisibilityChecker();
+        activity = Robolectric.buildActivity(Activity.class).create().get();
+        view = createViewMock(View.VISIBLE, 100, 100, 100, 100, true, true);
+        view2 = createViewMock(View.VISIBLE, 100, 100, 100, 100, true, true);
+
+        // Add a proxy listener to that makes a safe copy of the listener args.
+        VisibilityTrackerListener proxyListener = new VisibilityTrackerListener() {
+            @Override
+            public void onVisibilityChanged(List<View> visibleViews, List<View> invisibleViews) {
+                ArrayList<View> safeVisibleViews = new ArrayList<View>(visibleViews);
+                ArrayList<View> safeInVisibleViews = new ArrayList<View>(invisibleViews);
+                visibilityTrackerListener.onVisibilityChanged(safeVisibleViews, safeInVisibleViews);
+            }
+        };
+        subject = new VisibilityTracker(activity, trackedViews, visibilityChecker, visibilityHandler);
+        subject.setVisibilityTrackerListener(proxyListener);
+
+        // XXX We need this to ensure that our SystemClock starts
+        ShadowSystemClock.uptimeMillis();
+    }
+
+    @Test
+    public void constructor_shouldSetOnPreDrawListenerForDecorView() throws Exception {
+        Activity activity1 = spy(Robolectric.buildActivity(Activity.class).create().get());
+        Window window = mock(Window.class);
+        View decorView = mock(View.class);
+        ViewTreeObserver viewTreeObserver = mock(ViewTreeObserver.class);
+
+        when(activity1.getWindow()).thenReturn(window);
+        when(window.getDecorView()).thenReturn(decorView);
+        when(decorView.findViewById(anyInt())).thenReturn(decorView);
+        when(decorView.getViewTreeObserver()).thenReturn(viewTreeObserver);
+        when(viewTreeObserver.isAlive()).thenReturn(true);
+
+        subject = new VisibilityTracker(activity1, trackedViews, visibilityChecker, visibilityHandler);
+        assertThat(subject.mOnPreDrawListener).isNotNull();
+        verify(viewTreeObserver).addOnPreDrawListener(subject.mOnPreDrawListener);
+        assertThat(subject.mWeakViewTreeObserver.get()).isEqualTo(viewTreeObserver);
+    }
+
+    @Test
+    public void constructor_withNonAliveViewTreeObserver_shouldNotSetOnPreDrawListenerForDecorView() throws Exception {
+        Activity activity1 = mock(Activity.class);
+        Window window = mock(Window.class);
+        View decorView = mock(View.class);
+        ViewTreeObserver viewTreeObserver = mock(ViewTreeObserver.class);
+
+        when(activity1.getWindow()).thenReturn(window);
+        when(window.getDecorView()).thenReturn(decorView);
+        when(decorView.getViewTreeObserver()).thenReturn(viewTreeObserver);
+        when(viewTreeObserver.isAlive()).thenReturn(false);
+
+        subject = new VisibilityTracker(activity1, trackedViews, visibilityChecker, visibilityHandler);
+        verify(viewTreeObserver, never()).addOnPreDrawListener(subject.mOnPreDrawListener);
+        assertThat(subject.mWeakViewTreeObserver.get()).isNull();
+    }
+
+    @Test
+    public void constructor_withApplicationContext_shouldNotSetOnPreDrawListener() {
+        subject = new VisibilityTracker(activity.getApplicationContext(), trackedViews,
+                visibilityChecker, visibilityHandler);
+
+        assertThat(subject.mWeakViewTreeObserver.get()).isNull();
+    }
+
+    @Test
+    public void addView_withVisibleView_shouldAddVisibleViewToTrackedViews() throws Exception {
+        subject.addView(view, MIN_PERCENTAGE_VIEWED);
+
+        assertThat(trackedViews).hasSize(1);
+    }
+
+    @Test
+    public void addView_withViewTreeObserverNotSet_shouldSetViewTreeObserver() {
+        ViewTreeObserver viewTreeObserver = mock(ViewTreeObserver.class);
+        View rootView = mock(View.class);
+
+        when(view.getContext()).thenReturn(activity.getApplicationContext());
+        when(view.getRootView()).thenReturn(rootView);
+        when(rootView.getViewTreeObserver()).thenReturn(viewTreeObserver);
+        when(viewTreeObserver.isAlive()).thenReturn(true);
+
+        subject = new VisibilityTracker(activity.getApplicationContext(), trackedViews,
+                visibilityChecker, visibilityHandler);
+        subject.addView(view, MIN_PERCENTAGE_VIEWED);
+
+        assertThat(subject.mWeakViewTreeObserver.get()).isEqualTo(viewTreeObserver);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void addView_whenViewIsNull_shouldThrowNPE() throws Exception {
+        subject.addView(null, MIN_PERCENTAGE_VIEWED);
+
+        assertThat(trackedViews).isEmpty();
+    }
+
+    @Test
+    public void removeView_shouldRemoveFromTrackedViews() throws Exception {
+        subject.addView(view, MIN_PERCENTAGE_VIEWED);
+
+        assertThat(trackedViews).hasSize(1);
+        assertThat(trackedViews).containsKey(view);
+
+        subject.removeView(view);
+
+        assertThat(trackedViews).isEmpty();
+    }
+
+    @Test
+    public void clear_shouldRemoveAllViewsFromTrackedViews_shouldRemoveMessagesFromVisibilityHandler_shouldResetIsVisibilityScheduled() throws Exception {
+        subject.addView(view, MIN_PERCENTAGE_VIEWED);
+        subject.addView(view2, MIN_PERCENTAGE_VIEWED);
+        assertThat(trackedViews).hasSize(2);
+
+        subject.clear();
+
+        assertThat(trackedViews).isEmpty();
+        verify(visibilityHandler).removeMessages(0);
+    }
+
+    @Test
+    public void destroy_shouldCallClear_shouldRemoveListenerFromDecorView() throws Exception {
+        Activity activity1 = spy(Robolectric.buildActivity(Activity.class).create().get());
+        Window window = mock(Window.class);
+        View decorView = mock(View.class);
+        ViewTreeObserver viewTreeObserver = mock(ViewTreeObserver.class);
+
+        when(activity1.getWindow()).thenReturn(window);
+        when(window.getDecorView()).thenReturn(decorView);
+        when(decorView.findViewById(anyInt())).thenReturn(decorView);
+        when(decorView.getViewTreeObserver()).thenReturn(viewTreeObserver);
+        when(viewTreeObserver.isAlive()).thenReturn(true);
+
+        subject = new VisibilityTracker(activity1, trackedViews, visibilityChecker, visibilityHandler);
+
+        subject.addView(view, MIN_PERCENTAGE_VIEWED);
+        subject.addView(view2, MIN_PERCENTAGE_VIEWED);
+        assertThat(trackedViews).hasSize(2);
+
+        subject.destroy();
+
+        assertThat(trackedViews).isEmpty();
+        verify(visibilityHandler).removeMessages(0);
+        verify(viewTreeObserver).removeOnPreDrawListener(any(OnPreDrawListener.class));
+        assertThat(subject.mWeakViewTreeObserver.get()).isNull();
+    }
+
+    @Test
+    public void visibilityRunnable_run_withVisibleView_shouldCallOnVisibleCallback() throws Exception {
+        subject.addView(view, MIN_PERCENTAGE_VIEWED);
+
+        subject.new VisibilityRunnable().run();
+
+        verify(visibilityTrackerListener).onVisibilityChanged(
+                Lists.newArrayList(view), Lists.<View>newArrayList());
+    }
+
+    @Test
+    public void visibilityRunnable_run_withNonVisibleView_shouldCallOnNonVisibleCallback() throws Exception {
+        when(view.getVisibility()).thenReturn(View.INVISIBLE);
+        subject.addView(view, MIN_PERCENTAGE_VIEWED);
+
+        subject.new VisibilityRunnable().run();
+
+        ArgumentCaptor<List> visibleCaptor = ArgumentCaptor.forClass(List.class);
+        ArgumentCaptor<List> invisibleCaptor = ArgumentCaptor.forClass(List.class);
+        // noinspection unchecked
+        verify(visibilityTrackerListener).onVisibilityChanged(visibleCaptor.capture(),
+                invisibleCaptor.capture());
+        assertThat(visibleCaptor.getValue().size()).isEqualTo(0);
+        assertThat(invisibleCaptor.getValue().size()).isEqualTo(1);
+    }
+
+    // VisibilityChecker tests
+
+    @Test
+    public void hasRequiredTimeElapsed_withElapsedTimeGreaterThanMinTimeViewed_shouldReturnTrue() throws Exception {
+        assertThat(visibilityChecker.hasRequiredTimeElapsed(SystemClock.uptimeMillis() - 501, 500)).isTrue();
+    }
+
+    @Test
+    public void hasRequiredTimeElapsed_withElapsedTimeLessThanMinTimeViewed_shouldReturnFalse() throws Exception {
+        assertThat(visibilityChecker.hasRequiredTimeElapsed(SystemClock.uptimeMillis() - 499, 500)).isFalse();
+    }
+
+    @Test
+    public void isMostlyVisible_whenParentIsNull_shouldReturnFalse() throws Exception {
+        view = createViewMock(View.VISIBLE, 100, 100, 100, 100, false, true);
+        assertThat(visibilityChecker.isVisible(view, view, MIN_PERCENTAGE_VIEWED)).isFalse();
+    }
+
+    @Test
+    public void isMostlyVisible_whenViewIsOffScreen_shouldReturnFalse() throws Exception {
+        view = createViewMock(View.VISIBLE, 100, 100, 100, 100, true, false);
+        assertThat(visibilityChecker.isVisible(view, view, MIN_PERCENTAGE_VIEWED)).isFalse();
+    }
+
+    @Test
+    public void isMostlyVisible_whenViewIsEntirelyOnScreen_shouldReturnTrue() throws Exception {
+        view = createViewMock(View.VISIBLE, 100, 100, 100, 100, true, true);
+
+        assertThat(visibilityChecker.isVisible(view, view, MIN_PERCENTAGE_VIEWED)).isTrue();
+    }
+
+    @Test
+    public void isMostlyVisible_whenViewIs50PercentVisible_shouldReturnTrue() throws Exception {
+        view = createViewMock(View.VISIBLE, 50, 100, 100, 100, true, true);
+
+        assertThat(visibilityChecker.isVisible(view, view, MIN_PERCENTAGE_VIEWED)).isTrue();
+    }
+
+    @Test
+    public void isMostlyVisible_whenViewIs49PercentVisible_shouldReturnFalse() throws Exception {
+        view = createViewMock(View.VISIBLE, 49, 100, 100, 100, true, true);
+
+        assertThat(visibilityChecker.isVisible(view, view, MIN_PERCENTAGE_VIEWED)).isFalse();
+    }
+
+    @Test
+    public void isMostlyVisible_whenVisibleAreaIsZero_shouldReturnFalse() throws Exception {
+        view = createViewMock(View.VISIBLE, 0, 0, 100, 100, true, true);
+
+        assertThat(visibilityChecker.isVisible(view, view, MIN_PERCENTAGE_VIEWED)).isFalse();
+    }
+
+    @Test
+    public void isMostlyVisible_whenViewIsInvisibleOrGone_shouldReturnFalse() throws Exception {
+        View view = createViewMock(View.INVISIBLE, 100, 100, 100, 100, true, true);
+        assertThat(visibilityChecker.isVisible(view, view, MIN_PERCENTAGE_VIEWED)).isFalse();
+
+        reset(view);
+        view = createViewMock(View.GONE, 100, 100, 100, 100, true, true);
+        assertThat(visibilityChecker.isVisible(view, view, MIN_PERCENTAGE_VIEWED)).isFalse();
+    }
+
+    @Test
+    public void isMostlyVisible_whenViewHasZeroWidthAndHeight_shouldReturnFalse() throws Exception {
+        view = createViewMock(View.VISIBLE, 100, 100, 0, 0, true, true);
+
+        assertThat(visibilityChecker.isVisible(view, view, MIN_PERCENTAGE_VIEWED)).isFalse();
+    }
+
+    @Test
+    public void isMostlyVisible_whenViewIsNull_shouldReturnFalse() throws Exception {
+        assertThat(visibilityChecker.isVisible(null, null, MIN_PERCENTAGE_VIEWED)).isFalse();
+    }
+
+    @Test
+    public void addView_shouldClearViewAfterNumAccesses() {
+        // Access 1 time
+        subject.addView(view, MIN_PERCENTAGE_VIEWED);
+        assertThat(trackedViews).hasSize(1);
+
+        // Access 2-49 times
+        for (int i = 0; i < VisibilityTracker.NUM_ACCESSES_BEFORE_TRIMMING - 2; ++i) {
+            subject.addView(view2, MIN_PERCENTAGE_VIEWED);
+        }
+        assertThat(trackedViews).hasSize(2);
+
+        // 50th time
+        subject.addView(view2, MIN_PERCENTAGE_VIEWED);
+        assertThat(trackedViews).hasSize(2);
+
+        // 51-99
+        for (int i = 0; i < VisibilityTracker.NUM_ACCESSES_BEFORE_TRIMMING - 1; ++i) {
+            subject.addView(view2, MIN_PERCENTAGE_VIEWED);
+        }
+        assertThat(trackedViews).hasSize(2);
+
+        // 100
+        subject.addView(view2, MIN_PERCENTAGE_VIEWED);
+        assertThat(trackedViews).hasSize(1);
+    }
+
+    static View createViewMock(final int visibility,
+            final int visibleWidth,
+            final int visibleHeight,
+            final int viewWidth,
+            final int viewHeight,
+            final boolean isParentSet,
+            final boolean isOnScreen) {
+        View view = mock(View.class);
+        when(view.getContext()).thenReturn(new Activity());
+        when(view.getVisibility()).thenReturn(visibility);
+
+        when(view.getGlobalVisibleRect(any(Rect.class)))
+                .thenAnswer(new Answer<Boolean>() {
+                    @Override
+                    public Boolean answer(InvocationOnMock invocationOnMock) throws Throwable {
+                        Object[] args = invocationOnMock.getArguments();
+                        Rect rect = (Rect) args[0];
+                        rect.set(0, 0, visibleWidth, visibleHeight);
+                        return isOnScreen;
+                    }
+                });
+
+        when(view.getWidth()).thenReturn(viewWidth);
+        when(view.getHeight()).thenReturn(viewHeight);
+
+        if (isParentSet) {
+            when(view.getParent()).thenReturn(mock(ViewParent.class));
+        }
+
+        when(view.getViewTreeObserver()).thenCallRealMethod();
+
+        return view;
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/network/AdRequestTest.java b/mopub-sdk/src/test/java/com/mopub/network/AdRequestTest.java
new file mode 100644
index 00000000..646c2dc4
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/network/AdRequestTest.java
@@ -0,0 +1,527 @@
+package com.mopub.network;
+
+import android.app.Activity;
+import android.location.Location;
+
+import com.mopub.common.AdFormat;
+import com.mopub.common.AdType;
+import com.mopub.common.DataKeys;
+import com.mopub.common.MoPub.BrowserAgent;
+import com.mopub.common.event.BaseEvent;
+import com.mopub.common.event.EventDispatcher;
+import com.mopub.common.event.MoPubEvents;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.ResponseHeader;
+import com.mopub.mobileads.BuildConfig;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.Response;
+
+import org.json.JSONException;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+
+import java.nio.charset.Charset;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
+import java.util.TreeMap;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class AdRequestTest {
+
+    @Mock private AdRequest.Listener mockListener;
+    @Mock private AdResponse mockAdResponse;
+    @Mock private EventDispatcher mockEventDispatcher;
+
+    private AdRequest subject;
+    private HashMap<String, String> defaultHeaders;
+    private Activity activity;
+    private String adUnitId;
+
+    @Before
+    public void setup() {
+        activity = Robolectric.buildActivity(Activity.class).create().get();
+        adUnitId = "testAdUnitId";
+        subject = new AdRequest("testUrl", AdFormat.NATIVE, adUnitId, activity, mockListener);
+        defaultHeaders = new HashMap<String, String>();
+        defaultHeaders.put(ResponseHeader.SCROLLABLE.getKey(), "0");
+        defaultHeaders.put(ResponseHeader.REDIRECT_URL.getKey(), "redirect");
+        defaultHeaders.put(ResponseHeader.CLICK_TRACKING_URL.getKey(), "click_tracking");
+        defaultHeaders.put(ResponseHeader.IMPRESSION_URL.getKey(), "impression");
+        defaultHeaders.put(ResponseHeader.FAIL_URL.getKey(), "fail_url");
+        defaultHeaders.put(ResponseHeader.REFRESH_TIME.getKey(), "30");
+        defaultHeaders.put(ResponseHeader.PLAY_VISIBLE_PERCENT.getKey(), "50%");
+        defaultHeaders.put(ResponseHeader.PAUSE_VISIBLE_PERCENT.getKey(), "25");
+        defaultHeaders.put(ResponseHeader.IMPRESSION_MIN_VISIBLE_PERCENT.getKey(), "33%");
+        defaultHeaders.put(ResponseHeader.IMPRESSION_VISIBLE_MS.getKey(), "2000");
+        defaultHeaders.put(ResponseHeader.MAX_BUFFER_MS.getKey(), "1000");
+
+        MoPubEvents.setEventDispatcher(mockEventDispatcher);
+    }
+
+    @After
+    public void teardown() {
+        // Reset our locale for other tests.
+        Locale.setDefault(Locale.US);
+        MoPubEvents.setEventDispatcher(null);
+    }
+
+    @Test
+    public void parseNetworkResponse_stringBody_shouldSucceed() throws Exception {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.HTML);
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        assertThat(response.result).isNotNull();
+        assertThat(response.result.getStringBody()).isEqualTo("abc");
+    }
+
+    @Test
+    public void parseNetworkResponse_withStringBody_shouldLogScribeEvent() throws Exception {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.HTML);
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        subject.parseNetworkResponse(testResponse);
+
+        verify(mockEventDispatcher).dispatch(any(BaseEvent.class));
+    }
+
+    @Test
+    public void parseNetworkResponse_withServerExtrasInResponseBody_shouldSucceed_shouldCombineServerExtras() throws Exception {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.HTML);
+        defaultHeaders.put(ResponseHeader.FULL_AD_TYPE.getKey(), "anything");
+        defaultHeaders.put(ResponseHeader.CUSTOM_EVENT_NAME.getKey(), "class name");
+        defaultHeaders.put(ResponseHeader.CUSTOM_EVENT_DATA.getKey(),
+                "{customEventKey1: value1, customEventKey2: value2}");
+
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        // Check the server extras
+        final Map<String, String> serverExtras = response.result.getServerExtras();
+        assertThat(serverExtras).isNotNull();
+        assertThat(serverExtras).isNotEmpty();
+        assertThat(serverExtras.get(DataKeys.SCROLLABLE_KEY)).isEqualToIgnoringCase("false");
+        assertThat(serverExtras.get(DataKeys.REDIRECT_URL_KEY)).isEqualToIgnoringCase("redirect");
+        assertThat(serverExtras.get(DataKeys.CLICKTHROUGH_URL_KEY)).isEqualToIgnoringCase("click_tracking");
+
+        assertThat(serverExtras.get("customEventKey1")).isEqualTo("value1");
+        assertThat(serverExtras.get("customEventKey2")).isEqualTo("value2");
+    }
+
+    @Test
+    public void parseNetworkResponse_nonJsonStringBodyForNative_jsonParseShouldFail() {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.STATIC_NATIVE);
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        assertThat(response.error).isNotNull();
+        assertThat(response.error).isExactlyInstanceOf(MoPubNetworkError.class);
+        assertThat(((MoPubNetworkError) response.error).getReason()).isEqualTo(MoPubNetworkError.Reason.BAD_BODY);
+    }
+
+    @Test
+    public void parseNetworkResponse_nonJsonStringBodyForNative_shouldNotLogScribeEvent() {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.STATIC_NATIVE);
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        subject.parseNetworkResponse(testResponse);
+
+        verify(mockEventDispatcher, never()).dispatch(any(BaseEvent.class));
+    }
+
+    @Test
+    public void parseNetworkResponse_forNativeVideo_shouldSucceed() throws Exception {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.VIDEO_NATIVE);
+        NetworkResponse testResponse = new NetworkResponse(200,
+                "{\"abc\": \"def\"}".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        // Check the server extras
+        final Map<String, String> serverExtras = response.result.getServerExtras();
+        assertThat(serverExtras).isNotNull();
+        assertThat(serverExtras).isNotEmpty();
+        assertThat(serverExtras.get(DataKeys.PLAY_VISIBLE_PERCENT)).isEqualTo("50");
+        assertThat(serverExtras.get(DataKeys.PAUSE_VISIBLE_PERCENT)).isEqualTo("25");
+        assertThat(serverExtras.get(DataKeys.IMPRESSION_MIN_VISIBLE_PERCENT)).isEqualTo("33");
+        assertThat(serverExtras.get(DataKeys.IMPRESSION_VISIBLE_MS)).isEqualTo("2000");
+        assertThat(serverExtras.get(DataKeys.MAX_BUFFER_MS)).isEqualTo("1000");
+    }
+
+    @Test
+    public void parseNetworkResponse_forNativeVideo_shouldCombineServerExtrasAndEventData() throws Exception {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.VIDEO_NATIVE);
+        defaultHeaders.put(ResponseHeader.CUSTOM_EVENT_NAME.getKey(), "class name");
+        defaultHeaders.put(ResponseHeader.CUSTOM_EVENT_DATA.getKey(),
+                "{customEventKey1: value1, customEventKey2: value2}");
+        NetworkResponse testResponse = new NetworkResponse(200,
+                "{\"abc\": \"def\"}".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        // Check the server extras
+        final Map<String, String> serverExtras = response.result.getServerExtras();
+        assertThat(serverExtras).isNotNull();
+        assertThat(serverExtras).isNotEmpty();
+
+        assertThat(serverExtras.get(DataKeys.PLAY_VISIBLE_PERCENT)).isEqualTo("50");
+        assertThat(serverExtras.get(DataKeys.PAUSE_VISIBLE_PERCENT)).isEqualTo("25");
+        assertThat(serverExtras.get(DataKeys.IMPRESSION_MIN_VISIBLE_PERCENT)).isEqualTo("33");
+        assertThat(serverExtras.get(DataKeys.IMPRESSION_VISIBLE_MS)).isEqualTo("2000");
+        assertThat(serverExtras.get(DataKeys.MAX_BUFFER_MS)).isEqualTo("1000");
+
+        assertThat(serverExtras.get("customEventKey1")).isEqualTo("value1");
+        assertThat(serverExtras.get("customEventKey2")).isEqualTo("value2");
+    }
+
+    @Test
+    public void parseNetworkResponse_forNativeVideo_withInvalidValues_shouldSucceed_shouldParseNull() throws Exception {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.VIDEO_NATIVE);
+        defaultHeaders.put(ResponseHeader.PLAY_VISIBLE_PERCENT.getKey(), "-1");
+        defaultHeaders.put(ResponseHeader.PAUSE_VISIBLE_PERCENT.getKey(), "101%");
+        defaultHeaders.put(ResponseHeader.IMPRESSION_MIN_VISIBLE_PERCENT.getKey(), "XX%");
+        NetworkResponse testResponse = new NetworkResponse(200,
+                "{\"abc\": \"def\"}".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        // Check the server extras
+        final Map<String, String> serverExtras = response.result.getServerExtras();
+        assertThat(serverExtras).isNotNull();
+        assertThat(serverExtras).isNotEmpty();
+        assertThat(serverExtras.get(DataKeys.PLAY_VISIBLE_PERCENT)).isNull();
+        assertThat(serverExtras.get(DataKeys.PAUSE_VISIBLE_PERCENT)).isNull();
+        assertThat(serverExtras.get(DataKeys.IMPRESSION_MIN_VISIBLE_PERCENT)).isNull();
+        assertThat(serverExtras.get(DataKeys.IMPRESSION_VISIBLE_MS)).isEqualTo("2000");
+        assertThat(serverExtras.get(DataKeys.MAX_BUFFER_MS)).isEqualTo("1000");
+    }
+
+
+    @Test
+    public void parseNetworkResponse_withWarmupHeaderTrue_shouldError() {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.STATIC_NATIVE);
+        defaultHeaders.put(ResponseHeader.WARMUP.getKey(), "1");
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        assertThat(response.error).isNotNull();
+        assertThat(response.error).isInstanceOf(MoPubNetworkError.class);
+        assertThat(((MoPubNetworkError) response.error).getReason()).isEqualTo(MoPubNetworkError.Reason.WARMING_UP);
+    }
+
+    @Test
+    public void parseNetworkResponse_withWarmupHeaderTrue_shouldNotLogScribeEvent() {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.STATIC_NATIVE);
+        defaultHeaders.put(ResponseHeader.WARMUP.getKey(), "1");
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        subject.parseNetworkResponse(testResponse);
+
+        verify(mockEventDispatcher, never()).dispatch(any(BaseEvent.class));
+    }
+
+    @Test
+    public void parseNetworkResponse_withRefreshTime_shouldIncludeRefreshTimeInResult() {
+        defaultHeaders.put(ResponseHeader.REFRESH_TIME.getKey(), "13");
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+        assertThat(response.result.getRefreshTimeMillis()).isEqualTo(13000);
+    }
+
+    @Test
+    public void parseNetworkResponse_withoutRefreshTime_shouldNotIncludeRefreshTime() {
+        defaultHeaders.remove(ResponseHeader.REFRESH_TIME.getKey());
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+        assertThat(response.result.getRefreshTimeMillis()).isNull();
+    }
+    
+    @Test
+    public void parseNetworkResponse_withClearAdType_withRefreshTimeHeader_shouldErrorAndIncludeRefreshTime() {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.CLEAR);
+
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        assertThat(response.error).isNotNull();
+        assertThat(response.error).isInstanceOf(MoPubNetworkError.class);
+        final MoPubNetworkError moPubNetworkError = (MoPubNetworkError) response.error;
+        assertThat(moPubNetworkError.getReason()).isEqualTo(MoPubNetworkError.Reason.NO_FILL);
+        assertThat(moPubNetworkError.getRefreshTimeMillis()).isEqualTo(30000);
+    }
+
+    @Test
+    public void parseNetworkResponse_withClearAdType_withNoRefreshTimeHeader_shouldErrorAndNotIncludeRefreshTime() {
+        defaultHeaders.remove(ResponseHeader.REFRESH_TIME.getKey());
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.CLEAR);
+
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        assertThat(response.error).isNotNull();
+        assertThat(response.error).isInstanceOf(MoPubNetworkError.class);
+        final MoPubNetworkError moPubNetworkError = (MoPubNetworkError) response.error;
+        assertThat(moPubNetworkError.getReason()).isEqualTo(MoPubNetworkError.Reason.NO_FILL);
+        assertThat(moPubNetworkError.getRefreshTimeMillis()).isNull();
+    }
+
+    @Test
+    public void parseNetworkResponse_withClearAdType_shouldLogScribeEvent() {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.CLEAR);
+
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+        subject.parseNetworkResponse(testResponse);
+
+        verify(mockEventDispatcher).dispatch(any(BaseEvent.class));
+    }
+
+    @Test
+    public void parseNetworkResponse_withBadJSON_shouldReturnError() {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.STATIC_NATIVE);
+        NetworkResponse badNativeNetworkResponse = new NetworkResponse(200,
+                "{[abc}".getBytes(Charset.defaultCharset()),
+                defaultHeaders, false);
+        subject = new AdRequest("testUrl", AdFormat.NATIVE, "testAdUnitId", activity, mockListener);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(badNativeNetworkResponse);
+
+        assertThat(response.error).isNotNull();
+        assertThat(response.error.getCause()).isExactlyInstanceOf(JSONException.class);
+    }
+
+    @Test
+    public void parseNetworkResponse_forRewardedAds_shouldSucceed() {
+        defaultHeaders.put(ResponseHeader.AD_TYPE.getKey(), AdType.REWARDED_VIDEO);
+        defaultHeaders.put(ResponseHeader.REWARDED_VIDEO_CURRENCY_NAME.getKey(), "currencyName");
+        defaultHeaders.put(ResponseHeader.REWARDED_VIDEO_CURRENCY_AMOUNT.getKey(), "25");
+
+        final String rewardedCurrenciesJson = "{\"rewards\": ["
+                + "{\"name\": \"Coins\", \"amount\": 8},"
+                + "{\"name\": \"Diamonds\", \"amount\": 1},"
+                + "{\"name\": \"Diamonds\", \"amount\": 10 },"
+                + "{\"name\": \"Energy\", \"amount\": 20}"
+                + "]}";
+        defaultHeaders.put(ResponseHeader.REWARDED_CURRENCIES.getKey(), rewardedCurrenciesJson);
+
+        defaultHeaders.put(ResponseHeader.REWARDED_VIDEO_COMPLETION_URL.getKey(),
+                "http://completionUrl");
+        defaultHeaders.put(ResponseHeader.REWARDED_DURATION.getKey(), "15000");
+        defaultHeaders.put(ResponseHeader.SHOULD_REWARD_ON_CLICK.getKey(), "1");
+        NetworkResponse testResponse = new NetworkResponse(200,
+                "{\"abc\": \"def\"}".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+
+        assertThat(response.result.getAdType()).isEqualTo(AdType.REWARDED_VIDEO);
+        assertThat(response.result.getRewardedVideoCurrencyName()).isEqualTo("currencyName");
+        assertThat(response.result.getRewardedVideoCurrencyAmount()).isEqualTo("25");
+        assertThat(response.result.getRewardedCurrencies()).isEqualTo(rewardedCurrenciesJson);
+        assertThat(response.result.getRewardedVideoCompletionUrl()).isEqualTo(
+                "http://completionUrl");
+        assertThat(response.result.getRewardedDuration()).isEqualTo(15000);
+        assertThat(response.result.shouldRewardOnClick()).isTrue();
+    }
+
+    @Test
+    public void parseNetworkResponse_withInAppBrowserAgent_shouldSucceed() {
+        defaultHeaders.put(ResponseHeader.BROWSER_AGENT.getKey(), "0");
+
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+        assertThat(response.result.getBrowserAgent()).isEqualTo(BrowserAgent.IN_APP);
+    }
+
+    @Test
+    public void parseNetworkResponse_withNativeBrowserAgent_shouldSucceed() {
+        defaultHeaders.put(ResponseHeader.BROWSER_AGENT.getKey(), "1");
+
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+        assertThat(response.result.getBrowserAgent()).isEqualTo(BrowserAgent.NATIVE);
+    }
+
+    @Test
+    public void parseNetworkResponse_withNullBrowserAgent_shouldDefaultToInApp() {
+        defaultHeaders.put(ResponseHeader.BROWSER_AGENT.getKey(), null);
+
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+        assertThat(response.result.getBrowserAgent()).isEqualTo(BrowserAgent.IN_APP);
+    }
+
+    @Test
+    public void parseNetworkResponse_withUndefinedBrowserAgent_shouldDefaultToInApp() {
+        defaultHeaders.put(ResponseHeader.BROWSER_AGENT.getKey(), "foo");
+
+        NetworkResponse testResponse =
+                new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), defaultHeaders, false);
+
+        final Response<AdResponse> response = subject.parseNetworkResponse(testResponse);
+        assertThat(response.result.getBrowserAgent()).isEqualTo(BrowserAgent.IN_APP);
+    }
+
+    @Test
+    public void deliverResponse_shouldCallListenerOnSuccess() throws Exception {
+        subject.deliverResponse(mockAdResponse);
+        verify(mockListener).onSuccess(mockAdResponse);
+    }
+
+    @Test
+    public void getRequestId_shouldParseAndReturnRequestIdFromFailUrl() throws Exception {
+        String requestId = subject.getRequestId("https://ads.mopub.com/m/ad?id=8cf00598d3664adaaeccd800e46afaca&exclude=043fde1fe2f9470c9aa67fec262a0596&request_id=7fd6dd3bf1c84f87876b4740c1dd7baa&fail=1");
+
+        assertThat(requestId).isEqualTo("7fd6dd3bf1c84f87876b4740c1dd7baa");
+    }
+
+    @Test
+    public void getRequestId_withNullFailUrl_shouldReturnNull() throws Exception {
+        assertThat(subject.getRequestId(null)).isNull();
+    }
+
+    @Test
+    public void getRequestId_withUrlWithNoRequestIdParam_shouldReturnNull() throws Exception {
+        assertThat(subject.getRequestId("https://ads.mopub.com/m/ad?id=8cf00598d3664adaaeccd800e46afaca")).isNull();
+    }
+
+    @Test
+    public void getHeaders_withDefaultLocale_shouldReturnDefaultLanguageCode() throws Exception {
+        Map<String, String> expectedHeaders = new TreeMap<String, String>();
+        expectedHeaders.put(ResponseHeader.ACCEPT_LANGUAGE.getKey(), "en");
+
+        assertThat(subject.getHeaders()).isEqualTo(expectedHeaders);
+    }
+
+    @Test
+    public void getHeaders_withUserPreferredLocale_shouldReturnUserPreferredLanguageCode() throws Exception {
+        Map<String, String> expectedHeaders = new TreeMap<String, String>();
+        expectedHeaders.put(ResponseHeader.ACCEPT_LANGUAGE.getKey(), "fr");
+
+        // Assume user-preferred locale is fr_CA
+        activity.getResources().getConfiguration().locale = Locale.CANADA_FRENCH;
+
+        assertThat(subject.getHeaders()).isEqualTo(expectedHeaders);
+    }
+
+    @Test
+    public void getHeaders_withUserPreferredLocaleAsNull_shouldReturnDefaultLanguageCode() throws Exception {
+        Map<String, String> expectedHeaders = new TreeMap<String, String>();
+        expectedHeaders.put(ResponseHeader.ACCEPT_LANGUAGE.getKey(), "en");
+
+        // Assume user-preferred locale is null
+        activity.getResources().getConfiguration().locale = null;
+
+        assertThat(subject.getHeaders()).isEqualTo(expectedHeaders);
+    }
+
+    @Test
+    public void getHeaders_withUserPreferredLanguageAsEmptyString_shouldReturnDefaultLanguageCode() throws Exception {
+        Map<String, String> expectedHeaders = new TreeMap<String, String>();
+        expectedHeaders.put(ResponseHeader.ACCEPT_LANGUAGE.getKey(), "en");
+
+        // Assume user-preferred locale's language code is empty string after trimming
+        activity.getResources().getConfiguration().locale = new Locale(" ");
+
+        assertThat(subject.getHeaders()).isEqualTo(expectedHeaders);
+    }
+
+    @Test
+    public void getHeaders_withLocaleLanguageAsEmptyString_shouldNotAddLanguageHeader() throws Exception {
+        Map<String, String> expectedHeaders = Collections.emptyMap();
+
+        // Assume default locale's language code is empty string
+        Locale.setDefault(new Locale(""));
+
+        // Assume user-preferred locale's language code is empty string after trimming
+        activity.getResources().getConfiguration().locale = new Locale(" ");
+
+        assertThat(subject.getHeaders()).isEqualTo(expectedHeaders);
+
+
+    }
+
+    @Test
+    public void logScribeEvent_shouldLogEvent() throws Exception {
+        AdResponse mockAdResponse = mock(AdResponse.class);
+        when(mockAdResponse.getDspCreativeId()).thenReturn("dsp_creative_id");
+        when(mockAdResponse.getAdType()).thenReturn("html");
+        when(mockAdResponse.getNetworkType()).thenReturn("network_type");
+        when(mockAdResponse.getWidth()).thenReturn(320);
+        when(mockAdResponse.getHeight()).thenReturn(50);
+        when(mockAdResponse.getRequestId()).thenReturn("ac298c522b0e412b85ff81e4b9b51f03");
+
+        NetworkResponse networkResponse = new NetworkResponse(200, null, null, false, 300);
+
+        Location mockLocation = mock(Location.class);
+        when(mockLocation.getLatitude()).thenReturn(37.7833);
+        when(mockLocation.getLongitude()).thenReturn(-122.4167);
+        when(mockLocation.getAccuracy()).thenReturn((float) 2000.0);
+
+        doAnswer(new Answer() {
+            @Override
+            public Object answer(InvocationOnMock invocation) throws Throwable {
+                Object[] args = invocation.getArguments();
+                BaseEvent baseEvent = (BaseEvent) args[0];
+                assertThat(baseEvent.getName()).isEqualTo(BaseEvent.Name.AD_REQUEST);
+                assertThat(baseEvent.getCategory()).isEqualTo(BaseEvent.Category.REQUESTS);
+                assertThat(baseEvent.getSamplingRate()).isEqualTo(0.1);
+                assertThat(baseEvent.getAdUnitId()).isEqualTo(adUnitId);
+                assertThat(baseEvent.getDspCreativeId()).isEqualTo("dsp_creative_id");
+                assertThat(baseEvent.getAdType()).isEqualTo("html");
+                assertThat(baseEvent.getAdNetworkType()).isEqualTo("network_type");
+                assertThat(baseEvent.getAdWidthPx()).isEqualTo(320);
+                assertThat(baseEvent.getAdHeightPx()).isEqualTo(50);
+                assertThat(baseEvent.getGeoLat()).isEqualTo(37.7833);
+                assertThat(baseEvent.getGeoLon()).isEqualTo(-122.4167);
+                assertThat(baseEvent.getGeoAccuracy()).isEqualTo(2000.0);
+                assertThat(baseEvent.getPerformanceDurationMs()).isEqualTo(300);
+                assertThat(baseEvent.getRequestId()).isEqualTo("ac298c522b0e412b85ff81e4b9b51f03");
+                assertThat(baseEvent.getRequestStatusCode()).isEqualTo(200);
+                assertThat(baseEvent.getRequestUri()).isEqualTo("testUrl");
+                return null;
+            }
+        }).when(mockEventDispatcher).dispatch(any(BaseEvent.class));
+
+        subject.logScribeEvent(mockAdResponse, networkResponse, mockLocation);
+
+        verify(mockEventDispatcher).dispatch(any(BaseEvent.class));
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/network/RequestManagerTest.java b/mopub-sdk/src/test/java/com/mopub/network/RequestManagerTest.java
new file mode 100644
index 00000000..a9a52e2c
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/network/RequestManagerTest.java
@@ -0,0 +1,141 @@
+package com.mopub.network;
+
+import android.os.Looper;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
+import com.mopub.volley.Request;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.annotation.Config;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class RequestManagerTest {
+
+    private ScribeRequestManager subject;
+    @Mock private ScribeRequest.ScribeRequestFactory mockScribeRequestFactory;
+    @Mock private ScribeBackoffPolicy mockScribeBackoffPolicy;
+    @Mock private ScribeRequest mockScribeRequest;
+    @Mock private MoPubRequestQueue mockRequestQueue;
+
+    @Before
+    public void setUp() {
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+
+        subject = new ScribeRequestManager(Looper.getMainLooper());
+        when(mockScribeRequestFactory.createRequest(subject)).thenReturn(mockScribeRequest);
+    }
+
+    @Test
+    public void makeRequest_shouldAddRequestToQueue() throws Exception {
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+
+        verify(mockRequestQueue).add(mockScribeRequest);
+    }
+
+
+    @Test
+    public void makeRequest_shouldCancelTheCurrentRequest() throws Exception {
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+        Request<?> request = subject.getCurrentRequest();
+
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+
+        verify(mockRequestQueue).cancel(request);
+    }
+
+    @Test
+    public void cancelRequest_shouldCancelRequestInQueue_shouldClearRequest() throws Exception {
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+        subject.cancelRequest();
+
+        verify(mockRequestQueue).cancel(mockScribeRequest);
+        assertThat(subject.getCurrentRequest()).isNull();
+    }
+
+    @Test
+    public void cancelRequest_withNullRequestQueue_shouldOnlyClearCurrentRequest() throws Exception {
+        Networking.setRequestQueueForTesting(null);
+
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+        subject.cancelRequest();
+
+        verify(mockRequestQueue, never()).cancel(mockScribeRequest);
+        assertThat(subject.getCurrentRequest()).isNull();
+    }
+
+    @Test
+    public void cancelRequest_withNullCurrentRequest_shouldOnlyClearCurrentRequest() throws Exception {
+        subject.cancelRequest();
+
+        verify(mockRequestQueue, never()).cancel(mockScribeRequest);
+        assertThat(subject.getCurrentRequest()).isNull();
+    }
+
+    @Test
+    public void makeRequestInternal_shouldAddNewRequestToQueue() throws Exception {
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+        reset(mockRequestQueue);
+
+        ScribeRequest previousRequest = (ScribeRequest) subject.getCurrentRequest();
+        ScribeRequest nextRequest = mock(ScribeRequest.class);
+        when(mockScribeRequestFactory.createRequest(subject)).thenReturn(nextRequest);
+
+        subject.makeRequestInternal();
+
+        verify(mockRequestQueue).add(nextRequest);
+        verify(mockRequestQueue, never()).addDelayedRequest(any(Request.class), anyInt());
+        assertThat(previousRequest).isNotEqualTo(nextRequest);
+    }
+
+    @Test
+    public void makeRequestInternal_withRetryCountGreaterThan0_shouldAddNewDelayedRequestToQueue() throws Exception {
+        when(mockScribeBackoffPolicy.getRetryCount()).thenReturn(1);
+        when(mockScribeBackoffPolicy.getBackoffMs()).thenReturn(100);
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+        reset(mockRequestQueue);
+
+        ScribeRequest previousRequest = (ScribeRequest) subject.getCurrentRequest();
+        ScribeRequest nextRequest = mock(ScribeRequest.class);
+        when(mockScribeRequestFactory.createRequest(subject)).thenReturn(nextRequest);
+
+        subject.makeRequestInternal();
+
+        verify(mockRequestQueue).addDelayedRequest(nextRequest, 100);
+        verify(mockRequestQueue, never()).add(any(Request.class));
+        assertThat(previousRequest).isNotEqualTo(nextRequest);
+    }
+
+    @Test
+    public void makeRequestInternal_withNullRequestQueue_shouldClearCurrentRequest_shouldNotAddRequestToQueue() throws Exception {
+        Networking.setRequestQueueForTesting(null);
+
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+
+        verify(mockRequestQueue, never()).add(any(Request.class));
+        verify(mockRequestQueue, never()).addDelayedRequest(any(Request.class), anyInt());
+        assertThat(subject.getCurrentRequest()).isNull();
+    }
+
+    @Test
+    public void clearRequest_shouldSetCurrentRequestToNull() throws Exception {
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+        assertThat(subject.getCurrentRequest()).isNotNull();
+        subject.clearRequest();
+        assertThat(subject.getCurrentRequest()).isNull();
+    }
+}
+
diff --git a/mopub-sdk/src/test/java/com/mopub/network/ScribeBackoffPolicyTest.java b/mopub-sdk/src/test/java/com/mopub/network/ScribeBackoffPolicyTest.java
new file mode 100644
index 00000000..794121a1
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/network/ScribeBackoffPolicyTest.java
@@ -0,0 +1,132 @@
+package com.mopub.network;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.NoConnectionError;
+import com.mopub.volley.VolleyError;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.fest.assertions.api.Assertions.fail;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class ScribeBackoffPolicyTest {
+
+    private ScribeBackoffPolicy subject;
+
+    @Before
+    public void setUp() {
+        subject = new ScribeBackoffPolicy();
+    }
+
+    @Test
+    public void backoff_with503Error_shouldUpdateBackoffTime() throws Exception {
+        NetworkResponse networkResponse = new NetworkResponse(503, null, null, false);
+        VolleyError volleyError = new VolleyError(networkResponse);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(0);
+        assertThat(subject.getRetryCount()).isEqualTo(0);
+
+        subject.backoff(volleyError);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(60000);
+        assertThat(subject.getRetryCount()).isEqualTo(1);
+    }
+
+    @Test
+    public void backoff_with504Error_shouldUpdateBackoffTime() throws Exception {
+        NetworkResponse networkResponse = new NetworkResponse(504, null, null, false);
+        VolleyError volleyError = new VolleyError(networkResponse);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(0);
+        assertThat(subject.getRetryCount()).isEqualTo(0);
+
+        subject.backoff(volleyError);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(60000);
+        assertThat(subject.getRetryCount()).isEqualTo(1);
+    }
+
+    @Test
+    public void backoff_withNoConnectionError_shouldUpdateBackoffTime() throws Exception {
+        VolleyError volleyError = new NoConnectionError();
+
+        assertThat(subject.getBackoffMs()).isEqualTo(0);
+        assertThat(subject.getRetryCount()).isEqualTo(0);
+
+        subject.backoff(volleyError);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(60000);
+        assertThat(subject.getRetryCount()).isEqualTo(1);
+    }
+
+    @Test(expected = VolleyError.class)
+    public void backoff_withOtherErrorType_shouldRethrowException() throws Exception {
+        NetworkResponse networkResponse = new NetworkResponse(500, null, null, false);
+        VolleyError volleyError = new VolleyError(networkResponse);
+
+        subject.backoff(volleyError);
+    }
+
+    @Test
+    public void backoff_shouldUpdateBackoffTime5TimesMax() throws Exception {
+        VolleyError volleyError = new NoConnectionError();
+
+        assertThat(subject.getBackoffMs()).isEqualTo(0);
+        assertThat(subject.getRetryCount()).isEqualTo(0);
+        assertThat(subject.hasAttemptRemaining()).isTrue();
+
+        subject.backoff(volleyError);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(60000);
+        assertThat(subject.getRetryCount()).isEqualTo(1);
+        assertThat(subject.hasAttemptRemaining()).isTrue();
+
+        subject.backoff(volleyError);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(120000);
+        assertThat(subject.getRetryCount()).isEqualTo(2);
+        assertThat(subject.hasAttemptRemaining()).isTrue();
+
+        subject.backoff(volleyError);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(240000);
+        assertThat(subject.getRetryCount()).isEqualTo(3);
+        assertThat(subject.hasAttemptRemaining()).isTrue();
+
+        subject.backoff(volleyError);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(480000);
+        assertThat(subject.getRetryCount()).isEqualTo(4);
+        assertThat(subject.hasAttemptRemaining()).isTrue();
+
+        subject.backoff(volleyError);
+
+        assertThat(subject.getBackoffMs()).isEqualTo(960000);
+        assertThat(subject.getRetryCount()).isEqualTo(5);
+        assertThat(subject.hasAttemptRemaining()).isFalse();
+    }
+
+    @Test(expected = NoConnectionError.class)
+    public void backoff_withNoAttemptsRemaining_shouldRethrowVolleyException() throws Exception {
+        VolleyError volleyError = new NoConnectionError();
+
+        try {
+            subject.backoff(volleyError);
+            subject.backoff(volleyError);
+            subject.backoff(volleyError);
+            subject.backoff(volleyError);
+            subject.backoff(volleyError);
+        } catch (Exception e) {
+            fail("Exception should not be thrown from above backoffs.");
+        }
+
+        subject.backoff(volleyError);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/network/ScribeRequestManagerTest.java b/mopub-sdk/src/test/java/com/mopub/network/ScribeRequestManagerTest.java
new file mode 100644
index 00000000..7fc1b530
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/network/ScribeRequestManagerTest.java
@@ -0,0 +1,80 @@
+package com.mopub.network;
+
+import android.os.Looper;
+
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
+import com.mopub.volley.NoConnectionError;
+import com.mopub.volley.Request;
+import com.mopub.volley.VolleyError;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.annotation.Config;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class ScribeRequestManagerTest {
+
+    private ScribeRequestManager subject;
+    @Mock private ScribeRequest.ScribeRequestFactory mockScribeRequestFactory;
+    @Mock private ScribeBackoffPolicy mockScribeBackoffPolicy;
+    @Mock private ScribeRequest mockScribeRequest;
+    @Mock private MoPubRequestQueue mockRequestQueue;
+
+    @Before
+    public void setUp() {
+        Networking.setRequestQueueForTesting(mockRequestQueue);
+
+        subject = new ScribeRequestManager(Looper.getMainLooper());
+        when(mockScribeRequestFactory.createRequest(subject)).thenReturn(mockScribeRequest);
+        subject.makeRequest(mockScribeRequestFactory, mockScribeBackoffPolicy);
+    }
+
+    @Test
+    public void createRequest_shouldCreateNewScribeRequest() throws Exception {
+        Request request = subject.createRequest();
+        assertThat(request).isEqualTo(mockScribeRequest);
+    }
+
+    @Test
+    public void onResponse_shouldClearRequest() throws Exception {
+        subject.onResponse();
+        assertThat(subject.getCurrentRequest()).isNull();
+    }
+
+    @Test
+    public void onErrorResponse_withBackoffApplied_shouldCallBackoff_shouldMakeDelayedRequest() throws Exception {
+        when(mockScribeBackoffPolicy.getRetryCount()).thenReturn(1);
+        when(mockScribeBackoffPolicy.getBackoffMs()).thenReturn(100);
+
+        VolleyError volleyError = new NoConnectionError();
+        subject.onErrorResponse(volleyError);
+
+        verify(mockScribeBackoffPolicy).backoff(volleyError);
+        verify(mockRequestQueue).addDelayedRequest(mockScribeRequest, 100);
+    }
+
+    @Test
+    public void onErrorResponse_withBackoffNotApplied_shouldClearRequest() throws Exception {
+        reset(mockRequestQueue);
+
+        VolleyError volleyError = new NoConnectionError();
+        doThrow(new VolleyError()).when(mockScribeBackoffPolicy).backoff(volleyError);
+
+        subject.onErrorResponse(volleyError);
+
+        verify(mockScribeBackoffPolicy).backoff(volleyError);
+        verify(mockRequestQueue, never()).add(mockScribeRequest);
+        assertThat(subject.getCurrentRequest()).isNull();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/network/ScribeRequestTest.java b/mopub-sdk/src/test/java/com/mopub/network/ScribeRequestTest.java
new file mode 100644
index 00000000..3af7d466
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/network/ScribeRequestTest.java
@@ -0,0 +1,86 @@
+package com.mopub.network;
+
+import android.app.Activity;
+
+import com.mopub.common.event.BaseEvent;
+import com.mopub.common.event.EventSerializer;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.mobileads.BuildConfig;
+import com.mopub.volley.DefaultRetryPolicy;
+import com.mopub.volley.NetworkResponse;
+import com.mopub.volley.Response;
+
+import org.json.JSONArray;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+
+import java.nio.charset.Charset;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+@Config(constants = BuildConfig.class)
+public class ScribeRequestTest {
+
+    private ScribeRequest subject;
+    @Mock private List<BaseEvent> mockEvents;
+    @Mock private EventSerializer mockEventSerializer;
+    @Mock private ScribeRequest.Listener mockListener;
+
+    @Before
+    public void setUp() {
+        Activity activity = Robolectric.buildActivity(Activity.class).create().get();
+        Networking.getRequestQueue(activity);
+
+        subject = new ScribeRequest("url", mockEvents, mockEventSerializer, mockListener);
+    }
+
+    @Test
+    public void constructor_shouldSetShouldCacheToFalse() throws Exception {
+        assertThat(subject.shouldCache()).isFalse();
+    }
+
+    @Test
+    public void constructor_shouldSetRetryPolicyToDefaultRetryPolicy() throws Exception {
+        assertThat(subject.getRetryPolicy()).isExactlyInstanceOf(DefaultRetryPolicy.class);
+    }
+
+    @Test
+    public void getParams_returnJsonSerializedEventsInMap() throws Exception {
+        JSONArray mockJsonArray = mock(JSONArray.class);
+        when(mockJsonArray.toString()).thenReturn("jsonArrayToString");
+        when(mockEventSerializer.serializeAsJson(mockEvents)).thenReturn(mockJsonArray);
+
+        Map<String, String> params = subject.getParams();
+
+        verify(mockEventSerializer).serializeAsJson(mockEvents);
+        assertThat(params.keySet().size()).isEqualTo(1);
+        assertThat(params.get("log")).isEqualTo("jsonArrayToString");
+    }
+    
+    @Test
+    public void parseNetworkResponse_shouldReturnSuccessResponse() throws Exception {
+        NetworkResponse networkResponse = new NetworkResponse(200, "abc".getBytes(Charset.defaultCharset()), new HashMap<String, String>(), false);
+
+        Response<Void> response = subject.parseNetworkResponse(networkResponse);
+
+        assertThat(response.isSuccess()).isTrue();
+    }
+
+    @Test
+    public void deliverResponse_shouldNotifyListener() throws Exception {
+        subject.deliverResponse(null);
+
+        verify(mockListener).onResponse();
+    }
+}
diff --git a/mopub-sdk/src/test/resources/robolectric.properties b/mopub-sdk/src/test/resources/robolectric.properties
new file mode 100644
index 00000000..3cbe9a8d
--- /dev/null
+++ b/mopub-sdk/src/test/resources/robolectric.properties
@@ -0,0 +1,3 @@
+sdk=21
+shadows=com.mopub.nativeads.test.support.MoPubShadowDisplay,com.mopub.nativeads.test.support.MoPubShadowBitmap,com.mopub.mobileads.test.support.ShadowVastVideoView
+manifest=src/main/AndroidManifest.xml
\ No newline at end of file
