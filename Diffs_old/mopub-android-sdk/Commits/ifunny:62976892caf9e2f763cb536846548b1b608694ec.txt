diff --git a/CHANGELOG.md b/CHANGELOG.md
index 017ae86d..d464b7c6 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,7 @@
+## Version 3.13.0 (September 21, 2015)
+
+- **Android M Support** - Replaced usage of the now-deprecated HttpClient with HttpURLConnection.
+
 ## Version 3.12.0 (August 31, 2015)
 
 - **Rewarded Video Mediation** is now Generally Available. We provide support for Unity Ads, Chartboost, Vungle, and Ad Colony rewarded video.
diff --git a/README.md b/README.md
index a02c4714..f7b2a0b0 100644
--- a/README.md
+++ b/README.md
@@ -27,7 +27,7 @@ The MoPub SDK is available via:
     }
 
     dependencies {
-        compile('com.mopub:mopub-sdk:3.11.0@aar') {
+        compile('com.mopub:mopub-sdk:3.13.0@aar') {
             transitive = true
         }
     }
@@ -63,8 +63,7 @@ The MoPub SDK is available via:
 
 Please view the [changelog](https://github.com/mopub/mopub-android-sdk/blob/master/CHANGELOG.md) for a complete list of additions, fixes, and enhancements in the lastest release..
 
-- **Rewarded Video Mediation** is now Generally Available. We provide support for Unity Ads, Chartboost, Vungle, and Ad Colony rewarded video.
-- **Privacy Information Icon** is now available for native ads. You should add this view to your ViewBinder. See the example in the MoPub Sample app.
+- **Android M Support** - Replaced usage of the now-deprecated HttpClient with HttpURLConnection.
 
 ## Requirements
 
diff --git a/mopub-sample/AndroidManifest.xml b/mopub-sample/AndroidManifest.xml
index f82aa1b6..e481ce62 100644
--- a/mopub-sample/AndroidManifest.xml
+++ b/mopub-sample/AndroidManifest.xml
@@ -1,8 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
       package="com.mopub.simpleadsdemo"
-      android:versionCode="29"
-      android:versionName="3.12.0">
+      android:versionCode="30"
+      android:versionName="3.13.0">
     <uses-sdk android:minSdkVersion="9"
               android:targetSdkVersion="22"/>
 
diff --git a/mopub-sample/build.gradle b/mopub-sample/build.gradle
index 9762a689..c239e950 100644
--- a/mopub-sample/build.gradle
+++ b/mopub-sample/build.gradle
@@ -9,14 +9,14 @@ apply plugin: 'com.android.application'
 
 group = 'com.mopub'
 description = '''MoPub Sample App'''
-version = '3.12.0'
+version = '3.13.0'
 
 android {
     compileSdkVersion 22
     buildToolsVersion '22.0.1'
 
     defaultConfig {
-        versionCode 29
+        versionCode 30
         versionName version
         minSdkVersion 9
         targetSdkVersion 22
diff --git a/mopub-sdk/build.gradle b/mopub-sdk/build.gradle
index 764bcd0d..1698bcd6 100644
--- a/mopub-sdk/build.gradle
+++ b/mopub-sdk/build.gradle
@@ -24,49 +24,65 @@ task wrapper(type: Wrapper) {
 
 group = 'com.mopub'
 description = '''MoPub Android SDK'''
-version = '3.12.0'
+version = '3.13.0'
 
 android {
-	compileSdkVersion 23
-	buildToolsVersion '23.0.1'
-
-	useLibrary 'org.apache.http.legacy'
-
-	defaultConfig {
-		versionCode 29
-		versionName version
-		minSdkVersion 9
-		targetSdkVersion 23
-		consumerProguardFiles 'proguard.txt'
-	}
-
-	sourceSets {
-		main {
-			manifest.srcFile 'AndroidManifest.xml'
-			java.srcDirs = ['src/main/java']
-			resources.srcDirs = ['src/main/java']
-			aidl.srcDirs = ['src/main']
-			renderscript.srcDirs = ['src/main']
-			res.srcDirs = ['res']
-			assets.srcDirs = ['assets']
-		}
-	}
-
-	buildTypes {
-		release {
-			minifyEnabled false
-			proguardFiles getDefaultProguardFile('proguard-android.txt'), file('proguard.txt')
-		}
-
-		debug {
-			minifyEnabled false
-		}
-	}
-
-	// Note: You will also need a local.properties file to set the location of the SDK in the same
-	// way that the existing SDK requires, using the sdk.dir property.
-	// Alternatively, you can set an environment variable called ANDROID_HOME. There is no
-	// difference between the two methods, you can use the one you prefer.
+    compileSdkVersion 23
+    buildToolsVersion '23.0.1'
+
+    defaultConfig {
+        versionCode 30
+        versionName version
+        minSdkVersion 16
+        targetSdkVersion 23
+        consumerProguardFiles 'proguard.txt'
+    }
+
+    sourceSets {
+        main {
+            manifest.srcFile 'AndroidManifest.xml'
+            java.srcDirs = ['src/main/java']
+            resources.srcDirs = ['src/main/java']
+            aidl.srcDirs = ['src/main']
+            renderscript.srcDirs = ['src/main']
+            res.srcDirs = ['res']
+            assets.srcDirs = ['assets']
+        }
+    }
+
+    testOptions {
+        unitTests {
+            // This causes android platform methods from the test JAR
+            // to return null, false, etc instead of throwing an exception.
+            // We should periodically disable this and tackle the broken tests
+            // as it exposes when we are hitting platform APIs in our tests.
+            // If these tests *require* platform APIs we may want to make them
+            // connected tests instead.
+            returnDefaultValues = true
+
+            // Test JVM settings since we have a lot of classes loaded.
+            all {
+                jvmArgs '-XX:MaxPermSize=4096m', '-Xmx8192m'
+                forkEvery 200
+            }
+        }
+    }
+
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), file('proguard.txt')
+        }
+      
+        debug {
+            minifyEnabled false
+        }
+    }
+
+    // Note: You will also need a local.properties file to set the location of the SDK in the same 
+    // way that the existing SDK requires, using the sdk.dir property.
+    // Alternatively, you can set an environment variable called ANDROID_HOME. There is no 
+    // difference between the two methods, you can use the one you prefer.
 }
 
 
diff --git a/mopub-sdk/src/main/java/com/mopub/common/DownloadTask.java b/mopub-sdk/src/main/java/com/mopub/common/DownloadTask.java
deleted file mode 100644
index 7230a2ae..00000000
--- a/mopub-sdk/src/main/java/com/mopub/common/DownloadTask.java
+++ /dev/null
@@ -1,66 +0,0 @@
-package com.mopub.common;
-
-import android.net.http.AndroidHttpClient;
-import android.os.AsyncTask;
-
-import com.mopub.common.logging.MoPubLog;
-
-import org.apache.http.HttpResponse;
-import org.apache.http.client.methods.HttpUriRequest;
-
-public class DownloadTask extends AsyncTask<HttpUriRequest, Void, DownloadResponse> {
-    private final DownloadTaskListener mDownloadTaskListener;
-    private String mUrl;
-
-    public static interface DownloadTaskListener {
-        abstract void onComplete(String url, DownloadResponse downloadResponse);
-    }
-
-    public DownloadTask(final DownloadTaskListener downloadTaskListener) throws IllegalArgumentException {
-        if (downloadTaskListener == null) {
-            throw new IllegalArgumentException("DownloadTaskListener must not be null.");
-        }
-
-        mDownloadTaskListener = downloadTaskListener;
-    }
-
-    @Override
-    protected DownloadResponse doInBackground(final HttpUriRequest... httpUriRequests) {
-        if (httpUriRequests == null || httpUriRequests.length == 0 || httpUriRequests[0] == null) {
-            MoPubLog.d("Download task tried to execute null or empty url");
-            return null;
-        }
-
-        final HttpUriRequest httpUriRequest = httpUriRequests[0];
-        mUrl = httpUriRequest.getURI().toString();
-
-        AndroidHttpClient httpClient = null;
-        try {
-            httpClient = HttpClient.getHttpClient();
-            final HttpResponse httpResponse = httpClient.execute(httpUriRequest);
-            return new DownloadResponse(httpResponse);
-        } catch (Exception e) {
-            MoPubLog.d("Download task threw an internal exception", e);
-            return null;
-        } finally {
-            if (httpClient != null) {
-                httpClient.close();
-            }
-        }
-    }
-
-    @Override
-    protected void onPostExecute(final DownloadResponse downloadResponse) {
-        if (isCancelled()) {
-            onCancelled();
-            return;
-        }
-
-        mDownloadTaskListener.onComplete(mUrl, downloadResponse);
-    }
-
-    @Override
-    protected void onCancelled() {
-        MoPubLog.d("DownloadTask was cancelled.");
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/MoPub.java b/mopub-sdk/src/main/java/com/mopub/common/MoPub.java
index cbf225ed..53e91de0 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/MoPub.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/MoPub.java
@@ -8,7 +8,7 @@
 import com.mopub.mobileads.MoPubRewardedVideoManager;
 
 public class MoPub {
-    public static final String SDK_VERSION = "3.12.0";
+    public static final String SDK_VERSION = "3.13.0";
 
     public static enum LocationAwareness { NORMAL, TRUNCATED, DISABLED }
 
diff --git a/mopub-sdk/src/main/java/com/mopub/common/HttpClient.java b/mopub-sdk/src/main/java/com/mopub/common/MoPubHttpUrlConnection.java
similarity index 60%
rename from mopub-sdk/src/main/java/com/mopub/common/HttpClient.java
rename to mopub-sdk/src/main/java/com/mopub/common/MoPubHttpUrlConnection.java
index 09c16730..d8032625 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/HttpClient.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/MoPubHttpUrlConnection.java
@@ -1,51 +1,38 @@
 package com.mopub.common;
 
-import android.content.Context;
-import android.net.http.AndroidHttpClient;
 import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
 
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.network.Networking;
 
-import org.apache.http.client.methods.HttpGet;
-import org.apache.http.client.params.HttpClientParams;
-import org.apache.http.params.HttpConnectionParams;
-import org.apache.http.params.HttpParams;
-
+import java.io.IOException;
 import java.io.UnsupportedEncodingException;
+import java.net.HttpURLConnection;
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
 import java.net.URLDecoder;
 
-import static com.mopub.common.util.ResponseHeader.USER_AGENT;
-
-public class HttpClient {
-    private static final int CONNECTION_TIMEOUT = 10000;
-    private static final int SOCKET_TIMEOUT = 10000;
-
-    public static AndroidHttpClient getHttpClient() {
-        final String userAgent = Networking.getCachedUserAgent();
-
-        AndroidHttpClient httpClient = AndroidHttpClient.newInstance(userAgent);
+public abstract class MoPubHttpUrlConnection extends HttpURLConnection {
+    private static final int CONNECT_TIMEOUT = 10000;
+    private static final int READ_TIMEOUT = 10000;
 
-        HttpParams params = httpClient.getParams();
-        HttpConnectionParams.setConnectionTimeout(params, CONNECTION_TIMEOUT);
-        HttpConnectionParams.setSoTimeout(params, SOCKET_TIMEOUT);
-        HttpClientParams.setRedirecting(params, true);
-
-        return httpClient;
-    }
-
-    public static HttpGet initializeHttpGet(@NonNull final String url) {
-        return initializeHttpGet(url, null);
+    private MoPubHttpUrlConnection(URL url) {
+        super(url);
     }
 
-    public static HttpGet initializeHttpGet(@NonNull String url, @Nullable final Context context) {
+    public static HttpURLConnection getHttpUrlConnection(@NonNull final String url)
+            throws IOException {
         Preconditions.checkNotNull(url);
 
-        // Try to encode url. If this fails, then fallback on the original url
+        // If the passed-in url has already been encoded improperly, there is no way to salvage this
+        // connection request -- fail quickly instead.
+        if (isUrlImproperlyEncoded(url)) {
+            throw new IllegalArgumentException("URL is improperly encoded: " + url);
+        }
+
+        // Attempt to encode the passed-in url and use that, if possible. If this fails, then
+        // fallback to the original url instead.
         String getUrl;
         try {
             getUrl = urlEncode(url);
@@ -53,26 +40,20 @@ public static HttpGet initializeHttpGet(@NonNull String url, @Nullable final Con
             getUrl = url;
         }
 
-        final HttpGet httpGet = new HttpGet(getUrl);
-
-        final String webViewUserAgent;
-        if (context != null) {
-            webViewUserAgent = Networking.getUserAgent(context);
-        } else {
-            webViewUserAgent = Networking.getCachedUserAgent();
-        }
-
-        if (webViewUserAgent != null) {
-            httpGet.addHeader(USER_AGENT.getKey(), webViewUserAgent);
-        }
+        final HttpURLConnection urlConnection =
+                (HttpURLConnection) new URL(getUrl).openConnection();
+        urlConnection.setRequestProperty("User-Agent", Networking.getCachedUserAgent());
+        urlConnection.setConnectTimeout(CONNECT_TIMEOUT);
+        urlConnection.setReadTimeout(READ_TIMEOUT);
 
-        return httpGet;
+        return urlConnection;
     }
 
     /**
      * This method constructs a properly encoded and valid URI adhering to legal characters for
      * each component. See Android docs on these classes for reference.
      */
+    @NonNull
     public static String urlEncode(@NonNull final String url) throws Exception {
         Preconditions.checkNotNull(url);
 
@@ -122,6 +103,7 @@ static boolean isUrlUnencoded(@NonNull String url) {
     /**
      * This method encodes each component of the URL into a valid URI.
      */
+    @NonNull
     static URI encodeUrl(@NonNull String urlString) throws Exception {
         URI uri;
         try {
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastManager.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastManager.java
index d2e16bc7..11e41f7b 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/VastManager.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastManager.java
@@ -11,8 +11,7 @@
 import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.util.AsyncTasks;
-
-import static com.mopub.mobileads.VastVideoDownloadTask.VastVideoDownloadTaskListener;
+import com.mopub.mobileads.VideoDownloader.VideoDownloaderListener;
 
 /**
  * Given a VAST xml document, this class manages the lifecycle of parsing and finding a video and
@@ -32,8 +31,7 @@
          * @param vastVideoConfig A configuration that can be used for displaying a VAST
          *                               video or {@code null} if the VAST document is invalid.
          */
-        void onVastVideoConfigurationPrepared(
-                @Nullable final VastVideoConfig vastVideoConfig);
+        void onVastVideoConfigurationPrepared(@Nullable final VastVideoConfig vastVideoConfig);
     }
 
     @Nullable private VastManagerListener mVastManagerListener;
@@ -88,6 +86,7 @@ public void onAggregationComplete(@Nullable final VastVideoConfig vastVideoConfi
                     "mVastManagerListener cannot be null here. Did you call " +
                             "prepareVastVideoConfiguration()?");
         }
+
         if (vastVideoConfig == null) {
             mVastManagerListener.onVastVideoConfigurationPrepared(null);
             return;
@@ -98,28 +97,19 @@ public void onAggregationComplete(@Nullable final VastVideoConfig vastVideoConfi
             return;
         }
 
-        final VastVideoDownloadTask vastVideoDownloadTask = new VastVideoDownloadTask(
-                new VastVideoDownloadTaskListener() {
-                    @Override
-                    public void onComplete(boolean success) {
-                        if (success && updateDiskMediaFileUrl(vastVideoConfig)) {
-                            mVastManagerListener.onVastVideoConfigurationPrepared(vastVideoConfig);
-                        } else {
-                            mVastManagerListener.onVastVideoConfigurationPrepared(null);
-                        }
-                    }
+        final VideoDownloaderListener videoDownloaderListener = new VideoDownloaderListener() {
+            @Override
+            public void onComplete(boolean success) {
+                if (success && updateDiskMediaFileUrl(vastVideoConfig)) {
+                    mVastManagerListener.onVastVideoConfigurationPrepared(vastVideoConfig);
+                } else {
+                    MoPubLog.d("Failed to download VAST video.");
+                    mVastManagerListener.onVastVideoConfigurationPrepared(null);
                 }
-        );
-
-        try {
-            AsyncTasks.safeExecuteOnExecutor(
-                    vastVideoDownloadTask,
-                    vastVideoConfig.getNetworkMediaFileUrl()
-            );
-        } catch (Exception e) {
-            MoPubLog.d("Failed to download vast video", e);
-            mVastManagerListener.onVastVideoConfigurationPrepared(null);
-        }
+            }
+        };
+
+        VideoDownloader.cache(vastVideoConfig.getNetworkMediaFileUrl(), videoDownloaderListener);
     }
 
     /**
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoDownloadTask.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoDownloadTask.java
deleted file mode 100644
index 910b59d2..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoDownloadTask.java
+++ /dev/null
@@ -1,76 +0,0 @@
-package com.mopub.mobileads;
-
-import android.net.http.AndroidHttpClient;
-import android.os.AsyncTask;
-
-import com.mopub.common.CacheService;
-import com.mopub.common.HttpClient;
-import com.mopub.common.logging.MoPubLog;
-
-import org.apache.http.HttpResponse;
-import org.apache.http.client.methods.HttpGet;
-
-import java.io.BufferedInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-
-public class VastVideoDownloadTask extends AsyncTask<String, Void, Boolean> {
-    private static final int MAX_VIDEO_SIZE = 25 * 1024 * 1024; // 25 MiB
-
-    public interface VastVideoDownloadTaskListener {
-        public void onComplete(boolean success);
-    }
-
-    private final VastVideoDownloadTaskListener mVastVideoDownloadTaskListener;
-
-    public VastVideoDownloadTask(final VastVideoDownloadTaskListener listener) {
-        mVastVideoDownloadTaskListener = listener;
-    }
-
-    @Override
-    protected Boolean doInBackground(final String... params) {
-        if (params == null || params.length == 0 || params[0] == null) {
-            return false;
-        }
-
-        final String videoUrl = params[0];
-        AndroidHttpClient httpClient = null;
-        try {
-            httpClient = HttpClient.getHttpClient();
-            final HttpGet httpget = HttpClient.initializeHttpGet(videoUrl);
-            final HttpResponse response = httpClient.execute(httpget);
-
-            if (response == null || response.getEntity() == null) {
-                throw new IOException("Obtained null response from video url: " + videoUrl);
-            }
-
-            if (response.getEntity().getContentLength() > MAX_VIDEO_SIZE) {
-                throw new IOException("Video exceeded max download size");
-            }
-
-            final InputStream inputStream = new BufferedInputStream(response.getEntity().getContent());
-            final boolean diskPutResult = CacheService.putToDiskCache(videoUrl, inputStream);
-            inputStream.close();
-            return diskPutResult;
-        } catch (Exception e) {
-            MoPubLog.d("Failed to download video: " + e.getMessage());
-            return false;
-        } finally {
-            if (httpClient != null) {
-                httpClient.close();
-            }
-        }
-    }
-
-    @Override
-    protected void onCancelled() {
-        onPostExecute(false);
-    }
-
-    @Override
-    protected void onPostExecute(final Boolean success) {
-        if (mVastVideoDownloadTaskListener != null) {
-            mVastVideoDownloadTaskListener.onComplete(success);
-        }
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastXmlManagerAggregator.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastXmlManagerAggregator.java
index 09c5d7b7..a539f01e 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/VastXmlManagerAggregator.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastXmlManagerAggregator.java
@@ -3,7 +3,6 @@
 import android.content.Context;
 import android.content.res.Configuration;
 import android.graphics.Point;
-import android.net.http.AndroidHttpClient;
 import android.os.AsyncTask;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
@@ -11,19 +10,20 @@
 import android.view.Display;
 import android.view.WindowManager;
 
-import com.mopub.common.HttpClient;
+import com.mopub.common.MoPubHttpUrlConnection;
 import com.mopub.common.Preconditions;
 import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.util.Dips;
+import com.mopub.common.util.Streams;
 import com.mopub.common.util.Strings;
 import com.mopub.network.Networking;
 
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpResponse;
-import org.apache.http.client.methods.HttpGet;
-
+import java.io.BufferedInputStream;
+import java.io.IOException;
+import java.io.InputStream;
 import java.lang.ref.WeakReference;
+import java.net.HttpURLConnection;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -105,25 +105,17 @@ protected void onPreExecute() {
 
     @Override
     protected VastVideoConfig doInBackground(@Nullable String... strings) {
-        AndroidHttpClient httpClient = null;
+        if (strings == null || strings.length == 0 || strings[0] == null) {
+            return null;
+        }
+
         try {
-            httpClient = HttpClient.getHttpClient();
-            if (strings != null && strings.length > 0) {
-                String vastXml = strings[0];
-                if (vastXml == null) {
-                    return null;
-                }
-                return evaluateVastXmlManager(vastXml, httpClient, new ArrayList<VastTracker>());
-            }
+            final String vastXml = strings[0];
+            return evaluateVastXmlManager(vastXml, new ArrayList<VastTracker>());
         } catch (Exception e) {
-            MoPubLog.d("Failed to parse VAST XML", e);
-        } finally {
-            if (httpClient != null) {
-                httpClient.close();
-            }
+            MoPubLog.d("Unable to generate VastVideoConfig.", e);
+            return null;
         }
-
-        return null;
     }
 
     @Override
@@ -155,7 +147,6 @@ protected void onCancelled() {
      * non-xml errors.
      *
      * @param vastXml           The xml that this class parses
-     * @param androidHttpClient This is used to follow redirects
      * @param errorTrackers     This is the current list of error tracker URLs to hit if something
      *                          goes wrong.
      * @return {@link VastVideoConfig} with all available fields set or null if the xml is
@@ -164,10 +155,8 @@ protected void onCancelled() {
     @VisibleForTesting
     @Nullable
     VastVideoConfig evaluateVastXmlManager(@NonNull final String vastXml,
-            @NonNull final AndroidHttpClient androidHttpClient,
             @NonNull final List<VastTracker> errorTrackers) {
         Preconditions.checkNotNull(vastXml, "vastXml cannot be null");
-        Preconditions.checkNotNull(androidHttpClient, "androidHttpClient cannot be null");
         Preconditions.checkNotNull(errorTrackers, "errorTrackers cannot be null");
 
         final VastXmlManager xmlManager = new VastXmlManager();
@@ -180,7 +169,7 @@ VastVideoConfig evaluateVastXmlManager(@NonNull final String vastXml,
             return null;
         }
 
-        List<VastAdXmlManager> vastAdXmlManagers = xmlManager.getAdXmlManagers();
+        final List<VastAdXmlManager> vastAdXmlManagers = xmlManager.getAdXmlManagers();
 
         // If there are no ads, fire the error trackers
         if (fireErrorTrackerIfNoAds(vastAdXmlManagers, xmlManager, mContext)) {
@@ -188,15 +177,15 @@ VastVideoConfig evaluateVastXmlManager(@NonNull final String vastXml,
         }
 
         for (VastAdXmlManager vastAdXmlManager : vastAdXmlManagers) {
-
             if (!isValidSequenceNumber(vastAdXmlManager.getSequence())) {
                 continue;
             }
 
             // InLine evaluation
-            VastInLineXmlManager vastInLineXmlManager = vastAdXmlManager.getInLineXmlManager();
+            final VastInLineXmlManager vastInLineXmlManager =
+                    vastAdXmlManager.getInLineXmlManager();
             if (vastInLineXmlManager != null) {
-                VastVideoConfig vastVideoConfig = evaluateInLineXmlManager(
+                final VastVideoConfig vastVideoConfig = evaluateInLineXmlManager(
                         vastInLineXmlManager, errorTrackers);
                 // If the vastVideoConfig is non null, it means we found a valid media file
                 if (vastVideoConfig != null) {
@@ -206,19 +195,19 @@ VastVideoConfig evaluateVastXmlManager(@NonNull final String vastXml,
             }
 
             // Wrapper evaluation
-            VastWrapperXmlManager vastWrapperXmlManager = vastAdXmlManager.getWrapperXmlManager();
+            final VastWrapperXmlManager vastWrapperXmlManager
+                    = vastAdXmlManager.getWrapperXmlManager();
             if (vastWrapperXmlManager != null) {
                 final List<VastTracker> wrapperErrorTrackers = new ArrayList<VastTracker>(errorTrackers);
                 wrapperErrorTrackers.addAll(vastWrapperXmlManager.getErrorTrackers());
-                String vastRedirectXml = evaluateWrapperRedirect(vastWrapperXmlManager,
-                        androidHttpClient, wrapperErrorTrackers);
+                final String vastRedirectXml = evaluateWrapperRedirect(vastWrapperXmlManager,
+                        wrapperErrorTrackers);
                 if (vastRedirectXml == null) {
                     continue;
                 }
 
-                VastVideoConfig vastVideoConfig = evaluateVastXmlManager(
+                final VastVideoConfig vastVideoConfig = evaluateVastXmlManager(
                         vastRedirectXml,
-                        androidHttpClient,
                         wrapperErrorTrackers);
                 // If we don't find a valid video creative somewhere down this wrapper chain,
                 // look at the next Ad element
@@ -232,7 +221,7 @@ VastVideoConfig evaluateVastXmlManager(@NonNull final String vastXml,
                 // in one of Wrapper redirects. Therefore, aggregate all trackers in the wrapper
                 vastVideoConfig.addImpressionTrackers(
                         vastWrapperXmlManager.getImpressionTrackers());
-                List<VastLinearXmlManager> linearXmlManagers =
+                final List<VastLinearXmlManager> linearXmlManagers =
                         vastWrapperXmlManager.getLinearXmlManagers();
                 for (VastLinearXmlManager linearXmlManager : linearXmlManagers) {
                     populateLinearTrackersAndIcon(linearXmlManager, vastVideoConfig);
@@ -293,13 +282,16 @@ private VastVideoConfig evaluateInLineXmlManager(
             @NonNull final VastInLineXmlManager vastInLineXmlManager,
             @NonNull final List<VastTracker> errorTrackers) {
         Preconditions.checkNotNull(vastInLineXmlManager);
+        Preconditions.checkNotNull(errorTrackers);
+
+        final List<VastLinearXmlManager> linearXmlManagers
+                = vastInLineXmlManager.getLinearXmlManagers();
 
-        List<VastLinearXmlManager> linearXmlManagers = vastInLineXmlManager.getLinearXmlManagers();
         for (VastLinearXmlManager linearXmlManager : linearXmlManagers) {
             String bestMediaFileUrl = getBestMediaFileUrl(linearXmlManager.getMediaXmlManagers());
             if (bestMediaFileUrl != null) {
                 // Create vast video configuration and populate initial trackers
-                VastVideoConfig vastVideoConfig = new VastVideoConfig();
+                final VastVideoConfig vastVideoConfig = new VastVideoConfig();
                 vastVideoConfig.addImpressionTrackers(vastInLineXmlManager.getImpressionTrackers());
                 populateLinearTrackersAndIcon(linearXmlManager, vastVideoConfig);
 
@@ -327,22 +319,20 @@ private VastVideoConfig evaluateInLineXmlManager(
      * Retrieves the Wrapper's redirect uri and follows it to return the next VAST xml String.
      *
      * @param vastWrapperXmlManager used to get the redirect uri
-     * @param androidHttpClient     the http client
      * @param wrapperErrorTrackers  Error trackers to hit if something goes wrong
      * @return the next VAST xml String or {@code null} if it could not be resolved
      */
     @Nullable
     private String evaluateWrapperRedirect(@NonNull VastWrapperXmlManager vastWrapperXmlManager,
-            @NonNull AndroidHttpClient androidHttpClient,
             @NonNull List<VastTracker> wrapperErrorTrackers) {
-        String vastAdTagUri = vastWrapperXmlManager.getVastAdTagURI();
+        final String vastAdTagUri = vastWrapperXmlManager.getVastAdTagURI();
         if (vastAdTagUri == null) {
             return null;
         }
 
         String vastRedirectXml = null;
         try {
-            vastRedirectXml = followVastRedirect(androidHttpClient, vastAdTagUri);
+            vastRedirectXml = followVastRedirect(vastAdTagUri);
         } catch (Exception e) {
             MoPubLog.d("Failed to follow VAST redirect", e);
             if (!wrapperErrorTrackers.isEmpty()) {
@@ -688,19 +678,27 @@ static boolean isValidSequenceNumber(@Nullable final String sequence) {
     }
 
     @Nullable
-    private String followVastRedirect(@NonNull final AndroidHttpClient httpClient,
-            @NonNull final String redirectUrl) throws Exception {
-        Preconditions.checkNotNull(httpClient);
+    private String followVastRedirect(@NonNull final String redirectUrl) throws IOException {
         Preconditions.checkNotNull(redirectUrl);
 
         if (mTimesFollowedVastRedirect < MAX_TIMES_TO_FOLLOW_VAST_REDIRECT) {
             mTimesFollowedVastRedirect++;
 
-            final HttpGet httpget = HttpClient.initializeHttpGet(redirectUrl);
-            final HttpResponse response = httpClient.execute(httpget);
-            final HttpEntity entity = response.getEntity();
-            return (entity != null) ? Strings.fromStream(entity.getContent()) : null;
+            HttpURLConnection urlConnection = null;
+            InputStream inputStream = null;
+            try {
+                urlConnection = MoPubHttpUrlConnection.getHttpUrlConnection(redirectUrl);
+                inputStream = new BufferedInputStream(urlConnection.getInputStream());
+
+                return Strings.fromStream(inputStream);
+            } finally {
+                Streams.closeStream(inputStream);
+                if (urlConnection != null) {
+                    urlConnection.disconnect();
+                }
+            }
         }
+
         return null;
     }
 
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VideoDownloader.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VideoDownloader.java
new file mode 100644
index 00000000..968e5550
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VideoDownloader.java
@@ -0,0 +1,184 @@
+package com.mopub.mobileads;
+
+import android.os.AsyncTask;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.CacheService;
+import com.mopub.common.MoPubHttpUrlConnection;
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.AsyncTasks;
+import com.mopub.common.util.Streams;
+
+import java.io.BufferedInputStream;
+import java.io.InputStream;
+import java.lang.ref.WeakReference;
+import java.net.HttpURLConnection;
+import java.util.ArrayDeque;
+import java.util.Deque;
+
+public class VideoDownloader {
+    private static final int MAX_VIDEO_SIZE = 25 * 1024 * 1024; // 25 MiB
+    private static final Deque<WeakReference<VideoDownloaderTask>> sDownloaderTasks =
+            new ArrayDeque<WeakReference<VideoDownloaderTask>>();
+
+    interface VideoDownloaderListener {
+        void onComplete(boolean success);
+    }
+
+    private VideoDownloader() {}
+
+    public static void cache(@Nullable final String url,
+            @NonNull final VideoDownloaderListener listener) {
+        Preconditions.checkNotNull(listener);
+
+        if (url == null) {
+            MoPubLog.d("VideoDownloader attempted to cache video with null url.");
+            listener.onComplete(false);
+            return;
+        }
+
+        final VideoDownloaderTask videoDownloaderTask = new VideoDownloaderTask(listener);
+        try {
+            AsyncTasks.safeExecuteOnExecutor(videoDownloaderTask, url);
+        } catch (Exception e) {
+            listener.onComplete(false);
+        }
+    }
+
+
+    public static void cancelAllDownloaderTasks() {
+        for (final WeakReference<VideoDownloaderTask> weakDownloaderTask : sDownloaderTasks) {
+            cancelOneTask(weakDownloaderTask);
+        }
+
+        sDownloaderTasks.clear();
+    }
+
+    public static void cancelLastDownloadTask() {
+        if (sDownloaderTasks.isEmpty()) {
+            return;
+        }
+
+        cancelOneTask(sDownloaderTasks.peekLast());
+        sDownloaderTasks.removeLast();
+    }
+
+    /**
+     * @param weakDownloaderTask A weak reference to an in-flight VideoDownloaderTask
+     * @return  <tt>false</tt> if weakDownloaderTask is null, has a null referent, or if the task has
+     *          already been completed
+     *          <tt>true</tt> otherwise
+     */
+    private static boolean cancelOneTask(
+            @Nullable final WeakReference<VideoDownloaderTask> weakDownloaderTask) {
+        if (weakDownloaderTask == null) {
+            return false;
+        }
+
+        final VideoDownloaderTask downloaderTask = weakDownloaderTask.get();
+        if (downloaderTask == null) {
+            return false;
+        }
+
+        return downloaderTask.cancel(true);
+    }
+
+    @VisibleForTesting
+    static class VideoDownloaderTask extends AsyncTask<String, Void, Boolean> {
+        @NonNull private final VideoDownloaderListener mListener;
+        @NonNull private final WeakReference<VideoDownloaderTask> mWeakSelf;
+
+        @VisibleForTesting
+        VideoDownloaderTask(@NonNull final VideoDownloaderListener listener) {
+            mListener = listener;
+            mWeakSelf = new WeakReference<VideoDownloaderTask>(this);
+            sDownloaderTasks.add(mWeakSelf);
+        }
+
+        @Override
+        protected Boolean doInBackground(final String... params) {
+            if (params == null || params.length == 0 || params[0] == null) {
+                MoPubLog.d("VideoDownloader task tried to execute null or empty url.");
+                return false;
+            }
+
+            final String videoUrl = params[0];
+            HttpURLConnection urlConnection = null;
+            InputStream inputStream = null;
+            try {
+                urlConnection = MoPubHttpUrlConnection.getHttpUrlConnection(videoUrl);
+                inputStream = new BufferedInputStream(urlConnection.getInputStream());
+
+                // Check status code range
+                int statusCode = urlConnection.getResponseCode();
+                if (statusCode < HttpURLConnection.HTTP_OK
+                        || statusCode >= HttpURLConnection.HTTP_MULT_CHOICE) {
+                    MoPubLog.d("VideoDownloader encountered unexpected statusCode: " +
+                            statusCode);
+                    return false;
+                }
+
+                // Check video size below maximum
+                int contentLength = urlConnection.getContentLength();
+                if (contentLength > MAX_VIDEO_SIZE) {
+                    MoPubLog.d(String.format(
+                            "VideoDownloader encountered video larger than disk cap. " +
+                                    "(%d bytes / %d maximum).",
+                            contentLength,
+                            MAX_VIDEO_SIZE));
+                    return false;
+                }
+
+                boolean diskPutResult = CacheService.putToDiskCache(videoUrl, inputStream);
+                return diskPutResult;
+            } catch (Exception e) {
+                MoPubLog.d("VideoDownloader task threw an internal exception.", e);
+                return false;
+            } finally {
+                Streams.closeStream(inputStream);
+                if (urlConnection != null) {
+                    urlConnection.disconnect();
+                }
+            }
+        }
+
+        @Override
+        protected void onPostExecute(final Boolean success) {
+            if (isCancelled()) {
+                onCancelled();
+                return;
+            }
+
+            sDownloaderTasks.remove(mWeakSelf);
+
+            if (success == null) {
+                mListener.onComplete(false);
+                return;
+            }
+
+            mListener.onComplete(success);
+        }
+
+        @Override
+        protected void onCancelled() {
+            MoPubLog.d("VideoDownloader task was cancelled.");
+            sDownloaderTasks.remove(mWeakSelf);
+            mListener.onComplete(false);
+        }
+    }
+
+    @Deprecated
+    @VisibleForTesting
+    public static Deque<WeakReference<VideoDownloaderTask>> getDownloaderTasks() {
+        return sDownloaderTasks;
+    }
+
+    @Deprecated
+    @VisibleForTesting
+    public static void clearDownloaderTasks() {
+        sDownloaderTasks.clear();
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/HttpClientFactory.java b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/HttpClientFactory.java
deleted file mode 100644
index b13cded1..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/HttpClientFactory.java
+++ /dev/null
@@ -1,41 +0,0 @@
-package com.mopub.mobileads.factories;
-
-import org.apache.http.impl.client.DefaultHttpClient;
-import org.apache.http.params.BasicHttpParams;
-import org.apache.http.params.HttpConnectionParams;
-import org.apache.http.params.HttpParams;
-
-public class HttpClientFactory {
-    public static final int SOCKET_SIZE = 8192;
-
-    private static HttpClientFactory instance = new HttpClientFactory();
-
-    @Deprecated // for testing
-    public static void setInstance(HttpClientFactory factory) {
-        instance = factory;
-    }
-
-    public static DefaultHttpClient create(int timeoutMilliseconds) {
-        return instance.internalCreate(timeoutMilliseconds);
-    }
-
-    public static DefaultHttpClient create() {
-        return instance.internalCreate(0);
-    }
-
-    protected DefaultHttpClient internalCreate(int timeoutMilliseconds) {
-        HttpParams httpParameters = new BasicHttpParams();
-
-        if (timeoutMilliseconds > 0) {
-            // Set timeouts to wait for connection establishment / receiving data.
-            HttpConnectionParams.setConnectionTimeout(httpParameters, timeoutMilliseconds);
-            HttpConnectionParams.setSoTimeout(httpParameters, timeoutMilliseconds);
-        }
-
-        // Set the buffer size to avoid OutOfMemoryError exceptions on certain HTC devices.
-        // http://stackoverflow.com/questions/5358014/android-httpclient-oom-on-4g-lte-htc-thunderbolt
-        HttpConnectionParams.setSocketBufferSize(httpParameters, SOCKET_SIZE);
-
-        return new DefaultHttpClient(httpParameters);
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/VastVideoDownloadTaskFactory.java b/mopub-sdk/src/main/java/com/mopub/mobileads/factories/VastVideoDownloadTaskFactory.java
deleted file mode 100644
index c2bd8e68..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/factories/VastVideoDownloadTaskFactory.java
+++ /dev/null
@@ -1,20 +0,0 @@
-package com.mopub.mobileads.factories;
-
-import com.mopub.mobileads.VastVideoDownloadTask;
-
-public class VastVideoDownloadTaskFactory {
-    private static VastVideoDownloadTaskFactory instance = new VastVideoDownloadTaskFactory();
-
-    @Deprecated // for testing
-    public static void setInstance(VastVideoDownloadTaskFactory factory){
-        instance = factory;
-    }
-
-    public static VastVideoDownloadTask create(VastVideoDownloadTask.VastVideoDownloadTaskListener vastVideoDownloadTaskListener) {
-        return instance.internalCreate(vastVideoDownloadTaskListener);
-    }
-
-    protected VastVideoDownloadTask internalCreate(VastVideoDownloadTask.VastVideoDownloadTaskListener vastVideoDownloadTaskListener) {
-        return new VastVideoDownloadTask(vastVideoDownloadTaskListener);
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/HttpClients.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/HttpClients.java
deleted file mode 100644
index fa2dd387..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/HttpClients.java
+++ /dev/null
@@ -1,16 +0,0 @@
-package com.mopub.mobileads.util;
-
-import org.apache.http.client.HttpClient;
-
-public class HttpClients {
-    public static void safeShutdown(final HttpClient httpClient) {
-        new Thread(new Runnable() {
-            @Override
-            public void run() {
-                if (httpClient != null && httpClient.getConnectionManager() != null) {
-                    httpClient.getConnectionManager().shutdown();
-                }
-            }
-        }).start();
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mraid/MraidNativeCommandHandler.java b/mopub-sdk/src/main/java/com/mopub/mraid/MraidNativeCommandHandler.java
index bc0a2d82..63db6598 100644
--- a/mopub-sdk/src/main/java/com/mopub/mraid/MraidNativeCommandHandler.java
+++ b/mopub-sdk/src/main/java/com/mopub/mraid/MraidNativeCommandHandler.java
@@ -15,11 +15,14 @@
 import android.os.Environment;
 import android.provider.CalendarContract;
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
 import android.view.View;
 import android.view.Window;
 import android.view.WindowManager;
 import android.widget.Toast;
 
+import com.mopub.common.MoPubHttpUrlConnection;
 import com.mopub.common.Preconditions;
 import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
@@ -28,30 +31,24 @@
 import com.mopub.common.util.Streams;
 import com.mopub.common.util.Utils;
 import com.mopub.common.util.VersionCode;
-import com.mopub.mobileads.factories.HttpClientFactory;
-import com.mopub.network.HeaderUtils;
-
-import org.apache.http.Header;
-import org.apache.http.HttpResponse;
-import org.apache.http.client.HttpClient;
-import org.apache.http.client.methods.HttpGet;
 
+import java.io.BufferedInputStream;
 import java.io.File;
 import java.io.FileOutputStream;
-import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.net.HttpURLConnection;
 import java.net.URI;
 import java.text.ParseException;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 
 import static android.Manifest.permission.WRITE_EXTERNAL_STORAGE;
 import static android.os.Environment.MEDIA_MOUNTED;
-import static com.mopub.common.HttpClient.*;
 import static com.mopub.common.util.ResponseHeader.LOCATION;
 
 public class MraidNativeCommandHandler {
@@ -439,10 +436,18 @@ public void onClick(DialogInterface dialog, int which) {
                 .show();
     }
 
-    private static class DownloadImageAsyncTask extends AsyncTask<String, Void, Boolean> {
+    /**
+     * Downloads an image from a remote URL and stores it in the user's photo gallery.
+     *
+     * This runs on the background thread, creates the appropriate photo gallery directory if not
+     * present, and uses the mime-type to append a file extension if necessary.
+     *
+     * The DownloadImageAsyncTaskListener parameter is notified of task success or failure.
+     */
+    @VisibleForTesting
+    static class DownloadImageAsyncTask extends AsyncTask<String, Void, Boolean> {
         interface DownloadImageAsyncTaskListener {
             void onSuccess();
-
             void onFailure();
         }
 
@@ -458,8 +463,9 @@ public DownloadImageAsyncTask(@NonNull final Context context,
 
         @Override
         protected Boolean doInBackground(@NonNull String[] params) {
-            Preconditions.checkState(params.length > 0);
-            Preconditions.checkNotNull(params[0]);
+            if (params == null || params.length == 0 || params[0] == null) {
+                return false;
+            }
 
             final File pictureStoragePath = getPictureStoragePath();
 
@@ -469,21 +475,20 @@ protected Boolean doInBackground(@NonNull String[] params) {
             final String uriString = params[0];
             URI uri = URI.create(uriString);
 
-            final HttpClient httpClient = HttpClientFactory.create();
-            final HttpGet httpGet = initializeHttpGet(uri.toString());
-
             InputStream pictureInputStream = null;
             OutputStream pictureOutputStream = null;
             try {
-                final HttpResponse httpResponse = httpClient.execute(httpGet);
-                pictureInputStream = httpResponse.getEntity().getContent();
+                final HttpURLConnection urlConnection =
+                        MoPubHttpUrlConnection.getHttpUrlConnection(uriString);
+                pictureInputStream = new BufferedInputStream(urlConnection.getInputStream());
 
-                final String redirectLocation = HeaderUtils.extractHeader(httpResponse, LOCATION);
-                if (redirectLocation != null) {
+                final String redirectLocation = urlConnection.getHeaderField(LOCATION.getKey());
+                if (!TextUtils.isEmpty(redirectLocation)) {
                     uri = URI.create(redirectLocation);
                 }
 
-                final String pictureFileName = getFileNameForUriAndHttpResponse(uri, httpResponse);
+                final String pictureFileName =
+                        getFileNameForUriAndHeaders(uri, urlConnection.getHeaderFields());
                 final File pictureFile = new File(pictureStoragePath, pictureFileName);
                 pictureOutputStream = new FileOutputStream(pictureFile);
                 Streams.copyContent(pictureInputStream, pictureOutputStream);
@@ -492,7 +497,7 @@ protected Boolean doInBackground(@NonNull String[] params) {
                 loadPictureIntoGalleryApp(pictureFileFullPath);
 
                 return true;
-            } catch (IOException e) {
+            } catch (Exception e) {
                 return false;
             } finally {
                 Streams.closeStream(pictureInputStream);
@@ -509,27 +514,36 @@ protected void onPostExecute(final Boolean success) {
             }
         }
 
-        private String getFileNameForUriAndHttpResponse(final URI uri, final HttpResponse response) {
+        @Nullable
+        private String getFileNameForUriAndHeaders(@NonNull final URI uri,
+                @Nullable final Map<String, List<String>> headers) {
+            Preconditions.checkNotNull(uri);
             final String path = uri.getPath();
 
-            if (path == null) {
+            if (path == null || headers == null) {
                 return null;
             }
-
             String filename = new File(path).getName();
 
-            Header header = response.getFirstHeader(MIME_TYPE_HEADER);
-            if (header != null) {
-                String[] fields = header.getValue().split(";");
-                for (final String field : fields) {
-                    String extension;
-                    if (field.contains("image/")) {
-                        extension = "." + field.split("/")[1];
-                        if (!filename.endsWith(extension)) {
-                            filename += extension;
-                        }
-                        break;
+            final List<String> mimeTypeHeaders = headers.get(MIME_TYPE_HEADER);
+            if (mimeTypeHeaders == null || mimeTypeHeaders.isEmpty()
+                    || mimeTypeHeaders.get(0) == null) {
+                return filename;
+            }
+
+            // Capture the first MIME_TYPE_HEADER (e.g. "text/plain; image/jpeg; image/gif") and
+            // parse out supported Content-Types (e.g. {"text/plain", "image/jpeg", "image/gif"}).
+            // If any of the Content-Types are of type "image", use the extension matching the first
+            // associated content subtype: add this extension to the filename if it does not already
+            // include it.
+            final String[] fields = mimeTypeHeaders.get(0).split(";");
+            for (final String field : fields) {
+                if (field.contains("image/")) {
+                    final String extension = "." + field.split("/")[1];
+                    if (!filename.endsWith(extension)) {
+                        filename += extension;
                     }
+                    break;
                 }
             }
 
@@ -548,6 +562,12 @@ private void loadPictureIntoGalleryApp(final String filename) {
             mediaScannerConnectionClient.setMediaScannerConnection(mediaScannerConnection);
             mediaScannerConnection.connect();
         }
+
+        @VisibleForTesting
+        @Deprecated
+        DownloadImageAsyncTaskListener getListener() {
+            return mListener;
+        }
     }
 
     private static class MoPubMediaScannerConnectionClient
diff --git a/mopub-sdk/src/main/resources/fabric/com.mopub.sdk.android.mopub.properties b/mopub-sdk/src/main/resources/fabric/com.mopub.sdk.android.mopub.properties
index 75d2904a..34d02ef3 100644
--- a/mopub-sdk/src/main/resources/fabric/com.mopub.sdk.android.mopub.properties
+++ b/mopub-sdk/src/main/resources/fabric/com.mopub.sdk.android.mopub.properties
@@ -1,3 +1,3 @@
 fabric-identifier=com.mopub.sdk.android:mopub
-fabric-version=3.12.0+kit
+fabric-version=3.13.0+kit
 fabric-build-type=source
diff --git a/mopub-sdk/src/test/java/com/mopub/common/DownloadTaskTest.java b/mopub-sdk/src/test/java/com/mopub/common/DownloadTaskTest.java
deleted file mode 100644
index bbe1b484..00000000
--- a/mopub-sdk/src/test/java/com/mopub/common/DownloadTaskTest.java
+++ /dev/null
@@ -1,126 +0,0 @@
-package com.mopub.common;
-
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.ResponseHeader;
-import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
-
-import org.apache.http.client.methods.HttpGet;
-import org.apache.http.client.methods.HttpUriRequest;
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Captor;
-import org.mockito.Mock;
-import org.robolectric.Robolectric;
-import org.robolectric.tester.org.apache.http.FakeHttpLayer;
-
-import static junit.framework.Assert.fail;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-
-@RunWith(SdkTestRunner.class)
-public class DownloadTaskTest {
-
-    @Mock private DownloadTask.DownloadTaskListener mockDownloadTaskListener;
-    @Captor private ArgumentCaptor<DownloadResponse> responseCaptor;
-
-    private DownloadTask mDownloadTask;
-    private HttpGet httpGet;
-    private String mTestResponse;
-    private FakeHttpLayer mFakeHttpLayer;
-    private TestHttpResponseWithHeaders mTestHttpResponseWithHeaders;
-
-    @Before
-    public void setUp() {
-        mDownloadTask = new DownloadTask(mockDownloadTaskListener);
-        try {
-            httpGet = new HttpGet("http://www.mopub.com/");
-        } catch (IllegalArgumentException e) {
-            fail("Could not initialize HttpGet in test");
-        }
-
-        mTestResponse = "TEST RESPONSE";
-        mTestHttpResponseWithHeaders = new TestHttpResponseWithHeaders(200, mTestResponse);
-        mTestHttpResponseWithHeaders.addHeader(ResponseHeader.IMPRESSION_URL.getKey(), "moPubImpressionTrackerUrl");
-        mTestHttpResponseWithHeaders.addHeader(ResponseHeader.CLICK_TRACKING_URL.getKey(), "moPubClickTrackerUrl");
-
-        mFakeHttpLayer = Robolectric.getFakeHttpLayer();
-    }
-
-    @Test
-    public void whenDownloadTaskAndHttpClientCompleteSuccessfully_shouldReturn200HttpResponse() {
-        mFakeHttpLayer.addPendingHttpResponse(mTestHttpResponseWithHeaders);
-        mDownloadTask.execute(httpGet);
-
-        verify(mockDownloadTaskListener).onComplete(eq(httpGet.getURI().toString()), responseCaptor.capture());
-        DownloadResponse response = responseCaptor.getValue();
-        assertThat(response.getStatusCode()).isEqualTo(200);
-        assertThat(response.getFirstHeader(ResponseHeader.IMPRESSION_URL)).isEqualTo("moPubImpressionTrackerUrl");
-        assertThat(response.getFirstHeader(ResponseHeader.CLICK_TRACKING_URL)).isEqualTo("moPubClickTrackerUrl");
-        assertThat(HttpResponses.asResponseString(response)).isEqualTo(mTestResponse);
-    }
-
-    @Test
-    public void whenDownloadTaskCompletesSuccessfullyAndHttpClientTimesOut_shouldReturn599HttpResponse() {
-        mFakeHttpLayer.addPendingHttpResponse(599, "");
-        mDownloadTask.execute(httpGet);
-
-        verify(mockDownloadTaskListener).onComplete(eq(httpGet.getURI().toString()),
-                responseCaptor.capture());
-        DownloadResponse response = responseCaptor.getValue();
-        assertThat(response.getStatusCode()).isEqualTo(599);
-        assertThat(HttpResponses.asResponseString(response)).isEqualTo("");
-    }
-
-    @Test
-    public void whenDownloadTaskIsCancelledBeforeExecute_shouldNotCallOnComplete() {
-        mFakeHttpLayer.addPendingHttpResponse(200, mTestResponse);
-        mDownloadTask.cancel(true);
-        mDownloadTask.execute(httpGet);
-
-        verify(mockDownloadTaskListener, never()).onComplete(
-                any(String.class), any(DownloadResponse.class));
-    }
-
-    @Ignore("pending")
-    @Test
-    public void whenHttpUriRequestThrowsIOException_shouldCancelTaskAndReturnNullHttpResponse() {
-        // need a way to force HttpUriRequest to throw on execute
-    }
-
-    @Test
-    public void whenHttpUriRequestIsNull_shouldReturnNullHttpReponseAndNullUrl() {
-        mDownloadTask.execute((HttpUriRequest) null);
-        verify(mockDownloadTaskListener).onComplete(null, null);
-    }
-
-    @Test
-    public void whenHttpUriRequestIsNullArray_shouldReturnNullHttpReponseAndNullUrl() {
-        mDownloadTask.execute((HttpUriRequest[]) null);
-        verify(mockDownloadTaskListener).onComplete(null, null);
-    }
-
-    @Test
-    public void whenHttpUriRequestIsArray_shouldOnlyReturnFirstResponse() {
-        mFakeHttpLayer.addPendingHttpResponse(200, mTestResponse);
-        mFakeHttpLayer.addPendingHttpResponse(500, "");
-        mDownloadTask.execute(httpGet, new HttpGet("http://www.twitter.com/"));
-
-        verify(mockDownloadTaskListener).onComplete(eq(httpGet.getURI().toString()),
-                responseCaptor.capture());
-        DownloadResponse response = responseCaptor.getValue();
-
-        assertThat(response.getStatusCode()).isEqualTo(200);
-        assertThat(HttpResponses.asResponseString(response)).isEqualTo(mTestResponse);
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void constructor_withNullListener_shouldThrowIllegalArgumentException() {
-        new DownloadTask(null);
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/HttpClientTest.java b/mopub-sdk/src/test/java/com/mopub/common/MoPubHttpUrlConnectionTest.java
similarity index 51%
rename from mopub-sdk/src/test/java/com/mopub/common/HttpClientTest.java
rename to mopub-sdk/src/test/java/com/mopub/common/MoPubHttpUrlConnectionTest.java
index 497bbbbb..c961763e 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/HttpClientTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/MoPubHttpUrlConnectionTest.java
@@ -1,87 +1,77 @@
 package com.mopub.common;
 
 import android.app.Activity;
+import android.content.Context;
 import android.webkit.WebView;
 
-import com.mopub.common.util.ResponseHeader;
+import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.network.Networking;
 
 import org.apache.http.HttpRequest;
-import org.apache.http.client.methods.HttpGet;
-import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
 import org.robolectric.tester.org.apache.http.RequestMatcher;
 import org.robolectric.tester.org.apache.http.TestHttpResponse;
 
-import static com.mopub.common.HttpClient.initializeHttpGet;
-import static com.mopub.common.HttpClient.urlEncode;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.util.List;
+
+import static com.mopub.common.MoPubHttpUrlConnection.urlEncode;
 import static org.fest.assertions.api.Assertions.assertThat;
 
-@RunWith(RobolectricTestRunner.class)
-public class HttpClientTest {
-    static final String url = "http://www.mopub.com";
-    private Activity context;
+@RunWith(SdkTestRunner.class)
+public class MoPubHttpUrlConnectionTest {
+    private static final String url = "http://www.mopub.com";
     private String userAgent;
 
     @Before
-    public void setup() {
-        context = Robolectric.buildActivity(Activity.class).create().get();
+    public void setUp() throws Exception {
+        Context context = Robolectric.buildActivity(Activity.class).create().get();
         userAgent = new WebView(context).getSettings().getUserAgentString();
-
-        Robolectric.addHttpResponseRule(new RequestMatcher() {
-            @Override
-            public boolean matches(HttpRequest request) {
-                return true;
-            }
-        }, new TestHttpResponse(200, "body"));
-
-        Robolectric.getBackgroundScheduler().pause();
-        Robolectric.clearPendingHttpResponses();
-    }
-
-    @After
-    public void tearDown() throws Exception {
-        Robolectric.getBackgroundScheduler().reset();
-        Robolectric.clearPendingHttpResponses();
+        Networking.setUserAgentForTesting(userAgent);
     }
 
     @Test
-    public void initializeHttpGet_shouldReturnHttpGetWithWebViewUserAgent() throws Exception {
-        Networking.setUserAgentForTesting(null);
-        HttpGet httpGet = initializeHttpGet(url, context);
+    public void getHttpUrlConnection_shouldReturnHttpUrlConnectionWithUserAgent() throws Exception {
+        HttpURLConnection urlConnection = MoPubHttpUrlConnection.getHttpUrlConnection(url);
 
-        assertThat(httpGet.getURI().toURL().toString()).isEqualTo(url);
-        assertThat(httpGet.getFirstHeader(ResponseHeader.USER_AGENT.getKey()).getValue()).isEqualTo(
-                userAgent);
+        List<String> userAgentHeaders = urlConnection.getRequestProperties().get("User-Agent");
+        assertThat(userAgentHeaders).containsExactly(userAgent);
     }
 
     @Test
-    public void initializeHttpGet_withNullContext_shouldUseCachedUserAgent() throws Exception {
-        Networking.setUserAgentForTesting("cached");
-        HttpGet httpGet = initializeHttpGet("http://www.mopub.com/");
-        assertThat(httpGet.getFirstHeader(ResponseHeader.USER_AGENT.getKey()).getValue()).isEqualTo(
-                "cached");
+    public void getHttpUrlConnection_shouldSetConnectAndReadTimeoutTo10Seconds() throws Exception {
+        HttpURLConnection urlConnection = MoPubHttpUrlConnection.getHttpUrlConnection(url);
+
+        assertThat(urlConnection.getConnectTimeout()).isEqualTo(10000);
+        assertThat(urlConnection.getReadTimeout()).isEqualTo(10000);
     }
 
     @Test
-    public void initializeHttpGet_shouldProperlyEncodeUrl() throws Exception {
-        HttpGet httpGet = initializeHttpGet("http://host:80/doc|search?q=green robots#over 6\"");
-        assertThat(httpGet.getURI().toString())
+    public void getHttpUrlConnection_shouldProperlyEncodeUrl() throws Exception {
+        HttpURLConnection urlConnection = MoPubHttpUrlConnection.getHttpUrlConnection(
+                "http://host:80/doc|search?q=green robots#over 6\"");
+
+        assertThat(urlConnection.getURL().toString())
                 .isEqualTo("http://host:80/doc%7Csearch?q=green%20robots#over%206%22");
     }
 
     @Test(expected = IllegalArgumentException.class)
-    public void initializeHttpGet_withImproperlyEncodedUrl_shouldThrowIllegalArgumentException() throws Exception {
-        initializeHttpGet("http://user:passwrd@host:80/doc%7ZZZC");
+    public void getHttpUrlConnection_withImproperlyEncodedUrl_shouldThrowIllegalArgumentException() throws Exception {
+        MoPubHttpUrlConnection.getHttpUrlConnection("http://user:passwrd@host:80/doc%7ZZZC");
     }
 
-    @Test(expected = IllegalArgumentException.class)
-    public void initializeHttpGet_withMalformedUrl_shouldThrowIllegalArgumentException() throws Exception {
-        initializeHttpGet("bad://host:80/doc|search?q=green robots#over 6\"");
+    @Test(expected = MalformedURLException.class)
+    public void getHttpUrlConnection_withMalformedUrl_shouldThrowMalformedUrlException() throws Exception {
+        MoPubHttpUrlConnection.getHttpUrlConnection("bad://host:80/doc|search?q=green robots#over 6\"");
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void getHttpUrlConnection_withNullUrl_shouldThrowNullPointerException() throws Exception {
+        MoPubHttpUrlConnection.getHttpUrlConnection(null);
     }
 
     @Test
@@ -127,19 +117,4 @@ public void urlEncode_withImproperlyEncodedUrlScheme_shouldThowException() throw
     public void urlEncode_withMalformedUrl_shouldThrowException() throws Exception {
         urlEncode("derp://www.mopub.com/");
     }
-
-    @Test(expected = NullPointerException.class)
-    public void initializeHttpGet_withNullUrl_shouldThrowNullPointerException() throws Exception {
-        initializeHttpGet(null, context);
-    }
-
-    @Test
-    public void initializeHttpGet_withNullContext_shouldPopulateUserAgentHeaderWithCachedValue() throws Exception {
-        Networking.setUserAgentForTesting("cached");
-        HttpGet httpGet = initializeHttpGet(url, null);
-
-        assertThat(httpGet.getURI().toURL().toString()).isEqualTo(url);
-        assertThat(httpGet.getFirstHeader(ResponseHeader.USER_AGENT.getKey()).getValue()).isEqualTo(
-                "cached");
-    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/test/support/SdkTestRunner.java b/mopub-sdk/src/test/java/com/mopub/common/test/support/SdkTestRunner.java
index 7c03ac03..2fcb133e 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/test/support/SdkTestRunner.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/test/support/SdkTestRunner.java
@@ -3,12 +3,14 @@
 import com.mopub.common.CacheService;
 import com.mopub.common.ClientMetadata;
 import com.mopub.common.MoPub;
+import com.mopub.common.MoPubHttpUrlConnection;
 import com.mopub.common.event.EventDispatcher;
 import com.mopub.common.event.MoPubEvents;
 import com.mopub.common.factories.MethodBuilderFactory;
 import com.mopub.common.util.AsyncTasks;
 import com.mopub.common.util.DateAndTime;
 import com.mopub.common.util.test.support.ShadowAsyncTasks;
+import com.mopub.common.util.test.support.ShadowMoPubHttpUrlConnection;
 import com.mopub.common.util.test.support.TestDateAndTime;
 import com.mopub.common.util.test.support.TestMethodBuilderFactory;
 import com.mopub.mobileads.factories.AdViewControllerFactory;
@@ -18,11 +20,9 @@
 import com.mopub.mobileads.factories.CustomEventInterstitialFactory;
 import com.mopub.mobileads.factories.HtmlBannerWebViewFactory;
 import com.mopub.mobileads.factories.HtmlInterstitialWebViewFactory;
-import com.mopub.mobileads.factories.HttpClientFactory;
 import com.mopub.mobileads.factories.MoPubViewFactory;
 import com.mopub.mobileads.factories.MraidControllerFactory;
 import com.mopub.mobileads.factories.VastManagerFactory;
-import com.mopub.mobileads.factories.VastVideoDownloadTaskFactory;
 import com.mopub.mobileads.test.support.TestAdViewControllerFactory;
 import com.mopub.mobileads.test.support.TestCustomEventBannerAdapterFactory;
 import com.mopub.mobileads.test.support.TestCustomEventBannerFactory;
@@ -30,18 +30,15 @@
 import com.mopub.mobileads.test.support.TestCustomEventInterstitialFactory;
 import com.mopub.mobileads.test.support.TestHtmlBannerWebViewFactory;
 import com.mopub.mobileads.test.support.TestHtmlInterstitialWebViewFactory;
-import com.mopub.mobileads.test.support.TestHttpClientFactory;
 import com.mopub.mobileads.test.support.TestMoPubViewFactory;
 import com.mopub.mobileads.test.support.TestMraidControllerFactory;
 import com.mopub.mobileads.test.support.TestVastManagerFactory;
-import com.mopub.mobileads.test.support.TestVastVideoDownloadTaskFactory;
 import com.mopub.nativeads.factories.CustomEventNativeFactory;
 import com.mopub.nativeads.test.support.TestCustomEventNativeFactory;
 
 import org.junit.runners.model.InitializationError;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.DefaultTestLifecycle;
-import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.TestLifecycle;
 import org.robolectric.bytecode.ClassInfo;
@@ -63,6 +60,7 @@ public Setup createSetup() {
             @Override
             public boolean shouldInstrument(ClassInfo classInfo) {
                 return classInfo.getName().equals(AsyncTasks.class.getName())
+                        || classInfo.getName().equals(MoPubHttpUrlConnection.class.getName())
                         || super.shouldInstrument(classInfo);
             }
         };
@@ -78,7 +76,6 @@ public boolean shouldInstrument(ClassInfo classInfo) {
         public void prepareTest(Object test) {
             ClientMetadata.clearForTesting();
 
-            HttpClientFactory.setInstance(new TestHttpClientFactory());
             DateAndTime.setInstance(new TestDateAndTime());
             CustomEventBannerFactory.setInstance(new TestCustomEventBannerFactory());
             CustomEventInterstitialFactory.setInstance(new TestCustomEventInterstitialFactory());
@@ -89,12 +86,12 @@ public void prepareTest(Object test) {
             HtmlInterstitialWebViewFactory.setInstance(new TestHtmlInterstitialWebViewFactory());
             AdViewControllerFactory.setInstance(new TestAdViewControllerFactory());
             VastManagerFactory.setInstance(new TestVastManagerFactory());
-            VastVideoDownloadTaskFactory.setInstance(new TestVastVideoDownloadTaskFactory());
             MethodBuilderFactory.setInstance(new TestMethodBuilderFactory());
             CustomEventNativeFactory.setInstance(new TestCustomEventNativeFactory());
             MraidControllerFactory.setInstance(new TestMraidControllerFactory());
 
             ShadowAsyncTasks.reset();
+            ShadowMoPubHttpUrlConnection.reset();
             MoPubEvents.setEventDispatcher(mock(EventDispatcher.class));
             MoPub.setLocationAwareness(LocationAwareness.NORMAL);
             MoPub.setLocationPrecision(6);
@@ -103,7 +100,6 @@ public void prepareTest(Object test) {
 
             AsyncTasks.setExecutor(new RobolectricBackgroundExecutorService());
             CacheService.clearAndNullCaches();
-            Robolectric.getFakeHttpLayer().clearPendingHttpResponses();
         }
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/test/support/ShadowMoPubHttpUrlConnection.java b/mopub-sdk/src/test/java/com/mopub/common/util/test/support/ShadowMoPubHttpUrlConnection.java
new file mode 100644
index 00000000..7ae73832
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/test/support/ShadowMoPubHttpUrlConnection.java
@@ -0,0 +1,79 @@
+package com.mopub.common.util.test.support;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.MoPubHttpUrlConnection;
+
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.util.ArrayDeque;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Queue;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+@Implements(MoPubHttpUrlConnection.class)
+public abstract class ShadowMoPubHttpUrlConnection extends HttpURLConnection {
+    private static String sLatestRequestUrl;
+    private static final Queue<HttpURLConnection> sPendingUrlConnections =
+            new ArrayDeque<HttpURLConnection>();
+
+    private ShadowMoPubHttpUrlConnection(URL url) {
+        super(url);
+    }
+
+    public static void reset() {
+        sPendingUrlConnections.clear();
+    }
+
+    @Implementation
+    @Nullable
+    public static HttpURLConnection getHttpUrlConnection(@NonNull final String url)
+            throws IOException {
+        sLatestRequestUrl = url;
+
+        return sPendingUrlConnections.poll();
+    }
+
+    public static void addPendingResponse(final int statusCode, @NonNull final String response)
+            throws IOException {
+        addPendingResponse(statusCode, response, new HashMap<String, List<String>>());
+    }
+
+    public static void addPendingResponse(final int statusCode, @NonNull final String response,
+            @NonNull final Map<String, List<String>> headers) throws IOException {
+        final byte[] bytes = response.getBytes();
+        HttpURLConnection mockUrlConnection = mock(HttpURLConnection.class);
+
+        when(mockUrlConnection.getInputStream()).thenReturn(
+                new ByteArrayInputStream(bytes));
+        when(mockUrlConnection.getContentLength()).thenReturn(bytes.length);
+        when(mockUrlConnection.getResponseCode()).thenReturn(statusCode);
+        when(mockUrlConnection.getHeaderFields()).thenReturn(headers);
+
+        for (final Map.Entry<String, List<String>> entry : headers.entrySet()) {
+            when(mockUrlConnection.getHeaderField(entry.getKey())).thenReturn(entry.getValue().get(0));
+        }
+
+        sPendingUrlConnections.add(mockUrlConnection);
+    }
+
+    @NonNull
+    public static Queue getPendingUrlConnections() {
+        return sPendingUrlConnections;
+    }
+
+    @Nullable
+    public static String getLatestRequestUrl() {
+        return sLatestRequestUrl;
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastManagerTest.java
index 357e0ec7..9b653256 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastManagerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastManagerTest.java
@@ -5,15 +5,17 @@
 import com.mopub.common.CacheService;
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.common.util.DeviceUtils;
+import com.mopub.common.util.test.support.ShadowMoPubHttpUrlConnection;
 import com.mopub.mobileads.test.support.VastUtils;
 
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
-import org.robolectric.tester.org.apache.http.FakeHttpLayer;
+import org.robolectric.annotation.Config;
 
 import java.util.concurrent.Semaphore;
 
@@ -24,6 +26,7 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 
+@Config(shadows = {ShadowMoPubHttpUrlConnection.class})
 @RunWith(SdkTestRunner.class)
 public class VastManagerTest {
     static final String EXTENSIONS_SNIPPET_PLACEHOLDER = "<![CDATA[EXTENSIONS_SNIPPET]]>";
@@ -32,7 +35,6 @@
     static final String TEST_VAST_BAD_NEST_URL_XML_STRING = "<VAST version='2.0'><Ad id='62833'><Wrapper><AdSystem>Tapad</AdSystem><VASTAdTagURI>http://dsp.x-team.staging.mopub.com/xml\"$|||</VASTAdTagURI><Impression>http://myTrackingURL/wrapper/impression1</Impression><Impression>http://myTrackingURL/wrapper/impression2</Impression><Creatives><Creative AdID='62833'><Linear><TrackingEvents><Tracking event='creativeView'>http://myTrackingURL/wrapper/creativeView</Tracking><Tracking event='start'>http://myTrackingURL/wrapper/start</Tracking><Tracking event='midpoint'>http://myTrackingURL/wrapper/midpoint</Tracking><Tracking event='firstQuartile'>http://myTrackingURL/wrapper/firstQuartile</Tracking><Tracking event='thirdQuartile'>http://myTrackingURL/wrapper/thirdQuartile</Tracking><Tracking event='complete'>http://myTrackingURL/wrapper/complete</Tracking><Tracking event='mute'>http://myTrackingURL/wrapper/mute</Tracking><Tracking event='unmute'>http://myTrackingURL/wrapper/unmute</Tracking><Tracking event='pause'>http://myTrackingURL/wrapper/pause</Tracking><Tracking event='resume'>http://myTrackingURL/wrapper/resume</Tracking><Tracking event='fullscreen'>http://myTrackingURL/wrapper/fullscreen</Tracking></TrackingEvents><VideoClicks><ClickTracking>http://myTrackingURL/wrapper/click</ClickTracking></VideoClicks></Linear></Creative></Creatives></Wrapper></Ad></VAST><MP_TRACKING_URLS><MP_TRACKING_URL>http://www.mopub.com/imp1</MP_TRACKING_URL><MP_TRACKING_URL>http://www.mopub.com/imp2</MP_TRACKING_URL></MP_TRACKING_URLS>";
 
     private VastManager subject;
-    private FakeHttpLayer mFakeHttpLayer;
     private VastManagerListener vastManagerListener;
     private Activity context;
     private VastVideoConfig mVastVideoConfig;
@@ -43,7 +45,6 @@ public void setup() {
         context = Robolectric.buildActivity(Activity.class).create().get();
         CacheService.initializeDiskCache(context);
         subject = new VastManager(context);
-        mFakeHttpLayer = Robolectric.getFakeHttpLayer();
 
         semaphore = new Semaphore(0);
         vastManagerListener = mock(VastManagerListener.class);
@@ -58,6 +59,11 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
         }).when(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfig.class));
     }
 
+    @After
+    public void tearDown() {
+        CacheService.clearAndNullCaches();
+    }
+
     private void prepareVastVideoConfiguration() {
         subject.prepareVastVideoConfiguration(TEST_VAST_XML_STRING, vastManagerListener, context);
 
@@ -68,9 +74,9 @@ private void prepareVastVideoConfiguration() {
     @Test
     public void prepareVastVideoConfiguration_shouldNotifyTheListenerAndContainTheCorrectVastValues() throws Exception {
         // Vast redirect responses
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, TEST_NESTED_VAST_XML_STRING);
         // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, "video_data");
 
         prepareVastVideoConfiguration();
         semaphore.acquire();
@@ -127,11 +133,11 @@ public void prepareVastVideoConfiguration_shouldNotifyTheListenerAndContainTheCo
     @Test
     public void prepareVastVideoConfiguration_shouldHandleMultipleRedirects() throws Exception {
         // Vast redirect responses
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_VAST_XML_STRING);
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_VAST_XML_STRING);
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, TEST_VAST_XML_STRING);
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, TEST_VAST_XML_STRING);
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, TEST_NESTED_VAST_XML_STRING);
         // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, "video_data");
 
         prepareVastVideoConfiguration();
         semaphore.acquire();
@@ -194,9 +200,9 @@ public void prepareVastVideoConfiguration_shouldHandleMultipleRedirects() throws
     @Test
     public void prepareVastVideoConfiguration_shouldReturnCorrectVastValuesWhenAVastRedirectFails() throws Exception {
         // Vast redirect response
-        mFakeHttpLayer.addPendingHttpResponse(404, "");
+        ShadowMoPubHttpUrlConnection.addPendingResponse(404, "");
         // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, "video_data");
 
         prepareVastVideoConfiguration();
         semaphore.acquire();
@@ -208,9 +214,9 @@ public void prepareVastVideoConfiguration_shouldReturnCorrectVastValuesWhenAVast
     @Test
     public void prepareVastVideoConfiguration_withNoExtensions_shouldContainTheCorrectDefaultExtensionValues() throws Exception {
         // Vast redirect response to XML without VAST extensions
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, TEST_NESTED_VAST_XML_STRING);
         // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, "video_data");
 
         prepareVastVideoConfiguration();
         semaphore.acquire();
@@ -225,9 +231,9 @@ public void prepareVastVideoConfiguration_withNoExtensions_shouldContainTheCorre
     @Test
     public void prepareVastVideoConfiguration_withExtensionsUnderWrapper_shouldContainTheCorrectCustomExtensionValues() throws Exception {
         // Vast redirect response to XML without extensions
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, TEST_NESTED_VAST_XML_STRING);
         // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, "video_data");
 
         // Add extensions under Wrapper element in TEST_VAST_XML_STRING
         subject.prepareVastVideoConfiguration(
@@ -258,18 +264,18 @@ public void prepareVastVideoConfiguration_withExtensionsUnderWrapper_shouldConta
     @Test
     public void prepareVastVideoConfiguration_withExtensionsUnderInline_shouldContainTheCorrectCustomExtensionValues() throws Exception {
         // Vast redirect response to XML with extensions under Inline element
-        mFakeHttpLayer.addPendingHttpResponse(200,
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200,
                 TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
                         "<Extensions>" +
-                            "<Extension type=\"MoPub\">" +
+                                "<Extension type=\"MoPub\">" +
                                 "<MoPubCtaText>custom CTA text</MoPubCtaText>" +
                                 "<MoPubSkipText>skip</MoPubSkipText>" +
                                 "<MoPubCloseIcon>http://ton.twitter.com/exchange-media/images/v4/star_icon_3x.png</MoPubCloseIcon>" +
                                 "<MoPubForceOrientation>device</MoPubForceOrientation>" +
-                            "</Extension>" +
-                        "</Extensions>"));
+                                "</Extension>" +
+                                "</Extensions>"));
         // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, "video_data");
 
         prepareVastVideoConfiguration();
         semaphore.acquire();
@@ -286,18 +292,18 @@ public void prepareVastVideoConfiguration_withExtensionsUnderInline_shouldContai
     @Test
     public void prepareVastVideoConfiguration_withExtensionsUnderBothWrapperAndInline_shouldContainLastParsedCustomExtensionValues() throws Exception {
         // Vast redirect response to XML with extensions under Inline element in TEST_NESTED_VAST_XML_STRING, will be parsed last
-        mFakeHttpLayer.addPendingHttpResponse(200,
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200,
                 TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
                         "<Extensions>" +
-                            "<Extension type=\"MoPub\">" +
+                                "<Extension type=\"MoPub\">" +
                                 "<MoPubCtaText>CTA 2</MoPubCtaText>" +
                                 "<MoPubSkipText>skip 2</MoPubSkipText>" +
                                 "<MoPubCloseIcon>http://ton.twitter.com/exchange-media/images/v4/star_icon_3x_2.png</MoPubCloseIcon>" +
                                 "<MoPubForceOrientation>landscape</MoPubForceOrientation>" +
-                            "</Extension>" +
-                        "</Extensions>"));
+                                "</Extension>" +
+                                "</Extensions>"));
         // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, "video_data");
 
         // Also add extensions under Wrapper element in TEST_VAST_XML_STRING
         subject.prepareVastVideoConfiguration(
@@ -329,15 +335,15 @@ public void prepareVastVideoConfiguration_withExtensionsUnderBothWrapperAndInlin
     @Test
     public void prepareVastVideoConfiguration_withCustomCtaTextAsSingleSpace_shouldReturnEmptyString() throws Exception {
         // Vast redirect response
-        mFakeHttpLayer.addPendingHttpResponse(200,
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200,
                 TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
                         "<Extensions>" +
-                            "<Extension type=\"MoPub\">" +
+                                "<Extension type=\"MoPub\">" +
                                 "<MoPubCtaText> </MoPubCtaText>" +     // single space, i.e. no text
-                            "</Extension>" +
-                        "</Extensions>"));
+                                "</Extension>" +
+                                "</Extensions>"));
         // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, "video_data");
 
         prepareVastVideoConfiguration();
         semaphore.acquire();
@@ -349,15 +355,15 @@ public void prepareVastVideoConfiguration_withCustomCtaTextAsSingleSpace_shouldR
     @Test
     public void prepareVastVideoConfiguration_withCustomCtaTextLongerThan15Chars_shouldReturnNull() throws Exception {
         // Vast redirect response
-        mFakeHttpLayer.addPendingHttpResponse(200,
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200,
                 TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
                         "<Extensions>" +
-                            "<Extension type=\"MoPub\">" +
+                                "<Extension type=\"MoPub\">" +
                                 "<MoPubCtaText>1234567890123456</MoPubCtaText>" +     // 16 chars
-                            "</Extension>" +
-                        "</Extensions>"));
+                                "</Extension>" +
+                                "</Extensions>"));
         // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, "video_data");
 
         prepareVastVideoConfiguration();
         semaphore.acquire();
@@ -369,15 +375,15 @@ public void prepareVastVideoConfiguration_withCustomCtaTextLongerThan15Chars_sho
     @Test
     public void prepareVastVideoConfiguration_withCustomSkipTextLongerThan8Chars_shouldReturnNull() throws Exception {
         // Vast redirect response
-        mFakeHttpLayer.addPendingHttpResponse(200,
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200,
                 TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
                         "<Extensions>" +
-                            "<Extension type=\"MoPub\">" +
+                                "<Extension type=\"MoPub\">" +
                                 "<MoPubSkipText>123456789</MoPubSkipText>" +     // 9 chars
-                            "</Extension>" +
-                        "</Extensions>"));
+                                "</Extension>" +
+                                "</Extensions>"));
         // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, "video_data");
 
         prepareVastVideoConfiguration();
         semaphore.acquire();
@@ -389,15 +395,15 @@ public void prepareVastVideoConfiguration_withCustomSkipTextLongerThan8Chars_sho
     @Test
     public void prepareVastVideoConfiguration_withInvalidCustomForceOrientation_shouldReturnDefaultForceLandscapeOrientation() throws Exception {
         // Vast redirect response
-        mFakeHttpLayer.addPendingHttpResponse(200,
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200,
                 TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
                         "<Extensions>" +
-                            "<Extension type=\"MoPub\">" +
+                                "<Extension type=\"MoPub\">" +
                                 "<MoPubForceOrientation>abcd</MoPubForceOrientation>" +   // invalid value
-                            "</Extension>" +
-                        "</Extensions>"));
+                                "</Extension>" +
+                                "</Extensions>"));
         // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, "video_data");
 
         prepareVastVideoConfiguration();
         semaphore.acquire();
@@ -409,15 +415,15 @@ public void prepareVastVideoConfiguration_withInvalidCustomForceOrientation_shou
     @Test
     public void prepareVastVideoConfiguration_withCustomForceOrientationInMixedCaseAndUntrimmed_shouldReturnCustomForceOrientation() throws Exception {
         // Vast redirect response
-        mFakeHttpLayer.addPendingHttpResponse(200,
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200,
                 TEST_NESTED_VAST_XML_STRING.replace(EXTENSIONS_SNIPPET_PLACEHOLDER,
                         "<Extensions>" +
-                            "<Extension type=\"MoPub\">" +
+                                "<Extension type=\"MoPub\">" +
                                 "<MoPubForceOrientation> PortRAIT  </MoPubForceOrientation>" +
-                            "</Extension>" +
-                        "</Extensions>"));
+                                "</Extension>" +
+                                "</Extensions>"));
         // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, "video_data");
 
         prepareVastVideoConfiguration();
         semaphore.acquire();
@@ -429,9 +435,9 @@ public void prepareVastVideoConfiguration_withCustomForceOrientationInMixedCaseA
     @Test
     public void prepareVastVideoConfiguration_withValidPercentSkipOffset_shouldReturnCorrectValue() throws Exception {
         // Vast redirect response
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset='25%'>"));
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset='25%'>"));
         // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, "video_data");
 
         prepareVastVideoConfiguration();
         semaphore.acquire();
@@ -445,9 +451,9 @@ public void prepareVastVideoConfiguration_withValidPercentSkipOffset_shouldRetur
     @Test
     public void prepareVastVideoConfiguration_withValidAbsoluteSkipOffset_shouldReturnCorrectValue() throws Exception {
         // Vast redirect response
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset='  00:03:14 '>"));
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset='  00:03:14 '>"));
         // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, "video_data");
 
         prepareVastVideoConfiguration();
         semaphore.acquire();
@@ -460,9 +466,9 @@ public void prepareVastVideoConfiguration_withValidAbsoluteSkipOffset_shouldRetu
     @Test
     public void prepareVastVideoConfiguration_withValidAbsoluteSkipOffsetWithExtraSpace_shouldReturnCorrectTrimmedValue() throws Exception {
         // Vast redirect response
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset='  00:03:14.159 '>"));
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset='  00:03:14.159 '>"));
         // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, "video_data");
 
         prepareVastVideoConfiguration();
         semaphore.acquire();
@@ -475,9 +481,9 @@ public void prepareVastVideoConfiguration_withValidAbsoluteSkipOffsetWithExtraSp
     @Test
     public void prepareVastVideoConfiguration_withSkipOffsets_shouldReturnLastParsedValue() throws Exception {
         // Vast redirect response with skipoffset in percent format
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset='25%'>"));
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset='25%'>"));
         // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, "video_data");
 
         // Also add a skipoffset in absolute format
         subject.prepareVastVideoConfiguration(
@@ -498,9 +504,9 @@ public void prepareVastVideoConfiguration_withSkipOffsets_shouldReturnLastParsed
     @Test
     public void prepareVastVideoConfiguration_withEmptySkipOffset_shouldReturnNull() throws Exception {
         // Vast redirect response
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset=' '>"));
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, TEST_NESTED_VAST_XML_STRING.replace("<Linear>", "<Linear skipoffset=' '>"));
         // Video download response
-        mFakeHttpLayer.addPendingHttpResponse(200, "video_data");
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, "video_data");
 
         prepareVastVideoConfiguration();
         semaphore.acquire();
@@ -549,14 +555,14 @@ public void prepareVastVideoConfiguration_withEmptyXml_shouldReturnNull() throws
 
     @Test
     public void prepareVastVideoConfiguration_withVideoInDiskCache_shouldNotDownloadVideo() throws Exception {
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, TEST_NESTED_VAST_XML_STRING);
 
         CacheService.putToDiskCache("https://s3.amazonaws.com/mopub-vast/tapad-video.mp4", "video_data".getBytes());
 
         prepareVastVideoConfiguration();
         semaphore.acquire();
 
-        assertThat(mFakeHttpLayer.getSentHttpRequestInfos().size()).isEqualTo(1);
+        assertThat(ShadowMoPubHttpUrlConnection.getLatestRequestUrl()).isNotNull();
         verify(vastManagerListener).onVastVideoConfigurationPrepared(any(VastVideoConfig.class));
         assertThat(mVastVideoConfig.getDiskMediaFileUrl())
                 .isEqualTo(CacheService.getFilePathDiskCache("https://s3.amazonaws.com/mopub-vast/tapad-video.mp4"));
@@ -564,7 +570,8 @@ public void prepareVastVideoConfiguration_withVideoInDiskCache_shouldNotDownload
 
     @Test
     public void prepareVastVideoConfiguration_withUninitializedDiskCache_shouldReturnNull() throws Exception {
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
+        CacheService.clearAndNullCaches();
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, TEST_NESTED_VAST_XML_STRING);
 
         prepareVastVideoConfiguration();
         semaphore.acquire();
@@ -575,7 +582,7 @@ public void prepareVastVideoConfiguration_withUninitializedDiskCache_shouldRetur
 
     @Test
     public void cancel_shouldCancelBackgroundProcessingAndNotNotifyListenerWithNull() throws Exception {
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, TEST_NESTED_VAST_XML_STRING);
 
         Robolectric.getBackgroundScheduler().pause();
 
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoDownloadTaskTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoDownloadTaskTest.java
deleted file mode 100644
index 9fdafe8d..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoDownloadTaskTest.java
+++ /dev/null
@@ -1,142 +0,0 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-
-import com.mopub.common.CacheService;
-import com.mopub.common.CacheServiceTest;
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.Robolectric;
-import org.robolectric.tester.org.apache.http.TestHttpResponse;
-
-import java.util.Random;
-import java.util.concurrent.Semaphore;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.anyBoolean;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
-@RunWith(SdkTestRunner.class)
-public class VastVideoDownloadTaskTest {
-    private VastVideoDownloadTask.VastVideoDownloadTaskListener mVastVideoDownloadTaskListener;
-    private VastVideoDownloadTask subject;
-    private String videoUrl;
-    private TestHttpResponseWithHeaders response;
-    private Semaphore semaphore;
-
-    @Before
-    public void setUp() throws Exception {
-        Activity context = new Activity();
-        CacheService.initializeDiskCache(context);
-
-        videoUrl = "http://www.video.com";
-        response = new TestHttpResponseWithHeaders(200, "responseBody");
-        Robolectric.addPendingHttpResponse(response);
-
-        semaphore = new Semaphore(0);
-        mVastVideoDownloadTaskListener = mock(VastVideoDownloadTask.VastVideoDownloadTaskListener.class);
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                semaphore.release();
-                return null;
-            }
-        }).when(mVastVideoDownloadTaskListener).onComplete(anyBoolean());
-
-        subject = new VastVideoDownloadTask(mVastVideoDownloadTaskListener);
-    }
-
-    @Test
-    public void execute_shouldAddToCacheAndSignalDownloadSuccess() throws Exception {
-        subject.execute(videoUrl);
-
-        semaphore.acquire();
-        verify(mVastVideoDownloadTaskListener).onComplete(true);
-
-        final byte[] data = CacheService.getFromDiskCache(videoUrl);
-        assertThat(data).isEqualTo("responseBody".getBytes());
-    }
-
-    @Test
-    public void execute_withMultipleUrls_shouldParseTheFirstOne() throws Exception {
-        String ignoredUrl = "ignored";
-        subject.execute(videoUrl, ignoredUrl);
-
-        semaphore.acquire();
-        verify(mVastVideoDownloadTaskListener).onComplete(true);
-
-        assertThat(CacheService.getFromDiskCache(videoUrl)).isEqualTo("responseBody".getBytes());
-        assertThat(CacheService.getFromDiskCache(ignoredUrl)).isNull();
-    }
-
-    @Test
-    public void execute_whenUrlArrayIsNull_shouldSignalDownloadFailed() throws Exception {
-        subject.execute((String) null);
-
-        semaphore.acquire();
-        verify(mVastVideoDownloadTaskListener).onComplete(false);
-    }
-
-    @Test
-    public void execute_whenUrlArrayIsEmpty_shouldSignalDownloadFailed() throws Exception {
-        subject.execute(new String[0]);
-
-        semaphore.acquire();
-        verify(mVastVideoDownloadTaskListener).onComplete(false);
-    }
-
-    @Test
-    public void execute_whenFirstElementOfUrlArrayIsNull_shouldSignalDownloadFailed() throws Exception {
-        subject.execute(null, "ignored");
-
-        semaphore.acquire();
-        verify(mVastVideoDownloadTaskListener).onComplete(false);
-    }
-
-    @Test
-    public void execute_whenDiskCacheIsNotInitialized_shouldNotPutDataInCacheAndShouldSignalDownloadFailed() throws Exception {
-        CacheService.clearAndNullCaches();
-        CacheServiceTest.assertDiskCacheIsUninitialized();
-        subject.execute(videoUrl);
-
-        semaphore.acquire();
-        CacheServiceTest.assertDiskCacheIsUninitialized();
-        verify(mVastVideoDownloadTaskListener).onComplete(false);
-    }
-
-    @Test
-    public void execute_whenResponseContentLengthIsLargerThan25MiB_shouldNotPutDataInCacheAndShouldSignalDownloadFailed() throws Exception {
-        Robolectric.clearPendingHttpResponses();
-        final String randomString = createRandomString(25 * 1024 * 1024 + 1);
-        Robolectric.addPendingHttpResponse(new TestHttpResponse(200, randomString));
-        subject.execute(videoUrl);
-
-        semaphore.acquire();
-        CacheServiceTest.assertDiskCacheIsEmpty();
-        verify(mVastVideoDownloadTaskListener).onComplete(false);
-    }
-
-    @Test
-    public void onPostExecute_whenOnDownloadCompleteListenerIsNull_shouldNotBlowUp() throws Exception {
-        subject = new VastVideoDownloadTask(null);
-
-        subject.onPostExecute(true);
-        subject.onPostExecute(false);
-
-        // pass
-    }
-
-    private static String createRandomString(int size) {
-        byte[] buffer = new byte[size];
-        new Random().nextBytes(buffer);
-        return new String(buffer);
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoInterstitialTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoInterstitialTest.java
index 4a17ff8c..2ea08001 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoInterstitialTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoInterstitialTest.java
@@ -9,7 +9,6 @@
 import com.mopub.common.test.support.SdkTestRunner;
 import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
 import com.mopub.mobileads.test.support.TestVastManagerFactory;
-import com.mopub.mobileads.test.support.TestVastVideoDownloadTaskFactory;
 import com.mopub.mobileads.test.support.VastUtils;
 
 import org.junit.After;
@@ -51,14 +50,12 @@
     private String expectedResponse;
     private VastManager vastManager;
     private String videoUrl;
-    private VastVideoDownloadTask vastVideoDownloadTask;
     private long broadcastIdentifier;
 
     @Before
     public void setUp() throws Exception {
         subject = new VastVideoInterstitial();
 
-        vastVideoDownloadTask = TestVastVideoDownloadTaskFactory.getSingletonMock();
         vastManager = TestVastManagerFactory.getSingletonMock();
         expectedResponse = "<VAST>hello</VAST>";
         videoUrl = "http://www.video.com";
@@ -75,11 +72,6 @@ public void setUp() throws Exception {
         localExtras.put(BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
     }
 
-    @After
-    public void tearDown() throws Exception {
-        reset(vastVideoDownloadTask);
-    }
-
     @Test
     public void preRenderHtml_whenCreatingVideoCache_butItHasInitializationErrors_shouldSignalOnInterstitialFailedOnError() throws Exception {
         // context is null when loadInterstitial is not called, which causes DiskLruCache to not be created
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewControllerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewControllerTest.java
index 773e6e1b..ca2435c6 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewControllerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewControllerTest.java
@@ -2179,25 +2179,4 @@ private void setVideoViewParams(int currentPosition, int duration) throws Illega
     private ShadowVastVideoView getShadowVideoView() {
         return (ShadowVastVideoView) shadowOf_(subject.getVastVideoView());
     }
-
-    public static void assertHttpRequestsMade(final String userAgent, final String... urls) {
-        final int numberOfReceivedHttpRequests = Robolectric.getFakeHttpLayer().getSentHttpRequestInfos().size();
-        assertThat(numberOfReceivedHttpRequests).isEqualTo(urls.length);
-
-        for (final String url : urls) {
-            assertThat(Robolectric.httpRequestWasMade(url)).isTrue();
-        }
-
-        if (userAgent != null) {
-            while (true) {
-                final HttpRequest httpRequest = Robolectric.getNextSentHttpRequest();
-                if (httpRequest == null) {
-                    break;
-                }
-
-                assertThat(httpRequest.getFirstHeader(USER_AGENT.getKey()).getValue())
-                        .isEqualTo(userAgent);
-            }
-        }
-    }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastXmlManagerAggregatorTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastXmlManagerAggregatorTest.java
index e74a94cc..46f1bc31 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastXmlManagerAggregatorTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastXmlManagerAggregatorTest.java
@@ -7,8 +7,8 @@
 import android.view.Display;
 import android.view.WindowManager;
 
-import com.mopub.common.HttpClient;
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.test.support.ShadowMoPubHttpUrlConnection;
 import com.mopub.mobileads.test.support.VastUtils;
 import com.mopub.network.MoPubRequestQueue;
 import com.mopub.network.Networking;
@@ -20,7 +20,7 @@
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
-import org.robolectric.tester.org.apache.http.FakeHttpLayer;
+import org.robolectric.annotation.Config;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -38,6 +38,7 @@
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.Mockito.when;
 
+@Config(shadows = {ShadowMoPubHttpUrlConnection.class})
 @RunWith(SdkTestRunner.class)
 public class VastXmlManagerAggregatorTest {
     static final String TEST_VAST_XML_STRING = "<VAST version='2.0'>" +
@@ -267,7 +268,6 @@
             "</VAST>";
 
     private Activity context;
-    private FakeHttpLayer mFakeHttpLayer;
     private Semaphore semaphore;
     private VastXmlManagerAggregatorListener vastXmlManagerAggregatorListener;
     private VastXmlManagerAggregator subject;
@@ -279,7 +279,6 @@
     @Before
     public void setup() {
         context = Robolectric.buildActivity(Activity.class).create().get();
-        mFakeHttpLayer = Robolectric.getFakeHttpLayer();
 
         Networking.setRequestQueueForTesting(mockRequestQueue);
 
@@ -309,10 +308,10 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
 
     @Test
     public void doInBackground_shouldNotFollowRedirectsOnceTheLimitHasBeenReached() throws Exception {
-        for(int i = 0; i < VastXmlManagerAggregator.MAX_TIMES_TO_FOLLOW_VAST_REDIRECT; i++) {
-            mFakeHttpLayer.addPendingHttpResponse(200, TEST_VAST_XML_STRING);
+        for (int i = 0; i < VastXmlManagerAggregator.MAX_TIMES_TO_FOLLOW_VAST_REDIRECT; i++) {
+            ShadowMoPubHttpUrlConnection.addPendingResponse(200, TEST_VAST_XML_STRING);
         }
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, TEST_NESTED_VAST_XML_STRING);
 
         subject.execute(TEST_VAST_XML_STRING);
         semaphore.acquire();
@@ -322,10 +321,10 @@ public void doInBackground_shouldNotFollowRedirectsOnceTheLimitHasBeenReached()
 
     @Test
     public void doInBackground_shouldFollowMaxRedirectsMinusOne() throws Exception {
-        for(int i = 0; i < VastXmlManagerAggregator.MAX_TIMES_TO_FOLLOW_VAST_REDIRECT - 1; i++) {
-            mFakeHttpLayer.addPendingHttpResponse(200, TEST_VAST_XML_STRING);
+        for (int i = 0; i < VastXmlManagerAggregator.MAX_TIMES_TO_FOLLOW_VAST_REDIRECT - 1; i++) {
+            ShadowMoPubHttpUrlConnection.addPendingResponse(200, TEST_VAST_XML_STRING);
         }
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, TEST_NESTED_VAST_XML_STRING);
 
         subject.execute(TEST_VAST_XML_STRING);
         semaphore.acquire();
@@ -919,7 +918,7 @@ public void getBestIcon_withInvalidStaticResource_withValidHtmlResource_shouldRe
     @Test
     public void evaluateVastXmlManager_withStandardInline_shouldReturnValidVastVideoConfiguration() {
         VastVideoConfig vastVideoConfig = subject.evaluateVastXmlManager(
-                TEST_NESTED_VAST_XML_STRING, HttpClient.getHttpClient(), new ArrayList<VastTracker>());
+                TEST_NESTED_VAST_XML_STRING, new ArrayList<VastTracker>());
 
         assertThat(VastUtils.vastTrackersToStrings(vastVideoConfig.getImpressionTrackers()))
                 .containsOnly("http://rtb-test.dev.tapad.com:8080/creative/imp" +
@@ -981,10 +980,10 @@ public void evaluateVastXmlManager_withStandardInline_shouldReturnValidVastVideo
     }
 
     @Test
-    public void evaluateVastXmlManager_withAWrapperToAnInline_shouldReturnValidVastVideoConfiguration() {
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_VAST_XML_STRING);
+    public void evaluateVastXmlManager_withAWrapperToAnInline_shouldReturnValidVastVideoConfiguration() throws Exception {
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, TEST_NESTED_VAST_XML_STRING);
         VastVideoConfig vastVideoConfig = subject.evaluateVastXmlManager(
-                TEST_VAST_XML_STRING, HttpClient.getHttpClient(), new ArrayList<VastTracker>());
+                TEST_VAST_XML_STRING, new ArrayList<VastTracker>());
 
         assertThat(VastUtils.vastTrackersToStrings(vastVideoConfig.getImpressionTrackers()))
                 .containsOnly(
@@ -1087,17 +1086,17 @@ public void evaluateVastXmlManager_withAWrapperToAnInline_shouldReturnValidVastV
     @Test
     public void evaluateVastXmlManager_withInvalidXml_shouldReturnNullVastVideoConfiguration() {
         VastVideoConfig vastVideoConfig = subject.evaluateVastXmlManager(
-                TEST_VAST_BAD_NEST_URL_XML_STRING, HttpClient.getHttpClient(),
+                TEST_VAST_BAD_NEST_URL_XML_STRING,
                 new ArrayList<VastTracker>());
 
         assertThat(vastVideoConfig).isNull();
     }
 
     @Test
-    public void evaluateVastXmlManager_withRedirectHavingNoCompanionAd_shouldReturnVastVideoConfigurationWithCompanionAdOfWrapper() {
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_NESTED_NO_COMPANION_VAST_XML_STRING);
+    public void evaluateVastXmlManager_withRedirectHavingNoCompanionAd_shouldReturnVastVideoConfigurationWithCompanionAdOfWrapper() throws Exception {
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, TEST_NESTED_NO_COMPANION_VAST_XML_STRING);
         VastVideoConfig vastVideoConfig = subject.evaluateVastXmlManager(
-                TEST_VAST_XML_STRING, HttpClient.getHttpClient(), new ArrayList<VastTracker>());
+                TEST_VAST_XML_STRING, new ArrayList<VastTracker>());
 
         VastCompanionAdConfig[] companionAds = new VastCompanionAdConfig[2];
         companionAds[0] = vastVideoConfig.getVastCompanionAd(
@@ -1122,7 +1121,7 @@ public void evaluateVastXmlManager_withRedirectHavingNoCompanionAd_shouldReturnV
     @Test
     public void evaluateVastXmlManager_withSequenceNumbers_shouldReturnVastVideoConfigurationWithNegativeSequenceNumber() {
         VastVideoConfig vastVideoConfig = subject.evaluateVastXmlManager(
-                TEST_VAST_WITH_NEGATIVE_SEQUENCE_NUMBER_XML_STRING, HttpClient.getHttpClient(),
+                TEST_VAST_WITH_NEGATIVE_SEQUENCE_NUMBER_XML_STRING,
                 new ArrayList<VastTracker>());
 
         assertThat(vastVideoConfig.getNetworkMediaFileUrl()).isEqualTo(
@@ -1174,7 +1173,7 @@ public void isValidSequenceNumber_withTwo_shouldReturnFalse() {
     @Test
     public void evaluateVastXmlManager_withJustError_shouldReturnNullVastVideoConfiguration_shouldFireErrorTracker() {
         VastVideoConfig vastVideoConfig = subject.evaluateVastXmlManager(
-                TEST_JUST_ERROR_XML_STRING, HttpClient.getHttpClient(),
+                TEST_JUST_ERROR_XML_STRING,
                 new ArrayList<VastTracker>());
 
         assertThat(vastVideoConfig).isNull();
@@ -1183,10 +1182,10 @@ public void evaluateVastXmlManager_withJustError_shouldReturnNullVastVideoConfig
     }
 
     @Test
-    public void evaluateVastXmlManager_withWrapperToJustError_shouldReturnNullVastVideoConfiguration_shouldFireErrorTrackers() {
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_JUST_ERROR_XML_STRING);
+    public void evaluateVastXmlManager_withWrapperToJustError_shouldReturnNullVastVideoConfiguration_shouldFireErrorTrackers() throws Exception {
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, TEST_JUST_ERROR_XML_STRING);
         VastVideoConfig vastVideoConfig = subject.evaluateVastXmlManager(
-                TEST_VAST_XML_STRING, HttpClient.getHttpClient(), new ArrayList<VastTracker>());
+                TEST_VAST_XML_STRING, new ArrayList<VastTracker>());
 
         assertThat(vastVideoConfig).isNull();
         verify(mockRequestQueue).add(argThat(isUrl("http://justErrorTracking?errorcode=303")));
@@ -1194,20 +1193,20 @@ public void evaluateVastXmlManager_withWrapperToJustError_shouldReturnNullVastVi
     }
 
     @Test
-    public void evaluateVastXmlManager_withWrapperToVastXmlError_shouldReturnNullVastVideoConfiguration_shouldFireErrorTracker() {
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_INVALID_VAST_XML_STRING);
+    public void evaluateVastXmlManager_withWrapperToVastXmlError_shouldReturnNullVastVideoConfiguration_shouldFireErrorTracker() throws Exception {
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, TEST_INVALID_VAST_XML_STRING);
         VastVideoConfig vastVideoConfig = subject.evaluateVastXmlManager(
-                TEST_VAST_XML_STRING, HttpClient.getHttpClient(), new ArrayList<VastTracker>());
+                TEST_VAST_XML_STRING, new ArrayList<VastTracker>());
 
         assertThat(vastVideoConfig).isNull();
         verifyNoMoreInteractions(mockRequestQueue);
     }
 
     @Test
-    public void evaluateVastXmlManager_withWrapperToInvalidXml_shouldReturnNullVastVideoConfiguration_shouldFireErrorTracker() {
-        mFakeHttpLayer.addPendingHttpResponse(200, TEST_INVALID_XML_STRING);
+    public void evaluateVastXmlManager_withWrapperToInvalidXml_shouldReturnNullVastVideoConfiguration_shouldFireErrorTracker() throws Exception {
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, TEST_INVALID_XML_STRING);
         VastVideoConfig vastVideoConfig = subject.evaluateVastXmlManager(
-                TEST_VAST_XML_STRING, HttpClient.getHttpClient(), new ArrayList<VastTracker>());
+                TEST_VAST_XML_STRING, new ArrayList<VastTracker>());
 
         assertThat(vastVideoConfig).isNull();
         verify(mockRequestQueue).add(argThat(isUrl("http://wrapperErrorOne?errorcode=100")));
@@ -1218,7 +1217,7 @@ public void evaluateVastXmlManager_withWrapperToInvalidXml_shouldReturnNullVastV
     @Test
     public void evaluateVastXmlManager_withWrapperToNoHttpResponse_shouldReturnNullVastVideoConfiguration_shouldFireErrorTracker() {
         VastVideoConfig vastVideoConfig = subject.evaluateVastXmlManager(
-                TEST_VAST_XML_STRING, HttpClient.getHttpClient(), new ArrayList<VastTracker>());
+                TEST_VAST_XML_STRING, new ArrayList<VastTracker>());
 
         assertThat(vastVideoConfig).isNull();
         verify(mockRequestQueue).add(argThat(isUrl("http://wrapperErrorOne?errorcode=301")));
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VideoDownloaderTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VideoDownloaderTest.java
new file mode 100644
index 00000000..1ff5949f
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VideoDownloaderTest.java
@@ -0,0 +1,261 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.Context;
+
+import com.mopub.common.CacheService;
+import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.test.support.ShadowAsyncTasks;
+import com.mopub.common.util.test.support.ShadowMoPubHttpUrlConnection;
+import com.mopub.mobileads.VideoDownloader.VideoDownloaderListener;
+import com.mopub.mobileads.VideoDownloader.VideoDownloaderTask;
+
+import org.fest.util.Arrays;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+
+import java.lang.ref.WeakReference;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.anyBoolean;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+@Config(shadows = {ShadowAsyncTasks.class, ShadowMoPubHttpUrlConnection.class})
+@RunWith(SdkTestRunner.class)
+public class VideoDownloaderTest {
+    @Mock VideoDownloaderListener mockListener;
+    private final static String expectedUrl1 = "http://video_url";
+    private final static String expectedUrl2 = "http://video_url2";
+
+    @Before
+    public void setUp() {
+        Context context = Robolectric.buildActivity(Activity.class).create().get();
+        CacheService.initialize(context);
+    }
+
+    @After
+    public void tearDown() {
+        VideoDownloader.clearDownloaderTasks();
+        CacheService.clearAndNullCaches();
+    }
+
+    @Test
+    public void cache_shouldExecuteVideoDownloaderTask() {
+        VideoDownloader.cache(expectedUrl1, mockListener);
+
+        assertThat(ShadowAsyncTasks.wasCalled()).isTrue();
+        assertThat(ShadowAsyncTasks.getLatestAsyncTask()).isInstanceOf(VideoDownloaderTask.class);
+        assertThat(ShadowAsyncTasks.getLatestParams()).hasSize(1);
+        assertThat(ShadowAsyncTasks.getLatestParams().contains(expectedUrl1)).isTrue();
+
+        // In the success case, the listener will not be modified until after the AsyncTask is
+        // actually executed
+        verify(mockListener, never()).onComplete(anyBoolean());
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void cache_withNullListener_shouldThrowNullPointerException() {
+        VideoDownloader.cache(expectedUrl1, null);
+    }
+
+    @Test
+    public void cache_withNullUrl_shouldCallOnCompleteFalse_shouldNotExecuteAsyncTask() {
+        VideoDownloader.cache(null, mockListener);
+
+        verify(mockListener).onComplete(false);
+        assertThat(ShadowAsyncTasks.wasCalled()).isFalse();
+    }
+
+    @Test
+    public void cache_shouldAddVideoDownloaderTaskToStaticCollection() {
+        assertThat(VideoDownloader.getDownloaderTasks()).isEmpty();
+
+        VideoDownloader.cache(expectedUrl1, mockListener);
+
+        VideoDownloaderTask expectedTask =
+                (VideoDownloaderTask) ShadowAsyncTasks.getLatestAsyncTask();
+
+        assertThat(VideoDownloader.getDownloaderTasks()).hasSize(1);
+        assertThat(VideoDownloader.getDownloaderTasks().pop().get()).isEqualTo(expectedTask);
+    }
+
+    @Test
+    public void cache_shouldAddMultipleVideoDownloaderTasksToStaticCollection() {
+        VideoDownloader.cache(expectedUrl1, mockListener);
+        VideoDownloaderTask expectedTask1 =
+                (VideoDownloaderTask) ShadowAsyncTasks.getLatestAsyncTask();
+
+        VideoDownloader.cache(expectedUrl2, mockListener);
+        VideoDownloaderTask expectedTask2 =
+                (VideoDownloaderTask) ShadowAsyncTasks.getLatestAsyncTask();
+
+        assertThat(VideoDownloader.getDownloaderTasks()).hasSize(2);
+        assertThat(VideoDownloader.getDownloaderTasks().pop().get()).isEqualTo(expectedTask1);
+        assertThat(VideoDownloader.getDownloaderTasks().pop().get()).isEqualTo(expectedTask2);
+    }
+
+    @Test
+    public void cancelAllDownloaderTasks_shouldCancelAllTasksAndRemoveFromStaticCollection() {
+        final VideoDownloaderTask task1 = mock(VideoDownloaderTask.class);
+        final VideoDownloaderTask task2 = mock(VideoDownloaderTask.class);
+        VideoDownloader.getDownloaderTasks().add(new WeakReference<VideoDownloaderTask>(task1));
+        VideoDownloader.getDownloaderTasks().add(new WeakReference<VideoDownloaderTask>(task2));
+
+        VideoDownloader.cancelAllDownloaderTasks();
+
+        verify(task1).cancel(true);
+        verify(task2).cancel(true);
+        assertThat(VideoDownloader.getDownloaderTasks()).isEmpty();
+    }
+
+    @Test
+    public void cancelLastDownloaderTasks_shouldCancelTasksAndRemoveFromStaticCollection() {
+        final VideoDownloaderTask task1 = mock(VideoDownloaderTask.class);
+        final VideoDownloaderTask task2 = mock(VideoDownloaderTask.class);
+        VideoDownloader.getDownloaderTasks().add(new WeakReference<VideoDownloaderTask>(task1));
+        VideoDownloader.getDownloaderTasks().add(new WeakReference<VideoDownloaderTask>(task2));
+
+        VideoDownloader.cancelLastDownloadTask();
+
+        verify(task1, never()).cancel(anyBoolean());
+        verify(task2).cancel(true);
+        assertThat(VideoDownloader.getDownloaderTasks()).hasSize(1);
+        assertThat(VideoDownloader.getDownloaderTasks().pop().get()).isEqualTo(task1);
+    }
+
+    @Test
+    public void doInBackground_shouldReturnTrue_shouldUpdateCache() throws Exception {
+        String expectedResponse = "response";
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, expectedResponse);
+        final VideoDownloaderTask videoDownloaderTask = new VideoDownloaderTask(mockListener);
+
+        final Boolean result = videoDownloaderTask.doInBackground(expectedUrl1);
+
+        assertThat(result).isTrue();
+        assertThat(CacheService.getDiskLruCache().size()).isEqualTo(expectedResponse.length());
+        assertThat(CacheService.getFromDiskCache(expectedUrl1)).isEqualTo(expectedResponse.getBytes());
+    }
+
+    @Test
+    public void doInBackground_withNullArguments_shouldReturnFalse_shouldNotUpdateCache() throws Exception {
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, "response");
+        final VideoDownloaderTask videoDownloaderTask = new VideoDownloaderTask(mockListener);
+
+        final Boolean result = videoDownloaderTask.doInBackground((String) null);
+
+        assertThat(result).isFalse();
+        assertThat(CacheService.getDiskLruCache().size()).isEqualTo(0);
+    }
+
+    @Test
+    public void doInBackground_withEmptyArrayArguments_shouldReturnFalse_shouldNotUpdateCache() throws Exception {
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, "response");
+        final VideoDownloaderTask videoDownloaderTask = new VideoDownloaderTask(mockListener);
+
+        final Boolean result = videoDownloaderTask.doInBackground(Arrays.<String>array());
+
+        assertThat(result).isFalse();
+        assertThat(CacheService.getDiskLruCache().size()).isEqualTo(0);
+    }
+
+    @Test
+    public void doInBackground_withArrayStartingWithNull_shouldReturnFalse_shouldNotUpdateCache() throws Exception {
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, "response");
+        final VideoDownloaderTask videoDownloaderTask = new VideoDownloaderTask(mockListener);
+
+        final String[] parameters = {null};
+        final Boolean result = videoDownloaderTask.doInBackground(parameters);
+
+        assertThat(result).isFalse();
+        assertThat(CacheService.getDiskLruCache().size()).isEqualTo(0);
+    }
+
+    @Test
+    public void doInBackground_withStatusCodeLessThan200_shouldReturnFalse_shouldNotUpdateCache() throws Exception {
+        ShadowMoPubHttpUrlConnection.addPendingResponse(199, "response");
+        VideoDownloaderTask videoDownloaderTask = new VideoDownloaderTask(mockListener);
+
+        final Boolean result = videoDownloaderTask.doInBackground(expectedUrl1);
+
+        assertThat(result).isFalse();
+        assertThat(CacheService.getDiskLruCache().size()).isEqualTo(0);
+    }
+
+    @Test
+    public void doInBackground_withStatusCodeGreaterThan299_shouldReturnFalse_shouldNotUpdateCache() throws Exception {
+        ShadowMoPubHttpUrlConnection.addPendingResponse(300, "response");
+        VideoDownloaderTask videoDownloaderTask = new VideoDownloaderTask(mockListener);
+
+        final Boolean result = videoDownloaderTask.doInBackground(expectedUrl1);
+
+        assertThat(result).isFalse();
+        assertThat(CacheService.getDiskLruCache().size()).isEqualTo(0);
+    }
+
+    @Test
+    public void doInBackground_withResponseGreaterThan25Mb_shouldReturnFalse_shouldNotUpdateCache() throws Exception {
+        String longString = createLongString(25 * 1024 * 1024 + 1);
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, longString);
+        VideoDownloaderTask videoDownloaderTask = new VideoDownloaderTask(mockListener);
+
+        final Boolean result = videoDownloaderTask.doInBackground(expectedUrl1);
+
+        assertThat(result).isFalse();
+        assertThat(CacheService.getDiskLruCache().size()).isEqualTo(0);
+    }
+
+    @Test
+    public void onPostExecute_withSuccessTrue_shouldCallOnCompleteTrue_shouldRemoveDownloadTaskFromQueue() {
+        VideoDownloaderTask videoDownloaderTask = new VideoDownloaderTask(mockListener);
+        assertThat(VideoDownloader.getDownloaderTasks()).hasSize(1);
+
+        videoDownloaderTask.onPostExecute(true);
+
+        verify(mockListener).onComplete(true);
+        assertThat(VideoDownloader.getDownloaderTasks()).hasSize(0);
+    }
+
+    @Test
+    public void onPostExecute_withSuccessFalse_shouldCallOnCompleteFalse_shouldRemoveDownloadTaskFromQueue() {
+        VideoDownloaderTask videoDownloaderTask = new VideoDownloaderTask(mockListener);
+        assertThat(VideoDownloader.getDownloaderTasks()).hasSize(1);
+
+        videoDownloaderTask.onPostExecute(false);
+
+        verify(mockListener).onComplete(false);
+        assertThat(VideoDownloader.getDownloaderTasks()).hasSize(0);
+    }
+
+    @Test
+    public void onPostExecute_withSuccessNull_shouldCallOnCompleteFalse_shouldRemoveDownloadTaskFromQueue() {
+        VideoDownloaderTask videoDownloaderTask = new VideoDownloaderTask(mockListener);
+        assertThat(VideoDownloader.getDownloaderTasks()).hasSize(1);
+
+        videoDownloaderTask.onPostExecute(null);
+
+        verify(mockListener).onComplete(false);
+        assertThat(VideoDownloader.getDownloaderTasks()).hasSize(0);
+    }
+
+    @Test
+    public void cancelledTask_shouldCallOnCompleteFalse_shouldRemoveDownloadTaskFromQueue() {
+        VideoDownloaderTask videoDownloaderTask = new VideoDownloaderTask(mockListener);
+        assertThat(VideoDownloader.getDownloaderTasks()).hasSize(1);
+
+        videoDownloaderTask.cancel(true);
+
+        verify(mockListener).onComplete(false);
+        assertThat(VideoDownloader.getDownloaderTasks()).hasSize(0);
+    }
+
+    private static String createLongString(int size) {
+        return new String(new char[size]).replace("\0", "*");
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestHttpClientFactory.java b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestHttpClientFactory.java
deleted file mode 100644
index 2a364a19..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestHttpClientFactory.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package com.mopub.mobileads.test.support;
-
-import com.mopub.mobileads.factories.HttpClientFactory;
-
-import org.apache.http.impl.client.DefaultHttpClient;
-
-public class TestHttpClientFactory extends HttpClientFactory {
-    private DefaultHttpClient instance = new DefaultHttpClient();
-
-    @Override
-    protected DefaultHttpClient internalCreate(int timeout) {
-        return instance;
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestVastVideoDownloadTaskFactory.java b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestVastVideoDownloadTaskFactory.java
deleted file mode 100644
index fb9b24f7..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestVastVideoDownloadTaskFactory.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package com.mopub.mobileads.test.support;
-
-import com.mopub.mobileads.VastVideoDownloadTask;
-import com.mopub.mobileads.factories.VastVideoDownloadTaskFactory;
-
-import static org.mockito.Mockito.mock;
-
-public class TestVastVideoDownloadTaskFactory extends VastVideoDownloadTaskFactory {
-    private static VastVideoDownloadTask singletonMock = mock(VastVideoDownloadTask.class);
-
-    public static VastVideoDownloadTask getSingletonMock() {
-        return singletonMock;
-    }
-
-    @Override
-    protected VastVideoDownloadTask internalCreate(VastVideoDownloadTask.VastVideoDownloadTaskListener vastVideoDownloadTaskListener) {
-        return singletonMock;
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/HttpClientsTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/util/HttpClientsTest.java
deleted file mode 100644
index b2bbbb3b..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/util/HttpClientsTest.java
+++ /dev/null
@@ -1,57 +0,0 @@
-package com.mopub.mobileads.util;
-
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.mobileads.test.support.ThreadUtils;
-import org.apache.http.client.HttpClient;
-import org.apache.http.conn.ClientConnectionManager;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.stub;
-import static org.mockito.Mockito.verify;
-
-@RunWith(SdkTestRunner.class)
-public class HttpClientsTest {
-
-    public static final int HTTP_CLIENT_SHUTDOWN_TIME = 100;
-    private HttpClient httpClient;
-    private ClientConnectionManager clientConnectionManager;
-
-    @Before
-    public void setUp() throws Exception {
-        httpClient = mock(HttpClient.class);
-        clientConnectionManager = mock(ClientConnectionManager.class);
-        stub(httpClient.getConnectionManager()).toReturn(clientConnectionManager);
-    }
-
-    @Test
-    public void safeShutdown_shouldShutdownHttpClient() throws Exception {
-        HttpClients.safeShutdown(httpClient);
-
-        ThreadUtils.pause(HTTP_CLIENT_SHUTDOWN_TIME);
-
-        verify(clientConnectionManager).shutdown();
-    }
-
-    @Test
-    public void safeShutdown_withNullHttpClient_shouldNotBlowUp() throws Exception {
-        HttpClients.safeShutdown(null);
-
-        ThreadUtils.pause(HTTP_CLIENT_SHUTDOWN_TIME);
-
-        verify(clientConnectionManager, never()).shutdown();
-    }
-
-    @Test
-    public void safeShutdown_withNullConnectionManager_shouldNotBlowUp() throws Exception {
-        stub(httpClient.getConnectionManager()).toReturn(null);
-        HttpClients.safeShutdown(httpClient);
-
-        ThreadUtils.pause(HTTP_CLIENT_SHUTDOWN_TIME);
-
-        verify(clientConnectionManager, never()).shutdown();
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mraid/MraidNativeCommandHandlerTest.java b/mopub-sdk/src/test/java/com/mopub/mraid/MraidNativeCommandHandlerTest.java
index 533d66b3..8b6b6e1c 100644
--- a/mopub-sdk/src/test/java/com/mopub/mraid/MraidNativeCommandHandlerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mraid/MraidNativeCommandHandlerTest.java
@@ -11,20 +11,26 @@
 import android.os.Build;
 import android.os.Environment;
 import android.provider.CalendarContract;
+import android.support.annotation.NonNull;
+import android.util.Pair;
 import android.view.View;
 import android.view.WindowManager;
 import android.widget.LinearLayout;
 
 import com.mopub.common.test.support.SdkTestRunner;
+import com.mopub.common.util.test.support.ShadowAsyncTasks;
+import com.mopub.common.util.test.support.ShadowMoPubHttpUrlConnection;
 import com.mopub.mobileads.test.support.FileUtils;
 import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
 import com.mopub.mobileads.test.support.ThreadUtils;
+import com.mopub.mraid.MraidNativeCommandHandler.DownloadImageAsyncTask;
+import com.mopub.mraid.MraidNativeCommandHandler.DownloadImageAsyncTask.DownloadImageAsyncTaskListener;
 import com.mopub.mraid.MraidNativeCommandHandler.MraidCommandFailureListener;
 
 import org.apache.http.HttpResponse;
-import org.apache.http.client.methods.HttpUriRequest;
 import org.hamcrest.BaseMatcher;
 import org.hamcrest.Description;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -40,14 +46,16 @@
 import org.robolectric.shadows.ShadowToast;
 
 import java.io.File;
-import java.net.URI;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
+import java.util.TreeMap;
 
 import static android.content.DialogInterface.BUTTON_NEGATIVE;
 import static android.content.DialogInterface.BUTTON_POSITIVE;
+import static android.os.Environment.MEDIA_MOUNTED;
 import static com.mopub.mraid.MraidNativeCommandHandler.ANDROID_CALENDAR_CONTENT_TYPE;
+import static com.mopub.mraid.MraidNativeCommandHandler.MIME_TYPE_HEADER;
 import static java.io.File.separator;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
@@ -61,16 +69,18 @@
 import static org.mockito.Mockito.when;
 import static org.robolectric.Robolectric.shadowOf;
 
+@Config(shadows = {ShadowAsyncTasks.class, ShadowMoPubHttpUrlConnection.class})
 @RunWith(SdkTestRunner.class)
 public class MraidNativeCommandHandlerTest {
     private static final String IMAGE_URI_VALUE = "file://tmp/expectedFile.jpg";
+    private static final String REMOTE_IMAGE_URL = "http://www.mopub.com/expectedFile.jpg";
     private static final int TIME_TO_PAUSE_FOR_NETWORK = 300;
     private static final String FAKE_IMAGE_DATA = "imageFileData";
     //XXX: Robolectric or JUNIT doesn't support the correct suffix ZZZZZ in the parse pattern, so replacing xx:xx with xxxx for time.
     private static final String CALENDAR_START_TIME = "2013-08-14T20:00:00-0000";
 
-
-    @Mock MraidCommandFailureListener mraidCommandFailureListener;
+    @Mock MraidCommandFailureListener mockMraidCommandFailureListener;
+    @Mock DownloadImageAsyncTaskListener mockDownloadImageAsyncTaskListener;
     private MraidNativeCommandHandler subject;
     private Context context;
     private Map<String, String> params;
@@ -80,7 +90,6 @@
     private File fileWithoutExtension;
     private TestHttpResponseWithHeaders response;
 
-
     @Before
     public void setUp() throws Exception {
         subject = new MraidNativeCommandHandler();
@@ -90,14 +99,20 @@ public void setUp() throws Exception {
         expectedFile = new File(Environment.getExternalStorageDirectory(), "Pictures" + separator + "expectedFile.jpg");
         pictureDirectory = new File(Environment.getExternalStorageDirectory(), "Pictures");
         fileWithoutExtension = new File(pictureDirectory, "file");
+
+        // Mount external storage and grant necessary permissions
+        ShadowEnvironment.setExternalStorageState(MEDIA_MOUNTED);
+        Robolectric.getShadowApplication().grantPermissions(Manifest.permission.WRITE_EXTERNAL_STORAGE);
+    }
+
+    @After
+    public void tearDown() {
+        ShadowToast.reset();
     }
 
-    @Ignore("Mraid 2.0")
     @Test
     public void showUserDownloadImageAlert_withActivityContext_shouldDisplayAlertDialog() throws Exception {
-        response = new TestHttpResponseWithHeaders(200, FAKE_IMAGE_DATA);
-
-        subject.storePicture(context, IMAGE_URI_VALUE, mraidCommandFailureListener);
+        subject.storePicture(context, IMAGE_URI_VALUE, mockMraidCommandFailureListener);
 
         AlertDialog alertDialog = ShadowAlertDialog.getLatestAlertDialog();
         ShadowAlertDialog shadowAlertDialog = shadowOf(alertDialog);
@@ -112,96 +127,165 @@ public void showUserDownloadImageAlert_withActivityContext_shouldDisplayAlertDia
         assertThat(alertDialog.getButton(BUTTON_NEGATIVE)).isNotNull();
     }
 
-    @Ignore("Mraid 2.0")
     @Test
-    public void showUserDownloadImageAlert_whenOkayClicked_shouldDownloadImage() throws Exception {
-        response = new TestHttpResponseWithHeaders(200, FAKE_IMAGE_DATA);
-        Robolectric.addPendingHttpResponse(response);
+    public void showUserDownloadImageAlert_withAppContext_shouldToastAndStartDownloadImageAsyncTask() throws Exception {
+        assertThat(ShadowToast.shownToastCount()).isEqualTo(0);
 
-        subject.storePicture(context, IMAGE_URI_VALUE, mraidCommandFailureListener);
+        subject.storePicture(context.getApplicationContext(), IMAGE_URI_VALUE, mockMraidCommandFailureListener);
 
-        ShadowAlertDialog.getLatestAlertDialog().getButton(BUTTON_POSITIVE).performClick();
-        ThreadUtils.pause(TIME_TO_PAUSE_FOR_NETWORK);
+        assertThat(ShadowToast.shownToastCount()).isEqualTo(1);
+        assertThat(ShadowToast.getTextOfLatestToast()).isEqualTo("Downloading image to Picture gallery...");
 
-        assertThat(expectedFile.exists()).isTrue();
-        assertThat(expectedFile.length()).isEqualTo(FAKE_IMAGE_DATA.length());
+        assertThat(ShadowAsyncTasks.wasCalled()).isTrue();
+        assertThat(ShadowAsyncTasks.getLatestAsyncTask()).isInstanceOf(DownloadImageAsyncTask.class);
+        final List<?> latestParams = ShadowAsyncTasks.getLatestParams();
+        assertThat(latestParams).hasSize(1);
+        assertThat(latestParams.get(0)).isEqualTo(IMAGE_URI_VALUE);
+    }
+
+    @Test(expected = MraidCommandException.class)
+    public void showUserDownloadImageAlert_whenStorePictureNotSupported_shouldThrowMraidCommandException() throws Exception {
+        Robolectric.getShadowApplication().denyPermissions(Manifest.permission.WRITE_EXTERNAL_STORAGE);
+
+        subject.storePicture(context, IMAGE_URI_VALUE, mockMraidCommandFailureListener);
     }
 
-    @Ignore("Mraid 2.0")
     @Test
-    public void showUserDownloadImageAlert_whenCancelClicked_shouldDismissDialog() throws Exception {
-        response = new TestHttpResponseWithHeaders(200, FAKE_IMAGE_DATA);
+    public void showUserDownloadImageAlert_whenOkayClicked_shouldStartDownloadImageAsyncTask() throws Exception {
+        subject.storePicture(context, IMAGE_URI_VALUE, mockMraidCommandFailureListener);
 
-        subject.storePicture(context, IMAGE_URI_VALUE, mraidCommandFailureListener);
+        ShadowAlertDialog.getLatestAlertDialog().getButton(BUTTON_POSITIVE).performClick();
+
+        assertThat(ShadowAsyncTasks.wasCalled()).isTrue();
+        assertThat(ShadowAsyncTasks.getLatestAsyncTask()).isInstanceOf(DownloadImageAsyncTask.class);
+        final List<?> latestParams = ShadowAsyncTasks.getLatestParams();
+        assertThat(latestParams).hasSize(1);
+        assertThat(latestParams.get(0)).isEqualTo(IMAGE_URI_VALUE);
+    }
+
+    @Test
+    public void showUserDownloadImageAlert_whenCancelClicked_shouldDismissDialog_shouldNotStartDownloadImageAsyncTask() throws Exception {
+        subject.storePicture(context, IMAGE_URI_VALUE, mockMraidCommandFailureListener);
 
         AlertDialog alertDialog = ShadowAlertDialog.getLatestAlertDialog();
         ShadowAlertDialog shadowAlertDialog = shadowOf(alertDialog);
 
         alertDialog.getButton(BUTTON_NEGATIVE).performClick();
         assertThat(shadowAlertDialog.hasBeenDismissed()).isTrue();
+        assertThat(ShadowAsyncTasks.wasCalled()).isFalse();
+    }
 
-        assertThat(expectedFile.exists()).isFalse();
-        assertThat(expectedFile.length()).isEqualTo(0);
+    @Test
+    public void downloadImageAsyncTask_doInBackground_shouldReturnTrueAndCreateFile() throws Exception {
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, FAKE_IMAGE_DATA,
+                createHeaders(new Pair<String, String>("Content-Type", "image/jpg")));
+
+        final DownloadImageAsyncTask downloadImageAsyncTask =
+                new DownloadImageAsyncTask(context, mockDownloadImageAsyncTaskListener);
+
+        final Boolean result =
+                downloadImageAsyncTask.doInBackground(new String[]{REMOTE_IMAGE_URL});
+
+        assertThat(result).isTrue();
+        assertThat(expectedFile.exists()).isTrue();
+        assertThat(expectedFile.length()).isEqualTo(FAKE_IMAGE_DATA.length());
     }
 
-    @Ignore("MRAID 2.0")
     @Test
-    public void showUserDownloadImageAlert_withAppContext_shouldToastAndDownloadImage() throws Exception {
-        response = new TestHttpResponseWithHeaders(200, FAKE_IMAGE_DATA);
-        Robolectric.addPendingHttpResponse(response);
+    public void downloadImageAsyncTask_doInBackground_withLocationHeaderSet_shouldUseLocationHeaderAsFilename() throws Exception {
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, FAKE_IMAGE_DATA,
+                createHeaders(
+                        new Pair<String, String>("Content-Type", "image/jpg"),
+                        new Pair<String, String>("Location", "https://www.newhost.com/images/blah/file.wow")
+                )
+        );
 
-        assertThat(ShadowToast.shownToastCount()).isEqualTo(0);
+        final DownloadImageAsyncTask downloadImageAsyncTask =
+                new DownloadImageAsyncTask(context, mockDownloadImageAsyncTaskListener);
+        final Boolean result =
+                downloadImageAsyncTask.doInBackground(new String[]{REMOTE_IMAGE_URL});
 
-        subject.storePicture(context.getApplicationContext(), IMAGE_URI_VALUE, mraidCommandFailureListener);
-        ThreadUtils.pause(TIME_TO_PAUSE_FOR_NETWORK);
+        expectedFile = new File(Environment.getExternalStorageDirectory(), "Pictures" + separator + "file.wow.jpg");
 
-        assertThat(ShadowToast.shownToastCount()).isEqualTo(1);
-        assertThat(ShadowToast.getTextOfLatestToast()).isEqualTo("Downloading image to Picture gallery...");
+        assertThat(result).isTrue();
+        assertThat(expectedFile.exists()).isTrue();
+        assertThat(expectedFile.length()).isEqualTo(FAKE_IMAGE_DATA.length());
+    }
 
-        Robolectric.runUiThreadTasks();
+    @Test
+    public void downloadImageAsyncTask_doInBackground_withMissingMimeTypeHeaders_shouldUseDefaultFilename() throws Exception {
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, FAKE_IMAGE_DATA);
 
+        final DownloadImageAsyncTask downloadImageAsyncTask =
+                new DownloadImageAsyncTask(context, mockDownloadImageAsyncTaskListener);
+        final Boolean result =
+                downloadImageAsyncTask.doInBackground(new String[]{REMOTE_IMAGE_URL});
+
+        assertThat(result).isTrue();
         assertThat(expectedFile.exists()).isTrue();
         assertThat(expectedFile.length()).isEqualTo(FAKE_IMAGE_DATA.length());
     }
 
-    @Ignore("MRAID 2.0")
     @Test
-    public void showUserDownloadImageAlert_withAppContext_whenDownloadImageFails_shouldDisplayFailureToastAndNotDownloadImage() throws Exception {
-        response = new TestHttpResponseWithHeaders(200, FAKE_IMAGE_DATA);
-        Robolectric.addPendingHttpResponse(response);
+    public void downloadImageAsyncTask_doInBackground_withNullArray_shouldReturnFalseAndNotCreateFile() throws Exception {
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, FAKE_IMAGE_DATA,
+                createHeaders(new Pair<String, String>("Content-Type", "image/jpg")));
 
-        assertThat(ShadowToast.shownToastCount()).isEqualTo(0);
+        final DownloadImageAsyncTask downloadImageAsyncTask =
+                new DownloadImageAsyncTask(context, mockDownloadImageAsyncTaskListener);
 
-        subject.storePicture(context, "this is an invalid image url and cannot be downloaded", mraidCommandFailureListener);
-        ThreadUtils.pause(TIME_TO_PAUSE_FOR_NETWORK);
+        final Boolean result =
+                downloadImageAsyncTask.doInBackground(null);
 
-        assertThat(ShadowToast.shownToastCount()).isEqualTo(1);
-        assertThat(ShadowToast.getTextOfLatestToast()).isEqualTo("Downloading image to Picture gallery...");
+        assertThat(result).isFalse();
+        assertThat(expectedFile.exists()).isFalse();
+    }
 
-        Robolectric.runUiThreadTasks();
+    @Test
+    public void downloadImageAsyncTask_doInBackground_withEmptyArray_shouldReturnFalseAndNotCreateFile() throws Exception {
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, FAKE_IMAGE_DATA,
+                createHeaders(new Pair<String, String>("Content-Type", "image/jpg")));
 
-        assertThat(ShadowToast.shownToastCount()).isEqualTo(2);
-        assertThat(ShadowToast.getTextOfLatestToast()).isEqualTo("Image failed to download.");
+        final DownloadImageAsyncTask downloadImageAsyncTask =
+                new DownloadImageAsyncTask(context, mockDownloadImageAsyncTaskListener);
+
+        final Boolean result =
+                downloadImageAsyncTask.doInBackground(new String[]{});
 
+        assertThat(result).isFalse();
         assertThat(expectedFile.exists()).isFalse();
-        assertThat(expectedFile.length()).isEqualTo(0);
     }
 
-    @Ignore("Mraid 2.0")
     @Test
-    public void showUserDownloadImageAlert_whenStorePictureNotSupported_shouldFireErrorEvent_andNotToastNorAlertDialog() throws Exception {
-        Robolectric.getShadowApplication().denyPermissions(Manifest.permission.WRITE_EXTERNAL_STORAGE);
+    public void downloadImageAsyncTask_doInBackground_withArrayContainingNull_shouldReturnFalseAndNotCreateFile() throws Exception {
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, FAKE_IMAGE_DATA,
+                createHeaders(new Pair<String, String>("Content-Type", "image/jpg")));
 
-        subject.storePicture(context, "http://image.jpg", mraidCommandFailureListener);
+        final DownloadImageAsyncTask downloadImageAsyncTask =
+                new DownloadImageAsyncTask(context, mockDownloadImageAsyncTaskListener);
 
+        final Boolean result =
+                downloadImageAsyncTask.doInBackground(new String[]{null});
+
+        assertThat(result).isFalse();
+        assertThat(expectedFile.exists()).isFalse();
+    }
+
+    @Test
+    public void downloadImage_withFailedImageDownload_shouldToastErrorMessageAndNotifyOnFailure() {
         assertThat(ShadowToast.shownToastCount()).isEqualTo(0);
-        assertThat(ShadowAlertDialog.getLatestAlertDialog()).isNull();
-        verify(mraidCommandFailureListener).onFailure(any(MraidCommandException.class));
+        subject.downloadImage(context.getApplicationContext(), IMAGE_URI_VALUE, mockMraidCommandFailureListener);
+
+        DownloadImageAsyncTask latestAsyncTask = (DownloadImageAsyncTask) ShadowAsyncTasks.getLatestAsyncTask();
+        latestAsyncTask.getListener().onFailure();
+
+        assertThat(ShadowToast.shownToastCount()).isEqualTo(1);
+        assertThat(ShadowToast.getTextOfLatestToast()).isEqualTo("Image failed to download.");
+        verify(mockMraidCommandFailureListener).onFailure(any(MraidCommandException.class));
     }
 
-    @Ignore("Mraid 2.0")
     @Test
-    public void showUserDownloadImageAlert_withMimeTypeAndNoFileExtension_shouldSavePictureWithMimeType() throws Exception {
+    public void downloadImage_withMimeTypeAndNoFileExtension_shouldSavePictureWithMimeType() throws Exception {
         String fileNameWithNoExtension = "https://www.somewhere.com/images/blah/file";
 
         assertThatMimeTypeWasAddedCorrectly(
@@ -211,9 +295,8 @@ public void showUserDownloadImageAlert_withMimeTypeAndNoFileExtension_shouldSave
                 ".jpg");
     }
 
-    @Ignore("Mraid 2.0")
     @Test
-    public void showUserDownloadImageAlert_withMultipleContentTypesAndNoFileExtension_shouldSavePictureWithMimeType() throws Exception {
+    public void downloadImage_withMultipleContentTypesAndNoFileExtension_shouldSavePictureWithMimeType() throws Exception {
         String fileNameWithNoExtension = "https://www.somewhere.com/images/blah/file";
 
         assertThatMimeTypeWasAddedCorrectly(
@@ -223,9 +306,8 @@ public void showUserDownloadImageAlert_withMultipleContentTypesAndNoFileExtensio
                 ".png");
     }
 
-    @Ignore("Mraid 2.0")
     @Test
-    public void showUserDownloadImageAlert_withMimeTypeAndFileExtension_shouldSavePictureWithFileExtension() throws Exception {
+    public void downloadImage_withMimeTypeAndFileExtension_shouldSavePictureWithFileExtension() throws Exception {
         String fileNameWithExtension = "https://www.somewhere.com/images/blah/file.extension";
 
         assertThatMimeTypeWasAddedCorrectly(
@@ -237,16 +319,6 @@ public void showUserDownloadImageAlert_withMimeTypeAndFileExtension_shouldSavePi
         assertThat((expectedFile.getName()).endsWith(".extension.extension")).isFalse();
     }
 
-    @Ignore("Mraid 2.0")
-    @Test
-    public void showUserDownloadImageAlert_withHttpUri_shouldRequestPictureFromNetwork() throws Exception {
-        response = new TestHttpResponseWithHeaders(200, "OK");
-        downloadImageForPendingResponse("https://www.google.com/images/srpr/logo4w.png", response);
-
-        HttpUriRequest latestRequest = (HttpUriRequest) Robolectric.getLatestSentHttpRequest();
-        assertThat(latestRequest.getURI()).isEqualTo(URI.create("https://www.google.com/images/srpr/logo4w.png"));
-    }
-
     @Ignore("Mraid 2.0")
     @Config(reportSdk = Build.VERSION_CODES.ICE_CREAM_SANDWICH)
     @Test
@@ -255,7 +327,7 @@ public void createCalendarEvent_withMinimumValidParams_atLeastICS_shouldCreateEv
 
         subject.createCalendarEvent(context, params);
 
-        verify(mraidCommandFailureListener, never()).onFailure(any(MraidCommandException.class));
+        verify(mockMraidCommandFailureListener, never()).onFailure(any(MraidCommandException.class));
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
 
@@ -274,7 +346,7 @@ public void createCalendarEvent_withoutSecondsOnStartDate_atLeastICS_shouldCreat
 
         subject.createCalendarEvent(context, params);
 
-        verify(mraidCommandFailureListener, never()).onFailure(any(MraidCommandException.class));
+        verify(mockMraidCommandFailureListener, never()).onFailure(any(MraidCommandException.class));
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
 
@@ -477,7 +549,7 @@ public void createCalendarEvent_withWeeklyRecurrence_withInvalidDaysOfWeek_shoul
     public void createCalendarEvent_beforeIcs_shouldFireErrorEvent() throws Exception {
         subject.createCalendarEvent(context, params);
 
-        verify(mraidCommandFailureListener).onFailure(any(MraidCommandException.class));
+        verify(mockMraidCommandFailureListener).onFailure(any(MraidCommandException.class));
     }
 
     @Ignore("Mraid 2.0")
@@ -488,7 +560,7 @@ public void createCalendarEvent_withInvalidDate_shouldFireErrorEvent() throws Ex
 
         subject.createCalendarEvent(context, params);
 
-        verify(mraidCommandFailureListener).onFailure(any(MraidCommandException.class));
+        verify(mockMraidCommandFailureListener).onFailure(any(MraidCommandException.class));
     }
 
     @Ignore("Mraid 2.0")
@@ -499,7 +571,7 @@ public void createCalendarEvent_withMissingParameters_shouldFireErrorEvent() thr
 
         subject.createCalendarEvent(context, params);
 
-        verify(mraidCommandFailureListener).onFailure(any(MraidCommandException.class));
+        verify(mockMraidCommandFailureListener).onFailure(any(MraidCommandException.class));
     }
 
     @Ignore("Mraid 2.0")
@@ -510,7 +582,7 @@ public void createCalendarEvent_withNullDate_shouldFireErrorEvent() throws Excep
 
         subject.createCalendarEvent(context, params);
 
-        verify(mraidCommandFailureListener).onFailure(any(MraidCommandException.class));
+        verify(mockMraidCommandFailureListener).onFailure(any(MraidCommandException.class));
     }
 
     @Ignore("Mraid 2.0")
@@ -739,22 +811,34 @@ public void describeTo(Description description) {
         return context;
     }
 
-    private void downloadImageForPendingResponse(String uri, HttpResponse response) throws Exception {
-        Robolectric.addPendingHttpResponse(response);
+    private Map<String, List<String>> createHeaders(@NonNull final Pair<String, String>... pairs) {
+        final TreeMap<String, List<String>> headers = new TreeMap<String, List<String>>();
+        for (final Pair<String, String> pair : pairs) {
+            String key = pair.first;
+            String value = pair.second;
 
-        subject.storePicture(context, uri, mraidCommandFailureListener);
+            if (!headers.containsKey(key)) {
+                headers.put(key, new ArrayList<String>());
+            }
+            headers.get(key).add(value);
+        }
 
-        ThreadUtils.pause(TIME_TO_PAUSE_FOR_NETWORK);
+        return headers;
     }
 
     private void assertThatMimeTypeWasAddedCorrectly(String originalFileName, String contentType,
             String expectedFileName, String expectedExtension) throws Exception {
         expectedFile = new File(pictureDirectory, expectedFileName);
-        response = new TestHttpResponseWithHeaders(200, FAKE_IMAGE_DATA);
-        response.addHeader(MraidNativeCommandHandler.MIME_TYPE_HEADER, contentType);
 
-        downloadImageForPendingResponse(originalFileName, response);
+        ShadowMoPubHttpUrlConnection.addPendingResponse(200, FAKE_IMAGE_DATA,
+                createHeaders(new Pair<String, String>(MIME_TYPE_HEADER, contentType)));
+
+        final DownloadImageAsyncTask downloadImageAsyncTask =
+                new DownloadImageAsyncTask(context, mockDownloadImageAsyncTaskListener);
+        final Boolean result =
+                downloadImageAsyncTask.doInBackground(new String[]{originalFileName});
 
+        assertThat(result).isTrue();
         assertThat(expectedFile.exists()).isTrue();
         assertThat(expectedFile.getName()).endsWith(expectedExtension);
         assertThat(fileWithoutExtension.exists()).isFalse();
@@ -765,7 +849,7 @@ private void setupCalendarParams() {
         Context mockContext = createMockContextWithSpecificIntentData(null,
                 null, ANDROID_CALENDAR_CONTENT_TYPE, "android.intent.action.INSERT");
 
-        //but a mock context does't know how to startActivity(), so we stub it to use ShadowContext for starting activity
+        //but a mock context doesn't know how to startActivity(), so we stub it to use ShadowContext for starting activity
         doAnswer(new Answer<Void>() {
             public Void answer(InvocationOnMock invocation) throws Throwable {
                 if (!(invocation.getArguments()[0] instanceof Intent)) {
