diff --git a/.gitignore b/.gitignore
index 74909a5d..7fc571d6 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,15 +1,19 @@
 .DS_Store
 .git.bak/
-.idea/workspace.xml
-.idea/uiDesigner.xml
+.gradle/
+.idea/
 ant_build/
 bin/
+build/
+classes/
 gen/
+gen-external-apklibs/
 out/
+proguard_logs/
 tmp/
-classes/
-local.properties
 target/
+*.apk
+*.aar
 *.orig
 *.iml
 **/*.iml
@@ -18,4 +22,8 @@ mopub-sample/mopub-sample.iml
 robotium-sample/robotium-sample.iml
 build
 .gradle
+*.pyc
+*.iml
+local.properties
+
 
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 0c3bb146..e3cc0a38 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,4 +1,14 @@
-## Version 2.3 (Jul 17, 2014)
+## Version 2.4.0 (August 28, 2014)
+
+  - **Minimum Android version now at API Level 9.** To use the new SDK, your app must run on Android 2.3.1 (Version 9, Gingerbread) or higher.
+  - **Simplified APIs for inserting native ads.** See [Native Ads Integration](https://github.com/mopub/mopub-android-sdk/wiki/Native-Ads-Integration) for details.
+  - **Automatic ad caching for smooth scrolling.** For native ads, the SDK will now automatically pre-load ads, resulting in smoother scrolling.
+  - **Performance improvements** The SDK now makes more efficient use of memory for image caching and avoids allocating temporary objects while scrolling, resulting in fewer garbage collections.
+  - **Sample app improvements.** An improved sample app allows saving ad unit IDs for testing.
+  - **Bug fixes:**
+    - Banner auto-refresh is now properly re-enabled when resuming your app.
+
+## Version 2.3 (July 17, 2014)
 
   - **Improved impression tracking for Native Ads** Impression tracking for native ads is now more accurate and more efficient.
   - **Streamlined Maven Build and Dependencies** MoPub's Android SDK now depends on the Android v4 Support Library shipped with the Android Build tools. The MoPub Sample App also depends on Google Play Services to use the Android Advertising ID. We recommend building against Play Services in your app as well. For integration instructions, see the [wiki](https://github.com/mopub/mopub-android-sdk/wiki/Getting-Started).
@@ -7,7 +17,7 @@
   - Fixed intermittent NullPointerException in MoPubNative#requestNativeAd; fixes [Github issue #97] (https://github.com/mopub/mopub-android-sdk/issues/97)
   - Fixed an issue where MRAID interstitials could be not be closed.
 
-## Version 2.2 (Jun 19, 2014)
+## Version 2.2 (June 19, 2014)
 
   - **Native ads mediation** release; integration instructions and documentation are available on the [GitHub wiki](https://github.com/mopub/mopub-android-sdk/wiki/Integrating-Native-Third-Party-Ad-Networks). Added custom event native implementations to the native extras directory of the SDK (`/extras/src/com/mopub/nativeads`), with initial support for the following networks:
   	- Facebook Audience Network (`FacebookNative.java`)
@@ -25,7 +35,7 @@
     - Added support for companion banners (shown upon video completion)
   - Added Logcat warnings (and Toasts for debug builds) in cases where all necessary Activity permissions haven't been added to the `AndroidManifest`
 
-## Version 2.0 (Apr 22, 2014)
+## Version 2.0 (April 22, 2014)
 
   - **Native Ads** public release; integration instructions and documentation available on the [GitHub wiki](https://github.com/mopub/mopub-android-sdk/wiki/Native-Ads-Integration)
   - Changed minimum supported Android version to Froyo (Android 2.2, API level 8)
@@ -46,7 +56,7 @@
   - Upgraded the bundled `android-support-v4` library to r19.1.
       - **Note for Maven users:** Newer versions of the `android-support-v4` artifact are unavailable on Maven central, so we have included a small script to update the version in your local artifact repository. Please navigate to the `mopub-sdk` directory, and run `scripts/mavenize_support_library`.
       
-###### Version 2.0.1 (Apr 30, 2014)
+###### Version 2.0.1 (April 30, 2014)
 
   - Fixed cases where VAST Video Interstitials were failing to fire `InterstitialAdListener` callbacks; fixes [GitHub issue #78](https://github.com/mopub/mopub-android-sdk/issues/78)
   - Simplified click tracking logic for HTML ads
@@ -66,7 +76,7 @@
   - All `WebView`s are removed from their parents before `destroy()`; fixes [GitHub issue #38](https://github.com/mopub/mopub-android-sdk/issues/38)
   - Removed previously-deprecated `HTML5AdView`
   
-### Version 1.17.3 (Mar 19, 2014)
+### Version 1.17.3 (March 19, 2014)
 
   - Added safeguards to prevent two different `MoPubInterstitial` objects from listening in on one other's lifecycle callbacks
   - Disabled Javascript loading into `destroy()`ed `WebView`s; fixes [GitHub issue #62](https://github.com/mopub/mopub-android-sdk/issues/62)
@@ -74,27 +84,27 @@
   - MRAID ads that utilize `mraid.open()` now correctly record a click event
   - Added missing `FLAG_ACTIVITY_NEW_TASK` to `VastVideoView`'s intent creation; fixes part of [GitHub issue #56](https://github.com/mopub/mopub-android-sdk/issues/56)
   
-###### Version 1.17.3.1 (Mar 24, 2014)
+###### Version 1.17.3.1 (March 24, 2014)
 
   - Restricted use of methods and fields that require API 4+ (`WebView#removeJavascriptInterface` and `ConnectivityManager`'s connection types)
   
-### Version 1.17.2 (Feb 20, 2014)
+### Version 1.17.2 (February 20, 2014)
 
   - Updated InMobi custom events to support InMobi SDK 4.0.3+ only
   - MRAID viewable property now correctly updates on viewability change
   - `MraidView` properly handles null schemes; fixes [GitHub issue #63](https://github.com/mopub/mopub-android-sdk/pull/63)
   - Internal disk LRU cache correctly hashes keys when checking for existing files
   
-### Version 1.17.1 (Jan 23, 2014)
+### Version 1.17.1 (January 23, 2014)
 
   - Added custom events for Google Play Services. `GooglePlayServicesBanner` and `GooglePlayServicesInterstitial` can be found in the extras directory of the SDK (`/extras/src/com/mopub/mobileads`)
   - Resolved issues with missing annotations on `addJavascriptInterface` when `targetSdkVersion` is set to API level 17 or above
   - Updated MoPub sample application to allow in-app text entry of ad unit IDs
     
-###### Version 1.17.1.1 (Feb 5, 2014)
+###### Version 1.17.1.1 (February 5, 2014)
   - Fixed bug that caused clicks to not be recorded in the MoPub UI (introduced in 1.17.1)
   
-## Version 1.16 (Oct 16, 2013)
+## Version 1.16 (October 16, 2013)
 
   - Improved creative controls
     - Creative flagging
@@ -108,7 +118,7 @@
   - Simplified internal construction and handling of `WebView`s by removing `WebViewPool` and its subclasses
   - Updated mraid.getVersion() to return 2.0
 
-## Version 1.15 (Aug 21, 2013)
+## Version 1.15 (August 21, 2013)
 
 Includes support for ads in the MRAID 2.0 format. MRAID 2.0 allows advertisers to create ads with rich media functionality, including adding calendar events, storing pictures and playing videos in the native video player. To learn more about MRAID 2.0, read our [help article](http://j.mp/16MKSci).
 
@@ -124,7 +134,7 @@ To correctly display ads that ask the user to save a picture (storePicture ads),
 To allow users to play videos using the native video player:  
 * Declare activity `com.mopub.mobileads.MraidVideoPlayerActivity`. This activity is required to support playing videos in the native player and we strongly recommend adding it.
  
-### Version 1.15.2 (Sep 11, 2013) 
+### Version 1.15.2 (September 11, 2013) 
   - Allowed Facebook Support to be disabled optionally with `setFacebookSupported(false)`: 
   	- Use `MoPubInterstitial.setFacebookSupported(false);` for interstitials 
   	- Use `MoPubView.setFacebookSupported(false);` for banners 
@@ -138,19 +148,19 @@ To allow users to play videos using the native video player:
   - Fixed MRAID 2.0 `storePicture` command's messaging when a picture either fails to download or fails to save to device 
   - Expanded MRAID 2.0 `createCalendarEvent` command to support both minute- and second-level granularity  
 
-###### Version 1.15.2.1 (Sep 13, 2013)
+###### Version 1.15.2.1 (September 13, 2013)
   - Made the SDK more resilient to creatives that improperly use the `mopubnativebrowser://` scheme; fixes [GitHub issue #36](https://github.com/mopub/mopub-android-sdk/issues/36)
    
-###### Version 1.15.2.2 (Sep 20, 2013)
+###### Version 1.15.2.2 (September 20, 2013)
   - Removed `WebSettings.setPluginsEnabled()` so the SDK builds against Android API 18; fixes [GitHub issue #28](https://github.com/mopub/mopub-android-sdk/issues/28)
   - AdMob banners are now removed from the view hierarchy before they are destroyed; fixes the reopened [GitHub issue #23](https://github.com/mopub/mopub-android-sdk/issues/23)
   - Prevent ads from launching system features, such as a browser view, until the user has interacted with the ad.
  
-### Version 1.15.1 (Aug 27, 2013)
+### Version 1.15.1 (August 27, 2013)
   - Updated documentation to remove the requirement for certain AndroidManifest permissions
   - Fixed minor bug with MRAID 2.0 `storePicture` command where the user sees a false download completed message
   
-###### Version 1.15.1.1 (Sep 4, 2013)
+###### Version 1.15.1.1 (September 4, 2013)
   - Made the SDK more resilient to unexpected Flash creatives
 
 ## Version 1.14 (May 28, 2013)
@@ -252,4 +262,3 @@ To allow users to play videos using the native video player:
   - Added support for custom events
   - Added network connectivity check before loading an ad
   - Added `OnAdPresentedOverlay` listener methods
-  - Removed unnecessary permissions from the library's manifest
diff --git a/README.md b/README.md
index 4ddf8eb7..162330a4 100644
--- a/README.md
+++ b/README.md
@@ -27,17 +27,21 @@ Integration instructions are available on the [wiki](https://github.com/mopub/mo
 
 Please view the [changelog](https://github.com/mopub/mopub-android-sdk/blob/master/CHANGELOG.md) for details.
 
-  - **Improved impression tracking for Native Ads** Impression tracking for native ads is now more accurate and more efficient.
+  - **Minimum Android version now at API Level 9.** To use the new SDK, your app must run on Android 2.3.1 (Version 9, Gingerbread) or higher.
 
-  - **Streamlined Maven Build and Dependencies** MoPub's Android SDK now depends on the Android v4 Support Library shipped with the Android Build tools. The MoPub Sample App also depends on Google Play Services to use the Android Advertising ID. We recommend building against Play Services in your app as well. For integration instructions, see the [wiki](https://github.com/mopub/mopub-android-sdk/wiki/Getting-Started).
+  - **Simplified APIs for inserting native ads.** See [Native Ads Integration](https://github.com/mopub/mopub-android-sdk/wiki/Native-Ads-Integration) for details.
 
-  - **Updated Third-Party Network Compatibility** MoPub's provided Custom Events (included in the extras/ folder) are now compatible with the latest SDK releases from Millennial Media (5.3.0), Vungle (3.1.0), and InMobi (4.4.1), Google Play Services (5.0.77).
+  - **Automatic ad caching for smooth scrolling.** For native ads, the SDK will now automatically pre-load ads, resulting in smoother scrolling.
 
-  - Bug fixes
+  - **Performance improvements** The SDK now makes more efficient use of memory for image caching and avoids allocating temporary objects while scrolling, resulting in fewer garbage collections.
+
+  - **Sample app improvements.** An improved sample app allows saving ad unit IDs for testing.
+
+  - **Bug fixes**
 
 ## Requirements
 
-Android 2.2 and up
+Android 2.3.1 (API Version 9) and up
 
 ## License
 
diff --git a/mopub-sample/AndroidManifest.xml b/mopub-sample/AndroidManifest.xml
index 48338e11..0f350e93 100644
--- a/mopub-sample/AndroidManifest.xml
+++ b/mopub-sample/AndroidManifest.xml
@@ -3,7 +3,8 @@
       package="com.mopub.simpleadsdemo"
       android:versionCode="1"
       android:versionName="1.0">
-    <uses-sdk android:minSdkVersion="8" />
+    <uses-sdk android:minSdkVersion="9" 
+              android:targetSdkVersion="19"/>
 
     <uses-permission android:name="android.permission.INTERNET" />
     <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
@@ -13,8 +14,8 @@
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
 
     <application android:icon="@drawable/icon" android:label="@string/app_name">
-	    <activity android:name="com.mopub.simpleadsdemo.SimpleAdsDemo"
-	            android:label="@string/app_name" android:theme="@android:style/Theme.NoTitleBar"
+	    <activity android:name="com.mopub.simpleadsdemo.MoPubSampleActivity"
+	            android:label="@string/app_name"
                 android:configChanges="orientation">
 	        <intent-filter>
 	            <action android:name="android.intent.action.MAIN" />
@@ -32,6 +33,7 @@
 
         <meta-data android:name="com.google.android.gms.version"
                    android:value="@integer/google_play_services_version" />
+
     </application>
 
 </manifest>
diff --git a/mopub-sample/mopub-sample.apk b/mopub-sample/mopub-sample.apk
deleted file mode 100644
index 4c11d4c4..00000000
Binary files a/mopub-sample/mopub-sample.apk and /dev/null differ
diff --git a/mopub-sample/pom.xml b/mopub-sample/pom.xml
index 42580ee3..4196e85f 100644
--- a/mopub-sample/pom.xml
+++ b/mopub-sample/pom.xml
@@ -22,6 +22,7 @@
     <dependencies>
 
         <!--main-->
+
         <dependency>
             <groupId>com.mopub.mobileads</groupId>
             <artifactId>mopub-sdk</artifactId>
@@ -29,10 +30,17 @@
             <type>jar</type>
         </dependency>
 
+        <dependency>
+            <groupId>com.android.support</groupId>
+            <artifactId>support-v4</artifactId>
+            <version>19.1.0</version>
+            <type>jar</type>
+        </dependency>
+
         <dependency>
             <groupId>com.google.android.gms</groupId>
             <artifactId>play-services</artifactId>
-            <version>5.0.77</version>
+            <version>5.2.08</version>
             <type>aar</type>
         </dependency>
 
@@ -74,7 +82,6 @@
             <scope>test</scope>
         </dependency>
 
-        <!--android & robolectric-->
         <dependency>
             <groupId>org.robolectric</groupId>
             <artifactId>robolectric</artifactId>
@@ -82,8 +89,7 @@
             <scope>test</scope>
         </dependency>
 
-        <dependency>
-            <groupId>com.google.android</groupId>
+        <dependency> <groupId>com.google.android</groupId>
             <artifactId>android</artifactId>
             <version>4.1.2</version>
             <scope>provided</scope>
diff --git a/mopub-sample/proguard.cfg b/mopub-sample/proguard.cfg
index ebae2b03..c1f97c67 100644
--- a/mopub-sample/proguard.cfg
+++ b/mopub-sample/proguard.cfg
@@ -1,40 +1,18 @@
--optimizationpasses 5
--dontusemixedcaseclassnames
--dontskipnonpubliclibraryclasses
--dontpreverify
--verbose
--optimizations !code/simplification/arithmetic,!field/*,!class/merging/*
+# MoPub Proguard Config
+# NOTE: You should also include the Android Proguard config found with the build tools:
+# $ANDROID_HOME/tools/proguard/proguard-android.txt
 
--keep public class * extends android.app.Activity
--keep public class * extends android.app.Application
--keep public class * extends android.app.Service
--keep public class * extends android.content.BroadcastReceiver
--keep public class * extends android.content.ContentProvider
--keep public class * extends android.app.backup.BackupAgentHelper
--keep public class * extends android.preference.Preference
--keep public class com.android.vending.licensing.ILicensingService
+# Keep public classes and methods.
+-keepclassmembers class com.mopub.** { public *; }
+-keep public class com.mopub.**
+-keep public class android.webkit.JavascriptInterface {}
 
--keepclasseswithmembernames class * {
-    native <methods>;
-}
+# Explicitly keep any custom event classes in any package.
+-keep class * extends com.mopub.mobileads.CustomEventBanner {}
+-keep class * extends com.mopub.mobileads.CustomEventInterstitial {}
+-keep class * extends com.mopub.nativeads.CustomEventNative {}
 
--keepclasseswithmembernames class * {
-    public <init>(android.content.Context, android.util.AttributeSet);
-}
+# Support for Android Advertiser ID.
+-keep class com.google.android.gms.common.GooglePlayServicesUtil {*;}
+-keep class com.google.android.gms.ads.identifier.AdvertisingIdClient {*;}
 
--keepclasseswithmembernames class * {
-    public <init>(android.content.Context, android.util.AttributeSet, int);
-}
-
--keepclassmembers enum * {
-    public static **[] values();
-    public static ** valueOf(java.lang.String);
-}
-
--keep class * implements android.os.Parcelable {
-    public static final android.os.Parcelable$Creator *;
-}
-
--keep class com.chartboost.sdk.** {
-    *;
-}
diff --git a/mopub-sample/res/layout/about.xml b/mopub-sample/res/layout/about.xml
deleted file mode 100644
index 1bb51563..00000000
--- a/mopub-sample/res/layout/about.xml
+++ /dev/null
@@ -1,40 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-	android:orientation="vertical"
-	android:layout_width="fill_parent"
-	android:layout_height="fill_parent">
-
-<ImageView
-	android:layout_width="fill_parent"
-	android:layout_height="wrap_content"
-	android:gravity="center_horizontal"
-	android:src="@drawable/logo"
-	android:paddingTop="50dp"/>
-
-<RelativeLayout
-	android:id="@+id/toplayout"
-	android:orientation="vertical"
-	android:layout_width="fill_parent"
-	android:layout_height="fill_parent">
-
-	<Button
-		android:id="@+id/opensite"
-		android:layout_width="wrap_content"
-		android:layout_height="wrap_content"
-		android:layout_alignParentBottom="true"
-		android:layout_centerHorizontal="true"
-		android:text="www.mopub.com" />
-
-	<TextView
-		android:layout_width="wrap_content"
-		android:layout_height="wrap_content"
-		android:layout_above="@id/opensite"
-		android:gravity="center_horizontal"
-		android:paddingBottom="20dp"
-		android:textSize = "17sp"
-		android:layout_centerHorizontal="true"
-		android:text="This app shows various ways to integrate ads served by MoPub into your application." />
-
-</RelativeLayout>
-
-</LinearLayout>
diff --git a/mopub-sample/res/layout/ad_config_dialog.xml b/mopub-sample/res/layout/ad_config_dialog.xml
new file mode 100644
index 00000000..dc2c304b
--- /dev/null
+++ b/mopub-sample/res/layout/ad_config_dialog.xml
@@ -0,0 +1,71 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:layout_width="match_parent"
+              android:layout_height="match_parent"
+              android:orientation="vertical"
+              android:padding="@dimen/sample_text_size">
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_marginBottom="@dimen/sample_text_size"
+        android:gravity="center_vertical"
+        android:orientation="horizontal">
+
+        <TextView
+            android:layout_width="80sp"
+            android:layout_height="wrap_content"
+            android:text="@string/ad_type"
+            android:textSize="@dimen/sample_text_size"/>
+
+        <Spinner
+            android:id="@+id/add_ad_unit_type"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="1"/>
+    </LinearLayout>
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_marginBottom="@dimen/sample_text_size"
+        android:orientation="horizontal">
+
+        <TextView
+            android:layout_width="80sp"
+            android:layout_height="wrap_content"
+            android:text="@string/ad_unit_id"
+            android:textSize="@dimen/sample_text_size"/>
+
+        <EditText
+            android:id="@+id/add_ad_unit_id"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="1"
+            android:hint="@string/ad_unit_hint"/>
+
+    </LinearLayout>
+
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_marginBottom="@dimen/sample_text_size"
+        android:orientation="horizontal">
+
+        <TextView
+            android:layout_width="80sp"
+            android:layout_height="wrap_content"
+            android:text="@string/ad_unit_name"
+            android:textSize="@dimen/sample_text_size"/>
+
+        <EditText
+            android:id="@+id/add_ad_unit_description"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="1"
+            android:hint="@string/ad_unit_name_hint"/>
+    </LinearLayout>
+
+</LinearLayout>
diff --git a/mopub-sample/res/layout/ad_configuration_list_item.xml b/mopub-sample/res/layout/ad_configuration_list_item.xml
new file mode 100644
index 00000000..1d12f082
--- /dev/null
+++ b/mopub-sample/res/layout/ad_configuration_list_item.xml
@@ -0,0 +1,54 @@
+<LinearLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:orientation="vertical"
+    android:paddingBottom="8dp" >
+
+    <TextView
+        android:id="@+id/separator"
+        style="?android:attr/listSeparatorTextViewStyle"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content" />
+
+    <RelativeLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content">
+
+        <TextView
+            android:id="@+id/banner_description"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_alignParentTop="true"
+            android:paddingLeft="8dp"
+            android:paddingRight="8dp"
+            android:paddingTop="8dp"
+            android:singleLine="true"
+            android:textColor="?android:attr/textColorPrimary"
+            android:textSize="16sp"
+            android:textStyle="bold" />
+
+        <TextView
+            android:id="@+id/banner_ad_unit_id"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_below="@id/banner_description"
+            android:layout_marginTop="8dp"
+            android:paddingLeft="8dp"
+            android:paddingRight="8dp"
+            android:singleLine="true"
+            android:textColor="?android:attr/textColorSecondary"
+            android:textSize="14sp"
+            android:textStyle="normal" />
+
+        <ImageView
+            android:id="@+id/banner_delete"
+            android:layout_width="48dp"
+            android:layout_height="48dp"
+            android:layout_alignParentRight="true"
+            android:scaleType="centerCrop"
+            android:src="@android:drawable/ic_menu_delete"
+            />
+
+    </RelativeLayout>
+</LinearLayout>
diff --git a/mopub-sample/res/layout/ad_unit_list_fragment.xml b/mopub-sample/res/layout/ad_unit_list_fragment.xml
new file mode 100644
index 00000000..22ac358e
--- /dev/null
+++ b/mopub-sample/res/layout/ad_unit_list_fragment.xml
@@ -0,0 +1,30 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:orientation="vertical"
+              android:layout_width="match_parent"
+              android:layout_height="match_parent"
+              android:paddingBottom="15dp">
+
+    <ListView
+        android:id="@android:id/list"
+        android:layout_width="match_parent"
+        android:layout_height="0dp"
+        android:layout_weight="1"
+        android:layout_marginBottom="10dp"/>
+
+    <Button
+        android:id="@+id/add_ad_unit_button"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_gravity="center_horizontal"
+        android:text="@string/add_ad_unit_button"
+        />
+
+    <TextView
+        android:id="@+id/version_code"
+        android:layout_gravity="center_horizontal"
+        android:textSize="@dimen/detail_text_size"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"/>
+</LinearLayout>
diff --git a/mopub-sample/res/layout/banner_detail_fragment.xml b/mopub-sample/res/layout/banner_detail_fragment.xml
new file mode 100644
index 00000000..b910e373
--- /dev/null
+++ b/mopub-sample/res/layout/banner_detail_fragment.xml
@@ -0,0 +1,62 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:orientation="vertical"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent" >
+
+    <TextView
+        android:id="@+id/description"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:paddingLeft="8dp"
+        android:paddingRight="8dp"
+        android:paddingTop="8dp"
+        android:singleLine="true"
+        android:textColor="?android:attr/textColorPrimary"
+        android:textSize="16sp"
+        android:textStyle="bold" />
+
+    <TextView
+        android:id="@+id/ad_unit_id"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:paddingLeft="8dp"
+        android:paddingRight="8dp"
+        android:singleLine="true"
+        android:textColor="?android:attr/textColorSecondary"
+        android:textSize="14sp"
+        android:textStyle="normal" />
+
+    <LinearLayout
+        android:orientation="horizontal"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content">
+
+        <EditText
+            android:id="@+id/keywords_field"
+            android:hint="@string/keywords"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="3"
+            android:inputType="text|textFilter|textShortMessage"
+            android:imeOptions="actionDone"
+            android:singleLine="true" />
+
+        <Button
+            android:id="@+id/load_button"
+            android:text="@string/load_ad"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="1"
+            android:singleLine="true"/>
+    </LinearLayout>
+
+    <com.mopub.mobileads.MoPubView
+        android:id="@+id/banner_mopubview"
+        android:layout_width="320dp"
+        android:layout_height="50dp"
+        android:layout_gravity="center_horizontal"
+        android:layout_marginTop="10dp">
+    </com.mopub.mobileads.MoPubView>
+</LinearLayout>
diff --git a/mopub-sample/res/layout/banners.xml b/mopub-sample/res/layout/banners.xml
deleted file mode 100644
index 7efb2e83..00000000
--- a/mopub-sample/res/layout/banners.xml
+++ /dev/null
@@ -1,81 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
-     android:layout_width="fill_parent"
-     android:layout_height="fill_parent">
-
-    <LinearLayout
-        android:orientation="vertical"
-        android:layout_width="fill_parent"
-        android:layout_height="wrap_content">
-
-        <LinearLayout
-            android:layout_width="fill_parent"
-            android:layout_height="wrap_content"
-            android:orientation="horizontal">
-
-            <EditText
-                android:id="@+id/banner_adunit_field"
-                android:hint="Ad Unit ID for banner below"
-                android:layout_width="0dp"
-                android:layout_height="wrap_content"
-                android:layout_weight="7"
-                android:inputType="text|textFilter|textShortMessage"
-                android:imeOptions="actionDone"
-                android:singleLine="true" />
-
-            <Button
-                android:id="@+id/banner_load_button"
-                android:text="Load"
-                android:layout_width="wrap_content"
-                android:layout_height="wrap_content"
-                android:layout_weight="1" />
-        </LinearLayout>
-
-        <com.mopub.mobileads.MoPubView
-            android:id="@+id/banner_view"
-            android:layout_width="fill_parent"
-            android:layout_height="50dp"
-            android:background="@drawable/spacer" />
-
-        <LinearLayout
-            android:layout_width="fill_parent"
-            android:layout_height="wrap_content"
-            android:orientation="horizontal"
-            android:layout_marginTop="25dp">
-
-            <EditText
-                android:id="@+id/mrect_adunit_field"
-                android:hint="Ad Unit ID for mrect below"
-                android:layout_width="0dp"
-                android:layout_height="wrap_content"
-                android:layout_weight="7"
-                android:inputType="text|textFilter|textShortMessage"
-                android:imeOptions="actionDone"
-                android:singleLine="true" />
-
-            <Button
-                android:id="@+id/mrect_load_button"
-                android:text="Load"
-                android:layout_width="wrap_content"
-                android:layout_height="wrap_content"
-                android:layout_weight="1" />
-        </LinearLayout>
-
-        <com.mopub.mobileads.MoPubView
-            android:id="@+id/mrect_view"
-            android:layout_width="300dp"
-            android:layout_height="250dp"
-            android:layout_gravity="center_horizontal"
-            android:background="@drawable/spacer" />
-
-        <EditText
-            android:id="@+id/keywords_field"
-            android:hint="Keywords, try 'coffee'"
-            android:layout_width="fill_parent"
-            android:layout_height="wrap_content"
-            android:inputType="text|textFilter|textShortMessage"
-            android:imeOptions="actionDone"
-            android:singleLine="true"
-            android:layout_marginTop="25dp" />
-    </LinearLayout>
-</ScrollView>
diff --git a/mopub-sample/res/layout/empty_ad_row.xml b/mopub-sample/res/layout/empty_ad_row.xml
deleted file mode 100644
index 2266e491..00000000
--- a/mopub-sample/res/layout/empty_ad_row.xml
+++ /dev/null
@@ -1,7 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-              android:orientation="vertical"
-              android:layout_width="match_parent"
-              android:layout_height="0dp">
-</LinearLayout>
diff --git a/mopub-sample/res/layout/interstitial_detail_fragment.xml b/mopub-sample/res/layout/interstitial_detail_fragment.xml
new file mode 100644
index 00000000..37aebae5
--- /dev/null
+++ b/mopub-sample/res/layout/interstitial_detail_fragment.xml
@@ -0,0 +1,59 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:orientation="vertical"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+    <TextView
+        android:id="@+id/description"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:paddingLeft="8dp"
+        android:paddingRight="8dp"
+        android:paddingTop="8dp"
+        android:singleLine="true"
+        android:textColor="?android:attr/textColorPrimary"
+        android:textSize="16sp"
+        android:textStyle="bold" />
+
+    <TextView
+        android:id="@+id/ad_unit_id"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:paddingLeft="8dp"
+        android:paddingRight="8dp"
+        android:singleLine="true"
+        android:textColor="?android:attr/textColorSecondary"
+        android:textSize="14sp"
+        android:textStyle="normal" />
+
+    <EditText
+        android:id="@+id/keywords_field"
+        android:hint="@string/keywords"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:inputType="text|textFilter|textShortMessage"
+        android:imeOptions="actionDone"
+        android:singleLine="true" />
+
+    <LinearLayout
+        android:orientation="horizontal"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content">
+
+        <Button
+            android:id="@+id/load_button"
+            android:text="@string/load_ad"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="1" />
+
+        <Button
+            android:id="@+id/interstitial_show_button"
+            android:text="@string/show_ad"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="1"/>
+    </LinearLayout>
+</LinearLayout>
diff --git a/mopub-sample/res/layout/interstitials.xml b/mopub-sample/res/layout/interstitials.xml
deleted file mode 100644
index 0a70c5c3..00000000
--- a/mopub-sample/res/layout/interstitials.xml
+++ /dev/null
@@ -1,40 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="fill_parent"
-    android:layout_height="fill_parent">
-
-    <LinearLayout
-        android:orientation="vertical"
-        android:layout_width="fill_parent"
-        android:layout_height="wrap_content">
-
-        <EditText
-            android:id="@+id/interstitials_edit_text_interstitial"
-            android:hint="Ad Unit ID for interstitial"
-            android:layout_width="fill_parent"
-            android:layout_height="wrap_content"
-            android:inputType="text|textFilter|textShortMessage"
-            android:imeOptions="actionDone"
-            android:singleLine="true" />
-
-        <LinearLayout
-            android:orientation="horizontal"
-            android:layout_width="fill_parent"
-            android:layout_height="wrap_content">
-
-            <Button
-                android:id="@+id/interstitials_load_interstitial"
-                android:text="Load Interstitial"
-                android:layout_width="fill_parent"
-                android:layout_height="wrap_content"
-                android:layout_weight="1"/>
-
-            <Button
-                android:id="@+id/interstitials_show_interstitial"
-                android:text="Show Interstitial"
-                android:layout_width="fill_parent"
-                android:layout_height="wrap_content"
-                android:layout_weight="1"/>
-        </LinearLayout>
-    </LinearLayout>
-</ScrollView>
diff --git a/mopub-sample/res/layout/main.xml b/mopub-sample/res/layout/main.xml
index 32870ba9..682a1cc8 100644
--- a/mopub-sample/res/layout/main.xml
+++ b/mopub-sample/res/layout/main.xml
@@ -1,20 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
-<android.support.v4.app.FragmentTabHost xmlns:android="http://schemas.android.com/apk/res/android"
-    android:id="@+id/tabhost"
-    android:layout_width="fill_parent"
-    android:layout_height="fill_parent">
-    <LinearLayout
-        android:orientation="vertical"
-        android:layout_width="fill_parent"
-        android:layout_height="fill_parent">
-        <TabWidget
-            android:id="@+id/tabs"
-            android:layout_width="fill_parent"
-            android:layout_height="wrap_content" />
-        <FrameLayout
-            android:id="@+id/tabcontent"
-            android:layout_marginTop="64dp"
-            android:layout_width="fill_parent"
-            android:layout_height="fill_parent"/>
-    </LinearLayout>
-</android.support.v4.app.FragmentTabHost>
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/fragment_container"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+</FrameLayout>
diff --git a/mopub-sample/res/layout/mrect_detail_fragment.xml b/mopub-sample/res/layout/mrect_detail_fragment.xml
new file mode 100644
index 00000000..15167ce5
--- /dev/null
+++ b/mopub-sample/res/layout/mrect_detail_fragment.xml
@@ -0,0 +1,61 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:orientation="vertical"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+    <TextView
+        android:id="@+id/description"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:paddingLeft="8dp"
+        android:paddingRight="8dp"
+        android:paddingTop="8dp"
+        android:singleLine="true"
+        android:textColor="?android:attr/textColorPrimary"
+        android:textSize="16sp"
+        android:textStyle="bold" />
+
+    <TextView
+        android:id="@+id/ad_unit_id"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:paddingLeft="8dp"
+        android:paddingRight="8dp"
+        android:singleLine="true"
+        android:textColor="?android:attr/textColorSecondary"
+        android:textSize="14sp"
+        android:textStyle="normal" />
+
+    <LinearLayout
+        android:orientation="horizontal"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content">
+
+        <EditText
+            android:id="@+id/keywords_field"
+            android:hint="@string/keywords"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="3"
+            android:inputType="text|textFilter|textShortMessage"
+            android:imeOptions="actionDone"
+            android:singleLine="true" />
+
+        <Button
+            android:id="@+id/load_button"
+            android:text="@string/load_ad"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="1" />
+    </LinearLayout>
+
+    <com.mopub.mobileads.MoPubView
+        android:id="@+id/mrect_mopubview"
+        android:layout_width="300dp"
+        android:layout_height="250dp"
+        android:layout_gravity="center_horizontal"
+        android:paddingTop="10dp">
+    </com.mopub.mobileads.MoPubView>
+</LinearLayout>
diff --git a/mopub-sample/res/layout/native_ad_row.xml b/mopub-sample/res/layout/native_ad_row.xml
index 663885a5..33173d89 100644
--- a/mopub-sample/res/layout/native_ad_row.xml
+++ b/mopub-sample/res/layout/native_ad_row.xml
@@ -1,7 +1,7 @@
 <RelativeLayout
     xmlns:android="http://schemas.android.com/apk/res/android"
     android:id="@+id/native_outer_view"
-    android:layout_width="fill_parent"
+    android:layout_width="match_parent"
     android:layout_height="wrap_content"
     android:background="@android:color/white">
     <ImageView android:id="@+id/native_icon_image"
@@ -36,27 +36,29 @@
 
     <ImageView android:id="@+id/native_main_image"
         android:layout_width="match_parent"
-        android:layout_height="wrap_content"
+        android:layout_height="@dimen/native_main_image_height"
         android:adjustViewBounds="true"
         android:layout_marginTop="10dp"
+        android:layout_marginLeft="10dp"
+        android:layout_marginRight="10dp"
         android:layout_below="@+id/native_text"
-        android:layout_alignParentLeft="true" />
+        android:layout_alignParentLeft="true"
+        android:contentDescription="@string/native_main_image" 
+        android:scaleType="centerCrop"/>
 
     <Button
         android:id="@+id/native_cta"
         android:layout_width="wrap_content"
         android:layout_height="35dp"
-        android:text="Learn More"
+        android:text="@string/learn_more"
         android:textColor="@android:color/black"
-        android:onClick=""
         android:textStyle="bold"
         android:layout_marginRight="10dp"
         android:layout_marginTop="10dp"
         android:layout_below="@+id/native_main_image"
-        android:textSize="12dp"
+        android:textSize="12sp"
         android:layout_alignParentRight="true"
         android:clickable="true"
         android:paddingBottom="10dp" />
 
 </RelativeLayout>
-
diff --git a/mopub-sample/res/layout/native_gallery_content.xml b/mopub-sample/res/layout/native_gallery_content.xml
new file mode 100644
index 00000000..7bf2d7b4
--- /dev/null
+++ b/mopub-sample/res/layout/native_gallery_content.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<TextView xmlns:android="http://schemas.android.com/apk/res/android"
+          android:id="@+id/native_gallery_content_text"
+          android:layout_width="match_parent"
+          android:layout_height="wrap_content"
+          android:layout_gravity="center"
+          android:padding="16dp"/>
+
diff --git a/mopub-sample/res/layout/native_gallery_fragment.xml b/mopub-sample/res/layout/native_gallery_fragment.xml
new file mode 100644
index 00000000..530ab4bc
--- /dev/null
+++ b/mopub-sample/res/layout/native_gallery_fragment.xml
@@ -0,0 +1,69 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:layout_width="match_parent"
+              android:layout_height="match_parent"
+              android:orientation="vertical">
+
+    <TextView
+        android:id="@+id/description"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:paddingLeft="8dp"
+        android:paddingRight="8dp"
+        android:paddingTop="8dp"
+        android:singleLine="true"
+        android:textColor="?android:attr/textColorPrimary"
+        android:textSize="16sp"
+        android:textStyle="bold"/>
+
+    <TextView
+        android:id="@+id/ad_unit_id"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:paddingLeft="8dp"
+        android:paddingRight="8dp"
+        android:singleLine="true"
+        android:textColor="?android:attr/textColorSecondary"
+        android:textSize="14sp"
+        android:textStyle="normal"/>
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="horizontal">
+
+        <EditText
+            android:id="@+id/keywords_field"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="3"
+            android:hint="@string/keywords"
+            android:imeOptions="actionDone"
+            android:inputType="text|textFilter|textShortMessage"
+            android:singleLine="true"/>
+
+        <Button
+            android:id="@+id/load_button"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="1"
+            android:text="@string/load_ad"/>
+    </LinearLayout>
+
+    <FrameLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content">
+
+        <TextView
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
+            android:background="#aa333333"
+            android:gravity="center"
+            android:text="@string/swipe_text"/>
+
+        <android.support.v4.view.ViewPager
+            android:id="@+id/gallery_pager"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"/>
+    </FrameLayout>
+</LinearLayout>
diff --git a/mopub-sample/res/layout/native_list_view_fragment.xml b/mopub-sample/res/layout/native_list_view_fragment.xml
new file mode 100644
index 00000000..ff83a0ee
--- /dev/null
+++ b/mopub-sample/res/layout/native_list_view_fragment.xml
@@ -0,0 +1,58 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:layout_width="match_parent"
+              android:layout_height="match_parent"
+              android:orientation="vertical">
+
+    <TextView
+        android:id="@+id/description"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:paddingLeft="8dp"
+        android:paddingRight="8dp"
+        android:paddingTop="8dp"
+        android:singleLine="true"
+        android:textColor="?android:attr/textColorPrimary"
+        android:textSize="16sp"
+        android:textStyle="bold"/>
+
+    <TextView
+        android:id="@+id/ad_unit_id"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:paddingLeft="8dp"
+        android:paddingRight="8dp"
+        android:singleLine="true"
+        android:textColor="?android:attr/textColorSecondary"
+        android:textSize="14sp"
+        android:textStyle="normal"/>
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="horizontal">
+
+        <EditText
+            android:id="@+id/keywords_field"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="3"
+            android:hint="@string/keywords"
+            android:imeOptions="actionDone"
+            android:inputType="text|textFilter|textShortMessage"
+            android:singleLine="true"/>
+
+        <Button
+            android:id="@+id/load_button"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="1"
+            android:text="@string/load_ad"/>
+    </LinearLayout>
+
+    <ListView
+        android:id="@+id/native_list_view"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:padding="5dp"/>
+</LinearLayout>
diff --git a/mopub-sample/res/layout/nativetab.xml b/mopub-sample/res/layout/nativetab.xml
deleted file mode 100644
index 496b30f4..00000000
--- a/mopub-sample/res/layout/nativetab.xml
+++ /dev/null
@@ -1,37 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:orientation="vertical" android:layout_width="match_parent"
-    android:layout_height="match_parent">
-
-    <LinearLayout
-        android:layout_width="fill_parent"
-        android:layout_height="wrap_content"
-        android:orientation="horizontal">
-
-        <EditText
-            android:id="@+id/native_adunit_field"
-            android:hint="Ad Unit ID for native ads"
-            android:layout_width="0dp"
-            android:layout_height="wrap_content"
-            android:layout_weight="7"
-            android:inputType="text|textFilter|textShortMessage"
-            android:imeOptions="actionDone"
-            android:singleLine="true" />
-
-        <Button
-            android:id="@+id/native_load_button"
-            android:text="Load"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:layout_weight="1" />
-
-
-    </LinearLayout>
-
-    <ListView
-        android:id="@+id/list_view"
-        android:layout_width="fill_parent"
-        android:layout_height="wrap_content"
-        android:padding="5dp"/>
-</LinearLayout>
diff --git a/mopub-sample/res/layout/text_row.xml b/mopub-sample/res/layout/text_row.xml
deleted file mode 100644
index 373f0ad2..00000000
--- a/mopub-sample/res/layout/text_row.xml
+++ /dev/null
@@ -1,9 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<TextView
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    android:id="@+id/my_text_view"
-    android:layout_width="match_parent"
-    android:layout_height="75dp"
-    android:gravity="center_vertical"
-    android:padding="10dp"
-    />
\ No newline at end of file
diff --git a/mopub-sample/res/values-sw400dp/dimens.xml b/mopub-sample/res/values-sw400dp/dimens.xml
new file mode 100644
index 00000000..76535326
--- /dev/null
+++ b/mopub-sample/res/values-sw400dp/dimens.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <dimen name="native_main_image_height">200dp</dimen>
+</resources>
\ No newline at end of file
diff --git a/mopub-sample/res/values-sw600dp/dimens.xml b/mopub-sample/res/values-sw600dp/dimens.xml
new file mode 100644
index 00000000..512868f9
--- /dev/null
+++ b/mopub-sample/res/values-sw600dp/dimens.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <dimen name="native_main_image_height">300dp</dimen>
+</resources>
\ No newline at end of file
diff --git a/mopub-sample/res/values-sw800dp/dimens.xml b/mopub-sample/res/values-sw800dp/dimens.xml
new file mode 100644
index 00000000..9980b5c3
--- /dev/null
+++ b/mopub-sample/res/values-sw800dp/dimens.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <dimen name="native_main_image_height">400dp</dimen>
+</resources>
\ No newline at end of file
diff --git a/mopub-sample/res/values/dimens.xml b/mopub-sample/res/values/dimens.xml
new file mode 100644
index 00000000..02259949
--- /dev/null
+++ b/mopub-sample/res/values/dimens.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <dimen name="sample_text_size">16sp</dimen>
+    <dimen name="spinner_text_size">20sp</dimen>
+    <dimen name="detail_text_size">10sp</dimen>
+    <dimen name="title_size">24sp</dimen>
+    <dimen name="native_main_image_height">200dp</dimen>
+</resources>
\ No newline at end of file
diff --git a/mopub-sample/res/values/strings.xml b/mopub-sample/res/values/strings.xml
index 8a5847b9..6d5db0d9 100644
--- a/mopub-sample/res/values/strings.xml
+++ b/mopub-sample/res/values/strings.xml
@@ -1,5 +1,23 @@
 <?xml version="1.0" encoding="utf-8"?>
 <resources>
-    <string name="hello">Hello World, SimpleAdsDemo!</string>
-    <string name="app_name">SimpleAdsDemo</string>
+    <string name="app_name">MoPub Sample App</string>
+    <string name="keywords">Keywords (optional)</string>
+    <string name="load_ad">Load Ad</string>
+    <string name="show_ad">Show Ad</string>
+    <string name="native_icon_image">native_icon_image</string>
+    <string name="native_main_image">native_main_image</string>
+    <string name="learn_more">Learn More</string>
+    <string name="save">Save Ad Unit</string>
+    <string name="ad_unit_id">Ad Unit Id:</string>
+    <string name="ad_unit_hint">Enter Ad Unit Id</string>
+    <string name="ad_unit_name">Name:</string>
+    <string name="ad_unit_name_hint">Enter Name</string>
+    <string name="ad_type">Ad Type:</string>
+    <string name="add_ad_unit_title">Add an Ad Unit</string>
+    <string name="add_ad_unit_button">Add an Ad Unit</string>
+    <string name="ad_unit_id_banner">b195f8dd8ded45fe847ad89ed1d016da</string>
+    <string name="ad_unit_id_mrect">252412d5e9364a05ab77d9396346d73d</string>
+    <string name="ad_unit_id_interstitial">24534e1901884e398f1253216226017e</string>
+    <string name="ad_unit_id_native">11a17b188668469fb0412708c3d16813</string>
+    <string name="swipe_text"><![CDATA[< Swipe Left & Right >]]></string>
 </resources>
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/AboutFragment.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/AboutFragment.java
deleted file mode 100644
index 43cae373..00000000
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/AboutFragment.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright (c) 2010-2013, MoPub Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *  Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- *  Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- *  Neither the name of 'MoPub Inc.' nor the names of its contributors
- *   may be used to endorse or promote products derived from this software
- *   without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package com.mopub.simpleadsdemo;
-
-import android.content.Intent;
-import android.net.Uri;
-import android.os.Bundle;
-import android.support.v4.app.Fragment;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.View.OnClickListener;
-import android.view.ViewGroup;
-import android.widget.Button;
-
-public class AboutFragment extends Fragment {
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-    }
-    
-    
-    public View onCreateView(LayoutInflater inflater, ViewGroup container,
-            Bundle savedInstanceState) {
-    	
-        View aboutTabView = inflater.inflate(R.layout.about, container, false);
-
-        Button mOpenSiteButton = (Button) aboutTabView.findViewById(R.id.opensite);
-        mOpenSiteButton.setOnClickListener(new OnClickListener() {
-            public void onClick(View v) {
-                startActivity(new Intent(android.content.Intent.ACTION_VIEW,
-                        Uri.parse("http://www.mopub.com/")));
-            }
-        });
-        
-        return aboutTabView;
-    }
-}
\ No newline at end of file
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/AdUnitDataSource.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/AdUnitDataSource.java
new file mode 100644
index 00000000..7dc619c3
--- /dev/null
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/AdUnitDataSource.java
@@ -0,0 +1,96 @@
+package com.mopub.simpleadsdemo;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+
+import com.mopub.common.util.MoPubLog;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static com.mopub.simpleadsdemo.MoPubSQLiteHelper.COLUMN_AD_TYPE;
+import static com.mopub.simpleadsdemo.MoPubSQLiteHelper.COLUMN_AD_UNIT_ID;
+import static com.mopub.simpleadsdemo.MoPubSQLiteHelper.COLUMN_DESCRIPTION;
+import static com.mopub.simpleadsdemo.MoPubSQLiteHelper.COLUMN_ID;
+import static com.mopub.simpleadsdemo.MoPubSQLiteHelper.COLUMN_USER_GENERATED;
+import static com.mopub.simpleadsdemo.MoPubSQLiteHelper.TABLE_AD_CONFIGURATIONS;
+import static com.mopub.simpleadsdemo.MoPubSampleAdUnit.AdType;
+
+class AdUnitDataSource {
+    private MoPubSQLiteHelper mDatabaseHelper;
+    private String[] mAllColumns = {
+            COLUMN_ID,
+            COLUMN_AD_UNIT_ID,
+            COLUMN_DESCRIPTION,
+            COLUMN_USER_GENERATED,
+            COLUMN_AD_TYPE
+    };
+
+    AdUnitDataSource(final Context context) {
+        mDatabaseHelper = new MoPubSQLiteHelper(context);
+    }
+
+    MoPubSampleAdUnit createSampleAdUnit(final MoPubSampleAdUnit sampleAdUnit) {
+        final ContentValues values = new ContentValues();
+        values.put(COLUMN_AD_UNIT_ID, sampleAdUnit.getAdUnitId());
+        values.put(COLUMN_DESCRIPTION, sampleAdUnit.getDescription());
+        values.put(COLUMN_USER_GENERATED, 1);
+        values.put(COLUMN_AD_TYPE, sampleAdUnit.getFragmentClassName());
+        final SQLiteDatabase database = mDatabaseHelper.getWritableDatabase();
+        final long insertId = database.insert(TABLE_AD_CONFIGURATIONS, null, values);
+        final Cursor cursor = database.query(TABLE_AD_CONFIGURATIONS, mAllColumns,
+                COLUMN_ID + " = " + insertId, null, null, null, null);
+        cursor.moveToFirst();
+        final MoPubSampleAdUnit newAdConfiguration = cursorToAdConfiguration(cursor);
+        cursor.close();
+        database.close();
+        return newAdConfiguration;
+    }
+
+    void deleteSampleAdUnit(final MoPubSampleAdUnit adConfiguration) {
+        final long id = adConfiguration.getId();
+        SQLiteDatabase database = mDatabaseHelper.getWritableDatabase();
+        database.delete(TABLE_AD_CONFIGURATIONS, COLUMN_ID + " = " + id, null);
+        MoPubLog.d("Ad Configuration deleted with id: " + id);
+        database.close();
+    }
+
+    List<MoPubSampleAdUnit> getAllAdUnits() {
+        final List<MoPubSampleAdUnit> adConfigurations =
+                new ArrayList<MoPubSampleAdUnit>();
+        SQLiteDatabase database = mDatabaseHelper.getReadableDatabase();
+        final Cursor cursor = database.query(TABLE_AD_CONFIGURATIONS,
+                mAllColumns, null, null, null, null, null);
+        cursor.moveToFirst();
+
+        while (!cursor.isAfterLast()) {
+            final MoPubSampleAdUnit adConfiguration = cursorToAdConfiguration(cursor);
+            adConfigurations.add(adConfiguration);
+            cursor.moveToNext();
+        }
+
+        cursor.close();
+        database.close();
+        return adConfigurations;
+    }
+
+    private MoPubSampleAdUnit cursorToAdConfiguration(final Cursor cursor) {
+        final long id = cursor.getLong(0);
+        final String adUnitId = cursor.getString(1);
+        final String description = cursor.getString(2);
+        final int userGenerated = cursor.getInt(3);
+        final AdType adType = AdType.fromFragmentClassName(cursor.getString(4));
+
+        if (adType == null) {
+            return null;
+        }
+
+        return new MoPubSampleAdUnit.Builder(adUnitId, adType)
+                .description(description)
+                .isUserDefined(userGenerated == 1)
+                .id(id)
+                .build();
+    }
+}
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/BannerDetailFragment.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/BannerDetailFragment.java
new file mode 100644
index 00000000..a02dd1a1
--- /dev/null
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/BannerDetailFragment.java
@@ -0,0 +1,87 @@
+package com.mopub.simpleadsdemo;
+
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+
+import com.mopub.mobileads.MoPubErrorCode;
+import com.mopub.mobileads.MoPubView;
+
+import static com.mopub.mobileads.MoPubView.BannerAdListener;
+import static com.mopub.simpleadsdemo.Utils.hideSoftKeyboard;
+import static com.mopub.simpleadsdemo.Utils.logToast;
+
+public class BannerDetailFragment extends Fragment implements BannerAdListener {
+    private MoPubView mMoPubView;
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        super.onCreateView(inflater, container, savedInstanceState);
+        final MoPubSampleAdUnit adConfiguration =
+                MoPubSampleAdUnit.fromBundle(getArguments());
+        final View view = inflater.inflate(R.layout.banner_detail_fragment, container, false);
+        final DetailFragmentViewHolder views = DetailFragmentViewHolder.fromView(view);
+        mMoPubView = (MoPubView) view.findViewById(R.id.banner_mopubview);
+        hideSoftKeyboard(views.mKeywordsField);
+
+        final String adUnitId = adConfiguration.getAdUnitId();
+        views.mDescriptionView.setText(adConfiguration.getDescription());
+        views.mAdUnitIdView.setText(adUnitId);
+        views.mLoadButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                final String keywords = views.mKeywordsField.getText().toString();
+                loadMoPubView(adUnitId, keywords);
+            }
+        });
+        mMoPubView.setBannerAdListener(this);
+        loadMoPubView(adUnitId, null);
+
+        return view;
+    }
+
+    @Override
+    public void onDestroyView() {
+        super.onDestroyView();
+
+        if (mMoPubView != null) {
+            mMoPubView.destroy();
+            mMoPubView = null;
+        }
+    }
+
+    private void loadMoPubView(final String adUnitId, final String keywords) {
+        mMoPubView.setAdUnitId(adUnitId);
+        mMoPubView.setKeywords(keywords);
+        mMoPubView.loadAd();
+    }
+
+    // BannerAdListener
+    @Override
+    public void onBannerLoaded(MoPubView banner) {
+        logToast(getActivity(), "Banner loaded.");
+    }
+
+    @Override
+    public void onBannerFailed(MoPubView banner, MoPubErrorCode errorCode) {
+        final String errorMessage = (errorCode != null) ? errorCode.toString() : "";
+        logToast(getActivity(), "Banner failed to load: " + errorMessage);
+    }
+
+    @Override
+    public void onBannerClicked(MoPubView banner) {
+        logToast(getActivity(), "Banner clicked.");
+    }
+
+    @Override
+    public void onBannerExpanded(MoPubView banner) {
+        logToast(getActivity(), "Banner expanded.");
+    }
+
+    @Override
+    public void onBannerCollapsed(MoPubView banner) {
+        logToast(getActivity(), "Banner collapsed.");
+    }
+}
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/BannersFragment.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/BannersFragment.java
deleted file mode 100644
index 2331a02d..00000000
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/BannersFragment.java
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * Copyright (c) 2010-2013, MoPub Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *  Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- *  Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- *  Neither the name of 'MoPub Inc.' nor the names of its contributors
- *   may be used to endorse or promote products derived from this software
- *   without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package com.mopub.simpleadsdemo;
-
-import static com.mopub.simpleadsdemo.Utils.hideSoftKeyboard;
-import static com.mopub.simpleadsdemo.Utils.logToast;
-import static com.mopub.simpleadsdemo.Utils.validateAdUnitId;
-import android.os.Bundle;
-import android.support.v4.app.Fragment;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.View.OnClickListener;
-import android.view.ViewGroup;
-import android.widget.Button;
-import android.widget.EditText;
-
-import com.mopub.mobileads.MoPubErrorCode;
-import com.mopub.mobileads.MoPubView;
-import com.mopub.mobileads.MoPubView.BannerAdListener;
-
-public class BannersFragment extends Fragment implements BannerAdListener {
-    private MoPubView mBannerView;
-    private EditText mBannerAdUnitField;
-
-    private MoPubView mMrectView;
-    private EditText mMrectAdUnitField;
-
-    private EditText mKeywordsField;
-    
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-    }
-    
-    public View onCreateView(LayoutInflater inflater, ViewGroup container,
-            Bundle savedInstanceState) {
-    	
-        OnClickListener fieldFocusListener = new OnClickListener() {
-            public void onClick(View view) {
-            	view.requestFocusFromTouch();
-            }
-        };
-    	
-        View bannerTabView = inflater.inflate(R.layout.banners, container, false);
-        
-        mBannerView = (MoPubView) bannerTabView.findViewById(R.id.banner_view);
-        mBannerAdUnitField = (EditText) bannerTabView.findViewById(R.id.banner_adunit_field);
-        hideSoftKeyboard(mBannerAdUnitField);
-        
-        mBannerAdUnitField.setOnClickListener(fieldFocusListener);
-
-        mMrectView = (MoPubView) bannerTabView.findViewById(R.id.mrect_view);
-        mMrectAdUnitField = (EditText) bannerTabView.findViewById(R.id.mrect_adunit_field);
-        
-        mMrectAdUnitField.setOnClickListener(fieldFocusListener);
-
-        hideSoftKeyboard(mMrectAdUnitField);
-
-        mKeywordsField = (EditText) bannerTabView.findViewById(R.id.keywords_field);
-        hideSoftKeyboard(mKeywordsField);
-
-        Button bannerLoadButton = (Button) bannerTabView.findViewById(R.id.banner_load_button);
-        bannerLoadButton.setOnClickListener(new OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                String adUnitId = mBannerAdUnitField.getText().toString();
-                String keywords = mKeywordsField.getText().toString();
-
-                loadMoPubView(mBannerView, adUnitId, keywords);
-            }
-        });
-
-        Button mrectLoadButton = (Button) bannerTabView.findViewById(R.id.mrect_load_button);
-        mrectLoadButton.setOnClickListener(new OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                String adUnitId = mMrectAdUnitField.getText().toString();
-                String keywords = mKeywordsField.getText().toString();
-
-                loadMoPubView(mMrectView, adUnitId, keywords);
-            }
-        });
-        
-        return bannerTabView;
-    }
-
-    @Override
-	public void onDestroy() {
-        if (mBannerView != null) {
-            mBannerView.destroy();
-        }
-        if (mMrectView != null) {
-            mMrectView.destroy();
-        }
-        super.onDestroy();
-    }
-
-    private void loadMoPubView(MoPubView moPubView, String adUnitId, String keywords) {
-        if (moPubView == null) {
-            logToast(getActivity(), "Unable to inflate MoPubView from xml.");
-            return;
-        }
-
-        try {
-            validateAdUnitId(adUnitId);
-        } catch (IllegalArgumentException exception) {
-            logToast(getActivity(), exception.getMessage());
-            return;
-        }
-
-        moPubView.setBannerAdListener(this);
-        moPubView.setAdUnitId(adUnitId);
-        moPubView.setKeywords(keywords);
-        moPubView.loadAd();
-    }
-
-    /*
-     * MoPubBanner.BannerAdListener implementation
-     */
-    @Override
-    public void onBannerLoaded(MoPubView moPubView) {
-        logToast(getActivity(), "Banner loaded callback.");
-    }
-
-    @Override
-    public void onBannerFailed(MoPubView moPubView, MoPubErrorCode errorCode) {
-        logToast(getActivity(), "Banner failed callback with: " + errorCode.toString());
-    }
-
-    @Override
-    public void onBannerClicked(MoPubView moPubView) {
-        logToast(getActivity(), "Banner clicked callback.");
-    }
-
-    @Override
-    public void onBannerExpanded(MoPubView moPubView) {
-        logToast(getActivity(), "Banner expanded callback.");
-    }
-
-    @Override
-    public void onBannerCollapsed(MoPubView moPubView) {
-        logToast(getActivity(), "Banner collapsed callback.");
-    }
-}
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/DetailFragmentViewHolder.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/DetailFragmentViewHolder.java
new file mode 100644
index 00000000..ca780f7e
--- /dev/null
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/DetailFragmentViewHolder.java
@@ -0,0 +1,31 @@
+package com.mopub.simpleadsdemo;
+
+import android.view.View;
+import android.widget.Button;
+import android.widget.EditText;
+import android.widget.TextView;
+
+class DetailFragmentViewHolder {
+    final TextView mDescriptionView;
+    final Button mLoadButton;
+    final TextView mAdUnitIdView;
+    final EditText mKeywordsField;
+
+    DetailFragmentViewHolder(final TextView descriptionView, final TextView adUnitIdView,
+            final EditText keywordsField, final Button loadButton) {
+        mDescriptionView = descriptionView;
+        mAdUnitIdView = adUnitIdView;
+        mKeywordsField = keywordsField;
+        mLoadButton = loadButton;
+    }
+
+    static DetailFragmentViewHolder fromView(final View view) {
+        final TextView descriptionView = (TextView) view.findViewById(R.id.description);
+        final TextView adUnitIdView = (TextView) view.findViewById(R.id.ad_unit_id);
+        final EditText keywordsField = (EditText) view.findViewById(R.id.keywords_field);
+        final Button loadButton = (Button) view.findViewById(R.id.load_button);
+
+        return new DetailFragmentViewHolder(descriptionView, adUnitIdView,
+                keywordsField, loadButton);
+    }
+}
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/InterstitialDetailFragment.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/InterstitialDetailFragment.java
new file mode 100644
index 00000000..2314e718
--- /dev/null
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/InterstitialDetailFragment.java
@@ -0,0 +1,94 @@
+package com.mopub.simpleadsdemo;
+
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.Button;
+
+import com.mopub.mobileads.MoPubErrorCode;
+import com.mopub.mobileads.MoPubInterstitial;
+
+import static com.mopub.mobileads.MoPubInterstitial.InterstitialAdListener;
+import static com.mopub.simpleadsdemo.Utils.hideSoftKeyboard;
+import static com.mopub.simpleadsdemo.Utils.logToast;
+
+public class InterstitialDetailFragment extends Fragment implements InterstitialAdListener {
+    private MoPubInterstitial mMoPubInterstitial;
+    private Button mShowButton;
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        super.onCreateView(inflater, container, savedInstanceState);
+        final MoPubSampleAdUnit adConfiguration =
+                MoPubSampleAdUnit.fromBundle(getArguments());
+        final View view = inflater.inflate(R.layout.interstitial_detail_fragment, container, false);
+        final DetailFragmentViewHolder views = DetailFragmentViewHolder.fromView(view);
+        hideSoftKeyboard(views.mKeywordsField);
+
+        final String adUnitId = adConfiguration.getAdUnitId();
+        views.mDescriptionView.setText(adConfiguration.getDescription());
+        views.mAdUnitIdView.setText(adUnitId);
+        views.mLoadButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                final String keywords = views.mKeywordsField.getText().toString();
+                mMoPubInterstitial = new MoPubInterstitial(getActivity(), adUnitId);
+                mMoPubInterstitial.setInterstitialAdListener(InterstitialDetailFragment.this);
+                mMoPubInterstitial.setKeywords(keywords);
+                mMoPubInterstitial.load();
+                mShowButton.setEnabled(false);
+            }
+        });
+        mShowButton = (Button) view.findViewById(R.id.interstitial_show_button);
+        mShowButton.setEnabled(false);
+        mShowButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                mMoPubInterstitial.show();
+            }
+        });
+
+        return view;
+    }
+
+    @Override
+    public void onDestroyView() {
+        super.onDestroyView();
+
+        if (mMoPubInterstitial != null) {
+            mMoPubInterstitial.destroy();
+            mMoPubInterstitial = null;
+        }
+    }
+
+    // InterstitialAdListener implementation
+    @Override
+    public void onInterstitialLoaded(MoPubInterstitial interstitial) {
+        mShowButton.setEnabled(true);
+        logToast(getActivity(), "Interstitial loaded.");
+    }
+
+    @Override
+    public void onInterstitialFailed(MoPubInterstitial interstitial, MoPubErrorCode errorCode) {
+        final String errorMessage = (errorCode != null) ? errorCode.toString() : "";
+        logToast(getActivity(), "Interstitial failed to load: " + errorMessage);
+    }
+
+    @Override
+    public void onInterstitialShown(MoPubInterstitial interstitial) {
+        mShowButton.setEnabled(false);
+        logToast(getActivity(), "Interstitial shown.");
+    }
+
+    @Override
+    public void onInterstitialClicked(MoPubInterstitial interstitial) {
+        logToast(getActivity(), "Interstitial clicked.");
+    }
+
+    @Override
+    public void onInterstitialDismissed(MoPubInterstitial interstitial) {
+        logToast(getActivity(), "Interstitial dismissed.");
+    }
+}
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/InterstitialFragment.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/InterstitialFragment.java
deleted file mode 100644
index 38c895d0..00000000
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/InterstitialFragment.java
+++ /dev/null
@@ -1,144 +0,0 @@
-/*
- * Copyright (c) 2010-2013, MoPub Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *  Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- *  Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- *  Neither the name of 'MoPub Inc.' nor the names of its contributors
- *   may be used to endorse or promote products derived from this software
- *   without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package com.mopub.simpleadsdemo;
-
-import static com.mopub.simpleadsdemo.Utils.hideSoftKeyboard;
-import static com.mopub.simpleadsdemo.Utils.logToast;
-import static com.mopub.simpleadsdemo.Utils.validateAdUnitId;
-import android.os.Bundle;
-import android.support.v4.app.Fragment;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.View.OnClickListener;
-import android.view.ViewGroup;
-import android.widget.Button;
-import android.widget.EditText;
-
-import com.mopub.mobileads.MoPubErrorCode;
-import com.mopub.mobileads.MoPubInterstitial;
-import com.mopub.mobileads.MoPubInterstitial.InterstitialAdListener;
-
-public class InterstitialFragment extends Fragment implements InterstitialAdListener {
-    private MoPubInterstitial mMoPubInterstitial;
-    private EditText mInterstitialAdUnitField;
-    
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-    }
-    
-    public View onCreateView(LayoutInflater inflater, ViewGroup container,
-            Bundle savedInstanceState) {
-    	
-        View interstitialTabView = inflater.inflate(R.layout.interstitials, container, false);
-
-        OnClickListener fieldFocusListener = new OnClickListener() {
-            public void onClick(View view) {
-            	view.requestFocusFromTouch();
-            }
-        };
-       
-        mInterstitialAdUnitField = (EditText) interstitialTabView.findViewById(R.id.interstitials_edit_text_interstitial);
-        mInterstitialAdUnitField.setOnClickListener(fieldFocusListener);
-        hideSoftKeyboard(mInterstitialAdUnitField);
-
-        Button interstitialLoadButton = (Button) interstitialTabView.findViewById(R.id.interstitials_load_interstitial);
-        interstitialLoadButton.setOnClickListener(new OnClickListener() {
-            public void onClick(View v) {
-                String adUnitId = mInterstitialAdUnitField.getText().toString();
-
-                try {
-                    validateAdUnitId(adUnitId);
-
-                    mMoPubInterstitial = new MoPubInterstitial(InterstitialFragment.this.getActivity(), adUnitId);
-                    mMoPubInterstitial.setInterstitialAdListener(InterstitialFragment.this);
-                    mMoPubInterstitial.load();
-                } catch (IllegalArgumentException exception) {
-                    String message = exception.getMessage();
-
-                    if (message != null) {
-                        logToast(InterstitialFragment.this.getActivity(), message);
-                    }
-                }
-            }
-        });
-        
-        Button interstitialShowButton = (Button) interstitialTabView.findViewById(R.id.interstitials_show_interstitial);
-        interstitialShowButton.setOnClickListener(new OnClickListener() {
-            public void onClick(View v) {
-                if (mMoPubInterstitial != null && mMoPubInterstitial.isReady()) {
-                    mMoPubInterstitial.show();
-                } else {
-                    logToast(InterstitialFragment.this.getActivity(), "Interstitial was not ready. Try reloading.");
-                }
-            }
-        });
-        
-        return interstitialTabView;
-    }
-
-    @Override
-    public void onDestroy() {
-        if (mMoPubInterstitial != null) {
-            mMoPubInterstitial.destroy();
-        }
-        super.onDestroy();
-    }
-
-    /*
-     * MoPubInterstitial.InterstitialAdListener implementation
-     */
-    @Override
-    public void onInterstitialLoaded(MoPubInterstitial interstitial) {
-        logToast(getActivity(), "Interstitial loaded successfully.");
-    }
-
-    @Override
-    public void onInterstitialFailed(MoPubInterstitial interstitial, MoPubErrorCode errorCode) {
-        logToast(getActivity(), "Interstitial failed to load with error: " + errorCode.toString());
-    }
-
-    @Override
-    public void onInterstitialShown(MoPubInterstitial interstitial) {
-        logToast(getActivity(), "Interstitial shown.");
-    }
-
-    @Override
-    public void onInterstitialClicked(MoPubInterstitial interstitial) {
-        logToast(getActivity(), "Interstitial clicked.");
-    }
-
-    @Override
-    public void onInterstitialDismissed(MoPubInterstitial interstitial) {
-        logToast(getActivity(), "Interstitial dismissed.");
-    }
-}
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubListFragment.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubListFragment.java
new file mode 100644
index 00000000..75bfc06b
--- /dev/null
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubListFragment.java
@@ -0,0 +1,247 @@
+package com.mopub.simpleadsdemo;
+
+import android.app.AlertDialog;
+import android.app.Dialog;
+import android.content.DialogInterface;
+import android.os.Bundle;
+import android.support.v4.app.DialogFragment;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentTransaction;
+import android.support.v4.app.ListFragment;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ArrayAdapter;
+import android.widget.Button;
+import android.widget.EditText;
+import android.widget.ListView;
+import android.widget.Spinner;
+import android.widget.TextView;
+import android.widget.Toast;
+
+import com.mopub.common.MoPub;
+import com.mopub.common.util.MoPubLog;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static com.mopub.simpleadsdemo.MoPubSampleAdUnit.AdType;
+
+
+interface TrashCanClickListener {
+    void onTrashCanClicked(MoPubSampleAdUnit adUnit);
+}
+
+public class MoPubListFragment extends ListFragment implements TrashCanClickListener {
+    private MoPubSampleListAdapter mAdapter;
+    private AdUnitDataSource mAdUnitDataSource;
+
+    private static final AdType[] adTypes = AdType.values();
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        initializeAdapter();
+    }
+
+    @Override
+    public View onCreateView(final LayoutInflater inflater, final ViewGroup container, final Bundle savedInstanceState) {
+        final View view = inflater.inflate(R.layout.ad_unit_list_fragment, container, false);
+        final Button button = (Button) view.findViewById(R.id.add_ad_unit_button);
+        final TextView versionCodeView = (TextView) view.findViewById(R.id.version_code);
+        versionCodeView.setText("SDK Version " + MoPub.SDK_VERSION);
+
+        button.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(final View view) {
+                onAddClicked(view);
+            }
+        });
+
+        return view;
+    }
+
+    @Override
+    public void onListItemClick(ListView listView, View view, int position, long id) {
+        super.onListItemClick(listView, view, position, id);
+
+        final MoPubSampleAdUnit adConfiguration = mAdapter.getItem(position);
+
+        final FragmentTransaction fragmentTransaction =
+                getActivity().getSupportFragmentManager().beginTransaction();
+
+        final Class<? extends Fragment> fragmentClass = adConfiguration.getFragmentClass();
+        final Fragment fragment;
+
+        try {
+            fragment = fragmentClass.newInstance();
+        } catch (java.lang.InstantiationException e) {
+            MoPubLog.e("Error creating fragment for class " + fragmentClass, e);
+            return;
+        } catch (IllegalAccessException e) {
+            MoPubLog.e("Error creating fragment for class " + fragmentClass, e);
+            return;
+        }
+
+        fragment.setArguments(adConfiguration.toBundle());
+
+        fragmentTransaction
+                .replace(R.id.fragment_container, fragment)
+                .addToBackStack(null)
+                .commit();
+    }
+
+    @Override
+    public void onTrashCanClicked(final MoPubSampleAdUnit adUnit) {
+        final DialogFragment deleteConfirmation = DeleteDialogFragment.newInstance(adUnit);
+        deleteConfirmation.setTargetFragment(this, 0);
+        deleteConfirmation.show(getActivity().getSupportFragmentManager(), "delete");
+    }
+
+    public void onAddClicked(final View view) {
+        final AddDialogFragment dialogFragment = AddDialogFragment.newInstance();
+        dialogFragment.setTargetFragment(this, 0);
+        dialogFragment.show(getActivity().getSupportFragmentManager(), "add");
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        Utils.hideSoftKeyboard(getListView());
+    }
+
+    private void initializeAdapter() {
+        mAdapter = new MoPubSampleListAdapter(getActivity(), this);
+
+        mAdUnitDataSource = new AdUnitDataSource(getActivity());
+
+        // If you have a large amount of data, this loading work should be done in the background.
+        final List<MoPubSampleAdUnit> adUnits = mAdUnitDataSource.getAllAdUnits();
+        for (final MoPubSampleAdUnit adUnit : adUnits) {
+            mAdapter.add(adUnit);
+        }
+
+        mAdapter.sort(MoPubSampleAdUnit.COMPARATOR);
+        setListAdapter(mAdapter);
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+    }
+
+    void addAdUnit(final MoPubSampleAdUnit moPubSampleAdUnit) {
+        MoPubSampleAdUnit createdAdUnit = mAdUnitDataSource.createSampleAdUnit(moPubSampleAdUnit);
+        mAdapter.add(createdAdUnit);
+        mAdapter.sort(MoPubSampleAdUnit.COMPARATOR);
+    }
+
+    void deleteAdUnit(final MoPubSampleAdUnit moPubSampleAdUnit) {
+        mAdUnitDataSource.deleteSampleAdUnit(moPubSampleAdUnit);
+        mAdapter.remove(moPubSampleAdUnit);
+        mAdapter.sort(MoPubSampleAdUnit.COMPARATOR);
+    }
+
+    public static class DeleteDialogFragment extends DialogFragment {
+        public static DeleteDialogFragment newInstance(MoPubSampleAdUnit adUnit) {
+            final DeleteDialogFragment deleteDialogFragment = new DeleteDialogFragment();
+            Bundle args = adUnit.toBundle();
+            deleteDialogFragment.setArguments(args);
+            return deleteDialogFragment;
+        }
+
+        @Override
+        public Dialog onCreateDialog(final Bundle savedInstanceState) {
+            final Bundle args = getArguments();
+
+            return new AlertDialog.Builder(getActivity())
+                    .setTitle("Delete Ad Unit " + args.getString(MoPubSampleAdUnit.DESCRIPTION) + "?")
+                    .setPositiveButton("Delete", new DialogInterface.OnClickListener() {
+                        @Override
+                        public void onClick(final DialogInterface dialogInterface, final int i) {
+                            final MoPubListFragment listFragment = (MoPubListFragment) getTargetFragment();
+                            listFragment.deleteAdUnit(MoPubSampleAdUnit.fromBundle(args));
+                        }
+                    })
+                    .setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
+                        @Override
+                        public void onClick(final DialogInterface dialogInterface, final int i) {
+                            dismiss();
+                        }
+                    })
+                    .setCancelable(true)
+                    .create();
+        }
+    }
+
+    public static class AddDialogFragment extends DialogFragment {
+        public static AddDialogFragment newInstance() {
+            return new AddDialogFragment();
+        }
+
+        @Override
+        public Dialog onCreateDialog(final Bundle savedInstanceState) {
+            AlertDialog dialog = new AlertDialog.Builder(getActivity())
+                    .setTitle("Add a custom Ad Unit")
+                    .setPositiveButton("Save ad unit", new DialogInterface.OnClickListener() {
+                        @Override
+                        public void onClick(final DialogInterface dialogInterface, final int i) {
+                            AlertDialog dialog = (AlertDialog) dialogInterface;
+                            final EditText adUnitIdField =
+                                    (EditText) dialog.findViewById(R.id.add_ad_unit_id);
+                            final Spinner adTypeSpinner =
+                                    (Spinner) dialog.findViewById(R.id.add_ad_unit_type);
+                            final EditText descriptionField =
+                                    (EditText) dialog.findViewById(R.id.add_ad_unit_description);
+
+                            // Verify data:
+                            try {
+                                Utils.validateAdUnitId(adUnitIdField.getText().toString());
+                            } catch (IllegalArgumentException e) {
+                                // Input is not valid.
+                                Toast toast = Toast.makeText(getActivity(), "Ad Unit ID invalid",
+                                        Toast.LENGTH_SHORT);
+                                toast.show();
+                                return;
+                            }
+
+                            // Create ad unit and save it in the database:
+                            final String adUnitId = adUnitIdField.getText().toString();
+                            final AdType adType = adTypes[adTypeSpinner.getSelectedItemPosition()];
+                            final String description = descriptionField.getText().toString();
+                            final MoPubSampleAdUnit sampleAdUnit =
+                                    new MoPubSampleAdUnit.Builder(adUnitId, adType)
+                                            .description(description)
+                                            .isUserDefined(true)
+                                            .build();
+                            ((MoPubListFragment) getTargetFragment()).addAdUnit(sampleAdUnit);
+                            dismiss();
+                        }
+                    })
+                    .setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
+                        @Override
+                        public void onClick(final DialogInterface dialogInterface, final int i) {
+                            dismiss();
+                        }
+                    })
+                    .setCancelable(true)
+                    .create();
+
+            // Inflate and add our custom layout to the dialog.
+            final View view = dialog.getLayoutInflater()
+                    .inflate(R.layout.ad_config_dialog, null);
+            final Spinner spinner = (Spinner) view.findViewById(R.id.add_ad_unit_type);
+            final List<String> adTypeStrings = new ArrayList<String>(adTypes.length);
+
+            for (final AdType adType : adTypes) {
+                adTypeStrings.add(adType.getName());
+            }
+
+            spinner.setAdapter(new ArrayAdapter<String>(getActivity(),
+                    android.R.layout.simple_spinner_dropdown_item, android.R.id.text1, adTypeStrings));
+            dialog.setView(view);
+            return dialog;
+        }
+    }
+}
+
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSQLiteHelper.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSQLiteHelper.java
new file mode 100644
index 00000000..35f1862b
--- /dev/null
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSQLiteHelper.java
@@ -0,0 +1,116 @@
+package com.mopub.simpleadsdemo;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static com.mopub.simpleadsdemo.MoPubSampleAdUnit.AdType.BANNER;
+import static com.mopub.simpleadsdemo.MoPubSampleAdUnit.AdType.CUSTOM_NATIVE;
+import static com.mopub.simpleadsdemo.MoPubSampleAdUnit.AdType.INTERSTITIAL;
+import static com.mopub.simpleadsdemo.MoPubSampleAdUnit.AdType.LIST_VIEW;
+import static com.mopub.simpleadsdemo.MoPubSampleAdUnit.AdType.MRECT;
+
+class MoPubSQLiteHelper extends SQLiteOpenHelper {
+    public static final String TABLE_AD_CONFIGURATIONS = "adConfigurations";
+    public static final String COLUMN_ID = "_id";
+    public static final String COLUMN_AD_UNIT_ID = "adUnitId";
+    public static final String COLUMN_DESCRIPTION = "description";
+    public static final String COLUMN_USER_GENERATED = "userGenerated";
+    public static final String COLUMN_AD_TYPE = "adType";
+
+    private static final String DATABASE_NAME = "savedConfigurations.db";
+    private static final int DATABASE_VERSION = 1;
+
+    private static final String DATABASE_CREATE = "create table " + TABLE_AD_CONFIGURATIONS
+            + " ("
+            + COLUMN_ID + " integer primary key autoincrement, "
+            + COLUMN_AD_UNIT_ID + " text not null, "
+            + COLUMN_DESCRIPTION + " text not null, "
+            + COLUMN_USER_GENERATED + " integer not null, "
+            + COLUMN_AD_TYPE + " text not null"
+            + ");";
+
+    private final Context mContext;
+
+    public MoPubSQLiteHelper(final Context context) {
+        super(context, DATABASE_NAME, null, DATABASE_VERSION);
+        mContext = context.getApplicationContext();
+    }
+
+    @Override
+    public void onCreate(SQLiteDatabase sqLiteDatabase) {
+        // Built-in sample ad units.
+        final List<MoPubSampleAdUnit> adUnitList = new ArrayList<MoPubSampleAdUnit>();
+        adUnitList.add(
+                new MoPubSampleAdUnit
+                        .Builder(mContext.getString(R.string.ad_unit_id_banner), BANNER)
+                        .description("MoPub Banner Sample")
+                        .build());
+
+        adUnitList.add(
+                new MoPubSampleAdUnit
+                        .Builder(mContext.getString(R.string.ad_unit_id_mrect), MRECT)
+                        .description("MoPub Mrect Sample")
+                        .build());
+
+        adUnitList.add(
+                new MoPubSampleAdUnit
+                        .Builder(mContext.getString(R.string.ad_unit_id_interstitial), INTERSTITIAL)
+                        .description("MoPub Interstitial Sample")
+                        .build());
+
+        adUnitList.add(
+                new MoPubSampleAdUnit
+                        .Builder(mContext.getString(R.string.ad_unit_id_native), LIST_VIEW)
+                        .description("MoPub Ad Placer Sample")
+                        .build());
+        adUnitList.add(
+                new MoPubSampleAdUnit
+                        .Builder(mContext.getString(R.string.ad_unit_id_native), CUSTOM_NATIVE)
+                        .description("MoPub View Pager Sample")
+                        .build());
+        sqLiteDatabase.execSQL(DATABASE_CREATE);
+        sqLiteDatabase.beginTransaction();
+
+        // Populate the MoPub built-in samples.
+        for (final MoPubSampleAdUnit adUnit : adUnitList) {
+            final ContentValues values = new ContentValues();
+            values.put(COLUMN_AD_UNIT_ID, adUnit.getAdUnitId());
+            values.put(COLUMN_DESCRIPTION, adUnit.getDescription());
+            values.put(COLUMN_USER_GENERATED, 0);
+            values.put(COLUMN_AD_TYPE, adUnit.getFragmentClassName());
+
+            sqLiteDatabase.insert(TABLE_AD_CONFIGURATIONS, null, values);
+        }
+        sqLiteDatabase.setTransactionSuccessful();
+        sqLiteDatabase.endTransaction();
+    }
+
+    @Override
+    public void onDowngrade(SQLiteDatabase database, int oldVersion, int newVersion) {
+        Log.w(MoPubSQLiteHelper.class.getName(),
+                "Downgrading database from version " + oldVersion + " to "
+                        + newVersion + ", which will destroy all old data"
+        );
+        recreateDb(database);
+    }
+
+    @Override
+    public void onUpgrade(SQLiteDatabase database, int oldVersion, int newVersion) {
+        Log.w(MoPubSQLiteHelper.class.getName(),
+                "Upgrading database from version " + oldVersion + " to "
+                        + newVersion + ", which will destroy all old data"
+        );
+        recreateDb(database);
+    }
+
+    private void recreateDb(SQLiteDatabase database) {
+        database.execSQL("DROP TABLE IF EXISTS " + TABLE_AD_CONFIGURATIONS);
+        onCreate(database);
+    }
+}
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleActivity.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleActivity.java
new file mode 100644
index 00000000..12444978
--- /dev/null
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleActivity.java
@@ -0,0 +1,26 @@
+package com.mopub.simpleadsdemo;
+
+import android.os.Bundle;
+import android.support.v4.app.FragmentActivity;
+import android.support.v4.app.FragmentManager;
+
+public class MoPubSampleActivity extends FragmentActivity {
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.main);
+
+        if (savedInstanceState != null) {
+            return;
+        }
+
+        if (findViewById(R.id.fragment_container) != null) {
+            final MoPubListFragment listFragment = new MoPubListFragment();
+            listFragment.setArguments(getIntent().getExtras());
+            FragmentManager fragmentManager = getSupportFragmentManager();
+            fragmentManager.beginTransaction()
+                    .add(R.id.fragment_container, listFragment)
+                    .commit();
+        }
+    }
+}
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleAdUnit.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleAdUnit.java
new file mode 100644
index 00000000..dfeacd95
--- /dev/null
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleAdUnit.java
@@ -0,0 +1,200 @@
+package com.mopub.simpleadsdemo;
+
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+
+import java.util.Comparator;
+
+class MoPubSampleAdUnit implements Comparable<MoPubSampleAdUnit> {
+
+    public static final String AD_UNIT_ID = "adUnitId";
+    public static final String DESCRIPTION = "description";
+    public static final String AD_TYPE = "adType";
+    public static final String IS_USER_DEFINED = "isCustom";
+    public static final String ID = "id";
+
+    // Note that entries are also sorted in this order
+    enum AdType {
+        BANNER("Banner", BannerDetailFragment.class),
+        MRECT("Mrect", MrectDetailFragment.class),
+        INTERSTITIAL("Interstitial", InterstitialDetailFragment.class),
+        LIST_VIEW("Native List View", NativeListViewFragment.class),
+        CUSTOM_NATIVE("Native Gallery (Custom Stream)", NativeGalleryFragment.class);
+
+        String getName() {
+            return name;
+        }
+
+        private final String name;
+        private final Class<? extends Fragment> fragmentClass;
+
+        private AdType(final String name, final Class<? extends Fragment> fragmentClass) {
+            this.name = name;
+            this.fragmentClass = fragmentClass;
+        }
+
+        private Class<? extends Fragment> getFragmentClass() {
+            return fragmentClass;
+        }
+
+        static AdType fromFragmentClassName(final String fragmentClassName) {
+            for (final AdType adType : values()) {
+                if (adType.fragmentClass.getName().equals(fragmentClassName)) {
+                    return adType;
+                }
+            }
+
+            return null;
+        }
+    }
+
+    static final Comparator<MoPubSampleAdUnit> COMPARATOR =
+            new Comparator<MoPubSampleAdUnit>() {
+                @Override
+                public int compare(MoPubSampleAdUnit a, MoPubSampleAdUnit b) {
+                    return a.compareTo(b);
+                }
+            };
+
+    static class Builder {
+        private final String mAdUnitId;
+        private final AdType mAdType;
+
+        private String mDescription;
+        private boolean mIsUserDefined;
+        private long mId;
+
+        Builder(final String adUnitId, final AdType adType) {
+            mAdUnitId = adUnitId;
+            mAdType = adType;
+            mId = -1;
+        }
+
+        Builder description(final String description) {
+            mDescription = description;
+            return this;
+        }
+
+        Builder isUserDefined(boolean userDefined) {
+            mIsUserDefined = userDefined;
+            return this;
+        }
+
+        Builder id(final long id) {
+            mId = id;
+            return this;
+        }
+
+        MoPubSampleAdUnit build() {
+            return new MoPubSampleAdUnit(this);
+        }
+    }
+
+    private final String mAdUnitId;
+    private final AdType mAdType;
+    private final String mDescription;
+    private final boolean mIsUserDefined;
+    private final long mId;
+
+    private MoPubSampleAdUnit(final Builder builder) {
+        mAdUnitId = builder.mAdUnitId;
+        mAdType = builder.mAdType;
+        mDescription = builder.mDescription;
+        mIsUserDefined = builder.mIsUserDefined;
+        mId = builder.mId;
+    }
+
+    Class<? extends Fragment> getFragmentClass() {
+        return mAdType.getFragmentClass();
+    }
+
+    String getAdUnitId() {
+        return mAdUnitId;
+    }
+
+    String getDescription() {
+        return mDescription;
+    }
+
+    String getFragmentClassName() {
+        return mAdType.getFragmentClass().getName();
+    }
+
+    String getHeaderName() {
+        return mAdType.name;
+    }
+
+    long getId() {
+        return mId;
+    }
+
+    boolean isUserDefined() {
+        return mIsUserDefined;
+    }
+
+    Bundle toBundle() {
+        final Bundle bundle = new Bundle();
+        bundle.putLong(ID, mId);
+        bundle.putString(AD_UNIT_ID, mAdUnitId);
+        bundle.putString(DESCRIPTION, mDescription);
+        bundle.putSerializable(AD_TYPE, mAdType);
+        bundle.putBoolean(IS_USER_DEFINED, mIsUserDefined);
+
+        return bundle;
+    }
+
+    static MoPubSampleAdUnit fromBundle(final Bundle bundle) {
+        final Long id = bundle.getLong(ID, -1L);
+        final String adUnitId = bundle.getString(AD_UNIT_ID);
+        final AdType adType = (AdType) bundle.getSerializable(AD_TYPE);
+        final String description = bundle.getString(DESCRIPTION);
+        final boolean isUserDefined = bundle.getBoolean(IS_USER_DEFINED, false);
+        final Builder builder = new MoPubSampleAdUnit.Builder(adUnitId, adType);
+        builder.description(description);
+        builder.id(id);
+        builder.isUserDefined(isUserDefined);
+
+        return builder.build();
+    }
+
+    @Override
+    public int compareTo(MoPubSampleAdUnit that) {
+        if (mAdType != that.mAdType) {
+            return mAdType.ordinal() - that.mAdType.ordinal();
+        }
+
+        return mDescription.compareTo(that.mDescription);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = 11;
+        result = 31 * result + mAdType.ordinal();
+        result = 31 * result + (mIsUserDefined ? 1 : 0);
+        result = 31 * result + mDescription.hashCode();
+        result = 31 * result + mAdUnitId.hashCode();
+        return result;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (o == null) {
+            return false;
+        }
+
+        if (this == o) {
+            return true;
+        }
+
+        if (!(o instanceof MoPubSampleAdUnit)) {
+            return false;
+        }
+
+        final MoPubSampleAdUnit that = (MoPubSampleAdUnit) o;
+
+        return that.mAdType.equals(this.mAdType) &&
+                that.mIsUserDefined == this.mIsUserDefined &&
+                that.mDescription.equals(this.mDescription) &&
+                that.mAdUnitId.equals(this.mAdUnitId);
+    }
+}
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleListAdapter.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleListAdapter.java
new file mode 100644
index 00000000..a2678507
--- /dev/null
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MoPubSampleListAdapter.java
@@ -0,0 +1,86 @@
+package com.mopub.simpleadsdemo;
+
+import android.content.Context;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ArrayAdapter;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import java.util.ArrayList;
+
+class MoPubSampleListAdapter extends ArrayAdapter<MoPubSampleAdUnit> {
+    private final TrashCanClickListener mListener;
+
+    static class ViewHolder {
+        TextView separator;
+        TextView description;
+        TextView adUnitId;
+        ImageView trashCan;
+    }
+
+    private final LayoutInflater mLayoutInflater;
+
+    MoPubSampleListAdapter(final Context context, TrashCanClickListener listener) {
+        super(context, 0, new ArrayList<MoPubSampleAdUnit>());
+        mListener = listener;
+        mLayoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+    }
+
+
+    @Override
+    public View getView(final int position, final View convertView, final ViewGroup parent) {
+        final View view;
+        final ViewHolder viewHolder;
+
+        if (convertView == null) {
+            view = mLayoutInflater.inflate(R.layout.ad_configuration_list_item, parent, false);
+            viewHolder = new ViewHolder();
+            viewHolder.separator = (TextView) view.findViewById(R.id.separator);
+            viewHolder.description = (TextView) view.findViewById(R.id.banner_description);
+            viewHolder.adUnitId = (TextView) view.findViewById(R.id.banner_ad_unit_id);
+            viewHolder.trashCan = (ImageView) view.findViewById(R.id.banner_delete);
+        } else {
+            view = convertView;
+            viewHolder = (ViewHolder) view.getTag();
+        }
+
+        view.setTag(viewHolder);
+        final MoPubSampleAdUnit sampleAdUnit = getItem(position);
+        viewHolder.description.setText(sampleAdUnit.getDescription());
+        viewHolder.adUnitId.setText(sampleAdUnit.getAdUnitId());
+
+        if (isFirstInSection(position)) {
+            viewHolder.separator.setVisibility(View.VISIBLE);
+            viewHolder.separator.setText(sampleAdUnit.getHeaderName());
+        } else {
+            viewHolder.separator.setVisibility(View.GONE);
+        }
+
+        if (sampleAdUnit.isUserDefined()) {
+            viewHolder.trashCan.setVisibility(View.VISIBLE);
+            viewHolder.trashCan.setOnClickListener(new View.OnClickListener() {
+                @Override
+                public void onClick(final View view) {
+                    mListener.onTrashCanClicked(sampleAdUnit);
+                }
+            });
+        } else {
+            viewHolder.trashCan.setVisibility(View.INVISIBLE);
+            viewHolder.trashCan.setOnClickListener(null);
+        }
+
+        return view;
+    }
+
+    private boolean isFirstInSection(int position) {
+        if (position <= 0) {
+            return true;
+        }
+
+        final MoPubSampleAdUnit previous = getItem(position - 1);
+        final MoPubSampleAdUnit current = getItem(position);
+        return !previous.getHeaderName().equals(current.getHeaderName());
+    }
+}
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MrectDetailFragment.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MrectDetailFragment.java
new file mode 100644
index 00000000..2ae93318
--- /dev/null
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/MrectDetailFragment.java
@@ -0,0 +1,87 @@
+package com.mopub.simpleadsdemo;
+
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+
+import com.mopub.mobileads.MoPubErrorCode;
+import com.mopub.mobileads.MoPubView;
+
+import static com.mopub.mobileads.MoPubView.BannerAdListener;
+import static com.mopub.simpleadsdemo.Utils.hideSoftKeyboard;
+import static com.mopub.simpleadsdemo.Utils.logToast;
+
+public class MrectDetailFragment extends Fragment implements BannerAdListener {
+    private MoPubView mMoPubView;
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        super.onCreateView(inflater, container, savedInstanceState);
+
+        final MoPubSampleAdUnit adConfiguration =
+                MoPubSampleAdUnit.fromBundle(getArguments());
+        final View view = inflater.inflate(R.layout.mrect_detail_fragment, container, false);
+        final DetailFragmentViewHolder views = DetailFragmentViewHolder.fromView(view);
+        hideSoftKeyboard(views.mKeywordsField);
+        mMoPubView = (MoPubView) view.findViewById(R.id.mrect_mopubview);
+        final String adUnitId = adConfiguration.getAdUnitId();
+        views.mDescriptionView.setText(adConfiguration.getDescription());
+        views.mAdUnitIdView.setText(adUnitId);
+        views.mLoadButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                final String keywords = views.mKeywordsField.getText().toString();
+                loadMoPubView(adUnitId, keywords);
+            }
+        });
+        mMoPubView.setBannerAdListener(this);
+        loadMoPubView(adUnitId, null);
+
+        return view;
+    }
+
+    @Override
+    public void onDestroyView() {
+        super.onDestroyView();
+
+        if (mMoPubView != null) {
+            mMoPubView.destroy();
+            mMoPubView = null;
+        }
+    }
+
+    private void loadMoPubView(final String adUnitId, final String keywords) {
+        mMoPubView.setAdUnitId(adUnitId);
+        mMoPubView.setKeywords(keywords);
+        mMoPubView.loadAd();
+    }
+
+    // BannerAdListener
+    @Override
+    public void onBannerLoaded(MoPubView banner) {
+        logToast(getActivity(), "Mrect loaded.");
+    }
+
+    @Override
+    public void onBannerFailed(MoPubView banner, MoPubErrorCode errorCode) {
+        final String errorMessage = (errorCode != null) ? errorCode.toString() : "";
+        logToast(getActivity(), "Mrect failed to load: " + errorMessage);
+    }
+
+    @Override
+    public void onBannerClicked(MoPubView banner) {
+        logToast(getActivity(), "Mrect clicked.");
+    }
+
+    @Override
+    public void onBannerExpanded(MoPubView banner) {
+        logToast(getActivity(), "Mrect expanded.");
+    }
+
+    @Override
+    public void onBannerCollapsed(MoPubView banner) {
+        logToast(getActivity(), "Mrect collapsed.");
+    }
+}
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeAdapter.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeAdapter.java
deleted file mode 100644
index a281b289..00000000
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeAdapter.java
+++ /dev/null
@@ -1,210 +0,0 @@
-package com.mopub.simpleadsdemo;
-
-import android.content.Context;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.BaseAdapter;
-import android.widget.TextView;
-
-import com.mopub.nativeads.AdapterHelper;
-import com.mopub.nativeads.NativeResponse;
-import com.mopub.nativeads.ViewBinder;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Queue;
-
-import static com.mopub.nativeads.MoPubNative.MoPubNativeListener;
-import static com.mopub.simpleadsdemo.NativeFragment.MoPubNativeConsumptionListener;
-
-final class NativeAdapter extends BaseAdapter {
-    private static final int NUMBER_OF_ROWS = 100;
-    private static final int NATIVE_AD_START_POSITION = 10;
-    private static final int NATIVE_AD_REPEAT = 7;
-    private static final int CONTENT_LAYOUT = R.layout.text_row;
-
-    private final Context mContext;
-
-    // Listener to notify the activity of ad events
-    private final MoPubNativeListener mMoPubNativeListener;
-
-    // Specific listener to notify the activity when a native response has been consumed
-    // from the mNativeResponses queue
-    // This lets the activity request another native ad to replenish its supply
-    private final MoPubNativeConsumptionListener mMoPubNativeConsumptionListener;
-
-    // Binds native ad view ids to fields expected from the native response
-    private final ViewBinder mViewBinder;
-
-    // Helps with calculating native ad positions in the list and populating views with
-    // native response content
-    private final AdapterHelper mAdapterHelper;
-
-    // Sample content to be displayed in the list
-    private final List<String> mBackingList;
-
-    // Queue of native responses retrieved from the network and ready to be displayed in the app
-    private final Queue<NativeResponse> mNativeResponses;
-
-    // Mapping of native responses to position in the list where they have been displayed
-    private final HashMap<Integer, Object> mPositionToResponse;
-
-    private enum RowType {
-        CONTENT(0),
-        NATIVE_AD(1),
-        EMPTY_AD(2);
-
-        private static final int size = values().length;
-        private final int id;
-
-        private RowType(int id) {
-            this.id = id;
-        }
-    }
-
-    NativeAdapter(final Context context,
-            final MoPubNativeListener moPubNativeListener,
-            final MoPubNativeConsumptionListener moPubNativeConsumptionListener,
-            final ViewBinder viewBinder) {
-        super();
-
-        mContext = context.getApplicationContext();
-        mMoPubNativeListener = moPubNativeListener;
-        mMoPubNativeConsumptionListener = moPubNativeConsumptionListener;
-        mViewBinder = viewBinder;
-
-        mAdapterHelper = new AdapterHelper(context, NATIVE_AD_START_POSITION, NATIVE_AD_REPEAT);
-        mBackingList = createBackingList(NUMBER_OF_ROWS);
-
-        mNativeResponses = new LinkedList<NativeResponse>();
-        mPositionToResponse = new HashMap<Integer, Object>();
-    }
-
-    @Override
-    public int getCount() {
-        return mAdapterHelper.shiftedCount(NUMBER_OF_ROWS);
-    }
-
-    @Override
-    public String getItem(int position) {
-        return mBackingList.get(mAdapterHelper.shiftedPosition(position));
-    }
-
-    @Override
-    public long getItemId(int position) {
-        return 0;
-    }
-
-    @Override
-    public int getViewTypeCount() {
-        return RowType.size;
-    }
-
-    @Override
-    public int getItemViewType(int position) {
-        if (mAdapterHelper.isAdPosition(position)) {
-            Object nativeResponse = mPositionToResponse.get(position);
-
-            // If we have a native response already assigned to this position in the list then
-            // we can use it again
-            if (nativeResponse instanceof NativeResponse) {
-                return RowType.NATIVE_AD.id;
-
-            // If object is null it implies that this position in the list has yet to be assigned
-            // as a native response or empty response
-            // If we have a native response ready to be shown in the queue, then assign this
-            // position in the list a native response
-            } else if (nativeResponse == null && !mNativeResponses.isEmpty()) {
-                return RowType.NATIVE_AD.id;
-
-            // If we get here it means that the position in the list was either already an
-            // empty response or we didn't have a native response ready to show
-            } else {
-                return RowType.EMPTY_AD.id;
-            }
-        } else {
-            return RowType.CONTENT.id;
-        }
-    }
-
-    @Override
-    public View getView(int position, View convertView, ViewGroup parent) {
-        int itemViewType = getItemViewType(position);
-        if (itemViewType == RowType.NATIVE_AD.id) {
-            return getNativeAdView(position, convertView, parent);
-        } else if (itemViewType == RowType.EMPTY_AD.id) {
-            return getEmptyAdView(position, convertView, parent);
-        } else {
-            return getContentView(position, convertView, parent);
-        }
-    }
-
-    private View getNativeAdView(int position, View convertView, ViewGroup parent) {
-        // Check to see if we have a native response already used at this position
-        Object nativeResponse = mPositionToResponse.get(position);
-        if (nativeResponse == null) {
-
-            // If we don't then get a native response from the queue and assign it to this position
-            // in the LruCache
-            nativeResponse = mNativeResponses.poll();
-            mPositionToResponse.put(position, nativeResponse);
-
-            // Notify the activity that we consumed a native response from the queue so it can
-            // fetch another one
-            mMoPubNativeConsumptionListener
-                    .onNativeResponseConsumed((NativeResponse) nativeResponse);
-        }
-
-        View view = mAdapterHelper.getAdView(
-                convertView,
-                parent,
-                (NativeResponse) nativeResponse,
-                mViewBinder,
-                mMoPubNativeListener);
-
-        return view;
-    }
-
-    private View getEmptyAdView(int position, View convertView, ViewGroup parent) {
-        // Use a linear layout with height of 0 to display nothing for this row
-        if (convertView == null) {
-            convertView = LayoutInflater
-                    .from(mContext)
-                    .inflate(R.layout.empty_ad_row, parent, false);
-        }
-        mPositionToResponse.put(position, new EmptyNativeResponse());
-        return convertView;
-    }
-
-    private View getContentView(int position, View convertView, ViewGroup parent) {
-        // Display app content
-        if (convertView == null) {
-            convertView = LayoutInflater.from(mContext).inflate(CONTENT_LAYOUT, parent, false);
-        }
-
-        TextView label = (TextView) convertView.findViewById(R.id.my_text_view);
-        label.setText(getItem(position));
-
-        return convertView;
-    }
-
-    public void addNativeResponse(NativeResponse nativeResponse) {
-        // Add more native responses to the queue to be displayed in the app
-        mNativeResponses.add(nativeResponse);
-    }
-
-    private List<String> createBackingList(int numberOfRows) {
-        // Create sample content
-        List<String> list = new ArrayList<String>(numberOfRows);
-        for (int i = 0; i < numberOfRows; i++) {
-            list.add(String.valueOf(i));
-        }
-        return list;
-    }
-
-    // Empty class to denote an empty ad view in the list
-    private static final class EmptyNativeResponse {}
-}
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeFragment.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeFragment.java
deleted file mode 100644
index ee5780cb..00000000
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeFragment.java
+++ /dev/null
@@ -1,218 +0,0 @@
-/*
- * Copyright (c) 2010-2013, MoPub Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *  Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- *  Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- *  Neither the name of 'MoPub Inc.' nor the names of its contributors
- *   may be used to endorse or promote products derived from this software
- *   without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package com.mopub.simpleadsdemo;
-
-import android.location.Location;
-import android.os.Bundle;
-import android.os.Handler;
-import android.support.v4.app.Fragment;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.Button;
-import android.widget.EditText;
-import android.widget.ListView;
-
-import com.mopub.common.util.MoPubLog;
-import com.mopub.nativeads.MoPubNative;
-import com.mopub.nativeads.NativeErrorCode;
-import com.mopub.nativeads.NativeResponse;
-import com.mopub.nativeads.RequestParameters;
-import com.mopub.nativeads.ViewBinder;
-
-import static com.mopub.nativeads.MoPubNative.MoPubNativeListener;
-import static com.mopub.simpleadsdemo.Utils.hideSoftKeyboard;
-import static com.mopub.simpleadsdemo.Utils.logToast;
-
-public final class NativeFragment extends Fragment {
-    private static final int NATIVE_AD_INITIALIZATION_COUNT = 3;
-
-    private final MyMoPubNativeListener mMyMoPubNativeListener;
-    private final MyMoPubNativeConsumptionListener mMyMoPubNativeConsumptionListener;
-
-    private ListView mListView;
-    private MoPubNative mMoPubNative;
-    private EditText mNativeAdUnitField;
-
-    private ViewBinder mViewBinder;
-    private NativeAdapter mNativeAdapter;
-
-    public NativeFragment() {
-        super();
-        mMyMoPubNativeListener = new MyMoPubNativeListener();
-        mMyMoPubNativeConsumptionListener = new MyMoPubNativeConsumptionListener();
-    }
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState); }
-
-    public View onCreateView(LayoutInflater inflater, ViewGroup container,
-                 Bundle savedInstanceState) {
-
-        View nativeFragmentView = inflater.inflate(R.layout.nativetab, container, false);
-
-        mListView = (ListView) nativeFragmentView.findViewById(R.id.list_view);
-
-        View.OnClickListener fieldFocusListener = new View.OnClickListener() {
-            public void onClick(View view) {
-                view.requestFocusFromTouch();
-            }
-        };
-
-        mNativeAdUnitField = (EditText) nativeFragmentView.findViewById(R.id.native_adunit_field);
-        hideSoftKeyboard(mNativeAdUnitField);
-
-        mNativeAdUnitField.setOnClickListener(fieldFocusListener);
-
-        mViewBinder = new ViewBinder.Builder(R.layout.native_ad_row)
-                .titleId(R.id.native_title)
-                .textId(R.id.native_text)
-                .callToActionId(R.id.native_cta)
-                .mainImageId(R.id.native_main_image)
-                .iconImageId(R.id.native_icon_image)
-                .build();
-
-        Button nativeLoadButton = (Button) nativeFragmentView.findViewById(R.id.native_load_button);
-        nativeLoadButton.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                String adUnitId = mNativeAdUnitField.getText().toString();
-
-                // Destory old native ad if it exists
-                if(mMoPubNative != null) {
-                    mMoPubNative.destroy();
-                }
-
-                mMoPubNative = new MoPubNative(getActivity(), adUnitId, mMyMoPubNativeListener);
-
-                // Initialize activity with a number of native ads ready to show
-                for (int i=0; i < NATIVE_AD_INITIALIZATION_COUNT; ++i) {
-                    requestNativeAd();
-                }
-
-                mNativeAdapter = new NativeAdapter(
-                        getActivity(),
-                        mMyMoPubNativeListener,
-                        mMyMoPubNativeConsumptionListener,
-                        mViewBinder
-                );
-
-                mListView.setAdapter(mNativeAdapter);
-
-                logToast(getActivity(), "Loaded new native ad unit");
-            }
-        });
-
-        return nativeFragmentView;
-    }
-
-    private void requestNativeAd() {
-        Location exampleLocation = new Location("example");
-        exampleLocation.setLatitude(23.1);
-        exampleLocation.setLongitude(42.1);
-        exampleLocation.setAccuracy(100);
-
-        RequestParameters requestParameters = new RequestParameters.Builder()
-                .keywords("key:value")
-                .location(exampleLocation)
-                .build();
-
-        mMoPubNative.makeRequest(requestParameters);
-    }
-
-    private final class MyMoPubNativeListener implements MoPubNativeListener {
-        private static final int EMPTY_RESPONSE_DELAY_MS = 30000; // 30 seconds
-        private Handler mHandler;
-        private Runnable mRunnable;
-
-        public MyMoPubNativeListener() {
-            mHandler = new Handler();
-            mRunnable = new Runnable() {
-                @Override
-                public void run() {
-                    requestNativeAd();
-                }
-            };
-        }
-
-        @Override
-        public void onNativeLoad(final NativeResponse nativeResponse) {
-            MoPubLog.d("MoPubNativeListener: Load!, NativeResponse: " + nativeResponse.toString());
-
-            // When we have a valid response, let the adapter manage when it will be shown
-            mNativeAdapter.addNativeResponse(nativeResponse);
-        }
-
-        @Override
-        public void onNativeFail(final NativeErrorCode errorCode) {
-            MoPubLog.d("MoPubNativeListener: Fail!, NativeErrorCode: " + errorCode.toString());
-            switch (errorCode) {
-                case INVALID_REQUEST_URL:
-                    // Invalid url, don't try to request again
-                    break;
-                case CONNECTION_ERROR:
-                    // Data connection was lost, activity should start requesting ads again
-                    // when the data connection is regained
-                    break;
-                default:
-                    // For any other error, wait 30 seconds before trying again
-                    mHandler.postDelayed(mRunnable, EMPTY_RESPONSE_DELAY_MS);
-                    break;
-            }
-        }
-
-        @Override
-        public void onNativeImpression(final View view) {
-            MoPubLog.d("MoPubNativeListener: Impression!, View: " + view.toString());
-        }
-
-        @Override
-        public void onNativeClick(final View view) {
-            MoPubLog.d("MoPubNativeListener: Click!, View: " + view.toString());
-        }
-    }
-
-    public static interface MoPubNativeConsumptionListener {
-        public void onNativeResponseConsumed(NativeResponse nativeResponse);
-    }
-
-    private final class MyMoPubNativeConsumptionListener implements MoPubNativeConsumptionListener {
-        @Override
-        public void onNativeResponseConsumed(NativeResponse nativeResponse) {
-            // Native ad was displayed in the app, request a new one to always
-            // have ads ready to display
-            requestNativeAd();
-        }
-    }
-}
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeGalleryFragment.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeGalleryFragment.java
new file mode 100644
index 00000000..cd8a1a74
--- /dev/null
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeGalleryFragment.java
@@ -0,0 +1,224 @@
+package com.mopub.simpleadsdemo;
+
+import android.app.Activity;
+import android.location.Location;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentManager;
+import android.support.v4.app.FragmentStatePagerAdapter;
+import android.support.v4.view.ViewPager;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.TextView;
+
+import com.mopub.nativeads.MoPubNativeAdLoadedListener;
+import com.mopub.nativeads.MoPubNativeAdPositioning;
+import com.mopub.nativeads.MoPubNativeAdRenderer;
+import com.mopub.nativeads.MoPubStreamAdPlacer;
+import com.mopub.nativeads.RequestParameters;
+import com.mopub.nativeads.ViewBinder;
+
+import java.util.EnumSet;
+
+import static com.mopub.nativeads.RequestParameters.NativeAdAsset;
+
+public class NativeGalleryFragment extends Fragment implements MoPubNativeAdLoadedListener {
+    private MoPubSampleAdUnit mAdConfiguration;
+    private ViewPager mViewPager;
+    private CustomPagerAdapter mPagerAdapter;
+    private MoPubStreamAdPlacer mStreamAdPlacer;
+    private RequestParameters mRequestParameters;
+
+    @Override
+    public View onCreateView(final LayoutInflater inflater, final ViewGroup container,
+            final Bundle savedInstanceState) {
+        super.onCreateView(inflater, container, savedInstanceState);
+        mAdConfiguration = MoPubSampleAdUnit.fromBundle(getArguments());
+        final View view = inflater.inflate(R.layout.native_gallery_fragment, container, false);
+        final DetailFragmentViewHolder views = DetailFragmentViewHolder.fromView(view);
+        views.mLoadButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                // If your app already has location access, include it here.
+                final Location location = null;
+                final String keywords = views.mKeywordsField.getText().toString();
+
+                // Setting desired assets on your request helps native ad networks and bidders
+                // provide higher-quality ads.
+                final EnumSet<NativeAdAsset> desiredAssets = EnumSet.of(
+                        NativeAdAsset.TITLE,
+                        NativeAdAsset.TEXT,
+                        NativeAdAsset.ICON_IMAGE,
+                        NativeAdAsset.MAIN_IMAGE,
+                        NativeAdAsset.CALL_TO_ACTION_TEXT);
+
+                mRequestParameters = new RequestParameters.Builder()
+                        .location(location)
+                        .keywords(keywords)
+                        .desiredAssets(desiredAssets)
+                        .build();
+
+                if (mStreamAdPlacer != null) {
+                    mStreamAdPlacer.loadAds(mAdConfiguration.getAdUnitId(), mRequestParameters);
+                }
+            }
+        });
+
+        final String adUnitId = mAdConfiguration.getAdUnitId();
+        views.mDescriptionView.setText(mAdConfiguration.getDescription());
+        views.mAdUnitIdView.setText(adUnitId);
+        mViewPager = (ViewPager) view.findViewById(R.id.gallery_pager);
+        mStreamAdPlacer = new MoPubStreamAdPlacer(getActivity(),
+                MoPubNativeAdPositioning.newBuilder()
+                        .addFixedPosition(1)
+                        .addFixedPosition(4)
+                        .enableRepeatingPositions(3)
+                        .build()
+        );
+        final MoPubNativeAdRenderer adRenderer = new MoPubNativeAdRenderer(
+                new ViewBinder.Builder(R.layout.native_ad_row)
+                        .titleId(R.id.native_title)
+                        .textId(R.id.native_text)
+                        .mainImageId(R.id.native_main_image)
+                        .iconImageId(R.id.native_icon_image)
+                        .callToActionId(R.id.native_cta)
+                        .build()
+        );
+        mPagerAdapter = new CustomPagerAdapter(getChildFragmentManager(), mStreamAdPlacer);
+        mStreamAdPlacer.registerAdRenderer(adRenderer);
+        mStreamAdPlacer.setAdLoadedListener(this);
+        mViewPager.setAdapter(mPagerAdapter);
+
+        return view;
+    }
+
+    public MoPubStreamAdPlacer getAdPlacer() {
+        return mStreamAdPlacer;
+    }
+
+    @Override
+    public void onDestroyView() {
+        // You must call this or the ad adapter may cause a memory leak.
+        mStreamAdPlacer.destroy();
+        super.onDestroyView();
+    }
+
+    @Override
+    public void onResume() {
+        // MoPub recommends reloading ads when the user returns to a view.
+        mStreamAdPlacer.loadAds(mAdConfiguration.getAdUnitId(), mRequestParameters);
+        super.onResume();
+    }
+
+    @Override
+    public void onAdLoaded(final int position) {
+        mViewPager.invalidate();
+        mPagerAdapter.notifyDataSetChanged();
+    }
+
+    @Override
+    public void onAdRemoved(final int position) {
+        mViewPager.invalidate();
+        mPagerAdapter.notifyDataSetChanged();
+    }
+
+    private static class CustomPagerAdapter extends FragmentStatePagerAdapter {
+        private static final int ITEM_COUNT = 30;
+        private MoPubStreamAdPlacer mStreamAdPlacer;
+
+        public CustomPagerAdapter(final FragmentManager fragmentManager,
+                MoPubStreamAdPlacer streamAdPlacer) {
+            super(fragmentManager);
+            this.mStreamAdPlacer = streamAdPlacer;
+            streamAdPlacer.setItemCount(ITEM_COUNT);
+        }
+
+        @Override
+        public int getItemPosition(final Object object) {
+            // This forces all items to be recreated when invalidate() is called on the ViewPager.
+            return POSITION_NONE;
+        }
+
+        @Override
+        public Fragment getItem(final int i) {
+            mStreamAdPlacer.placeAdsInRange(i - 5, i + 5);
+            if (mStreamAdPlacer.isAd(i)) {
+                return AdFragment.newInstance(i);
+            }
+            return ContentFragment.newInstance(mStreamAdPlacer.getOriginalPosition(i));
+        }
+
+        @Override
+        public int getCount() {
+            return mStreamAdPlacer.getAdjustedCount(ITEM_COUNT);
+        }
+
+        @Override
+        public CharSequence getPageTitle(final int position) {
+            if (mStreamAdPlacer.isAd(position)) {
+                return "Advertisement";
+            }
+            return "Content Item " + mStreamAdPlacer.getOriginalPosition(position);
+        }
+
+    }
+
+    public static class ContentFragment extends Fragment {
+        /**
+         * The fragment argument representing the section number for this
+         * fragment.
+         */
+        private static final String ARG_SECTION_NUMBER = "section_number";
+
+        public static ContentFragment newInstance(int sectionNumber) {
+            ContentFragment fragment = new ContentFragment();
+            Bundle args = new Bundle();
+            args.putInt(ARG_SECTION_NUMBER, sectionNumber);
+            fragment.setArguments(args);
+            return fragment;
+        }
+
+        @Override
+        public View onCreateView(final LayoutInflater inflater, final ViewGroup container,
+                final Bundle savedInstanceState) {
+            // Inflate the view.
+            View rootView = inflater.inflate(R.layout.native_gallery_content, container, false);
+            int contentNumber = getArguments().getInt(ARG_SECTION_NUMBER);
+            TextView textView = (TextView) rootView.findViewById(R.id.native_gallery_content_text);
+            textView.setText("Content Item " + contentNumber);
+            return rootView;
+        }
+    }
+
+    public static class AdFragment extends Fragment {
+        private static final String ARG_AD_POSITION = "ad_position";
+        private MoPubStreamAdPlacer mAdPlacer;
+
+        public static AdFragment newInstance(int adPosition) {
+            AdFragment fragment = new AdFragment();
+            Bundle bundle = new Bundle();
+            bundle.putInt(ARG_AD_POSITION, adPosition);
+            fragment.setArguments(bundle);
+            return fragment;
+        }
+
+        @Override
+        public void onAttach(final Activity activity) {
+            mAdPlacer = ((NativeGalleryFragment) getParentFragment()).getAdPlacer();
+            super.onAttach(activity);
+        }
+
+        @Override
+        public View onCreateView(final LayoutInflater inflater, final ViewGroup container,
+                final Bundle savedInstanceState) {
+            if (mAdPlacer != null) {
+                int position = getArguments().getInt(ARG_AD_POSITION);
+                mAdPlacer.placeAdsInRange(position - 5, position + 5);
+                return mAdPlacer.getAdView(position, null, container);
+            }
+
+            return null;
+        }
+    }
+}
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeListViewFragment.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeListViewFragment.java
new file mode 100644
index 00000000..d6493288
--- /dev/null
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeListViewFragment.java
@@ -0,0 +1,109 @@
+package com.mopub.simpleadsdemo;
+
+import android.location.Location;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ArrayAdapter;
+import android.widget.ListView;
+
+import com.mopub.nativeads.MoPubAdAdapter;
+import com.mopub.nativeads.MoPubNativeAdPositioning;
+import com.mopub.nativeads.MoPubNativeAdRenderer;
+import com.mopub.nativeads.RequestParameters;
+import com.mopub.nativeads.ViewBinder;
+
+import java.util.EnumSet;
+
+import static com.mopub.nativeads.RequestParameters.NativeAdAsset;
+
+public class NativeListViewFragment extends Fragment {
+    private MoPubAdAdapter mAdAdapter;
+    private MoPubSampleAdUnit mAdConfiguration;
+    private RequestParameters mRequestParameters;
+
+    @Override
+    public View onCreateView(final LayoutInflater inflater,
+            final ViewGroup container,
+            final Bundle savedInstanceState) {
+        super.onCreateView(inflater, container, savedInstanceState);
+
+        mAdConfiguration = MoPubSampleAdUnit.fromBundle(getArguments());
+        final View view = inflater.inflate(R.layout.native_list_view_fragment, container, false);
+        final ListView listView = (ListView) view.findViewById(R.id.native_list_view);
+        final DetailFragmentViewHolder views = DetailFragmentViewHolder.fromView(view);
+        views.mLoadButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                // If your app already has location access, include it here.
+                final Location location = null;
+                final String keywords = views.mKeywordsField.getText().toString();
+
+                // Setting desired assets on your request helps native ad networks and bidders
+                // provide higher-quality ads.
+                final EnumSet<NativeAdAsset> desiredAssets = EnumSet.of(
+                        NativeAdAsset.TITLE,
+                        NativeAdAsset.TEXT,
+                        NativeAdAsset.ICON_IMAGE,
+                        NativeAdAsset.MAIN_IMAGE,
+                        NativeAdAsset.CALL_TO_ACTION_TEXT);
+
+                mRequestParameters = new RequestParameters.Builder()
+                        .location(location)
+                        .keywords(keywords)
+                        .desiredAssets(desiredAssets)
+                        .build();
+
+                mAdAdapter.loadAds(mAdConfiguration.getAdUnitId(), mRequestParameters);
+            }
+        });
+        final String adUnitId = mAdConfiguration.getAdUnitId();
+        views.mDescriptionView.setText(mAdConfiguration.getDescription());
+        views.mAdUnitIdView.setText(adUnitId);
+
+        final ArrayAdapter<String> adapter = new ArrayAdapter<String>(getActivity(),
+                android.R.layout.simple_list_item_1);
+        for (int i = 0; i < 100; ++i) {
+            adapter.add("Item " + i);
+        }
+
+        // Create an ad adapter with ads in positions 0, 4, and every 10 places thereafter.
+        // This adapter will be used in place of the original adapter for the ListView.
+        mAdAdapter = new MoPubAdAdapter(getActivity(), adapter, MoPubNativeAdPositioning.newBuilder()
+                .addFixedPosition(0)
+                .addFixedPosition(4)
+                .enableRepeatingPositions(10)
+                .build());
+
+        // Set up an renderer that knows how to put ad data in an ad view.
+        final MoPubNativeAdRenderer adRenderer = new MoPubNativeAdRenderer(
+                new ViewBinder.Builder(R.layout.native_ad_row)
+                        .titleId(R.id.native_title)
+                        .textId(R.id.native_text)
+                        .mainImageId(R.id.native_main_image)
+                        .iconImageId(R.id.native_icon_image)
+                        .callToActionId(R.id.native_cta)
+                        .build());
+
+        // Register the renderer with the MoPubAdAdapter and then set the adapter on the ListView.
+        mAdAdapter.registerAdRenderer(adRenderer);
+        listView.setAdapter(mAdAdapter);
+        return view;
+    }
+
+    @Override
+    public void onDestroyView() {
+        // You must call this or the ad adapter may cause a memory leak.
+        mAdAdapter.destroy();
+        super.onDestroyView();
+    }
+
+    @Override
+    public void onResume() {
+        // MoPub recommends loading knew ads when the user returns to your activity.
+        mAdAdapter.loadAds(mAdConfiguration.getAdUnitId(), mRequestParameters);
+        super.onResume();
+    }
+}
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/SimpleAdsDemo.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/SimpleAdsDemo.java
deleted file mode 100644
index c81aebf4..00000000
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/SimpleAdsDemo.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
-* Copyright (c) 2010-2013, MoPub Inc.
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are
-* met:
-*
-*  Redistributions of source code must retain the above copyright
-*   notice, this list of conditions and the following disclaimer.
-*
-*  Redistributions in binary form must reproduce the above copyright
-*   notice, this list of conditions and the following disclaimer in the
-*   documentation and/or other materials provided with the distribution.
-*
-*  Neither the name of 'MoPub Inc.' nor the names of its contributors
-*   may be used to endorse or promote products derived from this software
-*   without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-* TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-* PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
-* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-* PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-package com.mopub.simpleadsdemo;
-
-import android.os.Bundle;
-import android.support.v4.app.FragmentActivity;
-import android.support.v4.app.FragmentTabHost;
-
-import com.mopub.mobileads.MoPubConversionTracker;
-
-public class SimpleAdsDemo extends FragmentActivity {
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.main);
-
-        FragmentTabHost mTabHost = (FragmentTabHost)findViewById(R.id.tabhost);
-        mTabHost.setup(this, getSupportFragmentManager(), R.id.tabcontent);
-
-        mTabHost.addTab(mTabHost.newTabSpec("banners").setIndicator("Banners"),
-                BannersFragment.class, null);
-
-        mTabHost.addTab(mTabHost.newTabSpec("interstitials").setIndicator("Full"),
-        		InterstitialFragment.class, null);
-
-        mTabHost.addTab(mTabHost.newTabSpec("native").setIndicator("Native"),
-                NativeFragment.class, null);
-        
-        mTabHost.addTab(mTabHost.newTabSpec("about").setIndicator("About"),
-        		AboutFragment.class, null);
-
-
-        // Conversion tracking
-        new MoPubConversionTracker().reportAppOpen(this);
-    }
-}
\ No newline at end of file
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/Utils.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/Utils.java
index 0b50d55d..f63af8fe 100644
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/Utils.java
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/Utils.java
@@ -4,15 +4,14 @@
 import android.util.Log;
 import android.view.View;
 import android.view.inputmethod.InputMethodManager;
-import android.widget.EditText;
 import android.widget.Toast;
 
-public class Utils {
-    public static final String LOGTAG = "MoPub Demo";
+class Utils {
+    static final String LOGTAG = "MoPub Sample App";
 
     private Utils() {}
 
-    public static void validateAdUnitId(String adUnitId) throws IllegalArgumentException {
+    static void validateAdUnitId(String adUnitId) throws IllegalArgumentException {
         if (adUnitId == null) {
             throw new IllegalArgumentException("Invalid Ad Unit ID: null ad unit.");
         } else if (adUnitId.length() == 0) {
@@ -24,17 +23,17 @@ public static void validateAdUnitId(String adUnitId) throws IllegalArgumentExcep
         }
     }
 
-    public static void hideSoftKeyboard(final EditText editText) {
-        InputMethodManager inputMethodManager =
-                (InputMethodManager) editText.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
-        inputMethodManager.hideSoftInputFromWindow(editText.getWindowToken(), 0);
+    static void hideSoftKeyboard(final View view) {
+        final InputMethodManager inputMethodManager =
+                (InputMethodManager) view.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
+        inputMethodManager.hideSoftInputFromWindow(view.getWindowToken(), 0);
     }
 
-    public static boolean isAlphaNumeric(String input) {
+    static boolean isAlphaNumeric(final String input) {
         return input.matches("^[a-zA-Z0-9-_]*$");
     }
 
-    public static void logToast(Context context, String message) {
+    static void logToast(Context context, String message) {
         Log.d(LOGTAG, message);
         Toast.makeText(context, message, Toast.LENGTH_SHORT).show();
     }
diff --git a/mopub-sdk/AndroidManifest.xml b/mopub-sdk/AndroidManifest.xml
index 91419b01..c7cfe7d7 100644
--- a/mopub-sdk/AndroidManifest.xml
+++ b/mopub-sdk/AndroidManifest.xml
@@ -3,5 +3,5 @@
 		package="com.mopub.mobileads"
 		android:versionCode="1"
 		android:versionName="1.0">
-	<uses-sdk android:minSdkVersion="8"/>
+	<uses-sdk android:minSdkVersion="9"/>
 </manifest>
\ No newline at end of file
diff --git a/mopub-sdk/pom.xml b/mopub-sdk/pom.xml
index 2cbbc97f..f8f559b5 100644
--- a/mopub-sdk/pom.xml
+++ b/mopub-sdk/pom.xml
@@ -36,39 +36,17 @@
             <scope>test</scope>
         </dependency>
 
-        <dependency>
-            <groupId>org.apache.httpcomponents</groupId>
-            <artifactId>httpcore</artifactId>
-            <version>4.0.1</version>
-            <scope>test</scope>
-        </dependency>
-
         <dependency>
             <groupId>com.squareup</groupId>
             <artifactId>fest-android</artifactId>
-            <version>1.0.1</version>
-            <scope>test</scope>
-        </dependency>
-
-        <!-- this needs to come above fest-reflect or we pick up the wrong org.fest.util.Strings -->
-        <dependency>
-            <groupId>org.easytesting</groupId>
-            <artifactId>fest-assert-core</artifactId>
-            <version>2.0M9</version>
-            <scope>test</scope>
-        </dependency>
-
-        <dependency>
-            <groupId>org.easytesting</groupId>
-            <artifactId>fest-reflect</artifactId>
-            <version>1.4</version>
+            <version>1.0.7</version>
             <scope>test</scope>
         </dependency>
 
         <dependency>
             <groupId>junit</groupId>
-            <artifactId>junit</artifactId>
-            <version>4.8.2</version>
+            <artifactId>junit-dep</artifactId>
+            <version>4.10</version>
             <scope>test</scope>
         </dependency>
 
@@ -129,6 +107,7 @@
                     <excludes>
                         <exclude>**/Test*.java</exclude>
                     </excludes>
+                    <parallel>classesAndMethods</parallel>
                 </configuration>
             </plugin>
         </plugins>
diff --git a/mopub-sdk/proguard-project.txt b/mopub-sdk/proguard-project.txt
new file mode 100644
index 00000000..33978243
--- /dev/null
+++ b/mopub-sdk/proguard-project.txt
@@ -0,0 +1,17 @@
+# MoPub Proguard Config
+# NOTE: You should also include the Android Proguard config found with the build tools:
+# $ANDROID_HOME/tools/proguard/proguard-android.txt
+
+# Keep public classes and methods.
+-keepclassmembers class com.mopub.** { public *; }
+-keep public class com.mopub.**
+-keep public class android.webkit.JavascriptInterface {}
+
+# Explicitly keep any custom event classes in any package.
+-keep class * extends com.mopub.mobileads.CustomEventBanner {}
+-keep class * extends com.mopub.mobileads.CustomEventInterstitial {}
+-keep class * extends com.mopub.nativeads.CustomEventNative {}
+
+# Support for Android Advertiser ID.
+-keep class com.google.android.gms.common.GooglePlayServicesUtil {*;}
+-keep class com.google.android.gms.ads.identifier.AdvertisingIdClient {*;}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/AdUrlGenerator.java b/mopub-sdk/src/main/java/com/mopub/common/AdUrlGenerator.java
index 7852fd5e..18ff7ab2 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/AdUrlGenerator.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/AdUrlGenerator.java
@@ -74,7 +74,6 @@
     protected String mAdUnitId;
     protected String mKeywords;
     protected Location mLocation;
-    protected boolean mFacebookSupportEnabled;
 
     public static enum TwitterAppInstalledStatus {
         UNKNOWN,
@@ -110,11 +109,6 @@ public AdUrlGenerator withKeywords(String keywords) {
         return this;
     }
 
-    public AdUrlGenerator withFacebookSupported(boolean enabled) {
-        mFacebookSupportEnabled = enabled;
-        return this;
-    }
-
     public AdUrlGenerator withLocation(Location location) {
         mLocation = location;
         return this;
@@ -249,4 +243,12 @@ public TwitterAppInstalledStatus getTwitterAppInstallStatus() {
     public static void setTwitterAppInstalledStatus(TwitterAppInstalledStatus status) {
         sTwitterAppInstalledStatus = status;
     }
+
+    /**
+     * @deprecated As of release 2.4
+     */
+    @Deprecated
+    public AdUrlGenerator withFacebookSupported(boolean enabled) {
+        return this;
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/CacheService.java b/mopub-sdk/src/main/java/com/mopub/common/CacheService.java
index da362092..b61a62ba 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/CacheService.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/CacheService.java
@@ -1,6 +1,7 @@
 package com.mopub.common;
 
 import android.content.Context;
+import android.graphics.Bitmap;
 import android.os.AsyncTask;
 import android.support.v4.util.LruCache;
 
@@ -20,6 +21,10 @@
 import static com.mopub.common.DiskLruCache.open;
 
 public class CacheService {
+    public static interface DiskLruCacheGetListener {
+        void onComplete(final String key, final byte[] content);
+    }
+
     static final String UNIQUE_CACHE_NAME = "mopub-cache";
     private static final int APP_VERSION = 1;
     // The number of values per cache entry. Must be positive.
@@ -27,16 +32,16 @@
     private static final int DISK_CACHE_INDEX = 0;
 
     private static DiskLruCache sDiskLruCache;
-    private static MemoryLruCache sMemoryLruCache;
+    private static BitmapLruCache sBitmapLruCache;
 
-    public static boolean initializeMemoryCache(final Context context) {
+    public static boolean initializeBitmapCache(final Context context) {
         if (context == null) {
             return false;
         }
 
-        if (sMemoryLruCache == null) {
+        if (sBitmapLruCache == null) {
             final int memoryCacheSizeBytes = DeviceUtils.memoryCacheSizeBytes(context);
-            sMemoryLruCache = new MemoryLruCache(memoryCacheSizeBytes);
+            sBitmapLruCache = new BitmapLruCache(memoryCacheSizeBytes);
         }
         return true;
     }
@@ -63,8 +68,8 @@ public static boolean initializeDiskCache(final Context context) {
         return true;
     }
 
-    public static void initializeCaches(final Context context) {
-        initializeMemoryCache(context);
+    public static void initialize(final Context context) {
+        initializeBitmapCache(context);
         initializeDiskCache(context);
     }
 
@@ -105,12 +110,12 @@ public static String getFilePathDiskCache(final String key) {
                 + DISK_CACHE_INDEX;
     }
 
-    public static byte[] getFromMemoryCache(final String key) {
-        if (sMemoryLruCache == null) {
+    public static Bitmap getFromBitmapCache(final String key) {
+        if (sBitmapLruCache == null) {
             return null;
         }
 
-        return sMemoryLruCache.get(key);
+        return sBitmapLruCache.get(key);
     }
 
     public static byte[] getFromDiskCache(final String key) {
@@ -151,20 +156,12 @@ public static void getFromDiskCacheAsync(final String key, final DiskLruCacheGet
         new DiskLruCacheGetTask(key, diskLruCacheGetListener).execute();
     }
 
-    public static byte[] get(final String key) {
-        byte[] bytes = getFromMemoryCache(key);
-        if (bytes != null) {
-            return bytes;
-        }
-        return getFromDiskCache(key);
-    }
-
-    public static void putToMemoryCache(final String key, final byte[] content) {
-        if (sMemoryLruCache == null) {
+    public static void putToBitmapCache(final String key, final Bitmap bitmap) {
+        if (sBitmapLruCache == null) {
             return;
         }
 
-        sMemoryLruCache.put(key, content);
+        sBitmapLruCache.put(key, bitmap);
     }
 
     public static boolean putToDiskCache(final String key, final byte[] content) {
@@ -211,30 +208,21 @@ public static void putToDiskCacheAsync(final String key, final byte[] content) {
         new DiskLruCachePutTask(key, content).execute();
     }
 
-    public static void put(final String key, final byte[] content) {
-        putToMemoryCache(key, content);
-        putToDiskCacheAsync(key, content);
-    }
-
-    private static class MemoryLruCache extends LruCache<String, byte[]> {
-        public MemoryLruCache(int maxSize) {
+    private static class BitmapLruCache extends LruCache<String, Bitmap> {
+        public BitmapLruCache(final int maxSize) {
             super(maxSize);
         }
 
         @Override
-        protected int sizeOf(final String key, final byte[] bytes) {
-            if (bytes != null && bytes.length > 0) {
-                return bytes.length;
+        protected int sizeOf(final String key, final Bitmap bitmap) {
+            if (bitmap != null) {
+                return bitmap.getRowBytes() * bitmap.getHeight();
             }
 
-            return super.sizeOf(key, bytes);
+            return super.sizeOf(key, bitmap);
         }
     }
 
-    public static interface DiskLruCacheGetListener {
-        void onComplete(final String key, final byte[] content);
-    }
-
     private static class DiskLruCacheGetTask extends AsyncTask<Void, Void, byte[]> {
         private final DiskLruCacheGetListener mDiskLruCacheGetListener;
         private final String mKey;
@@ -287,6 +275,7 @@ protected Void doInBackground(Void... voids) {
 
     // Testing
     @Deprecated
+    @VisibleForTesting
     public static void clearAndNullCaches() {
         if (sDiskLruCache != null) {
             try {
@@ -296,20 +285,22 @@ public static void clearAndNullCaches() {
                 sDiskLruCache = null;
             }
         }
-        if (sMemoryLruCache != null) {
-            sMemoryLruCache.evictAll();
-            sMemoryLruCache = null;
+        if (sBitmapLruCache != null) {
+            sBitmapLruCache.evictAll();
+            sBitmapLruCache = null;
         }
     }
 
     // Testing
     @Deprecated
-    public static LruCache<String, byte[]> getMemoryLruCache() {
-        return sMemoryLruCache;
+    @VisibleForTesting
+    public static LruCache<String, Bitmap> getBitmapLruCache() {
+        return sBitmapLruCache;
     }
 
     // Testing
     @Deprecated
+    @VisibleForTesting
     public static DiskLruCache getDiskLruCache() {
         return sDiskLruCache;
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/DownloadTask.java b/mopub-sdk/src/main/java/com/mopub/common/DownloadTask.java
index 3e551b58..702da94c 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/DownloadTask.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/DownloadTask.java
@@ -40,7 +40,7 @@ protected DownloadResponse doInBackground(final HttpUriRequest... httpUriRequest
             final HttpResponse httpResponse = httpClient.execute(httpUriRequest);
             return new DownloadResponse(httpResponse);
         } catch (Exception e) {
-            MoPubLog.d("Download task threw an internal exception");
+            MoPubLog.d("Download task threw an internal exception", e);
             cancel(true);
             return null;
         } finally {
diff --git a/mopub-sdk/src/main/java/com/mopub/common/HttpResponses.java b/mopub-sdk/src/main/java/com/mopub/common/HttpResponses.java
index df8dbaaa..457a69fb 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/HttpResponses.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/HttpResponses.java
@@ -1,12 +1,14 @@
 package com.mopub.common;
 
 import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
 
 import org.json.JSONObject;
 import org.json.JSONTokener;
 
+import static android.graphics.BitmapFactory.decodeByteArray;
+
 public final class HttpResponses {
+
     private HttpResponses() {}
 
     public static Bitmap asBitmap(final DownloadResponse downloadResponse) {
@@ -15,7 +17,7 @@ public static Bitmap asBitmap(final DownloadResponse downloadResponse) {
         }
 
         final byte[] bytes = downloadResponse.getByteArray();
-        return BitmapFactory.decodeByteArray(bytes, 0, bytes.length);
+        return decodeByteArray(bytes, 0, bytes.length);
     }
 
     public static JSONObject asJsonObject(final DownloadResponse downloadResponse) {
diff --git a/mopub-sdk/src/main/java/com/mopub/common/MoPub.java b/mopub-sdk/src/main/java/com/mopub/common/MoPub.java
index 8f388b7a..b8d095d9 100644
--- a/mopub-sdk/src/main/java/com/mopub/common/MoPub.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/MoPub.java
@@ -33,5 +33,5 @@
 package com.mopub.common;
 
 public class MoPub {
-    public static final String SDK_VERSION = "2.3";
+    public static final String SDK_VERSION = "2.4.0";
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/VisibleForTesting.java b/mopub-sdk/src/main/java/com/mopub/common/VisibleForTesting.java
new file mode 100644
index 00000000..75dec6a8
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/VisibleForTesting.java
@@ -0,0 +1,9 @@
+package com.mopub.common;
+
+/**
+ * An annotation that indicates that the visibility of a type or member has been relaxed to make
+ * the code testable. You should not use VisibleForTesting methods when integrating the SDK, as
+ * they may change in future versions.
+ */
+public @interface VisibleForTesting {
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/Visibility.java b/mopub-sdk/src/main/java/com/mopub/common/util/Visibility.java
new file mode 100644
index 00000000..414aee91
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Visibility.java
@@ -0,0 +1,16 @@
+package com.mopub.common.util;
+
+import android.view.View;
+
+public class Visibility {
+    private Visibility() {}
+
+    public static boolean isScreenVisible(final int visibility) {
+        return visibility == View.VISIBLE;
+    }
+
+    public static boolean hasScreenVisibilityChanged(final int oldVisibility,
+            final int newVisibility) {
+        return (isScreenVisible(oldVisibility) != isScreenVisible(newVisibility));
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertReporter.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertReporter.java
index 5f19a7d9..d36beb93 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertReporter.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertReporter.java
@@ -43,9 +43,12 @@
 import com.mopub.common.util.Streams;
 import com.mopub.mobileads.util.Base64;
 
-import java.io.*;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
 import java.text.SimpleDateFormat;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Date;
 
 public class AdAlertReporter {
     private static final String EMAIL_RECIPIENT = "creative-review@mopub.com";
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdConfiguration.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdConfiguration.java
index 9160fe5d..8edd353d 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdConfiguration.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/AdConfiguration.java
@@ -44,13 +44,9 @@
 
 import org.apache.http.HttpResponse;
 
-import java.io.*;
-import java.util.*;
+import java.io.Serializable;
+import java.util.Map;
 
-import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
-import static com.mopub.mobileads.util.HttpResponses.extractHeader;
-import static com.mopub.mobileads.util.HttpResponses.extractIntHeader;
-import static com.mopub.mobileads.util.HttpResponses.extractIntegerHeader;
 import static com.mopub.common.util.ResponseHeader.AD_TIMEOUT;
 import static com.mopub.common.util.ResponseHeader.AD_TYPE;
 import static com.mopub.common.util.ResponseHeader.CLICKTHROUGH_URL;
@@ -62,6 +58,10 @@
 import static com.mopub.common.util.ResponseHeader.REDIRECT_URL;
 import static com.mopub.common.util.ResponseHeader.REFRESH_TIME;
 import static com.mopub.common.util.ResponseHeader.WIDTH;
+import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
+import static com.mopub.mobileads.util.HttpResponses.extractHeader;
+import static com.mopub.mobileads.util.HttpResponses.extractIntHeader;
+import static com.mopub.mobileads.util.HttpResponses.extractIntegerHeader;
 
 public class AdConfiguration implements Serializable {
     private static final long serialVersionUID = 0L;
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdFetchTask.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdFetchTask.java
index e4893cbf..e5f41452 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdFetchTask.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/AdFetchTask.java
@@ -34,17 +34,19 @@
 
 import android.os.AsyncTask;
 import android.util.Log;
+
 import com.mopub.mobileads.factories.HttpClientFactory;
+
 import org.apache.http.HttpResponse;
 import org.apache.http.HttpStatus;
 import org.apache.http.client.HttpClient;
 import org.apache.http.client.methods.HttpGet;
 import org.apache.http.conn.ClientConnectionManager;
 
-import static com.mopub.mobileads.util.HttpResponses.extractHeader;
 import static com.mopub.common.util.ResponseHeader.AD_TYPE;
 import static com.mopub.common.util.ResponseHeader.USER_AGENT;
 import static com.mopub.common.util.ResponseHeader.WARMUP;
+import static com.mopub.mobileads.util.HttpResponses.extractHeader;
 
 public class AdFetchTask extends AsyncTask<String, Void, AdLoadTask> {
     private TaskTracker mTaskTracker;
@@ -109,7 +111,7 @@ private boolean responseContainsContent(HttpResponse response) {
         // Ensure that the ad type header is valid and not "clear".
         String adType = extractHeader(response, AD_TYPE);
         if ("clear".equals(adType)) {
-            Log.d("MoPub", "No inventory found for adunit (" + mAdViewController.getAdUnitId() + ").");
+            Log.d("MoPub", "No ads found for adunit (" + mAdViewController.getAdUnitId() + ").");
             mFetchStatus = AdFetcher.FetchStatus.CLEAR_AD_TYPE;
             return false;
         }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdViewController.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdViewController.java
index 3f78096b..d421dfb2 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdViewController.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/AdViewController.java
@@ -52,11 +52,16 @@
 import org.apache.http.client.methods.HttpGet;
 import org.apache.http.impl.client.DefaultHttpClient;
 
-import java.util.*;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.WeakHashMap;
 
 import static android.Manifest.permission.ACCESS_NETWORK_STATE;
-import static com.mopub.common.LocationService.*;
-import static com.mopub.common.GpsHelper.*;
+import static com.mopub.common.GpsHelper.GpsHelperListener;
+import static com.mopub.common.GpsHelper.asyncFetchAdvertisingInfo;
+import static com.mopub.common.GpsHelper.asyncFetchAdvertisingInfoIfNotCached;
+import static com.mopub.common.LocationService.LocationAwareness;
+import static com.mopub.common.LocationService.getLastKnownLocation;
 import static com.mopub.mobileads.MoPubView.DEFAULT_LOCATION_PRECISION;
 
 public class AdViewController {
@@ -89,7 +94,6 @@
     private Location mLocation;
     private LocationAwareness mLocationAwareness = LocationAwareness.NORMAL;
     private int mLocationPrecision = DEFAULT_LOCATION_PRECISION;
-    private boolean mIsFacebookSupported = true;
     private boolean mIsTesting;
     private boolean mAdWasLoaded;
 
@@ -204,14 +208,6 @@ public void setKeywords(String keywords) {
         mKeywords = keywords;
     }
 
-    public boolean isFacebookSupported() {
-        return mIsFacebookSupported;
-    }
-
-    public void setFacebookSupported(boolean enabled) {
-        mIsFacebookSupported = enabled;
-    }
-
     public Location getLocation() {
         return mLocation;
     }
@@ -246,11 +242,6 @@ public String getClickthroughUrl() {
         return mAdConfiguration.getClickthroughUrl();
     }
 
-    @Deprecated
-    public void setClickthroughUrl(String clickthroughUrl) {
-        mAdConfiguration.setClickthroughUrl(clickthroughUrl);
-    }
-
     public String getRedirectUrl() {
         return mAdConfiguration.getRedirectUrl();
     }
@@ -415,7 +406,6 @@ String generateAdUrl() {
         return mUrlGenerator
                 .withAdUnitId(mAdConfiguration.getAdUnitId())
                 .withKeywords(mKeywords)
-                .withFacebookSupported(mIsFacebookSupported)
                 .withLocation(mLocation)
                 .generateUrlString(getServerHostname());
     }
@@ -527,4 +517,23 @@ public void customEventDidFailToLoadAd() {
     public void customEventActionWillBegin() {
         registerClick();
     }
+
+    @Deprecated
+    public void setClickthroughUrl(String clickthroughUrl) {
+        mAdConfiguration.setClickthroughUrl(clickthroughUrl);
+    }
+
+    /**
+     * @deprecated As of release 2.4
+     */
+    @Deprecated
+    public boolean isFacebookSupported() {
+        return false;
+    }
+
+    /**
+     * @deprecated As of release 2.4
+     */
+    @Deprecated
+    public void setFacebookSupported(boolean enabled) {}
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseHtmlWebView.java b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseHtmlWebView.java
index 3b30f0c5..be3c3890 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseHtmlWebView.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseHtmlWebView.java
@@ -38,9 +38,9 @@
 import android.view.MotionEvent;
 import android.view.View;
 
-import static com.mopub.mobileads.ViewGestureDetector.UserClickListener;
 import static com.mopub.common.util.VersionCode.ICE_CREAM_SANDWICH;
 import static com.mopub.common.util.VersionCode.currentApiLevel;
+import static com.mopub.mobileads.ViewGestureDetector.UserClickListener;
 
 public class BaseHtmlWebView extends BaseWebView implements UserClickListener {
     private final ViewGestureDetector mViewGestureDetector;
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseInterstitialActivity.java b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseInterstitialActivity.java
index 7ddca8df..921e0b95 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseInterstitialActivity.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseInterstitialActivity.java
@@ -96,10 +96,10 @@ public void onClick(final View view) {
             }
         };
 
+        // The contentView needs to be a RelativeLayout so the close button can be properly aligned
         mLayout = new RelativeLayout(this);
         final RelativeLayout.LayoutParams adViewLayout = new RelativeLayout.LayoutParams(
-                RelativeLayout.LayoutParams.FILL_PARENT, RelativeLayout.LayoutParams.WRAP_CONTENT);
-        adViewLayout.addRule(RelativeLayout.CENTER_IN_PARENT);
+                RelativeLayout.LayoutParams.MATCH_PARENT, RelativeLayout.LayoutParams.MATCH_PARENT);
         mLayout.addView(getAdView(), adViewLayout);
         setContentView(mLayout);
 
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventInterstitialAdapter.java b/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventInterstitialAdapter.java
index 4ef0f468..e52daf94 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventInterstitialAdapter.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/CustomEventInterstitialAdapter.java
@@ -61,12 +61,12 @@
     private final Handler mHandler;
     private final Runnable mTimeout;
 
-    public CustomEventInterstitialAdapter(MoPubInterstitial moPubInterstitial, String className, String jsonParams) {
+    public CustomEventInterstitialAdapter(final MoPubInterstitial moPubInterstitial, final String className, final String jsonParams) {
         mHandler = new Handler();
         mMoPubInterstitial = moPubInterstitial;
         mServerExtras = new HashMap<String, String>();
         mLocalExtras = new HashMap<String, Object>();
-        mContext = moPubInterstitial.getActivity();
+        mContext = mMoPubInterstitial.getActivity();
         mTimeout = new Runnable() {
             @Override
             public void run() {
@@ -81,22 +81,23 @@ public void run() {
             mCustomEventInterstitial = CustomEventInterstitialFactory.create(className);
         } catch (Exception exception) {
             Log.d("MoPub", "Couldn't locate or instantiate custom event: " + className + ".");
-            if (mCustomEventInterstitialAdapterListener != null) mCustomEventInterstitialAdapterListener.onCustomEventInterstitialFailed(ADAPTER_NOT_FOUND);
+            mMoPubInterstitial.onCustomEventInterstitialFailed(ADAPTER_NOT_FOUND);
+            return;
         }
-        
+
         // Attempt to load the JSON extras into mServerExtras.
         try {
             mServerExtras = Json.jsonStringToMap(jsonParams);
         } catch (Exception exception) {
             Log.d("MoPub", "Failed to create Map from JSON: " + jsonParams);
         }
-        
-        mLocalExtras = moPubInterstitial.getLocalExtras();
-        if (moPubInterstitial.getLocation() != null) {
-            mLocalExtras.put("location", moPubInterstitial.getLocation());
+
+        mLocalExtras = mMoPubInterstitial.getLocalExtras();
+        if (mMoPubInterstitial.getLocation() != null) {
+            mLocalExtras.put("location", mMoPubInterstitial.getLocation());
         }
 
-        AdViewController adViewController = moPubInterstitial.getMoPubInterstitialView().getAdViewController();
+        final AdViewController adViewController = mMoPubInterstitial.getMoPubInterstitialView().getAdViewController();
         if (adViewController != null) {
             mLocalExtras.put(AD_CONFIGURATION_KEY, adViewController.getAdConfiguration());
         }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/FacebookKeywordProvider.java b/mopub-sdk/src/main/java/com/mopub/mobileads/FacebookKeywordProvider.java
index 401aa998..8136348a 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/FacebookKeywordProvider.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/FacebookKeywordProvider.java
@@ -33,48 +33,17 @@
 package com.mopub.mobileads;
 
 import android.content.Context;
-import android.database.Cursor;
-import android.net.Uri;
-import android.util.Log;
 
-/*
- * This class enables the MoPub SDK to deliver targeted ads from Facebook via MoPub Marketplace
- * (MoPub's real-time bidding ad exchange) as part of a test program. This class sends an identifier
- * to Facebook so Facebook can select the ad MoPub will serve in your app through MoPub Marketplace.
- * If this class is removed from the SDK, your application will not receive targeted ads from
- * Facebook.
+/**
+ * @deprecated As of release 2.4
  */
-
+@Deprecated
 public class FacebookKeywordProvider {
-    private static final Uri ID_URL = Uri.parse("content://com.facebook.katana.provider.AttributionIdProvider");
-    private static final String ID_COLUMN_NAME = "aid";
-    private static final String ID_PREFIX = "FBATTRID:";
-
+    /**
+     * @deprecated As of release 2.4
+     */
+    @Deprecated
     public static String getKeyword(Context context) {
-        Cursor cursor = null;
-
-        try {
-            String projection[] = {ID_COLUMN_NAME};
-            cursor = context.getContentResolver().query(ID_URL, projection, null, null, null);
-            
-            if (cursor == null || !cursor.moveToFirst()) {
-                return null;
-            }
-            
-            String attributionId = cursor.getString(cursor.getColumnIndex(ID_COLUMN_NAME));
-            
-            if (attributionId == null || attributionId.length() == 0) {
-                return null;
-            }
-            
-            return ID_PREFIX + attributionId;
-        } catch (Exception exception) {
-            Log.d("MoPub", "Unable to retrieve FBATTRID: " + exception.toString());
-            return null;
-        } finally {
-            if (cursor != null) {
-                cursor.close();
-            }
-        }
+        return null;
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubErrorCode.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubErrorCode.java
index de6d1d11..1381113a 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubErrorCode.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubErrorCode.java
@@ -33,7 +33,7 @@
 package com.mopub.mobileads;
 
 public enum MoPubErrorCode {
-    NO_FILL("No inventory."),
+    NO_FILL("No ads found."),
     SERVER_ERROR("Unable to connect to MoPub adserver."),
     INTERNAL_ERROR("Unable to serve ad due to invalid internal state."),
     CANCELLED("Ad request was cancelled."),
@@ -41,7 +41,7 @@
     ADAPTER_NOT_FOUND("Unable to find Native Network or Custom Event adapter."),
     ADAPTER_CONFIGURATION_ERROR("Native Network or Custom Event adapter was configured incorrectly."),
     NETWORK_TIMEOUT("Third-party network failed to respond in a timely manner."),
-    NETWORK_NO_FILL("Third-party network failed to provide inventory."),
+    NETWORK_NO_FILL("Third-party network failed to provide an ad."),
     NETWORK_INVALID_STATE("Third-party network failed due to invalid internal state."),
     MRAID_LOAD_ERROR("Error loading MRAID ad."),
     VIDEO_CACHE_ERROR("Error creating a cache to store downloaded videos."),
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubInterstitial.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubInterstitial.java
index 85df9c9a..d81f5c31 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubInterstitial.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubInterstitial.java
@@ -39,12 +39,12 @@
 
 import com.mopub.mobileads.factories.CustomEventInterstitialAdapterFactory;
 
-import java.util.*;
+import java.util.Map;
 
-import static com.mopub.common.LocationService.*;
-import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
+import static com.mopub.common.LocationService.LocationAwareness;
 import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_DATA;
 import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_NAME;
+import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
 
 public class MoPubInterstitial implements CustomEventInterstitialAdapter.CustomEventInterstitialAdapterListener {
 
@@ -152,14 +152,6 @@ public String getKeywords() {
         return mInterstitialView.getKeywords();
     }
 
-    public void setFacebookSupported(boolean enabled) {
-        mInterstitialView.setFacebookSupported(enabled);
-    }
-
-    public boolean isFacebookSupported() {
-        return mInterstitialView.isFacebookSupported();
-    }
-
     public Activity getActivity() {
         return mActivity;
     }
@@ -351,4 +343,18 @@ public void customEventDidFailToLoadAd() {
     public void customEventActionWillBegin() {
         if (mInterstitialView != null) mInterstitialView.registerClick();
     }
+
+    /**
+     * @deprecated As of release 2.4
+     */
+    @Deprecated
+    public void setFacebookSupported(boolean enabled) {}
+
+    /**
+     * @deprecated As of release 2.4
+     */
+    @Deprecated
+    public boolean isFacebookSupported() {
+        return false;
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubView.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubView.java
index a9e887de..c010a82e 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubView.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubView.java
@@ -45,18 +45,19 @@
 import android.widget.FrameLayout;
 
 import com.mopub.common.util.ManifestUtils;
+import com.mopub.common.util.Visibility;
 import com.mopub.mobileads.factories.AdViewControllerFactory;
 import com.mopub.mobileads.factories.CustomEventBannerAdapterFactory;
 
-import java.util.*;
+import java.util.Collections;
+import java.util.Map;
 
-import static com.mopub.common.LocationService.*;
-import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
+import static com.mopub.common.LocationService.LocationAwareness;
 import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_DATA;
 import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_NAME;
+import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
 
 public class MoPubView extends FrameLayout {
-
     public interface BannerAdListener {
         public void onBannerLoaded(MoPubView banner);
         public void onBannerFailed(MoPubView banner, MoPubErrorCode errorCode);
@@ -74,8 +75,8 @@
     protected CustomEventBannerAdapter mCustomEventBannerAdapter;
 
     private Context mContext;
+    private int mScreenVisibility;
     private BroadcastReceiver mScreenStateReceiver;
-    private boolean mIsInForeground;
     private LocationAwareness mLocationAwareness;
 
     private BannerAdListener mBannerAdListener;
@@ -97,7 +98,7 @@ public MoPubView(Context context, AttributeSet attrs) {
         ManifestUtils.checkWebViewActivitiesDeclared(context);
 
         mContext = context;
-        mIsInForeground = (getVisibility() == VISIBLE);
+        mScreenVisibility = getVisibility();
         mLocationAwareness = LocationAwareness.NORMAL;
 
         setHorizontalScrollBarEnabled(false);
@@ -122,16 +123,16 @@ public MoPubView(Context context, AttributeSet attrs) {
     private void registerScreenStateBroadcastReceiver() {
         mScreenStateReceiver = new BroadcastReceiver() {
             public void onReceive(final Context context, final Intent intent) {
-                if (!mIsInForeground || intent == null) {
+                if (!Visibility.isScreenVisible(mScreenVisibility) || intent == null) {
                     return;
                 }
 
                 final String action = intent.getAction();
 
                 if (Intent.ACTION_USER_PRESENT.equals(action)) {
-                    setAdVisibility(true);
+                    setAdVisibility(View.VISIBLE);
                 } else if (Intent.ACTION_SCREEN_OFF.equals(action)) {
-                    setAdVisibility(false);
+                    setAdVisibility(View.GONE);
                 }
             }
         };
@@ -215,19 +216,20 @@ protected void trackNativeImpression() {
     }
 
     @Override
-    protected void onWindowVisibilityChanged(int visibility) {
-        final boolean isVisible = (visibility == VISIBLE);
-
-        mIsInForeground = isVisible;
-        setAdVisibility(isVisible);
+    protected void onWindowVisibilityChanged(final int visibility) {
+        // Ignore transitions between View.GONE and View.INVISIBLE
+        if (Visibility.hasScreenVisibilityChanged(mScreenVisibility, visibility)) {
+            mScreenVisibility = visibility;
+            setAdVisibility(mScreenVisibility);
+        }
     }
 
-    private void setAdVisibility(boolean isVisible) {
+    private void setAdVisibility(final int visibility) {
         if (mAdViewController == null) {
             return;
         }
 
-        if (isVisible) {
+        if (Visibility.isScreenVisible(visibility)) {
             mAdViewController.unpauseRefresh();
         } else {
             mAdViewController.pauseRefresh();
@@ -299,14 +301,6 @@ public String getKeywords() {
         return (mAdViewController != null) ? mAdViewController.getKeywords() : null;
     }
 
-    public void setFacebookSupported(boolean enabled) {
-        if (mAdViewController != null) mAdViewController.setFacebookSupported(enabled);
-    }
-
-    public boolean isFacebookSupported() {
-        return (mAdViewController != null) ? mAdViewController.isFacebookSupported() : false;
-    }
-
     public void setLocation(Location location) {
         if (mAdViewController != null) mAdViewController.setLocation(location);
     }
@@ -503,4 +497,18 @@ public void customEventDidFailToLoadAd() {
     public void customEventActionWillBegin() {
         if (mAdViewController != null) mAdViewController.customEventActionWillBegin();
     }
+
+    /**
+     * @deprecated As of release 2.4
+     */
+    @Deprecated
+    public void setFacebookSupported(boolean enabled) {}
+
+    /**
+     * @deprecated As of release 2.4
+     */
+    @Deprecated
+    public boolean isFacebookSupported() {
+        return false;
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidBanner.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidBanner.java
index 85455ffe..35f60206 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidBanner.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidBanner.java
@@ -34,10 +34,11 @@
 
 import android.content.Context;
 import android.net.Uri;
+
 import com.mopub.mobileads.MraidView.ViewState;
 import com.mopub.mobileads.factories.MraidViewFactory;
 
-import java.util.*;
+import java.util.Map;
 
 import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
 import static com.mopub.mobileads.MoPubErrorCode.MRAID_LOAD_ERROR;
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidVideoViewController.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidVideoViewController.java
index 67582d38..4d706215 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidVideoViewController.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidVideoViewController.java
@@ -42,7 +42,6 @@
 import android.widget.VideoView;
 
 import com.mopub.common.util.Dips;
-import com.mopub.common.util.Drawables;
 
 import static android.view.View.GONE;
 import static android.view.View.OnClickListener;
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidView.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidView.java
index f5e94874..dfe35b4f 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidView.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidView.java
@@ -55,9 +55,12 @@
 import org.apache.http.client.methods.HttpGet;
 import org.apache.http.client.utils.URLEncodedUtils;
 
-import java.io.*;
+import java.io.IOException;
 import java.net.URI;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
 
 import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand;
 import static com.mopub.mobileads.ViewGestureDetector.UserClickListener;
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/WebViewAdUrlGenerator.java b/mopub-sdk/src/main/java/com/mopub/mobileads/WebViewAdUrlGenerator.java
index 24e97126..7c20de9f 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/WebViewAdUrlGenerator.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/WebViewAdUrlGenerator.java
@@ -6,9 +6,6 @@
 import com.mopub.common.AdUrlGenerator;
 import com.mopub.common.GpsHelper;
 import com.mopub.common.MoPub;
-import com.mopub.mobileads.util.Utils;
-
-import java.lang.reflect.Method;
 
 import static com.mopub.mobileads.util.Mraids.isStorePictureSupported;
 
@@ -33,8 +30,7 @@ public String generateUrlString(String serverHostname) {
 
         setDoNotTrack(GpsHelper.isLimitAdTrackingEnabled(mContext));
 
-        String keywords = addKeyword(mKeywords, getFacebookKeyword(mContext, mFacebookSupportEnabled));
-        setKeywords(keywords);
+        setKeywords(mKeywords);
 
         setLocation(mLocation);
 
@@ -73,29 +69,4 @@ private boolean detectIsMraidSupported() {
         }
         return mraid;
     }
-
-    private static String getFacebookKeyword(Context context, final boolean enabled) {
-        if (!enabled) {
-            return null;
-        }
-
-        try {
-            Class<?> facebookKeywordProviderClass = Class.forName("com.mopub.mobileads.FacebookKeywordProvider");
-            Method getKeywordMethod = facebookKeywordProviderClass.getMethod("getKeyword", Context.class);
-
-            return (String) getKeywordMethod.invoke(facebookKeywordProviderClass, context);
-        } catch (Exception exception) {
-            return null;
-        }
-    }
-
-    private static String addKeyword(String keywords, String addition) {
-        if (addition == null || addition.length() == 0) {
-            return keywords;
-        } else if (keywords == null || keywords.length() == 0) {
-            return addition;
-        } else {
-            return keywords + "," + addition;
-        }
-    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/AdapterHelper.java b/mopub-sdk/src/main/java/com/mopub/nativeads/AdapterHelper.java
index ac8de165..3b6b5408 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/AdapterHelper.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/AdapterHelper.java
@@ -5,18 +5,25 @@
 import android.view.View;
 import android.view.ViewGroup;
 
+import com.mopub.common.VisibleForTesting;
 import com.mopub.common.util.MoPubLog;
 
 import java.lang.ref.WeakReference;
 
 import static com.mopub.nativeads.MoPubNative.MoPubNativeListener;
 
+/**
+ * @deprecated As of release 2.4, use {@link com.mopub.nativeads.MoPubAdAdapter} or
+ * {@link com.mopub.nativeads.MoPubStreamAdPlacer} instead
+ */
+@Deprecated
 public final class AdapterHelper {
     private final WeakReference<Activity> mActivity;
     private final Context mApplicationContext;
     private final int mStart;
     private final int mInterval;
 
+    @Deprecated
     public AdapterHelper(final Context context, final int start, final int interval) throws IllegalArgumentException {
         if (context == null) {
             throw new IllegalArgumentException("Illegal argument: Context was null.");
@@ -34,6 +41,7 @@ public AdapterHelper(final Context context, final int start, final int interval)
         mInterval = interval;
     }
 
+    @Deprecated
     public View getAdView(final View convertView,
             final ViewGroup parent,
             final NativeResponse nativeResponse,
@@ -57,15 +65,18 @@ public View getAdView(final View convertView,
     }
 
     // Total number of content rows + ad rows
+    @Deprecated
     public int shiftedCount(final int originalCount) {
         return originalCount + numberOfAdsThatCouldFitWithContent(originalCount);
     }
 
     // Shifted position of content in the backing list
+    @Deprecated
     public int shiftedPosition(final int position) {
         return position - numberOfAdsSeenUpToPosition(position);
     }
 
+    @Deprecated
     public boolean isAdPosition(final int position) {
         if (position < mStart) {
             return false;
@@ -106,6 +117,7 @@ private int numberOfAdsThatCouldFitWithContent(final int contentRowCount) {
 
     // Testing
     @Deprecated
+    @VisibleForTesting
     void clearActivityContext() {
         mActivity.clear();
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ImageDiskTaskManager.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ImageDiskTaskManager.java
index 2f678f7f..5dcda785 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/ImageDiskTaskManager.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/ImageDiskTaskManager.java
@@ -8,22 +8,26 @@
 
 import static com.mopub.common.CacheService.DiskLruCacheGetListener;
 
-class ImageDiskTaskManager extends ImageTaskManager {
+class ImageDiskTaskManager extends TaskManager<Bitmap> {
     private final List<String> mUrls;
+    private final int mMaxImageWidth;
 
-    ImageDiskTaskManager(final List<String> urls, final ImageTaskManagerListener imageTaskManagerListener)
+    ImageDiskTaskManager(final List<String> urls,
+            final TaskManagerListener<Bitmap> imageTaskManagerListener,
+            final int maxImageWidth)
             throws IllegalArgumentException {
         super(urls, imageTaskManagerListener);
+        mMaxImageWidth = maxImageWidth;
         mUrls = urls;
     }
 
     @Override
     void execute() {
         if (mUrls.isEmpty()) {
-            mImageTaskManagerListener.onSuccess(mImages);
+            mImageTaskManagerListener.onSuccess(mResults);
         }
 
-        ImageDiskTaskListener imageDiskTaskListener = new ImageDiskTaskListener();
+        ImageDiskTaskListener imageDiskTaskListener = new ImageDiskTaskListener(mMaxImageWidth);
         for (final String url : mUrls) {
             CacheService.getFromDiskCacheAsync(url, imageDiskTaskListener);
         }
@@ -36,6 +40,13 @@ void failAllTasks() {
     }
 
     private class ImageDiskTaskListener implements DiskLruCacheGetListener {
+
+        private final int mTargetWidth;
+
+        ImageDiskTaskListener(final int targetWidth) {
+            mTargetWidth = targetWidth;
+        }
+
         @Override
         public void onComplete(final String key, final byte[] content) {
             if (key == null) {
@@ -44,13 +55,13 @@ public void onComplete(final String key, final byte[] content) {
             } else {
                 Bitmap bitmap = null;
                 if (content != null) {
-                     bitmap = ImageService.byteArrayToBitmap(content);
+                     bitmap = ImageService.byteArrayToBitmap(content, mTargetWidth);
                 }
-                mImages.put(key, bitmap);
+                mResults.put(key, bitmap);
             }
 
             if (mCompletedCount.incrementAndGet() == mSize) {
-                mImageTaskManagerListener.onSuccess(mImages);
+                mImageTaskManagerListener.onSuccess(mResults);
             }
         }
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ImageDownloadTaskManager.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ImageDownloadTaskManager.java
index d10574b5..0a927cbb 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/ImageDownloadTaskManager.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/ImageDownloadTaskManager.java
@@ -1,10 +1,7 @@
 package com.mopub.nativeads;
 
-import android.graphics.Bitmap;
-
 import com.mopub.common.DownloadResponse;
 import com.mopub.common.DownloadTask;
-import com.mopub.common.HttpResponses;
 import com.mopub.common.util.AsyncTasks;
 import com.mopub.common.util.MoPubLog;
 
@@ -17,17 +14,21 @@
 import java.util.Map;
 
 import static com.mopub.common.DownloadTask.DownloadTaskListener;
-
 import static java.util.Map.Entry;
 
-class ImageDownloadTaskManager extends ImageTaskManager {
+class ImageDownloadTaskManager extends TaskManager<DownloadResponse> {
 
     private final Map<HttpUriRequest, DownloadTask> mDownloadTasks;
+    private final int mRequestedWidth;
 
-    ImageDownloadTaskManager(final List<String> urls, final ImageTaskManagerListener imageTaskManagerListener)
+    ImageDownloadTaskManager(final List<String> urls,
+                             final TaskManagerListener<DownloadResponse> imageTaskManagerListener,
+                             final int requestedWidth)
             throws IllegalArgumentException {
         super(urls, imageTaskManagerListener);
 
+        mRequestedWidth = requestedWidth;
+
         final DownloadTaskListener downloadTaskListener = new ImageDownloadTaskListener();
         mDownloadTasks = new HashMap<HttpUriRequest, DownloadTask>(urls.size());
         for (final String url : urls) {
@@ -39,7 +40,7 @@
     @Override
     void execute() {
         if (mDownloadTasks.isEmpty()) {
-            mImageTaskManagerListener.onSuccess(mImages);
+            mImageTaskManagerListener.onSuccess(mResults);
         }
 
         for (final Entry<HttpUriRequest, DownloadTask> entry : mDownloadTasks.entrySet()) {
@@ -74,18 +75,10 @@ public void onComplete(final String url, final DownloadResponse downloadResponse
                 return;
             }
 
-            final Bitmap bitmap = HttpResponses.asBitmap(downloadResponse);
-
-            if (bitmap == null) {
-                MoPubLog.d("Failed to decode bitmap from response for image: " + url);
-                failAllTasks();
-                return;
-            }
-
-            MoPubLog.d("Successfully downloaded image: " + url);
-            mImages.put(url, bitmap);
+            MoPubLog.d("Successfully downloaded image bye array: " + url);
+            mResults.put(url, downloadResponse);
             if (mCompletedCount.incrementAndGet() == mSize) {
-                mImageTaskManagerListener.onSuccess(mImages);
+                mImageTaskManagerListener.onSuccess(mResults);
             }
         }
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ImageService.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ImageService.java
index 6276a80c..f8b93df9 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/ImageService.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/ImageService.java
@@ -1,32 +1,60 @@
 package com.mopub.nativeads;
 
+import android.annotation.TargetApi;
 import android.content.Context;
 import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
+import android.graphics.Point;
+import android.view.Display;
+import android.view.WindowManager;
 
 import com.mopub.common.CacheService;
+import com.mopub.common.DownloadResponse;
+import com.mopub.common.VisibleForTesting;
 import com.mopub.common.util.MoPubLog;
-import com.mopub.common.util.Streams;
+import com.mopub.common.util.VersionCode;
 
-import java.io.ByteArrayOutputStream;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
-import static com.mopub.nativeads.ImageTaskManager.ImageTaskManagerListener;
+import static android.graphics.BitmapFactory.Options;
+import static android.graphics.BitmapFactory.decodeByteArray;
+import static com.mopub.common.util.VersionCode.HONEYCOMB_MR2;
+import static com.mopub.nativeads.TaskManager.TaskManagerListener;
 import static java.util.Map.Entry;
 
 class ImageService {
-    private static int COMPRESSION_QUALITY = 25;
+    private static final int TWO_MEGABYTES = 2097152;
+    private static int sTargetWidth = -1;
 
     interface ImageServiceListener {
         void onSuccess(Map<String, Bitmap> bitmaps);
         void onFail();
     }
 
+    @TargetApi(13)
+    @VisibleForTesting
+    static void initialize(Context context) {
+        if (sTargetWidth == -1) {
+            // Get Display Options
+            WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
+            Display display = wm.getDefaultDisplay();
+            Point size = new Point();
+            if (VersionCode.currentApiLevel().isBelow(HONEYCOMB_MR2)) {
+                size.set(display.getWidth(), display.getHeight());
+            } else {
+                display.getSize(size);
+            }
+
+            // Make our images no wider than the skinny side of the display.
+            sTargetWidth = Math.min(size.x, size.y);
+        }
+    }
+
     static void get(final Context context, final List<String> urls, final ImageServiceListener imageServiceListener) {
-        CacheService.initializeCaches(context);
+        initialize(context);
+        CacheService.initialize(context);
         get(urls, imageServiceListener);
     }
 
@@ -43,7 +71,8 @@ static void get(final List<String> urls, final ImageServiceListener imageService
         try {
             imageDiskTaskManager = new ImageDiskTaskManager(
                     urlCacheMisses,
-                    new ImageDiskTaskManagerListener(imageServiceListener, cacheBitmaps)
+                    new ImageDiskTaskManagerListener(imageServiceListener, cacheBitmaps),
+                    sTargetWidth
             );
         } catch (IllegalArgumentException e) {
             MoPubLog.d("Unable to initialize ImageDiskTaskManager", e);
@@ -54,16 +83,15 @@ static void get(final List<String> urls, final ImageServiceListener imageService
         imageDiskTaskManager.execute();
     }
 
-    static void putBitmapsInCache(final Map<String, Bitmap> bitmaps) {
-        for (final Entry<String, Bitmap> entry : bitmaps.entrySet()) {
-            MoPubLog.d("Caching bitmap: " + entry.getKey());
-            putBitmapInCache(entry.getKey(), entry.getValue());
-        }
-    }
+
 
     static void putBitmapInCache(final String key, final Bitmap bitmap) {
-        final byte[] bytes = bitmapToByteArray(bitmap);
-        CacheService.put(key, bytes);
+        CacheService.putToBitmapCache(key, bitmap);
+    }
+
+    static void putDataInCache(final String key, final Bitmap bitmap, final byte[] byteData) {
+        CacheService.putToBitmapCache(key, bitmap);
+        CacheService.putToDiskCacheAsync(key, byteData);
     }
 
     static List<String> getBitmapsFromMemoryCache(final List<String> urls, final Map<String, Bitmap> hits) {
@@ -82,30 +110,10 @@ static void putBitmapInCache(final String key, final Bitmap bitmap) {
     }
 
     static Bitmap getBitmapFromMemoryCache(final String key) {
-        Bitmap bitmap = null;
-        byte[] bytes = CacheService.getFromMemoryCache(key);
-        if (bytes != null) {
-            bitmap = byteArrayToBitmap(bytes);
-        }
-        return bitmap;
-    }
-
-    static Bitmap byteArrayToBitmap(final byte[] bytes) {
-        return BitmapFactory.decodeByteArray(bytes, 0, bytes.length);
+        return CacheService.getFromBitmapCache(key);
     }
 
-    static byte[] bitmapToByteArray(final Bitmap bitmap) {
-        ByteArrayOutputStream byteArrayOutputStream = null;
-        try {
-            byteArrayOutputStream = new ByteArrayOutputStream();
-            bitmap.compress(Bitmap.CompressFormat.JPEG, COMPRESSION_QUALITY, byteArrayOutputStream);
-            return byteArrayOutputStream.toByteArray();
-        } finally {
-            Streams.closeStream(byteArrayOutputStream);
-        }
-    }
-
-    private static class ImageDiskTaskManagerListener implements ImageTaskManagerListener {
+    private static class ImageDiskTaskManagerListener implements TaskManagerListener<Bitmap> {
         final private ImageServiceListener mImageServiceListener;
         final private Map<String, Bitmap> mBitmaps;
 
@@ -135,7 +143,8 @@ public void onSuccess(final Map<String, Bitmap> diskBitmaps) {
                 try {
                     imageDownloadTaskManager = new ImageDownloadTaskManager(
                             urlDiskMisses,
-                            new ImageNetworkTaskManagerListener(mImageServiceListener, mBitmaps)
+                            new ImageDownloadResponseListener(mImageServiceListener, mBitmaps),
+                            sTargetWidth
                     );
                 } catch (IllegalArgumentException e) {
                     MoPubLog.d("Unable to initialize ImageDownloadTaskManager", e);
@@ -153,20 +162,30 @@ public void onFail() {
         }
     }
 
-    private static class ImageNetworkTaskManagerListener implements ImageTaskManagerListener {
+    private static class ImageDownloadResponseListener implements TaskManagerListener<DownloadResponse> {
         private final ImageServiceListener mImageServiceListener;
         private final Map<String, Bitmap> mBitmaps;
 
-        ImageNetworkTaskManagerListener(final ImageServiceListener imageServiceListener,
+        ImageDownloadResponseListener(final ImageServiceListener imageServiceListener,
                 final Map<String, Bitmap> bitmaps) {
             mImageServiceListener = imageServiceListener;
             mBitmaps = bitmaps;
         }
 
         @Override
-        public void onSuccess(final Map<String, Bitmap> images) {
-            putBitmapsInCache(images);
-            mBitmaps.putAll(images);
+        public void onSuccess(final Map<String, DownloadResponse> responses) {
+            for (final Entry<String, DownloadResponse> entry : responses.entrySet()) {
+                final Bitmap bitmap = asBitmap(entry.getValue(), sTargetWidth);
+                final String key = entry.getKey();
+                if (bitmap == null) {
+                    MoPubLog.d("Error decoding image for url: " + entry.getKey());
+                    onFail();
+                    return;
+                }
+
+                putDataInCache(key, bitmap, entry.getValue().getByteArray());
+                mBitmaps.put(key, bitmap);
+            }
             mImageServiceListener.onSuccess(mBitmaps);
         }
 
@@ -176,14 +195,87 @@ public void onFail() {
         }
     }
 
+    public static Bitmap asBitmap(final DownloadResponse downloadResponse, final int requestedWidth) {
+        if (downloadResponse == null) {
+            return null;
+        }
+
+        final byte[] bytes = downloadResponse.getByteArray();
+        return byteArrayToBitmap(bytes, requestedWidth);
+    }
+
+    public static Bitmap byteArrayToBitmap(final byte[] bytes, final int requestedWidth) {
+        if (requestedWidth <= 0) {
+            return null;
+        }
+
+        Options options = new Options();
+        options.inJustDecodeBounds = true;
+        decodeByteArray(bytes, 0, bytes.length, options);
+        options.inSampleSize = calculateInSampleSize(options.outWidth, requestedWidth);
+
+        // If the bitmap will be very large, downsample more to avoid blowing up the heap.
+        while (getMemBytes(options) > TWO_MEGABYTES) {
+            options.inSampleSize *= 2;
+        }
+        options.inJustDecodeBounds = false;
+        Bitmap bitmap = decodeByteArray(bytes, 0, bytes.length, options);
+        final int subsampleWidth = bitmap.getWidth();
+
+        // If needed, scale the bitmap so it's exactly the requested width.
+        if (subsampleWidth > requestedWidth) {
+            final int requestedHeight = (int)(bitmap.getHeight() * (double) requestedWidth / bitmap.getWidth());
+            Bitmap subsampledBitmap = bitmap;
+            bitmap = Bitmap.createScaledBitmap(subsampledBitmap, requestedWidth, requestedHeight, true);
+            subsampledBitmap.recycle();
+        }
+        return bitmap;
+    }
+
+    /**
+     * Returns the size of the byte array that the bitmap described by the options object will consume.
+     */
+    public static long getMemBytes(Options options) {
+        long memBytes = 4 * (long) options.outWidth * (long) options.outHeight / options.inSampleSize / options.inSampleSize;
+        return memBytes;
+    }
+
+    /**
+     * Calculate the largest inSampleSize value that is a power of 2 and keeps the
+     * width greater than or equal to the requested width.
+     */
+    public static int calculateInSampleSize(final int nativeWidth, int requestedWidth) {
+        int inSampleSize = 1;
+
+        if (nativeWidth > requestedWidth) {
+            final int halfWidth = nativeWidth / 2;
+
+            while ((halfWidth / inSampleSize) >= requestedWidth) {
+                inSampleSize *= 2;
+            }
+        }
+
+        return inSampleSize;
+    }
+
     // Testing, also performs disk IO
     @Deprecated
     static Bitmap getBitmapFromDiskCache(final String key) {
         Bitmap bitmap = null;
         byte[] bytes = CacheService.getFromDiskCache(key);
         if (bytes != null) {
-            bitmap = byteArrayToBitmap(bytes);
+            bitmap = byteArrayToBitmap(bytes, sTargetWidth);
         }
         return bitmap;
     }
+
+    @VisibleForTesting
+    static void clear() {
+        sTargetWidth = -1;
+    }
+
+    @VisibleForTesting
+    static int getTargetWidth() {
+        return sTargetWidth;
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ImageViewService.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ImageViewService.java
index 924cd626..3232d17f 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/ImageViewService.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/ImageViewService.java
@@ -1,26 +1,30 @@
 package com.mopub.nativeads;
 
 import android.graphics.Bitmap;
-import android.view.View;
 import android.widget.ImageView;
 
+import com.mopub.common.VisibleForTesting;
 import com.mopub.common.util.MoPubLog;
 import com.mopub.common.util.Utils;
 
 import java.lang.ref.WeakReference;
 import java.util.Arrays;
 import java.util.Map;
+import java.util.WeakHashMap;
 
 import static com.mopub.nativeads.ImageService.ImageServiceListener;
 
 class ImageViewService {
-    // random large number so we hopefully don't collide with something a pub is using
-    private static final int VIEW_TAG_MOPUB_KEY = 817491827;
+    // This is used instead of View.setTag, which causes a memory leak in 2.3
+    // and earlier: https://code.google.com/p/android/issues/detail?id=18273
+    private static final WeakHashMap<ImageView, Long> sImageViewRequestIds =
+            new WeakHashMap<ImageView, Long>();
 
     private ImageViewService(){}
 
     static void loadImageView(final String url, final ImageView imageView) {
         if (imageView == null) {
+            MoPubLog.d("Attempted to load an image into a null ImageView");
             return;
         }
 
@@ -29,8 +33,8 @@ static void loadImageView(final String url, final ImageView imageView) {
 
         if (url != null) {
             // Unique id to identify this async image request
-            setImageViewUniqueId(imageView);
-            long uniqueId = getImageViewUniqueId(imageView);
+            long uniqueId = Utils.generateUniqueId();
+            sImageViewRequestIds.put(imageView, uniqueId);
 
             // Async call to get image from memory cache, disk and then network
             ImageService.get(
@@ -57,7 +61,7 @@ public void onSuccess(final Map<String, Bitmap> bitmaps) {
             if (imageView == null || bitmaps == null || !bitmaps.containsKey(mUrl)) {
                 return;
             }
-            final Long uniqueId = getImageViewUniqueId(imageView);
+            final Long uniqueId = sImageViewRequestIds.get(imageView);
             if (uniqueId != null && mUniqueId == uniqueId) {
                 imageView.setImageBitmap(bitmaps.get(mUrl));
             }
@@ -69,27 +73,15 @@ public void onFail() {
         }
     }
 
-    static void setImageViewUniqueId(final ImageView imageView) {
-        if (imageView != null) {
-            setViewTag(imageView, Utils.generateUniqueId());
-        }
-    }
-
+    @VisibleForTesting
+    @Deprecated
     static Long getImageViewUniqueId(final ImageView imageView) {
-        if (imageView != null) {
-            Object object = getViewTag(imageView);
-            if (object instanceof Long) {
-                return (Long) object;
-            }
-        }
-        return null;
-    }
-
-    static void setViewTag(final View view, final Object object) {
-        view.setTag(VIEW_TAG_MOPUB_KEY, object);
+        return sImageViewRequestIds.get(imageView);
     }
 
-    static Object getViewTag(final View view) {
-        return view.getTag(VIEW_TAG_MOPUB_KEY);
+    @VisibleForTesting
+    @Deprecated
+    static void setImageViewUniqueId(final ImageView imageView, final long uniqueId) {
+        sImageViewRequestIds.put(imageView, uniqueId);
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ImpressionTracker.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ImpressionTracker.java
new file mode 100644
index 00000000..35508618
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/ImpressionTracker.java
@@ -0,0 +1,197 @@
+package com.mopub.nativeads;
+
+import android.content.Context;
+import android.os.Handler;
+import android.view.View;
+
+import com.mopub.common.VisibleForTesting;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.WeakHashMap;
+
+import static com.mopub.nativeads.VisibilityTracker.VisibilityChecker;
+import static com.mopub.nativeads.VisibilityTracker.VisibilityTrackerListener;
+
+class ImpressionTracker {
+
+    private static final int PERIOD = 250;
+
+    // Object tracking visibility of added views
+    private final VisibilityTracker mVisibilityTracker;
+
+    // All views and responses being tracked for impressions
+    private final Map<View, NativeResponse> mTrackedViews;
+
+    // Visible views being polled for time on screen before tracking impression
+    private final Map<View, TimestampWrapper<NativeResponse>> mPollingViews;
+
+    // Handler for polling visible views
+    private final Handler mPollHandler;
+
+    // Runnable to run on each visibility loop
+    private final PollingRunnable mPollingRunnable;
+
+    // Object to check actual visibility
+    private final VisibilityChecker mVisibilityChecker;
+
+    // Listener for when a view becomes visible or non visible
+    private VisibilityTrackerListener mVisibilityTrackerListener;
+
+    ImpressionTracker(final Context context) {
+        this(new WeakHashMap<View, NativeResponse>(),
+                new WeakHashMap<View, TimestampWrapper<NativeResponse>>(),
+                new VisibilityChecker(),
+                new VisibilityTracker(context),
+                new Handler());
+    }
+
+    @VisibleForTesting
+    ImpressionTracker(final Map<View, NativeResponse> trackedViews,
+                      final Map<View, TimestampWrapper<NativeResponse>> pollingViews,
+                      final VisibilityChecker visibilityChecker,
+                      final VisibilityTracker visibilityTracker,
+                      final Handler handler) {
+        mTrackedViews = trackedViews;
+        mPollingViews = pollingViews;
+        mVisibilityChecker = visibilityChecker;
+        mVisibilityTracker = visibilityTracker;
+
+        mVisibilityTrackerListener = new VisibilityTrackerListener() {
+            @Override
+            public void onVisibilityChanged(final List<View> visibleViews, final List<View> invisibleViews) {
+                for (final View view : visibleViews) {
+                    // It's possible for native response to be null if the view was GC'd from this class
+                    // but not from VisibilityTracker
+                    // If it's null then clean up the view from this class
+                    final NativeResponse nativeResponse = mTrackedViews.get(view);
+                    if (nativeResponse == null) {
+                        removeView(view);
+                        continue;
+                    }
+
+                    // If the native response is already polling, don't recreate it
+                    final TimestampWrapper<NativeResponse> polling = mPollingViews.get(view);
+                    if (polling != null && nativeResponse.equals(polling.mInstance)) {
+                        continue;
+                    }
+
+                    // Add a new polling view
+                    mPollingViews.put(view, new TimestampWrapper<NativeResponse>(nativeResponse));
+                }
+
+                for (final View view : invisibleViews) {
+                    mPollingViews.remove(view);
+                }
+                scheduleNextPoll();
+            }
+        };
+        mVisibilityTracker.setVisibilityTrackerListener(mVisibilityTrackerListener);
+
+        mPollHandler = handler;
+        mPollingRunnable = new PollingRunnable();
+    }
+
+    /**
+     * Tracks the given view for impressions.
+     */
+    void addView(final View view, final NativeResponse nativeResponse) {
+        // View is already associated with same native response
+        if (mTrackedViews.get(view) == nativeResponse) {
+            return;
+        }
+
+        // Clean up state if view is being recycled and associated with a different response
+        removeView(view);
+
+        if (nativeResponse.getRecordedImpression() || nativeResponse.isDestroyed()) {
+            return;
+        }
+
+        mTrackedViews.put(view, nativeResponse);
+        mVisibilityTracker.addView(view, nativeResponse.getImpressionMinPercentageViewed());
+    }
+
+    void removeView(final View view) {
+        mTrackedViews.remove(view);
+        removePollingView(view);
+        mVisibilityTracker.removeView(view);
+    }
+
+    /**
+     * Immediately clear all views. Useful for when we re-request ads for an ad placer
+     */
+    void clear() {
+        mTrackedViews.clear();
+        mPollingViews.clear();
+        mVisibilityTracker.clear();
+        mPollHandler.removeMessages(0);
+    }
+
+    void destroy() {
+        clear();
+        mVisibilityTracker.destroy();
+        mVisibilityTrackerListener = null;
+    }
+
+    @VisibleForTesting
+    void scheduleNextPoll() {
+        // Only schedule if there are no messages already scheduled.
+        if (mPollHandler.hasMessages(0)) {
+            return;
+        }
+
+        mPollHandler.postDelayed(mPollingRunnable, PERIOD);
+    }
+
+    private void removePollingView(final View view) {
+        mPollingViews.remove(view);
+    }
+
+    @VisibleForTesting
+    class PollingRunnable implements Runnable {
+        // Create this once to avoid excessive garbage collection observed when calculating
+        // these on each pass.
+        private final ArrayList<View> mRemovedViews;
+
+        PollingRunnable() {
+            mRemovedViews = new ArrayList<View>();
+        }
+
+        @Override
+        public void run() {
+            for (final Map.Entry<View, TimestampWrapper<NativeResponse>> entry : mPollingViews.entrySet()) {
+                final View view = entry.getKey();
+                final TimestampWrapper<NativeResponse> timestampWrapper = entry.getValue();
+
+                // If it's been visible for the min impression time, trigger the callback
+                if (!mVisibilityChecker.hasRequiredTimeElapsed(
+                        timestampWrapper.mCreatedTimestamp,
+                        timestampWrapper.mInstance.getImpressionMinTimeViewed())) {
+                    continue;
+                }
+
+                timestampWrapper.mInstance.recordImpression(view);
+
+                // Removed in a separate loop to avoid a ConcurrentModification exception.
+                mRemovedViews.add(view);
+            }
+
+            for (View view : mRemovedViews) {
+              removeView(view);
+            }
+            mRemovedViews.clear();
+
+            if (!mPollingViews.isEmpty()) {
+                scheduleNextPoll();
+            }
+        }
+    }
+
+    @Deprecated
+    @VisibleForTesting
+    VisibilityTrackerListener getVisibilityTrackerListener() {
+        return mVisibilityTrackerListener;
+    }
+}
\ No newline at end of file
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ImpressionTrackingManager.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ImpressionTrackingManager.java
deleted file mode 100644
index fda539a5..00000000
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/ImpressionTrackingManager.java
+++ /dev/null
@@ -1,286 +0,0 @@
-package com.mopub.nativeads;
-
-import android.graphics.Rect;
-import android.os.Handler;
-import android.os.SystemClock;
-import android.view.View;
-import android.view.ViewTreeObserver;
-
-import java.lang.ref.WeakReference;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-import java.util.WeakHashMap;
-
-import static android.view.ViewTreeObserver.OnPreDrawListener;
-
-/**
- * Tracks views to determine when they've been viewable by the user, where viewability is defined as
- * having been at least X% on the screen for a continuous Y seconds. These values are set by the
- */
-final class ImpressionTrackingManager {
-    private ImpressionTrackingManager(){}
-
-    private static final int PERIOD = 250;
-
-    // Visible views currently polling to become viewable, subset of tracked views.
-    private static final WeakHashMap<View, OnPreDrawListener> sWaitingViews =
-            new WeakHashMap<View, OnPreDrawListener>(10);
-
-    // Views waiting to become visible, subset of tracked views
-    private static final WeakHashMap<View, NativeResponseWrapper> sPollingViews =
-            new WeakHashMap<View, NativeResponseWrapper>(10);
-
-    // Handler to delay starting tracking until the next render loop
-    private static final Handler startHandler = new Handler();
-
-    // Handler for polling visible views
-    private static final Handler pollHandler = new Handler();
-
-    // Runnable to run on each visibility loop
-    private static final PollingRunnable pollingRunnable = new PollingRunnable();
-
-    // Object to check actual visibility
-    private static final VisibilityChecker visibilityChecker = new VisibilityChecker();
-
-    /**
-     * Tracks the given view for visibility.
-     * <p/>
-     * If the view is already being tracked this does nothing. To restart tracking you should call
-     * stopTracking first.
-     * <p/>
-     * It is the caller's responsibility to avoid tracking views for ads that have already registered
-     * an impression.
-     */
-    static void addView(final View view, final NativeResponse nativeResponse) {
-        // Ignore if already being tracked.
-        if (view == null || nativeResponse == null || isViewTracked(view)) {
-            return;
-        }
-
-        // Posting the handler gives the view another render loop before checking visibility. Useful
-        // because ListView likes to reparent a views after calling getView.
-        final WeakReference<View> viewReference = new WeakReference<View>(view);
-        startHandler.post(new Runnable() {
-            @Override
-            public void run() {
-                final View view = viewReference.get();
-                // Might have been untracked or GC'd
-                if (view == null) {
-                    return;
-                }
-
-                // Important to test viewability instead of just waiting
-                if (visibilityChecker.isMostlyVisible(view,
-                        nativeResponse.getImpressionMinPercentageViewed())) {
-                    pollVisibleView(view, nativeResponse);
-                } else {
-                    waitForVisibility(view, nativeResponse);
-                }
-            }
-        });
-    }
-
-    static boolean isViewTracked(final View view) {
-        return sPollingViews.containsKey(view) || sWaitingViews.containsKey(view);
-    }
-
-    static void waitForVisibility(final View view, final NativeResponse nativeResponse) {
-        // Remove from the polling list
-        removePollingView(view);
-
-        // Track draw events on this view to see when it becomes visible
-        final WeakReference<View> viewReference = new WeakReference<View>(view);
-        OnPreDrawListener preDrawListener = new OnPreDrawListener() {
-            @Override
-            public boolean onPreDraw() {
-                final View view = viewReference.get();
-                if (view == null) {
-                    return true;
-                }
-
-                if (visibilityChecker.isMostlyVisible(view,
-                        nativeResponse.getImpressionMinPercentageViewed())) {
-                    pollVisibleView(view, nativeResponse);
-                }
-                return true;
-            }
-        };
-
-        final ViewTreeObserver viewTreeObserver = view.getViewTreeObserver();
-        if (viewTreeObserver.isAlive()) {
-            viewTreeObserver.addOnPreDrawListener(preDrawListener);
-            sWaitingViews.put(view, preDrawListener);
-        }
-    }
-
-    static void pollVisibleView(final View view, final NativeResponse nativeResponse) {
-        // Remove from waiting and add to polling
-        removeWaitingView(view);
-        sPollingViews.put(view, new NativeResponseWrapper(nativeResponse));
-
-        // Make sure we're polling
-        scheduleNextPoll();
-    }
-
-    static void scheduleNextPoll() {
-        // Only schedule if there are no messages already scheduled.
-        if (pollHandler.hasMessages(0)) {
-            return;
-        }
-
-        pollHandler.postDelayed(pollingRunnable, PERIOD);
-    }
-
-    static void removeWaitingView(final View view) {
-        final OnPreDrawListener listener = sWaitingViews.remove(view);
-        if (listener != null) {
-            final ViewTreeObserver viewTreeObserver = view.getViewTreeObserver();
-            if (viewTreeObserver.isAlive()) {
-                viewTreeObserver.removeOnPreDrawListener(listener);
-            }
-        }
-    }
-
-    static void removePollingView(View view) {
-        sPollingViews.remove(view);
-    }
-
-    /**
-     * Stops tracking a view, cleaning any pending tracking
-     */
-    static void removeView(View view) {
-        removeWaitingView(view);
-        removePollingView(view);
-    }
-
-    /**
-     * Immediately clear all views. Useful for when we re-request ads for an ad placer
-     */
-    static void clearTracking() {
-        // Stop waiting. Copy so that we can modify the map during iteration.
-        final List<View> views = new ArrayList<View>(sWaitingViews.keySet());
-        for (final View view : views) {
-            removeWaitingView(view);
-        }
-
-        // Clear and stop the polling
-        sPollingViews.clear();
-        pollHandler.removeMessages(0);
-
-        // Stop any views being currently added to tracking
-        startHandler.removeMessages(0);
-    }
-
-    static class PollingRunnable implements Runnable {
-
-        @Override
-        public void run() {
-            final ArrayList<View> views = new ArrayList<View>(sPollingViews.keySet());
-            for (final View view : views) {
-                final NativeResponseWrapper nativeResponseWrapper = sPollingViews.get(view);
-
-                if (nativeResponseWrapper == null
-                        || nativeResponseWrapper.mNativeResponse == null
-                        || nativeResponseWrapper.mNativeResponse.getRecordedImpression()
-                        || nativeResponseWrapper.mNativeResponse.isDestroyed()) {
-                    removeView(view);
-                    continue;
-                }
-
-                // If no longer visible, go back to a waiting state
-                if (!visibilityChecker.isMostlyVisible(view,
-                        nativeResponseWrapper.mNativeResponse.getImpressionMinPercentageViewed())) {
-                    // Also removes from the visible list
-                    waitForVisibility(view, nativeResponseWrapper.mNativeResponse);
-                    continue;
-                }
-
-                // If it's been visible for a Y seconds, trigger the callback
-                if (!visibilityChecker.hasRequiredTimeElapsed(
-                        nativeResponseWrapper.mFirstVisibleTimestamp,
-                        nativeResponseWrapper.mNativeResponse.getImpressionMinTimeViewed())) {
-                    continue;
-                }
-
-                nativeResponseWrapper.mNativeResponse.recordImpression(view);
-                removeView(view);
-            }
-
-            if (!sPollingViews.isEmpty()) {
-                scheduleNextPoll();
-            }
-        }
-    }
-
-    // Visible for testing.
-    static class VisibilityChecker {
-
-        /**
-         * Whether the visible time has elapsed from the start time. Easily mocked for testing.
-         */
-        static boolean hasRequiredTimeElapsed(final long startTimeMillis,
-                final int impressionMinTimeViewed) {
-            return SystemClock.uptimeMillis() - startTimeMillis >= impressionMinTimeViewed;
-        }
-
-        /**
-         * Whether the view is at least certain % visible
-         */
-        static boolean isMostlyVisible(final View view, final int impressionMinPercentageViewed) {
-            /*
-             * ListView & GridView both call detachFromParent() for views that can be recycled for
-             * new data. This is one of the rare instances where a view will have a null parent for
-             * an extended period of time and will not be the main window.
-             *
-             * view.getGlobalVisibleRect() doesn't check that case, so if the view has visibility
-             * of View.VISIBLE but has no parent it is likely in the recycle bin of a
-             * ListView / GridView and not on screen.
-             */
-            if (view == null || view.getVisibility() != View.VISIBLE || view.getParent() == null) {
-                return false;
-            }
-
-            final Rect clipRect = new Rect();
-            if (!view.getGlobalVisibleRect(clipRect)) {
-                // Not visible
-                return false;
-            }
-
-            // % visible check - the cast is to avoid int overflow for large views.
-            final long visibleViewArea = (long) clipRect.height() * clipRect.width();
-            final long totalViewArea = (long) view.getHeight() * view.getWidth();
-
-            if (totalViewArea <= 0) {
-                return false;
-            }
-
-            return 100 * visibleViewArea >= impressionMinPercentageViewed * totalViewArea;
-        }
-    }
-
-    static class NativeResponseWrapper {
-        final NativeResponse mNativeResponse;
-        long mFirstVisibleTimestamp;
-
-        NativeResponseWrapper(final NativeResponse nativeResponse) {
-            mNativeResponse = nativeResponse;
-            mFirstVisibleTimestamp = SystemClock.uptimeMillis();
-        }
-    }
-
-    @Deprecated // for testing
-    static Map<View, OnPreDrawListener> getWaitingViews() {
-        return sWaitingViews;
-    }
-
-    @Deprecated // for testing
-    static Map<View, NativeResponseWrapper> getPollingViews() {
-        return sPollingViews;
-    }
-
-    @Deprecated // for testing
-    static Handler getStartHandler() {
-        return startHandler;
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdAdapter.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdAdapter.java
new file mode 100644
index 00000000..eadf27cc
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdAdapter.java
@@ -0,0 +1,572 @@
+package com.mopub.nativeads;
+
+import android.content.Context;
+import android.database.DataSetObserver;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.Adapter;
+import android.widget.AdapterView;
+import android.widget.BaseAdapter;
+import android.widget.ListAdapter;
+import android.widget.ListView;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.util.MoPubLog;
+
+import java.util.List;
+import java.util.WeakHashMap;
+
+import static android.widget.AdapterView.OnItemClickListener;
+import static android.widget.AdapterView.OnItemLongClickListener;
+import static android.widget.AdapterView.OnItemSelectedListener;
+import static com.mopub.nativeads.VisibilityTracker.VisibilityTrackerListener;
+
+/**
+ * {@code MoPubAdAdapter} facilitates placing ads into an Android {@link android.widget.ListView} or
+ * other widgets that use a {@link android.widget.ListAdapter}.
+ *
+ * For your content items, this class will call your original adapter with the original position of
+ * content before ads were loaded.
+ *
+ * This adapter uses a {@link com.mopub.nativeads.MoPubStreamAdPlacer} object internally. If you
+ * wish to avoid wrapping your original adapter, you can use {@code MoPubStreamAdPlacer} directly.
+ */
+public class MoPubAdAdapter extends BaseAdapter {
+    private final WeakHashMap<View, Integer> mViewPositionMap;
+    private final Adapter mOriginalAdapter;
+    private final MoPubStreamAdPlacer mStreamAdPlacer;
+    private final VisibilityTracker mVisibilityTracker;
+
+    private MoPubNativeAdLoadedListener mAdLoadedListener;
+
+    /**
+     * @param context The activity context.
+     * @param originalAdapter Your original adapter.
+     * @param adPositioning A positioning object for specifying where ads will be placed in your
+     * stream.
+     */
+    public MoPubAdAdapter(final Context context,
+            final Adapter originalAdapter,
+            final MoPubNativeAdPositioning adPositioning) {
+        this(new MoPubStreamAdPlacer(context, adPositioning), originalAdapter,
+                new VisibilityTracker(context));
+    }
+
+    @VisibleForTesting
+    MoPubAdAdapter(final MoPubStreamAdPlacer streamAdPlacer,
+            final Adapter originalAdapter,
+            final VisibilityTracker visibilityTracker) {
+        mOriginalAdapter = originalAdapter;
+        mStreamAdPlacer = streamAdPlacer;
+        mViewPositionMap = new WeakHashMap<View, Integer>();
+
+        mVisibilityTracker = visibilityTracker;
+        mVisibilityTracker.setVisibilityTrackerListener(new VisibilityTrackerListener() {
+            @Override
+            public void onVisibilityChanged(final List<View> visibleViews,
+                    final List<View> invisibleViews) {
+                handleVisibilityChange(visibleViews);
+            }
+        });
+        mOriginalAdapter.registerDataSetObserver(new DataSetObserver() {
+            @Override
+            public void onChanged() {
+                mStreamAdPlacer.setItemCount(mOriginalAdapter.getCount());
+                notifyDataSetChanged();
+            }
+
+            @Override
+            public void onInvalidated() {
+                notifyDataSetInvalidated();
+            }
+        });
+
+        mStreamAdPlacer.setAdLoadedListener(new MoPubNativeAdLoadedListener() {
+            @Override
+            public void onAdLoaded(final int position) {
+                handleAdLoaded(position);
+            }
+
+            @Override
+            public void onAdRemoved(final int position) {
+                handleAdRemoved(position);
+            }
+
+        });
+
+        mStreamAdPlacer.setItemCount(mOriginalAdapter.getCount());
+    }
+
+    @VisibleForTesting
+    void handleAdLoaded(final int position) {
+        if (mAdLoadedListener != null) {
+            mAdLoadedListener.onAdLoaded(position);
+        }
+        notifyDataSetChanged();
+    }
+
+    @VisibleForTesting
+    void handleAdRemoved(final int position) {
+        if (mAdLoadedListener != null) {
+            mAdLoadedListener.onAdRemoved(position);
+        }
+        notifyDataSetChanged();
+    }
+
+    /**
+     * Registers a {@link MoPubNativeAdRenderer} to use when displaying ads in your stream.
+     *
+     * This renderer will automatically create and render your view when you call {@link #getView}.
+     * If you register a second renderer, it will replace the first, although this behavior is
+     * subject to change in a future SDK version.
+     *
+     * @param adRenderer The ad renderer.
+     */
+    public final void registerAdRenderer(final MoPubNativeAdRenderer adRenderer) {
+        if (adRenderer == null) {
+            MoPubLog.w("Tried to set a null ad renderer on the placer.");
+            return;
+        }
+        mStreamAdPlacer.registerAdRenderer(adRenderer);
+    }
+
+    /**
+     * Sets a listener that will be called after the SDK loads new ads from the server and places
+     * them into your stream.
+     *
+     * The listener will be active between when you call {@link #loadAds} and when you call {@link
+     * #destroy()}. You can also set the listener to {@code null} to remove the listener.
+     *
+     * Note that there is not a one to one correspondence between calls to {@link #loadAds} and this
+     * listener. The SDK will call the listener every time an ad loads.
+     *
+     * @param listener The listener.
+     */
+    public final void setAdLoadedListener(final MoPubNativeAdLoadedListener listener) {
+        mAdLoadedListener = listener;
+    }
+
+    /**
+     * Start loading ads from the MoPub server.
+     *
+     * We recommend using {@link #loadAds(String, RequestParameters)} instead of this method, in
+     * order to pass targeting information to the server.
+     *
+     * @param adUnitId The ad unit ID to use when loading ads.
+     */
+    public void loadAds(final String adUnitId) {
+        mStreamAdPlacer.loadAds(adUnitId);
+    }
+
+    /**
+     * Start loading ads from the MoPub server, using the given request targeting information.
+     *
+     * When loading ads, {@link MoPubNativeAdLoadedListener#onAdLoaded(int)} will be called for each
+     * ad that is added to the stream.
+     *
+     * To refresh ads in your stream, call {@link #refreshAds(ListView, String)}. When new ads load,
+     * they will replace the current ads in your stream. If you are using {@code
+     * MoPubNativeAdLoadedListener} you will see a call to {@code onAdRemoved} for each of the old
+     * ads, followed by a calls to {@code onAdLoaded}.
+     *
+     * @param adUnitId The ad unit ID to use when loading ads.
+     * @param requestParameters Targeting information to pass to the ad server.
+     */
+    public void loadAds(final String adUnitId,
+            final RequestParameters requestParameters) {
+        mStreamAdPlacer.loadAds(adUnitId, requestParameters);
+    }
+
+    /**
+     * Whether the given position is an ad.
+     *
+     * This will return {@code true} only if there is an ad loaded for this position. You can also
+     * listen for ads to load using {@link MoPubNativeAdLoadedListener#onAdLoaded(int)}.
+     *
+     * @param position The position to check for an ad, expressed in terms of the position in the
+     * stream including ads.
+     * @return Whether there is an ad at the given position.
+     */
+    public boolean isAd(final int position) {
+        return mStreamAdPlacer.isAd(position);
+    }
+
+    /**
+     * Stops loading ads, immediately clearing any ads currently in the stream.
+     *
+     * This method also stops ads from loading as the user moves through the stream. If you want to
+     * refresh ads, call {@link #refreshAds(ListView, String, RequestParameters)} instead of this
+     * method.
+     *
+     * When ads are cleared, {@link MoPubNativeAdLoadedListener#onAdRemoved} will be called for each
+     * ad that is removed from the stream.
+     */
+    public void clearAds() {
+        mStreamAdPlacer.clearAds();
+    }
+
+    /**
+     * Destroys the ad adapter, preventing it from future use.
+     *
+     * You must call this method before the hosting activity for this class is destroyed in order to
+     * avoid a memory leak. Typically you should destroy the adapter in the life-cycle method that
+     * is counterpoint to the method you used to create the adapter. For example, if you created the
+     * adapter in {@code Fragment#onCreateView} you should destroy it in {code
+     * Fragment#onDestroyView}.
+     */
+    public void destroy() {
+        mStreamAdPlacer.destroy();
+        mVisibilityTracker.destroy();
+    }
+
+    @Override
+    public boolean areAllItemsEnabled() {
+        return mOriginalAdapter instanceof ListAdapter
+                && ((ListAdapter) mOriginalAdapter).areAllItemsEnabled();
+    }
+
+    @Override
+    public boolean isEnabled(final int position) {
+        return isAd(position) || (mOriginalAdapter instanceof ListAdapter
+                && ((ListAdapter) mOriginalAdapter).isEnabled(mStreamAdPlacer.getOriginalPosition(
+                position)));
+    }
+
+    /**
+     * Returns the number of items in your stream, including ads.
+     *
+     * @return The count of items.
+     * @inheritDoc
+     */
+    @Override
+    public int getCount() {
+        return mStreamAdPlacer.getAdjustedCount(mOriginalAdapter.getCount());
+    }
+
+    /**
+     * For ad items, returns an ad data object. For non ad items, calls you original adapter using
+     * the original item position.
+     *
+     * @inheritDoc
+     */
+    @Override
+    public Object getItem(final int position) {
+        final Object ad = mStreamAdPlacer.getAdData(position);
+        if (ad != null) {
+            return ad;
+        }
+        return mOriginalAdapter.getItem(mStreamAdPlacer.getOriginalPosition(position));
+    }
+
+    /**
+     * For ad items, returns an ID representing the ad. For non ad items, calls your original
+     * adapter using the original item position.
+     *
+     * For ads, this ID will be a negative integer. If you feel that this ID might collide with your
+     * original adapter's IDs, you should return {@code false} from {@code #hasStableIds()}.
+     *
+     * @inheritDoc
+     */
+    @Override
+    public long getItemId(final int position) {
+        final Object adData = mStreamAdPlacer.getAdData(position);
+        if (adData != null) {
+            return ~System.identityHashCode(adData) + 1;
+        }
+        return mOriginalAdapter.getItemId(mStreamAdPlacer.getOriginalPosition(position));
+    }
+
+    /**
+     * Returns the value returned by {@code hasStableIds()} on your original adapter.
+     *
+     * @inheritDoc
+     */
+    @Override
+    public boolean hasStableIds() {
+        return mOriginalAdapter.hasStableIds();
+    }
+
+    /**
+     * For ad items, returns an ad View for the underlying position. For non-ad items, calls your
+     * original adapter using the original ad position.
+     *
+     * @inheritDoc
+     */
+    @Override
+    public View getView(final int position, final View view, final ViewGroup viewGroup) {
+        final View resultView;
+        final View adView = mStreamAdPlacer.getAdView(position, view, viewGroup);
+        if (adView != null) {
+            resultView = adView;
+        } else {
+            resultView = mOriginalAdapter.getView(
+                    mStreamAdPlacer.getOriginalPosition(position), view, viewGroup);
+        }
+        mViewPositionMap.put(resultView, position);
+        mVisibilityTracker.addView(resultView, 0);
+
+        return resultView;
+    }
+
+    /**
+     * For ad items, returns a number greater than or equal to the view type count for your
+     * underlying adapter. For non-ad items, calls your original adapter using the original ad
+     * position.
+     *
+     * @inheritDoc
+     */
+    @Override
+    public int getItemViewType(final int position) {
+        final int adType = mStreamAdPlacer.getAdViewType(position);
+        if (adType != 0) {
+            return adType + mOriginalAdapter.getViewTypeCount() - 1;
+        }
+        return mOriginalAdapter.getItemViewType(mStreamAdPlacer.getOriginalPosition(position));
+    }
+
+    /**
+     * Returns the view type count of your original adapter, plus the the number of possible view
+     * types for ads. The number of possible ad view types is currently 1, but this is subject to
+     * change in future SDK versions.
+     *
+     * @inheritDoc
+     */
+    @Override
+    public int getViewTypeCount() {
+        return mOriginalAdapter.getViewTypeCount() + mStreamAdPlacer.getAdViewTypeCount();
+    }
+
+    /**
+     * Returns whether the adapter is empty, calling through to your original adapter.
+     *
+     * @inheritDoc
+     */
+    @Override
+    public boolean isEmpty() {
+        return mOriginalAdapter.isEmpty() && mStreamAdPlacer.getAdjustedCount(0) == 0;
+    }
+
+    private void handleVisibilityChange(final List<View> visibleViews) {
+        // Loop through all visible positions in order to build a max and min range, and then
+        // place ads into that range.
+        int min = Integer.MAX_VALUE;
+        int max = 0;
+        for (final View view : visibleViews) {
+            final Integer pos = mViewPositionMap.get(view);
+            if (pos == null) {
+                continue;
+            }
+            min = Math.min(pos, min);
+            max = Math.max(pos, max);
+        }
+        mStreamAdPlacer.placeAdsInRange(min, max + 1);
+    }
+
+    /**
+     * Returns the original position of an item considering ads in the stream.
+     *
+     * @see {@link MoPubStreamAdPlacer#getOriginalPosition(int)}
+     * @param position The adjusted position.
+     * @return The original position before placing ads.
+     */
+    public int getOriginalPosition(final int position) {
+        return mStreamAdPlacer.getOriginalPosition(position);
+    }
+
+    /**
+     * Returns the position of an item considering ads in the stream.
+     *
+     * @see {@link MoPubStreamAdPlacer#getAdjustedPosition(int)}
+     * @param originalPosition The original position.
+     * @return The position adjusted by placing ads.
+     */
+    public int getAdjustedPosition(final int originalPosition) {
+        return mStreamAdPlacer.getAdjustedPosition(originalPosition);
+    }
+
+    /**
+     * Inserts a content row at the given position, adjusting ad positions accordingly.
+     *
+     * Use this method if you are inserting an item into your stream and want to increment ad
+     * positions based on that new item.
+     *
+     * If you do not want to increment your ad positions when inserting items, you can simply call
+     * notifyDataSetChanged on the adapter and let it reload items normally. This is typically the
+     * case when inserting items at the end of your stream.
+     *
+     * @see {@link MoPubStreamAdPlacer#insertItem(int)}
+     * @param originalPosition The original content position at which to add an item. If you have an
+     * adjusted position, you will need to call {@link #getOriginalPosition} to get this value.
+     */
+    public void insertItem(final int originalPosition) {
+        mStreamAdPlacer.insertItem(originalPosition);
+    }
+
+    /**
+     * Removes the content row at the given position, adjusting ad positions accordingly.
+     *
+     * Use this method if you are removing an item from your stream and want to decrement ad
+     * positions based on that removed item.
+     *
+     * If you do not want to decrement your ad positions when inserting items, you can simply call
+     * notifyDataSet changed on the adapter and let it reload items normally. This is typically the
+     * case when removing items from the end of your stream.
+     *
+     * @see {@link MoPubStreamAdPlacer#removeItem(int)}
+     * @param originalPosition The original content position at which to add an item. If you have an
+     * adjusted position, you will need to call {@link #getOriginalPosition} to get this value.
+     */
+    public void removeItem(final int originalPosition) {
+        mStreamAdPlacer.removeItem(originalPosition);
+    }
+
+
+    /**
+     * Sets an on click listener for the given ListView, automatically adjusting the listener
+     * callback positions based on ads in the adapter.
+     *
+     * This listener will not be called when ads are clicked.
+     *
+     * @param listView The ListView for this adapter.
+     * @param listener An on click listener.
+     */
+    public void setOnClickListener(final ListView listView,
+            final OnItemClickListener listener) {
+        listView.setOnItemClickListener(new OnItemClickListener() {
+            @Override
+            public void onItemClick(final AdapterView<?> adapterView, final View view,
+                    final int position, final long id) {
+                if (!mStreamAdPlacer.isAd(position)) {
+                    listener.onItemClick(
+                            adapterView, view, mStreamAdPlacer.getOriginalPosition(position), id);
+                }
+            }
+        });
+    }
+
+    /**
+     * Sets an on long click listener for the given ListView, automatically adjusting the listener
+     * callback positions based on ads in the adapter.
+     *
+     * This listener will not be called when ads are long clicked.
+     *
+     * @param listView The ListView for this adapter.
+     * @param listener An an long click listener.
+     */
+    public void setOnItemLongClickListener(final ListView listView,
+            final OnItemLongClickListener listener) {
+        listView.setOnItemLongClickListener(new OnItemLongClickListener() {
+            @Override
+            public boolean onItemLongClick(final AdapterView<?> adapterView,
+                    final View view, final int position, final long id) {
+                return isAd(position) || listener.onItemLongClick(
+                        adapterView, view, mStreamAdPlacer.getOriginalPosition(position), id);
+            }
+        });
+    }
+
+    /**
+     * Sets an on item selected listener for the given ListView, automatically adjusting the
+     * listener callback positions based on ads in the adapter.
+     *
+     * @param listView The ListView for this adapter.
+     * @param listener An an item selected listener.
+     */
+    public void setOnItemSelectedListener(final ListView listView,
+            final OnItemSelectedListener listener) {
+        listView.setOnItemSelectedListener(new OnItemSelectedListener() {
+            @Override
+            public void onItemSelected(final AdapterView<?> adapterView,
+                    final View view, final int position, final long id) {
+                if (!isAd(position)) {
+                    listener.onItemSelected(adapterView, view,
+                            mStreamAdPlacer.getOriginalPosition(position), id);
+                }
+            }
+
+            @Override
+            public void onNothingSelected(final AdapterView<?> adapterView) {
+                listener.onNothingSelected(adapterView);
+            }
+        });
+    }
+
+    /**
+     * Sets the currently selected item in the ListView, automatically adjusting the position based
+     * on ads in the adapter.
+     *
+     * @param listView The ListView for this adapter.
+     * @param originalPosition The original content position before loading ads.
+     */
+    public void setSelection(final ListView listView, final int originalPosition) {
+        listView.setSelection(mStreamAdPlacer.getAdjustedPosition(originalPosition));
+    }
+
+    /**
+     * Scrolls an item in the ListView, automatically adjusting the position based on ads in the
+     * adapter.
+     *
+     * @param listView The ListView for this adapter.
+     * @param originalPosition The original content position before loading ads.
+     */
+    public void smoothScrollToPosition(final ListView listView, final int originalPosition) {
+        listView.smoothScrollToPosition(mStreamAdPlacer.getAdjustedPosition(originalPosition));
+    }
+
+    /**
+     * Refreshes ads in the given ListView while preserving the scroll position.
+     *
+     * Call this instead of {@link #loadAds(String)} in order to preserve the scroll position in
+     * your list.
+     *
+     * @param adUnitId The ad unit ID to use when loading ads.
+     */
+    public void refreshAds(final ListView listView, String adUnitId) {
+        refreshAds(listView, adUnitId, null);
+    }
+
+    /**
+     * Refreshes ads in the given ListView while preserving the scroll position.
+     *
+     * Call this instead of {@link #loadAds(String, RequestParameters)} in order to preserve the
+     * scroll position in your list.
+     *
+     * @param adUnitId The ad unit ID to use when loading ads.
+     * @param requestParameters Targeting information to pass to the ad server.
+     */
+    public void refreshAds(final ListView listView,
+            String adUnitId, RequestParameters requestParameters) {
+        if (listView.getAdapter() != this) {
+            MoPubLog.w("You called refreshAds on a ListView whose adapter is not an ad placer");
+            return;
+        }
+
+        // Get scroll offset of the first view, if it exists.
+        View firstView = listView.getChildAt(0);
+        int offsetY = (firstView == null) ? 0 : firstView.getTop();
+
+        // Find the range of positions where we should not clear ads.
+        int firstPosition = listView.getFirstVisiblePosition();
+        int startRange = Math.max(firstPosition - 1, 0);
+        while (mStreamAdPlacer.isAd(startRange) && startRange > 0) {
+            startRange--;
+        }
+        int lastPosition = listView.getLastVisiblePosition();
+        while (mStreamAdPlacer.isAd(lastPosition) && lastPosition < getCount() - 1) {
+            lastPosition++;
+        }
+        int originalStartRange = mStreamAdPlacer.getOriginalPosition(startRange);
+        int originalEndRange = mStreamAdPlacer.getOriginalCount(lastPosition + 1);
+
+        // Remove ads before and after the range.
+        int originalCount = mStreamAdPlacer.getOriginalCount(getCount());
+        mStreamAdPlacer.removeAdsInRange(originalEndRange, originalCount);
+        int numAdsRemoved = mStreamAdPlacer.removeAdsInRange(0, originalStartRange);
+
+        // Reset the scroll position, and reload ads.
+        if (numAdsRemoved > 0) {
+            listView.setSelectionFromTop(firstPosition - numAdsRemoved, offsetY);
+        }
+        loadAds(adUnitId, requestParameters);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdRenderer.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdRenderer.java
new file mode 100644
index 00000000..87542fb1
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubAdRenderer.java
@@ -0,0 +1,39 @@
+package com.mopub.nativeads;
+
+import android.content.Context;
+import android.view.View;
+import android.view.ViewGroup;
+
+/**
+ * An interface for creating ad views and rendering them using ad data.
+ *
+ * Normally you will use the subclass {@link com.mopub.nativeads.MoPubNativeAdRenderer} with {@link
+ * com.mopub.nativeads.ViewBinder} to customize your ad view with your own layout. However, if you
+ * wish to programmatically create or manage your ad view, you can implement {@code
+ * }MoPubAdRenderer} directly.
+ *
+ * @param <T> The ad payload type.
+ */
+public interface MoPubAdRenderer<T> {
+    /**
+     * Creates a new view to be used as an ad.
+     *
+     * This method is called when you call {@link com.mopub.nativeads.MoPubStreamAdPlacer#getAdView}
+     * when the convertView is null. You must return a valid view.
+     *
+     * @param parent The parent that the view will eventually be attached to. You might use the
+     * parent to determine layout parameters, but should return the view without attaching it to the
+     * parent.
+     * @param context The context. Useful for creating a view.
+     * @return A new ad view.
+     */
+    View createAdView(Context context, ViewGroup parent);
+
+    /**
+     * Renders a view created by {@link #createAdView} by filling it with ad data.
+     *
+     * @param view The ad View
+     * @param ad The ad data that should be bound to the view.
+     */
+    void renderAdView(View view, T ad);
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubCustomEventNative.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubCustomEventNative.java
index a7f43959..338dc9c9 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubCustomEventNative.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubCustomEventNative.java
@@ -3,7 +3,6 @@
 import android.content.Context;
 
 import com.mopub.common.util.MoPubLog;
-import com.mopub.common.util.Numbers;
 
 import org.json.JSONArray;
 import org.json.JSONException;
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNative.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNative.java
index 4903cdb5..4d3aad64 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNative.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNative.java
@@ -7,6 +7,7 @@
 import com.mopub.common.DownloadTask;
 import com.mopub.common.GpsHelper;
 import com.mopub.common.HttpClient;
+import com.mopub.common.VisibleForTesting;
 import com.mopub.common.util.AsyncTasks;
 import com.mopub.common.util.DeviceUtils;
 import com.mopub.common.util.ManifestUtils;
@@ -24,7 +25,6 @@
 import static com.mopub.common.GpsHelper.GpsHelperListener;
 import static com.mopub.common.GpsHelper.asyncFetchAdvertisingInfo;
 import static com.mopub.nativeads.CustomEventNative.CustomEventNativeListener;
-import static com.mopub.nativeads.MoPubNative.MoPubNativeListener.EMPTY_MOPUB_NATIVE_LISTENER;
 import static com.mopub.nativeads.NativeErrorCode.CONNECTION_ERROR;
 import static com.mopub.nativeads.NativeErrorCode.EMPTY_AD_RESPONSE;
 import static com.mopub.nativeads.NativeErrorCode.INVALID_REQUEST_URL;
@@ -32,50 +32,99 @@
 import static com.mopub.nativeads.NativeErrorCode.UNEXPECTED_RESPONSE_CODE;
 import static com.mopub.nativeads.NativeErrorCode.UNSPECIFIED;
 
-public final class MoPubNative {
-
-    public interface MoPubNativeListener {
+public class MoPubNative {
+    public interface MoPubNativeNetworkListener {
         public void onNativeLoad(final NativeResponse nativeResponse);
         public void onNativeFail(final NativeErrorCode errorCode);
+    }
+
+    static final MoPubNativeNetworkListener EMPTY_NETWORK_LISTENER = new
+            MoPubNativeNetworkListener() {
+        @Override
+        public void onNativeLoad(final NativeResponse nativeResponse) {
+            // If this listener is invoked, it means that MoPubNative instance has been destroyed
+            // so destroy any leftover incoming NativeResponses
+            nativeResponse.destroy();
+        }
+        @Override
+        public void onNativeFail(final NativeErrorCode errorCode) {
+        }
+    };
+
+    static final MoPubNativeEventListener EMPTY_EVENT_LISTENER = new
+            MoPubNativeEventListener() {
+        @Override
+        public void onNativeImpression(final View view) {
+        }
+        @Override
+        public void onNativeClick(final View view) {
+        }
+    };
+
+    public interface MoPubNativeEventListener {
         public void onNativeImpression(final View view);
         public void onNativeClick(final View view);
+    }
 
-        public static final MoPubNativeListener EMPTY_MOPUB_NATIVE_LISTENER = new MoPubNativeListener() {
-            @Override public void onNativeLoad(final NativeResponse nativeResponse) {}
-            @Override public void onNativeFail(final NativeErrorCode errorCode) {}
-            @Override public void onNativeImpression(final View view) {}
-            @Override public void onNativeClick(final View view) {}
-        };
+    /**
+     * @deprecated As of release 2.4, use {@link MoPubNativeEventListener} and
+     * {@link MoPubNativeNetworkListener} instead.
+     */
+    @Deprecated
+    public interface MoPubNativeListener extends MoPubNativeNetworkListener, MoPubNativeEventListener {
     }
 
     // must be an activity context since 3rd party networks need it
     private final WeakReference<Context> mContext;
     private final String mAdUnitId;
-    private MoPubNativeListener mMoPubNativeListener;
+    private MoPubNativeNetworkListener mMoPubNativeNetworkListener;
+    private MoPubNativeEventListener mMoPubNativeEventListener;
     private Map<String, Object> mLocalExtras;
 
-    public MoPubNative(final Context context, final String adUnitId, final MoPubNativeListener moPubNativeListener) {
+    /**
+     * @deprecated As of release 2.4, use {@link MoPubNative(Context, String,
+     * MoPubNativeNetworkListener)} and {@link #setNativeEventListener(MoPubNativeEventListener)}
+     * instead.
+     */
+    @Deprecated
+    public MoPubNative(final Context context,
+            final String adUnitId,
+            final MoPubNativeListener moPubNativeListener) {
+        this(context, adUnitId, (MoPubNativeNetworkListener)moPubNativeListener);
+        setNativeEventListener(moPubNativeListener);
+    }
+
+    public MoPubNative(final Context context,
+                final String adUnitId,
+                final MoPubNativeNetworkListener moPubNativeNetworkListener) {
         if (context == null) {
             throw new IllegalArgumentException("Context may not be null.");
         } else if (adUnitId == null) {
             throw new IllegalArgumentException("AdUnitId may not be null.");
-        } else if (moPubNativeListener == null) {
-            throw new IllegalArgumentException("MoPubNativeListener may not be null.");
+        } else if (moPubNativeNetworkListener == null) {
+            throw new IllegalArgumentException("MoPubNativeNetworkListener may not be null.");
         }
 
         ManifestUtils.checkNativeActivitiesDeclared(context);
 
         mContext = new WeakReference<Context>(context);
         mAdUnitId = adUnitId;
-        mMoPubNativeListener = moPubNativeListener;
-        
+        mMoPubNativeNetworkListener = moPubNativeNetworkListener;
+        mMoPubNativeEventListener = EMPTY_EVENT_LISTENER;
+
         // warm up cache for google play services info
         asyncFetchAdvertisingInfo(context);
     }
 
+    public void setNativeEventListener(final MoPubNativeEventListener nativeEventListener) {
+        mMoPubNativeEventListener = (nativeEventListener == null)
+                ? EMPTY_EVENT_LISTENER : nativeEventListener;
+    }
+
     public void destroy() {
         mContext.clear();
-        mMoPubNativeListener = EMPTY_MOPUB_NATIVE_LISTENER;
+        mMoPubNativeNetworkListener = EMPTY_NETWORK_LISTENER;
+        mMoPubNativeEventListener = EMPTY_EVENT_LISTENER;
     }
 
     public void setLocalExtras(final Map<String, Object> localExtras) {
@@ -83,8 +132,7 @@ public void setLocalExtras(final Map<String, Object> localExtras) {
     }
 
     public void makeRequest() {
-        final RequestParameters requestParameters = null;
-        makeRequest(requestParameters);
+        makeRequest((RequestParameters)null);
     }
 
     public void makeRequest(final RequestParameters requestParameters) {
@@ -98,7 +146,7 @@ void makeRequest(final NativeGpsHelperListener nativeGpsHelperListener) {
         }
 
         if (!DeviceUtils.isNetworkAvailable(context)) {
-            mMoPubNativeListener.onNativeFail(CONNECTION_ERROR);
+            mMoPubNativeNetworkListener.onNativeFail(CONNECTION_ERROR);
             return;
         }
 
@@ -111,16 +159,21 @@ void makeRequest(final NativeGpsHelperListener nativeGpsHelperListener) {
         );
     }
 
-    void loadNativeAd(final RequestParameters requestParameters) {
+    void loadNativeAd(final RequestParameters requestParameters, final Integer sequenceNumber) {
         final Context context = getContextOrDestroy();
         if (context == null) {
             return;
         }
 
-        final String endpointUrl = new NativeUrlGenerator(context)
+        final NativeUrlGenerator generator = new NativeUrlGenerator(context)
                 .withAdUnitId(mAdUnitId)
-                .withRequest(requestParameters)
-                .generateUrlString(Constants.NATIVE_HOST);
+                .withRequest(requestParameters);
+
+        if (sequenceNumber != null) {
+            generator.withSequenceNumber(sequenceNumber);
+        }
+
+        final String endpointUrl = generator.generateUrlString(Constants.NATIVE_HOST);
 
         if (endpointUrl != null) {
             MoPubLog.d("Loading ad from: " + endpointUrl);
@@ -129,6 +182,10 @@ void loadNativeAd(final RequestParameters requestParameters) {
         requestNativeAd(endpointUrl);
     }
 
+    void loadNativeAd(final RequestParameters requestParameters) {
+        loadNativeAd(requestParameters, null);
+    }
+
     void requestNativeAd(final String endpointUrl) {
         final Context context = getContextOrDestroy();
         if (context == null) {
@@ -136,7 +193,7 @@ void requestNativeAd(final String endpointUrl) {
         }
 
         if (endpointUrl == null) {
-            mMoPubNativeListener.onNativeFail(INVALID_REQUEST_URL);
+            mMoPubNativeNetworkListener.onNativeFail(INVALID_REQUEST_URL);
             return;
         }
 
@@ -144,7 +201,7 @@ void requestNativeAd(final String endpointUrl) {
         try {
             httpGet = HttpClient.initializeHttpGet(endpointUrl, context);
         } catch (IllegalArgumentException e) {
-            mMoPubNativeListener.onNativeFail(INVALID_REQUEST_URL);
+            mMoPubNativeNetworkListener.onNativeFail(INVALID_REQUEST_URL);
             return;
         }
 
@@ -156,14 +213,14 @@ private void downloadJson(final HttpUriRequest httpUriRequest) {
             @Override
             public void onComplete(final String url, final DownloadResponse downloadResponse) {
                 if (downloadResponse == null) {
-                    mMoPubNativeListener.onNativeFail(UNSPECIFIED);
+                    mMoPubNativeNetworkListener.onNativeFail(UNSPECIFIED);
                 } else if (downloadResponse.getStatusCode() >= 500 &&
                         downloadResponse.getStatusCode() < 600) {
-                    mMoPubNativeListener.onNativeFail(SERVER_ERROR_RESPONSE_CODE);
+                    mMoPubNativeNetworkListener.onNativeFail(SERVER_ERROR_RESPONSE_CODE);
                 } else if (downloadResponse.getStatusCode() != HttpStatus.SC_OK) {
-                    mMoPubNativeListener.onNativeFail(UNEXPECTED_RESPONSE_CODE);
+                    mMoPubNativeNetworkListener.onNativeFail(UNEXPECTED_RESPONSE_CODE);
                 } else if (downloadResponse.getContentLength() == 0) {
-                    mMoPubNativeListener.onNativeFail(EMPTY_AD_RESPONSE);
+                    mMoPubNativeNetworkListener.onNativeFail(EMPTY_AD_RESPONSE);
                 } else {
                     final CustomEventNativeListener customEventNativeListener = new CustomEventNativeListener() {
                         @Override
@@ -172,7 +229,7 @@ public void onNativeAdLoaded(final NativeAdInterface nativeAd) {
                             if (context == null) {
                                 return;
                             }
-                            mMoPubNativeListener.onNativeLoad(new NativeResponse(context, downloadResponse, nativeAd, mMoPubNativeListener));
+                            mMoPubNativeNetworkListener.onNativeLoad(new NativeResponse(context, downloadResponse, mAdUnitId, nativeAd, mMoPubNativeEventListener));
                         }
 
                         @Override
@@ -200,7 +257,7 @@ public void onNativeAdFailed(final NativeErrorCode errorCode) {
         } catch (Exception e) {
             MoPubLog.d("Failed to download json", e);
 
-            mMoPubNativeListener.onNativeFail(UNSPECIFIED);
+            mMoPubNativeNetworkListener.onNativeFail(UNSPECIFIED);
         }
 
     }
@@ -217,18 +274,27 @@ Context getContextOrDestroy() {
 
     // Do not store this class as a member of MoPubNative; will result in circular reference
     class NativeGpsHelperListener implements GpsHelperListener {
-        private RequestParameters mRequestParameters;
+        private final RequestParameters mRequestParameters;
+
         NativeGpsHelperListener(RequestParameters requestParameters) {
             mRequestParameters = requestParameters;
         }
+
         @Override
         public void onFetchAdInfoCompleted() {
             loadNativeAd(mRequestParameters);
         }
     }
 
+    @VisibleForTesting
+    @Deprecated
+    MoPubNativeNetworkListener getMoPubNativeNetworkListener() {
+        return mMoPubNativeNetworkListener;
+    }
+
+    @VisibleForTesting
     @Deprecated
-    MoPubNativeListener getMoPubNativeListener() {
-        return mMoPubNativeListener;
+    MoPubNativeEventListener getMoPubNativeEventListener() {
+        return mMoPubNativeEventListener;
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdLoadedListener.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdLoadedListener.java
new file mode 100644
index 00000000..84289613
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdLoadedListener.java
@@ -0,0 +1,20 @@
+package com.mopub.nativeads;
+
+/**
+ * A listener for determining when ads are loaded into an ad Placer
+ */
+public interface MoPubNativeAdLoadedListener {
+    /**
+     * Called when an ad is loaded at the specified position.
+     *
+     * @param position The ad position of the newly loaded ad.
+     */
+    void onAdLoaded(int position);
+
+    /**
+     * Called when an ad is removed at the specified position.
+     *
+     * @param position The removed ad position.
+     */
+    void onAdRemoved(int position);
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdPositioning.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdPositioning.java
new file mode 100644
index 00000000..d21c39b3
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdPositioning.java
@@ -0,0 +1,184 @@
+package com.mopub.nativeads;
+
+import android.util.SparseArray;
+
+import com.mopub.common.util.MoPubLog;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * A positioning object used to specify ad positions in client SDK integration code.
+ *
+ * Client positioning allows you to:
+ * <ul>
+ * <li>Specify fixed positions for ads</li>
+ * <li>Specify an spacing interval for ads, starting at the last fixed position</li>
+ * <li>Override the ad unit for a given fixed ad position. This is useful to
+ * direct-sell a "premium" ad unit at a specified position. It can also be useful
+ * if you want to track a position separately from other positions in the MoPub UI.</li>
+ * </ul>
+ *
+ * For example, to space ads every 5 items, starting at position 3:
+ * <code>
+ * MoPubNativeAdPositioning positioning = new MoPubNativeAdPositioning.Builder()
+ *     .addFixedPosition(3)
+ *     .enableRepeatingPositions(5)
+ *     .build();
+ * }
+ * </code>
+ *
+ * {@code MoPubNativeAdPositioning} is an immutable class. To create a new instance, use
+ * {@link MoPubNativeAdPositioning.Builder}.
+ */
+public final class MoPubNativeAdPositioning {
+    /**
+     * Constant for indicating that ad positions should not repeat.
+     */
+    public static final int NO_REPEAT = -1;
+
+    private final int mRepeatInterval;
+    private final List<Integer> mFixedPositions;
+    private final SparseArray<String> mAdUnitOverrides;
+
+    private MoPubNativeAdPositioning(final int repeatInterval, final List<Integer> fixedPositions,
+            final SparseArray<String> adUnitOverrides) {
+        mRepeatInterval = repeatInterval;
+
+        // Safe copy the positions to avoid modification
+        mFixedPositions = new ArrayList<Integer>(fixedPositions);
+
+        // Safe copy overrides. 'clone' is protected on pre-ICS devices, so we copy manually.
+        mAdUnitOverrides = new SparseArray<String>(adUnitOverrides.size());
+        for (int i = 0; i < adUnitOverrides.size(); ++i) {
+            mAdUnitOverrides.put(adUnitOverrides.keyAt(i), adUnitOverrides.valueAt(i));
+        }
+    }
+
+    /**
+     * Returns an ordered array of fixed ad positions.
+     *
+     * @return Fixed ad positions.
+     */
+    public List<Integer> getFixedPositions() {
+        return mFixedPositions;
+    }
+
+    /**
+     * Returns the repeating ad interval.
+     *
+     * Repeating ads start after the last fixed position. Returns -1 if there is no repeating
+     * interval.
+     *
+     * @return The repeating ad interval.
+     */
+    public int getRepeatingInterval() {
+        return mRepeatInterval;
+    }
+
+    /**
+     * Returns the overridden ad unit ID for the given position.
+     *
+     * Returns {@code null} if the position is not an ad, or if there is no overridden ad unit for
+     * this position.
+     *
+     * @param position The ad position.
+     * @return The overridden ad unit ID.
+     */
+    public String getAdUnitIdOverride(int position) {
+        return mAdUnitOverrides.get(position);
+    }
+
+    /**
+     * Creates and returns a {@code MoPubNativeAdPositioning.Builder}.
+     *
+     * @return A new builder.
+     */
+    public static Builder newBuilder() {
+        return new Builder();
+    }
+
+    /**
+     * A Builder class for the ad positioning.
+     */
+    public static final class Builder {
+        private int mRepeatInterval = MoPubNativeAdPositioning.NO_REPEAT;
+        private final List<Integer> mFixedPositions;
+        private final SparseArray<String> mAdUnitIdOverrides;
+
+        private Builder() {
+            mFixedPositions = new ArrayList<Integer>();
+            mAdUnitIdOverrides = new SparseArray<String>();
+        }
+
+        /**
+         * Specifies a fixed ad position.
+         *
+         * @param position The ad position.
+         * @return The builder.
+         */
+        public Builder addFixedPosition(final int position) {
+            internalAddFixedPosition(position);
+            return this;
+        }
+
+        /**
+         * Specifies a fixed ad position, with an ad unit ID override.
+         *
+         * Calling this method twice with the same position and different ad unit IDs replaces the
+         * first ad unit ID.
+         *
+         * @param position The ad position.
+         * @param adUnitIdOverride The ad unit ID to use when requesting and ad for this position.
+         * @return The builder.
+         */
+        public Builder addFixedPosition(final int position, final String adUnitIdOverride) {
+            if (internalAddFixedPosition(position)) {
+                mAdUnitIdOverrides.put(position, adUnitIdOverride);
+            }
+            return this;
+        }
+
+        private boolean internalAddFixedPosition(final int position) {
+            if (position < 0) {
+                return false;
+            }
+            if (!mFixedPositions.contains(position)) {
+                mFixedPositions.add(position);
+            } else {
+                mAdUnitIdOverrides.remove(position);
+            }
+            return true;
+        }
+
+        /**
+         * Enables showing ads ad at a repeated interval.
+         *
+         * @param interval The frequency at which to show ads. Must be an integer greater than 1 or
+         * the constant NO_REPEAT.
+         * @return The builder.
+         */
+        public Builder enableRepeatingPositions(final int interval) {
+            if (interval < 1 && interval != NO_REPEAT) {
+                MoPubLog.w("Attempted to assign an illegal interval < 1 to the" +
+                        " ad positioning object. Call ignored.");
+                return this;
+            }
+            mRepeatInterval = interval;
+            return this;
+        }
+
+        /**
+         * Creates and returns a new immutable positioning object.
+         *
+         * @return A new positioning object.
+         */
+        public MoPubNativeAdPositioning build() {
+            // Could insert into a sorted LinkedList instead of doing this.
+            Collections.sort(mFixedPositions);
+            return new MoPubNativeAdPositioning(mRepeatInterval, mFixedPositions,
+                    mAdUnitIdOverrides);
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdRenderer.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdRenderer.java
new file mode 100644
index 00000000..c21d36c2
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNativeAdRenderer.java
@@ -0,0 +1,119 @@
+package com.mopub.nativeads;
+
+import android.content.Context;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.Button;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.util.MoPubLog;
+
+import java.util.WeakHashMap;
+
+import static android.view.View.VISIBLE;
+
+/**
+ * An implementation of {@link com.mopub.nativeads.MoPubAdRenderer} for rendering native ads.
+ */
+public class MoPubNativeAdRenderer implements MoPubAdRenderer<NativeResponse> {
+
+    private final ViewBinder mViewBinder;
+
+    // This is used instead of View.setTag, which causes a memory leak in 2.3
+    // and earlier: https://code.google.com/p/android/issues/detail?id=18273
+    private final WeakHashMap<View, NativeViewHolder> mViewHolderMap;
+
+    /**
+     * Constructs a native ad renderer with a view binder.
+     *
+     * @param viewBinder The view binder to use when inflating and rendering an ad.
+     */
+    public MoPubNativeAdRenderer(final ViewBinder viewBinder) {
+        mViewBinder = viewBinder;
+        mViewHolderMap = new WeakHashMap<View, NativeViewHolder>();
+    }
+
+    @Override
+    public View createAdView(final Context context, final ViewGroup parent) {
+        return LayoutInflater
+                .from(context)
+                .inflate(mViewBinder.layoutId, parent, false);
+    }
+
+    @Override
+    public void renderAdView(final View view, final NativeResponse nativeResponse) {
+        final NativeViewHolder nativeViewHolder = getOrCreateNativeViewHolder(view, mViewBinder);
+
+        if (nativeViewHolder == null) {
+            MoPubLog.d("Could not create NativeViewHolder.");
+            return;
+        }
+
+        // Clean up previous state of view
+        removeClickListeners(view, nativeViewHolder);
+
+        populateConvertViewSubViews(view, nativeViewHolder, nativeResponse, mViewBinder);
+        attachClickListeners(view, nativeViewHolder, nativeResponse);
+        view.setVisibility(VISIBLE);
+        nativeResponse.prepareImpression(view);
+    }
+
+    @VisibleForTesting
+    NativeViewHolder getOrCreateNativeViewHolder(final View view, final ViewBinder viewBinder) {
+        // Create view holder and put it in the view tag
+        NativeViewHolder nativeViewHolder = mViewHolderMap.get(view);
+        if (nativeViewHolder == null) {
+            nativeViewHolder = NativeViewHolder.fromViewBinder(view, viewBinder);
+            mViewHolderMap.put(view, nativeViewHolder);
+            return nativeViewHolder;
+        }
+        return nativeViewHolder;
+    }
+
+    private void populateConvertViewSubViews(final View view,
+            final NativeViewHolder nativeViewHolder,
+            final NativeResponse nativeResponse,
+            final ViewBinder viewBinder) {
+        nativeViewHolder.update(nativeResponse);
+        nativeViewHolder.updateExtras(view, nativeResponse, viewBinder);
+    }
+
+    private void removeClickListeners(final View view, final NativeViewHolder nativeViewHolder) {
+        view.setOnClickListener(null);
+        setCtaClickListener(nativeViewHolder, null);
+    }
+
+    private void attachClickListeners(final View view,
+            final NativeViewHolder nativeViewHolder,
+            final NativeResponse nativeResponse) {
+        final NativeViewClickListener nativeViewClickListener =
+                new NativeViewClickListener(nativeResponse);
+        view.setOnClickListener(nativeViewClickListener);
+        setCtaClickListener(nativeViewHolder, nativeViewClickListener);
+    }
+
+    private void setCtaClickListener(final NativeViewHolder nativeViewHolder,
+            final NativeViewClickListener nativeViewClickListener) {
+        // CTA widget could be a button and buttons don't inherit click listeners from parents
+        // So we have to set it manually here if so
+        if (nativeViewHolder.callToActionView != null
+                && nativeViewHolder.callToActionView instanceof Button) {
+            nativeViewHolder.callToActionView.setOnClickListener(nativeViewClickListener);
+        }
+    }
+
+    @VisibleForTesting
+    static class NativeViewClickListener implements View.OnClickListener {
+        private final NativeResponse mNativeResponse;
+
+        NativeViewClickListener(final NativeResponse nativeResponse) {
+            mNativeResponse = nativeResponse;
+        }
+
+        @Override
+        public void onClick(final View view) {
+            mNativeResponse.handleClick(view);
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubStreamAdPlacer.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubStreamAdPlacer.java
new file mode 100644
index 00000000..7e0da7da
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubStreamAdPlacer.java
@@ -0,0 +1,532 @@
+package com.mopub.nativeads;
+
+import android.content.Context;
+import android.os.Handler;
+import android.view.View;
+import android.view.ViewGroup;
+
+import com.mopub.common.VisibleForTesting;
+
+import java.util.ArrayList;
+
+/**
+ * @code MoPubStreamAdPlacer facilitates loading ads and placing them into a content stream.
+ *
+ * If you are inserting ads into a ListView, we recommend that you use a {@link MoPubAdAdapter}
+ * instead of this class.
+ *
+ * To start loading ads, call {@link #loadAds}. We recommend passing targeting information to
+ * increase the chance that you show ads that are relevant to your users.
+ *
+ * This class is not intended to be used by multiple threads. All calls should be made from the main
+ * UI thread.
+ */
+public class MoPubStreamAdPlacer {
+    private final Context mContext;
+    private final Handler mPlacementHandler;
+    private final Runnable mPlacementRunnable;
+    private final NativeAdSource mAdSource;
+    private final ImpressionTracker mImpressionTracker;
+    private final PlacementData mPlacementData;
+
+    private MoPubNativeAdRenderer mAdRenderer;
+
+    private String mAdUnitId;
+    private MoPubNativeAdLoadedListener mAdLoadedListener;
+
+    // The visible range is the range of items which we believe are visible, inclusive.
+    // Placing ads near this range makes for a smoother user experience when scrolling up
+    // or down.
+    private static final int MAX_VISIBLE_RANGE = 100;
+    private int mVisibleRangeStart;
+    private int mVisibleRangeEnd;
+    private int mItemCount;
+
+    // A buffer around the visible range where we'll place ads if possible.
+    private static final int RANGE_BUFFER = 10;
+    private boolean mNeedsPlacement;
+    private boolean mIsLoadingFirstAd;
+
+    /**
+     * @param context The activity context.
+     * @param adPositioning A positioning object for specifying where ads will be placed in your
+     * stream.
+     */
+    public MoPubStreamAdPlacer(final Context context,
+            final MoPubNativeAdPositioning adPositioning) {
+        this(context, new NativeAdSource(), new ImpressionTracker(context),
+                PlacementData.fromAdPositioning(adPositioning));
+    }
+
+    @VisibleForTesting
+    MoPubStreamAdPlacer(final Context context,
+            final NativeAdSource adSource,
+            final ImpressionTracker impressionTracker,
+            final PlacementData placementData) {
+        mPlacementHandler = new Handler();
+        mPlacementRunnable = new Runnable() {
+            @Override
+            public void run() {
+                if (!mNeedsPlacement) {
+                    return;
+                }
+                placeAds();
+                mNeedsPlacement = false;
+            }
+        };
+
+        mContext = context;
+        mAdSource = adSource;
+        mImpressionTracker = impressionTracker;
+        mPlacementData = placementData;
+        mVisibleRangeStart = 0;
+        mVisibleRangeEnd = 0;
+    }
+
+    /**
+     * Registers an ad renderer to use when displaying ads in your stream.
+     *
+     * This renderer will automatically create and render your view when you call {@link
+     * #getAdView}. If you register a second renderer, it will replace the first, although this
+     * behavior is subject to change in a future SDK version.
+     *
+     * @param adRenderer The ad renderer.
+     */
+    public void registerAdRenderer(final MoPubNativeAdRenderer adRenderer) {
+        mAdRenderer = adRenderer;
+    }
+
+    /**
+     * Sets a listener that will be called after the SDK loads new ads from the server and places
+     * them into your stream.
+     *
+     * The listener will be active between when you call {@link #loadAds} and when you call {@link
+     * #destroy()}. You can also set the listener to {@code null} to remove the listener.
+     *
+     * Note that there is not a one to one correspondence between calls to {@link #loadAds} and this
+     * listener. The SDK will call the listener every time an ad loads.
+     *
+     * @param listener The listener.
+     */
+    public void setAdLoadedListener(final MoPubNativeAdLoadedListener listener) {
+        mAdLoadedListener = listener;
+    }
+
+    /**
+     * Start loading ads from the MoPub server.
+     *
+     * We recommend using {@link #loadAds(String, RequestParameters)} instead of this method, in
+     * order to pass targeting information to the server.
+     *
+     * @param adUnitId The ad unit ID to use when loading ads.
+     */
+    public void loadAds(final String adUnitId) {
+        loadAds(adUnitId, /* requestParameters */ null);
+    }
+
+    /**
+     * Start loading ads from the MoPub server, using the given request targeting information.
+     *
+     * When loading ads, use {@link MoPubNativeAdLoadedListener#onAdLoaded(int)} will be called for
+     * each ad that is added to the stream.
+     *
+     * To refresh ads in your stream, call {@code loadAds} again. When new ads load, they will
+     * replace the current ads in your stream. If you are using {@code MoPubNativeAdLoadedListener}
+     * you will see a call to {@code onAdRemoved} for each of the old ads, followed by a calls to
+     * {@code onAdLoaded}.
+     *
+     * @param adUnitId The ad unit ID to use when loading ads.
+     * @param requestParameters Targeting information to pass to the ad server.
+     */
+    public void loadAds(final String adUnitId,
+            final RequestParameters requestParameters) {
+        mAdUnitId = adUnitId;
+
+        // Is loading will be true until the first ad is available.
+        mIsLoadingFirstAd = true;
+        mAdSource.setAdSourceListener(new NativeAdSource.AdSourceListener() {
+            @Override
+            public void onAdsAvailable() {
+                // When the first ad is available, remove ads that may be present and immediately
+                // place ads again. This prevents the UI from flashing grossly.
+                if (mIsLoadingFirstAd) {
+                    removeAdsInRange(0, mItemCount);
+                    placeAds();
+                } else {
+                    notifyNeedsPlacement();
+                }
+                mIsLoadingFirstAd = false;
+            }
+        });
+
+        mAdSource.loadAds(mContext, adUnitId, requestParameters);
+    }
+
+    /**
+     * Inserts ads that should appear in the given range.
+     *
+     * By default, the ad placer will place ads withing the first 10 positions in your stream,
+     * according the positions you've specified. You can should use this method as your user scrolls
+     * through your stream to place ads into the currently visible range.
+     *
+     * This method takes advantage of a short-lived in memory ad cache, and will immediately place
+     * any ads from the cache. If there are no ads in the cache, this method will load additional
+     * ads from the server and place them once they are loaded. If you call {@code placeAdsInRange}
+     * again before ads are retrieved from the server, the new ads will show in the new positions
+     * rather than the old positions.
+     *
+     * You can pass any integer as a startPosition and endPosition for the range, including negative
+     * numbers or numbers greater than the current stream item count. The ad placer will only place
+     * ads between 0 and item count.
+     *
+     * @param startPosition The start of the range in which to place ads, inclusive.
+     * @param endPosition The end of the range in which to place ads, exclusive.
+     */
+    public void placeAdsInRange(final int startPosition, final int endPosition) {
+        mVisibleRangeStart = startPosition;
+        mVisibleRangeEnd = Math.min(endPosition, startPosition + MAX_VISIBLE_RANGE);
+        notifyNeedsPlacement();
+    }
+
+    /**
+     * Whether the given position is an ad.
+     *
+     * This will return {@code true} only if there is an ad loaded for this position. You can listen
+     * for ads to load using {@link MoPubNativeAdLoadedListener#onAdLoaded(int)}.
+     *
+     * @param position The position to check for an ad, expressed in terms of the position in the
+     * stream including ads.
+     * @return Whether there is an ad at the given position.
+     */
+    public boolean isAd(final int position) {
+        return mPlacementData.isPlacedAd(position);
+    }
+
+    /**
+     * Stops loading ads, immediately clearing any ads currently in the stream.
+     *
+     * This method also stops ads from loading as the user moves through the stream. If you want to
+     * just remove ads but want to continue loading them, call {@link #removeAdsInRange(int, int)}.
+     *
+     * When ads are cleared, {@link MoPubNativeAdLoadedListener#onAdRemoved} will be called for each
+     * ad that is removed from the stream.
+     */
+    public void clearAds() {
+        removeAdsInRange(0, mItemCount);
+        mAdSource.clear();
+    }
+
+    /**
+     * Destroys the ad placer, preventing it from future use.
+     *
+     * You must call this method before the hosting activity for this class is destroyed in order to
+     * avoid a memory leak. Typically you should destroy the adapter in the life-cycle method that
+     * is counterpoint to the method you used to create the adapter. For example, if you created the
+     * adapter in {@code Fragment#onCreateView} you should destroy it in {code
+     * Fragment#onDestroyView}.
+     */
+    public void destroy() {
+        mPlacementHandler.removeMessages(0);
+        mAdSource.clear();
+        mImpressionTracker.destroy();
+        mPlacementData.clearAds();
+    }
+
+    /**
+     * Returns an ad data object, or {@code null} if there is no ad at this position.
+     *
+     * This method is useful when implementing your own Adapter using {@code MoPubStreamAdPlacer}.
+     * To avoid worrying about view type, consider using {@link MoPubAdAdapter} instead of this
+     * class.
+     *
+     * @param position The position where to place an ad.
+     * @return An object representing ad data.
+     */
+    public Object getAdData(final int position) {
+        return mPlacementData.getPlacedAd(position);
+    }
+
+    /**
+     * Gets the ad at the given position, or {@code null} if there is no ad at the given position.
+     *
+     * This method will attempt to reuse the convertView if it is not {@code null}, and will
+     * otherwise create it. See {@link MoPubAdRenderer#createAdView(Context, ViewGroup)}.
+     *
+     * @param position The position where to place an ad.
+     * @param convertView A recycled view into which to render data, or {@code null}.
+     * @param parent The parent that the view will eventually be attached to.
+     * @return The newly placed ad view.
+     */
+    public View getAdView(final int position, final View convertView, final ViewGroup parent) {
+        if (!isAd(position)) {
+            return null;
+        }
+
+        final NativeAdData adData = mPlacementData.getPlacedAd(position);
+        final MoPubAdRenderer adRenderer = adData.getAdRenderer();
+        final View view = (convertView != null) ?
+                convertView : adRenderer.createAdView(mContext, parent);
+
+        NativeResponse nativeResponse = adData.getAd();
+        adRenderer.renderAdView(view, nativeResponse);
+        mImpressionTracker.addView(view, nativeResponse);
+        return view;
+    }
+
+    /**
+     * Removes ads in the given range from [startRange, endRange).
+     *
+     * @param originalStartPosition The start position to clear, expressed as the original content
+     * position before ads were inserted.
+     * @param originalEndPosition The position after end position to clear, expressed as the
+     * original content position before ads were inserted.
+     * @return The number of ads removed.
+     */
+    public int removeAdsInRange(int originalStartPosition, int originalEndPosition) {
+        int[] positions = mPlacementData.getPlacedAdPositions();
+
+        int adjustedStartRange = mPlacementData.getAdjustedPosition(originalStartPosition);
+        int adjustedEndRange = mPlacementData.getAdjustedPosition(originalEndPosition);
+
+        ArrayList<Integer> removedPositions = new ArrayList<Integer>();
+        // Traverse in reverse order to make this less error-prone for developers who are removing
+        // views directly from their UI.
+        for (int i = positions.length - 1; i >= 0; --i) {
+            int position = positions[i];
+            if (position < adjustedStartRange || position >= adjustedEndRange) {
+                continue;
+            }
+
+            removedPositions.add(position);
+
+            // Decrement the start range for any removed ads. We don't bother to decrement the end
+            // range, as it is OK if it isn't 100% accurate.
+            if (position < mVisibleRangeStart) {
+                mVisibleRangeStart--;
+            }
+        }
+
+        int clearedAdsCount = mPlacementData.clearAdsInRange(adjustedStartRange, adjustedEndRange);
+        for (int position : removedPositions) {
+            mAdLoadedListener.onAdRemoved(position);
+        }
+        return clearedAdsCount;
+    }
+
+    /**
+     * Returns the number of ad view types that can be placed by this ad placer. The number of
+     * possible ad view types is currently 1, but this is subject to change in future SDK versions.
+     *
+     * @return The number of ad view types.
+     * @see #getAdViewType
+     */
+    public int getAdViewTypeCount() {
+        return 1;
+    }
+
+    /**
+     * The ad view type for this position.
+     *
+     * Returns 0 if this is a regular content item. Otherwise, returns a number between 1 and {@link
+     * #getAdViewTypeCount}.
+     *
+     * This method is useful when implementing your own Adapter using {@code MoPubStreamAdPlacer}.
+     * To avoid worrying about view type, consider using {@link MoPubAdAdapter} instead of this
+     * class.
+     *
+     * @param position The stream position.
+     * @return The ad view type.
+     */
+    public int getAdViewType(final int position) {
+        return isAd(position) ? 0 : 1;
+    }
+
+    /**
+     * Returns the original position of an item considering ads in the stream.
+     *
+     * For example if your stream looks like:
+     *
+     * {@code Item0 Ad Item1 Item2 Ad Item3 </code>
+     *
+     * {@code getOriginalPosition(5)} will return {@code 3}.
+     *
+     * @param position The adjusted position.
+     * @return The original position before placing ads.
+     */
+    public int getOriginalPosition(final int position) {
+        return mPlacementData.getOriginalPosition(position);
+    }
+
+    /**
+     * Returns the position of an item considering ads in the stream.
+     *
+     * @param originalPosition The original position.
+     * @return The position adjusted by placing ads.
+     */
+    public int getAdjustedPosition(final int originalPosition) {
+        return mPlacementData.getAdjustedPosition(originalPosition);
+    }
+
+    /**
+     * Returns the original number of items considering ads in the stream.
+     *
+     * @param count The number of items in the stream.
+     * @return The original number of items before placing ads.
+     */
+    public int getOriginalCount(final int count) {
+        return mPlacementData.getOriginalCount(count);
+    }
+
+    /**
+     * Returns the number of items considering ads in the stream.
+     *
+     * @param originalCount The original number of items.
+     * @return The number of items adjusted by placing ads.
+     */
+    public int getAdjustedCount(final int originalCount) {
+        return mPlacementData.getAdjustedCount(originalCount);
+    }
+
+    /**
+     * Sets the original number of items in your stream.
+     *
+     * You must call this method so that the placer knows where valid positions are to place ads.
+     * After calling this method, the ad placer will call {@link
+     * MoPubNativeAdLoadedListener#onAdLoaded
+     * (int)} each time an ad is loaded in the stream.
+     *
+     * @param originalCount The original number of items.
+     */
+    public void setItemCount(final int originalCount) {
+        mItemCount = mPlacementData.getAdjustedCount(originalCount);
+        notifyNeedsPlacement();
+    }
+
+    /**
+     * Inserts a content row at the given position, adjusting ad positions accordingly.
+     *
+     * Use this method if you are inserting an item into your stream and want to increment ad
+     * positions based on that new item.
+     *
+     * For example if your stream looks like:
+     *
+     * {@code Item0 Ad Item1 Item2 Ad Item3}
+     *
+     * and you insert an item at position 2, your new stream will look like:
+     *
+     * {@code Item0 Ad Item1 Item2 New Item Ad Item3}
+     *
+     * @param originalPosition The position at which to add an item. If you have an adjusted
+     * position, you will need to call {@link #getOriginalPosition} to get this value.
+     */
+    public void insertItem(final int originalPosition) {
+        mPlacementData.insertItem(originalPosition);
+    }
+
+    /**
+     * Removes the content row at the given position, adjusting ad positions accordingly.
+     *
+     * Use this method if you are removing an item from your stream and want to decrement ad
+     * positions based on that removed item.
+     *
+     * For example if your stream looks like:
+     *
+     * {@code Item0 Ad Item1 Item2 Ad Item3}
+     *
+     * and you remove an item at position 2, your new stream will look like:
+     *
+     * {@code Item0 Ad Item1 Ad Item3}
+     *
+     * @param originalPosition The position at which to add an item. If you have an adjusted
+     * position, you will need to call {@link #getOriginalPosition} to get this value.
+     */
+    public void removeItem(final int originalPosition) {
+        mPlacementData.removeItem(originalPosition);
+    }
+
+    /**
+     * Moves the content row at the given position adjusting ad positions accordingly.
+     *
+     * Use this method if you are moving an item in your stream and want to have ad positions move
+     * as well.
+     *
+     * @param originalPosition The position from which to move an item. If you have an adjusted
+     * position, you will need to call {@link #getOriginalPosition} to get this value.
+     * @param newPosition The new position, also expressed in terms of the original position.
+     */
+    public void moveItem(final int originalPosition, final int newPosition) {
+        mPlacementData.moveItem(originalPosition, newPosition);
+    }
+
+    private void notifyNeedsPlacement() {
+        // Avoid posting if this method has already been called.
+        if (mNeedsPlacement) {
+            return;
+        }
+        mNeedsPlacement = true;
+
+        // Post the placement to happen on the next UI render loop.
+        mPlacementHandler.post(mPlacementRunnable);
+    }
+
+    /**
+     * Places ads using the current visible range.
+     */
+    private void placeAds() {
+        // Place ads within the visible range
+        if (!tryPlaceAdsInRange(mVisibleRangeStart, mVisibleRangeEnd)) {
+            return;
+        }
+
+        // Place ads after the visible range so that user will see an ad if they scroll down. We
+        // don't place an ad before the visible range, because we are trying to be mindful of
+        // changes that will affect scrolling.
+        tryPlaceAdsInRange(mVisibleRangeEnd, mVisibleRangeEnd + RANGE_BUFFER);
+    }
+
+    /**
+     * Attempts to place ads in the range (start, end], returning false if there is no ad available
+     * to be placed.
+     */
+    private boolean tryPlaceAdsInRange(final int start, final int end) {
+        int position = start;
+        int lastPosition = end - 1;
+        while (position <= lastPosition && position != PlacementData.NOT_FOUND) {
+            if (position >= mItemCount) {
+                break;
+            }
+            if (mPlacementData.shouldPlaceAd(position)) {
+                if (!tryPlaceAd(position)) {
+                    return false;
+                }
+                lastPosition++;
+            }
+            position = mPlacementData.nextInsertionPosition(position);
+        }
+        return true;
+    }
+
+    /**
+     * Attempts to place an ad at the given position, returning false if there is no ad available to
+     * be placed.
+     */
+    private boolean tryPlaceAd(final int position) {
+        final NativeResponse adResponse = mAdSource.dequeueAd();
+        if (adResponse == null) {
+            return false;
+        }
+
+        final NativeAdData adData = createAdData(position, adResponse);
+        mPlacementData.placeAd(position, adData);
+        mItemCount++;
+
+        if (mAdLoadedListener != null) {
+            mAdLoadedListener.onAdLoaded(position);
+        }
+        return true;
+    }
+
+    private NativeAdData createAdData(final int position, final NativeResponse adResponse) {
+        return new NativeAdData(mAdUnitId, mAdRenderer, adResponse);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdData.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdData.java
new file mode 100644
index 00000000..d4623a35
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdData.java
@@ -0,0 +1,30 @@
+package com.mopub.nativeads;
+
+/**
+ * An object that represents placed ads in a {@link com.mopub.nativeads.MoPubStreamAdPlacer}
+ */
+class NativeAdData {
+    private final String adUnitId;
+    private final MoPubAdRenderer adRenderer;
+    private final NativeResponse adResponse;
+
+    NativeAdData(final String adUnitId,
+            final MoPubAdRenderer adRenderer,
+            final NativeResponse adResponse) {
+        this.adUnitId = adUnitId;
+        this.adRenderer = adRenderer;
+        this.adResponse = adResponse;
+    }
+
+    String getAdUnitId() {
+        return adUnitId;
+    }
+
+    MoPubAdRenderer getAdRenderer() {
+        return adRenderer;
+    }
+
+    NativeResponse getAd() {
+        return adResponse;
+    }
+}
\ No newline at end of file
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdSource.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdSource.java
new file mode 100644
index 00000000..f48bf770
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdSource.java
@@ -0,0 +1,236 @@
+package com.mopub.nativeads;
+
+import android.content.Context;
+import android.os.Handler;
+import android.os.SystemClock;
+
+import com.mopub.common.VisibleForTesting;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static com.mopub.nativeads.MoPubNative.MoPubNativeNetworkListener;
+
+/**
+ * An ad source responsible for requesting ads from the MoPub ad server.
+ *
+ * The ad source utilizes a cache to store ads, which allows ads to be immediately visible when
+ * scrolling through a stream rather than "snapping" in when loaded. The cache is implemented as
+ * a queue, so that the first ad loaded from the server will be the first ad available for dequeue.
+ * To take an ad out of the cache, call {@link #dequeueAd}.
+ *
+ * The cache size may be automatically adjusted by the MoPub server based on an app's usage and
+ * ad fill rate. Cached ads have a maximum TTL of 15 minutes before which they expire.
+ *
+ * The ad source also takes care of retrying failed ad requests, with a reasonable back-off to
+ * avoid spamming the server.
+ *
+ * This class is not thread safe and should only be called from the UI thread.
+ */
+class NativeAdSource {
+    private static final int CACHE_LIMIT = 3;
+    private static final int EXPIRATION_TIME_MILLISECONDS = 15 * 60 * 1000; // 15 minutes
+    private static final int DEFAULT_RETRY_TIME_MILLISECONDS = 1000; // 1 second
+    private static final int MAXIMUM_RETRY_TIME_MILLISECONDS = 5 * 60 * 1000; // 5 minutes.
+    private static final double EXPONENTIAL_BACKOFF_FACTOR = 2.0;
+
+    private final List<TimestampWrapper<NativeResponse>> mNativeAdCache;
+    private final Handler mReplenishCacheHandler;
+    private final Runnable mReplenishCacheRunnable;
+    private final MoPubNativeNetworkListener mMoPubNativeNetworkListener;
+
+    @VisibleForTesting boolean mRequestInFlight;
+    @VisibleForTesting int mSequenceNumber;
+    @VisibleForTesting int mRetryTimeMilliseconds;
+
+    private AdSourceListener mAdSourceListener;
+
+    // We will need collections of these when we support multiple ad units.
+    private RequestParameters mRequestParameters;
+    private MoPubNative mMoPubNative;
+
+    /**
+     * A listener for when ads are available for dequeueing.
+     */
+    interface AdSourceListener {
+        /**
+         * Called when the number of items available for goes from 0 to more than 0.
+         */
+        void onAdsAvailable();
+    }
+
+    NativeAdSource() {
+        this(new ArrayList<TimestampWrapper<NativeResponse>>(CACHE_LIMIT), new Handler());
+    }
+
+    @VisibleForTesting
+    NativeAdSource(final List<TimestampWrapper<NativeResponse>> nativeAdCache,
+            final Handler replenishCacheHandler) {
+        mNativeAdCache = nativeAdCache;
+        mReplenishCacheHandler = replenishCacheHandler;
+        mReplenishCacheRunnable = new Runnable() {
+            @Override
+            public void run() {
+                replenishCache();
+            }
+        };
+
+        // Construct native URL and start filling the cache
+        mMoPubNativeNetworkListener = new MoPubNativeNetworkListener() {
+            @Override
+            public void onNativeLoad(final NativeResponse nativeResponse) {
+                // This can be null if the ad source was cleared as the AsyncTask is posting
+                // back to the UI handler. Drop this response.
+                if (mMoPubNative == null) {
+                    return;
+                }
+
+                mRequestInFlight = false;
+                mSequenceNumber++;
+                resetRetryTime();
+
+                mNativeAdCache.add(new TimestampWrapper<NativeResponse>(nativeResponse));
+                if (mNativeAdCache.size() == 1 && mAdSourceListener != null) {
+                    mAdSourceListener.onAdsAvailable();
+                }
+
+                replenishCache();
+            }
+
+            @Override
+            public void onNativeFail(final NativeErrorCode errorCode) {
+                // Stopping requests after the max retry time prevents us from using battery when
+                // the user is not interacting with the stream, eg. the app is backgrounded.
+                if (mRetryTimeMilliseconds >= MAXIMUM_RETRY_TIME_MILLISECONDS) {
+                    // Reset the retry time for the next time we dequeue.
+                    mRequestInFlight = false;
+                    resetRetryTime();
+                    return;
+                }
+
+                // Don't reset mRequestInFlight here - dequeueAd shouldn't short-circuit the retry.
+                updateRetryTime();
+                mReplenishCacheHandler.postDelayed(mReplenishCacheRunnable, mRetryTimeMilliseconds);
+            }
+        };
+
+        mSequenceNumber = 0;
+        mRetryTimeMilliseconds = DEFAULT_RETRY_TIME_MILLISECONDS;
+    }
+
+    /**
+     * Sets a adSourceListener for determining when ads are available.
+     * @param adSourceListener An AdSourceListener.
+     */
+    void setAdSourceListener(final AdSourceListener adSourceListener) {
+        mAdSourceListener = adSourceListener;
+    }
+
+    void loadAds(final Context context,
+            final String adUnitId,
+            final RequestParameters requestParameters) {
+        loadAds(requestParameters, new MoPubNative(context, adUnitId, mMoPubNativeNetworkListener));
+    }
+
+    @VisibleForTesting
+    void loadAds(final RequestParameters requestParameters,
+             final MoPubNative moPubNative) {
+        clear();
+
+        mRequestParameters = requestParameters;
+        mMoPubNative = moPubNative;
+
+        replenishCache();
+    }
+
+    /**
+     * Clears the ad source, removing any currently queued ads.
+     */
+    void clear() {
+        // This will cleanup listeners to stop callbacks from handling old ad units
+        if (mMoPubNative != null) {
+            mMoPubNative.destroy();
+            mMoPubNative = null;
+        }
+
+        mRequestParameters = null;
+
+        for (final TimestampWrapper<NativeResponse> timestampWrapper : mNativeAdCache) {
+            timestampWrapper.mInstance.destroy();
+        }
+        mNativeAdCache.clear();
+
+        mReplenishCacheHandler.removeMessages(0);
+        mRequestInFlight = false;
+        mSequenceNumber = 0;
+        resetRetryTime();
+    }
+
+    /**
+     * Removes an ad from the front of the ad source cache.
+     *
+     * Dequeueing will automatically attempt to replenish the cache. Callers should dequeue ads as
+     * late as possible, typically immediately before rendering them into a view.
+     *
+     * Set the listener to {@code null} to remove the listener.
+     *
+     * @return Ad ad item that should be rendered into a view.
+     */
+    NativeResponse dequeueAd() {
+        final long now = SystemClock.uptimeMillis();
+
+        // Starting an ad request takes several millis. Post for performance reasons.
+        if (!mRequestInFlight) {
+            mReplenishCacheHandler.post(mReplenishCacheRunnable);
+        }
+
+        // Dequeue the first ad that hasn't expired.
+        while (!mNativeAdCache.isEmpty()) {
+            TimestampWrapper<NativeResponse> responseWrapper = mNativeAdCache.remove(0);
+
+            if (now - responseWrapper.mCreatedTimestamp < EXPIRATION_TIME_MILLISECONDS) {
+                return responseWrapper.mInstance;
+            }
+        }
+        return null;
+    }
+
+    @VisibleForTesting
+    void updateRetryTime() {
+        // Backoff time calculations
+        mRetryTimeMilliseconds = (int) (mRetryTimeMilliseconds * EXPONENTIAL_BACKOFF_FACTOR);
+        if (mRetryTimeMilliseconds > MAXIMUM_RETRY_TIME_MILLISECONDS) {
+            mRetryTimeMilliseconds = MAXIMUM_RETRY_TIME_MILLISECONDS;
+        }
+    }
+
+    @VisibleForTesting
+    void resetRetryTime() {
+        mRetryTimeMilliseconds = DEFAULT_RETRY_TIME_MILLISECONDS;
+    }
+
+    /**
+     * Replenish ads in the ad source cache.
+     *
+     * Calling this method is useful for warming the cache without dequeueing an ad.
+     */
+    @VisibleForTesting
+    void replenishCache() {
+        if (!mRequestInFlight && mMoPubNative != null && mNativeAdCache.size() < CACHE_LIMIT) {
+            mRequestInFlight = true;
+            mMoPubNative.loadNativeAd(mRequestParameters, mSequenceNumber);
+        }
+    }
+
+    @Deprecated
+    @VisibleForTesting
+    void setMoPubNative(final MoPubNative moPubNative) {
+        mMoPubNative = moPubNative;
+    }
+
+    @Deprecated
+    @VisibleForTesting
+    MoPubNativeNetworkListener getMoPubNativeNetworkListener() {
+        return mMoPubNativeNetworkListener;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdViewHelper.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdViewHelper.java
index faf76da4..454f7c26 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdViewHelper.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdViewHelper.java
@@ -1,21 +1,29 @@
 package com.mopub.nativeads;
 
 import android.content.Context;
-import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
-import android.widget.Button;
 
 import com.mopub.common.util.MoPubLog;
 
+import java.util.WeakHashMap;
+
 import static android.view.View.GONE;
-import static android.view.View.OnClickListener;
-import static android.view.View.VISIBLE;
 import static com.mopub.nativeads.MoPubNative.MoPubNativeListener;
 
+/**
+ * @deprecated As of release 2.4, use {@link com.mopub.nativeads.MoPubNativeAdRenderer} instead
+ */
+@Deprecated
 class NativeAdViewHelper {
     private NativeAdViewHelper() {}
 
+    // Because the impression tracker requires tracking drawing views,
+    // each context requires a separate impression tracker. To avoid leaking, keep weak references.
+    private static final WeakHashMap<Context, ImpressionTracker> sImpressionTrackerMap =
+            new WeakHashMap<Context, ImpressionTracker>();
+
+    @Deprecated
     static View getAdView(View convertView,
                           final ViewGroup parent,
                           final Context context,
@@ -28,15 +36,12 @@ static View getAdView(View convertView,
             return new View(context);
         }
 
+        final MoPubNativeAdRenderer moPubNativeAdRenderer = new MoPubNativeAdRenderer(viewBinder);
         if (convertView == null) {
-            convertView = createConvertView(context, parent, viewBinder);
+            convertView = moPubNativeAdRenderer.createAdView(context, parent);
         }
 
-        final NativeViewHolder nativeViewHolder = getOrCreateNativeViewHolder(convertView, viewBinder);
-
-        // Clean up previous state of view
-        removeClickListeners(convertView, nativeViewHolder);
-        ImpressionTrackingManager.removeView(convertView);
+        cleanUpImpressionTracking(context, convertView);
 
         if (nativeResponse == null) {
             // If we don't have content for the view, then hide the view for now
@@ -45,92 +50,28 @@ static View getAdView(View convertView,
         } else if (nativeResponse.isDestroyed()) {
             MoPubLog.d("NativeResponse is destroyed, returning hidden view.");
             convertView.setVisibility(GONE);
-        } else if (nativeViewHolder == null) {
-            MoPubLog.d("Could not create NativeViewHolder, returning hidden view.");
-            convertView.setVisibility(GONE);
         } else {
-            populateConvertViewSubViews(convertView, nativeViewHolder, nativeResponse, viewBinder);
-            attachClickListeners(convertView, nativeViewHolder, nativeResponse);
-            convertView.setVisibility(VISIBLE);
-            nativeResponse.prepareImpression(convertView);
+            moPubNativeAdRenderer.renderAdView(convertView, nativeResponse);
+            prepareImpressionTracking(context, convertView, nativeResponse);
         }
 
         return convertView;
     }
 
-    private static View createConvertView(final Context context, final ViewGroup parent, final ViewBinder viewBinder) {
-        final View convertView = LayoutInflater
-                .from(context)
-                .inflate(viewBinder.layoutId, parent, false);
-        return convertView;
+    private static void cleanUpImpressionTracking(final Context context, final View view) {
+        getImpressionTracker(context).removeView(view);
     }
 
-    static NativeViewHolder getOrCreateNativeViewHolder(final View convertView, final ViewBinder viewBinder) {
-        // Create view holder and put it in the view tag
-        Object object = ImageViewService.getViewTag(convertView);
-        if (object == null || !(object instanceof NativeViewHolder)) {
-            final NativeViewHolder nativeViewHolder = NativeViewHolder.fromViewBinder(convertView, viewBinder);
-            ImageViewService.setViewTag(convertView, nativeViewHolder);
-            return nativeViewHolder;
-        } else {
-            return (NativeViewHolder) object;
-        }
-    }
-
-    private static void populateConvertViewSubViews(final View convertView,
-            final NativeViewHolder nativeViewHolder,
-            final NativeResponse nativeResponse,
-            final ViewBinder viewBinder) {
-        nativeViewHolder.update(nativeResponse);
-        nativeViewHolder.updateExtras(convertView, nativeResponse, viewBinder);
-    }
-
-    private static void removeClickListeners(final View view,
-                                             final NativeViewHolder nativeViewHolder) {
-        if (view == null) {
-            return;
-        }
-
-        view.setOnClickListener(null);
-        setCtaClickListener(nativeViewHolder, null);
+    private static void prepareImpressionTracking(final Context context, final View view, final NativeResponse nativeResponse) {
+        getImpressionTracker(context).addView(view, nativeResponse);
     }
 
-    private static void attachClickListeners(final View view,
-            final NativeViewHolder nativeViewHolder,
-            final NativeResponse nativeResponse) {
-        if (view == null || nativeResponse == null) {
-            return;
-        }
-
-        final NativeViewClickListener nativeViewClickListener
-                = new NativeViewClickListener(nativeResponse);
-        view.setOnClickListener(nativeViewClickListener);
-        setCtaClickListener(nativeViewHolder, nativeViewClickListener);
-    }
-
-    private static void setCtaClickListener(final NativeViewHolder nativeViewHolder,
-            final NativeViewClickListener nativeViewClickListener) {
-        if (nativeViewHolder == null || nativeViewClickListener == null) {
-            return;
-        }
-
-        // CTA widget could be a button and buttons don't inherit click listeners from parents
-        // So we have to set it manually here if so
-        if (nativeViewHolder.callToActionView != null && nativeViewHolder.callToActionView instanceof Button) {
-            nativeViewHolder.callToActionView.setOnClickListener(nativeViewClickListener);
-        }
-    }
-
-    static class NativeViewClickListener implements OnClickListener {
-        private final NativeResponse mNativeResponse;
-
-        NativeViewClickListener(final NativeResponse nativeResponse) {
-            mNativeResponse = nativeResponse;
-        }
-
-        @Override
-        public void onClick(View view) {
-            mNativeResponse.handleClick(view);
+    private static ImpressionTracker getImpressionTracker(final Context context) {
+        ImpressionTracker impressionTracker = sImpressionTrackerMap.get(context);
+        if (impressionTracker == null) {
+            impressionTracker = new ImpressionTracker(context);
+            sImpressionTrackerMap.put(context, impressionTracker);
         }
+        return impressionTracker;
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeErrorCode.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeErrorCode.java
index c0d86de4..7999f22f 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeErrorCode.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeErrorCode.java
@@ -12,7 +12,7 @@
 
     NETWORK_INVALID_REQUEST("Third-party network received invalid request."),
     NETWORK_TIMEOUT("Third-party network failed to respond in a timely manner."),
-    NETWORK_NO_FILL("Third-party network failed to provide inventory."),
+    NETWORK_NO_FILL("Third-party network failed to provide an ad."),
     NETWORK_INVALID_STATE("Third-party network failed due to invalid internal state."),
 
     NATIVE_ADAPTER_CONFIGURATION_ERROR("Custom Event Native was configured incorrectly."),
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeResponse.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeResponse.java
index e353c2bf..d8662959 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeResponse.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeResponse.java
@@ -9,9 +9,11 @@
 import com.mopub.common.DownloadResponse;
 import com.mopub.common.HttpClient;
 import com.mopub.common.MoPubBrowser;
+import com.mopub.common.VisibleForTesting;
 import com.mopub.common.util.IntentUtils;
 import com.mopub.common.util.MoPubLog;
 import com.mopub.common.util.ResponseHeader;
+import com.mopub.nativeads.MoPubNative.MoPubNativeEventListener;
 
 import java.lang.ref.SoftReference;
 import java.util.ArrayList;
@@ -22,8 +24,6 @@
 import java.util.Map;
 import java.util.Set;
 
-import static com.mopub.nativeads.MoPubNative.MoPubNativeListener;
-import static com.mopub.nativeads.MoPubNative.MoPubNativeListener.EMPTY_MOPUB_NATIVE_LISTENER;
 import static com.mopub.nativeads.NativeResponse.Parameter.CALL_TO_ACTION;
 import static com.mopub.nativeads.NativeResponse.Parameter.CLICK_DESTINATION;
 import static com.mopub.nativeads.NativeResponse.Parameter.CLICK_TRACKER;
@@ -36,7 +36,7 @@
 import static com.mopub.nativeads.UrlResolutionTask.UrlResolutionListener;
 import static com.mopub.nativeads.UrlResolutionTask.getResolvedUrl;
 
-public final class NativeResponse {
+public class NativeResponse {
     enum Parameter {
         IMPRESSION_TRACKER("imptracker", true),
         CLICK_TRACKER("clktracker", true),
@@ -69,7 +69,8 @@ static Parameter from(final String name) {
             return null;
         }
 
-        static Set<String> requiredKeys = new HashSet<String>();
+        @VisibleForTesting
+        static final Set<String> requiredKeys = new HashSet<String>();
         static {
             for (final Parameter parameter : values()) {
                 if (parameter.required) {
@@ -79,24 +80,27 @@ static Parameter from(final String name) {
         }
     }
 
-    final Context mContext;
-    MoPubNativeListener mMoPubNativeListener;
-    final NativeAdInterface mNativeAd;
+    private final Context mContext;
+    private MoPubNativeEventListener mMoPubNativeEventListener;
+    private final NativeAdInterface mNativeAd;
 
     // Impression and click trackers for the MoPub adserver
-    final Set<String> mMoPubImpressionTrackers;
-    final String mMoPubClickTracker;
+    private final Set<String> mMoPubImpressionTrackers;
+    private final String mMoPubClickTracker;
+    private final String mAdUnitId;
 
-    boolean mRecordedImpression;
-    boolean mIsClicked;
-    boolean mIsDestroyed;
+    private boolean mRecordedImpression;
+    private boolean mIsClicked;
+    private boolean mIsDestroyed;
 
     public NativeResponse(final Context context,
             final DownloadResponse downloadResponse,
+            final String adUnitId,
             final NativeAdInterface nativeAd,
-            final MoPubNativeListener moPubNativeListener) {
+            final MoPubNativeEventListener moPubNativeEventListener) {
         mContext = context.getApplicationContext();
-        mMoPubNativeListener = moPubNativeListener;
+        mAdUnitId = adUnitId;
+        mMoPubNativeEventListener = moPubNativeEventListener;
         mNativeAd = nativeAd;
 
         mMoPubImpressionTrackers = new HashSet<String>();
@@ -123,6 +127,10 @@ public String toString() {
         return stringBuilder.toString();
     }
 
+   public String getAdUnitId() {
+       return mAdUnitId;
+   }
+
     // Interface Methods
     // Getters
     public String getMainImageUrl() {
@@ -187,7 +195,6 @@ public void prepareImpression(final View view) {
             return;
         }
 
-        ImpressionTrackingManager.addView(view, this);
         mNativeAd.prepareImpression(view);
     }
 
@@ -203,7 +210,7 @@ public void recordImpression(final View view) {
         mNativeAd.recordImpression();
         mRecordedImpression = true;
 
-        mMoPubNativeListener.onNativeImpression(view);
+        mMoPubNativeEventListener.onNativeImpression(view);
     }
 
     public void handleClick(final View view) {
@@ -219,7 +226,7 @@ public void handleClick(final View view) {
         mNativeAd.handleClick(view);
         mIsClicked = true;
 
-        mMoPubNativeListener.onNativeClick(view);
+        mMoPubNativeEventListener.onNativeClick(view);
     }
 
     public void destroy() {
@@ -227,7 +234,7 @@ public void destroy() {
             return;
         }
 
-        mMoPubNativeListener = EMPTY_MOPUB_NATIVE_LISTENER;
+        mMoPubNativeEventListener = MoPubNative.EMPTY_EVENT_LISTENER;
 
         mNativeAd.destroy();
         mIsDestroyed = true;
@@ -341,13 +348,13 @@ public String getSubtitle() {
         return mNativeAd.getText();
     }
 
-    // Testing
+    @VisibleForTesting
     @Deprecated
-    MoPubNativeListener getMoPubNativeListener() {
-        return mMoPubNativeListener;
+    MoPubNativeEventListener getMoPubNativeEventListener() {
+        return mMoPubNativeEventListener;
     }
 
-    // Testing
+    @VisibleForTesting
     @Deprecated
     void setRecordedImpression(final boolean recordedImpression) {
         mRecordedImpression = recordedImpression;
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeUrlGenerator.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeUrlGenerator.java
index af13c917..f04ea52e 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeUrlGenerator.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeUrlGenerator.java
@@ -3,6 +3,7 @@
 import android.content.Context;
 import android.location.Location;
 import android.os.Build;
+import android.text.TextUtils;
 
 import com.mopub.common.AdUrlGenerator;
 import com.mopub.common.GpsHelper;
@@ -16,6 +17,7 @@
             = LocationService.LocationAwareness.NORMAL;
 
     private String mDesiredAssets;
+    private String mSequenceNumber;
 
     NativeUrlGenerator(Context context) {
         super(context);
@@ -36,6 +38,11 @@ NativeUrlGenerator withRequest(final RequestParameters requestParameters) {
         return this;
     }
 
+    NativeUrlGenerator withSequenceNumber(final int sequenceNumber) {
+        mSequenceNumber = String.valueOf(sequenceNumber);
+        return this;
+    }
+
     @Override
     public String generateUrlString(final String serverHostname) {
         initUrlString(serverHostname, Constants.NATIVE_HANDLER);
@@ -82,9 +89,17 @@ public String generateUrlString(final String serverHostname) {
 
         setDesiredAssets();
 
+        setSequenceNumber();
+
         return getFinalUrlString();
     }
 
+    private void setSequenceNumber() {
+       if (!TextUtils.isEmpty(mSequenceNumber)) {
+           addParam("MAGIC_NO", mSequenceNumber);
+       }
+    }
+
     private void setDesiredAssets() {
         if (mDesiredAssets != null && !Strings.isEmpty(mDesiredAssets)) {
             addParam("assets", mDesiredAssets);
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeViewHolder.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeViewHolder.java
index 9e81b899..af85637a 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeViewHolder.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeViewHolder.java
@@ -17,7 +17,7 @@
     private NativeViewHolder() {}
 
     static NativeViewHolder fromViewBinder(final View view, final ViewBinder viewBinder) {
-        NativeViewHolder nativeViewHolder = new NativeViewHolder();
+        final NativeViewHolder nativeViewHolder = new NativeViewHolder();
 
         try {
             nativeViewHolder.titleView = (TextView) view.findViewById(viewBinder.titleId);
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/PlacementData.java b/mopub-sdk/src/main/java/com/mopub/nativeads/PlacementData.java
new file mode 100644
index 00000000..f80d08bb
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/PlacementData.java
@@ -0,0 +1,515 @@
+package com.mopub.nativeads;
+
+import com.mopub.common.util.MoPubLog;
+
+import java.util.List;
+
+/**
+ * A data that represents placed ads in a {@link com.mopub.nativeads.MoPubStreamAdPlacer},
+ * useful for tracking insertion and placed ad positions.
+ *
+ * It maintains four lists of integers
+ * 1) Desired insertion positions - positions to place ads
+ * 2) Desired original positions - original position for each ad to place
+ * 2) Adjusted ad positions - ad positions that were placed
+ * 3) Original ad positions - original position of the item after each placed ad
+ *
+ * For example, consider the following ad positions:
+ * ORIGINAL LIST    ADJUSTED LIST
+ *   Item 0           Item 0
+ *   Item 1           Ad
+ *   Item 2           Item 1
+ *   Item 3           Ad
+ *                    Item 2
+ *                    Ad
+ *                    Item 3
+ *
+ * List starts as:
+ *   Item 0
+ *   Item 1
+ *   Item 2
+ *   Item 3
+ * desiredOriginalPositions: {1, 2, 3}
+ * desiredInsertionPositions: {1, 2, 3}
+ * originalPositions: {}
+ * adjustedPositions: {}
+ *
+ * If we place at position 2:
+ *   Item 0
+ *   Item 1
+ *   Ad
+ *   Item 2
+ *   Item 3
+ * desiredOriginalPositions: {1, 3}
+ * desiredInsertionPositions: {1, 4}
+ * originalPositions: {2}
+ * adjustedPositions: {2}
+ *
+ * If the developer adds a content item at position 2
+ *   Item 0
+ *   Item 1
+ *   New Item
+ *   Ad
+ *   Item 3
+ *   Item 4
+ * desiredOriginalPositions: {1, 4}
+ * desiredInsertionPositions: {1, 5}
+ * originalPositions: {3}
+ * adjustedPositions: {3}
+ *
+ * Now, place at position 1
+ *   Item 0
+ *   Ad
+ *   Item 1
+ *   New Item
+ *   Ad
+ *   Item 3
+ *   Item 4
+ * desiredOriginalPositions: {4}
+ * desiredInsertionPositions: {6}
+ * originalPositions: {1, 3}
+ * adjustedPositions: {1, 4}
+ *
+ * Place at position 6
+ *   Item 0
+ *   Ad
+ *   Item 1
+ *   New Item
+ *   Ad
+ *   Item 3
+ *   Ad
+ *   Item 4
+ * desiredOriginalPositions: {}
+ * desiredInsertionPositions: {}
+ * originalPositions: {1, 3, 4}
+ * adjustedPositions: {1, 4, 6}
+ *
+ * Clear ad at position 1
+ *   Item 0
+ *   Item 1
+ *   New Item
+ *   Ad
+ *   Item 3
+ *   Ad
+ *   Item 4
+ * desiredOriginalPositions: {1}
+ * desiredInsertionPositions: {1}
+ * originalPositions: {3, 4}
+ * adjustedPositions: {3, 5}
+ *
+ * Clear ad at position 5
+ *   Item 0
+ *   Item 1
+ *   New Item
+ *   Ad
+ *   Item 3
+ *   Item 4
+ * desiredOriginalPositions: {1, 4}
+ * desiredInsertionPositions: {1, 5}
+ * originalPositions: {3}
+ * adjustedPositions: {3}
+ *
+ * Some runtime guarantees in terms of number of insertion ads:
+ * - Finds the next or previous insertion position in O(logN)
+ * - Maps from adjusted to original positions and vice versa in O(logN)
+ * - Places an ad (moves positions from desired to placed) in O(N)
+ */
+class PlacementData {
+    /**
+     * Returned when positions are not found.
+     */
+    public final static int NOT_FOUND = -1;
+
+    // Cap the number of ads to avoid unrestrained memory usage. 200 allows the 5 positioning
+    // arrays to fit in less than 4K.
+    private final static int MAX_ADS = 200;
+
+    // Initialize all of these to their max capacity. This prevents garbage collection when
+    // reallocating the list, which causes noticeable stuttering when scrolling on some devices.
+    private final int[] mDesiredOriginalPositions = new int[MAX_ADS];
+    private final int[] mDesiredInsertionPositions = new int[MAX_ADS];
+    private int mDesiredCount = 0;
+    private final int[] mOriginalAdPositions = new int[MAX_ADS];
+    private final int[] mAdjustedAdPositions = new int[MAX_ADS];
+    private final NativeAdData[] mAdDataObjects = new NativeAdData[MAX_ADS];
+    private int mPlacedCount = 0;
+
+    /**
+     * @param desiredInsertionPositions Insertion positions, expressed as original positions
+     */
+    private PlacementData(final int[] desiredInsertionPositions) {
+        mDesiredCount = Math.min(desiredInsertionPositions.length, MAX_ADS);
+        System.arraycopy(desiredInsertionPositions, 0, mDesiredInsertionPositions, 0, mDesiredCount);
+        System.arraycopy(desiredInsertionPositions, 0, mDesiredOriginalPositions, 0, mDesiredCount);
+    }
+
+    static PlacementData fromAdPositioning(final MoPubNativeAdPositioning adPositioning) {
+        final List<Integer> fixed = adPositioning.getFixedPositions();
+        final int interval = adPositioning.getRepeatingInterval();
+
+        final int size = (interval == MoPubNativeAdPositioning.NO_REPEAT ? fixed.size() : MAX_ADS);
+        final int[] desiredInsertionPositions = new int[size];
+
+        // Fixed positions are in terms of final positions. Calculate current insertion positions
+        // by decrementing numAds at each index.
+        int numAds = 0;
+        int lastPos = 0;
+        for (final Integer position : fixed) {
+            lastPos = position - numAds;
+            desiredInsertionPositions[numAds++] = lastPos;
+        }
+
+        // Expand the repeating positions, if there are any
+        while (numAds < size) {
+            lastPos = lastPos + interval - 1;
+            desiredInsertionPositions[numAds++] = lastPos;
+        }
+        return new PlacementData(desiredInsertionPositions);
+    }
+
+    /**
+     * Whether the given position should be an ad.
+     */
+    boolean shouldPlaceAd(final int position) {
+        final int index = binarySearch(mDesiredInsertionPositions, 0, mDesiredCount, position);
+        return index >= 0;
+    }
+
+    /**
+     * The next position after this position that should be an ad. Returns NOT_FOUND if there are no
+     * more ads.
+     */
+    int nextInsertionPosition(final int position) {
+        final int index = binarySearchGreaterThan(
+                mDesiredInsertionPositions, mDesiredCount, position);
+        if (index == mDesiredCount) {
+            return NOT_FOUND;
+        }
+        return mDesiredInsertionPositions[index];
+    }
+
+    /**
+     * The next position after this position that should be an ad. Returns NOT_FOUND if there
+     * are no more ads.
+     */
+    int previousInsertionPosition(final int position) {
+        final int index = binarySearchFirstEquals(
+                mDesiredInsertionPositions,  mDesiredCount, position);
+        if (index == 0) {
+            return NOT_FOUND;
+        }
+        return mDesiredInsertionPositions[index - 1];
+    }
+
+    /**
+     * Sets ad data at the given position.
+     */
+    void placeAd(final int adjustedPosition, final NativeAdData adData) {
+        // See if this is a insertion ad
+        final int desiredIndex = binarySearchFirstEquals(
+                mDesiredInsertionPositions, mDesiredCount, adjustedPosition);
+        if (desiredIndex == mDesiredCount
+                || mDesiredInsertionPositions[desiredIndex] != adjustedPosition) {
+            MoPubLog.w("Attempted to insert an ad at an invalid position");
+            return;
+        }
+
+        // Add to placed array
+        final int originalPosition = mDesiredOriginalPositions[desiredIndex];
+        int placeIndex = binarySearchGreaterThan(
+                mOriginalAdPositions, mPlacedCount, originalPosition);
+        if (placeIndex < mPlacedCount) {
+            final int num = mPlacedCount - placeIndex;
+            System.arraycopy(mOriginalAdPositions, placeIndex,
+                    mOriginalAdPositions, placeIndex + 1, num);
+            System.arraycopy(mAdjustedAdPositions, placeIndex,
+                    mAdjustedAdPositions, placeIndex + 1, num);
+            System.arraycopy(mAdDataObjects, placeIndex, mAdDataObjects, placeIndex + 1, num);
+        }
+        mOriginalAdPositions[placeIndex] = originalPosition;
+        mAdjustedAdPositions[placeIndex] = adjustedPosition;
+        mAdDataObjects[placeIndex] = adData;
+        mPlacedCount++;
+
+        // Remove desired index
+        final int num = mDesiredCount - desiredIndex - 1;
+        System.arraycopy(mDesiredInsertionPositions, desiredIndex + 1,
+                mDesiredInsertionPositions, desiredIndex, num);
+        System.arraycopy(mDesiredOriginalPositions, desiredIndex + 1,
+                mDesiredOriginalPositions, desiredIndex, num);
+        mDesiredCount--;
+
+        // Increment adjusted positions
+        for (int i = desiredIndex; i < mDesiredCount; ++i) {
+            mDesiredInsertionPositions[i]++;
+        }
+        for (int i = placeIndex + 1; i < mPlacedCount; ++i) {
+            mAdjustedAdPositions[i]++;
+        }
+    }
+
+    /**
+     * @see {@link com.mopub.nativeads.MoPubStreamAdPlacer#isAd(int)}
+     */
+    boolean isPlacedAd(final int position) {
+        final int index = binarySearch(mAdjustedAdPositions, 0, mPlacedCount, position);
+        return index >= 0;
+    }
+
+    /**
+     * Returns the ad data associated with the given ad position, or {@code null} if there is
+     * no ad at this position.
+     */
+    NativeAdData getPlacedAd(final int position) {
+        final int index = binarySearch(mAdjustedAdPositions, 0, mPlacedCount, position);
+        if (index < 0) {
+            return null;
+        }
+        return mAdDataObjects[index];
+    }
+
+    /**
+     * Returns all placed ad positions. This method allocates new memory on every invocation. Do
+     * not call it from performance critical code.
+     */
+    int[] getPlacedAdPositions() {
+        int[] positions = new int[mPlacedCount];
+        System.arraycopy(mAdjustedAdPositions, 0, positions, 0, mPlacedCount);
+        return positions;
+    }
+
+    /**
+     * @see com.mopub.nativeads.MoPubStreamAdPlacer#getOriginalPosition(int)
+     */
+    int getOriginalPosition(final int position) {
+        final int index = binarySearch(mAdjustedAdPositions, 0, mPlacedCount, position);
+
+        // No match, ~index is the number of ads before this pos.
+        if (index < 0) {
+            return position - ~index;
+        }
+
+        // This is an ad - there is no original position
+        return NOT_FOUND;
+    }
+
+    /**
+     * @see com.mopub.nativeads.MoPubStreamAdPlacer#getAdjustedPosition(int)
+     */
+    int getAdjustedPosition(final int originalPosition) {
+        // This is an ad. Since binary search doesn't properly handle dups, find the first non-ad.
+        int index = binarySearchGreaterThan(mOriginalAdPositions, mPlacedCount, originalPosition);
+        return originalPosition + index;
+    }
+
+    /**
+     * @see com.mopub.nativeads.MoPubStreamAdPlacer#getOriginalCount(int)
+     */
+    int getOriginalCount(final int count) {
+        if (count == 0) {
+            return 0;
+        }
+
+        // The last item will never be an ad
+        final int originalPos = getOriginalPosition(count - 1);
+        return (originalPos == NOT_FOUND) ? NOT_FOUND : originalPos + 1;
+    }
+
+    /**
+     * @see com.mopub.nativeads.MoPubStreamAdPlacer#getAdjustedCount(int)
+     */
+    int getAdjustedCount(final int originalCount) {
+        if (originalCount == 0) {
+            return 0;
+        }
+        return getAdjustedPosition(originalCount - 1) + 1;
+    }
+
+    /**
+     * Clears the ads in the given range. After calling this method, the ad positions
+     * will be removed from the placed ad positions and put back into the desired ad insertion
+     * positions.
+     */
+    int clearAdsInRange(final int adjustedStartRange, final int adjustedEndRange) {
+        // Temporary arrays to store the cleared positions. Using temporary arrays makes it
+        // easy to debug what positions are being cleared.
+        int[] clearOriginalPositions = new int[mPlacedCount];
+        int[] clearAdjustedPositions = new int[mPlacedCount];
+        int clearCount = 0;
+
+        // Add to the clear position arrays any positions that fall inside
+        // [adjustedRangeStart, adjustedRangeEnd).
+        for (int i = 0; i < mPlacedCount; ++i) {
+            int originalPosition = mOriginalAdPositions[i];
+            int adjustedPosition = mAdjustedAdPositions[i];
+            if (adjustedStartRange <= adjustedPosition && adjustedPosition < adjustedEndRange) {
+                // When copying adjusted positions, subtract the current clear count because there
+                // is no longer an ad incrementing the desired insertion position.
+                clearOriginalPositions[clearCount] = originalPosition;
+                clearAdjustedPositions[clearCount] = adjustedPosition - clearCount;
+
+                // Destroying and nulling out the ad objects to avoids a memory leak.
+                mAdDataObjects[i].getAd().destroy();
+                mAdDataObjects[i] = null;
+                clearCount++;
+            } else if (clearCount > 0) {
+                // The position is not in the range; shift it by the number of cleared ads.
+                int newIndex = i - clearCount;
+                mOriginalAdPositions[newIndex] = originalPosition;
+                mAdjustedAdPositions[newIndex] = adjustedPosition - clearCount;
+                mAdDataObjects[newIndex] = mAdDataObjects[i];
+            }
+        }
+
+        // If we have cleared nothing, this method was a no-op.
+        if (clearCount == 0) {
+            return 0;
+        }
+
+        // Modify the desired positions arrays in order to make space to put back the
+        // cleared ad positions. For example if the desired array was {1, 10,
+        // 15} and we need to insert {3, 7} we'll shift the desired array to be {1, ?, ? , 10, 15}.
+        int firstCleared = clearAdjustedPositions[0];
+        int desiredIndex = binarySearchFirstEquals(
+                mDesiredInsertionPositions, mDesiredCount, firstCleared);
+        for (int i = mDesiredCount - 1; i >= desiredIndex; --i) {
+            mDesiredOriginalPositions[i + clearCount] = mDesiredOriginalPositions[i];
+            mDesiredInsertionPositions[i + clearCount] = mDesiredInsertionPositions[i] - clearCount;
+        }
+
+        // Copy the cleared ad positions into the desired arrays.
+        for (int i = 0; i < clearCount; ++i) {
+            mDesiredOriginalPositions[desiredIndex + i] = clearOriginalPositions[i];
+            mDesiredInsertionPositions[desiredIndex + i] = clearAdjustedPositions[i];
+        }
+
+        // Update the array counts, and we're done.
+        mDesiredCount = mDesiredCount + clearCount;
+        mPlacedCount = mPlacedCount - clearCount;
+        return clearCount;
+    }
+
+    /**
+     * Clears the ads in the given range. After calling this method the ad's position
+     * will be back to the desired insertion positions.
+     */
+    void clearAds() {
+        if (mPlacedCount == 0) {
+            return;
+        }
+
+        clearAdsInRange(0, mAdjustedAdPositions[mPlacedCount - 1] + 1);
+    }
+
+    /**
+     * @see com.mopub.nativeads.MoPubStreamAdPlacer#insertItem(int)
+     */
+    void insertItem(final int originalPosition) {
+
+        // Increment desired arrays.
+        int indexToIncrement = binarySearchFirstEquals(
+                mDesiredOriginalPositions, mDesiredCount, originalPosition);
+        for (int i = indexToIncrement; i < mDesiredCount; ++i) {
+            mDesiredOriginalPositions[i]++;
+            mDesiredInsertionPositions[i]++;
+        }
+
+        // Increment placed arrays.
+        indexToIncrement = binarySearchFirstEquals(
+                mOriginalAdPositions, mPlacedCount, originalPosition);
+        for (int i = indexToIncrement; i < mPlacedCount; ++i) {
+            mOriginalAdPositions[i]++;
+            mAdjustedAdPositions[i]++;
+        }
+    }
+
+    /**
+     * @see com.mopub.nativeads.MoPubStreamAdPlacer#removeItem(int)
+     */
+    void removeItem(final int originalPosition) {
+        // When removing items, we only decrement ad position values *greater* than the original
+        // position we're removing. The original position associated with an ad is the original
+        // position of the first content item after the ad, so we shouldn't change the original
+        // position of an ad that matches the original position removed.
+        int indexToDecrement = binarySearchGreaterThan(
+                mDesiredOriginalPositions, mDesiredCount, originalPosition);
+
+        // Decrement desired arrays.
+        for (int i = indexToDecrement; i < mDesiredCount; ++i) {
+            mDesiredOriginalPositions[i]--;
+            mDesiredInsertionPositions[i]--;
+        }
+
+        indexToDecrement = binarySearchGreaterThan(
+                mOriginalAdPositions, mPlacedCount, originalPosition);
+
+        for (int i = indexToDecrement; i < mPlacedCount; ++i) {
+            mOriginalAdPositions[i]--;
+            mAdjustedAdPositions[i]--;
+        }
+    }
+
+    /**
+     * @see com.mopub.nativeads.MoPubStreamAdPlacer#moveItem(int, int)
+     */
+    void moveItem(final int originalPosition, final int newPosition) {
+        removeItem(originalPosition);
+        insertItem(newPosition);
+    }
+
+    private static int binarySearchFirstEquals(int[] array, int count, int value) {
+        int index = binarySearch(array, 0, count, value);
+
+        // If not found, binarySearch returns the 2's complement of the index of the nearest
+        // value higher than the target value, which is also the insertion index.
+        if (index < 0) {
+            return ~index;
+        }
+
+        int duplicateValue = array[index];
+        while (index >= 0 && array[index] == duplicateValue) {
+            index--;
+        }
+
+        return index + 1;
+    }
+
+    private static int binarySearchGreaterThan(int[] array, int count, int value) {
+        int index = binarySearch(array, 0, count, value);
+
+        // If not found, binarySearch returns the 2's complement of the index of the nearest
+        // value higher than the target value, which is also the insertion index.
+        if (index < 0) {
+            return ~index;
+        }
+
+        int duplicateValue = array[index];
+        while (index < count && array[index] == duplicateValue) {
+            index++;
+        }
+
+        return index;
+    }
+
+    /**
+     * Copied from Arrays.java, which isn't available until Gingerbread.
+     */
+    private static int binarySearch(int[] array, int startIndex, int endIndex, int value) {
+        int lo = startIndex;
+        int hi = endIndex - 1;
+
+        while (lo <= hi) {
+            int mid = (lo + hi) >>> 1;
+            int midVal = array[mid];
+
+            if (midVal < value) {
+                lo = mid + 1;
+            } else if (midVal > value) {
+                hi = mid - 1;
+            } else {
+                return mid;  // value found
+            }
+        }
+        return ~lo;  // value not present
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ImageTaskManager.java b/mopub-sdk/src/main/java/com/mopub/nativeads/TaskManager.java
similarity index 68%
rename from mopub-sdk/src/main/java/com/mopub/nativeads/ImageTaskManager.java
rename to mopub-sdk/src/main/java/com/mopub/nativeads/TaskManager.java
index 8d399039..443a9875 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/ImageTaskManager.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/TaskManager.java
@@ -1,7 +1,5 @@
 package com.mopub.nativeads;
 
-import android.graphics.Bitmap;
-
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
@@ -9,20 +7,20 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
-abstract class ImageTaskManager {
-    protected final ImageTaskManagerListener mImageTaskManagerListener;
+abstract class TaskManager<T> {
+    protected final TaskManagerListener<T> mImageTaskManagerListener;
     protected final int mSize;
-    protected final Map<String, Bitmap> mImages;
+    protected final Map<String, T> mResults;
 
     protected final AtomicInteger mCompletedCount;
     protected final AtomicBoolean mFailed;
 
-    interface ImageTaskManagerListener {
-        void onSuccess(final Map<String, Bitmap> images);
+    interface TaskManagerListener<T> {
+        void onSuccess(final Map<String, T> images);
         void onFail();
     }
 
-    ImageTaskManager(final List<String> urls, final ImageTaskManagerListener imageTaskManagerListener)
+    TaskManager(final List<String> urls, final TaskManagerListener<T> imageTaskManagerListener)
             throws IllegalArgumentException {
         if (urls == null) {
             throw new IllegalArgumentException("Urls list cannot be null");
@@ -37,8 +35,9 @@
         mImageTaskManagerListener = imageTaskManagerListener;
         mCompletedCount = new AtomicInteger(0);
         mFailed = new AtomicBoolean(false);
-        mImages = Collections.synchronizedMap(new HashMap<String, Bitmap>(mSize));
+        mResults = Collections.synchronizedMap(new HashMap<String, T>(mSize));
     }
 
     abstract void execute();
 }
+
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/TimestampWrapper.java b/mopub-sdk/src/main/java/com/mopub/nativeads/TimestampWrapper.java
new file mode 100644
index 00000000..3bed271a
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/TimestampWrapper.java
@@ -0,0 +1,13 @@
+package com.mopub.nativeads;
+
+import android.os.SystemClock;
+
+class TimestampWrapper<T> {
+    final T mInstance;
+    long mCreatedTimestamp;
+
+    TimestampWrapper(final T instance) {
+        mInstance = instance;
+        mCreatedTimestamp = SystemClock.uptimeMillis();
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/VisibilityTracker.java b/mopub-sdk/src/main/java/com/mopub/nativeads/VisibilityTracker.java
new file mode 100644
index 00000000..6cbc3983
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/VisibilityTracker.java
@@ -0,0 +1,266 @@
+package com.mopub.nativeads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.graphics.Rect;
+import android.os.Handler;
+import android.os.SystemClock;
+import android.view.View;
+import android.view.ViewTreeObserver;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.util.MoPubLog;
+
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.WeakHashMap;
+
+import static android.view.ViewTreeObserver.OnPreDrawListener;
+
+/**
+ * Tracks views to determine when they become visible or invisible, where visibility is defined as
+ * having been at least X% on the screen.
+ */
+class VisibilityTracker {
+    // Time interval to use for throttling visibility checks.
+    private static final int VISIBILITY_THROTTLE_MILLIS = 100;
+
+    // Trim the tracked views after this many accesses. This protects us against tracking
+    // too many views if the developer uses the adapter for multiple ListViews. It also
+    // limits the memory leak if a developer forgets to call destroy().
+    @VisibleForTesting static final int NUM_ACCESSES_BEFORE_TRIMMING = 50;
+
+    // Temporary array of trimmed views so that we don't allocate this on every trim.
+    private final ArrayList<View> mTrimmedViews;
+
+    // Incrementing access counter. Use a long to support very long-lived apps.
+    private long mAccessCounter = 0;
+
+    // Listener that passes all visible and invisible views when a visibility check occurs
+    static interface VisibilityTrackerListener {
+        void onVisibilityChanged(List<View> visibleViews, List<View> invisibleViews);
+    }
+
+    @VisibleForTesting OnPreDrawListener mOnPreDrawListener;
+    @VisibleForTesting final WeakReference<View> mRootView;
+
+    static class TrackingInfo {
+        int mMinViewablePercent;
+        long mAccessOrder;
+    }
+
+    // Views that are being tracked, mapped to the min viewable percentage
+    private final Map<View, TrackingInfo> mTrackedViews;
+
+    // Object to check actual visibility
+    private final VisibilityChecker mVisibilityChecker;
+
+    // Callback listener
+    private VisibilityTrackerListener mVisibilityTrackerListener;
+
+    // Runnable to run on each visibility loop
+    private final VisibilityRunnable mVisibilityRunnable;
+
+    // Handler for visibility
+    private final Handler mVisibilityHandler;
+
+    // Whether the visibility runnable is scheduled
+    private boolean mIsVisibilityScheduled;
+
+    public VisibilityTracker(final Context context) {
+        this(context,
+                new WeakHashMap<View, TrackingInfo>(10),
+                new VisibilityChecker(),
+                new Handler());
+    }
+
+    @VisibleForTesting
+    VisibilityTracker(final Context context,
+            final Map<View, TrackingInfo> trackedViews,
+            final VisibilityChecker visibilityChecker,
+            final Handler visibilityHandler) {
+        mTrackedViews = trackedViews;
+        mVisibilityChecker = visibilityChecker;
+        mVisibilityHandler = visibilityHandler;
+        mVisibilityRunnable = new VisibilityRunnable();
+        mTrimmedViews = new ArrayList<View>(NUM_ACCESSES_BEFORE_TRIMMING);
+
+        final View rootView = ((Activity) context).getWindow().getDecorView();
+        mRootView = new WeakReference<View>(rootView);
+        final ViewTreeObserver viewTreeObserver = rootView.getViewTreeObserver();
+        if (!viewTreeObserver.isAlive()) {
+            MoPubLog.w("Visibility Tracker was unable to track views because the"
+                    + " root view tree observer was not alive");
+        } else {
+            mOnPreDrawListener = new OnPreDrawListener() {
+                @Override
+                public boolean onPreDraw() {
+                    scheduleVisibilityCheck();
+                    return true;
+                }
+            };
+            viewTreeObserver.addOnPreDrawListener(mOnPreDrawListener);
+        }
+    }
+
+    void setVisibilityTrackerListener(final VisibilityTrackerListener visibilityTrackerListener) {
+        mVisibilityTrackerListener = visibilityTrackerListener;
+    }
+
+    /**
+     * Tracks the given view for visibility.
+     */
+    void addView(final View view, final int minPercentageViewed) {
+        // Find the view if already tracked
+        TrackingInfo trackingInfo = mTrackedViews.get(view);
+        if (trackingInfo == null) {
+            trackingInfo = new TrackingInfo();
+            mTrackedViews.put(view, trackingInfo);
+            scheduleVisibilityCheck();
+        }
+        trackingInfo.mMinViewablePercent = minPercentageViewed;
+        trackingInfo.mAccessOrder = mAccessCounter;
+
+        // Trim the number of tracked views to a reasonable number
+        mAccessCounter++;
+        if (mAccessCounter % NUM_ACCESSES_BEFORE_TRIMMING == 0) {
+            trimTrackedViews(mAccessCounter - NUM_ACCESSES_BEFORE_TRIMMING);
+        }
+    }
+
+    private void trimTrackedViews(long minAccessOrder) {
+        // Clear anything that is below minAccessOrder.
+        for (final Map.Entry<View, TrackingInfo> entry : mTrackedViews.entrySet()) {
+            if (entry.getValue().mAccessOrder <  minAccessOrder) {
+                mTrimmedViews.add(entry.getKey());
+            }
+        }
+
+        for (View view : mTrimmedViews) {
+            removeView(view);
+        }
+        mTrimmedViews.clear();
+    }
+
+    /**
+     * Stops tracking a view, cleaning any pending tracking
+     */
+    void removeView(final View view) {
+        mTrackedViews.remove(view);
+    }
+
+    /**
+     * Immediately clear all views. Useful for when we re-request ads for an ad placer
+     */
+    void clear() {
+        mTrackedViews.clear();
+        mVisibilityHandler.removeMessages(0);
+        mIsVisibilityScheduled = false;
+    }
+
+    /**
+     * Destroy the visibility tracker, preventing it from future use.
+     */
+    void destroy() {
+        clear();
+        final View rootView = mRootView.get();
+        if (rootView != null && mOnPreDrawListener != null) {
+            final ViewTreeObserver viewTreeObserver = rootView.getViewTreeObserver();
+            if (viewTreeObserver.isAlive()) {
+                viewTreeObserver.removeOnPreDrawListener(mOnPreDrawListener);
+            }
+            mOnPreDrawListener = null;
+        }
+        mVisibilityTrackerListener = null;
+    }
+
+    void scheduleVisibilityCheck() {
+        // Tracking this directly instead of calling hasMessages directly because we measured that
+        // this led to slightly better performance.
+        if (mIsVisibilityScheduled) {
+            return;
+        }
+
+        mIsVisibilityScheduled = true;
+        mVisibilityHandler.postDelayed(mVisibilityRunnable, VISIBILITY_THROTTLE_MILLIS);
+    }
+
+    class VisibilityRunnable implements Runnable {
+        // Set of views that are visible or invisible. We create these once to avoid excessive
+        // garbage collection observed when calculating these on each pass.
+        private final ArrayList<View> mVisibleViews;
+        private final ArrayList<View> mInvisibleViews;
+
+        VisibilityRunnable() {
+            mInvisibleViews = new ArrayList<View>();
+            mVisibleViews = new ArrayList<View>();
+        }
+
+        @Override
+        public void run() {
+            mIsVisibilityScheduled = false;
+            for (final Map.Entry<View, TrackingInfo> entry : mTrackedViews.entrySet()) {
+                final View view = entry.getKey();
+                final int minPercentageViewed = entry.getValue().mMinViewablePercent;
+
+                if (mVisibilityChecker.isVisible(view, minPercentageViewed)) {
+                    mVisibleViews.add(view);
+                } else {
+                    mInvisibleViews.add(view);
+                }
+            }
+
+            if (mVisibilityTrackerListener != null) {
+                mVisibilityTrackerListener.onVisibilityChanged(mVisibleViews, mInvisibleViews);
+            }
+
+            // Clear these immediately so that we don't leak memory
+            mVisibleViews.clear();
+            mInvisibleViews.clear();
+        }
+    }
+
+    static class VisibilityChecker {
+        // A rect to use for hit testing. Create this once to avoid excess garbage collection
+        private final Rect mClipRect = new Rect();
+
+        /**
+         * Whether the visible time has elapsed from the start time. Easily mocked for testing.
+         */
+        boolean hasRequiredTimeElapsed(final long startTimeMillis, final int minTimeViewed) {
+            return SystemClock.uptimeMillis() - startTimeMillis >= minTimeViewed;
+        }
+
+        /**
+         * Whether the view is at least certain % visible
+         */
+        boolean isVisible(final View view, final int minPercentageViewed) {
+            // ListView & GridView both call detachFromParent() for views that can be recycled for
+            // new data. This is one of the rare instances where a view will have a null parent for
+            // an extended period of time and will not be the main window.
+            // view.getGlobalVisibleRect() doesn't check that case, so if the view has visibility
+            // of View.VISIBLE but has no parent it is likely in the recycle bin of a
+            // ListView / GridView and not on screen.
+            if (view == null || view.getVisibility() != View.VISIBLE || view.getParent() == null) {
+                return false;
+            }
+
+            if (!view.getGlobalVisibleRect(mClipRect)) {
+                // Not visible
+                return false;
+            }
+
+            // % visible check - the cast is to avoid int overflow for large views.
+            final long visibleViewArea = (long) mClipRect.height() * mClipRect.width();
+            final long totalViewArea = (long) view.getHeight() * view.getWidth();
+
+            if (totalViewArea <= 0) {
+                return false;
+            }
+
+            return 100 * visibleViewArea >= minPercentageViewed * totalViewArea;
+        }
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/CacheServiceTest.java b/mopub-sdk/src/test/java/com/mopub/common/CacheServiceTest.java
index b2317b89..3fca2044 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/CacheServiceTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/CacheServiceTest.java
@@ -1,6 +1,7 @@
 package com.mopub.common;
 
 import android.app.Activity;
+import android.graphics.Bitmap;
 import android.support.v4.util.LruCache;
 
 import com.mopub.nativeads.test.support.SdkTestRunner;
@@ -67,15 +68,15 @@ public void tearDown() throws Exception {
     public void initializeCaches_withValidContext_shouldCreateNewCachesIdempotently() throws Exception {
         assertThat(CacheService.getDiskLruCache()).isNull();
 
-        CacheService.initializeCaches(context);
+        CacheService.initialize(context);
         DiskLruCache diskLruCache = CacheService.getDiskLruCache();
         assertThat(diskLruCache).isNotNull();
-        LruCache<String, byte[]> memoryLruCache = CacheService.getMemoryLruCache();
+        LruCache<String, Bitmap> memoryLruCache = CacheService.getBitmapLruCache();
         assertThat(memoryLruCache).isNotNull();
 
-        CacheService.initializeCaches(context);
+        CacheService.initialize(context);
         assertThat(diskLruCache).isEqualTo(CacheService.getDiskLruCache());
-        assertThat(memoryLruCache).isEqualTo(CacheService.getMemoryLruCache());
+        assertThat(memoryLruCache).isEqualTo(CacheService.getBitmapLruCache());
     }
     
     @Test
@@ -87,21 +88,21 @@ public void getDiskLruCacheDirectory_shouldReturnValidCacheDirectory() throws Ex
 
     @Test
     public void diskLruCacheGet_whenPopulated_shouldReturnValue() throws Exception {
-        CacheService.initializeCaches(context);
+        CacheService.initialize(context);
         CacheService.putToDiskCache(key1, data1.getBytes());
         assertThat(CacheService.getFromDiskCache(key1)).isEqualTo(data1.getBytes());
     }
 
     @Test
     public void diskLruCacheGet_whenEmpty_shouldReturnNull() throws Exception {
-        CacheService.initializeCaches(context);
+        CacheService.initialize(context);
         assertCachesAreEmpty();
         assertThat(CacheService.getFromDiskCache(key1)).isNull();
     }
 
     @Test
     public void diskLruCacheAsyncGet_whenPopulated_shouldReturnValue() throws Exception {
-        CacheService.initializeCaches(context);
+        CacheService.initialize(context);
         assertCachesAreEmpty();
         CacheService.putToDiskCache(key1, data1.getBytes());
         CacheService.getFromDiskCacheAsync(key1, diskCacheGetListener);
@@ -112,7 +113,7 @@ public void diskLruCacheAsyncGet_whenPopulated_shouldReturnValue() throws Except
 
     @Test
     public void diskLruCacheAsyncGet_whenEmpty_shouldReturnNull() throws Exception {
-        CacheService.initializeCaches(context);
+        CacheService.initialize(context);
         CacheService.getFromDiskCacheAsync(key1, diskCacheGetListener);
         semaphore.acquire();
         assertThat(getKey).isEqualTo(key1);
@@ -122,7 +123,7 @@ public void diskLruCacheAsyncGet_whenEmpty_shouldReturnNull() throws Exception {
     @Test
     public void diskLruCachePut_withEmptyStringKey_shouldPutCorrectly() throws Exception {
         // this works because an empty string sha1 hashes to a valid key
-        CacheService.initializeCaches(context);
+        CacheService.initialize(context);
         CacheService.putToDiskCache("", data1.getBytes());
         assertThat(CacheService.getFromDiskCache("")).isEqualTo(data1.getBytes());
     }
@@ -130,7 +131,7 @@ public void diskLruCachePut_withEmptyStringKey_shouldPutCorrectly() throws Excep
     @Test
     public void diskLruCachePut_withNullKey_shouldNotPut() throws Exception {
         // null value produces empty string key which is invalid for disk lru cache
-        CacheService.initializeCaches(context);
+        CacheService.initialize(context);
         assertCachesAreEmpty();
         CacheService.putToDiskCache(null, data1.getBytes());
         assertCachesAreEmpty();
@@ -138,13 +139,13 @@ public void diskLruCachePut_withNullKey_shouldNotPut() throws Exception {
 
     @Test
     public void createValidDiskLruCacheKey_withNullValue_shouldReturnEmptyString() throws Exception {
-        CacheService.initializeCaches(context);
+        CacheService.initialize(context);
         assertThat(CacheService.createValidDiskCacheKey(null)).isEqualTo("");
     }
 
     @Test
     public void diskLruCacheAsyncPut_whenEmpty_shouldReturnNull() throws Exception {
-        CacheService.initializeCaches(context);
+        CacheService.initialize(context);
         CacheService.putToDiskCacheAsync(key1, data1.getBytes());
         Thread.sleep(500);
         assertThat(CacheService.getFromDiskCache(key1)).isEqualTo(data1.getBytes());
@@ -164,8 +165,8 @@ public static void assertDiskCacheIsEmpty() {
     }
 
     public static void assertCachesAreEmpty() {
-        assertThat(CacheService.getMemoryLruCache()).isNotNull();
-        assertThat(CacheService.getMemoryLruCache().size()).isEqualTo(0);
+        assertThat(CacheService.getBitmapLruCache()).isNotNull();
+        assertThat(CacheService.getBitmapLruCache().size()).isEqualTo(0);
         assertDiskCacheIsEmpty();
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/common/HttpResponsesTest.java b/mopub-sdk/src/test/java/com/mopub/common/HttpResponsesTest.java
index 17bd22d4..814bcf55 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/HttpResponsesTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/HttpResponsesTest.java
@@ -36,13 +36,6 @@ public void asBitmap_shouldReturnBitmap() throws Exception {
         assertThat(shadowOf(bitmap).getCreatedFromBytes()).isEqualTo(imageData.getBytes());
     }
 
-    @Test
-    public void asBitmap_withNullResponse_shouldReturnNull() throws Exception {
-        final Bitmap bitmap = HttpResponses.asBitmap(null);
-
-        assertThat(bitmap).isNull();
-    }
-
     @Test
     public void asJsonObject_withEmptyJsonString_shouldReturnEmptyJsonObjectAndCloseStream() throws Exception {
         String jsonData = "{}";
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/ReflectionTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/ReflectionTest.java
index 78f7dac2..1cc99438 100644
--- a/mopub-sdk/src/test/java/com/mopub/common/util/ReflectionTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/ReflectionTest.java
@@ -40,7 +40,7 @@
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 
-import static com.mopub.common.util.Reflection.*;
+import static com.mopub.common.util.Reflection.MethodBuilder;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.fest.assertions.api.Assertions.fail;
 
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/VisibilityTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/VisibilityTest.java
new file mode 100644
index 00000000..891f72ad
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/VisibilityTest.java
@@ -0,0 +1,41 @@
+package com.mopub.common.util;
+
+import android.view.View;
+
+import com.mopub.nativeads.test.support.SdkTestRunner;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+public class VisibilityTest {
+    @Test
+    public void isScreenVisible_shouldOnlyReturnTrueForViewVisible() throws Exception {
+        assertThat(Visibility.isScreenVisible(View.VISIBLE)).isTrue();
+        assertThat(Visibility.isScreenVisible(View.INVISIBLE)).isFalse();
+        assertThat(Visibility.isScreenVisible(View.GONE)).isFalse();
+    }
+    
+    @Test
+    public void hasScreenVisibilityChanged_withIdenticalArguments_shouldReturnFalse() throws Exception {
+        assertThat(Visibility.hasScreenVisibilityChanged(View.VISIBLE, View.VISIBLE)).isFalse();
+        assertThat(Visibility.hasScreenVisibilityChanged(View.INVISIBLE, View.INVISIBLE)).isFalse();
+        assertThat(Visibility.hasScreenVisibilityChanged(View.GONE, View.GONE)).isFalse();
+    }
+
+    @Test
+    public void hasScreenVisibilityChanged_withTwoNonVisibleArguments_shouldReturnFalse() throws Exception {
+        assertThat(Visibility.hasScreenVisibilityChanged(View.INVISIBLE, View.GONE)).isFalse();
+        assertThat(Visibility.hasScreenVisibilityChanged(View.GONE, View.INVISIBLE)).isFalse();
+    }
+
+    @Test
+    public void hasScreenVisibilityChanged_withDifferentVisibilities_shouldReturnTrue() throws Exception {
+        assertThat(Visibility.hasScreenVisibilityChanged(View.VISIBLE, View.GONE)).isTrue();
+        assertThat(Visibility.hasScreenVisibilityChanged(View.GONE, View.VISIBLE)).isTrue();
+        assertThat(Visibility.hasScreenVisibilityChanged(View.VISIBLE, View.INVISIBLE)).isTrue();
+        assertThat(Visibility.hasScreenVisibilityChanged(View.INVISIBLE, View.VISIBLE)).isTrue();
+    }
+}
\ No newline at end of file
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertReporterTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertReporterTest.java
index e78a6989..5b395c06 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertReporterTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertReporterTest.java
@@ -39,16 +39,20 @@
 import android.net.Uri;
 import android.view.View;
 import android.widget.TextView;
-import com.mopub.mobileads.test.support.SdkTestRunner;
+
 import com.mopub.common.util.test.support.TestDateAndTime;
+import com.mopub.mobileads.test.support.SdkTestRunner;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 
-import java.io.*;
+import java.io.File;
+import java.io.FileOutputStream;
 import java.text.SimpleDateFormat;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Date;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdViewControllerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdViewControllerTest.java
index a0f7bbfd..7acf9350 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/AdViewControllerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/AdViewControllerTest.java
@@ -536,7 +536,7 @@ public void run() {
                 subject.setAdContentView(view);
             }
         }).start();
-        ThreadUtils.pause(10);
+        ThreadUtils.pause(100);
         Robolectric.runUiThreadTasks();
 
         verify(moPubView).removeAllViews();
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventBannerAdapterTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventBannerAdapterTest.java
index 0d6b1986..178738ee 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventBannerAdapterTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventBannerAdapterTest.java
@@ -36,8 +36,10 @@
 import android.content.Context;
 import android.location.Location;
 import android.view.View;
+
 import com.mopub.mobileads.factories.CustomEventBannerFactory;
 import com.mopub.mobileads.test.support.SdkTestRunner;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -45,7 +47,8 @@
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
 
-import java.util.*;
+import java.util.HashMap;
+import java.util.Map;
 
 import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
 import static com.mopub.mobileads.CustomEventBanner.CustomEventBannerListener;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventInterstitialAdapterTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventInterstitialAdapterTest.java
index c458e4ba..4e84f8b0 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventInterstitialAdapterTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/CustomEventInterstitialAdapterTest.java
@@ -34,8 +34,10 @@
 
 import android.content.Context;
 import android.location.Location;
+
 import com.mopub.mobileads.factories.CustomEventInterstitialFactory;
 import com.mopub.mobileads.test.support.SdkTestRunner;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -43,10 +45,12 @@
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
 
-import java.util.*;
+import java.util.HashMap;
+import java.util.Map;
 
 import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
 import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR;
+import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_TIMEOUT;
 import static com.mopub.mobileads.MoPubErrorCode.UNSPECIFIED;
 import static org.fest.assertions.api.Assertions.assertThat;
@@ -92,6 +96,15 @@ public void setUp() throws Exception {
         subject.setAdapterListener(interstitialAdapterListener);
     }
 
+    @Test
+    public void constructor_withInvalidClassName_shouldCallOnCustomEventInterstitialFailed() throws Exception {
+        // Remove testing mock and use the real thing
+        CustomEventInterstitialFactory.setInstance(new CustomEventInterstitialFactory());
+
+        new CustomEventInterstitialAdapter(moPubInterstitial, "bad_class_name_11i234jb", null);
+        verify(moPubInterstitial).onCustomEventInterstitialFailed(ADAPTER_NOT_FOUND);
+    }
+
     @Test
     public void timeout_shouldSignalFailureAndInvalidateWithDefaultDelay() throws Exception {
         subject.loadInterstitial();
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/EventForwardingBroadcastReceiverTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/EventForwardingBroadcastReceiverTest.java
index cc8d91e4..72a4c4b1 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/EventForwardingBroadcastReceiverTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/EventForwardingBroadcastReceiverTest.java
@@ -40,7 +40,6 @@
 import com.mopub.mobileads.factories.CustomEventInterstitialAdapterFactory;
 import com.mopub.mobileads.test.support.SdkTestRunner;
 
-import org.fest.util.Lists;
 import org.fest.util.Sets;
 import org.junit.Before;
 import org.junit.Ignore;
@@ -48,7 +47,6 @@
 import org.junit.runner.RunWith;
 import org.robolectric.shadows.ShadowLocalBroadcastManager;
 
-import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.Set;
 
@@ -62,7 +60,6 @@
 import static com.mopub.mobileads.MoPubInterstitial.InterstitialAdListener;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/FacebookKeywordProviderTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/FacebookKeywordProviderTest.java
deleted file mode 100644
index d2fdfc4f..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/FacebookKeywordProviderTest.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright (c) 2010-2013, MoPub Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *  Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- *  Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- *  Neither the name of 'MoPub Inc.' nor the names of its contributors
- *   may be used to endorse or promote products derived from this software
- *   without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package com.mopub.mobileads;
-
-import android.content.ContentResolver;
-import android.content.Context;
-import android.database.Cursor;
-import android.net.Uri;
-import com.mopub.mobileads.test.support.SdkTestRunner;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.stub;
-import static org.mockito.Mockito.verify;
-
-@RunWith(SdkTestRunner.class)
-public class FacebookKeywordProviderTest {
-
-    private Context context;
-    private ContentResolver contentResolver;
-    private Cursor cursor;
-    private FacebookKeywordProvider subject;
-
-    @Before
-    public void setUp() throws Exception {
-        subject = new FacebookKeywordProvider();
-        context = mock(Context.class);
-        contentResolver = mock(ContentResolver.class);
-        cursor = mock(Cursor.class);
-
-        stub(context.getContentResolver()).toReturn(contentResolver);
-        stub(contentResolver.query(
-                any(Uri.class),
-                any(String[].class),
-                anyString(),
-                any(String[].class),
-                anyString())).toReturn(cursor);
-    }
-
-    @Test
-    public void getKeyword_shouldCloseCursor() throws Exception {
-        subject.getKeyword(context);
-
-        verify(cursor).close();
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlInterstitialTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlInterstitialTest.java
index cd5da469..5b63655a 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlInterstitialTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlInterstitialTest.java
@@ -91,6 +91,7 @@ public void setUp() throws Exception {
         localExtras.put(AD_CONFIGURATION_KEY, adConfiguration);
     }
 
+    // FIXME
     @Test
     public void loadInterstitial_shouldNotifyCustomEventInterstitialListenerOnLoaded() throws Exception {
         subject.loadInterstitial(context, customEventInterstitialListener, localExtras, serverExtras);
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlWebViewClientTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlWebViewClientTest.java
index 5cb2fdc1..d601450f 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlWebViewClientTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlWebViewClientTest.java
@@ -42,6 +42,7 @@
 
 import com.mopub.common.MoPubBrowser;
 import com.mopub.mobileads.test.support.SdkTestRunner;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubActivityTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubActivityTest.java
index f5dbe9c2..d5e5de4d 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubActivityTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubActivityTest.java
@@ -50,7 +50,6 @@
 import org.robolectric.Robolectric;
 import org.robolectric.shadows.ShadowLocalBroadcastManager;
 
-import static android.widget.RelativeLayout.LayoutParams;
 import static com.mopub.mobileads.AdFetcher.CLICKTHROUGH_URL_KEY;
 import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
 import static com.mopub.mobileads.AdFetcher.REDIRECT_URL_KEY;
@@ -169,9 +168,8 @@ public void onCreate_shouldLayoutWebView() throws Exception {
         verify(htmlInterstitialWebView).setLayoutParams(captor.capture());
         RelativeLayout.LayoutParams actualLayoutParams = captor.getValue();
 
-        assertThat(actualLayoutParams.width).isEqualTo(RelativeLayout.LayoutParams.FILL_PARENT);
-        assertThat(actualLayoutParams.height).isEqualTo(RelativeLayout.LayoutParams.WRAP_CONTENT);
-        assertOnlyOneRuleSet(actualLayoutParams, RelativeLayout.CENTER_IN_PARENT);
+        assertThat(actualLayoutParams.width).isEqualTo(RelativeLayout.LayoutParams.MATCH_PARENT);
+        assertThat(actualLayoutParams.height).isEqualTo(RelativeLayout.LayoutParams.MATCH_PARENT);
     }
 
     @Test
@@ -292,17 +290,5 @@ public void broadcastingInterstitialListener_onInterstitialClicked_shouldBroadca
     private Intent createMoPubActivityIntent(String htmlData, boolean isScrollable, String redirectUrl, String clickthroughUrl, AdConfiguration adConfiguration) {
         return MoPubActivity.createIntent(new Activity(), htmlData, isScrollable, redirectUrl, clickthroughUrl, adConfiguration);
     }
-
-    private void assertOnlyOneRuleSet(LayoutParams layoutParams, int desiredRule) {
-        int[] rules = layoutParams.getRules();
-        for (int ruleIndex = 0; ruleIndex < rules.length; ruleIndex++) {
-            int currentRule = rules[ruleIndex];
-            if (ruleIndex == desiredRule) {
-                assertThat(currentRule).isNotEqualTo(0);
-            } else {
-                assertThat(currentRule).isEqualTo(0);
-            }
-        }
-    }
 }
 
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubInterstitialTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubInterstitialTest.java
index b92eb9ed..7fa52287 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubInterstitialTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubInterstitialTest.java
@@ -36,21 +36,23 @@
 
 import com.mopub.mobileads.test.support.TestAdViewControllerFactory;
 import com.mopub.mobileads.test.support.TestCustomEventInterstitialAdapterFactory;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
 import java.math.BigDecimal;
-import java.util.*;
+import java.util.HashMap;
+import java.util.Map;
 
-import static com.mopub.common.LocationService.*;
+import static com.mopub.common.LocationService.LocationAwareness;
+import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_DATA;
+import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_HTML_DATA;
+import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_NAME;
 import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
 import static com.mopub.mobileads.MoPubErrorCode.CANCELLED;
 import static com.mopub.mobileads.MoPubErrorCode.INTERNAL_ERROR;
 import static com.mopub.mobileads.MoPubErrorCode.UNSPECIFIED;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_DATA;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_HTML_DATA;
-import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_NAME;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubViewTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubViewTest.java
index 83ce806a..5f14615c 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubViewTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubViewTest.java
@@ -33,28 +33,28 @@
 package com.mopub.mobileads;
 
 import android.app.Activity;
-import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
-import android.support.v4.content.LocalBroadcastManager;
 import android.view.View;
 
 import com.mopub.mobileads.test.support.SdkTestRunner;
 import com.mopub.mobileads.test.support.TestAdViewControllerFactory;
 import com.mopub.mobileads.test.support.TestCustomEventBannerAdapterFactory;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.shadows.ShadowApplication;
-import org.robolectric.shadows.ShadowLocalBroadcastManager;
 
-import java.util.*;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
 
-import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
 import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_DATA;
 import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_HTML_DATA;
 import static com.mopub.common.util.ResponseHeader.CUSTOM_EVENT_NAME;
+import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.never;
@@ -132,17 +132,55 @@ public void screenStateBroadcastReceiver_afterOnDestroy_shouldDoNothing() throws
     }
 
     @Test
-    public void onWindowVisibilityChanged_toVisible_shouldUnpauseRefresh() throws Exception {
+    public void onWindowVisibilityChanged_fromVisibleToInvisible_shouldPauseRefresh() throws Exception {
+        // Default visibility is View.VISIBLE
+        subject.onWindowVisibilityChanged(View.INVISIBLE);
+
+        verify(adViewController).pauseRefresh();
+        verify(adViewController, never()).unpauseRefresh();
+    }
+
+
+    @Test
+    public void onWindowVisibilityChanged_fromInvisibleToVisible_shouldUnpauseRefresh() throws Exception {
+        subject.onWindowVisibilityChanged(View.INVISIBLE);
+        reset(adViewController);
+
         subject.onWindowVisibilityChanged(View.VISIBLE);
 
+        verify(adViewController, never()).pauseRefresh();
         verify(adViewController).unpauseRefresh();
     }
 
     @Test
-    public void onWindowVisibilityChanged_toInvisible_shouldPauseRefresh() throws Exception {
+    public void onWindowVisibilityChanged_fromVisibleToVisible_shouldDoNothing() throws Exception {
+        // Default visibility is View.VISIBLE
+        subject.onWindowVisibilityChanged(View.VISIBLE);
+
+        verify(adViewController, never()).pauseRefresh();
+        verify(adViewController, never()).unpauseRefresh();
+    }
+
+    @Test
+    public void onWindowVisibilityChanged_fromInvisibleToGone_shouldDoNothing() throws Exception {
         subject.onWindowVisibilityChanged(View.INVISIBLE);
+        reset(adViewController);
 
-        verify(adViewController).pauseRefresh();
+        subject.onWindowVisibilityChanged(View.GONE);
+
+        verify(adViewController, never()).pauseRefresh();
+        verify(adViewController, never()).unpauseRefresh();
+    }
+
+    @Test
+    public void onWindowVisibilityChanged_fromGoneToInvisible_shouldDoNothing() throws Exception {
+        subject.onWindowVisibilityChanged(View.GONE);
+        reset(adViewController);
+
+        subject.onWindowVisibilityChanged(View.INVISIBLE);
+
+        verify(adViewController, never()).pauseRefresh();
+        verify(adViewController, never()).unpauseRefresh();
     }
 
     @Test
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidActivityTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidActivityTest.java
index 1cc01d41..3e008422 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidActivityTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidActivityTest.java
@@ -175,6 +175,18 @@ public void onCreate_shouldSetupAnMraidView() throws Exception {
         verify(mraidView).loadHtmlData(EXPECTED_SOURCE);
     }
 
+    @Test
+    public void onCreate_shouldSetLayoutOfMraidView() throws Exception {
+        subject.onCreate(null);
+
+        ArgumentCaptor<RelativeLayout.LayoutParams> captor = ArgumentCaptor.forClass(RelativeLayout.LayoutParams.class);
+        verify(mraidView).setLayoutParams(captor.capture());
+        RelativeLayout.LayoutParams actualLayoutParams = captor.getValue();
+
+        assertThat(actualLayoutParams.width).isEqualTo(RelativeLayout.LayoutParams.MATCH_PARENT);
+        assertThat(actualLayoutParams.height).isEqualTo(RelativeLayout.LayoutParams.MATCH_PARENT);
+    }
+
     @Test
     public void onCreate_shouldAddCloseEventRegion() throws Exception {
         subject.onCreate(null);
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandTest.java
index 6dee186f..69658afd 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidCommandTest.java
@@ -34,7 +34,7 @@
 
 import org.junit.Test;
 
-import java.util.*;
+import java.util.Map;
 
 import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.CLOSE;
 import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.CREATE_CALENDAR_EVENT;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidInterstitialTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidInterstitialTest.java
index 56be2be0..1a72d470 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidInterstitialTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidInterstitialTest.java
@@ -94,6 +94,7 @@ public void loadInterstitial_withMalformedServerExtras_shouldNotifyInterstitialF
         verify(customEventInterstitialListener, never()).onInterstitialLoaded();
     }
 
+    // FIXME
     @Test
     public void loadInterstitial_shouldNotifyInterstitialLoaded() throws Exception {
         subject.loadInterstitial(context, customEventInterstitialListener, localExtras, serverExtras);
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/BaseForwardingNativeAdTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/BaseForwardingNativeAdTest.java
index cadf1625..488f2eb6 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/BaseForwardingNativeAdTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/BaseForwardingNativeAdTest.java
@@ -2,7 +2,6 @@
 
 import com.mopub.nativeads.test.support.SdkTestRunner;
 
-import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -19,11 +18,6 @@ public void setUp() throws Exception {
         subject = new BaseForwardingNativeAd() {};
     }
 
-    @After
-    public void tearDown() throws Exception {
-        ImpressionTrackingManager.clearTracking();
-    }
-
     @Test
     public void constructor_shouldInitializeMembers() throws Exception {
         assertThat(subject.getImpressionMinPercentageViewed()).isEqualTo(50);
@@ -46,7 +40,7 @@ public void setImpressionMinTimeViewed_whenTimeIsLessThan0_shouldNotSetTime() th
         subject.setImpressionMinTimeViewed(-1);
         assertThat(subject.getImpressionMinTimeViewed()).isEqualTo(250);
     }
-    
+
     @Test
     public void setStarRating_withinValidRange_shouldSetStarRating() throws Exception {
         subject.setStarRating(0.0);
@@ -84,7 +78,7 @@ public void setStarRating_withNanOrInf_shouldNotSetStarRating() throws Exception
         subject.setStarRating(Double.NEGATIVE_INFINITY);
         assertThat(subject.getStarRating()).isEqualTo(initialStarRating);
     }
-    
+
     @Test
     public void setStarRating_withValuesOutsideOfValidRange_shouldNotSetStarRating() throws Exception {
         // First, set star rating to a valid value
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/ImageDiskTaskManagerTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/ImageDiskTaskManagerTest.java
index 030f41b8..0067ae13 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/ImageDiskTaskManagerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/ImageDiskTaskManagerTest.java
@@ -12,6 +12,7 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
@@ -22,18 +23,16 @@
 import java.util.Map;
 import java.util.concurrent.Semaphore;
 
-import static com.mopub.nativeads.ImageTaskManager.ImageTaskManagerListener;
+import static com.mopub.nativeads.TaskManager.TaskManagerListener;
 import static junit.framework.Assert.fail;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.anyMap;
 import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(SdkTestRunner.class)
 public class ImageDiskTaskManagerTest {
 
-    private ImageTaskManagerListener imageTaskManagerListener;
+    @Mock private TaskManagerListener<Bitmap> imageTaskManagerListener;
     private Semaphore semaphore;
     private Map<String, Bitmap> bitmaps;
     private FakeHttpLayer fakeHttpLayer;
@@ -45,12 +44,12 @@
     private String imageData3;
     private List<String> list;
     private Context context;
+    private static final int TEST_WIDTH = 400;
 
     @Before
     public void setUp() throws Exception {
         context = new Activity();
         semaphore = new Semaphore(0);
-        imageTaskManagerListener = mock(ImageTaskManagerListener.class);
         doAnswer(new Answer() {
             @Override
             public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
@@ -90,7 +89,7 @@ public void tearDown() throws Exception {
     @Test
     public void constructor_withNullUrlsList_shouldThrowIllegalArgumentException() throws Exception {
         try {
-            new ImageDiskTaskManager(null, imageTaskManagerListener);
+            new ImageDiskTaskManager(null, imageTaskManagerListener, TEST_WIDTH);
             fail("Should have thrown IllegalArgumentException");
         } catch (IllegalArgumentException e) {
             // pass
@@ -102,7 +101,7 @@ public void constructor_withNullInUrlsList_shouldThrowIllegalArgumentException()
         List<String> myList = new ArrayList<String>();
         myList.add(null);
         try {
-            new ImageDiskTaskManager(myList, imageTaskManagerListener);
+            new ImageDiskTaskManager(myList, imageTaskManagerListener, TEST_WIDTH);
             fail("Should have thrown IllegalArgumentException");
         } catch (IllegalArgumentException e) {
             // pass
@@ -112,7 +111,7 @@ public void constructor_withNullInUrlsList_shouldThrowIllegalArgumentException()
     @Test
     public void constructor_withNullImageTaskManagerListener_shouldThrowIllegalArgumentException() throws Exception {
         try {
-            new ImageDiskTaskManager(list, null);
+            new ImageDiskTaskManager(list, null, TEST_WIDTH);
             fail("Should have thrown IllegalArgumentException");
         } catch (IllegalArgumentException e) {
             // pass
@@ -121,7 +120,7 @@ public void constructor_withNullImageTaskManagerListener_shouldThrowIllegalArgum
 
     @Test
     public void execute_withEmptyDiskCache_shouldReturnNullsInMap() throws Exception {
-        new ImageDiskTaskManager(list, imageTaskManagerListener).execute();
+        new ImageDiskTaskManager(list, imageTaskManagerListener, TEST_WIDTH).execute();
         semaphore.acquire();
 
         assertThat(bitmaps.size()).isEqualTo(2);
@@ -133,30 +132,30 @@ public void execute_withEmptyDiskCache_shouldReturnNullsInMap() throws Exception
 
     @Test
     public void execute_withPopulatedDiskCache_shouldReturnImagesInMap() throws Exception {
-        CacheService.initializeCaches(context);
+        CacheService.initialize(context);
         CacheServiceTest.assertCachesAreEmpty();
         CacheService.putToDiskCache(url1, imageData1.getBytes());
         CacheService.putToDiskCache(url2, imageData2.getBytes());
 
-        new ImageDiskTaskManager(list, imageTaskManagerListener).execute();
+        new ImageDiskTaskManager(list, imageTaskManagerListener, TEST_WIDTH).execute();
         semaphore.acquire();
 
         assertThat(bitmaps.size()).isEqualTo(2);
-        assertThat(shadowOf(bitmaps.get(url1)).getCreatedFromBytes()).isEqualTo(imageData1.getBytes());
-        assertThat(shadowOf(bitmaps.get(url2)).getCreatedFromBytes()).isEqualTo(imageData2.getBytes());
+        assertThat(bitmaps.get(url1)).isNotNull();
+        assertThat(bitmaps.get(url2)).isNotNull();
     }
 
     @Test
     public void execute_withPartiallyPopulatedDiskCache_shouldReturnSomeImagesInMap() throws Exception {
-        CacheService.initializeCaches(context);
+        CacheService.initialize(context);
         CacheServiceTest.assertCachesAreEmpty();
         CacheService.putToDiskCache(url1, imageData1.getBytes());
 
-        new ImageDiskTaskManager(list, imageTaskManagerListener).execute();
+        new ImageDiskTaskManager(list, imageTaskManagerListener, TEST_WIDTH).execute();
         semaphore.acquire();
 
         assertThat(bitmaps.size()).isEqualTo(2);
-        assertThat(shadowOf(bitmaps.get(url1)).getCreatedFromBytes()).isEqualTo(imageData1.getBytes());
+        assertThat(bitmaps.get(url1)).isNotNull();
         assertThat(bitmaps.containsKey(url2)).isTrue();
         assertThat(bitmaps.get(url2)).isNull();
     }
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/ImageDownloadTaskManagerTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/ImageDownloadTaskManagerTest.java
index 3c6734f8..eb5862b7 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/ImageDownloadTaskManagerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/ImageDownloadTaskManagerTest.java
@@ -1,7 +1,6 @@
 package com.mopub.nativeads;
 
-import android.graphics.Bitmap;
-
+import com.mopub.common.DownloadResponse;
 import com.mopub.nativeads.test.support.SdkTestRunner;
 
 import org.apache.http.HttpEntity;
@@ -11,6 +10,7 @@
 import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
@@ -23,6 +23,7 @@
 import java.util.Map;
 import java.util.concurrent.Semaphore;
 
+import static com.mopub.nativeads.TaskManager.TaskManagerListener;
 import static junit.framework.Assert.fail;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.anyMap;
@@ -31,15 +32,15 @@
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
-import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(SdkTestRunner.class)
 public class ImageDownloadTaskManagerTest {
 
     private ImageDownloadTaskManager subject;
-    private ImageDownloadTaskManager.ImageTaskManagerListener mMockImageTaskManagerListener;
+    @Mock private TaskManagerListener<DownloadResponse> mMockImageTaskManagerListener;
     private Semaphore semaphore;
-    private Map<String, Bitmap> networkImages;
+    private Map<String, DownloadResponse> networkImages;
+    private int testMaxWidth;
     private FakeHttpLayer fakeHttpLayer;
     private String url1;
     private String url2;
@@ -47,12 +48,11 @@
     @Before
     public void setUp() throws Exception {
         semaphore = new Semaphore(0);
-        mMockImageTaskManagerListener = mock(ImageDownloadTaskManager.ImageTaskManagerListener.class);
         doAnswer(new Answer() {
             @Override
             public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
                 Object[] args = invocationOnMock.getArguments();
-                Map<String, Bitmap> map = (Map)args[0];
+                Map<String, DownloadResponse> map = (Map)args[0];
                 ImageDownloadTaskManagerTest.this.networkImages = map;
                 semaphore.release();
                 return null;
@@ -65,6 +65,7 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
                 return null;
             }
         }).when(mMockImageTaskManagerListener).onFail();
+        testMaxWidth = 30;
 
         fakeHttpLayer = Robolectric.getFakeHttpLayer();
         url1 = "http://www.mopub.com/";
@@ -75,7 +76,8 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
     public void constructor_withValidUrlListAndListener_shouldReturnNewImageDownloadTaskManager() throws Exception {
         subject = new ImageDownloadTaskManager(
                 Arrays.asList(url1, url2),
-                mMockImageTaskManagerListener
+                mMockImageTaskManagerListener,
+                testMaxWidth
         );
     }
 
@@ -83,7 +85,8 @@ public void constructor_withValidUrlListAndListener_shouldReturnNewImageDownload
     public void constructor_withEmptyUrlListAndListener_shouldReturnNewImageDownloadTaskManager() throws Exception {
         subject = new ImageDownloadTaskManager(
                 new ArrayList<String>(),
-                mMockImageTaskManagerListener
+                mMockImageTaskManagerListener,
+                testMaxWidth
         );
     }
 
@@ -92,7 +95,8 @@ public void constructor_withInvalidUrlList_shouldThrowIllegalArgumentException()
         try {
             subject = new ImageDownloadTaskManager(
                     Arrays.asList("BAD URL", url2),
-                    mMockImageTaskManagerListener
+                    mMockImageTaskManagerListener,
+                    testMaxWidth
             );
             fail("ImageDownloadTaskManager didn't throw an illegal argument exception");
         } catch (IllegalArgumentException e) {
@@ -102,7 +106,8 @@ public void constructor_withInvalidUrlList_shouldThrowIllegalArgumentException()
         try {
             subject = new ImageDownloadTaskManager(
                     Arrays.asList(url1, null),
-                    mMockImageTaskManagerListener
+                    mMockImageTaskManagerListener,
+                    testMaxWidth
             );
             fail("ImageDownloadTaskManager didn't throw an illegal argument exception");
         } catch (IllegalArgumentException e) {
@@ -115,7 +120,8 @@ public void constructor_withAnyNullParams_shouldThrowIllegalArgumentException()
         try {
             subject = new ImageDownloadTaskManager(
                     null,
-                    mMockImageTaskManagerListener
+                    mMockImageTaskManagerListener,
+                    testMaxWidth
             );
             fail("ImageDownloadTaskManager didn't throw an illegal argument exception");
         } catch (IllegalArgumentException e) {
@@ -125,7 +131,8 @@ public void constructor_withAnyNullParams_shouldThrowIllegalArgumentException()
         try {
             subject = new ImageDownloadTaskManager(
                     Arrays.asList(url1, url2),
-                    null
+                    null,
+                    testMaxWidth
             );
             fail("ImageDownloadTaskManager didn't throw an illegal argument exception");
         } catch (IllegalArgumentException e) {
@@ -134,34 +141,26 @@ public void constructor_withAnyNullParams_shouldThrowIllegalArgumentException()
     }
 
     @Test
-    public void execute_withValidUrlListAndListenerAndHttpResponses_shouldReturnMapOfUrlToBitmap() throws Exception {
+    public void execute_withValidUrlListAndListenerAndHttpResponses_shouldReturnMapOfUrlToDownloadResponse() throws Exception {
         subject = new ImageDownloadTaskManager(
                 Arrays.asList(url1, url2),
-                mMockImageTaskManagerListener
+                mMockImageTaskManagerListener,
+                testMaxWidth
         );
 
         String imageData1 = "image_data_1";
-        Robolectric.addHttpResponseRule(
-                url1,
-                new TestHttpResponse(200, imageData1)
-        );
-
         String imageData2 = "image_data_2";
-        Robolectric.addHttpResponseRule(
-                url2,
-                new TestHttpResponse(200, imageData2)
-        );
+        fakeHttpLayer.addPendingHttpResponse(200, imageData1);
+        fakeHttpLayer.addPendingHttpResponse(200, imageData2);
 
         subject.execute();
         semaphore.acquire();
 
         assertThat(networkImages.keySet()).containsOnly(url1, url2);
 
-        Bitmap bitmap1 = networkImages.get(url1);
-        assertThat(shadowOf(bitmap1).getCreatedFromBytes()).isEqualTo(imageData1.getBytes());
-
-        Bitmap bitmap2 = networkImages.get(url2);
-        assertThat(shadowOf(bitmap2).getCreatedFromBytes()).isEqualTo(imageData2.getBytes());
+        // These statements will fail if the objects are not of the correct type.
+        DownloadResponse bitmap1 = networkImages.get(url1);
+        DownloadResponse bitmap2 = networkImages.get(url2);
 
         verify(mMockImageTaskManagerListener).onSuccess(anyMap());
         verify(mMockImageTaskManagerListener, never()).onFail();
@@ -171,7 +170,8 @@ public void execute_withValidUrlListAndListenerAndHttpResponses_shouldReturnMapO
     public void execute_withEmptyUrlList_shouldReturnEmptyMap() throws Exception {
         subject = new ImageDownloadTaskManager(
                 new ArrayList<String>(),
-                mMockImageTaskManagerListener
+                mMockImageTaskManagerListener,
+                testMaxWidth
         );
 
         subject.execute();
@@ -186,7 +186,8 @@ public void execute_withEmptyUrlList_shouldReturnEmptyMap() throws Exception {
     public void execute_withSingleNon200Response_shouldFailAllTasks() throws Exception {
         subject = new ImageDownloadTaskManager(
                 Arrays.asList(url1, url1, url1, url1, url1),
-                mMockImageTaskManagerListener
+                mMockImageTaskManagerListener,
+                testMaxWidth
         );
 
         fakeHttpLayer.addPendingHttpResponse(200, "");
@@ -206,7 +207,8 @@ public void execute_withSingleNon200Response_shouldFailAllTasks() throws Excepti
     public void execute_withMultipleNon200Response_shouldFailAllTasks() throws Exception {
         subject = new ImageDownloadTaskManager(
                 Arrays.asList(url1, url1, url1, url1, url1),
-                mMockImageTaskManagerListener
+                mMockImageTaskManagerListener,
+                testMaxWidth
         );
 
         fakeHttpLayer.addPendingHttpResponse(599, "");
@@ -227,7 +229,8 @@ public void execute_withMultipleNon200Response_shouldFailAllTasks() throws Excep
     public void execute_withSingleInvalidHttpResponse_shouldFailAllTasks() throws Exception {
         subject = new ImageDownloadTaskManager(
                 Arrays.asList(url1, url1, url1, url1, url1),
-                mMockImageTaskManagerListener
+                mMockImageTaskManagerListener,
+                testMaxWidth
         );
 
         fakeHttpLayer.addPendingHttpResponse(200, "");
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/ImageServiceTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/ImageServiceTest.java
index 55e792e5..8ec61d62 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/ImageServiceTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/ImageServiceTest.java
@@ -7,6 +7,9 @@
 
 import com.mopub.common.CacheService;
 import com.mopub.common.CacheServiceTest;
+import com.mopub.common.DownloadResponse;
+import com.mopub.nativeads.test.support.MoPubShadowBitmap;
+import com.mopub.nativeads.test.support.MoPubShadowDisplay;
 import com.mopub.nativeads.test.support.SdkTestRunner;
 
 import org.junit.After;
@@ -16,6 +19,7 @@
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
 import org.robolectric.tester.org.apache.http.FakeHttpLayer;
 
 import java.io.ByteArrayInputStream;
@@ -33,11 +37,12 @@
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
 import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(SdkTestRunner.class)
+@Config(shadows={MoPubShadowBitmap.class, MoPubShadowDisplay.class})
 public class ImageServiceTest {
-
     private ImageServiceListener imageServiceListener;
     private Semaphore semaphore;
     private Map<String, Bitmap> bitmaps;
@@ -49,6 +54,9 @@
     private String imageData2;
     private String imageData3;
     private Context context;
+    private Bitmap image2;
+    private Bitmap image1;
+    private DownloadResponse downloadResponse;
 
     @Before
     public void setUp() throws Exception {
@@ -72,6 +80,7 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
             }
         }).when(imageServiceListener).onFail();
 
+        downloadResponse = mock(DownloadResponse.class);
         fakeHttpLayer = Robolectric.getFakeHttpLayer();
         url1 = "http://www.mopub.com/";
         url2 = "http://www.twitter.com";
@@ -79,7 +88,11 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
         imageData1 = "image_data_1";
         imageData2 = "image_data_2";
         imageData3 = "image_data_3";
+        image1 = BitmapFactory.decodeByteArray(imageData1.getBytes(), 0, imageData1.getBytes().length);
+        image2 = BitmapFactory.decodeByteArray(imageData2.getBytes(), 0, imageData2.getBytes().length);
         context = new Activity();
+
+        ImageService.initialize(context);
     }
 
     @After
@@ -90,30 +103,40 @@ public void tearDown() throws Exception {
     @Test
     public void get_shouldInitializeCaches() throws Exception {
         CacheService.clearAndNullCaches();
-        assertThat(CacheService.getMemoryLruCache()).isNull();
+        assertThat(CacheService.getBitmapLruCache()).isNull();
         assertThat(CacheService.getDiskLruCache()).isNull();
 
         ImageService.get(context, new ArrayList<String>(), imageServiceListener);
 
-        assertThat(CacheService.getMemoryLruCache()).isNotNull();
+        assertThat(CacheService.getBitmapLruCache()).isNotNull();
         assertThat(CacheService.getDiskLruCache()).isNotNull();
     }
 
+    @Test
+    public void get_shouldGetDisplaySize() {
+        ImageService.clear();
+        assertThat(ImageService.getTargetWidth()).isEqualTo(-1);
+
+        ImageService.get(context, new ArrayList<String>(), imageServiceListener);
+        assertThat(ImageService.getTargetWidth()).isGreaterThan(-1);
+    }
+
     @Test
     public void get_withImageInMemoryCache_shouldReturnImage() throws Exception {
-        CacheService.initializeCaches(context);
+        CacheService.initialize(context);
         CacheServiceTest.assertCachesAreEmpty();
-        CacheService.putToMemoryCache(url1, imageData1.getBytes());
+        CacheService.putToBitmapCache(url1, image1);
 
         ImageService.get(context, Arrays.asList(url1), imageServiceListener);
         // no need for semaphore since memory cache is synchronous
 
-        assertThat(shadowOf(bitmaps.get(url1)).getCreatedFromBytes()).isEqualTo(imageData1.getBytes());
+        assertThat(shadowOf(bitmaps.get(url1)).getDescription())
+                .isEqualTo("Bitmap for image_data_1");
     }
 
     @Test
     public void get_withImageInDiskCache_shouldReturnImage() throws Exception {
-        CacheService.initializeCaches(context);
+        CacheService.initialize(context);
         CacheServiceTest.assertCachesAreEmpty();
         CacheService.putToDiskCache(url1, imageData1.getBytes());
 
@@ -121,12 +144,13 @@ public void get_withImageInDiskCache_shouldReturnImage() throws Exception {
         semaphore.acquire();
 
         assertThat(fakeHttpLayer.getLastSentHttpRequestInfo()).isNull();
-        assertThat(shadowOf(bitmaps.get(url1)).getCreatedFromBytes()).isEqualTo(imageData1.getBytes());
+        assertThat(shadowOf(bitmaps.get(url1)).getDescription())
+                .isEqualTo("Bitmap for image_data_1");
     }
 
     @Test
     public void get_withEmptyCaches_shouldGetImageFromNetwork() throws Exception {
-        CacheService.initializeCaches(context);
+        CacheService.initialize(context);
         CacheServiceTest.assertCachesAreEmpty();
 
         fakeHttpLayer.addPendingHttpResponse(200, imageData1);
@@ -134,31 +158,33 @@ public void get_withEmptyCaches_shouldGetImageFromNetwork() throws Exception {
         ImageService.get(context, Arrays.asList(url1), imageServiceListener);
         semaphore.acquire();
 
-        assertThat(shadowOf(bitmaps.get(url1)).getCreatedFromBytes()).isEqualTo(imageData1.getBytes());
+        assertThat(shadowOf(bitmaps.get(url1)).getDescription())
+                .isEqualTo("Bitmap for image_data_1");
     }
 
     @Test
     public void get_withImagesInMemoryCacheAndDiskCache_shouldReturnBothImages() throws Exception {
-        CacheService.initializeCaches(context);
+        CacheService.initialize(context);
         CacheServiceTest.assertCachesAreEmpty();
 
-        CacheService.putToMemoryCache(url1, imageData1.getBytes());
+        CacheService.putToBitmapCache(url1, image1);
         CacheService.putToDiskCache(url2, imageData2.getBytes());
 
         ImageService.get(context, Arrays.asList(url1, url2), imageServiceListener);
         semaphore.acquire();
 
-        assertThat(shadowOf(bitmaps.get(url1)).getCreatedFromBytes()).isEqualTo(imageData1.getBytes());
+        assertThat(bitmaps.get(url1)).isEqualTo(image1);
         assertThat(fakeHttpLayer.getLastSentHttpRequestInfo()).isNull();
-        assertThat(shadowOf(bitmaps.get(url2)).getCreatedFromBytes()).isEqualTo(imageData2.getBytes());
+        assertThat(shadowOf(bitmaps.get(url2)).getDescription())
+                .isEqualTo("Bitmap for image_data_2");
     }
 
     @Test
     public void get_withImagesInMemoryAndNetwork_shouldReturnBothImages() throws Exception {
-        CacheService.initializeCaches(context);
+        CacheService.initialize(context);
         CacheServiceTest.assertCachesAreEmpty();
 
-        CacheService.putToMemoryCache(url1, imageData1.getBytes());
+        CacheService.putToBitmapCache(url1, image1);
         fakeHttpLayer.addPendingHttpResponse(200, imageData2);
 
         ImageService.get(context, Arrays.asList(url1, url2), imageServiceListener);
@@ -166,12 +192,13 @@ public void get_withImagesInMemoryAndNetwork_shouldReturnBothImages() throws Exc
 
         assertThat(shadowOf(bitmaps.get(url1)).getCreatedFromBytes()).isEqualTo(imageData1.getBytes());
         assertThat(fakeHttpLayer.getLastSentHttpRequestInfo().getHttpHost().toString()).isEqualTo(url2);
-        assertThat(shadowOf(bitmaps.get(url2)).getCreatedFromBytes()).isEqualTo(imageData2.getBytes());
+        assertThat(shadowOf(bitmaps.get(url2)).getDescription())
+                .isEqualTo("Bitmap for image_data_2");
     }
 
     @Test
     public void get_withImagesInDiskAndNetwork_shouldReturnBothImages() throws Exception {
-        CacheService.initializeCaches(context);
+        CacheService.initialize(context);
         CacheServiceTest.assertCachesAreEmpty();
 
         CacheService.putToDiskCache(url1, imageData1.getBytes());
@@ -180,17 +207,19 @@ public void get_withImagesInDiskAndNetwork_shouldReturnBothImages() throws Excep
         ImageService.get(context, Arrays.asList(url1, url2), imageServiceListener);
         semaphore.acquire();
 
-        assertThat(shadowOf(bitmaps.get(url1)).getCreatedFromBytes()).isEqualTo(imageData1.getBytes());
+        assertThat(shadowOf(bitmaps.get(url1)).getDescription())
+                .isEqualTo("Bitmap for image_data_1");
         assertThat(fakeHttpLayer.getLastSentHttpRequestInfo().getHttpHost().toString()).isEqualTo(url2);
-        assertThat(shadowOf(bitmaps.get(url2)).getCreatedFromBytes()).isEqualTo(imageData2.getBytes());
+        assertThat(shadowOf(bitmaps.get(url2)).getDescription())
+                .isEqualTo("Bitmap for image_data_2");
     }
 
     @Test
     public void get_withImagesInMemoryAndDiskAndNetwork_shouldReturnAllImages() throws Exception {
-        CacheService.initializeCaches(context);
+        CacheService.initialize(context);
         CacheServiceTest.assertCachesAreEmpty();
 
-        CacheService.putToMemoryCache(url1, imageData1.getBytes());
+        CacheService.putToBitmapCache(url1, image1);
         CacheService.putToDiskCache(url2, imageData2.getBytes());
         fakeHttpLayer.addPendingHttpResponse(200, imageData3);
 
@@ -198,16 +227,18 @@ public void get_withImagesInMemoryAndDiskAndNetwork_shouldReturnAllImages() thro
         semaphore.acquire();
 
         assertThat(shadowOf(bitmaps.get(url1)).getCreatedFromBytes()).isEqualTo(imageData1.getBytes());
-        assertThat(shadowOf(bitmaps.get(url2)).getCreatedFromBytes()).isEqualTo(imageData2.getBytes());
-        assertThat(shadowOf(bitmaps.get(url3)).getCreatedFromBytes()).isEqualTo(imageData3.getBytes());
+        assertThat(shadowOf(bitmaps.get(url2)).getDescription())
+                .isEqualTo("Bitmap for image_data_2");
+        assertThat(shadowOf(bitmaps.get(url3)).getDescription())
+                .isEqualTo("Bitmap for image_data_3");
     }
 
     @Test
     public void get_withSameKeysInMemoryAndDiskCache_shouldReturnValueFromMemoryCache() throws Exception {
-        CacheService.initializeCaches(context);
+        CacheService.initialize(context);
         CacheServiceTest.assertCachesAreEmpty();
 
-        CacheService.putToMemoryCache(url1, imageData2.getBytes());
+        CacheService.putToBitmapCache(url1, image2);
         CacheService.putToDiskCache(url1, imageData1.getBytes());
 
         ImageService.get(context, Arrays.asList(url1), imageServiceListener);
@@ -218,10 +249,10 @@ public void get_withSameKeysInMemoryAndDiskCache_shouldReturnValueFromMemoryCach
 
     @Test
     public void get_withSameKeysInMemoryAndNetwork_shouldReturnValueFromMemoryCache() throws Exception {
-        CacheService.initializeCaches(context);
+        CacheService.initialize(context);
         CacheServiceTest.assertCachesAreEmpty();
 
-        CacheService.putToMemoryCache(url1, imageData2.getBytes());
+        CacheService.putToBitmapCache(url1, image2);
         fakeHttpLayer.addPendingHttpResponse(200, imageData1);
 
         ImageService.get(context, Arrays.asList(url1), imageServiceListener);
@@ -232,7 +263,7 @@ public void get_withSameKeysInMemoryAndNetwork_shouldReturnValueFromMemoryCache(
 
     @Test
     public void get_withSameKeysInDiskAndNetwork_shouldReturnValueFromDiskCache() throws Exception {
-        CacheService.initializeCaches(context);
+        CacheService.initialize(context);
         CacheServiceTest.assertCachesAreEmpty();
 
         CacheService.putToDiskCache(url1, imageData2.getBytes());
@@ -241,15 +272,17 @@ public void get_withSameKeysInDiskAndNetwork_shouldReturnValueFromDiskCache() th
         ImageService.get(context, Arrays.asList(url1), imageServiceListener);
         semaphore.acquire();
 
-        assertThat(shadowOf(bitmaps.get(url1)).getCreatedFromBytes()).isEqualTo(imageData2.getBytes());
+        assertThat(fakeHttpLayer.getLastSentHttpRequestInfo()).isNull();
+        assertThat(shadowOf(bitmaps.get(url1)).getDescription())
+                .isEqualTo("Bitmap for image_data_2");
     }
 
     @Test
     public void get_withNetworkFailure_shouldFail() throws Exception {
-        CacheService.initializeCaches(context);
+        CacheService.initialize(context);
         CacheServiceTest.assertCachesAreEmpty();
 
-        CacheService.putToMemoryCache(url1, imageData1.getBytes());
+        CacheService.putToBitmapCache(url1, image1);
         CacheService.putToDiskCache(url2, imageData2.getBytes());
         fakeHttpLayer.addPendingHttpResponse(500, imageData3);
 
@@ -261,7 +294,7 @@ public void get_withNetworkFailure_shouldFail() throws Exception {
 
     @Test
     public void get_withMultipleNetworkSuccessAndOneFailure_shouldFail() throws Exception {
-        CacheService.initializeCaches(context);
+        CacheService.initialize(context);
         CacheServiceTest.assertCachesAreEmpty();
 
         fakeHttpLayer.addPendingHttpResponse(200, imageData1);
@@ -275,34 +308,34 @@ public void get_withMultipleNetworkSuccessAndOneFailure_shouldFail() throws Exce
     }
 
     @Test
-    public void putBitmapsInCache_populatesCaches() throws Exception {
-        CacheService.initializeCaches(context);
+    public void putDataInCache_populatesCaches() throws Exception {
+        CacheService.initialize(context);
 
         Bitmap bitmap1 = BitmapFactory.decodeStream(getInputStreamFromString(imageData1));
         Bitmap bitmap2 = BitmapFactory.decodeStream(getInputStreamFromString(imageData2));
 
-        Map<String, Bitmap> bitmaps = new HashMap<String, Bitmap>(2);
-        bitmaps.put(url1, bitmap1);
-        bitmaps.put(url2, bitmap2);
-
         assertThat(ImageService.getBitmapFromDiskCache(url1)).isNull();
         assertThat(ImageService.getBitmapFromDiskCache(url2)).isNull();
         assertThat(ImageService.getBitmapFromMemoryCache(url1)).isNull();
         assertThat(ImageService.getBitmapFromMemoryCache(url2)).isNull();
 
-        ImageService.putBitmapsInCache(bitmaps);
+        ImageService.putDataInCache(url1, bitmap1, imageData1.getBytes());
+        ImageService.putDataInCache(url2, bitmap2, imageData2.getBytes());
+
         Thread.sleep(500); // disk cache put is async
 
-        assertThat(ImageService.getBitmapFromDiskCache(url1)).isNotNull();
-        assertThat(ImageService.getBitmapFromDiskCache(url2)).isNotNull();
-        assertThat(ImageService.getBitmapFromMemoryCache(url1)).isNotNull();
-        assertThat(ImageService.getBitmapFromMemoryCache(url2)).isNotNull();
+        assertThat(shadowOf(ImageService.getBitmapFromDiskCache(url1)).getDescription())
+                .isEqualTo("Bitmap for image_data_1");
+        assertThat(shadowOf(ImageService.getBitmapFromDiskCache(url2)).getDescription())
+                .isEqualTo("Bitmap for image_data_2");
+        assertThat(ImageService.getBitmapFromMemoryCache(url1)).isEqualTo(bitmap1);
+        assertThat(ImageService.getBitmapFromMemoryCache(url2)).isEqualTo(bitmap2);
     }
 
     @Test
     public void getBitmapsFromMemoryCache_withEmptyCacheAndTwoUrls_returnsNoCacheHitsAndTwoCacheMisses() throws Exception {
-        CacheService.initializeCaches(context);
-        assertThat(CacheService.getMemoryLruCache().size()).isEqualTo(0);
+        CacheService.initialize(context);
+        assertThat(CacheService.getBitmapLruCache().size()).isEqualTo(0);
 
         Map<String, Bitmap> cacheHits = new HashMap<String, Bitmap>(2);
         List<String> cacheMisses =
@@ -314,11 +347,11 @@ public void getBitmapsFromMemoryCache_withEmptyCacheAndTwoUrls_returnsNoCacheHit
 
     @Test
     public void getBitmapsFromMemoryCache_withOneCacheEntryAndTwoUrls_returnsOneCacheHitAndOneCacheMiss() throws Exception {
-        CacheService.initializeCaches(context);
+        CacheService.initialize(context);
 
-        assertThat(CacheService.getMemoryLruCache().size()).isEqualTo(0);
+        assertThat(CacheService.getBitmapLruCache().size()).isEqualTo(0);
 
-        CacheService.putToMemoryCache(url1, imageData1.getBytes());
+        CacheService.putToBitmapCache(url1, image1);
 
         Map<String, Bitmap> cacheHits = new HashMap<String, Bitmap>(2);
         List<String> cacheMisses =
@@ -328,6 +361,45 @@ public void getBitmapsFromMemoryCache_withOneCacheEntryAndTwoUrls_returnsOneCach
         assertThat(cacheMisses).containsOnly(url2);
     }
 
+    @Test
+    public void asBitmap_withMaxSize_shouldReturnBitmap() {
+
+        String imageData = "fake_bitmap_data";
+        when(downloadResponse.getByteArray()).thenReturn(imageData.getBytes());
+
+        final Bitmap bitmap = ImageService.asBitmap(downloadResponse, 30);
+
+        assertThat(bitmap).isNotNull();
+        assertThat(bitmap).isInstanceOf(Bitmap.class);
+    }
+
+    @Test
+    public void asBitmap_withNullResponse_shouldReturnNull() throws Exception {
+        final Bitmap bitmap = ImageService.asBitmap(null, 30);
+
+        assertThat(bitmap).isNull();
+    }
+
+    @Test
+    public void calculateInSampleSize_withImageSmallerThanRequested_shouldBe1() {
+        int nativeWidth = 1024;
+        assertThat(ImageService.calculateInSampleSize(nativeWidth, 2046)).isEqualTo(1);
+    }
+
+    @Test
+    public void calculateInSampleSize_withImageSlightlyBiggerThanRequest_shouldBe1() {
+        int nativeWidth = 1024;
+        assertThat(ImageService.calculateInSampleSize(nativeWidth, 800)).isEqualTo(1);
+
+    }
+
+    @Test
+    public void calculateInSampleSize_withImageMuchBiggerThanRequest_shouldBe4() {
+        int nativeWidth = 2048;
+        int nativeHeight = 1024;
+        assertThat(ImageService.calculateInSampleSize(nativeWidth, 512)).isEqualTo(4);
+    }
+
     private static InputStream getInputStreamFromString(final String string) {
         return spy(new ByteArrayInputStream(string.getBytes()));
     }
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/ImageViewServiceTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/ImageViewServiceTest.java
index 4aaef2fc..8eb2dc2c 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/ImageViewServiceTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/ImageViewServiceTest.java
@@ -3,11 +3,14 @@
 import android.app.Activity;
 import android.content.Context;
 import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
 import android.graphics.drawable.BitmapDrawable;
 import android.widget.ImageView;
 
 import com.mopub.common.CacheService;
 import com.mopub.common.CacheServiceTest;
+import com.mopub.nativeads.test.support.MoPubShadowBitmap;
+import com.mopub.nativeads.test.support.MoPubShadowDisplay;
 import com.mopub.nativeads.test.support.SdkTestRunner;
 
 import org.junit.After;
@@ -15,12 +18,14 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
 import org.robolectric.tester.org.apache.http.FakeHttpLayer;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(SdkTestRunner.class)
+@Config(shadows={MoPubShadowBitmap.class, MoPubShadowDisplay.class})
 public class ImageViewServiceTest {
 
     private ImageView imageView;
@@ -29,16 +34,19 @@
     private String imageData1;
     private String imageData2;
     private FakeHttpLayer fakeHttpLayer;
+    private Bitmap image1;
 
     @Before
     public void setUp() throws Exception {
         Context context = new Activity();
         imageView = new ImageView(context);
-        CacheService.initializeCaches(context);
+        CacheService.initialize(context);
+        ImageService.initialize(context);
         url1 = "http://www.mopub.com/";
         url2 = "http://www.twitter.com/";
         imageData1 = "image_data_1";
         imageData2 = "image_data_2";
+        image1 = BitmapFactory.decodeByteArray(imageData1.getBytes(), 0, imageData1.getBytes().length);
         fakeHttpLayer = Robolectric.getFakeHttpLayer();
     }
 
@@ -50,7 +58,7 @@ public void tearDown() throws Exception {
     @Test
     public void loadImageView_withImageInMemoryCache_shouldLoadImageData() throws Exception {
         CacheServiceTest.assertCachesAreEmpty();
-        CacheService.putToMemoryCache(url1, imageData1.getBytes());
+        CacheService.putToBitmapCache(url1, image1);
 
         assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNull();
 
@@ -65,6 +73,7 @@ public void loadImageView_withImageInMemoryCache_shouldLoadImageData() throws Ex
     public void loadImageView_withImageInDiskCache_shouldLoadImageDataAsync() throws Exception {
         CacheServiceTest.assertCachesAreEmpty();
         CacheService.putToDiskCache(url1, imageData1.getBytes());
+        assertThat(CacheService.containsKeyDiskCache(url1)).isTrue();
 
         assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNull();
 
@@ -72,8 +81,8 @@ public void loadImageView_withImageInDiskCache_shouldLoadImageDataAsync() throws
         Thread.sleep(500);
 
         assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNotNull();
-        assertThat(shadowOf(getBitmapFromImageView(imageView)).getCreatedFromBytes())
-                .isEqualTo(imageData1.getBytes());
+        assertThat(shadowOf(getBitmapFromImageView(imageView)).getDescription())
+                .isEqualTo("Bitmap for image_data_1");
     }
 
     @Test
@@ -82,13 +91,14 @@ public void loadImageView_withImageInNetwork_shouldLoadImageDataAsync() throws E
         fakeHttpLayer.addPendingHttpResponse(200, imageData1);
 
         assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNull();
+        assertThat(imageView.getDrawable()).isNull();
 
         ImageViewService.loadImageView(url1, imageView);
         Thread.sleep(500);
 
         assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNotNull();
-        assertThat(shadowOf(getBitmapFromImageView(imageView)).getCreatedFromBytes())
-                .isEqualTo(imageData1.getBytes());
+        assertThat(shadowOf(getBitmapFromImageView(imageView)).getDescription())
+                .isEqualTo("Bitmap for image_data_1");
     }
 
     @Test
@@ -103,7 +113,7 @@ public void loadImageView_withImageInNetworkAndUniqueIdChanges_shouldNotLoadImag
         ImageViewService.loadImageView(url1, imageView);
 
         // Change unique id before running async task to simulate another image load
-        ImageViewService.setImageViewUniqueId(imageView);
+        ImageViewService.setImageViewUniqueId(imageView, -1);
 
         Robolectric.getBackgroundScheduler().runOneTask();
         Robolectric.getBackgroundScheduler().unPause();
@@ -124,7 +134,7 @@ public void loadImageView_withImageInNetworkAndUniqueIdIsNull_shouldNotLoadImage
         ImageViewService.loadImageView(url1, imageView);
 
         // Change unique id before running async task to simulate another image load
-        ImageViewService.setViewTag(imageView, null);
+        ImageViewService.setImageViewUniqueId(imageView, -1);
 
         Robolectric.getBackgroundScheduler().runOneTask();
         Robolectric.getBackgroundScheduler().unPause();
@@ -151,8 +161,8 @@ public void loadImageView_withTwoNetworkRequests_shouldLoadSecondImageData() thr
         Robolectric.getBackgroundScheduler().unPause();
         Thread.sleep(500);
 
-        assertThat(shadowOf(getBitmapFromImageView(imageView)).getCreatedFromBytes())
-                .isEqualTo(imageData2.getBytes());
+        assertThat(shadowOf(getBitmapFromImageView(imageView)).getDescription())
+                .isEqualTo("Bitmap for image_data_2");
     }
 
     @Test
@@ -166,8 +176,8 @@ public void loadImageView_shouldClearDrawable() throws Exception {
 
         ImageViewService.loadImageView(url1, imageView);
         Thread.sleep(500);
-        assertThat(shadowOf(getBitmapFromImageView(imageView)).getCreatedFromBytes())
-                .isEqualTo(imageData1.getBytes());
+        assertThat(shadowOf(getBitmapFromImageView(imageView)).getDescription())
+                .isEqualTo("Bitmap for image_data_1");
 
         Robolectric.getBackgroundScheduler().pause();
         ImageViewService.loadImageView(url2, imageView);
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/ImpressionTrackerTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/ImpressionTrackerTest.java
new file mode 100644
index 00000000..c87c097d
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/ImpressionTrackerTest.java
@@ -0,0 +1,305 @@
+package com.mopub.nativeads;
+
+import android.os.Handler;
+import android.view.View;
+
+import com.mopub.nativeads.test.support.SdkTestRunner;
+
+import org.fest.util.Lists;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+import org.robolectric.shadows.ShadowSystemClock;
+
+import java.util.HashMap;
+
+import static com.mopub.nativeads.MoPubNative.MoPubNativeListener;
+import static com.mopub.nativeads.VisibilityTracker.VisibilityChecker;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class ImpressionTrackerTest {
+    private ImpressionTracker subject;
+    private TimestampWrapper<NativeResponse> timeStampWrapper;
+    private HashMap<View, NativeResponse> trackedViews;
+    private HashMap<View, TimestampWrapper<NativeResponse>> pollingViews;
+
+    @Mock private NativeResponse nativeResponse;
+    @Mock private NativeResponse nativeResponse2;
+    @Mock private MoPubNativeListener moPubNativeListener;
+    @Mock private VisibilityTracker visibilityTracker;
+    @Mock private Handler handler;
+    @Mock private View view;
+    @Mock private View view2;
+
+    @Before
+    public void setUp() {
+        view = VisibilityTrackerTest.createViewMock(View.VISIBLE, 100, 100, 100, 100, true, true);
+        view2 = VisibilityTrackerTest.createViewMock(View.VISIBLE, 100, 100, 100, 100, true, true);
+
+        pollingViews = new HashMap<View, TimestampWrapper<NativeResponse>>(10);
+        trackedViews = new HashMap<View, NativeResponse>(10);
+        final VisibilityChecker visibilityChecker = new VisibilityChecker();
+        subject = new ImpressionTracker(trackedViews, pollingViews, visibilityChecker,
+                visibilityTracker, handler);
+
+        timeStampWrapper = new TimestampWrapper<NativeResponse>(nativeResponse);
+
+        when(nativeResponse.getImpressionMinPercentageViewed()).thenReturn(50);
+        when(nativeResponse.getImpressionMinTimeViewed()).thenReturn(1000);
+        when(nativeResponse2.getImpressionMinPercentageViewed()).thenReturn(50);
+        when(nativeResponse2.getImpressionMinTimeViewed()).thenReturn(1000);
+
+        // XXX We need this to ensure that our SystemClock starts
+        ShadowSystemClock.uptimeMillis();
+    }
+
+    @Test
+    public void addView_shouldAddViewToTrackedViews_shouldAddViewToVisibilityTracker() {
+        subject.addView(view, nativeResponse);
+
+        assertThat(trackedViews).hasSize(1);
+        assertThat(trackedViews.get(view)).isEqualTo(nativeResponse);
+        verify(visibilityTracker).addView(view, nativeResponse.getImpressionMinPercentageViewed());
+    }
+
+    @Test
+    public void addView_withRecordedImpression_shouldNotAddView() {
+        when(nativeResponse.getRecordedImpression()).thenReturn(true);
+
+        subject.addView(view, nativeResponse);
+
+        assertThat(trackedViews).hasSize(0);
+        verify(visibilityTracker, never())
+                .addView(view, nativeResponse.getImpressionMinPercentageViewed());
+    }
+
+    @Test
+    public void addView_withDestroyedNativeResponse_shouldNotAddView() {
+        when(nativeResponse.isDestroyed()).thenReturn(true);
+
+        subject.addView(view, nativeResponse);
+
+        assertThat(trackedViews).isEmpty();
+        verify(visibilityTracker, never())
+                .addView(view, nativeResponse.getImpressionMinPercentageViewed());
+    }
+
+    @Test
+    public void addView_withDifferentNativeResponse_shouldRemoveFromPollingViews() {
+        subject.addView(view, nativeResponse);
+
+        assertThat(trackedViews).hasSize(1);
+        assertThat(trackedViews.get(view)).isEqualTo(nativeResponse);
+        verify(visibilityTracker).addView(view, nativeResponse.getImpressionMinPercentageViewed());
+
+        pollingViews.put(view, timeStampWrapper);
+
+        subject.addView(view, nativeResponse2);
+
+        assertThat(trackedViews).hasSize(1);
+        assertThat(trackedViews.get(view)).isEqualTo(nativeResponse2);
+        assertThat(pollingViews).isEmpty();
+        verify(visibilityTracker, times(2))
+                .addView(view, nativeResponse.getImpressionMinPercentageViewed());
+    }
+
+    @Test
+    public void addView_withDifferentAlreadyImpressedNativeResponse_shouldRemoveFromPollingViews_shouldNotTrack() {
+        when(nativeResponse2.getRecordedImpression()).thenReturn(true);
+
+        subject.addView(view, nativeResponse);
+
+        assertThat(trackedViews).hasSize(1);
+        assertThat(trackedViews.get(view)).isEqualTo(nativeResponse);
+        verify(visibilityTracker).addView(view, nativeResponse.getImpressionMinPercentageViewed());
+
+        pollingViews.put(view, timeStampWrapper);
+
+        subject.addView(view, nativeResponse2);
+
+        assertThat(trackedViews).hasSize(0);
+        assertThat(trackedViews.get(view)).isNull();
+        assertThat(pollingViews).isEmpty();
+        verify(visibilityTracker).addView(view, nativeResponse.getImpressionMinPercentageViewed());
+    }
+
+    @Test
+    public void addView_withSameNativeResponse_shouldNotAddView() {
+        subject.addView(view, nativeResponse);
+
+        assertThat(trackedViews).hasSize(1);
+        assertThat(trackedViews.get(view)).isEqualTo(nativeResponse);
+        verify(visibilityTracker).addView(view, nativeResponse.getImpressionMinPercentageViewed());
+
+        pollingViews.put(view, timeStampWrapper);
+
+        subject.addView(view, nativeResponse);
+
+        assertThat(trackedViews).hasSize(1);
+        assertThat(trackedViews.get(view)).isEqualTo(nativeResponse);
+        assertThat(pollingViews.keySet()).containsOnly(view);
+
+        // Still only one call
+        verify(visibilityTracker).addView(view, nativeResponse.getImpressionMinPercentageViewed());
+    }
+
+    @Test
+    public void removeView_shouldRemoveViewFromViewTrackedViews_shouldRemoveViewFromPollingMap_shouldRemoveViewFromVisibilityTracker() {
+        trackedViews.put(view, nativeResponse);
+        pollingViews.put(view, new TimestampWrapper<NativeResponse>(nativeResponse));
+        visibilityTracker.addView(view, nativeResponse.getImpressionMinPercentageViewed());
+
+        subject.removeView(view);
+
+        assertThat(trackedViews).isEmpty();
+        assertThat(pollingViews).isEmpty();
+        verify(visibilityTracker).removeView(view);
+    }
+
+    @Test
+    public void clear_shouldClearViewTrackedViews_shouldClearPollingViews_shouldClearVisibilityTracker_shouldClearPollHandler() {
+        trackedViews.put(view, nativeResponse);
+        trackedViews.put(view2, nativeResponse);
+        pollingViews.put(view, timeStampWrapper);
+        pollingViews.put(view2, timeStampWrapper);
+        visibilityTracker.addView(view, nativeResponse.getImpressionMinPercentageViewed());
+        visibilityTracker.addView(view2, nativeResponse.getImpressionMinPercentageViewed());
+
+        subject.clear();
+
+        assertThat(trackedViews).isEmpty();
+        assertThat(pollingViews).isEmpty();
+        verify(visibilityTracker).clear();
+        verify(handler).removeMessages(0);
+    }
+    
+    @Test
+    public void destroy_shouldCallClear_shouldDestroyVisibilityTracker_shouldSetVisibilityTrackerListenerToNull() throws Exception {
+        trackedViews.put(view, nativeResponse);
+        trackedViews.put(view2, nativeResponse);
+        pollingViews.put(view, timeStampWrapper);
+        pollingViews.put(view2, timeStampWrapper);
+        visibilityTracker.addView(view, nativeResponse.getImpressionMinPercentageViewed());
+        visibilityTracker.addView(view2, nativeResponse.getImpressionMinPercentageViewed());
+        assertThat(subject.getVisibilityTrackerListener()).isNotNull();
+
+        subject.destroy();
+
+        assertThat(trackedViews).isEmpty();
+        assertThat(pollingViews).isEmpty();
+        verify(visibilityTracker).clear();
+        verify(handler).removeMessages(0);
+
+        verify(visibilityTracker).destroy();
+        assertThat(subject.getVisibilityTrackerListener()).isNull();
+    }
+
+    @Test
+    public void scheduleNextPoll_shouldPostDelayedThePollingRunnable() {
+        when(handler.hasMessages(0)).thenReturn(false);
+
+        subject.scheduleNextPoll();
+
+        verify(handler).postDelayed(any(ImpressionTracker.PollingRunnable.class), eq((long) 250));
+    }
+
+    @Test
+    public void scheduleNextPoll_withMessages_shouldNotPostDelayedThePollingRunnable() {
+        when(handler.hasMessages(0)).thenReturn(true);
+
+        subject.scheduleNextPoll();
+
+        verify(handler, never())
+                .postDelayed(any(ImpressionTracker.PollingRunnable.class), eq((long) 250));
+    }
+
+    @Test
+    public void visibilityTrackerListener_onVisibilityChanged_withVisibleViews_shouldAddViewToPollingViews_shouldScheduleNextPoll() {
+        subject.addView(view, nativeResponse);
+
+        assertThat(pollingViews).isEmpty();
+
+        subject.getVisibilityTrackerListener()
+                .onVisibilityChanged(Lists.newArrayList(view), Lists.<View>newArrayList());
+
+        assertThat(pollingViews.keySet()).containsOnly(view);
+        verify(handler).postDelayed(any(ImpressionTracker.PollingRunnable.class), eq((long) 250));
+    }
+
+    @Test
+    public void visibilityTrackerListener_onVisibilityChanged_withVisibleViews_shouldRemoveViewFromPollingViews() {
+        subject.addView(view, nativeResponse);
+        subject.getVisibilityTrackerListener()
+                .onVisibilityChanged(Lists.newArrayList(view), Lists.<View>newArrayList());
+
+
+        assertThat(trackedViews.keySet()).containsOnly(view);
+        assertThat(pollingViews.keySet()).containsOnly(view);
+
+        subject.getVisibilityTrackerListener()
+                .onVisibilityChanged(Lists.<View>newArrayList(), Lists.newArrayList(view));
+
+        assertThat(trackedViews.keySet()).containsOnly(view);
+        assertThat(pollingViews).isEmpty();
+    }
+
+    @Test
+    public void pollingRunnableRun_whenLessThanOneSecondHasElapsed_shouldNotTrackImpression_shouldScheduleNextPoll() {
+        // Force the last viewed timestamp to be a known value
+        timeStampWrapper.mCreatedTimestamp = 5555;
+        pollingViews.put(view, timeStampWrapper);
+
+        // We progress 999 milliseconds
+        Robolectric.getUiThreadScheduler().advanceBy(5555 + 999);
+        subject.new PollingRunnable().run();
+
+        verify(nativeResponse, never()).recordImpression(view);
+
+        assertThat(pollingViews.keySet()).containsOnly(view);
+        verify(handler).postDelayed(any(ImpressionTracker.PollingRunnable.class), eq((long) 250));
+    }
+
+    @Test
+    public void pollingRunnableRun_whenMoreThanOneSecondHasElapsed_shouldTrackImpression_shouldNotScheduleNextPoll() {
+        // Force the last viewed timestamp to be a known value
+        timeStampWrapper.mCreatedTimestamp = 5555;
+        pollingViews.put(view, timeStampWrapper);
+
+        // We progress 1000 milliseconds
+        Robolectric.getUiThreadScheduler().advanceBy(5555 + 1000);
+        subject.new PollingRunnable().run();
+
+        verify(nativeResponse).recordImpression(view);
+
+        assertThat(pollingViews).isEmpty();
+        verify(handler, never())
+                .postDelayed(any(ImpressionTracker.PollingRunnable.class), eq((long) 250));
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void pollingRunnableRun_whenWrapperIsNull_shouldThrowNPE() {
+        pollingViews.put(view, null);
+        subject.new PollingRunnable().run();
+
+        verify(nativeResponse, never()).recordImpression(view);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void pollingRunnableRun_whenNativeResponseIsNull_shouldThrowNPE() {
+        // This doesn't normally happen; perhaps we're being overly defensive
+        pollingViews.put(view, new TimestampWrapper<NativeResponse>(null));
+
+        subject.new PollingRunnable().run();
+
+        verify(nativeResponse, never()).recordImpression(view);
+    }
+}
\ No newline at end of file
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/ImpressionTrackingManagerTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/ImpressionTrackingManagerTest.java
deleted file mode 100644
index e91cdcd7..00000000
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/ImpressionTrackingManagerTest.java
+++ /dev/null
@@ -1,493 +0,0 @@
-package com.mopub.nativeads;
-
-import android.app.Activity;
-import android.content.Context;
-import android.graphics.Rect;
-import android.view.View;
-import android.view.ViewParent;
-import android.view.ViewTreeObserver;
-
-import com.mopub.common.DownloadResponse;
-import com.mopub.common.util.ResponseHeader;
-import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
-import com.mopub.nativeads.test.support.SdkTestRunner;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.Robolectric;
-import org.robolectric.shadows.ShadowSystemClock;
-import org.robolectric.tester.org.apache.http.TestHttpResponse;
-
-import static android.view.ViewTreeObserver.OnPreDrawListener;
-import static com.mopub.nativeads.ImpressionTrackingManager.NativeResponseWrapper;
-import static com.mopub.nativeads.ImpressionTrackingManager.PollingRunnable;
-import static com.mopub.nativeads.ImpressionTrackingManager.VisibilityChecker.isMostlyVisible;
-import static com.mopub.nativeads.MoPubNative.MoPubNativeListener;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-@RunWith(SdkTestRunner.class)
-public class ImpressionTrackingManagerTest {
-    private static final String IMPRESSION_TRACKER = "url1";
-    private static final int IMPRESSION_MIN_PERCENTAGE_VIEWED = 50;
-
-    private View view;
-    private NativeResponse nativeResponse;
-    private NativeResponseWrapper nativeResponseWrapper;
-    private Context context;
-    private MoPubNativeListener mopubNativeListener;
-
-    @Before
-    public void setUp() throws Exception {
-        ImpressionTrackingManager.clearTracking();
-
-        context = new Activity();
-        mopubNativeListener = mock(MoPubNativeListener.class);
-        view = getViewMock(View.VISIBLE, 100, 100, 100, 100, true, true);
-
-        final BaseForwardingNativeAd nativeAd = new BaseForwardingNativeAd() {};
-        final TestHttpResponseWithHeaders testHttpResponseWithHeaders = new TestHttpResponseWithHeaders(200, "");
-        testHttpResponseWithHeaders.addHeader(ResponseHeader.IMPRESSION_URL.getKey(), "url1");
-        final DownloadResponse downloadResponse = new DownloadResponse(testHttpResponseWithHeaders);
-
-        nativeResponse = new NativeResponse(context, downloadResponse, nativeAd, mopubNativeListener);
-        nativeResponseWrapper = new NativeResponseWrapper(nativeResponse);
-
-        Robolectric.addPendingHttpResponse(new TestHttpResponse(200, ""));
-
-        // We need this to ensure that our SystemClock starts
-        ShadowSystemClock.uptimeMillis();
-    }
-
-    @After
-    public void tearDown() throws Exception {
-        ImpressionTrackingManager.clearTracking();
-    }
-
-    @Test
-    public void addView_withVisibleView_shouldAddViewToPollingHashMap() throws Exception {
-        ImpressionTrackingManager.addView(view, nativeResponse);
-
-        assertThat(ImpressionTrackingManager.getPollingViews().keySet()).containsOnly(view);
-        assertThat(ImpressionTrackingManager.getWaitingViews()).isEmpty();
-    }
-
-    @Test
-    public void addView_withNonVisibleView_shouldAddViewToWaitingHashMap() throws Exception {
-        view = getViewMock(View.GONE, 0, 0, 0, 0, true, false);
-
-        ImpressionTrackingManager.addView(view, nativeResponse);
-
-        assertThat(ImpressionTrackingManager.getPollingViews()).isEmpty();
-        assertThat(ImpressionTrackingManager.getWaitingViews().keySet()).containsOnly(view);
-    }
-
-    @Test
-    public void addView_whenViewIsNull_shouldNotAddView() throws Exception {
-        ImpressionTrackingManager.addView(null, nativeResponse);
-
-        assertThat(ImpressionTrackingManager.getPollingViews()).isEmpty();
-        assertThat(ImpressionTrackingManager.getWaitingViews()).isEmpty();
-    }
-
-    @Test
-    public void addView_whenNativeResponseIsNull_shouldNotAddView() throws Exception {
-        ImpressionTrackingManager.addView(view, null);
-
-        assertThat(ImpressionTrackingManager.getPollingViews()).isEmpty();
-        assertThat(ImpressionTrackingManager.getWaitingViews()).isEmpty();
-    }
-
-    @Test
-    public void isViewTracked_whenPollingViewsOrWaitingViewsContainsView_shouldReturnTrue() throws Exception {
-        assertThat(ImpressionTrackingManager.isViewTracked(view)).isEqualTo(false);
-
-        ImpressionTrackingManager.getPollingViews().put(view, new NativeResponseWrapper(nativeResponse));
-        assertThat(ImpressionTrackingManager.isViewTracked(view)).isTrue();
-        ImpressionTrackingManager.getPollingViews().clear();
-
-        ImpressionTrackingManager.getWaitingViews().put(view, mock(OnPreDrawListener.class));
-        assertThat(ImpressionTrackingManager.isViewTracked(view)).isTrue();
-        ImpressionTrackingManager.getWaitingViews().clear();
-
-        ImpressionTrackingManager.getPollingViews().put(view, new NativeResponseWrapper(nativeResponse));
-        ImpressionTrackingManager.getWaitingViews().put(view, mock(OnPreDrawListener.class));
-        assertThat(ImpressionTrackingManager.isViewTracked(view)).isTrue();
-    }
-    
-    @Test
-    public void waitForVisibility_shouldRemoveViewFromPollingHashMap() throws Exception {
-        ImpressionTrackingManager.getPollingViews().put(view, new NativeResponseWrapper(nativeResponse));
-        ImpressionTrackingManager.waitForVisibility(view, nativeResponse);
-
-        assertThat(ImpressionTrackingManager.getPollingViews()).isEmpty();
-    }
-
-    @Test
-    public void waitForVisibility_whenViewTreeObserverIsAliveIsTrue_shouldAddOnPreDrawListenerToViewTreeObserverAndPopulateWaitingViewsHashMap() throws Exception {
-        ViewTreeObserver mockViewTreeObserver = mock(ViewTreeObserver.class);
-        when(mockViewTreeObserver.isAlive()).thenReturn(true);
-        when(view.getViewTreeObserver()).thenReturn(mockViewTreeObserver);
-
-        ImpressionTrackingManager.waitForVisibility(view, nativeResponse);
-
-        verify(mockViewTreeObserver).addOnPreDrawListener(any(OnPreDrawListener.class));
-        assertThat(ImpressionTrackingManager.getWaitingViews().keySet()).containsOnly(view);
-    }
-
-    @Test
-    public void waitForVisibility_whenViewTreeObserverIsAliveIsFalse_shouldNotAddOnPreDrawListenerToViewTreeObserverAndNotPopulateWaitingViewsHashMap() throws Exception {
-        ViewTreeObserver mockViewTreeObserver = mock(ViewTreeObserver.class);
-        when(mockViewTreeObserver.isAlive()).thenReturn(false);
-        when(view.getViewTreeObserver()).thenReturn(mockViewTreeObserver);
-
-        ImpressionTrackingManager.waitForVisibility(view, nativeResponse);
-
-        verify(mockViewTreeObserver, never()).addOnPreDrawListener(any(OnPreDrawListener.class));
-        assertThat(ImpressionTrackingManager.getWaitingViews()).isEmpty();
-    }
-
-    @Test
-    public void waitForVisibility_onPreDrawListener_onPreDraw_withVisibleView_shouldAddViewToPollingHashMap() throws Exception {
-        ImpressionTrackingManager.waitForVisibility(view, nativeResponse);
-        view.getViewTreeObserver().dispatchOnPreDraw();
-
-        assertThat(ImpressionTrackingManager.getPollingViews().keySet()).containsOnly(view);
-    }
-
-    @Test
-    public void waitForVisibility_onPreDrawListener_onPreDraw_withNonVisibleView_shouldNotAddViewToPollingHashMap() throws Exception {
-        View view = getViewMock(View.INVISIBLE, 100, 100, 100, 100, true, true);
-        ImpressionTrackingManager.waitForVisibility(view, nativeResponse);
-        view.getViewTreeObserver().dispatchOnPreDraw();
-
-        assertThat(ImpressionTrackingManager.getPollingViews().keySet()).isEmpty();
-    }
-    
-    @Test
-    public void pollVisibleView_shouldRemoveViewFromWaitingHashMap_shouldAddViewToPollingHashMap_shouldScheduleNextPoll() throws Exception {
-        Robolectric.getUiThreadScheduler().pause();
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
-
-        ImpressionTrackingManager.getWaitingViews().put(view, mock(OnPreDrawListener.class));
-
-        ImpressionTrackingManager.pollVisibleView(view, nativeResponse);
-
-        assertThat(ImpressionTrackingManager.getWaitingViews()).isEmpty();
-        assertThat(ImpressionTrackingManager.getPollingViews()).hasSize(1);
-        assertThat(ImpressionTrackingManager.getPollingViews().get(view)).isNotNull();
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
-    }
-
-    @Test
-    public void scheduleNextPoll_withNoMessages_shouldSchedulePoll() throws Exception {
-        Robolectric.getUiThreadScheduler().pause();
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
-
-        ImpressionTrackingManager.scheduleNextPoll();
-
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
-    }
-
-    @Test
-    public void removeWaiting_shouldRemoveViewFromWaitingHashMapAndRemoveOnPreDrawListener() throws Exception {
-        ViewTreeObserver mockViewTreeObserver = mock(ViewTreeObserver.class);
-        when(mockViewTreeObserver.isAlive()).thenReturn(true);
-        when(view.getViewTreeObserver()).thenReturn(mockViewTreeObserver);
-
-        OnPreDrawListener onPreDrawListener = mock(OnPreDrawListener.class);
-        ImpressionTrackingManager.getWaitingViews().put(view, onPreDrawListener);
-
-        ImpressionTrackingManager.removeWaitingView(view);
-
-        assertThat(ImpressionTrackingManager.getWaitingViews().keySet()).isEmpty();
-        verify(mockViewTreeObserver).removeOnPreDrawListener(onPreDrawListener);
-    }
-
-    @Test
-    public void removeWaiting_withNullView_shouldDoNothing() throws Exception {
-        assertThat(ImpressionTrackingManager.getWaitingViews().keySet()).isEmpty();
-
-        ImpressionTrackingManager.removeWaitingView(null);
-
-        assertThat(ImpressionTrackingManager.getWaitingViews().keySet()).isEmpty();
-    }
-
-    @Test
-    public void removePolling_shouldRemoveViewFromPollingHashMap() throws Exception {
-        ImpressionTrackingManager.getPollingViews().put(view, nativeResponseWrapper);
-
-        ImpressionTrackingManager.removePollingView(view);
-
-        assertThat(ImpressionTrackingManager.getPollingViews()).isEmpty();
-    }
-
-    @Test
-    public void removePolling_withNullView_shouldDoNothing() throws Exception {
-        assertThat(ImpressionTrackingManager.getPollingViews()).isEmpty();
-
-        ImpressionTrackingManager.removePollingView(null);
-
-        assertThat(ImpressionTrackingManager.getPollingViews()).isEmpty();
-    }
-
-    @Test
-    public void removeView_shouldRemoveViewFromWaitingAndPollingViews() throws Exception {
-        ImpressionTrackingManager.addView(view, nativeResponse);
-        View view1 = getViewMock(View.GONE, 0, 0, 0, 0, true, false);
-        ImpressionTrackingManager.addView(view1, nativeResponse);
-
-        assertThat(ImpressionTrackingManager.getPollingViews()).hasSize(1);
-        assertThat(ImpressionTrackingManager.getWaitingViews()).hasSize(1);
-
-        ImpressionTrackingManager.removeView(view1);
-        assertThat(ImpressionTrackingManager.getPollingViews()).hasSize(1);
-       assertThat(ImpressionTrackingManager.getPollingViews().keySet()).containsOnly(view);
-        assertThat(ImpressionTrackingManager.getWaitingViews()).hasSize(0);
-
-        ImpressionTrackingManager.removeView(view);
-        assertThat(ImpressionTrackingManager.getPollingViews()).hasSize(0);
-        assertThat(ImpressionTrackingManager.getWaitingViews()).hasSize(0);
-    }
-
-    @Test
-    public void removeView_withEmptyPollingAndWaitingHashMaps_shouldDoNothing() throws Exception {
-        assertThat(ImpressionTrackingManager.getPollingViews()).isEmpty();
-        assertThat(ImpressionTrackingManager.getWaitingViews()).isEmpty();
-
-        ImpressionTrackingManager.removeView(view);
-
-        assertThat(ImpressionTrackingManager.getPollingViews()).isEmpty();
-        assertThat(ImpressionTrackingManager.getWaitingViews()).isEmpty();
-    }
-
-    @Test
-    public void removeView_whenViewIsNull_shouldDoNothing() throws Exception {
-        ImpressionTrackingManager.addView(view, nativeResponse);
-
-        assertThat(ImpressionTrackingManager.getPollingViews()).hasSize(1);
-        ImpressionTrackingManager.removeView(null);
-        assertThat(ImpressionTrackingManager.getPollingViews()).hasSize(1);
-    }
-
-    @Test
-    public void clearTracking_shouldClearWaitingAndPollingHashMaps_shouldClearHandlers() throws Exception {
-        ImpressionTrackingManager.getWaitingViews().put(view, mock(OnPreDrawListener.class));
-        ImpressionTrackingManager.getPollingViews().put(view, nativeResponseWrapper);
-
-        ImpressionTrackingManager.clearTracking();
-
-        assertThat(ImpressionTrackingManager.getWaitingViews()).isEmpty();
-        assertThat(ImpressionTrackingManager.getPollingViews()).isEmpty();
-
-    }
-
-    @Test
-    public void pollingRunnableRun_whenWrapperIsNull_shouldNotTrackImpression() throws Exception {
-        // This doesn't normally happen; perhaps we're being overly defensive
-        ImpressionTrackingManager.getPollingViews().put(view, null);
-
-        new PollingRunnable().run();
-        assertThat(nativeResponse.getRecordedImpression()).isFalse();
-        assertImpressionTracked(false);
-    }
-
-    @Test
-    public void pollingRunnableRun_whenNativeResponseIsNull_shouldNotTrackImpression() throws Exception {
-        // This doesn't normally happen; perhaps we're being overly defensive
-        ImpressionTrackingManager.getPollingViews().put(view, new NativeResponseWrapper(null));
-
-        new PollingRunnable().run();
-        assertThat(nativeResponse.getRecordedImpression()).isFalse();
-        assertImpressionTracked(false);
-    }
-
-    @Test
-    public void pollingRunnableRun_whenNativeResponseHasRecordedImpression_shouldNotTrackImpression() throws Exception {
-        nativeResponse.recordImpression(view);
-        assertImpressionTracked(true);
-
-        Robolectric.getFakeHttpLayer().clearRequestInfos();
-        reset(mopubNativeListener);
-
-        new PollingRunnable().run();
-        assertImpressionTracked(false);
-    }
-
-    @Test
-    public void pollingRunnableRun_whenNativeResponseHasBeenDestroyed_shouldNotTrackImpression() throws Exception {
-        nativeResponse.destroy();
-
-        Robolectric.getFakeHttpLayer().clearRequestInfos();
-        reset(mopubNativeListener);
-
-        new PollingRunnable().run();
-        assertImpressionTracked(false);
-    }
-
-    @Test
-    public void pollingRunnableRun_withNonVisibleView_shouldWaitForVisibility_shouldNotScheduleNextPoll() throws Exception {
-        View view = getViewMock(View.INVISIBLE, 100, 100, 100, 100, true, true);
-        ImpressionTrackingManager.getPollingViews().put(view, nativeResponseWrapper);
-
-        new PollingRunnable().run();
-
-        assertThat(nativeResponse.getRecordedImpression()).isFalse();
-        assertImpressionTracked(false);
-
-        assertThat(ImpressionTrackingManager.getPollingViews()).isEmpty();
-        assertThat(ImpressionTrackingManager.getWaitingViews().keySet()).containsOnly(view);
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
-    }
-
-    @Test
-    public void pollingRunnableRun_whenLessThanOneSecondHasElapsed_shouldNotTrackImpression_shouldScheduleNextPoll() throws Exception {
-        // Force the last viewed timestamp to be a known value
-        nativeResponseWrapper.mFirstVisibleTimestamp = 5555;
-        ImpressionTrackingManager.getPollingViews().put(view, nativeResponseWrapper);
-
-        // We progress 999 milliseconds
-        Robolectric.getUiThreadScheduler().advanceBy(5555 + 999);
-        new PollingRunnable().run();
-
-        assertThat(nativeResponse.getRecordedImpression()).isFalse();
-        assertImpressionTracked(false);
-
-        assertThat(ImpressionTrackingManager.getPollingViews().keySet()).containsOnly(view);
-        assertThat(ImpressionTrackingManager.getWaitingViews()).isEmpty();
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(1);
-    }
-
-    @Test
-    public void pollingRunnableRun_whenMoreThanOneSecondHasElapsed_shouldTrackImpression_shouldNotScheduleNextPoll() throws Exception {
-        // Force the last viewed timestamp to be a known value
-        nativeResponseWrapper.mFirstVisibleTimestamp = 5555;
-        ImpressionTrackingManager.getPollingViews().put(view, nativeResponseWrapper);
-
-        // We progress 1000 milliseconds
-        Robolectric.getUiThreadScheduler().advanceBy(5555 + 1000);
-        new PollingRunnable().run();
-
-        assertThat(nativeResponse.getRecordedImpression()).isTrue();
-        assertImpressionTracked(true);
-
-        assertThat(ImpressionTrackingManager.getPollingViews()).isEmpty();
-        assertThat(ImpressionTrackingManager.getWaitingViews()).isEmpty();
-        assertThat(Robolectric.getUiThreadScheduler().enqueuedTaskCount()).isEqualTo(0);
-    }
-
-    @Test
-    public void isMostlyVisible_whenParentIsNull_shouldReturnFalse() throws Exception {
-        view = getViewMock(View.VISIBLE, 100, 100, 100, 100, false, true);
-        assertThat(isMostlyVisible(view, IMPRESSION_MIN_PERCENTAGE_VIEWED)).isFalse();
-    }
-
-    @Test
-    public void isMostlyVisible_whenViewIsOffScreen_shouldReturnFalse() throws Exception {
-        view = getViewMock(View.VISIBLE, 100, 100, 100, 100, true, false);
-        assertThat(isMostlyVisible(view, IMPRESSION_MIN_PERCENTAGE_VIEWED)).isFalse();
-    }
-
-
-    @Test
-    public void isMostlyVisible_whenViewIsEntirelyOnScreen_shouldReturnTrue() throws Exception {
-        view = getViewMock(View.VISIBLE, 100, 100, 100, 100, true, true);
-
-        assertThat(isMostlyVisible(view, IMPRESSION_MIN_PERCENTAGE_VIEWED)).isTrue();
-    }
-
-    @Test
-    public void isMostlyVisible_whenViewIs50PercentVisible_shouldReturnTrue() throws Exception {
-        view = getViewMock(View.VISIBLE, 50, 100, 100, 100, true, true);
-
-        assertThat(isMostlyVisible(view, IMPRESSION_MIN_PERCENTAGE_VIEWED)).isTrue();
-    }
-
-    @Test
-    public void isMostlyVisible_whenViewIs49PercentVisible_shouldReturnFalse() throws Exception {
-        view = getViewMock(View.VISIBLE, 49, 100, 100, 100, true, true);
-
-        assertThat(isMostlyVisible(view, IMPRESSION_MIN_PERCENTAGE_VIEWED)).isFalse();
-    }
-
-    @Test
-    public void isMostlyVisible_whenVisibleAreaIsZero_shouldReturnFalse() throws Exception {
-        view = getViewMock(View.VISIBLE, 0, 0, 100, 100, true, true);
-
-        assertThat(isMostlyVisible(view, IMPRESSION_MIN_PERCENTAGE_VIEWED)).isFalse();
-    }
-
-    @Test
-    public void isMostlyVisible_whenViewIsInvisibleOrGone_shouldReturnFalse() throws Exception {
-        View view = getViewMock(View.INVISIBLE, 100, 100, 100, 100, true, true);
-        assertThat(isMostlyVisible(view, IMPRESSION_MIN_PERCENTAGE_VIEWED)).isFalse();
-
-        reset(view);
-        view = getViewMock(View.GONE, 100, 100, 100, 100, true, true);
-        assertThat(isMostlyVisible(view, IMPRESSION_MIN_PERCENTAGE_VIEWED)).isFalse();
-    }
-
-    @Test
-    public void isMostlyVisible_whenViewHasZeroWidthAndHeight_shouldReturnFalse() throws Exception {
-        view = getViewMock(View.VISIBLE, 100, 100, 0, 0, true, true);
-
-        assertThat(isMostlyVisible(view, IMPRESSION_MIN_PERCENTAGE_VIEWED)).isFalse();
-    }
-
-    @Test
-    public void isMostlyVisible_whenViewIsNull_shouldReturnFalse() throws Exception {
-        assertThat(isMostlyVisible(null, IMPRESSION_MIN_PERCENTAGE_VIEWED)).isFalse();
-    }
-
-    static View getViewMock(final int visibility,
-            final int visibleWidth, final int visibleHeight,
-            final int viewWidth, final int viewHeight,
-            final boolean isParentSet, final boolean isOnScreen) {
-        View view = mock(View.class);
-        when(view.getContext()).thenReturn(new Activity());
-        when(view.getVisibility()).thenReturn(visibility);
-
-        when(view.getGlobalVisibleRect(any(Rect.class)))
-                .thenAnswer(new Answer<Boolean>() {
-                    @Override
-                    public Boolean answer(InvocationOnMock invocationOnMock) throws Throwable {
-                        Object[] args = invocationOnMock.getArguments();
-                        Rect rect = (Rect) args[0];
-                        rect.set(0, 0, visibleWidth, visibleHeight);
-                        return isOnScreen;
-                    }
-                });
-
-        when(view.getWidth()).thenReturn(viewWidth);
-        when(view.getHeight()).thenReturn(viewHeight);
-        if (isParentSet) {
-            when(view.getParent()).thenReturn(mock(ViewParent.class));
-        }
-
-        when(view.getViewTreeObserver()).thenCallRealMethod();
-
-        return view;
-    }
-
-    private void assertImpressionTracked(final boolean wasTracked) {
-        // Ensure that we fired off the HttpGets for each of the impression trackers
-        if (wasTracked) {
-            assertThat(Robolectric.getFakeHttpLayer().getSentHttpRequestInfos().size()).isEqualTo(1);
-            final String actualUri = Robolectric.getFakeHttpLayer().getLastSentHttpRequestInfo().getHttpRequest().getRequestLine().getUri();
-            assertThat(actualUri).isEqualTo(IMPRESSION_TRACKER);
-            verify(mopubNativeListener).onNativeImpression(view);
-        } else {
-            assertThat(Robolectric.getFakeHttpLayer().getLastSentHttpRequestInfo()).isNull();
-            verify(mopubNativeListener, never()).onNativeImpression(view);
-        }
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubAdAdapterTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubAdAdapterTest.java
new file mode 100644
index 00000000..11c28870
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubAdAdapterTest.java
@@ -0,0 +1,145 @@
+package com.mopub.nativeads;
+
+import android.database.DataSetObserver;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.BaseAdapter;
+
+import com.mopub.nativeads.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.annotation.Config;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.AdditionalMatchers.leq;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@Config(manifest=Config.NONE)
+@RunWith(SdkTestRunner.class)
+public class MoPubAdAdapterTest {
+
+    @Mock
+    public BaseAdapter mockOriginalAdapter;
+    @Mock
+    public MoPubStreamAdPlacer mockStreamAdPlacer;
+    @Mock
+    public Object mockItem;
+    @Mock
+    public NativeAdData mockAd;
+    @Mock
+    public View mockAdView;
+    @Mock
+    public View mockItemView;
+    @Mock
+    public VisibilityTracker mockVisibilityTracker;
+    @Mock
+    public MoPubNativeAdLoadedListener mockAdLoadedListener;
+    @Mock
+    public DataSetObserver mockDataSetObserver;
+
+    public MoPubAdAdapter subject;
+
+    private static final int AD_POSITION = 4;
+
+    @Before
+    public void setup() {
+
+        // Mock setup code.
+        when(mockOriginalAdapter.getViewTypeCount()).thenReturn(1);
+        when(mockOriginalAdapter.getCount()).thenReturn(30);
+        when(mockOriginalAdapter.getItem(leq(29))).thenReturn(mockItem);
+        when(mockOriginalAdapter.getView(anyInt(), any(View.class), any(ViewGroup.class))).thenReturn(mockItemView);
+
+        when(mockStreamAdPlacer.getAdData(AD_POSITION)).thenReturn(mockAd);
+        when(mockStreamAdPlacer.getAdView(eq(AD_POSITION), any(View.class), any(ViewGroup.class))).thenReturn(mockAdView);
+
+        // Mock some adjustment behavior for tests.
+        when(mockStreamAdPlacer.getOriginalPosition(eq(1))).thenReturn(1);
+        when(mockStreamAdPlacer.getOriginalPosition(eq(8))).thenReturn(7);
+        when(mockStreamAdPlacer.getAdjustedCount(eq(30))).thenReturn(31);
+
+        subject = new MoPubAdAdapter(mockStreamAdPlacer, mockOriginalAdapter, mockVisibilityTracker);
+    }
+
+    @Test
+    public void getItem_shouldCallAdPlacer() throws Exception {
+        assertThat(subject.getItem(AD_POSITION)).isEqualTo(mockAd);
+        verify(mockStreamAdPlacer, never()).getOriginalPosition(AD_POSITION);
+        verify(mockStreamAdPlacer).getAdData(AD_POSITION);
+    }
+
+    @Test
+    public void getItem_shouldCallOriginalAdapter() throws Exception {
+        assertThat(subject.getItem(1)).isEqualTo(mockItem);
+        verify(mockStreamAdPlacer).getOriginalPosition(1);
+        verify(mockOriginalAdapter).getItem(1);
+
+        assertThat(subject.getItem(8)).isEqualTo(mockItem);
+        verify(mockStreamAdPlacer).getOriginalPosition(8);
+        verify(mockOriginalAdapter).getItem(7);
+    }
+
+    @Test
+    public void getCount_shouldCallAdPlacer() throws Exception {
+        assertThat(subject.getCount()).isEqualTo(31);
+        verify(mockStreamAdPlacer).getAdjustedCount(30);
+    }
+
+    @Test
+    public void getItemIdForAd_shouldBeNegative() throws Exception {
+        assertThat(subject.getItemId(AD_POSITION)).isLessThan(0);
+    }
+    
+    @Test
+    public void destroy_shouldDestroyStreamAdPlacer_shouldDestroyVisibilityTracker() {
+        subject.destroy();
+        verify(mockStreamAdPlacer).destroy();
+        verify(mockVisibilityTracker).destroy();
+    }
+
+    @Test
+    public void setAdLoadedListener_handleAdLoaded_shouldCallCallback_shouldCallObserver() {
+        subject.setAdLoadedListener(mockAdLoadedListener);
+        subject.registerDataSetObserver(mockDataSetObserver);
+
+        subject.handleAdLoaded(8);
+        verify(mockAdLoadedListener).onAdLoaded(8);
+        verify(mockDataSetObserver).onChanged();
+    }
+
+    @Test
+    public void setAdLoadedListener_handleAdRemoved_shouldCallCallback_shouldCallObserver() {
+        subject.setAdLoadedListener(mockAdLoadedListener);
+        subject.registerDataSetObserver(mockDataSetObserver);
+
+        subject.handleAdRemoved(10);
+        verify(mockAdLoadedListener).onAdRemoved(10);
+        verify(mockDataSetObserver).onChanged();
+    }
+
+    @Test
+    public void insertItem_shouldCallInsertItemOnStreamAdPlacer() throws Exception {
+        subject.insertItem(5);
+        verify(mockStreamAdPlacer).insertItem(5);
+    }
+
+    @Test
+    public void removeItem_shouldCallRemoveItemOnStreamAdPlacer() throws Exception {
+        subject.removeItem(5);
+        verify(mockStreamAdPlacer).removeItem(5);
+    }
+
+    @Test
+    public void getOriginalPosition_shouldCallGetOriginalPositionOnStreamAdPlacer() throws Exception {
+        subject.getOriginalPosition(5);
+        verify(mockStreamAdPlacer).getOriginalPosition(5);
+    }
+}
\ No newline at end of file
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubCustomEventNativeTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubCustomEventNativeTest.java
index 1dd83d8b..c0598add 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubCustomEventNativeTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubCustomEventNativeTest.java
@@ -3,6 +3,7 @@
 import android.app.Activity;
 
 import com.mopub.common.CacheService;
+import com.mopub.nativeads.test.support.MoPubShadowBitmap;
 import com.mopub.nativeads.test.support.SdkTestRunner;
 
 import org.apache.http.HttpRequest;
@@ -13,6 +14,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
 import org.robolectric.tester.org.apache.http.FakeHttpLayer;
 import org.robolectric.tester.org.apache.http.RequestMatcher;
 import org.robolectric.tester.org.apache.http.TestHttpResponse;
@@ -28,6 +30,7 @@
 import static org.mockito.Mockito.verify;
 
 @RunWith(SdkTestRunner.class)
+@Config(shadows={MoPubShadowBitmap.class})
 public class MoPubCustomEventNativeTest {
 
     private MoPubCustomEventNative subject;
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeAdPositioningTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeAdPositioningTest.java
new file mode 100644
index 00000000..4072e562
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeAdPositioningTest.java
@@ -0,0 +1,81 @@
+package com.mopub.nativeads;
+
+import com.mopub.nativeads.test.support.SdkTestRunner;
+
+import org.fest.util.Lists;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+
+import static com.mopub.nativeads.MoPubNativeAdPositioning.NO_REPEAT;
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@Config(manifest=Config.NONE)
+@RunWith(SdkTestRunner.class)
+public class MoPubNativeAdPositioningTest {
+
+    private MoPubNativeAdPositioning.Builder subject;
+
+    @Before
+    public void setup() {
+        subject = MoPubNativeAdPositioning.newBuilder();
+    }
+
+    @Test
+    public void addFixedPositionsOutOfOrder_shouldBeSorted() throws Exception {
+        subject.addFixedPosition(27);
+        subject.addFixedPosition(31);
+        subject.addFixedPosition(17);
+        subject.addFixedPosition(7);
+        subject.addFixedPosition(56);
+
+        assertThat(subject.build().getFixedPositions())
+                .isEqualTo(Lists.newArrayList(7, 17, 27, 31, 56));
+    }
+
+    @Test
+    public void setRepeatingEnabled_shouldHaveRightInterval() throws Exception {
+        subject.addFixedPosition(10);
+        subject.enableRepeatingPositions(5);
+
+        assertThat(subject.build().getRepeatingInterval()).isEqualTo(5);
+        assertThat(subject.build().getFixedPositions()).isEqualTo(Lists.newArrayList(10));
+    }
+
+    @Test
+    public void setNoRepeat_shouldReturnNoRepeat() throws Exception {
+        subject.enableRepeatingPositions(5);
+        subject.enableRepeatingPositions(NO_REPEAT);
+
+        assertThat(subject.build().getRepeatingInterval()).isEqualTo(NO_REPEAT);
+    }
+
+    @Test
+    public void setAdUnitOverrides_shouldReturnOverrides() throws Exception {
+        subject.addFixedPosition(7);
+        subject.addFixedPosition(13, "override");
+
+        MoPubNativeAdPositioning underTest = subject.build();
+        assertThat(underTest.getAdUnitIdOverride(2)).isNull();  // Nonexistent ad position.
+        assertThat(underTest.getAdUnitIdOverride(7)).isNull();
+        assertThat(underTest.getAdUnitIdOverride(13)).isEqualTo("override");
+    }
+    
+    @Test
+    public void setFixedPositionTwice_shouldReturnOnlyOne() throws Exception {
+        subject.addFixedPosition(7, "override");
+        subject.addFixedPosition(7);
+
+        MoPubNativeAdPositioning underTest = subject.build();
+        assertThat(underTest.getFixedPositions().size()).isEqualTo(1);
+        assertThat(underTest.getAdUnitIdOverride(7)).isEqualTo(null);
+    }
+
+    @Test
+    public void setInvalidFixedPosition_shouldNotAdd() throws Exception {
+        subject.addFixedPosition(-3);
+
+        assertThat(subject.build().getFixedPositions().size()).isEqualTo(0);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeAdRendererTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeAdRendererTest.java
new file mode 100644
index 00000000..b2ebc878
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeAdRendererTest.java
@@ -0,0 +1,231 @@
+package com.mopub.nativeads;
+
+import android.app.Activity;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.Button;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.RelativeLayout;
+import android.widget.TextView;
+
+import com.mopub.common.DownloadResponse;
+import com.mopub.common.util.ResponseHeader;
+import com.mopub.common.util.Utils;
+import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
+import com.mopub.nativeads.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+
+import static com.mopub.nativeads.MoPubNative.MoPubNativeListener;
+import static com.mopub.nativeads.MoPubNativeAdRenderer.NativeViewClickListener;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+
+@RunWith(SdkTestRunner.class)
+public class MoPubNativeAdRendererTest {
+    private MoPubNativeAdRenderer subject;
+    private Activity context;
+    private RelativeLayout relativeLayout;
+    private ViewGroup viewGroup;
+    private NativeResponse nativeResponse;
+    private BaseForwardingNativeAd mNativeAd;
+    private ViewBinder viewBinder;
+    private TextView titleView;
+    private TextView textView;
+    private TextView callToActionView;
+    private ImageView mainImageView;
+    private ImageView iconImageView;
+    private ImageView badView;
+
+    @Before
+    public void setUp() throws Exception {
+        context = new Activity();
+        relativeLayout = new RelativeLayout(context);
+        relativeLayout.setId((int) Utils.generateUniqueId());
+        viewGroup = new LinearLayout(context);
+
+        mNativeAd = new BaseForwardingNativeAd() {};
+        mNativeAd.setTitle("test title");
+        mNativeAd.setText("test text");
+        mNativeAd.setCallToAction("test call to action");
+        mNativeAd.setClickDestinationUrl("destinationUrl");
+
+        final TestHttpResponseWithHeaders testHttpResponseWithHeaders = new TestHttpResponseWithHeaders(200, "");
+        testHttpResponseWithHeaders.addHeader(ResponseHeader.CLICKTHROUGH_URL.getKey(), "clickTrackerUrl");
+        final DownloadResponse downloadResponse = new DownloadResponse(testHttpResponseWithHeaders);
+        nativeResponse = new NativeResponse(context, downloadResponse, "test ID", mNativeAd, mock(MoPubNativeListener.class));
+
+        titleView = new TextView(context);
+        titleView.setId((int) Utils.generateUniqueId());
+        textView = new TextView(context);
+        textView.setId((int) Utils.generateUniqueId());
+        callToActionView = new Button(context);
+        callToActionView.setId((int) Utils.generateUniqueId());
+        mainImageView = new ImageView(context);
+        mainImageView.setId((int) Utils.generateUniqueId());
+        iconImageView = new ImageView(context);
+        iconImageView.setId((int) Utils.generateUniqueId());
+        badView = new ImageView(context);
+        badView.setId((int) Utils.generateUniqueId());
+
+        relativeLayout.addView(titleView);
+        relativeLayout.addView(textView);
+        relativeLayout.addView(callToActionView);
+        relativeLayout.addView(mainImageView);
+        relativeLayout.addView(iconImageView);
+        relativeLayout.addView(badView);
+
+        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
+                .titleId(titleView.getId())
+                .textId(textView.getId())
+                .callToActionId(callToActionView.getId())
+                .mainImageId(mainImageView.getId())
+                .iconImageId(iconImageView.getId())
+                .build();
+
+        subject = new MoPubNativeAdRenderer(viewBinder);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void createAdView_withNullContext_shouldThrowNPE() {
+        subject.createAdView(null, viewGroup);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void renderAdView_withNullView_shouldThrowNPE() {
+        subject.renderAdView(null, nativeResponse);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void renderAdView_withNullNativeResponse_shouldThrowNPE() {
+        subject.renderAdView(relativeLayout, null);
+    }
+
+    @Rule public ExpectedException exception = ExpectedException.none();
+    public void renderAdView_withNullViewBinder_shouldThrowNPE() {
+        subject = new MoPubNativeAdRenderer(null);
+
+        exception.expect(NullPointerException.class);
+        subject.renderAdView(relativeLayout, nativeResponse);
+    }
+
+    @Test
+    public void renderAdView_shouldReturnPopulatedView() {
+        subject.renderAdView(relativeLayout, nativeResponse);
+
+        assertThat(((TextView)relativeLayout.findViewById(titleView.getId())).getText()).isEqualTo("test title");
+        assertThat(((TextView)relativeLayout.findViewById(textView.getId())).getText()).isEqualTo(
+                "test text");
+        assertThat(((TextView)relativeLayout.findViewById(callToActionView.getId())).getText()).isEqualTo("test call to action");
+
+        // not testing images due to testing complexity
+    }
+
+    @Test
+    public void renderAdView_withFailedViewBinder_shouldReturnFast() {
+        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
+                .titleId(titleView.getId())
+                .textId(badView.getId())
+                .callToActionId(callToActionView.getId())
+                .mainImageId(mainImageView.getId())
+                .iconImageId(iconImageView.getId())
+                .build();
+
+        subject = new MoPubNativeAdRenderer(viewBinder);
+        subject.renderAdView(relativeLayout, nativeResponse);
+
+        assertThat(((TextView)relativeLayout.findViewById(titleView.getId())).getText()).isEqualTo("");
+        assertThat(((TextView)relativeLayout.findViewById(textView.getId())).getText()).isEqualTo(
+                "");
+        assertThat(((TextView)relativeLayout.findViewById(callToActionView.getId())).getText()).isEqualTo(
+                "");
+    }
+
+    @Test
+    public void renderAdView_whenCallToActionIsAButton_shouldAttachClickListenersToConvertViewAndCtaButton() {
+        assertThat(relativeLayout.performClick()).isFalse();
+        assertThat(callToActionView.performClick()).isFalse();
+
+        subject.renderAdView(relativeLayout, nativeResponse);
+
+        assertThat(relativeLayout.performClick()).isTrue();
+        assertThat(callToActionView.performClick()).isTrue();
+    }
+
+    @Test
+    public void renderAdView_whenCallToActionIsATextView_shouldAttachClickListenersToConvertViewOnly() {
+        relativeLayout.removeView(callToActionView);
+        callToActionView = new TextView(context);
+        callToActionView.setId((int) Utils.generateUniqueId());
+        relativeLayout.addView(callToActionView);
+
+        assertThat(relativeLayout.performClick()).isFalse();
+        assertThat(callToActionView.performClick()).isFalse();
+
+        subject.renderAdView(relativeLayout, nativeResponse);
+
+        assertThat(relativeLayout.performClick()).isTrue();
+        assertThat(callToActionView.performClick()).isFalse();
+    }
+
+    @Test
+    public void getOrCreateNativeViewHolder_withNoViewHolder_shouldCreateNativeViewHolder() {
+        final NativeViewHolder viewHolder =
+                subject.getOrCreateNativeViewHolder(relativeLayout, viewBinder);
+
+        final NativeViewHolder expectedViewHolder =
+                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
+        compareNativeViewHolders(expectedViewHolder, viewHolder);
+    }
+
+    @Test
+    public void getOrCreateNativeViewHolder_withViewHolder_shouldNotReCreateNativeViewHolder() {
+        final NativeViewHolder viewHolder =
+                subject.getOrCreateNativeViewHolder(relativeLayout, viewBinder);
+
+        assertThat(subject.getOrCreateNativeViewHolder(relativeLayout, viewBinder))
+                .isEqualTo(viewHolder);
+    }
+
+    // NativeViewClickListener tests
+
+    @Test
+    public void onClick_shouldQueueClickTrackerAndUrlResolutionTasks() {
+        NativeViewClickListener nativeViewClickListener = new NativeViewClickListener(nativeResponse);
+
+        Robolectric.getBackgroundScheduler().pause();
+        assertThat(Robolectric.getBackgroundScheduler().enqueuedTaskCount()).isEqualTo(0);
+        nativeViewClickListener.onClick(new View(context));
+
+        assertThat(Robolectric.getBackgroundScheduler().enqueuedTaskCount()).isEqualTo(2);
+    }
+
+    @Test
+    public void onClick_withNullDestinationUrl_shouldNotQueueUrlResolutionTask() {
+        mNativeAd.setClickDestinationUrl(null);
+
+        NativeViewClickListener nativeViewClickListener = new NativeViewClickListener(nativeResponse);
+
+        Robolectric.getBackgroundScheduler().pause();
+        assertThat(Robolectric.getBackgroundScheduler().enqueuedTaskCount()).isEqualTo(0);
+        nativeViewClickListener.onClick(new View(context));
+
+        // 1 task for async ping to click tracker
+        assertThat(Robolectric.getBackgroundScheduler().enqueuedTaskCount()).isEqualTo(1);
+    }
+
+    static private void compareNativeViewHolders(final NativeViewHolder actualViewHolder,
+            final NativeViewHolder expectedViewHolder) {
+        assertThat(actualViewHolder.titleView).isEqualTo(expectedViewHolder.titleView);
+        assertThat(actualViewHolder.textView).isEqualTo(expectedViewHolder.textView);
+        assertThat(actualViewHolder.callToActionView).isEqualTo(expectedViewHolder.callToActionView);
+        assertThat(actualViewHolder.mainImageView).isEqualTo(expectedViewHolder.mainImageView);
+        assertThat(actualViewHolder.iconImageView).isEqualTo(expectedViewHolder.iconImageView);
+    }
+}
\ No newline at end of file
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeTest.java
index ea6073a5..23eeab83 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeTest.java
@@ -8,6 +8,8 @@
 import com.mopub.common.SharedPreferencesHelper;
 import com.mopub.common.util.test.support.ShadowAsyncTasks;
 import com.mopub.common.util.test.support.TestMethodBuilderFactory;
+import com.mopub.nativeads.MoPubNative.MoPubNativeEventListener;
+import com.mopub.nativeads.MoPubNative.MoPubNativeNetworkListener;
 import com.mopub.nativeads.test.support.SdkTestRunner;
 
 import org.apache.http.client.methods.HttpGet;
@@ -16,6 +18,7 @@
 import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.robolectric.Robolectric;
@@ -27,7 +30,8 @@
 import static android.Manifest.permission.ACCESS_NETWORK_STATE;
 import static android.Manifest.permission.INTERNET;
 import static com.mopub.common.util.Reflection.MethodBuilder;
-import static com.mopub.nativeads.MoPubNative.MoPubNativeListener;
+import static com.mopub.nativeads.MoPubNative.EMPTY_EVENT_LISTENER;
+import static com.mopub.nativeads.MoPubNative.EMPTY_NETWORK_LISTENER;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.doAnswer;
@@ -47,15 +51,17 @@
     private MoPubNative.NativeGpsHelperListener nativeGpsHelperListener;
     private Semaphore semaphore;
     private static final String adUnitId = "test_adunit_id";
-    private MoPubNativeListener moPubNativeListener;
+    
+    @Mock private MoPubNativeEventListener mockEventListener;
 
+    @Mock private MoPubNativeNetworkListener mockNetworkListener;
+    
     @Before
     public void setup() {
         context = new Activity();
         shadowOf(context).grantPermissions(ACCESS_NETWORK_STATE);
         shadowOf(context).grantPermissions(INTERNET);
-        moPubNativeListener = mock(MoPubNativeListener.class);
-        subject = new MoPubNative(context, adUnitId, moPubNativeListener);
+        subject = new MoPubNative(context, adUnitId, mockNetworkListener);
         methodBuilder = TestMethodBuilderFactory.getSingletonMock();
         nativeGpsHelperListener = mock(MoPubNative.NativeGpsHelperListener.class);
         semaphore = new Semaphore(0);
@@ -69,13 +75,14 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
     }
 
     @After
-    public void tearDown() throws Exception {
+    public void tearDown() {
         reset(methodBuilder);
     }
 
     @Ignore("fix concurrency issues")
     @Test
-    public void makeRequest_whenGooglePlayServicesIsLinkedAndAdInfoIsNotCached_shouldCacheAdInfoBeforeFetchingAd() throws Exception {
+    public void
+    makeRequest_whenGooglePlayServicesIsLinkedAndAdInfoIsNotCached_shouldCacheAdInfoBeforeFetchingAd() throws Exception {
         SharedPreferencesHelper.getSharedPreferences(context).edit().clear().commit();
         GpsHelperTest.verifyCleanSharedPreferences(context);
 
@@ -154,19 +161,32 @@ public void makeRequest_whenGooglePlayServicesIsLinkedAndAdInfoIsCached_shouldFe
     }
 
     @Test
-    public void destroy_shouldSetMoPubNativeListenerToEmptyAndClearContext() throws Exception {
+    public void destroy_shouldSetListenersToEmptyAndClearContext() {
         assertThat(subject.getContextOrDestroy()).isSameAs(context);
-        assertThat(subject.getMoPubNativeListener()).isSameAs(moPubNativeListener);
+        assertThat(subject.getMoPubNativeNetworkListener()).isSameAs(mockNetworkListener);
+        subject.setNativeEventListener(mockEventListener);
+        assertThat(subject.getMoPubNativeEventListener()).isSameAs(mockEventListener);
 
         subject.destroy();
 
         assertThat(subject.getContextOrDestroy()).isNull();
-        assertThat(subject.getMoPubNativeListener()).isSameAs(MoPubNativeListener.EMPTY_MOPUB_NATIVE_LISTENER);
+        assertThat(subject.getMoPubNativeNetworkListener()).isSameAs(EMPTY_NETWORK_LISTENER);
+        assertThat(subject.getMoPubNativeEventListener()).isSameAs(EMPTY_EVENT_LISTENER);
+    }
+
+    @Test
+    public void setNativeEventListener_shouldSetListener() {
+        assertThat(subject.getMoPubNativeNetworkListener()).isSameAs(mockNetworkListener);
+        subject.setNativeEventListener(mockEventListener);
+        assertThat(subject.getMoPubNativeEventListener()).isSameAs(mockEventListener);
+
+        subject.setNativeEventListener(null);
+        assertThat(subject.getMoPubNativeEventListener()).isSameAs(EMPTY_EVENT_LISTENER);
     }
 
     @Ignore("pending")
     @Test
-    public void loadNativeAd_shouldQueueAsyncDownloadTask() throws Exception {
+    public void loadNativeAd_shouldQueueAsyncDownloadTask() {
         Robolectric.getUiThreadScheduler().pause();
 
         subject.loadNativeAd(null);
@@ -175,7 +195,7 @@ public void loadNativeAd_shouldQueueAsyncDownloadTask() throws Exception {
     }
 
     @Test
-    public void loadNativeAd_shouldReturnFast() throws Exception {
+    public void loadNativeAd_shouldReturnFast() {
         Robolectric.getUiThreadScheduler().pause();
 
         subject.destroy();
@@ -185,13 +205,13 @@ public void loadNativeAd_shouldReturnFast() throws Exception {
     }
 
     @Test
-    public void requestNativeAd_withValidUrl_shouldStartDownloadTaskWithUrl() throws Exception {
+    public void requestNativeAd_withValidUrl_shouldStartDownloadTaskWithUrl() {
         Robolectric.getUiThreadScheduler().pause();
         Robolectric.addPendingHttpResponse(200, "body");
 
         subject.requestNativeAd("http://www.mopub.com");
 
-        verify(moPubNativeListener, never()).onNativeFail(any(NativeErrorCode.class));
+        verify(mockNetworkListener, never()).onNativeFail(any(NativeErrorCode.class));
         assertThat(wasDownloadTaskExecuted()).isTrue();
 
         List<?> latestParams = ShadowAsyncTasks.getLatestParams();
@@ -201,22 +221,22 @@ public void requestNativeAd_withValidUrl_shouldStartDownloadTaskWithUrl() throws
     }
 
     @Test
-    public void requestNativeAd_withInvalidUrl_shouldFireNativeFailAndNotStartAsyncTask() throws Exception {
+    public void requestNativeAd_withInvalidUrl_shouldFireNativeFailAndNotStartAsyncTask() {
         Robolectric.getUiThreadScheduler().pause();
 
         subject.requestNativeAd("//\\//\\::::");
 
-        verify(moPubNativeListener).onNativeFail(any(NativeErrorCode.class));
+        verify(mockNetworkListener).onNativeFail(any(NativeErrorCode.class));
         assertThat(wasDownloadTaskExecuted()).isFalse();
     }
 
     @Test
-    public void requestNativeAd_withNullUrl_shouldFireNativeFailAndNotStartAsyncTask() throws Exception {
+    public void requestNativeAd_withNullUrl_shouldFireNativeFailAndNotStartAsyncTask() {
         Robolectric.getUiThreadScheduler().pause();
 
         subject.requestNativeAd(null);
 
-        verify(moPubNativeListener).onNativeFail(any(NativeErrorCode.class));
+        verify(mockNetworkListener).onNativeFail(any(NativeErrorCode.class));
         assertThat(wasDownloadTaskExecuted()).isFalse();
     }
 
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubStreamAdPlacerTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubStreamAdPlacerTest.java
new file mode 100644
index 00000000..4922b179
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubStreamAdPlacerTest.java
@@ -0,0 +1,340 @@
+package com.mopub.nativeads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.view.View;
+import android.view.ViewGroup;
+
+import com.mopub.nativeads.NativeAdSource.AdSourceListener;
+import com.mopub.nativeads.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Answers;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.robolectric.Robolectric;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class MoPubStreamAdPlacerTest {
+    private Context context;
+
+    PlacementData placementData;
+
+    @Mock
+    NativeAdSource mockAdSource;
+    @Mock
+    MoPubNativeAdRenderer mockAdRenderer;
+    @Mock
+    MoPubNativeAdLoadedListener mockAdLoadedListener;
+    @Mock
+    ImpressionTracker mockImpressionTracker;
+
+    @Mock(answer = Answers.RETURNS_DEEP_STUBS)
+    NativeResponse stubNativeResponse;
+
+    private MoPubStreamAdPlacer subject;
+
+    @Before
+    public void setup() {
+        context = new Activity();
+
+        // Repeating every 5 positions
+        placementData = PlacementData.fromAdPositioning(MoPubNativeAdPositioning.newBuilder()
+                .enableRepeatingPositions(2)
+                .build());
+
+        subject = new MoPubStreamAdPlacer(context, mockAdSource, mockImpressionTracker, placementData);
+        subject.registerAdRenderer(mockAdRenderer);
+        subject.setAdLoadedListener(mockAdLoadedListener);
+    }
+
+    @Test
+    public void isAd_initialState_hasNoAds() {
+        assertThat(subject.isAd(0)).isFalse();
+        assertThat(subject.isAd(1)).isFalse();
+        assertThat(subject.isAd(2)).isFalse();
+        assertThat(subject.isAd(3)).isFalse();
+        assertThat(subject.isAd(4)).isFalse();
+    }
+
+    @Test
+    public void isAd_placeAdsWithNoAdsAvailable_hasNoAds() {
+        subject.setItemCount(4);
+
+        assertThat(subject.isAd(0)).isFalse();
+        assertThat(subject.isAd(1)).isFalse();
+        assertThat(subject.isAd(2)).isFalse();
+        assertThat(subject.isAd(3)).isFalse();
+        assertThat(subject.isAd(4)).isFalse();
+    }
+
+    @Test
+    public void isAd_placeAdsWithAdsAvailable_hasAds() {
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.setItemCount(4);  // Will place ads at positions 1, 3, and 5
+
+        assertThat(subject.isAd(0)).isFalse();
+        assertThat(subject.isAd(1)).isTrue();
+        assertThat(subject.isAd(2)).isFalse();
+        assertThat(subject.isAd(3)).isTrue();
+        assertThat(subject.isAd(4)).isFalse();
+    }
+
+    @Test
+    public void getAdData_placeAdsWithAdsAvailable_hasAds() {
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.setItemCount(4);  // Will place ads at positions 1, 3, and 5
+
+        assertThat(subject.getAdData(0)).isNull();
+        assertThat(subject.getAdData(1)).isNotNull();
+        assertThat(subject.getAdData(2)).isNull();
+        assertThat(subject.getAdData(3)).isNotNull();
+        assertThat(subject.getAdData(4)).isNull();
+    }
+
+    @Test
+    public void getOriginalPosition_adjustsPositions() {
+        assertThat(subject.getOriginalPosition(0)).isEqualTo(0);
+        assertThat(subject.getOriginalPosition(1)).isEqualTo(1);
+        assertThat(subject.getOriginalPosition(2)).isEqualTo(2);
+        assertThat(subject.getOriginalPosition(3)).isEqualTo(3);
+        assertThat(subject.getOriginalPosition(4)).isEqualTo(4);
+
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.setItemCount(4);  // Will place ads at positions 1, 3, and 5
+
+        assertThat(subject.getOriginalPosition(0)).isEqualTo(0);
+        assertThat(subject.getOriginalPosition(1)).isEqualTo(PlacementData.NOT_FOUND);
+        assertThat(subject.getOriginalPosition(2)).isEqualTo(1);
+        assertThat(subject.getOriginalPosition(3)).isEqualTo(PlacementData.NOT_FOUND);
+        assertThat(subject.getOriginalPosition(4)).isEqualTo(2);
+    }
+
+    @Test
+    public void getAdjustedPosition_adjustsPositions() {
+        assertThat(subject.getAdjustedPosition(0)).isEqualTo(0);
+        assertThat(subject.getAdjustedPosition(1)).isEqualTo(1);
+        assertThat(subject.getAdjustedPosition(2)).isEqualTo(2);
+        assertThat(subject.getAdjustedPosition(3)).isEqualTo(3);
+        assertThat(subject.getAdjustedPosition(4)).isEqualTo(4);
+
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.setItemCount(4);  // Will place ads at positions 1, 3, and 5
+
+        assertThat(subject.getAdjustedPosition(0)).isEqualTo(0);
+        assertThat(subject.getAdjustedPosition(1)).isEqualTo(2);
+        assertThat(subject.getAdjustedPosition(2)).isEqualTo(4);
+        assertThat(subject.getAdjustedPosition(3)).isEqualTo(6);
+        assertThat(subject.getAdjustedPosition(4)).isEqualTo(7);
+    }
+
+    @Test
+    public void getOriginalCount_adjustsPositions() {
+        assertThat(subject.getOriginalCount(0)).isEqualTo(0);
+        assertThat(subject.getOriginalCount(1)).isEqualTo(1);
+        assertThat(subject.getOriginalCount(2)).isEqualTo(2);
+        assertThat(subject.getOriginalCount(3)).isEqualTo(3);
+        assertThat(subject.getOriginalCount(4)).isEqualTo(4);
+
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.setItemCount(4);  // Will place ads at positions 1, 3, and 5
+
+        assertThat(subject.getOriginalCount(0)).isEqualTo(0);
+        assertThat(subject.getOriginalCount(1)).isEqualTo(1);
+        assertThat(subject.getOriginalCount(2)).isEqualTo(PlacementData.NOT_FOUND);
+        assertThat(subject.getOriginalCount(3)).isEqualTo(2);
+        assertThat(subject.getOriginalCount(4)).isEqualTo(PlacementData.NOT_FOUND);
+    }
+
+    @Test
+    public void getAdjustedCount_adjustsPositions() {
+        assertThat(subject.getAdjustedCount(0)).isEqualTo(0);
+        assertThat(subject.getAdjustedCount(1)).isEqualTo(1);
+        assertThat(subject.getAdjustedCount(2)).isEqualTo(2);
+        assertThat(subject.getAdjustedCount(3)).isEqualTo(3);
+        assertThat(subject.getAdjustedCount(4)).isEqualTo(4);
+
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.setItemCount(4);  // Will place ads at positions 1, 3, and 5
+
+        assertThat(subject.getAdjustedCount(0)).isEqualTo(0);
+        assertThat(subject.getAdjustedCount(1)).isEqualTo(1);
+        assertThat(subject.getAdjustedCount(2)).isEqualTo(3);
+        assertThat(subject.getAdjustedCount(3)).isEqualTo(5);
+        assertThat(subject.getAdjustedCount(4)).isEqualTo(7);
+    }
+
+    @Test
+    public void placeAds_shouldCallListener() {
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+
+        subject.setItemCount(4);  // Will place ads at positions 1, 3, and 5
+        verify(mockAdLoadedListener, never()).onAdLoaded(0);
+        verify(mockAdLoadedListener).onAdLoaded(1);
+        verify(mockAdLoadedListener, never()).onAdLoaded(2);
+        verify(mockAdLoadedListener).onAdLoaded(3);
+        verify(mockAdLoadedListener, never()).onAdLoaded(4);
+        verify(mockAdLoadedListener).onAdLoaded(5);
+        verify(mockAdLoadedListener, never()).onAdLoaded(6);
+        verify(mockAdLoadedListener, never()).onAdLoaded(7);
+    }
+
+    @Test
+    public void placeAdsInRange_shouldPlaceAfter() {
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+
+        Robolectric.getUiThreadScheduler().pause();
+        subject.setItemCount(100);
+        subject.placeAdsInRange(50, 50);
+        Robolectric.getUiThreadScheduler().advanceToLastPostedRunnable();
+
+        assertThat(subject.isAd(48)).isFalse();
+        assertThat(subject.isAd(49)).isFalse();
+        assertThat(subject.isAd(50)).isTrue();
+        assertThat(subject.isAd(51)).isFalse();
+        assertThat(subject.isAd(52)).isTrue();
+        assertThat(subject.isAd(53)).isFalse();
+        assertThat(subject.isAd(54)).isTrue();
+    }
+
+    @Test
+    public void placeAdsInRange_shouldCallListener() {
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+
+        Robolectric.getUiThreadScheduler().pause();
+        subject.setItemCount(100);
+        subject.placeAdsInRange(50, 54);
+        Robolectric.getUiThreadScheduler().advanceToLastPostedRunnable();
+
+        verify(mockAdLoadedListener).onAdLoaded(50);
+        verify(mockAdLoadedListener, never()).onAdLoaded(51);
+        verify(mockAdLoadedListener).onAdLoaded(52);
+        verify(mockAdLoadedListener, never()).onAdLoaded(53);
+        verify(mockAdLoadedListener).onAdLoaded(54);
+        verify(mockAdLoadedListener, never()).onAdLoaded(55);
+        verify(mockAdLoadedListener).onAdLoaded(56);
+    }
+
+    @Test
+    public void placeAdsInRange_aboveItemCount_shouldNotInsert() {
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+
+        Robolectric.getUiThreadScheduler().pause();
+        subject.setItemCount(0);
+        subject.placeAdsInRange(50, 54);
+        Robolectric.getUiThreadScheduler().advanceToLastPostedRunnable();
+
+        verify(mockAdLoadedListener, never()).onAdLoaded(50);
+    }
+
+    @Test
+    public void getAdView_withNoAds_returnsNull() {
+        assertThat(subject.getAdView(1, null, null)).isNull();
+    }
+
+    @Test
+    public void loadAds_shouldLoadAdsWhenAvailable() {
+        // Shouldn't load ads because there aren't any available
+        subject.setItemCount(2);
+        subject.placeAdsInRange(0, 1);
+        subject.loadAds("test-ad-unit-id");
+        assertThat(subject.isAd(1)).isFalse();
+        verify(mockAdLoadedListener, never()).onAdLoaded(anyInt());
+
+        // Capture the ad source listener so that we can trigger an ad loading
+        ArgumentCaptor<AdSourceListener> captor = ArgumentCaptor.forClass(AdSourceListener.class);
+        verify(mockAdSource).setAdSourceListener(captor.capture());
+        AdSourceListener adSourceListener = captor.getValue();
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        adSourceListener.onAdsAvailable();
+
+        // Check that an ad was loaded
+        assertThat(subject.isAd(1)).isTrue();
+        verify(mockAdLoadedListener).onAdLoaded(1);
+    }
+
+    @Test
+    public void loadAds_shouldClearAds_afterFirstAdLoads() {
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.setItemCount(2);
+        subject.placeAdsInRange(0, 1);
+
+        subject.loadAds("test-ad-unit-id");
+        ArgumentCaptor<AdSourceListener> captor = ArgumentCaptor.forClass(AdSourceListener.class);
+        verify(mockAdSource).setAdSourceListener(captor.capture());
+        AdSourceListener adSourceListener = captor.getValue();
+
+        // Ad should still exist until a new ad is available
+        assertThat(subject.isAd(1)).isTrue();
+        verify(mockAdLoadedListener, never()).onAdRemoved(anyInt());
+
+        // Once an ad is available, it should be immediately removed and replaced
+        adSourceListener.onAdsAvailable();
+        verify(mockAdLoadedListener).onAdRemoved(1);
+        verify(mockAdLoadedListener, times(2)).onAdLoaded(1);
+        assertThat(subject.isAd(1)).isTrue();
+    }
+
+    @Test
+    public void clearAds_shouldClearAdSource_shouldClearImpressionTracker_shouldResetPlacementData() {
+        PlacementData mockPlacementData = mock(PlacementData.class);
+        subject = new MoPubStreamAdPlacer(context, mockAdSource, mockImpressionTracker, mockPlacementData);
+
+        subject.destroy();
+
+        verify(mockAdSource).clear();
+        verify(mockImpressionTracker).destroy();
+        verify(mockPlacementData).clearAds();
+    }
+
+    @Test
+    public void getAdView_withNullConvertView_callsRenderer_addsToImpressionTracker() {
+        View view = new View(context);
+        when(mockAdRenderer.createAdView(any(Context.class), any(ViewGroup.class)))
+                .thenReturn(view);
+
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.setItemCount(100);
+
+        assertThat(subject.getAdView(1, null, null)).isEqualTo(view);
+        verify(mockAdRenderer).createAdView(any(Context.class), any(ViewGroup.class));
+        verify(mockAdRenderer).renderAdView(view, stubNativeResponse);
+        verify(mockImpressionTracker).addView(view, stubNativeResponse);
+    }
+
+    @Test
+    public void getAdView_withConvertView_callsRenderer_addsToImpressionTracker() {
+        View convertView = new View(context);
+
+        when(mockAdSource.dequeueAd()).thenReturn(stubNativeResponse);
+        subject.setItemCount(100);
+
+        assertThat(subject.getAdView(1, convertView, null)).isEqualTo(convertView);
+        verify(mockAdRenderer, never()).createAdView(any(Context.class), any(ViewGroup.class));
+        verify(mockAdRenderer).renderAdView(convertView, stubNativeResponse);
+        verify(mockImpressionTracker).addView(convertView, stubNativeResponse);
+    }
+
+    @Test
+    public void destroy_shouldClearAdSource_shouldDestroyImpressionTracker_shouldResetPlacementData() {
+        PlacementData mockPlacementData = mock(PlacementData.class);
+        subject = new MoPubStreamAdPlacer(context, mockAdSource, mockImpressionTracker, mockPlacementData);
+
+        subject.destroy();
+
+        verify(mockAdSource).clear();
+        verify(mockImpressionTracker).destroy();
+        verify(mockPlacementData).clearAds();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdSourceTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdSourceTest.java
new file mode 100644
index 00000000..d103c9b7
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdSourceTest.java
@@ -0,0 +1,323 @@
+package com.mopub.nativeads;
+
+import android.os.Handler;
+import android.os.SystemClock;
+
+import com.mopub.nativeads.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.shadows.ShadowSystemClock;
+
+import java.util.ArrayList;
+
+import static com.mopub.nativeads.NativeAdSource.AdSourceListener;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyLong;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+@RunWith(SdkTestRunner.class)
+public class NativeAdSourceTest {
+    private NativeAdSource subject;
+    private ArrayList<TimestampWrapper<NativeResponse>> nativeAdCache;
+    private RequestParameters requestParameters;
+    private int defaultRetryTime;
+    private int maxRetryTime;
+
+    @Mock private AdSourceListener mockAdSourceListener;
+    @Mock private MoPubNative mockMoPubNative;
+    @Mock private NativeResponse mockNativeResponse;
+    @Mock private Handler mockReplenishCacheHandler;
+
+    @Before
+    public void setUp() {
+        nativeAdCache = new ArrayList<TimestampWrapper<NativeResponse>>(2);
+        subject = new NativeAdSource(nativeAdCache, mockReplenishCacheHandler);
+        subject.setAdSourceListener(mockAdSourceListener);
+
+        requestParameters = new RequestParameters.Builder().build();
+
+        defaultRetryTime = 1000;
+        maxRetryTime = 5*60*1000;
+
+        // XXX We need this to ensure that our SystemClock starts
+        ShadowSystemClock.uptimeMillis();
+    }
+
+    @Test
+    public void constructor_shouldInitializeCorrectly() {
+        assertThat(subject.mRequestInFlight).isFalse();
+        assertThat(subject.mSequenceNumber).isEqualTo(0);
+        assertThat(subject.mRetryTimeMilliseconds).isEqualTo(defaultRetryTime);
+    }
+
+    @Test
+    public void loadAds_shouldReplenishCache() {
+        subject.loadAds(requestParameters, mockMoPubNative);
+        assertThat(subject.mRequestInFlight).isTrue();
+        verify(mockMoPubNative).loadNativeAd(requestParameters, 0);
+    }
+
+    @Test
+    public void loadAds_shouldClearNativeAdSource() {
+        subject.setMoPubNative(mockMoPubNative);
+        TimestampWrapper<NativeResponse> timestampWrapper =
+                new TimestampWrapper<NativeResponse>(mock(NativeResponse.class));
+        nativeAdCache.add(timestampWrapper);
+        subject.mRequestInFlight = true;
+        subject.mSequenceNumber = 5;
+        subject.mRetryTimeMilliseconds = maxRetryTime;
+
+        subject.loadAds(requestParameters, mockMoPubNative);
+
+        verify(timestampWrapper.mInstance).destroy();
+        assertThat(nativeAdCache).isEmpty();
+        verify(mockMoPubNative).destroy();
+        verify(mockReplenishCacheHandler).removeMessages(0);
+        assertThat(subject.mSequenceNumber).isEqualTo(0);
+        assertThat(subject.mRetryTimeMilliseconds).isEqualTo(defaultRetryTime);
+
+        // new request has been kicked off
+        assertThat(subject.mRequestInFlight).isTrue();
+    }
+
+    @Test
+    public void loadAds_shouldDestroyPreviousMoPubNativeInstance() {
+        subject.loadAds(requestParameters, mockMoPubNative);
+        verify(mockMoPubNative, never()).destroy();
+
+        subject.loadAds(requestParameters, mockMoPubNative);
+        verify(mockMoPubNative).destroy();
+    }
+
+    @Test
+    public void clear_shouldDestroyMoPubNative_shouldClearNativeAdCache_shouldRemovePollHandlerMessages_shouldResetSequenceNumber_shouldResetRequestInFlight_shouldResetRetryTime() {
+        subject.setMoPubNative(mockMoPubNative);
+        TimestampWrapper<NativeResponse> timestampWrapper = new TimestampWrapper<NativeResponse>(mock(NativeResponse.class));
+        nativeAdCache.add(timestampWrapper);
+        subject.mRequestInFlight = true;
+        subject.mSequenceNumber = 5;
+        subject.mRetryTimeMilliseconds = maxRetryTime;
+
+        subject.clear();
+
+        verify(timestampWrapper.mInstance).destroy();
+        assertThat(nativeAdCache).isEmpty();
+        verify(mockMoPubNative).destroy();
+        verify(mockReplenishCacheHandler).removeMessages(0);
+        assertThat(subject.mRequestInFlight).isFalse();
+        assertThat(subject.mSequenceNumber).isEqualTo(0);
+        assertThat(subject.mRetryTimeMilliseconds).isEqualTo(defaultRetryTime);
+    }
+
+    @Test
+    public void dequeueAd_withNonStaleResponse_shouldReturnNativeResponse() {
+        subject.setMoPubNative(mockMoPubNative);
+        nativeAdCache.add(new TimestampWrapper<NativeResponse>(mockNativeResponse));
+
+        assertThat(subject.dequeueAd()).isEqualTo(mockNativeResponse);
+        assertThat(nativeAdCache).isEmpty();
+    }
+
+    @Test
+    public void dequeueAd_withStaleResponse_shouldReturnNativeResponse() {
+        subject.setMoPubNative(mockMoPubNative);
+
+        TimestampWrapper<NativeResponse> timestampWrapper = new TimestampWrapper<NativeResponse>(
+                mockNativeResponse);
+        timestampWrapper.mCreatedTimestamp = SystemClock.uptimeMillis() - (15*60*1000+1);
+        nativeAdCache.add(timestampWrapper);
+
+        assertThat(subject.dequeueAd()).isNull();
+        assertThat(nativeAdCache).isEmpty();
+    }
+
+    @Test
+    public void dequeueAd_noRequestInFlight_shouldReplenishCache() {
+        subject.setMoPubNative(mockMoPubNative);
+
+        nativeAdCache.add(new TimestampWrapper<NativeResponse>(mockNativeResponse));
+
+        assertThat(subject.dequeueAd()).isEqualTo(mockNativeResponse);
+
+        assertThat(nativeAdCache).isEmpty();
+        verify(mockReplenishCacheHandler).post(any(Runnable.class));
+    }
+
+    @Test
+    public void dequeueAd_requestInFlight_shouldNotReplenishCache() {
+        subject.setMoPubNative(mockMoPubNative);
+
+        nativeAdCache.add(new TimestampWrapper<NativeResponse>(mockNativeResponse));
+
+        subject.mRequestInFlight = true;
+        assertThat(subject.dequeueAd()).isEqualTo(mockNativeResponse);
+
+        assertThat(nativeAdCache).isEmpty();
+        verify(mockReplenishCacheHandler, never()).post(any(Runnable.class));
+    }
+
+    @Test
+    public void updateRetryTime_shouldUpdateRetryTimeUntilAt10Minutes() {
+        int retryTime = 0;
+        while (subject.mRetryTimeMilliseconds < maxRetryTime) {
+            subject.updateRetryTime();
+            retryTime = subject.mRetryTimeMilliseconds;
+        }
+
+        assertThat(retryTime).isEqualTo(maxRetryTime);
+
+        // assert it won't change anymore
+        subject.updateRetryTime();
+        assertThat(retryTime).isEqualTo(subject.mRetryTimeMilliseconds);
+    }
+
+    @Test
+    public void resetRetryTime_shouldSetRetryTimeTo1Second() {
+        assertThat(subject.mRetryTimeMilliseconds).isEqualTo(defaultRetryTime);
+
+        subject.updateRetryTime();
+        assertThat(subject.mRetryTimeMilliseconds).isGreaterThan(defaultRetryTime);
+
+        subject.resetRetryTime();
+        assertThat(subject.mRetryTimeMilliseconds).isEqualTo(defaultRetryTime);
+    }
+
+    @Test
+    public void replenishCache_shouldLoadNativeAd_shouldMarkRequestInFlight() {
+        subject.setMoPubNative(mockMoPubNative);
+
+        subject.replenishCache();
+
+        verify(mockMoPubNative).loadNativeAd(any(RequestParameters.class), eq(0));
+        assertThat(subject.mRequestInFlight).isTrue();
+    }
+
+    @Test
+    public void replenishCache_withRequestInFlight_shouldNotLoadNativeAd() {
+        subject.mRequestInFlight = true;
+        subject.setMoPubNative(mockMoPubNative);
+
+        subject.replenishCache();
+
+        verify(mockMoPubNative, never()).loadNativeAd(requestParameters, 0);
+        assertThat(subject.mRequestInFlight).isTrue();
+    }
+
+    @Test
+    public void replenishCache_withCacheSizeAtLimit_shouldNotLoadNativeAd() {
+        // Default cache size may change in the future and this test will have to be updated
+        nativeAdCache.add(mock(TimestampWrapper.class));
+        nativeAdCache.add(mock(TimestampWrapper.class));
+        nativeAdCache.add(mock(TimestampWrapper.class));
+
+        subject.setMoPubNative(mockMoPubNative);
+
+        subject.replenishCache();
+
+        verify(mockMoPubNative, never()).loadNativeAd(any(RequestParameters.class), any(Integer.class));
+        assertThat(subject.mRequestInFlight).isFalse();
+    }
+
+    @Test
+    public void moPubNativeNetworkListener_onNativeLoad_shouldAddToCache() {
+        subject.setMoPubNative(mockMoPubNative);
+        subject.getMoPubNativeNetworkListener().onNativeLoad(mockNativeResponse);
+
+        assertThat(nativeAdCache).hasSize(1);
+        assertThat(nativeAdCache.get(0).mInstance).isEqualTo(mockNativeResponse);
+    }
+
+    @Test
+    public void moPubNativeNetworkListener_onNativeLoad_withEmptyCache_shouldCallOnAdsAvailable() {
+        subject.setMoPubNative(mockMoPubNative);
+
+        assertThat(nativeAdCache).isEmpty();
+        subject.getMoPubNativeNetworkListener().onNativeLoad(mockNativeResponse);
+
+        assertThat(nativeAdCache).hasSize(1);
+        verify(mockAdSourceListener).onAdsAvailable();
+    }
+
+    @Test
+    public void moPubNativeNetworkListener_onNativeLoad_withNonEmptyCache_shouldNotCallOnAdsAvailable() {
+        subject.setMoPubNative(mockMoPubNative);
+
+        nativeAdCache.add(mock(TimestampWrapper.class));
+        subject.getMoPubNativeNetworkListener().onNativeLoad(mockNativeResponse);
+
+        assertThat(nativeAdCache).hasSize(2);
+        verify(mockAdSourceListener, never()).onAdsAvailable();
+    }
+
+    @Test
+    public void moPubNativeNetworkListener_onNativeLoad_shouldIncrementSequenceNumber_shouldResetRetryTime() {
+        subject.setMoPubNative(mockMoPubNative);
+
+        subject.mRetryTimeMilliseconds = maxRetryTime;
+        subject.mSequenceNumber = 5;
+
+        subject.getMoPubNativeNetworkListener().onNativeLoad(mockNativeResponse);
+
+        assertThat(subject.mRetryTimeMilliseconds).isEqualTo(defaultRetryTime);
+        assertThat(subject.mSequenceNumber).isEqualTo(6);
+    }
+
+    @Test
+    public void moPubNativeNetworkListener_onNativeLoad_withFullCache_shouldResetRequestInFlight() {
+        subject.setMoPubNative(mockMoPubNative);
+
+        subject.mRequestInFlight = true;
+
+        // fill cache
+        nativeAdCache.add(mock(TimestampWrapper.class));
+        nativeAdCache.add(mock(TimestampWrapper.class));
+        nativeAdCache.add(mock(TimestampWrapper.class));
+
+        subject.getMoPubNativeNetworkListener().onNativeLoad(mockNativeResponse);
+
+        assertThat(subject.mRequestInFlight).isEqualTo(false);
+    }
+
+    @Test
+    public void moPubNativeNetworkListener_onNativeLoad_withNonFullCache_shouldReplenishCache() {
+        subject.setMoPubNative(mockMoPubNative);
+
+        subject.mRequestInFlight = true;
+
+        subject.getMoPubNativeNetworkListener().onNativeLoad(mockNativeResponse);
+
+        assertThat(subject.mRequestInFlight).isEqualTo(true);
+        verify(mockMoPubNative).loadNativeAd(any(RequestParameters.class), eq(1));
+    }
+
+    @Test
+    public void moPubNativeNetworkListener_onNativeFail_shouldResetRequestInFlight_shouldUpdateRetryTime_shouldPostDelayedRunnable() {
+        subject.mRequestInFlight = true;
+        subject.mRetryTimeMilliseconds = defaultRetryTime;
+
+        subject.getMoPubNativeNetworkListener().onNativeFail(NativeErrorCode.UNSPECIFIED);
+
+        assertThat(subject.mRequestInFlight).isEqualTo(true);
+        assertThat(subject.mRetryTimeMilliseconds).isGreaterThan(defaultRetryTime);
+        verify(mockReplenishCacheHandler).postDelayed(any(Runnable.class), eq((long)subject.mRetryTimeMilliseconds));
+    }
+
+    @Test
+    public void moPubNativeNetworkListener_onNativeFail_maxRetryTime_shouldResetRetryTime_shouldNotPostDelayedRunnable() {
+        subject.mRequestInFlight = true;
+        subject.mRetryTimeMilliseconds = maxRetryTime;
+
+        subject.getMoPubNativeNetworkListener().onNativeFail(NativeErrorCode.UNSPECIFIED);
+
+        assertThat(subject.mRequestInFlight).isEqualTo(false);
+        assertThat(subject.mRetryTimeMilliseconds).isEqualTo(defaultRetryTime);
+        verify(mockReplenishCacheHandler, never()).postDelayed(any(Runnable.class), anyLong());
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdViewHelperTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdViewHelperTest.java
index ad1e8d90..6208fa94 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdViewHelperTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdViewHelperTest.java
@@ -4,24 +4,19 @@
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.Button;
-import android.widget.ImageView;
 import android.widget.LinearLayout;
 import android.widget.RelativeLayout;
 import android.widget.TextView;
 
 import com.mopub.common.DownloadResponse;
-import com.mopub.common.util.ResponseHeader;
 import com.mopub.common.util.Utils;
-import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
 import com.mopub.nativeads.test.support.SdkTestRunner;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
 
 import static com.mopub.nativeads.MoPubNative.MoPubNativeListener;
-import static com.mopub.nativeads.NativeAdViewHelper.NativeViewClickListener;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
 
@@ -36,8 +31,6 @@
     private TextView titleView;
     private TextView textView;
     private TextView callToActionView;
-    private ImageView mainImageView;
-    private ImageView iconImageView;
 
     @Before
     public void setUp() throws Exception {
@@ -47,11 +40,11 @@ public void setUp() throws Exception {
         viewGroup = new LinearLayout(context);
 
         mNativeAd = new BaseForwardingNativeAd() {};
-        mNativeAd.setClickDestinationUrl("destinationUrl");
-        final TestHttpResponseWithHeaders testHttpResponseWithHeaders = new TestHttpResponseWithHeaders(200, "");
-        testHttpResponseWithHeaders.addHeader(ResponseHeader.CLICKTHROUGH_URL.getKey(), "clickTrackerUrl");
-        final DownloadResponse downloadResponse = new DownloadResponse(testHttpResponseWithHeaders);
-        nativeResponse = new NativeResponse(context, downloadResponse, mNativeAd, mock(MoPubNativeListener.class));
+        mNativeAd.setTitle("test title");
+        mNativeAd.setText("test text");
+        mNativeAd.setCallToAction("test call to action");
+
+        nativeResponse = new NativeResponse(context, mock(DownloadResponse.class), "testId", mNativeAd, mock(MoPubNativeListener.class));
 
         titleView = new TextView(context);
         titleView.setId((int) Utils.generateUniqueId());
@@ -59,108 +52,51 @@ public void setUp() throws Exception {
         textView.setId((int) Utils.generateUniqueId());
         callToActionView = new Button(context);
         callToActionView.setId((int) Utils.generateUniqueId());
-        mainImageView = new ImageView(context);
-        mainImageView.setId((int) Utils.generateUniqueId());
-        iconImageView = new ImageView(context);
-        iconImageView.setId((int) Utils.generateUniqueId());
 
         relativeLayout.addView(titleView);
         relativeLayout.addView(textView);
         relativeLayout.addView(callToActionView);
-        relativeLayout.addView(mainImageView);
-        relativeLayout.addView(iconImageView);
 
         viewBinder = new ViewBinder.Builder(relativeLayout.getId())
                 .titleId(titleView.getId())
                 .textId(textView.getId())
                 .callToActionId(callToActionView.getId())
-                .mainImageId(mainImageView.getId())
-                .iconImageId(iconImageView.getId())
                 .build();
     }
 
     @Test
-    public void getAdView_whenCallToActionIsAButton_shouldAttachClickListenersToConvertViewAndCtaButton() throws Exception {
-        assertThat(relativeLayout.performClick()).isFalse();
-        assertThat(callToActionView.performClick()).isFalse();
-        NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, nativeResponse, viewBinder, null);
-        assertThat(relativeLayout.performClick()).isTrue();
-        assertThat(callToActionView.performClick()).isTrue();
-    }
+    public void getAdView_shouldReturnPopulatedView() throws Exception {
+        View view = NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, nativeResponse, viewBinder, null);
 
-    @Test
-    public void getAdView_whenCallToActionIsATextView_shouldAttachClickListenersToConvertViewOnly() throws Exception {
-        relativeLayout.removeView(callToActionView);
-        callToActionView = new TextView(context);
-        callToActionView.setId((int) Utils.generateUniqueId());
-        relativeLayout.addView(callToActionView);
+        assertThat(((TextView)view.findViewById(titleView.getId())).getText()).isEqualTo("test title");
+        assertThat(((TextView)view.findViewById(textView.getId())).getText()).isEqualTo("test text");
+        assertThat(((TextView)view.findViewById(callToActionView.getId())).getText()).isEqualTo("test call to action");
 
-        assertThat(relativeLayout.performClick()).isFalse();
-        assertThat(callToActionView.performClick()).isFalse();
-
-        NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, nativeResponse, viewBinder, null);
-
-        assertThat(relativeLayout.performClick()).isTrue();
-        assertThat(callToActionView.performClick()).isFalse();
+        // not testing images due to testing complexity
     }
 
     @Test
-    public void getOrCreateNativeViewHolder_withNoViewHolder_shouldCreateNativeViewHolder() throws Exception {
-        assertThat(ImageViewService.getViewTag(relativeLayout)).isNull();
-        NativeAdViewHelper.getOrCreateNativeViewHolder(relativeLayout, viewBinder);
-        final NativeViewHolder nativeViewHolder = NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
-        compareNativeViewHolders(nativeViewHolder, (NativeViewHolder) ImageViewService.getViewTag(relativeLayout));
-    }
+    public void getAdView_withNullViewBinder_shouldReturnEmptyView() throws Exception {
+        View view = NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, nativeResponse, null, null);
 
-    @Test
-    public void getOrCreateNativeViewHolder_whenViewTagHasOtherObject_shouldCreateNativeViewHolder() throws Exception {
-        assertThat(ImageViewService.getViewTag(relativeLayout)).isNull();
-        ImageViewService.setViewTag(relativeLayout, new Object());
-        NativeAdViewHelper.getOrCreateNativeViewHolder(relativeLayout, viewBinder);
-        final NativeViewHolder nativeViewHolder = NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
-        compareNativeViewHolders(nativeViewHolder, (NativeViewHolder) ImageViewService.getViewTag(relativeLayout));
+        assertThat(view).isNotNull();
+        assertThat(view).isNotEqualTo(relativeLayout);
     }
 
     @Test
-    public void getOrCreateNativeViewHolder_whenViewTagHasNativeViewHolder_shouldNotCreateNativeViewHolder() throws Exception {
-        assertThat(ImageViewService.getViewTag(relativeLayout)).isNull();
-        final NativeViewHolder nativeViewHolder = NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
-        ImageViewService.setViewTag(relativeLayout, nativeViewHolder);
-        NativeAdViewHelper.getOrCreateNativeViewHolder(relativeLayout, viewBinder);
-        assertThat(ImageViewService.getViewTag(relativeLayout)).isEqualTo(nativeViewHolder);
-    }
-
-    @Test
-    public void onClick_shouldQueueClickTrackerAndUrlResolutionTasks() throws Exception {
-        NativeViewClickListener nativeViewClickListener = new NativeViewClickListener(nativeResponse);
-
-        Robolectric.getBackgroundScheduler().pause();
-        assertThat(Robolectric.getBackgroundScheduler().enqueuedTaskCount()).isEqualTo(0);
-        nativeViewClickListener.onClick(new View(context));
+    public void getAdView_withNullNativeResponse_shouldReturnGONEConvertView() throws Exception {
+        View view = NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, null, viewBinder, null);
 
-        assertThat(Robolectric.getBackgroundScheduler().enqueuedTaskCount()).isEqualTo(2);
+        assertThat(view).isEqualTo(relativeLayout);
+        assertThat(view.getVisibility()).isEqualTo(View.GONE);
     }
 
     @Test
-    public void onClick_withNullDestinationUrl_shouldNotQueueUrlResolutionTask() throws Exception {
-        mNativeAd.setClickDestinationUrl(null);
-
-        NativeViewClickListener nativeViewClickListener = new NativeViewClickListener(nativeResponse);
-
-        Robolectric.getBackgroundScheduler().pause();
-        assertThat(Robolectric.getBackgroundScheduler().enqueuedTaskCount()).isEqualTo(0);
-        nativeViewClickListener.onClick(new View(context));
-
-        // 1 task for async ping to click tracker
-        assertThat(Robolectric.getBackgroundScheduler().enqueuedTaskCount()).isEqualTo(1);
-    }
+    public void getAdView_withDestroyedNativeResponse_shouldReturnGONEConvertView() throws Exception {
+        nativeResponse.destroy();
+        View view = NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, nativeResponse, viewBinder, null);
 
-    static private void compareNativeViewHolders(final NativeViewHolder nativeViewHolder1,
-                                                 final NativeViewHolder nativeViewHolder2) {
-        assertThat(nativeViewHolder1.titleView).isEqualTo(nativeViewHolder2.titleView);
-        assertThat(nativeViewHolder1.textView).isEqualTo(nativeViewHolder2.textView);
-        assertThat(nativeViewHolder1.callToActionView).isEqualTo(nativeViewHolder2.callToActionView);
-        assertThat(nativeViewHolder1.mainImageView).isEqualTo(nativeViewHolder2.mainImageView);
-        assertThat(nativeViewHolder1.iconImageView).isEqualTo(nativeViewHolder2.iconImageView);
+        assertThat(view).isEqualTo(relativeLayout);
+        assertThat(view.getVisibility()).isEqualTo(View.GONE);
     }
 }
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeResponseTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeResponseTest.java
index 2fe23230..6ba1aa0d 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeResponseTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeResponseTest.java
@@ -10,7 +10,6 @@
 import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
 import com.mopub.nativeads.test.support.SdkTestRunner;
 
-import org.junit.After;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -21,8 +20,8 @@
 import java.util.List;
 import java.util.Map;
 
-import static com.mopub.nativeads.ImpressionTrackingManager.NativeResponseWrapper;
-import static com.mopub.nativeads.MoPubNative.MoPubNativeListener.EMPTY_MOPUB_NATIVE_LISTENER;
+import static com.mopub.nativeads.MoPubNative.EMPTY_EVENT_LISTENER;
+import static com.mopub.nativeads.MoPubNative.EMPTY_NETWORK_LISTENER;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
@@ -77,54 +76,49 @@ public void handleClick(final View view) {
 
         moPubNativeListener = mock(MoPubNative.MoPubNativeListener.class);
 
-        subject = new NativeResponse(context, downloadResponse, mNativeAd, moPubNativeListener);
+        subject = new NativeResponse(context, downloadResponse, "adunit_id", mNativeAd, moPubNativeListener);
 
         mMockNativeAd = mock(NativeAdInterface.class);
-        subjectWMockBaseNativeAd = new NativeResponse(context, downloadResponse, mMockNativeAd, moPubNativeListener);
-    }
-
-    @After
-    public void tearDown() throws Exception {
-        ImpressionTrackingManager.clearTracking();
+        subjectWMockBaseNativeAd = new NativeResponse(context, downloadResponse, "adunit_id", mMockNativeAd, moPubNativeListener);
     }
 
     @Test
-    public void getTitle_shouldReturnTitleFromBaseNativeAd() throws Exception {
+    public void getTitle_shouldReturnTitleFromBaseNativeAd() {
         assertThat(subject.getTitle()).isEqualTo("title");
     }
 
     @Test
-    public void getTitle_shouldReturnTextFromBaseNativeAd() throws Exception {
+    public void getTitle_shouldReturnTextFromBaseNativeAd() {
         assertThat(subject.getText()).isEqualTo("text");
     }
 
     @Test
-    public void getMainImageUrl_shouldReturnMainImageUrlFromBaseNativeAd() throws Exception {
+    public void getMainImageUrl_shouldReturnMainImageUrlFromBaseNativeAd() {
         assertThat(subject.getMainImageUrl()).isEqualTo("mainImageUrl");
     }
 
     @Test
-    public void getIconImageUrl_shouldReturnIconImageUrlFromBaseNativeAd() throws Exception {
+    public void getIconImageUrl_shouldReturnIconImageUrlFromBaseNativeAd() {
         assertThat(subject.getIconImageUrl()).isEqualTo("iconImageUrl");
     }
 
     @Test
-    public void getClickDestinationUrl_shouldReturnClickDestinationUrlFromBaseNativeAd() throws Exception {
+    public void getClickDestinationUrl_shouldReturnClickDestinationUrlFromBaseNativeAd() {
         assertThat(subject.getClickDestinationUrl()).isEqualTo("clickDestinationUrl");
     }
 
     @Test
-    public void getCallToAction_shouldReturnCallToActionFromBaseNativeAd() throws Exception {
+    public void getCallToAction_shouldReturnCallToActionFromBaseNativeAd() {
         assertThat(subject.getCallToAction()).isEqualTo("callToAction");
     }
 
     @Test
-    public void getExtra_shouldReturnExtraFromBaseNativeAd() throws Exception {
+    public void getExtra_shouldReturnExtraFromBaseNativeAd() {
         assertThat(subject.getExtra("extra")).isEqualTo("extraValue");
     }
 
     @Test
-    public void getExtras_shouldReturnCopyOfExtrasMapFromBaseNativeAd() throws Exception {
+    public void getExtras_shouldReturnCopyOfExtrasMapFromBaseNativeAd() {
         final Map<String, Object> extras = subject.getExtras();
         assertThat(extras.size()).isEqualTo(2);
         assertThat(extras.get("extra")).isEqualTo("extraValue");
@@ -133,65 +127,48 @@ public void getExtras_shouldReturnCopyOfExtrasMapFromBaseNativeAd() throws Excep
     }
 
     @Test
-    public void getImpressionTrackers_shouldReturnImpressionTrackersFromMoPubAndFromBaseNativeAd() throws Exception {
+    public void getImpressionTrackers_shouldReturnImpressionTrackersFromMoPubAndFromBaseNativeAd() {
         final List<String> impressionTrackers = subject.getImpressionTrackers();
         assertThat(impressionTrackers).containsOnly("moPubImpressionTrackerUrl", "impressionUrl");
     }
 
     @Test
-    public void getImpressionMinTimeViewed_shouldReturnImpressionMinTimeViewedFromBaseNativeAd() throws Exception {
+    public void getImpressionMinTimeViewed_shouldReturnImpressionMinTimeViewedFromBaseNativeAd() {
         assertThat(subject.getImpressionMinTimeViewed()).isEqualTo(500);
     }
 
     @Test
-    public void getImpressionMinPercentageViewed_shouldReturnImpressionMinPercentageViewedFromBaseNativeAd() throws Exception {
+    public void getImpressionMinPercentageViewed_shouldReturnImpressionMinPercentageViewedFromBaseNativeAd() {
         assertThat(subject.getImpressionMinPercentageViewed()).isEqualTo(50);
     }
 
     @Test
-    public void getClickTracker_shouldReturnMoPubClickTracker() throws Exception {
+    public void getClickTracker_shouldReturnMoPubClickTracker() {
         assertThat(subject.getClickTracker()).isEqualTo("moPubClickTrackerUrl");
     }
-    
-    @Test
-    public void prepareImpression_shouldAddViewAndResponseToImpressionTrackingManagerAndCallPrepareImpressionOnBaseNativeAd() throws Exception {
-        View view = ImpressionTrackingManagerTest.getViewMock(View.VISIBLE, 100, 100, 100, 100, true, true);
 
-        assertThat(ImpressionTrackingManager.getPollingViews()).isEmpty();
+    @Test
+    public void prepareImpression_shouldCallPrepareImpressionOnBaseNativeAd() {
         subjectWMockBaseNativeAd.prepareImpression(view);
-        final Map<View, NativeResponseWrapper> keptViews = ImpressionTrackingManager.getPollingViews();
-        assertThat(keptViews.size()).isEqualTo(1);
-        assertThat(keptViews.get(view).mNativeResponse).isSameAs(subjectWMockBaseNativeAd);
-
         verify(mMockNativeAd).prepareImpression(view);
     }
 
     @Test
-    public void prepareImpression_whenDestroyed_shouldReturnFast() throws Exception {
+    public void prepareImpression_whenDestroyed_shouldReturnFast() {
         subjectWMockBaseNativeAd.destroy();
-        assertThat(subjectWMockBaseNativeAd.isDestroyed()).isTrue();
-        assertThat(ImpressionTrackingManager.getPollingViews()).isEmpty();
-
         subjectWMockBaseNativeAd.prepareImpression(view);
-
-        assertThat(ImpressionTrackingManager.getPollingViews()).isEmpty();
         verify(mMockNativeAd, never()).prepareImpression(view);
     }
 
     @Test
-    public void prepareImpression_whenAlreadyImpressed_shouldReturnFast() throws Exception {
+    public void prepareImpression_whenAlreadyImpressed_shouldReturnFast() {
         subjectWMockBaseNativeAd.setRecordedImpression(true);
-        assertThat(subjectWMockBaseNativeAd.getRecordedImpression()).isTrue();
-        assertThat(ImpressionTrackingManager.getPollingViews()).isEmpty();
-
         subjectWMockBaseNativeAd.prepareImpression(view);
-
-        assertThat(ImpressionTrackingManager.getPollingViews()).isEmpty();
         verify(mMockNativeAd, never()).prepareImpression(view);
     }
 
     @Test
-    public void recordImpression_shouldRecordImpressionsAndCallIntoBaseNativeAdAndNotifyListenerIdempotently() throws Exception {
+    public void recordImpression_shouldRecordImpressionsAndCallIntoBaseNativeAdAndNotifyListenerIdempotently() {
         Robolectric.getFakeHttpLayer().addPendingHttpResponse(200, "ok");
         Robolectric.getFakeHttpLayer().addPendingHttpResponse(200, "ok");
         assertThat(subject.getRecordedImpression()).isFalse();
@@ -222,7 +199,7 @@ public void recordImpression_shouldRecordImpressionsAndCallIntoBaseNativeAdAndNo
     }
 
     @Test
-    public void recordImpression_whenDestroyed_shouldReturnFast() throws Exception {
+    public void recordImpression_whenDestroyed_shouldReturnFast() {
         subject.destroy();
         subject.recordImpression(view);
         assertThat(subject.getRecordedImpression()).isFalse();
@@ -232,7 +209,7 @@ public void recordImpression_whenDestroyed_shouldReturnFast() throws Exception {
     }
 
     @Test
-    public void handleClick_withNoBaseNativeAdClickDestinationUrl_shouldRecordClickAndCallIntoBaseNativeAdAndNotifyListener() throws Exception {
+    public void handleClick_withNoBaseNativeAdClickDestinationUrl_shouldRecordClickAndCallIntoBaseNativeAdAndNotifyListener() {
         Robolectric.getFakeHttpLayer().addPendingHttpResponse(200, "ok");
         assertThat(subject.isClicked()).isFalse();
 
@@ -262,12 +239,12 @@ public void handleClick_withNoBaseNativeAdClickDestinationUrl_shouldRecordClickA
 
     @Ignore("pending")
     @Test
-    public void handleClick_withBaseNativeAdClickDestinationUrl_shouldRecordClickAndCallIntoBaseNativeAdAndOpenClickDestinationAndNotifyListener() throws Exception {
+    public void handleClick_withBaseNativeAdClickDestinationUrl_shouldRecordClickAndCallIntoBaseNativeAdAndOpenClickDestinationAndNotifyListener() {
         // Really difficult to test url resolution since it doesn't use the apache http client
     }
 
     @Test
-    public void handleClick_whenDestroyed_shouldReturnFast() throws Exception {
+    public void handleClick_whenDestroyed_shouldReturnFast() {
         subject.destroy();
         subject.handleClick(view);
         assertThat(subject.isClicked()).isFalse();
@@ -277,7 +254,7 @@ public void handleClick_whenDestroyed_shouldReturnFast() throws Exception {
     }
 
     @Test
-    public void destroy_shouldCallIntoBaseNativeAd() throws Exception {
+    public void destroy_shouldCallIntoBaseNativeAd() {
         subjectWMockBaseNativeAd.destroy();
         assertThat(subjectWMockBaseNativeAd.isDestroyed()).isTrue();
         verify(mMockNativeAd).destroy();
@@ -289,17 +266,17 @@ public void destroy_shouldCallIntoBaseNativeAd() throws Exception {
     }
 
     @Test
-    public void destroy_shouldSetMoPubNativeListenerToEmptyMoPubNativeListener() throws Exception {
-        assertThat(subjectWMockBaseNativeAd.getMoPubNativeListener()).isSameAs(moPubNativeListener);
+    public void destroy_shouldSetMoPubNativeEventListenerToEmptyMoPubNativeListener() {
+        assertThat(subjectWMockBaseNativeAd.getMoPubNativeEventListener()).isSameAs(moPubNativeListener);
 
         subjectWMockBaseNativeAd.destroy();
 
-        assertThat(subjectWMockBaseNativeAd.getMoPubNativeListener()).isSameAs(EMPTY_MOPUB_NATIVE_LISTENER);
+        assertThat(subjectWMockBaseNativeAd.getMoPubNativeEventListener()).isSameAs(EMPTY_EVENT_LISTENER);
     }
 
     @Ignore("pending")
     @Test
-    public void loadExtrasImage_shouldAsyncLoadImages() throws Exception {
+    public void loadExtrasImage_shouldAsyncLoadImages() {
         // no easy way to test this since nothing can be mocked
         // also not a critical test since it directly calls another service
     }
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeViewHolderTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeViewHolderTest.java
index 736c6da7..8f3cc482 100644
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeViewHolderTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeViewHolderTest.java
@@ -2,6 +2,8 @@
 
 import android.app.Activity;
 import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
 import android.view.ViewGroup;
 import android.widget.Button;
 import android.widget.ImageView;
@@ -13,17 +15,20 @@
 import com.mopub.common.DownloadResponse;
 import com.mopub.common.util.Utils;
 import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
+import com.mopub.nativeads.test.support.MoPubShadowBitmap;
 import com.mopub.nativeads.test.support.SdkTestRunner;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
 import static org.robolectric.Robolectric.shadowOf;
 
 @RunWith(SdkTestRunner.class)
+@Config(shadows={MoPubShadowBitmap.class})
 public class NativeViewHolderTest {
     private Context context;
     private RelativeLayout relativeLayout;
@@ -39,6 +44,16 @@
     private TextView extrasTextView;
     private ImageView extrasImageView;
     private ImageView extrasImageView2;
+    private String mainImageUrl;
+    private String iconImageUrl;
+    private String mainImageData;
+    private String iconImageData;
+    private Bitmap iconImage;
+    private Bitmap mainImage;
+    private String extrasImageData;
+    private String extrasImageData2;
+    private Bitmap extrasImage2;
+    private Bitmap extrasImage;
 
     @Before
     public void setUp() throws Exception {
@@ -75,6 +90,17 @@ public void setUp() throws Exception {
         relativeLayout.addView(extrasTextView);
         relativeLayout.addView(extrasImageView);
         relativeLayout.addView(extrasImageView2);
+
+        mainImageUrl = "mainimageurl";
+        iconImageUrl = "iconimageurl";
+        mainImageData = "mainimagedata";
+        iconImageData = "iconimagedata";
+        extrasImageData = "extrasimagedata";
+        extrasImageData2 = "extrasimagedata2";
+        iconImage = BitmapFactory.decodeByteArray(iconImageData.getBytes(), 0, iconImageData.getBytes().length);
+        mainImage = BitmapFactory.decodeByteArray(mainImageData.getBytes(), 0, mainImageData.getBytes().length);
+        extrasImage = BitmapFactory.decodeByteArray(extrasImageData.getBytes(), 0, extrasImageData.getBytes().length);
+        extrasImage2 = BitmapFactory.decodeByteArray(extrasImageData2.getBytes(), 0, extrasImageData2.getBytes().length);
     }
 
     @Test
@@ -137,9 +163,9 @@ public void fromViewBinder_withNonExistantIds_shouldLeaveFieldsNull() throws Exc
     @Test
     public void update_shouldAddValuesToViews() throws Exception {
         // Setup for cache state for image gets
-        CacheService.initializeCaches(context);
-        CacheService.putToMemoryCache("mainimageurl", "mainimagedata".getBytes());
-        CacheService.putToMemoryCache("iconimageurl", "iconimagedata".getBytes());
+        CacheService.initialize(context);
+        CacheService.putToBitmapCache(mainImageUrl, mainImage);
+        CacheService.putToBitmapCache(iconImageUrl, iconImage);
 
         BaseForwardingNativeAd nativeAd = new BaseForwardingNativeAd() {};
         nativeAd.setTitle("titletext");
@@ -149,7 +175,7 @@ public void update_shouldAddValuesToViews() throws Exception {
         nativeAd.setCallToAction("cta");
 
         final DownloadResponse downloadResponse = new DownloadResponse(new TestHttpResponseWithHeaders(200, ""));
-        nativeResponse = new NativeResponse(context, downloadResponse, nativeAd, null);
+        nativeResponse = new NativeResponse(context, downloadResponse, "adunit_id", nativeAd, null);
 
         viewBinder = new ViewBinder.Builder(relativeLayout.getId())
                 .titleId(titleView.getId())
@@ -168,9 +194,9 @@ public void update_shouldAddValuesToViews() throws Exception {
         assertThat(textView.getText()).isEqualTo("texttext");
         assertThat(callToActionView.getText()).isEqualTo("cta");
         assertThat(shadowOf(ImageViewServiceTest.getBitmapFromImageView(mainImageView))
-                .getCreatedFromBytes()).isEqualTo("mainimagedata".getBytes());
+                .getCreatedFromBytes()).isEqualTo(mainImageData.getBytes());
         assertThat(shadowOf(ImageViewServiceTest.getBitmapFromImageView(iconImageView))
-                .getCreatedFromBytes()).isEqualTo("iconimagedata".getBytes());
+                .getCreatedFromBytes()).isEqualTo(iconImageData.getBytes());
     }
 
     @Test
@@ -179,12 +205,12 @@ public void update_withMissingNativeResponseFields_shouldClearPreviousValues() t
         titleView.setText("previoustitletext");
         textView.setText("previoustexttext");
         callToActionView.setText("previousctatext");
-        mainImageView.setImageBitmap(ImageService.byteArrayToBitmap("previousmainimagedata".getBytes()));
-        iconImageView.setImageBitmap(ImageService.byteArrayToBitmap("previousiconimagedata".getBytes()));
+        mainImageView.setImageBitmap(BitmapFactory.decodeByteArray("previousmainimagedata".getBytes(), 0, "previousmainimagedata".getBytes().length));
+        iconImageView.setImageBitmap(BitmapFactory.decodeByteArray("previousiconimagedata".getBytes(), 0, "previousiconimagedata".getBytes().length));
 
         // Only required fields in native response
         final DownloadResponse downloadResponse = new DownloadResponse(new TestHttpResponseWithHeaders(200, ""));
-        nativeResponse = new NativeResponse(context, downloadResponse, mock(BaseForwardingNativeAd.class), null);
+        nativeResponse = new NativeResponse(context, downloadResponse, "adunit_id", mock(BaseForwardingNativeAd.class), null);
 
         viewBinder = new ViewBinder.Builder(relativeLayout.getId())
                 .titleId(titleView.getId())
@@ -215,7 +241,7 @@ public void update_withDifferentViewBinder_shouldNotClearPreviousValues() throws
         BaseForwardingNativeAd nativeAd = new BaseForwardingNativeAd() {};
         nativeAd.setCallToAction("cta");
         final DownloadResponse downloadResponse = new DownloadResponse(new TestHttpResponseWithHeaders(200, ""));
-        nativeResponse = new NativeResponse(context, downloadResponse, nativeAd, null);
+        nativeResponse = new NativeResponse(context, downloadResponse, "adunit_id", nativeAd, null);
 
         viewBinder = new ViewBinder.Builder(relativeLayout.getId())
                 .callToActionId(callToActionView.getId())
@@ -234,16 +260,16 @@ public void update_withDifferentViewBinder_shouldNotClearPreviousValues() throws
     @Test
     public void updateExtras_shouldAddValuesToViews() throws Exception {
         // Setup for cache state for image gets
-        CacheService.initializeCaches(context);
-        CacheService.putToMemoryCache("extrasimageurl", "extrasimagedata".getBytes());
-        CacheService.putToMemoryCache("extrasimageurl2", "extrasimagedata2".getBytes());
+        CacheService.initialize(context);
+        CacheService.putToBitmapCache("extrasimageurl", extrasImage);
+        CacheService.putToBitmapCache("extrasimageurl2", extrasImage2);
 
         BaseForwardingNativeAd nativeAd = new BaseForwardingNativeAd() {};
         nativeAd.addExtra("extrastext", "extrastexttext");
         nativeAd.addExtra("extrasimage", "extrasimageurl");
         nativeAd.addExtra("extrasimage2", "extrasimageurl2");
         final DownloadResponse downloadResponse = new DownloadResponse(new TestHttpResponseWithHeaders(200, ""));
-        nativeResponse = new NativeResponse(context, downloadResponse, nativeAd, null);
+        nativeResponse = new NativeResponse(context, downloadResponse, "adunit_id", nativeAd, null);
 
         viewBinder = new ViewBinder.Builder(relativeLayout.getId())
                 .addExtra("extrastext", extrasTextView.getId())
@@ -266,11 +292,11 @@ public void updateExtras_shouldAddValuesToViews() throws Exception {
     @Test
     public void updateExtras_withMissingExtrasValues_shouldClearPreviousValues() throws Exception {
         extrasTextView.setText("previousextrastext");
-        extrasImageView.setImageBitmap(ImageService.byteArrayToBitmap("previousextrasimagedata".getBytes()));
-        extrasImageView2.setImageBitmap(ImageService.byteArrayToBitmap("previousextrasimagedata2".getBytes()));
+        extrasImageView.setImageBitmap(BitmapFactory.decodeByteArray("previousextrasimagedata".getBytes(), 0, "previousextrasimagedata".getBytes().length));
+        extrasImageView2.setImageBitmap(BitmapFactory.decodeByteArray("previousextrasimagedata2".getBytes(), 0, "previousextrasimagedata2".getBytes().length));
 
         final DownloadResponse downloadResponse = new DownloadResponse(new TestHttpResponseWithHeaders(200, ""));
-        nativeResponse = new NativeResponse(context, downloadResponse, new BaseForwardingNativeAd(){}, null);
+        nativeResponse = new NativeResponse(context, downloadResponse, "adunit_id", new BaseForwardingNativeAd(){}, null);
 
         viewBinder = new ViewBinder.Builder(relativeLayout.getId())
                 .addExtra("extrastext", extrasTextView.getId())
@@ -301,7 +327,7 @@ public void updateExtras_withMismatchingViewTypes_shouldSetTextViewToImageUrlAnd
         nativeAd.addExtra("extrasimage", "extrasimageurl");
 
         final DownloadResponse downloadResponse = new DownloadResponse(new TestHttpResponseWithHeaders(200, ""));
-        nativeResponse = new NativeResponse(context, downloadResponse, nativeAd, null);
+        nativeResponse = new NativeResponse(context, downloadResponse, "adunit_id", nativeAd, null);
 
         viewBinder = new ViewBinder.Builder(relativeLayout.getId())
                 .addExtra("extrastext", extrasImageView.getId())
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/PlacementDataTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/PlacementDataTest.java
new file mode 100644
index 00000000..a735fe7d
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/PlacementDataTest.java
@@ -0,0 +1,853 @@
+
+
+package com.mopub.nativeads;
+
+import com.mopub.nativeads.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.annotation.Config;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import static com.mopub.nativeads.PlacementData.NOT_FOUND;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@Config(manifest=Config.NONE)
+@RunWith(SdkTestRunner.class)
+public class PlacementDataTest {
+    private PlacementData noAds;
+    private PlacementData adAt0;
+    private PlacementData adAt1;
+    private PlacementData adsAt01;
+    private PlacementData adsAt1234;
+    private PlacementData adsAt14;
+    private PlacementData adsRepeating;
+    private PlacementData adsAt15repeating;
+
+    @Mock private NativeAdData mockNativeAdData;
+    @Mock private NativeAdData mockNativeAdData2;
+    @Mock private NativeAdData mockNativeAdData3;
+    @Mock private NativeAdData mockNativeAdData4;
+    @Mock private NativeResponse mockNativeResponse;
+    @Mock private NativeResponse mockNativeResponse2;
+    @Mock private NativeResponse mockNativeResponse3;
+    @Mock private NativeResponse mockNativeResponse4;
+
+    @Before
+    public void setup() {
+        noAds = PlacementData.fromAdPositioning(MoPubNativeAdPositioning.newBuilder()
+                .build());
+        adAt0 = PlacementData.fromAdPositioning(MoPubNativeAdPositioning.newBuilder()
+                .addFixedPosition(0)
+                .build());
+        adAt1 = PlacementData.fromAdPositioning(MoPubNativeAdPositioning.newBuilder()
+                .addFixedPosition(1)
+                .build());
+        adsAt01 = PlacementData.fromAdPositioning(MoPubNativeAdPositioning.newBuilder()
+                .addFixedPosition(0)
+                .addFixedPosition(1)
+                .build());
+        adsAt14 = PlacementData.fromAdPositioning(MoPubNativeAdPositioning.newBuilder()
+                .addFixedPosition(1)
+                .addFixedPosition(4)
+                .build());
+        adsRepeating = PlacementData.fromAdPositioning(MoPubNativeAdPositioning.newBuilder()
+                .enableRepeatingPositions(3)
+                .build());
+        adsAt15repeating = PlacementData.fromAdPositioning(MoPubNativeAdPositioning.newBuilder()
+                .addFixedPosition(1)
+                .addFixedPosition(5)
+                .enableRepeatingPositions(3)
+                .build());
+        adsAt1234 = PlacementData.fromAdPositioning(MoPubNativeAdPositioning.newBuilder()
+                .addFixedPosition(1)
+                .addFixedPosition(2)
+                .addFixedPosition(3)
+                .addFixedPosition(4)
+                .build());
+
+        when(mockNativeAdData.getAd()).thenReturn(mockNativeResponse);
+        when(mockNativeAdData2.getAd()).thenReturn(mockNativeResponse2);
+        when(mockNativeAdData3.getAd()).thenReturn(mockNativeResponse3);
+        when(mockNativeAdData4.getAd()).thenReturn(mockNativeResponse4);
+    }
+
+    @Test
+    public void initialState_isDesired() {
+        assertThat(noAds.shouldPlaceAd(0)).isFalse();
+        assertThat(noAds.shouldPlaceAd(1)).isFalse();
+        assertThat(noAds.shouldPlaceAd(2)).isFalse();
+        assertThat(noAds.shouldPlaceAd(3)).isFalse();
+        assertThat(noAds.shouldPlaceAd(4)).isFalse();
+
+        assertThat(adAt0.shouldPlaceAd(0)).isTrue();
+        assertThat(adAt0.shouldPlaceAd(1)).isFalse();
+        assertThat(adAt0.shouldPlaceAd(2)).isFalse();
+        assertThat(adAt0.shouldPlaceAd(3)).isFalse();
+        assertThat(adAt0.shouldPlaceAd(4)).isFalse();
+
+        assertThat(adAt1.shouldPlaceAd(0)).isFalse();
+        assertThat(adAt1.shouldPlaceAd(1)).isTrue();
+        assertThat(adAt1.shouldPlaceAd(2)).isFalse();
+        assertThat(adAt1.shouldPlaceAd(3)).isFalse();
+        assertThat(adAt1.shouldPlaceAd(4)).isFalse();
+
+        assertThat(adsAt01.shouldPlaceAd(0)).isTrue();
+        assertThat(adsAt01.shouldPlaceAd(1)).isFalse();
+        assertThat(adsAt01.shouldPlaceAd(2)).isFalse();
+        assertThat(adsAt01.shouldPlaceAd(3)).isFalse();
+        assertThat(adsAt01.shouldPlaceAd(4)).isFalse();
+
+        assertThat(adsAt14.shouldPlaceAd(0)).isFalse();
+        assertThat(adsAt14.shouldPlaceAd(1)).isTrue();
+        assertThat(adsAt14.shouldPlaceAd(2)).isFalse();
+        assertThat(adsAt14.shouldPlaceAd(3)).isTrue();
+        assertThat(adsAt14.shouldPlaceAd(4)).isFalse();
+
+        assertThat(adsRepeating.shouldPlaceAd(0)).isFalse();
+        assertThat(adsRepeating.shouldPlaceAd(1)).isFalse();
+        assertThat(adsRepeating.shouldPlaceAd(2)).isTrue();
+        assertThat(adsRepeating.shouldPlaceAd(3)).isFalse();
+        assertThat(adsRepeating.shouldPlaceAd(4)).isTrue();
+        assertThat(adsRepeating.shouldPlaceAd(5)).isFalse();
+        assertThat(adsRepeating.shouldPlaceAd(6)).isTrue();
+
+        assertThat(adsAt15repeating.shouldPlaceAd(0)).isFalse();
+        assertThat(adsAt15repeating.shouldPlaceAd(1)).isTrue();
+        assertThat(adsAt15repeating.shouldPlaceAd(2)).isFalse();
+        assertThat(adsAt15repeating.shouldPlaceAd(3)).isFalse();
+        assertThat(adsAt15repeating.shouldPlaceAd(4)).isTrue();
+        assertThat(adsAt15repeating.shouldPlaceAd(5)).isFalse();
+        assertThat(adsAt15repeating.shouldPlaceAd(6)).isTrue();
+        assertThat(adsAt15repeating.shouldPlaceAd(7)).isFalse();
+        assertThat(adsAt15repeating.shouldPlaceAd(8)).isTrue();
+
+        assertThat(adsAt1234.shouldPlaceAd(0)).isFalse();
+        assertThat(adsAt1234.shouldPlaceAd(1)).isTrue();
+        assertThat(adsAt1234.shouldPlaceAd(2)).isFalse();
+        assertThat(adsAt1234.shouldPlaceAd(3)).isFalse();
+    }
+
+    @Test
+    public void initialState_nextInsertionPosition() {
+        assertThat(noAds.nextInsertionPosition(0)).isEqualTo(NOT_FOUND);
+        assertThat(noAds.nextInsertionPosition(1)).isEqualTo(NOT_FOUND);
+
+        assertThat(adAt0.nextInsertionPosition(0)).isEqualTo(NOT_FOUND);
+        assertThat(adAt0.nextInsertionPosition(1)).isEqualTo(NOT_FOUND);
+
+        assertThat(adAt1.nextInsertionPosition(0)).isEqualTo(1);
+        assertThat(adAt1.nextInsertionPosition(1)).isEqualTo(NOT_FOUND);
+        assertThat(adAt1.nextInsertionPosition(2)).isEqualTo(NOT_FOUND);
+
+        assertThat(adsAt01.nextInsertionPosition(0)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt01.nextInsertionPosition(1)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt01.nextInsertionPosition(2)).isEqualTo(NOT_FOUND);
+
+        assertThat(adsAt14.nextInsertionPosition(0)).isEqualTo(1);
+        assertThat(adsAt14.nextInsertionPosition(1)).isEqualTo(3);
+        assertThat(adsAt14.nextInsertionPosition(2)).isEqualTo(3);
+        assertThat(adsAt14.nextInsertionPosition(3)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt14.nextInsertionPosition(4)).isEqualTo(NOT_FOUND);
+
+        assertThat(adsRepeating.nextInsertionPosition(0)).isEqualTo(2);
+        assertThat(adsRepeating.nextInsertionPosition(1)).isEqualTo(2);
+        assertThat(adsRepeating.nextInsertionPosition(2)).isEqualTo(4);
+        assertThat(adsRepeating.nextInsertionPosition(3)).isEqualTo(4);
+        assertThat(adsRepeating.nextInsertionPosition(4)).isEqualTo(6);
+        assertThat(adsRepeating.nextInsertionPosition(5)).isEqualTo(6);
+        assertThat(adsRepeating.nextInsertionPosition(6)).isEqualTo(8);
+
+        assertThat(adsAt15repeating.nextInsertionPosition(0)).isEqualTo(1);
+        assertThat(adsAt15repeating.nextInsertionPosition(1)).isEqualTo(4);
+        assertThat(adsAt15repeating.nextInsertionPosition(2)).isEqualTo(4);
+        assertThat(adsAt15repeating.nextInsertionPosition(3)).isEqualTo(4);
+        assertThat(adsAt15repeating.nextInsertionPosition(4)).isEqualTo(6);
+        assertThat(adsAt15repeating.nextInsertionPosition(5)).isEqualTo(6);
+        assertThat(adsAt15repeating.nextInsertionPosition(6)).isEqualTo(8);
+        assertThat(adsAt15repeating.nextInsertionPosition(7)).isEqualTo(8);
+        assertThat(adsAt15repeating.nextInsertionPosition(8)).isEqualTo(10);
+
+        assertThat(adsAt1234.nextInsertionPosition(0)).isEqualTo(1);
+        assertThat(adsAt1234.nextInsertionPosition(1)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt1234.nextInsertionPosition(2)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt1234.nextInsertionPosition(3)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt1234.nextInsertionPosition(4)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt1234.nextInsertionPosition(5)).isEqualTo(NOT_FOUND);
+    }
+
+    @Test
+    public void initialState_prevInsertionPosition() {
+        assertThat(noAds.previousInsertionPosition(0)).isEqualTo(NOT_FOUND);
+        assertThat(noAds.previousInsertionPosition(1)).isEqualTo(NOT_FOUND);
+
+        assertThat(adAt0.previousInsertionPosition(0)).isEqualTo(NOT_FOUND);
+        assertThat(adAt0.previousInsertionPosition(1)).isEqualTo(0);
+        assertThat(adAt0.previousInsertionPosition(2)).isEqualTo(0);
+
+        assertThat(adAt1.previousInsertionPosition(0)).isEqualTo(NOT_FOUND);
+        assertThat(adAt1.previousInsertionPosition(1)).isEqualTo(NOT_FOUND);
+        assertThat(adAt1.previousInsertionPosition(2)).isEqualTo(1);
+        assertThat(adAt1.previousInsertionPosition(3)).isEqualTo(1);
+
+        assertThat(adsAt01.previousInsertionPosition(0)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt01.previousInsertionPosition(1)).isEqualTo(0);
+        assertThat(adsAt01.previousInsertionPosition(2)).isEqualTo(0);
+        assertThat(adsAt01.previousInsertionPosition(3)).isEqualTo(0);
+
+        assertThat(adsAt14.previousInsertionPosition(0)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt14.previousInsertionPosition(1)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt14.previousInsertionPosition(2)).isEqualTo(1);
+        assertThat(adsAt14.previousInsertionPosition(3)).isEqualTo(1);
+        assertThat(adsAt14.previousInsertionPosition(4)).isEqualTo(3);
+        assertThat(adsAt14.previousInsertionPosition(5)).isEqualTo(3);
+
+        assertThat(adsRepeating.previousInsertionPosition(0)).isEqualTo(NOT_FOUND);
+        assertThat(adsRepeating.previousInsertionPosition(1)).isEqualTo(NOT_FOUND);
+        assertThat(adsRepeating.previousInsertionPosition(2)).isEqualTo(NOT_FOUND);
+        assertThat(adsRepeating.previousInsertionPosition(3)).isEqualTo(2);
+        assertThat(adsRepeating.previousInsertionPosition(4)).isEqualTo(2);
+        assertThat(adsRepeating.previousInsertionPosition(5)).isEqualTo(4);
+        assertThat(adsRepeating.previousInsertionPosition(6)).isEqualTo(4);
+        assertThat(adsRepeating.previousInsertionPosition(7)).isEqualTo(6);
+
+        assertThat(adsAt15repeating.previousInsertionPosition(0)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt15repeating.previousInsertionPosition(1)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt15repeating.previousInsertionPosition(2)).isEqualTo(1);
+        assertThat(adsAt15repeating.previousInsertionPosition(3)).isEqualTo(1);
+        assertThat(adsAt15repeating.previousInsertionPosition(4)).isEqualTo(1);
+        assertThat(adsAt15repeating.previousInsertionPosition(5)).isEqualTo(4);
+        assertThat(adsAt15repeating.previousInsertionPosition(6)).isEqualTo(4);
+        assertThat(adsAt15repeating.previousInsertionPosition(7)).isEqualTo(6);
+        assertThat(adsAt15repeating.previousInsertionPosition(8)).isEqualTo(6);
+        assertThat(adsAt15repeating.previousInsertionPosition(9)).isEqualTo(8);
+
+        assertThat(adsAt1234.previousInsertionPosition(0)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt1234.previousInsertionPosition(1)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt1234.previousInsertionPosition(2)).isEqualTo(1);
+        assertThat(adsAt1234.previousInsertionPosition(3)).isEqualTo(1);
+    }
+
+    @Test
+    public void initialState_isPlacedAd() {
+        assertThat(adsAt15repeating.isPlacedAd(0)).isFalse();
+        assertThat(adsAt15repeating.isPlacedAd(1)).isFalse();
+        assertThat(adsAt15repeating.isPlacedAd(10)).isFalse();
+        assertThat(adsAt15repeating.isPlacedAd(1000)).isFalse();
+
+        assertThat(noAds.isPlacedAd(0)).isFalse();
+        assertThat(noAds.isPlacedAd(1000)).isFalse();
+    }
+
+    @Test
+    public void initialState_getOriginalPosition() {
+        assertThat(adsAt15repeating.getOriginalPosition(0)).isEqualTo(0);
+        assertThat(adsAt15repeating.getOriginalPosition(1)).isEqualTo(1);
+        assertThat(adsAt15repeating.getOriginalPosition(10)).isEqualTo(10);
+        assertThat(adsAt15repeating.getOriginalPosition(1000)).isEqualTo(1000);
+
+        assertThat(noAds.getOriginalPosition(0)).isEqualTo(0);
+        assertThat(noAds.getOriginalPosition(1000)).isEqualTo(1000);
+    }
+
+    @Test
+    public void initialState_getOriginalCount() {
+        assertThat(adsAt15repeating.getOriginalCount(0)).isEqualTo(0);
+        assertThat(adsAt15repeating.getOriginalCount(1)).isEqualTo(1);
+        assertThat(adsAt15repeating.getOriginalCount(10)).isEqualTo(10);
+        assertThat(adsAt15repeating.getOriginalCount(1000)).isEqualTo(1000);
+
+        assertThat(noAds.getOriginalCount(0)).isEqualTo(0);
+        assertThat(noAds.getOriginalCount(1000)).isEqualTo(1000);
+    }
+
+    @Test
+    public void initialState_getAdjustedPosition() {
+        assertThat(adsAt15repeating.getAdjustedPosition(0)).isEqualTo(0);
+        assertThat(adsAt15repeating.getAdjustedPosition(1)).isEqualTo(1);
+        assertThat(adsAt15repeating.getAdjustedPosition(10)).isEqualTo(10);
+        assertThat(adsAt15repeating.getAdjustedPosition(1000)).isEqualTo(1000);
+
+        assertThat(noAds.getAdjustedPosition(0)).isEqualTo(0);
+        assertThat(noAds.getAdjustedPosition(1000)).isEqualTo(1000);
+    }
+
+    @Test
+    public void initialState_getAdjustedCount() {
+        assertThat(adsAt15repeating.getAdjustedCount(0)).isEqualTo(0);
+        assertThat(adsAt15repeating.getAdjustedCount(1)).isEqualTo(1);
+        assertThat(adsAt15repeating.getAdjustedCount(10)).isEqualTo(10);
+        assertThat(adsAt15repeating.getAdjustedCount(1000)).isEqualTo(1000);
+
+        assertThat(noAds.getAdjustedCount(0)).isEqualTo(0);
+        assertThat(noAds.getAdjustedCount(1000)).isEqualTo(1000);
+    }
+
+    @Test
+    public void placeAds_inOrder_shouldUpdatePositions() {
+        checkInsertionPositions(10, adsAt15repeating, 1, 4, 6, 8, 10);
+        checkPlacedPositions(20, adsAt15repeating);
+
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        checkInsertionPositions(10, adsAt15repeating, 5, 7, 9);
+        checkPlacedPositions(20, adsAt15repeating, 1);
+
+        adsAt15repeating.placeAd(5, mockNativeAdData);
+        checkInsertionPositions(10, adsAt15repeating, 8, 10);
+        checkPlacedPositions(20, adsAt15repeating, 1, 5);
+
+        adsAt15repeating.placeAd(8, mockNativeAdData);
+        checkInsertionPositions(10, adsAt15repeating);
+        checkPlacedPositions(20, adsAt15repeating, 1, 5, 8);
+    }
+
+    @Test
+    public void placeAds_outOfOrder_shouldUpdatePositions() {
+        checkInsertionPositions(10, adsAt15repeating, 1, 4, 6, 8, 10);
+        checkPlacedPositions(20, adsAt15repeating);
+
+        adsAt15repeating.placeAd(6, mockNativeAdData);
+        checkInsertionPositions(10, adsAt15repeating, 1, 4, 9);
+        checkPlacedPositions(20, adsAt15repeating, 6);
+
+        adsAt15repeating.placeAd(4, mockNativeAdData);
+        checkInsertionPositions(10, adsAt15repeating, 1, 10);
+        checkPlacedPositions(20, adsAt15repeating, 4, 7);
+
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        checkInsertionPositions(10, adsAt15repeating);
+        checkPlacedPositions(20, adsAt15repeating, 1, 5, 8);
+    }
+
+    @Test
+    public void placedAds_getOriginalPositionAndCount() {
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(5, mockNativeAdData);
+        adsAt15repeating.placeAd(8, mockNativeAdData);
+
+        assertThat(adsAt15repeating.getOriginalPosition(0)).isEqualTo(0);
+        assertThat(adsAt15repeating.getOriginalPosition(1)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt15repeating.getOriginalPosition(2)).isEqualTo(1);
+        assertThat(adsAt15repeating.getOriginalPosition(3)).isEqualTo(2);
+        assertThat(adsAt15repeating.getOriginalPosition(4)).isEqualTo(3);
+        assertThat(adsAt15repeating.getOriginalPosition(5)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt15repeating.getOriginalPosition(6)).isEqualTo(4);
+        assertThat(adsAt15repeating.getOriginalPosition(7)).isEqualTo(5);
+        assertThat(adsAt15repeating.getOriginalPosition(8)).isEqualTo(NOT_FOUND);
+        assertThat(adsAt15repeating.getOriginalPosition(9)).isEqualTo(6);
+        assertThat(adsAt15repeating.getOriginalPosition(10)).isEqualTo(7);
+
+        assertThat(adsAt15repeating.getOriginalCount(0)).isEqualTo(0);
+        assertThat(adsAt15repeating.getOriginalCount(10)).isEqualTo(7);
+        assertThat(adsAt15repeating.getOriginalCount(20)).isEqualTo(17);
+    }
+
+    @Test
+    public void placedAds_getAdjustedPositionAndCount() {
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(5, mockNativeAdData);
+        adsAt15repeating.placeAd(8, mockNativeAdData);
+
+        assertThat(adsAt15repeating.getAdjustedPosition(0)).isEqualTo(0);
+        // Ad here
+        assertThat(adsAt15repeating.getAdjustedPosition(1)).isEqualTo(2);
+        assertThat(adsAt15repeating.getAdjustedPosition(2)).isEqualTo(3);
+        assertThat(adsAt15repeating.getAdjustedPosition(3)).isEqualTo(4);
+        // Ad here
+        assertThat(adsAt15repeating.getAdjustedPosition(4)).isEqualTo(6);
+        assertThat(adsAt15repeating.getAdjustedPosition(5)).isEqualTo(7);
+        // Ad here
+        assertThat(adsAt15repeating.getAdjustedPosition(6)).isEqualTo(9);
+        assertThat(adsAt15repeating.getAdjustedPosition(7)).isEqualTo(10);
+        assertThat(adsAt15repeating.getAdjustedPosition(8)).isEqualTo(11);
+        assertThat(adsAt15repeating.getAdjustedPosition(9)).isEqualTo(12);
+        assertThat(adsAt15repeating.getAdjustedPosition(10)).isEqualTo(13);
+
+        assertThat(adsAt15repeating.getAdjustedCount(0)).isEqualTo(0);
+        assertThat(adsAt15repeating.getAdjustedCount(10)).isEqualTo(13);
+        assertThat(adsAt15repeating.getAdjustedCount(20)).isEqualTo(23);
+    }
+
+    @Test
+    public void placeAdsClumped_shouldPlaceAdsInOrder() {
+        int nextPosition = adsAt1234.nextInsertionPosition(0);
+        adsAt1234.placeAd(nextPosition, mockNativeAdData);
+
+        nextPosition = adsAt1234.nextInsertionPosition(nextPosition);
+        adsAt1234.placeAd(nextPosition, mockNativeAdData2);
+
+        nextPosition = adsAt1234.nextInsertionPosition(nextPosition);
+        adsAt1234.placeAd(nextPosition, mockNativeAdData3);
+
+        nextPosition = adsAt1234.nextInsertionPosition(nextPosition);
+        adsAt1234.placeAd(nextPosition, mockNativeAdData4);
+
+        nextPosition = adsAt1234.nextInsertionPosition(nextPosition);
+        assertThat(nextPosition).isEqualTo(NOT_FOUND);
+
+        assertThat(adsAt1234.isPlacedAd(0)).isFalse();
+        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mockNativeAdData);
+        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mockNativeAdData2);
+        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData3);
+        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mockNativeAdData4);
+        assertThat(adsAt1234.isPlacedAd(5)).isFalse();
+    }
+
+    @Test
+    public void placeAdsClumped_thenRemoveContentBeforeClumpedAds_shouldShiftAds() {
+        adsAt1234.placeAd(1, mockNativeAdData);
+        adsAt1234.placeAd(2, mockNativeAdData2);
+        adsAt1234.placeAd(3, mockNativeAdData3);
+        adsAt1234.placeAd(4, mockNativeAdData4);
+
+        adsAt1234.removeItem(0);
+        assertThat(adsAt1234.getPlacedAd(0)).isEqualTo(mockNativeAdData);
+        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mockNativeAdData2);
+        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mockNativeAdData3);
+        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData4);
+        assertThat(adsAt1234.isPlacedAd(4)).isFalse();
+
+        adsAt1234.removeItem(0);
+        assertThat(adsAt1234.getPlacedAd(0)).isEqualTo(mockNativeAdData);
+        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mockNativeAdData2);
+        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mockNativeAdData3);
+        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData4);
+        assertThat(adsAt1234.isPlacedAd(4)).isFalse();
+    }
+
+    @Test
+    public void placeAdsClumped_thenRemoveContentAfterClumpedAds_shouldNotShiftAds() {
+        adsAt1234.placeAd(1, mockNativeAdData);
+        adsAt1234.placeAd(2, mockNativeAdData2);
+        adsAt1234.placeAd(3, mockNativeAdData3);
+        adsAt1234.placeAd(4, mockNativeAdData4);
+
+        adsAt1234.removeItem(1);
+        assertThat(adsAt1234.isPlacedAd(0)).isFalse();
+        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mockNativeAdData);
+        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mockNativeAdData2);
+        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData3);
+        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mockNativeAdData4);
+        assertThat(adsAt1234.isPlacedAd(5)).isFalse();
+
+        adsAt1234.removeItem(2);
+        assertThat(adsAt1234.isPlacedAd(0)).isFalse();
+        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mockNativeAdData);
+        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mockNativeAdData2);
+        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData3);
+        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mockNativeAdData4);
+        assertThat(adsAt1234.isPlacedAd(5)).isFalse();
+    }
+
+    @Test
+    public void placeAdsClumped_thenInsertContentBeforeClumpedAds_shouldShiftAds() {
+        adsAt1234.placeAd(1, mockNativeAdData);
+        adsAt1234.placeAd(2, mockNativeAdData2);
+        adsAt1234.placeAd(3, mockNativeAdData3);
+        adsAt1234.placeAd(4, mockNativeAdData4);
+
+        adsAt1234.insertItem(1);
+        assertThat(adsAt1234.isPlacedAd(0)).isFalse();
+        assertThat(adsAt1234.isPlacedAd(1)).isFalse();
+        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mockNativeAdData);
+        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData2);
+        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mockNativeAdData3);
+        assertThat(adsAt1234.getPlacedAd(5)).isEqualTo(mockNativeAdData4);
+        assertThat(adsAt1234.isPlacedAd(6)).isFalse();
+
+        adsAt1234.insertItem(0);
+        assertThat(adsAt1234.isPlacedAd(0)).isFalse();
+        assertThat(adsAt1234.isPlacedAd(1)).isFalse();
+        assertThat(adsAt1234.isPlacedAd(2)).isFalse();
+        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData);
+        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mockNativeAdData2);
+        assertThat(adsAt1234.getPlacedAd(5)).isEqualTo(mockNativeAdData3);
+        assertThat(adsAt1234.getPlacedAd(6)).isEqualTo(mockNativeAdData4);
+        assertThat(adsAt1234.isPlacedAd(7)).isFalse();
+    }
+
+    @Test
+    public void placeAdsClumped_thenInsertContentAfterClumpedAds_shouldNotShiftAds() {
+        adsAt1234.placeAd(1, mockNativeAdData);
+        adsAt1234.placeAd(2, mockNativeAdData2);
+        adsAt1234.placeAd(3, mockNativeAdData3);
+        adsAt1234.placeAd(4, mockNativeAdData4);
+
+        adsAt1234.insertItem(2);
+        assertThat(adsAt1234.isPlacedAd(0)).isFalse();
+        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mockNativeAdData);
+        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mockNativeAdData2);
+        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData3);
+        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mockNativeAdData4);
+        assertThat(adsAt1234.isPlacedAd(5)).isFalse();
+
+        adsAt1234.removeItem(3);
+        assertThat(adsAt1234.isPlacedAd(0)).isFalse();
+        assertThat(adsAt1234.getPlacedAd(1)).isEqualTo(mockNativeAdData);
+        assertThat(adsAt1234.getPlacedAd(2)).isEqualTo(mockNativeAdData2);
+        assertThat(adsAt1234.getPlacedAd(3)).isEqualTo(mockNativeAdData3);
+        assertThat(adsAt1234.getPlacedAd(4)).isEqualTo(mockNativeAdData4);
+        assertThat(adsAt1234.isPlacedAd(5)).isFalse();
+    }
+
+    @Test
+    public void placedAds_thenClearEmptyRange_doesNothing() {
+        checkPlacedPositions(15, adsAt15repeating);
+        checkPlacedPositions(15, adsAt15repeating);
+        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
+
+        adsAt15repeating.clearAdsInRange(0, 0);
+        checkPlacedPositions(15, adsAt15repeating);
+        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
+
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(5, mockNativeAdData);
+        adsAt15repeating.placeAd(8, mockNativeAdData);
+        checkPlacedPositions(15, adsAt15repeating, 1, 5, 8);
+        checkInsertionPositions(15, adsAt15repeating, 11, 13, 15);
+
+        adsAt15repeating.clearAdsInRange(4, 4);
+        checkPlacedPositions(15, adsAt15repeating, 1, 5, 8);
+        checkInsertionPositions(15, adsAt15repeating, 11, 13, 15);
+    }
+
+    @Test
+    public void placedAds_thenClearAll_shouldResetInsertionPositions() {
+        checkPlacedPositions(15, adsAt15repeating);
+        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
+
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(5, mockNativeAdData);
+        adsAt15repeating.placeAd(8, mockNativeAdData);
+        checkPlacedPositions(15, adsAt15repeating, 1, 5, 8);
+        checkInsertionPositions(15, adsAt15repeating, 11, 13, 15);
+
+        adsAt15repeating.clearAdsInRange(1, 10);
+        checkPlacedPositions(15, adsAt15repeating);
+        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
+    }
+
+    @Test
+    public void placedAds_thenClearRange_inOrder_shouldResetInsertionPositions() {
+        checkPlacedPositions(15, adsAt15repeating);
+        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
+
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(5, mockNativeAdData);
+        adsAt15repeating.placeAd(8, mockNativeAdData);
+        checkPlacedPositions(15, adsAt15repeating, 1, 5, 8);
+        checkInsertionPositions(15, adsAt15repeating, 11, 13, 15);
+
+        adsAt15repeating.clearAdsInRange(1, 2);
+        checkPlacedPositions(15, adsAt15repeating, 4, 7);
+        checkInsertionPositions(15, adsAt15repeating, 1, 10, 12, 14);
+
+        adsAt15repeating.clearAdsInRange(4, 5);
+        checkPlacedPositions(15, adsAt15repeating, 6);
+        checkInsertionPositions(15, adsAt15repeating, 1, 4, 9, 11, 13, 15);
+
+        adsAt15repeating.clearAdsInRange(6, 7);
+        checkPlacedPositions(15, adsAt15repeating);
+        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
+    }
+
+    @Test
+    public void placedAds_thenClearRange_descending_shouldResetInsertionPositions() {
+        checkPlacedPositions(15, adsAt15repeating);
+        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
+
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(5, mockNativeAdData);
+        adsAt15repeating.placeAd(8, mockNativeAdData);
+        checkPlacedPositions(15, adsAt15repeating, 1, 5, 8);
+        checkInsertionPositions(15, adsAt15repeating, 11, 13, 15);
+
+        adsAt15repeating.clearAdsInRange(8, 9);
+        checkPlacedPositions(15, adsAt15repeating, 1, 5);
+        checkInsertionPositions(15, adsAt15repeating, 8, 10, 12, 14);
+
+        adsAt15repeating.clearAdsInRange(5, 6);
+        checkPlacedPositions(15, adsAt15repeating, 1);
+        checkInsertionPositions(15, adsAt15repeating, 5, 7, 9, 11, 13, 15);
+
+        adsAt15repeating.clearAdsInRange(1, 2);
+        checkPlacedPositions(15, adsAt15repeating);
+        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
+    }
+
+    @Test
+    public void placedAds_thenClearRange_multiple_shouldResetInsertionPositions() {
+        checkPlacedPositions(15, adsAt15repeating);
+        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
+
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(5, mockNativeAdData);
+        adsAt15repeating.placeAd(8, mockNativeAdData);
+        checkPlacedPositions(15, adsAt15repeating, 1, 5, 8);
+        checkInsertionPositions(15, adsAt15repeating, 11, 13, 15);
+
+        adsAt15repeating.clearAdsInRange(1, 6);
+        checkPlacedPositions(15, adsAt15repeating, 6);
+        checkInsertionPositions(15, adsAt15repeating, 1, 4, 9, 11, 13, 15);
+
+        adsAt15repeating.clearAdsInRange(5, 10);
+        checkPlacedPositions(15, adsAt15repeating);
+        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
+    }
+
+    @Test
+    public void placedAds_thenClearRange_descending_multiple_shouldResetInsertionPositions() {
+        checkPlacedPositions(15, adsAt15repeating);
+        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
+
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(5, mockNativeAdData);
+        adsAt15repeating.placeAd(8, mockNativeAdData);
+        checkPlacedPositions(15, adsAt15repeating, 1, 5, 8);
+        checkInsertionPositions(15, adsAt15repeating, 11, 13, 15);
+
+        adsAt15repeating.clearAdsInRange(5, 9);
+        checkPlacedPositions(15, adsAt15repeating, 1);
+        checkInsertionPositions(15, adsAt15repeating, 5, 7, 9, 11, 13, 15);
+
+        adsAt15repeating.clearAdsInRange(1, 5);
+        checkPlacedPositions(15, adsAt15repeating);
+        checkInsertionPositions(15, adsAt15repeating, 1, 4, 6, 8, 10, 12, 14);
+    }
+
+    @Test
+    public void placeAds_thenClear_shouldCallDestroy() {
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(5, mockNativeAdData2);
+        adsAt15repeating.placeAd(8, mockNativeAdData3);
+
+        adsAt15repeating.clearAdsInRange(5, 10);
+        verify(mockNativeResponse, never()).destroy();
+        verify(mockNativeResponse2).destroy();
+        verify(mockNativeResponse3).destroy();
+    }
+
+    @Test
+    public void insertItems_afterPlacing() {
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(5, mockNativeAdData);
+        adsAt15repeating.placeAd(8, mockNativeAdData);
+
+        adsAt15repeating.insertItem(1);
+        adsAt15repeating.insertItem(4);
+        adsAt15repeating.insertItem(12);
+
+        checkPlacedPositions(20, adsAt15repeating, 2, 7, 10);
+    }
+
+    @Test
+    public void insertItems_beforePlacing() {
+        checkInsertionPositions(7, adsAt15repeating, 1, 4, 6);
+
+        adsAt15repeating.insertItem(4);
+        adsAt15repeating.insertItem(7);
+
+        checkInsertionPositions(9, adsAt15repeating, 1, 5, 8);
+    }
+
+    @Test
+    public void removeThenInsertItem_atZero_shouldBeAtZero() {
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(5, mockNativeAdData);
+        adsAt15repeating.placeAd(8, mockNativeAdData);
+
+        adsAt15repeating.removeItem(0);
+        checkPlacedPositions(20, adsAt15repeating, 0, 4, 7);
+        checkInsertionPositions(16, adsAt15repeating, 10, 12, 14, 16);
+
+        adsAt15repeating.insertItem(0);
+        checkPlacedPositions(20, adsAt15repeating, 1, 5, 8);
+        checkInsertionPositions(16, adsAt15repeating, 11, 13, 15);
+    }
+
+    @Test
+    public void placeThenInsertThenPlace() {
+        adsAt15repeating.placeAd(4, mockNativeAdData);
+        adsAt15repeating.insertItem(4);
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+
+        checkPlacedPositions(20, adsAt15repeating, 1, 6);
+    }
+
+    @Test
+    public void removeItems_afterPlacing() {
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(5, mockNativeAdData);
+        adsAt15repeating.placeAd(8, mockNativeAdData);
+
+        checkPlacedPositions(20, adsAt15repeating, 1, 5, 8);
+
+        adsAt15repeating.removeItem(3);
+        adsAt15repeating.removeItem(5);
+
+        checkPlacedPositions(20, adsAt15repeating, 1, 4, 7);
+
+        // Check the adjusted positions.
+        assertThat(adsAt15repeating.getAdjustedPosition(0)).isEqualTo(0);
+        assertThat(adsAt15repeating.getAdjustedPosition(1)).isEqualTo(2);
+        assertThat(adsAt15repeating.getAdjustedPosition(2)).isEqualTo(3);
+        assertThat(adsAt15repeating.getAdjustedPosition(3)).isEqualTo(5);
+        assertThat(adsAt15repeating.getAdjustedPosition(4)).isEqualTo(6);
+        assertThat(adsAt15repeating.getAdjustedPosition(5)).isEqualTo(8);
+    }
+
+    @Test
+    public void removeItemsBetweenAds_thenInsert_shouldClumpAds() {
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(5, mockNativeAdData);
+        adsAt15repeating.placeAd(8, mockNativeAdData);
+
+        adsAt15repeating.removeItem(4);
+        adsAt15repeating.removeItem(4);
+
+        checkPlacedPositions(20, adsAt15repeating, 1, 5, 6);
+
+        adsAt15repeating.insertItem(5);
+
+        checkPlacedPositions(20, adsAt15repeating, 1, 5, 6);
+
+        adsAt15repeating.insertItem(4);
+
+        checkPlacedPositions(20, adsAt15repeating, 1, 6, 7);
+    }
+
+    @Test
+    public void removeItems_beforePlacing() {
+        checkInsertionPositions(7, adsAt15repeating, 1, 4, 6);
+
+        adsAt15repeating.removeItem(4);
+
+        // Check insertion positions.
+        checkInsertionPositions(7, adsAt15repeating, 1, 4, 5, 7);
+    }
+
+    @Test
+    public void removeItem_withClumpedAdsBeforeIt_shouldCorrectlyRemoveItem() throws Exception {
+        adsRepeating.placeAd(2, mockNativeAdData);
+        adsRepeating.placeAd(5, mockNativeAdData);
+        adsRepeating.placeAd(8, mockNativeAdData);
+
+        checkPlacedPositions(20, adsRepeating, 2, 5, 8);
+        assertThat(adsRepeating.getAdjustedCount(7)).isEqualTo(10);
+
+        // Removing from the head will cause ads to pile up
+        adsRepeating.removeItem(0);
+        adsRepeating.removeItem(0);
+        adsRepeating.removeItem(0);
+        adsRepeating.removeItem(0);
+        adsRepeating.removeItem(0);
+        adsRepeating.removeItem(0);
+
+        checkPlacedPositions(20, adsRepeating, 0, 1, 2);
+
+        adsRepeating.removeItem(0);
+
+        checkPlacedPositions(20, adsRepeating, 0, 1, 2);
+    }
+
+    @Test
+    public void removeItems_afterClumpedAds_shouldStayClumped() {
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(5, mockNativeAdData);
+        adsAt15repeating.placeAd(8, mockNativeAdData);
+
+        adsAt15repeating.removeItem(4);
+        adsAt15repeating.removeItem(4);
+
+        checkPlacedPositions(20, adsAt15repeating, 1, 5, 6);
+
+        // Shouldn't move any ads.
+        adsAt15repeating.removeItem(4);
+
+        checkPlacedPositions(20, adsAt15repeating, 1, 5, 6);
+
+        adsAt15repeating.removeItem(3);
+
+        checkPlacedPositions(20, adsAt15repeating, 1, 4, 5);
+    }
+
+    @Test
+    public void moveItems_afterPlacing() {
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(5, mockNativeAdData);
+        adsAt15repeating.placeAd(8, mockNativeAdData);
+
+        assertThat(adsAt15repeating.getAdjustedPosition(4)).isEqualTo(6);
+        assertThat(adsAt15repeating.getAdjustedPosition(5)).isEqualTo(7);
+
+        adsAt15repeating.moveItem(4, 2);
+
+        checkPlacedPositions(20, adsAt15repeating, 1, 6, 8);
+
+        assertThat(adsAt15repeating.getAdjustedPosition(4)).isEqualTo(5);
+        assertThat(adsAt15repeating.getAdjustedPosition(5)).isEqualTo(7);
+    }
+
+    @Test
+    public void clearAll_shouldCallDestroyOnAdData_shouldResetPositions() {
+        when(mockNativeAdData.getAd()).thenReturn(mockNativeResponse);
+        when(mockNativeAdData2.getAd()).thenReturn(mockNativeResponse2);
+        when(mockNativeAdData3.getAd()).thenReturn(mockNativeResponse3);
+
+        adsAt15repeating.placeAd(1, mockNativeAdData);
+        adsAt15repeating.placeAd(5, mockNativeAdData2);
+        adsAt15repeating.placeAd(8, mockNativeAdData3);
+
+        adsAt15repeating.clearAds();
+
+        verify(mockNativeResponse).destroy();
+        verify(mockNativeResponse2).destroy();
+        verify(mockNativeResponse3).destroy();
+
+        // Should reset to original positions
+        checkInsertionPositions(10, adsAt15repeating, 1, 4, 6, 8, 10);
+        checkPlacedPositions(20, adsAt15repeating);
+    }
+
+    void checkInsertionPositions(int maxValue, PlacementData placementData, Integer... positions) {
+        List<Integer> expected = Arrays.asList(positions);
+        List<Integer> actual = new ArrayList<Integer>();
+        for (int i = 0; i <= maxValue; i++) {
+            if (placementData.shouldPlaceAd(i)) {
+                actual.add(i);
+            }
+        }
+
+        assertThat(actual).isEqualTo(expected);
+    }
+
+    void checkPlacedPositions(int maxValue, PlacementData placementData, Integer... positions) {
+        List<Integer> expected = Arrays.asList(positions);
+        List<Integer> actual = new ArrayList<Integer>();
+        for (int i = 0; i < maxValue; i++) {
+            if (placementData.isPlacedAd(i)) {
+                actual.add(i);
+                assertThat(placementData.getPlacedAd(i)).isEqualTo(mockNativeAdData);
+            } else {
+                assertThat(placementData.getPlacedAd(i)).isNull();
+            }
+        }
+
+        assertThat(actual).isEqualTo(expected);
+
+        // Also check getPlacedAdPositions
+        List<Integer> actualFromAdPositions = new ArrayList<Integer>();
+        for (Integer position : placementData.getPlacedAdPositions()) {
+            actualFromAdPositions.add(position);
+        }
+        assertThat(actualFromAdPositions).isEqualTo(expected);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/VisibilityTrackerTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/VisibilityTrackerTest.java
new file mode 100644
index 00000000..d0f1f88a
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/VisibilityTrackerTest.java
@@ -0,0 +1,338 @@
+package com.mopub.nativeads;
+
+import android.app.Activity;
+import android.graphics.Rect;
+import android.os.Handler;
+import android.os.SystemClock;
+import android.view.View;
+import android.view.ViewParent;
+import android.view.ViewTreeObserver;
+import android.view.Window;
+
+import com.mopub.nativeads.VisibilityTracker.TrackingInfo;
+import com.mopub.nativeads.test.support.SdkTestRunner;
+
+import org.fest.util.Lists;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.shadows.ShadowSystemClock;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.WeakHashMap;
+
+import static android.view.ViewTreeObserver.OnPreDrawListener;
+import static com.mopub.nativeads.VisibilityTracker.VisibilityChecker;
+import static com.mopub.nativeads.VisibilityTracker.VisibilityTrackerListener;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class VisibilityTrackerTest {
+    private static final int MIN_PERCENTAGE_VIEWED = 50;
+
+    private Activity activity;
+    private VisibilityTracker subject;
+    private Map<View, TrackingInfo> trackedViews;
+    private VisibilityChecker visibilityChecker;
+
+    @Mock private VisibilityTrackerListener visibilityTrackerListener;
+    @Mock private View view;
+    @Mock private View view2;
+    @Mock private Handler visibilityHandler;
+
+    @Before
+    public void setUp() throws Exception {
+        trackedViews = new WeakHashMap<View, TrackingInfo>();
+        visibilityChecker = new VisibilityChecker();
+        activity = new Activity();
+        view = createViewMock(View.VISIBLE, 100, 100, 100, 100, true, true);
+        view2 = createViewMock(View.VISIBLE, 100, 100, 100, 100, true, true);
+
+        // Add a proxy listener to that makes a safe copy of the listener args.
+        VisibilityTrackerListener proxyListener = new VisibilityTrackerListener() {
+            @Override
+            public void onVisibilityChanged(List<View> visibleViews, List<View> invisibleViews) {
+                ArrayList<View> safeVisibleViews = new ArrayList<View>(visibleViews);
+                ArrayList<View> safeInVisibleViews = new ArrayList<View>(invisibleViews);
+                visibilityTrackerListener.onVisibilityChanged(safeVisibleViews, safeInVisibleViews);
+            }
+        };
+        subject = new VisibilityTracker(activity, trackedViews, visibilityChecker, visibilityHandler);
+        subject.setVisibilityTrackerListener(proxyListener);
+
+        // XXX We need this to ensure that our SystemClock starts
+        ShadowSystemClock.uptimeMillis();
+    }
+
+    @Test
+    public void constructor_shouldSetOnPreDrawListenerForDecorView() throws Exception {
+        Activity activity1 = mock(Activity.class);
+        Window window = mock(Window.class);
+        View decorView = mock(View.class);
+        ViewTreeObserver viewTreeObserver = mock(ViewTreeObserver.class);
+
+        when(activity1.getWindow()).thenReturn(window);
+        when(window.getDecorView()).thenReturn(decorView);
+        when(decorView.getViewTreeObserver()).thenReturn(viewTreeObserver);
+        when(viewTreeObserver.isAlive()).thenReturn(true);
+
+        subject = new VisibilityTracker(activity1, trackedViews, visibilityChecker, visibilityHandler);
+        assertThat(subject.mRootView.get()).isEqualTo(decorView);
+        assertThat(subject.mOnPreDrawListener).isNotNull();
+        verify(viewTreeObserver).addOnPreDrawListener(subject.mOnPreDrawListener);
+    }
+
+    @Test
+    public void constructor_withNonAliveViewTreeObserver_shouldNotSetOnPreDrawListenerForDecorView() throws Exception {
+        Activity activity1 = mock(Activity.class);
+        Window window = mock(Window.class);
+        View decorView = mock(View.class);
+        ViewTreeObserver viewTreeObserver = mock(ViewTreeObserver.class);
+
+        when(activity1.getWindow()).thenReturn(window);
+        when(window.getDecorView()).thenReturn(decorView);
+        when(decorView.getViewTreeObserver()).thenReturn(viewTreeObserver);
+        when(viewTreeObserver.isAlive()).thenReturn(false);
+
+        subject = new VisibilityTracker(activity1, trackedViews, visibilityChecker, visibilityHandler);
+        assertThat(subject.mRootView.get()).isEqualTo(decorView);
+        assertThat(subject.mOnPreDrawListener).isNull();
+        verify(viewTreeObserver, never()).addOnPreDrawListener(subject.mOnPreDrawListener);
+    }
+
+    @Test
+    public void addView_withVisibleView_shouldAddVisibleViewToTrackedViews() throws Exception {
+        subject.addView(view, MIN_PERCENTAGE_VIEWED);
+
+        assertThat(trackedViews).hasSize(1);
+    }
+
+    @Test(expected = AssertionError.class)
+    public void addView_whenViewIsNull_shouldThrowNPE() throws Exception {
+        subject.addView(null, MIN_PERCENTAGE_VIEWED);
+
+        assertThat(trackedViews).isEmpty();
+    }
+
+    @Test
+    public void removeView_shouldRemoveFromTrackedViews() throws Exception {
+        subject.addView(view, MIN_PERCENTAGE_VIEWED);
+
+        assertThat(trackedViews).hasSize(1);
+        assertThat(trackedViews).containsKey(view);
+
+        subject.removeView(view);
+
+        assertThat(trackedViews).isEmpty();
+    }
+
+    @Test
+    public void clear_shouldRemoveAllViewsFromTrackedViews_shouldRemoveMessagesFromVisibilityHandler_shouldResetIsVisibilityScheduled() throws Exception {
+        subject.addView(view, MIN_PERCENTAGE_VIEWED);
+        subject.addView(view2, MIN_PERCENTAGE_VIEWED);
+        assertThat(trackedViews).hasSize(2);
+
+        subject.clear();
+
+        assertThat(trackedViews).isEmpty();
+        verify(visibilityHandler).removeMessages(0);
+    }
+
+    @Test
+    public void destroy_shouldCallClear_shouldRemoveListenerFromDecorView() throws Exception {
+        Activity activity1 = mock(Activity.class);
+        Window window = mock(Window.class);
+        View decorView = mock(View.class);
+        ViewTreeObserver viewTreeObserver = mock(ViewTreeObserver.class);
+
+        when(activity1.getWindow()).thenReturn(window);
+        when(window.getDecorView()).thenReturn(decorView);
+        when(decorView.getViewTreeObserver()).thenReturn(viewTreeObserver);
+        when(viewTreeObserver.isAlive()).thenReturn(true);
+
+        subject = new VisibilityTracker(activity1, trackedViews, visibilityChecker, visibilityHandler);
+
+        subject.addView(view, MIN_PERCENTAGE_VIEWED);
+        subject.addView(view2, MIN_PERCENTAGE_VIEWED);
+        assertThat(trackedViews).hasSize(2);
+
+        subject.destroy();
+
+        assertThat(trackedViews).isEmpty();
+        verify(visibilityHandler).removeMessages(0);
+        verify(viewTreeObserver).removeOnPreDrawListener(any(OnPreDrawListener.class));
+        assertThat(subject.mOnPreDrawListener).isNull();
+    }
+
+    @Test
+    public void visibilityRunnable_run_withVisibleView_shouldCallOnVisibleCallback() throws Exception {
+        subject.addView(view, MIN_PERCENTAGE_VIEWED);
+
+        subject.new VisibilityRunnable().run();
+
+        verify(visibilityTrackerListener).onVisibilityChanged(
+                Lists.newArrayList(view), Lists.<View>newArrayList());
+    }
+
+    @Test
+    public void visibilityRunnable_run_withNonVisibleView_shouldCallOnNonVisibleCallback() throws Exception {
+        when(view.getVisibility()).thenReturn(View.INVISIBLE);
+        subject.addView(view, MIN_PERCENTAGE_VIEWED);
+
+        subject.new VisibilityRunnable().run();
+
+        ArgumentCaptor<List> visibleCaptor = ArgumentCaptor.forClass(List.class);
+        ArgumentCaptor<List> invisibleCaptor = ArgumentCaptor.forClass(List.class);
+        verify(visibilityTrackerListener).onVisibilityChanged(visibleCaptor.capture(),
+                invisibleCaptor.capture());
+        assertThat(visibleCaptor.getValue().size()).isEqualTo(0);
+        assertThat(invisibleCaptor.getValue().size()).isEqualTo(1);
+    }
+
+    // VisibilityChecker tests
+
+    @Test
+    public void hasRequiredTimeElapsed_withElapsedTimeGreaterThanMinTimeViewed_shouldReturnTrue() throws Exception {
+        assertThat(visibilityChecker.hasRequiredTimeElapsed(SystemClock.uptimeMillis() - 501, 500)).isTrue();
+    }
+
+    @Test
+    public void hasRequiredTimeElapsed_withElapsedTimeLessThanMinTimeViewed_shouldReturnFalse() throws Exception {
+        assertThat(visibilityChecker.hasRequiredTimeElapsed(SystemClock.uptimeMillis() - 499, 500)).isFalse();
+    }
+
+    @Test
+    public void isMostlyVisible_whenParentIsNull_shouldReturnFalse() throws Exception {
+        view = createViewMock(View.VISIBLE, 100, 100, 100, 100, false, true);
+        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isFalse();
+    }
+
+    @Test
+    public void isMostlyVisible_whenViewIsOffScreen_shouldReturnFalse() throws Exception {
+        view = createViewMock(View.VISIBLE, 100, 100, 100, 100, true, false);
+        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isFalse();
+    }
+
+    @Test
+    public void isMostlyVisible_whenViewIsEntirelyOnScreen_shouldReturnTrue() throws Exception {
+        view = createViewMock(View.VISIBLE, 100, 100, 100, 100, true, true);
+
+        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isTrue();
+    }
+
+    @Test
+    public void isMostlyVisible_whenViewIs50PercentVisible_shouldReturnTrue() throws Exception {
+        view = createViewMock(View.VISIBLE, 50, 100, 100, 100, true, true);
+
+        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isTrue();
+    }
+
+    @Test
+    public void isMostlyVisible_whenViewIs49PercentVisible_shouldReturnFalse() throws Exception {
+        view = createViewMock(View.VISIBLE, 49, 100, 100, 100, true, true);
+
+        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isFalse();
+    }
+
+    @Test
+    public void isMostlyVisible_whenVisibleAreaIsZero_shouldReturnFalse() throws Exception {
+        view = createViewMock(View.VISIBLE, 0, 0, 100, 100, true, true);
+
+        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isFalse();
+    }
+
+    @Test
+    public void isMostlyVisible_whenViewIsInvisibleOrGone_shouldReturnFalse() throws Exception {
+        View view = createViewMock(View.INVISIBLE, 100, 100, 100, 100, true, true);
+        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isFalse();
+
+        reset(view);
+        view = createViewMock(View.GONE, 100, 100, 100, 100, true, true);
+        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isFalse();
+    }
+
+    @Test
+    public void isMostlyVisible_whenViewHasZeroWidthAndHeight_shouldReturnFalse() throws Exception {
+        view = createViewMock(View.VISIBLE, 100, 100, 0, 0, true, true);
+
+        assertThat(visibilityChecker.isVisible(view, MIN_PERCENTAGE_VIEWED)).isFalse();
+    }
+
+    @Test
+    public void isMostlyVisible_whenViewIsNull_shouldReturnFalse() throws Exception {
+        assertThat(visibilityChecker.isVisible(null, MIN_PERCENTAGE_VIEWED)).isFalse();
+    }
+
+    @Test
+    public void addView_shouldClearViewAfterNumAccesses() {
+        // Access 1 time
+        subject.addView(view, MIN_PERCENTAGE_VIEWED);
+        assertThat(trackedViews).hasSize(1);
+
+        // Access 2-49 times
+        for (int i = 0; i < VisibilityTracker.NUM_ACCESSES_BEFORE_TRIMMING - 2; ++i) {
+            subject.addView(view2, MIN_PERCENTAGE_VIEWED);
+        }
+        assertThat(trackedViews).hasSize(2);
+
+        // 50th time
+        subject.addView(view2, MIN_PERCENTAGE_VIEWED);
+        assertThat(trackedViews).hasSize(2);
+
+        // 51-99
+        for (int i = 0; i < VisibilityTracker.NUM_ACCESSES_BEFORE_TRIMMING - 1; ++i) {
+            subject.addView(view2, MIN_PERCENTAGE_VIEWED);
+        }
+        assertThat(trackedViews).hasSize(2);
+
+        // 100
+        subject.addView(view2, MIN_PERCENTAGE_VIEWED);
+        assertThat(trackedViews).hasSize(1);
+    }
+
+    static View createViewMock(final int visibility,
+            final int visibleWidth,
+            final int visibleHeight,
+            final int viewWidth,
+            final int viewHeight,
+            final boolean isParentSet,
+            final boolean isOnScreen) {
+        View view = mock(View.class);
+        when(view.getContext()).thenReturn(new Activity());
+        when(view.getVisibility()).thenReturn(visibility);
+
+        when(view.getGlobalVisibleRect(any(Rect.class)))
+                .thenAnswer(new Answer<Boolean>() {
+                    @Override
+                    public Boolean answer(InvocationOnMock invocationOnMock) throws Throwable {
+                        Object[] args = invocationOnMock.getArguments();
+                        Rect rect = (Rect) args[0];
+                        rect.set(0, 0, visibleWidth, visibleHeight);
+                        return isOnScreen;
+                    }
+                });
+
+        when(view.getWidth()).thenReturn(viewWidth);
+        when(view.getHeight()).thenReturn(viewHeight);
+
+        if (isParentSet) {
+            when(view.getParent()).thenReturn(mock(ViewParent.class));
+        }
+
+        when(view.getViewTreeObserver()).thenCallRealMethod();
+
+        return view;
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/test/support/MoPubShadowBitmap.java b/mopub-sdk/src/test/java/com/mopub/nativeads/test/support/MoPubShadowBitmap.java
new file mode 100644
index 00000000..614254fc
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/test/support/MoPubShadowBitmap.java
@@ -0,0 +1,18 @@
+package com.mopub.nativeads.test.support;
+
+import android.graphics.Bitmap;
+
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadows.ShadowBitmap;
+
+// XXX the config for a newly created ShadowBitmap is never set so we need to set it ourselves
+// https://github.com/robolectric/robolectric/issues/876
+@Implements(Bitmap.class)
+public class MoPubShadowBitmap extends ShadowBitmap {
+
+    public MoPubShadowBitmap() {
+        // can also be some other config value
+        setConfig(Bitmap.Config.ARGB_8888);
+    }
+}
+
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/test/support/MoPubShadowDisplay.java b/mopub-sdk/src/test/java/com/mopub/nativeads/test/support/MoPubShadowDisplay.java
new file mode 100644
index 00000000..9b38d956
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/test/support/MoPubShadowDisplay.java
@@ -0,0 +1,16 @@
+package com.mopub.nativeads.test.support;
+
+import android.graphics.Point;
+import android.view.Display;
+
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadows.ShadowDisplay;
+
+/* Our old version of Robolectric doesn't have the newer Display.class methods implemented. */
+@Implements(Display.class)
+public class MoPubShadowDisplay extends ShadowDisplay {
+
+    public void getSize(Point size) {
+        size.set(getWidth(), getHeight());
+    }
+}
diff --git a/pom.xml b/pom.xml
index 5be7e9c3..7d637a7c 100644
--- a/pom.xml
+++ b/pom.xml
@@ -19,13 +19,13 @@
         <repository>
             <id>andsupport</id>
             <name>Android Support</name>
-            <url>file://${env.ANDROID_HOME}/extras/android/m2repository</url>
+            <url>file:///${env.ANDROID_HOME}/extras/android/m2repository</url>
         </repository>
 
         <repository>
             <id>playservices</id>
             <name>Android Play Services</name>
-            <url>file://${env.ANDROID_HOME}/extras/google/m2repository</url>
+            <url>file:///${env.ANDROID_HOME}/extras/google/m2repository</url>
         </repository>
     </repositories>
 
diff --git a/robotium-sample/AndroidManifest.xml b/robotium-sample/AndroidManifest.xml
index 24230c17..e42dca4f 100644
--- a/robotium-sample/AndroidManifest.xml
+++ b/robotium-sample/AndroidManifest.xml
@@ -3,7 +3,7 @@
       package="com.mopub.mobileads.robotium"
       android:versionCode="1"
       android:versionName="1.0">
-    <uses-sdk android:minSdkVersion="8" />
+    <uses-sdk android:minSdkVersion="9" />
 
     <uses-permission android:name="android.permission.INTERNET" />
     <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
@@ -18,9 +18,14 @@
 	        </intent-filter>
 	    </activity>
 
-        <activity android:name="com.mopub.mobileads.MoPubActivity" android:configChanges="keyboardHidden|orientation"/>
-        <activity android:name="com.mopub.mobileads.MraidActivity" android:configChanges="keyboardHidden|orientation"/>
-        <activity android:name="com.mopub.common.MoPubBrowser" android:configChanges="keyboardHidden|orientation"/>
+        <activity android:name="com.mopub.mobileads.MoPubActivity"
+                android:configChanges="keyboardHidden|orientation"/>
+        <activity android:name="com.mopub.mobileads.MraidActivity"
+                android:configChanges="keyboardHidden|orientation"/>
+        <activity android:name="com.mopub.common.MoPubBrowser"
+                android:configChanges="keyboardHidden|orientation"/>
+        <activity android:name="com.mopub.mobileads.MraidVideoPlayerActivity"
+                android:configChanges="keyboardHidden|orientation"/>
     </application>
 
 </manifest>
diff --git a/robotium-tests/AndroidManifest.xml b/robotium-tests/AndroidManifest.xml
index 03714b71..8de11840 100644
--- a/robotium-tests/AndroidManifest.xml
+++ b/robotium-tests/AndroidManifest.xml
@@ -3,11 +3,14 @@
 		package="com.mopub.mobileads.test"
 		android:versionCode="1"
 		android:versionName="1.0">
-	<uses-sdk android:minSdkVersion="8"/>
+	<uses-sdk android:minSdkVersion="9"/>
 
     <instrumentation android:targetPackage="com.mopub.mobileads.robotium" android:name="android.test.InstrumentationTestRunner" />
 
     <application android:label="Cool Activity Test">
         <uses-library android:name="android.test.runner" />
+
+        <meta-data android:name="com.google.android.gms.version"
+                   android:value="@integer/google_play_services_version" />
     </application>
 </manifest>
diff --git a/robotium-tests/pom.xml b/robotium-tests/pom.xml
index 262b5451..68eddd9c 100644
--- a/robotium-tests/pom.xml
+++ b/robotium-tests/pom.xml
@@ -25,6 +25,12 @@
             <scope>provided</scope>
         </dependency>
 
+        <dependency>
+            <groupId>com.google.android.gms</groupId>
+            <artifactId>play-services</artifactId>
+            <version>5.2.08</version>
+            <type>aar</type>
+        </dependency>
 
         <!--test-->
 
diff --git a/robotium-tests/src/main/java/com/mopub/mobileads/test/RobotiumTestSupportActivityTest.java b/robotium-tests/src/main/java/com/mopub/mobileads/test/RobotiumTestSupportActivityTest.java
index 3ddad10e..9c392177 100644
--- a/robotium-tests/src/main/java/com/mopub/mobileads/test/RobotiumTestSupportActivityTest.java
+++ b/robotium-tests/src/main/java/com/mopub/mobileads/test/RobotiumTestSupportActivityTest.java
@@ -48,7 +48,7 @@
 import static com.mopub.mobileads.MoPubInterstitial.InterstitialAdListener;
 
 public class RobotiumTestSupportActivityTest extends ActivityInstrumentationTestCase2<RobotiumTestSupportActivity>{
-    private static final long NETWORK_SLEEP_TIME = 3000;
+    private static final long NETWORK_SLEEP_TIME = 8000;
     private static final String BANNER_AD_UNIT_ID = "agltb3B1Yi1pbmNyDAsSBFNpdGUY8fgRDA";
     private static final String INTERSTITIAL_AD_UNIT_ID = "agltb3B1Yi1pbmNyDAsSBFNpdGUY6tERDA";
 
