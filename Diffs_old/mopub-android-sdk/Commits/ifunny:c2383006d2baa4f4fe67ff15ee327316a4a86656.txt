diff --git a/CHANGELOG.md b/CHANGELOG.md
index 00f6290c..a7979dd3 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,28 @@
+## Version 4.13.0 (March 23, 2017)
+
+- Updated AdColony Custom Events.
+- Updated Unity Custom Events.
+- Added AdMob Custom Events:
+  - Native: `GooglePlayServicesAdRenderer` and `GooglePlayServicesNative`
+  - Rewarded Video: `GooglePlayServicesRewardedVideo`
+- Bug fixes.
+
+## Version 4.12.0 (February 9, 2017)
+
+- Updated minimum supported Android API version to 16+ (Jelly Bean).
+- New required Activity declaration in `AndroidManifest`, please add:
+
+```
+<activity android:name="com.mopub.mobileads.RewardedMraidActivity"
+          android:configChanges="keyboardHidden|orientation|screenSize"/>
+```
+- Added support for **rich media in rewarded video** inventory.
+- Bug fixes:
+    - Fixed incorrectly forwarded lifecycle events `onStop()` and `onDestroy()` in `MoPubLifeCycleManager` for rewarded rich media ads.
+    - Prevented MoPub-related crashes due to system-level WebView updates while the app is running.
+    - Allow video playback in `reverseLandscape` orientation (in addition to previously supported `landscape` orientation).
+    - Fixed crash caused by invalid VAST absolute tracker values.
+
 ## Version 4.11.0 (November 10, 2016)
 - Added a workaround for an Android bug where Lollipop devices (Android 5.1.1, API level 22) and lower incorrectly handle SSL connections using Server Name Identification.
 - Rewarded video `load()` calls now do not load another rewarded video with the same ad unit id while one is already loading or loaded.
diff --git a/README.md b/README.md
index be76ca00..a64f9262 100644
--- a/README.md
+++ b/README.md
@@ -27,7 +27,7 @@ The MoPub SDK is available via:
     }
 
     dependencies {
-        compile('com.mopub:mopub-sdk:4.11.0@aar') {
+        compile('com.mopub:mopub-sdk:4.13.0@aar') {
             transitive = true
         }
     }
@@ -48,27 +48,27 @@ The MoPub SDK is available via:
         // ... other project dependencies
 
         // For banners
-        compile('com.mopub:mopub-sdk-banner:4.11.0@aar') {
+        compile('com.mopub:mopub-sdk-banner:4.13.0@aar') {
             transitive = true
         }
         
         // For interstitials
-        compile('com.mopub:mopub-sdk-interstitial:4.11.0@aar') {
+        compile('com.mopub:mopub-sdk-interstitial:4.13.0@aar') {
             transitive = true
         }
 
         // For rewarded videos. This will automatically also include interstitials
-        compile('com.mopub:mopub-sdk-rewardedvideo:4.11.0@aar') {
+        compile('com.mopub:mopub-sdk-rewardedvideo:4.13.0@aar') {
             transitive = true
         }
 
         // For native static (images).
-        compile('com.mopub:mopub-sdk-native-static:4.11.0@aar') {
+        compile('com.mopub:mopub-sdk-native-static:4.13.0@aar') {
             transitive = true
         }
 
         // For native video. This will automatically also include native static
-        compile('com.mopub:mopub-sdk-native-video:4.11.0@aar') {
+        compile('com.mopub:mopub-sdk-native-video:4.13.0@aar') {
             transitive = true
         }
     }
@@ -96,16 +96,16 @@ The MoPub SDK is available via:
 ## New in this Version
 Please view the [changelog](https://github.com/mopub/mopub-android-sdk/blob/master/CHANGELOG.md) for a complete list of additions, fixes, and enhancements in the latest release.
 
-- Added a workaround for an Android bug where Lollipop devices (Android 5.1.1, API level 22) and lower incorrectly handle SSL connections using Server Name Identification.
-- Rewarded video `load()` calls now do not load another rewarded video with the same ad unit id while one is already loading or loaded.
-- Moved the VAST video start tracker to immediately after the video starts (was 2 seconds after the video started).
+- Updated AdColony Custom Events.
+- Updated Unity Custom Events.
+- Added AdMob Custom Events:
+  - Native: `GooglePlayServicesAdRenderer` and `GooglePlayServicesNative`
+  - Rewarded Video: `GooglePlayServicesRewardedVideo`
 - Bug fixes.
 
-- **Note:** Maven builds from source are currently unstable and will be reinstated in a future release. Maven developers can still pull the MoPub SDK AAR from JCenter.
-
 ## Requirements
 
-- Android 2.3.1 (API Version 9) and up
+- Android 4.1 (API Version 16) and up (**Updated in 4.12.0**)
 - android-support-v4.jar, r23 (**Updated in 4.4.0**)
 - android-support-annotations.jar, r23 (**Updated in 4.4.0**)
 - android-support-v7-recyclerview.jar, r23 (**Updated in 4.4.0**)
diff --git a/extras/src/com/mopub/mobileads/AdColonyInterstitial.java b/extras/src/com/mopub/mobileads/AdColonyInterstitial.java
index 6e42be9c..3312cc45 100644
--- a/extras/src/com/mopub/mobileads/AdColonyInterstitial.java
+++ b/extras/src/com/mopub/mobileads/AdColonyInterstitial.java
@@ -5,26 +5,22 @@
 import android.os.Handler;
 import android.util.Log;
 
-import com.jirbo.adcolony.AdColony;
-import com.jirbo.adcolony.AdColonyAd;
-import com.jirbo.adcolony.AdColonyAdListener;
-import com.jirbo.adcolony.AdColonyVideoAd;
+import com.adcolony.sdk.AdColony;
+import com.adcolony.sdk.AdColonyAppOptions;
+import com.adcolony.sdk.AdColonyInterstitialListener;
+import com.adcolony.sdk.AdColonyZone;
 import com.mopub.common.util.Json;
 
 import java.util.Map;
-import java.util.concurrent.ScheduledThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
 
-/*
- * Tested with AdColony SDK 2.0.3.
- */
-public class AdColonyInterstitial extends CustomEventInterstitial implements AdColonyAdListener {
+public class AdColonyInterstitial extends CustomEventInterstitial {
+    private static final String TAG = "AdColonyInterstitial";
     /*
      * We recommend passing the AdColony client options, app ID, all zone IDs, and current zone ID
      * in the serverExtras Map by specifying Custom Event Data in MoPub's web interface.
      *
      * Please see AdColony's documentation for more information:
-     * https://github.com/AdColony/AdColony-Android-SDK/wiki/API-Details#configure-activity-activity-string-client_options-string-app_id-string-zone_ids-
+     * https://github.com/AdColony/AdColony-Android-SDK-3
      */
     private static final String DEFAULT_CLIENT_OPTIONS = "version=YOUR_APP_VERSION_HERE,store:google";
     private static final String DEFAULT_APP_ID = "YOUR_AD_COLONY_APP_ID_HERE";
@@ -39,16 +35,12 @@
     public static final String ALL_ZONE_IDS_KEY = "allZoneIds";
     public static final String ZONE_ID_KEY = "zoneId";
 
-    private static boolean isAdColonyConfigured = false;
-
     private CustomEventInterstitialListener mCustomEventInterstitialListener;
+    private AdColonyInterstitialListener mAdColonyInterstitialListener;
     private final Handler mHandler;
-    private AdColonyVideoAd mAdColonyVideoAd;
-    private final ScheduledThreadPoolExecutor mScheduledThreadPoolExecutor;
-    private boolean mIsLoading;
+    private com.adcolony.sdk.AdColonyInterstitial mAdColonyInterstitial;
 
     public AdColonyInterstitial() {
-        mScheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(1);
         mHandler = new Handler();
     }
 
@@ -76,111 +68,167 @@ protected void loadInterstitial(Context context,
             zoneId = serverExtras.get(ZONE_ID_KEY);
         }
 
-        if (!isAdColonyConfigured) {
-            AdColony.configure((Activity)context, clientOptions, appId, allZoneIds);
-            isAdColonyConfigured = true;
+        mAdColonyInterstitialListener = getAdColonyInterstitialListener();
+        if (!isAdColonyConfigured()) {
+            AdColony.configure((Activity) context, getAppOptions(clientOptions), appId, allZoneIds);
         }
 
-        mAdColonyVideoAd = new AdColonyVideoAd(zoneId);
-        mAdColonyVideoAd.withListener(this);
-
-        scheduleOnInterstitialLoaded();
+        AdColony.requestInterstitial(zoneId, mAdColonyInterstitialListener);
     }
 
     @Override
     protected void showInterstitial() {
-        if (mAdColonyVideoAd.isReady()) {
-            mAdColonyVideoAd.show();
+        if (mAdColonyInterstitial == null || mAdColonyInterstitial.isExpired()) {
+            Log.e(TAG, "AdColony interstitial ad is null or has expired");
+            mHandler.post(new Runnable() {
+                @Override
+                public void run() {
+                    mCustomEventInterstitialListener.onInterstitialFailed(MoPubErrorCode.VIDEO_PLAYBACK_ERROR);
+                }
+            });
         } else {
-            Log.d("MoPub", "Tried to show a AdColony interstitial ad before it finished loading. Please try again.");
+            mAdColonyInterstitial.show();
         }
     }
 
     @Override
     protected void onInvalidate() {
-        if (mAdColonyVideoAd != null) {
-            mAdColonyVideoAd.withListener(null);
+        if (mAdColonyInterstitial != null) {
+            mAdColonyInterstitialListener = null;
+            mAdColonyInterstitial.setListener(null);
+            mAdColonyInterstitial.destroy();
+            mAdColonyInterstitial = null;
+        }
+    }
+
+    private AdColonyAppOptions getAppOptions(String clientOptions) {
+        if (clientOptions == null || clientOptions.isEmpty()) {
+            return null;
+        }
+        AdColonyAppOptions adColonyAppOptions = new AdColonyAppOptions();
+        String[] allOptions = clientOptions.split(",");
+        for (String option : allOptions) {
+            String optionNameAndValue[] = option.split(":");
+            if (optionNameAndValue.length == 2) {
+                switch (optionNameAndValue[0]) {
+                    case "store":
+                        adColonyAppOptions.setOriginStore(optionNameAndValue[1]);
+                        break;
+                    case "version":
+                        adColonyAppOptions.setAppVersion(optionNameAndValue[1]);
+                        break;
+                    default:
+                        Log.e(TAG, "AdColony client options in wrong format - please check your MoPub dashboard");
+                        return null;
+                }
+            } else {
+                Log.e(TAG, "AdColony client options in wrong format - please check your MoPub dashboard");
+                return null;
+            }
         }
 
-        mScheduledThreadPoolExecutor.shutdownNow();
-        mIsLoading = false;
+        return adColonyAppOptions;
     }
 
-    private boolean extrasAreValid(Map<String, String> extras) {
-        return extras.containsKey(CLIENT_OPTIONS_KEY)
-                && extras.containsKey(APP_ID_KEY)
-                && extras.containsKey(ALL_ZONE_IDS_KEY)
-                && extras.containsKey(ZONE_ID_KEY);
+    private boolean isAdColonyConfigured() {
+        return !AdColony.getSDKVersion().isEmpty();
     }
 
-    private String[] extractAllZoneIds(Map<String, String> serverExtras) {
-        String[] result = Json.jsonArrayToStringArray(serverExtras.get(ALL_ZONE_IDS_KEY));
+    private AdColonyInterstitialListener getAdColonyInterstitialListener() {
+        if (mAdColonyInterstitialListener != null) {
+            return mAdColonyInterstitialListener;
+        } else {
+            return new AdColonyInterstitialListener() {
+                @Override
+                public void onRequestFilled(com.adcolony.sdk.AdColonyInterstitial adColonyInterstitial) {
+                    mAdColonyInterstitial = adColonyInterstitial;
+                    Log.d(TAG, "AdColony interstitial ad has been successfully loaded.");
+                    mHandler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            mCustomEventInterstitialListener.onInterstitialLoaded();
+                        }
+                    });
+                }
 
-        // AdColony requires at least one valid String in the allZoneIds array.
-        if (result.length == 0) {
-            result = new String[]{""};
-        }
+                @Override
+                public void onRequestNotFilled(AdColonyZone zone) {
+                    Log.d(TAG, "AdColony interstitial ad has no fill.");
+                    mHandler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            mCustomEventInterstitialListener.onInterstitialFailed(MoPubErrorCode.NETWORK_NO_FILL);
+                        }
+                    });
+                }
 
-        return result;
-    }
+                @Override
+                public void onClosed(com.adcolony.sdk.AdColonyInterstitial ad) {
+                    Log.d(TAG, "AdColony interstitial ad has been dismissed.");
+                    mHandler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            mCustomEventInterstitialListener.onInterstitialDismissed();
+                        }
+                    });
+                }
 
-    private void scheduleOnInterstitialLoaded() {
-        Runnable runnable = new Runnable() {
-            @Override
-            public void run() {
-                if (mAdColonyVideoAd.isReady()) {
-                    Log.d("MoPub", "AdColony interstitial ad successfully loaded.");
-                    mIsLoading = false;
-                    mScheduledThreadPoolExecutor.shutdownNow();
+                @Override
+                public void onOpened(com.adcolony.sdk.AdColonyInterstitial ad) {
+                    Log.d(TAG, "AdColony interstitial ad shown: " + ad.getZoneID());
                     mHandler.post(new Runnable() {
                         @Override
                         public void run() {
-                            mCustomEventInterstitialListener.onInterstitialLoaded();
+                            mCustomEventInterstitialListener.onInterstitialShown();
                         }
                     });
                 }
-            }
-        };
 
-        if (!mIsLoading) {
-            mScheduledThreadPoolExecutor.scheduleAtFixedRate(runnable, 1, 1, TimeUnit.SECONDS);
-            mIsLoading = true;
-        }
-    }
+                @Override
+                public void onExpiring(com.adcolony.sdk.AdColonyInterstitial ad) {
+                    Log.d(TAG, "AdColony interstitial ad is expiring; requesting new ad");
+                    AdColony.requestInterstitial(ad.getZoneID(), mAdColonyInterstitialListener);
+                }
 
-    /*
-     * AdColonyAdListener implementation
-     */
+                @Override
+                public void onLeftApplication(com.adcolony.sdk.AdColonyInterstitial ad) {
+                    mHandler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            mCustomEventInterstitialListener.onLeaveApplication();
+                        }
+                    });
+                }
 
-    @Override
-    public void onAdColonyAdStarted(AdColonyAd adColonyAd) {
-        Log.d("MoPub", "AdColony interstitial ad shown.");
-        mHandler.post(new Runnable() {
-            @Override
-            public void run() {
-                mCustomEventInterstitialListener.onInterstitialShown();
-            }
-        });
+                @Override
+                public void onClicked(com.adcolony.sdk.AdColonyInterstitial ad) {
+                    mCustomEventInterstitialListener.onInterstitialClicked();
+                }
+            };
+        }
     }
 
-    @Override
-    public void onAdColonyAdAttemptFinished(AdColonyAd adColonyAd) {
-        Log.d("MoPub", "AdColony interstitial ad dismissed.");
-        mHandler.post(new Runnable() {
-            @Override
-            public void run() {
-                mCustomEventInterstitialListener.onInterstitialDismissed();
-            }
-        });
+    private boolean extrasAreValid(Map<String, String> extras) {
+        return extras.containsKey(CLIENT_OPTIONS_KEY)
+                && extras.containsKey(APP_ID_KEY)
+                && extras.containsKey(ALL_ZONE_IDS_KEY)
+                && extras.containsKey(ZONE_ID_KEY);
     }
 
-    @Deprecated // for testing
-    ScheduledThreadPoolExecutor getScheduledThreadPoolExecutor() {
-        return mScheduledThreadPoolExecutor;
+    private String[] extractAllZoneIds(Map<String, String> serverExtras) {
+        String[] result = Json.jsonArrayToStringArray(serverExtras.get(ALL_ZONE_IDS_KEY));
+
+        // AdColony requires at least one valid String in the allZoneIds array.
+        if (result.length == 0) {
+            result = new String[]{""};
+        }
+
+        return result;
     }
 
-    @Deprecated // for testing
-    void resetAdColonyConfigured() {
-        isAdColonyConfigured = false;
+    @Deprecated
+    // For testing
+    public static String getAdUnitId(MoPubInterstitial interstitial) {
+        return interstitial.getMoPubInterstitialView().getAdUnitId();
     }
 }
diff --git a/extras/src/com/mopub/mobileads/AdColonyRewardedVideo.java b/extras/src/com/mopub/mobileads/AdColonyRewardedVideo.java
index 4d9baac4..8d81a6f7 100644
--- a/extras/src/com/mopub/mobileads/AdColonyRewardedVideo.java
+++ b/extras/src/com/mopub/mobileads/AdColonyRewardedVideo.java
@@ -4,39 +4,40 @@
 import android.os.Handler;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.util.Log;
+
+import com.adcolony.sdk.AdColony;
+import com.adcolony.sdk.AdColonyAdOptions;
+import com.adcolony.sdk.AdColonyAppOptions;
+import com.adcolony.sdk.AdColonyInterstitial;
+import com.adcolony.sdk.AdColonyInterstitialListener;
+import com.adcolony.sdk.AdColonyReward;
+import com.adcolony.sdk.AdColonyRewardListener;
+import com.adcolony.sdk.AdColonyZone;
 
-import com.jirbo.adcolony.AdColony;
-import com.jirbo.adcolony.AdColonyAd;
-import com.jirbo.adcolony.AdColonyAdListener;
-import com.jirbo.adcolony.AdColonyV4VCAd;
-import com.jirbo.adcolony.AdColonyV4VCListener;
-import com.jirbo.adcolony.AdColonyV4VCReward;
 import com.mopub.common.BaseLifecycleListener;
 import com.mopub.common.DataKeys;
 import com.mopub.common.LifecycleListener;
 import com.mopub.common.MediationSettings;
 import com.mopub.common.MoPubReward;
-import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.util.Json;
 
 import java.util.Map;
 import java.util.WeakHashMap;
-import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.ScheduledThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 
 /**
  * A custom event for showing AdColony rewarded videos.
- *
- * Certified with AdColony 2.0.3
  */
 public class AdColonyRewardedVideo extends CustomEventRewardedVideo {
+    private static final String TAG = "AdColonyRewardedVideo";
     /*
      * We recommend passing the AdColony client options, app ID, all zone IDs, and current zone ID
      * in the serverExtras Map by specifying Custom Event Data in MoPub's web interface.
      *
      * Please see AdColony's documentation for more information:
-     * https://github.com/AdColony/AdColony-Android-SDK/wiki/API-Details#configure-activity-activity-string-client_options-string-app_id-string-zone_ids-
+     * https://github.com/AdColony/AdColony-Android-SDK-3
      */
     private static final String DEFAULT_CLIENT_OPTIONS = "version=YOUR_APP_VERSION_HERE,store:google";
     private static final String DEFAULT_APP_ID = "YOUR_AD_COLONY_APP_ID_HERE";
@@ -52,31 +53,23 @@
     public static final String ZONE_ID_KEY = "zoneId";
 
     private static boolean sInitialized = false;
-    private static LifecycleListener sLifecycleListener = new BaseLifecycleListener() {
-        @Override
-        public void onPause(@NonNull final Activity activity) {
-            super.onPause(activity);
-            AdColony.pause();
-        }
-
-        @Override
-        public void onResume(@NonNull final Activity activity) {
-            super.onResume(activity);
-            AdColony.resume(activity);
-        }
-    };
-    private static AdColonyListener sAdColonyListener = new AdColonyListener();
-    private static WeakHashMap<AdColonyAd, String> sAdToZoneIdMap = new WeakHashMap<AdColonyAd, String>();
+    private static LifecycleListener sLifecycleListener = new BaseLifecycleListener();
 
-    private AdColonyV4VCAd mAd;
+    AdColonyInterstitial mAd;
     private String mZoneId;
-    @Nullable private String mAdUnitId;
+    private AdColonyListener mAdColonyListener;
+    private AdColonyAdOptions mAdColonyAdOptions = new AdColonyAdOptions();
+    private AdColonyAppOptions mAdColonyAppOptions = new AdColonyAppOptions();
+    private static WeakHashMap<String, AdColonyInterstitial> sZoneIdToAdMap = new WeakHashMap<>();
+
+
+    @Nullable
+    private String mAdUnitId;
     private boolean mIsLoading = false;
 
     // For waiting and notifying the SDK:
     private final Handler mHandler;
     private final ScheduledThreadPoolExecutor mScheduledThreadPoolExecutor;
-    private ScheduledFuture<?> mFuture;
 
     public AdColonyRewardedVideo() {
         mScheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(1);
@@ -86,7 +79,7 @@ public AdColonyRewardedVideo() {
     @Nullable
     @Override
     public CustomEventRewardedVideoListener getVideoListenerForSdk() {
-        return sAdColonyListener;
+        return mAdColonyListener;
     }
 
     @Nullable
@@ -104,12 +97,19 @@ public String getAdNetworkId() {
     @Override
     protected void onInvalidate() {
         mScheduledThreadPoolExecutor.shutdownNow();
+        AdColonyInterstitial ad = sZoneIdToAdMap.get(mZoneId);
+        if (ad != null) {
+            ad.setListener(null);
+            ad.destroy();
+            sZoneIdToAdMap.remove(mZoneId);
+            Log.d(TAG, "AdColony rewarded video destroyed");
+        }
     }
 
     @Override
     public boolean checkAndInitializeSdk(@NonNull final Activity launcherActivity,
-            @NonNull final Map<String, Object> localExtras,
-            @NonNull final Map<String, String> serverExtras) throws Exception {
+                                         @NonNull final Map<String, Object> localExtras,
+                                         @NonNull final Map<String, String> serverExtras) throws Exception {
         synchronized (AdColonyRewardedVideo.class) {
             if (sInitialized) {
                 return false;
@@ -127,8 +127,12 @@ public boolean checkAndInitializeSdk(@NonNull final Activity launcherActivity,
             }
 
             setUpGlobalSettings();
-            AdColony.configure(launcherActivity, adColonyClientOptions, adColonyAppId, adColonyAllZoneIds);
-            AdColony.addV4VCListener(sAdColonyListener);
+            setAppOptions(adColonyClientOptions);
+
+            if (!isAdColonyConfigured()) {
+                AdColony.configure(launcherActivity, mAdColonyAppOptions, adColonyAppId, adColonyAllZoneIds);
+            }
+
             sInitialized = true;
             return true;
         }
@@ -136,8 +140,8 @@ public boolean checkAndInitializeSdk(@NonNull final Activity launcherActivity,
 
     @Override
     protected void loadWithSdkInitialized(@NonNull final Activity activity,
-            @NonNull final Map<String, Object> localExtras,
-            @NonNull final Map<String, String> serverExtras) throws Exception {
+                                          @NonNull final Map<String, Object> localExtras,
+                                          @NonNull final Map<String, String> serverExtras) throws Exception {
 
         mZoneId = DEFAULT_ZONE_ID;
         if (extrasAreValid(serverExtras)) {
@@ -148,24 +152,66 @@ protected void loadWithSdkInitialized(@NonNull final Activity activity,
             mAdUnitId = (String) adUnitObject;
         }
 
-        mAd = new AdColonyV4VCAd(mZoneId).withListener(sAdColonyListener);
-        sAdToZoneIdMap.put(mAd, mZoneId);
+        sZoneIdToAdMap.put(mZoneId, null);
+        setUpAdOptions();
+        mAdColonyListener = new AdColonyListener(mAdColonyAdOptions);
+        AdColony.setRewardListener(mAdColonyListener);
+        AdColony.requestInterstitial(mZoneId, mAdColonyListener, mAdColonyAdOptions);
         scheduleOnVideoReady();
     }
 
+    private void setUpAdOptions() {
+        mAdColonyAdOptions.enableConfirmationDialog(getConfirmationDialogFromSettings());
+        mAdColonyAdOptions.enableResultsDialog(getResultsDialogFromSettings());
+    }
+
+    private void setAppOptions(String clientOptions) {
+        if(android.text.TextUtils.isEmpty(clientOptions)) {
+            Log.d(TAG, "AdColony client options are not configured on the MoPub dashboard");
+            return;
+        }
+
+        String[] allOptions = clientOptions.split(",");
+        for (String option : allOptions) {
+            String optionNameAndValue[] = option.split(":");
+            if (optionNameAndValue.length == 2) {
+                switch (optionNameAndValue[0]) {
+                    case "store":
+                        mAdColonyAppOptions.setOriginStore(optionNameAndValue[1]);
+                        break;
+                    case "version":
+                        mAdColonyAppOptions.setAppVersion(optionNameAndValue[1]);
+                        break;
+                    default:
+                        Log.e(TAG, "AdColony client options in wrong format - please check your MoPub dashboard");
+                        return;
+                }
+            } else {
+                Log.e(TAG, "AdColony client options is not recognized - please check your MoPub " +
+                        "dashboard");
+                return;
+            }
+        }
+    }
+
+    private boolean isAdColonyConfigured() {
+        return !AdColony.getSDKVersion().isEmpty();
+    }
+
     @Override
     public boolean hasVideoAvailable() {
-        return mAd != null && mAd.isReady() && mAd.getAvailableViews() != 0;
+        return mAd != null && !mAd.isExpired();
     }
 
     @Override
     public void showVideo() {
         if (this.hasVideoAvailable()) {
-            boolean withConfirmationDialog = getConfirmationDialogFromSettings();
-            boolean withResultsDialog = getResultsDialogFromSettings();
-            mAd.withConfirmationDialog(withConfirmationDialog).withResultsDialog(withResultsDialog).show();
+            mAd.show();
         } else {
-            MoPubRewardedVideoManager.onRewardedVideoPlaybackError(AdColonyRewardedVideo.class, mZoneId, MoPubErrorCode.VIDEO_PLAYBACK_ERROR);
+            MoPubRewardedVideoManager.onRewardedVideoPlaybackError(
+                    AdColonyRewardedVideo.class,
+                    mZoneId,
+                    MoPubErrorCode.VIDEO_PLAYBACK_ERROR);
         }
     }
 
@@ -191,11 +237,8 @@ private void setUpGlobalSettings() {
         final AdColonyGlobalMediationSettings globalMediationSettings =
                 MoPubRewardedVideoManager.getGlobalMediationSettings(AdColonyGlobalMediationSettings.class);
         if (globalMediationSettings != null) {
-            if (globalMediationSettings.getCustomId() != null) {
-                AdColony.setCustomID(globalMediationSettings.getCustomId());
-            }
-            if (globalMediationSettings.getDeviceId() != null) {
-                AdColony.setDeviceID(globalMediationSettings.getDeviceId());
+            if (globalMediationSettings.getUserId() != null) {
+                mAdColonyAppOptions.setUserID(globalMediationSettings.getUserId());
             }
         }
     }
@@ -216,13 +259,15 @@ private void scheduleOnVideoReady() {
         Runnable runnable = new Runnable() {
             @Override
             public void run() {
-                if (mAd.isReady()) {
+                if (isAdAvailable(mZoneId)) {
+                    mAd = sZoneIdToAdMap.get(mZoneId);
                     mIsLoading = false;
                     mScheduledThreadPoolExecutor.shutdownNow();
                     mHandler.post(new Runnable() {
                         @Override
                         public void run() {
-                            if (mAd.getAvailableViews() > 0) {
+                            if (hasVideoAvailable()) {
+                                Log.d(TAG, "AdColony rewarded ad has been successfully loaded.");
                                 MoPubRewardedVideoManager.onRewardedVideoLoadSuccess(
                                         AdColonyRewardedVideo.class,
                                         mZoneId);
@@ -244,71 +289,92 @@ public void run() {
         }
     }
 
-    private static class AdColonyListener implements AdColonyAdListener,
-            AdColonyV4VCListener, CustomEventRewardedVideoListener {
-
-        @Override
-        public void onAdColonyAdAttemptFinished(final AdColonyAd adColonyAd) {
-            String zoneId = sAdToZoneIdMap.get(adColonyAd);
-            MoPubRewardedVideoManager.onRewardedVideoClosed(AdColonyRewardedVideo.class, zoneId);
-            if (adColonyAd.notShown()) {
-                if (adColonyAd.canceled() || adColonyAd.skipped()) {
-                    MoPubLog.d("User canceled ad playback");
-                    return;
-                }
-
-                MoPubErrorCode reason = MoPubErrorCode.VIDEO_DOWNLOAD_ERROR;
-                if (adColonyAd.noFill()) {
-                    reason = MoPubErrorCode.NETWORK_NO_FILL;
-                }
+    private boolean isAdAvailable(String zoneId) {
+        return sZoneIdToAdMap.get(zoneId) != null;
+    }
 
-                MoPubRewardedVideoManager.onRewardedVideoLoadFailure(
-                        AdColonyRewardedVideo.class,
-                        zoneId,
-                        reason);
-            }
-        }
+    private static class AdColonyListener extends AdColonyInterstitialListener
+            implements AdColonyRewardListener, CustomEventRewardedVideoListener {
+        private static final String TAG = "AdColonyListener";
+        private AdColonyAdOptions mAdOptions;
 
-        @Override
-        public void onAdColonyAdStarted(final com.jirbo.adcolony.AdColonyAd adColonyAd) {
-            MoPubRewardedVideoManager.onRewardedVideoStarted(
-                    AdColonyRewardedVideo.class,
-                    sAdToZoneIdMap.get(adColonyAd));
+        AdColonyListener(AdColonyAdOptions adOptions) {
+            mAdOptions = adOptions;
         }
 
         @Override
-        public void onAdColonyV4VCReward(final AdColonyV4VCReward adColonyV4VCReward) {
+        public void onReward(AdColonyReward a) {
             MoPubReward reward;
-            if (adColonyV4VCReward.success()) {
-                reward = MoPubReward.success(adColonyV4VCReward.name(), adColonyV4VCReward.amount());
+            if (a.success()) {
+                Log.d(TAG, "AdColonyReward name: " + a.getRewardName());
+                Log.d(TAG, "AdColonyReward amount: " + a.getRewardAmount());
+                reward = MoPubReward.success(a.getRewardName(), a.getRewardAmount());
             } else {
+                Log.d(TAG, "AdColonyReward failed");
                 reward = MoPubReward.failure();
             }
+
             MoPubRewardedVideoManager.onRewardedVideoCompleted(
                     AdColonyRewardedVideo.class,
-                    null, // Can't deduce the zoneId from this object.
+                    a.getZoneID(),
                     reward);
         }
-    }
 
-    public static final class AdColonyGlobalMediationSettings implements MediationSettings {
+        @Override
+        public void onRequestFilled(com.adcolony.sdk.AdColonyInterstitial adColonyInterstitial) {
+            sZoneIdToAdMap.put(adColonyInterstitial.getZoneID(), adColonyInterstitial);
+        }
 
-        @Nullable private final String mCustomId;
-        @Nullable private final String mDeviceId;
+        @Override
+        public void onRequestNotFilled(AdColonyZone zone) {
+            Log.d(TAG, "AdColony rewarded ad has no fill.");
+            MoPubRewardedVideoManager.onRewardedVideoLoadFailure(
+                    AdColonyRewardedVideo.class,
+                    zone.getZoneID(),
+                    MoPubErrorCode.NETWORK_NO_FILL);
+        }
 
-        public AdColonyGlobalMediationSettings(@Nullable String customId, @Nullable String deviceId) {
-            mCustomId = customId;
-            mDeviceId = deviceId;
+        @Override
+        public void onClosed(com.adcolony.sdk.AdColonyInterstitial ad) {
+            Log.d(TAG, "AdColony rewarded ad has been dismissed.");
+            MoPubRewardedVideoManager.onRewardedVideoClosed(
+                    AdColonyRewardedVideo.class,
+                    ad.getZoneID());
         }
 
+        @Override
+        public void onOpened(com.adcolony.sdk.AdColonyInterstitial ad) {
+            Log.d(TAG, "AdColony rewarded ad shown: " + ad.getZoneID());
+            MoPubRewardedVideoManager.onRewardedVideoStarted(
+                    AdColonyRewardedVideo.class,
+                    ad.getZoneID());
+        }
+
+        @Override
+        public void onExpiring(com.adcolony.sdk.AdColonyInterstitial ad) {
+            Log.d(TAG, "AdColony rewarded ad is expiring; requesting new ad");
+            AdColony.requestInterstitial(ad.getZoneID(), ad.getListener(), mAdOptions);
+        }
+
+        @Override
+        public void onClicked(com.adcolony.sdk.AdColonyInterstitial ad) {
+            MoPubRewardedVideoManager.onRewardedVideoClicked(
+                    AdColonyRewardedVideo.class,
+                    ad.getZoneID());
+        }
+    }
+
+    public static final class AdColonyGlobalMediationSettings implements MediationSettings {
         @Nullable
-        public String getCustomId() {
-            return mCustomId;
+        private final String mUserId;
+
+        public AdColonyGlobalMediationSettings(@Nullable String userId) {
+            mUserId = userId;
         }
 
         @Nullable
-        public String getDeviceId() {
-            return mDeviceId;
+        public String getUserId() {
+            return mUserId;
         }
     }
 
diff --git a/extras/src/com/mopub/mobileads/GooglePlayServicesRewardedVideo.java b/extras/src/com/mopub/mobileads/GooglePlayServicesRewardedVideo.java
new file mode 100644
index 00000000..0f678d67
--- /dev/null
+++ b/extras/src/com/mopub/mobileads/GooglePlayServicesRewardedVideo.java
@@ -0,0 +1,261 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.google.android.gms.ads.AdRequest;
+import com.google.android.gms.ads.MobileAds;
+import com.google.android.gms.ads.reward.RewardItem;
+import com.google.android.gms.ads.reward.RewardedVideoAd;
+import com.google.android.gms.ads.reward.RewardedVideoAdListener;
+import com.mopub.common.BaseLifecycleListener;
+import com.mopub.common.LifecycleListener;
+import com.mopub.common.MoPubReward;
+
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+/**
+ * A {@link CustomEventRewardedVideo} used to load rewarded video Google rewarded video ads.
+ */
+public class GooglePlayServicesRewardedVideo extends CustomEventRewardedVideo implements
+        RewardedVideoAdListener {
+    private static final String TAG = "MoPubToAdMobRewarded";
+
+    /**
+     * The current version of the adapter.
+     */
+    private static final String ADAPTER_VERSION = "0.1.0";
+
+    /**
+     * Key to obtain AdMob application ID from the server extras provided by MoPub.
+     */
+    private static final String KEY_EXTRA_APPLICATION_ID = "appid";
+
+    /**
+     * Key to obtain AdMob ad unit ID from the extras provided by MoPub.
+     */
+    private static final String KEY_EXTRA_AD_UNIT_ID = "adunit";
+
+    /**
+     * Flag to determine whether or not the adapter has been initialized.
+     */
+    private static AtomicBoolean sIsInitialized;
+
+    /**
+     * Google Mobile Ads rewarded video ad unit ID.
+     */
+    private String mAdUnitId;
+
+    /**
+     * The Google Rewarded Video Ad instance.
+     */
+    private RewardedVideoAd mRewardedVideoAd;
+
+    /**
+     * A {@link LifecycleListener} used to forward the activity lifecycle events from MoPub SDK to
+     * Google Mobile Ads SDK.
+     */
+    private LifecycleListener mLifecycleListener = new BaseLifecycleListener() {
+        @Override
+        public void onPause(@NonNull Activity activity) {
+            super.onPause(activity);
+            if (mRewardedVideoAd != null) {
+                mRewardedVideoAd.pause(activity);
+            }
+        }
+
+        @Override
+        public void onResume(@NonNull Activity activity) {
+            super.onResume(activity);
+            if (mRewardedVideoAd != null) {
+                mRewardedVideoAd.resume(activity);
+            }
+        }
+    };
+
+    public GooglePlayServicesRewardedVideo() {
+        sIsInitialized = new AtomicBoolean(false);
+    }
+
+    @Nullable
+    @Override
+    protected LifecycleListener getLifecycleListener() {
+        return mLifecycleListener;
+    }
+
+    @NonNull
+    @Override
+    protected String getAdNetworkId() {
+        // Google rewarded videos do not have a unique identifier for each ad; using ad unit ID as
+        // an identifier for all ads.
+        return mAdUnitId;
+    }
+
+    @Override
+    protected void onInvalidate() {
+        if (mRewardedVideoAd != null) {
+            mRewardedVideoAd.setRewardedVideoAdListener(null);
+            mRewardedVideoAd = null;
+        }
+    }
+
+    @Override
+    protected boolean checkAndInitializeSdk(@NonNull Activity launcherActivity,
+                                            @NonNull Map<String, Object> localExtras,
+                                            @NonNull Map<String, String> serverExtras)
+            throws Exception {
+        if (!sIsInitialized.getAndSet(true)) {
+            Log.i(TAG, "Adapter version - " + ADAPTER_VERSION);
+
+            if (TextUtils.isEmpty(serverExtras.get(KEY_EXTRA_APPLICATION_ID))) {
+                MobileAds.initialize(launcherActivity);
+            } else {
+                MobileAds.initialize(launcherActivity, serverExtras.get(KEY_EXTRA_APPLICATION_ID));
+            }
+
+            if (TextUtils.isEmpty(serverExtras.get(KEY_EXTRA_AD_UNIT_ID))) {
+                // Using class name as the network ID for this callback since the ad unit ID is
+                // invalid.
+                MoPubRewardedVideoManager.onRewardedVideoLoadFailure(
+                        GooglePlayServicesRewardedVideo.class,
+                        GooglePlayServicesRewardedVideo.class.getSimpleName(),
+                        MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
+                return false;
+            }
+
+            mAdUnitId = serverExtras.get(KEY_EXTRA_AD_UNIT_ID);
+
+            mRewardedVideoAd = MobileAds.getRewardedVideoAdInstance(launcherActivity);
+            mRewardedVideoAd.setRewardedVideoAdListener(GooglePlayServicesRewardedVideo.this);
+            return true;
+        }
+
+        return false;
+    }
+
+    @Override
+    protected void loadWithSdkInitialized(@NonNull Activity activity,
+                                          @NonNull Map<String, Object> localExtras,
+                                          @NonNull Map<String, String> serverExtras)
+            throws Exception {
+        if (TextUtils.isEmpty(serverExtras.get(KEY_EXTRA_AD_UNIT_ID))) {
+            // Using class name as the network ID for this callback since the ad unit ID is
+            // invalid.
+            MoPubRewardedVideoManager.onRewardedVideoLoadFailure(
+                    GooglePlayServicesRewardedVideo.class,
+                    GooglePlayServicesRewardedVideo.class.getSimpleName(),
+                    MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
+            return;
+        }
+        mAdUnitId = serverExtras.get(KEY_EXTRA_AD_UNIT_ID);
+
+        if (mRewardedVideoAd == null) {
+            mRewardedVideoAd = MobileAds.getRewardedVideoAdInstance(activity);
+            mRewardedVideoAd.setRewardedVideoAdListener(GooglePlayServicesRewardedVideo.this);
+        }
+
+        if (mRewardedVideoAd.isLoaded()) {
+            MoPubRewardedVideoManager
+                    .onRewardedVideoLoadSuccess(GooglePlayServicesRewardedVideo.class, mAdUnitId);
+        } else {
+            mRewardedVideoAd
+                    .loadAd(mAdUnitId, new AdRequest.Builder().setRequestAgent("MoPub").build());
+        }
+    }
+
+    @Override
+    protected boolean hasVideoAvailable() {
+        return mRewardedVideoAd != null && mRewardedVideoAd.isLoaded();
+    }
+
+    @Override
+    protected void showVideo() {
+        if (hasVideoAvailable()) {
+            mRewardedVideoAd.show();
+        } else {
+            MoPubRewardedVideoManager.onRewardedVideoPlaybackError(
+                    GooglePlayServicesRewardedVideo.class,
+                    mAdUnitId,
+                    getMoPubErrorCode(AdRequest.ERROR_CODE_INTERNAL_ERROR));
+        }
+    }
+
+    @Override
+    public void onRewardedVideoAdLoaded() {
+        MoPubRewardedVideoManager.onRewardedVideoLoadSuccess(
+                GooglePlayServicesRewardedVideo.class,
+                mAdUnitId);
+    }
+
+    @Override
+    public void onRewardedVideoAdOpened() {
+        // MoPub SDK does not have an equivalent callback for an ad opened event. Do nothing.
+    }
+
+    @Override
+    public void onRewardedVideoStarted() {
+        MoPubRewardedVideoManager.onRewardedVideoStarted(
+                GooglePlayServicesRewardedVideo.class,
+                mAdUnitId);
+    }
+
+    @Override
+    public void onRewardedVideoAdClosed() {
+        MoPubRewardedVideoManager.onRewardedVideoClosed(
+                GooglePlayServicesRewardedVideo.class,
+                mAdUnitId);
+    }
+
+    @Override
+    public void onRewarded(RewardItem rewardItem) {
+        MoPubRewardedVideoManager.onRewardedVideoCompleted(
+                GooglePlayServicesRewardedVideo.class,
+                mAdUnitId,
+                MoPubReward.success(rewardItem.getType(), rewardItem.getAmount()));
+    }
+
+    @Override
+    public void onRewardedVideoAdLeftApplication() {
+        MoPubRewardedVideoManager.onRewardedVideoClicked(
+                GooglePlayServicesRewardedVideo.class,
+                mAdUnitId);
+    }
+
+    @Override
+    public void onRewardedVideoAdFailedToLoad(int error) {
+        MoPubRewardedVideoManager.onRewardedVideoLoadFailure(
+                GooglePlayServicesRewardedVideo.class,
+                mAdUnitId,
+                getMoPubErrorCode(error));
+    }
+
+    /**
+     * Converts a given Google Mobile Ads SDK error code into {@link MoPubErrorCode}.
+     *
+     * @param error Google Mobile Ads SDK error code.
+     * @return an equivalent MoPub SDK error code for the given Google Mobile Ads SDK error
+     * code.
+     */
+    private MoPubErrorCode getMoPubErrorCode(int error) {
+        MoPubErrorCode errorCode;
+        switch (error) {
+            case AdRequest.ERROR_CODE_INTERNAL_ERROR:
+                errorCode = MoPubErrorCode.INTERNAL_ERROR;
+                break;
+            case AdRequest.ERROR_CODE_INVALID_REQUEST:
+                errorCode = MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR;
+                break;
+            case AdRequest.ERROR_CODE_NETWORK_ERROR:
+                errorCode = MoPubErrorCode.NO_CONNECTION;
+                break;
+            case AdRequest.ERROR_CODE_NO_FILL:
+            default:
+                errorCode = MoPubErrorCode.UNSPECIFIED;
+        }
+        return errorCode;
+    }
+}
diff --git a/extras/src/com/mopub/mobileads/UnityInterstitial.java b/extras/src/com/mopub/mobileads/UnityInterstitial.java
new file mode 100644
index 00000000..4e2c9ece
--- /dev/null
+++ b/extras/src/com/mopub/mobileads/UnityInterstitial.java
@@ -0,0 +1,118 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.content.Context;
+
+import com.unity3d.ads.mediation.IUnityAdsExtendedListener;
+import com.unity3d.ads.UnityAds;
+
+import java.util.Map;
+
+public class UnityInterstitial extends CustomEventInterstitial implements IUnityAdsExtendedListener {
+
+    private static boolean sInitialized = false;
+    private static boolean sAdCached = false;
+    private CustomEventInterstitialListener mCustomEventInterstitialListener;
+    private Activity mLauncherActivity;
+    private String mPlacementId = "video";
+
+    @Override
+    protected void loadInterstitial(Context context,
+                                    CustomEventInterstitialListener customEventInterstitialListener,
+                                    Map<String, Object> localExtras,
+                                    Map<String, String> serverExtras) {
+
+        mPlacementId = UnityRouter.placementIdForServerExtras(serverExtras, mPlacementId);
+        mCustomEventInterstitialListener = customEventInterstitialListener;
+
+        if (!sInitialized) {
+            if (context == null || !(context instanceof Activity)) {
+                mCustomEventInterstitialListener.onInterstitialFailed(MoPubErrorCode.NETWORK_INVALID_STATE);
+                return;
+            }
+
+            mLauncherActivity = (Activity) context;
+
+            if (!UnityRouter.initUnityAds(serverExtras, mLauncherActivity, this, new Runnable() {
+                public void run() {
+                    mCustomEventInterstitialListener.onInterstitialFailed(MoPubErrorCode.NETWORK_INVALID_STATE);
+                }
+            })) {
+                return;
+            }
+
+            UnityAds.setListener(this);
+
+            UnityRouter.initPlacement(mPlacementId, new Runnable() {
+                public void run() {
+                    mCustomEventInterstitialListener.onInterstitialFailed(MoPubErrorCode.NETWORK_INVALID_STATE);
+                }
+            }, new Runnable() {
+                public void run() {
+                    mCustomEventInterstitialListener.onInterstitialLoaded();
+                }
+            });
+
+            sInitialized = true;
+        } else {
+            UnityAds.setListener(this);
+            if (UnityAds.isReady(mPlacementId)) {
+                mCustomEventInterstitialListener.onInterstitialLoaded();
+            } else {
+                sAdCached = false;
+            }
+        }
+    }
+
+    @Override
+    protected void showInterstitial() {
+        if (UnityAds.isReady(mPlacementId) && mLauncherActivity != null) {
+            UnityAds.show(mLauncherActivity, mPlacementId);
+        }
+    }
+
+    @Override
+    protected void onInvalidate() {
+        UnityAds.setListener(null);
+    }
+
+    @Override
+    public void onUnityAdsReady(String placementId) {
+        if (!sAdCached && placementId.equals(mPlacementId)) {
+            sAdCached = true;
+            mCustomEventInterstitialListener.onInterstitialLoaded();
+        }
+    }
+
+    @Override
+    public void onUnityAdsStart(String s) {
+        mCustomEventInterstitialListener.onInterstitialShown();
+    }
+
+    @Override
+    public void onUnityAdsFinish(String s, UnityAds.FinishState finishState) {
+        mCustomEventInterstitialListener.onInterstitialDismissed();
+    }
+
+    @Override
+    public void onUnityAdsClick(String placementId) {
+        mCustomEventInterstitialListener.onInterstitialClicked();
+    }
+
+    @Override
+    public void onUnityAdsError(UnityAds.UnityAdsError unityAdsError, String s) {
+        MoPubErrorCode errorCode;
+        switch (unityAdsError) {
+            case VIDEO_PLAYER_ERROR:
+                errorCode = MoPubErrorCode.VIDEO_PLAYBACK_ERROR;
+                break;
+            case INTERNAL_ERROR:
+                errorCode = MoPubErrorCode.INTERNAL_ERROR;
+                break;
+            default:
+                errorCode = MoPubErrorCode.NETWORK_INVALID_STATE;
+                break;
+        }
+        mCustomEventInterstitialListener.onInterstitialFailed(errorCode);
+    }
+}
\ No newline at end of file
diff --git a/extras/src/com/mopub/mobileads/UnityRewardedVideo.java b/extras/src/com/mopub/mobileads/UnityRewardedVideo.java
index f4fe4bcc..feaea2cf 100644
--- a/extras/src/com/mopub/mobileads/UnityRewardedVideo.java
+++ b/extras/src/com/mopub/mobileads/UnityRewardedVideo.java
@@ -3,38 +3,31 @@
 import android.app.Activity;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-import android.text.TextUtils;
 
 import com.mopub.common.BaseLifecycleListener;
-import com.mopub.common.DataKeys;
 import com.mopub.common.LifecycleListener;
-import com.mopub.common.MediationSettings;
 import com.mopub.common.MoPubReward;
 import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
-import com.unity3d.ads.android.IUnityAdsListener;
-import com.unity3d.ads.android.UnityAds;
+import com.unity3d.ads.mediation.IUnityAdsExtendedListener;
+import com.unity3d.ads.UnityAds;
 
-import java.util.Collections;
-import java.util.HashMap;
 import java.util.Map;
 
 /**
  * A custom event for showing Unity rewarded videos.
- *
- * Certified with Unity 1.4.7
  */
 public class UnityRewardedVideo extends CustomEventRewardedVideo {
-    private static final String DEFAULT_ZONE_ID = "";
     private static final String GAME_ID_KEY = "gameId";
-    private static final String ZONE_ID_KEY = "zoneId";
     private static final LifecycleListener sLifecycleListener = new UnityLifecycleListener();
     private static final UnityAdsListener sUnityAdsListener = new UnityAdsListener();
 
     private static boolean sInitialized = false;
-    @NonNull private static String sZoneId = DEFAULT_ZONE_ID;
+    private static boolean sAdCached = false;
+    private static String sPlacementId = "rewardedVideo";
 
-    @Nullable private UnityMediationSettings mMediationSettings;
+    @Nullable
+    private Activity mLauncherActivity;
 
     @Override
     @NonNull
@@ -51,30 +44,24 @@ public LifecycleListener getLifecycleListener() {
     @Override
     @NonNull
     public String getAdNetworkId() {
-        return sZoneId;
+        return sPlacementId;
     }
 
     @Override
     public boolean checkAndInitializeSdk(@NonNull final Activity launcherActivity,
-            @NonNull final Map<String, Object> localExtras,
-            @NonNull final Map<String, String> serverExtras) throws Exception {
+                                         @NonNull final Map<String, Object> localExtras,
+                                         @NonNull final Map<String, String> serverExtras) throws Exception {
         if (sInitialized) {
             return false;
         }
 
-        String gameId;
-        if (serverExtras.containsKey(GAME_ID_KEY)) {
-            gameId = serverExtras.get(GAME_ID_KEY);
-            if (TextUtils.isEmpty(gameId)) {
+        UnityRouter.initUnityAds(serverExtras, launcherActivity, sUnityAdsListener, new Runnable() {
+            @Override
+            public void run() {
                 throw new IllegalStateException("Unity rewarded video initialization failed due " +
-                        "to empty " + GAME_ID_KEY);
+                        "to empty or missing " + GAME_ID_KEY);
             }
-        } else {
-            throw new IllegalStateException("Unity rewarded video initialization failed due to " +
-                    "missing " + GAME_ID_KEY);
-        }
-
-        UnityAds.init(launcherActivity, gameId, sUnityAdsListener);
+        });
         sInitialized = true;
 
         return true;
@@ -82,32 +69,40 @@ public boolean checkAndInitializeSdk(@NonNull final Activity launcherActivity,
 
     @Override
     protected void loadWithSdkInitialized(@NonNull Activity activity,
-            @NonNull Map<String, Object> localExtras, @NonNull Map<String, String> serverExtras)
+                                          @NonNull Map<String, Object> localExtras,
+                                          @NonNull Map<String, String> serverExtras)
             throws Exception {
 
-        if (serverExtras.containsKey(ZONE_ID_KEY)) {
-            String zoneId = serverExtras.get(ZONE_ID_KEY);
-            sZoneId = TextUtils.isEmpty(zoneId) ? sZoneId : zoneId;
-        }
-
-        try {
-            setUpMediationSettingsForRequest((String) localExtras.get(DataKeys.AD_UNIT_ID_KEY));
-        } catch (ClassCastException e) {
-            MoPubLog.e("Failed to set up Unity mediation settings due to invalid ad unit id", e);
-        }
+        sPlacementId = UnityRouter.placementIdForServerExtras(serverExtras, sPlacementId);
+        mLauncherActivity = activity;
+        UnityAds.setListener(sUnityAdsListener);
 
-        loadRewardedVideo();
+        UnityRouter.initPlacement(sPlacementId, new Runnable() {
+            @Override
+            public void run() {
+                MoPubRewardedVideoManager.onRewardedVideoLoadFailure(UnityRewardedVideo.class, sPlacementId, MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
+            }
+        }, new Runnable() {
+            @Override
+            public void run() {
+                if (UnityAds.isReady(sPlacementId)) {
+                    MoPubRewardedVideoManager.onRewardedVideoLoadSuccess(UnityRewardedVideo.class, sPlacementId);
+                } else {
+                    sAdCached = false;
+                }
+            }
+        });
     }
 
     @Override
     public boolean hasVideoAvailable() {
-        return UnityAds.canShow();
+        return UnityRouter.hasVideoAvailable(sPlacementId);
     }
 
     @Override
     public void showVideo() {
         if (hasVideoAvailable()) {
-            UnityAds.show(getUnityProperties());
+            UnityAds.show(mLauncherActivity, sPlacementId);
         } else {
             MoPubLog.d("Attempted to show Unity rewarded video before it was available.");
         }
@@ -118,120 +113,78 @@ protected void onInvalidate() {
         UnityAds.setListener(null);
     }
 
-
-    private void setUpMediationSettingsForRequest(@Nullable final String moPubId) {
-        mMediationSettings =
-                MoPubRewardedVideoManager.getGlobalMediationSettings(UnityMediationSettings.class);
-
-        // Instance settings override global settings.
-        if (moPubId != null) {
-            final UnityMediationSettings instanceSettings = MoPubRewardedVideoManager
-                    .getInstanceMediationSettings(UnityMediationSettings.class, moPubId);
-            if (instanceSettings != null) {
-                mMediationSettings = instanceSettings;
-            }
-        }
-
-    }
-
     private static final class UnityLifecycleListener extends BaseLifecycleListener {
         @Override
         public void onCreate(@NonNull final Activity activity) {
             super.onCreate(activity);
-            UnityAds.changeActivity(activity);
         }
 
         @Override
         public void onResume(@NonNull final Activity activity) {
             super.onResume(activity);
-            UnityAds.changeActivity(activity);
         }
 
     }
 
-    @NonNull
-    private Map<String, Object> getUnityProperties() {
-        if (mMediationSettings == null) {
-            return Collections.emptyMap();
-        }
-        return mMediationSettings.getPropertiesMap();
-    }
-
-
-    private static class UnityAdsListener implements IUnityAdsListener,
+    private static class UnityAdsListener implements IUnityAdsExtendedListener,
             CustomEventRewardedVideoListener {
         @Override
-        public void onFetchCompleted() {
-            MoPubLog.d("Unity rewarded video cached for zone " + UnityAds.getZone() + ".");
-            loadRewardedVideo();
-        }
-
-        @Override
-        public void onFetchFailed() {
-            MoPubLog.d("Unity rewarded video cache failed for zone " + UnityAds.getZone() + ".");
-            MoPubRewardedVideoManager.onRewardedVideoLoadFailure(UnityRewardedVideo.class,
-                    UnityAds.getZone(), MoPubErrorCode.NETWORK_NO_FILL);
-        }
-
-        @Override
-        public void onShow() {
-            MoPubLog.d("Unity rewarded video displayed for zone " + UnityAds.getZone() + ".");
-        }
-
-        @Override
-        public void onHide() {
-            MoPubRewardedVideoManager.onRewardedVideoClosed(UnityRewardedVideo.class, UnityAds.getZone());
-            MoPubLog.d("Unity rewarded video dismissed for zone " + UnityAds.getZone() + ".");
+        public void onUnityAdsReady(String placementId) {
+            if (!sAdCached && placementId.equals(sPlacementId)) {
+                sAdCached = true;
+                MoPubLog.d("Unity rewarded video cached for placement " + placementId + ".");
+                MoPubRewardedVideoManager.onRewardedVideoLoadSuccess(UnityRewardedVideo.class, placementId);
+            }
         }
 
         @Override
-        public void onVideoStarted() {
-            MoPubRewardedVideoManager.onRewardedVideoStarted(UnityRewardedVideo.class, UnityAds.getZone());
-            MoPubLog.d("Unity rewarded video started for zone " + UnityAds.getZone() + ".");
+        public void onUnityAdsStart(String placementId) {
+            MoPubRewardedVideoManager.onRewardedVideoStarted(UnityRewardedVideo.class, placementId);
+            MoPubLog.d("Unity rewarded video started for placement " + placementId + ".");
         }
 
         @Override
-        public void onVideoCompleted(final String itemKey, final boolean skipped) {
-            if (!skipped) {
+        public void onUnityAdsFinish(String placementId, UnityAds.FinishState finishState) {
+            if (finishState == UnityAds.FinishState.ERROR) {
+                MoPubRewardedVideoManager.onRewardedVideoPlaybackError(
+                        UnityRewardedVideo.class,
+                        sPlacementId,
+                        MoPubErrorCode.VIDEO_PLAYBACK_ERROR);
+                MoPubLog.d("Unity rewarded video encountered a playback error for placement " + placementId);
+            } else if (finishState == UnityAds.FinishState.COMPLETED) {
                 MoPubRewardedVideoManager.onRewardedVideoCompleted(
                         UnityRewardedVideo.class,
-                        UnityAds.getZone(),
-                        MoPubReward.success(itemKey, MoPubReward.NO_REWARD_AMOUNT));
-                MoPubLog.d("Unity rewarded video completed for zone " + UnityAds.getZone()
-                        + " with reward item key " + itemKey);
+                        sPlacementId,
+                        MoPubReward.success(MoPubReward.NO_REWARD_LABEL, MoPubReward.NO_REWARD_AMOUNT));
+                MoPubLog.d("Unity rewarded video completed for placement " + placementId);
             } else {
                 MoPubRewardedVideoManager.onRewardedVideoCompleted(
                         UnityRewardedVideo.class,
-                        UnityAds.getZone(),
+                        placementId,
                         MoPubReward.failure());
-                MoPubLog.d("Unity rewarded video skipped for zone " + UnityAds.getZone() + " with "
-                        + "reward item key " + itemKey);
+                MoPubLog.d("Unity rewarded video skipped for placement " + placementId);
             }
+            MoPubRewardedVideoManager.onRewardedVideoClosed(UnityRewardedVideo.class, sPlacementId);
+            UnityAds.setListener(null);
         }
-    }
-
-    private static void loadRewardedVideo() {
-        UnityAds.setZone(sZoneId);
-        MoPubRewardedVideoManager.onRewardedVideoLoadSuccess(UnityRewardedVideo.class, UnityAds.getZone());
-    }
 
-    public static final class UnityMediationSettings implements MediationSettings {
-        @NonNull private final HashMap<String, Object> mProperties;
-
-        public UnityMediationSettings(@NonNull final String gamerId) {
-            mProperties = new HashMap<String, Object>();
-            mProperties.put(UnityAds.UNITY_ADS_OPTION_GAMERSID_KEY, gamerId);
+        @Override
+        public void onUnityAdsClick(String placementId) {
+            MoPubRewardedVideoManager.onRewardedVideoClicked(UnityRewardedVideo.class, placementId);
+            MoPubLog.d("Unity rewarded video clicked for placement " + placementId + ".");
         }
 
-        @NonNull
-        public Map<String, Object> getPropertiesMap() {
-            return mProperties;
+        @Override
+        public void onUnityAdsError(UnityAds.UnityAdsError unityAdsError, String message) {
+            MoPubLog.d("Unity rewarded video cache failed for placement " + sPlacementId + ".");
+            MoPubRewardedVideoManager.onRewardedVideoLoadFailure(UnityRewardedVideo.class,
+                    sPlacementId, MoPubErrorCode.NETWORK_NO_FILL);
         }
     }
 
     @VisibleForTesting
     void reset() {
         sInitialized = false;
-        sZoneId = DEFAULT_ZONE_ID;
+        sPlacementId = "";
     }
 }
diff --git a/extras/src/com/mopub/mobileads/UnityRouter.java b/extras/src/com/mopub/mobileads/UnityRouter.java
new file mode 100644
index 00000000..a86ed26b
--- /dev/null
+++ b/extras/src/com/mopub/mobileads/UnityRouter.java
@@ -0,0 +1,62 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.text.TextUtils;
+
+import com.mopub.common.MoPub;
+import com.unity3d.ads.mediation.IUnityAdsExtendedListener;
+import com.unity3d.ads.UnityAds;
+import com.unity3d.ads.metadata.MediationMetaData;
+
+import java.util.Map;
+
+public class UnityRouter {
+    private static final String GAME_ID_KEY = "gameId";
+    private static final String ZONE_ID_KEY = "zoneId";
+    private static final String PLACEMENT_ID_KEY = "placementId";
+
+    static boolean initUnityAds(Map<String, String> serverExtras, Activity launcherActivity, IUnityAdsExtendedListener unityAdsListener, Runnable onInitFailed) {
+        String gameId;
+        if (serverExtras.containsKey(GAME_ID_KEY)) {
+            gameId = serverExtras.get(GAME_ID_KEY);
+            if (TextUtils.isEmpty(gameId)) {
+                onInitFailed.run();
+                return false;
+            }
+        } else {
+            onInitFailed.run();
+            return false;
+        }
+
+        MediationMetaData mediationMetaData = new MediationMetaData(launcherActivity);
+        mediationMetaData.setName("MoPub");
+        mediationMetaData.setVersion(MoPub.SDK_VERSION);
+        mediationMetaData.commit();
+
+        UnityAds.initialize(launcherActivity, gameId, unityAdsListener);
+        return true;
+    }
+
+    static String placementIdForServerExtras(Map<String, String> serverExtras, String defaultPlacementId) {
+        String placementId = null;
+        if (serverExtras.containsKey(PLACEMENT_ID_KEY)) {
+            placementId = serverExtras.get(PLACEMENT_ID_KEY);
+        } else if (serverExtras.containsKey(ZONE_ID_KEY)) {
+            placementId = serverExtras.get(ZONE_ID_KEY);
+        }
+        return TextUtils.isEmpty(placementId) ? defaultPlacementId : placementId;
+    }
+
+    static void initPlacement(String placementId, Runnable onInitFailure, Runnable onInitSuccess) {
+        if (TextUtils.isEmpty(placementId)) {
+            onInitFailure.run();
+        } else if (hasVideoAvailable(placementId)) {
+            onInitSuccess.run();
+        }
+    }
+
+    static boolean hasVideoAvailable(String placementId) {
+        return UnityAds.isReady(placementId);
+    }
+
+}
\ No newline at end of file
diff --git a/extras/src/com/mopub/nativeads/GooglePlayServicesAdRenderer.java b/extras/src/com/mopub/nativeads/GooglePlayServicesAdRenderer.java
new file mode 100644
index 00000000..9798ec95
--- /dev/null
+++ b/extras/src/com/mopub/nativeads/GooglePlayServicesAdRenderer.java
@@ -0,0 +1,402 @@
+package com.mopub.nativeads;
+
+import android.content.Context;
+import android.support.annotation.IdRes;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.FrameLayout;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import com.google.android.gms.ads.formats.AdChoicesView;
+import com.google.android.gms.ads.formats.NativeAdView;
+import com.google.android.gms.ads.formats.NativeAppInstallAdView;
+import com.google.android.gms.ads.formats.NativeContentAdView;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.nativeads.GooglePlayServicesNative.GooglePlayServicesNativeAd;
+
+import java.util.Locale;
+import java.util.Map;
+import java.util.WeakHashMap;
+
+/**
+ * The {@link GooglePlayServicesAdRenderer} class is used to render
+ * GooglePlayServicesStaticNativeAds.
+ */
+public class GooglePlayServicesAdRenderer implements MoPubAdRenderer<GooglePlayServicesNativeAd> {
+
+    /**
+     * Key to set and get star rating text view as an extra in the view binder.
+     */
+    public static final String VIEW_BINDER_KEY_STAR_RATING = "key_star_rating";
+
+    /**
+     * Key to set and get advertiser text view as an extra in the view binder.
+     */
+    public static final String VIEW_BINDER_KEY_ADVERTISER = "key_advertiser";
+
+    /**
+     * Key to set and get store text view as an extra in the view binder.
+     */
+    public static final String VIEW_BINDER_KEY_STORE = "key_store";
+
+    /**
+     * Key to set and get price text view as an extra in the view binder.
+     */
+    public static final String VIEW_BINDER_KEY_PRICE = "key_price";
+
+    /**
+     * Key to set and get the AdChoices icon view as an extra in the view binder.
+     */
+    public static final String VIEW_BINDER_KEY_AD_CHOICES_ICON_CONTAINER = "ad_choices_container";
+
+    /**
+     * ID for the frame layout that wraps the Google ad view.
+     */
+    @IdRes
+    private static final int ID_WRAPPING_FRAME = 1001;
+
+    /**
+     * ID for the Google native ad view.
+     */
+    @IdRes
+    private static final int ID_GOOGLE_NATIVE_VIEW = 1002;
+
+    /**
+     * A view binder containing the layout resource and views to be rendered by the renderer.
+     */
+    private final ViewBinder mViewBinder;
+
+    /**
+     * A weak hash map used to keep track of view holder so that the views can be properly recycled.
+     */
+    private final WeakHashMap<View, GoogleStaticNativeViewHolder> mViewHolderMap;
+
+    public GooglePlayServicesAdRenderer(ViewBinder viewBinder) {
+        this.mViewBinder = viewBinder;
+        this.mViewHolderMap = new WeakHashMap<>();
+    }
+
+    @NonNull
+    @Override
+    public View createAdView(@NonNull Context context, @Nullable ViewGroup parent) {
+        View view = LayoutInflater.from(context).inflate(mViewBinder.layoutId, parent, false);
+        // Create a frame layout and add the inflated view as a child. This will allow us to add
+        // the Google native ad view into the view hierarchy at render time.
+        FrameLayout wrappingView = new FrameLayout(context);
+        wrappingView.setId(ID_WRAPPING_FRAME);
+        wrappingView.addView(view);
+        Log.i(GooglePlayServicesNative.TAG, "Ad view created.");
+        return wrappingView;
+    }
+
+    @Override
+    public void renderAdView(@NonNull View view,
+                             @NonNull GooglePlayServicesNativeAd nativeAd) {
+        GoogleStaticNativeViewHolder viewHolder = mViewHolderMap.get(view);
+        if (viewHolder == null) {
+            viewHolder = GoogleStaticNativeViewHolder.fromViewBinder(view, mViewBinder);
+            mViewHolderMap.put(view, viewHolder);
+        }
+
+        removeGoogleNativeAdView(view, nativeAd.shouldSwapMargins());
+
+        NativeAdView nativeAdView = null;
+        if (nativeAd.isNativeAppInstallAd()) {
+            nativeAdView = new NativeAppInstallAdView(view.getContext());
+            updateAppInstallAdView(nativeAd, viewHolder, (NativeAppInstallAdView) nativeAdView);
+        } else if (nativeAd.isNativeContentAd()) {
+            nativeAdView = new NativeContentAdView(view.getContext());
+            updateContentAdView(nativeAd, viewHolder, (NativeContentAdView) nativeAdView);
+        }
+
+        if (nativeAdView != null) {
+            insertGoogleNativeAdView(nativeAdView, view, nativeAd.shouldSwapMargins());
+        } else {
+            Log.w(GooglePlayServicesNative.TAG,
+                    "Couldn't add Google native ad view. NativeAdView is null.");
+        }
+    }
+
+    /**
+     * This method will add the given Google native ad view into the view hierarchy of the given
+     * MoPub native ad view.
+     *
+     * @param googleNativeAdView Google's native ad view to be added as a parent to the MoPub's
+     *                           view.
+     * @param moPubNativeAdView  MoPub's native ad view created by this renderer.
+     * @param swapMargins        {@code true} if the margins need to be swapped, {@code false}
+     *                           otherwise.
+     */
+    private static void insertGoogleNativeAdView(NativeAdView googleNativeAdView,
+                                                 View moPubNativeAdView,
+                                                 boolean swapMargins) {
+        if (moPubNativeAdView instanceof FrameLayout
+                && moPubNativeAdView.getId() == ID_WRAPPING_FRAME) {
+            googleNativeAdView.setId(ID_GOOGLE_NATIVE_VIEW);
+            FrameLayout outerFrame = (FrameLayout) moPubNativeAdView;
+            View actualView = outerFrame.getChildAt(0);
+
+            if (swapMargins) {
+                // Google native ad view renders the AdChoices icon in one of the four corners of
+                // its view. If a margin is specified on the actual ad view, the AdChoices view
+                // might be rendered outside the actual ad view. Moving the margins from the
+                // actual ad view to Google native ad view will make sure that the AdChoices icon
+                // is being rendered within the bounds of the actual ad view.
+                FrameLayout.LayoutParams googleNativeAdViewParams = new FrameLayout.LayoutParams(
+                        ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);
+                FrameLayout.LayoutParams actualViewParams =
+                        (FrameLayout.LayoutParams) actualView.getLayoutParams();
+                googleNativeAdViewParams.setMargins(actualViewParams.leftMargin,
+                        actualViewParams.topMargin,
+                        actualViewParams.rightMargin,
+                        actualViewParams.bottomMargin);
+                googleNativeAdView.setLayoutParams(googleNativeAdViewParams);
+                actualViewParams.setMargins(0, 0, 0, 0);
+            } else {
+                googleNativeAdView.setLayoutParams(new ViewGroup.LayoutParams(
+                        ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));
+            }
+
+            outerFrame.removeView(actualView);
+            googleNativeAdView.addView(actualView);
+            outerFrame.addView(googleNativeAdView);
+        } else {
+            Log.w(GooglePlayServicesNative.TAG,
+                    "Couldn't add Google native ad view. Wrapping view not found.");
+        }
+    }
+
+    /**
+     * This method will remove the Google native ad view from the view hierarchy if one is present.
+     *
+     * @param view        the view from which to remove the Google native ad view.
+     * @param swapMargins {@code true} if the margins need to be swapped before removing the
+     *                    Google native ad view, {@code false} otherwise.
+     */
+    protected static void removeGoogleNativeAdView(@NonNull View view, boolean swapMargins) {
+        if (view instanceof FrameLayout && view.getId() == ID_WRAPPING_FRAME) {
+            View adView = view.findViewById(ID_GOOGLE_NATIVE_VIEW);
+            if (adView != null) {
+                ViewGroup outerView = (ViewGroup) view;
+                int index = outerView.indexOfChild(adView);
+                outerView.removeView(adView);
+                View actualNativeView = ((ViewGroup) adView).getChildAt(0);
+                if (actualNativeView != null) {
+                    if (swapMargins) {
+                        FrameLayout.LayoutParams actualViewParams =
+                                (FrameLayout.LayoutParams) actualNativeView.getLayoutParams();
+                        FrameLayout.LayoutParams googleNativeViewParams =
+                                (FrameLayout.LayoutParams) adView.getLayoutParams();
+                        actualViewParams.setMargins(
+                                googleNativeViewParams.leftMargin,
+                                googleNativeViewParams.topMargin,
+                                googleNativeViewParams.rightMargin,
+                                googleNativeViewParams.bottomMargin);
+                    }
+                    ((ViewGroup) adView).removeView(actualNativeView);
+                    outerView.addView(actualNativeView, index);
+                }
+            }
+        }
+    }
+
+    /**
+     * This method will render the given native ad view using the native ad and set the views to
+     * Google's native content ad view.
+     *
+     * @param staticNativeAd         a static native ad object containing the required assets to
+     *                               set to the native ad view.
+     * @param staticNativeViewHolder a static native view holder object containing the mapped
+     *                               views from the view binder.
+     * @param contentAdView          the Google native content ad view in the view hierarchy.
+     */
+    private void updateContentAdView(GooglePlayServicesNativeAd staticNativeAd,
+                                     GoogleStaticNativeViewHolder staticNativeViewHolder,
+                                     NativeContentAdView contentAdView) {
+        NativeRendererHelper.addTextView(
+                staticNativeViewHolder.mTitleView, staticNativeAd.getTitle());
+        contentAdView.setHeadlineView(staticNativeViewHolder.mTitleView);
+        NativeRendererHelper.addTextView(
+                staticNativeViewHolder.mTextView, staticNativeAd.getText());
+        contentAdView.setBodyView(staticNativeViewHolder.mTextView);
+        NativeRendererHelper.addTextView(staticNativeViewHolder.mCallToActionView,
+                staticNativeAd.getCallToAction());
+        contentAdView.setCallToActionView(staticNativeViewHolder.mCallToActionView);
+        NativeImageHelper.loadImageView(staticNativeAd.getMainImageUrl(),
+                staticNativeViewHolder.mMainImageView);
+        contentAdView.setImageView(staticNativeViewHolder.mMainImageView);
+        NativeImageHelper.loadImageView(staticNativeAd.getIconImageUrl(),
+                staticNativeViewHolder.mIconImageView);
+        contentAdView.setLogoView(staticNativeViewHolder.mIconImageView);
+        if (staticNativeAd.getAdvertiser() != null) {
+            NativeRendererHelper.addTextView(
+                    staticNativeViewHolder.mAdvertiserTextView, staticNativeAd.getAdvertiser());
+            contentAdView.setAdvertiserView(staticNativeViewHolder.mAdvertiserTextView);
+        }
+
+        // Add the AdChoices icon to the container if one is provided by the publisher.
+        if (staticNativeViewHolder.mAdChoicesIconContainer != null) {
+            AdChoicesView adChoicesView = new AdChoicesView(contentAdView.getContext());
+            staticNativeViewHolder.mAdChoicesIconContainer.removeAllViews();
+            staticNativeViewHolder.mAdChoicesIconContainer.addView(adChoicesView);
+            contentAdView.setAdChoicesView(adChoicesView);
+        }
+
+        // Set the privacy information icon to null as the Google Mobile Ads SDK automatically
+        // renders the AdChoices icon.
+        NativeRendererHelper.addPrivacyInformationIcon(
+                staticNativeViewHolder.mPrivacyInformationIconImageView, null, null);
+
+        contentAdView.setNativeAd(staticNativeAd.getContentAd());
+    }
+
+    /**
+     * This method will render the given native ad view using the native ad and set the views to
+     * Google's native app install ad view.
+     *
+     * @param staticNativeAd         a static native ad object containing the required assets to set
+     *                               to the native ad view.
+     * @param staticNativeViewHolder a static native view holder object containing the mapped
+     *                               views from the view binder.
+     * @param appInstallAdView       the Google native app install ad view in the view hierarchy.
+     */
+    private void updateAppInstallAdView(GooglePlayServicesNativeAd staticNativeAd,
+                                        GoogleStaticNativeViewHolder staticNativeViewHolder,
+                                        NativeAppInstallAdView appInstallAdView) {
+
+        NativeRendererHelper.addTextView(
+                staticNativeViewHolder.mTitleView, staticNativeAd.getTitle());
+        appInstallAdView.setHeadlineView(staticNativeViewHolder.mTitleView);
+        NativeRendererHelper.addTextView(
+                staticNativeViewHolder.mTextView, staticNativeAd.getText());
+        appInstallAdView.setBodyView(staticNativeViewHolder.mTextView);
+        NativeRendererHelper.addTextView(
+                staticNativeViewHolder.mCallToActionView, staticNativeAd.getCallToAction());
+        appInstallAdView.setCallToActionView(staticNativeViewHolder.mCallToActionView);
+        NativeImageHelper.loadImageView(
+                staticNativeAd.getMainImageUrl(), staticNativeViewHolder.mMainImageView);
+        appInstallAdView.setImageView(staticNativeViewHolder.mMainImageView);
+        NativeImageHelper.loadImageView(
+                staticNativeAd.getIconImageUrl(), staticNativeViewHolder.mIconImageView);
+        appInstallAdView.setIconView(staticNativeViewHolder.mIconImageView);
+        if (staticNativeAd.getStarRating() != null) {
+            NativeRendererHelper.addTextView(staticNativeViewHolder.mStarRatingTextView,
+                    String.format(
+                            Locale.getDefault(), "%.1f/5 Stars", staticNativeAd.getStarRating()));
+            appInstallAdView.setStarRatingView(staticNativeViewHolder.mStarRatingTextView);
+        }
+        if (staticNativeAd.getPrice() != null) {
+            NativeRendererHelper.addTextView(
+                    staticNativeViewHolder.mPriceTextView, staticNativeAd.getPrice());
+            appInstallAdView.setPriceView(staticNativeViewHolder.mPriceTextView);
+        }
+        if (staticNativeAd.getStore() != null) {
+            NativeRendererHelper.addTextView(
+                    staticNativeViewHolder.mStoreTextView, staticNativeAd.getStore());
+            appInstallAdView.setStoreView(staticNativeViewHolder.mStoreTextView);
+        }
+
+        // Set the privacy information icon to null as the Google Mobile Ads SDK automatically
+        // renders the AdChoices icon.
+        NativeRendererHelper.addPrivacyInformationIcon(
+                staticNativeViewHolder.mPrivacyInformationIconImageView, null, null);
+
+        // Add the AdChoices icon to the container if one is provided by the publisher.
+        if (staticNativeViewHolder.mAdChoicesIconContainer != null) {
+            AdChoicesView adChoicesView = new AdChoicesView(appInstallAdView.getContext());
+            staticNativeViewHolder.mAdChoicesIconContainer.removeAllViews();
+            staticNativeViewHolder.mAdChoicesIconContainer.addView(adChoicesView);
+            appInstallAdView.setAdChoicesView(adChoicesView);
+        }
+
+        appInstallAdView.setNativeAd(staticNativeAd.getAppInstallAd());
+    }
+
+    @Override
+    public boolean supports(@NonNull BaseNativeAd nativeAd) {
+        return nativeAd instanceof GooglePlayServicesNativeAd;
+    }
+
+    private static class GoogleStaticNativeViewHolder {
+        @Nullable
+        View mMainView;
+        @Nullable
+        TextView mTitleView;
+        @Nullable
+        TextView mTextView;
+        @Nullable
+        TextView mCallToActionView;
+        @Nullable
+        ImageView mMainImageView;
+        @Nullable
+        ImageView mIconImageView;
+        @Nullable
+        ImageView mPrivacyInformationIconImageView;
+        @Nullable
+        TextView mStarRatingTextView;
+        @Nullable
+        TextView mAdvertiserTextView;
+        @Nullable
+        TextView mStoreTextView;
+        @Nullable
+        TextView mPriceTextView;
+        @Nullable
+        FrameLayout mAdChoicesIconContainer;
+
+        private static final GoogleStaticNativeViewHolder EMPTY_VIEW_HOLDER =
+                new GoogleStaticNativeViewHolder();
+
+        @NonNull
+        public static GoogleStaticNativeViewHolder fromViewBinder(@NonNull View view,
+                                                                  @NonNull ViewBinder viewBinder) {
+            final GoogleStaticNativeViewHolder viewHolder = new GoogleStaticNativeViewHolder();
+            viewHolder.mMainView = view;
+            try {
+                viewHolder.mTitleView = (TextView) view.findViewById(viewBinder.titleId);
+                viewHolder.mTextView = (TextView) view.findViewById(viewBinder.textId);
+                viewHolder.mCallToActionView =
+                        (TextView) view.findViewById(viewBinder.callToActionId);
+                viewHolder.mMainImageView =
+                        (ImageView) view.findViewById(viewBinder.mainImageId);
+                viewHolder.mIconImageView =
+                        (ImageView) view.findViewById(viewBinder.iconImageId);
+                viewHolder.mPrivacyInformationIconImageView =
+                        (ImageView) view.findViewById(viewBinder.privacyInformationIconImageId);
+                Map<String, Integer> extraViews = viewBinder.extras;
+                Integer starRatingTextViewId = extraViews.get(VIEW_BINDER_KEY_STAR_RATING);
+                if (starRatingTextViewId != null) {
+                    viewHolder.mStarRatingTextView =
+                            (TextView) view.findViewById(starRatingTextViewId);
+                }
+                Integer advertiserTextViewId = extraViews.get(VIEW_BINDER_KEY_ADVERTISER);
+                if (advertiserTextViewId != null) {
+                    viewHolder.mAdvertiserTextView =
+                            (TextView) view.findViewById(advertiserTextViewId);
+                }
+                Integer storeTextViewId = extraViews.get(VIEW_BINDER_KEY_STORE);
+                if (storeTextViewId != null) {
+                    viewHolder.mStoreTextView = (TextView) view.findViewById(storeTextViewId);
+                }
+                Integer priceTextViewId = extraViews.get(VIEW_BINDER_KEY_PRICE);
+                if (priceTextViewId != null) {
+                    viewHolder.mPriceTextView = (TextView) view.findViewById(priceTextViewId);
+                }
+                Integer adChoicesIconViewId =
+                        extraViews.get(VIEW_BINDER_KEY_AD_CHOICES_ICON_CONTAINER);
+                if (adChoicesIconViewId != null) {
+                    viewHolder.mAdChoicesIconContainer =
+                            (FrameLayout) view.findViewById(adChoicesIconViewId);
+                }
+                return viewHolder;
+            } catch (ClassCastException exception) {
+                MoPubLog.w("Could not cast from id in ViewBinder to expected View type", exception);
+                return EMPTY_VIEW_HOLDER;
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/extras/src/com/mopub/nativeads/GooglePlayServicesNative.java b/extras/src/com/mopub/nativeads/GooglePlayServicesNative.java
new file mode 100644
index 00000000..15932aa8
--- /dev/null
+++ b/extras/src/com/mopub/nativeads/GooglePlayServicesNative.java
@@ -0,0 +1,599 @@
+package com.mopub.nativeads;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.text.TextUtils;
+import android.util.Log;
+import android.view.View;
+
+import com.google.android.gms.ads.AdListener;
+import com.google.android.gms.ads.AdLoader;
+import com.google.android.gms.ads.AdRequest;
+import com.google.android.gms.ads.MobileAds;
+import com.google.android.gms.ads.formats.NativeAdOptions;
+import com.google.android.gms.ads.formats.NativeAppInstallAd;
+import com.google.android.gms.ads.formats.NativeContentAd;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+/**
+ * The {@link GooglePlayServicesNative} class is used to load native Google mobile ads.
+ */
+public class GooglePlayServicesNative extends CustomEventNative {
+    protected static final String TAG = "MoPubToAdMobNative";
+
+    /**
+     * The current version of the adapter.
+     */
+    private static final String ADAPTER_VERSION = "0.3.1";
+
+    /**
+     * Key to obtain AdMob application ID from the server extras provided by MoPub.
+     */
+    private static final String KEY_EXTRA_APPLICATION_ID = "appid";
+
+    /**
+     * Key to obtain AdMob ad unit ID from the extras provided by MoPub.
+     */
+    private static final String KEY_EXTRA_AD_UNIT_ID = "adunit";
+
+    /**
+     * Key to set and obtain the image orientation preference.
+     */
+    public static final String KEY_EXTRA_ORIENTATION_PREFERENCE = "orientation_preference";
+
+    /**
+     * Key to set and obtain the AdChoices icon placement preference.
+     */
+    public static final String KEY_EXTRA_AD_CHOICES_PLACEMENT = "ad_choices_placement";
+
+    /**
+     * Key to set and obtain the experimental swap margins flag.
+     */
+    public static final String KEY_EXPERIMENTAL_EXTRA_SWAP_MARGINS = "swap_margins";
+
+    /**
+     * Flag to determine whether or not the adapter has been initialized.
+     */
+    private static AtomicBoolean sIsInitialized = new AtomicBoolean(false);
+
+    @Override
+    protected void loadNativeAd(@NonNull final Context context,
+                                @NonNull final CustomEventNativeListener customEventNativeListener,
+                                @NonNull Map<String, Object> localExtras,
+                                @NonNull Map<String, String> serverExtras) {
+        if (!sIsInitialized.getAndSet(true)) {
+            Log.i(TAG, "Adapter version - " + ADAPTER_VERSION);
+            if (serverExtras.containsKey(KEY_EXTRA_APPLICATION_ID)
+                    && !TextUtils.isEmpty(serverExtras.get(KEY_EXTRA_APPLICATION_ID))) {
+                MobileAds.initialize(context, serverExtras.get(KEY_EXTRA_APPLICATION_ID));
+            } else {
+                MobileAds.initialize(context);
+            }
+        }
+
+        String adUnitId = serverExtras.get(KEY_EXTRA_AD_UNIT_ID);
+        if (TextUtils.isEmpty(adUnitId)) {
+            customEventNativeListener.onNativeAdFailed(NativeErrorCode.NETWORK_INVALID_REQUEST);
+            return;
+        }
+        GooglePlayServicesNativeAd nativeAd =
+                new GooglePlayServicesNativeAd(customEventNativeListener);
+        nativeAd.loadAd(context, adUnitId, localExtras);
+    }
+
+    /**
+     * The {@link GooglePlayServicesNativeAd} class is used to load and map Google native
+     * ads to MoPub native ads.
+     */
+    static class GooglePlayServicesNativeAd extends BaseNativeAd {
+
+        // Native ad assets.
+        private String mTitle;
+        private String mText;
+        private String mMainImageUrl;
+        private String mIconImageUrl;
+        private String mCallToAction;
+        private Double mStarRating;
+        private String mAdvertiser;
+        private String mStore;
+        private String mPrice;
+
+        /**
+         * Flag to determine whether or not to swap margins from actual ad view to Google native ad
+         * view.
+         */
+        private boolean mSwapMargins;
+
+        /**
+         * A custom event native listener used to forward Google Mobile Ads SDK events to MoPub.
+         */
+        private CustomEventNativeListener mCustomEventNativeListener;
+
+        /**
+         * A Google native ad of type content.
+         */
+        private NativeContentAd mNativeContentAd;
+
+        /**
+         * A Google native ad of type app install.
+         */
+        private NativeAppInstallAd mNativeAppInstallAd;
+
+        public GooglePlayServicesNativeAd(
+                CustomEventNativeListener customEventNativeListener) {
+            this.mCustomEventNativeListener = customEventNativeListener;
+        }
+
+        /**
+         * @return the title string associated with this native ad.
+         */
+        public String getTitle() {
+            return mTitle;
+        }
+
+        /**
+         * @return the text/body string associated with the native ad.
+         */
+        public String getText() {
+            return mText;
+        }
+
+        /**
+         * @return the main image URL associated with the native ad.
+         */
+        public String getMainImageUrl() {
+            return mMainImageUrl;
+        }
+
+        /**
+         * @return the icon image URL associated with the native ad.
+         */
+        public String getIconImageUrl() {
+            return mIconImageUrl;
+        }
+
+        /**
+         * @return the call to action string associated with the native ad.
+         */
+        public String getCallToAction() {
+            return mCallToAction;
+        }
+
+        /**
+         * @return the star rating associated with the native ad.
+         */
+        public Double getStarRating() {
+            return mStarRating;
+        }
+
+        /**
+         * @return the advertiser string associated with the native ad.
+         */
+        public String getAdvertiser() {
+            return mAdvertiser;
+        }
+
+        /**
+         * @return the store string associated with the native ad.
+         */
+        public String getStore() {
+            return mStore;
+        }
+
+        /**
+         * @return the price string associated with the native ad.
+         */
+        public String getPrice() {
+            return mPrice;
+        }
+
+        /**
+         * @param title the title to be set.
+         */
+        public void setTitle(String title) {
+            this.mTitle = title;
+        }
+
+        /**
+         * @param text the text/body to be set.
+         */
+        public void setText(String text) {
+            this.mText = text;
+        }
+
+        /**
+         * @param mainImageUrl the main image URL to be set.
+         */
+        public void setMainImageUrl(String mainImageUrl) {
+            this.mMainImageUrl = mainImageUrl;
+        }
+
+        /**
+         * @param iconImageUrl the icon image URL to be set.
+         */
+        public void setIconImageUrl(String iconImageUrl) {
+            this.mIconImageUrl = iconImageUrl;
+        }
+
+        /**
+         * @param callToAction the call to action string to be set.
+         */
+        public void setCallToAction(String callToAction) {
+            this.mCallToAction = callToAction;
+        }
+
+        /**
+         * @param starRating the star rating value to be set.
+         */
+        public void setStarRating(Double starRating) {
+            this.mStarRating = starRating;
+        }
+
+        /**
+         * @param advertiser the advertiser string to be set.
+         */
+        public void setAdvertiser(String advertiser) {
+            this.mAdvertiser = advertiser;
+        }
+
+        /**
+         * @param store the store string to be set.
+         */
+        public void setStore(String store) {
+            this.mStore = store;
+        }
+
+        /**
+         * @param price the price string to be set.
+         */
+        public void setPrice(String price) {
+            this.mPrice = price;
+        }
+
+        /**
+         * @return whether or not this ad is native content ad.
+         */
+        public boolean isNativeContentAd() {
+            return mNativeContentAd != null;
+        }
+
+        /**
+         * @return whether or not to swap margins when rendering the ad.
+         */
+        public boolean shouldSwapMargins() {
+            return this.mSwapMargins;
+        }
+
+        /**
+         * @return whether or not this ad is native app install ad.
+         */
+        public boolean isNativeAppInstallAd() {
+            return mNativeAppInstallAd != null;
+        }
+
+        /**
+         * @return {@link #mNativeContentAd}.
+         */
+        public NativeContentAd getContentAd() {
+            return mNativeContentAd;
+        }
+
+        /**
+         * @return {@link #mNativeAppInstallAd}.
+         */
+        public NativeAppInstallAd getAppInstallAd() {
+            return mNativeAppInstallAd;
+        }
+
+        /**
+         * This method will load native ads from Google for the given ad unit ID.
+         *
+         * @param context  required to request a Google native ad.
+         * @param adUnitId Google's AdMob Ad Unit ID.
+         */
+        public void loadAd(final Context context, String adUnitId,
+                           Map<String, Object> localExtras) {
+            AdLoader.Builder builder = new AdLoader.Builder(context, adUnitId);
+
+            // Get the experimental swap margins extra.
+            if (localExtras.containsKey(KEY_EXPERIMENTAL_EXTRA_SWAP_MARGINS)) {
+                Object swapMarginExtra = localExtras.get(KEY_EXPERIMENTAL_EXTRA_SWAP_MARGINS);
+                if (swapMarginExtra instanceof Boolean) {
+                    mSwapMargins = (boolean) swapMarginExtra;
+                }
+            }
+
+            NativeAdOptions.Builder optionsBuilder = new NativeAdOptions.Builder();
+
+            // MoPub requires the images to be pre-cached using their APIs, so we do not want
+            // Google to download the image assets.
+            optionsBuilder.setReturnUrlsForImageAssets(true);
+
+            // MoPub allows for only one image, so only request for one image.
+            optionsBuilder.setRequestMultipleImages(false);
+
+            // Get the preferred image orientation from the local extras.
+            if (localExtras.containsKey(KEY_EXTRA_ORIENTATION_PREFERENCE)
+                    && isValidOrientationExtra(localExtras.get(KEY_EXTRA_ORIENTATION_PREFERENCE))) {
+                optionsBuilder.setImageOrientation(
+                        (int) localExtras.get(KEY_EXTRA_ORIENTATION_PREFERENCE));
+            }
+
+            // Get the preferred AdChoices icon placement from the local extras.
+            if (localExtras.containsKey(KEY_EXTRA_AD_CHOICES_PLACEMENT)
+                    && isValidAdChoicesPlacementExtra(
+                    localExtras.get(KEY_EXTRA_AD_CHOICES_PLACEMENT))) {
+                optionsBuilder.setAdChoicesPlacement(
+                        (int) localExtras.get(KEY_EXTRA_AD_CHOICES_PLACEMENT));
+            }
+            NativeAdOptions adOptions = optionsBuilder.build();
+
+            AdLoader adLoader =
+                    builder.forContentAd(new NativeContentAd.OnContentAdLoadedListener() {
+                        @Override
+                        public void onContentAdLoaded(final NativeContentAd nativeContentAd) {
+                            if (!isValidContentAd(nativeContentAd)) {
+                                Log.i(TAG, "The Google native content ad is missing one or more "
+                                        + "required assets, failing request.");
+                                mCustomEventNativeListener.onNativeAdFailed(
+                                        NativeErrorCode.INVALID_RESPONSE);
+                                return;
+                            }
+
+                            mNativeContentAd = nativeContentAd;
+                            List<com.google.android.gms.ads.formats.NativeAd.Image> images =
+                                    nativeContentAd.getImages();
+                            List<String> imageUrls = new ArrayList<>();
+                            // Only one image should be in the the list as we turned off request
+                            // for multiple images.
+                            com.google.android.gms.ads.formats.NativeAd.Image mainImage =
+                                    images.get(0);
+                            // Assuming that the URI provided is an URL.
+                            imageUrls.add(mainImage.getUri().toString());
+
+                            com.google.android.gms.ads.formats.NativeAd.Image logoImage =
+                                    nativeContentAd.getLogo();
+                            // Assuming that the URI provided is an URL.
+                            imageUrls.add(logoImage.getUri().toString());
+                            preCacheImages(context, imageUrls);
+                        }
+                    }).forAppInstallAd(new NativeAppInstallAd.OnAppInstallAdLoadedListener() {
+                        @Override
+                        public void onAppInstallAdLoaded(
+                                final NativeAppInstallAd nativeAppInstallAd) {
+                            if (!isValidAppInstallAd(nativeAppInstallAd)) {
+                                Log.i(TAG, "The Google native app install ad is missing one or "
+                                        + "more required assets, failing request.");
+                                mCustomEventNativeListener.onNativeAdFailed(
+                                        NativeErrorCode.INVALID_RESPONSE);
+                                return;
+                            }
+                            mNativeAppInstallAd = nativeAppInstallAd;
+                            List<com.google.android.gms.ads.formats.NativeAd.Image> images =
+                                    nativeAppInstallAd.getImages();
+                            List<String> imageUrls = new ArrayList<>();
+                            // Only one image should be in the the list as we turned off request
+                            // for multiple images.
+                            com.google.android.gms.ads.formats.NativeAd.Image mainImage =
+                                    images.get(0);
+                            // Assuming that the URI provided is an URL.
+                            imageUrls.add(mainImage.getUri().toString());
+
+                            com.google.android.gms.ads.formats.NativeAd.Image iconImage =
+                                    nativeAppInstallAd.getIcon();
+                            // Assuming that the URI provided is an URL.
+                            imageUrls.add(iconImage.getUri().toString());
+                            preCacheImages(context, imageUrls);
+                        }
+                    }).withAdListener(new AdListener() {
+                        @Override
+                        public void onAdFailedToLoad(int errorCode) {
+                            super.onAdFailedToLoad(errorCode);
+                            switch (errorCode) {
+                                case AdRequest.ERROR_CODE_INTERNAL_ERROR:
+                                    mCustomEventNativeListener.onNativeAdFailed(
+                                            NativeErrorCode.NATIVE_ADAPTER_CONFIGURATION_ERROR);
+                                    break;
+                                case AdRequest.ERROR_CODE_INVALID_REQUEST:
+                                    mCustomEventNativeListener.onNativeAdFailed(
+                                            NativeErrorCode.NETWORK_INVALID_REQUEST);
+                                    break;
+                                case AdRequest.ERROR_CODE_NETWORK_ERROR:
+                                    mCustomEventNativeListener.onNativeAdFailed(
+                                            NativeErrorCode.CONNECTION_ERROR);
+                                    break;
+                                case AdRequest.ERROR_CODE_NO_FILL:
+                                    mCustomEventNativeListener.onNativeAdFailed(
+                                            NativeErrorCode.NETWORK_NO_FILL);
+                                    break;
+                                default:
+                                    mCustomEventNativeListener.onNativeAdFailed(
+                                            NativeErrorCode.UNSPECIFIED);
+                            }
+                        }
+                    }).withNativeAdOptions(adOptions).build();
+            adLoader.loadAd(new AdRequest.Builder().setRequestAgent("MoPub").build());
+        }
+
+        /**
+         * This method will check whether or not the provided extra value can be mapped to
+         * NativeAdOptions' orientation constants.
+         *
+         * @param extra to be checked if it is valid.
+         * @return {@code true} if the extra can be mapped to one of {@link NativeAdOptions}
+         * orientation constants, {@code false} otherwise.
+         */
+        private boolean isValidOrientationExtra(Object extra) {
+            if (extra == null || !(extra instanceof Integer)) {
+                return false;
+            }
+            Integer preference = (Integer) extra;
+            return (preference == NativeAdOptions.ORIENTATION_ANY
+                    || preference == NativeAdOptions.ORIENTATION_LANDSCAPE
+                    || preference == NativeAdOptions.ORIENTATION_PORTRAIT);
+        }
+
+        /**
+         * Checks whether or not the provided extra value can be mapped to NativeAdOptions'
+         * AdChoices icon placement constants.
+         *
+         * @param extra to be checked if it is valid.
+         * @return {@code true} if the extra can be mapped to one of {@link NativeAdOptions}
+         * AdChoices icon placement constants, {@code false} otherwise.
+         */
+        private boolean isValidAdChoicesPlacementExtra(Object extra) {
+            if (extra == null || !(extra instanceof Integer)) {
+                return false;
+            }
+            Integer placement = (Integer) extra;
+            return (placement == NativeAdOptions.ADCHOICES_TOP_LEFT
+                    || placement == NativeAdOptions.ADCHOICES_TOP_RIGHT
+                    || placement == NativeAdOptions.ADCHOICES_BOTTOM_LEFT
+                    || placement == NativeAdOptions.ADCHOICES_BOTTOM_RIGHT);
+        }
+
+        /**
+         * This method will check whether or not the given content ad has all the required assets
+         * (title, text, main image url, icon url and call to action) for it to be correctly
+         * mapped to a {@link GooglePlayServicesNativeAd}.
+         *
+         * @param contentAd to be checked if it is valid.
+         * @return {@code true} if the given native content ad has all the necessary assets to
+         * create a {@link GooglePlayServicesNativeAd}, {@code false} otherwise.
+         */
+        private boolean isValidContentAd(NativeContentAd contentAd) {
+            return (contentAd.getHeadline() != null && contentAd.getBody() != null
+                    && contentAd.getImages() != null && contentAd.getImages().get(0) != null
+                    && contentAd.getLogo() != null && contentAd.getCallToAction() != null);
+        }
+
+        /**
+         * This method will check whether or not the given native app install ad has all the
+         * required assets (title, text, main image url, icon url and call to action) for it to
+         * be correctly mapped to a {@link GooglePlayServicesNativeAd}.
+         *
+         * @param appInstallAd to checked if it is valid.
+         * @return {@code true} if the given native app install ad has all the necessary assets to
+         * to create a {@link GooglePlayServicesNativeAd}, {@code false} otherwise.
+         */
+        private boolean isValidAppInstallAd(NativeAppInstallAd appInstallAd) {
+            return (appInstallAd.getHeadline() != null && appInstallAd.getBody() != null
+                    && appInstallAd.getImages() != null && appInstallAd.getImages().get(0) != null
+                    && appInstallAd.getIcon() != null && appInstallAd.getCallToAction() != null);
+        }
+
+        @Override
+        public void prepare(@NonNull View view) {
+            // Adding click and impression trackers is handled by the GooglePlayServicesRenderer,
+            // do nothing here.
+        }
+
+        @Override
+        public void clear(@NonNull View view) {
+            // Called when an ad is no longer displayed to a user.
+            GooglePlayServicesAdRenderer.removeGoogleNativeAdView(view, shouldSwapMargins());
+        }
+
+        @Override
+        public void destroy() {
+            // Called when the ad will never be displayed again.
+            if (mNativeContentAd != null) {
+                mNativeContentAd.destroy();
+            }
+            if (mNativeAppInstallAd != null) {
+                mNativeAppInstallAd.destroy();
+            }
+        }
+
+        /**
+         * This method will try to cache images and send success/failure callbacks based on
+         * whether or not the image caching succeeded.
+         *
+         * @param context   required to pre-cache images.
+         * @param imageUrls the urls of images that need to be cached.
+         */
+        private void preCacheImages(Context context, List<String> imageUrls) {
+            NativeImageHelper.preCacheImages(context, imageUrls,
+                    new NativeImageHelper.ImageListener() {
+                        @Override
+                        public void onImagesCached() {
+                            if (mNativeContentAd != null) {
+                                prepareNativeContentAd(mNativeContentAd);
+                                mCustomEventNativeListener.onNativeAdLoaded(
+                                        GooglePlayServicesNativeAd.this);
+                            } else if (mNativeAppInstallAd != null) {
+                                prepareNativeAppInstallAd(mNativeAppInstallAd);
+                                mCustomEventNativeListener.onNativeAdLoaded(
+                                        GooglePlayServicesNativeAd.this);
+                            }
+                        }
+
+                        @Override
+                        public void onImagesFailedToCache(NativeErrorCode errorCode) {
+                            mCustomEventNativeListener.onNativeAdFailed(errorCode);
+                        }
+                    });
+        }
+
+        /**
+         * This method will map the Google native content ad loaded to this
+         * {@link GooglePlayServicesNativeAd}.
+         *
+         * @param contentAd that needs to be mapped to this native ad.
+         */
+        private void prepareNativeContentAd(NativeContentAd contentAd) {
+            List<com.google.android.gms.ads.formats.NativeAd.Image> images = contentAd.getImages();
+            setMainImageUrl(images.get(0).getUri().toString());
+
+            com.google.android.gms.ads.formats.NativeAd.Image logo = contentAd.getLogo();
+            setIconImageUrl(logo.getUri().toString());
+
+            setCallToAction(contentAd.getCallToAction().toString());
+
+            setTitle(contentAd.getHeadline().toString());
+
+            setText(contentAd.getBody().toString());
+
+            setAdvertiser(contentAd.getAdvertiser().toString());
+        }
+
+        /**
+         * This method will map the Google native app install ad loaded to this
+         * {@link GooglePlayServicesNativeAd}.
+         *
+         * @param appInstallAd that needs to be mapped to this native ad.
+         */
+        private void prepareNativeAppInstallAd(NativeAppInstallAd appInstallAd) {
+            List<com.google.android.gms.ads.formats.NativeAd.Image> images =
+                    appInstallAd.getImages();
+            setMainImageUrl(images.get(0).getUri().toString());
+
+            com.google.android.gms.ads.formats.NativeAd.Image icon = appInstallAd.getIcon();
+            setIconImageUrl(icon.getUri().toString());
+
+            setCallToAction(appInstallAd.getCallToAction().toString());
+
+            setTitle(appInstallAd.getHeadline().toString());
+
+            setText(appInstallAd.getBody().toString());
+
+            if (appInstallAd.getStarRating() != null) {
+                setStarRating(appInstallAd.getStarRating());
+            }
+
+            // Add store asset if available.
+            if (appInstallAd.getStore() != null) {
+                setStore(appInstallAd.getStore().toString());
+            }
+
+            // Add price asset if available.
+            if (appInstallAd.getPrice() != null) {
+                setPrice(appInstallAd.getPrice().toString());
+            }
+        }
+    }
+}
diff --git a/mopub-sample/AndroidManifest.xml b/mopub-sample/AndroidManifest.xml
index 0cd8cc88..e29019b9 100644
--- a/mopub-sample/AndroidManifest.xml
+++ b/mopub-sample/AndroidManifest.xml
@@ -1,9 +1,9 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
       package="com.mopub.simpleadsdemo"
-      android:versionCode="48"
-      android:versionName="4.11.0">
-    <uses-sdk android:minSdkVersion="9"
+      android:versionCode="50"
+      android:versionName="4.13.0">
+    <uses-sdk android:minSdkVersion="16"
               android:targetSdkVersion="23"/>
 
     <uses-permission android:name="android.permission.INTERNET" />
@@ -30,6 +30,8 @@
                 android:configChanges="keyboardHidden|orientation|screenSize"/>
         <activity android:name="com.mopub.mobileads.MraidVideoPlayerActivity"
                 android:configChanges="keyboardHidden|orientation|screenSize"/>
+        <activity android:name="com.mopub.mobileads.RewardedMraidActivity"
+                  android:configChanges="keyboardHidden|orientation|screenSize"/>
 
         <meta-data android:name="com.google.android.gms.version"
                    android:value="@integer/google_play_services_version" />
diff --git a/mopub-sample/build.gradle b/mopub-sample/build.gradle
index e1d18cc6..3524a58a 100644
--- a/mopub-sample/build.gradle
+++ b/mopub-sample/build.gradle
@@ -9,7 +9,7 @@ apply plugin: 'com.android.application'
 
 project.group = 'com.mopub'
 project.description = '''MoPub Sample App'''
-project.version = '4.11.0'
+project.version = '4.13.0'
 
 android {
     compileSdkVersion 23
@@ -17,9 +17,9 @@ android {
     lintOptions { abortOnError false }
 
     defaultConfig {
-        versionCode 48
+        versionCode 50
         versionName version
-        minSdkVersion 9
+        minSdkVersion 16
         targetSdkVersion 23
     }
 
diff --git a/mopub-sample/proguard.cfg b/mopub-sample/proguard.cfg
index 7cb03eb0..bff255cd 100644
--- a/mopub-sample/proguard.cfg
+++ b/mopub-sample/proguard.cfg
@@ -11,6 +11,7 @@
 -keep class * extends com.mopub.mobileads.CustomEventBanner {}
 -keep class * extends com.mopub.mobileads.CustomEventInterstitial {}
 -keep class * extends com.mopub.nativeads.CustomEventNative {}
+-keep class * extends com.mopub.nativeads.CustomEventRewardedAd {}
 
 # Keep methods that are accessed via reflection
 -keepclassmembers class ** { @com.mopub.common.util.ReflectionTarget *; }
diff --git a/mopub-sample/res/values/strings.xml b/mopub-sample/res/values/strings.xml
index a1deb782..661d725a 100644
--- a/mopub-sample/res/values/strings.xml
+++ b/mopub-sample/res/values/strings.xml
@@ -23,6 +23,7 @@
     <string name="ad_unit_id_leaderboard">a8919cca19784497872ae69d48f678e1</string>
     <string name="ad_unit_id_interstitial">24534e1901884e398f1253216226017e</string>
     <string name="ad_unit_id_rewarded_video">920b6145fb1546cf8b5cf2ac34638bb7</string>
+    <string name="ad_unit_id_rewarded_rich_media">15173ac6d3e54c9389b9a5ddca69b34b</string>
     <string name="ad_unit_id_native">11a17b188668469fb0412708c3d16813</string>
     <string name="swipe_text"><![CDATA[< Swipe Left & Right >]]></string>
 </resources>
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/AdUnitDataSource.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/AdUnitDataSource.java
index e95f9bce..dbe77011 100644
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/AdUnitDataSource.java
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/AdUnitDataSource.java
@@ -131,6 +131,12 @@ void deleteSampleAdUnit(final MoPubSampleAdUnit adConfiguration) {
                         REWARDED_VIDEO)
                         .description("MoPub Rewarded Video Sample")
                         .build());
+        adUnitList.add(
+                new MoPubSampleAdUnit
+                        .Builder(mContext.getString(R.string.ad_unit_id_rewarded_rich_media),
+                        REWARDED_VIDEO)
+                        .description("MoPub Rewarded Rich Media Sample")
+                        .build());
         adUnitList.add(
                 new MoPubSampleAdUnit
                         .Builder(mContext.getString(R.string.ad_unit_id_native), LIST_VIEW)
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/RewardedVideoDetailFragment.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/RewardedVideoDetailFragment.java
index 19e7825b..fc637371 100644
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/RewardedVideoDetailFragment.java
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/RewardedVideoDetailFragment.java
@@ -1,21 +1,27 @@
 package com.mopub.simpleadsdemo;
 
+import android.app.AlertDialog;
+import android.app.Dialog;
+import android.content.DialogInterface;
 import android.os.Bundle;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.v4.app.DialogFragment;
 import android.support.v4.app.Fragment;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.Button;
 
-import com.mopub.common.MoPub;
 import com.mopub.common.MoPubReward;
 import com.mopub.mobileads.MoPubErrorCode;
 import com.mopub.mobileads.MoPubRewardedVideoListener;
 import com.mopub.mobileads.MoPubRewardedVideoManager.RequestParameters;
+import com.mopub.mobileads.MoPubRewardedVideos;
 
+import java.util.HashMap;
 import java.util.Locale;
+import java.util.Map;
 import java.util.Set;
 
 import static com.mopub.simpleadsdemo.Utils.hideSoftKeyboard;
@@ -27,6 +33,8 @@
 
     @Nullable private Button mShowButton;
     @Nullable private String mAdUnitId;
+    @Nullable private Map<String, MoPubReward> mMoPubRewardsMap;
+    @Nullable private MoPubReward mSelectedReward;
 
     @Override
     public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
@@ -38,12 +46,14 @@ public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle sa
         hideSoftKeyboard(views.mKeywordsField);
 
         if (!sRewardedVideoInitialized) {
-            MoPub.initializeRewardedVideo(getActivity());
+            MoPubRewardedVideos.initializeRewardedVideo(getActivity());
             sRewardedVideoInitialized = true;
         }
-        MoPub.setRewardedVideoListener(this);
+        MoPubRewardedVideos.setRewardedVideoListener(this);
 
         mAdUnitId = adConfiguration.getAdUnitId();
+        mMoPubRewardsMap = new HashMap<>();
+
         views.mDescriptionView.setText(adConfiguration.getDescription());
         views.mAdUnitIdView.setText(mAdUnitId);
         views.mLoadButton.setOnClickListener(new View.OnClickListener() {
@@ -52,7 +62,7 @@ public void onClick(View view) {
                 if (mAdUnitId == null) {
                     return;
                 }
-                MoPub.loadRewardedVideo(mAdUnitId,
+                MoPubRewardedVideos.loadRewardedVideo(mAdUnitId,
                         new RequestParameters(views.mKeywordsField.getText().toString(), null,
                                 "sample_app_customer_id"));
                 if (mShowButton != null) {
@@ -68,7 +78,7 @@ public void onClick(View view) {
                 if (mAdUnitId == null) {
                     return;
                 }
-                MoPub.showRewardedVideo(mAdUnitId);
+                MoPubRewardedVideos.showRewardedVideo(mAdUnitId);
             }
         });
 
@@ -88,6 +98,32 @@ public void onRewardedVideoLoadSuccess(@NonNull final String adUnitId) {
                 mShowButton.setEnabled(true);
             }
             logToast(getActivity(), "Rewarded video loaded.");
+
+            Set<MoPubReward> availableRewards = MoPubRewardedVideos.getAvailableRewards(mAdUnitId);
+
+            // If there are more than one reward available, pop up alert dialog for reward selection
+            if (availableRewards.size() > 1) {
+                final SelectRewardDialogFragment selectRewardDialogFragment
+                        = SelectRewardDialogFragment.newInstance();
+
+                // The user must select a reward from the dialog
+                selectRewardDialogFragment.setCancelable(false);
+
+                // Reset rewards mapping and selected reward
+                mMoPubRewardsMap.clear();
+                mSelectedReward = null;
+
+                // Initialize mapping between reward string and reward instance
+                for (MoPubReward reward : availableRewards) {
+                    mMoPubRewardsMap.put(reward.getAmount() + " " + reward.getLabel(), reward);
+                }
+
+                selectRewardDialogFragment.loadRewards(mMoPubRewardsMap.keySet()
+                        .toArray(new String[mMoPubRewardsMap.size()]));
+                selectRewardDialogFragment.setTargetFragment(this, 0);
+                selectRewardDialogFragment.show(getActivity().getSupportFragmentManager(),
+                        "selectReward");
+            }
         }
     }
 
@@ -144,4 +180,57 @@ public void onRewardedVideoCompleted(@NonNull final Set<String> adUnitIds,
                             reward.getLabel()));
         }
     }
+
+    public void selectReward(@NonNull String selectedReward) {
+        mSelectedReward = mMoPubRewardsMap.get(selectedReward);
+        MoPubRewardedVideos.selectReward(mAdUnitId, mSelectedReward);
+    }
+
+    public static class SelectRewardDialogFragment extends DialogFragment {
+        @NonNull private String[] mRewards;
+        @NonNull private String mSelectedReward;
+
+        public static SelectRewardDialogFragment newInstance() {
+            return new SelectRewardDialogFragment();
+        }
+
+        public void loadRewards(@NonNull String[] rewards) {
+            mRewards = rewards;
+        }
+
+        @Override
+        public Dialog onCreateDialog(Bundle savedInstanceState) {
+            AlertDialog dialog = new AlertDialog.Builder(getActivity())
+                    .setTitle("Select a reward")
+                    .setSingleChoiceItems(mRewards, -1, new DialogInterface.OnClickListener() {
+                        public void onClick(DialogInterface dialog, int which) {
+                            mSelectedReward = mRewards[which];
+                        }
+                    })
+                    .setPositiveButton("Select", null)
+                    .create();
+
+            // Overriding onShow() of dialog's OnShowListener() and onClick() of the Select button's
+            // OnClickListener() to prevent the dialog from dismissing upon any button click without
+            // selecting an item first.
+            dialog.setOnShowListener(new DialogInterface.OnShowListener() {
+                @Override
+                public void onShow(DialogInterface dialog) {
+                    Button selectButton = ((AlertDialog) dialog).getButton(AlertDialog.BUTTON_POSITIVE);
+                    selectButton.setOnClickListener(new View.OnClickListener() {
+                        @Override
+                        public void onClick(View v) {
+                            if (mSelectedReward != null) {
+                                ((RewardedVideoDetailFragment) getTargetFragment())
+                                        .selectReward(mSelectedReward);
+                                dismiss();
+                            }
+                        }
+                    });
+                }
+            });
+
+            return dialog;
+        }
+    }
 }
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/AdType.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/AdType.java
index 38f7c2ba..c387b248 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/AdType.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/AdType.java
@@ -11,6 +11,7 @@
     public static final String STATIC_NATIVE = "json";
     public static final String VIDEO_NATIVE = "json_video";
     public static final String REWARDED_VIDEO = "rewarded_video";
+    public static final String REWARDED_PLAYABLE = "rewarded_playable";
     public static final String CUSTOM = "custom";
     public static final String CLEAR = "clear";
 }
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/CloseableLayout.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/CloseableLayout.java
index 6a642d16..24111e03 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/CloseableLayout.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/CloseableLayout.java
@@ -93,6 +93,8 @@ int getGravity() {
     private final Rect mCloseButtonBounds = new Rect();
     private final Rect mInsetCloseRegionBounds = new Rect();
 
+    private boolean mCloseAlwaysInteractable;
+
     @Nullable
     private UnsetPressedState mUnsetPressedState;
 
@@ -117,6 +119,7 @@ public CloseableLayout(@NonNull Context context) {
         mCloseButtonPadding = Dips.asIntPixels(CLOSE_BUTTON_PADDING_DP, context);
 
         setWillNotDraw(false);
+        mCloseAlwaysInteractable = true;
     }
 
     public void setOnCloseListener(@Nullable OnCloseListener onCloseListener) {
@@ -202,10 +205,11 @@ public boolean onInterceptTouchEvent(@NonNull final MotionEvent event) {
 
     @Override
     public boolean onTouchEvent(@NonNull MotionEvent event) {
-        // Stop receiving touch events if we aren't within the bounds, including some slop.
+        // Stop receiving touch events if we aren't within the bounds (including some slop)
+        // or if we aren't allowing a touch event due to an invisible button.
         final int x = (int) event.getX();
         final int y = (int) event.getY();
-        if (!pointInCloseBounds(x, y, mTouchSlop)) {
+        if (!pointInCloseBounds(x, y, mTouchSlop) || !shouldAllowPress()) {
             setClosePressed(false);
             super.onTouchEvent(event);
             return false;
@@ -234,6 +238,20 @@ public boolean onTouchEvent(@NonNull MotionEvent event) {
         return true;
     }
 
+    /**
+     * Sets it so that touch events are also valid when the button is not visible.
+     *
+     * @param closeAlwaysInteractable True if you want to allow touch events to an invisible button
+     */
+    public void setCloseAlwaysInteractable(boolean closeAlwaysInteractable) {
+        mCloseAlwaysInteractable = closeAlwaysInteractable;
+    }
+
+    @VisibleForTesting
+    boolean shouldAllowPress() {
+        return mCloseAlwaysInteractable || mCloseDrawable.isVisible();
+    }
+
     private void setClosePressed(boolean pressed) {
         if (pressed == isClosePressed()) {
             return;
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/Constants.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/Constants.java
index 649ca5d3..33e44fe3 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/Constants.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/Constants.java
@@ -25,4 +25,9 @@ private Constants() {}
 
     public static final String NATIVE_VIDEO_ID = "native_video_id";
     public static final String NATIVE_VAST_VIDEO_CONFIG = "native_vast_video_config";
+
+    // Internal Video Tracking nouns, defined in ad server
+    public static final String VIDEO_TRACKING_EVENTS_KEY = "events";
+    public static final String VIDEO_TRACKING_URLS_KEY = "urls";
+    public static final String VIDEO_TRACKING_URL_MACRO = "%%VIDEO_EVENT%%";
 }
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/DataKeys.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/DataKeys.java
index aa66cb94..494c980f 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/DataKeys.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/DataKeys.java
@@ -25,8 +25,19 @@
     public static final String MAX_BUFFER_MS = "Max-Buffer-Ms";
     public static final String EVENT_DETAILS = "Event-Details";
 
-    // Rewarded Video fields
-    public static final String REWARDED_VIDEO_CURRENCY_NAME_KEY = "Rewarded-Video-Currency-Name";
-    public static final String REWARDED_VIDEO_CURRENCY_AMOUNT_STRING_KEY = "Rewarded-Video-Currency-Value-String";
-    public static final String REWARDED_VIDEO_CUSTOMER_ID = "Rewarded-Video-Customer-Id";
+    // Rewarded Ad fields
+    public static final String REWARDED_AD_CURRENCY_NAME_KEY = "Rewarded-Ad-Currency-Name";
+    public static final String REWARDED_AD_CURRENCY_AMOUNT_STRING_KEY = "Rewarded-Ad-Currency-Value-String";
+    public static final String REWARDED_AD_CUSTOMER_ID_KEY = "Rewarded-Ad-Customer-Id";
+    public static final String REWARDED_AD_DURATION_KEY = "Rewarded-Ad-Duration";
+    public static final String SHOULD_REWARD_ON_CLICK_KEY = "Should-Reward-On-Click";
+
+    /**
+     * @deprecated as of 4.12, replaced by {@link #REWARDED_AD_CUSTOMER_ID_KEY}
+     */
+    @Deprecated
+    public static final String REWARDED_VIDEO_CUSTOMER_ID = "Rewarded-Ad-Customer-Id";
+
+    // Video tracking fields
+    public static final String VIDEO_TRACKERS_KEY = "Video-Trackers";
 }
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/IntentActions.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/IntentActions.java
index 00dcd8b5..39134208 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/IntentActions.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/IntentActions.java
@@ -11,6 +11,6 @@
     public static final String ACTION_INTERSTITIAL_CLICK = "com.mopub.action.interstitial.click";
 
     public static final String ACTION_REWARDED_VIDEO_COMPLETE = "com.mopub.action.rewardedvideo.complete";
-
+    public static final String ACTION_REWARDED_PLAYABLE_COMPLETE = "com.mopub.action.rewardedplayable.complete";
     private IntentActions() {}
 }
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/LocationService.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/LocationService.java
index 77e44feb..8e6e5471 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/LocationService.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/LocationService.java
@@ -3,6 +3,7 @@
 import android.content.Context;
 import android.location.Location;
 import android.location.LocationManager;
+import android.os.SystemClock;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 
@@ -47,6 +48,29 @@
         }
     }
 
+    private static volatile LocationService sInstance;
+    @VisibleForTesting @Nullable Location mLastKnownLocation;
+    @VisibleForTesting long mLocationLastUpdatedMillis;
+
+    private LocationService() {
+    }
+
+    @VisibleForTesting
+    @NonNull
+    static LocationService getInstance() {
+        LocationService locationService = sInstance;
+        if (locationService == null) {
+            synchronized (LocationService.class) {
+                locationService = sInstance;
+                if (locationService == null) {
+                    locationService = new LocationService();
+                    sInstance = locationService;
+                }
+            }
+        }
+        return locationService;
+    }
+
     public enum ValidLocationProvider {
         NETWORK(LocationManager.NETWORK_PROVIDER),
         GPS(LocationManager.GPS_PROVIDER);
@@ -75,12 +99,17 @@ private boolean hasRequiredPermissions(@NonNull final Context context) {
         }
     }
 
-    /*
+    /**
      * Returns the last known location of the device using its GPS and network location providers.
-     * May be null if:
-     * - Location permissions are not requested in the Android manifest file
-     * - The location providers don't exist
-     * - Location awareness is disabled in the parent MoPubView
+     * This only checks Android location providers as often as
+     * {@link MoPub#getMinimumLocationRefreshTimeMillis()} says to, in milliseconds.
+     * <p>
+     * May be {@code null} if:
+     * <ul>
+     * <li> Location permissions are not requested in the Android manifest file
+     * <li> The location providers don't exist
+     * <li> Location awareness is disabled in the parent MoPubView
+     * </ul>
      */
     @Nullable
     public static Location getLastKnownLocation(@NonNull final Context context,
@@ -93,6 +122,12 @@ public static Location getLastKnownLocation(@NonNull final Context context,
             return null;
         }
 
+        final LocationService locationService = getInstance();
+
+        if (isLocationFreshEnough()) {
+            return locationService.mLastKnownLocation;
+        }
+
         final Location gpsLocation = getLocationFromProvider(context, ValidLocationProvider.GPS);
         final Location networkLocation = getLocationFromProvider(context, ValidLocationProvider.NETWORK);
         final Location result = getMostRecentValidLocation(gpsLocation, networkLocation);
@@ -102,6 +137,8 @@ public static Location getLastKnownLocation(@NonNull final Context context,
             truncateLocationLatLon(result, locationPrecision);
         }
 
+        locationService.mLastKnownLocation = result;
+        locationService.mLocationLastUpdatedMillis = SystemClock.elapsedRealtime();
         return result;
     }
 
@@ -151,7 +188,6 @@ static Location getMostRecentValidLocation(@Nullable final Location a, @Nullable
     }
 
     @VisibleForTesting
-    @Nullable
     static void truncateLocationLatLon(@Nullable final Location location,
             final int precision) {
         if (location == null || precision < 0) {
@@ -170,4 +206,19 @@ static void truncateLocationLatLon(@Nullable final Location location,
                 .doubleValue();
         location.setLongitude(truncatedLon);
     }
+
+    private static boolean isLocationFreshEnough() {
+        final LocationService locationService = LocationService.getInstance();
+        if (locationService.mLastKnownLocation == null) {
+            return false;
+        }
+        return SystemClock.elapsedRealtime() - locationService.mLocationLastUpdatedMillis <=
+                MoPub.getMinimumLocationRefreshTimeMillis();
+    }
+
+    @Deprecated
+    @VisibleForTesting
+    public static void clearLastKnownLocation() {
+        getInstance().mLastKnownLocation = null;
+    }
 }
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/MoPub.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/MoPub.java
index 8c3356c4..f9025f68 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/MoPub.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/MoPub.java
@@ -11,7 +11,7 @@
 import java.lang.reflect.Method;
 
 public class MoPub {
-    public static final String SDK_VERSION = "4.11.0";
+    public static final String SDK_VERSION = "4.13.0";
 
     public enum LocationAwareness { NORMAL, TRUNCATED, DISABLED }
 
@@ -25,8 +25,10 @@
             "com.mopub.mobileads.MoPubRewardedVideoManager$RequestParameters";
 
     private static final int DEFAULT_LOCATION_PRECISION = 6;
+    private static final long DEFAULT_LOCATION_REFRESH_TIME_MILLIS = 60 * 1000;
     private static volatile LocationAwareness sLocationLocationAwareness = LocationAwareness.NORMAL;
     private static volatile int sLocationPrecision = DEFAULT_LOCATION_PRECISION;
+    private static volatile long sMinimumLocationRefreshTimeMillis = DEFAULT_LOCATION_REFRESH_TIME_MILLIS;
     private static boolean sSearchedForUpdateActivityMethod = false;
     @Nullable private static Method sUpdateActivityMethod;
 
@@ -50,6 +52,15 @@ public static void setLocationPrecision(int precision) {
         sLocationPrecision = Math.min(Math.max(0, precision), DEFAULT_LOCATION_PRECISION);
     }
 
+    public static void setMinimumLocationRefreshTimeMillis(
+            final long minimumLocationRefreshTimeMillis) {
+        sMinimumLocationRefreshTimeMillis = minimumLocationRefreshTimeMillis;
+    }
+
+    public static long getMinimumLocationRefreshTimeMillis() {
+        return sMinimumLocationRefreshTimeMillis;
+    }
+
 
     //////// MoPub LifecycleListener messages ////////
 
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/MoPubBrowser.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/MoPubBrowser.java
index 65baca5d..55b24452 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/MoPubBrowser.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/MoPubBrowser.java
@@ -172,7 +172,7 @@ protected void onPause() {
     protected void onResume() {
         super.onResume();
         CookieSyncManager.getInstance().startSync();
-        WebViews.onResume(mWebView);
+        mWebView.onResume();
 
         dwellTimeTracker.start();
     }
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/MoPubLifecycleManager.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/MoPubLifecycleManager.java
index 41394805..8d7a4e86 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/MoPubLifecycleManager.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/MoPubLifecycleManager.java
@@ -87,14 +87,14 @@ public void onRestart(@NonNull final Activity activity) {
     @Override
     public void onStop(@NonNull final Activity activity) {
         for (LifecycleListener lifecycleListener : mLifecycleListeners) {
-            lifecycleListener.onRestart(activity);
+            lifecycleListener.onStop(activity);
         }
     }
 
     @Override
     public void onDestroy(@NonNull final Activity activity) {
         for (LifecycleListener lifecycleListener : mLifecycleListeners) {
-            lifecycleListener.onRestart(activity);
+            lifecycleListener.onDestroy(activity);
         }
     }
 
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/UrlResolutionTask.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/UrlResolutionTask.java
index 543a4199..1e357657 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/UrlResolutionTask.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/UrlResolutionTask.java
@@ -17,137 +17,139 @@
 
 @VisibleForTesting
 public class UrlResolutionTask extends AsyncTask<String, Void, String> {
-    private static final int REDIRECT_LIMIT = 10;
-
-    interface UrlResolutionListener {
-        void onSuccess(@NonNull final String resolvedUrl);
-        void onFailure(@NonNull final String message, @Nullable final Throwable throwable);
-    }
-
-    @NonNull private final UrlResolutionListener mListener;
-
-    public static void getResolvedUrl(@NonNull final String urlString,
-            @NonNull final UrlResolutionListener listener) {
-        final UrlResolutionTask urlResolutionTask = new UrlResolutionTask(listener);
-
-        try {
-            AsyncTasks.safeExecuteOnExecutor(urlResolutionTask, urlString);
-        } catch (Exception e) {
-            listener.onFailure("Failed to resolve url", e);
-        }
-    }
-
-    UrlResolutionTask(@NonNull UrlResolutionListener listener) {
-        mListener = listener;
-    }
-
-    @Nullable
-    @Override
-    protected String doInBackground(@Nullable String... urls) {
-        if (urls == null || urls.length == 0) {
-            return null;
-        }
-
-        String previousUrl = null;
-        try {
-            String locationUrl = urls[0];
-
-            int redirectCount = 0;
-            while (locationUrl != null && redirectCount < REDIRECT_LIMIT) {
-                // if location url is not http(s), assume it's an Android deep link
-                // this scheme will fail URL validation so we have to check early
-                if (!UrlAction.OPEN_IN_APP_BROWSER.shouldTryHandlingUrl(Uri.parse(locationUrl))) {
-                    return locationUrl;
-                }
-
-                previousUrl = locationUrl;
-                locationUrl = getRedirectLocation(locationUrl);
-                redirectCount++;
-            }
-
-        } catch (IOException e) {
-            return null;
-        } catch (URISyntaxException e) {
-            return null;
-        }
-
-        return previousUrl;
-    }
-
-    @Nullable
-    private String getRedirectLocation(@NonNull final String urlString) throws IOException,
-            URISyntaxException {
-        final URL url = new URL(urlString);
-
-        HttpURLConnection httpUrlConnection = null;
-        try {
-            httpUrlConnection = (HttpURLConnection) url.openConnection();
-            httpUrlConnection.setInstanceFollowRedirects(false);
-
-            return resolveRedirectLocation(urlString, httpUrlConnection);
-        } catch (java.lang.IllegalStateException e) {
-            //java.lang.IllegalStateException possible from com.android.okhttp.internal.huc.HttpURLConnectionImpl.getResponseCode -> com.android.okhttp.internal.DiskLruCache.checkNotClosed
-            //Throw a new IOException like resolveRedirectLocation would for a similar IO error
-           throw new IOException("Unable to resolve URL due to IllegalStateException", e);
-        } finally {
-            if (httpUrlConnection != null) {
-                httpUrlConnection.disconnect();
-            }
-        }
-    }
-
-    @VisibleForTesting
-    @Nullable
-    static String resolveRedirectLocation(@NonNull final String baseUrl,
-            @NonNull final HttpURLConnection httpUrlConnection) throws IOException, URISyntaxException {
-        final URI baseUri = new URI(baseUrl);
-        final int responseCode = httpUrlConnection.getResponseCode();
-        final String redirectUrl = httpUrlConnection.getHeaderField("Location");
-        String result = null;
-
-        if (responseCode >= 300 && responseCode < 400) {
-
-            if (TextUtils.isEmpty(redirectUrl)){
-                throw new URISyntaxException(redirectUrl, "Unable to parse invalid URL");
-            }
-
-            try {
-                // If redirectUrl is a relative path, then resolve() will correctly complete the path;
-                // otherwise, resolve() will return the redirectUrl
-                String encodedRedirectUrl = encodeUriParameters(redirectUrl);
-                result = baseUri.resolve(encodedRedirectUrl).toString();
-            } catch (IllegalArgumentException| MalformedURLException | URISyntaxException e) {
-                // Ensure the request is cancelled instead of resolving an intermediary URL
-                throw new URISyntaxException(redirectUrl, "Unable to parse invalid URL");
-            }
-        }
-
-        return result;
-    }
-
-    @Override
-    protected void onPostExecute(@Nullable final String resolvedUrl) {
-        super.onPostExecute(resolvedUrl);
-
-        if (isCancelled() || resolvedUrl == null) {
-            onCancelled();
-        } else {
-            mListener.onSuccess(resolvedUrl);
-        }
-    }
-
-    @Override
-    protected void onCancelled() {
-        super.onCancelled();
-
-        mListener.onFailure("Task for resolving url was cancelled", null);
-    }
-
-    private static String encodeUriParameters(String locationUrl) throws MalformedURLException, URISyntaxException{
-        URL url = new URL(locationUrl);
-        URI uri = new URI(url.getProtocol(), url.getHost(), url.getPath(), url.getQuery(), null);
-        return uri.toString();
-    }
+	private static final int REDIRECT_LIMIT = 10;
+	
+	interface UrlResolutionListener {
+		void onSuccess(@NonNull final String resolvedUrl);
+		
+		void onFailure(@NonNull final String message, @Nullable final Throwable throwable);
+	}
+	
+	@NonNull private final UrlResolutionListener mListener;
+	
+	public static void getResolvedUrl(@NonNull final String urlString,
+	                                  @NonNull final UrlResolutionListener listener) {
+		final UrlResolutionTask urlResolutionTask = new UrlResolutionTask(listener);
+		
+		try {
+			AsyncTasks.safeExecuteOnExecutor(urlResolutionTask, urlString);
+		} catch (Exception e) {
+			listener.onFailure("Failed to resolve url", e);
+		}
+	}
+	
+	UrlResolutionTask(@NonNull UrlResolutionListener listener) {
+		mListener = listener;
+	}
+	
+	@Nullable
+	@Override
+	protected String doInBackground(@Nullable String... urls) {
+		if (urls == null || urls.length == 0) {
+			return null;
+		}
+		
+		String previousUrl = null;
+		try {
+			String locationUrl = urls[0];
+			
+			int redirectCount = 0;
+			while (locationUrl != null && redirectCount < REDIRECT_LIMIT) {
+				// if location url is not http(s), assume it's an Android deep link
+				// this scheme will fail URL validation so we have to check early
+				if (!UrlAction.OPEN_IN_APP_BROWSER.shouldTryHandlingUrl(Uri.parse(locationUrl))) {
+					return locationUrl;
+				}
+				
+				previousUrl = locationUrl;
+				locationUrl = getRedirectLocation(locationUrl);
+				redirectCount++;
+			}
+			
+		} catch (IOException e) {
+			return null;
+		} catch (URISyntaxException e) {
+			return null;
+		}
+		
+		return previousUrl;
+	}
+	
+	@Nullable
+	private String getRedirectLocation(@NonNull final String urlString) throws IOException,
+			URISyntaxException {
+		final URL url = new URL(urlString);
+		
+		HttpURLConnection httpUrlConnection = null;
+		try {
+			httpUrlConnection = (HttpURLConnection) url.openConnection();
+			httpUrlConnection.setInstanceFollowRedirects(false);
+			
+			return resolveRedirectLocation(urlString, httpUrlConnection);
+		} catch (java.lang.IllegalStateException e) {
+			//java.lang.IllegalStateException possible from com.android.okhttp.internal.huc.HttpURLConnectionImpl.getResponseCode -> com
+			// .android.okhttp.internal.DiskLruCache.checkNotClosed
+			//Throw a new IOException like resolveRedirectLocation would for a similar IO error
+			throw new IOException("Unable to resolve URL due to IllegalStateException", e);
+		} finally {
+			if (httpUrlConnection != null) {
+				httpUrlConnection.disconnect();
+			}
+		}
+	}
+	
+	@VisibleForTesting
+	@Nullable
+	static String resolveRedirectLocation(@NonNull final String baseUrl,
+	                                      @NonNull final HttpURLConnection httpUrlConnection) throws IOException, URISyntaxException {
+		final URI baseUri = new URI(baseUrl);
+		final int responseCode = httpUrlConnection.getResponseCode();
+		final String redirectUrl = httpUrlConnection.getHeaderField("Location");
+		String result = null;
+		
+		if (responseCode >= 300 && responseCode < 400) {
+			
+			if (TextUtils.isEmpty(redirectUrl)) {
+				throw new URISyntaxException(redirectUrl, "Unable to parse invalid URL");
+			}
+			
+			try {
+				// If redirectUrl is a relative path, then resolve() will correctly complete the path;
+				// otherwise, resolve() will return the redirectUrl
+				String encodedRedirectUrl = encodeUriParameters(redirectUrl);
+				result = baseUri.resolve(encodedRedirectUrl).toString();
+			} catch (IllegalArgumentException | MalformedURLException | URISyntaxException e) {
+				// Ensure the request is cancelled instead of resolving an intermediary URL
+				throw new URISyntaxException(redirectUrl, "Unable to parse invalid URL");
+			}
+		}
+		
+		return result;
+	}
+	
+	@Override
+	protected void onPostExecute(@Nullable final String resolvedUrl) {
+		super.onPostExecute(resolvedUrl);
+		
+		if (isCancelled() || resolvedUrl == null) {
+			onCancelled();
+		} else {
+			mListener.onSuccess(resolvedUrl);
+		}
+	}
+	
+	@Override
+	protected void onCancelled() {
+		super.onCancelled();
+		
+		mListener.onFailure("Task for resolving url was cancelled", null);
+	}
+	
+	private static String encodeUriParameters(String locationUrl) throws MalformedURLException, URISyntaxException {
+		Uri uriRow = Uri.parse(locationUrl);
+		URI uri = new URI(uriRow.getScheme(), uriRow.getHost(), uriRow.getEncodedPath(), uriRow.getEncodedQuery(), null);
+		return uri.toString();
+	}
 }
 
 
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/AsyncTasks.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/AsyncTasks.java
index b8e25d73..e1da8d52 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/AsyncTasks.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/AsyncTasks.java
@@ -1,15 +1,11 @@
 package com.mopub.common.util;
 
-import android.annotation.TargetApi;
 import android.os.AsyncTask;
-import android.os.Build.VERSION;
-import android.os.Build.VERSION_CODES;
 
 import com.mopub.common.Preconditions;
 import com.mopub.common.VisibleForTesting;
 
 import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
 
 public class AsyncTasks {
     private static Executor sExecutor;
@@ -19,14 +15,9 @@
     }
 
     // This is in a separate method rather than a static block to pass lint.
-    @TargetApi(VERSION_CODES.HONEYCOMB)
     private static void init() {
-        // Reuse the async task executor if possible
-        if (VERSION.SDK_INT >= VERSION_CODES.HONEYCOMB) {
-            sExecutor = AsyncTask.THREAD_POOL_EXECUTOR;
-        } else {
-            sExecutor = Executors.newSingleThreadExecutor();
-        }
+        // Reuse the async task executor
+        sExecutor = AsyncTask.THREAD_POOL_EXECUTOR;
     }
 
     @VisibleForTesting
@@ -36,18 +27,12 @@ public static void setExecutor(Executor executor) {
 
     /**
      * Starting with Honeycomb, default AsyncTask#execute behavior runs the tasks serially. This
-     * method attempts to force these AsyncTasks to run in parallel with a ThreadPoolExecutor, if
-     * possible.
+     * method attempts to force these AsyncTasks to run in parallel with a ThreadPoolExecutor.
      */
-    @TargetApi(VERSION_CODES.HONEYCOMB)
     public static <P> void safeExecuteOnExecutor(AsyncTask<P, ?, ?> asyncTask, P... params) {
         Preconditions.checkNotNull(asyncTask, "Unable to execute null AsyncTask.");
         Preconditions.checkUiThread("AsyncTask must be executed on the main thread");
 
-        if (VERSION.SDK_INT >= VERSION_CODES.HONEYCOMB) {
-            asyncTask.executeOnExecutor(sExecutor, params);
-        } else {
-            asyncTask.execute(params);
-        }
+        asyncTask.executeOnExecutor(sExecutor, params);
     }
 }
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/DeviceUtils.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/DeviceUtils.java
index ed4142da..c4395a46 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/DeviceUtils.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/DeviceUtils.java
@@ -31,8 +31,6 @@
 import static android.Manifest.permission.ACCESS_NETWORK_STATE;
 import static android.Manifest.permission.INTERNET;
 import static com.mopub.common.util.Reflection.MethodBuilder;
-import static com.mopub.common.util.VersionCode.HONEYCOMB;
-import static com.mopub.common.util.VersionCode.currentApiLevel;
 
 public class DeviceUtils {
     private static final int MAX_MEMORY_CACHE_SIZE = 30 * 1024 * 1024; // 30 MB
@@ -98,15 +96,13 @@ public static int memoryCacheSizeBytes(final Context context) {
         final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
         long memoryClass = activityManager.getMemoryClass();
 
-        if (currentApiLevel().isAtLeast(HONEYCOMB)) {
-            try {
-                final int flagLargeHeap = ApplicationInfo.class.getDeclaredField("FLAG_LARGE_HEAP").getInt(null);
-                if (Utils.bitMaskContainsFlag(context.getApplicationInfo().flags, flagLargeHeap)) {
-                    memoryClass = (Integer) new MethodBuilder(activityManager, "getLargeMemoryClass").execute();
-                }
-            } catch (Exception e) {
-                MoPubLog.d("Unable to reflectively determine large heap size on Honeycomb and above.");
+        try {
+            final int flagLargeHeap = ApplicationInfo.class.getDeclaredField("FLAG_LARGE_HEAP").getInt(null);
+            if (Utils.bitMaskContainsFlag(context.getApplicationInfo().flags, flagLargeHeap)) {
+                memoryClass = (Integer) new MethodBuilder(activityManager, "getLargeMemoryClass").execute();
             }
+        } catch (Exception e) {
+            MoPubLog.d("Unable to reflectively determine large heap size.");
         }
 
         long result = Math.min(MAX_MEMORY_CACHE_SIZE, memoryClass / 8 * 1024 * 1024);
@@ -217,26 +213,24 @@ public static Point getDeviceDimensions(@NonNull final Context context) {
         Integer bestWidthPixels = null;
         Integer bestHeightPixels = null;
 
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {
-            final WindowManager windowManager = (WindowManager) context.getSystemService(
-                    Context.WINDOW_SERVICE);
-            final Display display = windowManager.getDefaultDisplay();
-            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
-                final Point screenSize = new Point();
-                display.getRealSize(screenSize);
-                bestWidthPixels = screenSize.x;
-                bestHeightPixels = screenSize.y;
-            } else {
-                try {
-                    bestWidthPixels = (Integer) new MethodBuilder(display,
-                            "getRawWidth").execute();
-                    bestHeightPixels = (Integer) new MethodBuilder(display,
-                            "getRawHeight").execute();
-                } catch (Exception e) {
-                    // Best effort. If this fails, just get the height and width normally,
-                    // which may not capture the pixels used in the notification bar.
-                    MoPubLog.v("Display#getRawWidth/Height failed.", e);
-                }
+        final WindowManager windowManager = (WindowManager) context.getSystemService(
+                Context.WINDOW_SERVICE);
+        final Display display = windowManager.getDefaultDisplay();
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
+            final Point screenSize = new Point();
+            display.getRealSize(screenSize);
+            bestWidthPixels = screenSize.x;
+            bestHeightPixels = screenSize.y;
+        } else {
+            try {
+                bestWidthPixels = (Integer) new MethodBuilder(display,
+                        "getRawWidth").execute();
+                bestHeightPixels = (Integer) new MethodBuilder(display,
+                        "getRawHeight").execute();
+            } catch (Exception e) {
+                // Best effort. If this fails, just get the height and width normally,
+                // which may not capture the pixels used in the notification bar.
+                MoPubLog.v("Display#getRawWidth/Height failed.", e);
             }
         }
 
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/ImageUtils.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/ImageUtils.java
index 90e7f16a..deb8928b 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/ImageUtils.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/ImageUtils.java
@@ -43,19 +43,4 @@ public static Bitmap applyFastGaussianBlurToBitmap(@NonNull Bitmap mutableBitmap
         mutableBitmap.setPixels(pixels, 0, w, 0, 0, w, h);
         return mutableBitmap;
     }
-
-    /**
-     * Sets the alpha value of the ImageView.
-     * API Level < 16: https://developer.android.com/reference/android/widget/ImageView.html#setAlpha(int)
-     * API Level >= 16: https://developer.android.com/reference/android/widget/ImageView.html#setImageAlpha(int)
-     * @param imageView the ImageView
-     * @param alpha the alpha value being applied to the ImageView
-     */
-    public static void setImageViewAlpha(@NonNull ImageView imageView, int alpha) {
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
-            imageView.setImageAlpha(alpha);
-        } else {
-            imageView.setAlpha(alpha);
-        }
-    }
 }
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/ManifestUtils.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/ManifestUtils.java
index c248acec..791ef1f6 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/ManifestUtils.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/ManifestUtils.java
@@ -19,14 +19,13 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import static com.mopub.common.util.VersionCode.HONEYCOMB_MR2;
-import static com.mopub.common.util.VersionCode.currentApiLevel;
-
 public class ManifestUtils {
     private ManifestUtils() {}
 
     private static final String MOPUB_ACTIVITY = "com.mopub.mobileads.MoPubActivity";
     private static final String MRAID_ACTIVITY = "com.mopub.mobileads.MraidActivity";
+    private static final String REWARDED_MRAID_ACTIVITY =
+            "com.mopub.mobileads.RewardedMraidActivity";
     private static final List<Class<? extends Activity>> REQUIRED_WEB_VIEW_SDK_ACTIVITIES;
     private static FlagCheckUtil sFlagCheckUtil = new FlagCheckUtil();
 
@@ -41,8 +40,10 @@ private ManifestUtils() {}
         try {
             final Class moPubActivityClass = Class.forName(MOPUB_ACTIVITY);
             final Class mraidActivityClass = Class.forName(MRAID_ACTIVITY);
+            final Class rewardedMraidActivityClass = Class.forName(REWARDED_MRAID_ACTIVITY);
             REQUIRED_WEB_VIEW_SDK_ACTIVITIES.add(moPubActivityClass);
             REQUIRED_WEB_VIEW_SDK_ACTIVITIES.add(mraidActivityClass);
+            REQUIRED_WEB_VIEW_SDK_ACTIVITIES.add(rewardedMraidActivityClass);
         } catch (ClassNotFoundException e) {
             MoPubLog.i("ManifestUtils running without interstitial module");
         }
@@ -232,12 +233,7 @@ private static ActivityConfigChanges getActivityConfigChanges(@NonNull Context c
         activityConfigChanges.hasOrientation = sFlagCheckUtil.hasFlag(activity, activityInfo.configChanges, ActivityInfo.CONFIG_ORIENTATION);
         activityConfigChanges.hasScreenSize = true;
 
-        // For screenSize, only set to false if the API level and target API are >= 13
-        // If the target API is < 13, then Android will implement its own backwards compatibility
-        if (currentApiLevel().isAtLeast(HONEYCOMB_MR2) &&
-                context.getApplicationInfo().targetSdkVersion >= VersionCode.HONEYCOMB_MR2.getApiLevel()) {
-            activityConfigChanges.hasScreenSize = sFlagCheckUtil.hasFlag(activity, activityInfo.configChanges, ActivityInfo.CONFIG_SCREEN_SIZE);
-        }
+        activityConfigChanges.hasScreenSize = sFlagCheckUtil.hasFlag(activity, activityInfo.configChanges, ActivityInfo.CONFIG_SCREEN_SIZE);
 
         return activityConfigChanges;
     }
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/ResponseHeader.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/ResponseHeader.java
index 002c36b2..d8aded62 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/ResponseHeader.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/ResponseHeader.java
@@ -33,10 +33,16 @@
     IMPRESSION_VISIBLE_MS("X-Impression-Visible-Ms"),
     MAX_BUFFER_MS("X-Max-Buffer-Ms"),
 
-    // Rewarded Video fields
+    // Rewarded Ad fields
     REWARDED_VIDEO_CURRENCY_NAME("X-Rewarded-Video-Currency-Name"),
     REWARDED_VIDEO_CURRENCY_AMOUNT("X-Rewarded-Video-Currency-Amount"),
+    REWARDED_CURRENCIES("X-Rewarded-Currencies"),
     REWARDED_VIDEO_COMPLETION_URL("X-Rewarded-Video-Completion-Url"),
+    REWARDED_DURATION("X-Rewarded-Duration"),
+    SHOULD_REWARD_ON_CLICK("X-Should-Reward-On-Click"),
+
+    // Internal Video Trackers
+    VIDEO_TRACKERS("X-Video-Trackers"),
 
     @Deprecated CUSTOM_SELECTOR("X-Customselector");
 
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/VersionCode.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/VersionCode.java
deleted file mode 100644
index fee8713e..00000000
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/common/util/VersionCode.java
+++ /dev/null
@@ -1,61 +0,0 @@
-package com.mopub.common.util;
-
-import android.os.Build;
-
-public enum VersionCode {
-    BASE(1),
-    BASE_1_1(2),
-    CUPCAKE(3),
-    DONUT(4),
-    ECLAIR(5),
-    ECLAIR_0_1(6),
-    ECLAIR_MR1(7),
-    FROYO(8),
-    GINGERBREAD(9),
-    GINGERBREAD_MR1(10),
-    HONEYCOMB(11),
-    HONEYCOMB_MR1(12),
-    HONEYCOMB_MR2(13),
-    ICE_CREAM_SANDWICH(14),
-    ICE_CREAM_SANDWICH_MR1(15),
-    JELLY_BEAN(16),
-    JELLY_BEAN_MR1(17),
-    JELLY_BEAN_MR2(18),
-    KITKAT(19),
-    CUR_DEVELOPMENT(10000);
-
-    private int mApiLevel;
-
-    public static VersionCode currentApiLevel() {
-        return forApiLevel(Build.VERSION.SDK_INT);
-    }
-
-    private static VersionCode forApiLevel(int targetApiLevel) {
-        for (VersionCode versionCode : VersionCode.values()) {
-            if (versionCode.getApiLevel() == targetApiLevel) {
-                return versionCode;
-            }
-        }
-        return CUR_DEVELOPMENT;
-    }
-
-    VersionCode(int apiLevel) {
-        this.mApiLevel = apiLevel;
-    }
-
-    public int getApiLevel() {
-        return mApiLevel;
-    }
-
-    public boolean isAtMost(VersionCode that) {
-        return this.getApiLevel() <= that.getApiLevel();
-    }
-
-    public boolean isAtLeast(VersionCode that) {
-        return this.getApiLevel() >= that.getApiLevel();
-    }
-
-    public boolean isBelow(VersionCode that) {
-        return this.getApiLevel() < that.getApiLevel();
-    }
-}
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/AdTypeTranslator.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/AdTypeTranslator.java
index 7cdeb29e..8a827f7b 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/AdTypeTranslator.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/AdTypeTranslator.java
@@ -28,6 +28,7 @@
         MOPUB_NATIVE("mopub_native", "com.mopub.nativeads.MoPubCustomEventNative"),
         MOPUB_VIDEO_NATIVE("mopub_video_native", "com.mopub.nativeads.MoPubCustomEventVideoNative"),
         MOPUB_REWARDED_VIDEO("rewarded_video", "com.mopub.mobileads.MoPubRewardedVideo"),
+        MOPUB_REWARDED_PLAYABLE("rewarded_playable", "com.mopub.mobileads.MoPubRewardedPlayable"),
 
         UNSPECIFIED("", null);
 
@@ -75,6 +76,8 @@ public static String getCustomEventName(@NonNull AdFormat adFormat,
             return CustomEventType.MOPUB_VIDEO_NATIVE.toString();
         } else if (AdType.REWARDED_VIDEO.equalsIgnoreCase(adType)) {
             return CustomEventType.MOPUB_REWARDED_VIDEO.toString();
+        } else if (AdType.REWARDED_PLAYABLE.equalsIgnoreCase(adType)) {
+            return CustomEventType.MOPUB_REWARDED_PLAYABLE.toString();
         } else if (AdType.HTML.equalsIgnoreCase(adType) || AdType.MRAID.equalsIgnoreCase(adType)) {
             return (AdFormat.INTERSTITIAL.equals(adFormat)
                     ? CustomEventType.fromString(adType + INTERSTITIAL_SUFFIX)
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/AdViewController.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/AdViewController.java
index d1c22872..8861e88f 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/AdViewController.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/AdViewController.java
@@ -78,8 +78,20 @@
     int mBackoffPower = 1;
 
     private Map<String, Object> mLocalExtras = new HashMap<String, Object>();
-    private boolean mAutoRefreshEnabled = true;
-    private boolean mPreviousAutoRefreshSetting = true;
+
+    /**
+     * This is the current auto refresh status. If this is true, then ads will attempt to refresh.
+     * If mRefreshTimeMillis is null or not greater than 0, the auto refresh runnable will not
+     * be called.
+     */
+    private boolean mCurrentAutoRefreshStatus = true;
+
+    /**
+     * This is the publisher-specified auto refresh flag. AdViewController will only attempt to
+     * refresh ads when this is true. Setting this to false will block refreshing.
+     */
+    private boolean mShouldAllowAutoRefresh = true;
+
     private String mKeywords;
     private Location mLocation;
     private boolean mIsTesting;
@@ -353,35 +365,45 @@ public int getAdHeight() {
         return 0;
     }
 
+    /**
+     * This has been renamed to {@link #getCurrentAutoRefreshStatus()}.
+     */
+    @Deprecated
     public boolean getAutorefreshEnabled() {
-        return mAutoRefreshEnabled;
+        return getCurrentAutoRefreshStatus();
+    }
+
+    public boolean getCurrentAutoRefreshStatus() {
+        return mCurrentAutoRefreshStatus;
     }
 
     void pauseRefresh() {
-        mPreviousAutoRefreshSetting = mAutoRefreshEnabled;
-        setAutorefreshEnabled(false);
+        setAutoRefreshStatus(false);
     }
 
-    void unpauseRefresh() {
-        setAutorefreshEnabled(mPreviousAutoRefreshSetting);
+    void resumeRefresh() {
+        if (mShouldAllowAutoRefresh) {
+            setAutoRefreshStatus(true);
+        }
     }
 
-    void forceSetAutorefreshEnabled(boolean enabled) {
-        mPreviousAutoRefreshSetting = enabled;
-        setAutorefreshEnabled(enabled);
+    void setShouldAllowAutoRefresh(final boolean shouldAllowAutoRefresh) {
+        mShouldAllowAutoRefresh = shouldAllowAutoRefresh;
+        setAutoRefreshStatus(shouldAllowAutoRefresh);
     }
 
-    private void setAutorefreshEnabled(boolean enabled) {
-        final boolean autorefreshChanged = mAdWasLoaded && (mAutoRefreshEnabled != enabled);
-        if (autorefreshChanged) {
-            final String enabledString = (enabled) ? "enabled" : "disabled";
+    private void setAutoRefreshStatus(final boolean newAutoRefreshStatus) {
+        final boolean autoRefreshStatusChanged = mAdWasLoaded &&
+                (mCurrentAutoRefreshStatus != newAutoRefreshStatus);
+        if (autoRefreshStatusChanged) {
+            final String enabledString = (newAutoRefreshStatus) ? "enabled" : "disabled";
             MoPubLog.d("Refresh " + enabledString + " for ad unit (" + mAdUnitId + ").");
         }
 
-        mAutoRefreshEnabled = enabled;
-        if (mAdWasLoaded && mAutoRefreshEnabled) {
+        mCurrentAutoRefreshStatus = newAutoRefreshStatus;
+        if (mAdWasLoaded && mCurrentAutoRefreshStatus) {
             scheduleRefreshTimerIfEnabled();
-        } else if (!mAutoRefreshEnabled) {
+        } else if (!mCurrentAutoRefreshStatus) {
             cancelRefreshTimer();
         }
     }
@@ -419,7 +441,7 @@ void cleanup() {
             mActiveRequest = null;
         }
 
-        setAutorefreshEnabled(false);
+        setAutoRefreshStatus(false);
         cancelRefreshTimer();
 
         // WebView subclasses are not garbage-collected in a timely fashion on Froyo and below,
@@ -500,7 +522,7 @@ void adDidFail(MoPubErrorCode errorCode) {
 
     void scheduleRefreshTimerIfEnabled() {
         cancelRefreshTimer();
-        if (mAutoRefreshEnabled && mRefreshTimeMillis != null && mRefreshTimeMillis > 0) {
+        if (mCurrentAutoRefreshStatus && mRefreshTimeMillis != null && mRefreshTimeMillis > 0) {
 
             mHandler.postDelayed(mRefreshRunnable,
                     Math.min(MAX_REFRESH_TIME_MILLISECONDS,
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/BaseBroadcastReceiver.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/BaseBroadcastReceiver.java
index 9b2e04e4..9f6b7f32 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/BaseBroadcastReceiver.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/BaseBroadcastReceiver.java
@@ -19,7 +19,7 @@ public BaseBroadcastReceiver(final long broadcastIdentifier) {
         mBroadcastIdentifier = broadcastIdentifier;
     }
 
-    static void broadcastAction(@NonNull final Context context, final long broadcastIdentifier,
+    public static void broadcastAction(@NonNull final Context context, final long broadcastIdentifier,
             @NonNull final String action) {
         Preconditions.checkNotNull(context, "context cannot be null");
         Preconditions.checkNotNull(action, "action cannot be null");
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/BaseHtmlWebView.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/BaseHtmlWebView.java
index 0710d7dc..b37c8dec 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/BaseHtmlWebView.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/BaseHtmlWebView.java
@@ -10,8 +10,6 @@
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.network.Networking;
 
-import static com.mopub.common.util.VersionCode.ICE_CREAM_SANDWICH;
-import static com.mopub.common.util.VersionCode.currentApiLevel;
 import static com.mopub.mobileads.ViewGestureDetector.UserClickListener;
 
 public class BaseHtmlWebView extends BaseWebView implements UserClickListener {
@@ -27,9 +25,7 @@ public BaseHtmlWebView(Context context, AdReport adReport) {
         mViewGestureDetector = new ViewGestureDetector(context, this, adReport);
         mViewGestureDetector.setUserClickListener(this);
 
-        if (currentApiLevel().isAtLeast(ICE_CREAM_SANDWICH)) {
-            enablePlugins(true);
-        }
+        enablePlugins(true);
         setBackgroundColor(Color.TRANSPARENT);
     }
 
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/BaseWebView.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/BaseWebView.java
index 84d1e820..9837e067 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/BaseWebView.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/BaseWebView.java
@@ -13,7 +13,6 @@
 import android.webkit.WebView;
 
 import com.mopub.common.VisibleForTesting;
-import com.mopub.common.util.VersionCode;
 import com.mopub.common.util.Views;
 import com.mopub.mobileads.util.WebViews;
 
@@ -54,7 +53,7 @@ public void destroy() {
 
     protected void enablePlugins(final boolean enabled) {
         // Android 4.3 and above has no concept of plugin states
-        if (VersionCode.currentApiLevel().isAtLeast(VersionCode.JELLY_BEAN_MR2)) {
+        if (VERSION.SDK_INT >= VERSION_CODES.JELLY_BEAN_MR2) {
             return;
         }
 
@@ -84,15 +83,9 @@ protected void enableJavascriptCaching() {
      */
     private void restrictDeviceContentAccess() {
         getSettings().setAllowFileAccess(false);
-
-        if (VERSION.SDK_INT >= VERSION_CODES.HONEYCOMB) {
-            getSettings().setAllowContentAccess(false);
-        }
-
-        if (VERSION.SDK_INT >= VERSION_CODES.JELLY_BEAN) {
-            getSettings().setAllowFileAccessFromFileURLs(false);
-            getSettings().setAllowUniversalAccessFromFileURLs(false);
-        }
+        getSettings().setAllowContentAccess(false);
+        getSettings().setAllowFileAccessFromFileURLs(false);
+        getSettings().setAllowUniversalAccessFromFileURLs(false);
     }
 
     /**
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/MoPubErrorCode.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/MoPubErrorCode.java
index 656f3676..6ba5602f 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/MoPubErrorCode.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/MoPubErrorCode.java
@@ -21,6 +21,9 @@
     VIDEO_NOT_AVAILABLE("No video loaded for ad unit."),
     VIDEO_PLAYBACK_ERROR("Error playing a video."),
 
+    REWARDED_CURRENCIES_PARSING_ERROR("Error parsing rewarded currencies JSON header."),
+    REWARD_NOT_SELECTED("Reward not selected for rewarded ad."),
+
     UNSPECIFIED("Unspecified error.");
 
     private final String message;
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/MoPubView.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/MoPubView.java
index e93fd3e2..d82725c0 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/MoPubView.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/MoPubView.java
@@ -10,7 +10,6 @@
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
 import android.util.AttributeSet;
-import android.util.Log;
 import android.view.View;
 import android.webkit.WebViewDatabase;
 import android.widget.FrameLayout;
@@ -32,149 +31,144 @@
 import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
 
 public class MoPubView extends FrameLayout {
-	public interface BannerAdListener {
-		public void onBannerLoadStarted(MoPubView banner);
-		
-		public void onBannerLoaded(MoPubView banner);
-		
-		public void onBannerNetworkFailed(MoPubView banner);
-		
-		public void onBannerNetworkTimed(MoPubView banner);
-		
-		public void onBannerFailed(MoPubView banner, MoPubErrorCode errorCode);
-		
-		public void onBannerClicked(MoPubView banner);
-		
-		public void onBannerExpanded(MoPubView banner);
-		
-		public void onBannerCollapsed(MoPubView banner);
-	}
-	
-	private final String CUSTOM_EVENT_BANNER_ADAPTER_FACTORY =
-			"com.mopub.mobileads.factories.CustomEventBannerAdapterFactory";
-	
-	@Nullable
-	protected AdViewController mAdViewController;
-	// mCustomEventBannerAdapter must be a CustomEventBannerAdapter
-	protected Object mCustomEventBannerAdapter;
-	
-	private Context mContext;
-	private int mScreenVisibility;
-	private BroadcastReceiver mScreenStateReceiver;
-	
-	private BannerAdListener mBannerAdListener;
+    public interface BannerAdListener {
+	    public void onBannerLoadStarted(MoPubView banner);
+	    public void onBannerLoaded(MoPubView banner);
+	    public void onBannerNetworkFailed(MoPubView banner);
+	    public void onBannerNetworkTimed(MoPubView banner);
+	    public void onBannerFailed(MoPubView banner, MoPubErrorCode errorCode);
+	    public void onBannerClicked(MoPubView banner);
+	    public void onBannerExpanded(MoPubView banner);
+	    public void onBannerCollapsed(MoPubView banner);
+    }
+
+    private static final String CUSTOM_EVENT_BANNER_ADAPTER_FACTORY =
+            "com.mopub.mobileads.factories.CustomEventBannerAdapterFactory";
+
+    @Nullable
+    protected AdViewController mAdViewController;
+    // mCustomEventBannerAdapter must be a CustomEventBannerAdapter
+    protected Object mCustomEventBannerAdapter;
+
+    private Context mContext;
+    private int mScreenVisibility;
+    private BroadcastReceiver mScreenStateReceiver;
+
+    private BannerAdListener mBannerAdListener;
 	
 	private Set<String> bannedAdapters;
-	
 	private boolean resumed;
 	
-	public MoPubView(Context context) {
-		this(context, null);
-	}
-	
-	public MoPubView(Context context, AttributeSet attrs) {
-		super(context, attrs);
-		
-		ManifestUtils.checkWebViewActivitiesDeclared(context);
-		
-		mContext = context;
-		mScreenVisibility = getVisibility();
-		
-		bannedAdapters = new HashSet<>();
-		
-		setHorizontalScrollBarEnabled(false);
-		setVerticalScrollBarEnabled(false);
-		
-		// There is a rare bug in Froyo/2.2 where creation of a WebView causes a
-		// NullPointerException. (https://code.google.com/p/android/issues/detail?id=10789)
-		// It happens when the WebView can't access the local file store to make a cache file.
-		// Here, we'll work around it by trying to create a file store and then just go inert
-		// if it's not accessible.
-		try {
-			if (WebViewDatabase.getInstance(context) == null) {
-				MoPubLog.e("Disabling MoPub. Local cache file is inaccessible so MoPub will " +
-						"fail if we try to create a WebView. Details of this Android bug found at:" +
-						"https://code.google.com/p/android/issues/detail?id=10789");
-				return;
-			}
-		} catch (Exception e) {
-			Log.d("Mopub", "Unable to access android.WebView");
-			return;
-		}
-		
-		mAdViewController = AdViewControllerFactory.create(context, this);
-		registerScreenStateBroadcastReceiver();
-	}
-	
-	private void registerScreenStateBroadcastReceiver() {
-		mScreenStateReceiver = new BroadcastReceiver() {
-			public void onReceive(final Context context, final Intent intent) {
-				if (!Visibility.isScreenVisible(mScreenVisibility) || intent == null) {
-					return;
-				}
-				
-				final String action = intent.getAction();
-				
-				if (Intent.ACTION_USER_PRESENT.equals(action)) {
-					setAdVisibility(View.VISIBLE);
-				} else if (Intent.ACTION_SCREEN_OFF.equals(action)) {
-					setAdVisibility(View.GONE);
-				}
-			}
-		};
-		
-		final IntentFilter filter = new IntentFilter(Intent.ACTION_SCREEN_OFF);
-		filter.addAction(Intent.ACTION_USER_PRESENT);
-		mContext.registerReceiver(mScreenStateReceiver, filter);
-	}
-	
-	private void unregisterScreenStateBroadcastReceiver() {
-		try {
-			mContext.unregisterReceiver(mScreenStateReceiver);
-		} catch (Exception IllegalArgumentException) {
-			MoPubLog.d("Failed to unregister screen state broadcast receiver (never registered).");
-		}
-	}
 	
-	public void loadAd() {
-		if (!resumed){
-			return;
-		}
-		if (mAdViewController != null) {
-			mAdViewController.loadAd();
-		}
-	}
-	
-	/*
-	 * Tears down the ad view: no ads will be shown once this method executes. The parent
-	 * Activity's onDestroy implementation must include a call to this method.
-	 */
-	public void destroy() {
-		unregisterScreenStateBroadcastReceiver();
-		removeAllViews();
-		
-		if (mAdViewController != null) {
-			mAdViewController.cleanup();
-			mAdViewController = null;
-		}
-		
-		if (mCustomEventBannerAdapter != null) {
-			invalidateAdapter();
-			mCustomEventBannerAdapter = null;
-		}
-	}
-	
-	private void invalidateAdapter() {
-		if (mCustomEventBannerAdapter != null) {
-			try {
-				new Reflection.MethodBuilder(mCustomEventBannerAdapter, "invalidate")
-						.setAccessible()
-						.execute();
-			} catch (Exception e) {
-				MoPubLog.e("Error invalidating adapter", e);
-			}
-		}
-	}
+	public MoPubView(Context context) {
+        this(context, null);
+    }
+
+    public MoPubView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+
+        ManifestUtils.checkWebViewActivitiesDeclared(context);
+
+        mContext = context;
+        mScreenVisibility = getVisibility();
+	    bannedAdapters = new HashSet<>();
+
+        setHorizontalScrollBarEnabled(false);
+        setVerticalScrollBarEnabled(false);
+
+        try {
+            // There is a rare bug in Froyo/2.2 where creation of a WebView causes a
+            // NullPointerException. (https://code.google.com/p/android/issues/detail?id=10789)
+            // It happens when the WebView can't access the local file store to make a cache file.
+            // Here, we'll work around it by trying to create a file store and then just go inert
+            // if it's not accessible.
+            if (WebViewDatabase.getInstance(context) == null) {
+                MoPubLog.e("Disabling MoPub. Local cache file is inaccessible so MoPub will " +
+                        "fail if we try to create a WebView. Details of this Android bug found at:" +
+                        "https://code.google.com/p/android/issues/detail?id=10789");
+                return;
+            }
+        } catch (Exception e) {
+            // If anything goes wrong here, it's most likely due to not having a WebView at all.
+            // This happens when Android updates WebView.
+            MoPubLog.e("Disabling MoPub due to no WebView, or it's being updated", e);
+            return;
+        }
+
+        mAdViewController = AdViewControllerFactory.create(context, this);
+        registerScreenStateBroadcastReceiver();
+    }
+
+    private void registerScreenStateBroadcastReceiver() {
+        mScreenStateReceiver = new BroadcastReceiver() {
+            public void onReceive(final Context context, final Intent intent) {
+                if (!Visibility.isScreenVisible(mScreenVisibility) || intent == null) {
+                    return;
+                }
+
+                final String action = intent.getAction();
+
+                if (Intent.ACTION_USER_PRESENT.equals(action)) {
+                    setAdVisibility(View.VISIBLE);
+                } else if (Intent.ACTION_SCREEN_OFF.equals(action)) {
+                    setAdVisibility(View.GONE);
+                }
+            }
+        };
+
+        final IntentFilter filter = new IntentFilter(Intent.ACTION_SCREEN_OFF);
+        filter.addAction(Intent.ACTION_USER_PRESENT);
+        mContext.registerReceiver(mScreenStateReceiver, filter);
+    }
+
+    private void unregisterScreenStateBroadcastReceiver() {
+        try {
+            mContext.unregisterReceiver(mScreenStateReceiver);
+        } catch (Exception IllegalArgumentException) {
+            MoPubLog.d("Failed to unregister screen state broadcast receiver (never registered).");
+        }
+    }
+
+    public void loadAd() {
+	    if (!resumed){
+		    return;
+	    }
+	
+	    if (mAdViewController != null) {
+            mAdViewController.loadAd();
+        }
+    }
+
+    /*
+     * Tears down the ad view: no ads will be shown once this method executes. The parent
+     * Activity's onDestroy implementation must include a call to this method.
+     */
+    public void destroy() {
+        unregisterScreenStateBroadcastReceiver();
+        removeAllViews();
+
+        if (mAdViewController != null) {
+            mAdViewController.cleanup();
+            mAdViewController = null;
+        }
+
+        if (mCustomEventBannerAdapter != null) {
+            invalidateAdapter();
+            mCustomEventBannerAdapter = null;
+        }
+    }
+
+    private void invalidateAdapter() {
+        if (mCustomEventBannerAdapter != null) {
+            try {
+                new Reflection.MethodBuilder(mCustomEventBannerAdapter, "invalidate")
+                        .setAccessible()
+                        .execute();
+            } catch (Exception e) {
+                MoPubLog.e("Error invalidating adapter", e);
+            }
+        }
+    }
 	
 	public void stopAdapter() {
 		if (mCustomEventBannerAdapter != null) {
@@ -211,98 +205,99 @@ private void resumeAdapter() {
 			}
 		}
 	}
-	
-	Integer getAdTimeoutDelay() {
-		return (mAdViewController != null) ? mAdViewController.getAdTimeoutDelay() : null;
-	}
-	
-	protected boolean loadFailUrl(@NonNull final MoPubErrorCode errorCode) {
-		if (mAdViewController == null) {
-			return false;
-		}
-		return mAdViewController.loadFailUrl(errorCode);
-	}
-	
-	protected void loadCustomEvent(String customEventClassName, Map<String, String> serverExtras) {
-		if (mAdViewController == null) {
-			return;
-		}
-		
-		if (mBannerAdListener != null) {
-			mBannerAdListener.onBannerLoadStarted(this);
-		}
-		
-		if (TextUtils.isEmpty(customEventClassName)) {
-			MoPubLog.d("Couldn't invoke custom event because the server did not specify one.");
-			loadFailUrl(ADAPTER_NOT_FOUND);
-			return;
-		}
-		
-		if (bannedAdapters.contains(customEventClassName)) {
-			MoPubLog.d("Native Network or Custom Event adapter was banned.");
-			loadFailUrl(MoPubErrorCode.ADAPTER_BANNED);
-			return;
-		}
-		
-		if (mCustomEventBannerAdapter != null) {
-			invalidateAdapter();
-		}
-		
-		MoPubLog.d("Loading custom event adapter.");
-		
-		if (Reflection.classFound(CUSTOM_EVENT_BANNER_ADAPTER_FACTORY)) {
-			try {
-				final Class<?> adapterFactoryClass = Class.forName(CUSTOM_EVENT_BANNER_ADAPTER_FACTORY);
-				mCustomEventBannerAdapter = new Reflection.MethodBuilder(null, "create")
-						.setStatic(adapterFactoryClass)
-						.addParam(MoPubView.class, this)
-						.addParam(String.class, customEventClassName)
-						.addParam(Map.class, serverExtras)
-						.addParam(long.class, mAdViewController.getBroadcastIdentifier())
-						.addParam(AdReport.class, mAdViewController.getAdReport())
-						.execute();
-				new Reflection.MethodBuilder(mCustomEventBannerAdapter, "loadAd")
-						.setAccessible()
-						.execute();
-			} catch (Exception e) {
-				MoPubLog.e("Error loading custom event", e);
-			}
-		} else {
-			MoPubLog.e("Could not load custom event -- missing banner module");
-		}
-		
-	}
-	
-	protected void registerClick() {
-		if (mAdViewController != null) {
-			mAdViewController.registerClick();
-			
-			// Let any listeners know that an ad was clicked
-			adClicked();
-		}
-	}
-	
-	protected void trackNativeImpression() {
-		MoPubLog.d("Tracking impression for native adapter.");
-		if (mAdViewController != null) {
-			mAdViewController.trackImpression();
-		}
-	}
-	
-	@Override
-	protected void onWindowVisibilityChanged(final int visibility) {
-		// Ignore transitions between View.GONE and View.INVISIBLE
-		if (Visibility.hasScreenVisibilityChanged(mScreenVisibility, visibility)) {
-			mScreenVisibility = visibility;
-			setAdVisibility(mScreenVisibility);
-		}
-	}
+
+    Integer getAdTimeoutDelay() {
+        return (mAdViewController != null) ? mAdViewController.getAdTimeoutDelay() : null;
+    }
+
+    protected boolean loadFailUrl(@NonNull final MoPubErrorCode errorCode) {
+        if (mAdViewController == null) {
+            return false;
+        }
+        return mAdViewController.loadFailUrl(errorCode);
+    }
+
+    protected void loadCustomEvent(String customEventClassName, Map<String, String> serverExtras) {
+        if (mAdViewController == null) {
+            return;
+        }
+	
+	    if (mBannerAdListener != null){
+		    mBannerAdListener.onBannerLoadStarted(this);
+	    }
+	
+	
+	    if (TextUtils.isEmpty(customEventClassName)) {
+            MoPubLog.d("Couldn't invoke custom event because the server did not specify one.");
+            loadFailUrl(ADAPTER_NOT_FOUND);
+            return;
+        }
+	
+	    if (bannedAdapters.contains(customEventClassName)) {
+		    MoPubLog.d("Native Network or Custom Event adapter was banned.");
+		    loadFailUrl(MoPubErrorCode.ADAPTER_BANNED);
+		    return;
+	    }
+
+        if (mCustomEventBannerAdapter != null) {
+            invalidateAdapter();
+        }
+
+        MoPubLog.d("Loading custom event adapter.");
+
+        if (Reflection.classFound(CUSTOM_EVENT_BANNER_ADAPTER_FACTORY)) {
+            try {
+                final Class<?> adapterFactoryClass = Class.forName(CUSTOM_EVENT_BANNER_ADAPTER_FACTORY);
+                mCustomEventBannerAdapter = new Reflection.MethodBuilder(null, "create")
+                        .setStatic(adapterFactoryClass)
+                        .addParam(MoPubView.class, this)
+                        .addParam(String.class, customEventClassName)
+                        .addParam(Map.class, serverExtras)
+                        .addParam(long.class, mAdViewController.getBroadcastIdentifier())
+                        .addParam(AdReport.class, mAdViewController.getAdReport())
+                        .execute();
+                new Reflection.MethodBuilder(mCustomEventBannerAdapter, "loadAd")
+                        .setAccessible()
+                        .execute();
+            } catch (Exception e) {
+                MoPubLog.e("Error loading custom event", e);
+            }
+        } else {
+            MoPubLog.e("Could not load custom event -- missing banner module");
+        }
+    }
+
+    protected void registerClick() {
+        if (mAdViewController != null) {
+            mAdViewController.registerClick();
+
+            // Let any listeners know that an ad was clicked
+            adClicked();
+        }
+    }
+
+    protected void trackNativeImpression() {
+        MoPubLog.d("Tracking impression for native adapter.");
+        if (mAdViewController != null) mAdViewController.trackImpression();
+    }
+
+    @Override
+    protected void onWindowVisibilityChanged(final int visibility) {
+        // Ignore transitions between View.GONE and View.INVISIBLE
+        if (Visibility.hasScreenVisibilityChanged(mScreenVisibility, visibility)) {
+            mScreenVisibility = visibility;
+            setAdVisibility(mScreenVisibility);
+        }
+    }
 	
 	@Override
 	protected void onVisibilityChanged(@NonNull View changedView, int visibility) {
 		super.onVisibilityChanged(changedView, visibility);
 		if (changedView == this) {
-			setAdVisibility(visibility);
+			if (Visibility.hasScreenVisibilityChanged(mScreenVisibility, visibility)) {
+				mScreenVisibility = visibility;
+				setAdVisibility(mScreenVisibility);
+			}
 		}
 	}
 	
@@ -313,7 +308,7 @@ private void setAdVisibility(final int visibility) {
 		
 		if (Visibility.isScreenVisible(visibility)) {
 			if (resumed) {
-				mAdViewController.unpauseRefresh();
+				mAdViewController.resumeRefresh();
 				resumeAdapter();
 			}
 		} else {
@@ -322,11 +317,12 @@ private void setAdVisibility(final int visibility) {
 		}
 	}
 	
+	
 	public void resume() {
 		if (!resumed) {
 			resumed = true;
 			if (mAdViewController != null) {
-				mAdViewController.unpauseRefresh();
+				mAdViewController.resumeRefresh();
 				resumeAdapter();
 				loadAd();
 			}
@@ -343,13 +339,14 @@ public void pause() {
 		}
 	}
 	
+	
 	protected void adLoaded() {
-		MoPubLog.d("adLoaded");
-		
-		if (mBannerAdListener != null) {
-			mBannerAdListener.onBannerLoaded(this);
-		}
-	}
+        MoPubLog.d("adLoaded");
+
+        if (mBannerAdListener != null) {
+            mBannerAdListener.onBannerLoaded(this);
+        }
+    }
 	
 	protected void adNetworkFailed() {
 		if (mBannerAdListener != null) {
@@ -368,170 +365,137 @@ public void adNetworkTimed() {
 			mBannerAdListener.onBannerNetworkTimed(this);
 		}
 	}
-	
-	protected void adPresentedOverlay() {
-		if (mBannerAdListener != null) {
-			mBannerAdListener.onBannerExpanded(this);
-		}
-	}
-	
-	protected void adClosed() {
-		if (mBannerAdListener != null) {
-			mBannerAdListener.onBannerCollapsed(this);
-		}
-	}
-	
-	protected void adClicked() {
-		if (mBannerAdListener != null) {
-			mBannerAdListener.onBannerClicked(this);
-		}
-	}
-	
-	protected void nativeAdLoaded() {
-		if (mAdViewController != null) {
-			mAdViewController.scheduleRefreshTimerIfEnabled();
-		}
-		adLoaded();
-	}
-	
-	////////////////////////////////////////////////////////////////////////////////////////////////
-	
-	public void setAdUnitId(String adUnitId) {
-		if (mAdViewController != null) {
-			mAdViewController.setAdUnitId(adUnitId);
-		}
-	}
-	
-	public String getAdUnitId() {
-		return (mAdViewController != null) ? mAdViewController.getAdUnitId() : null;
-	}
-	
-	public void setKeywords(String keywords) {
-		if (mAdViewController != null) {
-			mAdViewController.setKeywords(keywords);
-		}
-	}
-	
-	public String getKeywords() {
-		return (mAdViewController != null) ? mAdViewController.getKeywords() : null;
-	}
-	
-	public void setLocation(Location location) {
-		if (mAdViewController != null) {
-			mAdViewController.setLocation(location);
-		}
-	}
-	
-	public Location getLocation() {
-		return (mAdViewController != null) ? mAdViewController.getLocation() : null;
-	}
-	
-	public int getAdWidth() {
-		return (mAdViewController != null) ? mAdViewController.getAdWidth() : 0;
-	}
-	
-	public int getAdHeight() {
-		return (mAdViewController != null) ? mAdViewController.getAdHeight() : 0;
-	}
-	
-	public Activity getActivity() {
-		return (Activity) mContext;
-	}
-	
-	public void setBannerAdListener(BannerAdListener listener) {
-		mBannerAdListener = listener;
-	}
-	
-	public BannerAdListener getBannerAdListener() {
-		return mBannerAdListener;
-	}
-	
-	public void setLocalExtras(Map<String, Object> localExtras) {
-		if (mAdViewController != null) {
-			mAdViewController.setLocalExtras(localExtras);
-		}
-	}
-	
-	public Map<String, Object> getLocalExtras() {
-		if (mAdViewController != null) {
-			return mAdViewController.getLocalExtras();
-		}
-		return new TreeMap<String, Object>();
-	}
-	
-	public void setAutorefreshEnabled(boolean enabled) {
-		if (mAdViewController != null) {
-			mAdViewController.forceSetAutorefreshEnabled(enabled);
-		}
-	}
-	
-	public boolean getAutorefreshEnabled() {
-		if (mAdViewController != null) {
-			return mAdViewController.getAutorefreshEnabled();
-		} else {
-			MoPubLog.d("Can't get autorefresh status for destroyed MoPubView. " +
-					"Returning false.");
-			return false;
-		}
-	}
-	
-	public void setAdContentView(View view) {
-		if (mAdViewController != null) {
-			mAdViewController.setAdContentView(view);
-		}
-	}
-	
-	public void setTesting(boolean testing) {
-		if (mAdViewController != null) {
-			mAdViewController.setTesting(testing);
-		}
-	}
-	
-	public boolean getTesting() {
-		if (mAdViewController != null) {
-			return mAdViewController.getTesting();
-		} else {
-			MoPubLog.d("Can't get testing status for destroyed MoPubView. " +
-					"Returning false.");
-			return false;
-		}
-	}
-	
-	public void forceRefresh() {
-		if (mCustomEventBannerAdapter != null) {
-			invalidateAdapter();
-			mCustomEventBannerAdapter = null;
-		}
-		
-		if (mAdViewController != null) {
-			mAdViewController.forceRefresh();
-		}
-	}
-	
-	public AdViewController getAdViewController() {
-		return mAdViewController;
-	}
-	
-	public AdFormat getAdFormat() {
-		return AdFormat.BANNER;
-	}
-	
-	/**
-	 * @deprecated As of release 4.4.0
-	 */
-	@Deprecated
-	public void setTimeout(int milliseconds) {
-	}
-	
-	@Deprecated
-	public String getResponseString() {
-		return null;
-	}
-	
-	@Deprecated
-	public String getClickTrackingUrl() {
-		return null;
-	}
+
+    protected void adPresentedOverlay() {
+        if (mBannerAdListener != null) {
+            mBannerAdListener.onBannerExpanded(this);
+        }
+    }
+
+    protected void adClosed() {
+        if (mBannerAdListener != null) {
+            mBannerAdListener.onBannerCollapsed(this);
+        }
+    }
+
+    protected void adClicked() {
+        if (mBannerAdListener != null) {
+            mBannerAdListener.onBannerClicked(this);
+        }
+    }
+
+    protected void nativeAdLoaded() {
+        if (mAdViewController != null) mAdViewController.scheduleRefreshTimerIfEnabled();
+        adLoaded();
+    }
+
+    ////////////////////////////////////////////////////////////////////////////////////////////////
+
+    public void setAdUnitId(String adUnitId) {
+        if (mAdViewController != null) mAdViewController.setAdUnitId(adUnitId);
+    }
+
+    public String getAdUnitId() {
+        return (mAdViewController != null) ? mAdViewController.getAdUnitId() : null;
+    }
+
+    public void setKeywords(String keywords) {
+        if (mAdViewController != null) mAdViewController.setKeywords(keywords);
+    }
+
+    public String getKeywords() {
+        return (mAdViewController != null) ? mAdViewController.getKeywords() : null;
+    }
+
+    public void setLocation(Location location) {
+        if (mAdViewController != null) mAdViewController.setLocation(location);
+    }
+
+    public Location getLocation() {
+        return (mAdViewController != null) ? mAdViewController.getLocation() : null;
+    }
+
+    public int getAdWidth() {
+        return (mAdViewController != null) ? mAdViewController.getAdWidth() : 0;
+    }
+
+    public int getAdHeight() {
+        return (mAdViewController != null) ? mAdViewController.getAdHeight() : 0;
+    }
+
+    public Activity getActivity() {
+        return (Activity) mContext;
+    }
+
+    public void setBannerAdListener(BannerAdListener listener) {
+        mBannerAdListener = listener;
+    }
+
+    public BannerAdListener getBannerAdListener() {
+        return mBannerAdListener;
+    }
+
+    public void setLocalExtras(Map<String, Object> localExtras) {
+        if (mAdViewController != null) mAdViewController.setLocalExtras(localExtras);
+    }
+
+    public Map<String, Object> getLocalExtras() {
+        if (mAdViewController != null) {
+            return mAdViewController.getLocalExtras();
+        }
+        return new TreeMap<String, Object>();
+    }
+
+    public void setAutorefreshEnabled(boolean enabled) {
+        if (mAdViewController != null) {
+            mAdViewController.setShouldAllowAutoRefresh(enabled);
+        }
+    }
+
+    public boolean getAutorefreshEnabled() {
+        if (mAdViewController != null) return mAdViewController.getCurrentAutoRefreshStatus();
+        else {
+            MoPubLog.d("Can't get autorefresh status for destroyed MoPubView. " +
+                    "Returning false.");
+            return false;
+        }
+    }
+
+    public void setAdContentView(View view) {
+        if (mAdViewController != null) mAdViewController.setAdContentView(view);
+    }
+
+    public void setTesting(boolean testing) {
+        if (mAdViewController != null) mAdViewController.setTesting(testing);
+    }
+
+    public boolean getTesting() {
+        if (mAdViewController != null) return mAdViewController.getTesting();
+        else {
+            MoPubLog.d("Can't get testing status for destroyed MoPubView. " +
+                    "Returning false.");
+            return false;
+        }
+    }
+
+    public void forceRefresh() {
+        if (mCustomEventBannerAdapter != null) {
+            invalidateAdapter();
+            mCustomEventBannerAdapter = null;
+        }
+
+        if (mAdViewController != null) {
+            mAdViewController.forceRefresh();
+        }
+    }
+
+    public AdViewController getAdViewController() {
+        return mAdViewController;
+    }
+
+    public AdFormat getAdFormat() {
+        return AdFormat.BANNER;
+    }
 	
 	public void banAdapter(String adapterClassName) {
 		bannedAdapters.add(adapterClassName);
@@ -551,5 +515,21 @@ public Context getTrackedContext() {
 		Context context = getContext();
 		return new TrackedContext(context);
 	}
-	
+
+    /**
+     * @deprecated As of release 4.4.0
+     */
+    @Deprecated
+    public void setTimeout(int milliseconds) {
+    }
+
+    @Deprecated
+    public String getResponseString() {
+        return null;
+    }
+
+    @Deprecated
+    public String getClickTrackingUrl() {
+        return null;
+    }
 }
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/RepeatingHandlerRunnable.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/RepeatingHandlerRunnable.java
index 05a8c05d..ee2512ba 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/RepeatingHandlerRunnable.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/RepeatingHandlerRunnable.java
@@ -50,8 +50,9 @@ public void stop() {
         mIsRunning = false;
     }
 
+    @Deprecated
     @VisibleForTesting
-    boolean shouldBeRunning() {
+    public boolean isRunning() {
         return mIsRunning;
     }
 }
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VastLinearXmlManager.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VastLinearXmlManager.java
index 78997180..ce6a4b9a 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VastLinearXmlManager.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VastLinearXmlManager.java
@@ -105,9 +105,12 @@
                 if (Strings.isPercentageTracker(offsetString)) {
                     String trackingUrl = XmlUtils.getNodeValue(progressNode);
                     try {
-                        float trackingFraction =
+                        final float trackingFraction =
                                 Float.parseFloat(offsetString.replace("%", "")) / 100f;
-                        percentTrackers.add(new VastFractionalProgressTracker(trackingUrl, trackingFraction));
+                        if (trackingFraction >= 0) {
+                            percentTrackers.add(new VastFractionalProgressTracker(trackingUrl,
+                                    trackingFraction));
+                        }
                     } catch (NumberFormatException e) {
                         MoPubLog.d(String.format("Failed to parse VAST progress tracker %s",
                                 offsetString));
@@ -164,7 +167,7 @@
                     String trackingUrl = XmlUtils.getNodeValue(progressNode);
                     try {
                         Integer trackingMilliseconds = Strings.parseAbsoluteOffset(offsetString);
-                        if (trackingMilliseconds != null) {
+                        if (trackingMilliseconds != null && trackingMilliseconds >= 0) {
                             trackers.add(new VastAbsoluteProgressTracker(trackingUrl, trackingMilliseconds));
                         }
                     } catch (NumberFormatException e) {
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VastVideoBlurLastVideoFrameTask.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VastVideoBlurLastVideoFrameTask.java
index d1075d47..dcbcbba9 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VastVideoBlurLastVideoFrameTask.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VastVideoBlurLastVideoFrameTask.java
@@ -38,38 +38,34 @@ public VastVideoBlurLastVideoFrameTask(
 
     @Override
     protected Boolean doInBackground(String... videoPaths) {
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD_MR1) {
-            if (videoPaths == null || videoPaths.length == 0 || videoPaths[0] == null) {
-                return false;
-            }
-
-            try {
-                final String videoPath = videoPaths[0];
-
-                mMediaMetadataRetriever.setDataSource(videoPath);
+        if (videoPaths == null || videoPaths.length == 0 || videoPaths[0] == null) {
+            return false;
+        }
 
-                // This actually gets a frame just before the video ends. If we try to get a frame
-                // that's actually past the end of the video or before 0, this will pick some
-                // arbitrary frame.
-                mLastVideoFrame = mMediaMetadataRetriever.getFrameAtTime(
-                        mVideoDuration * MICROSECONDS_PER_MILLISECOND - OFFSET_IN_MICROSECONDS,
-                        MediaMetadataRetriever.OPTION_CLOSEST);
+        try {
+            final String videoPath = videoPaths[0];
 
-                if (mLastVideoFrame == null) {
-                    return false;
-                }
+            mMediaMetadataRetriever.setDataSource(videoPath);
 
-                mBlurredLastVideoFrame = ImageUtils.applyFastGaussianBlurToBitmap(
-                        mLastVideoFrame, 4);
+            // This actually gets a frame just before the video ends. If we try to get a frame
+            // that's actually past the end of the video or before 0, this will pick some
+            // arbitrary frame.
+            mLastVideoFrame = mMediaMetadataRetriever.getFrameAtTime(
+                    mVideoDuration * MICROSECONDS_PER_MILLISECOND - OFFSET_IN_MICROSECONDS,
+                    MediaMetadataRetriever.OPTION_CLOSEST);
 
-                return true;
-            } catch (Exception e) {
-                MoPubLog.d("Failed to blur last video frame", e);
+            if (mLastVideoFrame == null) {
                 return false;
             }
-        }
 
-        return false;
+            mBlurredLastVideoFrame = ImageUtils.applyFastGaussianBlurToBitmap(
+                    mLastVideoFrame, 4);
+
+            return true;
+        } catch (Exception e) {
+            MoPubLog.d("Failed to blur last video frame", e);
+            return false;
+        }
     }
 
     @Override
@@ -81,8 +77,8 @@ protected void onPostExecute(final Boolean success) {
 
         if (success != null && success) {
             mBlurredLastVideoFrameImageView.setImageBitmap(mBlurredLastVideoFrame);
-            ImageUtils.setImageViewAlpha(mBlurredLastVideoFrameImageView,
-                    DrawableConstants.BlurredLastVideoFrame.ALPHA);
+            mBlurredLastVideoFrameImageView.setImageAlpha(DrawableConstants.BlurredLastVideoFrame
+                    .ALPHA);
         }
     }
 
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VastVideoConfig.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VastVideoConfig.java
index 9f53d535..e3012c70 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VastVideoConfig.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VastVideoConfig.java
@@ -10,6 +10,7 @@
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
 
+import com.mopub.common.Constants;
 import com.mopub.common.MoPubBrowser;
 import com.mopub.common.Preconditions;
 import com.mopub.common.UrlAction;
@@ -20,6 +21,9 @@
 import com.mopub.common.util.Strings;
 import com.mopub.exceptions.IntentNotResolvableException;
 
+import org.json.JSONArray;
+import org.json.JSONObject;
+
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -112,7 +116,7 @@ public void addFractionalTrackers(@NonNull final List<VastFractionalProgressTrac
     }
 
     /**
-     * Add trackers for absolute tracking. This includes start trackers, which have an absolute threshold of 2 seconds.
+     * Add trackers for absolute tracking.
      */
     public void addAbsoluteTrackers(@NonNull final List<VastAbsoluteProgressTracker> absoluteTrackers) {
         Preconditions.checkNotNull(absoluteTrackers, "absoluteTrackers cannot be null");
@@ -170,6 +174,73 @@ public void addErrorTrackers(@NonNull final List<VastTracker> errorTrackers) {
         mErrorTrackers.addAll(errorTrackers);
     }
 
+    /**
+     * Adds internal video trackers from a JSONObject in the form:
+     *      {
+     *          urls: [ "...%%VIDEO_EVENT%%...", ... ],
+     *          events: [ "companionAdView", ... ]
+     *      }
+     *
+     * Each event adds a corresponding tracker type with all the listed urls, with %%VIDEO_EVENT%%
+     * replaced with the event name. The currently supported trackers and their mappings are:
+     *      > start: addAbsoluteTrackers(url, 0)
+     *      > firstQuartile: addFractionalTrackers(url, 0.25f)
+     *      > midpoint: addFractionalTrackers(url, 0.5f)
+     *      > thirdQuartile: addFractionalTrackers(url, 0.75f)
+     *      > complete: addCompleteTrackers(url)
+     *      > companionAdView: VastCompanionAdConfig.addCreativeViewTrackers
+     *      > companionAdClick: VastCompanionAdConfig.addClickTrackers
+     *
+     * @param videoTrackers A JSONObject with the urls and events to track
+     */
+    public void addVideoTrackers(@Nullable final JSONObject videoTrackers) {
+        if (videoTrackers == null) {
+            return;
+        }
+
+        final JSONArray urls = videoTrackers.optJSONArray(Constants.VIDEO_TRACKING_URLS_KEY);
+        final JSONArray events = videoTrackers.optJSONArray(Constants.VIDEO_TRACKING_EVENTS_KEY);
+        if (urls == null || events == null) {
+            return;
+        }
+
+        for (int i = 0; i < events.length(); i++) { // JSONArray isn't Iterable -_-)
+            final String eventName = events.optString(i);
+            final List<String> urlsForEvent = hydrateUrls(eventName, urls);
+            final VideoTrackingEvent event = VideoTrackingEvent.fromString(eventName);
+            if (eventName == null || urlsForEvent == null) {
+                continue;
+            }
+
+            switch (event) {
+                case START:
+                    addStartTrackersForUrls(urlsForEvent);
+                    break;
+                case FIRST_QUARTILE:
+                    addFractionalTrackersForUrls(urlsForEvent, 0.25f);
+                    break;
+                case MIDPOINT:
+                    addFractionalTrackersForUrls(urlsForEvent, 0.5f);
+                    break;
+                case THIRD_QUARTILE:
+                    addFractionalTrackersForUrls(urlsForEvent, 0.75f);
+                    break;
+                case COMPLETE:
+                    addCompleteTrackersForUrls(urlsForEvent);
+                    break;
+                case COMPANION_AD_VIEW:
+                    addCompanionAdViewTrackersForUrls(urlsForEvent);
+                    break;
+                case COMPANION_AD_CLICK:
+                    addCompanionAdClickTrackersForUrls(urlsForEvent);
+                    break;
+                case UNKNOWN:
+                default:
+                    MoPubLog.d("Encountered unknown video tracking event: " + eventName);
+            }
+        }
+    }
+
     public void setClickThroughUrl(@Nullable final String clickThroughUrl) {
         mClickThroughUrl = clickThroughUrl;
     }
@@ -619,12 +690,13 @@ public void handleError(@NonNull Context context, @Nullable VastErrorCode errorC
      * @param videoLengthMillis the total video length.
      */
     @NonNull
-    public List<VastTracker> getUntriggeredTrackersBefore(int currentPositionMillis, int videoLengthMillis) {
-        if (Preconditions.NoThrow.checkArgument(videoLengthMillis > 0)) {
+    public List<VastTracker> getUntriggeredTrackersBefore(final int currentPositionMillis, final int videoLengthMillis) {
+        if (Preconditions.NoThrow.checkArgument(videoLengthMillis > 0) && currentPositionMillis >= 0) {
             float progressFraction = currentPositionMillis / (float) (videoLengthMillis);
             List<VastTracker> untriggeredTrackers = new ArrayList<VastTracker>();
 
-            VastAbsoluteProgressTracker absoluteTest = new VastAbsoluteProgressTracker("", currentPositionMillis);
+            VastAbsoluteProgressTracker absoluteTest = new VastAbsoluteProgressTracker("",
+                    currentPositionMillis);
             int absoluteTrackerCount = mAbsoluteTrackers.size();
             for (int i = 0; i < absoluteTrackerCount; i++) {
                 VastAbsoluteProgressTracker tracker = mAbsoluteTrackers.get(i);
@@ -699,4 +771,81 @@ public Integer getSkipOffsetMillis(final int videoDuration) {
         }
         return null;
     }
+
+    @Nullable
+    private List<String> hydrateUrls(@Nullable final String event, @NonNull final JSONArray urls) {
+        Preconditions.checkNotNull(urls);
+
+        if (event == null) {
+            return null;
+        }
+
+        final List<String> hydratedUrls = new ArrayList<String>();
+        for (int i = 0; i < urls.length(); i++) {
+            final String url = urls.optString(i);
+            if (url == null) {
+                continue;
+            }
+            hydratedUrls.add(url.replace(Constants.VIDEO_TRACKING_URL_MACRO, event));
+        }
+        return hydratedUrls;
+    }
+
+    private List<VastTracker> createVastTrackersForUrls(@NonNull final List<String> urls) {
+        Preconditions.checkNotNull(urls);
+
+        final List<VastTracker> trackers = new ArrayList<VastTracker>();
+        for (String url : urls) {
+            trackers.add(new VastTracker(url));
+        }
+        return trackers;
+    }
+
+    private void addCompleteTrackersForUrls(@NonNull final List<String> urls) {
+        Preconditions.checkNotNull(urls);
+
+        addCompleteTrackers(createVastTrackersForUrls(urls));
+    }
+
+    private void addStartTrackersForUrls(@NonNull final List<String> urls) {
+        Preconditions.checkNotNull(urls);
+
+        final List<VastAbsoluteProgressTracker> startTrackers = new ArrayList<VastAbsoluteProgressTracker>();
+        for (String url : urls) {
+            startTrackers.add(new VastAbsoluteProgressTracker(url, 0));
+        }
+        addAbsoluteTrackers(startTrackers);
+    }
+
+    private void addFractionalTrackersForUrls(@NonNull final List<String> urls,
+            final float fraction) {
+        Preconditions.checkNotNull(urls);
+
+        final List<VastFractionalProgressTracker> fractionalTrackers = new ArrayList<VastFractionalProgressTracker>();
+        for (String url : urls) {
+            fractionalTrackers.add(new VastFractionalProgressTracker(url, fraction));
+        }
+        addFractionalTrackers(fractionalTrackers);
+    }
+
+    private void addCompanionAdViewTrackersForUrls(@NonNull final List<String> urls) {
+        Preconditions.checkNotNull(urls);
+
+        if (hasCompanionAd()) {
+            final List<VastTracker> companionAdViewTrackers = createVastTrackersForUrls(urls);
+            mLandscapeVastCompanionAdConfig.addCreativeViewTrackers(companionAdViewTrackers);
+            mPortraitVastCompanionAdConfig.addCreativeViewTrackers(companionAdViewTrackers);
+        }
+    }
+
+    private void addCompanionAdClickTrackersForUrls(@NonNull final List<String> urls) {
+        Preconditions.checkNotNull(urls);
+
+        if (hasCompanionAd()) {
+            final List<VastTracker> companionAdClickTrackers = createVastTrackersForUrls(urls);
+            mLandscapeVastCompanionAdConfig.addClickTrackers(companionAdClickTrackers);
+            mPortraitVastCompanionAdConfig.addClickTrackers(companionAdClickTrackers);
+        }
+    }
+
 }
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VastVideoRadialCountdownWidget.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VastVideoRadialCountdownWidget.java
index 8fe0e8fd..8704e0fe 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VastVideoRadialCountdownWidget.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VastVideoRadialCountdownWidget.java
@@ -37,12 +37,12 @@ public VastVideoRadialCountdownWidget(@NonNull final Context context) {
         setLayoutParams(layoutParams);
     }
 
-    void calibrateAndMakeVisible(final int initialCountdownMilliseconds) {
+    public void calibrateAndMakeVisible(final int initialCountdownMilliseconds) {
         mRadialCountdownDrawable.setInitialCountdown(initialCountdownMilliseconds);
         setVisibility(VISIBLE);
     }
 
-    void updateCountdownProgress(final int initialCountdownMilliseconds, final int currentProgressMilliseconds) {
+    public void updateCountdownProgress(final int initialCountdownMilliseconds, final int currentProgressMilliseconds) {
         // There exists an Android video player bug where VideoView.getCurrentPosition()
         // temporarily returns 0 right after backgrounding and switching back to the app.
         // Therefore, we check against the last known current position to ensure that it's
@@ -65,14 +65,14 @@ void updateCountdownProgress(final int initialCountdownMilliseconds, final int c
     // for testing
     @Deprecated
     @VisibleForTesting
-    RadialCountdownDrawable getImageViewDrawable() {
+    public RadialCountdownDrawable getImageViewDrawable() {
         return mRadialCountdownDrawable;
     }
 
     // for testing
     @Deprecated
     @VisibleForTesting
-    void setImageViewDrawable(RadialCountdownDrawable drawable) {
+    public void setImageViewDrawable(RadialCountdownDrawable drawable) {
         mRadialCountdownDrawable = drawable;
     }
 }
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VastVideoView.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VastVideoView.java
index 32904efb..d4f9949d 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VastVideoView.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VastVideoView.java
@@ -2,7 +2,6 @@
 
 import android.content.Context;
 import android.media.MediaMetadataRetriever;
-import android.media.MediaPlayer;
 import android.os.AsyncTask;
 import android.os.Build;
 import android.support.annotation.NonNull;
@@ -14,10 +13,6 @@
 import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.util.AsyncTasks;
-import com.mopub.common.util.Streams;
-
-import java.io.File;
-import java.io.FileInputStream;
 
 /**
  * Custom VideoView dedicated for VAST videos. This primarily deals with the blurring of the last
@@ -30,12 +25,11 @@
 
     @Nullable private VastVideoBlurLastVideoFrameTask mBlurLastVideoFrameTask;
     @Nullable private MediaMetadataRetriever mMediaMetadataRetriever;
-    private int mVideoRetries;
 
     public VastVideoView(@NonNull final Context context) {
         super(context);
         Preconditions.checkNotNull(context, "context cannot be null");
-        mMediaMetadataRetriever = createMediaMetadataRetriever();
+        mMediaMetadataRetriever = new MediaMetadataRetriever();
     }
 
     /**
@@ -74,63 +68,6 @@ public void onDestroy() {
         }
     }
 
-    boolean retryMediaPlayer(final MediaPlayer mediaPlayer, final int what, final int extra,
-            @NonNull final String diskMediaFileUrl) {
-        // XXX
-        // VideoView has a bug in versions lower than Jelly Bean, Api Level 16, Android 4.1
-        // For api < 16, VideoView is not able to read files written to disk since it reads them in
-        // a Context different from the Application and therefore does not have correct permission.
-        // To solve this problem we obtain the video file descriptor ourselves with valid permissions
-        // and pass it to the underlying MediaPlayer in VideoView.
-        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN
-                && what == MediaPlayer.MEDIA_ERROR_UNKNOWN
-                && extra == VIDEO_VIEW_FILE_PERMISSION_ERROR
-                && mVideoRetries < MAX_VIDEO_RETRIES) {
-
-            FileInputStream inputStream = null;
-            try {
-                mediaPlayer.reset();
-                final File file = new File(diskMediaFileUrl);
-                inputStream = new FileInputStream(file);
-                mediaPlayer.setDataSource(inputStream.getFD());
-
-                // XXX
-                // VideoView has a callback registered with the MediaPlayer to set a flag when the
-                // media file has been prepared. Start also sets a flag in VideoView indicating the
-                // desired state is to play the video. Therefore, whichever method finishes last
-                // will check both flags and begin playing the video.
-                mediaPlayer.prepareAsync();
-                start();
-                return true;
-            } catch (Exception e) {
-                return false;
-            } finally {
-                Streams.closeStream(inputStream);
-                mVideoRetries++;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Called when the activity enclosing this view is resumed.
-     */
-    public void onResume() {
-        // When resuming, VideoView needs to reinitialize its MediaPlayer with the video path
-        // and therefore reset the count to zero, to let it retry on error
-        mVideoRetries = 0;
-    }
-
-    @VisibleForTesting
-    @Nullable
-    MediaMetadataRetriever createMediaMetadataRetriever() {
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD_MR1) {
-            return new MediaMetadataRetriever();
-        }
-
-        return null;
-    }
-
     // for testing
     @Deprecated
     @VisibleForTesting
@@ -153,10 +90,4 @@ void setBlurLastVideoFrameTask(@NonNull VastVideoBlurLastVideoFrameTask blurLast
         mBlurLastVideoFrameTask = blurLastVideoFrameTask;
     }
 
-    // for testing
-    @Deprecated
-    @VisibleForTesting
-    int getVideoRetries() {
-        return mVideoRetries;
-    }
 }
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VastVideoViewController.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VastVideoViewController.java
index 2015a857..d83b08f5 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VastVideoViewController.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VastVideoViewController.java
@@ -33,8 +33,8 @@
 import java.io.Serializable;
 import java.util.Map;
 
-import static android.content.pm.ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
 import static android.content.pm.ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
+import static android.content.pm.ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE;
 import static com.mopub.common.MoPubBrowser.MOPUB_BROWSER_REQUEST_CODE;
 import static com.mopub.mobileads.VastXmlManagerAggregator.ADS_BY_AD_SLOT_ID;
 import static com.mopub.mobileads.VastXmlManagerAggregator.SOCIAL_ACTIONS_AD_SLOT_ID;
@@ -252,7 +252,7 @@ protected void onCreate() {
                 getBaseVideoViewControllerListener().onSetRequestedOrientation(SCREEN_ORIENTATION_PORTRAIT);
                 break;
             case FORCE_LANDSCAPE:
-                getBaseVideoViewControllerListener().onSetRequestedOrientation(SCREEN_ORIENTATION_LANDSCAPE);
+                getBaseVideoViewControllerListener().onSetRequestedOrientation(SCREEN_ORIENTATION_SENSOR_LANDSCAPE);
                 break;
             case DEVICE_ORIENTATION:
                 break;  // don't do anything
@@ -446,20 +446,15 @@ public void onCompletion(MediaPlayer mp) {
         videoView.setOnErrorListener(new MediaPlayer.OnErrorListener() {
             @Override
             public boolean onError(final MediaPlayer mediaPlayer, final int what, final int extra) {
-                if (videoView.retryMediaPlayer(mediaPlayer, what, extra,
-                        mVastVideoConfig.getDiskMediaFileUrl())) {
-                    return true;
-                } else {
-                    stopRunnables();
-                    makeVideoInteractable();
-                    videoError(false);
-                    mVideoError = true;
+                stopRunnables();
+                makeVideoInteractable();
+                videoError(false);
+                mVideoError = true;
 
-                    mVastVideoConfig.handleError(getContext(),
-                            VastErrorCode.GENERAL_LINEAR_AD_ERROR, getCurrentPosition());
+                mVastVideoConfig.handleError(getContext(),
+                        VastErrorCode.GENERAL_LINEAR_AD_ERROR, getCurrentPosition());
 
-                    return false;
-                }
+                return false;
             }
         });
 
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VastVideoViewCountdownRunnable.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VastVideoViewCountdownRunnable.java
index c3602e9f..b7c6319c 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VastVideoViewCountdownRunnable.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VastVideoViewCountdownRunnable.java
@@ -6,8 +6,8 @@
 import com.mopub.common.Preconditions;
 
 /**
- * This class is used to update a {@link VastVideoViewController}'s countdown display according to rules
- * contained in the {@link VastVideoViewController}
+ * A runnable that is used to update a {@link VastVideoViewController}'s countdown display according
+ * to rules contained in the {@link VastVideoViewController}
  */
 public class VastVideoViewCountdownRunnable extends RepeatingHandlerRunnable {
 
@@ -19,7 +19,6 @@ public VastVideoViewCountdownRunnable(@NonNull VastVideoViewController videoView
         Preconditions.checkNotNull(handler);
         Preconditions.checkNotNull(videoViewController);
 
-
         mVideoViewController = videoViewController;
     }
 
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VastWebView.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VastWebView.java
index 673dc07f..ba8288f1 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VastWebView.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VastWebView.java
@@ -11,11 +11,8 @@
 import com.mopub.common.Preconditions;
 import com.mopub.common.VisibleForTesting;
 import com.mopub.common.util.Utils;
-import com.mopub.common.util.VersionCode;
 import com.mopub.network.Networking;
 
-import static com.mopub.common.util.VersionCode.currentApiLevel;
-
 /**
  * A WebView customized for Vast video needs.
  */
@@ -32,9 +29,7 @@
         disableScrollingAndZoom();
         getSettings().setJavaScriptEnabled(true);
 
-        if (currentApiLevel().isAtLeast(VersionCode.ICE_CREAM_SANDWICH)) {
-            enablePlugins(true);
-        }
+        enablePlugins(true);
 
         setBackgroundColor(Color.TRANSPARENT);
         setOnTouchListener(new VastWebViewOnTouchListener());
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VideoTrackingEvent.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VideoTrackingEvent.java
new file mode 100644
index 00000000..4a041f44
--- /dev/null
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/VideoTrackingEvent.java
@@ -0,0 +1,44 @@
+package com.mopub.mobileads;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+/**
+ * Internal Video Tracking events, defined in ad server
+ */
+enum VideoTrackingEvent {
+    START("start"),
+    FIRST_QUARTILE("firstQuartile"),
+    MIDPOINT("midpoint"),
+    THIRD_QUARTILE("thirdQuartile"),
+    COMPLETE("complete"),
+    COMPANION_AD_VIEW("companionAdView"),
+    COMPANION_AD_CLICK("companionAdClick"),
+    UNKNOWN("");
+
+    private final String name;
+
+    VideoTrackingEvent(@NonNull final String name) {
+        this.name = name;
+    }
+
+    @NonNull
+    public String getName() {
+        return name;
+    }
+
+    @NonNull
+    public static VideoTrackingEvent fromString(@Nullable final String name) {
+        if (name == null) {
+            return UNKNOWN;
+        }
+
+        for (VideoTrackingEvent event : VideoTrackingEvent.values()) {
+            if (name.equals(event.getName())) {
+                return event;
+            }
+        }
+
+        return UNKNOWN;
+    }
+}
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/resource/MraidJavascript.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/resource/MraidJavascript.java
index 7071ffa0..cc0791a9 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/resource/MraidJavascript.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/resource/MraidJavascript.java
@@ -884,5 +884,5 @@
             "      }\n" +
             "    }\n" +
             "  };\n" +
-            "}());\n";
+            "}());\n".replaceAll("(?m)^\\s+", "").replaceAll("(?m)^//.*(?=\\n)", "");
 }
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/util/WebViews.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/util/WebViews.java
index 12170703..f97898a0 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/util/WebViews.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mobileads/util/WebViews.java
@@ -1,8 +1,5 @@
 package com.mopub.mobileads.util;
 
-import android.annotation.TargetApi;
-import android.os.Build.VERSION;
-import android.os.Build.VERSION_CODES;
 import android.support.annotation.NonNull;
 import android.webkit.JsPromptResult;
 import android.webkit.JsResult;
@@ -10,25 +7,8 @@
 import android.webkit.WebView;
 
 import com.mopub.common.logging.MoPubLog;
-import com.mopub.common.util.Reflection.MethodBuilder;
 
 public class WebViews {
-    @TargetApi(VERSION_CODES.HONEYCOMB)
-    public static void onResume(@NonNull final WebView webView) {
-        if (VERSION.SDK_INT >= VERSION_CODES.HONEYCOMB) {
-            webView.onResume();
-            return;
-        }
-
-        // Method is still available, but hidden. Invoke using reflection.
-        try {
-            new MethodBuilder(webView, "onResume").setAccessible().execute();
-        } catch (Exception e) {
-            // no-op
-        }
-    }
-
-    @TargetApi(VERSION_CODES.HONEYCOMB)
     public static void onPause(@NonNull final WebView webView, boolean isFinishing) {
         // XXX
         // We need to call WebView#stopLoading and WebView#loadUrl here due to an Android
@@ -40,17 +20,7 @@ public static void onPause(@NonNull final WebView webView, boolean isFinishing)
             webView.loadUrl("");
         }
 
-        if (VERSION.SDK_INT >= VERSION_CODES.HONEYCOMB) {
-            webView.onPause();
-            return;
-        }
-
-        // Method is still available, but hidden. Invoke using reflection.
-        try {
-            new MethodBuilder(webView, "onPause").setAccessible().execute();
-        } catch (Exception e) {
-            // no-op
-        }
+        webView.onPause();
     }
 
     public static void setDisableJSChromeClient(@NonNull final WebView webView) {
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mraid/MraidBridge.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mraid/MraidBridge.java
index c0ca1319..59311bd5 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mraid/MraidBridge.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mraid/MraidBridge.java
@@ -23,10 +23,10 @@
 import com.mopub.common.Constants;
 import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.TrackedContext;
 import com.mopub.mobileads.BaseWebView;
 import com.mopub.mobileads.ViewGestureDetector;
 import com.mopub.mobileads.ViewGestureDetector.UserClickListener;
-import com.mopub.mobileads.resource.MraidJavascript;
 import com.mopub.mobileads.util.WebViews;
 import com.mopub.mraid.MraidBridge.MraidWebView.OnVisibilityChangedListener;
 import com.mopub.mraid.MraidNativeCommandHandler.MraidCommandFailureListener;
@@ -75,10 +75,6 @@ void onSetOrientationProperties(boolean allowOrientationChange, MraidOrientation
         void onDirectClick(URI uri);
     }
 
-    private final String FILTERED_JAVASCRIPT_SOURCE = MraidJavascript.JAVASCRIPT_SOURCE
-            .replaceAll("(?m)^\\s+", "")
-            .replaceAll("(?m)^//.*(?=\\n)", "");
-
     @NonNull private final PlacementType mPlacementType;
 
     @NonNull private final MraidNativeCommandHandler mMraidNativeCommandHandler;
@@ -117,7 +113,6 @@ void attachView(@NonNull MraidWebView mraidWebView) {
             }
         }
 
-        mMraidWebView.loadUrl("javascript:" + FILTERED_JAVASCRIPT_SOURCE);
         mMraidWebView.setScrollContainer(false);
         mMraidWebView.setVerticalScrollBarEnabled(false);
         mMraidWebView.setHorizontalScrollBarEnabled(false);
@@ -287,13 +282,7 @@ public boolean isVisible() {
         }
     }
 
-    private final WebViewClient mMraidWebViewClient = new WebViewClient() {
-        @Override
-        public void onReceivedError(WebView view, int errorCode, String description, String failingUrl) {
-            MoPubLog.d("Error: " + description);
-            super.onReceivedError(view, errorCode, description, failingUrl);
-        }
-
+    private final WebViewClient mMraidWebViewClient = new MraidWebViewClient() {
         @Override
         public boolean shouldOverrideUrlLoading(@NonNull WebView view, @NonNull String url) {
             return handleShouldOverrideUrl(url);
@@ -303,6 +292,13 @@ public boolean shouldOverrideUrlLoading(@NonNull WebView view, @NonNull String u
         public void onPageFinished(@NonNull WebView view, @NonNull String url) {
             handlePageFinished();
         }
+
+        @Override
+        public void onReceivedError(@NonNull WebView view, int errorCode,
+                @NonNull String description, @NonNull String failingUrl) {
+            MoPubLog.d("Error: " + description);
+            super.onReceivedError(view, errorCode, description, failingUrl);
+        }
     };
 
     @VisibleForTesting
@@ -352,6 +348,7 @@ boolean handleShouldOverrideUrl(@NonNull final String url) {
             Intent intent = new Intent();
             intent.setAction(Intent.ACTION_VIEW);
             intent.setData(Uri.parse(url));
+            TrackedContext.markIntent(intent);
             intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
 
             try {
@@ -606,7 +603,7 @@ public void notifyScreenMetrics(@NonNull final MraidScreenMetrics screenMetrics)
                 + stringifyRect(screenMetrics.getDefaultAdRectDips())
                 + ")");
         injectJavaScript("mraidbridge.notifySizeChangeEvent("
-                + stringifySize(screenMetrics.getCurrentAdRect())
+                + stringifySize(screenMetrics.getCurrentAdRectDips())
                 + ")");
     }
 
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mraid/MraidController.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mraid/MraidController.java
index d38a818f..020a8835 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mraid/MraidController.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mraid/MraidController.java
@@ -1,6 +1,5 @@
 package com.mopub.mraid;
 
-import android.annotation.TargetApi;
 import android.app.Activity;
 import android.content.BroadcastReceiver;
 import android.content.ComponentName;
@@ -10,8 +9,6 @@
 import android.content.pm.ActivityInfo;
 import android.content.pm.PackageManager;
 import android.graphics.Rect;
-import android.os.Build.VERSION;
-import android.os.Build.VERSION_CODES;
 import android.os.Handler;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
@@ -28,12 +25,12 @@
 import android.widget.FrameLayout.LayoutParams;
 
 import com.mopub.common.AdReport;
-import com.mopub.common.UrlHandler;
 import com.mopub.common.CloseableLayout;
 import com.mopub.common.CloseableLayout.ClosePosition;
 import com.mopub.common.CloseableLayout.OnCloseListener;
 import com.mopub.common.Preconditions;
 import com.mopub.common.UrlAction;
+import com.mopub.common.UrlHandler;
 import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.common.util.DeviceUtils;
@@ -586,10 +583,10 @@ public void resume() {
 
         // This causes an inline video to resume if it was playing previously
         if (mMraidWebView != null) {
-            WebViews.onResume(mMraidWebView);
+            mMraidWebView.onResume();
         }
         if (mTwoPartWebView != null) {
-            WebViews.onResume(mTwoPartWebView);
+            mTwoPartWebView.onResume();
         }
     }
 
@@ -809,7 +806,7 @@ void handleExpand(@Nullable URI uri, boolean shouldUseCustomClose)
     }
 
     @VisibleForTesting
-    void handleClose() {
+    protected void handleClose() {
         if (mMraidWebView == null) {
             // Doesn't throw an exception because the ad has been destroyed
             return;
@@ -926,7 +923,6 @@ void unApplyOrientation() {
         mOriginalActivityOrientation = null;
     }
 
-    @TargetApi(VERSION_CODES.HONEYCOMB_MR2)
     @VisibleForTesting
     boolean shouldAllowForceOrientation(final MraidOrientation newOrientation) {
         // NONE is the default and always allowed
@@ -959,17 +955,15 @@ boolean shouldAllowForceOrientation(final MraidOrientation newOrientation) {
         boolean containsNecessaryConfigChanges =
                 bitMaskContainsFlag(activityInfo.configChanges, CONFIG_ORIENTATION);
 
-        // And on API 13+, configChanges must also include "screenSize"
-        if (VERSION.SDK_INT >= VERSION_CODES.HONEYCOMB_MR2) {
-            containsNecessaryConfigChanges = containsNecessaryConfigChanges
-                    && bitMaskContainsFlag(activityInfo.configChanges, CONFIG_SCREEN_SIZE);
-        }
+        // configChanges must also include "screenSize"
+        containsNecessaryConfigChanges = containsNecessaryConfigChanges
+                && bitMaskContainsFlag(activityInfo.configChanges, CONFIG_SCREEN_SIZE);
 
         return containsNecessaryConfigChanges;
     }
 
     @VisibleForTesting
-    void handleCustomClose(boolean useCustomClose) {
+    protected void handleCustomClose(boolean useCustomClose) {
         boolean wasUsingCustomClose = !mCloseableAdContainer.isCloseVisible();
         if (useCustomClose == wasUsingCustomClose) {
             return;
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mraid/MraidNativeCommandHandler.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mraid/MraidNativeCommandHandler.java
index b90b60ab..26963641 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mraid/MraidNativeCommandHandler.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mraid/MraidNativeCommandHandler.java
@@ -1,22 +1,18 @@
 package com.mopub.mraid;
 
-import android.annotation.TargetApi;
 import android.app.Activity;
 import android.app.AlertDialog;
 import android.content.ActivityNotFoundException;
 import android.content.Context;
 import android.content.DialogInterface;
 import android.content.Intent;
-import android.content.pm.PackageManager;
 import android.media.MediaScannerConnection;
 import android.net.Uri;
 import android.os.AsyncTask;
-import android.os.Build.VERSION_CODES;
 import android.os.Environment;
 import android.provider.CalendarContract;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-import android.support.v4.content.ContextCompat;
 import android.text.TextUtils;
 import android.view.View;
 import android.view.Window;
@@ -32,7 +28,6 @@
 import com.mopub.common.util.Intents;
 import com.mopub.common.util.Streams;
 import com.mopub.common.util.Utils;
-import com.mopub.common.util.VersionCode;
 
 import java.io.BufferedInputStream;
 import java.io.File;
@@ -147,8 +142,7 @@ public static boolean isStorePictureSupported(Context context) {
     static boolean isCalendarAvailable(Context context) {
         Intent calendarIntent = new Intent(Intent.ACTION_INSERT).setType(ANDROID_CALENDAR_CONTENT_TYPE);
 
-        return VersionCode.currentApiLevel().isAtLeast(VersionCode.ICE_CREAM_SANDWICH)
-                && Intents.deviceCanHandleIntent(context, calendarIntent);
+        return Intents.deviceCanHandleIntent(context, calendarIntent);
     }
 
     /**
@@ -156,16 +150,7 @@ static boolean isCalendarAvailable(Context context) {
      * enabled in its foreground window and only if the View or any ParentView in the view tree
      * has not had hardware acceleration explicitly turned off.
      */
-    // TargetApi is needed to access hardware accelerated flags
-    @TargetApi(11)
     boolean isInlineVideoAvailable(@NonNull Activity activity, @NonNull View view) {
-        // In addition to potential hardware acceleration problems, there is a problem in the WebKit
-        // HTML5VideoView implementation pre-Gingerbread that would result in HTML5VideoViewProxy
-        // holding on to an instance of the WebView even after the WebView is destroyed. For
-        // this reason, we never allow inline video on Gingerbread devices.
-        if (VersionCode.currentApiLevel().isBelow(VersionCode.HONEYCOMB_MR1)) {
-            return false;
-        }
 
         // Hardware Acceleration
         // Hardware acceleration for the application and activity is enabled by default
@@ -211,7 +196,6 @@ boolean isInlineVideoAvailable(@NonNull Activity activity, @NonNull View view) {
         return false;
     }
 
-    @TargetApi(VERSION_CODES.ICE_CREAM_SANDWICH)
     private Map<String, Object> translateJSParamsToAndroidCalendarEventMapping(Map<String, String> params) {
         Map<String, Object> validatedParamsMapping = new HashMap<String, Object>();
         if (!params.containsKey("description") || !params.containsKey("start")) {
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mraid/MraidWebViewClient.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mraid/MraidWebViewClient.java
new file mode 100644
index 00000000..b2864ed4
--- /dev/null
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/mraid/MraidWebViewClient.java
@@ -0,0 +1,46 @@
+package com.mopub.mraid;
+
+import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
+import android.webkit.WebResourceResponse;
+import android.webkit.WebView;
+import android.webkit.WebViewClient;
+
+import com.mopub.mobileads.resource.MraidJavascript;
+
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.util.Locale;
+
+/**
+ * Handles injecting the MRAID javascript when encountering mraid.js urls
+ */
+public class MraidWebViewClient extends WebViewClient {
+
+    private static final String MRAID_JS = "mraid.js";
+    private static final String MRAID_INJECTION_JAVASCRIPT = "javascript:"
+            + MraidJavascript.JAVASCRIPT_SOURCE;
+
+    @SuppressWarnings("deprecation") // new method will simply call this one
+    @Override
+    public WebResourceResponse shouldInterceptRequest(@NonNull final WebView view,
+            @NonNull final String url) {
+        if (matchesInjectionUrl(url)) {
+            return createMraidInjectionResponse();
+        } else {
+            return super.shouldInterceptRequest(view, url);
+        }
+    }
+
+    @VisibleForTesting
+    boolean matchesInjectionUrl(@NonNull final String url) {
+        final Uri uri = Uri.parse(url.toLowerCase(Locale.US));
+        return MRAID_JS.equals(uri.getLastPathSegment());
+    }
+
+    private WebResourceResponse createMraidInjectionResponse() {
+        InputStream data = new ByteArrayInputStream(MRAID_INJECTION_JAVASCRIPT.getBytes());
+        return new WebResourceResponse("text/javascript", "UTF-8", data);
+    }
+}
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/AdRequest.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/AdRequest.java
index 2118eaa2..1285cc62 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/AdRequest.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/AdRequest.java
@@ -3,7 +3,6 @@
 import android.content.Context;
 import android.location.Location;
 import android.net.Uri;
-import android.os.Build;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
@@ -231,12 +230,6 @@ public Listener getListener() {
             serverExtras.put(DataKeys.CREATIVE_ORIENTATION_KEY, extractHeader(headers, ResponseHeader.ORIENTATION));
         }
         if (AdType.VIDEO_NATIVE.equals(adTypeString)) {
-            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN) {
-                return Response.error(new MoPubNetworkError("Native Video ads are only supported" +
-                        " for Android API Level 16 (JellyBean) and above.",
-                        MoPubNetworkError.Reason.UNSPECIFIED));
-
-            }
             serverExtras.put(DataKeys.PLAY_VISIBLE_PERCENT,
                     extractPercentHeaderString(headers, ResponseHeader.PLAY_VISIBLE_PERCENT));
             serverExtras.put(DataKeys.PAUSE_VISIBLE_PERCENT,
@@ -266,18 +259,35 @@ public Listener getListener() {
                             .build()
             );
         }
+
+        // Extract internal video trackers, if available
+        final String videoTrackers = extractHeader(headers, ResponseHeader.VIDEO_TRACKERS);
+        if (videoTrackers != null) {
+            serverExtras.put(DataKeys.VIDEO_TRACKERS_KEY, videoTrackers);
+        }
+
         builder.setServerExtras(serverExtras);
 
-        if (AdType.REWARDED_VIDEO.equals(adTypeString) || AdType.CUSTOM.equals(adTypeString)) {
+        if (AdType.REWARDED_VIDEO.equals(adTypeString) || AdType.CUSTOM.equals(adTypeString) ||
+                AdType.REWARDED_PLAYABLE.equals(adTypeString)) {
             final String rewardedVideoCurrencyName = extractHeader(headers,
                     ResponseHeader.REWARDED_VIDEO_CURRENCY_NAME);
             final String rewardedVideoCurrencyAmount = extractHeader(headers,
                     ResponseHeader.REWARDED_VIDEO_CURRENCY_AMOUNT);
+            final String rewardedCurrencies = extractHeader(headers,
+                    ResponseHeader.REWARDED_CURRENCIES);
             final String rewardedVideoCompletionUrl = extractHeader(headers,
                     ResponseHeader.REWARDED_VIDEO_COMPLETION_URL);
+            final Integer rewardedDuration = extractIntegerHeader(headers,
+                    ResponseHeader.REWARDED_DURATION);
+            final boolean shouldRewardOnClick = extractBooleanHeader(headers,
+                    ResponseHeader.SHOULD_REWARD_ON_CLICK, false);
             builder.setRewardedVideoCurrencyName(rewardedVideoCurrencyName);
             builder.setRewardedVideoCurrencyAmount(rewardedVideoCurrencyAmount);
+            builder.setRewardedCurrencies(rewardedCurrencies);
             builder.setRewardedVideoCompletionUrl(rewardedVideoCompletionUrl);
+            builder.setRewardedDuration(rewardedDuration);
+            builder.setShouldRewardOnClick(shouldRewardOnClick);
         }
 
         AdResponse adResponse = builder.build();
@@ -291,7 +301,8 @@ private boolean eventDataIsInResponseBody(@Nullable String adType,
             @Nullable String fullAdType) {
         return AdType.MRAID.equals(adType) || AdType.HTML.equals(adType) ||
                 (AdType.INTERSTITIAL.equals(adType) && FullAdType.VAST.equals(fullAdType)) ||
-                (AdType.REWARDED_VIDEO.equals(adType) && FullAdType.VAST.equals(fullAdType));
+                (AdType.REWARDED_VIDEO.equals(adType) && FullAdType.VAST.equals(fullAdType)) ||
+                AdType.REWARDED_PLAYABLE.equals(adType);
     }
 
     // Based on Volley's StringResponse class.
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/AdResponse.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/AdResponse.java
index c4036719..f601a06e 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/AdResponse.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/AdResponse.java
@@ -41,7 +41,12 @@
     @Nullable
     private final String mRewardedVideoCurrencyAmount;
     @Nullable
+    private final String mRewardedCurrencies;
+    @Nullable
     private final String mRewardedVideoCompletionUrl;
+    @Nullable
+    private final Integer mRewardedDuration;
+    private final boolean mShouldRewardOnClick;
 
     @Nullable
     private final String mRedirectUrl;
@@ -97,7 +102,10 @@ private AdResponse(@NonNull Builder builder) {
 
         mRewardedVideoCurrencyName = builder.rewardedVideoCurrencyName;
         mRewardedVideoCurrencyAmount = builder.rewardedVideoCurrencyAmount;
+        mRewardedCurrencies = builder.rewardedCurrencies;
         mRewardedVideoCompletionUrl = builder.rewardedVideoCompletionUrl;
+        mRewardedDuration = builder.rewardedDuration;
+        mShouldRewardOnClick = builder.shouldRewardOnClick;
 
         mRedirectUrl = builder.redirectUrl;
         mClickTrackingUrl = builder.clickTrackingUrl;
@@ -203,11 +211,25 @@ public String getRewardedVideoCurrencyAmount() {
         return mRewardedVideoCurrencyAmount;
     }
 
+    @Nullable
+    public String getRewardedCurrencies() {
+        return mRewardedCurrencies;
+    }
+
     @Nullable
     public String getRewardedVideoCompletionUrl() {
         return mRewardedVideoCompletionUrl;
     }
 
+    @Nullable
+    public Integer getRewardedDuration() {
+        return mRewardedDuration;
+    }
+
+    public boolean shouldRewardOnClick() {
+        return mShouldRewardOnClick;
+    }
+
     @Nullable
     public String getRedirectUrl() {
         return mRedirectUrl;
@@ -291,6 +313,12 @@ public Builder toBuilder() {
         return new Builder()
                 .setAdType(mAdType)
                 .setNetworkType(mNetworkType)
+                .setRewardedVideoCurrencyName(mRewardedVideoCurrencyName)
+                .setRewardedVideoCurrencyAmount(mRewardedVideoCurrencyAmount)
+                .setRewardedCurrencies(mRewardedCurrencies)
+                .setRewardedVideoCompletionUrl(mRewardedVideoCompletionUrl)
+                .setRewardedDuration(mRewardedDuration)
+                .setShouldRewardOnClick(mShouldRewardOnClick)
                 .setRedirectUrl(mRedirectUrl)
                 .setClickTrackingUrl(mClickTrackingUrl)
                 .setImpressionTrackingUrl(mImpressionTrackingUrl)
@@ -315,7 +343,10 @@ public Builder toBuilder() {
 
         private String rewardedVideoCurrencyName;
         private String rewardedVideoCurrencyAmount;
+        private String rewardedCurrencies;
         private String rewardedVideoCompletionUrl;
+        private Integer rewardedDuration;
+        private boolean shouldRewardOnClick;
 
         private String redirectUrl;
         private String clickTrackingUrl;
@@ -371,12 +402,27 @@ public Builder setRewardedVideoCurrencyAmount(
             return this;
         }
 
+        public Builder setRewardedCurrencies(@Nullable final String rewardedCurrencies) {
+            this.rewardedCurrencies = rewardedCurrencies;
+            return this;
+        }
+
         public Builder setRewardedVideoCompletionUrl(
                 @Nullable final String rewardedVideoCompletionUrl) {
             this.rewardedVideoCompletionUrl = rewardedVideoCompletionUrl;
             return this;
         }
 
+        public Builder setRewardedDuration(@Nullable final Integer rewardedDuration) {
+            this.rewardedDuration = rewardedDuration;
+            return this;
+        }
+
+        public Builder setShouldRewardOnClick(final boolean shouldRewardOnClick) {
+            this.shouldRewardOnClick = shouldRewardOnClick;
+            return this;
+        }
+
         public Builder setRedirectUrl(@Nullable final String redirectUrl) {
             this.redirectUrl = redirectUrl;
             return this;
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/CustomSSLSocketFactory.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/CustomSSLSocketFactory.java
index 087f864e..5cd1d30f 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/CustomSSLSocketFactory.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/CustomSSLSocketFactory.java
@@ -116,16 +116,25 @@ public Socket createSocket(final Socket socketParam, final String host, final in
             throw new SocketException("SSLSocketFactory was null. Unable to create socket.");
         }
 
-        // Don't use the original socket and create a new one. This closes the original socket
-        // if the autoClose flag is set.
-        if (autoClose && socketParam != null) {
-            socketParam.close();
+        // There is a bug in Android before version 6.0 where SNI does not work, so we try to do
+        // it manually here.
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
+            // Don't use the original socket and create a new one. This closes the original socket
+            // if the autoClose flag is set.
+            if (autoClose && socketParam != null) {
+                socketParam.close();
+            }
+
+            final Socket socket = mCertificateSocketFactory.createSocket(
+                    InetAddressUtils.getInetAddressByName(host), port);
+            enableTlsIfAvailable(socket);
+            doManualServerNameIdentification(socket, host);
+            return socket;
         }
 
-        final Socket socket = mCertificateSocketFactory.createSocket(
-                InetAddressUtils.getInetAddressByName(host), port);
+        final Socket socket = mCertificateSocketFactory.createSocket(socketParam, host, port,
+                autoClose);
         enableTlsIfAvailable(socket);
-        doManualServerNameIdentification(socket, host);
         return socket;
     }
 
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/HeaderUtils.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/HeaderUtils.java
index 1732beab..c4247ca7 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/HeaderUtils.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/HeaderUtils.java
@@ -72,6 +72,14 @@ private static Integer formatIntHeader(String headerValue) {
             return null;
         }
 
+        try {
+            return Integer.parseInt(headerValue);
+        } catch (Exception e) {
+            // Continue below if we can't parse it quickly
+        }
+
+        // The number format way of parsing integers is way slower than Integer.parseInt, but
+        // for numbers like 3.14, we would like to return 3, not null.
         NumberFormat numberFormat = NumberFormat.getInstance(Locale.US);
         numberFormat.setParseIntegerOnly(true);
 
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/MaxWidthImageLoader.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/MaxWidthImageLoader.java
index 6927dd96..99851c23 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/MaxWidthImageLoader.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/MaxWidthImageLoader.java
@@ -1,9 +1,7 @@
 package com.mopub.network;
 
-import android.annotation.TargetApi;
 import android.content.Context;
 import android.graphics.Point;
-import android.os.Build;
 import android.view.Display;
 import android.view.WindowManager;
 
@@ -13,7 +11,6 @@
     private final int mMaxImageWidth;
 
 
-    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)
     public MaxWidthImageLoader(final RequestQueue queue, final Context context, final ImageCache imageCache) {
         super(queue, imageCache);
 
@@ -21,11 +18,7 @@ public MaxWidthImageLoader(final RequestQueue queue, final Context context, fina
         WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
         Display display = wm.getDefaultDisplay();
         Point size = new Point();
-        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB_MR2) {
-            size.set(display.getWidth(), display.getHeight());
-        } else {
-            display.getSize(size);
-        }
+        display.getSize(size);
 
         // Make our images no wider than the skinny side of the display.
         mMaxImageWidth = Math.min(size.x, size.y);
diff --git a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/Networking.java b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/Networking.java
index e55db850..67309a7a 100644
--- a/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/Networking.java
+++ b/mopub-sdk/mopub-sdk-base/src/main/java/com/mopub/network/Networking.java
@@ -2,10 +2,12 @@
 
 import android.content.Context;
 import android.graphics.Bitmap;
+import android.os.Build;
 import android.os.Looper;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.support.v4.util.LruCache;
+import android.webkit.WebSettings;
 import android.webkit.WebView;
 
 import com.mopub.common.ClientMetadata;
@@ -127,16 +129,17 @@ public static String getUserAgent(@NonNull Context context) {
             synchronized (Networking.class) {
                 userAgent = sUserAgent;
                 if (userAgent == null) {
-                    // As of Android 4.4, WebViews may only be instantiated on the UI thread
-                    if (Looper.myLooper() == Looper.getMainLooper()) {
+                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
+                        userAgent = WebSettings.getDefaultUserAgent(context);
+                    } else if (Looper.myLooper() == Looper.getMainLooper()){
+                        // WebViews may only be instantiated on the UI thread. If anything goes
+                        // wrong with getting a user agent, use the system-specific user agent.
                         try {
                             userAgent = new WebView(context).getSettings().getUserAgentString();
                         } catch (Exception e) {
                             userAgent = DEFAULT_USER_AGENT;
                         }
                     } else {
-                        // In the exceptional case where we can't access the WebView user agent,
-                        // fall back to the System-specific user agent.
                         userAgent = DEFAULT_USER_AGENT;
                     }
                     sUserAgent = userAgent;
diff --git a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/BaseInterstitialActivity.java b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/BaseInterstitialActivity.java
index 122787a0..f5208bb0 100644
--- a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/BaseInterstitialActivity.java
+++ b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/BaseInterstitialActivity.java
@@ -17,7 +17,7 @@
 import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
 
 abstract class BaseInterstitialActivity extends Activity {
-    protected AdReport mAdReport;
+    @Nullable protected AdReport mAdReport;
 
     enum JavaScriptWebViewCallbacks {
         // The ad server appends these functions to the MRAID javascript to help with third party
@@ -39,8 +39,8 @@ protected String getUrl() {
         }
     }
 
-    private CloseableLayout mCloseableLayout;
-    private Long mBroadcastIdentifier;
+    @Nullable private CloseableLayout mCloseableLayout;
+    @Nullable private Long mBroadcastIdentifier;
 
     public abstract View getAdView();
 
@@ -71,20 +71,32 @@ public void onClose() {
 
     @Override
     protected void onDestroy() {
-        mCloseableLayout.removeAllViews();
+        if (mCloseableLayout != null) {
+            mCloseableLayout.removeAllViews();
+        }
         super.onDestroy();
     }
 
+    @Nullable
+    protected CloseableLayout getCloseableLayout() {
+        return mCloseableLayout;
+    }
+
+    @Nullable
     Long getBroadcastIdentifier() {
         return mBroadcastIdentifier;
     }
 
     protected void showInterstitialCloseButton() {
-        mCloseableLayout.setCloseVisible(true);
+        if (mCloseableLayout != null) {
+            mCloseableLayout.setCloseVisible(true);
+        }
     }
 
     protected void hideInterstitialCloseButton() {
-        mCloseableLayout.setCloseVisible(false);
+        if (mCloseableLayout != null) {
+            mCloseableLayout.setCloseVisible(false);
+        }
     }
 
     protected static Long getBroadcastIdentifierFromIntent(Intent intent) {
diff --git a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/MraidActivity.java b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/MraidActivity.java
index 7431b47d..e2f86bd6 100644
--- a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/MraidActivity.java
+++ b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/MraidActivity.java
@@ -3,8 +3,6 @@
 import android.content.ActivityNotFoundException;
 import android.content.Context;
 import android.content.Intent;
-import android.os.Build.VERSION;
-import android.os.Build.VERSION_CODES;
 import android.os.Bundle;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
@@ -12,7 +10,6 @@
 import android.view.View;
 import android.view.WindowManager;
 import android.webkit.WebView;
-import android.webkit.WebViewClient;
 
 import com.mopub.common.AdReport;
 import com.mopub.common.Constants;
@@ -22,6 +19,7 @@
 import com.mopub.mraid.MraidController;
 import com.mopub.mraid.MraidController.MraidListener;
 import com.mopub.mraid.MraidController.UseCustomCloseListener;
+import com.mopub.mraid.MraidWebViewClient;
 import com.mopub.mraid.MraidWebViewDebugListener;
 import com.mopub.mraid.PlacementType;
 import com.mopub.network.Networking;
@@ -29,12 +27,12 @@
 import static com.mopub.common.DataKeys.AD_REPORT_KEY;
 import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
 import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
-import static com.mopub.mobileads.BaseInterstitialActivity.JavaScriptWebViewCallbacks.WEB_VIEW_DID_APPEAR;
-import static com.mopub.mobileads.BaseInterstitialActivity.JavaScriptWebViewCallbacks.WEB_VIEW_DID_CLOSE;
 import static com.mopub.common.IntentActions.ACTION_INTERSTITIAL_CLICK;
 import static com.mopub.common.IntentActions.ACTION_INTERSTITIAL_DISMISS;
 import static com.mopub.common.IntentActions.ACTION_INTERSTITIAL_FAIL;
 import static com.mopub.common.IntentActions.ACTION_INTERSTITIAL_SHOW;
+import static com.mopub.mobileads.BaseInterstitialActivity.JavaScriptWebViewCallbacks.WEB_VIEW_DID_APPEAR;
+import static com.mopub.mobileads.BaseInterstitialActivity.JavaScriptWebViewCallbacks.WEB_VIEW_DID_CLOSE;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.broadcastAction;
 
 public class MraidActivity extends BaseInterstitialActivity {
@@ -43,26 +41,31 @@
 
     public static void preRenderHtml(@NonNull final Context context,
             @NonNull final CustomEventInterstitialListener customEventInterstitialListener,
-            @NonNull final String htmlData) {
+            @Nullable final String htmlData) {
         preRenderHtml(customEventInterstitialListener, htmlData, new BaseWebView(context));
     }
 
     @VisibleForTesting
     static void preRenderHtml(
             @NonNull final CustomEventInterstitialListener customEventInterstitialListener,
-            @NonNull final String htmlData, @NonNull final BaseWebView dummyWebView) {
+            @Nullable final String htmlData, @NonNull final BaseWebView dummyWebView) {
         dummyWebView.enablePlugins(false);
         dummyWebView.enableJavascriptCaching();
 
-        dummyWebView.setWebViewClient(new WebViewClient() {
+        dummyWebView.setWebViewClient(new MraidWebViewClient() {
             @Override
-            public void onPageFinished(final WebView view, final String url) {
-                customEventInterstitialListener.onInterstitialLoaded();
+            public boolean shouldOverrideUrlLoading(WebView view, String url) {
+                return true;
             }
 
             @Override
-            public boolean shouldOverrideUrlLoading(WebView view, String url) {
-                return true;
+            public void onPageFinished(final WebView view, final String url) {
+                customEventInterstitialListener.onInterstitialLoaded();
+
+                // can't reuse MraidBridge methods because MraidController is not initialized yet
+                dummyWebView.loadUrl("javascript:mraidbridge.setState('default');");
+                dummyWebView.loadUrl("javascript:mraidbridge.notifyReadyEvent();");
+
             }
 
             @Override
@@ -79,7 +82,7 @@ public void onReceivedError(final WebView view, final int errorCode,
                 htmlData, "text/html", "UTF-8", null);
     }
 
-    public static void start(@NonNull Context context, @Nullable AdReport adreport, @NonNull String htmlData, long broadcastIdentifier) {
+    public static void start(@NonNull Context context, @Nullable AdReport adreport, @Nullable String htmlData, long broadcastIdentifier) {
         Intent intent = createIntent(context, adreport, htmlData, broadcastIdentifier);
         try {
             context.startActivity(intent);
@@ -90,7 +93,7 @@ public static void start(@NonNull Context context, @Nullable AdReport adreport,
 
     @VisibleForTesting
     protected static Intent createIntent(@NonNull Context context, @Nullable AdReport adReport,
-            @NonNull String htmlData, long broadcastIdentifier) {
+            @Nullable String htmlData, long broadcastIdentifier) {
         Intent intent = new Intent(context, MraidActivity.class);
         intent.putExtra(HTML_RESPONSE_BODY_KEY, htmlData);
         intent.putExtra(BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
@@ -123,8 +126,10 @@ public void onLoaded(View view) {
             @Override
             public void onFailedToLoad() {
                 MoPubLog.d("MraidActivity failed to load. Finishing the activity");
-                broadcastAction(MraidActivity.this, getBroadcastIdentifier(),
-                        ACTION_INTERSTITIAL_FAIL);
+                if (getBroadcastIdentifier() != null) {
+                    broadcastAction(MraidActivity.this, getBroadcastIdentifier(),
+                            ACTION_INTERSTITIAL_FAIL);
+                }
                 finish();
             }
 
@@ -140,8 +145,10 @@ public void onExpand() {
 
             @Override
             public void onOpen() {
-                broadcastAction(MraidActivity.this, getBroadcastIdentifier(),
-                        ACTION_INTERSTITIAL_CLICK);
+                if (getBroadcastIdentifier()!= null) {
+                    broadcastAction(MraidActivity.this, getBroadcastIdentifier(),
+                            ACTION_INTERSTITIAL_CLICK);
+                }
             }
         });
 
@@ -164,13 +171,13 @@ public void useCustomCloseChanged(boolean useCustomClose) {
     @Override
     public void onCreate(@Nullable Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
-        broadcastAction(this, getBroadcastIdentifier(), ACTION_INTERSTITIAL_SHOW);
-
-        if (VERSION.SDK_INT >= VERSION_CODES.ICE_CREAM_SANDWICH) {
-            getWindow().setFlags(
-                    WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,
-                    WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
+        if (getBroadcastIdentifier()!= null) {
+            broadcastAction(this, getBroadcastIdentifier(), ACTION_INTERSTITIAL_SHOW);
         }
+
+        getWindow().setFlags(
+                WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,
+                WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
     }
 
     @Override
@@ -195,7 +202,9 @@ protected void onDestroy() {
             mMraidController.destroy();
         }
 
-        broadcastAction(this, getBroadcastIdentifier(), ACTION_INTERSTITIAL_DISMISS);
+        if (getBroadcastIdentifier()!= null) {
+            broadcastAction(this, getBroadcastIdentifier(), ACTION_INTERSTITIAL_DISMISS);
+        }
         super.onDestroy();
     }
 
diff --git a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/VastVideoInterstitial.java b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/VastVideoInterstitial.java
index 293336d2..d990c8e6 100644
--- a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/VastVideoInterstitial.java
+++ b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mobileads/VastVideoInterstitial.java
@@ -1,9 +1,16 @@
 package com.mopub.mobileads;
 
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+
 import com.mopub.common.CacheService;
 import com.mopub.common.DataKeys;
+import com.mopub.common.logging.MoPubLog;
 import com.mopub.mobileads.factories.VastManagerFactory;
 
+import org.json.JSONException;
+import org.json.JSONObject;
+
 import java.util.Map;
 
 class VastVideoInterstitial extends ResponseBodyInterstitial implements VastManager.VastManagerListener {
@@ -11,10 +18,23 @@
     private String mVastResponse;
     private VastManager mVastManager;
     private VastVideoConfig mVastVideoConfig;
+    @Nullable private JSONObject mVideoTrackers;
 
     @Override
     protected void extractExtras(Map<String, String> serverExtras) {
         mVastResponse = serverExtras.get(DataKeys.HTML_RESPONSE_BODY_KEY);
+
+        final String videoTrackers = serverExtras.get(DataKeys.VIDEO_TRACKERS_KEY);
+        if (TextUtils.isEmpty(videoTrackers)) {
+            return;
+        }
+
+        try {
+            mVideoTrackers = new JSONObject(videoTrackers);
+        } catch (JSONException e) {
+            MoPubLog.d("Failed to parse video trackers to JSON: " + videoTrackers, e);
+            mVideoTrackers = null;
+        }
     }
 
     @Override
@@ -52,11 +72,13 @@ public void onInvalidate() {
     @Override
     public void onVastVideoConfigurationPrepared(final VastVideoConfig vastVideoConfig) {
         if (vastVideoConfig == null) {
-            mCustomEventInterstitialListener.onInterstitialFailed(MoPubErrorCode.VIDEO_DOWNLOAD_ERROR);
+            mCustomEventInterstitialListener
+                    .onInterstitialFailed(MoPubErrorCode.VIDEO_DOWNLOAD_ERROR);
             return;
         }
 
         mVastVideoConfig = vastVideoConfig;
+        mVastVideoConfig.addVideoTrackers(mVideoTrackers);
         mCustomEventInterstitialListener.onInterstitialLoaded();
     }
 
diff --git a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mraid/MraidInterstitial.java b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mraid/MraidInterstitial.java
index f7e1ae39..b0f5b08d 100644
--- a/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mraid/MraidInterstitial.java
+++ b/mopub-sdk/mopub-sdk-interstitial/src/main/java/com/mopub/mraid/MraidInterstitial.java
@@ -2,6 +2,7 @@
 
 
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 
 import com.mopub.mobileads.MraidActivity;
 import com.mopub.mobileads.ResponseBodyInterstitial;
@@ -11,7 +12,7 @@
 import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
 
 class MraidInterstitial extends ResponseBodyInterstitial {
-    private String mHtmlData;
+    @Nullable protected String mHtmlData;
 
     @Override
     protected void extractExtras(Map<String, String> serverExtras) {
diff --git a/mopub-sdk/mopub-sdk-native-video/src/main/java/com/mopub/nativeads/MediaLayout.java b/mopub-sdk/mopub-sdk-native-video/src/main/java/com/mopub/nativeads/MediaLayout.java
index 8cfd81bc..43de589e 100644
--- a/mopub-sdk/mopub-sdk-native-video/src/main/java/com/mopub/nativeads/MediaLayout.java
+++ b/mopub-sdk/mopub-sdk-native-video/src/main/java/com/mopub/nativeads/MediaLayout.java
@@ -1,12 +1,10 @@
 package com.mopub.nativeads;
 
-import android.annotation.TargetApi;
 import android.content.Context;
 import android.graphics.Color;
 import android.graphics.SurfaceTexture;
 import android.graphics.drawable.Drawable;
 import android.graphics.drawable.GradientDrawable;
-import android.os.Build;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.util.AttributeSet;
@@ -24,7 +22,6 @@
 import com.mopub.mobileads.VastVideoProgressBarWidget;
 import com.mopub.mobileads.resource.DrawableConstants.GradientStrip;
 
-@TargetApi(Build.VERSION_CODES.JELLY_BEAN)
 public class MediaLayout extends RelativeLayout {
     public enum Mode { IMAGE, PLAYING, LOADING, BUFFERING, PAUSED, FINISHED }
     public enum MuteState { MUTED, UNMUTED }
diff --git a/mopub-sdk/mopub-sdk-native-video/src/main/java/com/mopub/nativeads/MoPubCustomEventVideoNative.java b/mopub-sdk/mopub-sdk-native-video/src/main/java/com/mopub/nativeads/MoPubCustomEventVideoNative.java
index a669f735..c85dd567 100644
--- a/mopub-sdk/mopub-sdk-native-video/src/main/java/com/mopub/nativeads/MoPubCustomEventVideoNative.java
+++ b/mopub-sdk/mopub-sdk-native-video/src/main/java/com/mopub/nativeads/MoPubCustomEventVideoNative.java
@@ -1,10 +1,8 @@
 package com.mopub.nativeads;
 
-import android.annotation.TargetApi;
 import android.content.Context;
 import android.graphics.SurfaceTexture;
 import android.media.AudioManager;
-import android.os.Build;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
@@ -27,10 +25,10 @@
 import com.mopub.mobileads.VideoViewabilityTracker;
 import com.mopub.mobileads.factories.VastManagerFactory;
 import com.mopub.nativeads.NativeVideoController.NativeVideoProgressRunnable;
-import com.mopub.nativeads.events.NativeAdType;
 import com.mopub.network.TrackingRequest;
 
 import org.json.JSONArray;
+import org.json.JSONException;
 import org.json.JSONObject;
 
 import java.lang.ref.WeakReference;
@@ -49,895 +47,906 @@
 import static com.mopub.common.DataKeys.MAX_BUFFER_MS;
 import static com.mopub.common.DataKeys.PAUSE_VISIBLE_PERCENT;
 import static com.mopub.common.DataKeys.PLAY_VISIBLE_PERCENT;
+import static com.mopub.common.DataKeys.VIDEO_TRACKERS_KEY;
 import static com.mopub.nativeads.NativeImageHelper.preCacheImages;
 import static com.mopub.nativeads.NativeVideoController.VisibilityTrackingEvent;
 
-@TargetApi(Build.VERSION_CODES.JELLY_BEAN)
 public class MoPubCustomEventVideoNative extends CustomEventNative {
 
-	@Override
-	protected void loadNativeAd(@NonNull final Context context,
-	                            @NonNull final CustomEventNativeListener customEventNativeListener,
-	                            @NonNull final Map<String, Object> localExtras,
-	                            @NonNull final Map<String, String> serverExtras) {
-		setCustomEventNativeListener(customEventNativeListener);
-		setNativeAdType(NativeAdType.Mopub);
-
-		final Object json = localExtras.get(JSON_BODY_KEY);
-		// null or non-JSONObjects should not be passed in localExtras as JSON_BODY_KEY
-		if (!(json instanceof JSONObject)) {
-			notifyLoadFailed(NativeErrorCode.INVALID_RESPONSE);
-			return;
-		}
-
-		final Object eventDetailsObject = localExtras.get(EVENT_DETAILS);
-		final EventDetails eventDetails = eventDetailsObject instanceof EventDetails ?
-				(EventDetails) eventDetailsObject : null;
-
-		final VideoResponseHeaders videoResponseHeaders = new VideoResponseHeaders(serverExtras);
-		if (!videoResponseHeaders.hasValidHeaders()) {
-			notifyLoadFailed(NativeErrorCode.INVALID_RESPONSE);
-			return;
-		}
-
-		final Object clickTrackingUrlFromHeaderObject =
-				localExtras.get(DataKeys.CLICK_TRACKING_URL_KEY);
-		// Ensure click tracking url is a non-empty String
-		if (!(clickTrackingUrlFromHeaderObject instanceof String) ||
-				TextUtils.isEmpty((String) clickTrackingUrlFromHeaderObject)) {
-			notifyLoadFailed(NativeErrorCode.UNSPECIFIED);
-			return;
-		}
-
-		final String clickTrackingUrlFromHeader = (String) clickTrackingUrlFromHeaderObject;
-		final MoPubVideoNativeAd videoNativeAd = new MoPubVideoNativeAd(context, (JSONObject) json,
-				this, videoResponseHeaders, eventDetails,
-				clickTrackingUrlFromHeader);
-		try {
-			videoNativeAd.loadAd();
-		} catch (IllegalArgumentException e) {
-			notifyLoadFailed(NativeErrorCode.UNSPECIFIED);
-		}
-	}
-
-	@TargetApi(Build.VERSION_CODES.JELLY_BEAN)
-	public static class MoPubVideoNativeAd extends VideoNativeAd
-			implements VastManager.VastManagerListener, NativeVideoProgressRunnable.ProgressListener,
-			AudioManager.OnAudioFocusChangeListener {
-
-		enum Parameter {
-			IMPRESSION_TRACKER("imptracker", true),
-			CLICK_TRACKER("clktracker", true),
-			TITLE("title", false),
-			TEXT("text", false),
-			IMAGE_URL("mainimage", false),
-			ICON_URL("iconimage", false),
-			CLICK_DESTINATION("clk", false),
-			FALLBACK("fallback", false),
-			CALL_TO_ACTION("ctatext", false),
-			VAST_VIDEO("video", false);
-
-			@NonNull final String mName;
-			final boolean mRequired;
-
-			Parameter(@NonNull final String name, final boolean required) {
-				Preconditions.checkNotNull(name);
-				mName = name;
-				mRequired = required;
-			}
-
-			@Nullable
-			static Parameter from(@NonNull final String name) {
-				Preconditions.checkNotNull(name);
-				for (final Parameter parameter : values()) {
-					if (parameter.mName.equals(name)) {
-						return parameter;
-					}
-				}
-
-				return null;
-			}
-
-			@NonNull
-			@VisibleForTesting
-			static final Set<String> requiredKeys = new HashSet<String>();
-
-			static {
-				for (final Parameter parameter : values()) {
-					if (parameter.mRequired) {
-						requiredKeys.add(parameter.mName);
-					}
-				}
-			}
-		}
-
-		public enum VideoState {
-			CREATED, LOADING, BUFFERING, PAUSED, PLAYING, PLAYING_MUTED, ENDED, FAILED_LOAD
-		}
-
-		static final String PRIVACY_INFORMATION_CLICKTHROUGH_URL = "https://www.mopub.com/optout/";
-
-		@NonNull private final Context mContext;
-		@NonNull private final JSONObject mJsonObject;
-		@NonNull private VideoState mVideoState;
-		@NonNull private final VisibilityTracker mVideoVisibleTracking;
-		@NonNull private final String mMoPubClickTrackingUrl;
-		@NonNull private final VideoResponseHeaders mVideoResponseHeaders;
-		@NonNull private final NativeVideoControllerFactory mNativeVideoControllerFactory;
-		@Nullable private NativeVideoController mNativeVideoController;
-
-		// We need to hold a reference to the VastManager because internal VAST classes
-		// hold only weak refs to this.
-		@NonNull private final VastManager mVastManager;
-		@Nullable VastVideoConfig mVastVideoConfig;
-		@Nullable private MediaLayout mMediaLayout;
-		@Nullable private View mRootView;
-		@Nullable private final EventDetails mEventDetails;
-
-		private final long mId;
-		private boolean mNeedsSeek;
-		private boolean mNeedsPrepare;
-		private boolean mPauseCanBeTracked = false;
-		private boolean mResumeCanBeTracked = false;
-
-		// These variables influence video state.
-		private int mLatestVideoControllerState;
-		private boolean mError;
-		private boolean mLatestVisibility;
-		private boolean mMuted;
-		private boolean mEnded;
-
-		public MoPubVideoNativeAd(
-				@NonNull final Context context,
-				@NonNull final JSONObject jsonObject,
-				@NonNull final CustomEventNative customEventNative,
-				@NonNull final VideoResponseHeaders videoResponseHeaders,
-				@Nullable final EventDetails eventDetails,
-				@NonNull final String clickTrackingUrl) {
-			this(context, jsonObject, customEventNative, videoResponseHeaders,
-					new VisibilityTracker(context), new NativeVideoControllerFactory(),
-					eventDetails, clickTrackingUrl, VastManagerFactory.create(context.getApplicationContext(), false));
-
-		}
-
-		@VisibleForTesting
-		MoPubVideoNativeAd(
-				@NonNull final Context context,
-				@NonNull final JSONObject jsonObject,
-				@NonNull final CustomEventNative customEventNative,
-				@NonNull final VideoResponseHeaders videoResponseHeaders,
-				@NonNull final VisibilityTracker visibilityTracker,
-				@NonNull final NativeVideoControllerFactory nativeVideoControllerFactory,
-				@Nullable final EventDetails eventDetails,
-				@NonNull final String clickTrackingUrl,
-				@NonNull final VastManager vastManager) {
-			Preconditions.checkNotNull(context);
-			Preconditions.checkNotNull(jsonObject);
-			Preconditions.checkNotNull(customEventNative);
-			Preconditions.checkNotNull(videoResponseHeaders);
-			Preconditions.checkNotNull(visibilityTracker);
-			Preconditions.checkNotNull(nativeVideoControllerFactory);
-			Preconditions.checkNotNull(clickTrackingUrl);
-			Preconditions.checkNotNull(vastManager);
-			setEventNative(customEventNative);
-			mContext = context.getApplicationContext();
-			mJsonObject = jsonObject;
-			mVideoResponseHeaders = videoResponseHeaders;
-
-			mNativeVideoControllerFactory = nativeVideoControllerFactory;
-			mMoPubClickTrackingUrl = clickTrackingUrl;
-
-			mEventDetails = eventDetails;
-
-			mId = Utils.generateUniqueId();
-			mNeedsSeek = true;
-			mVideoState = VideoState.CREATED;
-
-			mNeedsPrepare = true;
-			mLatestVideoControllerState = NativeVideoController.STATE_IDLE;
-			mMuted = true;
-			mVideoVisibleTracking = visibilityTracker;
-			mVideoVisibleTracking.setVisibilityTrackerListener(new VisibilityTracker
-					.VisibilityTrackerListener() {
-				@Override
-				public void onVisibilityChanged(final List<View> visibleViews,
-				                                final List<View> invisibleViews) {
-					if (!visibleViews.isEmpty() && !mLatestVisibility) { // State transition
-						mLatestVisibility = true;
-						maybeChangeState();
-					} else if (!invisibleViews.isEmpty() && mLatestVisibility) { // state transition
-						mLatestVisibility = false;
-						maybeChangeState();
-					}
-				}
-			});
-			mVastManager = vastManager;
-		}
-
-		@Override
-		protected void loadAd() throws IllegalArgumentException {
-			if (!containsRequiredKeys(mJsonObject)) {
-				throw new IllegalArgumentException("JSONObject did not contain required keys.");
-			}
-
-			super.loadAd();
-			final Iterator<String> keys = mJsonObject.keys();
-			while (keys.hasNext()) {
-				final String key = keys.next();
-				final Parameter parameter = Parameter.from(key);
-
-				if (parameter != null) {
-					try {
-						addInstanceVariable(parameter, mJsonObject.opt(key));
-					} catch (ClassCastException e) {
-						throw new IllegalArgumentException("JSONObject key (" + key
-								+ ") contained unexpected value.");
-					}
-				} else {
-					addExtra(key, mJsonObject.opt(key));
-				}
-			}
-			setPrivacyInformationIconClickThroughUrl(PRIVACY_INFORMATION_CLICKTHROUGH_URL);
-
-			preCacheImages(mContext, getAllImageUrls(), new NativeImageHelper.ImageListener() {
-				@Override
-				public void onImagesCached() {
-					mVastManager.prepareVastVideoConfiguration(getVastVideo(),
-							MoPubVideoNativeAd.this,
-							mEventDetails == null ? null : mEventDetails.getDspCreativeId(),
-							mContext);
-				}
-
-				@Override
-				public void onImagesFailedToCache(final NativeErrorCode errorCode) {
-					notifyLoadFailed(errorCode);
-				}
-			});
-		}
-
-		@Override
-		public void onVastVideoConfigurationPrepared(@Nullable VastVideoConfig vastVideoConfig) {
-			if (vastVideoConfig == null) {
-				notifyLoadFailed(NativeErrorCode.INVALID_RESPONSE);
-				return;
-			}
-
-			final List<NativeVideoController.VisibilityTrackingEvent> visibilityTrackingEvents =
-					new ArrayList<VisibilityTrackingEvent>();
-
-			// Custom visibility tracking event from http response headers
-			final VisibilityTrackingEvent visibilityTrackingEvent = new VisibilityTrackingEvent();
-			visibilityTrackingEvent.strategy = new HeaderVisibilityStrategy(this);
-			visibilityTrackingEvent.minimumPercentageVisible =
-					mVideoResponseHeaders.getImpressionMinVisiblePercent();
-			visibilityTrackingEvent.totalRequiredPlayTimeMs =
-					mVideoResponseHeaders.getImpressionVisibleMs();
-			visibilityTrackingEvents.add(visibilityTrackingEvent);
-
-			// Visibility tracking event from http response Vast payload
-			mVastVideoConfig = vastVideoConfig;
-			final VideoViewabilityTracker vastVideoViewabilityTracker =
-					mVastVideoConfig.getVideoViewabilityTracker();
-			if (vastVideoViewabilityTracker != null) {
-				final VisibilityTrackingEvent vastVisibilityTrackingEvent =
-						new VisibilityTrackingEvent();
-				vastVisibilityTrackingEvent.strategy =
-						new PayloadVisibilityStrategy(mContext,
-								vastVideoViewabilityTracker.getTrackingUrl());
-				vastVisibilityTrackingEvent.minimumPercentageVisible =
-						vastVideoViewabilityTracker.getPercentViewable();
-				vastVisibilityTrackingEvent.totalRequiredPlayTimeMs =
-						vastVideoViewabilityTracker.getViewablePlaytimeMS();
-				visibilityTrackingEvents.add(vastVisibilityTrackingEvent);
-			}
-
-			Set<String> clickTrackers = new HashSet<String>();
-			clickTrackers.add(mMoPubClickTrackingUrl);
-			clickTrackers.addAll(getClickTrackers());
-
-			final ArrayList<VastTracker> vastClickTrackers = new ArrayList<VastTracker>();
-			for (String clickTrackingUrl : clickTrackers) {
-				vastClickTrackers.add(new VastTracker(clickTrackingUrl, false));
-			}
-			mVastVideoConfig.addClickTrackers(vastClickTrackers);
-
-			// Always use click destination URL from JSON "clk" value instead of from VAST document
-			mVastVideoConfig.setClickThroughUrl(getClickDestinationUrl());
-
-			mNativeVideoController = mNativeVideoControllerFactory.createForId(
-					mId, mContext, visibilityTrackingEvents, mVastVideoConfig, mEventDetails);
-
-			notifyAdLoaded();
-		}
-
-		private boolean containsRequiredKeys(@NonNull final JSONObject jsonObject) {
-			Preconditions.checkNotNull(jsonObject);
-
-			final Set<String> keys = new HashSet<String>();
-			final Iterator<String> jsonKeys = jsonObject.keys();
-			while (jsonKeys.hasNext()) {
-				keys.add(jsonKeys.next());
-			}
-
-			return keys.containsAll(Parameter.requiredKeys);
-		}
-
-		private void addInstanceVariable(@NonNull final Parameter key,
-		                                 @Nullable final Object value) throws ClassCastException {
-			Preconditions.checkNotNull(key);
-			Preconditions.checkNotNull(value);
-
-			try {
-				switch (key) {
-					case IMPRESSION_TRACKER:
-						addImpressionTrackers(value);
-						break;
-					case TITLE:
-						setTitle((String) value);
-						break;
-					case TEXT:
-						setText((String) value);
-						break;
-					case IMAGE_URL:
-						setMainImageUrl((String) value);
-						break;
-					case ICON_URL:
-						setIconImageUrl((String) value);
-						break;
-					case CLICK_DESTINATION:
-						setClickDestinationUrl((String) value);
-						break;
-					case CLICK_TRACKER:
-						parseClickTrackers(value);
-						break;
-					case CALL_TO_ACTION:
-						setCallToAction((String) value);
-						break;
-					case VAST_VIDEO:
-						setVastVideo((String) value);
-						break;
-					default:
-						MoPubLog.d("Unable to add JSON key to internal mapping: " + key.mName);
-						break;
-				}
-			} catch (ClassCastException e) {
-				if (!key.mRequired) {
-					MoPubLog.d("Ignoring class cast exception for optional key: " + key.mName);
-				} else {
-					throw e;
-				}
-			}
-		}
-
-		private void parseClickTrackers(@NonNull final Object clickTrackers) {
-			if (clickTrackers instanceof JSONArray) {
-				addClickTrackers(clickTrackers);
-			} else {
-				addClickTracker((String) clickTrackers);
-			}
-		}
-
-		@Override
-		public void render(@NonNull MediaLayout mediaLayout) {
-			Preconditions.checkNotNull(mediaLayout);
-
-			mVideoVisibleTracking.addView(mRootView,
-					mediaLayout,
-					mVideoResponseHeaders.getPlayVisiblePercent(),
-					mVideoResponseHeaders.getPauseVisiblePercent());
-
-			mMediaLayout = mediaLayout;
-			mMediaLayout.initForVideo();
-
-			mMediaLayout.setSurfaceTextureListener(new TextureView.SurfaceTextureListener() {
-				@Override
-				public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int
-						height) {
-
-					mNativeVideoController.setListener(MoPubVideoNativeAd.this);
-					mNativeVideoController.setOnAudioFocusChangeListener(MoPubVideoNativeAd.this);
-					mNativeVideoController.setProgressListener(MoPubVideoNativeAd.this);
-					mNativeVideoController.setTextureView(mMediaLayout.getTextureView());
-					mMediaLayout.resetProgress();
-
-					// If we're returning to an ended video, make a note of that so we don't flash
-					// a bunch of UI changes while we prepare the data.
-					final long duration = mNativeVideoController.getDuration();
-					final long currentPosition = mNativeVideoController.getCurrentPosition();
-					if (mLatestVideoControllerState == NativeVideoController.STATE_ENDED
-							|| (duration > 0 && duration - currentPosition < NativeVideoController.RESUME_FINISHED_THRESHOLD)) {
-						mEnded = true;
-					}
-
-					if (mNeedsPrepare) {
-						mNeedsPrepare = false;
-						mNativeVideoController.prepare(MoPubVideoNativeAd.this);
-					}
-
-					mNeedsSeek = true;
-					maybeChangeState();
-				}
-
-				@Override
-				public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width,
-				                                        int height) {
-				}
-
-				@Override
-				public boolean onSurfaceTextureDestroyed(final SurfaceTexture surface) {
-					mNeedsPrepare = true;
-					mNativeVideoController.release(MoPubVideoNativeAd.this);
-					applyState(VideoState.PAUSED);
-					return true;
-				}
-
-				@Override
-				public void onSurfaceTextureUpdated(SurfaceTexture surface) {
-				}
-			});
-
-			mMediaLayout.setPlayButtonClickListener(new View.OnClickListener() {
-				@Override
-				public void onClick(View v) {
-					mMediaLayout.resetProgress();
-					mNativeVideoController.seekTo(0);
-					mEnded = false;
-					mNeedsSeek = false;
-				}
-			});
-
-			mMediaLayout.setMuteControlClickListener(new View.OnClickListener() {
-				@Override
-				public void onClick(final View v) {
-					mMuted = !mMuted;
-					maybeChangeState();
-				}
-			});
-
-			mMediaLayout.setOnClickListener(new View.OnClickListener() {
-				@Override
-				public void onClick(final View v) {
-					prepareToLeaveView();
-					mNativeVideoController.triggerImpressionTrackers();
-					MraidVideoPlayerActivity.startNativeVideo(mContext, mId, mVastVideoConfig);
-				}
-			});
-
-			if (mNativeVideoController.getPlaybackState() == NativeVideoController.STATE_CLEARED) {
-				mNativeVideoController.prepare(this);
-			}
-
-			applyState(VideoState.PAUSED);
-		}
-
-		// Lifecycle Handlers
-		@Override
-		public void prepare(@NonNull final View view) {
-			Preconditions.checkNotNull(view);
-			mRootView = view;
-			mRootView.setOnClickListener(new View.OnClickListener() {
-				@Override
-				public void onClick(View v) {
-					prepareToLeaveView();
-					// No need to call notifyAdClicked since handleCtaClick does clickTracking
-					mNativeVideoController.triggerImpressionTrackers();
-					mNativeVideoController.handleCtaClick(mContext);
-				}
-			});
-		}
-
-		@Override
-		public void clear(@NonNull final View view) {
-			Preconditions.checkNotNull(view);
-			mNativeVideoController.clear();
-			cleanUpMediaLayout();
-		}
-
-		@Override
-		public void destroy() {
-			cleanUpMediaLayout();
-			mNativeVideoController.setPlayWhenReady(false);
-			mNativeVideoController.release(this);
-			NativeVideoController.remove(mId);
-			mVideoVisibleTracking.destroy();
-		}
-
-		@Override
-		public void onStateChanged(final boolean playWhenReady, final int playbackState) {
-			mLatestVideoControllerState = playbackState;
-			maybeChangeState();
-		}
-
-		@Override
-		public void onError(final Exception e) {
-			MoPubLog.w("Error playing back video.", e);
-			mError = true;
-			maybeChangeState();
-		}
-
-		@Override
-		public void updateProgress(final int progressTenthPercent) {
-			mMediaLayout.updateProgress(progressTenthPercent);
-		}
-
-		@Override
-		public void onAudioFocusChange(int focusChange) {
-			if (focusChange == AudioManager.AUDIOFOCUS_LOSS
-					|| focusChange == AudioManager.AUDIOFOCUS_LOSS_TRANSIENT) {
-				// Mute the video
-				mMuted = true;
-				maybeChangeState();
-			} else if (focusChange == AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK) {
-				// Lower the volume
-				mNativeVideoController.setAudioVolume(0.3f);
-			} else if (focusChange == AudioManager.AUDIOFOCUS_GAIN) {
-				// Resume playback
-				mNativeVideoController.setAudioVolume(1.0f);
-				maybeChangeState();
-			}
-		}
-
-		private void cleanUpMediaLayout() {
-			// When clearing, we also clear medialayout references so if we're rendered again
-			// with the same view, we reset the video state correctly.
-			if (mMediaLayout != null) {
-				mMediaLayout.setMode(MediaLayout.Mode.IMAGE);
-				mMediaLayout.setSurfaceTextureListener(null);
-				mMediaLayout.setPlayButtonClickListener(null);
-				mMediaLayout.setMuteControlClickListener(null);
-				mMediaLayout.setOnClickListener(null);
-				mVideoVisibleTracking.removeView(mMediaLayout);
-				mMediaLayout = null;
-			}
-		}
-
-		private void prepareToLeaveView() {
-			mNeedsSeek = true;
-			mNeedsPrepare = true;
-
-			// Clean up any references to this class when storing the NativeVideoController
-			// in a static location and starting a new activity
-			mNativeVideoController.setListener(null);
-			mNativeVideoController.setOnAudioFocusChangeListener(null);
-			mNativeVideoController.setProgressListener(null);
-			mNativeVideoController.clear();
-
-			applyState(VideoState.PAUSED, true);
-		}
-
-		private void maybeChangeState() {
-			VideoState newState = mVideoState;
-
-			if (mError) {
-				newState = VideoState.FAILED_LOAD;
-			} else if (mEnded) {
-				newState = VideoState.ENDED;
-			} else {
-				if (mLatestVideoControllerState == NativeVideoController.STATE_PREPARING
-						|| mLatestVideoControllerState == NativeVideoController.STATE_IDLE) {
-					newState = VideoState.LOADING;
-				} else if (mLatestVideoControllerState == NativeVideoController.STATE_BUFFERING) {
-					newState = VideoState.BUFFERING;
-				} else if (mLatestVideoControllerState == NativeVideoController.STATE_ENDED) {
-					mEnded = true;
-					newState = VideoState.ENDED;
-				} else if (mLatestVideoControllerState == NativeVideoController.STATE_READY) {
-					if (mLatestVisibility) {
-						newState = mMuted ? VideoState.PLAYING_MUTED : VideoState.PLAYING;
-					} else {
-						newState = VideoState.PAUSED;
-					}
-				}
-			}
-
-			applyState(newState);
-		}
-
-		@VisibleForTesting
-		void applyState(@NonNull final VideoState videoState) {
-			applyState(videoState, false);
-		}
-
-		@VisibleForTesting
-		void applyState(@NonNull final VideoState videoState, boolean transitionToFullScreen) {
-			Preconditions.checkNotNull(videoState);
-
-			// Ignore the state change if video player is not ready to take state changes.
-			if (mVastVideoConfig == null || mNativeVideoController == null || mMediaLayout == null) {
-				return;
-			}
-
-			// Check and set mVideoState so any changes we make to exo state don't
-			// trigger a duplicate run of this.
-			if (mVideoState == videoState) {
-				return;
-			}
-			VideoState previousState = mVideoState;
-			mVideoState = videoState;
-
-			switch (videoState) {
-				case FAILED_LOAD:
-					mVastVideoConfig.handleError(mContext, null, 0);
-					mNativeVideoController.setAppAudioEnabled(false);
-					mMediaLayout.setMode(MediaLayout.Mode.IMAGE);
-					// Only log the failed to play event when the video has not started
-					if (previousState != VideoState.PLAYING && previousState != VideoState.PLAYING_MUTED) {
-						MoPubEvents.log(Event.createEventFromDetails(
-								BaseEvent.Name.ERROR_FAILED_TO_PLAY,
-								BaseEvent.Category.NATIVE_VIDEO,
-								BaseEvent.SamplingRate.NATIVE_VIDEO,
-								mEventDetails));
-					}
-					break;
-				case CREATED:
-				case LOADING:
-					mNativeVideoController.setPlayWhenReady(true);
-					mMediaLayout.setMode(MediaLayout.Mode.LOADING);
-					break;
-				case BUFFERING:
-					mNativeVideoController.setPlayWhenReady(true);
-					mMediaLayout.setMode(MediaLayout.Mode.BUFFERING);
-					break;
-				case PAUSED:
-					if (transitionToFullScreen) {
-						// Prevents firing resume trackers when we return from full-screen.
-						mResumeCanBeTracked = false;
-					}
-
-					if (!transitionToFullScreen) {
-						mNativeVideoController.setAppAudioEnabled(false);
-						if (mPauseCanBeTracked) {
-							TrackingRequest.makeVastTrackingHttpRequest(
-									mVastVideoConfig.getPauseTrackers(),
-									null, // VastErrorCode
-									(int) mNativeVideoController.getCurrentPosition(),
-									null, // Asset URI
-									mContext);
-							mPauseCanBeTracked = false;
-							mResumeCanBeTracked = true;
-						}
-					}
-					mNativeVideoController.setPlayWhenReady(false);
-					mMediaLayout.setMode(MediaLayout.Mode.PAUSED);
-					break;
-				case PLAYING:
-					handleResumeTrackersAndSeek(previousState);
-
-					mNativeVideoController.setPlayWhenReady(true);
-					mNativeVideoController.setAudioEnabled(true);
-					mNativeVideoController.setAppAudioEnabled(true);
-					mMediaLayout.setMode(MediaLayout.Mode.PLAYING);
-					mMediaLayout.setMuteState(MediaLayout.MuteState.UNMUTED);
-					break;
-				case PLAYING_MUTED:
-					handleResumeTrackersAndSeek(previousState);
-
-					mNativeVideoController.setPlayWhenReady(true);
-					mNativeVideoController.setAudioEnabled(false);
-					mNativeVideoController.setAppAudioEnabled(false);
-					mMediaLayout.setMode(MediaLayout.Mode.PLAYING);
-					mMediaLayout.setMuteState(MediaLayout.MuteState.MUTED);
-					break;
-				case ENDED:
-					if (mNativeVideoController.hasFinalFrame()) {
-						mMediaLayout.setMainImageDrawable(mNativeVideoController.getFinalFrame());
-					}
-					mPauseCanBeTracked = false;
-					mResumeCanBeTracked = false;
-					mVastVideoConfig.handleComplete(mContext, 0);
-					mNativeVideoController.setAppAudioEnabled(false);
-					mMediaLayout.setMode(MediaLayout.Mode.FINISHED);
-					mMediaLayout.updateProgress(1000);
-					break;
-			}
-		}
-
-		private void handleResumeTrackersAndSeek(VideoState previousState) {
-			if (mResumeCanBeTracked
-					&& previousState != VideoState.PLAYING
-					&& previousState != VideoState.PLAYING_MUTED) {  // If we've played before, fire resume trackers.
-				TrackingRequest.makeVastTrackingHttpRequest(
-						mVastVideoConfig.getResumeTrackers(),
-						null, // VastErrorCode
-						(int) mNativeVideoController.getCurrentPosition(),
-						null, // Asset URI
-						mContext
-				);
-				mResumeCanBeTracked = false;
-			}
-
-			mPauseCanBeTracked = true;
-
-			// We force a seek here to get keyframe rendering in ExtractorSampleSource.
-			if (mNeedsSeek) {
-				mNeedsSeek = false;
-				mNativeVideoController.seekTo(mNativeVideoController.getCurrentPosition());
-			}
-		}
-
-
-		private boolean isImageKey(@Nullable final String name) {
-			return name != null && name.toLowerCase(Locale.US).endsWith("image");
-		}
-
-		@NonNull
-		private List<String> getExtrasImageUrls() {
-			final List<String> extrasBitmapUrls = new ArrayList<String>(getExtras().size());
-			for (final Map.Entry<String, Object> entry : getExtras().entrySet()) {
-				if (isImageKey(entry.getKey()) && entry.getValue() instanceof String) {
-					extrasBitmapUrls.add((String) entry.getValue());
-				}
-			}
-
-			return extrasBitmapUrls;
-		}
-
-		@NonNull
-		private List<String> getAllImageUrls() {
-			final List<String> imageUrls = new ArrayList<String>();
-			if (getMainImageUrl() != null) {
-				imageUrls.add(getMainImageUrl());
-			}
-			if (getIconImageUrl() != null) {
-				imageUrls.add(getIconImageUrl());
-			}
-
-			imageUrls.addAll(getExtrasImageUrls());
-			return imageUrls;
-		}
-
-		@Deprecated
-		@VisibleForTesting
-		boolean needsPrepare() {
-			return mNeedsPrepare;
-		}
-
-		@Deprecated
-		@VisibleForTesting
-		boolean hasEnded() {
-			return mEnded;
-		}
-
-		@Deprecated
-		@VisibleForTesting
-		boolean needsSeek() {
-			return mNeedsSeek;
-		}
-
-		@Deprecated
-		@VisibleForTesting
-		boolean isMuted() {
-			return mMuted;
-		}
-
-		@Deprecated
-		@VisibleForTesting
-		long getId() {
-			return mId;
-		}
-
-		@Deprecated
-		@VisibleForTesting
-		VideoState getVideoState() {
-			return mVideoState;
-		}
-
-		@Deprecated
-		@VisibleForTesting
-		void setLatestVisibility(boolean latestVisibility) {
-			mLatestVisibility = latestVisibility;
-		}
-
-		@Deprecated
-		@VisibleForTesting
-		void setMuted(boolean muted) {
-			mMuted = muted;
-		}
-
-		@Deprecated
-		@VisibleForTesting
-		MediaLayout getMediaLayout() {
-			return mMediaLayout;
-		}
-	}
-
-	@VisibleForTesting
-	@TargetApi(Build.VERSION_CODES.JELLY_BEAN)
-	static class HeaderVisibilityStrategy implements VisibilityTrackingEvent.OnTrackedStrategy {
-		@NonNull private final WeakReference<MoPubVideoNativeAd> mMoPubVideoNativeAd;
-
-		HeaderVisibilityStrategy(@NonNull final MoPubVideoNativeAd moPubVideoNativeAd) {
-			mMoPubVideoNativeAd = new WeakReference<MoPubVideoNativeAd>(moPubVideoNativeAd);
-		}
-
-		@Override
-		public void execute() {
-			final MoPubVideoNativeAd moPubVideoNativeAd = mMoPubVideoNativeAd.get();
-			if (moPubVideoNativeAd != null) {
-				moPubVideoNativeAd.notifyAdImpressed();
-			}
-		}
-	}
-
-	@VisibleForTesting
-	@TargetApi(Build.VERSION_CODES.JELLY_BEAN)
-	static class PayloadVisibilityStrategy implements VisibilityTrackingEvent.OnTrackedStrategy {
-		@NonNull private final Context mContext;
-		@NonNull private final String mUrl;
-
-		PayloadVisibilityStrategy(@NonNull final Context context, @NonNull final String url) {
-			mContext = context.getApplicationContext();
-			mUrl = url;
-		}
-
-		@Override
-		public void execute() {
-			TrackingRequest.makeTrackingHttpRequest(mUrl, mContext);
-		}
-	}
-
-	/**
-	 * Created purely for the purpose of mocking to ease testing.
-	 */
-	@VisibleForTesting
-	@TargetApi(Build.VERSION_CODES.JELLY_BEAN)
-	static class NativeVideoControllerFactory {
-		public NativeVideoController createForId(final long id,
-		                                         @NonNull final Context context,
-		                                         @NonNull final List<VisibilityTrackingEvent> visibilityTrackingEvents,
-		                                         @NonNull final VastVideoConfig vastVideoConfig,
-		                                         @Nullable final EventDetails eventDetails) {
-			return NativeVideoController.createForId(id, context, visibilityTrackingEvents,
-					vastVideoConfig, eventDetails);
-		}
-	}
-
-	@VisibleForTesting
-	@TargetApi(Build.VERSION_CODES.JELLY_BEAN)
-	static class VideoResponseHeaders {
-		private boolean mHeadersAreValid;
-		private int mPlayVisiblePercent;
-		private int mPauseVisiblePercent;
-		private int mImpressionMinVisiblePercent;
-		private int mImpressionVisibleMs;
-		private int mMaxBufferMs;
-
-		VideoResponseHeaders(@NonNull final Map<String, String> serverExtras) {
-			try {
-				mPlayVisiblePercent = Integer.parseInt(serverExtras.get(PLAY_VISIBLE_PERCENT));
-				mPauseVisiblePercent = Integer.parseInt(serverExtras.get(PAUSE_VISIBLE_PERCENT));
-				mImpressionMinVisiblePercent =
-						Integer.parseInt(serverExtras.get(IMPRESSION_MIN_VISIBLE_PERCENT));
-				mImpressionVisibleMs = Integer.parseInt(serverExtras.get(IMPRESSION_VISIBLE_MS));
-				mMaxBufferMs = Integer.parseInt(serverExtras.get(MAX_BUFFER_MS));
-				mHeadersAreValid = true;
-			} catch (NumberFormatException e) {
-				mHeadersAreValid = false;
-			}
-		}
-
-		boolean hasValidHeaders() {
-			return mHeadersAreValid;
-		}
-
-		int getPlayVisiblePercent() {
-			return mPlayVisiblePercent;
-		}
-
-		int getPauseVisiblePercent() {
-			return mPauseVisiblePercent;
-		}
-
-		int getImpressionMinVisiblePercent() {
-			return mImpressionMinVisiblePercent;
-		}
-
-		int getImpressionVisibleMs() {
-			return mImpressionVisibleMs;
-		}
-
-		int getMaxBufferMs() {
-			return mMaxBufferMs;
-		}
-	}
+    @Override
+    protected void loadNativeAd(@NonNull final Context context,
+            @NonNull final CustomEventNativeListener customEventNativeListener,
+            @NonNull final Map<String, Object> localExtras,
+            @NonNull final Map<String, String> serverExtras) {
+        final Object json = localExtras.get(JSON_BODY_KEY);
+        // null or non-JSONObjects should not be passed in localExtras as JSON_BODY_KEY
+        if (!(json instanceof JSONObject)) {
+            customEventNativeListener.onNativeAdFailed(NativeErrorCode.INVALID_RESPONSE);
+            return;
+        }
+
+        final Object eventDetailsObject = localExtras.get(EVENT_DETAILS);
+        final EventDetails eventDetails = eventDetailsObject instanceof EventDetails ?
+                (EventDetails) eventDetailsObject : null;
+
+        final VideoResponseHeaders videoResponseHeaders = new VideoResponseHeaders(serverExtras);
+        if (!videoResponseHeaders.hasValidHeaders()) {
+            customEventNativeListener.onNativeAdFailed(NativeErrorCode.INVALID_RESPONSE);
+            return;
+        }
+
+        final Object clickTrackingUrlFromHeaderObject =
+                localExtras.get(DataKeys.CLICK_TRACKING_URL_KEY);
+        // Ensure click tracking url is a non-empty String
+        if (!(clickTrackingUrlFromHeaderObject instanceof String) ||
+                TextUtils.isEmpty((String) clickTrackingUrlFromHeaderObject)) {
+            customEventNativeListener.onNativeAdFailed(NativeErrorCode.UNSPECIFIED);
+            return;
+        }
+
+        final String clickTrackingUrlFromHeader = (String) clickTrackingUrlFromHeaderObject;
+        final MoPubVideoNativeAd videoNativeAd = new MoPubVideoNativeAd(context, (JSONObject) json,
+                customEventNativeListener, videoResponseHeaders, eventDetails,
+                clickTrackingUrlFromHeader);
+        try {
+            videoNativeAd.loadAd();
+        } catch (IllegalArgumentException e) {
+            customEventNativeListener.onNativeAdFailed(NativeErrorCode.UNSPECIFIED);
+        }
+    }
+
+    public static class MoPubVideoNativeAd extends VideoNativeAd
+            implements VastManager.VastManagerListener, NativeVideoProgressRunnable.ProgressListener,
+            AudioManager.OnAudioFocusChangeListener {
+
+        enum Parameter {
+            IMPRESSION_TRACKER("imptracker", true),
+            CLICK_TRACKER("clktracker", true),
+            TITLE("title", false),
+            TEXT("text", false),
+            IMAGE_URL("mainimage", false),
+            ICON_URL("iconimage", false),
+            CLICK_DESTINATION("clk", false),
+            FALLBACK("fallback", false),
+            CALL_TO_ACTION("ctatext", false),
+            VAST_VIDEO("video", false);
+
+            @NonNull final String mName;
+            final boolean mRequired;
+
+            Parameter(@NonNull final String name, final boolean required) {
+                Preconditions.checkNotNull(name);
+                mName = name;
+                mRequired = required;
+            }
+
+            @Nullable
+            static Parameter from(@NonNull final String name) {
+                Preconditions.checkNotNull(name);
+                for (final Parameter parameter : values()) {
+                    if (parameter.mName.equals(name)) {
+                        return parameter;
+                    }
+                }
+
+                return null;
+            }
+
+            @NonNull
+            @VisibleForTesting
+            static final Set<String> requiredKeys = new HashSet<String>();
+            static {
+                for (final Parameter parameter : values()) {
+                    if (parameter.mRequired) {
+                        requiredKeys.add(parameter.mName);
+                    }
+                }
+            }
+        }
+
+        public enum VideoState {
+            CREATED, LOADING, BUFFERING, PAUSED, PLAYING, PLAYING_MUTED, ENDED, FAILED_LOAD
+        }
+
+        static final String PRIVACY_INFORMATION_CLICKTHROUGH_URL = "https://www.mopub.com/optout/";
+
+        @NonNull private final Context mContext;
+        @NonNull private final JSONObject mJsonObject;
+        @NonNull private VideoState mVideoState;
+        @NonNull private final VisibilityTracker mVideoVisibleTracking;
+        @NonNull private final String mMoPubClickTrackingUrl;
+        @NonNull private final CustomEventNativeListener mCustomEventNativeListener;
+        @NonNull private final VideoResponseHeaders mVideoResponseHeaders;
+        @NonNull private final NativeVideoControllerFactory mNativeVideoControllerFactory;
+        @Nullable private NativeVideoController mNativeVideoController;
+
+        // We need to hold a reference to the VastManager because internal VAST classes
+        // hold only weak refs to this.
+        @NonNull private final VastManager mVastManager;
+        @Nullable VastVideoConfig mVastVideoConfig;
+        @Nullable private MediaLayout mMediaLayout;
+        @Nullable private View mRootView;
+        @Nullable private final EventDetails mEventDetails;
+
+        private final long mId;
+        private boolean mNeedsSeek;
+        private boolean mNeedsPrepare;
+        private boolean mPauseCanBeTracked = false;
+        private boolean mResumeCanBeTracked = false;
+
+        // These variables influence video state.
+        private int mLatestVideoControllerState;
+        private boolean mError;
+        private boolean mLatestVisibility;
+        private boolean mMuted;
+        private boolean mEnded;
+
+        public MoPubVideoNativeAd(
+                @NonNull final Context context,
+                @NonNull final JSONObject jsonObject,
+                @NonNull final CustomEventNativeListener customEventNativeListener,
+                @NonNull final VideoResponseHeaders videoResponseHeaders,
+                @Nullable final EventDetails eventDetails,
+                @NonNull final String clickTrackingUrl) {
+            this(context, jsonObject, customEventNativeListener, videoResponseHeaders,
+                    new VisibilityTracker(context), new NativeVideoControllerFactory(),
+                    eventDetails, clickTrackingUrl, VastManagerFactory.create(context.getApplicationContext(), false));
+        }
+
+        @VisibleForTesting
+        MoPubVideoNativeAd(
+                @NonNull final Context context,
+                @NonNull final JSONObject jsonObject,
+                @NonNull final CustomEventNativeListener customEventNativeListener,
+                @NonNull final VideoResponseHeaders videoResponseHeaders,
+                @NonNull final VisibilityTracker visibilityTracker,
+                @NonNull final NativeVideoControllerFactory nativeVideoControllerFactory,
+                @Nullable final EventDetails eventDetails,
+                @NonNull final String clickTrackingUrl,
+                @NonNull final VastManager vastManager) {
+            Preconditions.checkNotNull(context);
+            Preconditions.checkNotNull(jsonObject);
+            Preconditions.checkNotNull(customEventNativeListener);
+            Preconditions.checkNotNull(videoResponseHeaders);
+            Preconditions.checkNotNull(visibilityTracker);
+            Preconditions.checkNotNull(nativeVideoControllerFactory);
+            Preconditions.checkNotNull(clickTrackingUrl);
+            Preconditions.checkNotNull(vastManager);
+
+            mContext = context.getApplicationContext();
+            mJsonObject = jsonObject;
+            mCustomEventNativeListener = customEventNativeListener;
+            mVideoResponseHeaders = videoResponseHeaders;
+
+            mNativeVideoControllerFactory = nativeVideoControllerFactory;
+            mMoPubClickTrackingUrl = clickTrackingUrl;
+
+            mEventDetails = eventDetails;
+
+            mId = Utils.generateUniqueId();
+            mNeedsSeek = true;
+            mVideoState = VideoState.CREATED;
+
+            mNeedsPrepare = true;
+            mLatestVideoControllerState = NativeVideoController.STATE_IDLE;
+            mMuted = true;
+            mVideoVisibleTracking = visibilityTracker;
+            mVideoVisibleTracking.setVisibilityTrackerListener(new VisibilityTracker
+                    .VisibilityTrackerListener() {
+                @Override
+                public void onVisibilityChanged(final List<View> visibleViews,
+                        final List<View> invisibleViews) {
+                    if (!visibleViews.isEmpty() && !mLatestVisibility) { // State transition
+                        mLatestVisibility = true;
+                        maybeChangeState();
+                    } else if (!invisibleViews.isEmpty() && mLatestVisibility) { // state transition
+                        mLatestVisibility = false;
+                        maybeChangeState();
+                    }
+                }
+            });
+            mVastManager = vastManager;
+        }
+
+        void loadAd() throws IllegalArgumentException {
+            if (!containsRequiredKeys(mJsonObject)) {
+                throw new IllegalArgumentException("JSONObject did not contain required keys.");
+            }
+
+            final Iterator<String> keys = mJsonObject.keys();
+            while (keys.hasNext()) {
+                final String key = keys.next();
+                final Parameter parameter = Parameter.from(key);
+
+                if (parameter != null) {
+                    try {
+                        addInstanceVariable(parameter, mJsonObject.opt(key));
+                    } catch (ClassCastException e) {
+                        throw new IllegalArgumentException("JSONObject key (" + key
+                                + ") contained unexpected value.");
+                    }
+                } else {
+                    addExtra(key, mJsonObject.opt(key));
+                }
+            }
+            setPrivacyInformationIconClickThroughUrl(PRIVACY_INFORMATION_CLICKTHROUGH_URL);
+
+            preCacheImages(mContext, getAllImageUrls(), new NativeImageHelper.ImageListener() {
+                @Override
+                public void onImagesCached() {
+                    mVastManager.prepareVastVideoConfiguration(getVastVideo(),
+                            MoPubVideoNativeAd.this,
+                            mEventDetails == null ? null : mEventDetails.getDspCreativeId(),
+                            mContext);
+                }
+
+                @Override
+                public void onImagesFailedToCache(final NativeErrorCode errorCode) {
+                    mCustomEventNativeListener.onNativeAdFailed(errorCode);
+                }
+            });
+        }
+
+        @Override
+        public void onVastVideoConfigurationPrepared(@Nullable VastVideoConfig vastVideoConfig) {
+            if (vastVideoConfig == null) {
+                mCustomEventNativeListener.onNativeAdFailed(NativeErrorCode.INVALID_RESPONSE);
+                return;
+            }
+
+            final List<NativeVideoController.VisibilityTrackingEvent> visibilityTrackingEvents =
+                    new ArrayList<VisibilityTrackingEvent>();
+
+            // Custom visibility tracking event from http response headers
+            final VisibilityTrackingEvent visibilityTrackingEvent = new VisibilityTrackingEvent();
+            visibilityTrackingEvent.strategy = new HeaderVisibilityStrategy(this);
+            visibilityTrackingEvent.minimumPercentageVisible =
+                    mVideoResponseHeaders.getImpressionMinVisiblePercent();
+            visibilityTrackingEvent.totalRequiredPlayTimeMs =
+                    mVideoResponseHeaders.getImpressionVisibleMs();
+            visibilityTrackingEvents.add(visibilityTrackingEvent);
+
+            // Visibility tracking event from http response Vast payload
+            mVastVideoConfig = vastVideoConfig;
+            final VideoViewabilityTracker vastVideoViewabilityTracker =
+                    mVastVideoConfig.getVideoViewabilityTracker();
+            if (vastVideoViewabilityTracker != null) {
+                final VisibilityTrackingEvent vastVisibilityTrackingEvent =
+                        new VisibilityTrackingEvent();
+                vastVisibilityTrackingEvent.strategy =
+                        new PayloadVisibilityStrategy(mContext,
+                                vastVideoViewabilityTracker.getTrackingUrl());
+                vastVisibilityTrackingEvent.minimumPercentageVisible =
+                        vastVideoViewabilityTracker.getPercentViewable();
+                vastVisibilityTrackingEvent.totalRequiredPlayTimeMs =
+                        vastVideoViewabilityTracker.getViewablePlaytimeMS();
+                visibilityTrackingEvents.add(vastVisibilityTrackingEvent);
+            }
+
+            Set<String> clickTrackers = new HashSet<String>();
+            clickTrackers.add(mMoPubClickTrackingUrl);
+            clickTrackers.addAll(getClickTrackers());
+
+            final ArrayList<VastTracker> vastClickTrackers = new ArrayList<VastTracker>();
+            for (String clickTrackingUrl : clickTrackers) {
+                vastClickTrackers.add(new VastTracker(clickTrackingUrl, false));
+            }
+            mVastVideoConfig.addClickTrackers(vastClickTrackers);
+
+            // Always use click destination URL from JSON "clk" value instead of from VAST document
+            mVastVideoConfig.setClickThroughUrl(getClickDestinationUrl());
+
+            mNativeVideoController = mNativeVideoControllerFactory.createForId(
+                    mId, mContext, visibilityTrackingEvents, mVastVideoConfig, mEventDetails);
+
+            mCustomEventNativeListener.onNativeAdLoaded(this);
+
+            // Internal Video Trackers
+            final JSONObject videoTrackers = mVideoResponseHeaders.getVideoTrackers();
+            if (videoTrackers != null) {
+                mVastVideoConfig.addVideoTrackers(videoTrackers);
+            }
+        }
+
+        private boolean containsRequiredKeys(@NonNull final JSONObject jsonObject) {
+            Preconditions.checkNotNull(jsonObject);
+
+            final Set<String> keys = new HashSet<String>();
+            final Iterator<String> jsonKeys = jsonObject.keys();
+            while (jsonKeys.hasNext()) {
+                keys.add(jsonKeys.next());
+            }
+
+            return keys.containsAll(Parameter.requiredKeys);
+        }
+
+        private void addInstanceVariable(@NonNull final Parameter key,
+                @Nullable final Object value) throws ClassCastException {
+            Preconditions.checkNotNull(key);
+            Preconditions.checkNotNull(value);
+
+            try {
+                switch (key) {
+                    case IMPRESSION_TRACKER:
+                        addImpressionTrackers(value);
+                        break;
+                    case TITLE:
+                        setTitle((String) value);
+                        break;
+                    case TEXT:
+                        setText((String) value);
+                        break;
+                    case IMAGE_URL:
+                        setMainImageUrl((String) value);
+                        break;
+                    case ICON_URL:
+                        setIconImageUrl((String) value);
+                        break;
+                    case CLICK_DESTINATION:
+                        setClickDestinationUrl((String) value);
+                        break;
+                    case CLICK_TRACKER:
+                        parseClickTrackers(value);
+                        break;
+                    case CALL_TO_ACTION:
+                        setCallToAction((String) value);
+                        break;
+                    case VAST_VIDEO:
+                        setVastVideo((String) value);
+                        break;
+                    default:
+                        MoPubLog.d("Unable to add JSON key to internal mapping: " + key.mName);
+                        break;
+                }
+            } catch (ClassCastException e) {
+                if (!key.mRequired) {
+                    MoPubLog.d("Ignoring class cast exception for optional key: " + key.mName);
+                } else {
+                    throw e;
+                }
+            }
+        }
+
+        private void parseClickTrackers(@NonNull final Object clickTrackers) {
+            if (clickTrackers instanceof JSONArray) {
+                addClickTrackers(clickTrackers);
+            } else {
+                addClickTracker((String) clickTrackers);
+            }
+        }
+
+        @Override
+        public void render(@NonNull MediaLayout mediaLayout) {
+            Preconditions.checkNotNull(mediaLayout);
+
+            mVideoVisibleTracking.addView(mRootView,
+                    mediaLayout,
+                    mVideoResponseHeaders.getPlayVisiblePercent(),
+                    mVideoResponseHeaders.getPauseVisiblePercent());
+
+            mMediaLayout = mediaLayout;
+            mMediaLayout.initForVideo();
+
+            mMediaLayout.setSurfaceTextureListener(new TextureView.SurfaceTextureListener() {
+                @Override
+                public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int
+                        height) {
+
+                    mNativeVideoController.setListener(MoPubVideoNativeAd.this);
+                    mNativeVideoController.setOnAudioFocusChangeListener(MoPubVideoNativeAd.this);
+                    mNativeVideoController.setProgressListener(MoPubVideoNativeAd.this);
+                    mNativeVideoController.setTextureView(mMediaLayout.getTextureView());
+                    mMediaLayout.resetProgress();
+
+                    // If we're returning to an ended video, make a note of that so we don't flash
+                    // a bunch of UI changes while we prepare the data.
+                    final long duration = mNativeVideoController.getDuration();
+                    final long currentPosition = mNativeVideoController.getCurrentPosition();
+                    if (mLatestVideoControllerState == NativeVideoController.STATE_ENDED
+                        || (duration > 0 && duration - currentPosition < NativeVideoController.RESUME_FINISHED_THRESHOLD)) {
+                        mEnded = true;
+                    }
+
+                    if (mNeedsPrepare) {
+                        mNeedsPrepare = false;
+                        mNativeVideoController.prepare(MoPubVideoNativeAd.this);
+                    }
+
+                    mNeedsSeek = true;
+                    maybeChangeState();
+                }
+
+                @Override
+                public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width,
+                        int height) { }
+
+                @Override
+                public boolean onSurfaceTextureDestroyed(final SurfaceTexture surface) {
+                    mNeedsPrepare = true;
+                    mNativeVideoController.release(MoPubVideoNativeAd.this);
+                    applyState(VideoState.PAUSED);
+                    return true;
+                }
+
+                @Override
+                public void onSurfaceTextureUpdated(SurfaceTexture surface) { }
+            });
+
+            mMediaLayout.setPlayButtonClickListener(new View.OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    mMediaLayout.resetProgress();
+                    mNativeVideoController.seekTo(0);
+                    mEnded = false;
+                    mNeedsSeek = false;
+                }
+            });
+
+            mMediaLayout.setMuteControlClickListener(new View.OnClickListener() {
+                @Override
+                public void onClick(final View v) {
+                    mMuted = !mMuted;
+                    maybeChangeState();
+                }
+            });
+
+            mMediaLayout.setOnClickListener(new View.OnClickListener() {
+                @Override
+                public void onClick(final View v) {
+                    prepareToLeaveView();
+                    mNativeVideoController.triggerImpressionTrackers();
+                    MraidVideoPlayerActivity.startNativeVideo(mContext, mId, mVastVideoConfig);
+                }
+            });
+
+            if (mNativeVideoController.getPlaybackState() == NativeVideoController.STATE_CLEARED) {
+                mNativeVideoController.prepare(this);
+            }
+
+            applyState(VideoState.PAUSED);
+        }
+
+        // Lifecycle Handlers
+        @Override
+        public void prepare(@NonNull final View view) {
+            Preconditions.checkNotNull(view);
+            mRootView = view;
+            mRootView.setOnClickListener(new View.OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    prepareToLeaveView();
+                    // No need to call notifyAdClicked since handleCtaClick does clickTracking
+                    mNativeVideoController.triggerImpressionTrackers();
+                    mNativeVideoController.handleCtaClick(mContext);
+                }
+            });
+        }
+
+        @Override
+        public void clear(@NonNull final View view) {
+            Preconditions.checkNotNull(view);
+            mNativeVideoController.clear();
+            cleanUpMediaLayout();
+        }
+
+        @Override
+        public void destroy() {
+            cleanUpMediaLayout();
+            mNativeVideoController.setPlayWhenReady(false);
+            mNativeVideoController.release(this);
+            NativeVideoController.remove(mId);
+            mVideoVisibleTracking.destroy();
+        }
+
+        @Override
+        public void onStateChanged(final boolean playWhenReady, final int playbackState) {
+            mLatestVideoControllerState = playbackState;
+            maybeChangeState();
+        }
+
+        @Override
+        public void onError(final Exception e) {
+            MoPubLog.w("Error playing back video.", e);
+            mError = true;
+            maybeChangeState();
+        }
+
+        @Override
+        public void updateProgress(final int progressTenthPercent) {
+            mMediaLayout.updateProgress(progressTenthPercent);
+        }
+
+        @Override
+        public void onAudioFocusChange(int focusChange) {
+            if (focusChange == AudioManager.AUDIOFOCUS_LOSS
+                    || focusChange == AudioManager.AUDIOFOCUS_LOSS_TRANSIENT) {
+                // Mute the video
+                mMuted = true;
+                maybeChangeState();
+            } else if (focusChange == AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK) {
+                // Lower the volume
+                mNativeVideoController.setAudioVolume(0.3f);
+            } else if (focusChange == AudioManager.AUDIOFOCUS_GAIN) {
+                // Resume playback
+                mNativeVideoController.setAudioVolume(1.0f);
+                maybeChangeState();
+            }
+        }
+
+        private void cleanUpMediaLayout() {
+            // When clearing, we also clear medialayout references so if we're rendered again
+            // with the same view, we reset the video state correctly.
+            if (mMediaLayout != null) {
+                mMediaLayout.setMode(MediaLayout.Mode.IMAGE);
+                mMediaLayout.setSurfaceTextureListener(null);
+                mMediaLayout.setPlayButtonClickListener(null);
+                mMediaLayout.setMuteControlClickListener(null);
+                mMediaLayout.setOnClickListener(null);
+                mVideoVisibleTracking.removeView(mMediaLayout);
+                mMediaLayout = null;
+            }
+        }
+
+        private void prepareToLeaveView() {
+            mNeedsSeek = true;
+            mNeedsPrepare = true;
+
+            // Clean up any references to this class when storing the NativeVideoController
+            // in a static location and starting a new activity
+            mNativeVideoController.setListener(null);
+            mNativeVideoController.setOnAudioFocusChangeListener(null);
+            mNativeVideoController.setProgressListener(null);
+            mNativeVideoController.clear();
+
+            applyState(VideoState.PAUSED, true);
+        }
+
+        private void maybeChangeState() {
+            VideoState newState = mVideoState;
+
+            if (mError) {
+                newState = VideoState.FAILED_LOAD;
+            } else if (mEnded) {
+                newState = VideoState.ENDED;
+            } else {
+                if (mLatestVideoControllerState == NativeVideoController.STATE_PREPARING
+                        || mLatestVideoControllerState == NativeVideoController.STATE_IDLE) {
+                    newState = VideoState.LOADING;
+                } else if (mLatestVideoControllerState == NativeVideoController.STATE_BUFFERING) {
+                    newState = VideoState.BUFFERING;
+                } else if (mLatestVideoControllerState == NativeVideoController.STATE_ENDED) {
+                    mEnded = true;
+                    newState = VideoState.ENDED;
+                } else if (mLatestVideoControllerState == NativeVideoController.STATE_READY) {
+                    if (mLatestVisibility) {
+                        newState = mMuted ? VideoState.PLAYING_MUTED : VideoState.PLAYING;
+                    } else {
+                        newState = VideoState.PAUSED;
+                    }
+                }
+            }
+
+            applyState(newState);
+        }
+
+        @VisibleForTesting
+        void applyState(@NonNull final VideoState videoState) {
+            applyState(videoState, false);
+        }
+
+        @VisibleForTesting
+        void applyState(@NonNull final VideoState videoState, boolean transitionToFullScreen) {
+            Preconditions.checkNotNull(videoState);
+
+            // Ignore the state change if video player is not ready to take state changes.
+            if (mVastVideoConfig == null || mNativeVideoController == null || mMediaLayout == null) {
+                return;
+            }
+
+            // Check and set mVideoState so any changes we make to exo state don't
+            // trigger a duplicate run of this.
+            if (mVideoState == videoState) {
+                return;
+            }
+            VideoState previousState = mVideoState;
+            mVideoState = videoState;
+
+            switch (videoState) {
+                case FAILED_LOAD:
+                    mVastVideoConfig.handleError(mContext, null, 0);
+                    mNativeVideoController.setAppAudioEnabled(false);
+                    mMediaLayout.setMode(MediaLayout.Mode.IMAGE);
+                    // Only log the failed to play event when the video has not started
+                    if (previousState != VideoState.PLAYING && previousState != VideoState.PLAYING_MUTED) {
+                        MoPubEvents.log(Event.createEventFromDetails(
+                                BaseEvent.Name.ERROR_FAILED_TO_PLAY,
+                                BaseEvent.Category.NATIVE_VIDEO,
+                                BaseEvent.SamplingRate.NATIVE_VIDEO,
+                                mEventDetails));
+                    }
+                    break;
+                case CREATED:
+                case LOADING:
+                    mNativeVideoController.setPlayWhenReady(true);
+                    mMediaLayout.setMode(MediaLayout.Mode.LOADING);
+                    break;
+                case BUFFERING:
+                    mNativeVideoController.setPlayWhenReady(true);
+                    mMediaLayout.setMode(MediaLayout.Mode.BUFFERING);
+                    break;
+                case PAUSED:
+                    if (transitionToFullScreen) {
+                        // Prevents firing resume trackers when we return from full-screen.
+                        mResumeCanBeTracked = false;
+                    }
+
+                    if (!transitionToFullScreen) {
+                        mNativeVideoController.setAppAudioEnabled(false);
+                        if (mPauseCanBeTracked) {
+                            TrackingRequest.makeVastTrackingHttpRequest(
+                                    mVastVideoConfig.getPauseTrackers(),
+                                    null, // VastErrorCode
+                                    (int) mNativeVideoController.getCurrentPosition(),
+                                    null, // Asset URI
+                                    mContext);
+                            mPauseCanBeTracked = false;
+                            mResumeCanBeTracked = true;
+                        }
+                    }
+                    mNativeVideoController.setPlayWhenReady(false);
+                    mMediaLayout.setMode(MediaLayout.Mode.PAUSED);
+                    break;
+                case PLAYING:
+                    handleResumeTrackersAndSeek(previousState);
+
+                    mNativeVideoController.setPlayWhenReady(true);
+                    mNativeVideoController.setAudioEnabled(true);
+                    mNativeVideoController.setAppAudioEnabled(true);
+                    mMediaLayout.setMode(MediaLayout.Mode.PLAYING);
+                    mMediaLayout.setMuteState(MediaLayout.MuteState.UNMUTED);
+                    break;
+                case PLAYING_MUTED:
+                    handleResumeTrackersAndSeek(previousState);
+
+                    mNativeVideoController.setPlayWhenReady(true);
+                    mNativeVideoController.setAudioEnabled(false);
+                    mNativeVideoController.setAppAudioEnabled(false);
+                    mMediaLayout.setMode(MediaLayout.Mode.PLAYING);
+                    mMediaLayout.setMuteState(MediaLayout.MuteState.MUTED);
+                    break;
+                case ENDED:
+                    if (mNativeVideoController.hasFinalFrame()) {
+                        mMediaLayout.setMainImageDrawable(mNativeVideoController.getFinalFrame());
+                    }
+                    mPauseCanBeTracked = false;
+                    mResumeCanBeTracked = false;
+                    mVastVideoConfig.handleComplete(mContext, 0);
+                    mNativeVideoController.setAppAudioEnabled(false);
+                    mMediaLayout.setMode(MediaLayout.Mode.FINISHED);
+                    mMediaLayout.updateProgress(1000);
+                    break;
+            }
+        }
+
+        private void handleResumeTrackersAndSeek(VideoState previousState) {
+            if (mResumeCanBeTracked
+                    && previousState != VideoState.PLAYING
+                    && previousState != VideoState.PLAYING_MUTED) {  // If we've played before, fire resume trackers.
+                TrackingRequest.makeVastTrackingHttpRequest(
+                        mVastVideoConfig.getResumeTrackers(),
+                        null, // VastErrorCode
+                        (int) mNativeVideoController.getCurrentPosition(),
+                        null, // Asset URI
+                        mContext
+                );
+                mResumeCanBeTracked = false;
+            }
+
+            mPauseCanBeTracked = true;
+
+            // We force a seek here to get keyframe rendering in ExtractorSampleSource.
+            if (mNeedsSeek) {
+                mNeedsSeek = false;
+                mNativeVideoController.seekTo(mNativeVideoController.getCurrentPosition());
+            }
+        }
+
+
+        private boolean isImageKey(@Nullable final String name) {
+            return name != null && name.toLowerCase(Locale.US).endsWith("image");
+        }
+
+        @NonNull
+        private List<String> getExtrasImageUrls() {
+            final List<String> extrasBitmapUrls = new ArrayList<String>(getExtras().size());
+            for (final Map.Entry<String, Object> entry : getExtras().entrySet()) {
+                if (isImageKey(entry.getKey()) && entry.getValue() instanceof String) {
+                    extrasBitmapUrls.add((String) entry.getValue());
+                }
+            }
+
+            return extrasBitmapUrls;
+        }
+
+        @NonNull
+        private List<String> getAllImageUrls() {
+            final List<String> imageUrls = new ArrayList<String>();
+            if (getMainImageUrl() != null) {
+                imageUrls.add(getMainImageUrl());
+            }
+            if (getIconImageUrl() != null) {
+                imageUrls.add(getIconImageUrl());
+            }
+
+            imageUrls.addAll(getExtrasImageUrls());
+            return imageUrls;
+        }
+
+        @Deprecated
+        @VisibleForTesting
+        boolean needsPrepare() {
+            return mNeedsPrepare;
+        }
+
+        @Deprecated
+        @VisibleForTesting
+        boolean hasEnded() {
+            return mEnded;
+        }
+
+        @Deprecated
+        @VisibleForTesting
+        boolean needsSeek() {
+            return mNeedsSeek;
+        }
+
+        @Deprecated
+        @VisibleForTesting
+        boolean isMuted() {
+            return mMuted;
+        }
+
+        @Deprecated
+        @VisibleForTesting
+        long getId() {
+            return mId;
+        }
+
+        @Deprecated
+        @VisibleForTesting
+        VideoState getVideoState() {
+            return mVideoState;
+        }
+
+        @Deprecated
+        @VisibleForTesting
+        void setLatestVisibility(boolean latestVisibility) {
+            mLatestVisibility = latestVisibility;
+        }
+
+        @Deprecated
+        @VisibleForTesting
+        void setMuted(boolean muted) {
+            mMuted = muted;
+        }
+
+        @Deprecated
+        @VisibleForTesting
+        MediaLayout getMediaLayout() {
+            return mMediaLayout;
+        }
+    }
+
+    @VisibleForTesting
+    static class HeaderVisibilityStrategy implements VisibilityTrackingEvent.OnTrackedStrategy {
+        @NonNull private final WeakReference<MoPubVideoNativeAd> mMoPubVideoNativeAd;
+
+        HeaderVisibilityStrategy(@NonNull final MoPubVideoNativeAd moPubVideoNativeAd) {
+            mMoPubVideoNativeAd = new WeakReference<MoPubVideoNativeAd>(moPubVideoNativeAd);
+        }
+
+        @Override
+        public void execute() {
+            final MoPubVideoNativeAd moPubVideoNativeAd = mMoPubVideoNativeAd.get();
+            if (moPubVideoNativeAd != null) {
+                moPubVideoNativeAd.notifyAdImpressed();
+            }
+        }
+    }
+
+    @VisibleForTesting
+    static class PayloadVisibilityStrategy implements VisibilityTrackingEvent.OnTrackedStrategy {
+        @NonNull private final Context mContext;
+        @NonNull private final String mUrl;
+
+        PayloadVisibilityStrategy(@NonNull final Context context, @NonNull final String url) {
+            mContext = context.getApplicationContext();
+            mUrl = url;
+        }
+
+        @Override
+        public void execute() {
+            TrackingRequest.makeTrackingHttpRequest(mUrl, mContext);
+        }
+    }
+
+    /**
+     * Created purely for the purpose of mocking to ease testing.
+     */
+    @VisibleForTesting
+    static class NativeVideoControllerFactory {
+        public NativeVideoController createForId(final long id,
+                @NonNull final Context context,
+                @NonNull final List<VisibilityTrackingEvent> visibilityTrackingEvents,
+                @NonNull final VastVideoConfig vastVideoConfig,
+                @Nullable final EventDetails eventDetails) {
+            return NativeVideoController.createForId(id, context, visibilityTrackingEvents,
+                    vastVideoConfig, eventDetails);
+        }
+    }
+
+    @VisibleForTesting
+    static class VideoResponseHeaders {
+        private boolean mHeadersAreValid;
+        private int mPlayVisiblePercent;
+        private int mPauseVisiblePercent;
+        private int mImpressionMinVisiblePercent;
+        private int mImpressionVisibleMs;
+        private int mMaxBufferMs;
+        private JSONObject mVideoTrackers;
+
+        VideoResponseHeaders(@NonNull final Map<String, String> serverExtras) {
+            try {
+                mPlayVisiblePercent = Integer.parseInt(serverExtras.get(PLAY_VISIBLE_PERCENT));
+                mPauseVisiblePercent = Integer.parseInt(serverExtras.get(PAUSE_VISIBLE_PERCENT));
+                mImpressionMinVisiblePercent =
+                        Integer.parseInt(serverExtras.get(IMPRESSION_MIN_VISIBLE_PERCENT));
+                mImpressionVisibleMs = Integer.parseInt(serverExtras.get(IMPRESSION_VISIBLE_MS));
+                mMaxBufferMs = Integer.parseInt(serverExtras.get(MAX_BUFFER_MS));
+                mHeadersAreValid = true;
+            } catch (NumberFormatException e) {
+                mHeadersAreValid = false;
+            }
+
+            final String videoTrackers = serverExtras.get(VIDEO_TRACKERS_KEY);
+            if (TextUtils.isEmpty(videoTrackers)) {
+                return;
+            }
+
+            try {
+                mVideoTrackers = new JSONObject(videoTrackers);
+            } catch (JSONException e) {
+                MoPubLog.d("Failed to parse video trackers to JSON: " + videoTrackers, e);
+                mVideoTrackers = null;
+            }
+        }
+
+        boolean hasValidHeaders() {
+            return mHeadersAreValid;
+        }
+
+        int getPlayVisiblePercent() {
+            return mPlayVisiblePercent;
+        }
+
+        int getPauseVisiblePercent() {
+            return mPauseVisiblePercent;
+        }
+
+        int getImpressionMinVisiblePercent() {
+            return mImpressionMinVisiblePercent;
+        }
+
+        int getImpressionVisibleMs() {
+            return mImpressionVisibleMs;
+        }
+
+        int getMaxBufferMs() {
+            return mMaxBufferMs;
+        }
+
+        JSONObject getVideoTrackers() {
+            return mVideoTrackers;
+        }
+    }
 }
diff --git a/mopub-sdk/mopub-sdk-native-video/src/main/java/com/mopub/nativeads/NativeFullScreenVideoView.java b/mopub-sdk/mopub-sdk-native-video/src/main/java/com/mopub/nativeads/NativeFullScreenVideoView.java
index 91ea4256..2f551fb9 100644
--- a/mopub-sdk/mopub-sdk-native-video/src/main/java/com/mopub/nativeads/NativeFullScreenVideoView.java
+++ b/mopub-sdk/mopub-sdk-native-video/src/main/java/com/mopub/nativeads/NativeFullScreenVideoView.java
@@ -1,6 +1,5 @@
 package com.mopub.nativeads;
 
-import android.annotation.TargetApi;
 import android.content.Context;
 import android.content.res.Configuration;
 import android.graphics.Bitmap;
@@ -13,7 +12,6 @@
 import android.graphics.drawable.Drawable;
 import android.graphics.drawable.GradientDrawable;
 import android.graphics.drawable.GradientDrawable.Orientation;
-import android.os.Build;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
@@ -36,7 +34,6 @@
 import com.mopub.mobileads.resource.DrawableConstants;
 import com.mopub.mobileads.resource.DrawableConstants.GradientStrip;
 
-@TargetApi(Build.VERSION_CODES.JELLY_BEAN)
 public class NativeFullScreenVideoView extends RelativeLayout {
 
     public enum Mode { LOADING, PLAYING, PAUSED, FINISHED }
diff --git a/mopub-sdk/mopub-sdk-native-video/src/main/java/com/mopub/nativeads/NativeVideoController.java b/mopub-sdk/mopub-sdk-native-video/src/main/java/com/mopub/nativeads/NativeVideoController.java
index 33e80e12..ea7d68ea 100644
--- a/mopub-sdk/mopub-sdk-native-video/src/main/java/com/mopub/nativeads/NativeVideoController.java
+++ b/mopub-sdk/mopub-sdk-native-video/src/main/java/com/mopub/nativeads/NativeVideoController.java
@@ -1,6 +1,5 @@
 package com.mopub.nativeads;
 
-import android.annotation.TargetApi;
 import android.content.Context;
 import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
@@ -8,7 +7,6 @@
 import android.media.AudioManager.OnAudioFocusChangeListener;
 import android.media.MediaCodec;
 import android.net.Uri;
-import android.os.Build;
 import android.os.Handler;
 import android.os.Looper;
 import android.support.annotation.NonNull;
@@ -50,7 +48,6 @@
  * Wrapper class around the {@link ExoPlayer} to provide a nice interface into the player along
  * with some helper methods. This class is not thread safe.
  */
-@TargetApi(Build.VERSION_CODES.JELLY_BEAN)
 public class NativeVideoController implements ExoPlayer.Listener,OnAudioFocusChangeListener {
 
     public interface Listener {
diff --git a/mopub-sdk/mopub-sdk-native-video/src/main/java/com/mopub/nativeads/NativeVideoViewController.java b/mopub-sdk/mopub-sdk-native-video/src/main/java/com/mopub/nativeads/NativeVideoViewController.java
index 501d0d19..4dc33142 100644
--- a/mopub-sdk/mopub-sdk-native-video/src/main/java/com/mopub/nativeads/NativeVideoViewController.java
+++ b/mopub-sdk/mopub-sdk-native-video/src/main/java/com/mopub/nativeads/NativeVideoViewController.java
@@ -1,13 +1,11 @@
 package com.mopub.nativeads;
 
-import android.annotation.TargetApi;
 import android.app.Activity;
 import android.content.Context;
 import android.content.res.Configuration;
 import android.graphics.Bitmap;
 import android.graphics.SurfaceTexture;
 import android.media.AudioManager;
-import android.os.Build;
 import android.os.Bundle;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
@@ -28,7 +26,6 @@
 import com.mopub.nativeads.NativeFullScreenVideoView.Mode;
 import com.mopub.nativeads.NativeVideoController.NativeVideoProgressRunnable;
 
-@TargetApi(Build.VERSION_CODES.JELLY_BEAN)
 public class NativeVideoViewController extends BaseVideoViewController implements TextureView
         .SurfaceTextureListener, NativeVideoController.Listener,
         AudioManager.OnAudioFocusChangeListener {
diff --git a/mopub-sdk/mopub-sdk-native-video/src/main/java/com/mopub/nativeads/VideoNativeAd.java b/mopub-sdk/mopub-sdk-native-video/src/main/java/com/mopub/nativeads/VideoNativeAd.java
index 71f3fa9a..97d19869 100644
--- a/mopub-sdk/mopub-sdk-native-video/src/main/java/com/mopub/nativeads/VideoNativeAd.java
+++ b/mopub-sdk/mopub-sdk-native-video/src/main/java/com/mopub/nativeads/VideoNativeAd.java
@@ -1,7 +1,5 @@
 package com.mopub.nativeads;
 
-import android.annotation.TargetApi;
-import android.os.Build;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.view.View;
@@ -11,7 +9,6 @@
 import java.util.HashMap;
 import java.util.Map;
 
-@TargetApi(Build.VERSION_CODES.JELLY_BEAN)
 public abstract class VideoNativeAd extends BaseNativeAd implements NativeVideoController.Listener {
 
     // Basic fields
diff --git a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/common/MoPubReward.java b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/common/MoPubReward.java
index 0c2b0ce3..60014242 100644
--- a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/common/MoPubReward.java
+++ b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/common/MoPubReward.java
@@ -35,7 +35,7 @@ private MoPubReward(boolean success, @NonNull String label, int amount) {
 
     @NonNull
     public static MoPubReward failure() {
-        return new MoPubReward(false, NO_REWARD_LABEL, 0);
+        return new MoPubReward(false, NO_REWARD_LABEL, DEFAULT_REWARD_AMOUNT);
     }
 
     @NonNull
diff --git a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/CustomEventRewardedAd.java b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/CustomEventRewardedAd.java
new file mode 100644
index 00000000..c9b15d97
--- /dev/null
+++ b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/CustomEventRewardedAd.java
@@ -0,0 +1,111 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.LifecycleListener;
+import com.mopub.common.MoPubLifecycleManager;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+
+import java.util.Map;
+
+/**
+ * The base class when dealing with rewarded formats.
+ */
+public abstract class CustomEventRewardedAd {
+
+    /**
+     * Provides a {@link LifecycleListener} if the custom event's ad network wishes to be notified of
+     * activity lifecycle events in the application.
+     *
+     * @return a LifecycleListener. May be null.
+     */
+    @Nullable
+    @VisibleForTesting
+    protected abstract LifecycleListener getLifecycleListener();
+
+    /**
+     * The MoPub ad loading system calls this after MoPub indicates that this custom event should
+     * be loaded.
+     *
+     * @param launcherActivity the "main activity" of the app. Useful for initializing sdks.
+     * @param localExtras      a map containing additional custom data set in app
+     * @param serverExtras     a map containing additional custom data configurable on the mopub website
+     */
+    final void loadCustomEvent(@NonNull Activity launcherActivity,
+            @NonNull Map<String, Object> localExtras,
+            @NonNull Map<String, String> serverExtras) {
+        try {
+            if (checkAndInitializeSdk(launcherActivity, localExtras, serverExtras)) {
+                MoPubLifecycleManager.getInstance(launcherActivity).addLifecycleListener(
+                        getLifecycleListener());
+            }
+            loadWithSdkInitialized(launcherActivity, localExtras, serverExtras);
+        } catch (Exception e) {
+            MoPubLog.e(e.getMessage());
+        }
+    }
+
+    /**
+     * Sets up the 3rd party ads SDK if it needs configuration. Extenders should use this
+     * to do any static initialization the first time this method is run by any class instance.
+     * From then on, the SDK should be reused without initialization.
+     *
+     * @return true if the SDK performed initialization, false if the SDK was already initialized.
+     */
+    protected abstract boolean checkAndInitializeSdk(@NonNull Activity launcherActivity,
+            @NonNull Map<String, Object> localExtras,
+            @NonNull Map<String, String> serverExtras)
+            throws Exception;
+
+    /**
+     * Runs the ad-loading logic for the 3rd party SDK. localExtras & serverExtras should together
+     * contain all the data needed to load an ad.
+     * <p/>
+     * Implementers should also use this method (or checkAndInitializeSdk)
+     * to register a listener for their SDK.
+     * <p/>
+     * This method should not call any {@link MoPubRewardedVideoManager} event methods directly
+     * (onAdLoadSuccess, etc). Instead the SDK delegate/listener should call these methods.
+     *
+     * @param activity     the "main activity" of the app. Useful for initializing sdks.
+     * @param localExtras  a map containing additional custom data set in app
+     * @param serverExtras a map containing additional custom data configurable on the mopub website
+     */
+    protected abstract void loadWithSdkInitialized(@NonNull Activity activity,
+            @NonNull Map<String, Object> localExtras,
+            @NonNull Map<String, String> serverExtras)
+            throws Exception;
+
+    /**
+     * Called by the {@link MoPubRewardedVideoManager} after loading the custom event.
+     * This should return the "ad unit id", "zone id" or similar identifier for the network.
+     * May be empty if the network does not have anything more specific than an application ID.
+     *
+     * @return the id string for this ad unit with the ad network.
+     */
+    @NonNull
+    protected abstract String getAdNetworkId();
+
+    /**
+     * Called to when the custom event is no longer used. Implementers should cancel any
+     * pending requests. The initialized SDK may be reused by another CustomEvent instance
+     * and should not be shut down or cleaned up.
+     */
+    protected abstract void onInvalidate();
+
+    /**
+     * Implementers should query the 3rd party SDK for whether the 3rd party SDK & ID represented
+     * by the custom event is ready to be shown.
+     *
+     * @return true iff a video is available to play.
+     */
+    protected abstract boolean isReady();
+
+    /**
+     * Implementers should now play the rewarded item for this custom event.
+     */
+    protected abstract void show();
+}
diff --git a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/CustomEventRewardedPlayable.java b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/CustomEventRewardedPlayable.java
new file mode 100644
index 00000000..9858e2a9
--- /dev/null
+++ b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/CustomEventRewardedPlayable.java
@@ -0,0 +1,7 @@
+package com.mopub.mobileads;
+
+/**
+ * Extend this class to mediate 3rd party rewarded playables.
+ */
+public abstract class CustomEventRewardedPlayable extends CustomEventRewardedAd {
+}
diff --git a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/CustomEventRewardedVideo.java b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/CustomEventRewardedVideo.java
index 9e1c961b..f3ecfad6 100644
--- a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/CustomEventRewardedVideo.java
+++ b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/CustomEventRewardedVideo.java
@@ -1,126 +1,49 @@
 package com.mopub.mobileads;
 
-import android.app.Activity;
-import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 
-import com.mopub.common.DataKeys;
-import com.mopub.common.LifecycleListener;
-import com.mopub.common.MoPubLifecycleManager;
-import com.mopub.common.VisibleForTesting;
-import com.mopub.common.logging.MoPubLog;
-
-import java.util.Map;
-
 /**
- *
+ * Extend this class to mediate 3rd party rewarded videos.
  */
-public abstract class CustomEventRewardedVideo {
+public abstract class CustomEventRewardedVideo extends CustomEventRewardedAd {
 
-    /**
-     * This marker interface is used to indicate that an object is a listener for a 3rd party SDKs
-     * rewarded video system.
-     */
-    @VisibleForTesting
-    protected static interface CustomEventRewardedVideoListener {}
-
-    /**
-     * Called by the {@link MoPubRewardedVideoManager} after loading the custom event.
-     */
-    @Nullable
-    @VisibleForTesting
-    protected abstract CustomEventRewardedVideoListener getVideoListenerForSdk();
+    @Deprecated
+    protected interface CustomEventRewardedVideoListener {
+    }
 
-    /**
-     * Provides a {@link LifecycleListener} if the custom event's ad network wishes to be notified of
-     * activity lifecycle events in the application.
-     *
-     * @return a LifecycleListener. May be null.
-     */
+    @Deprecated
     @Nullable
-    @VisibleForTesting
-    protected abstract LifecycleListener getLifecycleListener();
-
-    /**
-     * Called by the {@link MoPubRewardedVideoManager} after loading the custom event.
-     * This should return the "ad unit id", "zone id" or similar identifier for the network.
-     * May be empty if the network does not have anything more specific than an application ID.
-     *
-     * @return the id string for this ad unit with the ad network.
-     */
-    @NonNull
-    protected abstract String getAdNetworkId();
-
-    /**
-     * Called to when the custom event is no longer used. Implementers should cancel any
-     * pending requests. The initialized SDK may be reused by another CustomEvent instance
-     * and should not be shut down or cleaned up.
-     */
-    protected abstract void onInvalidate();
-
     /**
-     * The MoPub ad loading system calls this after MoPub indicates that this custom event should
-     * be loaded.
-     *
-     * @param launcherActivity the "main activity" of the app. Useful for initializing sdks.
-     * @param localExtras a map containing additional custom data set in app
-     * @param serverExtras a map containing additional custom data configurable on the mopub website
+     * This is no longer used. Implementing this does not do anything.
      */
-    final void loadCustomEvent(@NonNull Activity launcherActivity,
-            @NonNull Map<String, Object> localExtras,
-            @NonNull Map<String, String> serverExtras) {
-        try {
-            if (checkAndInitializeSdk(launcherActivity, localExtras, serverExtras)) {
-                MoPubLifecycleManager.getInstance(launcherActivity).addLifecycleListener(getLifecycleListener());
-            }
-            loadWithSdkInitialized(launcherActivity, localExtras, serverExtras);
-        } catch (Exception e) {
-            MoPubLog.e(e.getMessage());
-        }
+    protected CustomEventRewardedVideoListener getVideoListenerForSdk() {
+        return null;
     }
 
     /**
-     * Sets up the 3rd party ads SDK if it needs configuration. Extenders should use this
-     * to do any static initialization the first time this method is run by any class instance.
-     * From then on, the SDK should be reused without initialization.
-     *
-     * @return true if the SDK performed initialization, false if the SDK was already initialized.
-     */
-    protected abstract boolean checkAndInitializeSdk(@NonNull Activity launcherActivity,
-            @NonNull Map<String, Object> localExtras,
-            @NonNull Map<String, String> serverExtras)
-            throws Exception;
-
-    /**
-     * Runs the ad-loading logic for the 3rd party SDK. localExtras & serverExtras should together
-     * contain all the data needed to load an ad.
-     *
-     * Implementers should also use this method (or checkAndInitializeSdk)
-     * to register a listener for their SDK, wrap it in a
-     * {@link com.mopub.mobileads.CustomEventRewardedVideo.CustomEventRewardedVideoListener}
-     *
-     * This method should not call any {@link MoPubRewardedVideoManager} event methods directly
-     * (onAdLoadSuccess, etc). Instead the SDK delegate/listener should call these methods.
-     *
-     * @param activity the "main activity" of the app. Useful for initializing sdks.
-     * @param localExtras a map containing additional custom data set in app
-     * @param serverExtras a map containing additional custom data configurable on the mopub website
-     */
-    protected abstract void loadWithSdkInitialized(@NonNull Activity activity,
-            @NonNull Map<String, Object> localExtras,
-            @NonNull Map<String, String> serverExtras)
-            throws Exception;
-
-    /**
-     * Implementers should query the 3rd party SDK for whether there is a video available for the
-     * 3rd party SDK & ID represented by the custom event.
-     *
-     * @return true iff a video is available to play.
+     * Legacy proxy for {@link CustomEventRewardedAd#isReady}. Implementers should query the 3rd
+     * party SDK for whether there is a video available for the 3rd party SDK & ID represented by
+     * the custom event. This has been deprecated in favor of isReady(), but isReady() will call
+     * hasVideoAvailable() if not overridden.
      */
+    @Deprecated
     protected abstract boolean hasVideoAvailable();
 
     /**
-     * Implementers should now play the rewarded video for this custom event.
+     * Legacy proxy for {@link CustomEventRewardedAd#show}. Implementers should now play the
+     * rewarded video for this custom event. This has been deprecated in favor of show(), but
+     * show() will call showVideo() if not overridden.
      */
+    @Deprecated
     protected abstract void showVideo();
+
+    @Override
+    protected boolean isReady() {
+        return hasVideoAvailable();
+    }
+
+    @Override
+    protected void show() {
+        showVideo();
+    }
 }
diff --git a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedAd.java b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedAd.java
new file mode 100644
index 00000000..d0129295
--- /dev/null
+++ b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedAd.java
@@ -0,0 +1,161 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.DataKeys;
+import com.mopub.common.LifecycleListener;
+import com.mopub.common.MoPubReward;
+import com.mopub.common.Preconditions;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+
+import java.util.Map;
+
+/**
+ * Contains the common logic for rewarded ads.
+ */
+public abstract class MoPubRewardedAd extends CustomEventRewardedAd {
+
+    private boolean mIsLoaded;
+    @Nullable private String mRewardedAdCurrencyName;
+    private int mRewardedAdCurrencyAmount;
+
+    @Nullable
+    @Override
+    protected LifecycleListener getLifecycleListener() {
+        // This custom event does not need additional lifecycle listeners.
+        return null;
+    }
+
+    @Override
+    protected boolean checkAndInitializeSdk(@NonNull final Activity launcherActivity,
+            @NonNull final Map<String, Object> localExtras,
+            @NonNull final Map<String, String> serverExtras) throws Exception {
+        // No additional initialization is necessary.
+        return false;
+    }
+
+    @Override
+    protected void loadWithSdkInitialized(@NonNull final Activity activity,
+            @NonNull final Map<String, Object> localExtras,
+            @NonNull final Map<String, String> serverExtras) throws Exception {
+        Preconditions.checkNotNull(activity, "activity cannot be null");
+        Preconditions.checkNotNull(localExtras, "localExtras cannot be null");
+        Preconditions.checkNotNull(serverExtras, "serverExtras cannot be null");
+
+        final Object rewardedAdCurrencyName = localExtras.get(
+                DataKeys.REWARDED_AD_CURRENCY_NAME_KEY);
+        if (rewardedAdCurrencyName instanceof String) {
+            mRewardedAdCurrencyName = (String) rewardedAdCurrencyName;
+        } else {
+            MoPubLog.d("No currency name specified for rewarded video. Using the default name.");
+            mRewardedAdCurrencyName = MoPubReward.NO_REWARD_LABEL;
+        }
+
+        final Object rewardedAdCurrencyAmount = localExtras.get(
+                DataKeys.REWARDED_AD_CURRENCY_AMOUNT_STRING_KEY);
+        if (rewardedAdCurrencyAmount instanceof String) {
+            try {
+                mRewardedAdCurrencyAmount = Integer.parseInt(
+                        (String) rewardedAdCurrencyAmount);
+            } catch (NumberFormatException e) {
+                MoPubLog.d(
+                        "Unable to convert currency amount: " + rewardedAdCurrencyAmount +
+                                ". Using the default reward amount: " +
+                                MoPubReward.DEFAULT_REWARD_AMOUNT);
+                mRewardedAdCurrencyAmount = MoPubReward.DEFAULT_REWARD_AMOUNT;
+            }
+        } else {
+            MoPubLog.d(
+                    "No currency amount specified for rewarded ad. Using the default reward amount: " +
+                            MoPubReward.DEFAULT_REWARD_AMOUNT);
+            mRewardedAdCurrencyAmount = MoPubReward.DEFAULT_REWARD_AMOUNT;
+        }
+
+        if (mRewardedAdCurrencyAmount < 0) {
+            MoPubLog.d(
+                    "Negative currency amount specified for rewarded ad. Using the default reward amount: " +
+                            MoPubReward.DEFAULT_REWARD_AMOUNT);
+            mRewardedAdCurrencyAmount = MoPubReward.DEFAULT_REWARD_AMOUNT;
+        }
+    }
+
+    @Override
+    protected void onInvalidate() {
+        mIsLoaded = false;
+    }
+
+    @Override
+    protected boolean isReady() {
+        return mIsLoaded;
+    }
+
+    protected class MoPubRewardedAdListener implements CustomEventInterstitial.CustomEventInterstitialListener {
+
+        @NonNull final Class<? extends MoPubRewardedAd>  mCustomEventClass;
+
+        public MoPubRewardedAdListener(@NonNull final Class<? extends MoPubRewardedAd>
+                customEventClass) {
+            Preconditions.checkNotNull(customEventClass);
+
+            mCustomEventClass = customEventClass;
+        }
+
+        @Override
+        public void onInterstitialLoaded() {
+            mIsLoaded = true;
+            MoPubRewardedVideoManager.onRewardedVideoLoadSuccess(mCustomEventClass,
+                    getAdNetworkId());
+        }
+
+        @Override
+        public void onInterstitialFailed(final MoPubErrorCode errorCode) {
+            switch (errorCode) {
+                case VIDEO_PLAYBACK_ERROR:
+                    MoPubRewardedVideoManager.onRewardedVideoPlaybackError(mCustomEventClass,
+                            getAdNetworkId(), errorCode);
+                    break;
+                default:
+                    MoPubRewardedVideoManager.onRewardedVideoLoadFailure(mCustomEventClass,
+                            getAdNetworkId(), errorCode);
+            }
+        }
+
+        @Override
+        public void onInterstitialShown() {
+            MoPubRewardedVideoManager.onRewardedVideoStarted(mCustomEventClass, getAdNetworkId());
+        }
+
+        @Override
+        public void onInterstitialClicked() {
+            MoPubRewardedVideoManager.onRewardedVideoClicked(mCustomEventClass, getAdNetworkId());
+        }
+
+        @Override
+        public void onLeaveApplication() {
+        }
+
+        @Override
+        public void onInterstitialDismissed() {
+            MoPubRewardedVideoManager.onRewardedVideoClosed(mCustomEventClass, getAdNetworkId());
+        }
+    }
+
+    @Nullable
+    protected String getRewardedAdCurrencyName() {
+        return mRewardedAdCurrencyName;
+    }
+
+    protected int getRewardedAdCurrencyAmount() {
+        return mRewardedAdCurrencyAmount;
+    }
+
+    @Deprecated
+    @VisibleForTesting
+    void setIsLoaded(final boolean isLoaded) {
+        mIsLoaded = isLoaded;
+    }
+
+}
diff --git a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedPlayable.java b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedPlayable.java
new file mode 100644
index 00000000..41eabaa5
--- /dev/null
+++ b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedPlayable.java
@@ -0,0 +1,82 @@
+package com.mopub.mobileads;
+
+import android.app.Activity;
+import android.support.annotation.NonNull;
+
+import com.mopub.common.MoPubReward;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.mraid.RewardedMraidInterstitial;
+
+import java.util.Map;
+
+/**
+ * A custom event for showing MoPub rewarded playables.
+ */
+public class MoPubRewardedPlayable extends MoPubRewardedAd {
+
+    @NonNull private static final String MOPUB_REWARDED_PLAYABLE_ID = "mopub_rewarded_playable_id";
+    @NonNull private RewardedMraidInterstitial mRewardedMraidInterstitial;
+
+    public MoPubRewardedPlayable() {
+        mRewardedMraidInterstitial = new RewardedMraidInterstitial();
+    }
+
+    @Override
+    protected void loadWithSdkInitialized(@NonNull final Activity activity,
+            @NonNull final Map<String, Object> localExtras,
+            @NonNull final Map<String, String> serverExtras) throws Exception {
+        super.loadWithSdkInitialized(activity, localExtras, serverExtras);
+
+        mRewardedMraidInterstitial.loadInterstitial(activity, new MoPubRewardedPlayableListener(),
+                localExtras, serverExtras);
+    }
+
+    @NonNull
+    @Override
+    protected String getAdNetworkId() {
+        return MOPUB_REWARDED_PLAYABLE_ID;
+    }
+
+    @Override
+    protected void onInvalidate() {
+        mRewardedMraidInterstitial.onInvalidate();
+        super.onInvalidate();
+    }
+
+    @Override
+    protected void show() {
+        if (isReady()) {
+            MoPubLog.d("Showing MoPub rewarded playable.");
+            mRewardedMraidInterstitial.showInterstitial();
+        } else {
+            MoPubLog.d("MoPub rewarded playable not loaded. Unable to show playable.");
+        }
+    }
+
+    private class MoPubRewardedPlayableListener extends MoPubRewardedAdListener implements RewardedMraidInterstitial.RewardedMraidInterstitialListener {
+
+        public MoPubRewardedPlayableListener() {
+            super(MoPubRewardedPlayable.class);
+        }
+
+        @Override
+        public void onMraidComplete() {
+            if (getRewardedAdCurrencyName() == null) {
+                MoPubLog.d("No rewarded video was loaded, so no reward is possible");
+            } else {
+                MoPubRewardedVideoManager.onRewardedVideoCompleted(mCustomEventClass,
+                        getAdNetworkId(),
+                        MoPubReward.success(getRewardedAdCurrencyName(),
+                                getRewardedAdCurrencyAmount()));
+            }
+        }
+    }
+
+    @Deprecated
+    @VisibleForTesting
+    void setRewardedMraidInterstitial(
+            @NonNull final RewardedMraidInterstitial rewardedMraidInterstitial) {
+        mRewardedMraidInterstitial = rewardedMraidInterstitial;
+    }
+}
diff --git a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedVideo.java b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedVideo.java
index 9715fdb0..a9695b16 100644
--- a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedVideo.java
+++ b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedVideo.java
@@ -2,12 +2,8 @@
 
 import android.app.Activity;
 import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
 
-import com.mopub.common.DataKeys;
-import com.mopub.common.LifecycleListener;
 import com.mopub.common.MoPubReward;
-import com.mopub.common.Preconditions;
 import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
 
@@ -16,34 +12,17 @@
 /**
  * A custom event for showing MoPub rewarded videos.
  */
-public class MoPubRewardedVideo extends CustomEventRewardedVideo {
+public class MoPubRewardedVideo extends MoPubRewardedAd {
 
     @NonNull private static final String MOPUB_REWARDED_VIDEO_ID = "mopub_rewarded_video_id";
 
     @NonNull private RewardedVastVideoInterstitial mRewardedVastVideoInterstitial;
-    @Nullable private String mRewardedVideoCurrencyName;
-    private int mRewardedVideoCurrencyAmount;
-    private boolean mIsLoaded;
+
 
     public MoPubRewardedVideo() {
         mRewardedVastVideoInterstitial = new RewardedVastVideoInterstitial();
     }
 
-    @Nullable
-    @Override
-    protected CustomEventRewardedVideoListener getVideoListenerForSdk() {
-        // Since MoPub is the SDK, there is no reason to get the SDK video listener
-        // since we have direct access.
-        return null;
-    }
-
-    @Nullable
-    @Override
-    protected LifecycleListener getLifecycleListener() {
-        // RewardedVastVideoInterstitial will handle all lifecycle events.
-        return null;
-    }
-
     @NonNull
     @Override
     protected String getAdNetworkId() {
@@ -53,73 +32,22 @@ protected String getAdNetworkId() {
     @Override
     protected void onInvalidate() {
         mRewardedVastVideoInterstitial.onInvalidate();
-        mIsLoaded = false;
-    }
-
-    @Override
-    protected boolean checkAndInitializeSdk(@NonNull final Activity launcherActivity,
-            @NonNull final Map<String, Object> localExtras,
-            @NonNull final Map<String, String> serverExtras) throws Exception {
-        // No additional initialization is necessary.
-        return false;
+        super.onInvalidate();
     }
 
     @Override
     protected void loadWithSdkInitialized(@NonNull final Activity activity,
             @NonNull final Map<String, Object> localExtras,
             @NonNull final Map<String, String> serverExtras) throws Exception {
-        Preconditions.checkNotNull(activity, "activity cannot be null");
-        Preconditions.checkNotNull(localExtras, "localExtras cannot be null");
-        Preconditions.checkNotNull(serverExtras, "serverExtras cannot be null");
-
-        final Object rewardedVideoCurrencyName = localExtras.get(
-                DataKeys.REWARDED_VIDEO_CURRENCY_NAME_KEY);
-        if (rewardedVideoCurrencyName instanceof String) {
-            mRewardedVideoCurrencyName = (String) rewardedVideoCurrencyName;
-        } else {
-            MoPubLog.d("No currency name specified for rewarded video. Using the default name.");
-            mRewardedVideoCurrencyName = MoPubReward.NO_REWARD_LABEL;
-        }
-
-        final Object rewardedVideoCurrencyAmount = localExtras.get(
-                DataKeys.REWARDED_VIDEO_CURRENCY_AMOUNT_STRING_KEY);
-        if (rewardedVideoCurrencyAmount instanceof String) {
-            try {
-                mRewardedVideoCurrencyAmount = Integer.parseInt(
-                        (String) rewardedVideoCurrencyAmount);
-            } catch (NumberFormatException e) {
-                MoPubLog.d(
-                        "Unable to convert currency amount: " + rewardedVideoCurrencyAmount +
-                                ". Using the default reward amount: " +
-                                MoPubReward.DEFAULT_REWARD_AMOUNT);
-                mRewardedVideoCurrencyAmount = MoPubReward.DEFAULT_REWARD_AMOUNT;
-            }
-        } else {
-            MoPubLog.d(
-                    "No currency amount specified for rewarded video. Using the default reward amount: " +
-                            MoPubReward.DEFAULT_REWARD_AMOUNT);
-            mRewardedVideoCurrencyAmount = MoPubReward.DEFAULT_REWARD_AMOUNT;
-        }
-
-        if (mRewardedVideoCurrencyAmount < 0) {
-            MoPubLog.d(
-                    "Negative currency amount specified for rewarded video. Using the default reward amount: " +
-                            MoPubReward.DEFAULT_REWARD_AMOUNT);
-            mRewardedVideoCurrencyAmount = MoPubReward.DEFAULT_REWARD_AMOUNT;
-        }
+        super.loadWithSdkInitialized(activity, localExtras, serverExtras);
 
         mRewardedVastVideoInterstitial.loadInterstitial(activity, new MoPubRewardedVideoListener(),
                 localExtras, serverExtras);
     }
 
     @Override
-    protected boolean hasVideoAvailable() {
-        return mIsLoaded;
-    }
-
-    @Override
-    protected void showVideo() {
-        if (hasVideoAvailable()) {
+    protected void show() {
+        if (isReady()) {
             MoPubLog.d("Showing MoPub rewarded video.");
             mRewardedVastVideoInterstitial.showInterstitial();
         } else {
@@ -127,58 +55,22 @@ protected void showVideo() {
         }
     }
 
-    private class MoPubRewardedVideoListener implements CustomEventInterstitial.CustomEventInterstitialListener, RewardedVastVideoInterstitial.CustomEventRewardedVideoInterstitialListener {
-        @Override
-        public void onInterstitialLoaded() {
-            mIsLoaded = true;
-            MoPubRewardedVideoManager.onRewardedVideoLoadSuccess(MoPubRewardedVideo.class,
-                    MOPUB_REWARDED_VIDEO_ID);
-        }
-
-        @Override
-        public void onInterstitialFailed(final MoPubErrorCode errorCode) {
-            switch (errorCode) {
-                case VIDEO_PLAYBACK_ERROR:
-                    MoPubRewardedVideoManager.onRewardedVideoPlaybackError(MoPubRewardedVideo.class,
-                            MOPUB_REWARDED_VIDEO_ID, errorCode);
-                    break;
-                default:
-                    MoPubRewardedVideoManager.onRewardedVideoLoadFailure(MoPubRewardedVideo.class,
-                            MOPUB_REWARDED_VIDEO_ID, errorCode);
-            }
-        }
+    private class MoPubRewardedVideoListener extends MoPubRewardedAdListener implements RewardedVastVideoInterstitial.RewardedVideoInterstitialListener {
 
-        @Override
-        public void onInterstitialShown() {
-            MoPubRewardedVideoManager.onRewardedVideoStarted(MoPubRewardedVideo.class,
-                    MOPUB_REWARDED_VIDEO_ID);
+        public MoPubRewardedVideoListener() {
+            super(MoPubRewardedVideo.class);
         }
 
-        @Override
-        public void onInterstitialClicked() {
-            MoPubRewardedVideoManager.onRewardedVideoClicked(MoPubRewardedVideo.class,
-                    MOPUB_REWARDED_VIDEO_ID);
-        }
-
-        @Override
-        public void onLeaveApplication() {
-        }
-
-        @Override
-        public void onInterstitialDismissed() {
-            MoPubRewardedVideoManager.onRewardedVideoClosed(MoPubRewardedVideo.class,
-                    MOPUB_REWARDED_VIDEO_ID);
-        }
 
         @Override
         public void onVideoComplete() {
-            if (mRewardedVideoCurrencyName == null) {
+            if (getRewardedAdCurrencyName() == null) {
                 MoPubLog.d("No rewarded video was loaded, so no reward is possible");
             } else {
-                MoPubRewardedVideoManager.onRewardedVideoCompleted(MoPubRewardedVideo.class,
-                        MOPUB_REWARDED_VIDEO_ID,
-                        MoPubReward.success(mRewardedVideoCurrencyName,
-                                mRewardedVideoCurrencyAmount));
+                MoPubRewardedVideoManager.onRewardedVideoCompleted(mCustomEventClass,
+                        getAdNetworkId(),
+                        MoPubReward.success(getRewardedAdCurrencyName(),
+                                getRewardedAdCurrencyAmount()));
             }
         }
     }
@@ -189,23 +81,4 @@ void setRewardedVastVideoInterstitial(
             @NonNull final RewardedVastVideoInterstitial rewardedVastVideoInterstitial) {
         mRewardedVastVideoInterstitial = rewardedVastVideoInterstitial;
     }
-
-    @Deprecated
-    @VisibleForTesting
-    @Nullable
-    String getRewardedVideoCurrencyName() {
-        return mRewardedVideoCurrencyName;
-    }
-
-    @Deprecated
-    @VisibleForTesting
-    int getRewardedVideoCurrencyAmount() {
-        return mRewardedVideoCurrencyAmount;
-    }
-
-    @Deprecated
-    @VisibleForTesting
-    void setIsLoaded(final boolean isLoaded) {
-        mIsLoaded = isLoaded;
-    }
 }
diff --git a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedVideoManager.java b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedVideoManager.java
index 80c50c7b..2867c02d 100644
--- a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedVideoManager.java
+++ b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedVideoManager.java
@@ -20,6 +20,7 @@
 import com.mopub.common.Preconditions;
 import com.mopub.common.VisibleForTesting;
 import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Json;
 import com.mopub.common.util.MoPubCollections;
 import com.mopub.common.util.Reflection;
 import com.mopub.common.util.ReflectionTarget;
@@ -32,7 +33,10 @@
 import com.mopub.volley.RequestQueue;
 import com.mopub.volley.VolleyError;
 
+import org.json.JSONException;
+
 import java.lang.ref.WeakReference;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Locale;
@@ -41,12 +45,15 @@
 import java.util.TreeMap;
 
 /**
- * Handles requesting Rewarded Video ads and mapping Rewarded Video SDK settings to the CustomEvent
+ * Handles requesting Rewarded ads and mapping Rewarded Ad SDK settings to the CustomEvent
  * that is being loaded.
  */
 public class MoPubRewardedVideoManager {
     private static MoPubRewardedVideoManager sInstance;
     private static final int DEFAULT_LOAD_TIMEOUT = Constants.THIRTY_SECONDS_MILLIS;
+    private static final String CURRENCIES_JSON_REWARDS_MAP_KEY = "rewards";
+    private static final String CURRENCIES_JSON_REWARD_NAME_KEY = "name";
+    private static final String CURRENCIES_JSON_REWARD_AMOUNT_KEY = "amount";
 
     /**
      * This must an integer because the backend only supports int types for api version.
@@ -57,7 +64,7 @@
     @NonNull private WeakReference<Activity> mMainActivity;
     @NonNull private final Context mContext;
     @NonNull private final AdRequestStatusMapping mAdRequestStatus;
-    @NonNull private final RewardedVideoData mRewardedVideoData;
+    @NonNull private final RewardedAdData mRewardedAdData;
     @Nullable private MoPubRewardedVideoListener mVideoListener;
 
     @NonNull private final Set<MediationSettings> mGlobalMediationSettings;
@@ -112,7 +119,7 @@ public RequestParameters(@Nullable final String keywords, @Nullable final Locati
     private MoPubRewardedVideoManager(@NonNull Activity mainActivity, MediationSettings... mediationSettings) {
         mMainActivity = new WeakReference<Activity>(mainActivity);
         mContext = mainActivity.getApplicationContext();
-        mRewardedVideoData = new RewardedVideoData();
+        mRewardedAdData = new RewardedAdData();
         mCallbackHandler = new Handler(Looper.getMainLooper());
         mGlobalMediationSettings = new HashSet<MediationSettings>();
         MoPubCollections.addAllNonNull(mGlobalMediationSettings, mediationSettings);
@@ -230,15 +237,15 @@ public static void loadVideo(@NonNull final String adUnitId,
         }
 
         final String currentlyShowingAdUnitId =
-                sInstance.mRewardedVideoData.getCurrentlyShowingAdUnitId();
+                sInstance.mRewardedAdData.getCurrentlyShowingAdUnitId();
         if (!TextUtils.isEmpty(currentlyShowingAdUnitId)) {
-            MoPubLog.d(String.format(Locale.US, "Did not queue rewarded video request for ad " +
-                    "unit %s. The video is already showing.", adUnitId));
+            MoPubLog.d(String.format(Locale.US, "Did not queue rewarded ad request for ad " +
+                    "unit %s. The ad is already showing.", adUnitId));
             return;
         }
 
         if (sInstance.mAdRequestStatus.canPlay(adUnitId)) {
-            MoPubLog.d(String.format(Locale.US, "Did not queue rewarded video request for ad " +
+            MoPubLog.d(String.format(Locale.US, "Did not queue rewarded ad request for ad " +
             "unit %s. This ad unit already finished loading and is ready to show.", adUnitId));
             postToInstance(new Runnable() {
                 @Override
@@ -261,7 +268,7 @@ public void run() {
 
         final String customerId = requestParameters == null ? null : requestParameters.mCustomerId;
         if (!TextUtils.isEmpty(customerId)) {
-            sInstance.mRewardedVideoData.setCustomerId(customerId);
+            sInstance.mRewardedAdData.setCustomerId(customerId);
         }
 
         final AdUrlGenerator urlGenerator = new WebViewAdUrlGenerator(sInstance.mContext, false);
@@ -280,7 +287,7 @@ private static void loadVideo(@NonNull String adUnitId, @NonNull String adUrlStr
         }
 
         if (sInstance.mAdRequestStatus.isLoading(adUnitId)) {
-            MoPubLog.d(String.format(Locale.US, "Did not queue rewarded video request for ad " +
+            MoPubLog.d(String.format(Locale.US, "Did not queue rewarded ad request for ad " +
                     "unit %s. A request is already pending.", adUnitId));
             return;
         }
@@ -296,11 +303,13 @@ private static void loadVideo(@NonNull String adUnitId, @NonNull String adUrlStr
         final RequestQueue requestQueue = Networking.getRequestQueue(sInstance.mContext);
         requestQueue.add(request);
         sInstance.mAdRequestStatus.markLoading(adUnitId);
+        MoPubLog.d(String.format(Locale.US,
+                "Loading rewarded ad request for ad unit %s with URL %s", adUnitId, adUrlString));
     }
 
     public static boolean hasVideo(@NonNull String adUnitId) {
         if (sInstance != null) {
-            final CustomEventRewardedVideo customEvent = sInstance.mRewardedVideoData.getCustomEvent(adUnitId);
+            final CustomEventRewardedAd customEvent = sInstance.mRewardedAdData.getCustomEvent(adUnitId);
             return isPlayable(adUnitId, customEvent);
         } else {
             logErrorNotInitialized();
@@ -310,14 +319,21 @@ public static boolean hasVideo(@NonNull String adUnitId) {
 
     public static void showVideo(@NonNull String adUnitId) {
         if (sInstance != null) {
-            final CustomEventRewardedVideo customEvent = sInstance.mRewardedVideoData.getCustomEvent(adUnitId);
+            final CustomEventRewardedAd customEvent = sInstance.mRewardedAdData.getCustomEvent(adUnitId);
             if (isPlayable(adUnitId, customEvent)) {
-                sInstance.mRewardedVideoData.updateCustomEventLastShownRewardMapping(
+                // If there are rewards available but no reward is selected, fail over.
+                if (!sInstance.mRewardedAdData.getAvailableRewards(adUnitId).isEmpty()
+                        && sInstance.mRewardedAdData.getMoPubReward(adUnitId) == null) {
+                    sInstance.failover(adUnitId, MoPubErrorCode.REWARD_NOT_SELECTED);
+                    return;
+                }
+
+                sInstance.mRewardedAdData.updateCustomEventLastShownRewardMapping(
                         customEvent.getClass(),
-                        sInstance.mRewardedVideoData.getMoPubReward(adUnitId));
-                sInstance.mRewardedVideoData.setCurrentlyShowingAdUnitId(adUnitId);
+                        sInstance.mRewardedAdData.getMoPubReward(adUnitId));
+                sInstance.mRewardedAdData.setCurrentlyShowingAdUnitId(adUnitId);
                 sInstance.mAdRequestStatus.markPlayed(adUnitId);
-                customEvent.showVideo();
+                customEvent.show();
             } else {
                 sInstance.failover(adUnitId, MoPubErrorCode.VIDEO_NOT_AVAILABLE);
             }
@@ -326,11 +342,41 @@ public static void showVideo(@NonNull String adUnitId) {
         }
     }
 
-    private static boolean isPlayable(String adUnitId, @Nullable CustomEventRewardedVideo customEvent) {
+    private static boolean isPlayable(String adUnitId, @Nullable CustomEventRewardedAd customEvent) {
         return (sInstance != null
                 && sInstance.mAdRequestStatus.canPlay(adUnitId)
                 && customEvent != null
-                && customEvent.hasVideoAvailable());
+                && customEvent.isReady());
+    }
+
+    /**
+     * Retrieves the set of available {@link MoPubReward} instance(s) for this AdUnit.
+     * @param adUnitId MoPub adUnitId String
+     * @return a set of {@link MoPubReward} instance(s) if available, else an empty set.
+     */
+    @NonNull
+    public static Set<MoPubReward> getAvailableRewards(@NonNull String adUnitId) {
+        if (sInstance != null) {
+            return sInstance.mRewardedAdData.getAvailableRewards(adUnitId);
+        } else {
+            logErrorNotInitialized();
+            return Collections.<MoPubReward>emptySet();
+        }
+    }
+
+    /**
+     * Selects the reward for this AdUnit from available {@link MoPubReward} instances.
+     * If this AdUnit does not have any rewards, or if the selected reward is not available
+     * for this AdUnit, then no reward will be selected for this AdUnit.
+     * @param adUnitId MoPub adUnitId String
+     * @param selectedReward selected {@link MoPubReward}
+     */
+    public static void selectReward(@NonNull String adUnitId, @NonNull MoPubReward selectedReward) {
+        if (sInstance != null) {
+            sInstance.mRewardedAdData.selectReward(adUnitId, selectedReward);
+        } else {
+            logErrorNotInitialized();
+        }
     }
 
     ///// Ad Request / Response methods /////
@@ -353,9 +399,9 @@ private void onAdSuccess(AdResponse adResponse, String adUnitId) {
             return;
         }
 
-        // We only allow one rewarded video to be loaded at a time for each ad unit. This should
-        // clear out the old rewarded video if there already was one loaded and not played.
-        final CustomEventRewardedVideo oldRewardedVideo = mRewardedVideoData.getCustomEvent(
+        // We only allow one rewarded ad to be loaded at a time for each ad unit. This should
+        // clear out the old rewarded ad if there already was one loaded and not played.
+        final CustomEventRewardedAd oldRewardedVideo = mRewardedAdData.getCustomEvent(
                 adUnitId);
         if (oldRewardedVideo != null) {
             oldRewardedVideo.onInvalidate();
@@ -363,34 +409,58 @@ private void onAdSuccess(AdResponse adResponse, String adUnitId) {
 
         try {
             // Instantiate a custom event
-            final CustomEventRewardedVideo customEvent =
+            final CustomEventRewardedAd customEvent =
                     Reflection.instantiateClassWithEmptyConstructor(
                             customEventClassName,
-                            CustomEventRewardedVideo.class);
+                            CustomEventRewardedAd.class);
 
             // Put important data into localExtras...
             final Map<String, Object> localExtras = new TreeMap<String, Object>();
             localExtras.put(DataKeys.AD_UNIT_ID_KEY, adUnitId);
-            localExtras.put(DataKeys.REWARDED_VIDEO_CURRENCY_NAME_KEY,
+            localExtras.put(DataKeys.REWARDED_AD_CURRENCY_NAME_KEY,
                     adResponse.getRewardedVideoCurrencyName());
-            localExtras.put(DataKeys.REWARDED_VIDEO_CURRENCY_AMOUNT_STRING_KEY,
+            localExtras.put(DataKeys.REWARDED_AD_CURRENCY_AMOUNT_STRING_KEY,
                     adResponse.getRewardedVideoCurrencyAmount());
+            localExtras.put(DataKeys.REWARDED_AD_DURATION_KEY,
+                    adResponse.getRewardedDuration());
+            localExtras.put(DataKeys.SHOULD_REWARD_ON_CLICK_KEY,
+                    adResponse.shouldRewardOnClick());
             localExtras.put(DataKeys.AD_REPORT_KEY,
                     new AdReport(adUnitId, ClientMetadata.getInstance(mContext), adResponse));
             localExtras.put(DataKeys.BROADCAST_IDENTIFIER_KEY, Utils.generateUniqueId());
 
-            localExtras.put(DataKeys.REWARDED_VIDEO_CUSTOMER_ID,
-                    mRewardedVideoData.getCustomerId());
-            mRewardedVideoData.updateAdUnitRewardMapping(adUnitId,
-                    adResponse.getRewardedVideoCurrencyName(),
-                    adResponse.getRewardedVideoCurrencyAmount());
-            mRewardedVideoData.updateAdUnitToServerCompletionUrlMapping(adUnitId,
+            localExtras.put(DataKeys.REWARDED_AD_CUSTOMER_ID_KEY,
+                    mRewardedAdData.getCustomerId());
+
+            // Check for new multi-currency header X-Rewarded-Currencies.
+            final String rewardedCurrencies = adResponse.getRewardedCurrencies();
+
+            // Clear any available rewards for this AdUnit.
+            mRewardedAdData.resetAvailableRewards(adUnitId);
+
+            // If the new multi-currency header doesn't exist, fallback to parsing legacy headers
+            // X-Rewarded-Video-Currency-Name and X-Rewarded-Video-Currency-Amount.
+            if (TextUtils.isEmpty(rewardedCurrencies)) {
+                mRewardedAdData.updateAdUnitRewardMapping(adUnitId,
+                        adResponse.getRewardedVideoCurrencyName(),
+                        adResponse.getRewardedVideoCurrencyAmount());
+            } else {
+                try {
+                    parseMultiCurrencyJson(adUnitId, rewardedCurrencies);
+                } catch (Exception e) {
+                    MoPubLog.e("Error parsing rewarded currencies JSON header: " + rewardedCurrencies);
+                    failover(adUnitId, MoPubErrorCode.REWARDED_CURRENCIES_PARSING_ERROR);
+                    return;
+                }
+            }
+
+            mRewardedAdData.updateAdUnitToServerCompletionUrlMapping(adUnitId,
                     adResponse.getRewardedVideoCompletionUrl());
 
             Activity mainActivity = mMainActivity.get();
             if (mainActivity == null) {
                 MoPubLog.d("Could not load custom event because Activity reference was null. Call" +
-                        " MoPub#updateActivity before requesting more rewarded videos.");
+                        " MoPub#updateActivity before requesting more rewarded ads.");
 
                 // Don't go through the ordinary failover process since we have
                 // no activity for the failover to use.
@@ -402,7 +472,7 @@ private void onAdSuccess(AdResponse adResponse, String adUnitId) {
             Runnable timeout = new Runnable() {
                 @Override
                 public void run() {
-                    MoPubLog.d("Custom Event failed to load rewarded video in a timely fashion.");
+                    MoPubLog.d("Custom Event failed to load rewarded ad in a timely fashion.");
                     onRewardedVideoLoadFailure(customEvent.getClass(), customEvent.getAdNetworkId(),
                             MoPubErrorCode.NETWORK_TIMEOUT);
                     customEvent.onInvalidate();
@@ -412,12 +482,12 @@ public void run() {
             mTimeoutMap.put(adUnitId, timeout);
 
             // Load custom event
+            MoPubLog.d(String.format(Locale.US,
+                    "Loading custom event with class name %s", customEventClassName));
             customEvent.loadCustomEvent(mainActivity, localExtras, adResponse.getServerExtras());
 
-            final CustomEventRewardedVideo.CustomEventRewardedVideoListener listener =
-                    customEvent.getVideoListenerForSdk();
             final String adNetworkId = customEvent.getAdNetworkId();
-            mRewardedVideoData.updateAdUnitCustomEventMapping(adUnitId, customEvent, listener, adNetworkId);
+            mRewardedAdData.updateAdUnitCustomEventMapping(adUnitId, customEvent, adNetworkId);
         } catch (Exception e) {
             MoPubLog.e(String.format(Locale.US, "Couldn't create custom event with class name %s", customEventClassName));
             failover(adUnitId, MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR);
@@ -445,14 +515,50 @@ private void onAdError(@NonNull VolleyError volleyError, @NonNull String adUnitI
         failover(adUnitId, errorCode);
     }
 
+    private void parseMultiCurrencyJson(@NonNull String adUnitId,
+            @NonNull String rewardedCurrencies) throws JSONException {
+        /* Parse multi-currency JSON string, an example below:
+            {
+                "rewards": [
+                    { "name": "Coins", "amount": 8 },
+                    { "name": "Diamonds", "amount": 1 },
+                    { "name": "Diamonds", "amount": 10 },
+                    { "name": "Energy", "amount": 20 }
+                ]
+            }
+         */
+
+        final Map<String, String> rewardsMap = Json.jsonStringToMap(rewardedCurrencies);
+        final String[] rewardsArray =
+                Json.jsonArrayToStringArray(rewardsMap.get(CURRENCIES_JSON_REWARDS_MAP_KEY));
+
+        // If there's only one reward, update adunit-to-reward mapping now
+        if (rewardsArray.length == 1) {
+            Map<String, String> rewardData = Json.jsonStringToMap(rewardsArray[0]);
+            mRewardedAdData.updateAdUnitRewardMapping(
+                    adUnitId,
+                    rewardData.get(CURRENCIES_JSON_REWARD_NAME_KEY),
+                    rewardData.get(CURRENCIES_JSON_REWARD_AMOUNT_KEY));
+        }
+
+        // Loop through awards array and create a set of available reward(s) for this adunit
+        for (String rewardDataStr : rewardsArray) {
+            Map<String, String> rewardData = Json.jsonStringToMap(rewardDataStr);
+            mRewardedAdData.addAvailableReward(
+                    adUnitId,
+                    rewardData.get(CURRENCIES_JSON_REWARD_NAME_KEY),
+                    rewardData.get(CURRENCIES_JSON_REWARD_AMOUNT_KEY));
+        }
+    }
+
     private void failover(@NonNull final String adUnitId, @NonNull final MoPubErrorCode errorCode) {
         final String failoverUrl = mAdRequestStatus.getFailoverUrl(adUnitId);
         mAdRequestStatus.markFail(adUnitId);
 
         if (failoverUrl != null) {
             loadVideo(adUnitId, failoverUrl);
-        } else if (mVideoListener != null) {
-            mVideoListener.onRewardedVideoLoadFailure(adUnitId, errorCode);
+        } else if (sInstance.mVideoListener != null) {
+            sInstance.mVideoListener.onRewardedVideoLoadFailure(adUnitId, errorCode);
         }
     }
 
@@ -466,15 +572,15 @@ private void cancelTimeouts(@NonNull String moPubId) {
     //////// Listener methods that should be called by third-party SDKs. //////////
 
     /**
-     * Notify the manager that a rewarded video loaded successfully.
+     * Notify the manager that a rewarded ad loaded successfully.
      *
      * @param customEventClass - the Class of the third-party custom event object.
      * @param thirdPartyId - the ad id of the third party SDK. This may be an empty String if the
      *                     SDK does not use ad ids, zone ids, or a analogous concept.
-     * @param <T> - a class that extends {@link CustomEventRewardedVideo}. Only rewarded video
+     * @param <T> - a class that extends {@link CustomEventRewardedAd}. Only rewarded ad
      *           custom events should use these methods.
      */
-    public static <T extends CustomEventRewardedVideo>
+    public static <T extends CustomEventRewardedAd>
     void onRewardedVideoLoadSuccess(@NonNull final Class<T> customEventClass, @NonNull final String thirdPartyId) {
         postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
             @Override
@@ -487,7 +593,7 @@ protected void forEach(@NonNull final String moPubId) {
         });
     }
 
-    public static <T extends CustomEventRewardedVideo>
+    public static <T extends CustomEventRewardedAd>
     void onRewardedVideoLoadFailure(@NonNull final Class<T> customEventClass, final String thirdPartyId, final MoPubErrorCode errorCode) {
         postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
             @Override
@@ -498,10 +604,10 @@ protected void forEach(@NonNull final String moPubId) {
         });
     }
 
-    public static <T extends CustomEventRewardedVideo>
+    public static <T extends CustomEventRewardedAd>
     void onRewardedVideoStarted(@NonNull final Class<T> customEventClass, final String thirdPartyId) {
         final String currentlyShowingAdUnitId =
-                sInstance.mRewardedVideoData.getCurrentlyShowingAdUnitId();
+                sInstance.mRewardedAdData.getCurrentlyShowingAdUnitId();
         if (TextUtils.isEmpty(currentlyShowingAdUnitId)) {
             postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
                 @Override
@@ -530,10 +636,10 @@ private static void onRewardedVideoStartedAction(@NonNull final String adUnitId)
         sInstance.mAdRequestStatus.clearImpressionUrl(adUnitId);
     }
 
-    public static <T extends CustomEventRewardedVideo>
+    public static <T extends CustomEventRewardedAd>
     void onRewardedVideoPlaybackError(@NonNull final Class<T> customEventClass, final String thirdPartyId, final MoPubErrorCode errorCode) {
         final String currentlyShowingAdUnitId =
-                sInstance.mRewardedVideoData.getCurrentlyShowingAdUnitId();
+                sInstance.mRewardedAdData.getCurrentlyShowingAdUnitId();
         if (TextUtils.isEmpty(currentlyShowingAdUnitId)) {
             postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
                 @Override
@@ -559,10 +665,10 @@ private static void onRewardedVideoPlaybackErrorAction(@NonNull final String adU
         }
     }
 
-    public static <T extends CustomEventRewardedVideo>
+    public static <T extends CustomEventRewardedAd>
     void onRewardedVideoClicked(@NonNull final Class<T> customEventClass, final String thirdPartyId) {
         final String currentlyShowingAdUnitId =
-                sInstance.mRewardedVideoData.getCurrentlyShowingAdUnitId();
+                sInstance.mRewardedAdData.getCurrentlyShowingAdUnitId();
         if (TextUtils.isEmpty(currentlyShowingAdUnitId)) {
             postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
                 @Override
@@ -588,10 +694,10 @@ private static void onRewardedVideoClickedAction(@NonNull final String adUnitId)
         sInstance.mAdRequestStatus.clearClickUrl(adUnitId);
     }
 
-    public static <T extends CustomEventRewardedVideo>
+    public static <T extends CustomEventRewardedAd>
     void onRewardedVideoClosed(@NonNull final Class<T> customEventClass, final String thirdPartyId) {
         final String currentlyShowingAdUnitId =
-                sInstance.mRewardedVideoData.getCurrentlyShowingAdUnitId();
+                sInstance.mRewardedAdData.getCurrentlyShowingAdUnitId();
         if (TextUtils.isEmpty(currentlyShowingAdUnitId)) {
             postToInstance(new ForEachMoPubIdRunnable(customEventClass, thirdPartyId) {
                 @Override
@@ -607,7 +713,7 @@ public void run() {
                 }
             });
         }
-        sInstance.mRewardedVideoData.setCurrentlyShowingAdUnitId(null);
+        sInstance.mRewardedAdData.setCurrentlyShowingAdUnitId(null);
     }
 
     private static void onRewardedVideoClosedAction(@NonNull final String adUnitId) {
@@ -617,24 +723,24 @@ private static void onRewardedVideoClosedAction(@NonNull final String adUnitId)
         }
     }
 
-    public static <T extends CustomEventRewardedVideo>
+    public static <T extends CustomEventRewardedAd>
     void onRewardedVideoCompleted(@NonNull final Class<T> customEventClass, final String thirdPartyId, @NonNull final MoPubReward moPubReward) {
         // Unlike other callbacks in this class, only call the listener once with all the MoPubIds in the matching set.
         final String currentlyShowingAdUnitId =
-                sInstance.mRewardedVideoData.getCurrentlyShowingAdUnitId();
-        final String serverCompletionUrl = sInstance.mRewardedVideoData.getServerCompletionUrl(
+                sInstance.mRewardedAdData.getCurrentlyShowingAdUnitId();
+        final String serverCompletionUrl = sInstance.mRewardedAdData.getServerCompletionUrl(
                 currentlyShowingAdUnitId);
         if (TextUtils.isEmpty(serverCompletionUrl)) {
             postToInstance(new Runnable() {
                 @Override
                 public void run() {
                     final MoPubReward chosenReward = chooseReward(
-                            sInstance.mRewardedVideoData.getLastShownMoPubReward(customEventClass),
+                            sInstance.mRewardedAdData.getLastShownMoPubReward(customEventClass),
                             moPubReward);
 
                     Set<String> rewardedIds = new HashSet<String>();
                     if (TextUtils.isEmpty(currentlyShowingAdUnitId)) {
-                        final Set<String> moPubIds = sInstance.mRewardedVideoData.getMoPubIdsForAdNetwork(
+                        final Set<String> moPubIds = sInstance.mRewardedAdData.getMoPubIdsForAdNetwork(
                                 customEventClass, thirdPartyId);
                         rewardedIds.addAll(moPubIds);
                     } else {
@@ -653,10 +759,22 @@ public void run() {
             postToInstance(new Runnable() {
                 @Override
                 public void run() {
+                    final MoPubReward reward
+                            = sInstance.mRewardedAdData.getMoPubReward(currentlyShowingAdUnitId);
+
+                    final String rewardName = (reward == null)
+                            ? MoPubReward.NO_REWARD_LABEL
+                            : reward.getLabel();
+                    final String rewardAmount = (reward == null)
+                            ? Integer.toString(MoPubReward.DEFAULT_REWARD_AMOUNT)
+                            : Integer.toString(reward.getAmount());
+
                     RewardedVideoCompletionRequestHandler.makeRewardedVideoCompletionRequest(
                             sInstance.mContext,
                             serverCompletionUrl,
-                            sInstance.mRewardedVideoData.getCustomerId());
+                            sInstance.mRewardedAdData.getCustomerId(),
+                            rewardName,
+                            rewardAmount);
                 }
             });
         }
@@ -683,20 +801,20 @@ private static void postToInstance(@NonNull Runnable runnable) {
     }
 
     private static void logErrorNotInitialized() {
-        MoPubLog.e("MoPub rewarded video was not initialized. You must call " +
+        MoPubLog.e("MoPub rewarded ad was not initialized. You must call " +
                 "MoPub.initializeRewardedVideo() before loading or attempting " +
-                "to play video ads.");
+                "to play rewarded ads.");
     }
 
     /**
-     * A runnable that calls forEach on each member of the rewarded video data passed to the runnable.
+     * A runnable that calls forEach on each member of the rewarded ad data passed to the runnable.
      */
     private static abstract class ForEachMoPubIdRunnable implements Runnable {
 
-        @NonNull private final Class<? extends CustomEventRewardedVideo> mCustomEventClass;
+        @NonNull private final Class<? extends CustomEventRewardedAd> mCustomEventClass;
         @NonNull private final String mThirdPartyId;
 
-        ForEachMoPubIdRunnable(@NonNull final Class<? extends CustomEventRewardedVideo> customEventClass,
+        ForEachMoPubIdRunnable(@NonNull final Class<? extends CustomEventRewardedAd> customEventClass,
                 @NonNull final String thirdPartyId) {
             Preconditions.checkNotNull(customEventClass);
             Preconditions.checkNotNull(thirdPartyId);
@@ -708,7 +826,7 @@ private static void logErrorNotInitialized() {
 
         @Override
         public void run() {
-            final Set<String> moPubIds = sInstance.mRewardedVideoData
+            final Set<String> moPubIds = sInstance.mRewardedAdData
                     .getMoPubIdsForAdNetwork(mCustomEventClass, mThirdPartyId);
             for (String moPubId : moPubIds) {
                 forEach(moPubId);
@@ -719,9 +837,9 @@ public void run() {
     @Deprecated
     @VisibleForTesting
     @Nullable
-    static RewardedVideoData getRewardedVideoData() {
+    static RewardedAdData getRewardedAdData() {
         if (sInstance != null) {
-            return sInstance.mRewardedVideoData;
+            return sInstance.mRewardedAdData;
         }
         return null;
     }
diff --git a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedVideos.java b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedVideos.java
index 3fd9c37b..9e7577c3 100644
--- a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedVideos.java
+++ b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/MoPubRewardedVideos.java
@@ -5,9 +5,12 @@
 import android.support.annotation.Nullable;
 
 import com.mopub.common.MediationSettings;
+import com.mopub.common.MoPubReward;
 import com.mopub.common.Preconditions;
 import com.mopub.common.util.ReflectionTarget;
 
+import java.util.Set;
+
 /**
  * MoPubRewardedVideos is a utility class that holds controller methods for other MoPub rewarded
  * video classes.
@@ -57,4 +60,19 @@ public static void showRewardedVideo(@NonNull String adUnitId) {
 
         MoPubRewardedVideoManager.showVideo(adUnitId);
     }
+
+    @ReflectionTarget
+    public static Set<MoPubReward> getAvailableRewards(@NonNull String adUnitId) {
+        Preconditions.checkNotNull(adUnitId);
+
+        return MoPubRewardedVideoManager.getAvailableRewards(adUnitId);
+    }
+
+    @ReflectionTarget
+    public static void selectReward(@NonNull String adUnitId, @NonNull MoPubReward selectedReward) {
+        Preconditions.checkNotNull(adUnitId);
+        Preconditions.checkNotNull(selectedReward);
+
+        MoPubRewardedVideoManager.selectReward(adUnitId, selectedReward);
+    }
 }
diff --git a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/RewardedVideoData.java b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/RewardedAdData.java
similarity index 56%
rename from mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/RewardedVideoData.java
rename to mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/RewardedAdData.java
index 1023820d..f67a6f48 100644
--- a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/RewardedVideoData.java
+++ b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/RewardedAdData.java
@@ -8,48 +8,50 @@
 import com.mopub.common.MoPubReward;
 import com.mopub.common.Preconditions;
 import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
 
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 import java.util.TreeMap;
 
 /**
- * Used to manage the mapping between MoPub ad unit ids and third-party ad network ids for rewarded videos.
+ * Used to manage the mapping between MoPub ad unit ids and third-party ad network ids for rewarded ads.
  */
-class RewardedVideoData {
+class RewardedAdData {
     @NonNull
-    private final Map<String, CustomEventRewardedVideo> mAdUnitToCustomEventMap;
+    private final Map<String, CustomEventRewardedAd> mAdUnitToCustomEventMap;
     @NonNull
     private final Map<String, MoPubReward> mAdUnitToRewardMap;
     @NonNull
+    private final Map<String, Set<MoPubReward>> mAdUnitToAvailableRewardsMap;
+    @NonNull
     private final Map<String, String> mAdUnitToServerCompletionUrlMap;
     @NonNull
-    private final Map<Class<? extends CustomEventRewardedVideo>, MoPubReward> mCustomEventToRewardMap;
+    private final Map<Class<? extends CustomEventRewardedAd>, MoPubReward> mCustomEventToRewardMap;
     @NonNull
     private final Map<TwoPartKey, Set<String>> mCustomEventToMoPubIdMap;
-    @NonNull
-    private final Set<CustomEventRewardedVideo.CustomEventRewardedVideoListener> mAdNetworkListeners;
     @Nullable
     private String mCurrentlyShowingAdUnitId;
     @Nullable
     private String mCustomerId;
 
 
-    RewardedVideoData() {
-        mAdUnitToCustomEventMap = new TreeMap<String, CustomEventRewardedVideo>();
+    RewardedAdData() {
+        mAdUnitToCustomEventMap = new TreeMap<String, CustomEventRewardedAd>();
         mAdUnitToRewardMap = new TreeMap<String, MoPubReward>();
+        mAdUnitToAvailableRewardsMap = new TreeMap<String, Set<MoPubReward>>();
         mAdUnitToServerCompletionUrlMap = new TreeMap<String, String>();
-        mCustomEventToRewardMap = new HashMap<Class<? extends CustomEventRewardedVideo>, MoPubReward>();
+        mCustomEventToRewardMap = new HashMap<Class<? extends CustomEventRewardedAd>, MoPubReward>();
         mCustomEventToMoPubIdMap = new HashMap<TwoPartKey, Set<String>>();
-        mAdNetworkListeners = new HashSet<CustomEventRewardedVideo.CustomEventRewardedVideoListener>();
     }
 
     @Nullable
-    CustomEventRewardedVideo getCustomEvent(@NonNull String moPubId) {
+    CustomEventRewardedAd getCustomEvent(@NonNull String moPubId) {
         return mAdUnitToCustomEventMap.get(moPubId);
     }
 
@@ -58,6 +60,78 @@ MoPubReward getMoPubReward(@Nullable String moPubId) {
         return mAdUnitToRewardMap.get(moPubId);
     }
 
+    void addAvailableReward(
+            @NonNull String moPubId,
+            @Nullable String currencyName,
+            @Nullable String currencyAmount) {
+        Preconditions.checkNotNull(moPubId);
+        if (currencyName == null || currencyAmount == null) {
+            MoPubLog.e(String.format(Locale.US, "Currency name and amount cannot be null: " +
+                    "name = %s, amount = %s", currencyName, currencyAmount));
+            return;
+        }
+
+        int intCurrencyAmount;
+        try {
+            intCurrencyAmount = Integer.parseInt(currencyAmount);
+        } catch(NumberFormatException e) {
+            MoPubLog.e(String.format(Locale.US, "Currency amount must be an integer: %s",
+                    currencyAmount));
+            return;
+        }
+
+        if (intCurrencyAmount < 0) {
+            MoPubLog.e(String.format(Locale.US, "Currency amount cannot be negative: %s",
+                    currencyAmount));
+            return;
+        }
+
+        if (mAdUnitToAvailableRewardsMap.containsKey(moPubId)) {
+            mAdUnitToAvailableRewardsMap.get(moPubId)
+                    .add(MoPubReward.success(currencyName, intCurrencyAmount));
+        } else {
+            HashSet<MoPubReward> availableRewards = new HashSet<>();
+            availableRewards.add(MoPubReward.success(currencyName, intCurrencyAmount));
+            mAdUnitToAvailableRewardsMap.put(moPubId, availableRewards);
+        }
+    }
+
+    @NonNull
+    Set<MoPubReward> getAvailableRewards(@NonNull String moPubId) {
+        Preconditions.checkNotNull(moPubId);
+        Set<MoPubReward> availableRewards = mAdUnitToAvailableRewardsMap.get(moPubId);
+        return (availableRewards == null) ? Collections.<MoPubReward>emptySet() : availableRewards;
+    }
+
+    void selectReward(@NonNull String moPubId, @NonNull MoPubReward selectedReward) {
+        Preconditions.checkNotNull(moPubId);
+        Preconditions.checkNotNull(selectedReward);
+
+        Set<MoPubReward> availableRewards = mAdUnitToAvailableRewardsMap.get(moPubId);
+        if (availableRewards == null || availableRewards.isEmpty()) {
+            MoPubLog.e(String.format(
+                    Locale.US, "AdUnit %s does not have any rewards.", moPubId));
+            return;
+        }
+
+        if (!availableRewards.contains(selectedReward)) {
+            MoPubLog.e(String.format(
+                    Locale.US, "Selected reward is invalid for AdUnit %s.", moPubId));
+            return;
+        }
+
+        updateAdUnitRewardMapping(moPubId, selectedReward.getLabel(),
+                Integer.toString(selectedReward.getAmount()));
+    }
+
+    void resetAvailableRewards(@NonNull String moPubId) {
+        Preconditions.checkNotNull(moPubId);
+        Set<MoPubReward> availableRewards = mAdUnitToAvailableRewardsMap.get(moPubId);
+        if (availableRewards != null && !availableRewards.isEmpty()) {
+            availableRewards.clear();
+        }
+    }
+
     @Nullable
     String getServerCompletionUrl(@Nullable final String moPubId) {
         if (TextUtils.isEmpty(moPubId)) {
@@ -67,13 +141,13 @@ String getServerCompletionUrl(@Nullable final String moPubId) {
     }
 
     @Nullable
-    MoPubReward getLastShownMoPubReward(@NonNull Class<? extends CustomEventRewardedVideo> customEventClass) {
+    MoPubReward getLastShownMoPubReward(@NonNull Class<? extends CustomEventRewardedAd> customEventClass) {
         return mCustomEventToRewardMap.get(customEventClass);
     }
 
     @NonNull
     Set<String> getMoPubIdsForAdNetwork(
-            @NonNull Class<? extends CustomEventRewardedVideo> customEventClass,
+            @NonNull Class<? extends CustomEventRewardedAd> customEventClass,
             @Nullable String adNetworkId) {
         if (adNetworkId == null) {
             final Set<String> allIds = new HashSet<String>();
@@ -94,11 +168,9 @@ MoPubReward getLastShownMoPubReward(@NonNull Class<? extends CustomEventRewarded
 
     void updateAdUnitCustomEventMapping(
             @NonNull String moPubId,
-            @NonNull CustomEventRewardedVideo customEvent,
-            @Nullable CustomEventRewardedVideo.CustomEventRewardedVideoListener listener,
+            @NonNull CustomEventRewardedAd customEvent,
             @NonNull String adNetworkId) {
         mAdUnitToCustomEventMap.put(moPubId, customEvent);
-        mAdNetworkListeners.add(listener);
         associateCustomEventWithMoPubId(customEvent.getClass(), adNetworkId, moPubId);
     }
 
@@ -117,10 +189,14 @@ void updateAdUnitRewardMapping(
         try {
             intCurrencyAmount = Integer.parseInt(currencyAmount);
         } catch(NumberFormatException e) {
+            MoPubLog.e(String.format(Locale.US, "Currency amount must be an integer: %s",
+                    currencyAmount));
             return;
         }
 
         if (intCurrencyAmount < 0) {
+            MoPubLog.e(String.format(Locale.US, "Currency amount cannot be negative: %s",
+                    currencyAmount));
             return;
         }
 
@@ -134,23 +210,23 @@ void updateAdUnitToServerCompletionUrlMapping(@NonNull final String moPubId,
     }
 
     /**
-     * This method should be called right before the rewarded video is shown in order to store the
+     * This method should be called right before the rewarded ad is shown in order to store the
      * reward associated with the custom event class. If called earlier in the rewarded lifecycle,
-     * it's possible that this mapping will be overridden by another reward value before the video
+     * it's possible that this mapping will be overridden by another reward value before the ad
      * is shown.
      *
-     * @param customEventClass the rewarded video custom event class
-     * @param moPubReward the reward from teh MoPub ad server returned in HTTP headers
+     * @param customEventClass the rewarded ad custom event class
+     * @param moPubReward the reward from the MoPub ad server returned in HTTP headers
      */
     void updateCustomEventLastShownRewardMapping(
-            @NonNull final Class<? extends CustomEventRewardedVideo> customEventClass,
+            @NonNull final Class<? extends CustomEventRewardedAd> customEventClass,
             @Nullable final MoPubReward moPubReward) {
         Preconditions.checkNotNull(customEventClass);
         mCustomEventToRewardMap.put(customEventClass, moPubReward);
     }
 
     void associateCustomEventWithMoPubId(
-            @NonNull Class<? extends CustomEventRewardedVideo> customEventClass,
+            @NonNull Class<? extends CustomEventRewardedAd> customEventClass,
             @NonNull String adNetworkId,
             @NonNull String moPubId) {
         final TwoPartKey newCustomEventMapping = new TwoPartKey(customEventClass, adNetworkId);
@@ -207,22 +283,44 @@ String getCustomerId() {
     void clear() {
         mAdUnitToCustomEventMap.clear();
         mAdUnitToRewardMap.clear();
+        mAdUnitToAvailableRewardsMap.clear();
         mAdUnitToServerCompletionUrlMap.clear();
         mCustomEventToRewardMap.clear();
         mCustomEventToMoPubIdMap.clear();
-        mAdNetworkListeners.clear();
         mCurrentlyShowingAdUnitId = null;
         mCustomerId = null;
     }
 
-    private static class TwoPartKey extends Pair<Class<? extends CustomEventRewardedVideo>, String> {
+    @VisibleForTesting
+    @Deprecated
+    /**
+     * This method is purely used as a helper method in unit tests. Note that calling
+     * {@link MoPubReward#success(String, int)} creates a new instance, even with the same reward
+     * label and amount as an existing reward. Therefore, existence of a reward cannot be asserted
+     * simply by comparing objects in the unit tests.
+     */
+    boolean existsInAvailableRewards(@NonNull String moPubId, @NonNull String currencyName,
+            int currencyAmount) {
+        Preconditions.checkNotNull(moPubId);
+        Preconditions.checkNotNull(currencyName);
+
+        for (MoPubReward reward : getAvailableRewards(moPubId)) {
+            if (reward.getLabel().equals(currencyName) && reward.getAmount() == currencyAmount) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    private static class TwoPartKey extends Pair<Class<? extends CustomEventRewardedAd>, String> {
         @NonNull
-        final Class<? extends CustomEventRewardedVideo> customEventClass;
+        final Class<? extends CustomEventRewardedAd> customEventClass;
         @NonNull
         final String adNetworkId;
 
         public TwoPartKey(
-                @NonNull final Class<? extends CustomEventRewardedVideo> customEventClass,
+                @NonNull final Class<? extends CustomEventRewardedAd> customEventClass,
                 @NonNull final String adNetworkId) {
             super(customEventClass, adNetworkId);
 
diff --git a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/RewardedMraidActivity.java b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/RewardedMraidActivity.java
new file mode 100644
index 00000000..38e6846b
--- /dev/null
+++ b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/RewardedMraidActivity.java
@@ -0,0 +1,182 @@
+package com.mopub.mobileads;
+
+import android.content.Context;
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
+import android.util.Log;
+import android.view.View;
+
+import com.mopub.common.AdReport;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.common.logging.MoPubLog;
+import com.mopub.common.util.Intents;
+import com.mopub.exceptions.IntentNotResolvableException;
+import com.mopub.mraid.MraidController.MraidListener;
+import com.mopub.mraid.MraidWebViewDebugListener;
+import com.mopub.mraid.PlacementType;
+import com.mopub.mraid.RewardedMraidController;
+
+import static com.mopub.common.DataKeys.AD_REPORT_KEY;
+import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
+import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
+import static com.mopub.common.DataKeys.REWARDED_AD_DURATION_KEY;
+import static com.mopub.common.DataKeys.SHOULD_REWARD_ON_CLICK_KEY;
+import static com.mopub.common.IntentActions.ACTION_INTERSTITIAL_CLICK;
+import static com.mopub.common.IntentActions.ACTION_INTERSTITIAL_FAIL;
+import static com.mopub.mobileads.BaseInterstitialActivity.JavaScriptWebViewCallbacks.WEB_VIEW_DID_APPEAR;
+import static com.mopub.mobileads.BaseInterstitialActivity.JavaScriptWebViewCallbacks.WEB_VIEW_DID_CLOSE;
+import static com.mopub.mobileads.EventForwardingBroadcastReceiver.broadcastAction;
+
+public class RewardedMraidActivity extends MraidActivity {
+    @Nullable private RewardedMraidController mRewardedMraidController;
+    @Nullable private MraidWebViewDebugListener mDebugListener;
+
+    public static void start(@NonNull Context context, @Nullable AdReport adreport,
+            @Nullable String htmlData, long broadcastIdentifier, int rewardedDuration,
+            boolean shouldRewardOnClick) {
+        final Intent intent = createIntent(context, adreport, htmlData, broadcastIdentifier,
+                rewardedDuration, shouldRewardOnClick);
+        try {
+            Intents.startActivity(context, intent);
+        } catch (IntentNotResolvableException exception) {
+            Log.d("RewardedMraidActivity", "RewardedMraidActivity.class not found. " +
+                    "Did you declare RewardedMraidActivity in your manifest?");
+        }
+    }
+
+    @VisibleForTesting
+    protected static Intent createIntent(@NonNull Context context, @Nullable AdReport adReport,
+            @Nullable String htmlData, long broadcastIdentifier, int rewardedDuration,
+            boolean shouldRewardOnClick) {
+        Intent intent = new Intent(context, RewardedMraidActivity.class);
+        intent.putExtra(HTML_RESPONSE_BODY_KEY, htmlData);
+        intent.putExtra(BROADCAST_IDENTIFIER_KEY, broadcastIdentifier);
+        intent.putExtra(AD_REPORT_KEY, adReport);
+        intent.putExtra(REWARDED_AD_DURATION_KEY, rewardedDuration);
+        intent.putExtra(SHOULD_REWARD_ON_CLICK_KEY, shouldRewardOnClick);
+        return intent;
+    }
+
+    @Override
+    public View getAdView() {
+        final Intent intent = getIntent();
+        final String htmlData = intent.getStringExtra(HTML_RESPONSE_BODY_KEY);
+        if (TextUtils.isEmpty(htmlData)) {
+            MoPubLog.w("RewardedMraidActivity received a null HTML body. Finishing the activity.");
+            finish();
+            return new View(this);
+        } else if (getBroadcastIdentifier() == null) {
+            MoPubLog.w("RewardedMraidActivity received a null broadcast id. Finishing the activity.");
+            finish();
+            return new View(this);
+        }
+
+        final int rewardedDurationInSeconds = intent.getIntExtra(REWARDED_AD_DURATION_KEY,
+                RewardedMraidController.DEFAULT_PLAYABLE_DURATION_FOR_CLOSE_BUTTON_SECONDS);
+        final boolean shouldRewardOnClick = intent.getBooleanExtra(SHOULD_REWARD_ON_CLICK_KEY,
+                RewardedMraidController.DEFAULT_PLAYABLE_SHOULD_REWARD_ON_CLICK);
+
+        mRewardedMraidController = new RewardedMraidController(
+                this, mAdReport, PlacementType.INTERSTITIAL, rewardedDurationInSeconds,
+                getBroadcastIdentifier());
+
+        mRewardedMraidController.setDebugListener(mDebugListener);
+        mRewardedMraidController.setMraidListener(new MraidListener() {
+            @Override
+            public void onLoaded(View view) {
+                // This is only done for the interstitial. Banners have a different mechanism
+                // for tracking third party impressions.
+                mRewardedMraidController.loadJavascript(WEB_VIEW_DID_APPEAR.getJavascript());
+            }
+
+            @Override
+            public void onFailedToLoad() {
+                MoPubLog.d("RewardedMraidActivity failed to load. Finishing the activity");
+                broadcastAction(RewardedMraidActivity.this, getBroadcastIdentifier(),
+                        ACTION_INTERSTITIAL_FAIL);
+                finish();
+            }
+
+            public void onClose() {
+                mRewardedMraidController.loadJavascript(WEB_VIEW_DID_CLOSE.getJavascript());
+                finish();
+            }
+
+            @Override
+            public void onExpand() {
+                // No-op. The interstitial is always expanded.
+            }
+
+            @Override
+            public void onOpen() {
+                if (shouldRewardOnClick) {
+                    mRewardedMraidController.showPlayableCloseButton();
+                }
+                broadcastAction(RewardedMraidActivity.this, getBroadcastIdentifier(),
+                        ACTION_INTERSTITIAL_CLICK);
+            }
+        });
+
+        mRewardedMraidController.loadContent(htmlData);
+        return mRewardedMraidController.getAdContainer();
+    }
+
+    @Override
+    public void onCreate(@Nullable Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        if (mRewardedMraidController != null) {
+            mRewardedMraidController.create(RewardedMraidActivity.this, getCloseableLayout());
+        }
+    }
+
+    @Override
+    protected void onPause() {
+        if (mRewardedMraidController != null) {
+            mRewardedMraidController.pause();
+        }
+        super.onPause();
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        if (mRewardedMraidController != null) {
+            mRewardedMraidController.resume();
+        }
+    }
+
+    @Override
+    protected void onDestroy() {
+        if (mRewardedMraidController != null) {
+            mRewardedMraidController.destroy();
+        }
+
+        super.onDestroy();
+    }
+
+    @Override
+    public void onBackPressed() {
+        if (mRewardedMraidController == null || mRewardedMraidController.backButtonEnabled()) {
+            super.onBackPressed();
+        }
+    }
+
+    @VisibleForTesting
+    public void setDebugListener(@Nullable MraidWebViewDebugListener debugListener) {
+        mDebugListener = debugListener;
+        if (mRewardedMraidController != null) {
+            mRewardedMraidController.setDebugListener(debugListener);
+        }
+    }
+
+    @Nullable
+    @Deprecated
+    @VisibleForTesting
+    public RewardedMraidController getRewardedMraidController() {
+        return mRewardedMraidController;
+    }
+}
diff --git a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/RewardedMraidCountdownRunnable.java b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/RewardedMraidCountdownRunnable.java
new file mode 100644
index 00000000..530b41b0
--- /dev/null
+++ b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/RewardedMraidCountdownRunnable.java
@@ -0,0 +1,42 @@
+package com.mopub.mobileads;
+
+import android.os.Handler;
+import android.support.annotation.NonNull;
+import android.support.annotation.VisibleForTesting;
+
+import com.mopub.common.Preconditions;
+import com.mopub.mraid.RewardedMraidController;
+
+/**
+ * A runnable that is used to update a {@link RewardedMraidController}'s countdown display according
+ * to rules contained in the {@link RewardedMraidController}
+ */
+public class RewardedMraidCountdownRunnable extends RepeatingHandlerRunnable {
+    @NonNull private final RewardedMraidController mRewardedMraidController;
+    private int mCurrentElapsedTimeMillis;
+
+    public RewardedMraidCountdownRunnable(@NonNull RewardedMraidController rewardedMraidController,
+            @NonNull Handler handler) {
+        super(handler);
+        Preconditions.checkNotNull(handler);
+        Preconditions.checkNotNull(rewardedMraidController);
+
+        mRewardedMraidController = rewardedMraidController;
+    }
+
+    @Override
+    public void doWork() {
+        mCurrentElapsedTimeMillis += mUpdateIntervalMillis;
+        mRewardedMraidController.updateCountdown(mCurrentElapsedTimeMillis);
+
+        if (mRewardedMraidController.isPlayableCloseable()) {
+            mRewardedMraidController.showPlayableCloseButton();
+        }
+    }
+
+    @Deprecated
+    @VisibleForTesting
+    int getCurrentElapsedTimeMillis() {
+        return mCurrentElapsedTimeMillis;
+    }
+}
diff --git a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/RewardedVastVideoInterstitial.java b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/RewardedVastVideoInterstitial.java
index 3e1b6c7d..6b0c4ecd 100644
--- a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/RewardedVastVideoInterstitial.java
+++ b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/RewardedVastVideoInterstitial.java
@@ -9,16 +9,12 @@
 
 class RewardedVastVideoInterstitial extends VastVideoInterstitial {
 
-    interface CustomEventRewardedVideoInterstitialListener extends CustomEventInterstitialListener {
+    interface RewardedVideoInterstitialListener extends CustomEventInterstitialListener {
         void onVideoComplete();
     }
 
     @Nullable private RewardedVideoBroadcastReceiver mRewardedVideoBroadcastReceiver;
 
-    public RewardedVastVideoInterstitial() {
-        super();
-    }
-
     @Override
     public void loadInterstitial(
             Context context,
@@ -27,9 +23,9 @@ public void loadInterstitial(
             Map<String, String> serverExtras) {
         super.loadInterstitial(context, customEventInterstitialListener, localExtras, serverExtras);
 
-        if (customEventInterstitialListener instanceof CustomEventRewardedVideoInterstitialListener) {
+        if (customEventInterstitialListener instanceof RewardedVideoInterstitialListener) {
             mRewardedVideoBroadcastReceiver = new RewardedVideoBroadcastReceiver(
-                    (CustomEventRewardedVideoInterstitialListener) customEventInterstitialListener,
+                    (RewardedVideoInterstitialListener) customEventInterstitialListener,
                     mBroadcastIdentifier);
             mRewardedVideoBroadcastReceiver.register(mRewardedVideoBroadcastReceiver, context);
         }
diff --git a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/RewardedVideoBroadcastReceiver.java b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/RewardedVideoBroadcastReceiver.java
index 4ec3c111..506d38b7 100644
--- a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/RewardedVideoBroadcastReceiver.java
+++ b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/RewardedVideoBroadcastReceiver.java
@@ -7,16 +7,17 @@
 import android.support.annotation.Nullable;
 
 import com.mopub.common.IntentActions;
+import com.mopub.common.Preconditions;
 
 public class RewardedVideoBroadcastReceiver extends BaseBroadcastReceiver {
 
     private static IntentFilter sIntentFilter;
 
     @Nullable
-    private RewardedVastVideoInterstitial.CustomEventRewardedVideoInterstitialListener mRewardedVideoListener;
+    private RewardedVastVideoInterstitial.RewardedVideoInterstitialListener mRewardedVideoListener;
 
     public RewardedVideoBroadcastReceiver(
-            @Nullable RewardedVastVideoInterstitial.CustomEventRewardedVideoInterstitialListener rewardedVideoListener,
+            @Nullable RewardedVastVideoInterstitial.RewardedVideoInterstitialListener rewardedVideoListener,
             final long broadcastIdentifier) {
         super(broadcastIdentifier);
         mRewardedVideoListener = rewardedVideoListener;
@@ -34,6 +35,9 @@ public IntentFilter getIntentFilter() {
 
     @Override
     public void onReceive(@NonNull final Context context, @NonNull final Intent intent) {
+        Preconditions.checkNotNull(context);
+        Preconditions.checkNotNull(intent);
+
         if (mRewardedVideoListener == null) {
             return;
         }
diff --git a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/RewardedVideoCompletionRequestHandler.java b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/RewardedVideoCompletionRequestHandler.java
index 5e37c66b..0cb0c34d 100644
--- a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/RewardedVideoCompletionRequestHandler.java
+++ b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mobileads/RewardedVideoCompletionRequestHandler.java
@@ -38,6 +38,8 @@
     private static final String CUSTOMER_ID_KEY = "&customer_id=";
     private static final String SDK_VERSION_KEY = "&nv=";
     private static final String API_VERSION_KEY = "&v=";
+    private static final String REWARD_NAME_KEY = "&rcn=";
+    private static final String REWARD_AMOUNT_KEY = "&rca=";
 
     @NonNull private final String mUrl;
     @NonNull private final Handler mHandler;
@@ -46,17 +48,26 @@
     private volatile boolean mShouldStop;
 
     RewardedVideoCompletionRequestHandler(@NonNull final Context context,
-            @NonNull final String url, @Nullable final String customerId) {
-        this(context, url, customerId, new Handler());
+            @NonNull final String url,
+            @Nullable final String customerId,
+            @NonNull final String rewardName,
+            @NonNull final String rewardAmount) {
+        this(context, url, customerId, rewardName, rewardAmount, new Handler());
     }
 
     RewardedVideoCompletionRequestHandler(@NonNull final Context context,
             @NonNull final String url,
             @Nullable final String customerId,
+            @NonNull final String rewardName,
+            @NonNull final String rewardAmount,
             @NonNull final Handler handler) {
         Preconditions.checkNotNull(context);
         Preconditions.checkNotNull(url);
-        mUrl = appendParameters(url, customerId);
+        Preconditions.checkNotNull(rewardName);
+        Preconditions.checkNotNull(rewardAmount);
+        Preconditions.checkNotNull(handler);
+
+        mUrl = appendParameters(url, customerId, rewardName, rewardAmount);
         mRetryCount = 0;
         mHandler = handler;
         mRequestQueue = Networking.getRequestQueue(context);
@@ -109,13 +120,15 @@ public void onErrorResponse(final VolleyError volleyError) {
 
     public static void makeRewardedVideoCompletionRequest(@Nullable final Context context,
             @Nullable final String url,
-            @Nullable final String customerId) {
-        if (TextUtils.isEmpty(url) || context == null) {
+            @Nullable final String customerId,
+            @NonNull final String rewardName,
+            @NonNull final String rewardAmount) {
+        if (context == null || TextUtils.isEmpty(url) || rewardName == null || rewardAmount == null) {
             return;
         }
 
-        new RewardedVideoCompletionRequestHandler(context,
-                url, customerId).makeRewardedVideoCompletionRequest();
+        new RewardedVideoCompletionRequestHandler(context, url, customerId, rewardName,
+                rewardAmount).makeRewardedVideoCompletionRequest();
     }
 
     static int getTimeout(int retryCount) {
@@ -127,11 +140,17 @@ static int getTimeout(int retryCount) {
     }
 
     private static String appendParameters(@NonNull final String url,
-            @Nullable final String customerId) {
+            @Nullable final String customerId,
+            @NonNull final String rewardName,
+            @NonNull final String rewardAmount) {
         Preconditions.checkNotNull(url);
+        Preconditions.checkNotNull(rewardName);
+        Preconditions.checkNotNull(rewardAmount);
 
         return url +
                 CUSTOMER_ID_KEY + (customerId == null ? "" : Uri.encode(customerId)) +
+                REWARD_NAME_KEY + Uri.encode(rewardName) +
+                REWARD_AMOUNT_KEY + Uri.encode(rewardAmount) +
                 SDK_VERSION_KEY + Uri.encode(MoPub.SDK_VERSION) +
                 API_VERSION_KEY + MoPubRewardedVideoManager.API_VERSION;
     }
diff --git a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mraid/RewardedMraidController.java b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mraid/RewardedMraidController.java
new file mode 100644
index 00000000..ad96fbdc
--- /dev/null
+++ b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mraid/RewardedMraidController.java
@@ -0,0 +1,197 @@
+package com.mopub.mraid;
+
+
+import android.content.Context;
+import android.os.Handler;
+import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.view.Gravity;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.FrameLayout;
+
+import com.mopub.common.AdReport;
+import com.mopub.common.CloseableLayout;
+import com.mopub.common.VisibleForTesting;
+import com.mopub.mobileads.RewardedMraidCountdownRunnable;
+import com.mopub.mobileads.VastVideoRadialCountdownWidget;
+
+import static com.mopub.common.IntentActions.ACTION_REWARDED_PLAYABLE_COMPLETE;
+import static com.mopub.mobileads.BaseBroadcastReceiver.broadcastAction;
+
+public class RewardedMraidController extends MraidController {
+
+    /**
+     * Should reward on click is for when the user should be rewarded when clicking on the
+     * creative. This is defaulted to false so the user must wait for the entire countdown
+     * before able to leave the app.
+     */
+    public static final boolean DEFAULT_PLAYABLE_SHOULD_REWARD_ON_CLICK = false;
+
+    /**
+     * If a duration is not specified, this duration is used. 30 seconds is also the maximum
+     * amount of time that we currently allow rewarded playables to be not closeable.
+     */
+    public static final int DEFAULT_PLAYABLE_DURATION_FOR_CLOSE_BUTTON_SECONDS = 30;
+
+    public static final int MILLIS_IN_SECOND = 1000;
+
+    @VisibleForTesting
+    static final int DEFAULT_PLAYABLE_DURATION_FOR_CLOSE_BUTTON_MILLIS =
+            DEFAULT_PLAYABLE_DURATION_FOR_CLOSE_BUTTON_SECONDS * MILLIS_IN_SECOND;
+    @VisibleForTesting
+    static final long PLAYABLE_COUNTDOWN_UPDATE_INTERVAL_MILLIS = 250;
+
+    @NonNull private CloseableLayout mCloseableLayout;
+    @NonNull private VastVideoRadialCountdownWidget mRadialCountdownWidget;
+    @NonNull private RewardedMraidCountdownRunnable mCountdownRunnable;
+
+    private final int mShowCloseButtonDelay;
+    private final long mBroadcastIdentifier;
+
+    private int mCurrentElapsedTimeMillis;
+    private boolean mShowCloseButtonEventFired;
+    private boolean mIsCalibrationDone;
+    private boolean mIsRewarded;
+
+    @VisibleForTesting
+    public RewardedMraidController(@NonNull Context context, @Nullable AdReport adReport,
+            @NonNull PlacementType placementType, int rewardedDurationInSeconds,
+            long broadcastIdentifier) {
+        super(context, adReport, placementType);
+        final int rewardedDurationInMillis = rewardedDurationInSeconds * MILLIS_IN_SECOND;
+        if (rewardedDurationInMillis < 0
+                || rewardedDurationInMillis > DEFAULT_PLAYABLE_DURATION_FOR_CLOSE_BUTTON_MILLIS) {
+            mShowCloseButtonDelay = DEFAULT_PLAYABLE_DURATION_FOR_CLOSE_BUTTON_MILLIS;
+        } else {
+            mShowCloseButtonDelay = rewardedDurationInMillis;
+        }
+        mBroadcastIdentifier = broadcastIdentifier;
+    }
+
+    public void create(@NonNull Context context, CloseableLayout closeableLayout) {
+        mCloseableLayout = closeableLayout;
+        mCloseableLayout.setCloseAlwaysInteractable(false);
+        mCloseableLayout.setCloseVisible(false);
+
+        addRadialCountdownWidget(context, View.INVISIBLE);
+        mRadialCountdownWidget.calibrateAndMakeVisible(mShowCloseButtonDelay);
+        mIsCalibrationDone = true;
+
+        Handler mainHandler = new Handler(Looper.getMainLooper());
+        mCountdownRunnable = new RewardedMraidCountdownRunnable(this, mainHandler);
+    }
+
+    public void pause() {
+        stopRunnables();
+    }
+
+    @Override
+    public void resume() {
+        startRunnables();
+    }
+
+    @Override
+    public void destroy() {
+        stopRunnables();
+    }
+
+    @Override
+    protected void handleCustomClose(boolean useCustomClose) {
+    }
+
+    @Override
+    protected void handleClose() {
+        if (mShowCloseButtonEventFired) {
+            super.handleClose();
+        }
+    }
+
+    public boolean backButtonEnabled() {
+        return mShowCloseButtonEventFired;
+    }
+
+    public boolean isPlayableCloseable() {
+        return !mShowCloseButtonEventFired && mCurrentElapsedTimeMillis >= mShowCloseButtonDelay;
+    }
+
+    public void showPlayableCloseButton() {
+        mShowCloseButtonEventFired = true;
+
+        mRadialCountdownWidget.setVisibility(View.GONE);
+        mCloseableLayout.setCloseVisible(true);
+
+        if (!mIsRewarded) {
+            broadcastAction(getContext(), mBroadcastIdentifier, ACTION_REWARDED_PLAYABLE_COMPLETE);
+            mIsRewarded = true;
+        }
+    }
+
+    public void updateCountdown(int currentElapsedTimeMillis) {
+        mCurrentElapsedTimeMillis = currentElapsedTimeMillis;
+        if (mIsCalibrationDone) {
+            mRadialCountdownWidget.updateCountdownProgress(mShowCloseButtonDelay,
+                    mCurrentElapsedTimeMillis);
+        }
+    }
+
+    private void startRunnables() {
+        mCountdownRunnable.startRepeating(PLAYABLE_COUNTDOWN_UPDATE_INTERVAL_MILLIS);
+    }
+
+    private void stopRunnables() {
+        mCountdownRunnable.stop();
+    }
+
+    private void addRadialCountdownWidget(@NonNull final Context context, int initialVisibility) {
+        mRadialCountdownWidget = new VastVideoRadialCountdownWidget(context);
+        mRadialCountdownWidget.setVisibility(initialVisibility);
+
+        ViewGroup.MarginLayoutParams lp =
+                (ViewGroup.MarginLayoutParams) mRadialCountdownWidget.getLayoutParams();
+        final int widgetWidth = lp.width + lp.leftMargin + lp.rightMargin;
+        final int widgetHeight = lp.height + lp.topMargin + lp.bottomMargin;
+
+        FrameLayout.LayoutParams widgetLayoutParams =
+                new FrameLayout.LayoutParams(widgetWidth, widgetHeight);
+        widgetLayoutParams.gravity = Gravity.TOP | Gravity.RIGHT;
+        mCloseableLayout.addView(mRadialCountdownWidget, widgetLayoutParams);
+    }
+
+    @Deprecated
+    @VisibleForTesting
+    public int getShowCloseButtonDelay() {
+        return mShowCloseButtonDelay;
+    }
+
+    @Deprecated
+    @VisibleForTesting
+    public VastVideoRadialCountdownWidget getRadialCountdownWidget() {
+        return mRadialCountdownWidget;
+    }
+
+    @Deprecated
+    @VisibleForTesting
+    public RewardedMraidCountdownRunnable getCountdownRunnable() {
+        return mCountdownRunnable;
+    }
+
+    @Deprecated
+    @VisibleForTesting
+    public boolean isCalibrationDone() {
+        return mIsCalibrationDone;
+    }
+
+    @Deprecated
+    @VisibleForTesting
+    public boolean isShowCloseButtonEventFired() {
+        return mShowCloseButtonEventFired;
+    }
+
+    @Deprecated
+    @VisibleForTesting
+    public boolean isRewarded() {
+        return mIsRewarded;
+    }
+}
diff --git a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mraid/RewardedMraidInterstitial.java b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mraid/RewardedMraidInterstitial.java
new file mode 100644
index 00000000..32bf7b3f
--- /dev/null
+++ b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mraid/RewardedMraidInterstitial.java
@@ -0,0 +1,80 @@
+package com.mopub.mraid;
+
+import android.content.Context;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.VisibleForTesting;
+import com.mopub.mobileads.CustomEventInterstitial;
+import com.mopub.mobileads.RewardedMraidActivity;
+
+import java.util.Map;
+
+import static com.mopub.common.DataKeys.REWARDED_AD_DURATION_KEY;
+import static com.mopub.common.DataKeys.SHOULD_REWARD_ON_CLICK_KEY;
+
+/**
+ * Handles the showing of rewarded MRAID interstitials. 'Rewarded duration' and 'should reward on
+ * click' are optional and will default to the values set in {@link RewardedMraidController}.
+ */
+public class RewardedMraidInterstitial extends MraidInterstitial {
+
+    public interface RewardedMraidInterstitialListener extends CustomEventInterstitial.CustomEventInterstitialListener {
+        void onMraidComplete();
+    }
+
+    @Nullable private RewardedPlayableBroadcastReceiver mRewardedPlayableBroadcastReceiver;
+    private int mRewardedDuration;
+    private boolean mShouldRewardOnClick;
+
+    @Override
+    public void loadInterstitial(
+            Context context,
+            CustomEventInterstitialListener customEventInterstitialListener,
+            Map<String, Object> localExtras,
+            Map<String, String> serverExtras) {
+        super.loadInterstitial(context, customEventInterstitialListener, localExtras, serverExtras);
+
+        if (customEventInterstitialListener instanceof RewardedMraidInterstitialListener) {
+            mRewardedPlayableBroadcastReceiver = new RewardedPlayableBroadcastReceiver(
+                    (RewardedMraidInterstitialListener) customEventInterstitialListener,
+                    mBroadcastIdentifier);
+            mRewardedPlayableBroadcastReceiver.register(mRewardedPlayableBroadcastReceiver, context);
+        }
+
+        final Object rewardedDurationObject = localExtras.get(REWARDED_AD_DURATION_KEY);
+        mRewardedDuration = rewardedDurationObject instanceof Integer ?
+                (int) rewardedDurationObject :
+                RewardedMraidController.DEFAULT_PLAYABLE_DURATION_FOR_CLOSE_BUTTON_SECONDS;
+        final Object shouldRewardOnClickObject = localExtras.get(SHOULD_REWARD_ON_CLICK_KEY);
+        mShouldRewardOnClick = shouldRewardOnClickObject instanceof Boolean ?
+                (boolean) shouldRewardOnClickObject :
+                RewardedMraidController.DEFAULT_PLAYABLE_SHOULD_REWARD_ON_CLICK;
+    }
+
+    @Override
+    public void showInterstitial() {
+        RewardedMraidActivity.start(mContext, mAdReport, mHtmlData, mBroadcastIdentifier,
+                mRewardedDuration, mShouldRewardOnClick);
+    }
+
+
+    @Override
+    public void onInvalidate() {
+        super.onInvalidate();
+        if (mRewardedPlayableBroadcastReceiver != null) {
+            mRewardedPlayableBroadcastReceiver.unregister(mRewardedPlayableBroadcastReceiver);
+        }
+    }
+
+    @Deprecated
+    @VisibleForTesting
+    int getRewardedDuration() {
+        return mRewardedDuration;
+    }
+
+    @Deprecated
+    @VisibleForTesting
+    boolean isShouldRewardOnClick() {
+        return mShouldRewardOnClick;
+    }
+}
diff --git a/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mraid/RewardedPlayableBroadcastReceiver.java b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mraid/RewardedPlayableBroadcastReceiver.java
new file mode 100644
index 00000000..4599a175
--- /dev/null
+++ b/mopub-sdk/mopub-sdk-rewardedvideo/src/main/java/com/mopub/mraid/RewardedPlayableBroadcastReceiver.java
@@ -0,0 +1,55 @@
+package com.mopub.mraid;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.mopub.common.IntentActions;
+import com.mopub.mobileads.BaseBroadcastReceiver;
+
+/**
+ * Handles the rewarded playable complete broadcast.
+ */
+public class RewardedPlayableBroadcastReceiver extends BaseBroadcastReceiver {
+
+    private static IntentFilter sIntentFilter;
+
+    @Nullable
+    private RewardedMraidInterstitial.RewardedMraidInterstitialListener mRewardedMraidListener;
+
+    public RewardedPlayableBroadcastReceiver(
+            @Nullable RewardedMraidInterstitial.RewardedMraidInterstitialListener rewardedVideoListener,
+            final long broadcastIdentifier) {
+        super(broadcastIdentifier);
+        mRewardedMraidListener = rewardedVideoListener;
+        getIntentFilter();
+    }
+
+    @NonNull
+    public IntentFilter getIntentFilter() {
+        if (sIntentFilter == null) {
+            sIntentFilter = new IntentFilter();
+            sIntentFilter.addAction(IntentActions.ACTION_REWARDED_PLAYABLE_COMPLETE);
+        }
+        return sIntentFilter;
+    }
+
+    @Override
+    public void onReceive(@NonNull final Context context, @NonNull final Intent intent) {
+        if (mRewardedMraidListener == null) {
+            return;
+        }
+
+        if (!shouldConsumeBroadcast(intent)) {
+            return;
+        }
+
+        final String action = intent.getAction();
+        if (IntentActions.ACTION_REWARDED_PLAYABLE_COMPLETE.equals(action)) {
+            mRewardedMraidListener.onMraidComplete();
+            unregister(this);
+        }
+    }
+}
diff --git a/mopub-sdk/proguard.txt b/mopub-sdk/proguard.txt
index 2aecdd6d..caf3b903 100644
--- a/mopub-sdk/proguard.txt
+++ b/mopub-sdk/proguard.txt
@@ -11,6 +11,10 @@
 -keep class * extends com.mopub.mobileads.CustomEventBanner {}
 -keep class * extends com.mopub.mobileads.CustomEventInterstitial {}
 -keep class * extends com.mopub.nativeads.CustomEventNative {}
+<<<<<<< HEAD
+=======
+-keep class * extends com.mopub.nativeads.CustomEventRewardedAd {}
+>>>>>>> e037a082630d67f8545ccd04635a903053888390
 
 # Keep methods that are accessed via reflection
 -keepclassmembers class ** { @com.mopub.common.util.ReflectionTarget *; }
@@ -19,8 +23,22 @@
 -keep class com.google.android.gms.common.GooglePlayServicesUtil {*;}
 -keep class com.google.android.gms.ads.identifier.AdvertisingIdClient {*;}
 -keep class com.google.android.gms.ads.identifier.AdvertisingIdClient$Info {*;}
--dontwarn com.google.android.gms.**
 
-# Filter out warnings that refer to legacy Code.
--dontwarn org.apache.http.**
--dontwarn com.mopub.volley.toolbox.**
+# Support for Google Play Services
+# http://developer.android.com/google/play-services/setup.html
+-keep class * extends java.util.ListResourceBundle {
+    protected Object[][] getContents();
+}
+
+-keep public class com.google.android.gms.common.internal.safeparcel.SafeParcelable {
+    public static final *** NULL;
+}
+
+-keepnames @com.google.android.gms.common.annotation.KeepName class *
+-keepclassmembernames class * {
+    @com.google.android.gms.common.annotation.KeepName *;
+}
+
+-keepnames class * implements android.os.Parcelable {
+    public static final ** CREATOR;
+}
diff --git a/mopub-sdk/shared-build.gradle b/mopub-sdk/shared-build.gradle
index cc82fef6..bd8ad001 100644
--- a/mopub-sdk/shared-build.gradle
+++ b/mopub-sdk/shared-build.gradle
@@ -8,7 +8,7 @@ repositories {
 }
 
 project.group = 'com.mopub'
-project.version = '4.11.0'
+project.version = '4.13.0'
 
 android {
 	compileSdkVersion 24
@@ -17,7 +17,7 @@ android {
 	useLibrary 'org.apache.http.legacy'
 
 	defaultConfig {
-		versionCode 48
+		versionCode 50
 		versionName version
 		minSdkVersion 16
 		targetSdkVersion 24
diff --git a/mopub-sdk/src/main/resources/fabric/com.mopub.sdk.android.mopub.properties b/mopub-sdk/src/main/resources/fabric/com.mopub.sdk.android.mopub.properties
index 23ca26ca..12bcf2e5 100644
--- a/mopub-sdk/src/main/resources/fabric/com.mopub.sdk.android.mopub.properties
+++ b/mopub-sdk/src/main/resources/fabric/com.mopub.sdk.android.mopub.properties
@@ -1,3 +1,3 @@
 fabric-identifier=com.mopub.sdk.android:mopub
-fabric-version=4.11.0+kit
+fabric-version=4.13.0+kit
 fabric-build-type=source
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/ManifestUtilsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/ManifestUtilsTest.java
deleted file mode 100644
index a42b716d..00000000
--- a/mopub-sdk/src/test/java/com/mopub/common/util/ManifestUtilsTest.java
+++ /dev/null
@@ -1,443 +0,0 @@
-package com.mopub.common.util;
-
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.ActivityInfo;
-import android.content.pm.ApplicationInfo;
-import android.content.pm.ResolveInfo;
-import android.os.Build;
-
-import com.mopub.TestSdkHelper;
-import com.mopub.common.MoPubBrowser;
-import com.mopub.mobileads.MoPubActivity;
-import com.mopub.mobileads.MraidActivity;
-import com.mopub.mobileads.MraidVideoPlayerActivity;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
-import org.robolectric.shadows.ShadowLog;
-import org.robolectric.shadows.ShadowToast;
-
-import java.util.List;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.when;
-
-@RunWith(RobolectricTestRunner.class)
-public class ManifestUtilsTest {
-    private Context context;
-    private List<Class<? extends Activity>> requiredWebViewSdkActivities;
-    private List<Class<? extends Activity>> requiredNativeSdkActivities;
-
-    @Mock private ResolveInfo mockResolveInfo;
-
-    @Before
-    public void setUp() throws Exception {
-        context = spy(Robolectric.buildActivity(Activity.class).create().get());
-
-        requiredWebViewSdkActivities = ManifestUtils.getRequiredWebViewSdkActivities();
-        requiredNativeSdkActivities = ManifestUtils.getRequiredNativeSdkActivities();
-
-        setDebugMode(false);
-    }
-
-    @After
-    public void tearDown() throws Exception {
-        setDebugMode(false);
-        // This may have been set to a mock during testing. Reset this class back to normal
-        ManifestUtils.setFlagCheckUtil(new ManifestUtils.FlagCheckUtil());
-
-        addInterstitialModule();
-    }
-
-    @Test
-    public void checkWebViewSdkActivitiesDeclared_shouldIncludeFourActivityDeclarations() throws Exception {
-        ShadowLog.setupLogging();
-
-        ManifestUtils.checkWebViewActivitiesDeclared(context);
-
-        assertLogIncludes(
-                "com.mopub.mobileads.MoPubActivity",
-                "com.mopub.mobileads.MraidActivity",
-                "com.mopub.mobileads.MraidVideoPlayerActivity",
-                "com.mopub.common.MoPubBrowser"
-        );
-    }
-
-    @Test
-    public void checkNativeSdkActivitiesDeclared_shouldIncludeOneActivityDeclaration() throws Exception {
-        ShadowLog.setupLogging();
-
-        ManifestUtils.checkNativeActivitiesDeclared(context);
-
-        assertLogIncludes("com.mopub.common.MoPubBrowser");
-        assertLogDoesntInclude(
-                "com.mopub.mobileads.MoPubActivity",
-                "com.mopub.mobileads.MraidActivity",
-                "com.mopub.mobileads.MraidVideoPlayerActivity"
-        );
-    }
-
-    @Test
-    public void displayWarningForMissingActivities_withAllActivitiesDeclared_shouldNotShowLogOrToast() throws Exception {
-        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
-        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MraidActivity.class), mockResolveInfo);
-        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MraidVideoPlayerActivity.class), mockResolveInfo);
-        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MoPubBrowser.class), mockResolveInfo);
-
-        ShadowLog.setupLogging();
-        setDebugMode(true);
-
-        ManifestUtils.displayWarningForMissingActivities(context, requiredWebViewSdkActivities);
-
-        assertThat(ShadowToast.getLatestToast()).isNull();
-        assertThat(ShadowLog.getLogs()).isEmpty();
-    }
-
-    @Test
-    public void displayWarningForMissingActivities_withoutInterstitialModule_withoutInterstitialActivitiesDeclared_shouldNotShowLogOrToast() throws Exception {
-        removeInterstitialModule();
-        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MraidVideoPlayerActivity.class), mockResolveInfo);
-        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MoPubBrowser.class), mockResolveInfo);
-
-        ShadowLog.setupLogging();
-        setDebugMode(true);
-
-        ManifestUtils.displayWarningForMissingActivities(context, requiredWebViewSdkActivities);
-
-        assertThat(ShadowToast.getLatestToast()).isNull();
-        assertThat(ShadowLog.getLogs()).isEmpty();
-    }
-
-    @Test
-     public void displayWarningForMissingActivities_withOneMissingActivity_shouldLogOnlyThatOne() throws Exception {
-        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
-        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MraidActivity.class), mockResolveInfo);
-        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MraidVideoPlayerActivity.class), mockResolveInfo);
-        // Here, we leave out MoPubBrowser on purpose
-
-        ShadowLog.setupLogging();
-
-        ManifestUtils.displayWarningForMissingActivities(context, requiredWebViewSdkActivities);
-
-        assertLogIncludes("com.mopub.common.MoPubBrowser");
-        assertLogDoesntInclude(
-                "com.mopub.mobileads.MoPubActivity",
-                "com.mopub.mobileads.MraidActivity",
-                "com.mopub.mobileads.MraidVideoPlayerActivity"
-        );
-    }
-
-    @Test
-    public void displayWarningForMissingActivities_withAllMissingActivities_shouldLogMessage() throws Exception {
-        setDebugMode(true);
-        ShadowLog.setupLogging();
-
-        ManifestUtils.displayWarningForMissingActivities(context, requiredWebViewSdkActivities);
-
-        final List<ShadowLog.LogItem> logs = ShadowLog.getLogs();
-
-        assertLogIncludes(
-                "com.mopub.mobileads.MoPubActivity",
-                "com.mopub.mobileads.MraidActivity",
-                "com.mopub.mobileads.MraidVideoPlayerActivity",
-                "com.mopub.common.MoPubBrowser"
-        );
-    }
-
-    @Test
-    public void displayWarningForMissingActivities_withMissingActivities_withDebugTrue_shouldShowToast() throws Exception {
-        setDebugMode(true);
-
-        ManifestUtils.displayWarningForMissingActivities(context, requiredWebViewSdkActivities);
-
-        assertThat(ShadowToast.getLatestToast()).isNotNull();
-        final String toastText = ShadowToast.getTextOfLatestToast();
-        assertThat(toastText).isEqualTo("ERROR: YOUR MOPUB INTEGRATION IS INCOMPLETE.\nCheck logcat and update your AndroidManifest.xml with the correct activities and configuration.");
-    }
-
-    @Test
-    public void displayWarningForMissingActivities_withMissingActivities_withDebugFalse_shouldNotShowToast() throws Exception {
-        setDebugMode(false);
-
-        ManifestUtils.displayWarningForMissingActivities(context, requiredWebViewSdkActivities);
-
-        assertThat(ShadowToast.getLatestToast()).isNull();
-    }
-
-    @SuppressWarnings("unchecked")
-    @TargetApi(13)
-    @Test
-    public void displayWarningForMisconfiguredActivities_withAllActivitiesConfigured_shouldNotLogOrShowToast() throws Exception {
-        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN))).thenReturn(true);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(true);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(true);
-        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
-
-        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
-        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MraidActivity.class), mockResolveInfo);
-        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MraidVideoPlayerActivity.class), mockResolveInfo);
-        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MoPubBrowser.class), mockResolveInfo);
-
-        ShadowLog.setupLogging();
-        setDebugMode(true);
-
-        ManifestUtils.displayWarningForMisconfiguredActivities(context, requiredWebViewSdkActivities);
-
-        assertThat(ShadowToast.getLatestToast()).isNull();
-        assertThat(ShadowLog.getLogs()).isEmpty();
-    }
-
-    @SuppressWarnings("unchecked")
-    @TargetApi(13)
-    @Test
-    public void displayWarningForMisconfiguredActivities_withOneMisconfiguredActivity_shouldLogOnlyThatOne() throws Exception {
-        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
-
-        // Misconfigure the first activity; only return false if the activity is MoPubActivity
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                Object[] args = invocationOnMock.getArguments();
-                return MoPubActivity.class != args[0];
-            }
-        }).when(mockActivitiyConfigCheck).hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN));
-
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(true);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(true);
-        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
-
-        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
-        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MraidActivity.class), mockResolveInfo);
-        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MraidVideoPlayerActivity.class), mockResolveInfo);
-        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MoPubBrowser.class), mockResolveInfo);
-
-        ShadowLog.setupLogging();
-
-        ManifestUtils.displayWarningForMisconfiguredActivities(context, requiredWebViewSdkActivities);
-
-        assertLogIncludes("com.mopub.mobileads.MoPubActivity");
-        assertLogIncludes("The android:configChanges param for activity " + MoPubActivity.class.getName() + " must include keyboardHidden.");
-        assertLogDoesntInclude(
-                "com.mopub.mobileads.MraidActivity",
-                "com.mopub.mobileads.MraidVideoPlayerActivity",
-                "com.mopub.common.MoPubBrowser"
-        );
-        assertLogDoesntInclude("The android:configChanges param for activity " + MoPubActivity.class.getName() + " must include orientation.");
-        assertLogDoesntInclude("The android:configChanges param for activity " + MoPubActivity.class.getName() + " must include screenSize.");
-    }
-
-    @SuppressWarnings("unchecked")
-    @TargetApi(13)
-    @Test
-    public void displayWarningForMisconfiguredActivities_withOneMisconfiguredActivity_withMissingAllConfigChangesValues_shouldLogAllConfigChangesValues() throws Exception {
-        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
-
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN))).thenReturn(false);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(false);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(false);
-        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
-
-        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
-
-        ShadowLog.setupLogging();
-
-        ManifestUtils.displayWarningForMisconfiguredActivities(context, requiredWebViewSdkActivities);
-
-        assertLogIncludes("The android:configChanges param for activity " + MoPubActivity.class.getName() + " must include keyboardHidden.");
-        assertLogIncludes("The android:configChanges param for activity " + MoPubActivity.class.getName() + " must include orientation.");
-        assertLogIncludes("The android:configChanges param for activity " + MoPubActivity.class.getName() + " must include screenSize.");
-    }
-
-    @SuppressWarnings("unchecked")
-
-    @TargetApi(13)
-    @Test
-    public void displayWarningForMisconfiguredActivities_withMissingScreenSize_withApiLessThan13_shouldNotLogOrShowToast() throws Exception {
-        TestSdkHelper.setReportedSdkLevel(Build.VERSION_CODES.HONEYCOMB);
-        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN))).thenReturn(true);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(true);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(false);
-        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
-
-        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
-
-        ShadowLog.setupLogging();
-        setDebugMode(true);
-
-        ManifestUtils.displayWarningForMisconfiguredActivities(context, requiredWebViewSdkActivities);
-
-        assertThat(ShadowToast.getLatestToast()).isNull();
-        assertThat(ShadowLog.getLogs()).isEmpty();
-    }
-
-    @SuppressWarnings("unchecked")
-    @TargetApi(13)
-    @Test
-    public void displayWarningForMisconfiguredActivities_withMissingScreenSize_withTargetApiLessThan13_shouldNotLogOrShowToast() throws Exception {
-        // Set target API to < 13
-        ApplicationInfo applicationInfo = context.getApplicationInfo();
-        applicationInfo.targetSdkVersion = Build.VERSION_CODES.HONEYCOMB_MR1;
-        when(context.getApplicationInfo()).thenReturn(applicationInfo);
-
-        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN))).thenReturn(true);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(true);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(false);
-        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
-
-        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
-
-        ShadowLog.setupLogging();
-        setDebugMode(true);
-
-        ManifestUtils.displayWarningForMisconfiguredActivities(context, requiredWebViewSdkActivities);
-
-        assertThat(ShadowToast.getLatestToast()).isNull();
-        assertThat(ShadowLog.getLogs()).isEmpty();
-    }
-
-    @SuppressWarnings("unchecked")
-    @TargetApi(13)
-    @Test
-    public void displayWarningForMisconfiguredActivities_withMisconfiguredActivities_withDebugTrue_shouldShowToast() throws Exception {
-        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN))).thenReturn(false);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(false);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(false);
-        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
-
-        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
-
-        setDebugMode(true);
-
-        ManifestUtils.displayWarningForMisconfiguredActivities(context, requiredWebViewSdkActivities);
-
-        assertThat(ShadowToast.getLatestToast()).isNotNull();
-        final String toastText = ShadowToast.getTextOfLatestToast();
-        assertThat(toastText).isEqualTo("ERROR: YOUR MOPUB INTEGRATION IS INCOMPLETE.\nCheck logcat and update your AndroidManifest.xml with the correct activities and configuration.");
-    }
-
-    @SuppressWarnings("unchecked")
-    @TargetApi(13)
-    @Test
-    public void displayWarningForMisconfiguredActivities_withMisconfiguredActivities_withDebugFalse_shouldNotShowToast() throws Exception {
-        ManifestUtils.FlagCheckUtil mockActivitiyConfigCheck = mock(ManifestUtils.FlagCheckUtil.class);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_KEYBOARD_HIDDEN))).thenReturn(false);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_ORIENTATION))).thenReturn(false);
-        when(mockActivitiyConfigCheck.hasFlag(any(Class.class), anyInt(), eq(ActivityInfo.CONFIG_SCREEN_SIZE))).thenReturn(false);
-        ManifestUtils.setFlagCheckUtil(mockActivitiyConfigCheck);
-
-        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(context, MoPubActivity.class), mockResolveInfo);
-
-        setDebugMode(false);
-
-        ManifestUtils.displayWarningForMissingActivities(context, requiredWebViewSdkActivities);
-
-        assertThat(ShadowToast.getLatestToast()).isNull();
-    }
-
-    @Test
-    public void isDebuggable_whenApplicationIsDebuggable_shouldReturnTrue() throws Exception {
-        setDebugMode(true);
-
-        assertThat(ManifestUtils.isDebuggable(context)).isTrue();
-    }
-
-    @Test
-    public void isDebuggable_whenApplicationIsNotDebuggable_shouldReturnFalse() throws Exception {
-        setDebugMode(false);
-
-        assertThat(ManifestUtils.isDebuggable(context)).isFalse();
-    }
-
-    @SuppressWarnings("unchecked")
-    @Test
-    public void getRequiredWebViewSdkActivities_shouldIncludeRequiredActivities() throws Exception {
-        assertThat(requiredWebViewSdkActivities).containsOnly(
-                MoPubActivity.class,
-                MraidActivity.class,
-                MraidVideoPlayerActivity.class,
-                MoPubBrowser.class
-        );
-    }
-
-    @Test
-    public void getRequiredWebViewSdkActivities_withoutInterstitialModule_shouldNotHaveAllRequiredActivities() throws Exception {
-        removeInterstitialModule();
-        assertThat(requiredWebViewSdkActivities).containsOnly(
-                MraidVideoPlayerActivity.class,
-                MoPubBrowser.class
-        );
-    }
-
-    @SuppressWarnings("unchecked")
-    @Test
-    public void getRequiredNativeSdkActivities_shouldIncludeRequiredActivities() throws Exception {
-        assertThat(requiredNativeSdkActivities).containsOnly(
-                MoPubBrowser.class
-        );
-    }
-
-    private void addInterstitialModule() {
-        Class moPubActivityClass = com.mopub.mobileads.MoPubActivity.class;
-        Class mraidActivityClass = com.mopub.mobileads.MraidActivity.class;
-        if (!ManifestUtils.getRequiredWebViewSdkActivities().contains(moPubActivityClass)) {
-            ManifestUtils.getRequiredWebViewSdkActivities().add(moPubActivityClass);
-        }
-        if (!ManifestUtils.getRequiredWebViewSdkActivities().contains(mraidActivityClass)) {
-            ManifestUtils.getRequiredWebViewSdkActivities().add(mraidActivityClass);
-        }
-    }
-
-    private void removeInterstitialModule() {
-        Class moPubActivityClass = com.mopub.mobileads.MoPubActivity.class;
-        Class mraidActivityClass = com.mopub.mobileads.MraidActivity.class;
-        ManifestUtils.getRequiredWebViewSdkActivities().remove(moPubActivityClass);
-        ManifestUtils.getRequiredWebViewSdkActivities().remove(mraidActivityClass);
-    }
-
-    private void setDebugMode(boolean enabled) {
-        final ApplicationInfo applicationInfo = context.getApplicationInfo();
-
-        if (enabled) {
-            applicationInfo.flags |= ApplicationInfo.FLAG_DEBUGGABLE;
-        } else {
-            applicationInfo.flags &= ~ApplicationInfo.FLAG_DEBUGGABLE;
-        }
-
-        when(context.getApplicationInfo()).thenReturn(applicationInfo);
-    }
-
-    private void assertLogIncludes(final String... messages) {
-        final String logText = ShadowLog.getLogs().get(0).msg;
-        for (final String message : messages) {
-            assertThat(logText).containsOnlyOnce(message);
-        }
-    }
-
-    private void assertLogDoesntInclude(final String... messages) {
-        final String logText = ShadowLog.getLogs().get(0).msg;
-        for (final String message : messages) {
-            assertThat(logText).doesNotContain(message);
-        }
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubRewardedVideoManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubRewardedVideoManagerTest.java
deleted file mode 100644
index 24e0e4db..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubRewardedVideoManagerTest.java
+++ /dev/null
@@ -1,600 +0,0 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.net.Uri;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-
-import com.mopub.common.AdType;
-import com.mopub.common.DataKeys;
-import com.mopub.common.LifecycleListener;
-import com.mopub.common.MoPubReward;
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.network.AdRequest;
-import com.mopub.network.AdResponse;
-import com.mopub.network.MoPubRequestQueue;
-import com.mopub.network.Networking;
-import com.mopub.volley.Request;
-import com.mopub.volley.VolleyError;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.ArgumentCaptor;
-import org.mockito.ArgumentMatcher;
-import org.mockito.Mock;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.Robolectric;
-import org.robolectric.annotation.Config;
-import org.robolectric.shadows.ShadowLooper;
-
-import java.util.Map;
-import java.util.Set;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.argThat;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.verifyZeroInteractions;
-import static org.mockito.Mockito.when;
-
-@RunWith(SdkTestRunner.class)
-@Config(constants = BuildConfig.class)
-public class
-        MoPubRewardedVideoManagerTest {
-
-    public static final String MOPUB_REWARD = "mopub_reward";
-
-    @Mock
-    MoPubRequestQueue mockRequestQueue;
-    @Mock
-    MoPubRewardedVideoListener mockVideoListener;
-
-    AdRequest.Listener requestListener;
-    private AdRequest request;
-    private Activity mActivity;
-
-    @Before
-    public void setup() {
-        mActivity = Robolectric.buildActivity(Activity.class).create().get();
-        MoPubRewardedVideoManager.init(mActivity);
-        MoPubRewardedVideoManager.setVideoListener(mockVideoListener);
-
-        when(mockRequestQueue.add(any(AdRequest.class))).then(new Answer<Object>() {
-            @Override
-            public Object answer(final InvocationOnMock invocationOnMock) throws Throwable {
-                request = ((AdRequest) invocationOnMock.getArguments()[0]);
-                requestListener = request.getListener();
-                return null;
-            }
-        });
-
-        Networking.setRequestQueueForTesting(mockRequestQueue);
-    }
-
-    @After
-    public void tearDown() {
-        // Unpause the main looper in case a test terminated while the looper was paused.
-        ShadowLooper.unPauseMainLooper();
-        MoPubRewardedVideoManager.getRewardedVideoData().clear();
-        MoPubRewardedVideoManager.getAdRequestStatusMapping().clearMapping();
-    }
-
-    @Test
-    public void loadVideo_withRequestParameters_shouldGenerateUrlWithKeywords() {
-        // Robolectric executes its handlers immediately, so if we want the async behavior we see
-        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
-        ShadowLooper.pauseMainLooper();
-
-        MoPubRewardedVideoManager.loadVideo("testAdUnit", new MoPubRewardedVideoManager.RequestParameters("nonsense;garbage;keywords"));
-
-        verify(mockRequestQueue).add(argThat(new RequestUrlContains(Uri.encode("nonsense;garbage;keywords"))));
-
-        // Finish the request
-        requestListener.onErrorResponse(new VolleyError("end test"));
-        ShadowLooper.unPauseMainLooper();
-    }
-
-    @Test
-    public void loadVideo_withCustomerIdInRequestParameters_shouldSetCustomerId() {
-        // Robolectric executes its handlers immediately, so if we want the async behavior we see
-        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
-        ShadowLooper.pauseMainLooper();
-
-        MoPubRewardedVideoManager.loadVideo("testAdUnit", new MoPubRewardedVideoManager.RequestParameters("keywords", null, "testCustomerId"));
-
-        assertThat(MoPubRewardedVideoManager.getRewardedVideoData().getCustomerId()).isEqualTo("testCustomerId");
-
-        // Finish the request
-        requestListener.onErrorResponse(new VolleyError("end test"));
-        ShadowLooper.unPauseMainLooper();
-    }
-
-    @Test
-    public void loadVideo_withVideoAlreadyShowing_shouldNotLoadVideo() {
-        // To simulate that a video is showing
-        MoPubRewardedVideoManager.getRewardedVideoData().setCurrentlyShowingAdUnitId("testAdUnit");
-
-        // Robolectric executes its handlers immediately, so if we want the async behavior we see
-        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
-        ShadowLooper.pauseMainLooper();
-
-        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
-
-        ShadowLooper.unPauseMainLooper();
-
-        verifyZeroInteractions(mockRequestQueue);
-    }
-
-    @Test
-    public void callbackMethods_withNullListener_shouldNotError() {
-        // Clients can set RVM null.
-        MoPubRewardedVideoManager.setVideoListener(null);
-
-        AdResponse testResponse = new AdResponse.Builder()
-                .setCustomEventClassName("com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
-                .setAdType(AdType.CUSTOM)
-                .build();
-
-        // Robolectric executes its handlers immediately, so if we want the async behavior we see
-        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
-        ShadowLooper.pauseMainLooper();
-
-        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
-        // Triggers a call to MoPubRewardedVideoManager.onRewardedVideoLoadSuccess
-        requestListener.onSuccess(testResponse);
-
-        ShadowLooper.unPauseMainLooper();
-
-        MoPubRewardedVideoManager.onRewardedVideoClicked(TestCustomEvent.class,
-                TestCustomEvent.AD_NETWORK_ID);
-        MoPubRewardedVideoManager.onRewardedVideoStarted(TestCustomEvent.class,
-                TestCustomEvent.AD_NETWORK_ID);
-        MoPubRewardedVideoManager.onRewardedVideoClosed(TestCustomEvent.class,
-                TestCustomEvent.AD_NETWORK_ID);
-        MoPubRewardedVideoManager.onRewardedVideoCompleted(TestCustomEvent.class,
-                TestCustomEvent.AD_NETWORK_ID,
-                MoPubReward.success("test", 111));
-
-        // The test passed because none of the above calls thew an exception even though the listener is null.
-    }
-
-    @Test
-    public void onAdSuccess_noActivityFound_shouldNotCallFailUrl() {
-        AdResponse testResponse = new AdResponse.Builder()
-                .setAdType(AdType.CUSTOM)
-                .setCustomEventClassName(
-                        "com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
-                .setFailoverUrl("fail.url")
-                .build();
-
-        MoPubRewardedVideoManager.updateActivity(null);
-        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
-        requestListener.onSuccess(testResponse);
-
-        verify(mockRequestQueue).add(any(AdRequest.class));
-        verifyNoMoreInteractions(mockRequestQueue);
-
-        // Clean up the static state we screwed up:
-        MoPubRewardedVideoManager.updateActivity(mActivity);
-    }
-
-    @Test
-    public void onAdSuccess_noCEFound_shouldCallFailCallback() throws Exception {
-        AdResponse testResponse = new AdResponse.Builder()
-                .setAdType(AdType.CUSTOM)
-                .setCustomEventClassName("doesn't_Exist")
-                .build();
-
-        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
-
-        requestListener.onSuccess(testResponse);
-
-        verify(mockVideoListener).onRewardedVideoLoadFailure(eq("testAdUnit"),
-                eq(MoPubErrorCode.ADAPTER_CONFIGURATION_ERROR));
-        verifyNoMoreInteractions(mockVideoListener);
-    }
-
-    @Test
-    public void onAdSuccess_noCEFound_shouldLoadFailUrl() {
-        AdResponse testResponse = new AdResponse.Builder()
-                .setAdType(AdType.CUSTOM)
-                .setCustomEventClassName("doesn't_Exist")
-                .setFailoverUrl("fail.url")
-                .build();
-
-        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
-
-        assertThat(request.getUrl()).contains("testAdUnit");
-        requestListener.onSuccess(testResponse);
-        assertThat(request.getUrl()).isEqualTo("fail.url");
-        // Clear up the static state :(
-        requestListener.onErrorResponse(new VolleyError("reset"));
-    }
-
-    @Test
-    public void onAdSuccess_shouldInstantiateCustomEvent_andLoad() {
-        AdResponse testResponse = new AdResponse.Builder()
-                .setCustomEventClassName(
-                        "com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
-                .setAdType(AdType.CUSTOM)
-                .build();
-
-        // Robolectric executes its handlers immediately, so if we want the async behavior we see
-        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
-        ShadowLooper.pauseMainLooper();
-
-        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
-        requestListener.onSuccess(testResponse);
-
-        ShadowLooper.unPauseMainLooper();
-
-        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isTrue();
-        verify(mockVideoListener).onRewardedVideoLoadSuccess(eq("testAdUnit"));
-        verifyNoMoreInteractions(mockVideoListener);
-    }
-
-    @Test
-    public void loadVideo_withCustomEventAlreadyLoaded_shouldNotLoadAnotherVideo() throws Exception {
-        final CustomEventRewardedVideo mockCustomEvent = mock(CustomEventRewardedVideo.class);
-        MoPubRewardedVideoManager.getRewardedVideoData().updateAdUnitCustomEventMapping(
-                "testAdUnit", mockCustomEvent, null, TestCustomEvent.AD_NETWORK_ID);
-
-        AdResponse testResponse = new AdResponse.Builder()
-                .setCustomEventClassName(
-                        "com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
-                .setAdType(AdType.CUSTOM)
-                .build();
-
-        // Robolectric executes its handlers immediately, so if we want the async behavior we see
-        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
-        ShadowLooper.pauseMainLooper();
-
-        // Load the first custom event
-        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
-        requestListener.onSuccess(testResponse);
-
-        ShadowLooper.unPauseMainLooper();
-
-        // Verify the first custom event
-        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isTrue();
-        verify(mockVideoListener).onRewardedVideoLoadSuccess(eq("testAdUnit"));
-        verifyNoMoreInteractions(mockVideoListener);
-        verify(mockRequestQueue).add(any(Request.class));
-        reset(mockVideoListener);
-
-        ShadowLooper.pauseMainLooper();
-
-        // Load the second custom event
-        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
-
-        ShadowLooper.unPauseMainLooper();
-
-        // Verify the first custom event is still available
-        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isTrue();
-        verify(mockVideoListener).onRewardedVideoLoadSuccess(eq("testAdUnit"));
-        verifyNoMoreInteractions(mockVideoListener);
-        // Make sure the second load does not attempt to load another ad
-        verifyNoMoreInteractions(mockRequestQueue);
-    }
-
-    @Test
-    public void onAdSuccess_shouldHaveUniqueBroadcastIdsSetForEachCustomEvent() throws Exception {
-        AdResponse testResponse = new AdResponse.Builder()
-                .setCustomEventClassName(
-                        "com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
-                .setAdType(AdType.CUSTOM)
-                .build();
-
-        // Robolectric executes its handlers immediately, so if we want the async behavior we see
-        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
-        ShadowLooper.pauseMainLooper();
-
-        // Load the first custom event
-        MoPubRewardedVideoManager.loadVideo("testAdUnit1", null);
-        requestListener.onSuccess(testResponse);
-
-        ShadowLooper.unPauseMainLooper();
-
-        // Get the first custom event's broadcast id
-        TestCustomEvent testCustomEvent1 = (TestCustomEvent)
-                MoPubRewardedVideoManager.getRewardedVideoData().getCustomEvent("testAdUnit1");
-        Long broadcastId1 = (Long) testCustomEvent1.getLocalExtras().get(
-                DataKeys.BROADCAST_IDENTIFIER_KEY);
-        assertThat(broadcastId1).isNotNull();
-
-        ShadowLooper.pauseMainLooper();
-
-        // Load the second custom event
-        MoPubRewardedVideoManager.loadVideo("testAdUnit2", null);
-        requestListener.onSuccess(testResponse);
-
-        ShadowLooper.unPauseMainLooper();
-
-        // Get the second custom event's broadcast id
-        TestCustomEvent testCustomEvent2 = (TestCustomEvent)
-                MoPubRewardedVideoManager.getRewardedVideoData().getCustomEvent("testAdUnit2");
-        Long broadcastId2 = (Long) testCustomEvent2.getLocalExtras().get(
-                DataKeys.BROADCAST_IDENTIFIER_KEY);
-        assertThat(broadcastId2).isNotNull();
-
-        // Make sure they're different
-        assertThat(broadcastId1).isNotEqualTo(broadcastId2);
-    }
-
-    @Test
-    public void onAdSuccess_shouldUpdateAdUnitRewardMapping() throws Exception {
-        AdResponse testResponse = new AdResponse.Builder()
-                .setCustomEventClassName(
-                        "com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
-                .setAdType(AdType.CUSTOM)
-                .setRewardedVideoCurrencyName("currency_name")
-                .setRewardedVideoCurrencyAmount("123")
-                .build();
-
-        // Robolectric executes its handlers immediately, so if we want the async behavior we see
-        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
-        ShadowLooper.pauseMainLooper();
-
-        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
-        requestListener.onSuccess(testResponse);
-
-        ShadowLooper.unPauseMainLooper();
-
-        MoPubReward moPubReward =
-                MoPubRewardedVideoManager.getRewardedVideoData().getMoPubReward("testAdUnit");
-        assertThat(moPubReward.getAmount()).isEqualTo(123);
-        assertThat(moPubReward.getLabel()).isEqualTo("currency_name");
-    }
-
-    @Test
-    public void playVideo_shouldSetHasVideoFalse() {
-        AdResponse testResponse = new AdResponse.Builder()
-                .setCustomEventClassName("com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
-                .setAdType(AdType.CUSTOM)
-                .build();
-
-        // Robolectric executes its handlers immediately, so if we want the async behavior we see
-        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
-        ShadowLooper.pauseMainLooper();
-
-        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
-        requestListener.onSuccess(testResponse);
-
-        ShadowLooper.unPauseMainLooper();
-
-        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isTrue();
-        MoPubRewardedVideoManager.showVideo("testAdUnit");
-        verify(mockVideoListener).onRewardedVideoLoadSuccess(eq("testAdUnit"));
-        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isFalse();
-        verify(mockVideoListener).onRewardedVideoStarted(eq("testAdUnit"));
-    }
-    
-    @Test
-    public void playVideo_whenNotHasVideo_shouldFail() {
-        AdResponse testResponse = new AdResponse.Builder()
-                .setCustomEventClassName("com.mopub.mobileads.MoPubRewardedVideoManagerTest$NoVideoCustomEvent")
-                .setAdType(AdType.CUSTOM)
-                .build();
-
-        // Robolectric executes its handlers immediately, so if we want the async behavior we see
-        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
-        ShadowLooper.pauseMainLooper();
-
-        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
-        requestListener.onSuccess(testResponse);
-
-        ShadowLooper.unPauseMainLooper();
-
-        verify(mockVideoListener).onRewardedVideoLoadFailure(eq("testAdUnit"), eq(MoPubErrorCode.NETWORK_NO_FILL));
-
-        assertThat(MoPubRewardedVideoManager.hasVideo("testAdUnit")).isFalse();
-        MoPubRewardedVideoManager.showVideo("testAdUnit");
-        verify(mockVideoListener).onRewardedVideoLoadFailure(eq("testAdUnit"), eq(MoPubErrorCode.VIDEO_NOT_AVAILABLE));
-    }
-
-    @Test
-    public void playVideo_shouldUpdateLastShownCustomEventRewardMapping() throws Exception {
-        AdResponse testResponse = new AdResponse.Builder()
-                .setCustomEventClassName(
-                        "com.mopub.mobileads.MoPubRewardedVideoManagerTest$TestCustomEvent")
-                .setAdType(AdType.CUSTOM)
-                .setRewardedVideoCurrencyName("currency_name")
-                .setRewardedVideoCurrencyAmount("123")
-                .build();
-
-        // Robolectric executes its handlers immediately, so if we want the async behavior we see
-        // in an actual app we have to pause the main looper until we're done successfully loading the ad.
-        ShadowLooper.pauseMainLooper();
-
-        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
-        requestListener.onSuccess(testResponse);
-
-        ShadowLooper.unPauseMainLooper();
-
-        MoPubRewardedVideoManager.showVideo("testAdUnit");
-
-        MoPubReward moPubReward =
-                MoPubRewardedVideoManager.getRewardedVideoData().getLastShownMoPubReward(TestCustomEvent.class);
-        assertThat(moPubReward.getAmount()).isEqualTo(123);
-        assertThat(moPubReward.getLabel()).isEqualTo("currency_name");
-    }
-
-    @Test
-    public void onAdFailure_shouldCallFailCallback() {
-        VolleyError e = new VolleyError("testError!");
-
-        MoPubRewardedVideoManager.loadVideo("testAdUnit", null);
-
-        assertThat(request.getUrl()).contains("testAdUnit");
-        requestListener.onErrorResponse(e);
-        verify(mockVideoListener).onRewardedVideoLoadFailure(anyString(), any(MoPubErrorCode.class));
-        verifyNoMoreInteractions(mockVideoListener);
-    }
-
-    @Test
-    public void chooseReward_shouldReturnMoPubRewardOverNetworkReward() throws Exception {
-        MoPubReward moPubReward = MoPubReward.success(MOPUB_REWARD, 123);
-        MoPubReward networkReward = MoPubReward.success("network_reward", 456);
-
-        MoPubReward chosenReward =
-                MoPubRewardedVideoManager.chooseReward(moPubReward, networkReward);
-        assertThat(chosenReward).isEqualTo(moPubReward);
-    }
-
-    @Test
-    public void chooseReward_withNetworkRewardNotSuccessful_shouldReturnNetworkReward() throws Exception {
-        MoPubReward moPubReward = MoPubReward.success(MOPUB_REWARD, 123);
-        MoPubReward networkReward = MoPubReward.failure();
-
-        MoPubReward chosenReward =
-                MoPubRewardedVideoManager.chooseReward(moPubReward, networkReward);
-        assertThat(chosenReward).isEqualTo(networkReward);
-    }
-    
-    @Test
-    public void onRewardedVideoCompleted_withEmptyServerCompletionUrl_withCurrentlyShowingAdUnitId_shouldNotifyRewardedVideoCompletedForOneAdUnitId() {
-        MoPubReward moPubReward = MoPubReward.success(MOPUB_REWARD, 123);
-        RewardedVideoData rewardedVideoData = MoPubRewardedVideoManager.getRewardedVideoData();
-        rewardedVideoData.setCurrentlyShowingAdUnitId("testAdUnit1");
-        rewardedVideoData.updateAdUnitCustomEventMapping("testAdUnit1", new TestCustomEvent(), null,
-                TestCustomEvent.AD_NETWORK_ID);
-        rewardedVideoData.updateAdUnitCustomEventMapping("testAdUnit2", new TestCustomEvent(), null,
-                TestCustomEvent.AD_NETWORK_ID);
-        // Server completion url empty and custom event has no server reward set
-
-        ShadowLooper.pauseMainLooper();
-
-        MoPubRewardedVideoManager.onRewardedVideoCompleted(TestCustomEvent.class, TestCustomEvent.AD_NETWORK_ID,
-                moPubReward);
-        
-        ShadowLooper.unPauseMainLooper();
-
-        ArgumentCaptor<Set<String>> rewardedIdsCaptor = ArgumentCaptor.forClass((Class) Set.class);
-        verify(mockVideoListener).onRewardedVideoCompleted(rewardedIdsCaptor.capture(),
-                eq(moPubReward));
-        assertThat(rewardedIdsCaptor.getValue()).containsOnly("testAdUnit1");
-    }
-
-    @Test
-    public void onRewardedVideoCompleted_withEmptyServerCompletionUrl_withNoCurrentlyShowingAdUnitId_shouldNotifyRewardedVideoCompletedForAllAdUnitIds() {
-        MoPubReward moPubReward = MoPubReward.success(MOPUB_REWARD, 123);
-        RewardedVideoData rewardedVideoData = MoPubRewardedVideoManager.getRewardedVideoData();
-        rewardedVideoData.setCurrentlyShowingAdUnitId(null);
-        rewardedVideoData.updateAdUnitCustomEventMapping("testAdUnit1", new TestCustomEvent(), null,
-                TestCustomEvent.AD_NETWORK_ID);
-        rewardedVideoData.updateAdUnitCustomEventMapping("testAdUnit2", new TestCustomEvent(), null,
-                TestCustomEvent.AD_NETWORK_ID);
-        rewardedVideoData.updateAdUnitCustomEventMapping("testAdUnit3", new TestCustomEvent(), null,
-                TestCustomEvent.AD_NETWORK_ID);
-        // Server completion url empty and custom event has no server reward set
-
-        ShadowLooper.pauseMainLooper();
-
-        MoPubRewardedVideoManager.onRewardedVideoCompleted(TestCustomEvent.class, TestCustomEvent.AD_NETWORK_ID,
-                moPubReward);
-
-        ShadowLooper.unPauseMainLooper();
-
-        ArgumentCaptor<Set<String>> rewardedIdsCaptor = ArgumentCaptor.forClass((Class) Set.class);
-        verify(mockVideoListener).onRewardedVideoCompleted(rewardedIdsCaptor.capture(),
-                eq(moPubReward));
-        assertThat(rewardedIdsCaptor.getValue()).containsOnly("testAdUnit1", "testAdUnit2",
-                "testAdUnit3");
-    }
-
-    public static class TestCustomEvent extends CustomEventRewardedVideo {
-        public static final String AD_NETWORK_ID = "id!";
-
-        boolean mPlayable = false;
-        private Map<String, Object> mLocalExtras;
-
-        @Nullable
-        @Override
-        protected CustomEventRewardedVideoListener getVideoListenerForSdk() {
-            return null;
-        }
-
-        @Nullable
-        @Override
-        protected LifecycleListener getLifecycleListener() {
-            return null;
-        }
-
-        @NonNull
-        @Override
-        protected String getAdNetworkId() {
-            return AD_NETWORK_ID;
-        }
-
-        @Override
-        protected void onInvalidate() {
-            mPlayable = false;
-        }
-
-        @Override
-        protected boolean checkAndInitializeSdk(@NonNull final Activity launcherActivity,
-                @NonNull final Map<String, Object> localExtras,
-                @NonNull final Map<String, String> serverExtras) throws Exception {
-            return false;
-        }
-
-        @Override
-        protected void loadWithSdkInitialized(@NonNull final Activity activity,
-                @NonNull final Map<String, Object> localExtras,
-                @NonNull final Map<String, String> serverExtras) throws Exception {
-            // Do nothing because robolectric handlers execute immediately.
-            mPlayable = true;
-            MoPubRewardedVideoManager.onRewardedVideoLoadSuccess(TestCustomEvent.class,
-                    TestCustomEvent.AD_NETWORK_ID);
-            mLocalExtras = localExtras;
-        }
-
-        @Override
-        protected boolean hasVideoAvailable() {
-            return mPlayable;
-        }
-
-        @Override
-        protected void showVideo() {
-            MoPubRewardedVideoManager.onRewardedVideoStarted(TestCustomEvent.class, TestCustomEvent.AD_NETWORK_ID);
-        }
-
-        @Nullable
-        Map<String, Object> getLocalExtras() {
-            return mLocalExtras;
-        }
-    }
-
-    public static class NoVideoCustomEvent extends TestCustomEvent {
-        @Override
-        protected void loadWithSdkInitialized(@NonNull final Activity activity,
-                @NonNull final Map<String, Object> localExtras,
-                @NonNull final Map<String, String> serverExtras) throws Exception {
-            mPlayable = false;
-            MoPubRewardedVideoManager.onRewardedVideoLoadFailure(NoVideoCustomEvent.class, TestCustomEvent.AD_NETWORK_ID, MoPubErrorCode.NETWORK_NO_FILL);
-        }
-    }
-
-    private static class RequestUrlContains extends ArgumentMatcher<Request> {
-
-        private final String mMustContain;
-
-        RequestUrlContains(String stringToFind) {
-            mMustContain = stringToFind;
-        }
-
-        @Override
-        public boolean matches(final Object argument) {
-            return argument instanceof Request
-                    && ((Request) argument).getUrl().contains(mMustContain);
-        }
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubViewTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubViewTest.java
deleted file mode 100644
index 0b440d17..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubViewTest.java
+++ /dev/null
@@ -1,260 +0,0 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.view.View;
-
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.Reflection;
-import com.mopub.common.util.test.support.ShadowReflection;
-import com.mopub.mobileads.test.support.TestAdViewControllerFactory;
-import com.mopub.mobileads.test.support.TestCustomEventBannerAdapterFactory;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.annotation.Config;
-import org.robolectric.shadows.ShadowApplication;
-
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.verify;
-
-@RunWith(SdkTestRunner.class)
-@Config(constants = BuildConfig.class, shadows = {ShadowReflection.class})
-public class MoPubViewTest {
-    private MoPubView subject;
-    private Map<String,String> paramsMap = new HashMap<String, String>();
-    private CustomEventBannerAdapter customEventBannerAdapter;
-    private AdViewController adViewController;
-    private Context context;
-
-    @Before
-    public void setup() {
-        context = Robolectric.buildActivity(Activity.class).create().get();
-        subject = new MoPubView(context);
-        customEventBannerAdapter = TestCustomEventBannerAdapterFactory.getSingletonMock();
-        reset(customEventBannerAdapter);
-        adViewController = TestAdViewControllerFactory.getSingletonMock();
-    }
-
-    @After
-    public void tearDown() {
-        ShadowReflection.reset();
-    }
-
-    @Test
-    public void screenStateBroadcastReceiver_withActionUserPresent_shouldUnpauseRefresh() throws Exception {
-        broadcastIntent(new Intent(Intent.ACTION_USER_PRESENT));
-
-        verify(adViewController).unpauseRefresh();
-    }
-
-    @Test
-    public void screenStateBroadcastReceiver_withActionScreenOff_shouldPauseRefersh() throws Exception {
-        broadcastIntent(new Intent(Intent.ACTION_SCREEN_OFF));
-
-        verify(adViewController).pauseRefresh();
-    }
-
-    @Test
-    public void screenStateBroadcastReceiver_withNullIntent_shouldDoNothing() throws Exception {
-        broadcastIntent(null);
-
-        verify(adViewController, never()).pauseRefresh();
-        verify(adViewController, never()).unpauseRefresh();
-    }
-
-    @Test
-    public void screenStateBroadcastReceiver_withRandomIntent_shouldDoNothing() throws Exception {
-        broadcastIntent(new Intent(Intent.ACTION_BATTERY_LOW));
-
-        verify(adViewController, never()).pauseRefresh();
-        verify(adViewController, never()).unpauseRefresh();
-    }
-
-    @Test
-    public void screenStateBroadcastReceiver_whenAdInBackground_shouldDoNothing() throws Exception {
-        subject.onWindowVisibilityChanged(View.INVISIBLE);
-        reset(adViewController);
-
-        broadcastIntent(new Intent(Intent.ACTION_USER_PRESENT));
-        verify(adViewController, never()).unpauseRefresh();
-
-        broadcastIntent(new Intent(Intent.ACTION_SCREEN_OFF));
-        verify(adViewController, never()).pauseRefresh();
-    }
-
-    @Test
-    public void screenStateBroadcastReceiver_afterOnDestroy_shouldDoNothing() throws Exception {
-        subject.destroy();
-
-        broadcastIntent(new Intent(Intent.ACTION_USER_PRESENT));
-        verify(adViewController, never()).unpauseRefresh();
-
-        broadcastIntent(new Intent(Intent.ACTION_SCREEN_OFF));
-        verify(adViewController, never()).pauseRefresh();
-    }
-
-    @Test
-    public void onWindowVisibilityChanged_fromVisibleToInvisible_shouldPauseRefresh() throws Exception {
-        // Default visibility is View.VISIBLE
-        subject.onWindowVisibilityChanged(View.INVISIBLE);
-
-        verify(adViewController).pauseRefresh();
-        verify(adViewController, never()).unpauseRefresh();
-    }
-
-
-    @Test
-    public void onWindowVisibilityChanged_fromInvisibleToVisible_shouldUnpauseRefresh() throws Exception {
-        subject.onWindowVisibilityChanged(View.INVISIBLE);
-        reset(adViewController);
-
-        subject.onWindowVisibilityChanged(View.VISIBLE);
-
-        verify(adViewController, never()).pauseRefresh();
-        verify(adViewController).unpauseRefresh();
-    }
-
-    @Test
-    public void onWindowVisibilityChanged_fromVisibleToVisible_shouldDoNothing() throws Exception {
-        // Default visibility is View.VISIBLE
-        subject.onWindowVisibilityChanged(View.VISIBLE);
-
-        verify(adViewController, never()).pauseRefresh();
-        verify(adViewController, never()).unpauseRefresh();
-    }
-
-    @Test
-    public void onWindowVisibilityChanged_fromInvisibleToGone_shouldDoNothing() throws Exception {
-        subject.onWindowVisibilityChanged(View.INVISIBLE);
-        reset(adViewController);
-
-        subject.onWindowVisibilityChanged(View.GONE);
-
-        verify(adViewController, never()).pauseRefresh();
-        verify(adViewController, never()).unpauseRefresh();
-    }
-
-    @Test
-    public void onWindowVisibilityChanged_fromGoneToInvisible_shouldDoNothing() throws Exception {
-        subject.onWindowVisibilityChanged(View.GONE);
-        reset(adViewController);
-
-        subject.onWindowVisibilityChanged(View.INVISIBLE);
-
-        verify(adViewController, never()).pauseRefresh();
-        verify(adViewController, never()).unpauseRefresh();
-    }
-
-    @Test
-    public void setAutorefreshEnabled_withRefreshTrue_shouldForwardToAdViewController() throws Exception {
-        subject.setAutorefreshEnabled(true);
-
-        verify(adViewController).forceSetAutorefreshEnabled(true);
-    }
-
-    @Test
-    public void setAutorefreshEnabled_withRefreshFalse_shouldForwardToAdViewController() throws Exception {
-        subject.setAutorefreshEnabled(false);
-
-        verify(adViewController).forceSetAutorefreshEnabled(false);
-    }
-    
-    @Test
-    public void nativeAdLoaded_shouldScheduleRefreshTimer() throws Exception {
-        subject.nativeAdLoaded();
-
-        verify(adViewController).scheduleRefreshTimerIfEnabled();
-    }
-
-    @Test
-    public void loadCustomEvent_shouldInitializeCustomEventBannerAdapter() throws Exception {
-        subject.loadCustomEvent("name", paramsMap);
-
-        assertThat(TestCustomEventBannerAdapterFactory.getLatestMoPubView()).isEqualTo(subject);
-        assertThat(TestCustomEventBannerAdapterFactory.getLatestClassName()).isEqualTo("name");
-        assertThat(TestCustomEventBannerAdapterFactory.getLatestClassData()).isEqualTo(paramsMap);
-
-        verify(customEventBannerAdapter).loadAd();
-    }
-
-    @Test
-    public void loadCustomEvent_whenParamsMapIsNull_shouldCallLoadFailUrl() throws Exception {
-        subject.loadCustomEvent(null, null);
-
-        verify(adViewController).loadFailUrl(eq(ADAPTER_NOT_FOUND));
-        verify(customEventBannerAdapter, never()).invalidate();
-        verify(customEventBannerAdapter, never()).loadAd();
-    }
-
-    @Test
-    public void loadCustomEvent_withTwoCalls_shouldInvalidateAdapterOnce() throws Exception {
-        subject.loadCustomEvent("name", paramsMap);
-        subject.loadCustomEvent("name", paramsMap);
-
-        verify(customEventBannerAdapter).invalidate();
-    }
-
-    @Test
-    public void forceRefresh_withCallToLoadCustomEvent_shouldInvalidateAdapter() throws Exception {
-        subject.loadCustomEvent("name", paramsMap);
-        subject.forceRefresh();
-
-        verify(customEventBannerAdapter).invalidate();
-    }
-
-    @Test
-    public void loadCustomEvent_withoutBannerModule_shouldNotLoadAd() throws Exception {
-        ShadowReflection.setNextClassNotFound(true);
-
-        subject.loadCustomEvent("name", paramsMap);
-
-        verify(customEventBannerAdapter, never()).loadAd();
-    }
-
-    @Test
-    public void forceRefresh_withoutBannerModule_withCallToLoadCustomEvent_shouldNotInvalidateAdapter() throws Exception {
-        ShadowReflection.setNextClassNotFound(true);
-
-        subject.loadCustomEvent("name", paramsMap);
-        subject.forceRefresh();
-
-        verify(customEventBannerAdapter, never()).invalidate();
-    }
-
-    @Test
-    public void forceRefresh_withoutBannerModule_withCallToLoadCustomEvent_shouldForceRefreshAdViewController() throws Exception {
-        ShadowReflection.setNextClassNotFound(true);
-
-        subject.loadCustomEvent("name", paramsMap);
-        subject.forceRefresh();
-
-        verify(adViewController).forceRefresh();
-    }
-
-    @Test
-    public void invalidateAdapter_withReflection_shouldExist() throws Exception {
-        assertThat(Reflection.getDeclaredMethodWithTraversal(CustomEventBannerAdapter.class,
-                "invalidate")).isNotNull();
-    }
-
-    private void broadcastIntent(final Intent intent) {
-        final List<ShadowApplication.Wrapper> wrappers = ShadowApplication.getInstance().getRegisteredReceivers();
-
-        for (final ShadowApplication.Wrapper wrapper : wrappers) {
-            wrapper.broadcastReceiver.onReceive(context, intent);
-        }
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidActivityTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidActivityTest.java
deleted file mode 100644
index 189d3ad8..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidActivityTest.java
+++ /dev/null
@@ -1,377 +0,0 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.content.BroadcastReceiver;
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.Intent;
-import android.os.Build.VERSION_CODES;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.WindowManager;
-import android.webkit.WebViewClient;
-import android.widget.FrameLayout;
-
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.mraid.MraidBridge;
-import com.mopub.mraid.MraidBridge.MraidWebView;
-import com.mopub.mraid.MraidController;
-import com.mopub.mraid.MraidController.MraidListener;
-
-import org.fest.assertions.api.ANDROID;
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Mock;
-import org.robolectric.Robolectric;
-import org.robolectric.Shadows;
-import org.robolectric.annotation.Config;
-import org.robolectric.shadows.support.v4.ShadowLocalBroadcastManager;
-import org.robolectric.util.ActivityController;
-
-import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
-import static com.mopub.common.DataKeys.HTML_RESPONSE_BODY_KEY;
-import static com.mopub.common.IntentActions.ACTION_INTERSTITIAL_CLICK;
-import static com.mopub.common.IntentActions.ACTION_INTERSTITIAL_DISMISS;
-import static com.mopub.common.IntentActions.ACTION_INTERSTITIAL_SHOW;
-import static com.mopub.mobileads.EventForwardingBroadcastReceiverTest.getIntentForActionAndIdentifier;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.verify;
-
-
-@RunWith(SdkTestRunner.class)
-@Config(constants = BuildConfig.class)
-public class MraidActivityTest {
-    static final String EXPECTED_SOURCE = "expected source";
-    static final String HTML_DATA = "html_data";
-
-    @Mock MraidWebView mockMraidWebView;
-    @Mock MraidBridge mraidBridge;
-    @Mock MraidController mraidController;
-    @Mock CustomEventInterstitial.CustomEventInterstitialListener
-            customEventInterstitialListener;
-    @Mock BroadcastReceiver broadcastReceiver;
-
-    Context context;
-
-    // These fields are relics of a previous version of this class (all tests using them have since
-    // been deprecated).
-    MraidActivity subject;
-    ActivityController<MraidActivity> activityController;
-
-    long testBroadcastIdentifier = 2222;
-
-    @Before
-    public void setUp() throws Exception {
-        context = Robolectric.buildActivity(Activity.class).create().get();
-    }
-
-    @Test
-    public void preRenderHtml_shouldEnableJavascriptCachingForDummyWebView() {
-        MraidActivity.preRenderHtml(customEventInterstitialListener, HTML_DATA, mockMraidWebView);
-
-        verify(mockMraidWebView).enableJavascriptCaching();
-    }
-
-    @Test
-    public void preRenderHtml_shouldDisablePluginsForDummyWebView() {
-        MraidActivity.preRenderHtml(customEventInterstitialListener, HTML_DATA, mockMraidWebView);
-
-        verify(mockMraidWebView).enablePlugins(false);
-    }
-
-    @Test
-    public void preRenderHtml_shouldLoadHtml() {
-        MraidActivity.preRenderHtml(customEventInterstitialListener, HTML_DATA, mockMraidWebView);
-
-        verify(mockMraidWebView).loadDataWithBaseURL(
-                "http://ads.mopub.com/",
-                HTML_DATA,
-                "text/html",
-                "UTF-8",
-                null
-        );
-    }
-
-    @Ignore("Mraid 2.0")
-    @Test
-    public void preRenderHtml_shouldSetWebViewClient() throws Exception {
-        MraidActivity.preRenderHtml(subject, customEventInterstitialListener, "3:27");
-
-        verify(mockMraidWebView).enablePlugins(eq(false));
-        verify(mraidController).setMraidListener(any(MraidListener.class));
-        verify(mockMraidWebView).setWebViewClient(any(WebViewClient.class));
-        verify(mraidBridge).setContentHtml(eq("3:27"));
-    }
-
-    @Ignore("Mraid 2.0")
-    @Test
-    public void preRenderHtml_shouldCallCustomEventInterstitialOnInterstitialLoaded_whenMraidListenerOnReady() throws Exception {
-        MraidActivity.preRenderHtml(subject, customEventInterstitialListener, "");
-
-        ArgumentCaptor<MraidListener> mraidListenerArgumentCaptorr = ArgumentCaptor.forClass(MraidListener.class);
-        verify(mraidController).setMraidListener(mraidListenerArgumentCaptorr.capture());
-        MraidListener mraidListener = mraidListenerArgumentCaptorr.getValue();
-
-        mraidListener.onLoaded(null);
-
-        verify(customEventInterstitialListener).onInterstitialLoaded();
-    }
-
-    @Ignore("Mraid 2.0")
-    @Test
-    public void preRenderHtml_shouldCallCustomEventInterstitialOnInterstitialFailed_whenMraidListenerOnFailure() throws Exception {
-        MraidActivity.preRenderHtml(subject, customEventInterstitialListener, "");
-
-        ArgumentCaptor<MraidListener> mraidListenerArgumentCaptorr = ArgumentCaptor.forClass(MraidListener.class);
-        verify(mraidController).setMraidListener(mraidListenerArgumentCaptorr.capture());
-        MraidListener mraidListener = mraidListenerArgumentCaptorr.getValue();
-
-        mraidListener.onFailedToLoad();
-
-        verify(customEventInterstitialListener).onInterstitialFailed(null);
-    }
-
-    @Ignore("Mraid 2.0")
-    @Test
-    public void preRenderHtml_whenWebViewClientShouldOverrideUrlLoading_shouldReturnTrue() throws Exception {
-        MraidActivity.preRenderHtml(subject, customEventInterstitialListener, "");
-
-        ArgumentCaptor<WebViewClient> webViewClientArgumentCaptor = ArgumentCaptor.forClass(WebViewClient.class);
-        verify(mockMraidWebView).setWebViewClient(webViewClientArgumentCaptor.capture());
-        WebViewClient webViewClient = webViewClientArgumentCaptor.getValue();
-
-        boolean consumeUrlLoading = webViewClient.shouldOverrideUrlLoading(null, null);
-
-        assertThat(consumeUrlLoading).isTrue();
-        verify(customEventInterstitialListener, never()).onInterstitialLoaded();
-        verify(customEventInterstitialListener, never()).onInterstitialFailed(
-                any(MoPubErrorCode.class));
-    }
-
-    @Ignore("Mraid 2.0")
-    @Test
-    public void preRenderHtml_shouldCallCustomEventInterstitialOnInterstitialLoaded_whenWebViewClientOnPageFinished() throws Exception {
-        MraidActivity.preRenderHtml(subject, customEventInterstitialListener, "");
-
-        ArgumentCaptor<WebViewClient> webViewClientArgumentCaptor = ArgumentCaptor.forClass(WebViewClient.class);
-        verify(mockMraidWebView).setWebViewClient(webViewClientArgumentCaptor.capture());
-        WebViewClient webViewClient = webViewClientArgumentCaptor.getValue();
-
-        webViewClient.onPageFinished(null, null);
-
-        verify(customEventInterstitialListener).onInterstitialLoaded();
-    }
-
-    @Ignore("Mraid 2.0")
-    @Test
-    public void onCreate_shouldSetContentView() throws Exception {
-        subject.onCreate(null);
-
-        assertThat(getContentView().getChildCount()).isEqualTo(1);
-    }
-
-    @Ignore("Mraid 2.0")
-    @Test
-    public void onCreate_shouldSetupAnMraidView() throws Exception {
-        subject.onCreate(null);
-
-        assertThat(getContentView().getChildAt(0)).isSameAs(mockMraidWebView);
-        verify(mraidController).setMraidListener(any(MraidListener.class));
-
-        verify(mraidBridge).setContentHtml(EXPECTED_SOURCE);
-    }
-
-    @Ignore("Mraid 2.0")
-    @Test
-    public void onCreate_shouldSetLayoutOfMraidView() throws Exception {
-        subject.onCreate(null);
-
-        ArgumentCaptor<FrameLayout.LayoutParams> captor = ArgumentCaptor.forClass(
-                FrameLayout.LayoutParams.class);
-        verify(mockMraidWebView).setLayoutParams(captor.capture());
-        FrameLayout.LayoutParams actualLayoutParams = captor.getValue();
-
-        assertThat(actualLayoutParams.width).isEqualTo(FrameLayout.LayoutParams.MATCH_PARENT);
-        assertThat(actualLayoutParams.height).isEqualTo(FrameLayout.LayoutParams.MATCH_PARENT);
-    }
-
-    @Config(sdk = VERSION_CODES.ICE_CREAM_SANDWICH)
-    @Ignore("Mraid 2.0")
-    @Test
-    public void onCreate_atLeastIcs_shouldSetHardwareAcceleratedFlag() throws Exception {
-        subject.onCreate(null);
-
-        boolean hardwareAccelerated = Shadows.shadowOf(subject.getWindow()).getFlag(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
-        assertThat(hardwareAccelerated).isTrue();
-    }
-
-    @Config(sdk = VERSION_CODES.HONEYCOMB_MR2)
-    @Ignore("Mraid 2.0")
-    @Test
-    public void onCreate_beforeIcs_shouldNotSetHardwareAcceleratedFlag() throws Exception {
-        subject.onCreate(null);
-
-        boolean hardwareAccelerated = Shadows.shadowOf(subject.getWindow()).getFlag(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
-        assertThat(hardwareAccelerated).isFalse();
-    }
-
-    @Ignore("Mraid 2.0")
-    @Test
-    public void onDestroy_DestroyMraidView() throws Exception {
-        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_DISMISS, subject.getBroadcastIdentifier());
-        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver,
-                new EventForwardingBroadcastReceiver(customEventInterstitialListener,
-                        testBroadcastIdentifier).getIntentFilter());
-
-        subject.onDestroy();
-
-        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
-        verify(mockMraidWebView).destroy();
-        assertThat(getContentView().getChildCount()).isEqualTo(0);
-    }
-
-    @Ignore("Mraid 2.0")
-    @Test
-    public void getAdView_shouldSetupOnReadyListener() throws Exception {
-        reset(mockMraidWebView);
-        ArgumentCaptor<MraidListener> captor = ArgumentCaptor.forClass(MraidListener.class);
-        View actualAdView = subject.getAdView();
-
-        assertThat(actualAdView).isSameAs(mockMraidWebView);
-        verify(mraidController).setMraidListener(captor.capture());
-
-        subject.hideInterstitialCloseButton();
-        captor.getValue().onLoaded(null);
-    }
-
-    @Ignore("Mraid 2.0")
-    @Test
-    public void baseMraidListenerOnReady_shouldFireJavascriptWebViewDidAppear() throws Exception {
-        reset(mockMraidWebView);
-        ArgumentCaptor<MraidListener> captor = ArgumentCaptor.forClass(MraidListener.class);
-        View actualAdView = subject.getAdView();
-
-        assertThat(actualAdView).isSameAs(mockMraidWebView);
-        verify(mraidController).setMraidListener(captor.capture());
-
-        MraidListener baseMraidListener = captor.getValue();
-        baseMraidListener.onLoaded(null);
-
-        verify(mockMraidWebView).loadUrl(eq("javascript:webviewDidAppear();"));
-    }
-
-    @Ignore("Mraid 2.0")
-    @Test
-    public void baseMraidListenerOnClose_shouldFireJavascriptWebViewDidClose() throws Exception {
-        reset(mockMraidWebView);
-        ArgumentCaptor<MraidListener> captor = ArgumentCaptor.forClass(MraidListener.class);
-        View actualAdView = subject.getAdView();
-
-        assertThat(actualAdView).isSameAs(mockMraidWebView);
-        verify(mraidController).setMraidListener(captor.capture());
-
-        MraidListener baseMraidListener = captor.getValue();
-        baseMraidListener.onClose();
-
-        verify(mockMraidWebView).loadUrl(eq("javascript:webviewDidClose();"));
-    }
-
-    @Ignore("Mraid 2.0")
-    @Test
-    public void baseMraidListenerOnOpen_shouldBroadcastClickEvent() throws Exception {
-        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_CLICK, testBroadcastIdentifier);
-        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver,
-                new EventForwardingBroadcastReceiver(customEventInterstitialListener,
-                        testBroadcastIdentifier).getIntentFilter());
-
-        reset(mockMraidWebView);
-
-        ArgumentCaptor<MraidListener> captor = ArgumentCaptor.forClass(MraidListener.class);
-        View actualAdView = subject.getAdView();
-
-        assertThat(actualAdView).isSameAs(mockMraidWebView);
-        verify(mraidController).setMraidListener(captor.capture());
-
-        MraidListener baseMraidListener = captor.getValue();
-        baseMraidListener.onOpen();
-
-        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
-    }
-
-    @Ignore("Mraid 2.0")
-    @Test
-    public void getAdView_shouldSetupOnCloseListener() throws Exception {
-        reset(mockMraidWebView);
-        ArgumentCaptor<MraidListener> captor = ArgumentCaptor.forClass(MraidListener.class);
-        View actualAdView = subject.getAdView();
-
-        assertThat(actualAdView).isSameAs(mockMraidWebView);
-        verify(mraidController).setMraidListener(captor.capture());
-
-        captor.getValue().onClose();
-
-        ANDROID.assertThat(subject).isFinishing();
-    }
-
-    @Ignore("Mraid 2.0")
-    @Test
-    public void onPause_shouldOnPauseMraidView() throws Exception {
-        activityController.pause();
-
-        verify(mockMraidWebView).onPause();
-    }
-
-    @Ignore("Mraid 2.0")
-    @Test
-    public void onResume_shouldResumeMraidView() throws Exception {
-        subject.onCreate(null);
-        Shadows.shadowOf(subject).pauseAndThenResume();
-
-        verify(mockMraidWebView).onResume();
-    }
-
-    private Intent createMraidActivityIntent(String expectedSource) {
-        Intent mraidActivityIntent = new Intent();
-        mraidActivityIntent.setComponent(new ComponentName("", ""));
-        mraidActivityIntent.putExtra(HTML_RESPONSE_BODY_KEY, expectedSource);
-
-        mraidActivityIntent.putExtra(BROADCAST_IDENTIFIER_KEY, testBroadcastIdentifier);
-
-        return mraidActivityIntent;
-    }
-
-    @Ignore("Mraid 2.0")
-    @Test
-    public void onCreate_shouldBroadcastInterstitialShow() throws Exception {
-        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_SHOW, testBroadcastIdentifier);
-        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver,
-                new EventForwardingBroadcastReceiver(customEventInterstitialListener,
-                        testBroadcastIdentifier).getIntentFilter());
-
-        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
-    }
-
-    @Ignore("Mraid 2.0")
-    @Test
-    public void onDestroy_shouldBroadcastInterstitialDismiss() throws Exception {
-        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_DISMISS, testBroadcastIdentifier);
-        ShadowLocalBroadcastManager.getInstance(subject).registerReceiver(broadcastReceiver,
-                new EventForwardingBroadcastReceiver(customEventInterstitialListener,
-                        testBroadcastIdentifier).getIntentFilter());
-
-        subject.onDestroy();
-
-        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
-    }
-
-    private FrameLayout getContentView() {
-        return (FrameLayout) ((ViewGroup) subject.findViewById(android.R.id.content)).getChildAt(0);
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidVideoPlayerActivityTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidVideoPlayerActivityTest.java
deleted file mode 100644
index 8c120a01..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidVideoPlayerActivityTest.java
+++ /dev/null
@@ -1,252 +0,0 @@
-package com.mopub.mobileads;
-
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.ActivityInfo;
-import android.graphics.Bitmap;
-import android.os.Build;
-import android.os.Bundle;
-import android.view.TextureView;
-import android.view.View;
-import android.widget.ImageView;
-
-import com.mopub.common.Constants;
-import com.mopub.common.MoPubBrowser;
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.mraid.MraidVideoViewController;
-import com.mopub.nativeads.NativeFullScreenVideoView;
-import com.mopub.nativeads.NativeVideoController;
-import com.mopub.nativeads.NativeVideoViewController;
-
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.Shadows;
-import org.robolectric.annotation.Config;
-import org.robolectric.shadows.ShadowActivity;
-
-import java.lang.reflect.Constructor;
-
-import static com.mopub.common.DataKeys.BROADCAST_IDENTIFIER_KEY;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-@RunWith(SdkTestRunner.class)
-@Config(constants = BuildConfig.class)
-public class MraidVideoPlayerActivityTest {
-    private static final String VAST = "vast";
-    private static final String MRAID = "mraid";
-    private static final String NATIVE_VIDEO_VIEW_CONTROLLER =
-            "com.mopub.nativeads.NativeVideoViewController";
-
-    private MraidVideoPlayerActivity subject;
-    private long testBroadcastIdentifier;
-    private Intent intent;
-    private Context context;
-    private BaseVideoViewController baseVideoViewController;
-
-    @Before
-    public void setup() {
-        context = Robolectric.buildActivity(Activity.class).create().get();
-        intent = new Intent(context, MraidVideoPlayerActivity.class);
-
-        testBroadcastIdentifier = 1001;
-        intent.putExtra(BROADCAST_IDENTIFIER_KEY, testBroadcastIdentifier);
-        baseVideoViewController = mock(BaseVideoViewController.class);
-    }
-
-    @Test
-    public void onCreate_withVastExtraKey_shouldUseVastVideoViewController() throws Exception {
-        initializeSubjectForVast();
-
-        assertThat(subject.getBaseVideoViewController()).isInstanceOf(VastVideoViewController.class);
-    }
-
-    @Test
-    public void onCreate_withMraidExtraKey_shouldUseMraidVideoViewController() throws Exception {
-        initializeSubjectForMraid();
-
-        assertThat(subject.getBaseVideoViewController()).isInstanceOf(MraidVideoViewController.class);
-    }
-
-    @Test
-    public void onCreate_withNativeExtraKey_shouldUseNativeVideoViewController() throws Exception {
-        initializeSubjectForNative();
-
-        assertThat(subject.getBaseVideoViewController()).isInstanceOf(NativeVideoViewController.class);
-    }
-
-    @Ignore("pending: this is currently impossible to write")
-    @Test
-    public void onCreate_shouldForwardOnCreateToViewController() throws Exception {
-        initializeSubjectWithMockViewController();
-
-    }
-
-    @Test
-    public void onPause_shouldForwardOnPauseToViewController() throws Exception {
-        initializeSubjectWithMockViewController();
-
-        subject.onPause();
-
-        verify(baseVideoViewController).onPause();
-    }
-
-    @Test
-    public void onResume_shouldForwardOnResumeToViewController() throws Exception {
-        initializeSubjectWithMockViewController();
-
-        subject.onResume();
-
-        verify(baseVideoViewController).onResume();
-    }
-
-    @Test
-    public void onDestroy_shouldForwardOnDestroyToViewController() throws Exception {
-        initializeSubjectWithMockViewController();
-
-        subject.onDestroy();
-
-        verify(baseVideoViewController).onDestroy();
-    }
-
-    @Test
-    public void onActivityResult_shouldForwardOnActivityResultToViewController() throws Exception {
-        initializeSubjectWithMockViewController();
-
-        int expectedRequestCode = -100;
-        int expectedResultCode = 200;
-        Intent expectedData = new Intent("arbitrary_data");
-        subject.onActivityResult(expectedRequestCode, expectedResultCode, expectedData);
-
-        verify(baseVideoViewController).onActivityResult(
-                eq(expectedRequestCode),
-                eq(expectedResultCode),
-                eq(expectedData)
-        );
-    }
-
-    @Test
-    public void onSetContentView_shouldActuallySetContentView() throws Exception {
-        initializeSubjectWithMockViewController();
-        final View expectedView = new ImageView(context);
-
-        subject.onSetContentView(expectedView);
-
-        assertThat(Shadows.shadowOf(subject).getContentView()).isEqualTo(expectedView);
-    }
-
-    @Test
-    public void onSetRequestedOrientation_shouldActuallySetRequestedOrientation() throws Exception {
-        initializeSubjectWithMockViewController();
-
-        subject.onSetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR);
-
-        assertThat(subject.getRequestedOrientation()).isEqualTo(ActivityInfo.SCREEN_ORIENTATION_SENSOR);
-    }
-
-    @Test
-    public void onFinish_shouldActuallyCallFinish() throws Exception {
-        initializeSubjectWithMockViewController();
-
-        subject.onFinish();
-
-        assertThat(subject.isFinishing());
-    }
-
-    @Test
-    public void onStartActivityForResult_shouldStartAnActivityWithRelevantRequestCodeAndExtras() throws Exception {
-        initializeSubjectWithMockViewController();
-
-        final Bundle expectedExtras = new Bundle();
-        expectedExtras.putString("hello", "goodbye");
-
-        subject.onStartActivityForResult(MoPubBrowser.class, 100, expectedExtras);
-
-        final ShadowActivity.IntentForResult intentForResult = Shadows.shadowOf(subject).getNextStartedActivityForResult();
-
-        assertThat(intentForResult.intent.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
-        assertThat(intentForResult.intent.getExtras()).isEqualTo(expectedExtras);
-        assertThat(intentForResult.requestCode).isEqualTo(100);
-    }
-
-    @Test
-    public void onStartActivityForResult_withNullClass_shouldNotStartAnActivity() throws Exception {
-        initializeSubjectWithMockViewController();
-
-        subject.onStartActivityForResult(null, 100, new Bundle());
-
-        final ShadowActivity.IntentForResult intentForResult = Shadows.shadowOf(subject).getNextStartedActivityForResult();
-        assertThat(intentForResult).isNull();
-    }
-
-    @Test
-    public void createVideoViewController_withNativeVideoViewControllerReflectionConstructor_shouldExist() throws Exception {
-        final Class<?> nativeVideoViewController = Class.forName(NATIVE_VIDEO_VIEW_CONTROLLER);
-        final Constructor<?> declaredConstructor = nativeVideoViewController.getDeclaredConstructor(
-                Context.class, Bundle.class, Bundle.class,
-                BaseVideoViewController.BaseVideoViewControllerListener.class);
-
-        assertThat(declaredConstructor).isNotNull();
-    }
-
-    private void initializeSubjectForMraid() {
-        intent.putExtra(BaseVideoPlayerActivity.VIDEO_CLASS_EXTRAS_KEY, "mraid");
-
-        subject = Robolectric.buildActivity(MraidVideoPlayerActivity.class)
-                .withIntent(intent)
-                .create()
-                .get();
-    }
-
-    private void initializeSubjectForVast() {
-        intent.putExtra(BaseVideoPlayerActivity.VIDEO_CLASS_EXTRAS_KEY, "vast");
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("video_path");
-        intent.putExtra(VastVideoViewController.VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        subject = Robolectric.buildActivity(MraidVideoPlayerActivity.class)
-                .withIntent(intent)
-                .create()
-                .get();
-    }
-
-    @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
-    private void initializeSubjectForNative() {
-        intent.putExtra(BaseVideoPlayerActivity.VIDEO_CLASS_EXTRAS_KEY, "native");
-
-        NativeFullScreenVideoView mockFullScreenVideoView = mock(NativeFullScreenVideoView.class);
-        NativeVideoController mockVideoController = mock(NativeVideoController.class);
-        VastVideoConfig mockVastVideoConfig = mock(VastVideoConfig.class);
-        TextureView mockTextureView = mock(TextureView.class);
-        Bitmap mockBitmap = mock(Bitmap.class);
-
-        when(mockVastVideoConfig.getCustomCtaText()).thenReturn("Learn More");
-        when(mockFullScreenVideoView.getTextureView()).thenReturn(mockTextureView);
-        when(mockTextureView.getBitmap()).thenReturn(mockBitmap);
-
-        Bundle additionalExtras = new Bundle();
-        additionalExtras.putSerializable(Constants.NATIVE_VAST_VIDEO_CONFIG, mockVastVideoConfig);
-        additionalExtras.putLong(Constants.NATIVE_VIDEO_ID, 123);
-        NativeVideoController.setForId(123, mockVideoController);
-        intent.putExtras(additionalExtras);
-
-        subject = Robolectric.buildActivity(MraidVideoPlayerActivity.class)
-                .withIntent(intent)
-                .create()
-                .get();
-    }
-
-    private void initializeSubjectWithMockViewController() {
-        initializeSubjectForMraid();
-
-        subject.setBaseVideoViewController(baseVideoViewController);
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/RewardedVideoBroadcastReceiverTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/RewardedVideoBroadcastReceiverTest.java
deleted file mode 100644
index 97a711ec..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/RewardedVideoBroadcastReceiverTest.java
+++ /dev/null
@@ -1,68 +0,0 @@
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.content.Intent;
-import android.content.IntentFilter;
-
-import com.mopub.common.IntentActions;
-import com.mopub.common.test.support.SdkTestRunner;
-
-import org.fest.util.Sets;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.annotation.Config;
-
-import java.util.Iterator;
-import java.util.Set;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
-@RunWith(SdkTestRunner.class)
-@Config(constants = BuildConfig.class)
-public class RewardedVideoBroadcastReceiverTest {
-
-    private RewardedVastVideoInterstitial.CustomEventRewardedVideoInterstitialListener customEventRewardedVideoInterstitialListener;
-    private RewardedVideoBroadcastReceiver subject;
-    private Activity context;
-    private long broadcastIdentifier;
-
-    @Before
-    public void setUp() throws Exception {
-        customEventRewardedVideoInterstitialListener = mock(
-                RewardedVastVideoInterstitial.CustomEventRewardedVideoInterstitialListener.class);
-        broadcastIdentifier = 123456L;
-        subject = new RewardedVideoBroadcastReceiver(customEventRewardedVideoInterstitialListener,
-                broadcastIdentifier);
-        context = new Activity();
-    }
-
-    @Test
-    public void constructor_shouldSetIntentFilter() throws Exception {
-        Set<String> expectedActions = Sets.newLinkedHashSet(
-                IntentActions.ACTION_REWARDED_VIDEO_COMPLETE
-        );
-
-        final IntentFilter intentFilter = subject.getIntentFilter();
-        final Iterator<String> actionIterator = intentFilter.actionsIterator();
-
-        assertThat(intentFilter.countActions()).isEqualTo(1);
-        while (actionIterator.hasNext()) {
-            assertThat(expectedActions.contains(actionIterator.next()));
-        }
-    }
-
-    @Test
-    public void onReceive_withActionRewardedVideoComplete_shouldNotifyListener() {
-        final Intent rewardedVideoCompleteIntent = new Intent();
-        rewardedVideoCompleteIntent.setAction(
-                IntentActions.ACTION_REWARDED_VIDEO_COMPLETE);
-        rewardedVideoCompleteIntent.putExtra("broadcastIdentifier", broadcastIdentifier);
-
-        subject.onReceive(context, rewardedVideoCompleteIntent);
-
-        verify(customEventRewardedVideoInterstitialListener).onVideoComplete();
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastLinearXmlManagerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastLinearXmlManagerTest.java
deleted file mode 100644
index bee53d27..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastLinearXmlManagerTest.java
+++ /dev/null
@@ -1,478 +0,0 @@
-package com.mopub.mobileads;
-
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.mobileads.test.support.VastUtils;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.annotation.Config;
-import org.w3c.dom.Node;
-
-import java.util.List;
-
-import static com.mopub.mobileads.test.support.VastUtils.createNode;
-import static org.fest.assertions.api.Assertions.assertThat;
-
-@RunWith(SdkTestRunner.class)
-@Config(constants = BuildConfig.class)
-public class VastLinearXmlManagerTest {
-
-    private VastLinearXmlManager subject;
-    private Node linearNode;
-
-    @Before
-    public void setup() throws Exception {
-        String linearXml = "<Linear skipoffset=\"25%\">" +
-                "<Duration>00:00:58</Duration>" +
-                "<TrackingEvents>" +
-                "    <Tracking event=\"creativeView\">" +
-                "        <![CDATA[" +
-                "        https://creativeView/one" +
-                "        ]]>" +
-                "    </Tracking>" +
-                "    <Tracking event=\"creativeView\">" +
-                "        <![CDATA[" +
-                "        https://creativeView/two" +
-                "        ]]>" +
-                "    </Tracking>" +
-                // Ensure empty creativeView event is ignored
-                "    <Tracking event=\"creativeView\"/>" +
-                "    <Tracking event=\"start\">" +
-                "        <![CDATA[" +
-                "        https://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
-                "        ]]>" +
-                "    </Tracking>" +
-                "    <Tracking event=\"progress\" offset=\"13%\">" +
-                "        <![CDATA[" +
-                "        https://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
-                "        ]]>" +
-                "    </Tracking>" +
-                "    <Tracking event=\"progress\" offset=\"01:01:10.300\">" +
-                "        <![CDATA[" +
-                "        https://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
-                "        ]]>" +
-                "    </Tracking>" +
-                // Invalid tracking due to ambiguous offset.
-                "    <Tracking event=\"progress\" offset=\"01:01\">" +
-                "        <![CDATA[" +
-                "        https://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
-                "        ]]>" +
-                "    </Tracking>" +
-                // Invalid tracking due to a too-high percentage offset.
-                "    <Tracking event=\"progress\" offset=\"113%\">" +
-                "        <![CDATA[" +
-                "        https://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
-                "        ]]>" +
-                "    </Tracking>" +
-                // Invalid tracking due to a negative percentage offset.
-                "    <Tracking event=\"progress\" offset=\"-113%\">" +
-                "        <![CDATA[" +
-                "        https://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
-                "        ]]>" +
-                "    </Tracking>" +
-                // Invalid tracking due to a non-number offset
-                "    <Tracking event=\"progress\" offset=\"ten seconds\">" +
-                "        <![CDATA[" +
-                "        https://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;" +
-                "        ]]>" +
-                "    </Tracking>" +
-                "    <Tracking event=\"midpoint\">" +
-                "        <![CDATA[" +
-                "        https://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=18;ecn1=1;etm1=0;" +
-                "        ]]>" +
-                "    </Tracking>" +
-                "    <Tracking event=\"midpoint\">" +
-                "        <![CDATA[" +
-                "        https://ad.doubleclick.net/ad/N270.Process_Other/B3473145.3;sz=1x1;ord=2922389?" +
-                "        ]]>" +
-                "    </Tracking>" +
-                "    <Tracking event=\"firstQuartile\">" +
-                "        <![CDATA[" +
-                "        https://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=26;ecn1=1;etm1=0;" +
-                "        ]]>" +
-                "    </Tracking>" +
-                "    <Tracking event=\"firstQuartile\">" +
-                "        <![CDATA[" +
-                "        https://ad.doubleclick.net/ad/N270.Process_Other/B3473145.2;sz=1x1;ord=2922389?" +
-                "        ]]>" +
-                "    </Tracking>" +
-                "    <Tracking event=\"thirdQuartile\">" +
-                "        <![CDATA[" +
-                "        https://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=27;ecn1=1;etm1=0;" +
-                "        ]]>" +
-                "    </Tracking>" +
-                "    <Tracking event=\"thirdQuartile\">" +
-                "        <![CDATA[" +
-                "        https://ad.doubleclick.net/ad/N270.Process_Other/B3473145.4;sz=1x1;ord=2922389?" +
-                "        ]]>" +
-                "    </Tracking>" +
-                "    <Tracking event=\"complete\">" +
-                "        <![CDATA[" +
-                "        https://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=13;ecn1=1;etm1=0;" +
-                "        ]]>" +
-                "    </Tracking>" +
-                "    <Tracking event=\"complete\">" +
-                "        <![CDATA[" +
-                "        https://ad.doubleclick.net/ad/N270.Process_Other/B3473145.5;sz=1x1;ord=2922389?" +
-                "        ]]>" +
-                "    </Tracking>" +
-                "    <Tracking event=\"close\">" +
-                "        <![CDATA[" +
-                "        https://www.mopub.com/close?q=ignatius" +
-                "        ]]>" +
-                "    </Tracking>" +
-                "    <Tracking event=\"close\">" +
-                "        <![CDATA[" +
-                "        https://www.mopub.com/close?q=j3" +
-                "        ]]>" +
-                "    </Tracking>" +
-                "    <Tracking event=\"closeLinear\">" +
-                "        <![CDATA[" +
-                "        https://www.mopub.com/closeLinear" +
-                "        ]]>" +
-                "    </Tracking>" +
-                "    <Tracking event=\"skip\">" +
-                "        <![CDATA[" +
-                "        https://www.mopub.com/skip?q=ignatius" +
-                "        ]]>" +
-                "    </Tracking>" +
-                "    <Tracking event=\"skip\">" +
-                "        <![CDATA[" +
-                "        https://www.mopub.com/skip?q=j3" +
-                "        ]]>" +
-                "    </Tracking>" +
-                "    <Tracking event=\"mute\">" +
-                "        <![CDATA[" +
-                "        https://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=16;ecn1=1;etm1=0;" +
-                "        ]]>" +
-                "    </Tracking>" +
-                "    <Tracking event=\"pause\">" +
-                "        <![CDATA[" +
-                "        https://www.mopub.com/pause?num=1" +
-                "        ]]>" +
-                "    </Tracking>" +
-                "    <Tracking event=\"pause\">" +
-                "        <![CDATA[" +
-                "        https://www.mopub.com/pause?num=2" +
-                "        ]]>" +
-                "    </Tracking>" +
-                "    <Tracking event=\"resume\">" +
-                "        <![CDATA[" +
-                "        https://www.mopub.com/resume?num=1" +
-                "        ]]>" +
-                "    </Tracking>" +
-                "    <Tracking event=\"resume\">" +
-                "        <![CDATA[" +
-                "        https://www.mopub.com/resume?num=2" +
-                "        ]]>" +
-                "    </Tracking>" +
-                "    <Tracking event=\"fullscreen\">" +
-                "        <![CDATA[" +
-                "        https://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=19;ecn1=1;etm1=0;" +
-                "        ]]>" +
-                "    </Tracking>" +
-                "    <Tracking event=\"fullscreen\">" +
-                "        <![CDATA[" +
-                "        https://ad.doubleclick.net/ad/N270.Process_Other/B3473145.6;sz=1x1;ord=2922389?" +
-                "        ]]>" +
-                "    </Tracking>" +
-                "</TrackingEvents>" +
-                "<AdParameters/>" +
-                "<VideoClicks>" +
-                "    <ClickThrough>" +
-                "        <![CDATA[ https://www.google.com/support/richmedia ]]>" +
-                "    </ClickThrough>" +
-                "    <ClickTracking id=\"DART\">" +
-                "        <![CDATA[" +
-                "        https://ad.doubleclick.net/click%3Bh%3Dv8/3e1b/3/0/%2a/z%3B223626102%3B0-0%3B0%3B47414672%3B255-0/0%3B30477563/30495440/1%3B%3B%7Eaopt%3D0/0/ff/0%3B%7Esscs%3D%3fhttp://s0.2mdn.net/dot.gif" +
-                "        ]]>" +
-                "    </ClickTracking>" +
-                "    <ClickTracking id=\"ThirdParty\">" +
-                "        <![CDATA[" +
-                "        https://ad.doubleclick.net/clk;212442087;33815766;i?https://www.google.com/support/richmedia" +
-                "        ]]>" +
-                "    </ClickTracking>" +
-                "</VideoClicks>" +
-                "<MediaFiles>" +
-                "    <MediaFile id=\"1\" delivery=\"progressive\" type=\"video/quicktime\" bitrate=\"457\"" +
-                "               width=\"300\" height=\"225\">" +
-                "        <![CDATA[" +
-                "        https://s3.amazonaws.com/uploads.hipchat.com/10627/429509/t8hqeqf98nvtir7/big_buck_bunny.mp4" +
-                "        ]]>" +
-                "    </MediaFile>" +
-                "    <MediaFile id=\"2\" delivery=\"progressive\" type=\"video/quicktime\" bitrate=\"457\"" +
-                "               width=\"300\" height=\"225\">" +
-                "        <![CDATA[" +
-                "        https://s3.amazonaws.com/uploads.hipchat.com/10627/429509/t8hqeqf98nvtir7/big_buck_bunny_2.mp4" +
-                "        ]]>" +
-                "    </MediaFile>" +
-                "</MediaFiles>" +
-                "<Icons>" +
-                "    <Icon program=\"program\" width=\"123\" height=\"234\" xPosition=\"789\" " +
-                "    yPosition=\"101\" apiFramework=\"apiFramework\" offset=\"01:02:03\" " +
-                "    duration=\"01:02:03.456\">" +
-                "        <StaticResource creativeType=\"ImAge/JpEg\">" +
-                "           <![CDATA[staticResource1]]>" +
-                "        </StaticResource>" +
-                "    </Icon>" +
-                "    <Icon program=\"program\" width=\"123\" height=\"234\" xPosition=\"789\" " +
-                "    yPosition=\"101\" apiFramework=\"apiFramework\" offset=\"01:02:03\" " +
-                "    duration=\"01:02:03.456\">" +
-                "        <StaticResource creativeType=\"ImAge/JpEg\">" +
-                "           <![CDATA[staticResource2]]>" +
-                "        </StaticResource>" +
-                "    </Icon>" +
-                "</Icons>" +
-                "</Linear>";
-
-        linearNode = createNode(linearXml);
-    }
-
-    @Test
-    public void getFractionalTrackers_shouldReturnCorrectValues() {
-        subject = new VastLinearXmlManager(linearNode);
-        List<VastFractionalProgressTracker> trackers = subject.getFractionalProgressTrackers();
-
-        assertThat(trackers.size()).isEqualTo(7);
-
-        VastFractionalProgressTracker tracker0 = trackers.get(0);
-        assertThat(tracker0.trackingFraction()).isEqualTo(0.13f);
-        assertThat(tracker0.getTrackingUrl()).isEqualTo("https://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;");
-
-        VastFractionalProgressTracker tracker1 = trackers.get(1);
-        assertThat(tracker1.trackingFraction()).isEqualTo(0.25f);
-        assertThat(tracker1.getTrackingUrl()).isEqualTo("https://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=26;ecn1=1;etm1=0;");
-
-        VastFractionalProgressTracker tracker2 = trackers.get(2);
-        assertThat(tracker2.trackingFraction()).isEqualTo(0.25f);
-        assertThat(tracker2.getTrackingUrl()).isEqualTo("https://ad.doubleclick.net/ad/N270.Process_Other/B3473145.2;sz=1x1;ord=2922389?");
-
-        VastFractionalProgressTracker tracker3 = trackers.get(3);
-        assertThat(tracker3.trackingFraction()).isEqualTo(0.5f);
-        assertThat(tracker3.getTrackingUrl()).isEqualTo("https://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=18;ecn1=1;etm1=0;");
-
-        VastFractionalProgressTracker tracker4 = trackers.get(4);
-        assertThat(tracker4.trackingFraction()).isEqualTo(0.5f);
-        assertThat(tracker4.getTrackingUrl()).isEqualTo("https://ad.doubleclick.net/ad/N270.Process_Other/B3473145.3;sz=1x1;ord=2922389?");
-
-        VastFractionalProgressTracker tracker5 = trackers.get(5);
-        assertThat(tracker5.trackingFraction()).isEqualTo(0.75f);
-        assertThat(tracker5.getTrackingUrl()).isEqualTo("https://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=27;ecn1=1;etm1=0;");
-
-        VastFractionalProgressTracker tracker6 = trackers.get(6);
-        assertThat(tracker6.trackingFraction()).isEqualTo(0.75f);
-        assertThat(tracker6.getTrackingUrl()).isEqualTo("https://ad.doubleclick.net/ad/N270.Process_Other/B3473145.4;sz=1x1;ord=2922389?");
-    }
-
-    @Test
-    public void getAbsoluteProgressTrackers_shouldReturnCorrectValues() {
-        subject = new VastLinearXmlManager(linearNode);
-        List<VastAbsoluteProgressTracker> trackers = subject.getAbsoluteProgressTrackers();
-
-        assertThat(trackers.size()).isEqualTo(4);
-
-        VastAbsoluteProgressTracker tracker0 = trackers.get(0);
-        assertThat(tracker0.getTrackingMilliseconds()).isEqualTo(0);
-        assertThat(tracker0.getTrackingUrl()).isEqualTo("https://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;");
-
-        VastAbsoluteProgressTracker tracker1 = trackers.get(1);
-        assertThat(tracker1.getTrackingMilliseconds()).isEqualTo(0);
-        assertThat(tracker1.getTrackingUrl()).isEqualTo("https://creativeView/one");
-
-        VastAbsoluteProgressTracker tracker2 = trackers.get(2);
-        assertThat(tracker2.getTrackingMilliseconds()).isEqualTo(0);
-        assertThat(tracker2.getTrackingUrl()).isEqualTo("https://creativeView/two");
-
-        VastAbsoluteProgressTracker tracker3 = trackers.get(3);
-        assertThat(tracker3.getTrackingMilliseconds()).isEqualTo(3670300);
-        assertThat(tracker3.getTrackingUrl()).isEqualTo("https://ad.doubleclick.net/activity;" +
-                "src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;" +
-                "rv=1;timestamp=2922389;eid1=11;ecn1=1;etm1=0;");
-    }
-
-    @Test
-    public void getVideoCompleteTrackers_shouldReturnTheCorrectValue() {
-        subject = new VastLinearXmlManager(linearNode);
-        assertThat(VastUtils.vastTrackersToStrings(subject.getVideoCompleteTrackers()))
-                .containsOnly("https://ad.doubleclick.net/activity;src=2215309;met=1;v=1;pid=47414672;aid=223626102;ko=0;cid=30477563;rid=30495440;rv=1;timestamp=2922389;eid1=13;ecn1=1;etm1=0;",
-                        "https://ad.doubleclick.net/ad/N270.Process_Other/B3473145.5;sz=1x1;ord=2922389?");
-    }
-
-    @Test
-    public void getVideoCloseTrackers_shouldReturnTheCorrectValue() {
-        subject = new VastLinearXmlManager(linearNode);
-        assertThat(VastUtils.vastTrackersToStrings(subject.getVideoCloseTrackers()))
-                .containsOnly("https://www.mopub.com/close?q=ignatius",
-                        "https://www.mopub.com/close?q=j3",
-                        "https://www.mopub.com/closeLinear");
-    }
-
-    @Test
-    public void getPauseTrackers_shouldReturnRepeatableVastTrackers() {
-        subject = new VastLinearXmlManager(linearNode);
-        for (VastTracker vastTracker : subject.getPauseTrackers()) {
-            assertThat(vastTracker.isRepeatable());
-        }
-        assertThat(VastUtils.vastTrackersToStrings(subject.getPauseTrackers()))
-                .containsOnly("https://www.mopub.com/pause?num=1",
-                        "https://www.mopub.com/pause?num=2");
-    }
-
-    @Test
-    public void getResumeTrackers_shouldReturnRepeatableVastTrackers() {
-        subject = new VastLinearXmlManager(linearNode);
-        for (VastTracker vastTracker : subject.getResumeTrackers()) {
-            assertThat(vastTracker.isRepeatable());
-        }
-        assertThat(VastUtils.vastTrackersToStrings(subject.getResumeTrackers()))
-                .containsOnly("https://www.mopub.com/resume?num=1",
-                        "https://www.mopub.com/resume?num=2");
-    }
-
-    @Test
-    public void getVideoSkipTrackers_shouldReturnTheCorrectValue() {
-        subject = new VastLinearXmlManager(linearNode);
-        assertThat(VastUtils.vastTrackersToStrings(subject.getVideoSkipTrackers()))
-                .containsOnly("https://www.mopub.com/skip?q=ignatius",
-                        "https://www.mopub.com/skip?q=j3");
-    }
-
-    @Test
-    public void getClickThroughUrl_shouldReturnTheCorrectValue() {
-        subject = new VastLinearXmlManager(linearNode);
-        String url = subject.getClickThroughUrl();
-
-        assertThat(url).isEqualTo("https://www.google.com/support/richmedia");
-    }
-
-    @Test
-    public void getClickTrackers_shouldReturnTheCorrectValue() {
-        subject = new VastLinearXmlManager(linearNode);
-        assertThat(VastUtils.vastTrackersToStrings(subject.getClickTrackers()))
-                .containsOnly("https://ad.doubleclick" +
-                                ".net/click%3Bh%3Dv8/3e1b/3/0/%2a/z%3B223626102%3B0-0%3B0" +
-                                "%3B47414672%3B255-0/0%3B30477563/30495440/1%3B%3B%7Eaopt%3D0/0" +
-                                "/ff/0%3B%7Esscs%3D%3fhttp://s0.2mdn.net/dot.gif",
-                        "https://ad.doubleclick.net/clk;212442087;33815766;i?https://www.google" +
-                                ".com/support/richmedia");
-    }
-
-    @Test
-    public void getSkipOffset_shouldReturnTheCorrectValue() {
-        subject = new VastLinearXmlManager(linearNode);
-        String skipOffset = subject.getSkipOffset();
-
-        assertThat(skipOffset).isEqualTo("25%");
-    }
-
-    @Test
-    public void getSkipOffset_withNoSkipOffsetAttribute_shouldReturnNull() throws Exception {
-        String linearXml = "<Linear>" +
-                "</Linear>";
-
-        Node linearNode = createNode(linearXml);
-        subject = new VastLinearXmlManager(linearNode);
-
-        assertThat(subject.getSkipOffset()).isNull();
-    }
-
-    @Test
-    public void getSkipOffset_withNoSkipOffsetAttributeValue_shouldReturnNull() throws Exception {
-        String linearXml = "<Linear skipoffset=\"\">" +
-                "</Linear>";
-
-        Node linearNode = createNode(linearXml);
-        subject = new VastLinearXmlManager(linearNode);
-
-        assertThat(subject.getSkipOffset()).isNull();
-    }
-
-    @Test
-    public void getMediaXmlManagers_shouldReturnMediaXmlManagers() {
-        subject = new VastLinearXmlManager(linearNode);
-        List<VastMediaXmlManager> mediaXmlManagers = subject.getMediaXmlManagers();
-
-        assertThat(mediaXmlManagers.size()).isEqualTo(2);
-
-        assertThat(mediaXmlManagers.get(0).getMediaUrl()).isEqualTo("https://s3.amazonaws" +
-                ".com/uploads.hipchat.com/10627/429509/t8hqeqf98nvtir7/big_buck_bunny.mp4");
-        assertThat(mediaXmlManagers.get(1).getMediaUrl()).isEqualTo("https://s3.amazonaws" +
-                ".com/uploads.hipchat.com/10627/429509/t8hqeqf98nvtir7/big_buck_bunny_2.mp4");
-    }
-
-    @Test
-    public void getMediaXmlManagers_withNoMediaFileNode_shouldReturnEmptyList() throws Exception {
-        String linearXml = "<Linear skipoffset=\"25%\">" +
-                "    <MediaFiles>" +
-                "    </MediaFiles>" +
-                "</Linear>";
-
-        Node linearNode = createNode(linearXml);
-        subject = new VastLinearXmlManager(linearNode);
-
-        List<VastMediaXmlManager> mediaXmlManagers = subject.getMediaXmlManagers();
-        assertThat(mediaXmlManagers).isEmpty();
-    }
-
-    @Test
-    public void getMediaXmlManagers_withNoMediaFilesNode_shouldReturnEmptyList() throws Exception {
-        String linearXml = "<Linear skipoffset=\"25%\">" +
-                "    <MediaFile id=\"1\" delivery=\"progressive\" type=\"video/quicktime\" bitrate=\"457\"" +
-                "               width=\"300\" height=\"225\">" +
-                "        <![CDATA[" +
-                "        https://s3.amazonaws.com/uploads.hipchat.com/10627/429509/t8hqeqf98nvtir7/big_buck_bunny.mp4" +
-                "        ]]>" +
-                "    </MediaFile>" +
-                "</Linear>";
-
-        Node linearNode = createNode(linearXml);
-        subject = new VastLinearXmlManager(linearNode);
-
-        List<VastMediaXmlManager> mediaXmlManagers = subject.getMediaXmlManagers();
-        assertThat(mediaXmlManagers).isEmpty();
-    }
-
-    @Test
-    public void getIconXmlManagers_shouldReturnIconXmlManagers() throws Exception {
-        subject = new VastLinearXmlManager(linearNode);
-        List<VastIconXmlManager> iconXmlManagers = subject.getIconXmlManagers();
-
-        assertThat(iconXmlManagers).hasSize(2);
-        assertThat(iconXmlManagers.get(0).getResourceXmlManager().getStaticResource())
-                .isEqualTo("staticResource1");
-        assertThat(iconXmlManagers.get(1).getResourceXmlManager().getStaticResource())
-                .isEqualTo("staticResource2");
-    }
-
-    @Test
-    public void getIconXmlManagers_withNoIconNode_shouldReturnEmptyList() throws Exception {
-        String linearXml = "<Linear skipoffset=\"25%\">" +
-                "    <Icons>" +
-                "    </Icons>" +
-                "</Linear>";
-
-        Node linearNode = createNode(linearXml);
-        subject = new VastLinearXmlManager(linearNode);
-
-        assertThat(subject.getIconXmlManagers()).isEmpty();
-    }
-
-    @Test
-    public void getIconXmlManagers_withNoIconsNode_shouldReturnEmptyList() throws Exception {
-        String linearXml = "<Linear skipoffset=\"25%\">" +
-                "    <Icon program=\"program\" width=\"123\" height=\"234\" xPosition=\"789\" " +
-                "    yPosition=\"101\" apiFramework=\"apiFramework\" offset=\"01:02:03\" " +
-                "    duration=\"01:02:03.456\">" +
-                "        <StaticResource creativeType=\"ImAge/JpEg\">" +
-                "           <![CDATA[staticResource1]]>" +
-                "        </StaticResource>" +
-                "    </Icon>" +
-                "</Linear>";
-
-        Node linearNode = createNode(linearXml);
-        subject = new VastLinearXmlManager(linearNode);
-
-        assertThat(subject.getIconXmlManagers()).isEmpty();
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewControllerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewControllerTest.java
deleted file mode 100644
index 1c063c3a..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewControllerTest.java
+++ /dev/null
@@ -1,2312 +0,0 @@
-package com.mopub.mobileads;
-
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.content.res.Configuration;
-import android.graphics.Bitmap;
-import android.graphics.Color;
-import android.graphics.drawable.BitmapDrawable;
-import android.graphics.drawable.ColorDrawable;
-import android.graphics.drawable.Drawable;
-import android.media.MediaMetadataRetriever;
-import android.media.MediaPlayer;
-import android.net.Uri;
-import android.os.AsyncTask;
-import android.os.Build.VERSION_CODES;
-import android.os.Bundle;
-import android.view.View;
-import android.webkit.WebView;
-import android.widget.ImageView;
-import android.widget.VideoView;
-
-import com.mopub.TestSdkHelper;
-import com.mopub.common.MoPubBrowser;
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.DeviceUtils.ForceOrientation;
-import com.mopub.mobileads.resource.CloseButtonDrawable;
-import com.mopub.mobileads.test.support.GestureUtils;
-import com.mopub.mobileads.test.support.ShadowVastVideoView;
-import com.mopub.mobileads.test.support.VastUtils;
-import com.mopub.network.MaxWidthImageLoader;
-import com.mopub.network.MoPubRequestQueue;
-import com.mopub.network.Networking;
-
-import org.apache.http.HttpRequest;
-import org.apache.maven.artifact.ant.shaded.ReflectionUtils;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.robolectric.Robolectric;
-import org.robolectric.Shadows;
-import org.robolectric.annotation.Config;
-import org.robolectric.internal.ShadowExtractor;
-import org.robolectric.shadows.ShadowApplication;
-import org.robolectric.shadows.ShadowImageView;
-import org.robolectric.shadows.ShadowRelativeLayout;
-import org.robolectric.shadows.ShadowTextView;
-import org.robolectric.shadows.ShadowVideoView;
-import org.robolectric.shadows.httpclient.FakeHttp;
-import org.robolectric.shadows.httpclient.RequestMatcher;
-import org.robolectric.shadows.httpclient.TestHttpResponse;
-import org.robolectric.shadows.support.v4.ShadowLocalBroadcastManager;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-
-import static android.content.pm.ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
-import static android.content.pm.ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
-import static com.mopub.common.VolleyRequestMatcher.isUrl;
-import static com.mopub.mobileads.BaseVideoViewController.BaseVideoViewControllerListener;
-import static com.mopub.common.IntentActions.ACTION_INTERSTITIAL_DISMISS;
-import static com.mopub.common.IntentActions.ACTION_INTERSTITIAL_FAIL;
-import static com.mopub.common.IntentActions.ACTION_INTERSTITIAL_SHOW;
-import static com.mopub.mobileads.EventForwardingBroadcastReceiverTest.getIntentForActionAndIdentifier;
-import static com.mopub.mobileads.VastVideoViewController.CURRENT_POSITION;
-import static com.mopub.mobileads.VastVideoViewController.DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON;
-import static com.mopub.mobileads.VastVideoViewController.MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON;
-import static com.mopub.mobileads.VastVideoViewController.RESUMED_VAST_CONFIG;
-import static com.mopub.mobileads.VastVideoViewController.VAST_VIDEO_CONFIG;
-import static com.mopub.mobileads.VastXmlManagerAggregator.ADS_BY_AD_SLOT_ID;
-import static com.mopub.mobileads.VastXmlManagerAggregator.SOCIAL_ACTIONS_AD_SLOT_ID;
-import static com.mopub.volley.toolbox.ImageLoader.ImageListener;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyBoolean;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyLong;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.argThat;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.verifyZeroInteractions;
-import static org.mockito.Mockito.when;
-
-@RunWith(SdkTestRunner.class)
-@Config(constants = BuildConfig.class, shadows = {ShadowVastVideoView.class})
-public class VastVideoViewControllerTest {
-    public static final int NETWORK_DELAY = 100;
-
-    private static final String COMPANION_IMAGE_URL = "companion_image_url";
-    private static final String COMPANION_CLICK_TRACKING_URL_1 = "companion_click_tracking_url_1";
-    private static final String COMPANION_CLICK_TRACKING_URL_2 = "companion_click_tracking_url_2";
-    private static final String COMPANION_CLICK_TRACKING_URL_3 = "companion_click_tracking_url_3";
-    private static final String COMPANION_CLICK_DESTINATION_URL = "https://companion_click_destination_url";
-    private static final String COMPANION_CREATIVE_VIEW_URL_1 = "companion_creative_view_url_1";
-    private static final String COMPANION_CREATIVE_VIEW_URL_2 = "companion_creative_view_url_2";
-    private static final String COMPANION_CREATIVE_VIEW_URL_3 = "companion_creative_view_url_3";
-    private static final String RESOLVED_CLICKTHROUGH_URL = "https://www.mopub.com/";
-    private static final String CLICKTHROUGH_URL = "deeplink+://navigate?" +
-            "&primaryUrl=bogus%3A%2F%2Furl" +
-            "&fallbackUrl=" + Uri.encode(RESOLVED_CLICKTHROUGH_URL);
-
-    /**
-     * A list of macros to include in all trackers
-     */
-    private static final String MACRO_TAGS = "?errorcode=[ERRORCODE]&asseturi=[ASSETURI]&contentplayhead=[CONTENTPLAYHEAD]";
-
-    private Context context;
-    private Bundle bundle;
-    private Bundle savedInstanceState;
-    private long testBroadcastIdentifier;
-    private VastVideoViewController subject;
-    private int expectedBrowserRequestCode;
-    private String expectedUserAgent;
-
-    @Mock private BaseVideoViewControllerListener baseVideoViewControllerListener;
-    @Mock private EventForwardingBroadcastReceiver broadcastReceiver;
-    @Mock MoPubRequestQueue mockRequestQueue;
-    @Mock MaxWidthImageLoader mockImageLoader;
-    @Mock private VastIconConfig mMockVastIconConfig;
-    @Mock private MediaMetadataRetriever mockMediaMetadataRetriever;
-    @Mock private Bitmap mockBitmap;
-
-    private VastVideoViewCountdownRunnable spyCountdownRunnable;
-    private VastVideoViewProgressRunnable spyProgressRunnable;
-    private VideoView spyVideoView;
-
-    @TargetApi(VERSION_CODES.GINGERBREAD_MR1)
-    @Before
-    public void setUp() throws Exception {
-        Networking.setRequestQueueForTesting(mockRequestQueue);
-        Networking.setImageLoaderForTesting(mockImageLoader);
-        context = spy(Robolectric.buildActivity(Activity.class).create().get());
-        bundle = new Bundle();
-        savedInstanceState = new Bundle();
-        testBroadcastIdentifier = 1111;
-
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setNetworkMediaFileUrl("video_url");
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.setDspCreativeId("dsp_creative_id");
-        vastVideoConfig.addAbsoluteTrackers(
-                Arrays.asList(new VastAbsoluteProgressTracker("start" + MACRO_TAGS, 2000)));
-        vastVideoConfig.addFractionalTrackers(
-                Arrays.asList(new VastFractionalProgressTracker("first" + MACRO_TAGS, 0.25f),
-                        new VastFractionalProgressTracker("mid" + MACRO_TAGS, 0.5f),
-                        new VastFractionalProgressTracker("third" + MACRO_TAGS, 0.75f)));
-        vastVideoConfig.addPauseTrackers(
-                Arrays.asList(new VastTracker("pause" + MACRO_TAGS, true)));
-        vastVideoConfig.addResumeTrackers(
-                Arrays.asList(new VastTracker("resume" + MACRO_TAGS, true)));
-        vastVideoConfig.addCompleteTrackers(
-                VastUtils.stringsToVastTrackers("complete" + MACRO_TAGS));
-        vastVideoConfig.addCloseTrackers(
-                VastUtils.stringsToVastTrackers("close" + MACRO_TAGS));
-        vastVideoConfig.addSkipTrackers(VastUtils.stringsToVastTrackers("skip" + MACRO_TAGS));
-        vastVideoConfig.addImpressionTrackers(
-                VastUtils.stringsToVastTrackers("imp" + MACRO_TAGS));
-        vastVideoConfig.addErrorTrackers(
-                Collections.singletonList(new VastTracker("error" + MACRO_TAGS)));
-        vastVideoConfig.setClickThroughUrl(CLICKTHROUGH_URL);
-        vastVideoConfig.addClickTrackers(
-                VastUtils.stringsToVastTrackers("click_1" + MACRO_TAGS, "click_2" + MACRO_TAGS));
-
-        VastCompanionAdConfig landscapeVastCompanionAdConfig = new VastCompanionAdConfig(
-                300,
-                250,
-                new VastResource(COMPANION_IMAGE_URL,
-                        VastResource.Type.STATIC_RESOURCE,
-                        VastResource.CreativeType.IMAGE, 300, 250),
-                COMPANION_CLICK_DESTINATION_URL,
-                VastUtils.stringsToVastTrackers(COMPANION_CLICK_TRACKING_URL_1, COMPANION_CLICK_TRACKING_URL_2),
-                VastUtils.stringsToVastTrackers(COMPANION_CREATIVE_VIEW_URL_1, COMPANION_CREATIVE_VIEW_URL_2)
-        );
-        VastCompanionAdConfig portraitVastCompanionAdConfig = new VastCompanionAdConfig(
-                250,
-                300,
-                new VastResource(COMPANION_IMAGE_URL,
-                        VastResource.Type.STATIC_RESOURCE,
-                        VastResource.CreativeType.IMAGE, 250, 300),
-                COMPANION_CLICK_DESTINATION_URL,
-                VastUtils.stringsToVastTrackers(COMPANION_CLICK_TRACKING_URL_3),
-                VastUtils.stringsToVastTrackers(COMPANION_CREATIVE_VIEW_URL_3)
-        );
-        vastVideoConfig.setVastCompanionAd(landscapeVastCompanionAdConfig,
-                portraitVastCompanionAdConfig);
-
-        when(mMockVastIconConfig.getWidth()).thenReturn(40);
-        when(mMockVastIconConfig.getHeight()).thenReturn(40);
-        VastResource vastResource = mock(VastResource.class);
-        when(vastResource.getType()).thenReturn(VastResource.Type.STATIC_RESOURCE);
-        when(vastResource.getResource()).thenReturn("static");
-        when(vastResource.getCreativeType()).thenReturn(VastResource.CreativeType.IMAGE);
-        when(mMockVastIconConfig.getVastResource()).thenReturn(vastResource);
-        vastVideoConfig.setVastIconConfig(mMockVastIconConfig);
-
-
-        final ArrayList<VastTracker> vastTrackers = new ArrayList<>();
-        VastCompanionAdConfig socialActionsCompanionAd =
-                new VastCompanionAdConfig(65, 20, vastResource, "", vastTrackers, vastTrackers);
-        Map<String, VastCompanionAdConfig> socialActionsCompanionAds =
-                new HashMap<String, VastCompanionAdConfig>();
-        socialActionsCompanionAds.put(ADS_BY_AD_SLOT_ID, socialActionsCompanionAd);
-        socialActionsCompanionAds.put(SOCIAL_ACTIONS_AD_SLOT_ID, socialActionsCompanionAd);
-        vastVideoConfig.setSocialActionsCompanionAds(socialActionsCompanionAds);
-
-        when(mockMediaMetadataRetriever.getFrameAtTime(anyLong(), anyInt())).thenReturn(mockBitmap);
-
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        expectedBrowserRequestCode = 1;
-
-        Robolectric.getForegroundThreadScheduler().pause();
-        Robolectric.getBackgroundThreadScheduler().pause();
-        FakeHttp.clearPendingHttpResponses();
-
-        // Used to give responses to Vast Download Tasks.
-        FakeHttp.addHttpResponseRule(new RequestMatcher() {
-            @Override
-            public boolean matches(HttpRequest request) {
-                return true;
-            }
-        }, new TestHttpResponse(200, "body"));
-
-        ShadowLocalBroadcastManager.getInstance(context).registerReceiver(broadcastReceiver,
-                new EventForwardingBroadcastReceiver(null,
-                testBroadcastIdentifier).getIntentFilter());
-
-        expectedUserAgent = new WebView(context).getSettings().getUserAgentString();
-    }
-
-    @After
-    public void tearDown() throws Exception {
-        Robolectric.getForegroundThreadScheduler().reset();
-        Robolectric.getBackgroundThreadScheduler().reset();
-
-        ShadowLocalBroadcastManager.getInstance(context).unregisterReceiver(broadcastReceiver);
-    }
-
-    @Test
-    public void constructor_shouldAddCtaButtonWidgetToLayoutAndSetInvisibleWithOnTouchListeners() throws Exception {
-        initializeSubject();
-
-        VastVideoCtaButtonWidget ctaButtonWidget = subject.getCtaButtonWidget();
-        assertThat(ctaButtonWidget.getParent()).isEqualTo(subject.getLayout());
-        assertThat(ctaButtonWidget.getVisibility()).isEqualTo(View.INVISIBLE);
-        ShadowImageView ctaButtonWidgetShadow = Shadows.shadowOf(ctaButtonWidget);
-        assertThat(ctaButtonWidgetShadow.getOnTouchListener()).isNotNull();
-        assertThat(ctaButtonWidgetShadow.getOnTouchListener()).isEqualTo(
-                getShadowVideoView().getOnTouchListener());
-    }
-
-    @Test
-    public void constructor_shouldAddProgressBarWidgetToLayoutAndSetInvisibleWithNoListeners() throws Exception {
-        initializeSubject();
-
-        VastVideoProgressBarWidget progressBarWidget = subject.getProgressBarWidget();
-        assertThat(progressBarWidget.getParent()).isEqualTo(subject.getLayout());
-        assertThat(progressBarWidget.getVisibility()).isEqualTo(View.INVISIBLE);
-        ShadowImageView progressBarWidgetShadow = Shadows.shadowOf(progressBarWidget);
-        assertThat(progressBarWidgetShadow.getOnTouchListener()).isNull();
-    }
-
-    @Test
-    public void constructor_shouldAddRadialCountdownWidgetToLayoutAndSetInvisibleWithNoListeners() throws Exception {
-        initializeSubject();
-
-        VastVideoRadialCountdownWidget radialCountdownWidget = subject.getRadialCountdownWidget();
-        assertThat(radialCountdownWidget.getParent()).isEqualTo(subject.getLayout());
-        assertThat(radialCountdownWidget.getVisibility()).isEqualTo(View.INVISIBLE);
-        ShadowImageView radialCountdownWidgetShadow = Shadows.shadowOf(radialCountdownWidget);
-        assertThat(radialCountdownWidgetShadow.getOnTouchListener()).isNull();
-    }
-
-    @Test
-    public void constructor_shouldAddIconViewToLayoutAndSetInvisibleWithWebViewClickListener() throws Exception {
-        initializeSubject();
-
-        View iconView = subject.getIconView();
-        assertThat(iconView.getParent()).isEqualTo(subject.getLayout());
-        assertThat(iconView.getVisibility()).isEqualTo(View.INVISIBLE);
-        assertThat(((VastWebView)iconView).getVastWebViewClickListener()).isNotNull();
-    }
-
-    @Test
-    public void constructor_withAdsByCompanion_shouldAddAdsByViewToLayout() throws Exception {
-        initializeSubject();
-
-        View adsByView = subject.createAdsByView((Activity) context);
-        assertThat(adsByView.getVisibility()).isEqualTo(View.VISIBLE);
-        assertThat(subject.getHasSocialActions()).isTrue();
-        assertThat(subject.getCtaButtonWidget().getHasSocialActions()).isTrue();
-        assertThat(((VastWebView) adsByView).getVastWebViewClickListener()).isNotNull();
-    }
-
-    @Test
-    public void constructor_withSocialActionsCompanion_shouldAddSocialActionsViewToLayout() throws Exception {
-        initializeSubject();
-
-        View socialActionsView = subject.getSocialActionsView();
-        assertThat(socialActionsView.getVisibility()).isEqualTo(View.INVISIBLE);
-        assertThat(subject.getHasSocialActions()).isTrue();
-        assertThat(subject.getCtaButtonWidget().getHasSocialActions()).isTrue();
-        assertThat(((VastWebView) socialActionsView).getVastWebViewClickListener()).isNotNull();
-    }
-
-    @Test
-    public void constructor_shouldAddCloseButtonWidgetToLayoutAndSetToGoneWithOnTouchListeners() throws Exception {
-        initializeSubject();
-
-        VastVideoCloseButtonWidget closeButtonWidget = subject.getCloseButtonWidget();
-        assertThat(closeButtonWidget.getParent()).isEqualTo(subject.getLayout());
-        assertThat(closeButtonWidget.getVisibility()).isEqualTo(View.GONE);
-
-        ShadowRelativeLayout closeButtonWidgetShadow = (ShadowRelativeLayout) Shadows.shadowOf(closeButtonWidget);
-        assertThat(closeButtonWidgetShadow.getOnTouchListener()).isNull();
-
-        ShadowImageView closeButtonImageViewShadow = Shadows.shadowOf(closeButtonWidget.getImageView());
-        assertThat(closeButtonImageViewShadow.getOnTouchListener()).isNotNull();
-
-        ShadowTextView closeButtonTextViewShadow = Shadows.shadowOf(closeButtonWidget.getTextView());
-        assertThat(closeButtonTextViewShadow.getOnTouchListener()).isNotNull();
-    }
-
-    @Test
-    public void constructor_shouldAddTopGradientStripWidgetToLayoutWithNoListeners() throws Exception {
-        initializeSubject();
-
-        VastVideoGradientStripWidget topGradientStripWidget = subject.getTopGradientStripWidget();
-        assertThat(topGradientStripWidget.getParent()).isEqualTo(subject.getLayout());
-
-        ShadowImageView topGradientStripWidgetShadow = Shadows.shadowOf(topGradientStripWidget);
-        assertThat(topGradientStripWidgetShadow.getOnTouchListener()).isNull();
-    }
-
-    @Test
-    public void constructor_shouldAddBottomGradientStripWidgetToLayoutWithNoListeners() throws Exception {
-        initializeSubject();
-
-        VastVideoGradientStripWidget bottomGradientStripWidget = subject.getBottomGradientStripWidget();
-        assertThat(bottomGradientStripWidget.getParent()).isEqualTo(subject.getLayout());
-
-        ShadowImageView bottomGradientStripWidgetShadow = Shadows.shadowOf(bottomGradientStripWidget);
-        assertThat(bottomGradientStripWidgetShadow.getOnTouchListener()).isNull();
-    }
-
-    @Test
-    public void constructor_shouldAddBlurredLastVideoFrameWidgetToLayoutAndSetInvisibleWithNoListeners() throws Exception {
-        initializeSubject();
-
-        ImageView blurredLastVideoFrameImageView = subject.getBlurredLastVideoFrameImageView();
-        assertThat(blurredLastVideoFrameImageView.getParent()).isEqualTo(subject.getLayout());
-        assertThat(blurredLastVideoFrameImageView.getVisibility()).isEqualTo(View.INVISIBLE);
-        ShadowImageView blurredLastVideoFrameImageViewShadow = Shadows.shadowOf(blurredLastVideoFrameImageView);
-        assertThat(blurredLastVideoFrameImageViewShadow.getOnTouchListener()).isNull();
-    }
-
-    @Test
-    public void constructor_shouldSetVideoListenersAndVideoPath() throws Exception {
-        initializeSubject();
-        ShadowVideoView videoView = Shadows.shadowOf(subject.getVideoView());
-
-        assertThat(videoView.getOnCompletionListener()).isNotNull();
-        assertThat(videoView.getOnErrorListener()).isNotNull();
-        assertThat(videoView.getOnTouchListener()).isNotNull();
-        assertThat(videoView.getOnPreparedListener()).isNotNull();
-
-        assertThat(videoView.getVideoPath()).isEqualTo("disk_video_path");
-        assertThat(subject.getVideoView().hasFocus()).isTrue();
-    }
-
-    @Test
-    public void constructor_shouldNotChangeCloseButtonDelay() throws Exception {
-        initializeSubject();
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(
-                DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
-    }
-
-    @TargetApi(VERSION_CODES.HONEYCOMB)
-    @Test
-    public void constructor_shouldAddBlackBackgroundToLayout() throws Exception {
-        initializeSubject();
-        Drawable background = subject.getLayout().getBackground();
-        assertThat(background).isInstanceOf(ColorDrawable.class);
-        assertThat(((ColorDrawable) background).getColor()).isEqualTo(Color.BLACK);
-    }
-
-    @Test
-    public void constructor_withMissingVastVideoConfiguration_shouldThrowIllegalStateException() throws Exception {
-        bundle.clear();
-        try {
-            initializeSubject();
-            fail("VastVideoViewController didn't throw IllegalStateException");
-        } catch (IllegalStateException e) {
-            // pass
-        }
-    }
-
-    @Test
-    public void constructor_withNullVastVideoConfigurationDiskMediaFileUrl_shouldThrowIllegalStateException() throws Exception {
-        bundle.putSerializable(VAST_VIDEO_CONFIG, new VastVideoConfig());
-        try {
-            initializeSubject();
-            fail("VastVideoViewController didn't throw IllegalStateException");
-        } catch (IllegalStateException e) {
-            // pass
-        }
-    }
-
-    @Test
-    public void constructor_whenCustomCtaTextNotSpecified_shouldUseDefaultCtaText() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-
-        assertThat(subject.getCtaButtonWidget().getCtaText()).isEqualTo(
-                "Learn More");
-    }
-
-    @Test
-    public void constructor_whenCustomCtaTextSpecified_shouldUseCustomCtaText() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.setCustomCtaText("custom CTA text");
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-
-        assertThat(subject.getCtaButtonWidget().getCtaText()).isEqualTo(
-                "custom CTA text");
-    }
-
-    @Test
-    public void constructor_whenCustomSkipTextNotSpecified_shouldUseDefaultSkipText() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-
-        assertThat(subject.getCloseButtonWidget().getTextView().getText().toString()).isEqualTo(
-                "");
-    }
-
-    @Test
-    public void constructor_whenCustomSkipTextSpecified_shouldUseCustomSkipText() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.setCustomSkipText("custom skip text");
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-
-        assertThat(subject.getCloseButtonWidget().getTextView().getText().toString()).isEqualTo(
-                "custom skip text");
-    }
-
-    @Test
-    public void constructor_whenCustomCloseIconNotSpecified_shouldUseDefaultCloseIcon() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-
-        Drawable imageViewDrawable = subject.getCloseButtonWidget().getImageView().getDrawable();
-
-        // Default close icon is an instance of CloseButtonDrawable
-        assertThat(imageViewDrawable).isInstanceOf(CloseButtonDrawable.class);
-    }
-
-    @Test
-    public void constructor_whenCustomCloseIconSpecified_shouldUseCustomCloseIcon() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.setCustomCloseIconUrl(
-                "https://ton.twitter.com/exchange-media/images/v4/star_icon_3x_1.png");
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-
-        verify(mockImageLoader).get(
-                eq("https://ton.twitter.com/exchange-media/images/v4/star_icon_3x_1.png"),
-                any(ImageListener.class));
-    }
-
-    @Test
-    public void constructor_withVastConfigurationInSavedInstanceState_shouldUseThatVastConfiguration() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.setNetworkMediaFileUrl("resumed_network_media_url");
-        savedInstanceState.putSerializable(RESUMED_VAST_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-
-        assertThat(subject.getNetworkMediaFileUrl()).isEqualTo("resumed_network_media_url");
-    }
-
-    @Test
-    public void constructor_withSavedVastConfiguration_shouldUseThatVastConfiguration() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.setNetworkMediaFileUrl("resumed_network_media_url");
-        savedInstanceState.putSerializable(RESUMED_VAST_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-
-        assertThat(subject.getNetworkMediaFileUrl()).isEqualTo("resumed_network_media_url");
-    }
-
-    @Test
-    public void constructor_withSavedVastConfiguration_withCurrentPositionSet_shouldResumeVideoFromCurrentPosition() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.setNetworkMediaFileUrl("resumed_network_media_url");
-        savedInstanceState.putSerializable(RESUMED_VAST_CONFIG, vastVideoConfig);
-        savedInstanceState.putInt(CURRENT_POSITION, 123);
-
-        initializeSubject();
-        spyOnVideoView();
-
-        subject.onResume();
-
-        verify(spyVideoView).seekTo(eq(123));
-    }
-
-    @Test
-    public void onCreate_shouldFireImpressionTracker() throws Exception {
-        initializeSubject();
-
-        subject.onCreate();
-        verify(mockRequestQueue).add(
-                argThat(isUrl("imp?errorcode=&asseturi=video_url&contentplayhead=00:00:00.000")));
-    }
-
-    @Test
-    public void onCreate_shouldBroadcastInterstitialShow() throws Exception {
-        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_SHOW, testBroadcastIdentifier);
-
-        initializeSubject();
-
-        Robolectric.getForegroundThreadScheduler().unPause();
-        subject.onCreate();
-        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
-    }
-
-    @Test
-    public void onCreate_whenCustomForceOrientationNotSpecified_shouldForceLandscapeOrientation() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-        subject.onCreate();
-
-        verify(baseVideoViewControllerListener).onSetRequestedOrientation(
-                SCREEN_ORIENTATION_LANDSCAPE);
-    }
-
-    @Test
-    public void onCreate_whenCustomForceOrientationIsDeviceOrientation_shouldNotForceLandscapeOrientation() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.setCustomForceOrientation(ForceOrientation.DEVICE_ORIENTATION);
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-        subject.onCreate();
-
-        verify(baseVideoViewControllerListener, never()).onSetRequestedOrientation(anyInt());
-    }
-
-    @Test
-    public void onCreate_whenCustomForceOrientationIsPortraitOrientation_shouldForcePortraitOrientation() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.setCustomForceOrientation(ForceOrientation.FORCE_PORTRAIT);
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-        subject.onCreate();
-
-        verify(baseVideoViewControllerListener).onSetRequestedOrientation(
-                SCREEN_ORIENTATION_PORTRAIT);
-    }
-
-    @Test
-    public void onCreate_whenCustomForceOrientationIsLandscapeOrientation_shouldForceLandscapeOrientation() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.setCustomForceOrientation(ForceOrientation.FORCE_LANDSCAPE);
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-        subject.onCreate();
-
-        verify(baseVideoViewControllerListener).onSetRequestedOrientation(
-                SCREEN_ORIENTATION_LANDSCAPE);
-    }
-
-    @Test
-    public void VastWebView_onVastWebViewClick_shouldCallVastCompanionAdHandleClick() throws Exception {
-        initializeSubject();
-
-        VastCompanionAdConfig vastCompanionAdConfig = mock(VastCompanionAdConfig.class);
-        when(vastCompanionAdConfig.getWidth()).thenReturn(300);
-        when(vastCompanionAdConfig.getHeight()).thenReturn(240);
-        VastResource vastResource = mock(VastResource.class);
-        when(vastResource.getType()).thenReturn(VastResource.Type.STATIC_RESOURCE);
-        when(vastResource.getResource()).thenReturn("static");
-        when(vastCompanionAdConfig.getVastResource()).thenReturn(vastResource);
-
-        VastWebView view = (VastWebView) subject.createCompanionAdView(context,
-                vastCompanionAdConfig, View.INVISIBLE);
-
-        view.getVastWebViewClickListener().onVastWebViewClick();
-        verify(vastCompanionAdConfig).handleClick(any(Context.class), eq(1), anyString(), eq("dsp_creative_id"));
-    }
-
-    @Test
-    public void createCompanionAdView_shouldLayoutAndReturnInvisibleVastIconView() throws Exception {
-        initializeSubject();
-
-        VastCompanionAdConfig vastCompanionAdConfig = mock(VastCompanionAdConfig.class);
-        when(vastCompanionAdConfig.getWidth()).thenReturn(300);
-        when(vastCompanionAdConfig.getHeight()).thenReturn(240);
-        VastResource vastResource = mock(VastResource.class);
-        when(vastResource.getType()).thenReturn(VastResource.Type.STATIC_RESOURCE);
-        when(vastResource.getResource()).thenReturn("static");
-        when(vastCompanionAdConfig.getVastResource()).thenReturn(vastResource);
-
-        VastWebView view = (VastWebView) subject.createCompanionAdView(context,
-                vastCompanionAdConfig, View.INVISIBLE);
-
-        assertThat(view).isNotNull();
-        assertThat(view.getVisibility()).isEqualTo(View.INVISIBLE);
-        assertThat(view.getVastWebViewClickListener()).isNotNull();
-        assertThat(subject.getLayout().findViewById(view.getId())).isEqualTo(view);
-    }
-
-    @Test
-    public void createCompanionAdView_withNullCompanionAd_shouldReturnEmptyView() throws Exception {
-        initializeSubject();
-
-        assertThat(subject.createCompanionAdView(context, null, View.INVISIBLE)).isNotNull();
-    }
-
-    @Test
-    public void onDestroy_shouldBroadcastInterstitialDismiss() throws Exception {
-        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_DISMISS,
-                testBroadcastIdentifier);
-
-        initializeSubject();
-
-        subject.onDestroy();
-        Robolectric.getForegroundThreadScheduler().unPause();
-
-        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
-    }
-
-    @Test
-    public void onDestroy_withBlurLastVideoFrameTaskStillRunning_shouldCancelTask() throws Exception {
-        initializeSubject();
-
-        VastVideoBlurLastVideoFrameTask mockBlurLastVideoFrameTask = mock(
-                VastVideoBlurLastVideoFrameTask.class);
-        when(mockBlurLastVideoFrameTask.getStatus()).thenReturn(AsyncTask.Status.RUNNING);
-        subject.getVastVideoView().setBlurLastVideoFrameTask(mockBlurLastVideoFrameTask);
-
-        subject.onDestroy();
-
-        verify(mockBlurLastVideoFrameTask).cancel(true);
-    }
-
-    @Test
-    public void onDestroy_withBlurLastVideoFrameTaskStillPending_shouldCancelTask() throws Exception {
-        initializeSubject();
-
-        VastVideoBlurLastVideoFrameTask mockBlurLastVideoFrameTask = mock(VastVideoBlurLastVideoFrameTask.class);
-        when(mockBlurLastVideoFrameTask.getStatus()).thenReturn(AsyncTask.Status.PENDING);
-        subject.getVastVideoView().setBlurLastVideoFrameTask(mockBlurLastVideoFrameTask);
-
-        subject.onDestroy();
-
-        verify(mockBlurLastVideoFrameTask).cancel(true);
-    }
-
-    @Test
-    public void onDestroy_withBlurLastVideoFrameTaskFinished_shouldNotCancelTask() throws Exception {
-        initializeSubject();
-
-        VastVideoBlurLastVideoFrameTask mockBlurLastVideoFrameTask = mock(VastVideoBlurLastVideoFrameTask.class);
-        when(mockBlurLastVideoFrameTask.getStatus()).thenReturn(AsyncTask.Status.FINISHED);
-        subject.getVastVideoView().setBlurLastVideoFrameTask(mockBlurLastVideoFrameTask);
-
-        subject.onDestroy();
-
-        verify(mockBlurLastVideoFrameTask, never()).cancel(anyBoolean());
-    }
-
-    @Test
-    public void onSaveInstanceState_shouldSetCurrentPosition_shouldSetVastConfiguration() throws Exception {
-        initializeSubject();
-
-        Bundle bundle = mock(Bundle.class);
-        subject.onSaveInstanceState(bundle);
-
-        verify(bundle).putInt(eq(CURRENT_POSITION), anyInt());
-        verify(bundle).putSerializable(eq(RESUMED_VAST_CONFIG), any(VastVideoConfig
-                .class));
-    }
-
-    @Test
-    public void onActivityResult_shouldCallFinish() throws Exception {
-        final int expectedResultCode = Activity.RESULT_OK;
-
-        initializeSubject();
-
-        subject.onActivityResult(expectedBrowserRequestCode, expectedResultCode, null);
-
-        verify(baseVideoViewControllerListener).onFinish();
-    }
-
-    @Test
-    public void onActivityResult_withIncorrectRequestCode_shouldNotCallFinish() throws Exception {
-        final int incorrectRequestCode = 1000;
-        final int expectedResultCode = Activity.RESULT_OK;
-
-        initializeSubject();
-
-        subject.onActivityResult(incorrectRequestCode, expectedResultCode, null);
-
-        verify(baseVideoViewControllerListener, never()).onFinish();
-    }
-
-    @Test
-    public void onActivityResult_withIncorrectResultCode_shouldNotCallFinish() throws Exception {
-        final int incorrectResultCode = Activity.RESULT_CANCELED;
-
-        initializeSubject();
-
-        subject.onActivityResult(expectedBrowserRequestCode, incorrectResultCode, null);
-
-        verify(baseVideoViewControllerListener, never()).onFinish();
-    }
-
-    @Test
-    public void onTouch_withTouchUp_whenVideoLessThan16Seconds_andClickBeforeEnd_shouldDoNothing() throws Exception {
-        initializeSubject();
-        spyOnVideoView();
-        setVideoViewParams(15990, 15999);
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        Robolectric.getForegroundThreadScheduler().unPause();
-
-        getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(0, 0));
-
-        Intent nextStartedActivity = ShadowApplication.getInstance().getNextStartedActivity();
-        assertThat(nextStartedActivity).isNull();
-    }
-
-    @Test
-    public void onTouch_withTouchUp_whenVideoLessThan16Seconds_andClickAfterEnd_shouldTrackClick_shouldStartMoPubBrowser() throws Exception {
-        initializeSubject();
-        spyOnVideoView();
-        setVideoViewParams(15999, 15999);
-        subject.onResume();
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        Robolectric.getForegroundThreadScheduler().unPause();
-
-        getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(0, 0));
-
-        Robolectric.getBackgroundThreadScheduler().advanceBy(0);
-        final Intent startedActivity = ShadowApplication.getInstance().peekNextStartedActivity();
-        assertThat(startedActivity.getComponent().getClassName())
-                .isEqualTo(MoPubBrowser.class.getName());
-        assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(
-                RESOLVED_CLICKTHROUGH_URL);
-        verify((Activity) context).startActivityForResult(any(Intent.class),
-                eq(expectedBrowserRequestCode));
-    }
-
-    @Test
-    public void onTouch_withTouchUp_whenVideoLongerThan16Seconds_andClickBefore5Seconds_shouldDoNothing() throws Exception {
-        initializeSubject();
-        spyOnVideoView();
-        setVideoViewParams(4999, 100000);
-        subject.onResume();
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        Robolectric.getForegroundThreadScheduler().unPause();
-
-        getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(0, 0));
-
-        Intent nextStartedActivity = ShadowApplication.getInstance().getNextStartedActivity();
-        assertThat(nextStartedActivity).isNull();
-    }
-
-    @Test
-    public void onTouch_withTouchUp_whenVideoLongerThan16Seconds_andClickAfter5Seconds_shouldStartMoPubBrowser() throws Exception {
-        initializeSubject();
-        spyOnVideoView();
-        setVideoViewParams(5001, 100000);
-        subject.onResume();
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        Robolectric.getForegroundThreadScheduler().unPause();
-
-        getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(0, 0));
-
-        Robolectric.getBackgroundThreadScheduler().advanceBy(0);
-        final Intent startedActivity = ShadowApplication.getInstance().peekNextStartedActivity();
-        assertThat(startedActivity.getComponent().getClassName())
-                .isEqualTo(MoPubBrowser.class.getName());
-        assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(
-                RESOLVED_CLICKTHROUGH_URL);
-        verify((Activity) context).startActivityForResult(any(Intent.class),
-                eq(expectedBrowserRequestCode));
-    }
-
-    @Test
-    public void onTouch_whenCloseButtonVisible_shouldPingClickThroughTrackers() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setNetworkMediaFileUrl("video_url");
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.addClickTrackers(
-                VastUtils.stringsToVastTrackers("click_1" + MACRO_TAGS, "click_2" + MACRO_TAGS));
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-        spyOnVideoView();
-        // Because it's almost never exactly 15 seconds
-        when(spyVideoView.getDuration()).thenReturn(15142);
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
-
-        subject.setCloseButtonVisible(true);
-
-        getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(0, 0));
-        verify(mockRequestQueue).add(argThat(isUrl(
-                "click_1?errorcode=&asseturi=video_url&contentplayhead=00:00:15.142")));
-        verify(mockRequestQueue).add(argThat(isUrl(
-                "click_2?errorcode=&asseturi=video_url&contentplayhead=00:00:15.142")));
-    }
-
-    @Test
-    public void onTouch_whenCloseButtonNotVisible_shouldNotPingClickThroughTrackers() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.addClickTrackers(VastUtils.stringsToVastTrackers("click_1",
-                "click_2"));
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-
-        subject.setCloseButtonVisible(false);
-
-        getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(0, 0));
-        assertThat(FakeHttp.httpRequestWasMade()).isFalse();
-    }
-
-    @Test
-    public void onTouch_withNullBaseVideoViewListener_andActionTouchUp_shouldReturnTrueAndNotBlowUp() throws Exception {
-        subject = new VastVideoViewController((Activity) context, bundle, null,
-                testBroadcastIdentifier, null);
-
-        boolean result = getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionUp(
-                0, 0));
-
-        // pass
-
-        assertThat(result).isTrue();
-    }
-
-    @Test
-    public void onTouch_withActionTouchDown_shouldConsumeMotionEvent() throws Exception {
-        initializeSubject();
-
-        boolean result = getShadowVideoView().getOnTouchListener().onTouch(null, GestureUtils.createActionDown(
-                0, 0));
-
-        assertThat(result).isTrue();
-    }
-
-    @Test
-    public void onPrepared_whenDurationIsLessThanMaxVideoDurationForCloseButton_shouldSetShowCloseButtonDelayToDuration() throws Exception {
-        initializeSubject();
-        spyOnVideoView();
-        setVideoViewParams(0, 1000);
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(1000);
-    }
-
-    @Test
-    public void onPrepared_whenDurationIsGreaterThanMaxVideoDurationForCloseButton_shouldNotSetShowCloseButtonDelay() throws Exception {
-        initializeSubject();
-        spyOnVideoView();
-        setVideoViewParams(0, MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(
-                DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
-    }
-
-    @Test
-    public void onPrepared_whenPercentSkipOffsetSpecified_shouldSetShowCloseButtonDelayToSkipOffset() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.setSkipOffset("25%");
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-        spyOnVideoView();
-        setVideoViewParams(0, 10000);
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(2500);
-        assertThat(subject.getHasSkipOffset()).isTrue();
-    }
-
-    @Test
-    public void onPrepared_whenAbsoluteSkipOffsetSpecified_shouldSetShowCloseButtonDelayToSkipOffset() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.setSkipOffset("00:00:03");
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-        spyOnVideoView();
-        setVideoViewParams(0, 10000);
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(3000);
-        assertThat(subject.getHasSkipOffset()).isTrue();
-    }
-
-    @Test
-    public void onPrepared_whenAbsoluteSkipOffsetWithMillisecondsSpecified_shouldSetShowCloseButtonDelayToSkipOffset() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.setSkipOffset("00:00:03.141");
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-        spyOnVideoView();
-        setVideoViewParams(0, 10000);
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(3141);
-        assertThat(subject.getHasSkipOffset()).isTrue();
-    }
-
-    @Test
-    public void onPrepared_whenSkipOffsetIsNull_shouldNotSetShowCloseButtonDelay() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.setSkipOffset(null);
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-        spyOnVideoView();
-        setVideoViewParams(0, MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(
-                DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
-        assertThat(subject.getHasSkipOffset()).isFalse();
-    }
-
-    @Test
-    public void onPrepared_whenSkipOffsetHasInvalidAbsoluteFormat_shouldNotSetShowCloseButtonDelay() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.setSkipOffset("123:4:56.7");
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-        spyOnVideoView();
-        setVideoViewParams(0, MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(
-                DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
-        assertThat(subject.getHasSkipOffset()).isFalse();
-    }
-
-    @Test
-    public void onPrepared_whenSkipOffsetHasInvalidPercentFormat_shouldNotSetShowCloseButtonDelay() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.setSkipOffset("101%");
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-        spyOnVideoView();
-        setVideoViewParams(0, MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(
-                DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
-        assertThat(subject.getHasSkipOffset()).isFalse();
-    }
-
-    @Test
-    public void onPrepared_whenSkipOffsetHasInvalidFractionalPercentFormat_shouldNotSetShowCloseButtonDelay() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.setSkipOffset("3.14%");
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-        spyOnVideoView();
-        setVideoViewParams(0, MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(
-                DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
-        assertThat(subject.getHasSkipOffset()).isFalse();
-    }
-
-    @Test
-    public void onPrepared_whenSkipOffsetIsNegative_shouldNotSetShowCloseButtonDelay() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.setSkipOffset("-00:00:03");
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-        spyOnVideoView();
-        setVideoViewParams(0, MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(
-                DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
-        assertThat(subject.getHasSkipOffset()).isFalse();
-    }
-
-    @Test
-    public void onPrepared_whenSkipOffsetIsZero_shouldSetShowCloseButtonDelayToZero() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.setSkipOffset("00:00:00");
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-        spyOnVideoView();
-        setVideoViewParams(0, MAX_VIDEO_DURATION_FOR_CLOSE_BUTTON + 1);
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(0);
-        assertThat(subject.getHasSkipOffset()).isTrue();
-    }
-
-    @Test
-    public void onPrepared_whenSkipOffsetIsLongerThanDurationForShortVideo_shouldSetShowCloseButtonDelay() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.setSkipOffset("00:00:11");   // 11s
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-        spyOnVideoView();
-        setVideoViewParams(0, 10000);    // 10s: short video
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(10 * 1000);
-        assertThat(subject.getHasSkipOffset()).isTrue();
-    }
-
-    @Test
-    public void onPrepared_whenSkipOffsetIsLongerThanDurationForLongVideo_shouldSetShowCloseButtonDelay() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.setSkipOffset("00:00:21");   // 21s
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-        spyOnVideoView();
-        setVideoViewParams(0, 20000);    // 20s: long video
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(20 * 1000);
-        assertThat(subject.getHasSkipOffset()).isTrue();
-    }
-
-    @Test
-    public void onPrepared_whenSkipOffset100Percent_shouldSetShowCloseButtonDelayToVideoDuration() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.setSkipOffset("100%");   // 20000 ms
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-        spyOnVideoView();
-        setVideoViewParams(0, 20000);    // 20s: long video
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(20000);
-        assertThat(subject.getHasSkipOffset()).isTrue();
-    }
-
-    @Test
-    public void onPrepared_whenSkipOffsetGreaterThan100Percent_shouldSetShowCloseButtonDelayToDefault() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.setSkipOffset("101%");   // 20200 ms
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-        spyOnVideoView();
-        setVideoViewParams(0, 20000);    // 20s: long video
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);
-        assertThat(subject.getHasSkipOffset()).isFalse();
-    }
-
-    @Test
-    public void onPrepared_shouldCalibrateAndMakeVisibleRadialCountdownWidget() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.setSkipOffset("00:00:05");
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-        initializeSubject();
-        spyOnVideoView();
-        setVideoViewParams(0, 10000);
-
-        final VastVideoRadialCountdownWidget radialCountdownWidgetSpy = spy(subject.getRadialCountdownWidget());
-        subject.setRadialCountdownWidget(radialCountdownWidgetSpy);
-
-        assertThat(subject.isCalibrationDone()).isFalse();
-        assertThat(radialCountdownWidgetSpy.getVisibility()).isEqualTo(View.INVISIBLE);
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.isCalibrationDone()).isTrue();
-        assertThat(radialCountdownWidgetSpy.getVisibility()).isEqualTo(View.VISIBLE);
-        verify(radialCountdownWidgetSpy).calibrateAndMakeVisible(5000);
-    }
-
-    @Test
-    public void onPrepared_shouldCalibrateAndMakeVisibleProgressBarWidget() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.setSkipOffset("00:00:05");
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-        initializeSubject();
-        spyOnVideoView();
-        setVideoViewParams(0, 10000);
-
-        final VastVideoProgressBarWidget progressBarWidgetSpy = spy(subject.getProgressBarWidget());
-        subject.setProgressBarWidget(progressBarWidgetSpy);
-
-        assertThat(subject.isCalibrationDone()).isFalse();
-        assertThat(progressBarWidgetSpy.getVisibility()).isEqualTo(View.INVISIBLE);
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.isCalibrationDone()).isTrue();
-        assertThat(progressBarWidgetSpy.getVisibility()).isEqualTo(View.VISIBLE);
-        verify(progressBarWidgetSpy).calibrateAndMakeVisible(10000, 5000);
-    }
-
-    @Test
-    public void onPrepared_beforeGingerbreadMr1_shouldNotSetBlurredLastVideoFrame() throws Exception {
-
-        TestSdkHelper.setReportedSdkLevel(VERSION_CODES.GINGERBREAD);
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-        Robolectric.getBackgroundThreadScheduler().unPause();
-        Robolectric.getForegroundThreadScheduler().unPause();
-        Thread.sleep(NETWORK_DELAY);
-
-        assertThat(subject.getBlurredLastVideoFrameImageView().getDrawable()).isNull();
-
-        ShadowImageView imageView = Shadows.shadowOf(subject.getBlurredLastVideoFrameImageView());
-        assertThat(imageView.getOnTouchListener()).isNull();
-    }
-
-    @Test
-    public void onPrepared_atLeastGingerbreadMr1_shouldSetBlurredLastVideoFrame() throws Exception {
-        TestSdkHelper.setReportedSdkLevel(VERSION_CODES.GINGERBREAD_MR1);
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-        Robolectric.getBackgroundThreadScheduler().unPause();
-        Robolectric.getForegroundThreadScheduler().unPause();
-        Thread.sleep(NETWORK_DELAY);
-
-        final ImageView blurredLastVideoFrameImageView = subject.getBlurredLastVideoFrameImageView();
-        assertThat(blurredLastVideoFrameImageView.getDrawable()).isInstanceOf(BitmapDrawable.class);
-        assertThat(
-                ((BitmapDrawable) blurredLastVideoFrameImageView.getDrawable()).getBitmap()).isNotNull();
-
-        ShadowImageView imageView = Shadows.shadowOf(subject.getBlurredLastVideoFrameImageView());
-        assertThat(imageView.getOnTouchListener()).isNull();
-    }
-
-    @Test
-    public void onCompletion_shouldMarkVideoAsFinished() throws Exception {
-        initializeSubject();
-
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
-
-        assertThat(subject.isVideoFinishedPlaying()).isTrue();
-    }
-
-    @Test
-    public void onCompletion_whenAllTrackersTracked_whenNoPlaybackErrors_shouldPingCompletionTrackersOnlyOnce() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setNetworkMediaFileUrl("video_url");
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        VastAbsoluteProgressTracker testTracker = new VastAbsoluteProgressTracker(
-                "testUrl" + MACRO_TAGS, 123);
-        vastVideoConfig.addAbsoluteTrackers(Arrays.asList(testTracker));
-        vastVideoConfig.addCompleteTrackers(
-                VastUtils.stringsToVastTrackers("complete_1" + MACRO_TAGS,
-                        "complete_2" + MACRO_TAGS));
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-        testTracker.setTracked();
-        spyOnVideoView();
-        setVideoViewParams(15000, 15000);
-
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
-        verify(mockRequestQueue).add(argThat(isUrl(
-                "complete_1?errorcode=&asseturi=video_url&contentplayhead=00:00:15.000")));
-        verify(mockRequestQueue).add(argThat(isUrl(
-                "complete_2?errorcode=&asseturi=video_url&contentplayhead=00:00:15.000")));
-
-        // Completion trackers should still only be hit once
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
-        verify(mockRequestQueue).add(argThat(isUrl(
-                "complete_1?errorcode=&asseturi=video_url&contentplayhead=00:00:15.000")));
-        verify(mockRequestQueue).add(argThat(isUrl(
-                "complete_2?errorcode=&asseturi=video_url&contentplayhead=00:00:15.000")));
-    }
-
-    @Test
-    public void onCompletion_whenSomeTrackersRemain_shouldNotPingCompletionTrackers() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setNetworkMediaFileUrl("video_url");
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.addCompleteTrackers(
-                VastUtils.stringsToVastTrackers("complete_1", "complete_2"));
-        VastAbsoluteProgressTracker testTracker = new VastAbsoluteProgressTracker(
-                "testUrl" + MACRO_TAGS, 123);
-        // Never track the testTracker, so completion trackers should not be fired.
-        vastVideoConfig.addAbsoluteTrackers(Arrays.asList(testTracker));
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
-        verify(mockRequestQueue, never()).add(argThat(isUrl("complete_1")));
-        verify(mockRequestQueue, never()).add(argThat(isUrl("complete_2")));
-    }
-
-    @Test
-    public void onCompletion_whenPlaybackError_shouldNotPingCompletionTrackers() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setNetworkMediaFileUrl("video_url");
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.addCompleteTrackers(
-                VastUtils.stringsToVastTrackers("complete_1", "complete_2"));
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-        subject.setVideoError();
-        spyOnVideoView();
-        setVideoViewParams(12345, 15000);
-
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
-        verify(mockRequestQueue, never()).add(argThat(isUrl("complete_1")));
-        verify(mockRequestQueue, never()).add(argThat(isUrl("complete_2")));
-    }
-
-    @Test
-    public void onCompletion_shouldPreventOnResumeFromStartingVideo() throws Exception {
-        initializeSubject();
-
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
-
-        subject.onResume();
-
-        assertThat(getShadowVideoView().isPlaying()).isFalse();
-    }
-
-    @Test
-    public void onCompletion_shouldStopProgressCheckerAndCountdown() throws Exception {
-        initializeSubject();
-        subject.onResume();
-
-        reset(spyCountdownRunnable, spyCountdownRunnable);
-
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
-
-        verify(spyCountdownRunnable).stop();
-        verify(spyProgressRunnable).stop();
-    }
-
-    @Test
-    public void onCompletion_whenCompanionAdAvailable_shouldShowCompanionAdAndHideBlurredLastVideoFrame() throws Exception {
-        final VastVideoConfig vastVideoConfig =
-                (VastVideoConfig) bundle.getSerializable(VAST_VIDEO_CONFIG);
-        vastVideoConfig.setSocialActionsCompanionAds(new HashMap<String, VastCompanionAdConfig>());
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-        initializeSubject();
-
-        final View companionView = subject.getLandscapeCompanionAdView();
-        final ImageView blurredLastVideoFrameImageView = subject.getBlurredLastVideoFrameImageView();
-
-        assertThat(subject.getVideoView().getVisibility()).isEqualTo(View.VISIBLE);
-        assertThat(companionView.getVisibility()).isEqualTo(View.INVISIBLE);
-        assertThat(blurredLastVideoFrameImageView.getVisibility()).isEqualTo(View.INVISIBLE);
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-        Robolectric.getBackgroundThreadScheduler().unPause();
-        Robolectric.getForegroundThreadScheduler().unPause();
-        Thread.sleep(NETWORK_DELAY);
-
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
-
-        assertThat(subject.getVastVideoView().getBlurLastVideoFrameTask()).isNull();
-        assertThat(subject.getVideoView().getVisibility()).isEqualTo(View.INVISIBLE);
-        assertThat(companionView.getVisibility()).isEqualTo(View.VISIBLE);
-        assertThat(blurredLastVideoFrameImageView.getVisibility()).isEqualTo(View.INVISIBLE);
-    }
-
-    @Test
-    public void onCompletion_whenCompanionAdAvailable_shouldOnlyShowTopGradientStripWidget() throws Exception {
-        initializeSubject();
-
-        final VastVideoGradientStripWidget topGradientStripWidget = subject.getTopGradientStripWidget();
-        final VastVideoGradientStripWidget bottomGradientStripWidget = subject.getBottomGradientStripWidget();
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-        Robolectric.getBackgroundThreadScheduler().unPause();
-        Robolectric.getForegroundThreadScheduler().unPause();
-        Thread.sleep(NETWORK_DELAY);
-
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
-
-        assertThat(topGradientStripWidget.getVisibility()).isEqualTo(View.VISIBLE);
-        assertThat(bottomGradientStripWidget.getVisibility()).isEqualTo(View.GONE);
-    }
-
-    @Test
-    public void onCompletion_whenCompanionAdNotAvailable_shouldHideCompanionAdAndShowBlurredLastVideoFrame() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.setVastCompanionAd(null, null);
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-
-        final View companionView = subject.getLandscapeCompanionAdView();
-        final ImageView blurredLastVideoFrameImageView = subject.getBlurredLastVideoFrameImageView();
-
-        assertThat(subject.getVideoView().getVisibility()).isEqualTo(View.VISIBLE);
-        assertThat(companionView.getVisibility()).isEqualTo(View.INVISIBLE);
-        assertThat(blurredLastVideoFrameImageView.getVisibility()).isEqualTo(View.INVISIBLE);
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-        Robolectric.getBackgroundThreadScheduler().unPause();
-        Robolectric.getForegroundThreadScheduler().unPause();
-        Thread.sleep(NETWORK_DELAY);
-
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
-
-        assertThat(subject.getVastVideoView().getBlurLastVideoFrameTask()).isNotNull();
-        assertThat(subject.getVideoView().getVisibility()).isEqualTo(View.INVISIBLE);
-        assertThat(companionView.getVisibility()).isEqualTo(View.INVISIBLE);
-        assertThat(blurredLastVideoFrameImageView.getVisibility()).isEqualTo(View.VISIBLE);
-        assertThat(blurredLastVideoFrameImageView.getDrawable()).isInstanceOf(BitmapDrawable.class);
-        assertThat(
-                ((BitmapDrawable) blurredLastVideoFrameImageView.getDrawable()).getBitmap()).isNotNull();
-    }
-
-    @Test
-    public void onCompletion_whenCompanionAdNotAvailable_shouldHideBothGradientStripWidgets() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.setVastCompanionAd(null, null);
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-
-        final VastVideoGradientStripWidget topGradientStripWidget = subject.getTopGradientStripWidget();
-        final VastVideoGradientStripWidget bottomGradientStripWidget = subject.getBottomGradientStripWidget();
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-        Robolectric.getBackgroundThreadScheduler().unPause();
-        Robolectric.getForegroundThreadScheduler().unPause();
-        Thread.sleep(NETWORK_DELAY);
-
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
-
-        assertThat(topGradientStripWidget.getVisibility()).isEqualTo(View.GONE);
-        assertThat(bottomGradientStripWidget.getVisibility()).isEqualTo(View.GONE);
-    }
-
-    @TargetApi(VERSION_CODES.HONEYCOMB)
-    @Test
-    public void onCompletion_whenCompanionAdNotAvailableAndBlurredLastVideoFrameNotPrepared_shouldShowBlackBackground() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.setVastCompanionAd(null, null);
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-
-        final View companionView = subject.getLandscapeCompanionAdView();
-        final ImageView blurredLastVideoFrameImageView = subject.getBlurredLastVideoFrameImageView();
-
-        assertThat(subject.getVideoView().getVisibility()).isEqualTo(View.VISIBLE);
-        assertThat(companionView.getVisibility()).isEqualTo(View.INVISIBLE);
-        assertThat(blurredLastVideoFrameImageView.getVisibility()).isEqualTo(View.INVISIBLE);
-
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
-
-        assertThat(subject.getVastVideoView().getBlurLastVideoFrameTask()).isNull();
-        assertThat(subject.getVideoView().getVisibility()).isEqualTo(View.INVISIBLE);
-        assertThat(companionView.getVisibility()).isEqualTo(View.INVISIBLE);
-        assertThat(blurredLastVideoFrameImageView.getVisibility()).isEqualTo(View.INVISIBLE);
-
-        Drawable background = subject.getLayout().getBackground();
-        assertThat(((ColorDrawable) background).getColor()).isEqualTo(Color.BLACK);
-    }
-
-    @Test
-    public void onCompletion_whenCompanionAdNotAvailableAndBlurredLastVideoFrameNotPrepared_shouldHideBothGradientStripWidgets() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.setVastCompanionAd(null, null);
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-
-        final VastVideoGradientStripWidget topGradientStripWidget = subject.getTopGradientStripWidget();
-        final VastVideoGradientStripWidget bottomGradientStripWidget = subject.getBottomGradientStripWidget();
-
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
-
-        assertThat(topGradientStripWidget.getVisibility()).isEqualTo(View.GONE);
-        assertThat(bottomGradientStripWidget.getVisibility()).isEqualTo(View.GONE);
-    }
-
-    @Test
-    public void onCompletion_withSocialActions_shouldShowCompanionAdAndShowBlurredLastVideoFrame() throws Exception {
-        initializeSubject();
-
-        final View companionView = subject.getLandscapeCompanionAdView();
-        final ImageView blurredLastVideoFrameImageView = subject.getBlurredLastVideoFrameImageView();
-
-        assertThat(subject.getVideoView().getVisibility()).isEqualTo(View.VISIBLE);
-        assertThat(companionView.getVisibility()).isEqualTo(View.INVISIBLE);
-        assertThat(blurredLastVideoFrameImageView.getVisibility()).isEqualTo(View.INVISIBLE);
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-        Robolectric.getBackgroundThreadScheduler().unPause();
-        Robolectric.getForegroundThreadScheduler().unPause();
-        Thread.sleep(NETWORK_DELAY);
-
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
-
-        assertThat(subject.getVastVideoView().getBlurLastVideoFrameTask()).isNotNull();
-        assertThat(subject.getVideoView().getVisibility()).isEqualTo(View.INVISIBLE);
-        assertThat(companionView.getVisibility()).isEqualTo(View.VISIBLE);
-        assertThat(blurredLastVideoFrameImageView.getVisibility()).isEqualTo(View.VISIBLE);
-    }
-
-    @Test
-    public void onError_shouldFireVideoErrorAndReturnFalse() throws Exception {
-        initializeSubject();
-
-        Intent expectedIntent = getIntentForActionAndIdentifier(ACTION_INTERSTITIAL_FAIL, testBroadcastIdentifier);
-
-        boolean result = getShadowVideoView().getOnErrorListener().onError(null, 0, 0);
-        Robolectric.getForegroundThreadScheduler().unPause();
-
-        assertThat(result).isFalse();
-        verify(broadcastReceiver).onReceive(any(Context.class), eq(expectedIntent));
-        assertThat(subject.getVideoError()).isTrue();
-    }
-
-    @Test
-    public void onError_shouldStopProgressChecker() throws Exception {
-        initializeSubject();
-        subject.onResume();
-
-        verify(spyProgressRunnable).startRepeating(anyLong());
-        verify(spyCountdownRunnable).startRepeating(anyLong());
-        reset(spyProgressRunnable, spyCountdownRunnable);
-        getShadowVideoView().getOnErrorListener().onError(null, 0, 0);
-
-        verify(spyProgressRunnable).stop();
-        verify(spyCountdownRunnable).stop();
-    }
-
-
-    @Test
-    @Config(shadows = {MoPubShadowMediaPlayer.class})
-    public void onError_withVideoFilePermissionErrorBelowJellyBean_shouldRetryPlayingTheVideo() throws Exception {
-        TestSdkHelper.setReportedSdkLevel(VERSION_CODES.ICE_CREAM_SANDWICH);
-
-        File file = new File("disk_video_path");
-        file.createNewFile();
-
-        // ShadowMediaPlayer setup needed to
-
-        initializeSubject();
-
-        assertThat(getShadowVideoView().getCurrentVideoState()).isEqualTo(-1);
-
-        assertThat(subject.getVastVideoView().getVideoRetries()).isEqualTo(0);
-        getShadowVideoView().getOnErrorListener().onError(new MediaPlayer(), 1, Integer.MIN_VALUE);
-
-        // Robo 3.0 introduces a requirement that ShadowMediaPlayer be set up with MediaInfo for a data source.
-        // Because we generate a file descriptor datasource at runtime, we can't set it up easily in this test.
-
-        assertThat(getShadowVideoView().isPlaying()).isTrue();
-        assertThat(subject.getVastVideoView().getVideoRetries()).isEqualTo(1);
-
-        file.delete();
-    }
-
-    @Test
-    public void onError_shouldFireErrorTrackers() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setNetworkMediaFileUrl("video_url");
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.addCompleteTrackers(
-                VastUtils.stringsToVastTrackers("complete_1", "complete_2"));
-        vastVideoConfig.addErrorTrackers(
-                Collections.singletonList(new VastTracker("error" + MACRO_TAGS)));
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-        subject.setVideoError();
-        spyOnVideoView();
-        setVideoViewParams(12345, 15000);
-
-        getShadowVideoView().getOnErrorListener().onError(null, 0, 0);
-        verify(mockRequestQueue, never()).add(argThat(isUrl("complete_1")));
-        verify(mockRequestQueue, never()).add(argThat(isUrl("complete_2")));
-        verify(mockRequestQueue).add(argThat(isUrl(
-                "error?errorcode=400&asseturi=video_url&contentplayhead=00:00:12.345")));
-    }
-
-    @Test
-    public void onError_withMultipleCalls_shouldRepeatedlyFireErrorTrackers() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setNetworkMediaFileUrl("video_url");
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.addErrorTrackers(
-                Collections.singletonList(new VastTracker("error" + MACRO_TAGS)));
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-        subject.setVideoError();
-        spyOnVideoView();
-        setVideoViewParams(12345, 15000);
-
-        for(int i = 0; i < 10; i++) {
-            getShadowVideoView().getOnErrorListener().onError(null, 0, 0);
-            verify(mockRequestQueue).add(argThat(isUrl(
-                    "error?errorcode=400&asseturi=video_url&contentplayhead=00:00:12.345")));
-        }
-        verifyNoMoreInteractions(mockRequestQueue);
-    }
-
-    @Test
-    public void videoRunnablesRun_shouldFireOffAllProgressTrackers() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setNetworkMediaFileUrl("video_url");
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.addFractionalTrackers(
-                Arrays.asList(new VastFractionalProgressTracker("first" + MACRO_TAGS, 0.25f),
-                        new VastFractionalProgressTracker("second" + MACRO_TAGS, 0.5f),
-                        new VastFractionalProgressTracker("third" + MACRO_TAGS, 0.75f)));
-
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-        spyOnVideoView();
-        setVideoViewParams(9002, 9002);
-        subject.onResume();
-
-        // this runs the videoProgressChecker and countdown runnable
-        Robolectric.getForegroundThreadScheduler().unPause();
-
-        verify(mockRequestQueue).add(
-                argThat(isUrl("first?errorcode=&asseturi=video_url&contentplayhead=00:00:09.002")));
-        verify(mockRequestQueue).add(argThat(isUrl(
-                "second?errorcode=&asseturi=video_url&contentplayhead=00:00:09.002")));
-        verify(mockRequestQueue).add(
-                argThat(isUrl("third?errorcode=&asseturi=video_url&contentplayhead=00:00:09.002")));
-    }
-
-    @Test
-    public void videoRunnablesRun_whenDurationIsInvalid_shouldNotMakeAnyNetworkCalls() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-        spyOnVideoView();
-        setVideoViewParams(0, 100);
-
-        subject.onResume();
-        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(2);
-        Robolectric.getForegroundThreadScheduler().runOneTask();
-        Robolectric.getForegroundThreadScheduler().runOneTask();
-
-        // make sure the repeated task hasn't run yet
-        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(2);
-        verifyZeroInteractions(mockRequestQueue);
-    }
-
-    @Test
-    public void videoRunnablesRun_whenCurrentTimeLessThanTwoSeconds_shouldNotFireStartTracker() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.addAbsoluteTrackers(
-                Arrays.asList(new VastAbsoluteProgressTracker("start", 2000)));
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-        spyOnVideoView();
-        setVideoViewParams(1999, 100000);
-        subject.onResume();
-
-        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(2);
-
-        Robolectric.getForegroundThreadScheduler().runOneTask();
-        Robolectric.getForegroundThreadScheduler().runOneTask();
-        // make sure the repeated task hasn't run yet
-        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(2);
-
-        // Since it has not yet been a second, we expect that the start tracker has not been fired
-        verifyZeroInteractions(mockRequestQueue);
-
-        // run checker another time
-        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(2);
-        Robolectric.getForegroundThreadScheduler().runOneTask();
-        Robolectric.getForegroundThreadScheduler().runOneTask();
-
-        verifyZeroInteractions(mockRequestQueue);
-    }
-
-    @Test
-    public void videoRunnablesRun_whenCurrentTimeGreaterThanTwoSeconds_shouldFireStartTracker() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setNetworkMediaFileUrl("video_url");
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.addAbsoluteTrackers(
-                Arrays.asList(new VastAbsoluteProgressTracker("start" + MACRO_TAGS, 2000)));
-        vastVideoConfig.addAbsoluteTrackers(
-                Arrays.asList(new VastAbsoluteProgressTracker("later" + MACRO_TAGS, 3000)));
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-        spyOnVideoView();
-        setVideoViewParams(2000, 100000);
-        subject.onResume();
-        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(2);
-
-        Robolectric.getForegroundThreadScheduler().unPause();
-
-        verify(mockRequestQueue).add(
-                argThat(isUrl("start?errorcode=&asseturi=video_url&contentplayhead=00:00:02.000")));
-
-        // run checker another time
-        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(2);
-        Robolectric.getForegroundThreadScheduler().runOneTask();
-        Robolectric.getForegroundThreadScheduler().runOneTask();
-
-        verifyNoMoreInteractions(mockRequestQueue);
-    }
-
-    @Test
-    public void videoRunnablesRun_whenProgressIsPastFirstQuartile_shouldOnlyPingFirstQuartileTrackersOnce() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setNetworkMediaFileUrl("video_url");
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.addFractionalTrackers(
-                Arrays.asList(new VastFractionalProgressTracker("first" + MACRO_TAGS, 0.25f)));
-        vastVideoConfig.addFractionalTrackers(
-                Arrays.asList(new VastFractionalProgressTracker("don't call" + MACRO_TAGS, 0.28f)));
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-        spyOnVideoView();
-        setVideoViewParams(26, 100);
-        subject.onResume();
-
-        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(2);
-
-        Robolectric.getForegroundThreadScheduler().unPause();
-
-        verify(mockRequestQueue).add(
-                argThat(isUrl("first?errorcode=&asseturi=video_url&contentplayhead=00:00:00.026")));
-
-        // run checker another time
-        Robolectric.getForegroundThreadScheduler().runOneTask();
-        Robolectric.getForegroundThreadScheduler().runOneTask();
-
-        verifyNoMoreInteractions(mockRequestQueue);
-    }
-
-    @Test
-    public void videoRunnablesRun_whenProgressIsPastMidQuartile_shouldPingFirstQuartileTrackers_andMidQuartileTrackersBothOnlyOnce() throws Exception {
-
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setNetworkMediaFileUrl("video_url");
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.addFractionalTrackers(
-                Arrays.asList(new VastFractionalProgressTracker("first" + MACRO_TAGS, 0.25f)));
-        vastVideoConfig.addFractionalTrackers(
-                Arrays.asList(new VastFractionalProgressTracker("second" + MACRO_TAGS, 0.5f)));
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-        spyOnVideoView();
-        setVideoViewParams(51, 100);
-
-        subject.onResume();
-        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(2);
-
-        Robolectric.getForegroundThreadScheduler().unPause();
-
-        verify(mockRequestQueue).add(
-                argThat(isUrl("first?errorcode=&asseturi=video_url&contentplayhead=00:00:00.051")));
-        verify(mockRequestQueue).add(argThat(isUrl(
-                "second?errorcode=&asseturi=video_url&contentplayhead=00:00:00.051")));
-
-        Robolectric.getForegroundThreadScheduler().runOneTask();
-        Robolectric.getForegroundThreadScheduler().runOneTask();
-
-        verifyNoMoreInteractions(mockRequestQueue);
-    }
-
-    @Test
-    public void videoRunnablesRun_whenProgressIsPastThirdQuartile_shouldPingFirstQuartileTrackers_andMidQuartileTrackers_andThirdQuartileTrackersAllOnlyOnce() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setNetworkMediaFileUrl("video_url");
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.addFractionalTrackers(
-                Arrays.asList(new VastFractionalProgressTracker("first" + MACRO_TAGS, 0.25f)));
-        vastVideoConfig.addFractionalTrackers(
-                Arrays.asList(new VastFractionalProgressTracker("second" + MACRO_TAGS, 0.5f)));
-        vastVideoConfig.addFractionalTrackers(
-                Arrays.asList(new VastFractionalProgressTracker("third" + MACRO_TAGS, 0.75f)));
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-        spyOnVideoView();
-        setVideoViewParams(76, 100);
-
-        subject.onResume();
-        assertThat(Robolectric.getForegroundThreadScheduler().size()).isEqualTo(2);
-
-        Robolectric.getForegroundThreadScheduler().unPause();
-
-        verify(mockRequestQueue).add(
-                argThat(isUrl("first?errorcode=&asseturi=video_url&contentplayhead=00:00:00.076")));
-        verify(mockRequestQueue).add(argThat(isUrl(
-                "second?errorcode=&asseturi=video_url&contentplayhead=00:00:00.076")));
-        verify(mockRequestQueue).add(
-                argThat(isUrl("third?errorcode=&asseturi=video_url&contentplayhead=00:00:00.076")));
-
-        Robolectric.getForegroundThreadScheduler().runOneTask();
-        Robolectric.getForegroundThreadScheduler().runOneTask();
-
-        verifyNoMoreInteractions(mockRequestQueue);
-    }
-
-    @Test
-    public void videoRunnablesRun_asVideoPlays_shouldPingAllThreeTrackersIndividuallyOnce() throws Exception {
-        //stub(mockMediaPlayer.getDuration()).toReturn(100);
-
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setNetworkMediaFileUrl("video_url");
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.addFractionalTrackers(
-                Arrays.asList(new VastFractionalProgressTracker("first" + MACRO_TAGS, 0.25f)));
-        vastVideoConfig.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("second" + MACRO_TAGS, 0.5f)));
-        vastVideoConfig.addFractionalTrackers(Arrays.asList(new VastFractionalProgressTracker("third" + MACRO_TAGS, 0.75f)));
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-        spyOnVideoView();
-        when(spyVideoView.getDuration()).thenReturn(100);
-        subject.onResume();
-
-        // before any trackers are fired
-        seekToAndAssertRequestsMade(1);
-
-        seekToAndAssertRequestsMade(24);
-
-        // after it hits first tracker
-        seekToAndAssertRequestsMade(26,
-                "first?errorcode=&asseturi=video_url&contentplayhead=00:00:00.026");
-
-        // before mid quartile is hit
-        seekToAndAssertRequestsMade(49);
-
-        // after it hits mid trackers
-        seekToAndAssertRequestsMade(51,
-                "second?errorcode=&asseturi=video_url&contentplayhead=00:00:00.051");
-
-        // before third quartile is hit
-        seekToAndAssertRequestsMade(74);
-
-        // after third quartile is hit
-        seekToAndAssertRequestsMade(76,
-                "third?errorcode=&asseturi=video_url&contentplayhead=00:00:00.076");
-
-        // way after third quartile is hit
-        seekToAndAssertRequestsMade(99);
-    }
-
-    private void seekToAndAssertRequestsMade(int position, String... trackingUrls) {
-        when(spyVideoView.getCurrentPosition()).thenReturn(position);
-        Robolectric.getForegroundThreadScheduler().advanceToLastPostedRunnable();
-
-        for (String url : trackingUrls) {
-            verify(mockRequestQueue).add(argThat(isUrl(url)));
-        }
-    }
-
-    @Test
-    public void videoRunnablesRun_whenCurrentPositionIsGreaterThanShowCloseButtonDelay_shouldShowCloseButton() throws Exception {
-
-        initializeSubject();
-        spyOnVideoView();
-        setVideoViewParams(5001, 5002);
-        subject.onResume();
-
-        assertThat(subject.isShowCloseButtonEventFired()).isFalse();
-        Robolectric.getForegroundThreadScheduler().unPause();
-
-        assertThat(subject.isShowCloseButtonEventFired()).isTrue();
-    }
-
-    @Test
-    public void videoRunnablesRun_whenCurrentPositionIsGreaterThanSkipOffset_shouldShowCloseButton() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.setSkipOffset("25%");    // skipoffset is at 2.5s
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-        spyOnVideoView();
-        setVideoViewParams(2501, 10000); // duration is 10s, current position is 1ms after skipoffset
-        subject.onResume();
-
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(2500);
-        assertThat(subject.getHasSkipOffset()).isTrue();
-
-        assertThat(subject.isShowCloseButtonEventFired()).isFalse();
-        Robolectric.getForegroundThreadScheduler().unPause();
-
-        assertThat(subject.isShowCloseButtonEventFired()).isTrue();
-    }
-
-    @Test
-    public void videoRunnablesRun_whenCurrentPositionIsLessThanSkipOffset_shouldNotShowCloseButton() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.setSkipOffset("00:00:03");   // skipoffset is at 3s
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-
-        initializeSubject();
-        spyOnVideoView();
-        setVideoViewParams(2999, 10000); // duration is 10s, current position is 1ms before skipoffset
-        subject.onResume();
-
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-
-        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(3000);
-        assertThat(subject.getHasSkipOffset()).isTrue();
-
-        assertThat(subject.isShowCloseButtonEventFired()).isFalse();
-        Robolectric.getForegroundThreadScheduler().unPause();
-
-        assertThat(subject.isShowCloseButtonEventFired()).isFalse();
-    }
-
-    @Test
-    public void onPause_shouldStopRunnables() throws Exception {
-        initializeSubject();
-
-        subject.onResume();
-        verify(spyCountdownRunnable).startRepeating(anyLong());
-        verify(spyProgressRunnable).startRepeating(anyLong());
-
-        subject.onPause();
-        verify(spyCountdownRunnable).stop();
-        verify(spyProgressRunnable).stop();
-    }
-
-    @Test
-    public void onPause_shouldFirePauseTrackers() throws Exception {
-        initializeSubject();
-
-        subject.onPause();
-        verify(mockRequestQueue).add(
-                argThat(isUrl("pause?errorcode=&asseturi=video_url&contentplayhead=00:00:00.000")));
-    }
-
-    @Test
-    public void onPause_withIsClosingFlagSet_shouldNotFirePauseTrackers() throws Exception {
-        initializeSubject();
-        subject.setIsClosing(true);
-
-        subject.onPause();
-        verifyNoMoreInteractions(mockRequestQueue);
-    }
-
-    @Test
-    public void onResume_shouldStartRunnables() throws Exception {
-        initializeSubject();
-
-        subject.onPause();
-        verify(spyCountdownRunnable).stop();
-        verify(spyProgressRunnable).stop();
-
-        subject.onResume();
-        verify(spyCountdownRunnable).startRepeating(anyLong());
-        verify(spyProgressRunnable).startRepeating(anyLong());
-    }
-
-    @Test
-    public void onResume_shouldSetVideoViewStateToStarted() throws Exception {
-        initializeSubject();
-
-        subject.onResume();
-
-        assertThat(getShadowVideoView().getCurrentVideoState()).isEqualTo(ShadowVideoView.START);
-        assertThat(getShadowVideoView().getPrevVideoState()).isNotEqualTo(ShadowVideoView.START);
-    }
-
-    @Test
-    public void onResume_shouldSeekToPrePausedPosition() throws Exception {
-        initializeSubject();
-        spyOnVideoView();
-        setVideoViewParams(7000, 10000);
-
-        subject.onPause();
-
-        setVideoViewParams(1000, 10000);
-
-        subject.onResume();
-        verify(spyVideoView).seekTo(eq(7000));
-    }
-
-    @Test
-    public void onResume_multipleTimes_shouldFirePauseResumeTrackersMultipleTimes() throws Exception {
-        initializeSubject();
-        spyOnVideoView();
-
-        setVideoViewParams(7000, 10000);
-        subject.onPause();
-
-        setVideoViewParams(1000, 10000);
-        subject.onResume();
-
-        verify(mockRequestQueue).add(argThat(isUrl
-                ("pause?errorcode=&asseturi=video_url&contentplayhead=00:00:07.000")));
-        verify(mockRequestQueue).add(
-                argThat(isUrl("resume?errorcode=&asseturi=video_url&contentplayhead=00:00:07.000")));
-
-        subject.onPause();
-        subject.onResume();
-
-        verify(mockRequestQueue).add(
-                argThat(isUrl("pause?errorcode=&asseturi=video_url&contentplayhead=00:00:07.000")));
-        verify(mockRequestQueue).add(
-                argThat(isUrl("resume?errorcode=&asseturi=video_url&contentplayhead=00:00:07.000")));
-    }
-
-    @Test
-    public void onConfigurationChanged_withPortraitCompanionAdVisible_withDeviceLandscape_shouldMakeLandscapeCompanionAdVisible() throws Exception {
-        initializeSubject();
-        context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_LANDSCAPE;
-        subject.getPortraitCompanionAdView().setVisibility(View.VISIBLE);
-
-        subject.onConfigurationChanged(null);
-
-        assertThat(subject.getPortraitCompanionAdView().getVisibility()).isEqualTo(View.INVISIBLE);
-        assertThat(subject.getLandscapeCompanionAdView().getVisibility()).isEqualTo(View.VISIBLE);
-        verify(mockRequestQueue).add(argThat(isUrl(COMPANION_CREATIVE_VIEW_URL_1)));
-        verify(mockRequestQueue).add(argThat(isUrl(COMPANION_CREATIVE_VIEW_URL_2)));
-        verifyNoMoreInteractions(mockRequestQueue);
-    }
-
-    @Test
-    public void onConfigurationChanged_withLandscapeCompanionAdVisible_withDevicePortrait_shouldMakePortraitCompanionAdVisible() throws Exception {
-        initializeSubject();
-        context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_PORTRAIT;
-        subject.getLandscapeCompanionAdView().setVisibility(View.VISIBLE);
-
-        subject.onConfigurationChanged(null);
-
-        assertThat(subject.getLandscapeCompanionAdView().getVisibility()).isEqualTo(View.INVISIBLE);
-        assertThat(subject.getPortraitCompanionAdView().getVisibility()).isEqualTo(View.VISIBLE);
-        verify(mockRequestQueue).add(argThat(isUrl(COMPANION_CREATIVE_VIEW_URL_3)));
-        verifyNoMoreInteractions(mockRequestQueue);
-    }
-
-    @Test
-    public void onConfigurationChanged_withPortraitCompanionAdVisible_withDevicePortrait_shouldKeepPortraitCompanionAdVisible() throws Exception {
-        initializeSubject();
-        context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_PORTRAIT;
-        subject.getPortraitCompanionAdView().setVisibility(View.VISIBLE);
-
-        subject.onConfigurationChanged(null);
-
-        assertThat(subject.getPortraitCompanionAdView().getVisibility()).isEqualTo(View.VISIBLE);
-        assertThat(subject.getLandscapeCompanionAdView().getVisibility()).isEqualTo(View.INVISIBLE);
-        verify(mockRequestQueue).add(argThat(isUrl(COMPANION_CREATIVE_VIEW_URL_3)));
-        verifyNoMoreInteractions(mockRequestQueue);
-    }
-
-    @Test
-    public void onConfigurationChanged_withNoCompanionAdVisible_shouldDoNothing() throws Exception {
-        initializeSubject();
-        context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_LANDSCAPE;
-
-        subject.onConfigurationChanged(null);
-
-        assertThat(subject.getPortraitCompanionAdView().getVisibility()).isEqualTo(View.INVISIBLE);
-        assertThat(subject.getLandscapeCompanionAdView().getVisibility()).isEqualTo(View.INVISIBLE);
-        verifyNoMoreInteractions(mockRequestQueue);
-    }
-
-    @Test
-    public void onConfigurationChanged_whenCalledMultipleTimes_shouldOnlyEverFireEachCreativeViewTrackerOnce() throws Exception {
-        initializeSubject();
-        subject.getPortraitCompanionAdView().setVisibility(View.VISIBLE);
-
-        for(int i = 0; i < 10; i++) {
-            context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_LANDSCAPE;
-            subject.onConfigurationChanged(null);
-            context.getResources().getConfiguration().orientation = Configuration.ORIENTATION_PORTRAIT;
-            subject.onConfigurationChanged(null);
-        }
-        verify(mockRequestQueue).add(argThat(isUrl(COMPANION_CREATIVE_VIEW_URL_1)));
-        verify(mockRequestQueue).add(argThat(isUrl(COMPANION_CREATIVE_VIEW_URL_2)));
-        verify(mockRequestQueue).add(argThat(isUrl(COMPANION_CREATIVE_VIEW_URL_3)));
-        verifyNoMoreInteractions(mockRequestQueue);
-    }
-
-    @Test
-    public void onConfigurationChanged_withNoCompanionAd_shouldDoNothing() throws Exception {
-        VastVideoConfig vastVideoConfig = new VastVideoConfig();
-        vastVideoConfig.setDiskMediaFileUrl("disk_video_path");
-        vastVideoConfig.setNetworkMediaFileUrl("media_url");
-        bundle.putSerializable(VAST_VIDEO_CONFIG, vastVideoConfig);
-        initializeSubject();
-
-        subject.onConfigurationChanged(null);
-
-        verifyNoMoreInteractions(mockRequestQueue);
-        assertThat(subject.getLandscapeCompanionAdView().getVisibility()).isEqualTo(View.INVISIBLE);
-        assertThat(subject.getLandscapeCompanionAdView().getWidth()).isEqualTo(0);
-        assertThat(subject.getLandscapeCompanionAdView().getHeight()).isEqualTo(0);
-        assertThat(subject.getPortraitCompanionAdView().getVisibility()).isEqualTo(View.INVISIBLE);
-        assertThat(subject.getPortraitCompanionAdView().getWidth()).isEqualTo(0);
-        assertThat(subject.getPortraitCompanionAdView().getHeight()).isEqualTo(0);
-    }
-
-    @Test
-    public void backButtonEnabled_shouldDefaultToFalse() throws Exception {
-        initializeSubject();
-
-        assertThat(subject.backButtonEnabled()).isFalse();
-    }
-
-    @Test
-    public void backButtonEnabled_whenCloseButtonIsVisible_shouldReturnTrue() throws Exception {
-        initializeSubject();
-
-        subject.setCloseButtonVisible(true);
-
-        assertThat(subject.backButtonEnabled()).isTrue();
-    }
-
-    @Test
-    public void onClickCloseButtonImageView_whenCloseButtonIsVisible_shouldFireCloseTrackers() throws Exception {
-        initializeSubject();
-        spyOnVideoView();
-        // Because it's almost never exactly 15 seconds
-        when(spyVideoView.getDuration()).thenReturn(15094);
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
-
-        subject.setCloseButtonVisible(true);
-
-        // We don't have direct access to the CloseButtonWidget icon's close event, so we manually
-        // invoke its onTouchListener's onTouch callback with a fake MotionEvent.ACTION_UP action.
-        View.OnTouchListener closeButtonImageViewOnTouchListener =
-                Shadows.shadowOf(subject.getCloseButtonWidget().getImageView()).getOnTouchListener();
-        closeButtonImageViewOnTouchListener.onTouch(null, GestureUtils.createActionUp(0, 0));
-
-        verify(mockRequestQueue).add(
-                argThat(isUrl("close?errorcode=&asseturi=video_url&contentplayhead=00:00:15.094")));
-        verify(mockRequestQueue).add(
-                argThat(isUrl("skip?errorcode=&asseturi=video_url&contentplayhead=00:00:15.094")));
-    }
-
-    @Test
-    public void onClickCloseButtonTextView_whenCloseButtonIsVisible_shouldFireCloseTrackers() throws Exception {
-        initializeSubject();
-        spyOnVideoView();
-        // Because it's almost never exactly 15 seconds
-        when(spyVideoView.getDuration()).thenReturn(15203);
-        getShadowVideoView().getOnPreparedListener().onPrepared(null);
-        getShadowVideoView().getOnCompletionListener().onCompletion(null);
-
-        subject.setCloseButtonVisible(true);
-
-        // We don't have direct access to the CloseButtonWidget text's close event, so we manually
-        // invoke its onTouchListener's onTouch callback with a fake MotionEvent.ACTION_UP action.
-        View.OnTouchListener closeButtonTextViewOnTouchListener =
-                Shadows.shadowOf(subject.getCloseButtonWidget().getTextView()).getOnTouchListener();
-        closeButtonTextViewOnTouchListener.onTouch(null, GestureUtils.createActionUp(0, 0));
-
-        verify(mockRequestQueue).add(
-                argThat(isUrl("close?errorcode=&asseturi=video_url&contentplayhead=00:00:15.203")));
-        verify(mockRequestQueue).add(
-                argThat(isUrl("skip?errorcode=&asseturi=video_url&contentplayhead=00:00:15.203")));
-    }
-
-    @Test
-    public void createIconView_shouldLayoutAndReturnInvisibleVastIconView() throws Exception {
-        initializeSubject();
-
-        VastIconConfig vastIconConfig = mock(VastIconConfig.class);
-        when(vastIconConfig.getWidth()).thenReturn(40);
-        when(vastIconConfig.getHeight()).thenReturn(40);
-        VastResource vastResource = mock(VastResource.class);
-        when(vastResource.getType()).thenReturn(VastResource.Type.STATIC_RESOURCE);
-        when(vastResource.getResource()).thenReturn("static");
-        when(vastIconConfig.getVastResource()).thenReturn(vastResource);
-
-        VastWebView view = (VastWebView) subject.createIconView(context, vastIconConfig, View.INVISIBLE);
-
-        assertThat(view).isNotNull();
-        assertThat(view.getVisibility()).isEqualTo(View.INVISIBLE);
-        assertThat(view.getVastWebViewClickListener()).isNotNull();
-        assertThat(subject.getLayout().findViewById(view.getId())).isEqualTo(view);
-    }
-
-    @Test
-    public void createIconView_withNullVastIcon_shouldReturnEmptyView() throws Exception {
-        initializeSubject();
-
-        assertThat(subject.createIconView(context, null, View.INVISIBLE)).isNotNull();
-    }
-
-    @Test
-    public void VastWebView_onVastWebViewClick_shouldCallVastIconHandleClick() throws Exception {
-        initializeSubject();
-
-        VastIconConfig vastIconConfig = mock(VastIconConfig.class);
-        when(vastIconConfig.getWidth()).thenReturn(40);
-        when(vastIconConfig.getHeight()).thenReturn(40);
-        VastResource vastResource = mock(VastResource.class);
-        when(vastResource.getType()).thenReturn(VastResource.Type.STATIC_RESOURCE);
-        when(vastResource.getResource()).thenReturn("static");
-        when(vastIconConfig.getVastResource()).thenReturn(vastResource);
-
-        VastWebView view = (VastWebView) subject.createIconView(context, vastIconConfig, View.INVISIBLE);
-
-        view.getVastWebViewClickListener().onVastWebViewClick();
-        verify(vastIconConfig).handleClick(any(Context.class), anyString(), eq("dsp_creative_id"));
-    }
-
-    @Test
-    public void handleIconDisplay_withCurrentPositionGreaterThanOffset_shouldSetIconToVisible_shouldCallHandleImpression() throws Exception {
-        initializeSubject();
-
-        when(mMockVastIconConfig.getOffsetMS()).thenReturn(0);
-        when(mMockVastIconConfig.getDurationMS()).thenReturn(1);
-
-        subject.handleIconDisplay(0);
-
-        assertThat(subject.getIconView().getVisibility()).isEqualTo(View.VISIBLE);
-        verify(mMockVastIconConfig).handleImpression(any(Context.class), eq(0), eq("video_url"));
-    }
-
-    @Test
-    public void handleIconDisplay_withCurrentPositionLessThanOffset_shouldReturn() throws Exception {
-        initializeSubject();
-
-        when(mMockVastIconConfig.getOffsetMS()).thenReturn(1);
-
-        subject.handleIconDisplay(0);
-
-        assertThat(subject.getIconView().getVisibility()).isEqualTo(View.INVISIBLE);
-        verify(mMockVastIconConfig, never()).handleImpression(any(Context.class), eq(0),
-                eq("video_url"));
-    }
-
-    @Test
-    public void handleIconDisplay_withCurrentPositionGreaterThanOffsetPlusDuration_shouldSetIconToGone() throws Exception {
-        initializeSubject();
-
-        when(mMockVastIconConfig.getOffsetMS()).thenReturn(0);
-        when(mMockVastIconConfig.getDurationMS()).thenReturn(1);
-
-        subject.handleIconDisplay(2);
-
-        assertThat(subject.getIconView().getVisibility()).isEqualTo(View.GONE);
-    }
-
-    @Test
-    public void makeInteractable_shouldHideCountdownWidgetAndShowCtaAndCloseButtonWidgetsAndShowSocialActions() throws Exception {
-        initializeSubject();
-
-        subject.makeVideoInteractable();
-
-        assertThat(subject.getRadialCountdownWidget().getVisibility()).isEqualTo(View.GONE);
-        assertThat(subject.getCloseButtonWidget().getVisibility()).isEqualTo(View.VISIBLE);
-        assertThat(subject.getSocialActionsView().getVisibility()).isEqualTo(View.VISIBLE);
-    }
-
-    private void initializeSubject() throws IllegalAccessException {
-        subject = new VastVideoViewController((Activity) context, bundle, savedInstanceState,
-                testBroadcastIdentifier, baseVideoViewControllerListener);
-        subject.getVastVideoView().setMediaMetadataRetriever(mockMediaMetadataRetriever);
-        spyOnRunnables();
-    }
-
-    private void spyOnVideoView() throws IllegalAccessException {
-        spyVideoView = spy(subject.getVideoView());
-        ReflectionUtils.setVariableValueInObject(subject, "mVideoView", spyVideoView);
-    }
-
-    private void spyOnRunnables() throws IllegalAccessException {
-        final VastVideoViewProgressRunnable progressCheckerRunnable = (VastVideoViewProgressRunnable) ReflectionUtils.getValueIncludingSuperclasses("mProgressCheckerRunnable", subject);
-        spyProgressRunnable = spy(progressCheckerRunnable);
-
-        final VastVideoViewCountdownRunnable countdownRunnable = (VastVideoViewCountdownRunnable) ReflectionUtils.getValueIncludingSuperclasses("mCountdownRunnable", subject);
-        spyCountdownRunnable = spy(countdownRunnable);
-
-        ReflectionUtils.setVariableValueInObject(subject, "mProgressCheckerRunnable", spyProgressRunnable);
-        ReflectionUtils.setVariableValueInObject(subject, "mCountdownRunnable", spyCountdownRunnable);
-    }
-
-    private void setVideoViewParams(int currentPosition, int duration) throws IllegalAccessException {
-        when(spyVideoView.getCurrentPosition()).thenReturn(currentPosition);
-        when(spyVideoView.getDuration()).thenReturn(duration);
-    }
-
-    private ShadowVastVideoView getShadowVideoView() {
-        return (ShadowVastVideoView) ShadowExtractor.extract(subject.getVastVideoView());
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/mraid/MraidControllerTest.java b/mopub-sdk/src/test/java/com/mopub/mraid/MraidControllerTest.java
deleted file mode 100644
index 4d79a2e2..00000000
--- a/mopub-sdk/src/test/java/com/mopub/mraid/MraidControllerTest.java
+++ /dev/null
@@ -1,1046 +0,0 @@
-package com.mopub.mraid;
-
-import android.app.Activity;
-import android.content.ComponentName;
-import android.content.Intent;
-import android.content.pm.ActivityInfo;
-import android.content.pm.PackageManager;
-import android.content.pm.ResolveInfo;
-import android.net.Uri;
-import android.os.Build;
-import android.view.View;
-import android.widget.FrameLayout;
-
-import com.mopub.TestSdkHelper;
-import com.mopub.common.AdReport;
-import com.mopub.common.CloseableLayout.ClosePosition;
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.common.util.Utils;
-import com.mopub.mobileads.BaseVideoPlayerActivityTest;
-import com.mopub.mobileads.BuildConfig;
-import com.mopub.mobileads.MraidVideoPlayerActivity;
-import com.mopub.mraid.MraidBridge.MraidBridgeListener;
-import com.mopub.mraid.MraidBridge.MraidWebView;
-import com.mopub.mraid.MraidController.MraidListener;
-import com.mopub.mraid.MraidController.OrientationBroadcastReceiver;
-import com.mopub.mraid.MraidController.ScreenMetricsWaiter;
-import com.mopub.mraid.MraidController.ScreenMetricsWaiter.WaitRequest;
-import com.mopub.mraid.MraidController.UseCustomCloseListener;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Captor;
-import org.mockito.Mock;
-import org.mockito.Mockito;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.Robolectric;
-import org.robolectric.RuntimeEnvironment;
-import org.robolectric.annotation.Config;
-import org.robolectric.shadows.ShadowApplication;
-
-import java.net.URI;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.fest.assertions.api.Assertions.fail;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyBoolean;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-@RunWith(SdkTestRunner.class)
-@Config(constants = BuildConfig.class)
-public class MraidControllerTest {
-    private long broadcastIdentifier = 123;
-    @Mock private AdReport mockAdReport;
-    @Mock private MraidBridge mockBridge;
-    @Mock private MraidBridge mockTwoPartBridge;
-    @Mock private ScreenMetricsWaiter mockScreenMetricsWaiter;
-    @Mock private WaitRequest mockWaitRequest;
-    @Mock private MraidListener mockMraidListener;
-    @Mock private UseCustomCloseListener mockUseCustomCloseListener;
-    @Mock private OrientationBroadcastReceiver mockOrientationBroadcastReceiver;
-    @Captor private ArgumentCaptor<MraidBridgeListener> bridgeListenerCaptor;
-    @Captor private ArgumentCaptor<MraidBridgeListener> twoPartBridgeListenerCaptor;
-
-    private Activity activity;
-    private FrameLayout rootView;
-
-    private MraidController subject;
-
-    @Before
-    public void setUp() {
-        ShadowApplication.setDisplayMetricsDensity(1.0f);
-
-        activity = spy(Robolectric.buildActivity(Activity.class).create().get());
-        activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
-
-        rootView = new FrameLayout(activity);
-        when(mockBridge.isVisible()).thenReturn(true);
-
-        // By default, immediately fulfill a screen metrics wait request. Individual tests can
-        // reset this, if desired.
-        when(mockScreenMetricsWaiter.waitFor(Mockito.<View>anyVararg()))
-                .thenReturn(mockWaitRequest);
-        doAnswer(new Answer<Void>() {
-            @Override
-            public Void answer(final InvocationOnMock invocation) throws Throwable {
-                Runnable runnable = (Runnable) invocation.getArguments()[0];
-                runnable.run();
-                return null;
-            }
-        }).when(mockWaitRequest).start(any(Runnable.class));
-
-        subject = new MraidController(
-                activity, mockAdReport, PlacementType.INLINE,
-                mockBridge, mockTwoPartBridge, mockScreenMetricsWaiter);
-        subject.setMraidListener(mockMraidListener);
-        subject.setOrientationBroadcastReceiver(mockOrientationBroadcastReceiver);
-        subject.setRootView(rootView);
-        subject.loadContent("fake_html_data");
-
-        verify(mockBridge).setMraidBridgeListener(bridgeListenerCaptor.capture());
-        verify(mockTwoPartBridge).setMraidBridgeListener(twoPartBridgeListenerCaptor.capture());
-    }
-
-    @Test
-    public void constructor_shouldSetStateToLoading() {
-        ViewState state = subject.getViewState();
-
-        assertThat(state).isEqualTo(ViewState.LOADING);
-    }
-
-    @Test
-    public void bridgeOnReady_shouldSetStateToDefault_shouldCallListener() {
-        bridgeListenerCaptor.getValue().onPageLoaded();
-
-        ViewState state = subject.getViewState();
-
-        assertThat(state).isEqualTo(ViewState.DEFAULT);
-        verify(mockMraidListener).onLoaded(any(View.class));
-    }
-
-    @Test
-    public void handlePageLoad_shouldNotifyBridgeOfVisibilityPlacementScreenSizeAndSupports() {
-        when(mockBridge.isVisible()).thenReturn(true);
-
-        subject.handlePageLoad();
-
-        verify(mockBridge).notifyViewability(true);
-        verify(mockBridge).notifyPlacementType(PlacementType.INLINE);
-        verify(mockBridge).notifyScreenMetrics(any(MraidScreenMetrics.class));
-
-        // The actual values here are supplied by the Mraids class, which has separate tests.
-        verify(mockBridge).notifySupports(false, false, false, false, false);
-    }
-
-    @Test
-    public void handlePageLoad_shouldCancelLastRequest() {
-        subject.handlePageLoad();
-
-        verify(mockScreenMetricsWaiter).cancelLastRequest();
-    }
-
-    @Test
-    public void handlePageLoad_thenDestroy_shouldCancelLastRequest() {
-        subject.handlePageLoad();
-        subject.destroy();
-
-        verify(mockScreenMetricsWaiter, times(2)).cancelLastRequest();
-    }
-
-    @Test
-    public void onPageFailedToLoad_shouldNotifyListener() {
-        bridgeListenerCaptor.getValue().onPageFailedToLoad();
-
-        verify(mockMraidListener).onFailedToLoad();
-    }
-
-    @Test
-    public void onPageFailedToLoad_withTwoPartBridge_shouldNotNotifyListener() {
-        twoPartBridgeListenerCaptor.getValue().onPageFailedToLoad();
-
-        verify(mockMraidListener, never()).onFailedToLoad();
-    }
-
-    @Test
-    public void bridgeOnVisibilityChanged_withTwoPartBridgeAttached_shouldNotNotifyVisibility() {
-        when(mockTwoPartBridge.isAttached()).thenReturn(true);
-
-        bridgeListenerCaptor.getValue().onVisibilityChanged(true);
-        bridgeListenerCaptor.getValue().onVisibilityChanged(false);
-
-        verify(mockBridge, never()).notifyViewability(anyBoolean());
-        verify(mockTwoPartBridge, never()).notifyViewability(anyBoolean());
-    }
-
-    @Test
-    public void handleResize_shouldBeIgnoredWhenLoadingOrHidden() throws MraidCommandException {
-        subject.setViewStateForTesting(ViewState.LOADING);
-        subject.handleResize(100, 200, 0, 0, ClosePosition.TOP_RIGHT, true);
-        assertThat(subject.getViewState()).isEqualTo(ViewState.LOADING);
-
-        subject.setViewStateForTesting(ViewState.HIDDEN);
-        subject.handleResize(100, 200, 0, 0, ClosePosition.TOP_RIGHT, true);
-        assertThat(subject.getViewState()).isEqualTo(ViewState.HIDDEN);
-    }
-
-    @Test(expected = MraidCommandException.class)
-    public void handleResize_shouldThrowExceptionWhenExpanded() throws MraidCommandException {
-        subject.setViewStateForTesting(ViewState.EXPANDED);
-        subject.handleResize(100, 200, 0, 0, ClosePosition.TOP_RIGHT, true);
-    }
-
-    @Test(expected = MraidCommandException.class)
-    public void handleResize_shouldThrowExceptionForInterstitial() throws MraidCommandException {
-        MraidListener listener = mock(MraidListener.class);
-        subject = new MraidController(activity, mockAdReport, PlacementType.INTERSTITIAL,
-                mockBridge, mockTwoPartBridge, mockScreenMetricsWaiter);
-        subject.setMraidListener(listener);
-        subject.setRootView(rootView);
-
-        // Move to DEFAULT state
-        subject.loadContent("fake_html_data");
-        subject.handlePageLoad();
-
-        subject.handleResize(100, 200, 0, 0, ClosePosition.TOP_RIGHT, true);
-    }
-
-    @Test
-    public void handleResize_shouldMoveWebViewToResizedContainer_shouldSetResizedState()
-            throws MraidCommandException {
-        // Move to DEFAULT state
-        subject.handlePageLoad();
-        subject.setRootViewSize(100, 100);
-
-        subject.handleResize(100, 100, 0, 0, ClosePosition.TOP_RIGHT, true);
-        assertThat(subject.getExpandedAdContainer().getChildCount()).isEqualTo(2);
-        assertThat(subject.getAdContainer().getChildCount()).isEqualTo(0);
-        assertThat(subject.getViewState()).isEqualTo(ViewState.RESIZED);
-    }
-
-    @Test
-    public void handleResize_noAllowOffscreen_smallView_shouldResize()
-            throws MraidCommandException {
-        // Move to DEFAULT state
-        subject.handlePageLoad();
-        subject.setRootViewSize(100, 100);
-
-        subject.handleResize(50, 50, 0, 0, ClosePosition.TOP_RIGHT, /* allowOffscreen */ false);
-        assertThat(subject.getViewState()).isEqualTo(ViewState.RESIZED);
-    }
-
-    @Test(expected = MraidCommandException.class)
-    public void handleResize_noAllowOffscreen_largeView_shouldThrowException()
-            throws MraidCommandException {
-        // Move to DEFAULT state
-        subject.handlePageLoad();
-        subject.setRootViewSize(100, 100);
-
-        subject.handleResize(101, 101, 0, 0, ClosePosition.TOP_RIGHT, /* allowOffscreen */ false);
-    }
-
-    @Test(expected = MraidCommandException.class)
-    public void handleResize_allowOffscreen_largeView_closeButtonTopRight_shouldThrowException()
-            throws MraidCommandException {
-        // Move to DEFAULT state
-        subject.handlePageLoad();
-        subject.setRootViewSize(100, 100);
-
-        subject.handleResize(150, 150, 0, 0, ClosePosition.TOP_RIGHT, /* allowOffscreen */ true);
-    }
-
-    @Test
-    public void handleResize_allowOffscreen_closeButtonTopLeft_shouldNotThrowException()
-            throws MraidCommandException {
-        // Move to DEFAULT state
-        subject.handlePageLoad();
-        subject.setRootViewSize(100, 100);
-
-        subject.handleResize(150, 150, 0, 0, ClosePosition.TOP_LEFT, /* allowOffscreen */ true);
-        assertThat(subject.getViewState()).isEqualTo(ViewState.RESIZED);
-    }
-
-    @Test(expected = MraidCommandException.class)
-    public void handleResize_allowOffscreen_largeOffset_closeButtonBottomRight_shouldThrowException()
-            throws MraidCommandException {
-        // Move to DEFAULT state
-        subject.handlePageLoad();
-        subject.setRootViewSize(100, 1000);
-
-        // Throws an exception because the close button overlaps the edge
-        subject.handleResize(100, 100, 25, 25, ClosePosition.BOTTOM_RIGHT, /* allowOffscreen */
-                true);
-    }
-
-    @Test
-    public void handleResize_allowOffscreen_largeOffset_closeButtonBottomLeft_shouldNotThrowException()
-            throws MraidCommandException {
-        // Move to DEFAULT state
-        subject.handlePageLoad();
-        subject.setRootViewSize(100, 1000);
-
-        subject.handleResize(100, 100, 25, 25, ClosePosition.BOTTOM_LEFT, /* allowOffscreen */
-                true);
-        assertThat(subject.getViewState()).isEqualTo(ViewState.RESIZED);
-    }
-
-    @Test(expected = MraidCommandException.class)
-    public void handleResize_heightSmallerThan50Dips_shouldFail() throws MraidCommandException {
-        subject.handlePageLoad();
-        subject.setRootViewSize(100, 100);
-        subject.handleResize(100, 49, 25, 25, ClosePosition.BOTTOM_LEFT, /* allowOffscreen */
-                false);
-    }
-
-    @Test(expected = MraidCommandException.class)
-    public void handleResize_widthSmallerThan50Dips_shouldFail() throws MraidCommandException {
-        subject.handlePageLoad();
-        subject.setRootViewSize(100, 100);
-        subject.handleResize(49, 100, 25, 25, ClosePosition.BOTTOM_LEFT, /* allowOffscreen */
-                false);
-    }
-
-    @Test
-    public void handleClose_fromResizedState_shouldMoveWebViewToOriginalContainer_shouldNotFireOnClose()
-            throws MraidCommandException {
-        // Move to RESIZED state
-        subject.handlePageLoad();
-        subject.setRootViewSize(100, 100);
-        subject.handleResize(100, 100, 0, 0, ClosePosition.TOP_RIGHT, false);
-
-        subject.handleClose();
-
-        assertThat(subject.getExpandedAdContainer().getChildCount()).isEqualTo(1);
-        assertThat(subject.getAdContainer().getChildCount()).isEqualTo(1);
-        assertThat(subject.getViewState()).isEqualTo(ViewState.DEFAULT);
-        verify(mockMraidListener, never()).onClose();
-    }
-
-    @Test(expected = MraidCommandException.class)
-    public void handleExpand_afterDestroy_shouldThrowException() throws MraidCommandException {
-        subject.destroy();
-        subject.handleExpand(null, false);
-    }
-
-    @Test
-    public void handleExpand_shouldBeIgnoredForInterstitial() throws MraidCommandException {
-        MraidListener listener = mock(MraidListener.class);
-        subject = new MraidController(activity, mockAdReport, PlacementType.INTERSTITIAL,
-                mockBridge, mockTwoPartBridge, mockScreenMetricsWaiter);
-        subject.setMraidListener(listener);
-        subject.setRootView(rootView);
-
-        // Move to DEFAULT state
-        subject.loadContent("fake_html_data");
-        subject.handlePageLoad();
-
-        subject.handleExpand(null, false);
-
-        assertThat(subject.getViewState()).isEqualTo(ViewState.DEFAULT);
-        verify(listener, never()).onExpand();
-    }
-
-    @Test
-    public void handleExpand_shouldBeIgnoredWhenLoadingHiddenOrExpanded()
-            throws MraidCommandException {
-        subject.setViewStateForTesting(ViewState.LOADING);
-        subject.handleExpand(null, false);
-        assertThat(subject.getViewState()).isEqualTo(ViewState.LOADING);
-        verify(mockMraidListener, never()).onExpand();
-
-        subject.setViewStateForTesting(ViewState.HIDDEN);
-        subject.handleExpand(null, false);
-        assertThat(subject.getViewState()).isEqualTo(ViewState.HIDDEN);
-        verify(mockMraidListener, never()).onExpand();
-
-        subject.setViewStateForTesting(ViewState.EXPANDED);
-        subject.handleExpand(null, false);
-        assertThat(subject.getViewState()).isEqualTo(ViewState.EXPANDED);
-        verify(mockMraidListener, never()).onExpand();
-    }
-
-    @Test
-    public void handleExpand_withNoUrl_shouldMoveWebViewToExpandedContainer_shouldCallOnExpand()
-            throws MraidCommandException {
-        // Move to DEFAULT state
-        subject.handlePageLoad();
-
-        subject.handleExpand(null, false);
-
-        assertThat(subject.getExpandedAdContainer().getChildCount()).isEqualTo(2);
-        assertThat(subject.getAdContainer().getChildCount()).isEqualTo(0);
-        verify(mockMraidListener).onExpand();
-    }
-
-    @Test
-    public void handleExpand_withTwoPartUrl_shouldAttachTwoPartBridge_shouldCallOnExpand()
-            throws MraidCommandException {
-        // Move to DEFAULT state
-        subject.handlePageLoad();
-
-        subject.handleExpand(URI.create("https://two-part-url"), false);
-
-        verify(mockTwoPartBridge).setMraidBridgeListener(any(MraidBridgeListener.class));
-        verify(mockTwoPartBridge).attachView(any(MraidWebView.class));
-        verify(mockTwoPartBridge).setContentUrl(URI.create("https://two-part-url").toString());
-
-        assertThat(subject.getExpandedAdContainer().getChildCount()).isEqualTo(2);
-        assertThat(subject.getAdContainer().getChildCount()).isEqualTo(1);
-        verify(mockMraidListener).onExpand();
-        assertThat(subject.getViewState()).isEqualTo(ViewState.EXPANDED);
-    }
-
-    @Test
-    public void handleClose_afterDestroy_shouldNotFireOnClose() {
-        subject.destroy();
-        subject.handleClose();
-
-        verify(mockMraidListener, never()).onClose();
-    }
-
-    @Test
-    public void handleClose_fromExpandedState_shouldMoveWebViewToOriginalContainer_shouldFireOnClose() throws MraidCommandException {
-        // Move to EXPANDED state
-        subject.handlePageLoad();
-        subject.handleExpand(null, false);
-
-        subject.handleClose();
-
-        assertThat(subject.getExpandedAdContainer().getChildCount()).isEqualTo(1);
-        assertThat(subject.getAdContainer().getChildCount()).isEqualTo(1);
-        assertThat(subject.getViewState()).isEqualTo(ViewState.DEFAULT);
-        verify(mockMraidListener).onClose();
-    }
-
-    @Test
-    public void handleClose_fromTwoPartExpandedState_shouldDetachTwoPartBridge_shouldMoveWebViewToOriginalContainer_shouldFireOnClose()
-            throws MraidCommandException {
-        URI uri = URI.create("https://two-part-url");
-
-        // Move to two part EXPANDED state
-        subject.handlePageLoad();
-        subject.handleExpand(uri, false);
-        when(mockTwoPartBridge.isAttached()).thenReturn(true);
-
-        subject.handleClose();
-
-        verify(mockTwoPartBridge).detach();
-        assertThat(subject.getExpandedAdContainer().getChildCount()).isEqualTo(1);
-        assertThat(subject.getAdContainer().getChildCount()).isEqualTo(1);
-        assertThat(subject.getViewState()).isEqualTo(ViewState.DEFAULT);
-
-        verify(mockMraidListener).onClose();
-    }
-
-    @Test
-    public void handleClose_fromDefaultState_shouldHideAdContainer_shouldCallOnClose() {
-        // Move to DEFAULT state
-        subject.handlePageLoad();
-        assertThat(subject.getViewState()).isEqualTo(ViewState.DEFAULT);
-
-        subject.handleClose();
-
-        assertThat(subject.getAdContainer().getVisibility()).isEqualTo(View.INVISIBLE);
-        assertThat(subject.getViewState()).isEqualTo(ViewState.HIDDEN);
-
-        verify(mockMraidListener).onClose();
-    }
-
-    @Test
-    public void handleShowVideo_shouldStartVideoPlayerActivity() {
-        subject.handleShowVideo("https://video");
-        BaseVideoPlayerActivityTest.assertMraidVideoPlayerActivityStarted(
-                MraidVideoPlayerActivity.class, "https://video");
-    }
-
-    @Test
-    public void handleCustomClose_shouldUpdateExpandedContainer() {
-        subject.handleCustomClose(true);
-        assertThat(subject.getExpandedAdContainer().isCloseVisible()).isFalse();
-
-        subject.handleCustomClose(false);
-        assertThat(subject.getExpandedAdContainer().isCloseVisible()).isTrue();
-    }
-
-    @Test
-    public void handleCustomClose_shouldCallCustomCloseChangedListener() {
-        subject.setUseCustomCloseListener(mockUseCustomCloseListener);
-
-        subject.handleCustomClose(true);
-        verify(mockUseCustomCloseListener).useCustomCloseChanged(true);
-
-        reset(mockUseCustomCloseListener);
-        subject.handleCustomClose(false);
-        verify(mockUseCustomCloseListener).useCustomCloseChanged(false);
-    }
-
-    @Test
-    public void handleOpen_withMoPubNativeBrowserUrl_shouldOpenExternalBrowser() {
-        subject.handleOpen("mopubnativebrowser://navigate?url=https%3A%2F%2Fwww.example.com");
-
-        Intent intent = ShadowApplication.getInstance().getNextStartedActivity();
-        assertThat(intent.getDataString()).isEqualTo("https://www.example.com");
-        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
-    }
-
-    @Test
-    public void handleOpen_withMalformedMoPubNativeBrowserUrl_shouldNotStartNewActivity() {
-        // invalid host parameter 'nav'
-        subject.handleOpen("mopubnativebrowser://nav?url=https%3A%2F%2Fwww.example.com");
-
-        assertThat(ShadowApplication.getInstance().getNextStartedActivity()).isNull();
-    }
-
-    @Test
-    public void handleOpen_withApplicationUrl_shouldStartNewIntent() {
-        String applicationUrl = "amzn://blah";
-        RuntimeEnvironment.getRobolectricPackageManager().addResolveInfoForIntent(new Intent(Intent.ACTION_VIEW, Uri
-                .parse(applicationUrl)), new ResolveInfo());
-
-        subject.handleOpen(applicationUrl);
-
-        Intent startedIntent = ShadowApplication.getInstance().getNextStartedActivity();
-        assertThat(startedIntent).isNotNull();
-        // Since we are not using an Activity context, we should have FLAG_ACTIVITY_NEW_TASK
-        assertThat(Utils.bitMaskContainsFlag(startedIntent.getFlags(),
-                Intent.FLAG_ACTIVITY_NEW_TASK)).isTrue();
-        assertThat(startedIntent.getComponent()).isNull();
-
-        verify(mockMraidListener).onOpen();
-    }
-
-    @Test
-    public void handleOpen_withHttpApplicationUrl_shouldStartMoPubBrowser() {
-        String applicationUrl = "https://www.mopub.com/";
-
-        subject.handleOpen(applicationUrl);
-
-        Robolectric.getBackgroundThreadScheduler().advanceBy(0);
-        Intent startedIntent = ShadowApplication.getInstance().getNextStartedActivity();
-        assertThat(startedIntent).isNotNull();
-        // Since we are not using an Activity context, we should have FLAG_ACTIVITY_NEW_TASK
-        assertThat(Utils.bitMaskContainsFlag(startedIntent.getFlags(),
-                Intent.FLAG_ACTIVITY_NEW_TASK)).isTrue();
-        assertThat(startedIntent.getComponent().getClassName())
-                .isEqualTo("com.mopub.common.MoPubBrowser");
-
-        verify(mockMraidListener).onOpen();
-    }
-
-    @Test
-    public void handleOpen_withApplicationUrlThatCantBeHandled_shouldDefaultToMoPubBrowser()
-            throws Exception {
-        String applicationUrl = "canthandleme://blah";
-
-        subject.handleOpen(applicationUrl);
-
-        Intent startedIntent = ShadowApplication.getInstance().getNextStartedActivity();
-        assertThat(startedIntent).isNull();
-
-        verify(mockMraidListener).onOpen();
-    }
-
-    @Test
-    public void handleOpen_withAboutBlankUrl_shouldFailSilently() {
-        final String url = "about:blank";
-
-        subject.handleOpen(url);
-
-        assertThat(ShadowApplication.getInstance().getNextStartedActivity()).isNull();
-    }
-
-    @Test
-    public void orientationBroadcastReceiver_whenUnregistered_shouldIgnoreOnReceive() {
-        Intent intent = mock(Intent.class);
-        when(intent.getAction()).thenReturn("some bogus action which we hope never to see");
-
-        MraidController.OrientationBroadcastReceiver receiver =
-                subject.new OrientationBroadcastReceiver();
-        receiver.register(activity);
-        receiver.unregister();
-        receiver.onReceive(activity, intent);
-
-        verify(intent, never()).getAction();
-    }
-
-    @Test
-    public void orientationProperties_shouldDefaultToAllowChangeTrueAndForceOrientationNone() {
-        // These are the default values provided by the MRAID spec
-        assertThat(subject.getAllowOrientationChange()).isTrue();
-        assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.NONE);
-    }
-
-    @Test
-    public void handleSetOrientationProperties_withForcedOrientation_shouldUpdateProperties() throws MraidCommandException, PackageManager.NameNotFoundException {
-        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
-                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
-
-        subject.handleSetOrientationProperties(false, MraidOrientation.LANDSCAPE);
-
-        assertThat(subject.getAllowOrientationChange()).isFalse();
-        assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.LANDSCAPE);
-    }
-
-    @Test
-    public void handleSetOrientationProperties_withOrientationNone_withApplicationContext_shouldUpdateProperties() throws MraidCommandException, PackageManager.NameNotFoundException {
-        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
-                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
-
-        subject = new MraidController(
-                activity.getApplicationContext(), mockAdReport, PlacementType.INLINE,
-                mockBridge, mockTwoPartBridge, mockScreenMetricsWaiter);
-
-        subject.handleSetOrientationProperties(false, MraidOrientation.NONE);
-
-        assertThat(subject.getAllowOrientationChange()).isFalse();
-        assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.NONE);
-    }
-
-    @Test
-    public void handleSetOrientationProperties_withForcedOrientation_withApplicationContext_shouldThrowMraidCommandExceptionAndNotUpdateProperties() throws PackageManager.NameNotFoundException {
-        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
-                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
-
-        subject = new MraidController(
-                activity.getApplicationContext(), mockAdReport, PlacementType.INLINE,
-                mockBridge, mockTwoPartBridge, mockScreenMetricsWaiter);
-
-        try {
-            subject.handleSetOrientationProperties(false, MraidOrientation.LANDSCAPE);
-            fail("Expected MraidCommandException");
-        } catch (MraidCommandException e) {
-            // pass
-        }
-
-        assertThat(subject.getAllowOrientationChange()).isTrue();
-        assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.NONE);
-    }
-
-    @Test
-    public void handleSetOrientationProperties_withActivityInfoNotFound_shouldThrowMraidCommandException() throws PackageManager.NameNotFoundException {
-        setMockActivityInfo(false, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
-                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
-
-        try {
-            subject.handleSetOrientationProperties(false, MraidOrientation.LANDSCAPE);
-            fail("Expected MraidCommandException");
-        } catch (MraidCommandException e) {
-            // pass
-        }
-
-        assertThat(subject.getAllowOrientationChange()).isTrue();
-        assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.NONE);
-    }
-
-    @Test
-    public void handleSetOrientationProperties_whenTryingToSetToOrientationDeclaredInManifest_shouldUpdateProperties() throws Exception {
-        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_PORTRAIT,
-                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
-
-        subject.handleSetOrientationProperties(true, MraidOrientation.PORTRAIT);
-
-        assertThat(subject.getAllowOrientationChange()).isTrue();
-        assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.PORTRAIT);
-    }
-
-    @Test
-    public void handleSetOrientationProperties_whenTryingToSetToOrientationDifferentFromManifest_shouldThrowMraidCommandException() throws Exception {
-        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_PORTRAIT,
-                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
-
-        try {
-            subject.handleSetOrientationProperties(true, MraidOrientation.LANDSCAPE);
-            fail("Expected MraidCommandException");
-        } catch (MraidCommandException e) {
-            // pass
-        }
-
-        assertThat(subject.getAllowOrientationChange()).isTrue();
-        assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.NONE);
-    }
-
-    @Test
-    public void handleSetOrientationProperties_withForcedOrientation_withMissingConfigChangeOrientation_shouldThrowMraidCommandException() throws Exception {
-        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
-                /* missing CONFIG_ORIENTATION */ ActivityInfo.CONFIG_SCREEN_SIZE);
-
-        try {
-            subject.handleSetOrientationProperties(true, MraidOrientation.PORTRAIT);
-            fail("Expected MraidCommandException");
-        } catch (MraidCommandException e) {
-            // pass
-        }
-
-        assertThat(subject.getAllowOrientationChange()).isTrue();
-        assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.NONE);
-    }
-
-    @Test
-    public void handleSetOrientationProperties_beforeHoneycombMr2_withMissingConfigChangeScreenSize_shouldUpdateProperties() throws Exception {
-        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
-                ActivityInfo.CONFIG_ORIENTATION);
-        TestSdkHelper.setReportedSdkLevel(Build.VERSION_CODES.HONEYCOMB_MR1);
-
-        subject.handleSetOrientationProperties(false, MraidOrientation.LANDSCAPE);
-
-        assertThat(subject.getAllowOrientationChange()).isFalse();
-        assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.LANDSCAPE);
-    }
-
-    @Test
-    public void handleSetOrientationProperties_atLeastHoneycombMr2_withMissingConfigChangeScreenSize_shouldThrowMraidCommandException() throws Exception {
-        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
-                ActivityInfo.CONFIG_ORIENTATION);
-        TestSdkHelper.setReportedSdkLevel(Build.VERSION_CODES.HONEYCOMB_MR2);
-
-        try {
-            subject.handleSetOrientationProperties(false, MraidOrientation.LANDSCAPE);
-            fail("Expected MraidCommandException");
-        } catch (MraidCommandException e) {
-            // pass
-        }
-
-        assertThat(subject.getAllowOrientationChange()).isTrue();
-        assertThat(subject.getForceOrientation()).isEqualTo(MraidOrientation.NONE);
-    }
-
-    @Test
-    public void handleSetOrientationProperties_forExpandedBanner_shouldImmediatelyChangeScreenOrientation() throws MraidCommandException, PackageManager.NameNotFoundException {
-        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
-                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
-
-        subject.handlePageLoad();
-        subject.handleExpand(null, false);
-
-        subject.handleSetOrientationProperties(true, MraidOrientation.LANDSCAPE);
-
-        assertThat(activity.getRequestedOrientation()).isEqualTo(ActivityInfo
-                .SCREEN_ORIENTATION_LANDSCAPE);
-    }
-
-    @Test
-    public void handleSetOrientationProperties_forExpandedBanner_beforeExpandIsCalled_shouldChangeScreenOrientationUponExpand() throws MraidCommandException, PackageManager.NameNotFoundException {
-        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
-                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
-
-        subject.handlePageLoad();
-        subject.handleSetOrientationProperties(true, MraidOrientation.LANDSCAPE);
-
-        assertThat(activity.getRequestedOrientation()).isEqualTo(ActivityInfo
-                .SCREEN_ORIENTATION_PORTRAIT);
-
-        subject.handleExpand(null, false);
-
-        assertThat(activity.getRequestedOrientation()).isEqualTo(ActivityInfo
-                .SCREEN_ORIENTATION_LANDSCAPE);
-    }
-
-    @Test
-    public void handleSetOrientationProperties_forDefaultBanner_shouldNotChangeScreenOrientation() throws MraidCommandException, PackageManager.NameNotFoundException {
-        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
-                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
-
-        subject.handlePageLoad();
-        // don't expand the banner
-
-        subject.handleSetOrientationProperties(true, MraidOrientation.LANDSCAPE);
-
-        assertThat(activity.getRequestedOrientation()).isEqualTo(ActivityInfo
-                .SCREEN_ORIENTATION_PORTRAIT);
-    }
-
-    @Test
-    public void handleSetOrientationProperties_forInterstitial_shouldChangeScreenOrientation() throws MraidCommandException, PackageManager.NameNotFoundException {
-        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
-                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
-
-        subject = new MraidController(
-                activity, mockAdReport, PlacementType.INTERSTITIAL,
-                mockBridge, mockTwoPartBridge, mockScreenMetricsWaiter);
-
-        assertThat(activity.getRequestedOrientation()).isEqualTo(ActivityInfo
-                .SCREEN_ORIENTATION_PORTRAIT);
-
-        subject.handlePageLoad();
-        subject.handleSetOrientationProperties(true, MraidOrientation.LANDSCAPE);
-
-        assertThat(activity.getRequestedOrientation()).isEqualTo(ActivityInfo
-                .SCREEN_ORIENTATION_LANDSCAPE);
-    }
-
-    @Test
-    public void shouldAllowForceOrientation_withNoneOrientation_shouldReturnTrue() throws PackageManager.NameNotFoundException {
-        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
-                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
-
-        final boolean result = subject.shouldAllowForceOrientation(MraidOrientation.NONE);
-
-        assertThat(result).isTrue();
-    }
-
-    @Test
-    public void shouldAllowForceOrientation_withApplicationContext_shouldReturnFalse() throws PackageManager.NameNotFoundException {
-        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
-                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
-
-        subject = new MraidController(
-                activity.getApplicationContext(), mockAdReport, PlacementType.INLINE,
-                mockBridge, mockTwoPartBridge, mockScreenMetricsWaiter);
-
-        final boolean result = subject.shouldAllowForceOrientation(MraidOrientation.PORTRAIT);
-
-        assertThat(result).isFalse();
-    }
-
-    @Test(expected = MraidCommandException.class)
-    public void lockOrientation_withApplicationContext_shouldThrowMraidCommandException() throws MraidCommandException, PackageManager.NameNotFoundException {
-        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
-                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
-
-        subject = new MraidController(
-                activity.getApplicationContext(), mockAdReport, PlacementType.INLINE,
-                mockBridge, mockTwoPartBridge, mockScreenMetricsWaiter);
-
-        subject.lockOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
-    }
-
-    @Test
-    public void lockOrientation_withActivityContext_shouldInitializeOriginalActivityOrientationAndCallActivitySetOrientation() throws MraidCommandException, PackageManager.NameNotFoundException {
-        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
-                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
-
-        assertThat(subject.getOriginalActivityOrientation()).isNull();
-        assertThat(activity.getRequestedOrientation())
-                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
-
-        subject.lockOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
-
-        assertThat(subject.getOriginalActivityOrientation())
-                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
-        assertThat(activity.getRequestedOrientation())
-                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
-    }
-
-    @Test
-    public void lockOrientation_subsequentTimes_shouldNotModifyOriginalActivityOrientation() throws MraidCommandException, PackageManager.NameNotFoundException {
-        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
-                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
-
-        subject.lockOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
-
-        assertThat(subject.getOriginalActivityOrientation())
-                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
-
-        subject.lockOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
-
-        assertThat(subject.getOriginalActivityOrientation())
-                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
-    }
-
-    @Test
-    public void applyOrientation_withLockedOrientation_withForceOrientationNone_withAllowOrientationChangeTrue_shouldResetOrientation() throws MraidCommandException, PackageManager.NameNotFoundException {
-        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
-                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
-
-        assertThat(activity.getRequestedOrientation())
-                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
-
-        subject.lockOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
-
-        assertThat(activity.getRequestedOrientation())
-                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
-
-        subject.handleSetOrientationProperties(true, MraidOrientation.NONE);
-        subject.applyOrientation();
-
-        assertThat(activity.getRequestedOrientation())
-                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
-    }
-
-    @Test
-    public void applyOrientation_withNoLockedOrientation_withForceOrientationNone_withAllowOrientationChangeTrue_shouldDoNothing() throws MraidCommandException, PackageManager.NameNotFoundException {
-        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
-                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
-
-        assertThat(activity.getRequestedOrientation())
-                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
-
-        subject.handleSetOrientationProperties(true, MraidOrientation.NONE);
-        subject.applyOrientation();
-
-        assertThat(activity.getRequestedOrientation())
-                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
-    }
-
-    @Test
-    public void applyOrientation_withForcedOrientationTrue_shouldSetRequestedOrientationToForcedOrienation() throws MraidCommandException, PackageManager.NameNotFoundException {
-        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
-                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
-
-        subject.handleSetOrientationProperties(true, MraidOrientation.LANDSCAPE);
-        subject.applyOrientation();
-
-        assertThat(activity.getRequestedOrientation())
-                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
-    }
-
-    @Test
-    public void applyOrientation_withForcedOrientationFalse_shouldSetRequestedOrientationToForcedOrienation() throws MraidCommandException, PackageManager.NameNotFoundException {
-        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
-                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
-
-        subject.handleSetOrientationProperties(false, MraidOrientation.LANDSCAPE);
-        subject.applyOrientation();
-
-        assertThat(activity.getRequestedOrientation())
-                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
-    }
-
-    @Test
-    public void unapplyOrientation_withALockedOrientation_shouldReturnToOriginalOrientationAndResetOriginalActivityOrientation() throws MraidCommandException, PackageManager.NameNotFoundException {
-        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
-                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
-
-        assertThat(subject.getOriginalActivityOrientation()).isNull();
-        assertThat(activity.getRequestedOrientation())
-                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
-
-        subject.lockOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
-
-        assertThat(subject.getOriginalActivityOrientation())
-                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
-        assertThat(activity.getRequestedOrientation())
-                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
-
-        subject.unApplyOrientation();
-
-        assertThat(subject.getOriginalActivityOrientation()).isNull();
-        assertThat(activity.getRequestedOrientation())
-                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
-    }
-
-    @Test
-    public void unapplyOrientation_withoutLockedOrientation_shouldNotChangeRequestedOrientation()
-            throws PackageManager.NameNotFoundException {
-        setMockActivityInfo(true, ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED,
-                ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_SCREEN_SIZE);
-
-        assertThat(subject.getOriginalActivityOrientation()).isNull();
-        assertThat(activity.getRequestedOrientation())
-                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
-
-        subject.unApplyOrientation();
-
-        assertThat(subject.getOriginalActivityOrientation()).isNull();
-        assertThat(activity.getRequestedOrientation())
-                .isEqualTo(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
-    }
-
-    @Test
-    public void destroy_shouldCancelLastMetricsRequest_shouldUnregisterBroadcastReceiver_shouldDetachAllBridges() {
-        subject.destroy();
-
-        verify(mockScreenMetricsWaiter).cancelLastRequest();
-        verify(mockOrientationBroadcastReceiver).unregister();
-        verify(mockBridge).detach();
-        verify(mockTwoPartBridge).detach();
-    }
-
-    @Test
-    public void destroy_withDefaultState_shouldSetMraidWebViewsToNull() {
-        subject.setViewStateForTesting(ViewState.DEFAULT);
-        assertThat(subject.getMraidWebView()).isNotNull();
-        // The two-part WebView is null by default
-        assertThat(subject.getTwoPartWebView()).isNull();
-
-        subject.destroy();
-
-        assertThat(subject.getMraidWebView()).isNull();
-        assertThat(subject.getTwoPartWebView()).isNull();
-    }
-
-    @Test
-    public void destroy_withExpandedState_shouldSetMraidWebViewsToNull()
-            throws MraidCommandException {
-        // Necessary to set up the webview before expanding. Also moves the state to DEFAULT.
-        subject.handlePageLoad();
-        assertThat(subject.getViewState()).isEqualTo(ViewState.DEFAULT);
-        subject.handleExpand(URI.create("https://two-part-url"), false);
-
-        assertThat(subject.getMraidWebView()).isNotNull();
-        assertThat(subject.getTwoPartWebView()).isNotNull();
-
-        subject.destroy();
-
-        assertThat(subject.getMraidWebView()).isNull();
-        assertThat(subject.getTwoPartWebView()).isNull();
-    }
-
-    @Test
-    public void destroy_afterDestroy_shouldNotThrowAnException() {
-        subject.destroy();
-        subject.destroy();
-
-        assertThat(subject.getMraidWebView()).isNull();
-        assertThat(subject.getTwoPartWebView()).isNull();
-    }
-
-    @Test
-    public void destroy_fromExpandedState_shouldRemoveCloseableAdContainerFromContentView()
-            throws MraidCommandException {
-        subject.handlePageLoad();
-        subject.handleExpand(null, false);
-
-        assertThat(rootView.getChildCount()).isEqualTo(1);
-
-        subject.destroy();
-
-        assertThat(rootView.getChildCount()).isEqualTo(0);
-    }
-
-    @Test
-    public void destroy_fromResizedState_shouldRemoveCloseableAdContainerFromContentView()
-            throws MraidCommandException {
-        subject.handlePageLoad();
-        subject.setRootViewSize(100, 100);
-        subject.handleResize(100, 100, 0, 0, ClosePosition.TOP_RIGHT, true);
-
-        assertThat(rootView.getChildCount()).isEqualTo(1);
-
-        subject.destroy();
-
-        assertThat(rootView.getChildCount()).isEqualTo(0);
-    }
-
-    private void setMockActivityInfo(final boolean activityInfoFound, int screenOrientation,
-            int configChanges) throws PackageManager.NameNotFoundException {
-        final ActivityInfo mockActivityInfo = mock(ActivityInfo.class);
-
-        mockActivityInfo.screenOrientation = screenOrientation;
-        mockActivityInfo.configChanges = configChanges;
-
-        final PackageManager mockPackageManager = mock(PackageManager.class);
-        doAnswer(new Answer() {
-            @Override
-            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
-                if (!activityInfoFound) {
-                    throw new PackageManager.NameNotFoundException("");
-                }
-
-                return mockActivityInfo;
-            }
-        }).when(mockPackageManager).getActivityInfo(any(ComponentName.class), anyInt());
-
-        when(activity.getPackageManager()).thenReturn(mockPackageManager);
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubVideoNativeAdTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubVideoNativeAdTest.java
deleted file mode 100644
index f3cd7f58..00000000
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubVideoNativeAdTest.java
+++ /dev/null
@@ -1,923 +0,0 @@
-package com.mopub.nativeads;
-
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.graphics.Bitmap;
-import android.graphics.SurfaceTexture;
-import android.graphics.drawable.Drawable;
-import android.media.AudioManager;
-import android.os.Build;
-import android.view.TextureView;
-import android.view.TextureView.SurfaceTextureListener;
-import android.view.View;
-
-import com.mopub.common.Constants;
-import com.mopub.common.event.EventDetails;
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.mobileads.BaseVideoPlayerActivity;
-import com.mopub.mobileads.BuildConfig;
-import com.mopub.mobileads.MraidVideoPlayerActivity;
-import com.mopub.mobileads.VastManager;
-import com.mopub.mobileads.VastTracker;
-import com.mopub.mobileads.VastVideoConfig;
-import com.mopub.mobileads.VideoViewabilityTracker;
-import com.mopub.nativeads.BaseNativeAd.NativeEventListener;
-import com.mopub.nativeads.CustomEventNative.CustomEventNativeListener;
-import com.mopub.nativeads.MoPubCustomEventVideoNative.HeaderVisibilityStrategy;
-import com.mopub.nativeads.MoPubCustomEventVideoNative.MoPubVideoNativeAd;
-import com.mopub.nativeads.MoPubCustomEventVideoNative.MoPubVideoNativeAd.VideoState;
-import com.mopub.nativeads.MoPubCustomEventVideoNative.NativeVideoControllerFactory;
-import com.mopub.nativeads.MoPubCustomEventVideoNative.PayloadVisibilityStrategy;
-import com.mopub.nativeads.MoPubCustomEventVideoNative.VideoResponseHeaders;
-import com.mopub.nativeads.NativeVideoController.VisibilityTrackingEvent;
-import com.mopub.network.MaxWidthImageLoader;
-import com.mopub.network.MoPubRequestQueue;
-import com.mopub.network.Networking;
-import com.mopub.volley.toolbox.ImageLoader;
-import com.mopub.volley.toolbox.ImageLoader.ImageListener;
-
-import org.json.JSONArray;
-import org.json.JSONObject;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Mock;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.Robolectric;
-import org.robolectric.annotation.Config;
-import org.robolectric.shadows.ShadowApplication;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import static com.mopub.common.VolleyRequestMatcher.isUrl;
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyBoolean;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.argThat;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.stub;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-@TargetApi(Build.VERSION_CODES.JELLY_BEAN)
-@RunWith(SdkTestRunner.class)
-@Config(constants = BuildConfig.class)
-public class MoPubVideoNativeAdTest {
-
-    private MoPubVideoNativeAd subject;
-    private Activity activity;
-    private JSONObject jsonObject;
-    private Map<String, String> serverExtras;
-    private VideoResponseHeaders videoResponseHeaders;
-
-    @Mock private CustomEventNativeListener mockCustomEventNativeListener;
-    @Mock private VastVideoConfig mockVastVideoConfig;
-    @Mock private MaxWidthImageLoader mockImageLoader;
-    @Mock private ImageLoader.ImageContainer mockImageContainer;
-    @Mock private NativeVideoController mockNativeVideoController;
-    @Mock private VisibilityTracker mockVisibilityTracker;
-    @Mock private NativeVideoControllerFactory mockNativeVideoControllerFactory;
-    @Mock private MediaLayout mockMediaLayout;
-    @Mock private View mockRootView;
-    @Mock private SurfaceTexture mockSurfaceTexture;
-    @Mock private TextureView mockTextureView;
-    @Mock private Drawable mockDrawable;
-    @Mock private MoPubRequestQueue mockRequestQueue;
-    @Mock private NativeEventListener mockNativeEventListener;
-    @Mock private VastManager mockVastManager;
-
-    @Before
-    public void setUp() throws Exception {
-        activity = Robolectric.buildActivity(Activity.class).create().get();
-
-        jsonObject = new JSONObject();
-        jsonObject.put("imptracker", new JSONArray("[\"url1\", \"url2\"]"));
-        jsonObject.put("clktracker", "json click tracker");
-        jsonObject.put("title", "title");
-        jsonObject.put("text", "text");
-        jsonObject.put("mainimage", "mainimageurl");
-        jsonObject.put("iconimage", "iconimageurl");
-        jsonObject.put("clk", "clk");
-        jsonObject.put("fallback", "fallback");
-        jsonObject.put("ctatext", "ctatext");
-        jsonObject.put("video", "video");
-        jsonObject.put("extraimage", "extraimageurl");
-
-        serverExtras = new HashMap<String, String>();
-        serverExtras.put("Play-Visible-Percent", "10");
-        serverExtras.put("Pause-Visible-Percent", "5");
-        serverExtras.put("Impression-Min-Visible-Percent", "15");
-        serverExtras.put("Impression-Visible-Ms", "100");
-        serverExtras.put("Max-Buffer-Ms", "20");
-        videoResponseHeaders = new VideoResponseHeaders(serverExtras);
-
-        when(mockVastVideoConfig.getVideoViewabilityTracker())
-                .thenReturn(new VideoViewabilityTracker(98, 76, "viewabilityTracker"));
-
-        subject = new MoPubVideoNativeAd(
-                activity, jsonObject, mockCustomEventNativeListener, videoResponseHeaders,
-                mockVisibilityTracker, mockNativeVideoControllerFactory, null,
-                "header click tracker", mockVastManager);
-        subject.setNativeEventListener(mockNativeEventListener);
-        // noinspection unchecked
-        when(mockNativeVideoControllerFactory
-                .createForId(anyInt(), any(Context.class), any(List.class), eq(mockVastVideoConfig),
-                        any(EventDetails.class)))
-                .thenReturn(mockNativeVideoController);
-
-        when(mockImageLoader.get(anyString(), any(ImageListener.class)))
-                .then(new Answer<Void>() {
-                    @Override
-                    public Void answer(final InvocationOnMock invocationOnMock) throws Throwable {
-                        ImageListener listener = ((ImageListener) invocationOnMock.getArguments()[1]);
-                        listener.onResponse(mockImageContainer, false);
-                        return null;
-                    }
-                });
-        when(mockMediaLayout.getTextureView()).thenReturn(mockTextureView);
-
-        stub(mockImageContainer.getBitmap()).toReturn(mock(Bitmap.class));
-        Networking.setImageLoaderForTesting(mockImageLoader);
-        Networking.setRequestQueueForTesting(mockRequestQueue);
-    }
-
-    @After
-    public void tearDown() {
-        Networking.setImageLoaderForTesting(null);
-        Networking.setRequestQueueForTesting(null);
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void loadAd_withoutImpTrackerRequiredKey_shouldThrowIllegalArgumentException() {
-        jsonObject.remove("imptracker");
-        subject.loadAd();
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void loadAd_withoutClkTrackerRequiredKey_shouldThrowIllegalArgumentException() {
-        jsonObject.remove("clktracker");
-        subject.loadAd();
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void loadAd_withInvalidValueForRequiredKey_shouldThrowIllegalArgumentException() throws Exception {
-        jsonObject.put("imptracker", 123);
-        subject.loadAd();
-    }
-
-    @Test
-    public void loadAd_withInvalidValueForOptionalKey_shouldNotThrowExcpetion() throws Exception {
-        jsonObject.put("title", 123);
-        subject.loadAd();
-    }
-
-    @Test
-    public void loadAd_shouldInitializeAssetValues() {
-        subject.loadAd();
-
-        assertThat(subject.getImpressionTrackers()).containsOnly("url1", "url2");
-        assertThat(subject.getTitle()).isEqualTo("title");
-        assertThat(subject.getText()).isEqualTo("text");
-        assertThat(subject.getMainImageUrl()).isEqualTo("mainimageurl");
-        assertThat(subject.getIconImageUrl()).isEqualTo("iconimageurl");
-        assertThat(subject.getClickDestinationUrl()).isEqualTo("clk");
-        assertThat(subject.getCallToAction()).isEqualTo("ctatext");
-        assertThat(subject.getPrivacyInformationIconClickThroughUrl()).isEqualTo(
-                "https://www.mopub.com/optout/");
-        assertThat(subject.getVastVideo()).isEqualTo("video");
-        assertThat(subject.getExtra("extraimage")).isEqualTo("extraimageurl");
-        assertThat(subject.getExtras()).hasSize(1);
-    }
-
-    @Test
-    public void loadAd_shouldPrecacheImages_andLoadVastXml() {
-        subject.loadAd();
-
-        verify(mockImageLoader).get(eq("mainimageurl"), any(ImageListener.class));
-        verify(mockImageLoader).get(eq("iconimageurl"), any(ImageListener.class));
-        verify(mockImageLoader).get(eq("extraimageurl"), any(ImageListener.class));
-        verify(mockVastManager).prepareVastVideoConfiguration(eq("video"),
-                any(VastManager.VastManagerListener.class), anyString(), any(Context.class));
-    }
-
-    @Test
-    public void onVastVideoConfigurationPrepared_withNullVastVideoConfig_shouldNotifyListenerFailed() {
-        subject.onVastVideoConfigurationPrepared(null);
-        verify(mockCustomEventNativeListener).onNativeAdFailed(NativeErrorCode.INVALID_RESPONSE);
-    }
-
-    @SuppressWarnings("unchecked")
-    @Test
-    public void onVastVideoConfigurationPrepared_shouldConstructNativeVideoController_shouldNotifyListenerOfAdLoaded() {
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-
-        ArgumentCaptor<List> argumentCaptor = ArgumentCaptor.forClass(List.class);
-        verify(mockNativeVideoControllerFactory).createForId(anyInt(),
-                eq(activity.getApplicationContext()),
-                argumentCaptor.capture(),
-                eq(mockVastVideoConfig),
-                any(EventDetails.class));
-
-        List<VisibilityTrackingEvent> visibilityTrackingEvents = (List<VisibilityTrackingEvent>) argumentCaptor.getValue();
-        assertThat(visibilityTrackingEvents.get(0).strategy).isInstanceOf(HeaderVisibilityStrategy.class);
-        assertThat(visibilityTrackingEvents.get(0).minimumPercentageVisible).isEqualTo(15);
-        assertThat(visibilityTrackingEvents.get(0).totalRequiredPlayTimeMs).isEqualTo(100);
-
-        assertThat(visibilityTrackingEvents.get(1).strategy).isInstanceOf(PayloadVisibilityStrategy.class);
-        assertThat(visibilityTrackingEvents.get(1).minimumPercentageVisible).isEqualTo(76);
-        assertThat(visibilityTrackingEvents.get(1).totalRequiredPlayTimeMs).isEqualTo(98);
-
-        verify(mockVastVideoConfig).addClickTrackers(any(List.class));
-        verify(mockVastVideoConfig).setClickThroughUrl("clk");
-        verify(mockCustomEventNativeListener).onNativeAdLoaded(subject);
-    }
-
-    @SuppressWarnings("unchecked")
-    @Test
-    public void onVastVideoConfigurationPrepared_shouldMergeHeaderAndJsonClickTrackers() {
-        final ArgumentCaptor<List> argumentCaptor = ArgumentCaptor.forClass(List.class);
-
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-
-        verify(mockVastVideoConfig).addClickTrackers(argumentCaptor.capture());
-        final List<VastTracker> actualClickTrackers = (List<VastTracker>) argumentCaptor.getValue();
-        assertThat(actualClickTrackers.size()).isEqualTo(2);
-        final VastTracker headerClickTracker = actualClickTrackers.get(0);
-        final VastTracker jsonClickTracker = actualClickTrackers.get(1);
-        assertThat(headerClickTracker.getTrackingUrl()).isEqualTo("header click tracker");
-        assertThat(headerClickTracker.isRepeatable()).isFalse();
-        assertThat(jsonClickTracker.getTrackingUrl()).isEqualTo("json click tracker");
-        assertThat(jsonClickTracker.isRepeatable()).isFalse();
-    }
-
-    @SuppressWarnings("unchecked")
-    @Test
-    public void onVastVideoConfigurationPrepared_shouldDedupeHeaderAndJsonClickTrackers() throws Exception {
-        jsonObject.remove("clktracker");
-        jsonObject.put("clktracker", "header click tracker");
-        final ArgumentCaptor<List> argumentCaptor = ArgumentCaptor.forClass(List.class);
-
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-
-        verify(mockVastVideoConfig).addClickTrackers(argumentCaptor.capture());
-        final List<VastTracker> actualClickTrackers = (List<VastTracker>) argumentCaptor.getValue();
-        assertThat(actualClickTrackers.size()).isEqualTo(1);
-        final VastTracker clickTracker = actualClickTrackers.get(0);
-        assertThat(clickTracker.getTrackingUrl()).isEqualTo("header click tracker");
-        assertThat(clickTracker.isRepeatable()).isFalse();
-    }
-
-    @SuppressWarnings("unchecked")
-    @Test
-    public void onVastVideoConfigurationPrepared_shouldAcceptJsonArrayClickTrackers() throws Exception {
-        jsonObject.remove("clktracker");
-        jsonObject.put("clktracker",
-                new JSONArray("[\"json click tracker 1\", \"json click tracker 2\"]"));
-        final ArgumentCaptor<List> argumentCaptor = ArgumentCaptor.forClass(List.class);
-
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-
-        verify(mockVastVideoConfig).addClickTrackers(argumentCaptor.capture());
-        final List<VastTracker> actualClickTrackers = (List<VastTracker>) argumentCaptor.getValue();
-        assertThat(actualClickTrackers.size()).isEqualTo(3);
-        final VastTracker jsonClickTracker1 = actualClickTrackers.get(0);
-        final VastTracker jsonClickTracker2 = actualClickTrackers.get(1);
-        final VastTracker headerClickTracker = actualClickTrackers.get(2);
-        assertThat(jsonClickTracker1.getTrackingUrl()).isEqualTo("json click tracker 1");
-        assertThat(jsonClickTracker1.isRepeatable()).isFalse();
-        assertThat(jsonClickTracker2.getTrackingUrl()).isEqualTo("json click tracker 2");
-        assertThat(jsonClickTracker2.isRepeatable()).isFalse();
-        assertThat(headerClickTracker.getTrackingUrl()).isEqualTo("header click tracker");
-        assertThat(headerClickTracker.isRepeatable()).isFalse();
-    }
-
-    @SuppressWarnings("unchecked")
-    @Test
-    public void onVastVideoConfigurationPrepared_shouldDedupeJsonArrayClickTrackers() throws Exception {
-        jsonObject.remove("clktracker");
-        jsonObject.put("clktracker",
-                new JSONArray("[\"json click tracker\", \"header click tracker\"]"));
-        final ArgumentCaptor<List> argumentCaptor = ArgumentCaptor.forClass(List.class);
-
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-
-        verify(mockVastVideoConfig).addClickTrackers(argumentCaptor.capture());
-        final List<VastTracker> actualClickTrackers = (List<VastTracker>) argumentCaptor.getValue();
-        assertThat(actualClickTrackers.size()).isEqualTo(2);
-        final VastTracker headerClickTracker = actualClickTrackers.get(0);
-        final VastTracker jsonClickTracker = actualClickTrackers.get(1);
-        assertThat(headerClickTracker.getTrackingUrl()).isEqualTo("header click tracker");
-        assertThat(headerClickTracker.isRepeatable()).isFalse();
-        assertThat(jsonClickTracker.getTrackingUrl()).isEqualTo("json click tracker");
-        assertThat(jsonClickTracker.isRepeatable()).isFalse();
-    }
-
-    @Test
-    public void render_shouldAddViewToVisibilityTracker() {
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-        subject.prepare(mockRootView);
-        subject.render(mockMediaLayout);
-
-        verify(mockVisibilityTracker).addView(mockRootView, mockMediaLayout, 10, 5);
-    }
-
-    @Test
-    public void render_shouldSetupMediaLayout() {
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-        subject.prepare(mockRootView);
-        subject.render(mockMediaLayout);
-
-        verify(mockMediaLayout).setSurfaceTextureListener(any(SurfaceTextureListener.class));
-        verify(mockMediaLayout).setPlayButtonClickListener(any(View.OnClickListener.class));
-        verify(mockMediaLayout).setMuteControlClickListener(any(View.OnClickListener.class));
-        verify(mockMediaLayout).setOnClickListener(any(View.OnClickListener.class));
-    }
-
-    @Test
-    public void render_shouldApplyStatePaused() {
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-        subject.prepare(mockRootView);
-        subject.render(mockMediaLayout);
-
-        verify(mockMediaLayout).setMode(MediaLayout.Mode.PAUSED);
-    }
-
-    @Test
-    public void render_withPlaybackStateCleared_shouldPrepareNativeVideoController() {
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-        subject.prepare(mockRootView);
-        when(mockNativeVideoController.getPlaybackState()).thenReturn(NativeVideoController
-                .STATE_CLEARED);
-        subject.render(mockMediaLayout);
-
-        verify(mockNativeVideoController).prepare(subject);
-    }
-
-    @Test
-    public void MediaLayout_surfaceTextureListener_onSurfaceTextureAvailable_shouldSetupNativeVideoController_shouldResetMediaLayoutProgress() {
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-        subject.prepare(mockRootView);
-        subject.render(mockMediaLayout);
-
-        ArgumentCaptor<SurfaceTextureListener> argumentCaptor =
-                ArgumentCaptor.forClass(SurfaceTextureListener.class);
-        verify(mockMediaLayout).setSurfaceTextureListener(argumentCaptor.capture());
-        SurfaceTextureListener surfaceTextureListener = argumentCaptor.getValue();
-
-        surfaceTextureListener.onSurfaceTextureAvailable(mockSurfaceTexture, 0, 0);
-
-        verify(mockNativeVideoController).setListener(subject);
-        verify(mockNativeVideoController).setOnAudioFocusChangeListener(subject);
-        verify(mockNativeVideoController).setProgressListener(subject);
-        verify(mockNativeVideoController).setTextureView(mockMediaLayout.getTextureView());
-        verify(mockMediaLayout).resetProgress();
-    }
-
-    @Test
-    public void MediaLayout_surfaceTextureListener_onSurfaceTextureAvailable_withCurrentPositionWithinThreshhold_withStateEnded_shouldSetFinalFrameAsMainImage() {
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-        subject.prepare(mockRootView);
-        subject.render(mockMediaLayout);
-
-        ArgumentCaptor<SurfaceTextureListener> argumentCaptor =
-                ArgumentCaptor.forClass(SurfaceTextureListener.class);
-        verify(mockMediaLayout).setSurfaceTextureListener(argumentCaptor.capture());
-        SurfaceTextureListener surfaceTextureListener = argumentCaptor.getValue();
-
-        when(mockNativeVideoController.getPlaybackState())
-                .thenReturn(NativeVideoController.STATE_ENDED);
-        when(mockNativeVideoController.getCurrentPosition()).thenReturn(9L);
-        when(mockNativeVideoController.getDuration()).thenReturn(10L);
-        when(mockNativeVideoController.hasFinalFrame()).thenReturn(true);
-        when(mockNativeVideoController.getFinalFrame()).thenReturn(mockDrawable);
-
-        surfaceTextureListener.onSurfaceTextureAvailable(mockSurfaceTexture, 0, 0);
-
-        verify(mockMediaLayout).setMainImageDrawable(mockNativeVideoController.getFinalFrame());
-    }
-
-    @Test
-    public void MediaLayout_surfaceTextureListener_onSurfaceTextureAvailable_withNeedsPrepare_shouldPrepareNativeVideoController() {
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-        subject.render(mockMediaLayout);
-
-        ArgumentCaptor<SurfaceTextureListener> argumentCaptor =
-                ArgumentCaptor.forClass(SurfaceTextureListener.class);
-        verify(mockMediaLayout).setSurfaceTextureListener(argumentCaptor.capture());
-        SurfaceTextureListener surfaceTextureListener = argumentCaptor.getValue();
-
-        surfaceTextureListener.onSurfaceTextureAvailable(mockSurfaceTexture, 0, 0);
-
-        verify(mockNativeVideoController).prepare(subject);
-    }
-
-    @Test
-    public void MediaLayout_surfaceTextureListener_onSurfaceTextureDestroyed_shouldSetNeedsPrepareTrue_shouldReleaseMoPubNativeVideoAd_shouldApplyStatePaused() {
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-        subject.prepare(mockRootView);
-        subject.render(mockMediaLayout);
-
-        ArgumentCaptor<SurfaceTextureListener> argumentCaptor =
-                ArgumentCaptor.forClass(SurfaceTextureListener.class);
-        verify(mockMediaLayout).setSurfaceTextureListener(argumentCaptor.capture());
-        SurfaceTextureListener surfaceTextureListener = argumentCaptor.getValue();
-
-        surfaceTextureListener.onSurfaceTextureDestroyed(mockSurfaceTexture);
-
-        assertThat(subject.needsPrepare()).isTrue();
-        verify(mockNativeVideoController).release(subject);
-        verify(mockMediaLayout).setMode(MediaLayout.Mode.PAUSED);
-    }
-
-    @Test
-    public void MediaLayout_playButtonClickListener_shouldResetMediaLayoutProgress_shouldSeekTo0_shouldSetEndedFalse_shouldSetNeedsSeekFalse() {
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-        subject.prepare(mockRootView);
-        subject.render(mockMediaLayout);
-
-        ArgumentCaptor<View.OnClickListener> argumentCaptor =
-                ArgumentCaptor.forClass(View.OnClickListener.class);
-        verify(mockMediaLayout).setPlayButtonClickListener(argumentCaptor.capture());
-
-        View.OnClickListener onClickListener = argumentCaptor.getValue();
-        onClickListener.onClick(null);
-
-        verify(mockMediaLayout).resetProgress();
-        verify(mockNativeVideoController).seekTo(0);
-        assertThat(subject.hasEnded()).isEqualTo(false);
-        assertThat(subject.needsSeek()).isEqualTo(false);
-    }
-
-    @Test
-    public void MediaLayout_muteButtonClickListener_withStateReady_shouldToggleMutedState() {
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-        subject.prepare(mockRootView);
-        subject.render(mockMediaLayout);
-
-        ArgumentCaptor<View.OnClickListener> argumentCaptor =
-                ArgumentCaptor.forClass(View.OnClickListener.class);
-        verify(mockMediaLayout).setMuteControlClickListener(argumentCaptor.capture());
-
-        View.OnClickListener onClickListener = argumentCaptor.getValue();
-        onClickListener.onClick(null);
-        assertThat(subject.isMuted()).isFalse();
-
-        onClickListener.onClick(null);
-        assertThat(subject.isMuted()).isTrue();
-    }
-
-    @Test
-    public void MediaLayout_clickListener_shouldPrepareToLeaveView_shouldTriggerImpressionTracker_shouldNotDisableAppAudio_shouldStartFullScreenVideoActivity() {
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-        subject.prepare(mockRootView);
-        subject.render(mockMediaLayout);
-
-        ArgumentCaptor<View.OnClickListener> argumentCaptor =
-                ArgumentCaptor.forClass(View.OnClickListener.class);
-        verify(mockMediaLayout).setOnClickListener(argumentCaptor.capture());
-
-        reset(mockNativeVideoController);
-        View.OnClickListener onClickListener = argumentCaptor.getValue();
-        onClickListener.onClick(null);
-
-        assertThat(subject.needsSeek()).isTrue();
-        assertThat(subject.needsPrepare()).isTrue();
-        assertThat(subject.needsPrepare()).isTrue();
-        verify(mockNativeVideoController).setListener(null);
-        verify(mockNativeVideoController).setOnAudioFocusChangeListener(null);
-        verify(mockNativeVideoController).setProgressListener(null);
-        verify(mockNativeVideoController).clear();
-        verify(mockNativeVideoController).triggerImpressionTrackers();
-        verify(mockMediaLayout).setMode(MediaLayout.Mode.PAUSED);
-        verify(mockNativeVideoController, never()).setAppAudioEnabled(anyBoolean());
-
-        final Intent startedActivity = ShadowApplication.getInstance().peekNextStartedActivity();
-        assertThat(startedActivity.getComponent().getClassName())
-                .isEqualTo(MraidVideoPlayerActivity.class.getName());
-        assertThat(startedActivity.getStringExtra(BaseVideoPlayerActivity.VIDEO_CLASS_EXTRAS_KEY))
-                .isEqualTo("native");
-        assertThat(startedActivity.getLongExtra(Constants.NATIVE_VIDEO_ID, 0L))
-                .isGreaterThan(0L);
-        assertThat(startedActivity.getSerializableExtra(Constants
-                .NATIVE_VAST_VIDEO_CONFIG))
-                .isEqualTo(mockVastVideoConfig);
-    }
-
-    @Test
-    public void prepare_shouldSetOnClickListenerOnView() {
-        subject.prepare(mockRootView);
-        verify(mockRootView).setOnClickListener(any(View.OnClickListener.class));
-    }
-
-    @Test
-    public void RootView_onClickListener_onClick_shouldPrepareToLeaveView_shouldNotDisableAppAudio_shouldNotNotifyAdClicked_shouldTriggerImpressionTrackers_shouldshouldHandleCtaClick() {
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-        subject.prepare(mockRootView);
-        subject.render(mockMediaLayout);
-
-        ArgumentCaptor<View.OnClickListener> argumentCaptor =
-                ArgumentCaptor.forClass(View.OnClickListener.class);
-        verify(mockRootView).setOnClickListener(argumentCaptor.capture());
-
-        View.OnClickListener onClickListener = argumentCaptor.getValue();
-        reset(mockNativeVideoController);
-        onClickListener.onClick(null);
-
-        assertThat(subject.needsSeek()).isTrue();
-        assertThat(subject.needsPrepare()).isTrue();
-        assertThat(subject.needsPrepare()).isTrue();
-        verify(mockNativeVideoController).setListener(null);
-        verify(mockNativeVideoController).setOnAudioFocusChangeListener(null);
-        verify(mockNativeVideoController).setProgressListener(null);
-        verify(mockNativeVideoController).clear();
-        verify(mockMediaLayout).setMode(MediaLayout.Mode.PAUSED);
-        verify(mockNativeVideoController).handleCtaClick(activity.getApplicationContext());
-        verify(mockNativeEventListener, never()).onAdClicked();
-        verify(mockNativeVideoController).triggerImpressionTrackers();
-        verify(mockNativeVideoController, never()).setAppAudioEnabled(anyBoolean());
-    }
-
-    @Test
-    public void clear_shouldClearNativeVideoController_shouldSetMediaLayoutModeImage_shouldSetMediaLayoutNull_shouldSetMediaLayoutListenersToNull_shouldRemoveMediaLayoutFromVisibilityTracker() {
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-        subject.prepare(mockRootView);
-        subject.render(mockMediaLayout);
-        subject.clear(mockRootView);
-
-        verify(mockNativeVideoController).clear();
-        verify(mockMediaLayout).setMode(MediaLayout.Mode.IMAGE);
-        verify(mockMediaLayout).setSurfaceTextureListener(null);
-        verify(mockMediaLayout).setPlayButtonClickListener(null);
-        verify(mockMediaLayout).setMuteControlClickListener(null);
-        verify(mockMediaLayout).setOnClickListener(null);
-        verify(mockVisibilityTracker).removeView(mockMediaLayout);
-        assertThat(subject.getMediaLayout()).isNull();
-    }
-
-    @Test
-    public void destroy_shouldSetPlayWhenReadyFalse_shouldReleaseNativeVideoController_shouldRemoveNativeVideoController_shouldDestroyVisibilityTracker() {
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-        subject.prepare(mockRootView);
-        subject.render(mockMediaLayout);
-
-        reset(mockNativeVideoController);
-        subject.destroy();
-
-        verify(mockMediaLayout).setMode(MediaLayout.Mode.IMAGE);
-        verify(mockMediaLayout).setSurfaceTextureListener(null);
-        verify(mockMediaLayout).setPlayButtonClickListener(null);
-        verify(mockMediaLayout).setMuteControlClickListener(null);
-        verify(mockMediaLayout).setOnClickListener(null);
-        verify(mockVisibilityTracker).removeView(mockMediaLayout);
-
-        assertThat(subject.getMediaLayout()).isNull();
-        verify(mockNativeVideoController).setPlayWhenReady(false);
-        verify(mockNativeVideoController).release(subject);
-        assertThat(NativeVideoController.getForId(subject.getId())).isNull();
-        verify(mockVisibilityTracker).destroy();
-    }
-
-    @Test
-    public void onStateChanged_shouldAppropriatelySetVideoState() {
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-        subject.prepare(mockRootView);
-        subject.render(mockMediaLayout);
-
-        subject.onStateChanged(true, NativeVideoController.STATE_PREPARING);
-        assertThat(subject.getVideoState()).isEqualTo(VideoState.LOADING);
-
-        subject.onStateChanged(true, NativeVideoController.STATE_IDLE);
-        assertThat(subject.getVideoState()).isEqualTo(VideoState.LOADING);
-
-        subject.onStateChanged(true, NativeVideoController.STATE_BUFFERING);
-        assertThat(subject.getVideoState()).isEqualTo(VideoState.BUFFERING);
-
-        subject.onStateChanged(true, NativeVideoController.STATE_READY);
-        assertThat(subject.getVideoState()).isEqualTo(VideoState.PAUSED);
-
-        subject.setLatestVisibility(true);
-        subject.onStateChanged(true, NativeVideoController.STATE_READY);
-        assertThat(subject.getVideoState()).isEqualTo(VideoState.PLAYING_MUTED);
-
-        subject.setMuted(false);
-        subject.onStateChanged(true, NativeVideoController.STATE_READY);
-        assertThat(subject.getVideoState()).isEqualTo(VideoState.PLAYING);
-
-        subject.onStateChanged(true, NativeVideoController.STATE_ENDED);
-        assertThat(subject.getVideoState()).isEqualTo(VideoState.ENDED);
-        assertThat(subject.hasEnded()).isTrue();
-    }
-
-    @Test
-    public void onError_shouldSetVideoStateError() {
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-        subject.prepare(mockRootView);
-        subject.render(mockMediaLayout);
-
-        subject.onError(new Exception());
-
-        assertThat(subject.getVideoState()).isEqualTo(VideoState.FAILED_LOAD);
-    }
-
-    @Test
-    public void updateProgress_shouldUpdateMediaLayoutProgress() {
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-        subject.prepare(mockRootView);
-        subject.render(mockMediaLayout);
-
-        subject.updateProgress(312);
-
-        verify(mockMediaLayout).updateProgress(312);
-    }
-
-    @Test
-    public void onAudioFocusChange_withFocusChangeAudioFocusLossOrAudioFocusLossTransient_shouldMuteTheVideo() throws Exception {
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-        subject.prepare(mockRootView);
-        subject.render(mockMediaLayout);
-
-        subject.setMuted(false);
-        subject.onAudioFocusChange(AudioManager.AUDIOFOCUS_LOSS);
-
-        assertThat(subject.isMuted()).isTrue();
-
-        subject.setMuted(false);
-        subject.onAudioFocusChange(AudioManager.AUDIOFOCUS_LOSS_TRANSIENT);
-
-        assertThat(subject.isMuted()).isTrue();
-    }
-
-    @Test
-    public void onAudioFocusChange_withFocusChangeAudioFocusLossTransientCanDuck_shouldLowerVolume() throws Exception {
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-        subject.prepare(mockRootView);
-        subject.render(mockMediaLayout);
-
-        subject.onAudioFocusChange(AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK);
-
-        verify(mockNativeVideoController).setAudioVolume(0.3f);
-    }
-
-    @Test
-    public void onAudioFocusChange_withFocusChangeAudioFocusGain_shouldRaiseVolume() throws Exception {
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-        subject.prepare(mockRootView);
-        subject.render(mockMediaLayout);
-
-        subject.onAudioFocusChange(AudioManager.AUDIOFOCUS_GAIN);
-
-        verify(mockNativeVideoController).setAudioVolume(1.0f);
-    }
-
-    @Test
-    public void applyState_shouldHandleError_shouldSetAppAudioEnabledFalse_shouldSetMediaLayoutModeImage() {
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-        subject.prepare(mockRootView);
-        subject.render(mockMediaLayout);
-
-        reset(mockNativeVideoController);
-        subject.applyState(VideoState.FAILED_LOAD);
-
-        verify(mockVastVideoConfig).handleError(activity.getApplicationContext(), null, 0);
-        verify(mockNativeVideoController).setAppAudioEnabled(false);
-        verify(mockMediaLayout).setMode(MediaLayout.Mode.IMAGE);
-    }
-
-    @Test
-    public void applyState_withVideoStateCreatedOrLoading_shouldSetPlayWhenReadyTrue_shouldSetMediaLayoutModeLoading() {
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-        subject.prepare(mockRootView);
-        subject.render(mockMediaLayout);
-
-        subject.applyState(VideoState.CREATED);
-
-        verify(mockNativeVideoController).setPlayWhenReady(true);
-        verify(mockMediaLayout).setMode(MediaLayout.Mode.LOADING);
-
-        reset(mockNativeVideoController);
-        reset(mockMediaLayout);
-        subject.applyState(VideoState.LOADING);
-
-        verify(mockNativeVideoController).setPlayWhenReady(true);
-        verify(mockMediaLayout).setMode(MediaLayout.Mode.LOADING);
-    }
-
-    @Test
-    public void applyState_withVideoStateBuffering_shouldSetPlayWhenReadyTrue_shouldSetMediaLayoutModeBuffering() {
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-        subject.prepare(mockRootView);
-        subject.render(mockMediaLayout);
-
-        subject.applyState(VideoState.BUFFERING);
-
-        verify(mockNativeVideoController).setPlayWhenReady(true);
-        verify(mockMediaLayout).setMode(MediaLayout.Mode.BUFFERING);
-    }
-
-    @Test
-    public void applyState_withVideoStatePaused_withTransitionToFullScreenFalse_shouldSetAppAudioEnabledFalse_shouldSetPlayWhenReadyFalse_shouldSetMediaLayoutModePaused() {
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-        subject.prepare(mockRootView);
-        subject.render(mockMediaLayout);
-
-        subject.applyState(VideoState.PAUSED);
-
-        verify(mockNativeVideoController).setAppAudioEnabled(false);
-        verify(mockNativeVideoController).setPlayWhenReady(false);
-        verify(mockMediaLayout).setMode(MediaLayout.Mode.PAUSED);
-    }
-
-    @Test
-    public void applyState_withVideoStatePlaying_shouldSetPlayWhenReadyTrue_shouldSetAudioEnabledTrue_shouldSetAppAudioEnabledTrue_shouldSetMediaLayoutModePlaying_shouldSetMuteStateUnmuted() {
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-        subject.prepare(mockRootView);
-        subject.render(mockMediaLayout);
-
-        reset(mockNativeVideoController);
-        subject.applyState(VideoState.PLAYING);
-
-        verify(mockNativeVideoController).setPlayWhenReady(true);
-        verify(mockNativeVideoController).setAudioEnabled(true);
-        verify(mockNativeVideoController).setAppAudioEnabled(true);
-        verify(mockMediaLayout).setMode(MediaLayout.Mode.PLAYING);
-        verify(mockMediaLayout).setMuteState(MediaLayout.MuteState.UNMUTED);
-    }
-
-    @Test
-    public void applyState_withVideoStatePlaying_withNeedsSeek_shouldSeekToCurrentPosition() {
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-        subject.prepare(mockRootView);
-        subject.render(mockMediaLayout);
-
-        assertThat(subject.needsSeek()).isTrue();
-        when(mockNativeVideoController.getCurrentPosition()).thenReturn(543L);
-        subject.applyState(VideoState.PLAYING);
-
-        verify(mockNativeVideoController).seekTo(mockNativeVideoController.getCurrentPosition());
-    }
-
-    @Test
-    public void applyState_withVideoStatePlayingMuted_shouldSetPlayWhenReadyTrue_shouldSetAudioEnabledFalse_shouldSetAppAudioEnabledTrue_shouldSetMediaLayoutModePlaying_shouldSetMuteStateMuted() {
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-        subject.prepare(mockRootView);
-        subject.render(mockMediaLayout);
-
-        reset(mockNativeVideoController);
-        subject.applyState(VideoState.PLAYING_MUTED);
-
-        verify(mockNativeVideoController).setPlayWhenReady(true);
-        verify(mockNativeVideoController).setAudioEnabled(false);
-        verify(mockNativeVideoController).setAppAudioEnabled(false);
-        verify(mockMediaLayout).setMode(MediaLayout.Mode.PLAYING);
-        verify(mockMediaLayout).setMuteState(MediaLayout.MuteState.MUTED);
-    }
-
-    @Test
-    public void applyState_withVideoStatePlayingMuted_withNeedsSeek_shouldSeekToCurrentPosition() {
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-        subject.prepare(mockRootView);
-        subject.render(mockMediaLayout);
-
-        assertThat(subject.needsSeek()).isTrue();
-        when(mockNativeVideoController.getCurrentPosition()).thenReturn(543L);
-        subject.applyState(VideoState.PLAYING_MUTED);
-
-        verify(mockNativeVideoController).seekTo(mockNativeVideoController.getCurrentPosition());
-    }
-
-    @Test
-    public void applyState_withVideoStatePlayingEnded_shouldHandleComplete_shouldSetAppAudioEnabledTrue_shouldSetMediaLayoutModeFinished_shouldUpdateMediaLayoutProgress1000() {
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-        subject.prepare(mockRootView);
-        subject.render(mockMediaLayout);
-
-        reset(mockNativeVideoController);
-        subject.applyState(VideoState.ENDED);
-
-        verify(mockVastVideoConfig).handleComplete(activity.getApplicationContext(), 0);
-        verify(mockNativeVideoController).setAppAudioEnabled(false);
-        verify(mockMediaLayout).setMode(MediaLayout.Mode.FINISHED);
-        verify(mockMediaLayout).updateProgress(1000);
-
-        verify(mockMediaLayout, never()).setMainImageDrawable(any(Drawable.class));
-    }
-
-    @Test
-    public void applyState_withVideoStatePlayingEnded_withFinalFrame_shouldSetMainImageDrawableOfMediaLayout() {
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-        subject.prepare(mockRootView);
-        subject.render(mockMediaLayout);
-
-        when(mockNativeVideoController.hasFinalFrame()).thenReturn(true);
-        when(mockNativeVideoController.getFinalFrame()).thenReturn(mockDrawable);
-        subject.applyState(VideoState.ENDED);
-
-        verify(mockMediaLayout).setMainImageDrawable(mockNativeVideoController.getFinalFrame());
-    }
-
-    @Test
-    public void applyState_withVideoStatePause_afterVideoStatePlayingMuted_shouldFirePauseTrackers() {
-        final ArrayList<VastTracker> testList = new ArrayList<VastTracker>();
-        testList.add(new VastTracker("testUrl", true));
-
-        when(mockVastVideoConfig.getPauseTrackers()).thenReturn(testList);
-
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-        subject.prepare(mockRootView);
-        subject.render(mockMediaLayout);
-
-        subject.applyState(VideoState.PLAYING_MUTED);
-        subject.applyState(VideoState.PAUSED);
-
-        verify(mockVastVideoConfig).getPauseTrackers();
-        verify(mockRequestQueue).add(argThat(isUrl("testUrl")));
-    }
-
-    @Test
-    public void applyState_withVideoStatePlayingMuted_afterPaused_afterPlaying_shouldFireResumeTrackers() {
-        final ArrayList<VastTracker> testList = new ArrayList<VastTracker>();
-        testList.add(new VastTracker("testResumeUrl", true));
-
-        when(mockVastVideoConfig.getResumeTrackers()).thenReturn(testList);
-
-        subject.loadAd();
-        subject.onVastVideoConfigurationPrepared(mockVastVideoConfig);
-        subject.prepare(mockRootView);
-        subject.render(mockMediaLayout);
-
-        subject.applyState(VideoState.PLAYING_MUTED);
-        subject.applyState(VideoState.PAUSED);
-        subject.applyState(VideoState.BUFFERING);
-        subject.applyState(VideoState.PLAYING_MUTED);
-
-        verify(mockVastVideoConfig).getPauseTrackers();
-        verify(mockRequestQueue).add(argThat(isUrl("testResumeUrl")));
-    }
-
-    @Test
-    public void HeaderVisibilityStrategy_execute_shouldNotifyAdImpressed() throws Exception {
-        HeaderVisibilityStrategy headerVisibilityStrategy
-                = new HeaderVisibilityStrategy(subject);
-        headerVisibilityStrategy.execute();
-
-        verify(mockNativeEventListener).onAdImpressed();
-    }
-
-    @Test
-    public void PayloadVisibilityStrategy_execute_shouldMakeTrackingRequest() throws Exception {
-        PayloadVisibilityStrategy payloadVisibilityStrategy
-                = new PayloadVisibilityStrategy(activity, "payloadUrl");
-        payloadVisibilityStrategy.execute();
-
-        verify(mockRequestQueue).add(argThat(isUrl("payloadUrl")));
-    }
-}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeVideoViewControllerTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeVideoViewControllerTest.java
deleted file mode 100644
index 6c35d102..00000000
--- a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeVideoViewControllerTest.java
+++ /dev/null
@@ -1,362 +0,0 @@
-package com.mopub.nativeads;
-
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.content.Intent;
-import android.content.res.Configuration;
-import android.graphics.Bitmap;
-import android.media.AudioManager;
-import android.os.Build;
-import android.os.Bundle;
-import android.view.TextureView;
-import android.view.View;
-import android.view.ViewGroup.LayoutParams;
-
-import com.mopub.common.Constants;
-import com.mopub.common.MoPubBrowser;
-import com.mopub.common.test.support.SdkTestRunner;
-import com.mopub.mobileads.BaseVideoViewController.BaseVideoViewControllerListener;
-import com.mopub.mobileads.BuildConfig;
-import com.mopub.mobileads.VastVideoConfig;
-import com.mopub.mobileads.resource.CtaButtonDrawable;
-import com.mopub.nativeads.MoPubCustomEventVideoNative.MoPubVideoNativeAd;
-import com.mopub.nativeads.NativeFullScreenVideoView.Mode;
-import com.mopub.nativeads.NativeVideoController.NativeVideoProgressRunnable.ProgressListener;
-import com.mopub.nativeads.NativeVideoViewController.VideoState;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Mock;
-import org.robolectric.Robolectric;
-import org.robolectric.annotation.Config;
-import org.robolectric.shadows.ShadowApplication;
-
-import static org.fest.assertions.api.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.when;
-
-@TargetApi(Build.VERSION_CODES.JELLY_BEAN)
-@RunWith(SdkTestRunner.class)
-@Config(constants = BuildConfig.class)
-public class NativeVideoViewControllerTest {
-
-    private NativeVideoViewController subject;
-    private Activity activity;
-    private Bundle intentExtras;
-
-    @Mock private BaseVideoViewControllerListener mockBaseVideoViewControllerListener;
-    @Mock private NativeFullScreenVideoView mockFullScreenVideoView;
-    @Mock private NativeVideoController mockVideoController;
-    @Mock private VastVideoConfig mockVastVideoConfig;
-    @Mock private TextureView mockTextureView;
-    @Mock private Bitmap mockBitmap;
-
-    @Before
-    public void setUp() {
-        activity = Robolectric.buildActivity(Activity.class).create().get();
-
-        intentExtras = new Bundle();
-        intentExtras.putLong(Constants.NATIVE_VIDEO_ID, 123);
-        NativeVideoController.setForId(123, mockVideoController);
-
-        when(mockVastVideoConfig.getCustomCtaText()).thenReturn("Learn More");
-        when(mockFullScreenVideoView.getTextureView()).thenReturn(mockTextureView);
-        when(mockTextureView.getBitmap()).thenReturn(mockBitmap);
-        intentExtras.putSerializable(Constants.NATIVE_VAST_VIDEO_CONFIG, mockVastVideoConfig);
-
-        subject = new NativeVideoViewController(activity, intentExtras, null,
-                mockBaseVideoViewControllerListener, mockFullScreenVideoView);
-    }
-
-    @After
-    public void tearDown() {
-        NativeVideoController.remove(123);
-    }
-
-    @Test
-    public void constructor_shouldSetCtaText() {
-        subject = new NativeVideoViewController(activity, intentExtras, null,
-                mockBaseVideoViewControllerListener);
-        CtaButtonDrawable ctaButtonDrawable =
-                (CtaButtonDrawable) subject.getNativeFullScreenVideoView().getCtaButton()
-                        .getDrawable();
-
-        assertThat(ctaButtonDrawable.getCtaText()).isEqualTo("Learn More");
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void constructor_withNullNativeVideoController_shouldThrowNPE() {
-        NativeVideoController.remove(123);
-        subject = new NativeVideoViewController(activity, intentExtras, null,
-                mockBaseVideoViewControllerListener, mockFullScreenVideoView);
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void onCreate_withNullNativeVideoController_shouldThrowNPE() {
-        intentExtras.remove(Constants.NATIVE_VAST_VIDEO_CONFIG);
-        subject = new NativeVideoViewController(activity, intentExtras, null,
-                mockBaseVideoViewControllerListener, mockFullScreenVideoView);
-    }
-
-    @Test
-    public void onCreate_shouldSetupVideoView() {
-        subject.onCreate();
-
-        verify(mockFullScreenVideoView).setSurfaceTextureListener(subject);
-        verify(mockFullScreenVideoView).setMode(Mode.LOADING);
-        verify(mockFullScreenVideoView).setPlayControlClickListener(any(View.OnClickListener.class));
-        verify(mockFullScreenVideoView).setCloseControlListener(any(View.OnClickListener.class));
-        verify(mockFullScreenVideoView).setCtaClickListener(any(View.OnClickListener.class));
-        verify(mockFullScreenVideoView).setPrivacyInformationClickListener(
-                any(View.OnClickListener.class));
-        verify(mockFullScreenVideoView).setLayoutParams(any(LayoutParams.class));
-        verify(mockBaseVideoViewControllerListener).onSetContentView(mockFullScreenVideoView);
-        verify(mockBaseVideoViewControllerListener, never()).onFinish();
-    }
-
-    @Test
-    public void onCreate_shouldSetupNativeVideoController() {
-        subject.onCreate();
-
-        verify(mockVideoController).setProgressListener(any(ProgressListener.class));
-    }
-
-    @Test
-    public void NativeFullScreenVideoView_playControlClickListener_withVideoEnded_shouldResetFullScreenVideoProgress_shouldSeekTo0_shouldApplyPlaying() {
-        ArgumentCaptor<View.OnClickListener> captor = ArgumentCaptor.forClass(View.OnClickListener.class);
-
-        subject.onCreate();
-        subject.applyState(VideoState.ENDED);
-
-        verify(mockFullScreenVideoView).setPlayControlClickListener(captor.capture());
-        captor.getValue().onClick(null);
-
-        verify(mockFullScreenVideoView).resetProgress();
-        verify(mockVideoController).seekTo(0);
-        assertThat(subject.getVideoState()).isEqualTo(VideoState.PLAYING);
-        verify(mockBaseVideoViewControllerListener, never()).onFinish();
-    }
-
-    @Test
-    public void NativeFullScreenVideoView_closeControlClickListener_shouldSetStatePaused_shouldNotDisableAppAudio_shouldFinishActivity() {
-        ArgumentCaptor<View.OnClickListener> captor = ArgumentCaptor.forClass(View.OnClickListener.class);
-
-        subject.onCreate();
-
-        verify(mockFullScreenVideoView).setCloseControlListener(captor.capture());
-        captor.getValue().onClick(null);
-
-        assertThat(subject.getVideoState()).isEqualTo(VideoState.PAUSED);
-        verify(mockVideoController, never()).setAppAudioEnabled(false);
-        verify(mockBaseVideoViewControllerListener).onFinish();
-    }
-
-    @Test
-    public void NativeFullScreenVideoView_ctaClickListener_shouldSetPlayWhenReadyToFalse_shouldHandleCtaClick() {
-        ArgumentCaptor<View.OnClickListener> captor = ArgumentCaptor.forClass(View.OnClickListener.class);
-        subject.onCreate();
-
-        verify(mockFullScreenVideoView).setCtaClickListener(captor.capture());
-        captor.getValue().onClick(null);
-
-        verify(mockVideoController).setPlayWhenReady(false);
-        verify(mockVideoController).handleCtaClick(activity);
-        verify(mockBaseVideoViewControllerListener, never()).onFinish();
-    }
-
-    @Test
-    public void NativeFullScreenVideoView_privacyInformationIconClickListener_shouldSetPlayWhenReadyToFalse_shouldOpenInAppBrowser() {
-        ArgumentCaptor<View.OnClickListener> captor = ArgumentCaptor.forClass(View.OnClickListener.class);
-
-        subject.onCreate();
-
-        verify(mockFullScreenVideoView).setPrivacyInformationClickListener(captor.capture());
-        captor.getValue().onClick(null);
-
-        verify(mockVideoController).setPlayWhenReady(false);
-
-        final Intent startedActivity = ShadowApplication.getInstance().peekNextStartedActivity();
-        assertThat(startedActivity.getComponent().getClassName())
-                .isEqualTo(MoPubBrowser.class.getName());
-        assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY))
-                .isEqualTo(MoPubVideoNativeAd.PRIVACY_INFORMATION_CLICKTHROUGH_URL);
-        verify(mockBaseVideoViewControllerListener, never()).onFinish();
-    }
-
-    @Test
-    public void NativeVideoController_progressListener_shouldUpdateFullScreenVideoProgress() {
-        ArgumentCaptor<ProgressListener> captor = ArgumentCaptor.forClass(ProgressListener.class);
-
-        subject.onCreate();
-
-        verify(mockVideoController).setProgressListener(captor.capture());
-        captor.getValue().updateProgress(10);
-
-        verify(mockFullScreenVideoView).updateProgress(10);
-        verify(mockBaseVideoViewControllerListener, never()).onFinish();
-    }
-
-    @Test
-    public void onResume_shouldPrepareNativeVideoController_shouldSetListeners() {
-        subject.onResume();
-
-        verify(mockVideoController).prepare(subject);
-        verify(mockVideoController).setListener(subject);
-        verify(mockVideoController).setOnAudioFocusChangeListener(subject);
-        verifyNoMoreInteractions(mockBaseVideoViewControllerListener);
-    }
-
-    @Test
-    public void onConfigurationChanged_shouldSetOrientationOfFullScreenVideoView() {
-        Configuration configuration = new Configuration();
-        configuration.orientation = Configuration.ORIENTATION_LANDSCAPE;
-        subject.onConfigurationChanged(configuration);
-
-        verify(mockFullScreenVideoView).setOrientation(Configuration.ORIENTATION_LANDSCAPE);
-        verifyNoMoreInteractions(mockBaseVideoViewControllerListener);
-    }
-
-    @Test
-    public void onBackPressed_shouldApplyStatePaused_shouldNotDisableAppAudio() throws Exception {
-        subject.onBackPressed();
-
-        assertThat(subject.getVideoState()).isEqualTo(VideoState.PAUSED);
-        verify(mockVideoController, never()).setAppAudioEnabled(false);
-    }
-
-    @Test
-    public void onSurfaceTexutureAvailable_shouldSetTextureView_shouldSeekToLastPosition_shouldSetPlayWhenReadyTrue() {
-        TextureView textureView = mock(TextureView.class);
-        when(mockFullScreenVideoView.getTextureView()).thenReturn(textureView);
-        when(mockVideoController.getCurrentPosition()).thenReturn(321L);
-
-        subject.onSurfaceTextureAvailable(null, 0, 0);
-
-        verify(mockVideoController).setTextureView(textureView);
-        verify(mockVideoController).seekTo(321L);
-        verify(mockVideoController).setPlayWhenReady(true);
-        verifyNoMoreInteractions(mockBaseVideoViewControllerListener);
-    }
-
-    @Test
-    public void onSurfaceTextureDestroyed_shouldReleaseVideoController_shouldApplyStatePaused() {
-        subject.onSurfaceTextureDestroyed(null);
-
-        verify(mockVideoController).release(subject);
-        assertThat(subject.getVideoState()).isEqualTo(VideoState.PAUSED);
-        verifyNoMoreInteractions(mockBaseVideoViewControllerListener);
-    }
-
-    @Test
-    public void onStateChanged_shouldAppropriatelySetVideoState() {
-        subject.onStateChanged(true, NativeVideoController.STATE_PREPARING);
-        assertThat(subject.getVideoState()).isEqualTo(VideoState.LOADING);
-
-        subject.onStateChanged(true, NativeVideoController.STATE_IDLE);
-        assertThat(subject.getVideoState()).isEqualTo(VideoState.LOADING);
-
-        subject.onStateChanged(true, NativeVideoController.STATE_BUFFERING);
-        assertThat(subject.getVideoState()).isEqualTo(VideoState.BUFFERING);
-
-        subject.onStateChanged(true, NativeVideoController.STATE_READY);
-        assertThat(subject.getVideoState()).isEqualTo(VideoState.PLAYING);
-
-        subject.onStateChanged(true, NativeVideoController.STATE_ENDED);
-        assertThat(subject.getVideoState()).isEqualTo(VideoState.ENDED);
-
-        subject.onStateChanged(true, NativeVideoController.STATE_CLEARED);
-        assertThat(subject.getVideoState()).isEqualTo(VideoState.ENDED);
-        verifyNoMoreInteractions(mockBaseVideoViewControllerListener);
-    }
-
-    @Test
-    public void onError_shouldAppropriatelySetVideoState() {
-        subject.onError(new Exception());
-        assertThat(subject.getVideoState()).isEqualTo(VideoState.FAILED_LOAD);
-        verifyNoMoreInteractions(mockBaseVideoViewControllerListener);
-    }
-
-    @Test
-    public void onAudioFocusChange_withFocusChangeAudioFocusLossOrAudioFocusLossTransient_shouldPauseVideo() throws Exception {
-        subject.onAudioFocusChange(AudioManager.AUDIOFOCUS_LOSS);
-
-        assertThat(subject.getVideoState()).isEqualTo(VideoState.PAUSED);
-    }
-
-    @Test
-    public void onAudioFocusChange_withFocusChangeAudioFocusLossTransientCanDuck_shouldLowerVolume() throws Exception {
-        subject.onAudioFocusChange(AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK);
-
-        verify(mockVideoController).setAudioVolume(0.3f);
-    }
-
-    @Test
-    public void onAudioFocusChange_withFocusChangeAudioFocusGain_shouldRaiseVolume() throws Exception {
-        subject.onAudioFocusChange(AudioManager.AUDIOFOCUS_GAIN);
-
-        verify(mockVideoController).setAudioVolume(1.0f);
-    }
-
-    @Test
-    public void applyState_withVideoStateFailedLoad_shouldSetPlayWhenReadyFalse_shouldSetAudioEnabledFalse_shouldSetAppAudioEnabledFalse_shouldSetModeLoading_shouldHandleError() {
-        subject.applyState(VideoState.FAILED_LOAD);
-        verify(mockVideoController).setPlayWhenReady(false);
-        verify(mockVideoController).setAudioEnabled(false);
-        verify(mockVideoController).setAppAudioEnabled(false);
-        verify(mockFullScreenVideoView).setMode(Mode.LOADING);
-        verify(mockVastVideoConfig).handleError(activity, null, 0);
-        verifyNoMoreInteractions(mockBaseVideoViewControllerListener);
-    }
-
-    @Test
-    public void applyState_withVideoStateLoadingOrBuffering_shouldSetPlayWhenReadyTrue_shouldSetModeLoading() {
-        subject.applyState(VideoState.LOADING);
-        verify(mockVideoController).setPlayWhenReady(true);
-        verify(mockFullScreenVideoView).setMode(Mode.LOADING);
-
-        reset(mockVideoController);
-        reset(mockFullScreenVideoView);
-
-        subject.applyState(VideoState.BUFFERING);
-        verify(mockVideoController).setPlayWhenReady(true);
-        verify(mockFullScreenVideoView).setMode(Mode.LOADING);
-        verifyNoMoreInteractions(mockBaseVideoViewControllerListener);
-    }
-
-    @Test
-    public void applyState_withVideoStatePlaying_shouldSetPlayWhenReadyTrue_shouldSetAudioEnabled_shouldSetAppAudioEnabled_shouldSetModePlaying() {
-        subject.applyState(VideoState.PLAYING);
-        verify(mockVideoController).setPlayWhenReady(true);
-        verify(mockVideoController).setAudioEnabled(true);
-        verify(mockVideoController).setAppAudioEnabled(true);
-        verify(mockFullScreenVideoView).setMode(Mode.PLAYING);
-        verifyNoMoreInteractions(mockBaseVideoViewControllerListener);
-    }
-
-    @Test
-    public void applyState_withVideoStatePaused_shouldSetAppAudioEnabledFalse_shouldSetPlayWhenReadyFalse_shouldSetModePaused() {
-        subject.applyState(VideoState.PAUSED);
-        verify(mockVideoController).setAppAudioEnabled(false);
-        verify(mockVideoController).setPlayWhenReady(false);
-        verify(mockFullScreenVideoView).setMode(Mode.PAUSED);
-        verifyNoMoreInteractions(mockBaseVideoViewControllerListener);
-    }
-
-    @Test
-    public void applyState_withVideoStateEnded_shuoldSetAppAudioEnabledFalse_shouldUpdateProgress_shouldSetModeFinished() {
-        subject.applyState(VideoState.ENDED);
-        verify(mockVideoController).setAppAudioEnabled(false);
-        verify(mockFullScreenVideoView).updateProgress(1000);
-        verify(mockFullScreenVideoView).setMode(Mode.FINISHED);
-        verify(mockVastVideoConfig).handleComplete(activity, 0);
-        verifyNoMoreInteractions(mockBaseVideoViewControllerListener);
-    }
-}
