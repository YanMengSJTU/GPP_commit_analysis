diff --git a/.gradle/1.11/taskArtifacts/cache.properties.lock b/.gradle/1.11/taskArtifacts/cache.properties.lock
index 633ce226..54c9106d 100644
Binary files a/.gradle/1.11/taskArtifacts/cache.properties.lock and b/.gradle/1.11/taskArtifacts/cache.properties.lock differ
diff --git a/.gradle/1.11/taskArtifacts/fileHashes.bin b/.gradle/1.11/taskArtifacts/fileHashes.bin
index 7c718c8a..bcef7228 100644
Binary files a/.gradle/1.11/taskArtifacts/fileHashes.bin and b/.gradle/1.11/taskArtifacts/fileHashes.bin differ
diff --git a/.gradle/1.11/taskArtifacts/fileSnapshots.bin b/.gradle/1.11/taskArtifacts/fileSnapshots.bin
index 95bb9183..0d88be5f 100644
Binary files a/.gradle/1.11/taskArtifacts/fileSnapshots.bin and b/.gradle/1.11/taskArtifacts/fileSnapshots.bin differ
diff --git a/.gradle/1.11/taskArtifacts/outputFileStates.bin b/.gradle/1.11/taskArtifacts/outputFileStates.bin
index 0f66ab8a..eb978cd0 100644
Binary files a/.gradle/1.11/taskArtifacts/outputFileStates.bin and b/.gradle/1.11/taskArtifacts/outputFileStates.bin differ
diff --git a/.gradle/1.11/taskArtifacts/taskArtifacts.bin b/.gradle/1.11/taskArtifacts/taskArtifacts.bin
index 89a1daee..0240725d 100644
Binary files a/.gradle/1.11/taskArtifacts/taskArtifacts.bin and b/.gradle/1.11/taskArtifacts/taskArtifacts.bin differ
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 998ce32f..e43855f7 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,24 @@
+## Version 2.0 (Apr 22, 2014)
+
+  - **Native Ads** public release; integration instructions and documentation available on the [GitHub wiki](https://github.com/mopub/mopub-android-sdk/wiki/Native-Ads-Integration)
+  - Changed minimum supported Android version to Froyo (Android 2.2, API level 8)
+  - Added support for Google Play Services advertising identifier
+  - Renamed the `com.mopub.mobileads.MraidBrowser` Activity to `com.mopub.common.MoPubBrowser`.
+      - **Important Note:** This change requires a modification to the `AndroidManifest`. The updated set of requisite activity permissions are as follows:
+      
+      	```      	      	
+    <activity android:name="com.mopub.common.MoPubBrowser"
+			android:configChanges="keyboardHidden|orientation"/>
+    <activity android:name="com.mopub.mobileads.MoPubActivity"
+                android:configChanges="keyboardHidden|orientation"/>
+    <activity android:name="com.mopub.mobileads.MraidActivity"
+                android:configChanges="keyboardHidden|
+	<activity android:name="com.mopub.mobileads.MraidVideoPlayerActivity"
+                android:configChanges="keyboardHidden|orientation"/>
+		```  
+  - Upgraded the bundled `android-support-v4` library to r19.1.
+      - **Note for Maven users:** Newer versions of the `android-support-v4` artifact are unavailable on Maven central, so we have included a small script to update the version in your local artifact repository. Please navigate to the `mopub-sdk` directory, and run `scripts/mavenize_support_library`.
+
 ## Version 1.17 (Nov 20, 2013)
 
   - Support for VAST 2.0 video playback via MoPub Marketplace
diff --git a/README.md b/README.md
index 1fa7062d..f12adfc4 100644
--- a/README.md
+++ b/README.md
@@ -27,14 +27,28 @@ Integration instructions are available on the [wiki](https://github.com/mopub/mo
 
 Please view the [changelog](https://github.com/mopub/mopub-android-sdk/blob/master/CHANGELOG.md) for details.
 
-  - Bug fixes
-
-### Changes to InMobi Custom Event Integrations
-**Important**: As of version 1.17.2.0, the InMobi custom events packaged with the MoPub SDK only support InMobi version 4.0.3 and up. Follow the instructions [here](https://www.inmobi.com/support/integration/23817448/22051163/android-sdk-integration-guide/) to integrate InMobi version 4.0.3 and up. If you would like to continue to use a prior version of the InMobi SDK, do not update the custom event files and follow the instructions [here](https://www.inmobi.com/support/art/23806682/22095493/mopub-adaptor-android-sdk-integration-guide/) to integrate.
+  - **Native Ads** public release; integration instructions and documentation available on the [GitHub wiki](https://github.com/mopub/mopub-android-sdk/wiki/Native-Ads-Integration)
+  - Changed minimum supported Android version to Froyo (Android 2.2, API level 8)
+  - Added support for Google Play Services advertising identifier
+  - Renamed the `com.mopub.mobileads.MraidBrowser` Activity to `com.mopub.common.MoPubBrowser`.
+       - **Important Note:** This change requires a modification to the `AndroidManifest`. The updated set of requisite activity permissions are as follows:
+      
+      	```      	      	
+    <activity android:name="com.mopub.common.MoPubBrowser"
+				android:configChanges="keyboardHidden|orientation"/>
+    <activity android:name="com.mopub.mobileads.MoPubActivity"
+            	android:configChanges="keyboardHidden|orientation"/>
+    <activity android:name="com.mopub.mobileads.MraidActivity"
+            	android:configChanges="keyboardHidden|orientation"/>
+	<activity android:name="com.mopub.mobileads.MraidVideoPlayerActivity"
+            	android:configChanges="keyboardHidden|orientation"/>
+		```  
+  - Upgraded the bundled `android-support-v4` library to r19.1.
+      - **Note for Maven users:** Newer versions of the `android-support-v4` artifact are unavailable on Maven central, so we have included a small script to update the version in your local artifact repository. Please navigate to the `mopub-sdk` directory, and run `scripts/mavenize_support_library`.
 
 ## Requirements
 
-Android 1.6 and up
+Android 2.2 and up
 
 ## License
 
diff --git a/extras/src/com/mopub/mobileads/GoogleAdMobBanner.java b/extras/src/com/mopub/mobileads/GoogleAdMobBanner.java
index 7b0b5b1d..c3a2e31d 100644
--- a/extras/src/com/mopub/mobileads/GoogleAdMobBanner.java
+++ b/extras/src/com/mopub/mobileads/GoogleAdMobBanner.java
@@ -42,7 +42,7 @@
 import com.google.ads.AdRequest.ErrorCode;
 import com.google.ads.AdSize;
 import com.google.ads.AdView;
-import com.mopub.mobileads.util.Views;
+import com.mopub.common.util.Views;
 
 import java.util.*;
 
diff --git a/extras/src/com/mopub/mobileads/GooglePlayServicesBanner.java b/extras/src/com/mopub/mobileads/GooglePlayServicesBanner.java
index 0a511e0a..d844536f 100644
--- a/extras/src/com/mopub/mobileads/GooglePlayServicesBanner.java
+++ b/extras/src/com/mopub/mobileads/GooglePlayServicesBanner.java
@@ -5,7 +5,7 @@
 
 import java.util.Map;
 
-import com.mopub.mobileads.util.Views;
+import com.mopub.common.util.Views;
 
 import com.google.android.gms.ads.*;
 
diff --git a/extras/src/com/mopub/mobileads/InMobiBanner.java b/extras/src/com/mopub/mobileads/InMobiBanner.java
index f1248a91..0cfaaad0 100644
--- a/extras/src/com/mopub/mobileads/InMobiBanner.java
+++ b/extras/src/com/mopub/mobileads/InMobiBanner.java
@@ -10,7 +10,7 @@
 import com.mopub.mobileads.CustomEventBanner;
 import com.mopub.mobileads.MoPub;
 import com.mopub.mobileads.MoPubErrorCode;
-import com.mopub.mobileads.util.Views;
+import com.mopub.common.util.Views;
 
 import java.util.*;
 
diff --git a/mopub-sample/AndroidManifest.xml b/mopub-sample/AndroidManifest.xml
index 10b3793c..9ee197b6 100644
--- a/mopub-sample/AndroidManifest.xml
+++ b/mopub-sample/AndroidManifest.xml
@@ -3,7 +3,7 @@
       package="com.mopub.simpleadsdemo"
       android:versionCode="1"
       android:versionName="1.0">
-    <uses-sdk android:minSdkVersion="4" />
+    <uses-sdk android:minSdkVersion="8" />
 
     <uses-permission android:name="android.permission.INTERNET" />
     <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
@@ -15,7 +15,8 @@
     <application android:icon="@drawable/icon" android:label="@string/app_name"
             android:debuggable="true">
 	    <activity android:name="com.mopub.simpleadsdemo.SimpleAdsDemo"
-	            android:label="@string/app_name" android:theme="@android:style/Theme.NoTitleBar" >
+	            android:label="@string/app_name" android:theme="@android:style/Theme.NoTitleBar"
+                android:configChanges="orientation">
 	        <intent-filter>
 	            <action android:name="android.intent.action.MAIN" />
 	            <category android:name="android.intent.category.LAUNCHER" />
@@ -25,13 +26,10 @@
                 android:configChanges="keyboardHidden|orientation"/>
         <activity android:name="com.mopub.mobileads.MraidActivity"
                 android:configChanges="keyboardHidden|orientation"/>
-        <activity android:name="com.mopub.mobileads.MraidBrowser"
+        <activity android:name="com.mopub.common.MoPubBrowser"
                 android:configChanges="keyboardHidden|orientation"/>
         <activity android:name="com.mopub.mobileads.MraidVideoPlayerActivity"
                 android:configChanges="keyboardHidden|orientation"/>
-        <activity android:name="com.mopub.simpleadsdemo.BannersTab" />
-        <activity android:name="com.mopub.simpleadsdemo.InterstitialsTab" />
-        <activity android:name="com.mopub.simpleadsdemo.AboutTab" />
     </application>
 
 </manifest>
diff --git a/mopub-sample/pom.xml b/mopub-sample/pom.xml
index dea0362c..1957cf8c 100644
--- a/mopub-sample/pom.xml
+++ b/mopub-sample/pom.xml
@@ -30,7 +30,6 @@
             <type>jar</type>
         </dependency>
 
-
         <!--test-->
 
         <dependency>
@@ -100,7 +99,7 @@
             <plugin>
                 <groupId>com.jayway.maven.plugins.android.generation2</groupId>
                 <artifactId>android-maven-plugin</artifactId>
-                <version>3.6.0</version>
+                <version>3.8.2</version>
                 <configuration>
                     <sdk>
                         <!-- platform or api level (api level 4 = platform 1.6)-->
diff --git a/mopub-sample/project.properties b/mopub-sample/project.properties
index e4abf810..41c4563e 100644
--- a/mopub-sample/project.properties
+++ b/mopub-sample/project.properties
@@ -11,4 +11,3 @@
 target=android-16
 android.library.reference.1=../mopub-sdk
 
-
diff --git a/mopub-sample/res/layout/empty_ad_row.xml b/mopub-sample/res/layout/empty_ad_row.xml
new file mode 100644
index 00000000..2266e491
--- /dev/null
+++ b/mopub-sample/res/layout/empty_ad_row.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:orientation="vertical"
+              android:layout_width="match_parent"
+              android:layout_height="0dp">
+</LinearLayout>
diff --git a/mopub-sample/res/layout/main.xml b/mopub-sample/res/layout/main.xml
index 5c0d3935..32870ba9 100644
--- a/mopub-sample/res/layout/main.xml
+++ b/mopub-sample/res/layout/main.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
-<TabHost xmlns:android="http://schemas.android.com/apk/res/android"
-    android:id="@android:id/tabhost"
+<android.support.v4.app.FragmentTabHost xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/tabhost"
     android:layout_width="fill_parent"
     android:layout_height="fill_parent">
     <LinearLayout
@@ -8,12 +8,13 @@
         android:layout_width="fill_parent"
         android:layout_height="fill_parent">
         <TabWidget
-            android:id="@android:id/tabs"
+            android:id="@+id/tabs"
             android:layout_width="fill_parent"
             android:layout_height="wrap_content" />
         <FrameLayout
-            android:id="@android:id/tabcontent"
+            android:id="@+id/tabcontent"
+            android:layout_marginTop="64dp"
             android:layout_width="fill_parent"
             android:layout_height="fill_parent"/>
     </LinearLayout>
-</TabHost>
+</android.support.v4.app.FragmentTabHost>
diff --git a/mopub-sample/res/layout/native_ad_row.xml b/mopub-sample/res/layout/native_ad_row.xml
new file mode 100644
index 00000000..663885a5
--- /dev/null
+++ b/mopub-sample/res/layout/native_ad_row.xml
@@ -0,0 +1,62 @@
+<RelativeLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/native_outer_view"
+    android:layout_width="fill_parent"
+    android:layout_height="wrap_content"
+    android:background="@android:color/white">
+    <ImageView android:id="@+id/native_icon_image"
+        android:layout_width="64dp"
+        android:layout_height="64dp"
+        android:background="#FFFFFF"
+        android:layout_alignParentLeft="true"
+        android:layout_alignParentTop="true"
+        android:layout_marginTop="10dp"
+        android:layout_marginLeft="10dp"
+        />
+
+    <TextView android:id="@+id/native_title"
+        android:layout_width="match_parent"
+        android:layout_marginLeft="84dp"
+        android:layout_marginTop="32dp"
+        android:layout_height="wrap_content"
+        android:layout_alignParentTop="true"
+        android:layout_alignParentLeft="true"
+        android:textColor="@android:color/darker_gray"
+        android:textStyle="bold" />
+
+    <TextView android:id="@+id/native_text"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_below="@+id/native_icon_image"
+        android:layout_alignParentLeft="true"
+        android:layout_marginLeft="10dp"
+        android:layout_marginTop="10dp"
+        android:textColor="@android:color/darker_gray" />
+
+
+    <ImageView android:id="@+id/native_main_image"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:adjustViewBounds="true"
+        android:layout_marginTop="10dp"
+        android:layout_below="@+id/native_text"
+        android:layout_alignParentLeft="true" />
+
+    <Button
+        android:id="@+id/native_cta"
+        android:layout_width="wrap_content"
+        android:layout_height="35dp"
+        android:text="Learn More"
+        android:textColor="@android:color/black"
+        android:onClick=""
+        android:textStyle="bold"
+        android:layout_marginRight="10dp"
+        android:layout_marginTop="10dp"
+        android:layout_below="@+id/native_main_image"
+        android:textSize="12dp"
+        android:layout_alignParentRight="true"
+        android:clickable="true"
+        android:paddingBottom="10dp" />
+
+</RelativeLayout>
+
diff --git a/mopub-sample/res/layout/nativetab.xml b/mopub-sample/res/layout/nativetab.xml
new file mode 100644
index 00000000..496b30f4
--- /dev/null
+++ b/mopub-sample/res/layout/nativetab.xml
@@ -0,0 +1,37 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:orientation="vertical" android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+    <LinearLayout
+        android:layout_width="fill_parent"
+        android:layout_height="wrap_content"
+        android:orientation="horizontal">
+
+        <EditText
+            android:id="@+id/native_adunit_field"
+            android:hint="Ad Unit ID for native ads"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="7"
+            android:inputType="text|textFilter|textShortMessage"
+            android:imeOptions="actionDone"
+            android:singleLine="true" />
+
+        <Button
+            android:id="@+id/native_load_button"
+            android:text="Load"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_weight="1" />
+
+
+    </LinearLayout>
+
+    <ListView
+        android:id="@+id/list_view"
+        android:layout_width="fill_parent"
+        android:layout_height="wrap_content"
+        android:padding="5dp"/>
+</LinearLayout>
diff --git a/mopub-sample/res/layout/text_row.xml b/mopub-sample/res/layout/text_row.xml
new file mode 100644
index 00000000..373f0ad2
--- /dev/null
+++ b/mopub-sample/res/layout/text_row.xml
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8"?>
+<TextView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/my_text_view"
+    android:layout_width="match_parent"
+    android:layout_height="75dp"
+    android:gravity="center_vertical"
+    android:padding="10dp"
+    />
\ No newline at end of file
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/AboutTab.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/AboutFragment.java
similarity index 81%
rename from mopub-sample/src/main/java/com/mopub/simpleadsdemo/AboutTab.java
rename to mopub-sample/src/main/java/com/mopub/simpleadsdemo/AboutFragment.java
index 4d5b6f09..43cae373 100644
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/AboutTab.java
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/AboutFragment.java
@@ -32,25 +32,35 @@
 
 package com.mopub.simpleadsdemo;
 
-import android.app.Activity;
 import android.content.Intent;
 import android.net.Uri;
 import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.view.LayoutInflater;
 import android.view.View;
 import android.view.View.OnClickListener;
+import android.view.ViewGroup;
 import android.widget.Button;
 
-public class AboutTab extends Activity {
+public class AboutFragment extends Fragment {
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
-        setContentView(R.layout.about);
+    }
+    
+    
+    public View onCreateView(LayoutInflater inflater, ViewGroup container,
+            Bundle savedInstanceState) {
+    	
+        View aboutTabView = inflater.inflate(R.layout.about, container, false);
 
-        Button mOpenSiteButton = (Button) findViewById(R.id.opensite);
+        Button mOpenSiteButton = (Button) aboutTabView.findViewById(R.id.opensite);
         mOpenSiteButton.setOnClickListener(new OnClickListener() {
             public void onClick(View v) {
                 startActivity(new Intent(android.content.Intent.ACTION_VIEW,
                         Uri.parse("http://www.mopub.com/")));
             }
         });
+        
+        return aboutTabView;
     }
 }
\ No newline at end of file
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/BannersTab.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/BannersFragment.java
similarity index 69%
rename from mopub-sample/src/main/java/com/mopub/simpleadsdemo/BannersTab.java
rename to mopub-sample/src/main/java/com/mopub/simpleadsdemo/BannersFragment.java
index 7b57fca9..2331a02d 100644
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/BannersTab.java
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/BannersFragment.java
@@ -32,10 +32,15 @@
 
 package com.mopub.simpleadsdemo;
 
-import android.app.Activity;
+import static com.mopub.simpleadsdemo.Utils.hideSoftKeyboard;
+import static com.mopub.simpleadsdemo.Utils.logToast;
+import static com.mopub.simpleadsdemo.Utils.validateAdUnitId;
 import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.view.LayoutInflater;
 import android.view.View;
 import android.view.View.OnClickListener;
+import android.view.ViewGroup;
 import android.widget.Button;
 import android.widget.EditText;
 
@@ -43,11 +48,7 @@
 import com.mopub.mobileads.MoPubView;
 import com.mopub.mobileads.MoPubView.BannerAdListener;
 
-import static com.mopub.simpleadsdemo.Utils.hideSoftKeyboard;
-import static com.mopub.simpleadsdemo.Utils.logToast;
-import static com.mopub.simpleadsdemo.Utils.validateAdUnitId;
-
-public class BannersTab extends Activity implements BannerAdListener {
+public class BannersFragment extends Fragment implements BannerAdListener {
     private MoPubView mBannerView;
     private EditText mBannerAdUnitField;
 
@@ -55,23 +56,39 @@
     private EditText mMrectAdUnitField;
 
     private EditText mKeywordsField;
-
+    
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
-        setContentView(R.layout.banners);
-
-        mBannerView = (MoPubView) findViewById(R.id.banner_view);
-        mBannerAdUnitField = (EditText) findViewById(R.id.banner_adunit_field);
+    }
+    
+    public View onCreateView(LayoutInflater inflater, ViewGroup container,
+            Bundle savedInstanceState) {
+    	
+        OnClickListener fieldFocusListener = new OnClickListener() {
+            public void onClick(View view) {
+            	view.requestFocusFromTouch();
+            }
+        };
+    	
+        View bannerTabView = inflater.inflate(R.layout.banners, container, false);
+        
+        mBannerView = (MoPubView) bannerTabView.findViewById(R.id.banner_view);
+        mBannerAdUnitField = (EditText) bannerTabView.findViewById(R.id.banner_adunit_field);
         hideSoftKeyboard(mBannerAdUnitField);
+        
+        mBannerAdUnitField.setOnClickListener(fieldFocusListener);
+
+        mMrectView = (MoPubView) bannerTabView.findViewById(R.id.mrect_view);
+        mMrectAdUnitField = (EditText) bannerTabView.findViewById(R.id.mrect_adunit_field);
+        
+        mMrectAdUnitField.setOnClickListener(fieldFocusListener);
 
-        mMrectView = (MoPubView) findViewById(R.id.mrect_view);
-        mMrectAdUnitField = (EditText) findViewById(R.id.mrect_adunit_field);
         hideSoftKeyboard(mMrectAdUnitField);
 
-        mKeywordsField = (EditText) findViewById(R.id.keywords_field);
+        mKeywordsField = (EditText) bannerTabView.findViewById(R.id.keywords_field);
         hideSoftKeyboard(mKeywordsField);
 
-        Button bannerLoadButton = (Button) findViewById(R.id.banner_load_button);
+        Button bannerLoadButton = (Button) bannerTabView.findViewById(R.id.banner_load_button);
         bannerLoadButton.setOnClickListener(new OnClickListener() {
             @Override
             public void onClick(View v) {
@@ -82,7 +99,7 @@ public void onClick(View v) {
             }
         });
 
-        Button mrectLoadButton = (Button) findViewById(R.id.mrect_load_button);
+        Button mrectLoadButton = (Button) bannerTabView.findViewById(R.id.mrect_load_button);
         mrectLoadButton.setOnClickListener(new OnClickListener() {
             @Override
             public void onClick(View v) {
@@ -92,10 +109,12 @@ public void onClick(View v) {
                 loadMoPubView(mMrectView, adUnitId, keywords);
             }
         });
+        
+        return bannerTabView;
     }
 
     @Override
-    protected void onDestroy() {
+	public void onDestroy() {
         if (mBannerView != null) {
             mBannerView.destroy();
         }
@@ -107,14 +126,14 @@ protected void onDestroy() {
 
     private void loadMoPubView(MoPubView moPubView, String adUnitId, String keywords) {
         if (moPubView == null) {
-            logToast(this, "Unable to inflate MoPubView from xml.");
+            logToast(getActivity(), "Unable to inflate MoPubView from xml.");
             return;
         }
 
         try {
             validateAdUnitId(adUnitId);
         } catch (IllegalArgumentException exception) {
-            logToast(BannersTab.this, exception.getMessage());
+            logToast(getActivity(), exception.getMessage());
             return;
         }
 
@@ -129,26 +148,26 @@ private void loadMoPubView(MoPubView moPubView, String adUnitId, String keywords
      */
     @Override
     public void onBannerLoaded(MoPubView moPubView) {
-        logToast(this, "Banner loaded callback.");
+        logToast(getActivity(), "Banner loaded callback.");
     }
 
     @Override
     public void onBannerFailed(MoPubView moPubView, MoPubErrorCode errorCode) {
-        logToast(this, "Banner failed callback with: " + errorCode.toString());
+        logToast(getActivity(), "Banner failed callback with: " + errorCode.toString());
     }
 
     @Override
     public void onBannerClicked(MoPubView moPubView) {
-        logToast(this, "Banner clicked callback.");
+        logToast(getActivity(), "Banner clicked callback.");
     }
 
     @Override
     public void onBannerExpanded(MoPubView moPubView) {
-        logToast(this, "Banner expanded callback.");
+        logToast(getActivity(), "Banner expanded callback.");
     }
 
     @Override
     public void onBannerCollapsed(MoPubView moPubView) {
-        logToast(this, "Banner collapsed callback.");
+        logToast(getActivity(), "Banner collapsed callback.");
     }
 }
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/InterstitialsTab.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/InterstitialFragment.java
similarity index 69%
rename from mopub-sample/src/main/java/com/mopub/simpleadsdemo/InterstitialsTab.java
rename to mopub-sample/src/main/java/com/mopub/simpleadsdemo/InterstitialFragment.java
index 6fef4064..38c895d0 100644
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/InterstitialsTab.java
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/InterstitialFragment.java
@@ -32,11 +32,15 @@
 
 package com.mopub.simpleadsdemo;
 
-import android.app.Activity;
+import static com.mopub.simpleadsdemo.Utils.hideSoftKeyboard;
+import static com.mopub.simpleadsdemo.Utils.logToast;
+import static com.mopub.simpleadsdemo.Utils.validateAdUnitId;
 import android.os.Bundle;
-import android.util.Log;
+import android.support.v4.app.Fragment;
+import android.view.LayoutInflater;
 import android.view.View;
 import android.view.View.OnClickListener;
+import android.view.ViewGroup;
 import android.widget.Button;
 import android.widget.EditText;
 
@@ -44,23 +48,30 @@
 import com.mopub.mobileads.MoPubInterstitial;
 import com.mopub.mobileads.MoPubInterstitial.InterstitialAdListener;
 
-import static com.mopub.simpleadsdemo.Utils.LOGTAG;
-import static com.mopub.simpleadsdemo.Utils.hideSoftKeyboard;
-import static com.mopub.simpleadsdemo.Utils.logToast;
-import static com.mopub.simpleadsdemo.Utils.validateAdUnitId;
-
-public class InterstitialsTab extends Activity implements InterstitialAdListener {
+public class InterstitialFragment extends Fragment implements InterstitialAdListener {
     private MoPubInterstitial mMoPubInterstitial;
     private EditText mInterstitialAdUnitField;
-
+    
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
-        setContentView(R.layout.interstitials);
-
-        mInterstitialAdUnitField = (EditText) findViewById(R.id.interstitials_edit_text_interstitial);
+    }
+    
+    public View onCreateView(LayoutInflater inflater, ViewGroup container,
+            Bundle savedInstanceState) {
+    	
+        View interstitialTabView = inflater.inflate(R.layout.interstitials, container, false);
+
+        OnClickListener fieldFocusListener = new OnClickListener() {
+            public void onClick(View view) {
+            	view.requestFocusFromTouch();
+            }
+        };
+       
+        mInterstitialAdUnitField = (EditText) interstitialTabView.findViewById(R.id.interstitials_edit_text_interstitial);
+        mInterstitialAdUnitField.setOnClickListener(fieldFocusListener);
         hideSoftKeyboard(mInterstitialAdUnitField);
 
-        Button interstitialLoadButton = (Button) findViewById(R.id.interstitials_load_interstitial);
+        Button interstitialLoadButton = (Button) interstitialTabView.findViewById(R.id.interstitials_load_interstitial);
         interstitialLoadButton.setOnClickListener(new OnClickListener() {
             public void onClick(View v) {
                 String adUnitId = mInterstitialAdUnitField.getText().toString();
@@ -68,33 +79,35 @@ public void onClick(View v) {
                 try {
                     validateAdUnitId(adUnitId);
 
-                    mMoPubInterstitial = new MoPubInterstitial(InterstitialsTab.this, adUnitId);
-                    mMoPubInterstitial.setInterstitialAdListener(InterstitialsTab.this);
+                    mMoPubInterstitial = new MoPubInterstitial(InterstitialFragment.this.getActivity(), adUnitId);
+                    mMoPubInterstitial.setInterstitialAdListener(InterstitialFragment.this);
                     mMoPubInterstitial.load();
                 } catch (IllegalArgumentException exception) {
                     String message = exception.getMessage();
 
                     if (message != null) {
-                        logToast(InterstitialsTab.this, message);
+                        logToast(InterstitialFragment.this.getActivity(), message);
                     }
                 }
             }
         });
         
-        Button interstitialShowButton = (Button) findViewById(R.id.interstitials_show_interstitial);
+        Button interstitialShowButton = (Button) interstitialTabView.findViewById(R.id.interstitials_show_interstitial);
         interstitialShowButton.setOnClickListener(new OnClickListener() {
             public void onClick(View v) {
                 if (mMoPubInterstitial != null && mMoPubInterstitial.isReady()) {
                     mMoPubInterstitial.show();
                 } else {
-                    logToast(InterstitialsTab.this, "Interstitial was not ready. Try reloading.");
+                    logToast(InterstitialFragment.this.getActivity(), "Interstitial was not ready. Try reloading.");
                 }
             }
         });
+        
+        return interstitialTabView;
     }
 
     @Override
-    protected void onDestroy() {
+    public void onDestroy() {
         if (mMoPubInterstitial != null) {
             mMoPubInterstitial.destroy();
         }
@@ -106,26 +119,26 @@ protected void onDestroy() {
      */
     @Override
     public void onInterstitialLoaded(MoPubInterstitial interstitial) {
-        logToast(this, "Interstitial loaded successfully.");
+        logToast(getActivity(), "Interstitial loaded successfully.");
     }
 
     @Override
     public void onInterstitialFailed(MoPubInterstitial interstitial, MoPubErrorCode errorCode) {
-        logToast(this, "Interstitial failed to load with error: " + errorCode.toString());
+        logToast(getActivity(), "Interstitial failed to load with error: " + errorCode.toString());
     }
 
     @Override
     public void onInterstitialShown(MoPubInterstitial interstitial) {
-        logToast(this, "Interstitial shown.");
+        logToast(getActivity(), "Interstitial shown.");
     }
 
     @Override
     public void onInterstitialClicked(MoPubInterstitial interstitial) {
-        logToast(this, "Interstitial clicked.");
+        logToast(getActivity(), "Interstitial clicked.");
     }
 
     @Override
     public void onInterstitialDismissed(MoPubInterstitial interstitial) {
-        logToast(this, "Interstitial dismissed.");
+        logToast(getActivity(), "Interstitial dismissed.");
     }
 }
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeAdapter.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeAdapter.java
new file mode 100644
index 00000000..a281b289
--- /dev/null
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeAdapter.java
@@ -0,0 +1,210 @@
+package com.mopub.simpleadsdemo;
+
+import android.content.Context;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.BaseAdapter;
+import android.widget.TextView;
+
+import com.mopub.nativeads.AdapterHelper;
+import com.mopub.nativeads.NativeResponse;
+import com.mopub.nativeads.ViewBinder;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Queue;
+
+import static com.mopub.nativeads.MoPubNative.MoPubNativeListener;
+import static com.mopub.simpleadsdemo.NativeFragment.MoPubNativeConsumptionListener;
+
+final class NativeAdapter extends BaseAdapter {
+    private static final int NUMBER_OF_ROWS = 100;
+    private static final int NATIVE_AD_START_POSITION = 10;
+    private static final int NATIVE_AD_REPEAT = 7;
+    private static final int CONTENT_LAYOUT = R.layout.text_row;
+
+    private final Context mContext;
+
+    // Listener to notify the activity of ad events
+    private final MoPubNativeListener mMoPubNativeListener;
+
+    // Specific listener to notify the activity when a native response has been consumed
+    // from the mNativeResponses queue
+    // This lets the activity request another native ad to replenish its supply
+    private final MoPubNativeConsumptionListener mMoPubNativeConsumptionListener;
+
+    // Binds native ad view ids to fields expected from the native response
+    private final ViewBinder mViewBinder;
+
+    // Helps with calculating native ad positions in the list and populating views with
+    // native response content
+    private final AdapterHelper mAdapterHelper;
+
+    // Sample content to be displayed in the list
+    private final List<String> mBackingList;
+
+    // Queue of native responses retrieved from the network and ready to be displayed in the app
+    private final Queue<NativeResponse> mNativeResponses;
+
+    // Mapping of native responses to position in the list where they have been displayed
+    private final HashMap<Integer, Object> mPositionToResponse;
+
+    private enum RowType {
+        CONTENT(0),
+        NATIVE_AD(1),
+        EMPTY_AD(2);
+
+        private static final int size = values().length;
+        private final int id;
+
+        private RowType(int id) {
+            this.id = id;
+        }
+    }
+
+    NativeAdapter(final Context context,
+            final MoPubNativeListener moPubNativeListener,
+            final MoPubNativeConsumptionListener moPubNativeConsumptionListener,
+            final ViewBinder viewBinder) {
+        super();
+
+        mContext = context.getApplicationContext();
+        mMoPubNativeListener = moPubNativeListener;
+        mMoPubNativeConsumptionListener = moPubNativeConsumptionListener;
+        mViewBinder = viewBinder;
+
+        mAdapterHelper = new AdapterHelper(context, NATIVE_AD_START_POSITION, NATIVE_AD_REPEAT);
+        mBackingList = createBackingList(NUMBER_OF_ROWS);
+
+        mNativeResponses = new LinkedList<NativeResponse>();
+        mPositionToResponse = new HashMap<Integer, Object>();
+    }
+
+    @Override
+    public int getCount() {
+        return mAdapterHelper.shiftedCount(NUMBER_OF_ROWS);
+    }
+
+    @Override
+    public String getItem(int position) {
+        return mBackingList.get(mAdapterHelper.shiftedPosition(position));
+    }
+
+    @Override
+    public long getItemId(int position) {
+        return 0;
+    }
+
+    @Override
+    public int getViewTypeCount() {
+        return RowType.size;
+    }
+
+    @Override
+    public int getItemViewType(int position) {
+        if (mAdapterHelper.isAdPosition(position)) {
+            Object nativeResponse = mPositionToResponse.get(position);
+
+            // If we have a native response already assigned to this position in the list then
+            // we can use it again
+            if (nativeResponse instanceof NativeResponse) {
+                return RowType.NATIVE_AD.id;
+
+            // If object is null it implies that this position in the list has yet to be assigned
+            // as a native response or empty response
+            // If we have a native response ready to be shown in the queue, then assign this
+            // position in the list a native response
+            } else if (nativeResponse == null && !mNativeResponses.isEmpty()) {
+                return RowType.NATIVE_AD.id;
+
+            // If we get here it means that the position in the list was either already an
+            // empty response or we didn't have a native response ready to show
+            } else {
+                return RowType.EMPTY_AD.id;
+            }
+        } else {
+            return RowType.CONTENT.id;
+        }
+    }
+
+    @Override
+    public View getView(int position, View convertView, ViewGroup parent) {
+        int itemViewType = getItemViewType(position);
+        if (itemViewType == RowType.NATIVE_AD.id) {
+            return getNativeAdView(position, convertView, parent);
+        } else if (itemViewType == RowType.EMPTY_AD.id) {
+            return getEmptyAdView(position, convertView, parent);
+        } else {
+            return getContentView(position, convertView, parent);
+        }
+    }
+
+    private View getNativeAdView(int position, View convertView, ViewGroup parent) {
+        // Check to see if we have a native response already used at this position
+        Object nativeResponse = mPositionToResponse.get(position);
+        if (nativeResponse == null) {
+
+            // If we don't then get a native response from the queue and assign it to this position
+            // in the LruCache
+            nativeResponse = mNativeResponses.poll();
+            mPositionToResponse.put(position, nativeResponse);
+
+            // Notify the activity that we consumed a native response from the queue so it can
+            // fetch another one
+            mMoPubNativeConsumptionListener
+                    .onNativeResponseConsumed((NativeResponse) nativeResponse);
+        }
+
+        View view = mAdapterHelper.getAdView(
+                convertView,
+                parent,
+                (NativeResponse) nativeResponse,
+                mViewBinder,
+                mMoPubNativeListener);
+
+        return view;
+    }
+
+    private View getEmptyAdView(int position, View convertView, ViewGroup parent) {
+        // Use a linear layout with height of 0 to display nothing for this row
+        if (convertView == null) {
+            convertView = LayoutInflater
+                    .from(mContext)
+                    .inflate(R.layout.empty_ad_row, parent, false);
+        }
+        mPositionToResponse.put(position, new EmptyNativeResponse());
+        return convertView;
+    }
+
+    private View getContentView(int position, View convertView, ViewGroup parent) {
+        // Display app content
+        if (convertView == null) {
+            convertView = LayoutInflater.from(mContext).inflate(CONTENT_LAYOUT, parent, false);
+        }
+
+        TextView label = (TextView) convertView.findViewById(R.id.my_text_view);
+        label.setText(getItem(position));
+
+        return convertView;
+    }
+
+    public void addNativeResponse(NativeResponse nativeResponse) {
+        // Add more native responses to the queue to be displayed in the app
+        mNativeResponses.add(nativeResponse);
+    }
+
+    private List<String> createBackingList(int numberOfRows) {
+        // Create sample content
+        List<String> list = new ArrayList<String>(numberOfRows);
+        for (int i = 0; i < numberOfRows; i++) {
+            list.add(String.valueOf(i));
+        }
+        return list;
+    }
+
+    // Empty class to denote an empty ad view in the list
+    private static final class EmptyNativeResponse {}
+}
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeFragment.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeFragment.java
new file mode 100644
index 00000000..d957da7c
--- /dev/null
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeFragment.java
@@ -0,0 +1,218 @@
+/*
+ * Copyright (c) 2010-2013, MoPub Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *  Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in the
+ *   documentation and/or other materials provided with the distribution.
+ *
+ *  Neither the name of 'MoPub Inc.' nor the names of its contributors
+ *   may be used to endorse or promote products derived from this software
+ *   without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.mopub.simpleadsdemo;
+
+import android.location.Location;
+import android.os.Bundle;
+import android.os.Handler;
+import android.support.v4.app.Fragment;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.Button;
+import android.widget.EditText;
+import android.widget.ListView;
+
+import com.mopub.nativeads.MoPubNative;
+import com.mopub.nativeads.NativeErrorCode;
+import com.mopub.nativeads.NativeResponse;
+import com.mopub.nativeads.RequestParameters;
+import com.mopub.nativeads.ViewBinder;
+
+import static com.mopub.nativeads.MoPubNative.MoPubNativeListener;
+import static com.mopub.nativeads.util.Utils.MoPubLog;
+import static com.mopub.simpleadsdemo.Utils.hideSoftKeyboard;
+import static com.mopub.simpleadsdemo.Utils.logToast;
+
+public final class NativeFragment extends Fragment {
+    private static final int NATIVE_AD_INITIALIZATION_COUNT = 3;
+
+    private final MyMoPubNativeListener mMyMoPubNativeListener;
+    private final MyMoPubNativeConsumptionListener mMyMoPubNativeConsumptionListener;
+
+    private ListView mListView;
+    private MoPubNative mMoPubNative;
+    private EditText mNativeAdUnitField;
+
+    private ViewBinder mViewBinder;
+    private NativeAdapter mNativeAdapter;
+
+    public NativeFragment() {
+        super();
+        mMyMoPubNativeListener = new MyMoPubNativeListener();
+        mMyMoPubNativeConsumptionListener = new MyMoPubNativeConsumptionListener();
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState); }
+
+    public View onCreateView(LayoutInflater inflater, ViewGroup container,
+                 Bundle savedInstanceState) {
+
+        View nativeFragmentView = inflater.inflate(R.layout.nativetab, container, false);
+
+        mListView = (ListView) nativeFragmentView.findViewById(R.id.list_view);
+
+        View.OnClickListener fieldFocusListener = new View.OnClickListener() {
+            public void onClick(View view) {
+                view.requestFocusFromTouch();
+            }
+        };
+
+        mNativeAdUnitField = (EditText) nativeFragmentView.findViewById(R.id.native_adunit_field);
+        hideSoftKeyboard(mNativeAdUnitField);
+
+        mNativeAdUnitField.setOnClickListener(fieldFocusListener);
+
+        mViewBinder = new ViewBinder.Builder(R.layout.native_ad_row)
+                .titleId(R.id.native_title)
+                .textId(R.id.native_text)
+                .callToActionId(R.id.native_cta)
+                .mainImageId(R.id.native_main_image)
+                .iconImageId(R.id.native_icon_image)
+                .build();
+
+        Button nativeLoadButton = (Button) nativeFragmentView.findViewById(R.id.native_load_button);
+        nativeLoadButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                String adUnitId = mNativeAdUnitField.getText().toString();
+
+                // Destory old native ad if it exists
+                if(mMoPubNative != null) {
+                    mMoPubNative.destroy();
+                }
+
+                mMoPubNative = new MoPubNative(getActivity(), adUnitId, mMyMoPubNativeListener);
+
+                // Initialize activity with a number of native ads ready to show
+                for (int i=0; i < NATIVE_AD_INITIALIZATION_COUNT; ++i) {
+                    requestNativeAd();
+                }
+
+                mNativeAdapter = new NativeAdapter(
+                        getActivity(),
+                        mMyMoPubNativeListener,
+                        mMyMoPubNativeConsumptionListener,
+                        mViewBinder
+                );
+
+                mListView.setAdapter(mNativeAdapter);
+
+                logToast(getActivity(), "Loaded new native ad unit");
+            }
+        });
+
+        return nativeFragmentView;
+    }
+
+    private void requestNativeAd() {
+        Location exampleLocation = new Location("example");
+        exampleLocation.setLatitude(23.1);
+        exampleLocation.setLongitude(42.1);
+        exampleLocation.setAccuracy(100);
+
+        RequestParameters requestParameters = new RequestParameters.Builder()
+                .keywords("key:value")
+                .location(exampleLocation)
+                .build();
+
+        mMoPubNative.makeRequest(requestParameters);
+    }
+
+    private final class MyMoPubNativeListener implements MoPubNativeListener {
+        private static final int EMPTY_RESPONSE_DELAY_MS = 30000; // 30 seconds
+        private Handler mHandler;
+        private Runnable mRunnable;
+
+        public MyMoPubNativeListener() {
+            mHandler = new Handler();
+            mRunnable = new Runnable() {
+                @Override
+                public void run() {
+                    requestNativeAd();
+                }
+            };
+        }
+
+        @Override
+        public void onNativeLoad(final NativeResponse nativeResponse) {
+            MoPubLog("MoPubNativeListener: Load!, NativeResponse: " + nativeResponse.toString());
+
+            // When we have a valid response, let the adapter manage when it will be shown
+            mNativeAdapter.addNativeResponse(nativeResponse);
+        }
+
+        @Override
+        public void onNativeFail(final NativeErrorCode errorCode) {
+            MoPubLog("MoPubNativeListener: Fail!, NativeErrorCode: " + errorCode.toString());
+            switch (errorCode) {
+                case INVALID_REQUEST_URL:
+                    // Invalid url, don't try to request again
+                    break;
+                case CONNECTION_ERROR:
+                    // Data connection was lost, activity should start requesting ads again
+                    // when the data connection is regained
+                    break;
+                default:
+                    // For any other error, wait 30 seconds before trying again
+                    mHandler.postDelayed(mRunnable, EMPTY_RESPONSE_DELAY_MS);
+                    break;
+            }
+        }
+
+        @Override
+        public void onNativeImpression(final View view) {
+            MoPubLog("MoPubNativeListener: Impression!, View: " + view.toString());
+        }
+
+        @Override
+        public void onNativeClick(final View view) {
+            MoPubLog("MoPubNativeListener: Click!, View: " + view.toString());
+        }
+    }
+
+    public static interface MoPubNativeConsumptionListener {
+        public void onNativeResponseConsumed(NativeResponse nativeResponse);
+    }
+
+    private final class MyMoPubNativeConsumptionListener implements MoPubNativeConsumptionListener {
+        @Override
+        public void onNativeResponseConsumed(NativeResponse nativeResponse) {
+            // Native ad was displayed in the app, request a new one to always
+            // have ads ready to display
+            requestNativeAd();
+        }
+    }
+}
diff --git a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/SimpleAdsDemo.java b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/SimpleAdsDemo.java
index 111d66f6..c81aebf4 100644
--- a/mopub-sample/src/main/java/com/mopub/simpleadsdemo/SimpleAdsDemo.java
+++ b/mopub-sample/src/main/java/com/mopub/simpleadsdemo/SimpleAdsDemo.java
@@ -1,67 +1,64 @@
 /*
- * Copyright (c) 2010-2013, MoPub Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *  Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- *  Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- *  Neither the name of 'MoPub Inc.' nor the names of its contributors
- *   may be used to endorse or promote products derived from this software
- *   without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
+* Copyright (c) 2010-2013, MoPub Inc.
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are
+* met:
+*
+*  Redistributions of source code must retain the above copyright
+*   notice, this list of conditions and the following disclaimer.
+*
+*  Redistributions in binary form must reproduce the above copyright
+*   notice, this list of conditions and the following disclaimer in the
+*   documentation and/or other materials provided with the distribution.
+*
+*  Neither the name of 'MoPub Inc.' nor the names of its contributors
+*   may be used to endorse or promote products derived from this software
+*   without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+* TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+* PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+* PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
 
 package com.mopub.simpleadsdemo;
 
-import android.app.TabActivity;
-import android.content.Intent;
 import android.os.Bundle;
-import android.widget.TabHost;
+import android.support.v4.app.FragmentActivity;
+import android.support.v4.app.FragmentTabHost;
 
 import com.mopub.mobileads.MoPubConversionTracker;
 
-public class SimpleAdsDemo extends TabActivity {
+public class SimpleAdsDemo extends FragmentActivity {
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.main);
 
-        TabHost tabHost = getTabHost();
-        TabHost.TabSpec spec;
+        FragmentTabHost mTabHost = (FragmentTabHost)findViewById(R.id.tabhost);
+        mTabHost.setup(this, getSupportFragmentManager(), R.id.tabcontent);
 
-        spec = tabHost.newTabSpec("banners")
-                .setIndicator("Banners")
-                .setContent(new Intent().setClass(this, BannersTab.class));
-        tabHost.addTab(spec);
+        mTabHost.addTab(mTabHost.newTabSpec("banners").setIndicator("Banners"),
+                BannersFragment.class, null);
 
-        spec = tabHost.newTabSpec("interstitials")
-                .setIndicator("Full")
-                .setContent(new Intent().setClass(this, InterstitialsTab.class));
-        tabHost.addTab(spec);
+        mTabHost.addTab(mTabHost.newTabSpec("interstitials").setIndicator("Full"),
+        		InterstitialFragment.class, null);
+
+        mTabHost.addTab(mTabHost.newTabSpec("native").setIndicator("Native"),
+                NativeFragment.class, null);
+        
+        mTabHost.addTab(mTabHost.newTabSpec("about").setIndicator("About"),
+        		AboutFragment.class, null);
 
-        spec = tabHost.newTabSpec("about")
-                .setIndicator("About")
-                .setContent(new Intent().setClass(this, AboutTab.class));
-        tabHost.addTab(spec);
 
         // Conversion tracking
         new MoPubConversionTracker().reportAppOpen(this);
diff --git a/mopub-sdk/AndroidManifest.xml b/mopub-sdk/AndroidManifest.xml
new file mode 100644
index 00000000..91419b01
--- /dev/null
+++ b/mopub-sdk/AndroidManifest.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+		package="com.mopub.mobileads"
+		android:versionCode="1"
+		android:versionName="1.0">
+	<uses-sdk android:minSdkVersion="8"/>
+</manifest>
\ No newline at end of file
diff --git a/mopub-sdk/build/bundles/debug/classes.jar b/mopub-sdk/build/bundles/debug/classes.jar
index 71b0bc60..98597219 100644
Binary files a/mopub-sdk/build/bundles/debug/classes.jar and b/mopub-sdk/build/bundles/debug/classes.jar differ
diff --git a/mopub-sdk/build/bundles/release/classes.jar b/mopub-sdk/build/bundles/release/classes.jar
index 4d8b0658..9aa487ed 100644
Binary files a/mopub-sdk/build/bundles/release/classes.jar and b/mopub-sdk/build/bundles/release/classes.jar differ
diff --git a/mopub-sdk/build/libs/mopub-sdk.aar b/mopub-sdk/build/libs/mopub-sdk.aar
index a8f88532..eff0d35d 100644
Binary files a/mopub-sdk/build/libs/mopub-sdk.aar and b/mopub-sdk/build/libs/mopub-sdk.aar differ
diff --git a/mopub-sdk/libs/android-support-v4.jar b/mopub-sdk/libs/android-support-v4.jar
new file mode 100644
index 00000000..187bdf48
Binary files /dev/null and b/mopub-sdk/libs/android-support-v4.jar differ
diff --git a/mopub-sdk/pom.xml b/mopub-sdk/pom.xml
new file mode 100644
index 00000000..c5ab0d21
--- /dev/null
+++ b/mopub-sdk/pom.xml
@@ -0,0 +1,137 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.sonatype.oss</groupId>
+        <artifactId>oss-parent</artifactId>
+        <version>5</version>
+    </parent>
+
+    <groupId>com.mopub.mobileads</groupId>
+    <artifactId>mopub-sdk</artifactId>
+    <version>1.0.0-SNAPSHOT</version>
+    <packaging>jar</packaging>
+    <name>MoPub SDK</name>
+    <description>The SDK for MoPub developers.</description>
+
+    <properties>
+        <robolectric.version>2.1</robolectric.version>
+    </properties>
+
+    <dependencies>
+
+        <!--main-->
+        <dependency>
+            <groupId>com.google.android</groupId>
+            <artifactId>support-v4</artifactId>
+            <version>r19.1</version>
+        </dependency>
+
+        <!--test-->
+        <dependency>
+            <groupId>org.apache.httpcomponents</groupId>
+            <artifactId>httpclient</artifactId>
+            <version>4.0.3</version>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>org.apache.httpcomponents</groupId>
+            <artifactId>httpcore</artifactId>
+            <version>4.0.1</version>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>com.squareup</groupId>
+            <artifactId>fest-android</artifactId>
+            <version>1.0.1</version>
+            <scope>test</scope>
+        </dependency>
+
+        <!-- this needs to come above fest-reflect or we pick up the wrong org.fest.util.Strings -->
+        <dependency>
+            <groupId>org.easytesting</groupId>
+            <artifactId>fest-assert-core</artifactId>
+            <version>2.0M9</version>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>org.easytesting</groupId>
+            <artifactId>fest-reflect</artifactId>
+            <version>1.4</version>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <version>4.8.2</version>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>org.mockito</groupId>
+            <artifactId>mockito-core</artifactId>
+            <version>1.9.5</version>
+            <scope>test</scope>
+        </dependency>
+
+        <!--android & robolectric-->
+        <dependency>
+            <groupId>org.robolectric</groupId>
+            <artifactId>robolectric</artifactId>
+            <version>${robolectric.version}</version>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>com.google.android</groupId>
+            <artifactId>android</artifactId>
+            <version>4.1.2</version>
+            <scope>provided</scope>
+        </dependency>
+    </dependencies>
+
+    <build>
+        <finalName>${project.artifactId}</finalName>
+
+        <plugins>
+            <plugin>
+                <artifactId>maven-compiler-plugin</artifactId>
+                <version>2.3.2</version>
+                <configuration>
+                    <source>1.6</source>
+                    <target>1.6</target>
+                </configuration>
+            </plugin>
+            <plugin>
+                <groupId>com.jayway.maven.plugins.android.generation2</groupId>
+                <artifactId>android-maven-plugin</artifactId>
+                <version>3.8.2</version>
+                <configuration>
+                    <sdk>
+                        <!-- platform or api level (api level 4 = platform 1.6)-->
+                        <platform>16</platform>
+                    </sdk>
+                    <undeployBeforeDeploy>true</undeployBeforeDeploy>
+                </configuration>
+                <extensions>true</extensions>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-surefire-plugin</artifactId>
+                <version>2.6</version>
+                <configuration>
+                    <argLine>-Xms512m -Xmx1024m -XX:MaxPermSize=256m</argLine>
+                    <excludes>
+                        <exclude>**/Test*.java</exclude>
+                    </excludes>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+</project>
diff --git a/mopub-sdk/scripts/mavenize_support_library b/mopub-sdk/scripts/mavenize_support_library
new file mode 100755
index 00000000..619dfff7
--- /dev/null
+++ b/mopub-sdk/scripts/mavenize_support_library
@@ -0,0 +1,3 @@
+#!/bin/sh
+mvn install:install-file -DgroupId=com.google.android -DartifactId=support-v4 -Dversion=r19.1 -Dpackaging=jar -Dfile=libs/android-support-v4.jar
+
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdUrlGenerator.java b/mopub-sdk/src/main/java/com/mopub/common/AdUrlGenerator.java
similarity index 61%
rename from mopub-sdk/src/main/java/com/mopub/mobileads/AdUrlGenerator.java
rename to mopub-sdk/src/main/java/com/mopub/common/AdUrlGenerator.java
index ade41ac9..7852fd5e 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdUrlGenerator.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/AdUrlGenerator.java
@@ -30,31 +30,31 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package com.mopub.mobileads;
+package com.mopub.common;
 
 import android.content.Context;
 import android.content.res.Configuration;
 import android.location.Location;
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
-import android.os.Build;
 import android.telephony.TelephonyManager;
-import com.mopub.mobileads.util.DateAndTime;
 
-import java.lang.reflect.Method;
+import com.mopub.common.util.DateAndTime;
+import com.mopub.common.util.IntentUtils;
+
 import java.text.SimpleDateFormat;
 
 import static android.Manifest.permission.ACCESS_NETWORK_STATE;
 import static android.content.pm.PackageManager.PERMISSION_GRANTED;
-import static android.net.ConnectivityManager.TYPE_WIFI;
 import static android.net.ConnectivityManager.TYPE_MOBILE;
-import static com.mopub.mobileads.AdUrlGenerator.MoPubNetworkType.ETHERNET;
-import static com.mopub.mobileads.AdUrlGenerator.MoPubNetworkType.MOBILE;
-import static com.mopub.mobileads.AdUrlGenerator.MoPubNetworkType.UNKNOWN;
-import static com.mopub.mobileads.AdUrlGenerator.MoPubNetworkType.WIFI;
-import static com.mopub.mobileads.util.Mraids.isStorePictureSupported;
+import static android.net.ConnectivityManager.TYPE_WIFI;
+import static com.mopub.common.AdUrlGenerator.MoPubNetworkType.ETHERNET;
+import static com.mopub.common.AdUrlGenerator.MoPubNetworkType.MOBILE;
+import static com.mopub.common.AdUrlGenerator.MoPubNetworkType.UNKNOWN;
+import static com.mopub.common.AdUrlGenerator.MoPubNetworkType.WIFI;
 
-public class AdUrlGenerator extends BaseUrlGenerator {
+public abstract class AdUrlGenerator extends BaseUrlGenerator {
+    private static TwitterAppInstalledStatus sTwitterAppInstalledStatus = TwitterAppInstalledStatus.UNKNOWN;
     public static final String DEVICE_ORIENTATION_PORTRAIT = "p";
     public static final String DEVICE_ORIENTATION_LANDSCAPE = "l";
     public static final String DEVICE_ORIENTATION_SQUARE = "s";
@@ -68,22 +68,20 @@
     public static final int TYPE_MOBILE_MMS = 0x2;
     public static final int TYPE_MOBILE_SUPL = 0x3;
 
+    protected Context mContext;
+    protected TelephonyManager mTelephonyManager;
+    protected ConnectivityManager mConnectivityManager;
+    protected String mAdUnitId;
+    protected String mKeywords;
+    protected Location mLocation;
+    protected boolean mFacebookSupportEnabled;
+
     public static enum TwitterAppInstalledStatus {
         UNKNOWN,
         NOT_INSTALLED,
         INSTALLED,
     }
 
-    private static TwitterAppInstalledStatus sTwitterAppInstalledStatus = TwitterAppInstalledStatus.UNKNOWN;
-
-    private Context mContext;
-    private TelephonyManager mTelephonyManager;
-    private ConnectivityManager mConnectivityManager;
-    private String mAdUnitId;
-    private String mKeywords;
-    private Location mLocation;
-    private boolean mFacebookSupportEnabled;
-
     public static enum MoPubNetworkType {
         UNKNOWN,
         ETHERNET,
@@ -122,89 +120,30 @@ public AdUrlGenerator withLocation(Location location) {
         return this;
     }
 
-    @Override
-    public String generateUrlString(String serverHostname) {
-        initUrlString(serverHostname, MoPubView.AD_HANDLER);
-
-        setApiVersion("6");
-
-        setAdUnitId(mAdUnitId);
-
-        setSdkVersion(MoPub.SDK_VERSION);
-
-        setDeviceInfo(Build.MANUFACTURER, Build.MODEL, Build.PRODUCT);
-
-        setUdid(getUdidFromContext(mContext));
-
-        String keywords = AdUrlGenerator.addKeyword(mKeywords, AdUrlGenerator.getFacebookKeyword(mContext, mFacebookSupportEnabled));
-        setKeywords(keywords);
-
-        setLocation(mLocation);
-
-        setTimezone(AdUrlGenerator.getTimeZoneOffsetString());
-
-        setOrientation(mContext.getResources().getConfiguration().orientation);
-
-        setDensity(mContext.getResources().getDisplayMetrics().density);
-
-        setMraidFlag(detectIsMraidSupported());
-
-        String networkOperator = getNetworkOperator();
-        setMccCode(networkOperator);
-        setMncCode(networkOperator);
-
-        setIsoCountryCode(mTelephonyManager.getNetworkCountryIso());
-        setCarrierName(mTelephonyManager.getNetworkOperatorName());
-
-        setNetworkType(getActiveNetworkType());
-
-        setAppVersion(getAppVersionFromContext(mContext));
-
-        setExternalStoragePermission(isStorePictureSupported(mContext));
-
-        setTwitterAppInstalledFlag();
-
-        return getFinalUrlString();
-    }
-
-    private void setTwitterAppInstalledFlag() {
-        if (sTwitterAppInstalledStatus == TwitterAppInstalledStatus.UNKNOWN) {
-            sTwitterAppInstalledStatus = getTwitterAppInstallStatus();
-        }
-
-        if (sTwitterAppInstalledStatus == TwitterAppInstalledStatus.INSTALLED) {
-            addParam("ts", "1");
-        }
-    }
-
-    TwitterAppInstalledStatus getTwitterAppInstallStatus() {
-        return Utils.canHandleTwitterUrl(mContext) ? TwitterAppInstalledStatus.INSTALLED : TwitterAppInstalledStatus.NOT_INSTALLED;
-    }
-
-    private void setAdUnitId(String adUnitId) {
+    protected void setAdUnitId(String adUnitId) {
         addParam("id", adUnitId);
     }
 
-    private void setSdkVersion(String sdkVersion) {
+    protected void setSdkVersion(String sdkVersion) {
         addParam("nv", sdkVersion);
     }
 
-    private void setKeywords(String keywords) {
+    protected void setKeywords(String keywords) {
         addParam("q", keywords);
     }
 
-    private void setLocation(Location location) {
+    protected void setLocation(Location location) {
         if (location != null) {
             addParam("ll", location.getLatitude() + "," + location.getLongitude());
             addParam("lla", "" + (int) location.getAccuracy());
         }
     }
 
-    private void setTimezone(String timeZoneOffsetString) {
+    protected void setTimezone(String timeZoneOffsetString) {
         addParam("z", timeZoneOffsetString);
     }
 
-    private void setOrientation(int orientation) {
+    protected void setOrientation(int orientation) {
         String orString = DEVICE_ORIENTATION_UNKNOWN;
         if (orientation == Configuration.ORIENTATION_PORTRAIT) {
             orString = DEVICE_ORIENTATION_PORTRAIT;
@@ -216,33 +155,33 @@ private void setOrientation(int orientation) {
         addParam("o", orString);
     }
 
-    private void setDensity(float density) {
+    protected void setDensity(float density) {
         addParam("sc_a", "" + density);
     }
 
-    private void setMraidFlag(boolean mraid) {
+    protected void setMraidFlag(boolean mraid) {
         if (mraid) addParam("mr", "1");
     }
 
-    private void setMccCode(String networkOperator) {
+    protected void setMccCode(String networkOperator) {
         String mcc = networkOperator == null ? "" : networkOperator.substring(0, mncPortionLength(networkOperator));
         addParam("mcc", mcc);
     }
 
-    private void setMncCode(String networkOperator) {
+    protected void setMncCode(String networkOperator) {
         String mnc = networkOperator == null ? "" : networkOperator.substring(mncPortionLength(networkOperator));
         addParam("mnc", mnc);
     }
 
-    private void setIsoCountryCode(String networkCountryIso) {
+    protected void setIsoCountryCode(String networkCountryIso) {
         addParam("iso", networkCountryIso);
     }
 
-    private void setCarrierName(String networkOperatorName) {
+    protected void setCarrierName(String networkOperatorName) {
         addParam("cn", networkOperatorName);
     }
 
-    private void setNetworkType(int type) {
+    protected void setNetworkType(int type) {
         switch(type) {
             case TYPE_ETHERNET:
                 addParam("ct", ETHERNET);
@@ -265,18 +204,7 @@ private void setNetworkType(int type) {
     private void addParam(String key, MoPubNetworkType value) {
         addParam(key, value.toString());
     }
-
-    private boolean detectIsMraidSupported() {
-        boolean mraid = true;
-        try {
-            Class.forName("com.mopub.mobileads.MraidView");
-        } catch (ClassNotFoundException e) {
-            mraid = false;
-        }
-        return mraid;
-    }
-
-    private String getNetworkOperator() {
+    protected String getNetworkOperator() {
         String networkOperator = mTelephonyManager.getNetworkOperator();
         if (mTelephonyManager.getPhoneType() == TelephonyManager.PHONE_TYPE_CDMA &&
                 mTelephonyManager.getSimState() == TelephonyManager.SIM_STATE_READY) {
@@ -289,28 +217,13 @@ private int mncPortionLength(String networkOperator) {
         return Math.min(3, networkOperator.length());
     }
 
-    private static String getTimeZoneOffsetString() {
+    protected static String getTimeZoneOffsetString() {
         SimpleDateFormat format = new SimpleDateFormat("Z");
         format.setTimeZone(DateAndTime.localTimeZone());
         return format.format(DateAndTime.now());
     }
 
-    private static String getFacebookKeyword(Context context, final boolean enabled) {
-        if (!enabled) {
-            return null;
-        }
-
-        try {
-            Class<?> facebookKeywordProviderClass = Class.forName("com.mopub.mobileads.FacebookKeywordProvider");
-            Method getKeywordMethod = facebookKeywordProviderClass.getMethod("getKeyword", Context.class);
-
-            return (String) getKeywordMethod.invoke(facebookKeywordProviderClass, context);
-        } catch (Exception exception) {
-            return null;
-        }
-    }
-
-    private int getActiveNetworkType() {
+    protected int getActiveNetworkType() {
         if (mContext.checkCallingOrSelfPermission(ACCESS_NETWORK_STATE) == PERMISSION_GRANTED) {
             NetworkInfo activeNetworkInfo = mConnectivityManager.getActiveNetworkInfo();
             return activeNetworkInfo != null ? activeNetworkInfo.getType() : TYPE_DUMMY;
@@ -318,18 +231,22 @@ private int getActiveNetworkType() {
         return TYPE_DUMMY;
     }
 
-    private static String addKeyword(String keywords, String addition) {
-        if (addition == null || addition.length() == 0) {
-            return keywords;
-        } else if (keywords == null || keywords.length() == 0) {
-            return addition;
-        } else {
-            return keywords + "," + addition;
+    protected void setTwitterAppInstalledFlag() {
+        if (sTwitterAppInstalledStatus == TwitterAppInstalledStatus.UNKNOWN) {
+            sTwitterAppInstalledStatus = getTwitterAppInstallStatus();
+        }
+
+        if (sTwitterAppInstalledStatus == TwitterAppInstalledStatus.INSTALLED) {
+            addParam("ts", "1");
         }
     }
 
+    public TwitterAppInstalledStatus getTwitterAppInstallStatus() {
+        return IntentUtils.canHandleTwitterUrl(mContext) ? TwitterAppInstalledStatus.INSTALLED : TwitterAppInstalledStatus.NOT_INSTALLED;
+    }
+
     @Deprecated // for testing
-    static void setTwitterAppInstalledStatus(TwitterAppInstalledStatus status) {
+    public static void setTwitterAppInstalledStatus(TwitterAppInstalledStatus status) {
         sTwitterAppInstalledStatus = status;
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseUrlGenerator.java b/mopub-sdk/src/main/java/com/mopub/common/BaseUrlGenerator.java
similarity index 80%
rename from mopub-sdk/src/main/java/com/mopub/mobileads/BaseUrlGenerator.java
rename to mopub-sdk/src/main/java/com/mopub/common/BaseUrlGenerator.java
index 0d31f3ec..9fec434f 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseUrlGenerator.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/BaseUrlGenerator.java
@@ -30,16 +30,21 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package com.mopub.mobileads;
+package com.mopub.common;
 
 import android.content.Context;
 import android.content.pm.PackageInfo;
 import android.net.Uri;
 import android.provider.Settings;
 
-import static com.mopub.mobileads.util.Strings.isEmpty;
+import com.mopub.common.util.Utils;
+
+import static com.mopub.common.util.Strings.isEmpty;
 
 public abstract class BaseUrlGenerator {
+    private static final String IFA_PREFIX = "ifa:";
+    private static final String SHA_PREFIX = "sha:";
+
     private StringBuilder mStringBuilder;
     private boolean mFirstParam;
 
@@ -99,9 +104,30 @@ protected void setDeviceInfo(String... info) {
         addParam("dn", result.toString());
     }
 
+    protected void setDoNotTrack(boolean dnt) {
+        if (dnt) {
+            addParam("dnt", "1");
+        }
+    }
+
     protected void setUdid(String udid) {
-        String udidDigest = (udid == null) ? "" : Utils.sha1(udid);
-        addParam("udid", "sha:" + udidDigest);
+        addParam("udid", udid);
+    }
+
+    protected String getUdidFromContext(Context context) {
+        /*
+         * try to use the android id from Google Play Services if available
+         * if not fall back on the device id
+         */
+        final String androidId = GpsHelper.getAdvertisingId(context);
+
+        if (androidId != null) {
+            return IFA_PREFIX + androidId;
+        } else {
+            String deviceId = Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID);
+            deviceId = (deviceId == null) ? "" : Utils.sha1(deviceId);
+            return SHA_PREFIX + deviceId;
+        }
     }
 
     protected String getAppVersionFromContext(Context context) {
@@ -113,8 +139,4 @@ protected String getAppVersionFromContext(Context context) {
             return null;
         }
     }
-
-    protected String getUdidFromContext(Context context) {
-        return Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID);
-    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/common/GpsHelper.java b/mopub-sdk/src/main/java/com/mopub/common/GpsHelper.java
new file mode 100644
index 00000000..d0e60f78
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/GpsHelper.java
@@ -0,0 +1,172 @@
+package com.mopub.common;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.util.Log;
+
+import com.mopub.common.factories.MethodBuilderFactory;
+
+import static com.mopub.common.util.Reflection.MethodBuilder;
+import static com.mopub.common.util.Reflection.classFound;
+import static com.mopub.mobileads.AdTypeTranslator.CustomEventType;
+import static com.mopub.mobileads.AdTypeTranslator.CustomEventType.ADMOB_BANNER;
+import static com.mopub.mobileads.AdTypeTranslator.CustomEventType.ADMOB_INTERSTITIAL;
+import static com.mopub.mobileads.AdTypeTranslator.CustomEventType.GOOGLE_PLAY_BANNER;
+import static com.mopub.mobileads.AdTypeTranslator.CustomEventType.GOOGLE_PLAY_INTERSTITIAL;
+
+public class GpsHelper {
+    static public final int GOOGLE_PLAY_SUCCESS_CODE = 0;
+    static public final String ADVERTISING_ID_KEY = "advertisingId";
+    static public final String IS_LIMIT_AD_TRACKING_ENABLED_KEY = "isLimitAdTrackingEnabled";
+    private static String sPlayServicesUtilClassName = "com.google.android.gms.common.GooglePlayServicesUtil";
+    private static String sAdvertisingIdClientClassName = "com.google.android.gms.ads.identifier.AdvertisingIdClient";
+
+    public interface GpsHelperListener {
+        public void onFetchAdInfoCompleted();
+    }
+
+    static public CustomEventType convertAdMobToGooglePlayServices(final Context context, final CustomEventType customEventType) {
+        // In both cases, only check if GooglePlayServices is available if absolutely necessary
+        if (customEventType == ADMOB_BANNER &&
+                classFound(GOOGLE_PLAY_BANNER.toString()) &&
+                isGpsAvailable(context)) {
+            return GOOGLE_PLAY_BANNER;
+        } else if (customEventType == ADMOB_INTERSTITIAL &&
+                classFound(GOOGLE_PLAY_INTERSTITIAL.toString()) &&
+                isGpsAvailable(context)) {
+            return GOOGLE_PLAY_INTERSTITIAL;
+        }
+
+        return customEventType;
+    }
+
+    static boolean isGpsAvailable(final Context context) {
+        try {
+            MethodBuilder methodBuilder = MethodBuilderFactory.create(null, "isGooglePlayServicesAvailable")
+                    .setStatic(Class.forName(sPlayServicesUtilClassName))
+                    .addParam(Context.class, context);
+
+            Object result = methodBuilder.execute();
+
+            return (result != null && (Integer) result == GOOGLE_PLAY_SUCCESS_CODE);
+        } catch (Exception exception) {
+            return false;
+        }
+    }
+
+    static String getAdvertisingId(final Context context) {
+        final String defaultValue = null;
+        if (isGpsAvailable(context)) {
+            return SharedPreferencesHelper.getSharedPreferences(context)
+                    .getString(ADVERTISING_ID_KEY, defaultValue);
+        } else {
+            return defaultValue;
+        }
+    }
+
+    static public boolean isLimitAdTrackingEnabled(Context context) {
+        final boolean defaultValue = false;
+        if (isGpsAvailable(context)) {
+            return SharedPreferencesHelper.getSharedPreferences(context)
+                    .getBoolean(IS_LIMIT_AD_TRACKING_ENABLED_KEY, defaultValue);
+        } else {
+            return defaultValue;
+        }
+    }
+
+    static boolean isSharedPreferencesPopluated(final Context context) {
+        SharedPreferences sharedPreferences = SharedPreferencesHelper.getSharedPreferences(context);
+        return sharedPreferences.contains(ADVERTISING_ID_KEY) &&
+                sharedPreferences.contains(IS_LIMIT_AD_TRACKING_ENABLED_KEY);
+    }
+
+    static public void asyncFetchAdvertisingInfoIfNotCached(final Context context, final GpsHelperListener gpsHelperListener) {
+        // This method guarantees that the Google Play Services (GPS) advertising info will
+        // be populated if GPS is available and the ad info is not already cached
+        // The above will happen before the callback is run
+        if (isGpsAvailable(context) && !isSharedPreferencesPopluated(context)) {
+            asyncFetchAdvertisingInfo(context, gpsHelperListener);
+        } else {
+            gpsHelperListener.onFetchAdInfoCompleted();
+        }
+    }
+
+    static public void asyncFetchAdvertisingInfo(final Context context) {
+        asyncFetchAdvertisingInfo(context, null);
+    }
+
+    static public void asyncFetchAdvertisingInfo(final Context context, final GpsHelperListener gpsHelperListener) {
+        if (!classFound(sAdvertisingIdClientClassName)) {
+            if (gpsHelperListener != null) {
+                gpsHelperListener.onFetchAdInfoCompleted();
+            }
+        }
+
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    MethodBuilder methodBuilder = MethodBuilderFactory.create(null, "getAdvertisingIdInfo")
+                            .setStatic(Class.forName(sAdvertisingIdClientClassName))
+                            .addParam(Context.class, context);
+
+                    Object adInfo = methodBuilder.execute();
+
+                    if (adInfo != null) {
+                        updateSharedPreferences(context, adInfo);
+                    }
+                } catch (Exception exception) {
+                    Log.d("MoPub", "Unable to obtain AdvertisingIdClient.getAdvertisingIdInfo()");
+                } finally {
+                    if (gpsHelperListener != null) {
+                        gpsHelperListener.onFetchAdInfoCompleted();
+                    }
+                }
+            }
+        }).start();
+    }
+
+    static void updateSharedPreferences(final Context context, final Object adInfo) {
+        String advertisingId = reflectedGetAdvertisingId(adInfo, null);
+        boolean isLimitAdTrackingEnabled = reflectedIsLimitAdTrackingEnabled(adInfo, false);
+
+        /*
+         * Committing using the editor is atomic; a single editor must always commit
+         * to ensure that the state of the GPS variables are in sync.
+         */
+
+        SharedPreferencesHelper.getSharedPreferences(context)
+                .edit()
+                .putString(ADVERTISING_ID_KEY, advertisingId)
+                .putBoolean(IS_LIMIT_AD_TRACKING_ENABLED_KEY, isLimitAdTrackingEnabled)
+                .commit();
+    }
+
+    static String reflectedGetAdvertisingId(final Object adInfo, final String defaultValue) {
+        try {
+            return (String) MethodBuilderFactory.create(adInfo, "getId").execute();
+        } catch (Exception exception) {
+            return defaultValue;
+        }
+    }
+
+    static boolean reflectedIsLimitAdTrackingEnabled(final Object adInfo, final boolean defaultValue) {
+        try {
+            Boolean result = (Boolean) MethodBuilderFactory.create(adInfo, "isLimitAdTrackingEnabled").execute();
+            return (result != null) ? result : defaultValue;
+        } catch (Exception exception) {
+            return defaultValue;
+        }
+    }
+
+    @Deprecated
+    static public void setClassNamesForTesting() {
+        // This method is used for testing only to help alleviate pain with testing
+        // unlinked libraries via reflection
+        // Set class names to something that is linked so Class.forName method doesn't throw
+        String className = "java.lang.Class";
+        sPlayServicesUtilClassName = className;
+        sAdvertisingIdClientClassName = className;
+    }
+}
+
diff --git a/mopub-sdk/src/main/java/com/mopub/common/LocationService.java b/mopub-sdk/src/main/java/com/mopub/common/LocationService.java
new file mode 100644
index 00000000..0c89cc6f
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/LocationService.java
@@ -0,0 +1,76 @@
+package com.mopub.common;
+
+import android.content.Context;
+import android.location.Location;
+import android.location.LocationManager;
+
+import java.math.BigDecimal;
+
+import static com.mopub.nativeads.util.Utils.MoPubLog;
+
+public class LocationService {
+    public static enum LocationAwareness { NORMAL, TRUNCATED, DISABLED };
+
+    /*
+     * Returns the last known location of the device using its GPS and network location providers.
+     * May be null if:
+     * - Location permissions are not requested in the Android manifest file
+     * - The location providers don't exist
+     * - Location awareness is disabled in the parent MoPubView
+     */
+    public static Location getLastKnownLocation(final Context context,
+                                                final int locationPrecision,
+                                                final LocationAwareness locationAwareness) {
+        Location result;
+
+        if (locationAwareness == LocationAwareness.DISABLED) {
+            return null;
+        }
+
+        LocationManager locationManager = (LocationManager) context.getSystemService(Context.LOCATION_SERVICE);
+        Location gpsLocation = null;
+        try {
+            gpsLocation = locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER);
+        } catch (SecurityException e) {
+            MoPubLog("Failed to retrieve GPS location: access appears to be disabled.");
+        } catch (IllegalArgumentException e) {
+            MoPubLog("Failed to retrieve GPS location: device has no GPS provider.");
+        }
+
+        Location networkLocation = null;
+        try {
+            networkLocation = locationManager.getLastKnownLocation(LocationManager.NETWORK_PROVIDER);
+        } catch (SecurityException e) {
+            MoPubLog("Failed to retrieve network location: access appears to be disabled.");
+        } catch (IllegalArgumentException e) {
+            MoPubLog("Failed to retrieve network location: device has no network provider.");
+        }
+
+        if (gpsLocation == null && networkLocation == null) {
+            return null;
+        }
+        else if (gpsLocation != null && networkLocation != null) {
+            if (gpsLocation.getTime() > networkLocation.getTime()) result = gpsLocation;
+            else result = networkLocation;
+        }
+        else if (gpsLocation != null) result = gpsLocation;
+        else result = networkLocation;
+
+        // Truncate latitude/longitude to the number of digits specified by locationPrecision.
+        if (locationAwareness == LocationAwareness.TRUNCATED) {
+            double lat = result.getLatitude();
+            double truncatedLat = BigDecimal.valueOf(lat)
+                    .setScale(locationPrecision, BigDecimal.ROUND_HALF_DOWN)
+                    .doubleValue();
+            result.setLatitude(truncatedLat);
+
+            double lon = result.getLongitude();
+            double truncatedLon = BigDecimal.valueOf(lon)
+                    .setScale(locationPrecision, BigDecimal.ROUND_HALF_DOWN)
+                    .doubleValue();
+            result.setLongitude(truncatedLon);
+        }
+
+        return result;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPub.java b/mopub-sdk/src/main/java/com/mopub/common/MoPub.java
similarity index 94%
rename from mopub-sdk/src/main/java/com/mopub/mobileads/MoPub.java
rename to mopub-sdk/src/main/java/com/mopub/common/MoPub.java
index 730bdfc1..e10626aa 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPub.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/MoPub.java
@@ -30,9 +30,9 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package com.mopub.mobileads;
+package com.mopub.common;
 
 public class MoPub {
-    public static final String SDK_VERSION = "1.17.3.1";
+    public static final String SDK_VERSION = "2.0";
 }
 
diff --git a/mopub-sdk/src/main/java/com/mopub/common/MoPubBrowser.java b/mopub-sdk/src/main/java/com/mopub/common/MoPubBrowser.java
new file mode 100644
index 00000000..8ead5409
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/MoPubBrowser.java
@@ -0,0 +1,241 @@
+package com.mopub.common;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.graphics.Bitmap;
+import android.graphics.Color;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.os.Bundle;
+import android.view.Gravity;
+import android.view.View;
+import android.view.Window;
+import android.webkit.CookieSyncManager;
+import android.webkit.WebChromeClient;
+import android.webkit.WebSettings;
+import android.webkit.WebView;
+import android.webkit.WebViewClient;
+import android.widget.ImageButton;
+import android.widget.LinearLayout;
+import android.widget.RelativeLayout;
+import android.widget.Toast;
+
+import com.mopub.nativeads.util.Utils;
+
+import static android.view.ViewGroup.LayoutParams.MATCH_PARENT;
+import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;
+import static com.mopub.common.util.Drawables.BACKGROUND;
+import static com.mopub.common.util.Drawables.CLOSE;
+import static com.mopub.common.util.Drawables.LEFT_ARROW;
+import static com.mopub.common.util.Drawables.REFRESH;
+import static com.mopub.common.util.Drawables.RIGHT_ARROW;
+import static com.mopub.common.util.Drawables.UNLEFT_ARROW;
+import static com.mopub.common.util.Drawables.UNRIGHT_ARROW;
+import static com.mopub.common.util.IntentUtils.deviceCanHandleIntent;
+import static com.mopub.common.util.IntentUtils.isDeepLink;
+
+public class MoPubBrowser extends Activity {
+    public static final String DESTINATION_URL_KEY = "URL";
+    private static final int INNER_LAYOUT_ID = 1;
+
+    private WebView mWebView;
+    private ImageButton mBackButton;
+    private ImageButton mForwardButton;
+    private ImageButton mRefreshButton;
+    private ImageButton mCloseButton;
+
+    public static void open(final Context context, final String url) {
+        Utils.MoPubLog("Opening url in MoPubBrowser: " + url);
+        final Intent intent = new Intent(context, MoPubBrowser.class);
+        intent.putExtra(DESTINATION_URL_KEY, url);
+        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        context.startActivity(intent);
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        getWindow().requestFeature(Window.FEATURE_PROGRESS);
+        getWindow().setFeatureInt(Window.FEATURE_PROGRESS, Window.PROGRESS_VISIBILITY_ON);
+
+        setContentView(getMoPubBrowserView());
+
+        initializeWebView();
+        initializeButtons();
+        enableCookies();
+    }
+
+    private void initializeWebView() {
+        WebSettings webSettings = mWebView.getSettings();
+
+        webSettings.setJavaScriptEnabled(true);
+
+        /**
+         * Pinch to zoom is apparently not enabled by default on all devices, so
+         * declare zoom support explicitly.
+         * http://stackoverflow.com/questions/5125851/enable-disable-zoom-in-android-webview
+         */
+        webSettings.setSupportZoom(true);
+        webSettings.setBuiltInZoomControls(true);
+        webSettings.setUseWideViewPort(true);
+
+        mWebView.loadUrl(getIntent().getStringExtra(DESTINATION_URL_KEY));
+        mWebView.setWebViewClient(new WebViewClient() {
+            @Override
+            public void onReceivedError(WebView view, int errorCode, String description,
+                    String failingUrl) {
+                Toast.makeText(MoPubBrowser.this, "MoPubBrowser error: " + description, Toast.LENGTH_SHORT).show();
+            }
+
+            @Override
+            public boolean shouldOverrideUrlLoading(WebView view, String url) {
+                if (url == null) {
+                    return false;
+                }
+
+                final Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
+                if (isDeepLink(url) && deviceCanHandleIntent(MoPubBrowser.this, intent)) {
+                    startActivity(intent);
+                    finish();
+                    return true;
+                } else {
+                    return false;
+                }
+            }
+
+            @Override
+            public void onPageStarted(WebView view, String url, Bitmap favicon) {
+                super.onPageStarted(view, url, favicon);
+                mForwardButton.setImageDrawable(UNRIGHT_ARROW.decodeImage(MoPubBrowser.this));
+            }
+
+            @Override
+            public void onPageFinished(WebView view, String url) {
+                super.onPageFinished(view, url);
+
+                Drawable backImageDrawable = view.canGoBack()
+                        ? LEFT_ARROW.decodeImage(MoPubBrowser.this)
+                        : UNLEFT_ARROW.decodeImage(MoPubBrowser.this);
+                mBackButton.setImageDrawable(backImageDrawable);
+
+                Drawable forwardImageDrawable = view.canGoForward()
+                        ? RIGHT_ARROW.decodeImage(MoPubBrowser.this)
+                        : UNRIGHT_ARROW.decodeImage(MoPubBrowser.this);
+                mForwardButton.setImageDrawable(forwardImageDrawable);
+            }
+        });
+
+        mWebView.setWebChromeClient(new WebChromeClient() {
+            public void onProgressChanged(WebView webView, int progress) {
+                setTitle("Loading...");
+                setProgress(progress * 100);
+                if (progress == 100) {
+                    setTitle(webView.getUrl());
+                }
+            }
+        });
+    }
+
+    private void initializeButtons() {
+        mBackButton.setBackgroundColor(Color.TRANSPARENT);
+        mBackButton.setOnClickListener(new View.OnClickListener() {
+            public void onClick(View v) {
+                if (mWebView.canGoBack()) {
+                    mWebView.goBack();
+                }
+            }
+        });
+
+        mForwardButton.setBackgroundColor(Color.TRANSPARENT);
+        mForwardButton.setOnClickListener(new View.OnClickListener() {
+            public void onClick(View v) {
+                if (mWebView.canGoForward()) {
+                    mWebView.goForward();
+                }
+            }
+        });
+
+        mRefreshButton.setBackgroundColor(Color.TRANSPARENT);
+        mRefreshButton.setOnClickListener(new View.OnClickListener() {
+            public void onClick(View v) {
+                mWebView.reload();
+            }
+        });
+
+        mCloseButton.setBackgroundColor(Color.TRANSPARENT);
+        mCloseButton.setOnClickListener(new View.OnClickListener() {
+            public void onClick(View v) {
+                MoPubBrowser.this.finish();
+            }
+        });
+    }
+
+    private void enableCookies() {
+        CookieSyncManager.createInstance(this);
+        CookieSyncManager.getInstance().startSync();
+    }
+
+    @Override
+    protected void onPause() {
+        super.onPause();
+        CookieSyncManager.getInstance().stopSync();
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        CookieSyncManager.getInstance().startSync();
+    }
+
+    private View getMoPubBrowserView() {
+        LinearLayout moPubBrowserView = new LinearLayout(this);
+        LinearLayout.LayoutParams browserLayoutParams = new LinearLayout.LayoutParams(MATCH_PARENT, MATCH_PARENT);
+        moPubBrowserView.setLayoutParams(browserLayoutParams);
+        moPubBrowserView.setOrientation(LinearLayout.VERTICAL);
+
+        RelativeLayout outerLayout = new RelativeLayout(this);
+        LinearLayout.LayoutParams outerLayoutParams = new LinearLayout.LayoutParams(MATCH_PARENT, WRAP_CONTENT);
+        outerLayout.setLayoutParams(outerLayoutParams);
+        moPubBrowserView.addView(outerLayout);
+
+        LinearLayout innerLayout = new LinearLayout(this);
+        innerLayout.setId(INNER_LAYOUT_ID);
+        RelativeLayout.LayoutParams innerLayoutParams = new RelativeLayout.LayoutParams(MATCH_PARENT, WRAP_CONTENT);
+        innerLayoutParams.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM);
+        innerLayout.setLayoutParams(innerLayoutParams);
+        innerLayout.setBackgroundDrawable(BACKGROUND.decodeImage(this));
+        outerLayout.addView(innerLayout);
+
+        mBackButton = getButton(LEFT_ARROW.decodeImage(this));
+        mForwardButton = getButton(RIGHT_ARROW.decodeImage(this));
+        mRefreshButton = getButton(REFRESH.decodeImage(this));
+        mCloseButton = getButton(CLOSE.decodeImage(this));
+
+        innerLayout.addView(mBackButton);
+        innerLayout.addView(mForwardButton);
+        innerLayout.addView(mRefreshButton);
+        innerLayout.addView(mCloseButton);
+
+        mWebView = new WebView(this);
+        RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(MATCH_PARENT, MATCH_PARENT);
+        layoutParams.addRule(RelativeLayout.ABOVE, INNER_LAYOUT_ID);
+        mWebView.setLayoutParams(layoutParams);
+        outerLayout.addView(mWebView);
+
+        return moPubBrowserView;
+    }
+
+    private ImageButton getButton(final Drawable drawable) {
+        ImageButton imageButton = new ImageButton(this);
+
+        LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(WRAP_CONTENT, WRAP_CONTENT, 1f);
+        layoutParams.gravity = Gravity.CENTER_VERTICAL;
+        imageButton.setLayoutParams(layoutParams);
+
+        imageButton.setImageDrawable(drawable);
+
+        return imageButton;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/SharedPreferencesHelper.java b/mopub-sdk/src/main/java/com/mopub/common/SharedPreferencesHelper.java
new file mode 100644
index 00000000..f6acc1d8
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/SharedPreferencesHelper.java
@@ -0,0 +1,16 @@
+package com.mopub.common;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+
+import static android.content.Context.MODE_PRIVATE;
+
+public final class SharedPreferencesHelper {
+    public static final String PREFERENCE_NAME = "mopubSettings";
+
+    private SharedPreferencesHelper() {}
+    
+    public static SharedPreferences getSharedPreferences(Context context) {
+    	return context.getSharedPreferences(PREFERENCE_NAME, MODE_PRIVATE);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/common/factories/MethodBuilderFactory.java b/mopub-sdk/src/main/java/com/mopub/common/factories/MethodBuilderFactory.java
new file mode 100644
index 00000000..0c008962
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/factories/MethodBuilderFactory.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2010-2013, MoPub Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *  Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in the
+ *   documentation and/or other materials provided with the distribution.
+ *
+ *  Neither the name of 'MoPub Inc.' nor the names of its contributors
+ *   may be used to endorse or promote products derived from this software
+ *   without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.mopub.common.factories;
+
+import static com.mopub.common.util.Reflection.MethodBuilder;
+
+public class MethodBuilderFactory {
+    protected static MethodBuilderFactory instance = new MethodBuilderFactory();
+
+    @Deprecated // for testing
+    public static void setInstance(MethodBuilderFactory factory) {
+        instance = factory;
+    }
+
+    public static MethodBuilder create(Object object, String methodName) {
+        return instance.internalCreate(object, methodName);
+    }
+
+    protected MethodBuilder internalCreate(Object object, String methodName) {
+        return new MethodBuilder(object, methodName);
+    }
+}
+
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/AsyncTasks.java b/mopub-sdk/src/main/java/com/mopub/common/util/AsyncTasks.java
new file mode 100644
index 00000000..4ee8b4be
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/AsyncTasks.java
@@ -0,0 +1,36 @@
+package com.mopub.common.util;
+
+import android.os.AsyncTask;
+
+import java.util.concurrent.Executor;
+
+import static com.mopub.common.util.Reflection.MethodBuilder;
+import static com.mopub.common.util.VersionCode.ICE_CREAM_SANDWICH;
+import static com.mopub.common.util.VersionCode.currentApiLevel;
+
+public class AsyncTasks {
+    /**
+     * Starting with ICS, default AsyncTask#execute behavior runs the tasks serially. This method
+     * attempts to force these AsyncTasks to run in parallel with a ThreadPoolExecutor, if possible.
+     */
+    public static <P> void safeExecuteOnExecutor(AsyncTask<P, ?, ?> asyncTask, P... params) {
+        if (asyncTask == null) {
+            throw new IllegalArgumentException("Unable to execute null AsyncTask.");
+        }
+
+        if (currentApiLevel().isAtLeast(ICE_CREAM_SANDWICH)) {
+            try {
+                Executor threadPoolExecutor = (Executor) AsyncTask.class.getField("THREAD_POOL_EXECUTOR").get(AsyncTask.class);
+
+                new MethodBuilder(asyncTask, "executeOnExecutor")
+                        .addParam(Executor.class, threadPoolExecutor)
+                        .addParam(Object[].class, params)
+                        .execute();
+            } catch (Exception e) {
+                asyncTask.execute(params);
+            }
+        } else {
+            asyncTask.execute(params);
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/DateAndTime.java b/mopub-sdk/src/main/java/com/mopub/common/util/DateAndTime.java
similarity index 96%
rename from mopub-sdk/src/main/java/com/mopub/mobileads/util/DateAndTime.java
rename to mopub-sdk/src/main/java/com/mopub/common/util/DateAndTime.java
index 0490fcc2..b4e0cbfd 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/DateAndTime.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/DateAndTime.java
@@ -30,9 +30,10 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package com.mopub.mobileads.util;
+package com.mopub.common.util;
 
-import java.util.*;
+import java.util.Date;
+import java.util.TimeZone;
 
 public class DateAndTime {
     protected static DateAndTime instance = new DateAndTime();
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/DeviceUtils.java b/mopub-sdk/src/main/java/com/mopub/common/util/DeviceUtils.java
new file mode 100644
index 00000000..07086308
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/DeviceUtils.java
@@ -0,0 +1,157 @@
+package com.mopub.common.util;
+
+import android.app.ActivityManager;
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+import android.os.StatFs;
+import android.provider.Settings;
+
+import org.apache.http.conn.util.InetAddressUtils;
+
+import java.io.File;
+import java.net.InetAddress;
+import java.net.NetworkInterface;
+import java.net.SocketException;
+
+import static android.Manifest.permission.ACCESS_NETWORK_STATE;
+import static android.Manifest.permission.INTERNET;
+import static com.mopub.common.util.Reflection.MethodBuilder;
+import static com.mopub.common.util.VersionCode.HONEYCOMB;
+import static com.mopub.common.util.VersionCode.currentApiLevel;
+import static com.mopub.nativeads.util.Utils.MoPubLog;
+import static java.util.Collections.list;
+
+public class DeviceUtils {
+    private static final int MAX_MEMORY_CACHE_SIZE = 30 * 1024 * 1024; // 30 MB
+    private static final int MIN_DISK_CACHE_SIZE = 30 * 1024 * 1024; // 30 MB
+    private static final int MAX_DISK_CACHE_SIZE = 100 * 1024 * 1024; // 100 MB
+
+    private DeviceUtils() {}
+
+    public static enum IP {
+        IPv4,
+        IPv6;
+
+        private boolean matches(final String address) {
+            switch (this) {
+                case IPv4:
+                    return InetAddressUtils.isIPv4Address(address);
+                case IPv6:
+                    return InetAddressUtils.isIPv6Address(address);
+                default:
+                    return false;
+            }
+        }
+
+        private String toString(final String address) {
+            switch (this) {
+                case IPv4:
+                    return address;
+                case IPv6:
+                    return address.split("%")[0];
+                default:
+                    return null;
+            }
+        }
+    }
+
+    public static String getIpAddress(IP ip) throws SocketException {
+        for (final NetworkInterface networkInterface : list(NetworkInterface.getNetworkInterfaces())) {
+            for (final InetAddress address : list(networkInterface.getInetAddresses())) {
+                if (!address.isLoopbackAddress()) {
+                    String hostAddress = address.getHostAddress().toUpperCase();
+                    if (ip.matches(hostAddress)) {
+                        return ip.toString(hostAddress);
+                    }
+                }
+            }
+        }
+
+        return null;
+    }
+
+    public static String getHashedUdid(final Context context) {
+        if (context == null) {
+            return null;
+        }
+
+        String udid = Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID);
+        return Utils.sha1(udid);
+    }
+
+    public static String getUserAgent() {
+        return System.getProperty("http.agent");
+    }
+
+    public static boolean isNetworkAvailable(final Context context) {
+        if (context == null) {
+            return false;
+        }
+
+        final int internetPermission = context.checkCallingOrSelfPermission(INTERNET);
+        if (internetPermission == PackageManager.PERMISSION_DENIED) {
+            return false;
+        }
+
+        /**
+         * This is only checking if we have permission to access the network state
+         * It's possible to not have permission to check network state but still be able
+         * to access the network itself.
+         */
+        final int networkAccessPermission = context.checkCallingOrSelfPermission(ACCESS_NETWORK_STATE);
+        if (networkAccessPermission == PackageManager.PERMISSION_DENIED) {
+            return true;
+        }
+
+        // Otherwise, perform the connectivity check.
+        try {
+            final ConnectivityManager connnectionManager =
+                    (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
+            final NetworkInfo networkInfo = connnectionManager.getActiveNetworkInfo();
+            return networkInfo.isConnected();
+        } catch (NullPointerException e) {
+            return false;
+        }
+    }
+
+    public static int memoryCacheSizeBytes(final Context context) {
+        final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
+        long memoryClass = activityManager.getMemoryClass();
+
+        if (currentApiLevel().isAtLeast(HONEYCOMB)) {
+            try {
+                final int flagLargeHeap = ApplicationInfo.class.getDeclaredField("FLAG_LARGE_HEAP").getInt(null);
+                if (bitmaskContainsFlag(context.getApplicationInfo().flags, flagLargeHeap)) {
+                    memoryClass = (Integer) new MethodBuilder(activityManager, "getLargeMemoryClass").execute();
+                }
+            } catch (Exception e) {
+                MoPubLog("Unable to reflectively determine large heap size on Honeycomb and above.");
+            }
+        }
+
+        long result = Math.min(MAX_MEMORY_CACHE_SIZE, memoryClass / 8 * 1024 * 1024);
+        return (int) result;
+    }
+
+    public static long diskCacheSizeBytes(File dir) {
+        long size = MIN_DISK_CACHE_SIZE;
+
+        try {
+            StatFs statFs = new StatFs(dir.getAbsolutePath());
+            long availableBytes = ((long) statFs.getBlockCount()) * statFs.getBlockSize();
+            size = availableBytes / 50;
+        } catch (IllegalArgumentException e) {
+            MoPubLog("Unable to calculate 2% of available disk space, defaulting to minimum");
+        }
+
+        // Bound inside min/max size for disk cache.
+        return Math.max(Math.min(size, MAX_DISK_CACHE_SIZE), MIN_DISK_CACHE_SIZE);
+    }
+
+    public static boolean bitmaskContainsFlag(final int bitmask, final int flag) {
+        return (bitmask & flag) != 0;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/Dips.java b/mopub-sdk/src/main/java/com/mopub/common/util/Dips.java
similarity index 98%
rename from mopub-sdk/src/main/java/com/mopub/mobileads/util/Dips.java
rename to mopub-sdk/src/main/java/com/mopub/common/util/Dips.java
index f472d585..6d2e0dbb 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/Dips.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Dips.java
@@ -30,7 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package com.mopub.mobileads.util;
+package com.mopub.common.util;
 
 import android.content.Context;
 import android.util.DisplayMetrics;
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/resource/Drawables.java b/mopub-sdk/src/main/java/com/mopub/common/util/Drawables.java
similarity index 98%
rename from mopub-sdk/src/main/java/com/mopub/mobileads/resource/Drawables.java
rename to mopub-sdk/src/main/java/com/mopub/common/util/Drawables.java
index 9dc8f31f..0fe32998 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/resource/Drawables.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Drawables.java
@@ -30,16 +30,17 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package com.mopub.mobileads.resource;
+package com.mopub.common.util;
 
 import android.content.Context;
 import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.util.Base64;
 import android.util.DisplayMetrics;
-import com.mopub.mobileads.util.Base64;
-import com.mopub.mobileads.util.Dips;
 
-import java.io.*;
+import com.mopub.common.util.Dips;
 
+import java.io.ByteArrayInputStream;
 
 public enum Drawables {
     BACKGROUND("iVBORw0KGgoAAAANSUhEUgAAAAEAAAAsCAIAAAArRUU2AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAEFJREFUeNpicPP0Zvr3/z/T/3//gDQQg+i//5j+gum/QBqIQXwg+x+YjckH6fkL0/f3NwMPHz8jKxsbAw0AQIABAGYHPKslk98oAAAAAElFTkSuQmCC"),
@@ -62,9 +63,9 @@ private Drawables(String encodedString) {
         this.encodedString = encodedString;
     }
 
-    public BitmapDrawable decodeImage(Context context) {
+    public Drawable decodeImage(final Context context) {
         if (cachedImage == null) {
-            DisplayMetrics displayMetrics = context.getResources().getDisplayMetrics();
+            final DisplayMetrics displayMetrics = context.getResources().getDisplayMetrics();
             int scaledDensity = Dips.asIntPixels(displayMetrics.xdpi, context);
 
             byte[] rawImageData = Base64.decode(encodedString, Base64.DEFAULT);
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/Files.java b/mopub-sdk/src/main/java/com/mopub/common/util/Files.java
similarity index 93%
rename from mopub-sdk/src/main/java/com/mopub/mobileads/util/Files.java
rename to mopub-sdk/src/main/java/com/mopub/common/util/Files.java
index b5c58039..52693bdb 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/Files.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Files.java
@@ -1,6 +1,6 @@
-package com.mopub.mobileads.util;
+package com.mopub.common.util;
 
-import java.io.*;
+import java.io.File;
 
 public class Files {
     public static File createDirectory(String absolutePath) {
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/IntentUtils.java b/mopub-sdk/src/main/java/com/mopub/common/util/IntentUtils.java
new file mode 100644
index 00000000..f9827e40
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/IntentUtils.java
@@ -0,0 +1,89 @@
+package com.mopub.common.util;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.net.Uri;
+import android.util.Log;
+
+import java.util.List;
+
+public class IntentUtils {
+    private static final String TWITTER_APPLICATION_DEEPLINK_URL = "twitter://timeline";
+    private static final String PLAY_GOOGLE_COM = "play.google.com";
+    private static final String MARKET_ANDROID_COM = "market.android.com";
+    private static final String MARKET = "market";
+    private static final String HTTP = "http";
+    private static final String HTTPS = "https";
+
+    private IntentUtils() {}
+
+    public static boolean deviceCanHandleIntent(final Context context, final Intent intent) {
+        try {
+            final PackageManager packageManager = context.getPackageManager();
+            final List<ResolveInfo> activities = packageManager.queryIntentActivities(intent, 0);
+            return !activities.isEmpty();
+        } catch (NullPointerException e) {
+            return false;
+        }
+    }
+
+    public static boolean isHttpUrl(final String url) {
+        if (url == null) {
+            return false;
+        }
+
+        final String scheme = Uri.parse(url).getScheme();
+        return (HTTP.equals(scheme) || HTTPS.equals(scheme));
+    }
+
+    private static boolean isAppStoreUrl(final String url) {
+        if (url == null) {
+            return false;
+        }
+
+        final Uri uri = Uri.parse(url);
+        final String scheme = uri.getScheme();
+        final String host = uri.getHost();
+
+        if (PLAY_GOOGLE_COM.equals(host) || MARKET_ANDROID_COM.equals(host)) {
+            return true;
+        }
+
+        if (MARKET.equals(scheme)) {
+            return true;
+        }
+
+        return false;
+    }
+
+    public static boolean isDeepLink(final String url) {
+        return isAppStoreUrl(url) || !isHttpUrl(url);
+    }
+
+    public static boolean canHandleTwitterUrl(Context context) {
+        return canHandleApplicationUrl(context, TWITTER_APPLICATION_DEEPLINK_URL, false);
+    }
+
+    public static boolean canHandleApplicationUrl(Context context, String url) {
+        return canHandleApplicationUrl(context, url, true);
+    }
+
+    public static boolean canHandleApplicationUrl(Context context, String url, boolean logError) {
+        // Determine which activities can handle the intent
+        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
+
+        // If there are no relevant activities, don't follow the link
+        if (!IntentUtils.deviceCanHandleIntent(context, intent)) {
+            if (logError) {
+                Log.w("MoPub", "Could not handle application specific action: " + url + ". " +
+                        "You may be running in the emulator or another device which does not " +
+                        "have the required application.");
+            }
+            return false;
+        }
+
+        return true;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/Reflection.java b/mopub-sdk/src/main/java/com/mopub/common/util/Reflection.java
similarity index 92%
rename from mopub-sdk/src/main/java/com/mopub/mobileads/util/Reflection.java
rename to mopub-sdk/src/main/java/com/mopub/common/util/Reflection.java
index 392565ec..e4974559 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/Reflection.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Reflection.java
@@ -30,10 +30,11 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package com.mopub.mobileads.util;
+package com.mopub.common.util;
 
 import java.lang.reflect.Method;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.List;
 
 public class Reflection {
     public static class MethodBuilder {
@@ -110,4 +111,13 @@ public static Method getDeclaredMethodWithTraversal(Class<?> clazz, String metho
 
         throw new NoSuchMethodException();
     }
+
+    public static boolean classFound(final String className) {
+        try {
+            Class.forName(className);
+            return true;
+        } catch (ClassNotFoundException e) {
+            return false;
+        }
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/Streams.java b/mopub-sdk/src/main/java/com/mopub/common/util/Streams.java
similarity index 65%
rename from mopub-sdk/src/main/java/com/mopub/mobileads/util/Streams.java
rename to mopub-sdk/src/main/java/com/mopub/common/util/Streams.java
index 16067718..c8b619fd 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/Streams.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Streams.java
@@ -30,41 +30,58 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package com.mopub.mobileads.util;
+package com.mopub.common.util;
 
-import java.io.*;
+import java.io.Closeable;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
 
+// Copy for dependency reasons
 public class Streams {
-    public static void copyContent(InputStream in, OutputStream out) throws IOException {
-        if (in == null || out == null) {
+    public static void copyContent(final InputStream inputStream, final OutputStream outputStream) throws IOException {
+        if (inputStream == null || outputStream == null) {
             throw new IOException("Unable to copy from or to a null stream.");
         }
 
-        byte[] buffer = new byte[65536];
+        byte[] buffer = new byte[16384];
         int length;
 
-        while ((length = in.read(buffer)) != -1) {
-            out.write(buffer, 0, length);
+        while ((length = inputStream.read(buffer)) != -1) {
+            outputStream.write(buffer, 0, length);
         }
     }
 
-    public static void copyContent(InputStream in, OutputStream out, long maxBytes) throws IOException {
-        if (in == null || out == null) {
+    public static void copyContent(final InputStream inputStream, final OutputStream outputStream, final long maxBytes) throws IOException {
+        if (inputStream == null || outputStream == null) {
             throw new IOException("Unable to copy from or to a null stream.");
         }
 
-        byte[] buffer = new byte[65536];
+        byte[] buffer = new byte[16384];
         int length;
         long totalRead = 0;
 
-        while ((length = in.read(buffer)) != -1) {
+        while ((length = inputStream.read(buffer)) != -1) {
             totalRead += length;
             if (totalRead >= maxBytes) {
                 throw new IOException("Error copying content: attempted to copy " +
                         totalRead + " bytes, with " + maxBytes + " maximum.");
             }
 
-            out.write(buffer, 0, length);
+            outputStream.write(buffer, 0, length);
+        }
+    }
+
+    public static void readStream(final InputStream inputStream, byte[] buffer) throws IOException {
+        int offset = 0;
+        int bytesRead = 0;
+        int maxBytes = buffer.length;
+        while ((bytesRead = inputStream.read(buffer, offset, maxBytes)) != -1) {
+            offset += bytesRead;
+            maxBytes -= bytesRead;
+            if (maxBytes <= 0) {
+                return;
+            }
         }
     }
 
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/Strings.java b/mopub-sdk/src/main/java/com/mopub/common/util/Strings.java
similarity index 96%
rename from mopub-sdk/src/main/java/com/mopub/mobileads/util/Strings.java
rename to mopub-sdk/src/main/java/com/mopub/common/util/Strings.java
index 8581bf70..c27fa0fc 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/Strings.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Strings.java
@@ -30,9 +30,10 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package com.mopub.mobileads.util;
+package com.mopub.common.util;
 
-import java.io.*;
+import java.io.IOException;
+import java.io.InputStream;
 
 public class Strings {
     public static String fromStream(InputStream inputStream) throws IOException {
diff --git a/mopub-sdk/src/main/java/com/mopub/common/util/Utils.java b/mopub-sdk/src/main/java/com/mopub/common/util/Utils.java
new file mode 100644
index 00000000..1da67880
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Utils.java
@@ -0,0 +1,45 @@
+package com.mopub.common.util;
+
+import java.security.MessageDigest;
+import java.util.concurrent.atomic.AtomicLong;
+
+public class Utils {
+    private static final AtomicLong sNextGeneratedId = new AtomicLong(1);
+
+    public static String sha1(String string) {
+        StringBuilder stringBuilder = new StringBuilder();
+
+        try {
+            MessageDigest digest = MessageDigest.getInstance("SHA-1");
+            byte[] bytes = string.getBytes("UTF-8");
+            digest.update(bytes, 0, bytes.length);
+            bytes = digest.digest();
+
+            for (final byte b : bytes) {
+                stringBuilder.append(String.format("%02X", b));
+            }
+
+            return stringBuilder.toString().toLowerCase();
+        } catch (Exception e) {
+            return "";
+        }
+    }
+
+    /**
+     * Adaptation of View.generateViewId() from API 17.
+     * There is only a guarantee of ID uniqueness within a given session. Please do not store these
+     * values between sessions.
+     */
+    public static long generateUniqueId() {
+        for (;;) {
+            final long result = sNextGeneratedId.get();
+            long newValue = result + 1;
+            if (newValue > Long.MAX_VALUE - 1) {
+                newValue = 1;
+            }
+            if (sNextGeneratedId.compareAndSet(result, newValue)) {
+                return result;
+            }
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/VersionCode.java b/mopub-sdk/src/main/java/com/mopub/common/util/VersionCode.java
similarity index 98%
rename from mopub-sdk/src/main/java/com/mopub/mobileads/util/VersionCode.java
rename to mopub-sdk/src/main/java/com/mopub/common/util/VersionCode.java
index 79ba61bd..6cff3281 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/VersionCode.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/VersionCode.java
@@ -30,7 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package com.mopub.mobileads.util;
+package com.mopub.common.util;
 
 import android.os.Build;
 
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/Views.java b/mopub-sdk/src/main/java/com/mopub/common/util/Views.java
similarity index 98%
rename from mopub-sdk/src/main/java/com/mopub/mobileads/util/Views.java
rename to mopub-sdk/src/main/java/com/mopub/common/util/Views.java
index c5e5c991..de44f4f7 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/Views.java
+++ b/mopub-sdk/src/main/java/com/mopub/common/util/Views.java
@@ -30,7 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package com.mopub.mobileads.util;
+package com.mopub.common.util;
 
 import android.view.View;
 import android.view.ViewGroup;
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertReporter.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertReporter.java
index 8d3976d1..b4f163a4 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertReporter.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertReporter.java
@@ -38,9 +38,10 @@
 import android.net.Uri;
 import android.util.Log;
 import android.view.View;
+
+import com.mopub.common.util.DateAndTime;
+import com.mopub.common.util.Streams;
 import com.mopub.mobileads.util.Base64;
-import com.mopub.mobileads.util.DateAndTime;
-import com.mopub.mobileads.util.Streams;
 
 import java.io.*;
 import java.text.SimpleDateFormat;
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdConfiguration.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdConfiguration.java
index 324249d1..a60c1d58 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdConfiguration.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/AdConfiguration.java
@@ -36,8 +36,12 @@
 import android.os.Build;
 import android.provider.Settings;
 import android.webkit.WebView;
-import com.mopub.mobileads.util.DateAndTime;
-import com.mopub.mobileads.util.VersionCode;
+
+import com.mopub.common.MoPub;
+import com.mopub.common.util.DateAndTime;
+import com.mopub.common.util.Utils;
+import com.mopub.common.util.VersionCode;
+
 import org.apache.http.HttpResponse;
 
 import java.io.*;
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdFetcher.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdFetcher.java
index 2fa59173..03c73101 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdFetcher.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/AdFetcher.java
@@ -33,8 +33,9 @@
 package com.mopub.mobileads;
 
 import android.util.Log;
+
+import com.mopub.common.util.AsyncTasks;
 import com.mopub.mobileads.factories.AdFetchTaskFactory;
-import com.mopub.mobileads.util.AsyncTasks;
 
 /*
  * AdFetcher is a delegate of an AdViewController that handles loading ad data over a
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdLoadTask.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdLoadTask.java
index 97eb39be..3dcb0c3a 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdLoadTask.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/AdLoadTask.java
@@ -35,8 +35,10 @@
 import android.app.Activity;
 import android.net.Uri;
 import android.util.Log;
+
+import com.mopub.common.util.Strings;
 import com.mopub.mobileads.util.Json;
-import com.mopub.mobileads.util.Strings;
+
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
 import org.apache.http.HttpResponse;
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdTypeTranslator.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdTypeTranslator.java
index 437f270c..9a9d384e 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdTypeTranslator.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/AdTypeTranslator.java
@@ -32,16 +32,9 @@
 
 package com.mopub.mobileads;
 
-import android.content.Context;
-
-import static com.mopub.mobileads.AdTypeTranslator.CustomEventType.ADMOB_BANNER;
-import static com.mopub.mobileads.AdTypeTranslator.CustomEventType.ADMOB_INTERSTITIAL;
-import static com.mopub.mobileads.AdTypeTranslator.CustomEventType.GOOGLE_PLAY_BANNER;
-import static com.mopub.mobileads.AdTypeTranslator.CustomEventType.GOOGLE_PLAY_INTERSTITIAL;
-import static com.mopub.mobileads.util.Reflection.MethodBuilder;
+import com.mopub.common.GpsHelper;
 
 public class AdTypeTranslator {
-    private static final int GOOGLE_PLAY_SUCCESS_CODE = 0;
 
     public enum CustomEventType {
         ADMOB_BANNER("admob_native_banner", "com.mopub.mobileads.GoogleAdMobBanner"),
@@ -100,7 +93,7 @@ static String getCustomEventNameForAdType(MoPubView moPubView, String adType, St
                     : CustomEventType.fromString(adType + "_banner");
 
             if (moPubView != null) {
-                customEventType = convertAdMobToGooglePlay(moPubView.getContext(), customEventType);
+                customEventType = GpsHelper.convertAdMobToGooglePlayServices(moPubView.getContext(), customEventType);
             }
         }
 
@@ -110,42 +103,4 @@ static String getCustomEventNameForAdType(MoPubView moPubView, String adType, St
     private static boolean isInterstitial(MoPubView moPubView) {
         return moPubView instanceof MoPubInterstitial.MoPubInterstitialView;
     }
-
-    private static CustomEventType convertAdMobToGooglePlay(Context context, CustomEventType customEventType) {
-        // In both cases, only check if GooglePlayServices is available if absolutely necessary
-        if (customEventType == ADMOB_BANNER &&
-                classFound(GOOGLE_PLAY_BANNER) &&
-                isGooglePlayServicesAvailable(context)) {
-            return GOOGLE_PLAY_BANNER;
-        } else if (customEventType == ADMOB_INTERSTITIAL &&
-                classFound(GOOGLE_PLAY_INTERSTITIAL) &&
-                isGooglePlayServicesAvailable(context)) {
-            return GOOGLE_PLAY_INTERSTITIAL;
-        }
-
-        return customEventType;
-    }
-
-    private static boolean classFound(CustomEventType customEventType) {
-        try {
-            Class.forName(customEventType.toString());
-            return true;
-        } catch (ClassNotFoundException e) {
-            return false;
-        }
-    }
-
-    private static boolean isGooglePlayServicesAvailable(Context context) {
-        try {
-            MethodBuilder methodBuilder = new MethodBuilder(null, "isGooglePlayServicesAvailable")
-                    .setStatic(Class.forName("com.google.android.gms.common.GooglePlayServicesUtil"))
-                    .addParam(Context.class, context);
-
-            Object result = methodBuilder.execute();
-
-            return (result != null && (Integer) result == GOOGLE_PLAY_SUCCESS_CODE);
-        } catch (Exception exception) {
-            return false;
-        }
-    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/AdViewController.java b/mopub-sdk/src/main/java/com/mopub/mobileads/AdViewController.java
index de2a6110..9464adfb 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/AdViewController.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/AdViewController.java
@@ -35,7 +35,6 @@
 import android.content.Context;
 import android.content.pm.PackageManager;
 import android.location.Location;
-import android.location.LocationManager;
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
 import android.os.Handler;
@@ -43,18 +42,20 @@
 import android.view.Gravity;
 import android.view.View;
 import android.widget.FrameLayout;
-import com.mopub.mobileads.MoPubView.LocationAwareness;
+
+import com.mopub.common.util.Dips;
 import com.mopub.mobileads.factories.AdFetcherFactory;
 import com.mopub.mobileads.factories.HttpClientFactory;
-import com.mopub.mobileads.util.Dips;
+
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
 import org.apache.http.impl.client.DefaultHttpClient;
 
-import java.math.BigDecimal;
 import java.util.*;
 
 import static android.Manifest.permission.ACCESS_NETWORK_STATE;
+import static com.mopub.common.LocationService.*;
+import static com.mopub.common.GpsHelper.*;
 import static com.mopub.mobileads.MoPubView.DEFAULT_LOCATION_PRECISION;
 
 public class AdViewController {
@@ -68,8 +69,9 @@
     private static WeakHashMap<View,Boolean> sViewShouldHonorServerDimensions = new WeakHashMap<View, Boolean>();;
 
     private final Context mContext;
+    private GpsHelperListener mGpsHelperListener;
     private MoPubView mMoPubView;
-    private final AdUrlGenerator mUrlGenerator;
+    private final WebViewAdUrlGenerator mUrlGenerator;
     private AdFetcher mAdFetcher;
     private AdConfiguration mAdConfiguration;
     private final Runnable mRefreshRunnable;
@@ -83,7 +85,7 @@
     private boolean mAutoRefreshEnabled = true;
     private String mKeywords;
     private Location mLocation;
-    private LocationAwareness mLocationAwareness = LocationAwareness.LOCATION_AWARENESS_NORMAL;
+    private LocationAwareness mLocationAwareness = LocationAwareness.NORMAL;
     private int mLocationPrecision = DEFAULT_LOCATION_PRECISION;
     private boolean mIsFacebookSupported = true;
     private boolean mIsTesting;
@@ -100,11 +102,15 @@ public AdViewController(Context context, MoPubView view) {
         mContext = context;
         mMoPubView = view;
 
-        mUrlGenerator = new AdUrlGenerator(context);
+        mUrlGenerator = new WebViewAdUrlGenerator(context);
         mAdConfiguration = new AdConfiguration(mContext);
 
         mAdFetcher = AdFetcherFactory.create(this, mAdConfiguration.getUserAgent());
 
+        mGpsHelperListener = new AdViewControllerGpsHelperListener();
+
+        asyncFetchAdvertisingInfo(mContext);
+
         mRefreshRunnable = new Runnable() {
             public void run() {
                 loadAd();
@@ -132,11 +138,13 @@ public void loadAd() {
         }
 
         if (mLocation == null) {
-            mLocation = getLastKnownLocation();
+            mLocation = getLastKnownLocation(mContext, mLocationPrecision, mLocationAwareness);
         }
 
-        String adUrl = generateAdUrl();
-        loadNonJavascript(adUrl);
+        // If we have access to Google Play Services (GPS) but the advertising info
+        // is not cached then guarantee we get it before building the ad request url
+        // in the callback, this is a requirement from Google
+        asyncFetchAdvertisingInfoIfNotCached(mContext, mGpsHelperListener);
     }
 
     void loadNonJavascript(String url) {
@@ -470,65 +478,17 @@ public void run() {
         }
     }
 
-    /*
-     * Returns the last known location of the device using its GPS and network location providers.
-     * May be null if:
-     * - Location permissions are not requested in the Android manifest file
-     * - The location providers don't exist
-     * - Location awareness is disabled in the parent MoPubView
-     */
-    private Location getLastKnownLocation() {
-        Location result;
-
-        if (mLocationAwareness == LocationAwareness.LOCATION_AWARENESS_DISABLED) {
-            return null;
-        }
-
-        LocationManager lm = (LocationManager) mContext.getSystemService(Context.LOCATION_SERVICE);
-        Location gpsLocation = null;
-        try {
-            gpsLocation = lm.getLastKnownLocation(LocationManager.GPS_PROVIDER);
-        } catch (SecurityException e) {
-            Log.d("MoPub", "Failed to retrieve GPS location: access appears to be disabled.");
-        } catch (IllegalArgumentException e) {
-            Log.d("MoPub", "Failed to retrieve GPS location: device has no GPS provider.");
-        }
-
-        Location networkLocation = null;
-        try {
-            networkLocation = lm.getLastKnownLocation(LocationManager.NETWORK_PROVIDER);
-        } catch (SecurityException e) {
-            Log.d("MoPub", "Failed to retrieve network location: access appears to be disabled.");
-        } catch (IllegalArgumentException e) {
-            Log.d("MoPub", "Failed to retrieve network location: device has no network provider.");
-        }
-
-        if (gpsLocation == null && networkLocation == null) {
-            return null;
-        }
-        else if (gpsLocation != null && networkLocation != null) {
-            if (gpsLocation.getTime() > networkLocation.getTime()) result = gpsLocation;
-            else result = networkLocation;
-        }
-        else if (gpsLocation != null) result = gpsLocation;
-        else result = networkLocation;
-
-        // Truncate latitude/longitude to the number of digits specified by locationPrecision.
-        if (mLocationAwareness == LocationAwareness.LOCATION_AWARENESS_TRUNCATED) {
-            double lat = result.getLatitude();
-            double truncatedLat = BigDecimal.valueOf(lat)
-                    .setScale(mLocationPrecision, BigDecimal.ROUND_HALF_DOWN)
-                    .doubleValue();
-            result.setLatitude(truncatedLat);
-
-            double lon = result.getLongitude();
-            double truncatedLon = BigDecimal.valueOf(lon)
-                    .setScale(mLocationPrecision, BigDecimal.ROUND_HALF_DOWN)
-                    .doubleValue();
-            result.setLongitude(truncatedLon);
+    class AdViewControllerGpsHelperListener implements GpsHelperListener {
+        @Override
+        public void onFetchAdInfoCompleted() {
+            String adUrl = generateAdUrl();
+            loadNonJavascript(adUrl);
         }
+    }
 
-        return result;
+    @Deprecated
+    void setGpsHelperListener(GpsHelperListener gpsHelperListener) {
+        mGpsHelperListener = gpsHelperListener;
     }
 
     @Deprecated
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseHtmlWebView.java b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseHtmlWebView.java
index 73b04306..3b30f0c5 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseHtmlWebView.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseHtmlWebView.java
@@ -39,8 +39,8 @@
 import android.view.View;
 
 import static com.mopub.mobileads.ViewGestureDetector.UserClickListener;
-import static com.mopub.mobileads.util.VersionCode.ICE_CREAM_SANDWICH;
-import static com.mopub.mobileads.util.VersionCode.currentApiLevel;
+import static com.mopub.common.util.VersionCode.ICE_CREAM_SANDWICH;
+import static com.mopub.common.util.VersionCode.currentApiLevel;
 
 public class BaseHtmlWebView extends BaseWebView implements UserClickListener {
     private final ViewGestureDetector mViewGestureDetector;
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseInterstitialActivity.java b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseInterstitialActivity.java
index 5ad3794e..cc8d59a8 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseInterstitialActivity.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseInterstitialActivity.java
@@ -42,13 +42,14 @@
 import android.widget.ImageButton;
 import android.widget.ImageView;
 import android.widget.RelativeLayout;
-import com.mopub.mobileads.util.Dips;
+
+import com.mopub.common.util.Dips;
 
 import static android.view.View.INVISIBLE;
 import static android.view.View.VISIBLE;
 import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
-import static com.mopub.mobileads.resource.Drawables.INTERSTITIAL_CLOSE_BUTTON_NORMAL;
-import static com.mopub.mobileads.resource.Drawables.INTERSTITIAL_CLOSE_BUTTON_PRESSED;
+import static com.mopub.common.util.Drawables.INTERSTITIAL_CLOSE_BUTTON_NORMAL;
+import static com.mopub.common.util.Drawables.INTERSTITIAL_CLOSE_BUTTON_PRESSED;
 
 abstract class BaseInterstitialActivity extends Activity {
     enum JavaScriptWebViewCallbacks {
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseWebView.java b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseWebView.java
index 5f6f0a8a..5d321a44 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/BaseWebView.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/BaseWebView.java
@@ -35,8 +35,9 @@
 import android.content.Context;
 import android.util.Log;
 import android.webkit.WebView;
-import com.mopub.mobileads.util.VersionCode;
-import com.mopub.mobileads.util.Views;
+
+import com.mopub.common.util.VersionCode;
+import com.mopub.common.util.Views;
 import com.mopub.mobileads.util.WebViews;
 
 import java.lang.reflect.Method;
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/DiskLruCache.java b/mopub-sdk/src/main/java/com/mopub/mobileads/DiskLruCache.java
index ec31cb65..80f59adc 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/DiskLruCache.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/DiskLruCache.java
@@ -4,8 +4,10 @@
 import android.net.Uri;
 import android.support.v4.util.LruCache;
 import android.util.Log;
-import com.mopub.mobileads.util.Files;
-import com.mopub.mobileads.util.Streams;
+
+import com.mopub.common.util.Files;
+import com.mopub.common.util.Streams;
+import com.mopub.common.util.Utils;
 
 import java.io.*;
 
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlInterstitialWebView.java b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlInterstitialWebView.java
index 5dec9f16..4f7c99c7 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlInterstitialWebView.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlInterstitialWebView.java
@@ -38,8 +38,8 @@
 import android.webkit.JavascriptInterface;
 
 import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
-import static com.mopub.mobileads.util.VersionCode.HONEYCOMB;
-import static com.mopub.mobileads.util.VersionCode.currentApiLevel;
+import static com.mopub.common.util.VersionCode.HONEYCOMB;
+import static com.mopub.common.util.VersionCode.currentApiLevel;
 
 public class HtmlInterstitialWebView extends BaseHtmlWebView {
     private Handler mHandler;
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlWebViewClient.java b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlWebViewClient.java
index e16677ef..93dfe5b2 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlWebViewClient.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/HtmlWebViewClient.java
@@ -40,6 +40,10 @@
 import android.webkit.WebView;
 import android.webkit.WebViewClient;
 
+import com.mopub.common.MoPubBrowser;
+import com.mopub.common.util.IntentUtils;
+import com.mopub.mobileads.util.Utils;
+
 import static com.mopub.mobileads.MoPubErrorCode.UNSPECIFIED;
 
 class HtmlWebViewClient extends WebViewClient {
@@ -70,13 +74,13 @@ public boolean shouldOverrideUrlLoading(WebView view, String url) {
         Log.d("MoPub", "Ad clicked. Click URL: " + url);
 
         // this is added because http/s can also be intercepted
-        if (!isWebSiteUrl(url) && Utils.canHandleApplicationUrl(mContext, url)) {
+        if (!isWebSiteUrl(url) && IntentUtils.canHandleApplicationUrl(mContext, url)) {
             if (launchApplicationUrl(url)) {
                 return true;
             }
         }
 
-        showMraidBrowserForUrl(url);
+        showMoPubBrowserForUrl(url);
         return true;
     }
 
@@ -86,7 +90,7 @@ public void onPageStarted(WebView view, String url, Bitmap favicon) {
         if (mRedirectUrl != null && url.startsWith(mRedirectUrl)) {
             url = urlWithClickTrackingRedirect(url);
             view.stopLoading();
-            showMraidBrowserForUrl(url);
+            showMoPubBrowserForUrl(url);
         }
     }
 
@@ -193,20 +197,20 @@ private boolean launchApplicationUrl(String url) {
         return launchIntentForUserClick(mContext, intent, errorMessage);
     }
 
-    private void showMraidBrowserForUrl(String url) {
+    private void showMoPubBrowserForUrl(String url) {
         if (url == null || url.equals("")) url = "about:blank";
         Log.d("MoPub", "Final URI to show in browser: " + url);
-        Intent intent = new Intent(mContext, MraidBrowser.class);
-        intent.putExtra(MraidBrowser.URL_EXTRA, url);
+        Intent intent = new Intent(mContext, MoPubBrowser.class);
+        intent.putExtra(MoPubBrowser.DESTINATION_URL_KEY, url);
         intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
 
         String errorMessage = "Could not handle intent action. "
-                + ". Perhaps you forgot to declare com.mopub.mobileads.MraidBrowser"
+                + ". Perhaps you forgot to declare com.mopub.common.MoPubBrowser"
                 + " in your Android manifest file.";
 
-        boolean handledByMraidBrowser = launchIntentForUserClick(mContext, intent, errorMessage);
+        boolean handledByMoPubBrowser = launchIntentForUserClick(mContext, intent, errorMessage);
 
-        if (!handledByMraidBrowser) {
+        if (!handledByMoPubBrowser) {
             intent = new Intent(Intent.ACTION_VIEW, Uri.parse("about:blank"));
             intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
             launchIntentForUserClick(mContext, intent, null);
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidBrowserController.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubBrowserController.java
similarity index 84%
rename from mopub-sdk/src/main/java/com/mopub/mobileads/MraidBrowserController.java
rename to mopub-sdk/src/main/java/com/mopub/mobileads/MoPubBrowserController.java
index 036844cc..4288e162 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidBrowserController.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubBrowserController.java
@@ -38,11 +38,15 @@
 import android.net.Uri;
 import android.util.Log;
 
-class MraidBrowserController extends MraidAbstractController {
-    private static final String LOGTAG = "MraidBrowserController";
+import com.mopub.common.MoPubBrowser;
+import com.mopub.common.util.IntentUtils;
+import com.mopub.mobileads.util.Utils;
+
+class MoPubBrowserController extends MraidAbstractController {
+    private static final String LOGTAG = "MoPubBrowserController";
     private Context mContext;
 
-    MraidBrowserController(MraidView view) {
+    MoPubBrowserController(MraidView view) {
         super(view);
         mContext = view.getContext();
     }
@@ -56,13 +60,13 @@ protected void open(String url) {
         }
 
         // this is added because http/s can also be intercepted
-        if (!isWebSiteUrl(url) && Utils.canHandleApplicationUrl(mContext, url)) {
+        if (!isWebSiteUrl(url) && IntentUtils.canHandleApplicationUrl(mContext, url)) {
             launchApplicationUrl(url);
             return;
         }
 
-        Intent i = new Intent(mContext, MraidBrowser.class);
-        i.putExtra(MraidBrowser.URL_EXTRA, url);
+        Intent i = new Intent(mContext, MoPubBrowser.class);
+        i.putExtra(MoPubBrowser.DESTINATION_URL_KEY, url);
         i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
         mContext.startActivity(i);
     }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubConversionTracker.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubConversionTracker.java
index 42666dd2..012ddcbb 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubConversionTracker.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubConversionTracker.java
@@ -35,24 +35,31 @@
 import android.content.Context;
 import android.content.SharedPreferences;
 import android.util.Log;
+
+import com.mopub.common.BaseUrlGenerator;
+import com.mopub.common.GpsHelper;
+import com.mopub.common.SharedPreferencesHelper;
 import com.mopub.mobileads.factories.HttpClientFactory;
+
 import org.apache.http.HttpEntity;
 import org.apache.http.HttpResponse;
 import org.apache.http.HttpStatus;
 import org.apache.http.client.methods.HttpGet;
 import org.apache.http.impl.client.DefaultHttpClient;
 
-import static android.content.Context.MODE_PRIVATE;
-
 public class MoPubConversionTracker {
     private static final String TRACK_HOST = "ads.mopub.com";
     private static final String TRACK_HANDLER = "/m/open";
-    private static final String PREFERENCE_NAME = "mopubSettings";
 
     private Context mContext;
     private String mIsTrackedKey;
     private SharedPreferences mSharedPreferences;
     private String mPackageName;
+    private ConversionTrackerGpsHelperListener mConversionTrackerGpsHelperListener;
+
+    public MoPubConversionTracker() {
+        mConversionTrackerGpsHelperListener = new ConversionTrackerGpsHelperListener();
+    }
 
     public void reportAppOpen(Context context) {
         if (context == null) {
@@ -62,10 +69,10 @@ public void reportAppOpen(Context context) {
         mContext = context;
         mPackageName = mContext.getPackageName();
         mIsTrackedKey = mPackageName + " tracked";
-        mSharedPreferences = mContext.getSharedPreferences(PREFERENCE_NAME, MODE_PRIVATE);
+        mSharedPreferences = SharedPreferencesHelper.getSharedPreferences(mContext);
 
         if (!isAlreadyTracked()) {
-            new Thread(new TrackOpen()).start();
+            GpsHelper.asyncFetchAdvertisingInfo(mContext, mConversionTrackerGpsHelperListener);
         } else {
             Log.d("MoPub", "Conversion already tracked");
         }
@@ -83,6 +90,7 @@ public String generateUrlString(String serverHostname) {
             setApiVersion("6");
             setPackageId(mPackageName);
             setUdid(getUdidFromContext(mContext));
+            setDoNotTrack(GpsHelper.isLimitAdTrackingEnabled(mContext));
             setAppVersion(getAppVersionFromContext(mContext));
             return getFinalUrlString();
         }
@@ -126,4 +134,11 @@ public void run() {
                     .commit();
         }
     }
+
+    class ConversionTrackerGpsHelperListener implements GpsHelper.GpsHelperListener {
+        @Override
+        public void onFetchAdInfoCompleted() {
+            new Thread(new TrackOpen()).start();
+        }
+    }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubInterstitial.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubInterstitial.java
index c91e86f4..5825e232 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubInterstitial.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubInterstitial.java
@@ -36,11 +36,13 @@
 import android.content.Context;
 import android.location.Location;
 import android.util.Log;
-import com.mopub.mobileads.MoPubView.LocationAwareness;
+
+import com.mopub.common.LocationService;
 import com.mopub.mobileads.factories.CustomEventInterstitialAdapterFactory;
 
 import java.util.*;
 
+import static com.mopub.common.LocationService.*;
 import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
 import static com.mopub.mobileads.util.ResponseHeader.CUSTOM_EVENT_DATA;
 import static com.mopub.mobileads.util.ResponseHeader.CUSTOM_EVENT_NAME;
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubView.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubView.java
index dfea5af0..e7dedc96 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubView.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MoPubView.java
@@ -43,11 +43,14 @@
 import android.view.View;
 import android.webkit.WebViewDatabase;
 import android.widget.FrameLayout;
+
+import com.mopub.common.LocationService;
 import com.mopub.mobileads.factories.AdViewControllerFactory;
 import com.mopub.mobileads.factories.CustomEventBannerAdapterFactory;
 
 import java.util.*;
 
+import static com.mopub.common.LocationService.*;
 import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
 import static com.mopub.mobileads.util.ResponseHeader.CUSTOM_EVENT_DATA;
 import static com.mopub.mobileads.util.ResponseHeader.CUSTOM_EVENT_NAME;
@@ -62,10 +65,6 @@
         public void onBannerCollapsed(MoPubView banner);
     }
 
-    public enum LocationAwareness {
-        LOCATION_AWARENESS_NORMAL, LOCATION_AWARENESS_TRUNCATED, LOCATION_AWARENESS_DISABLED
-    }
-
     public static final String HOST = "ads.mopub.com";
     public static final String HOST_FOR_TESTING = "testing.ads.mopub.com";
     public static final String AD_HANDLER = "/m/ad";
@@ -98,7 +97,7 @@ public MoPubView(Context context, AttributeSet attrs) {
 
         mContext = context;
         mIsInForeground = (getVisibility() == VISIBLE);
-        mLocationAwareness = LocationAwareness.LOCATION_AWARENESS_NORMAL;
+        mLocationAwareness = LocationAwareness.NORMAL;
 
         setHorizontalScrollBarEnabled(false);
         setVerticalScrollBarEnabled(false);
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidActivity.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidActivity.java
index b958befe..51edb2cb 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidActivity.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidActivity.java
@@ -53,12 +53,12 @@
 import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
 import static com.mopub.mobileads.BaseInterstitialActivity.JavaScriptWebViewCallbacks.WEB_VIEW_DID_APPEAR;
 import static com.mopub.mobileads.BaseInterstitialActivity.JavaScriptWebViewCallbacks.WEB_VIEW_DID_CLOSE;
+import static com.mopub.common.util.VersionCode.ICE_CREAM_SANDWICH;
+import static com.mopub.common.util.VersionCode.currentApiLevel;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_CLICK;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.broadcastAction;
-import static com.mopub.mobileads.util.VersionCode.ICE_CREAM_SANDWICH;
-import static com.mopub.mobileads.util.VersionCode.currentApiLevel;
 
 public class MraidActivity extends BaseInterstitialActivity {
     private MraidView mMraidView;
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidBrowser.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidBrowser.java
deleted file mode 100644
index 8e8bb951..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidBrowser.java
+++ /dev/null
@@ -1,267 +0,0 @@
-/*
- * Copyright (c) 2010-2013, MoPub Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *  Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- *  Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- *  Neither the name of 'MoPub Inc.' nor the names of its contributors
- *   may be used to endorse or promote products derived from this software
- *   without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.content.ActivityNotFoundException;
-import android.content.Intent;
-import android.graphics.Bitmap;
-import android.graphics.Color;
-import android.graphics.drawable.Drawable;
-import android.net.Uri;
-import android.os.Bundle;
-import android.util.Log;
-import android.view.Gravity;
-import android.view.View;
-import android.view.View.OnClickListener;
-import android.view.Window;
-import android.webkit.CookieSyncManager;
-import android.webkit.WebChromeClient;
-import android.webkit.WebSettings;
-import android.webkit.WebView;
-import android.webkit.WebViewClient;
-import android.widget.ImageButton;
-import android.widget.LinearLayout;
-import android.widget.RelativeLayout;
-import android.widget.Toast;
-
-import static android.view.ViewGroup.LayoutParams.FILL_PARENT;
-import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;
-import static com.mopub.mobileads.resource.Drawables.BACKGROUND;
-import static com.mopub.mobileads.resource.Drawables.CLOSE;
-import static com.mopub.mobileads.resource.Drawables.LEFT_ARROW;
-import static com.mopub.mobileads.resource.Drawables.REFRESH;
-import static com.mopub.mobileads.resource.Drawables.RIGHT_ARROW;
-import static com.mopub.mobileads.resource.Drawables.UNLEFT_ARROW;
-import static com.mopub.mobileads.resource.Drawables.UNRIGHT_ARROW;
-
-public class MraidBrowser extends Activity {
-    
-    public static final String URL_EXTRA = "extra_url";
-    public static final int INNER_LAYOUT_ID = 1;
-    private WebView mWebView;
-    private ImageButton mBackButton;
-    private ImageButton mForwardButton;
-    private ImageButton mRefreshButton;
-    private ImageButton mCloseButton;
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        
-        getWindow().requestFeature(Window.FEATURE_PROGRESS);
-        getWindow().setFeatureInt(Window.FEATURE_PROGRESS, Window.PROGRESS_VISIBILITY_ON);
-        
-        setContentView(getMraidBrowserView());
-        
-        Intent intent = getIntent();
-        initializeWebView(intent);
-        initializeButtons();
-        enableCookies();
-    }
-
-    private void initializeWebView(Intent intent) {
-        WebSettings webSettings = mWebView.getSettings();
-        
-        webSettings.setJavaScriptEnabled(true);
-        
-        /* Pinch to zoom is apparently not enabled by default on all devices, so
-         * declare zoom support explicitly.
-         * http://stackoverflow.com/questions/5125851/enable-disable-zoom-in-android-webview
-         */
-        webSettings.setSupportZoom(true);
-        webSettings.setBuiltInZoomControls(true);
-        webSettings.setUseWideViewPort(true);
-        
-        mWebView.loadUrl(intent.getStringExtra(URL_EXTRA));
-        mWebView.setWebViewClient(new WebViewClient() {
-            @Override
-            public void onReceivedError(WebView view, int errorCode, String description,
-                                        String failingUrl) {
-                Activity a = (Activity) view.getContext();
-                Toast.makeText(a, "MRAID error: " + description, Toast.LENGTH_SHORT).show();
-            }
-
-            @Override
-            public boolean shouldOverrideUrlLoading(WebView view, String url) {
-                if (url == null) return false;
-
-                Uri uri = Uri.parse(url);
-                String host = uri.getHost();
-
-                if ((url.startsWith("http:") || url.startsWith("https:"))
-                        && !"play.google.com".equals(host)
-                        && !"market.android.com".equals(host)) {
-                    return false;
-                }
-
-                try {
-                    startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(url)));
-                } catch (ActivityNotFoundException exception) {
-                    Log.w("MoPub", "Unable to start activity for " + url + ". " +
-                            "Ensure that your phone can handle this intent.");
-                }
-
-                finish();
-                return true;
-            }
-
-            @Override
-            public void onPageStarted(WebView view, String url, Bitmap favicon) {
-                super.onPageStarted(view, url, favicon);
-                mForwardButton.setImageDrawable(UNRIGHT_ARROW.decodeImage(MraidBrowser.this));
-            }
-
-            @Override
-            public void onPageFinished(WebView view, String url) {
-                super.onPageFinished(view, url);
-
-                Drawable backImageDrawable = view.canGoBack()
-                        ? LEFT_ARROW.decodeImage(MraidBrowser.this)
-                        : UNLEFT_ARROW.decodeImage(MraidBrowser.this);
-                mBackButton.setImageDrawable(backImageDrawable);
-
-                Drawable forwardImageDrawable = view.canGoForward()
-                        ? RIGHT_ARROW.decodeImage(MraidBrowser.this)
-                        : UNRIGHT_ARROW.decodeImage(MraidBrowser.this);
-                mForwardButton.setImageDrawable(forwardImageDrawable);
-            }
-        });
-        
-        mWebView.setWebChromeClient(new WebChromeClient() {
-            public void onProgressChanged(WebView view, int progress) {
-                Activity a = (Activity) view.getContext();
-                a.setTitle("Loading...");
-                a.setProgress(progress * 100);
-                if (progress == 100) a.setTitle(view.getUrl());
-            }
-        });
-    }
-    
-    private void initializeButtons() {
-        mBackButton.setBackgroundColor(Color.TRANSPARENT);
-        mBackButton.setOnClickListener(new OnClickListener() {
-            public void onClick(View v) {
-                if (mWebView.canGoBack()) mWebView.goBack();
-            }
-        });
-        
-        mForwardButton.setBackgroundColor(Color.TRANSPARENT);
-        mForwardButton.setOnClickListener(new OnClickListener() {
-            public void onClick(View v) {
-                if (mWebView.canGoForward()) mWebView.goForward();
-            }
-        });
-        
-        mRefreshButton.setBackgroundColor(Color.TRANSPARENT);
-        mRefreshButton.setOnClickListener(new OnClickListener() {
-            public void onClick(View v) {
-                mWebView.reload();
-            }
-        });
-        
-        mCloseButton.setBackgroundColor(Color.TRANSPARENT);
-        mCloseButton.setOnClickListener(new OnClickListener() {
-            public void onClick(View v) {
-                MraidBrowser.this.finish();
-            }
-        });
-    }
-    
-    private void enableCookies() {
-        CookieSyncManager.createInstance(this);
-        CookieSyncManager.getInstance().startSync();
-    }
-    
-    @Override
-    protected void onPause() {
-        super.onPause();
-        CookieSyncManager.getInstance().stopSync();
-    }
-    
-    @Override
-    protected void onResume() {
-        super.onResume();
-        CookieSyncManager.getInstance().startSync();
-    }
-
-    private View getMraidBrowserView() {
-        LinearLayout mraidBrowserView = new LinearLayout(this);
-        LinearLayout.LayoutParams browserLayoutParams = new LinearLayout.LayoutParams(FILL_PARENT, FILL_PARENT);
-        mraidBrowserView.setLayoutParams(browserLayoutParams);
-        mraidBrowserView.setOrientation(LinearLayout.VERTICAL);
-
-        RelativeLayout outerLayout = new RelativeLayout(this);
-        LinearLayout.LayoutParams outerLayoutParams = new LinearLayout.LayoutParams(FILL_PARENT, WRAP_CONTENT);
-        outerLayout.setLayoutParams(outerLayoutParams);
-        mraidBrowserView.addView(outerLayout);
-
-        LinearLayout innerLayout = new LinearLayout(this);
-        innerLayout.setId(INNER_LAYOUT_ID);
-        RelativeLayout.LayoutParams innerLayoutParams = new RelativeLayout.LayoutParams(FILL_PARENT, WRAP_CONTENT);
-        innerLayoutParams.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM);
-        innerLayout.setLayoutParams(innerLayoutParams);
-        innerLayout.setBackgroundDrawable(BACKGROUND.decodeImage(MraidBrowser.this));
-        outerLayout.addView(innerLayout);
-
-        mBackButton = getButton(LEFT_ARROW.decodeImage(MraidBrowser.this));
-        mForwardButton = getButton(RIGHT_ARROW.decodeImage(MraidBrowser.this));
-        mRefreshButton = getButton(REFRESH.decodeImage(MraidBrowser.this));
-        mCloseButton = getButton(CLOSE.decodeImage(MraidBrowser.this));
-
-        innerLayout.addView(mBackButton);
-        innerLayout.addView(mForwardButton);
-        innerLayout.addView(mRefreshButton);
-        innerLayout.addView(mCloseButton);
-
-        mWebView = new WebView(this);
-        RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(FILL_PARENT, FILL_PARENT);
-        layoutParams.addRule(RelativeLayout.ABOVE, INNER_LAYOUT_ID);
-        mWebView.setLayoutParams(layoutParams);
-        outerLayout.addView(mWebView);
-
-        return mraidBrowserView;
-    }
-
-    private ImageButton getButton(Drawable drawable) {
-        ImageButton imageButton = new ImageButton(this);
-
-        LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(WRAP_CONTENT, WRAP_CONTENT, 1f);
-        layoutParams.gravity = Gravity.CENTER_VERTICAL;
-        imageButton.setLayoutParams(layoutParams);
-
-        imageButton.setImageDrawable(drawable);
-
-        return imageButton;
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidDisplayController.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidDisplayController.java
index 02a6118c..b259e6e3 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidDisplayController.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidDisplayController.java
@@ -65,6 +65,8 @@
 import android.widget.ImageView;
 import android.widget.RelativeLayout;
 import android.widget.Toast;
+
+import com.mopub.common.util.Streams;
 import com.mopub.mobileads.MraidView.ExpansionStyle;
 import com.mopub.mobileads.MraidView.NativeCloseButtonStyle;
 import com.mopub.mobileads.MraidView.PlacementType;
@@ -72,7 +74,7 @@
 import com.mopub.mobileads.factories.HttpClientFactory;
 import com.mopub.mobileads.util.HttpResponses;
 import com.mopub.mobileads.util.Mraids;
-import com.mopub.mobileads.util.Streams;
+
 import org.apache.http.Header;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.HttpClient;
@@ -93,8 +95,8 @@
 import static com.mopub.mobileads.MraidCommandFactory.MraidJavascriptCommand.STORE_PICTURE;
 import static com.mopub.mobileads.MraidCommandStorePicture.MIME_TYPE_HEADER;
 import static com.mopub.mobileads.MraidView.BaseMraidListener;
-import static com.mopub.mobileads.resource.Drawables.INTERSTITIAL_CLOSE_BUTTON_NORMAL;
-import static com.mopub.mobileads.resource.Drawables.INTERSTITIAL_CLOSE_BUTTON_PRESSED;
+import static com.mopub.common.util.Drawables.INTERSTITIAL_CLOSE_BUTTON_NORMAL;
+import static com.mopub.common.util.Drawables.INTERSTITIAL_CLOSE_BUTTON_PRESSED;
 import static com.mopub.mobileads.util.Mraids.ANDROID_CALENDAR_CONTENT_TYPE;
 import static com.mopub.mobileads.util.Mraids.isCalendarAvailable;
 import static com.mopub.mobileads.util.Mraids.isInlineVideoAvailable;
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidView.java b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidView.java
index dcabf4a1..f5e94874 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/MraidView.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/MraidView.java
@@ -42,9 +42,11 @@
 import android.view.View;
 import android.webkit.WebView;
 import android.webkit.WebViewClient;
+
+import com.mopub.common.util.Strings;
 import com.mopub.mobileads.factories.HttpClientFactory;
 import com.mopub.mobileads.resource.MraidJavascript;
-import com.mopub.mobileads.util.Strings;
+
 import org.apache.http.HttpEntity;
 import org.apache.http.HttpResponse;
 import org.apache.http.NameValuePair;
@@ -63,7 +65,7 @@
 public class MraidView extends BaseWebView implements UserClickListener {
     private static final String LOGTAG = "MraidView";
     
-    private MraidBrowserController mBrowserController;
+    private MoPubBrowserController mBrowserController;
     private MraidDisplayController mDisplayController;
     
     private WebViewClient mWebViewClient;
@@ -163,7 +165,7 @@ public boolean onTouch(View v, MotionEvent event) {
         
         getSettings().setJavaScriptEnabled(true);
         
-        mBrowserController = new MraidBrowserController(this);
+        mBrowserController = new MoPubBrowserController(this);
         mDisplayController = new MraidDisplayController(this, expStyle, buttonStyle);
         
         mWebViewClient = new MraidWebViewClient();
@@ -244,7 +246,7 @@ private void notifyOnFailureListener() {
 
     // Controllers /////////////////////////////////////////////////////////////////////////////////
     
-    protected MraidBrowserController getBrowserController() {
+    protected MoPubBrowserController getBrowserController() {
         return mBrowserController;
     }
     
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/Utils.java b/mopub-sdk/src/main/java/com/mopub/mobileads/Utils.java
deleted file mode 100644
index b0154597..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/Utils.java
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
- * Copyright (c) 2010-2013, MoPub Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *  Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- *
- *  Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in the
- *   documentation and/or other materials provided with the distribution.
- *
- *  Neither the name of 'MoPub Inc.' nor the names of its contributors
- *   may be used to endorse or promote products derived from this software
- *   without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package com.mopub.mobileads;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.content.pm.ResolveInfo;
-import android.net.Uri;
-import android.util.Log;
-
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-import java.util.*;
-import java.util.concurrent.atomic.*;
-
-public class Utils {
-    private static final String TWITTER_APPLICATION_DEEPLINK_URL = "twitter://timeline";
-    private static final AtomicLong sNextGeneratedId = new AtomicLong(1);
-
-    private Utils() {
-    }
-
-    public static String sha1(String s) {
-        try {
-            MessageDigest digest = MessageDigest.getInstance("SHA-1");
-            digest.update(s.getBytes());
-            byte messageDigest[] = digest.digest();
-
-            StringBuffer hexString = new StringBuffer();
-            for (int i = 0; i < messageDigest.length; i++) {
-                hexString.append(Integer.toHexString((0xFF & messageDigest[i]) | 0x100).substring(1));
-            }
-            return hexString.toString();
-        } catch (NoSuchAlgorithmException e) {
-            return "";
-        }
-        catch (NullPointerException e) {
-            return "";
-        }
-    }
-
-    public static boolean deviceCanHandleIntent(Context context, Intent intent) {
-        PackageManager packageManager = context.getPackageManager();
-        List<ResolveInfo> activities = packageManager.queryIntentActivities(intent, 0);
-        return (activities.size() > 0);
-    }
-
-    public static boolean canHandleTwitterUrl(Context context) {
-        return canHandleApplicationUrl(context, TWITTER_APPLICATION_DEEPLINK_URL, false);
-    }
-
-    public static boolean canHandleApplicationUrl(Context context, String url) {
-        return canHandleApplicationUrl(context, url, true);
-    }
-
-    public static boolean canHandleApplicationUrl(Context context, String url, boolean logError) {
-        // Determine which activities can handle the intent
-        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
-
-        // If there are no relevant activities, don't follow the link
-        if (!deviceCanHandleIntent(context, intent)) {
-            if (logError) {
-                Log.w("MoPub", "Could not handle application specific action: " + url + ". " +
-                        "You may be running in the emulator or another device which does not " +
-                        "have the required application.");
-            }
-            return false;
-        }
-
-        return true;
-    }
-
-    public static boolean executeIntent(Context context, Intent intent, String errorMessage) {
-        try {
-            if (!(context instanceof Activity)) {
-                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-            }
-            context.startActivity(intent);
-        } catch (Exception e) {
-            Log.d("MoPub", (errorMessage != null)
-                    ? errorMessage
-                    : "Unable to start intent.");
-            return false;
-        }
-        return true;
-    }
-
-    /**
-     * Adaptation of View.generateViewId() from API 17.
-     * There is only a guarantee of ID uniqueness within a given session. Please do not store these
-     * values between sessions.
-     */
-    public static long generateUniqueId() {
-        for (;;) {
-            final long result = sNextGeneratedId.get();
-            long newValue = result + 1;
-            if (newValue > Long.MAX_VALUE - 1) {
-                newValue = 1;
-            }
-            if (sNextGeneratedId.compareAndSet(result, newValue)) {
-                return result;
-            }
-        }
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoDownloadTask.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoDownloadTask.java
index fa502ed7..6be1b18f 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoDownloadTask.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoDownloadTask.java
@@ -34,9 +34,11 @@
 
 import android.os.AsyncTask;
 import android.util.Log;
+
+import com.mopub.common.util.Streams;
 import com.mopub.mobileads.factories.HttpClientFactory;
 import com.mopub.mobileads.util.HttpClients;
-import com.mopub.mobileads.util.Streams;
+
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
 import org.apache.http.impl.client.DefaultHttpClient;
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoView.java b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoView.java
index 9cacc8cb..6d0fc5a8 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoView.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoView.java
@@ -39,6 +39,8 @@
 import android.util.Log;
 import android.view.MotionEvent;
 import android.view.View;
+
+import com.mopub.common.MoPubBrowser;
 import com.mopub.mobileads.util.HttpUtils;
 
 import java.util.*;
@@ -124,10 +126,10 @@ public boolean onTouch(View view, MotionEvent motionEvent) {
                         mBaseVideoViewListener.videoClicked();
                     }
 
-                    Intent mraidBrowserIntent = new Intent(context, MraidBrowser.class);
-                    mraidBrowserIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-                    mraidBrowserIntent.putExtra(MraidBrowser.URL_EXTRA, mClickThroughUrl);
-                    context.startActivity(mraidBrowserIntent);
+                    Intent moPubBrowserIntent = new Intent(context, MoPubBrowser.class);
+                    moPubBrowserIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+                    moPubBrowserIntent.putExtra(MoPubBrowser.DESTINATION_URL_KEY, mClickThroughUrl);
+                    context.startActivity(moPubBrowserIntent);
                 }
 
                 return true;
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/WebViewAdUrlGenerator.java b/mopub-sdk/src/main/java/com/mopub/mobileads/WebViewAdUrlGenerator.java
new file mode 100644
index 00000000..24e97126
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/WebViewAdUrlGenerator.java
@@ -0,0 +1,101 @@
+package com.mopub.mobileads;
+
+import android.content.Context;
+import android.os.Build;
+
+import com.mopub.common.AdUrlGenerator;
+import com.mopub.common.GpsHelper;
+import com.mopub.common.MoPub;
+import com.mopub.mobileads.util.Utils;
+
+import java.lang.reflect.Method;
+
+import static com.mopub.mobileads.util.Mraids.isStorePictureSupported;
+
+public class WebViewAdUrlGenerator extends AdUrlGenerator {
+    public WebViewAdUrlGenerator(Context context) {
+        super(context);
+    }
+
+    @Override
+    public String generateUrlString(String serverHostname) {
+        initUrlString(serverHostname, MoPubView.AD_HANDLER);
+
+        setApiVersion("6");
+
+        setAdUnitId(mAdUnitId);
+
+        setSdkVersion(MoPub.SDK_VERSION);
+
+        setDeviceInfo(Build.MANUFACTURER, Build.MODEL, Build.PRODUCT);
+
+        setUdid(getUdidFromContext(mContext));
+
+        setDoNotTrack(GpsHelper.isLimitAdTrackingEnabled(mContext));
+
+        String keywords = addKeyword(mKeywords, getFacebookKeyword(mContext, mFacebookSupportEnabled));
+        setKeywords(keywords);
+
+        setLocation(mLocation);
+
+        setTimezone(AdUrlGenerator.getTimeZoneOffsetString());
+
+        setOrientation(mContext.getResources().getConfiguration().orientation);
+
+        setDensity(mContext.getResources().getDisplayMetrics().density);
+
+        setMraidFlag(detectIsMraidSupported());
+
+        String networkOperator = getNetworkOperator();
+        setMccCode(networkOperator);
+        setMncCode(networkOperator);
+
+        setIsoCountryCode(mTelephonyManager.getNetworkCountryIso());
+        setCarrierName(mTelephonyManager.getNetworkOperatorName());
+
+        setNetworkType(getActiveNetworkType());
+
+        setAppVersion(getAppVersionFromContext(mContext));
+
+        setExternalStoragePermission(isStorePictureSupported(mContext));
+
+        setTwitterAppInstalledFlag();
+
+        return getFinalUrlString();
+    }
+
+    private boolean detectIsMraidSupported() {
+        boolean mraid = true;
+        try {
+            Class.forName("com.mopub.mobileads.MraidView");
+        } catch (ClassNotFoundException e) {
+            mraid = false;
+        }
+        return mraid;
+    }
+
+    private static String getFacebookKeyword(Context context, final boolean enabled) {
+        if (!enabled) {
+            return null;
+        }
+
+        try {
+            Class<?> facebookKeywordProviderClass = Class.forName("com.mopub.mobileads.FacebookKeywordProvider");
+            Method getKeywordMethod = facebookKeywordProviderClass.getMethod("getKeyword", Context.class);
+
+            return (String) getKeywordMethod.invoke(facebookKeywordProviderClass, context);
+        } catch (Exception exception) {
+            return null;
+        }
+    }
+
+    private static String addKeyword(String keywords, String addition) {
+        if (addition == null || addition.length() == 0) {
+            return keywords;
+        } else if (keywords == null || keywords.length() == 0) {
+            return addition;
+        } else {
+            return keywords + "," + addition;
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/AsyncTasks.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/AsyncTasks.java
deleted file mode 100644
index 9cc59c81..00000000
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/AsyncTasks.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package com.mopub.mobileads.util;
-
-import android.os.AsyncTask;
-
-import java.util.concurrent.*;
-
-import static com.mopub.mobileads.util.Reflection.MethodBuilder;
-import static com.mopub.mobileads.util.VersionCode.ICE_CREAM_SANDWICH;
-import static com.mopub.mobileads.util.VersionCode.currentApiLevel;
-
-public class AsyncTasks {
-    public static <P> void safeExecuteOnExecutor(AsyncTask<P, ?, ?> asyncTask, P... params) throws Exception {
-        if (asyncTask == null) {
-            throw new IllegalArgumentException("Unable to execute null AsyncTask.");
-        }
-
-        if (currentApiLevel().isAtLeast(ICE_CREAM_SANDWICH)) {
-            Executor threadPoolExecutor = (Executor) AsyncTask.class.getField("THREAD_POOL_EXECUTOR").get(AsyncTask.class);
-
-            new MethodBuilder(asyncTask, "executeOnExecutor")
-                    .addParam(Executor.class, threadPoolExecutor)
-                    .addParam(Object[].class, params)
-                    .execute();
-        } else {
-            asyncTask.execute(params);
-        }
-    }
-}
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/Mraids.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/Mraids.java
index 96175bbf..55ad6d0f 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/Mraids.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/util/Mraids.java
@@ -37,8 +37,10 @@
 import android.content.pm.PackageManager;
 import android.net.Uri;
 import android.os.Environment;
+
+import com.mopub.common.util.IntentUtils;
+import com.mopub.common.util.VersionCode;
 import com.mopub.mobileads.MraidVideoPlayerActivity;
-import com.mopub.mobileads.Utils;
 
 import static android.Manifest.permission.WRITE_EXTERNAL_STORAGE;
 import static android.os.Environment.MEDIA_MOUNTED;
@@ -50,14 +52,14 @@ public static boolean isTelAvailable(Context context) {
         Intent telIntent = new Intent(Intent.ACTION_DIAL);
         telIntent.setData(Uri.parse("tel:"));
 
-        return Utils.deviceCanHandleIntent(context, telIntent);
+        return IntentUtils.deviceCanHandleIntent(context, telIntent);
     }
 
     public static boolean isSmsAvailable(Context context) {
         Intent smsIntent = new Intent(Intent.ACTION_VIEW);
         smsIntent.setData(Uri.parse("sms:"));
 
-        return Utils.deviceCanHandleIntent(context, smsIntent);
+        return IntentUtils.deviceCanHandleIntent(context, smsIntent);
     }
 
     public static boolean isStorePictureSupported(Context context) {
@@ -69,12 +71,12 @@ public static boolean isCalendarAvailable(Context context) {
         Intent calendarIntent = new Intent(Intent.ACTION_INSERT).setType(ANDROID_CALENDAR_CONTENT_TYPE);
 
         return VersionCode.currentApiLevel().isAtLeast(VersionCode.ICE_CREAM_SANDWICH)
-                && Utils.deviceCanHandleIntent(context, calendarIntent);
+                && IntentUtils.deviceCanHandleIntent(context, calendarIntent);
     }
 
     public static boolean isInlineVideoAvailable(Context context) {
         Intent mraidVideoIntent = new Intent(context, MraidVideoPlayerActivity.class);
 
-        return Utils.deviceCanHandleIntent(context, mraidVideoIntent);
+        return IntentUtils.deviceCanHandleIntent(context, mraidVideoIntent);
     }
 }
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/Utils.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/Utils.java
new file mode 100644
index 00000000..6ed1f14e
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/util/Utils.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2010-2013, MoPub Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *  Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in the
+ *   documentation and/or other materials provided with the distribution.
+ *
+ *  Neither the name of 'MoPub Inc.' nor the names of its contributors
+ *   may be used to endorse or promote products derived from this software
+ *   without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.mopub.mobileads.util;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.util.Log;
+
+public class Utils {
+    private Utils() {}
+
+    public static boolean executeIntent(Context context, Intent intent, String errorMessage) {
+        try {
+            if (!(context instanceof Activity)) {
+                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+            }
+            context.startActivity(intent);
+        } catch (Exception e) {
+            Log.d("MoPub", (errorMessage != null)
+                    ? errorMessage
+                    : "Unable to start intent.");
+            return false;
+        }
+        return true;
+    }
+}
\ No newline at end of file
diff --git a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastManager.java b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastManager.java
index c212d9ea..da600cfd 100644
--- a/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastManager.java
+++ b/mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastManager.java
@@ -3,17 +3,15 @@
 import android.os.AsyncTask;
 import android.util.Log;
 
+import com.mopub.common.util.Strings;
 import com.mopub.mobileads.factories.HttpClientFactory;
 import com.mopub.mobileads.util.HttpClients;
-import com.mopub.mobileads.util.Strings;
+
 import org.apache.http.HttpEntity;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.HttpClient;
 import org.apache.http.client.methods.HttpGet;
-import org.xml.sax.SAXException;
 
-import javax.xml.parsers.ParserConfigurationException;
-import java.io.*;
 import java.util.*;
 
 public class VastManager {
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/AdapterHelper.java b/mopub-sdk/src/main/java/com/mopub/nativeads/AdapterHelper.java
new file mode 100644
index 00000000..d735504e
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/AdapterHelper.java
@@ -0,0 +1,90 @@
+package com.mopub.nativeads;
+
+import android.content.Context;
+import android.view.View;
+import android.view.ViewGroup;
+
+import static com.mopub.nativeads.MoPubNative.MoPubNativeListener;
+
+public final class AdapterHelper {
+    private final Context mContext;
+    private final int mStart;
+    private final int mInterval;
+
+    public AdapterHelper(final Context context, final int start, final int interval) throws IllegalArgumentException {
+        if (context == null) {
+            throw new IllegalArgumentException("Illegal argument: context was null.");
+        } else if (start < 0) {
+            throw new IllegalArgumentException("Illegal argument: negative starting position.");
+        } else if (interval < 2) {
+            throw new IllegalArgumentException("Illegal argument: interval must be at least 2.");
+        }
+
+        mContext = context.getApplicationContext();
+        mStart = start;
+        mInterval = interval;
+    }
+
+    public View getAdView(final View convertView,
+                          final ViewGroup parent,
+                          final NativeResponse nativeResponse,
+                          final ViewBinder viewBinder,
+                          final MoPubNativeListener moPubNativeListener) {
+        return NativeAdViewHelper.getAdView(
+                convertView,
+                parent,
+                mContext,
+                nativeResponse,
+                viewBinder,
+                moPubNativeListener
+        );
+    }
+
+    // Total number of content rows + ad rows
+    public int shiftedCount(final int originalCount) {
+        return originalCount + numberOfAdsThatCouldFitWithContent(originalCount);
+    }
+
+    // Shifted position of content in the backing list
+    public int shiftedPosition(final int position) {
+        return position - numberOfAdsSeenUpToPosition(position);
+    }
+
+    public boolean isAdPosition(final int position) {
+        if (position < mStart) {
+            return false;
+        }
+
+        return ((position - mStart) % mInterval == 0);
+    }
+
+    private int numberOfAdsSeenUpToPosition(final int position) {
+        // This method takes a position from a list of content and ads mixed together
+        // and calculates the number of ads seen up to that point
+
+        if (position <= mStart) {
+            return 0;
+        }
+
+        // Add 1 to the result since we start with an ad at start position and round down
+        return (int) Math.floor((double) (position - mStart) / mInterval) + 1;
+    }
+
+    private int numberOfAdsThatCouldFitWithContent(final int contentRowCount) {
+        // This method is passed the number of content rows from the backing list
+        // and calculates how many ads could fit in with the content
+
+        if (contentRowCount <= mStart) {
+            return 0;
+        }
+
+        final int spacesBetweenAds = mInterval - 1;
+        if ((contentRowCount - mStart) % spacesBetweenAds == 0) {
+            // Don't add 1 to result since we never include an ad at the last position in the list
+            return (contentRowCount - mStart) / spacesBetweenAds;
+        } else {
+            // Add 1 to the result since we start with an ad at start position and round down
+            return (int) Math.floor((double) (contentRowCount - mStart) / spacesBetweenAds) + 1;
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/CacheService.java b/mopub-sdk/src/main/java/com/mopub/nativeads/CacheService.java
new file mode 100644
index 00000000..dc310b10
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/CacheService.java
@@ -0,0 +1,260 @@
+package com.mopub.nativeads;
+
+import android.content.Context;
+import android.os.AsyncTask;
+import android.support.v4.util.LruCache;
+
+import com.mopub.common.util.DeviceUtils;
+import com.mopub.common.util.Streams;
+import com.mopub.common.util.Utils;
+
+import java.io.BufferedInputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+import static com.mopub.nativeads.DiskLruCache.open;
+import static com.mopub.nativeads.util.Utils.MoPubLog;
+
+class CacheService {
+    static final String UNIQUE_CACHE_NAME = "mopub-cache";
+    private static final int APP_VERSION = 1;
+    // The number of values per cache entry. Must be positive.
+    private static final int VALUE_COUNT = 1;
+
+    private static DiskLruCache sDiskLruCache;
+    private static MemoryLruCache sMemoryLruCache;
+
+    static void initializeCaches(final Context context) {
+        if (sDiskLruCache == null) {
+            final File cacheDirectory = getDiskCacheDirectory(context);
+            final long diskCacheSizeBytes = DeviceUtils.diskCacheSizeBytes(cacheDirectory);
+            try {
+                sDiskLruCache = open(
+                        cacheDirectory,
+                        APP_VERSION,
+                        VALUE_COUNT,
+                        diskCacheSizeBytes
+                );
+            } catch (IOException e) {
+                MoPubLog("Unable to create DiskLruCache", e);
+            }
+        }
+
+        if (sMemoryLruCache == null) {
+            final int memoryCacheSizeBytes = DeviceUtils.memoryCacheSizeBytes(context);
+            sMemoryLruCache = new MemoryLruCache(memoryCacheSizeBytes);
+        }
+    }
+
+    static String createValidDiskCacheKey(final String key) {
+        return Utils.sha1(key);
+    }
+
+    static File getDiskCacheDirectory(final Context context) {
+        final String cachePath = context.getCacheDir().getPath();
+        return new File(cachePath + File.separator + UNIQUE_CACHE_NAME);
+    }
+
+    static byte[] getFromMemoryCache(final String key) {
+        if (sMemoryLruCache == null) {
+            return null;
+        }
+
+        return sMemoryLruCache.get(key);
+    }
+
+    static byte[] getFromDiskCache(final String key) {
+        if (sDiskLruCache == null) {
+            return null;
+        }
+
+        byte[] bytes = null;
+        DiskLruCache.Snapshot snapshot = null;
+        try {
+            snapshot = sDiskLruCache.get(createValidDiskCacheKey(key));
+            if (snapshot == null) {
+                return null;
+            }
+
+            final InputStream in = snapshot.getInputStream(0);
+            if (in != null) {
+                bytes = new byte[(int)snapshot.getLength(0)];
+                final BufferedInputStream buffIn = new BufferedInputStream(in);
+                try {
+                    Streams.readStream(buffIn, bytes);
+                } finally {
+                    Streams.closeStream(buffIn);
+                }
+            }
+        } catch (Exception e) {
+            MoPubLog("Unable to get from DiskLruCache", e);
+        } finally {
+            if (snapshot != null) {
+                snapshot.close();
+            }
+        }
+
+        return bytes;
+    }
+
+    static void getFromDiskCacheAsync(final String key, final DiskLruCacheGetListener diskLruCacheGetListener) {
+        new DiskLruCacheGetTask(key, diskLruCacheGetListener).execute();
+    }
+
+    static byte[] get(final String key) {
+        byte[] bytes = getFromMemoryCache(key);
+        if (bytes != null) {
+            return bytes;
+        }
+        return getFromDiskCache(key);
+    }
+
+    static void putToMemoryCache(final String key, final byte[] content) {
+        if (sMemoryLruCache == null) {
+            return;
+        }
+
+        sMemoryLruCache.put(key, content);
+    }
+
+    static void putToDiskCache(final String key, final byte[] content) {
+        if (sDiskLruCache == null) {
+            return;
+        }
+
+        DiskLruCache.Editor editor = null;
+        try {
+            editor = sDiskLruCache.edit(createValidDiskCacheKey(key));
+
+            if (editor == null) {
+                // another edit is in progress
+                return;
+            }
+
+            final OutputStream outputStream = editor.newOutputStream(0);
+            outputStream.write(content);
+            outputStream.close();
+
+            sDiskLruCache.flush();
+            editor.commit();
+        } catch (Exception e) {
+            MoPubLog("Unable to put to DiskLruCache", e);
+            try {
+                if (editor != null) {
+                    editor.abort();
+                }
+            } catch (IOException ignore) {
+                // ignore
+            }
+        }
+    }
+
+    static void putToDiskCacheAsync(final String key, final byte[] content) {
+        new DiskLruCachePutTask(key, content).execute();
+    }
+
+    static void put(final String key, final byte[] content) {
+        putToMemoryCache(key, content);
+        putToDiskCacheAsync(key, content);
+    }
+
+    private static class MemoryLruCache extends LruCache<String, byte[]> {
+        public MemoryLruCache(int maxSize) {
+            super(maxSize);
+        }
+
+        @Override
+        protected int sizeOf(final String key, final byte[] bytes) {
+            if (bytes != null && bytes.length > 0) {
+                return bytes.length;
+            }
+
+            return super.sizeOf(key, bytes);
+        }
+    }
+
+    static interface DiskLruCacheGetListener {
+        void onComplete(final String key, final byte[] content);
+    }
+
+    private static class DiskLruCacheGetTask extends AsyncTask<Void, Void, byte[]> {
+        private final DiskLruCacheGetListener mDiskLruCacheGetListener;
+        private final String mKey;
+
+        DiskLruCacheGetTask(final String key, final DiskLruCacheGetListener diskLruCacheGetListener) {
+            mDiskLruCacheGetListener = diskLruCacheGetListener;
+            mKey = key;
+        }
+
+        @Override
+        protected byte[] doInBackground(Void... voids) {
+            return CacheService.getFromDiskCache(mKey);
+        }
+
+        @Override
+        protected void onPostExecute(final byte[] bytes) {
+            if (isCancelled()) {
+                onCancelled();
+                return;
+            }
+
+            if (mDiskLruCacheGetListener != null) {
+                mDiskLruCacheGetListener.onComplete(mKey, bytes);
+            }
+        }
+
+        @Override
+        protected void onCancelled() {
+            if (mDiskLruCacheGetListener != null) {
+                mDiskLruCacheGetListener.onComplete(mKey, null);
+            }
+        }
+    }
+
+    private static class DiskLruCachePutTask extends AsyncTask<Void, Void, Void> {
+        private final String mKey;
+        private final byte[] mContent;
+
+        DiskLruCachePutTask(final String key, final byte[] content) {
+            mKey = key;
+            mContent = content;
+        }
+
+        @Override
+        protected Void doInBackground(Void... voids) {
+            CacheService.putToDiskCache(mKey, mContent);
+            return null;
+        }
+    }
+
+    // Testing
+    @Deprecated
+    static void clearAndNullCaches() {
+        if (sDiskLruCache != null) {
+            try {
+                sDiskLruCache.delete();
+                sDiskLruCache = null;
+            } catch (IOException ignore) {
+                sDiskLruCache = null;
+            }
+        }
+        if (sMemoryLruCache != null) {
+            sMemoryLruCache.evictAll();
+            sMemoryLruCache = null;
+        }
+    }
+
+    // Testing
+    @Deprecated
+    static LruCache<String, byte[]> getMemoryLruCache() {
+        return sMemoryLruCache;
+    }
+
+    // Testing
+    @Deprecated
+    static DiskLruCache getDiskLruCache() {
+        return sDiskLruCache;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/Constants.java b/mopub-sdk/src/main/java/com/mopub/nativeads/Constants.java
new file mode 100644
index 00000000..389731aa
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/Constants.java
@@ -0,0 +1,8 @@
+package com.mopub.nativeads;
+
+public class Constants {
+    public static final String LOGTAG = "MoPub Native";
+
+    static final String NATIVE_HOST = "ads.mopub.com";
+    static final String NATIVE_HANDLER = "/m/ad";
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/DiskLruCache.java b/mopub-sdk/src/main/java/com/mopub/nativeads/DiskLruCache.java
new file mode 100644
index 00000000..80ee56ea
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/DiskLruCache.java
@@ -0,0 +1,930 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.mopub.nativeads;
+
+import java.io.BufferedWriter;
+import java.io.Closeable;
+import java.io.EOFException;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.FilterOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.io.Writer;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.concurrent.Callable;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * A cache that uses a bounded amount of space on a filesystem. Each cache
+ * entry has a string key and a fixed number of values. Each key must match
+ * the regex <strong>[a-z0-9_-]{1,64}</strong>. Values are byte sequences,
+ * accessible as streams or files. Each value must be between {@code 0} and
+ * {@code Integer.MAX_VALUE} bytes in length.
+ *
+ * <p>The cache stores its data in a directory on the filesystem. This
+ * directory must be exclusive to the cache; the cache may delete or overwrite
+ * files from its directory. It is an error for multiple processes to use the
+ * same cache directory at the same time.
+ *
+ * <p>This cache limits the number of bytes that it will store on the
+ * filesystem. When the number of stored bytes exceeds the limit, the cache will
+ * remove entries in the background until the limit is satisfied. The limit is
+ * not strict: the cache may temporarily exceed it while waiting for files to be
+ * deleted. The limit does not include filesystem overhead or the cache
+ * journal so space-sensitive applications should set a conservative limit.
+ *
+ * <p>Clients call {@link #edit} to create or update the values of an entry. An
+ * entry may have only one editor at one time; if a value is not available to be
+ * edited then {@link #edit} will return null.
+ * <ul>
+ * <li>When an entry is being <strong>created</strong> it is necessary to
+ * supply a full set of values; the empty value should be used as a
+ * placeholder if necessary.
+ * <li>When an entry is being <strong>edited</strong>, it is not necessary
+ * to supply data for every value; values default to their previous
+ * value.
+ * </ul>
+ * Every {@link #edit} call must be matched by a call to {@link Editor#commit}
+ * or {@link Editor#abort}. Committing is atomic: a read observes the full set
+ * of values as they were before or after the commit, but never a mix of values.
+ *
+ * <p>Clients call {@link #get} to read a snapshot of an entry. The read will
+ * observe the value at the time that {@link #get} was called. Updates and
+ * removals after the call do not impact ongoing reads.
+ *
+ * <p>This class is tolerant of some I/O errors. If files are missing from the
+ * filesystem, the corresponding entries will be dropped from the cache. If
+ * an error occurs while writing a cache value, the edit will fail silently.
+ * Callers should handle other problems by catching {@code IOException} and
+ * responding appropriately.
+ */
+public final class DiskLruCache implements Closeable {
+  static final String JOURNAL_FILE = "journal";
+  static final String JOURNAL_FILE_TEMP = "journal.tmp";
+  static final String JOURNAL_FILE_BACKUP = "journal.bkp";
+  static final String MAGIC = "libcore.io.DiskLruCache";
+  static final String VERSION_1 = "1";
+  static final long ANY_SEQUENCE_NUMBER = -1;
+  static final Pattern LEGAL_KEY_PATTERN = Pattern.compile("[a-z0-9_-]{1,64}");
+  private static final String CLEAN = "CLEAN";
+  private static final String DIRTY = "DIRTY";
+  private static final String REMOVE = "REMOVE";
+  private static final String READ = "READ";
+
+    /*
+     * This cache uses a journal file named "journal". A typical journal file
+     * looks like this:
+     *     libcore.io.DiskLruCache
+     *     1
+     *     100
+     *     2
+     *
+     *     CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054
+     *     DIRTY 335c4c6028171cfddfbaae1a9c313c52
+     *     CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342
+     *     REMOVE 335c4c6028171cfddfbaae1a9c313c52
+     *     DIRTY 1ab96a171faeeee38496d8b330771a7a
+     *     CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234
+     *     READ 335c4c6028171cfddfbaae1a9c313c52
+     *     READ 3400330d1dfc7f3f7f4b8d4d803dfcf6
+     *
+     * The first five lines of the journal form its header. They are the
+     * constant string "libcore.io.DiskLruCache", the disk cache's version,
+     * the application's version, the value count, and a blank line.
+     *
+     * Each of the subsequent lines in the file is a record of the state of a
+     * cache entry. Each line contains space-separated values: a state, a key,
+     * and optional state-specific values.
+     *   o DIRTY lines track that an entry is actively being created or updated.
+     *     Every successful DIRTY action should be followed by a CLEAN or REMOVE
+     *     action. DIRTY lines without a matching CLEAN or REMOVE indicate that
+     *     temporary files may need to be deleted.
+     *   o CLEAN lines track a cache entry that has been successfully published
+     *     and may be read. A publish line is followed by the lengths of each of
+     *     its values.
+     *   o READ lines track accesses for LRU.
+     *   o REMOVE lines track entries that have been deleted.
+     *
+     * The journal file is appended to as cache operations occur. The journal may
+     * occasionally be compacted by dropping redundant lines. A temporary file named
+     * "journal.tmp" will be used during compaction; that file should be deleted if
+     * it exists when the cache is opened.
+     */
+
+  private final File directory;
+  private final File journalFile;
+  private final File journalFileTmp;
+  private final File journalFileBackup;
+  private final int appVersion;
+  private long maxSize;
+  private final int valueCount;
+  private long size = 0;
+  private Writer journalWriter;
+  private final LinkedHashMap<String, Entry> lruEntries =
+      new LinkedHashMap<String, Entry>(0, 0.75f, true);
+  private int redundantOpCount;
+
+  /**
+   * To differentiate between old and current snapshots, each entry is given
+   * a sequence number each time an edit is committed. A snapshot is stale if
+   * its sequence number is not equal to its entry's sequence number.
+   */
+  private long nextSequenceNumber = 0;
+
+  /** This cache uses a single background thread to evict entries. */
+  final ThreadPoolExecutor executorService =
+      new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
+  private final Callable<Void> cleanupCallable = new Callable<Void>() {
+    public Void call() throws Exception {
+      synchronized (DiskLruCache.this) {
+        if (journalWriter == null) {
+          return null; // Closed.
+        }
+        trimToSize();
+        if (journalRebuildRequired()) {
+          rebuildJournal();
+          redundantOpCount = 0;
+        }
+      }
+      return null;
+    }
+  };
+
+  private DiskLruCache(File directory, int appVersion, int valueCount, long maxSize) {
+    this.directory = directory;
+    this.appVersion = appVersion;
+    this.journalFile = new File(directory, JOURNAL_FILE);
+    this.journalFileTmp = new File(directory, JOURNAL_FILE_TEMP);
+    this.journalFileBackup = new File(directory, JOURNAL_FILE_BACKUP);
+    this.valueCount = valueCount;
+    this.maxSize = maxSize;
+  }
+
+  /**
+   * Opens the cache in {@code directory}, creating a cache if none exists
+   * there.
+   *
+   * @param directory a writable directory
+   * @param valueCount the number of values per cache entry. Must be positive.
+   * @param maxSize the maximum number of bytes this cache should use to store
+   * @throws IOException if reading or writing the cache directory fails
+   */
+  public static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize)
+      throws IOException {
+    if (maxSize <= 0) {
+      throw new IllegalArgumentException("maxSize <= 0");
+    }
+    if (valueCount <= 0) {
+      throw new IllegalArgumentException("valueCount <= 0");
+    }
+
+    // If a bkp file exists, use it instead.
+    File backupFile = new File(directory, JOURNAL_FILE_BACKUP);
+    if (backupFile.exists()) {
+      File journalFile = new File(directory, JOURNAL_FILE);
+      // If journal file also exists just delete backup file.
+      if (journalFile.exists()) {
+        backupFile.delete();
+      } else {
+        renameTo(backupFile, journalFile, false);
+      }
+    }
+
+    // Prefer to pick up where we left off.
+    DiskLruCache cache = new DiskLruCache(directory, appVersion, valueCount, maxSize);
+    if (cache.journalFile.exists()) {
+      try {
+        cache.readJournal();
+        cache.processJournal();
+        cache.journalWriter = new BufferedWriter(
+            new OutputStreamWriter(new FileOutputStream(cache.journalFile, true), DiskLruCacheUtil.US_ASCII));
+        return cache;
+      } catch (IOException journalIsCorrupt) {
+        System.out
+            .println("DiskLruCache "
+                + directory
+                + " is corrupt: "
+                + journalIsCorrupt.getMessage()
+                + ", removing");
+        cache.delete();
+      }
+    }
+
+    // Create a new empty cache.
+    directory.mkdirs();
+    cache = new DiskLruCache(directory, appVersion, valueCount, maxSize);
+    cache.rebuildJournal();
+    return cache;
+  }
+
+  private void readJournal() throws IOException {
+    DiskLruCacheStrictLineReader reader = new DiskLruCacheStrictLineReader(new FileInputStream(journalFile), DiskLruCacheUtil.US_ASCII);
+    try {
+      String magic = reader.readLine();
+      String version = reader.readLine();
+      String appVersionString = reader.readLine();
+      String valueCountString = reader.readLine();
+      String blank = reader.readLine();
+      if (!MAGIC.equals(magic)
+          || !VERSION_1.equals(version)
+          || !Integer.toString(appVersion).equals(appVersionString)
+          || !Integer.toString(valueCount).equals(valueCountString)
+          || !"".equals(blank)) {
+        throw new IOException("unexpected journal header: [" + magic + ", " + version + ", "
+            + valueCountString + ", " + blank + "]");
+      }
+
+      int lineCount = 0;
+      while (true) {
+        try {
+          readJournalLine(reader.readLine());
+          lineCount++;
+        } catch (EOFException endOfJournal) {
+          break;
+        }
+      }
+      redundantOpCount = lineCount - lruEntries.size();
+    } finally {
+      DiskLruCacheUtil.closeQuietly(reader);
+    }
+  }
+
+  private void readJournalLine(String line) throws IOException {
+    int firstSpace = line.indexOf(' ');
+    if (firstSpace == -1) {
+      throw new IOException("unexpected journal line: " + line);
+    }
+
+    int keyBegin = firstSpace + 1;
+    int secondSpace = line.indexOf(' ', keyBegin);
+    final String key;
+    if (secondSpace == -1) {
+      key = line.substring(keyBegin);
+      if (firstSpace == REMOVE.length() && line.startsWith(REMOVE)) {
+        lruEntries.remove(key);
+        return;
+      }
+    } else {
+      key = line.substring(keyBegin, secondSpace);
+    }
+
+    Entry entry = lruEntries.get(key);
+    if (entry == null) {
+      entry = new Entry(key);
+      lruEntries.put(key, entry);
+    }
+
+    if (secondSpace != -1 && firstSpace == CLEAN.length() && line.startsWith(CLEAN)) {
+      String[] parts = line.substring(secondSpace + 1).split(" ");
+      entry.readable = true;
+      entry.currentEditor = null;
+      entry.setLengths(parts);
+    } else if (secondSpace == -1 && firstSpace == DIRTY.length() && line.startsWith(DIRTY)) {
+      entry.currentEditor = new Editor(entry);
+    } else if (secondSpace == -1 && firstSpace == READ.length() && line.startsWith(READ)) {
+      // This work was already done by calling lruEntries.get().
+    } else {
+      throw new IOException("unexpected journal line: " + line);
+    }
+  }
+
+  /**
+   * Computes the initial size and collects garbage as a part of opening the
+   * cache. Dirty entries are assumed to be inconsistent and will be deleted.
+   */
+  private void processJournal() throws IOException {
+    deleteIfExists(journalFileTmp);
+    for (Iterator<Entry> i = lruEntries.values().iterator(); i.hasNext(); ) {
+      Entry entry = i.next();
+      if (entry.currentEditor == null) {
+        for (int t = 0; t < valueCount; t++) {
+          size += entry.lengths[t];
+        }
+      } else {
+        entry.currentEditor = null;
+        for (int t = 0; t < valueCount; t++) {
+          deleteIfExists(entry.getCleanFile(t));
+          deleteIfExists(entry.getDirtyFile(t));
+        }
+        i.remove();
+      }
+    }
+  }
+
+  /**
+   * Creates a new journal that omits redundant information. This replaces the
+   * current journal if it exists.
+   */
+  private synchronized void rebuildJournal() throws IOException {
+    if (journalWriter != null) {
+      journalWriter.close();
+    }
+
+    Writer writer = new BufferedWriter(
+        new OutputStreamWriter(new FileOutputStream(journalFileTmp), DiskLruCacheUtil.US_ASCII));
+    try {
+      writer.write(MAGIC);
+      writer.write("\n");
+      writer.write(VERSION_1);
+      writer.write("\n");
+      writer.write(Integer.toString(appVersion));
+      writer.write("\n");
+      writer.write(Integer.toString(valueCount));
+      writer.write("\n");
+      writer.write("\n");
+
+      for (Entry entry : lruEntries.values()) {
+        if (entry.currentEditor != null) {
+          writer.write(DIRTY + ' ' + entry.key + '\n');
+        } else {
+          writer.write(CLEAN + ' ' + entry.key + entry.getLengths() + '\n');
+        }
+      }
+    } finally {
+      writer.close();
+    }
+
+    if (journalFile.exists()) {
+      renameTo(journalFile, journalFileBackup, true);
+    }
+    renameTo(journalFileTmp, journalFile, false);
+    journalFileBackup.delete();
+
+    journalWriter = new BufferedWriter(
+        new OutputStreamWriter(new FileOutputStream(journalFile, true), DiskLruCacheUtil.US_ASCII));
+  }
+
+  private static void deleteIfExists(File file) throws IOException {
+    if (file.exists() && !file.delete()) {
+      throw new IOException();
+    }
+  }
+
+  private static void renameTo(File from, File to, boolean deleteDestination) throws IOException {
+    if (deleteDestination) {
+      deleteIfExists(to);
+    }
+    if (!from.renameTo(to)) {
+      throw new IOException();
+    }
+  }
+
+  /**
+   * Returns a snapshot of the entry named {@code key}, or null if it doesn't
+   * exist is not currently readable. If a value is returned, it is moved to
+   * the head of the LRU queue.
+   */
+  public synchronized Snapshot get(String key) throws IOException {
+    checkNotClosed();
+    validateKey(key);
+    Entry entry = lruEntries.get(key);
+    if (entry == null) {
+      return null;
+    }
+
+    if (!entry.readable) {
+      return null;
+    }
+
+    // Open all streams eagerly to guarantee that we see a single published
+    // snapshot. If we opened streams lazily then the streams could come
+    // from different edits.
+    InputStream[] ins = new InputStream[valueCount];
+    try {
+      for (int i = 0; i < valueCount; i++) {
+        ins[i] = new FileInputStream(entry.getCleanFile(i));
+      }
+    } catch (FileNotFoundException e) {
+      // A file must have been deleted manually!
+      for (int i = 0; i < valueCount; i++) {
+        if (ins[i] != null) {
+          DiskLruCacheUtil.closeQuietly(ins[i]);
+        } else {
+          break;
+        }
+      }
+      return null;
+    }
+
+    redundantOpCount++;
+    journalWriter.append(READ + ' ' + key + '\n');
+    if (journalRebuildRequired()) {
+      executorService.submit(cleanupCallable);
+    }
+
+    return new Snapshot(key, entry.sequenceNumber, ins, entry.lengths);
+  }
+
+  /**
+   * Returns an editor for the entry named {@code key}, or null if another
+   * edit is in progress.
+   */
+  public Editor edit(String key) throws IOException {
+    return edit(key, ANY_SEQUENCE_NUMBER);
+  }
+
+  private synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException {
+    checkNotClosed();
+    validateKey(key);
+    Entry entry = lruEntries.get(key);
+    if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER && (entry == null
+        || entry.sequenceNumber != expectedSequenceNumber)) {
+      return null; // Snapshot is stale.
+    }
+    if (entry == null) {
+      entry = new Entry(key);
+      lruEntries.put(key, entry);
+    } else if (entry.currentEditor != null) {
+      return null; // Another edit is in progress.
+    }
+
+    Editor editor = new Editor(entry);
+    entry.currentEditor = editor;
+
+    // Flush the journal before creating files to prevent file leaks.
+    journalWriter.write(DIRTY + ' ' + key + '\n');
+    journalWriter.flush();
+    return editor;
+  }
+
+  /** Returns the directory where this cache stores its data. */
+  public File getDirectory() {
+    return directory;
+  }
+
+  /**
+   * Returns the maximum number of bytes that this cache should use to store
+   * its data.
+   */
+  public synchronized long getMaxSize() {
+    return maxSize;
+  }
+
+  /**
+   * Changes the maximum number of bytes the cache can store and queues a job
+   * to trim the existing store, if necessary.
+   */
+  public synchronized void setMaxSize(long maxSize) {
+    this.maxSize = maxSize;
+    executorService.submit(cleanupCallable);
+  }
+
+  /**
+   * Returns the number of bytes currently being used to store the values in
+   * this cache. This may be greater than the max size if a background
+   * deletion is pending.
+   */
+  public synchronized long size() {
+    return size;
+  }
+
+  private synchronized void completeEdit(Editor editor, boolean success) throws IOException {
+    Entry entry = editor.entry;
+    if (entry.currentEditor != editor) {
+      throw new IllegalStateException();
+    }
+
+    // If this edit is creating the entry for the first time, every index must have a value.
+    if (success && !entry.readable) {
+      for (int i = 0; i < valueCount; i++) {
+        if (!editor.written[i]) {
+          editor.abort();
+          throw new IllegalStateException("Newly created entry didn't create value for index " + i);
+        }
+        if (!entry.getDirtyFile(i).exists()) {
+          editor.abort();
+          return;
+        }
+      }
+    }
+
+    for (int i = 0; i < valueCount; i++) {
+      File dirty = entry.getDirtyFile(i);
+      if (success) {
+        if (dirty.exists()) {
+          File clean = entry.getCleanFile(i);
+          dirty.renameTo(clean);
+          long oldLength = entry.lengths[i];
+          long newLength = clean.length();
+          entry.lengths[i] = newLength;
+          size = size - oldLength + newLength;
+        }
+      } else {
+        deleteIfExists(dirty);
+      }
+    }
+
+    redundantOpCount++;
+    entry.currentEditor = null;
+    if (entry.readable | success) {
+      entry.readable = true;
+      journalWriter.write(CLEAN + ' ' + entry.key + entry.getLengths() + '\n');
+      if (success) {
+        entry.sequenceNumber = nextSequenceNumber++;
+      }
+    } else {
+      lruEntries.remove(entry.key);
+      journalWriter.write(REMOVE + ' ' + entry.key + '\n');
+    }
+    journalWriter.flush();
+
+    if (size > maxSize || journalRebuildRequired()) {
+      executorService.submit(cleanupCallable);
+    }
+  }
+
+  /**
+   * We only rebuild the journal when it will halve the size of the journal
+   * and eliminate at least 2000 ops.
+   */
+  private boolean journalRebuildRequired() {
+    final int redundantOpCompactThreshold = 2000;
+    return redundantOpCount >= redundantOpCompactThreshold //
+        && redundantOpCount >= lruEntries.size();
+  }
+
+  /**
+   * Drops the entry for {@code key} if it exists and can be removed. Entries
+   * actively being edited cannot be removed.
+   *
+   * @return true if an entry was removed.
+   */
+  public synchronized boolean remove(String key) throws IOException {
+    checkNotClosed();
+    validateKey(key);
+    Entry entry = lruEntries.get(key);
+    if (entry == null || entry.currentEditor != null) {
+      return false;
+    }
+
+    for (int i = 0; i < valueCount; i++) {
+      File file = entry.getCleanFile(i);
+      if (file.exists() && !file.delete()) {
+        throw new IOException("failed to delete " + file);
+      }
+      size -= entry.lengths[i];
+      entry.lengths[i] = 0;
+    }
+
+    redundantOpCount++;
+    journalWriter.append(REMOVE + ' ' + key + '\n');
+    lruEntries.remove(key);
+
+    if (journalRebuildRequired()) {
+      executorService.submit(cleanupCallable);
+    }
+
+    return true;
+  }
+
+  /** Returns true if this cache has been closed. */
+  public synchronized boolean isClosed() {
+    return journalWriter == null;
+  }
+
+  private void checkNotClosed() {
+    if (journalWriter == null) {
+      throw new IllegalStateException("cache is closed");
+    }
+  }
+
+  /** Force buffered operations to the filesystem. */
+  public synchronized void flush() throws IOException {
+    checkNotClosed();
+    trimToSize();
+    journalWriter.flush();
+  }
+
+  /** Closes this cache. Stored values will remain on the filesystem. */
+  public synchronized void close() throws IOException {
+    if (journalWriter == null) {
+      return; // Already closed.
+    }
+    for (Entry entry : new ArrayList<Entry>(lruEntries.values())) {
+      if (entry.currentEditor != null) {
+        entry.currentEditor.abort();
+      }
+    }
+    trimToSize();
+    journalWriter.close();
+    journalWriter = null;
+  }
+
+  private void trimToSize() throws IOException {
+    while (size > maxSize) {
+      Map.Entry<String, Entry> toEvict = lruEntries.entrySet().iterator().next();
+      remove(toEvict.getKey());
+    }
+  }
+
+  /**
+   * Closes the cache and deletes all of its stored values. This will delete
+   * all files in the cache directory including files that weren't created by
+   * the cache.
+   */
+  public void delete() throws IOException {
+    close();
+    DiskLruCacheUtil.deleteContents(directory);
+  }
+
+  private void validateKey(String key) {
+    Matcher matcher = LEGAL_KEY_PATTERN.matcher(key);
+    if (!matcher.matches()) {
+      throw new IllegalArgumentException("keys must match regex [a-z0-9_-]{1,64}: \"" + key + "\"");
+    }
+  }
+
+  private static String inputStreamToString(InputStream in) throws IOException {
+    return DiskLruCacheUtil.readFully(new InputStreamReader(in, DiskLruCacheUtil.UTF_8));
+  }
+
+  /** A snapshot of the values for an entry. */
+  public final class Snapshot implements Closeable {
+    private final String key;
+    private final long sequenceNumber;
+    private final InputStream[] ins;
+    private final long[] lengths;
+
+    private Snapshot(String key, long sequenceNumber, InputStream[] ins, long[] lengths) {
+      this.key = key;
+      this.sequenceNumber = sequenceNumber;
+      this.ins = ins;
+      this.lengths = lengths;
+    }
+
+    /**
+     * Returns an editor for this snapshot's entry, or null if either the
+     * entry has changed since this snapshot was created or if another edit
+     * is in progress.
+     */
+    public Editor edit() throws IOException {
+      return DiskLruCache.this.edit(key, sequenceNumber);
+    }
+
+    /** Returns the unbuffered stream with the value for {@code index}. */
+    public InputStream getInputStream(int index) {
+      return ins[index];
+    }
+
+    /** Returns the string value for {@code index}. */
+    public String getString(int index) throws IOException {
+      return inputStreamToString(getInputStream(index));
+    }
+
+    /** Returns the byte length of the value for {@code index}. */
+    public long getLength(int index) {
+      return lengths[index];
+    }
+
+    public void close() {
+      for (InputStream in : ins) {
+        DiskLruCacheUtil.closeQuietly(in);
+      }
+    }
+  }
+
+  private static final OutputStream NULL_OUTPUT_STREAM = new OutputStream() {
+    @Override
+    public void write(int b) throws IOException {
+      // Eat all writes silently. Nom nom.
+    }
+  };
+
+  /** Edits the values for an entry. */
+  public final class Editor {
+    private final Entry entry;
+    private final boolean[] written;
+    private boolean hasErrors;
+    private boolean committed;
+
+    private Editor(Entry entry) {
+      this.entry = entry;
+      this.written = (entry.readable) ? null : new boolean[valueCount];
+    }
+
+    /**
+     * Returns an unbuffered input stream to read the last committed value,
+     * or null if no value has been committed.
+     */
+    public InputStream newInputStream(int index) throws IOException {
+      synchronized (DiskLruCache.this) {
+        if (entry.currentEditor != this) {
+          throw new IllegalStateException();
+        }
+        if (!entry.readable) {
+          return null;
+        }
+        try {
+          return new FileInputStream(entry.getCleanFile(index));
+        } catch (FileNotFoundException e) {
+          return null;
+        }
+      }
+    }
+
+    /**
+     * Returns the last committed value as a string, or null if no value
+     * has been committed.
+     */
+    public String getString(int index) throws IOException {
+      InputStream in = newInputStream(index);
+      return in != null ? inputStreamToString(in) : null;
+    }
+
+    /**
+     * Returns a new unbuffered output stream to write the value at
+     * {@code index}. If the underlying output stream encounters errors
+     * when writing to the filesystem, this edit will be aborted when
+     * {@link #commit} is called. The returned output stream does not throw
+     * IOExceptions.
+     */
+    public OutputStream newOutputStream(int index) throws IOException {
+      synchronized (DiskLruCache.this) {
+        if (entry.currentEditor != this) {
+          throw new IllegalStateException();
+        }
+        if (!entry.readable) {
+          written[index] = true;
+        }
+        File dirtyFile = entry.getDirtyFile(index);
+        FileOutputStream outputStream;
+        try {
+          outputStream = new FileOutputStream(dirtyFile);
+        } catch (FileNotFoundException e) {
+          // Attempt to recreate the cache directory.
+          directory.mkdirs();
+          try {
+            outputStream = new FileOutputStream(dirtyFile);
+          } catch (FileNotFoundException e2) {
+            // We are unable to recover. Silently eat the writes.
+            return NULL_OUTPUT_STREAM;
+          }
+        }
+        return new FaultHidingOutputStream(outputStream);
+      }
+    }
+
+    /** Sets the value at {@code index} to {@code value}. */
+    public void set(int index, String value) throws IOException {
+      Writer writer = null;
+      try {
+        writer = new OutputStreamWriter(newOutputStream(index), DiskLruCacheUtil.UTF_8);
+        writer.write(value);
+      } finally {
+        DiskLruCacheUtil.closeQuietly(writer);
+      }
+    }
+
+    /**
+     * Commits this edit so it is visible to readers.  This releases the
+     * edit lock so another edit may be started on the same key.
+     */
+    public void commit() throws IOException {
+      if (hasErrors) {
+        completeEdit(this, false);
+        remove(entry.key); // The previous entry is stale.
+      } else {
+        completeEdit(this, true);
+      }
+      committed = true;
+    }
+
+    /**
+     * Aborts this edit. This releases the edit lock so another edit may be
+     * started on the same key.
+     */
+    public void abort() throws IOException {
+      completeEdit(this, false);
+    }
+
+    public void abortUnlessCommitted() {
+      if (!committed) {
+        try {
+          abort();
+        } catch (IOException ignored) {
+        }
+      }
+    }
+
+    private class FaultHidingOutputStream extends FilterOutputStream {
+      private FaultHidingOutputStream(OutputStream out) {
+        super(out);
+      }
+
+      @Override public void write(int oneByte) {
+        try {
+          out.write(oneByte);
+        } catch (IOException e) {
+          hasErrors = true;
+        }
+      }
+
+      @Override public void write(byte[] buffer, int offset, int length) {
+        try {
+          out.write(buffer, offset, length);
+        } catch (IOException e) {
+          hasErrors = true;
+        }
+      }
+
+      @Override public void close() {
+        try {
+          out.close();
+        } catch (IOException e) {
+          hasErrors = true;
+        }
+      }
+
+      @Override public void flush() {
+        try {
+          out.flush();
+        } catch (IOException e) {
+          hasErrors = true;
+        }
+      }
+    }
+  }
+
+  private final class Entry {
+    private final String key;
+
+    /** Lengths of this entry's files. */
+    private final long[] lengths;
+
+    /** True if this entry has ever been published. */
+    private boolean readable;
+
+    /** The ongoing edit or null if this entry is not being edited. */
+    private Editor currentEditor;
+
+    /** The sequence number of the most recently committed edit to this entry. */
+    private long sequenceNumber;
+
+    private Entry(String key) {
+      this.key = key;
+      this.lengths = new long[valueCount];
+    }
+
+    public String getLengths() throws IOException {
+      StringBuilder result = new StringBuilder();
+      for (long size : lengths) {
+        result.append(' ').append(size);
+      }
+      return result.toString();
+    }
+
+    /** Set lengths using decimal numbers like "10123". */
+    private void setLengths(String[] strings) throws IOException {
+      if (strings.length != valueCount) {
+        throw invalidLengths(strings);
+      }
+
+      try {
+        for (int i = 0; i < strings.length; i++) {
+          lengths[i] = Long.parseLong(strings[i]);
+        }
+      } catch (NumberFormatException e) {
+        throw invalidLengths(strings);
+      }
+    }
+
+    private IOException invalidLengths(String[] strings) throws IOException {
+      throw new IOException("unexpected journal line: " + java.util.Arrays.toString(strings));
+    }
+
+    public File getCleanFile(int i) {
+      return new File(directory, key + "." + i);
+    }
+
+    public File getDirtyFile(int i) {
+      return new File(directory, key + "." + i + ".tmp");
+    }
+  }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/DiskLruCacheStrictLineReader.java b/mopub-sdk/src/main/java/com/mopub/nativeads/DiskLruCacheStrictLineReader.java
new file mode 100644
index 00000000..998118d8
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/DiskLruCacheStrictLineReader.java
@@ -0,0 +1,192 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.mopub.nativeads;
+
+import java.io.ByteArrayOutputStream;
+import java.io.Closeable;
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.UnsupportedEncodingException;
+import java.nio.charset.Charset;
+
+/**
+ * Buffers input from an {@link InputStream} for reading lines.
+ *
+ * <p>This class is used for buffered reading of lines. For purposes of this class, a line ends
+ * with "\n" or "\r\n". End of input is reported by throwing {@code EOFException}. Unterminated
+ * line at end of input is invalid and will be ignored, the caller may use {@code
+ * hasUnterminatedLine()} to detect it after catching the {@code EOFException}.
+ *
+ * <p>This class is intended for reading input that strictly consists of lines, such as line-based
+ * cache entries or cache journal. Unlike the {@link java.io.BufferedReader} which in conjunction
+ * with {@link java.io.InputStreamReader} provides similar functionality, this class uses different
+ * end-of-input reporting and a more restrictive definition of a line.
+ *
+ * <p>This class supports only charsets that encode '\r' and '\n' as a single byte with value 13
+ * and 10, respectively, and the representation of no other character contains these values.
+ * We currently check in constructor that the charset is one of US-ASCII, UTF-8 and ISO-8859-1.
+ * The default charset is US_ASCII.
+ */
+class DiskLruCacheStrictLineReader implements Closeable {
+  private static final byte CR = (byte) '\r';
+  private static final byte LF = (byte) '\n';
+
+  private final InputStream in;
+  private final Charset charset;
+
+  /*
+   * Buffered data is stored in {@code buf}. As long as no exception occurs, 0 <= pos <= end
+   * and the data in the range [pos, end) is buffered for reading. At end of input, if there is
+   * an unterminated line, we set end == -1, otherwise end == pos. If the underlying
+   * {@code InputStream} throws an {@code IOException}, end may remain as either pos or -1.
+   */
+  private byte[] buf;
+  private int pos;
+  private int end;
+
+  /**
+   * Constructs a new {@code LineReader} with the specified charset and the default capacity.
+   *
+   * @param in the {@code InputStream} to read data from.
+   * @param charset the charset used to decode data. Only US-ASCII, UTF-8 and ISO-8859-1 are
+   * supported.
+   * @throws NullPointerException if {@code in} or {@code charset} is null.
+   * @throws IllegalArgumentException if the specified charset is not supported.
+   */
+  public DiskLruCacheStrictLineReader(InputStream in, Charset charset) {
+    this(in, 8192, charset);
+  }
+
+  /**
+   * Constructs a new {@code LineReader} with the specified capacity and charset.
+   *
+   * @param in the {@code InputStream} to read data from.
+   * @param capacity the capacity of the buffer.
+   * @param charset the charset used to decode data. Only US-ASCII, UTF-8 and ISO-8859-1 are
+   * supported.
+   * @throws NullPointerException if {@code in} or {@code charset} is null.
+   * @throws IllegalArgumentException if {@code capacity} is negative or zero
+   * or the specified charset is not supported.
+   */
+  public DiskLruCacheStrictLineReader(InputStream in, int capacity, Charset charset) {
+    if (in == null || charset == null) {
+      throw new NullPointerException();
+    }
+    if (capacity < 0) {
+      throw new IllegalArgumentException("capacity <= 0");
+    }
+    if (!(charset.equals(DiskLruCacheUtil.US_ASCII))) {
+      throw new IllegalArgumentException("Unsupported encoding");
+    }
+
+    this.in = in;
+    this.charset = charset;
+    buf = new byte[capacity];
+  }
+
+  /**
+   * Closes the reader by closing the underlying {@code InputStream} and
+   * marking this reader as closed.
+   *
+   * @throws IOException for errors when closing the underlying {@code InputStream}.
+   */
+  public void close() throws IOException {
+    synchronized (in) {
+      if (buf != null) {
+        buf = null;
+        in.close();
+      }
+    }
+  }
+
+  /**
+   * Reads the next line. A line ends with {@code "\n"} or {@code "\r\n"},
+   * this end of line marker is not included in the result.
+   *
+   * @return the next line from the input.
+   * @throws IOException for underlying {@code InputStream} errors.
+   * @throws EOFException for the end of source stream.
+   */
+  public String readLine() throws IOException {
+    synchronized (in) {
+      if (buf == null) {
+        throw new IOException("LineReader is closed");
+      }
+
+      // Read more data if we are at the end of the buffered data.
+      // Though it's an error to read after an exception, we will let {@code fillBuf()}
+      // throw again if that happens; thus we need to handle end == -1 as well as end == pos.
+      if (pos >= end) {
+        fillBuf();
+      }
+      // Try to find LF in the buffered data and return the line if successful.
+      for (int i = pos; i != end; ++i) {
+        if (buf[i] == LF) {
+          int lineEnd = (i != pos && buf[i - 1] == CR) ? i - 1 : i;
+          String res = new String(buf, pos, lineEnd - pos, charset.name());
+          pos = i + 1;
+          return res;
+        }
+      }
+
+      // Let's anticipate up to 80 characters on top of those already read.
+      ByteArrayOutputStream out = new ByteArrayOutputStream(end - pos + 80) {
+        @Override
+        public String toString() {
+          int length = (count > 0 && buf[count - 1] == CR) ? count - 1 : count;
+          try {
+            return new String(buf, 0, length, charset.name());
+          } catch (UnsupportedEncodingException e) {
+            throw new AssertionError(e); // Since we control the charset this will never happen.
+          }
+        }
+      };
+
+      while (true) {
+        out.write(buf, pos, end - pos);
+        // Mark unterminated line in case fillBuf throws EOFException or IOException.
+        end = -1;
+        fillBuf();
+        // Try to find LF in the buffered data and return the line if successful.
+        for (int i = pos; i != end; ++i) {
+          if (buf[i] == LF) {
+            if (i != pos) {
+              out.write(buf, pos, i - pos);
+            }
+            pos = i + 1;
+            return out.toString();
+          }
+        }
+      }
+    }
+  }
+
+  /**
+   * Reads new input data into the buffer. Call only with pos == end or end == -1,
+   * depending on the desired outcome if the function throws.
+   */
+  private void fillBuf() throws IOException {
+    int result = in.read(buf, 0, buf.length);
+    if (result == -1) {
+      throw new EOFException();
+    }
+    pos = 0;
+    end = result;
+  }
+}
+
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/DiskLruCacheUtil.java b/mopub-sdk/src/main/java/com/mopub/nativeads/DiskLruCacheUtil.java
new file mode 100644
index 00000000..1d9dbb23
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/DiskLruCacheUtil.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.mopub.nativeads;
+
+import java.io.Closeable;
+import java.io.File;
+import java.io.IOException;
+import java.io.Reader;
+import java.io.StringWriter;
+import java.nio.charset.Charset;
+
+/** Junk drawer of utility methods. */
+public final class DiskLruCacheUtil {
+  static final Charset US_ASCII = Charset.forName("US-ASCII");
+  static final Charset UTF_8 = Charset.forName("UTF-8");
+
+  private DiskLruCacheUtil() {
+  }
+
+  static String readFully(Reader reader) throws IOException {
+    try {
+      StringWriter writer = new StringWriter();
+      char[] buffer = new char[1024];
+      int count;
+      while ((count = reader.read(buffer)) != -1) {
+        writer.write(buffer, 0, count);
+      }
+      return writer.toString();
+    } finally {
+      reader.close();
+    }
+  }
+
+  /**
+   * Deletes the contents of {@code dir}. Throws an IOException if any file
+   * could not be deleted, or if {@code dir} is not a readable directory.
+   */
+  static void deleteContents(File dir) throws IOException {
+    File[] files = dir.listFiles();
+    if (files == null) {
+      throw new IOException("not a readable directory: " + dir);
+    }
+    for (File file : files) {
+      if (file.isDirectory()) {
+        deleteContents(file);
+      }
+      if (!file.delete()) {
+        throw new IOException("failed to delete file: " + file);
+      }
+    }
+  }
+
+  static void closeQuietly(/*Auto*/Closeable closeable) {
+    if (closeable != null) {
+      try {
+        closeable.close();
+      } catch (RuntimeException rethrown) {
+        throw rethrown;
+      } catch (Exception ignored) {
+      }
+    }
+  }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/DownloadResponse.java b/mopub-sdk/src/main/java/com/mopub/nativeads/DownloadResponse.java
new file mode 100644
index 00000000..b5825b12
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/DownloadResponse.java
@@ -0,0 +1,42 @@
+package com.mopub.nativeads;
+
+import com.mopub.common.util.Streams;
+
+import org.apache.http.HttpResponse;
+
+import java.io.BufferedInputStream;
+import java.io.ByteArrayOutputStream;
+
+class DownloadResponse {
+    private byte[] bytes = new byte[0];
+    private final int statusCode;
+    private final long contentLength;
+
+    DownloadResponse(final HttpResponse httpResponse) throws Exception {
+        final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+        BufferedInputStream inputStream = null;
+        try {
+            inputStream = new BufferedInputStream(httpResponse.getEntity().getContent());
+            Streams.copyContent(inputStream, outputStream);
+            bytes = outputStream.toByteArray();
+        } finally {
+            Streams.closeStream(inputStream);
+            Streams.closeStream(outputStream);
+        }
+
+        this.statusCode = httpResponse.getStatusLine().getStatusCode();
+        this.contentLength = httpResponse.getEntity().getContentLength();
+    }
+
+    byte[] getByteArray() {
+        return bytes;
+    }
+
+    int getStatusCode() {
+        return statusCode;
+    }
+
+    long getContentLength() {
+        return contentLength;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/DownloadTask.java b/mopub-sdk/src/main/java/com/mopub/nativeads/DownloadTask.java
new file mode 100644
index 00000000..0736da40
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/DownloadTask.java
@@ -0,0 +1,64 @@
+package com.mopub.nativeads;
+
+import android.net.http.AndroidHttpClient;
+import android.os.AsyncTask;
+
+import org.apache.http.HttpResponse;
+import org.apache.http.client.methods.HttpUriRequest;
+
+import static com.mopub.nativeads.util.Utils.MoPubLog;
+
+class DownloadTask extends AsyncTask<HttpUriRequest, Void, DownloadResponse> {
+    private final DownloadTaskListener mDownloadTaskListener;
+    private String mUrl;
+
+    interface DownloadTaskListener {
+        abstract void onComplete(String url, DownloadResponse downloadResponse);
+    }
+
+    DownloadTask(final DownloadTaskListener downloadTaskListener) throws IllegalArgumentException {
+        if (downloadTaskListener == null) {
+            throw new IllegalArgumentException("DownloadTaskListener must not be null.");
+        }
+
+        mDownloadTaskListener = downloadTaskListener;
+    }
+
+    @Override
+    protected DownloadResponse doInBackground(final HttpUriRequest... httpUriRequests) {
+        if (httpUriRequests == null || httpUriRequests.length == 0 || httpUriRequests[0] == null) {
+            MoPubLog("Download task tried to execute null or empty url");
+            return null;
+        }
+
+        final HttpUriRequest httpUriRequest = httpUriRequests[0];
+        mUrl = httpUriRequest.getURI().toString();
+
+        final AndroidHttpClient httpClient = NativeHttpClient.getHttpClient();
+        try {
+            final HttpResponse httpResponse = httpClient.execute(httpUriRequest);
+            return new DownloadResponse(httpResponse);
+        } catch (Exception e) {
+            MoPubLog("Download task threw an internal exception");
+            cancel(true);
+            return null;
+        } finally {
+            httpClient.close();
+        }
+    }
+
+    @Override
+    protected void onPostExecute(final DownloadResponse downloadResponse) {
+        if (isCancelled()) {
+            onCancelled();
+            return;
+        }
+
+        mDownloadTaskListener.onComplete(mUrl, downloadResponse);
+    }
+
+    @Override
+    protected void onCancelled() {
+        mDownloadTaskListener.onComplete(mUrl, null);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/HttpResponses.java b/mopub-sdk/src/main/java/com/mopub/nativeads/HttpResponses.java
new file mode 100644
index 00000000..365b0aa9
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/HttpResponses.java
@@ -0,0 +1,48 @@
+package com.mopub.nativeads;
+
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+
+import org.json.JSONObject;
+import org.json.JSONTokener;
+
+class HttpResponses {
+    private HttpResponses() {}
+
+    static Bitmap asBitmap(final DownloadResponse downloadResponse) {
+        if (downloadResponse == null) {
+            return null;
+        }
+
+        final byte[] bytes = downloadResponse.getByteArray();
+        final int contentLength = (int) downloadResponse.getContentLength();
+        return BitmapFactory.decodeByteArray(bytes, 0, contentLength);
+    }
+
+    static JSONObject asJsonObject(final DownloadResponse downloadResponse) {
+        if (downloadResponse == null) {
+            return null;
+        }
+
+        try {
+            final String responseString = asResponseString(downloadResponse);
+
+            final JSONTokener tokener = new JSONTokener(responseString);
+            return new JSONObject(tokener);
+        } catch (Exception e) {
+            return null;
+        }
+    }
+
+    static String asResponseString(final DownloadResponse downloadResponse) {
+        if (downloadResponse == null) {
+            return null;
+        }
+
+        try {
+            return new String(downloadResponse.getByteArray(), "UTF-8");
+        } catch (Exception e) {
+            return null;
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ImageDiskTaskManager.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ImageDiskTaskManager.java
new file mode 100644
index 00000000..9959c3ff
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/ImageDiskTaskManager.java
@@ -0,0 +1,56 @@
+package com.mopub.nativeads;
+
+import android.graphics.Bitmap;
+
+import java.util.List;
+
+import static com.mopub.nativeads.CacheService.DiskLruCacheGetListener;
+
+class ImageDiskTaskManager extends ImageTaskManager {
+    private final List<String> mUrls;
+
+    ImageDiskTaskManager(final List<String> urls, final ImageTaskManagerListener imageTaskManagerListener)
+            throws IllegalArgumentException {
+        super(urls, imageTaskManagerListener);
+        mUrls = urls;
+    }
+
+    @Override
+    void execute() {
+        if (mUrls.isEmpty()) {
+            mImageTaskManagerListener.onSuccess(mImages);
+        }
+
+        ImageDiskTaskListener imageDiskTaskListener = new ImageDiskTaskListener();
+        for (final String url : mUrls) {
+            CacheService.getFromDiskCacheAsync(url, imageDiskTaskListener);
+        }
+    }
+
+    void failAllTasks() {
+        if (mFailed.compareAndSet(false, true)) {
+            // See ImageDownloadTaskManager for an example
+            mImageTaskManagerListener.onFail();
+        }
+    }
+
+    private class ImageDiskTaskListener implements DiskLruCacheGetListener {
+        @Override
+        public void onComplete(final String key, final byte[] content) {
+            if (key == null) {
+                failAllTasks();
+                return;
+            } else {
+                Bitmap bitmap = null;
+                if (content != null) {
+                     bitmap = ImageService.byteArrayToBitmap(content);
+                }
+                mImages.put(key, bitmap);
+            }
+
+            if (mCompletedCount.incrementAndGet() == mSize) {
+                mImageTaskManagerListener.onSuccess(mImages);
+            }
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ImageDownloadTaskManager.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ImageDownloadTaskManager.java
new file mode 100644
index 00000000..ff4eef45
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/ImageDownloadTaskManager.java
@@ -0,0 +1,82 @@
+package com.mopub.nativeads;
+
+import android.graphics.Bitmap;
+
+import com.mopub.common.util.AsyncTasks;
+
+import org.apache.http.HttpStatus;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.client.methods.HttpUriRequest;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import static com.mopub.nativeads.DownloadTask.DownloadTaskListener;
+import static com.mopub.nativeads.util.Utils.MoPubLog;
+import static java.util.Map.Entry;
+
+class ImageDownloadTaskManager extends ImageTaskManager {
+
+    private final Map<HttpUriRequest, DownloadTask> mDownloadTasks;
+
+    ImageDownloadTaskManager(final List<String> urls, final ImageTaskManagerListener imageTaskManagerListener)
+            throws IllegalArgumentException {
+        super(urls, imageTaskManagerListener);
+
+        final DownloadTaskListener downloadTaskListener = new ImageDownloadTaskListener();
+        mDownloadTasks = new HashMap<HttpUriRequest, DownloadTask>(urls.size());
+        for (final String url : urls) {
+            final HttpGet httpGet = new HttpGet(url);
+            mDownloadTasks.put(httpGet, new DownloadTask(downloadTaskListener));
+        }
+    }
+
+    @Override
+    void execute() {
+        if (mDownloadTasks.isEmpty()) {
+            mImageTaskManagerListener.onSuccess(mImages);
+        }
+
+        for (final Entry<HttpUriRequest, DownloadTask> entry : mDownloadTasks.entrySet()) {
+            final HttpUriRequest httpUriRequest = entry.getKey();
+            final DownloadTask downloadTask = entry.getValue();
+
+            AsyncTasks.safeExecuteOnExecutor(downloadTask, httpUriRequest);
+        }
+    }
+
+    void failAllTasks() {
+        if (mFailed.compareAndSet(false, true)) {
+            for (final DownloadTask downloadTask : mDownloadTasks.values()) {
+                downloadTask.cancel(true);
+            }
+            mImageTaskManagerListener.onFail();
+        }
+    }
+
+    private class ImageDownloadTaskListener implements DownloadTaskListener {
+        @Override
+        public void onComplete(final String url, final DownloadResponse downloadResponse) {
+            if (downloadResponse == null || downloadResponse.getStatusCode() != HttpStatus.SC_OK) {
+                MoPubLog("Failed to download image: " + url);
+                failAllTasks();
+                return;
+            }
+
+            final Bitmap bitmap = HttpResponses.asBitmap(downloadResponse);
+
+            if (bitmap == null) {
+                MoPubLog("Failed to decode bitmap from response for image: " + url);
+                failAllTasks();
+                return;
+            }
+
+            MoPubLog("Successfully downloaded image: " + url);
+            mImages.put(url, bitmap);
+            if (mCompletedCount.incrementAndGet() == mSize) {
+                mImageTaskManagerListener.onSuccess(mImages);
+            }
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ImageService.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ImageService.java
new file mode 100644
index 00000000..ae3fbf5b
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/ImageService.java
@@ -0,0 +1,188 @@
+package com.mopub.nativeads;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+
+import com.mopub.common.util.Streams;
+
+import java.io.ByteArrayOutputStream;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import static com.mopub.nativeads.ImageTaskManager.ImageTaskManagerListener;
+import static com.mopub.nativeads.util.Utils.MoPubLog;
+import static java.util.Map.Entry;
+
+class ImageService {
+    private static int COMPRESSION_QUALITY = 25;
+
+    interface ImageServiceListener {
+        void onSuccess(Map<String, Bitmap> bitmaps);
+        void onFail();
+    }
+
+    static void get(final Context context, final List<String> urls, final ImageServiceListener imageServiceListener) {
+        CacheService.initializeCaches(context);
+        get(urls, imageServiceListener);
+    }
+
+    static void get(final List<String> urls, final ImageServiceListener imageServiceListener) {
+        final Map<String, Bitmap> cacheBitmaps = new HashMap<String, Bitmap>(urls.size());
+        final List<String> urlCacheMisses = getBitmapsFromMemoryCache(urls, cacheBitmaps);
+
+        if (urlCacheMisses.isEmpty()) {
+            imageServiceListener.onSuccess(cacheBitmaps);
+            return;
+        }
+
+        final ImageDiskTaskManager imageDiskTaskManager;
+        try {
+            imageDiskTaskManager = new ImageDiskTaskManager(
+                    urlCacheMisses,
+                    new ImageDiskTaskManagerListener(imageServiceListener, cacheBitmaps)
+            );
+        } catch (IllegalArgumentException e) {
+            MoPubLog("Unable to initialize ImageDiskTaskManager", e);
+            imageServiceListener.onFail();
+            return;
+        }
+
+        imageDiskTaskManager.execute();
+    }
+
+    static void putBitmapsInCache(final Map<String, Bitmap> bitmaps) {
+        for (final Entry<String, Bitmap> entry : bitmaps.entrySet()) {
+            MoPubLog("Caching bitmap: " + entry.getKey());
+            putBitmapInCache(entry.getKey(), entry.getValue());
+        }
+    }
+
+    static void putBitmapInCache(final String key, final Bitmap bitmap) {
+        final byte[] bytes = bitmapToByteArray(bitmap);
+        CacheService.put(key, bytes);
+    }
+
+    static List<String> getBitmapsFromMemoryCache(final List<String> urls, final Map<String, Bitmap> hits) {
+        final List<String> cacheMisses = new ArrayList<String>();
+        for (final String url : urls) {
+            Bitmap bitmap = getBitmapFromMemoryCache(url);
+
+            if (bitmap != null) {
+                hits.put(url, bitmap);
+            } else {
+                cacheMisses.add(url);
+            }
+        }
+
+        return cacheMisses;
+    }
+
+    static Bitmap getBitmapFromMemoryCache(final String key) {
+        Bitmap bitmap = null;
+        byte[] bytes = CacheService.getFromMemoryCache(key);
+        if (bytes != null) {
+            bitmap = byteArrayToBitmap(bytes);
+        }
+        return bitmap;
+    }
+
+    static Bitmap byteArrayToBitmap(final byte[] bytes) {
+        return BitmapFactory.decodeByteArray(bytes, 0, bytes.length);
+    }
+
+    static byte[] bitmapToByteArray(final Bitmap bitmap) {
+        ByteArrayOutputStream byteArrayOutputStream = null;
+        try {
+            byteArrayOutputStream = new ByteArrayOutputStream();
+            bitmap.compress(Bitmap.CompressFormat.JPEG, COMPRESSION_QUALITY, byteArrayOutputStream);
+            return byteArrayOutputStream.toByteArray();
+        } finally {
+            Streams.closeStream(byteArrayOutputStream);
+        }
+    }
+
+    private static class ImageDiskTaskManagerListener implements ImageTaskManagerListener {
+        final private ImageServiceListener mImageServiceListener;
+        final private Map<String, Bitmap> mBitmaps;
+
+        ImageDiskTaskManagerListener(final ImageServiceListener imageServiceListener,
+                final Map<String, Bitmap> bitmaps) {
+            mImageServiceListener = imageServiceListener;
+            mBitmaps = bitmaps;
+        }
+
+        @Override
+        public void onSuccess(final Map<String, Bitmap> diskBitmaps) {
+            final List<String> urlDiskMisses = new ArrayList<String>();
+            for (final Entry <String, Bitmap> entry : diskBitmaps.entrySet()) {
+                if (entry.getValue() == null) {
+                    urlDiskMisses.add(entry.getKey());
+                } else {
+                    putBitmapInCache(entry.getKey(), entry.getValue());
+                    mBitmaps.put(entry.getKey(), entry.getValue());
+                }
+            }
+
+            if (urlDiskMisses.isEmpty()) {
+                mImageServiceListener.onSuccess(mBitmaps);
+            } else {
+
+                final ImageDownloadTaskManager imageDownloadTaskManager;
+                try {
+                    imageDownloadTaskManager = new ImageDownloadTaskManager(
+                            urlDiskMisses,
+                            new ImageNetworkTaskManagerListener(mImageServiceListener, mBitmaps)
+                    );
+                } catch (IllegalArgumentException e) {
+                    MoPubLog("Unable to initialize ImageDownloadTaskManager", e);
+                    mImageServiceListener.onFail();
+                    return;
+                }
+
+                imageDownloadTaskManager.execute();
+            }
+        }
+
+        @Override
+        public void onFail() {
+            mImageServiceListener.onFail();
+        }
+    }
+
+    private static class ImageNetworkTaskManagerListener implements ImageTaskManagerListener {
+        private final ImageServiceListener mImageServiceListener;
+        private final Map<String, Bitmap> mBitmaps;
+
+        ImageNetworkTaskManagerListener(final ImageServiceListener imageServiceListener,
+                final Map<String, Bitmap> bitmaps) {
+            mImageServiceListener = imageServiceListener;
+            mBitmaps = bitmaps;
+        }
+
+        @Override
+        public void onSuccess(final Map<String, Bitmap> images) {
+            putBitmapsInCache(images);
+            mBitmaps.putAll(images);
+            mImageServiceListener.onSuccess(mBitmaps);
+        }
+
+        @Override
+        public void onFail() {
+            mImageServiceListener.onFail();
+        }
+    }
+
+    // Testing, also performs disk IO
+    @Deprecated
+    static Bitmap getBitmapFromDiskCache(final String key) {
+        Bitmap bitmap = null;
+        byte[] bytes = CacheService.getFromDiskCache(key);
+        if (bytes != null) {
+            bitmap = byteArrayToBitmap(bytes);
+        }
+        return bitmap;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ImageTaskManager.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ImageTaskManager.java
new file mode 100644
index 00000000..8d399039
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/ImageTaskManager.java
@@ -0,0 +1,44 @@
+package com.mopub.nativeads;
+
+import android.graphics.Bitmap;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+
+abstract class ImageTaskManager {
+    protected final ImageTaskManagerListener mImageTaskManagerListener;
+    protected final int mSize;
+    protected final Map<String, Bitmap> mImages;
+
+    protected final AtomicInteger mCompletedCount;
+    protected final AtomicBoolean mFailed;
+
+    interface ImageTaskManagerListener {
+        void onSuccess(final Map<String, Bitmap> images);
+        void onFail();
+    }
+
+    ImageTaskManager(final List<String> urls, final ImageTaskManagerListener imageTaskManagerListener)
+            throws IllegalArgumentException {
+        if (urls == null) {
+            throw new IllegalArgumentException("Urls list cannot be null");
+        } else if (urls.contains(null)) {
+            throw new IllegalArgumentException("Urls list cannot contain null");
+        } else if (imageTaskManagerListener == null) {
+            throw new IllegalArgumentException("ImageTaskManagerListener cannot be null");
+        }
+
+        mSize = urls.size();
+
+        mImageTaskManagerListener = imageTaskManagerListener;
+        mCompletedCount = new AtomicInteger(0);
+        mFailed = new AtomicBoolean(false);
+        mImages = Collections.synchronizedMap(new HashMap<String, Bitmap>(mSize));
+    }
+
+    abstract void execute();
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ImageViewService.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ImageViewService.java
new file mode 100644
index 00000000..364c58a3
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/ImageViewService.java
@@ -0,0 +1,95 @@
+package com.mopub.nativeads;
+
+import android.graphics.Bitmap;
+import android.view.View;
+import android.widget.ImageView;
+
+import com.mopub.common.util.Utils;
+
+import java.lang.ref.WeakReference;
+import java.util.Arrays;
+import java.util.Map;
+
+import static com.mopub.nativeads.ImageService.ImageServiceListener;
+import static com.mopub.nativeads.util.Utils.MoPubLog;
+
+class ImageViewService {
+    // random large number so we hopefully don't collide with something a pub is using
+    private static final int VIEW_TAG_MOPUB_KEY = 817491827;
+
+    private ImageViewService(){}
+
+    static void loadImageView(final String url, final ImageView imageView) {
+        if (imageView == null) {
+            return;
+        }
+
+        // Blank out previous image content while waiting for request to return
+        imageView.setImageDrawable(null);
+
+        if (url != null) {
+            // Unique id to identify this async image request
+            setImageViewUniqueId(imageView);
+            long uniqueId = getImageViewUniqueId(imageView);
+
+            // Async call to get image from memory cache, disk and then network
+            ImageService.get(
+                    Arrays.asList(url),
+                    new MyImageViewServiceListener(url, imageView, uniqueId)
+            );
+        }
+    }
+
+    private static class MyImageViewServiceListener implements ImageServiceListener {
+        private final WeakReference<ImageView> mImageView;
+        private final String mUrl;
+        private final long mUniqueId;
+
+        MyImageViewServiceListener(final String url, final ImageView imageView, final long uniqueId) {
+            mUrl = url;
+            mImageView = new WeakReference<ImageView>(imageView);
+            mUniqueId = uniqueId;
+        }
+
+        @Override
+        public void onSuccess(final Map<String, Bitmap> bitmaps) {
+            final ImageView imageView = mImageView.get();
+            if (imageView == null || bitmaps == null || !bitmaps.containsKey(mUrl)) {
+                return;
+            }
+            final Long uniqueId = getImageViewUniqueId(imageView);
+            if (uniqueId != null && mUniqueId == uniqueId) {
+                imageView.setImageBitmap(bitmaps.get(mUrl));
+            }
+        }
+
+        @Override
+        public void onFail() {
+            MoPubLog("Failed to load image for ImageView");
+        }
+    }
+
+    static void setImageViewUniqueId(final ImageView imageView) {
+        if (imageView != null) {
+            setViewTag(imageView, Utils.generateUniqueId());
+        }
+    }
+
+    static Long getImageViewUniqueId(final ImageView imageView) {
+        if (imageView != null) {
+            Object object = getViewTag(imageView);
+            if (object instanceof Long) {
+                return (Long) object;
+            }
+        }
+        return null;
+    }
+
+    static void setViewTag(final View view, final Object object) {
+        view.setTag(VIEW_TAG_MOPUB_KEY, object);
+    }
+
+    static Object getViewTag(final View view) {
+        return view.getTag(VIEW_TAG_MOPUB_KEY);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ImpressionTrackingManager.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ImpressionTrackingManager.java
new file mode 100644
index 00000000..70d66479
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/ImpressionTrackingManager.java
@@ -0,0 +1,177 @@
+package com.mopub.nativeads;
+
+import android.graphics.Rect;
+import android.os.SystemClock;
+import android.view.View;
+
+import java.util.ConcurrentModificationException;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.WeakHashMap;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import static com.mopub.nativeads.MoPubNative.MoPubNativeListener;
+import static com.mopub.nativeads.NativeHttpClient.makeTrackingHttpRequest;
+
+class ImpressionTrackingManager {
+    private static final int PERIOD = 250;
+
+    private static WeakHashMap<View, NativeResponseWrapper> sKeptViews = new WeakHashMap<View, NativeResponseWrapper>(10);
+
+    private static final ScheduledExecutorService sScheduledExecutorService = Executors.newSingleThreadScheduledExecutor();
+    private static final VisibilityCheck sVisibilityCheck = new VisibilityCheck();
+    private static AtomicBoolean mIsStarted = new AtomicBoolean(false);
+
+    static void start() {
+        if (mIsStarted.compareAndSet(false, true)) {
+            /**
+             * Scheduling with fixed delay means that the delay is calculated after the task
+             * finishes running. This means that we will never have two tasks running at the same
+             * time.
+             */
+            sScheduledExecutorService.scheduleWithFixedDelay(sVisibilityCheck, 0, PERIOD, TimeUnit.MILLISECONDS);
+        }
+    }
+
+    static void stop() {
+        if (mIsStarted.compareAndSet(true, false)) {
+            sScheduledExecutorService.shutdownNow();
+        }
+    }
+
+    static void addView(final View view, final NativeResponse nativeResponse, final MoPubNativeListener moPubNativeListener) {
+        if (view != null && nativeResponse != null) {
+            sKeptViews.put(view, new NativeResponseWrapper(nativeResponse, moPubNativeListener));
+        }
+    }
+
+    static void removeView(final View view) {
+        sKeptViews.remove(view);
+    }
+
+    static class VisibilityCheck implements Runnable {
+        private static final double MINIMUM_PERCENT_VISIBLE = 50;
+        private static final long MINIMUM_IMPRESSION_TIME = 1000;
+
+        @Override
+        public void run() {
+            final Iterator<Map.Entry<View, NativeResponseWrapper>> entryIterator = sKeptViews.entrySet().iterator();
+
+            while (entryIterator.hasNext()) {
+                final Map.Entry<View, NativeResponseWrapper> entry = entryIterator.next();
+                final View view = entry.getKey();
+                final NativeResponseWrapper wrapper = entry.getValue();
+
+                // if our wrapper or its response is null, skip
+                if (wrapper == null || wrapper.mNativeResponse == null) {
+                    try {
+                        entryIterator.remove();
+                    } catch (ConcurrentModificationException e) {
+                        // continue
+                    }
+                    continue;
+                }
+
+                if (wrapper.mNativeResponse.isDestroyed()) {
+                    try {
+                        entryIterator.remove();
+                    } catch (ConcurrentModificationException e) {
+                        // continue
+                    }
+                    continue;
+                }
+
+                // if this response has already recorded an impression, skip
+                if (wrapper.mNativeResponse.getRecordedImpression()) {
+                    try {
+                        entryIterator.remove();
+                    } catch (ConcurrentModificationException e) {
+                        // continue
+                    }
+                    continue;
+                }
+
+                // if the view is not sufficiently visible, reset the visible timestamp, and skip
+                if (!isVisible(view)) {
+                    wrapper.mFirstVisibleTimestamp = 0;
+                    continue;
+                }
+
+                // if it just became visible, set the firstChecked timestamp, and skip
+                if (wrapper.mFirstVisibleTimestamp == 0) {
+                    wrapper.mFirstVisibleTimestamp = SystemClock.uptimeMillis();
+                    continue;
+                }
+
+                // if not enough time has elapsed, skip
+                if (SystemClock.uptimeMillis() - wrapper.mFirstVisibleTimestamp < MINIMUM_IMPRESSION_TIME) {
+                    continue;
+                }
+
+                // otherwise, record an impression
+                wrapper.mNativeResponse.recordImpression();
+
+                // Fire and forget impression trackers
+                for (final String impressionTracker : wrapper.mNativeResponse.getImpressionTrackers()) {
+                    makeTrackingHttpRequest(impressionTracker);
+                }
+
+                // Notify the developer
+                if (wrapper.mMoPubNativeListener != null) {
+                    wrapper.mMoPubNativeListener.onNativeImpression(view);
+                    try {
+                        entryIterator.remove();
+                    } catch (ConcurrentModificationException e) {
+                        // continue
+                    }
+                }
+            }
+        }
+
+        static boolean isVisible(final View view) {
+            if (view == null || view.getVisibility() != View.VISIBLE) {
+                return false;
+            }
+
+            final Rect visibleRect = new Rect();
+            view.getGlobalVisibleRect(visibleRect);
+
+            int visibleViewArea = visibleRect.width() * visibleRect.height();
+            int totalViewArea = view.getWidth() * view.getHeight();
+
+            if (totalViewArea <= 0) {
+                return false;
+            }
+
+            double visiblePercent = 100 * visibleViewArea / totalViewArea;
+
+            return visiblePercent >= MINIMUM_PERCENT_VISIBLE;
+        }
+    }
+
+    static class NativeResponseWrapper {
+        final NativeResponse mNativeResponse;
+        final MoPubNativeListener mMoPubNativeListener;
+        long mFirstVisibleTimestamp;
+
+        NativeResponseWrapper(final NativeResponse nativeResponse,
+                final MoPubNativeListener moPubNativeListener) {
+            mNativeResponse = nativeResponse;
+            mMoPubNativeListener = moPubNativeListener;
+            mFirstVisibleTimestamp = 0;
+        }
+    }
+
+    @Deprecated // for testing
+    static void purgeViews() {
+        sKeptViews.clear();
+    }
+
+    @Deprecated // for testing
+    static Map<View, NativeResponseWrapper> getKeptViews() {
+        return sKeptViews;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNative.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNative.java
new file mode 100644
index 00000000..94863461
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNative.java
@@ -0,0 +1,178 @@
+package com.mopub.nativeads;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.view.View;
+
+import com.mopub.common.GpsHelper;
+import com.mopub.common.util.AsyncTasks;
+import com.mopub.common.util.DeviceUtils;
+
+import org.apache.http.HttpStatus;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.client.methods.HttpUriRequest;
+import org.json.JSONObject;
+
+import java.util.Map;
+
+import static com.mopub.common.GpsHelper.GpsHelperListener;
+import static com.mopub.common.GpsHelper.asyncFetchAdvertisingInfo;
+import static com.mopub.nativeads.MoPubNative.MoPubNativeListener.EMPTY_MOPUB_NATIVE_LISTENER;
+import static com.mopub.nativeads.NativeErrorCode.CONNECTION_ERROR;
+import static com.mopub.nativeads.NativeErrorCode.EMPTY_AD_RESPONSE;
+import static com.mopub.nativeads.NativeErrorCode.IMAGE_DOWNLOAD_FAILURE;
+import static com.mopub.nativeads.NativeErrorCode.INVALID_JSON;
+import static com.mopub.nativeads.NativeErrorCode.INVALID_REQUEST_URL;
+import static com.mopub.nativeads.NativeErrorCode.SERVER_ERROR_RESPONSE_CODE;
+import static com.mopub.nativeads.NativeErrorCode.UNEXPECTED_RESPONSE_CODE;
+import static com.mopub.nativeads.NativeErrorCode.UNSPECIFIED;
+import static com.mopub.nativeads.util.Utils.MoPubLog;
+
+public final class MoPubNative {
+    public interface MoPubNativeListener {
+        public void onNativeLoad(final NativeResponse nativeResponse);
+        public void onNativeFail(final NativeErrorCode errorCode);
+        public void onNativeImpression(final View view);
+        public void onNativeClick(final View view);
+
+        public static final MoPubNativeListener EMPTY_MOPUB_NATIVE_LISTENER = new MoPubNativeListener() {
+            @Override public void onNativeLoad(final NativeResponse nativeResponse) {}
+            @Override public void onNativeFail(final NativeErrorCode errorCode) {}
+            @Override public void onNativeImpression(final View view) {}
+            @Override public void onNativeClick(final View view) {}
+        };
+    }
+
+    private NativeResponse mNativeResponse;
+    private final Context mContext;
+    private final String mAdUnitId;
+    private MoPubNativeListener mMoPubNativeListener;
+
+    public MoPubNative(final Context context, final String adUnitId, final MoPubNativeListener moPubNativeListener) {
+        ImpressionTrackingManager.start();
+
+        if (context == null) {
+            throw new IllegalArgumentException("Context may not be null.");
+        } else if (adUnitId == null) {
+            throw new IllegalArgumentException("AdUnitId may not be null.");
+        } else if (moPubNativeListener == null) {
+            throw new IllegalArgumentException("MoPubNativeListener may not be null.");
+        }
+
+        mContext = context.getApplicationContext();
+        mAdUnitId = adUnitId;
+        mMoPubNativeListener = moPubNativeListener;
+        
+        // warm up cache for google play services info
+        asyncFetchAdvertisingInfo(mContext);
+    }
+
+    public void makeRequest() {
+        makeRequest(null);
+    }
+
+    public void makeRequest(final RequestParameters requestParameters) {
+        makeRequest(requestParameters, new NativeGpsHelperListener(requestParameters));
+    }
+
+    void makeRequest(final RequestParameters requestParameters,
+            NativeGpsHelperListener nativeGpsHelperListener) {
+        if (!DeviceUtils.isNetworkAvailable(mContext)) {
+            mMoPubNativeListener.onNativeFail(CONNECTION_ERROR);
+            return;
+        }
+
+        // If we have access to Google Play Services (GPS) but the advertising info
+        // is not cached then guarantee we get it before building the ad request url
+        // in the callback, this is a requirement from Google
+        GpsHelper.asyncFetchAdvertisingInfoIfNotCached(
+                mContext,
+                nativeGpsHelperListener
+        );
+    }
+    public void destroy() {
+        mMoPubNativeListener = EMPTY_MOPUB_NATIVE_LISTENER;
+    }
+
+    private void loadNativeAd(final RequestParameters requestParameters) {
+        String endpointUrl = new NativeUrlGenerator(mContext)
+                .withAdUnitId(mAdUnitId)
+                .withRequest(requestParameters)
+                .generateUrlString(Constants.NATIVE_HOST);
+
+        if (endpointUrl != null) {
+            MoPubLog("Loading ad from: " + endpointUrl);
+        }
+
+        final HttpGet httpGet;
+        try {
+            httpGet = new HttpGet(endpointUrl);
+        } catch (IllegalArgumentException e) {
+            mMoPubNativeListener.onNativeFail(INVALID_REQUEST_URL);
+            return;
+        }
+
+        downloadJson(httpGet);
+    }
+
+    private void downloadJson(final HttpUriRequest httpUriRequest) {
+        final DownloadTask jsonDownloadTask = new DownloadTask(new DownloadTask.DownloadTaskListener() {
+            @Override
+            public void onComplete(final String url, final DownloadResponse downloadResponse) {
+                if (downloadResponse == null) {
+                    mMoPubNativeListener.onNativeFail(UNSPECIFIED);
+                } else if (downloadResponse.getStatusCode() >= 500 &&
+                        downloadResponse.getStatusCode() < 600) {
+                    mMoPubNativeListener.onNativeFail(SERVER_ERROR_RESPONSE_CODE);
+                } else if (downloadResponse.getStatusCode() != HttpStatus.SC_OK) {
+                    mMoPubNativeListener.onNativeFail(UNEXPECTED_RESPONSE_CODE);
+                } else if (downloadResponse.getContentLength() == 0) {
+                    mMoPubNativeListener.onNativeFail(EMPTY_AD_RESPONSE);
+                } else {
+
+                    final JSONObject jsonObject = HttpResponses.asJsonObject(downloadResponse);
+
+                    if (jsonObject == null) {
+                        mMoPubNativeListener.onNativeFail(INVALID_JSON);
+                    } else {
+                        try {
+                            mNativeResponse = new NativeResponse(jsonObject);
+                        } catch (IllegalArgumentException e) {
+                            mMoPubNativeListener.onNativeFail(INVALID_JSON);
+                            return;
+                        }
+                        downloadImages();
+                    }
+                }
+            }
+        });
+
+        AsyncTasks.safeExecuteOnExecutor(jsonDownloadTask, httpUriRequest);
+    }
+
+    private void downloadImages() {
+        ImageService.get(mContext, mNativeResponse.getAllImageUrls(), new ImageService.ImageServiceListener() {
+            @Override
+            public void onSuccess(Map<String, Bitmap> bitmaps) {
+                mMoPubNativeListener.onNativeLoad(mNativeResponse);
+            }
+
+            @Override
+            public void onFail() {
+                mMoPubNativeListener.onNativeFail(IMAGE_DOWNLOAD_FAILURE);
+            }
+        });
+    }
+
+    // Do not store this class as a member of MoPubNative; will result in circular reference
+    class NativeGpsHelperListener implements GpsHelperListener {
+        private RequestParameters mRequestParameters;
+        NativeGpsHelperListener(RequestParameters requestParameters) {
+            mRequestParameters = requestParameters;
+        }
+        @Override
+        public void onFetchAdInfoCompleted() {
+            loadNativeAd(mRequestParameters);
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdViewHelper.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdViewHelper.java
new file mode 100644
index 00000000..04e0e456
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdViewHelper.java
@@ -0,0 +1,234 @@
+package com.mopub.nativeads;
+
+import android.content.Context;
+import android.content.Intent;
+import android.net.Uri;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.Button;
+
+import com.mopub.common.MoPubBrowser;
+
+import java.lang.ref.SoftReference;
+import java.util.Arrays;
+import java.util.Iterator;
+
+import static android.view.View.GONE;
+import static android.view.View.OnClickListener;
+import static android.view.View.VISIBLE;
+import static com.mopub.common.util.IntentUtils.deviceCanHandleIntent;
+import static com.mopub.common.util.IntentUtils.isDeepLink;
+import static com.mopub.nativeads.MoPubNative.MoPubNativeListener;
+import static com.mopub.nativeads.NativeHttpClient.makeTrackingHttpRequest;
+import static com.mopub.nativeads.UrlResolutionTask.UrlResolutionListener;
+import static com.mopub.nativeads.util.Utils.MoPubLog;
+
+class NativeAdViewHelper {
+    private NativeAdViewHelper() {}
+
+    static View getAdView(View convertView,
+                          final ViewGroup parent,
+                          final Context context,
+                          final NativeResponse nativeResponse,
+                          final ViewBinder viewBinder,
+                          final MoPubNativeListener moPubNativeListener) {
+
+        if (viewBinder == null) {
+            MoPubLog("ViewBinder is null, returning empty view.");
+            return new View(context);
+        }
+
+        if (convertView == null) {
+            convertView = createConvertView(context, parent, viewBinder);
+        }
+
+        final NativeViewHolder nativeViewHolder = getOrCreateNativeViewHolder(convertView, viewBinder);
+
+        // Clean up previous state of view
+        removeClickListeners(convertView, nativeViewHolder);
+        ImpressionTrackingManager.removeView(convertView);
+
+        if (nativeResponse == null) {
+            // If we don't have content for the view, then hide the view for now
+            MoPubLog("NativeResponse is null, returning hidden view.");
+            convertView.setVisibility(GONE);
+        } else if (nativeResponse.isDestroyed()) {
+            MoPubLog("NativeResponse is destroyed, returning hidden view.");
+            convertView.setVisibility(GONE);
+        } else if (nativeViewHolder == null) {
+            MoPubLog("Could not create NativeViewHolder, returning hidden view.");
+            convertView.setVisibility(GONE);
+        } else {
+            populateConvertViewSubViews(convertView, nativeViewHolder, nativeResponse, viewBinder);
+            attachClickListeners(context, convertView, nativeViewHolder, nativeResponse, moPubNativeListener);
+            convertView.setVisibility(VISIBLE);
+            ImpressionTrackingManager.addView(convertView, nativeResponse, moPubNativeListener);
+        }
+
+        return convertView;
+    }
+
+    private static View createConvertView(final Context context, final ViewGroup parent, final ViewBinder viewBinder) {
+        final View convertView = LayoutInflater
+                .from(context)
+                .inflate(viewBinder.layoutId, parent, false);
+        return convertView;
+    }
+
+    static NativeViewHolder getOrCreateNativeViewHolder(final View convertView, final ViewBinder viewBinder) {
+        // Create view holder and put it in the view tag
+        Object object = ImageViewService.getViewTag(convertView);
+        if (object == null || !(object instanceof NativeViewHolder)) {
+            final NativeViewHolder nativeViewHolder = NativeViewHolder.fromViewBinder(convertView, viewBinder);
+            ImageViewService.setViewTag(convertView, nativeViewHolder);
+            return nativeViewHolder;
+        } else {
+            return (NativeViewHolder) object;
+        }
+    }
+
+    private static void populateConvertViewSubViews(final View convertView,
+                                                    final NativeViewHolder nativeViewHolder,
+                                                    final NativeResponse nativeResponse,
+                                                    final ViewBinder viewBinder) {
+        nativeViewHolder.update(nativeResponse);
+        nativeViewHolder.updateExtras(convertView, nativeResponse, viewBinder);
+    }
+
+    private static void removeClickListeners(final View view,
+                                             final NativeViewHolder nativeViewHolder) {
+        if (view == null) {
+            return;
+        }
+
+        view.setOnClickListener(null);
+        setCtaClickListener(nativeViewHolder, null);
+    }
+
+    private static void attachClickListeners(final Context context,
+                                             final View view,
+                                             final NativeViewHolder nativeViewHolder,
+                                             final NativeResponse nativeResponse,
+                                             final MoPubNativeListener moPubNativeListener) {
+        if (view == null || nativeResponse == null) {
+            return;
+        }
+
+        final String clickTrackerUrl = nativeResponse.getClickTracker();
+        final String destinationUrl = nativeResponse.getClickDestinationUrl();
+        final NativeViewClickListener nativeViewClickListener
+                = new NativeViewClickListener(context, clickTrackerUrl, destinationUrl, moPubNativeListener);
+        view.setOnClickListener(nativeViewClickListener);
+        setCtaClickListener(nativeViewHolder, nativeViewClickListener);
+    }
+
+    private static void setCtaClickListener(final NativeViewHolder nativeViewHolder,
+                                            final NativeViewClickListener nativeViewClickListener) {
+        if (nativeViewHolder == null || nativeViewClickListener == null) {
+            return;
+        }
+
+        // CTA widget could be a button and buttons don't inherit click listeners from parents
+        // So we have to set it manually here if so
+        if (nativeViewHolder.callToActionView != null && nativeViewHolder.callToActionView instanceof Button) {
+            nativeViewHolder.callToActionView.setOnClickListener(nativeViewClickListener);
+        }
+    }
+
+    static class NativeViewClickListener implements OnClickListener {
+        private final Context mContext;
+        private final String mClickTrackerUrl;
+        private final String mDestinationUrl;
+        private final MoPubNativeListener mMoPubNativeListener;
+
+        NativeViewClickListener(final Context context,
+                final String clickTrackerUrl,
+                final String destinationUrl,
+                final MoPubNativeListener moPubNativeListener) {
+            mContext = context.getApplicationContext();
+            mClickTrackerUrl = clickTrackerUrl;
+            mDestinationUrl = destinationUrl;
+            mMoPubNativeListener = moPubNativeListener;
+        }
+
+        @Override
+        public void onClick(View view) {
+            final SpinningProgressView spinningProgressView = new SpinningProgressView(mContext);
+            spinningProgressView.addToRoot(view);
+
+            // Fire and forget click tracker
+            makeTrackingHttpRequest(mClickTrackerUrl);
+
+            if (mDestinationUrl != null) {
+                final Iterator<String> urlIterator = Arrays.asList(mDestinationUrl).iterator();
+                final ClickDestinationUrlResolutionListener urlResolutionListener = new ClickDestinationUrlResolutionListener(
+                        mContext,
+                        urlIterator,
+                        spinningProgressView,
+                        mMoPubNativeListener,
+                        view
+                );
+                NativeHttpClient.getResolvedUrl(urlIterator.next(), urlResolutionListener);
+            }
+        }
+    }
+
+    private static class ClickDestinationUrlResolutionListener implements UrlResolutionListener {
+        private final Context mContext;
+        private final Iterator<String> mUrlIterator;
+        private final SoftReference<SpinningProgressView> mSpinningProgressView;
+        private final MoPubNativeListener mMoPubNativeListener;
+        private final SoftReference<View> mView;
+
+        public ClickDestinationUrlResolutionListener(final Context context,
+                final Iterator<String> urlIterator,
+                final SpinningProgressView spinningProgressView,
+                final MoPubNativeListener moPubNativeListener,
+                final View view) {
+            mContext = context;
+            mUrlIterator = urlIterator;
+            mSpinningProgressView = new SoftReference<SpinningProgressView>(spinningProgressView);
+            mMoPubNativeListener = (moPubNativeListener == null)
+                    ? MoPubNativeListener.EMPTY_MOPUB_NATIVE_LISTENER
+                    : moPubNativeListener;
+            mView = new SoftReference<View>(view);
+        }
+
+        @Override
+        public void onSuccess(String result) {
+            final Intent intent = new Intent(Intent.ACTION_VIEW);
+            intent.setData(Uri.parse(result));
+            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+
+            if (isDeepLink(result)) {
+                if (deviceCanHandleIntent(mContext, intent)) {
+                    mMoPubNativeListener.onNativeClick(mView.get());
+                    mContext.startActivity(intent);
+                } else {
+                    if (mUrlIterator.hasNext()) {
+                        NativeHttpClient.getResolvedUrl(mUrlIterator.next(), this);
+                    } else {
+                        mMoPubNativeListener.onNativeClick(mView.get());
+                        MoPubBrowser.open(mContext, result);
+                    }
+                }
+            } else {
+                mMoPubNativeListener.onNativeClick(mView.get());
+                MoPubBrowser.open(mContext, result);
+            }
+
+            if (mSpinningProgressView.get() != null) {
+                mSpinningProgressView.get().removeFromRoot();
+            }
+        }
+
+        @Override
+        public void onFailure() {
+            MoPubLog("Failed to resolve URL for click.");
+            if (mSpinningProgressView.get() != null) {
+                mSpinningProgressView.get().removeFromRoot();
+            }
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeErrorCode.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeErrorCode.java
new file mode 100644
index 00000000..12a14a49
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeErrorCode.java
@@ -0,0 +1,23 @@
+package com.mopub.nativeads;
+
+public enum NativeErrorCode {
+    EMPTY_AD_RESPONSE("Server returned empty response."),
+    INVALID_JSON("Unable to parse JSON response from server."),
+    IMAGE_DOWNLOAD_FAILURE("Unable to download images associated with ad."),
+    INVALID_REQUEST_URL("Invalid request url."),
+    UNEXPECTED_RESPONSE_CODE("Received unexpected response code from server."),
+    SERVER_ERROR_RESPONSE_CODE("Server returned erroneous response code."),
+    CONNECTION_ERROR("Network is unavailable."),
+    UNSPECIFIED("Unspecified error occurred.");
+
+    private final String message;
+
+    private NativeErrorCode(String message) {
+        this.message = message;
+    }
+
+    @Override
+    public final String toString() {
+        return message;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeHttpClient.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeHttpClient.java
new file mode 100644
index 00000000..462c9d30
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeHttpClient.java
@@ -0,0 +1,65 @@
+package com.mopub.nativeads;
+
+import android.net.http.AndroidHttpClient;
+
+import com.mopub.common.util.AsyncTasks;
+import com.mopub.common.util.DeviceUtils;
+
+import org.apache.http.HttpStatus;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.client.params.HttpClientParams;
+import org.apache.http.params.HttpConnectionParams;
+import org.apache.http.params.HttpParams;
+
+import static com.mopub.nativeads.UrlResolutionTask.UrlResolutionListener;
+import static com.mopub.nativeads.util.Utils.MoPubLog;
+
+class NativeHttpClient {
+    private static final int CONNECTION_TIMEOUT = 10000;
+    private static final int SOCKET_TIMEOUT = 10000;
+
+    public static AndroidHttpClient getHttpClient() {
+        String userAgent = DeviceUtils.getUserAgent();
+
+        AndroidHttpClient httpClient = AndroidHttpClient.newInstance(userAgent);
+
+        HttpParams params = httpClient.getParams();
+        HttpConnectionParams.setConnectionTimeout(params, CONNECTION_TIMEOUT);
+        HttpConnectionParams.setSoTimeout(params, SOCKET_TIMEOUT);
+        HttpClientParams.setRedirecting(params, true);
+
+        return httpClient;
+    }
+
+    static void makeTrackingHttpRequest(final String url) {
+        final DownloadTask httpDownloadTask = new DownloadTask(new DownloadTask.DownloadTaskListener() {
+            @Override
+            public void onComplete(final String url, final DownloadResponse downloadResponse) {
+                if (downloadResponse == null || downloadResponse.getStatusCode() != HttpStatus.SC_OK) {
+                    MoPubLog("Failed to hit tracking endpoint: " + url);
+                    return;
+                }
+
+                String result = HttpResponses.asResponseString(downloadResponse);
+
+                if (result != null) {
+                    MoPubLog("Successfully hit tracking endpoint:" + url);
+                } else {
+                    MoPubLog("Failed to hit tracking endpoint: " + url);
+                }
+            }
+        });
+
+        try {
+            final HttpGet httpGet = new HttpGet(url);
+            httpDownloadTask.execute(httpGet);
+        } catch (Exception e) {
+            MoPubLog("Failed to hit tracking endpoint: " + url);
+        }
+    }
+
+    static void getResolvedUrl(final String urlString, final UrlResolutionListener listener) {
+        final UrlResolutionTask urlResolutionTask = new UrlResolutionTask(listener);
+        AsyncTasks.safeExecuteOnExecutor(urlResolutionTask, urlString);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeResponse.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeResponse.java
new file mode 100644
index 00000000..edf7f8d6
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeResponse.java
@@ -0,0 +1,311 @@
+package com.mopub.nativeads;
+
+import android.widget.ImageView;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import static com.mopub.nativeads.NativeResponse.Parameter.CALL_TO_ACTION;
+import static com.mopub.nativeads.NativeResponse.Parameter.CLICK_DESTINATION;
+import static com.mopub.nativeads.NativeResponse.Parameter.CLICK_TRACKER;
+import static com.mopub.nativeads.NativeResponse.Parameter.ICON_IMAGE;
+import static com.mopub.nativeads.NativeResponse.Parameter.IMPRESSION_TRACKER;
+import static com.mopub.nativeads.NativeResponse.Parameter.MAIN_IMAGE;
+import static com.mopub.nativeads.NativeResponse.Parameter.TEXT;
+import static com.mopub.nativeads.NativeResponse.Parameter.TITLE;
+import static com.mopub.nativeads.NativeResponse.Parameter.isImageKey;
+import static com.mopub.nativeads.util.Utils.MoPubLog;
+import static java.util.Map.Entry;
+
+public final class NativeResponse {
+    enum Parameter {
+        IMPRESSION_TRACKER("imptracker", true),
+        CLICK_TRACKER("clktracker", true),
+
+        TITLE("title", false),
+        TEXT("text", false),
+        MAIN_IMAGE("mainimage", false),
+        ICON_IMAGE("iconimage", false),
+
+        CLICK_DESTINATION("clk", false),
+        FALLBACK("fallback", false),
+        CALL_TO_ACTION("ctatext", false),
+        STAR_RATING("starrating", false);
+
+        private final String name;
+        private final boolean required;
+
+        Parameter(final String name, boolean required) {
+            this.name = name;
+            this.required = required;
+        }
+
+        static Parameter from(final String name) {
+            for (final Parameter parameter : Parameter.values()) {
+                if (parameter.name.equals(name)) {
+                    return parameter;
+                }
+            }
+
+            return null;
+        }
+
+        static boolean isImageKey(final String name) {
+            return name != null && name.toLowerCase().endsWith("image");
+        }
+
+        static Set<String> requiredKeys = new HashSet<String>();
+        static {
+            for (final Parameter parameter : Parameter.values()) {
+                if (parameter.required) {
+                    requiredKeys.add(parameter.name);
+                }
+            }
+        }
+    }
+
+    private String mMainImageUrl;
+    private String mIconImageUrl;
+    private List<String> mImpressionTrackers;
+    private String mClickTracker;
+    private String mClickDestinationUrl;
+    private String mCallToAction;
+    private String mTitle;
+    private String mText;
+    private boolean mRecordedImpression;
+    private final Map<String, Object> mExtras;
+    private boolean mIsDestroyed;
+
+    NativeResponse(final JSONObject jsonObject) throws IllegalArgumentException {
+        mExtras = new HashMap<String, Object>();
+        mImpressionTrackers = new ArrayList<String>();
+
+        if (!containsRequiredKeys(jsonObject)) {
+            throw new IllegalArgumentException("JSONObject did not contain required keys.");
+        }
+
+        Iterator<String> keys = jsonObject.keys();
+        while (keys.hasNext()) {
+            final String key = keys.next();
+            final Parameter parameter = Parameter.from(key);
+
+            if (parameter != null) {
+                try {
+                    addInstanceVariable(parameter, jsonObject.opt(key));
+                } catch (ClassCastException e) {
+                    throw new IllegalArgumentException("JSONObject key (" + key + ") contained unexpected value.");
+                }
+            } else {
+                addExtra(key, jsonObject.opt(key));
+            }
+        }
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder stringBuilder = new StringBuilder();
+
+        stringBuilder.append(TITLE.name).append(":").append(mTitle).append("\n");
+        stringBuilder.append(TEXT.name).append(":").append(mText).append("\n");
+        stringBuilder.append(ICON_IMAGE.name).append(":").append(mIconImageUrl).append("\n");
+        stringBuilder.append(MAIN_IMAGE.name).append(":").append(mMainImageUrl).append("\n");
+        stringBuilder.append(IMPRESSION_TRACKER.name).append(":").append(mImpressionTrackers).append("\n");
+        stringBuilder.append(CLICK_TRACKER.name).append(":").append(mClickTracker).append("\n");
+        stringBuilder.append(CLICK_DESTINATION.name).append(":").append(mClickDestinationUrl).append("\n");
+        stringBuilder.append(CALL_TO_ACTION.name).append(":").append(mCallToAction).append("\n");
+        stringBuilder.append("recordedImpression").append(":").append(mRecordedImpression).append("\n");
+        stringBuilder.append("extras").append(":").append(mExtras);
+
+        return stringBuilder.toString();
+    }
+
+    public void destroy() {
+        mIsDestroyed = true;
+        mExtras.clear();
+    }
+
+    /**
+     * Getters
+     */
+    public String getMainImageUrl() {
+        return mMainImageUrl;
+    }
+
+    public void loadMainImage(final ImageView imageView) {
+        loadImageView(mMainImageUrl, imageView);
+    }
+
+    public String getIconImageUrl() {
+        return mIconImageUrl;
+    }
+
+    public void loadIconImage(final ImageView imageView) {
+        loadImageView(mIconImageUrl, imageView);
+    }
+
+    public List<String> getImpressionTrackers() {
+        return mImpressionTrackers;
+    }
+
+    public String getClickTracker() {
+        return mClickTracker;
+    }
+
+    public String getClickDestinationUrl() {
+        return mClickDestinationUrl;
+    }
+
+    public String getCallToAction() {
+        return mCallToAction;
+    }
+
+    public String getTitle() {
+        return mTitle;
+    }
+
+    public String getSubtitle() {
+        return mText;
+    }
+
+    public boolean getRecordedImpression() {
+        return mRecordedImpression;
+    }
+
+    public Object getExtra(final String key) {
+        return mExtras.get(key);
+    }
+
+    public Map<String, Object> getExtras() {
+        return new HashMap<String, Object>(mExtras);
+    }
+
+    public void loadExtrasImage(final String key, final ImageView imageView) {
+        Object object = mExtras.get(key);
+        if (object != null && object instanceof String) {
+            final String imageUrl = (String) mExtras.get(key);
+            loadImageView(imageUrl, imageView);
+        }
+    }
+
+    private void loadImageView(final String url, final ImageView imageView) {
+        ImageViewService.loadImageView(url, imageView);
+    }
+
+    public boolean isDestroyed() {
+        return mIsDestroyed;
+    }
+
+    List<String> getExtrasImageUrls() {
+        final List<String> extrasBitmapUrls = new ArrayList<String>(mExtras.size());
+
+        for (final Entry<String, Object> entry : mExtras.entrySet()) {
+            if (isImageKey(entry.getKey()) && entry.getValue() instanceof String) {
+                extrasBitmapUrls.add((String) entry.getValue());
+            }
+        }
+
+        return extrasBitmapUrls;
+    }
+
+    List<String> getAllImageUrls() {
+        final List<String> imageUrls = new ArrayList<String>();
+        if (mMainImageUrl != null) {
+            imageUrls.add(mMainImageUrl);
+        }
+        if (mIconImageUrl != null) {
+            imageUrls.add(mIconImageUrl);
+        }
+
+        imageUrls.addAll(getExtrasImageUrls());
+        return imageUrls;
+    }
+
+    /**
+     * Setters
+     */
+
+    void recordImpression() {
+        mRecordedImpression = true;
+    }
+
+    private boolean containsRequiredKeys(final JSONObject jsonObject) {
+        final Set<String> keys = new HashSet<String>();
+
+        final Iterator<String> jsonKeys = jsonObject.keys();
+        while (jsonKeys.hasNext()) {
+            keys.add(jsonKeys.next());
+        }
+
+        return keys.containsAll(Parameter.requiredKeys);
+    }
+
+    private void addInstanceVariable(final Parameter key, final Object value) throws ClassCastException {
+        try {
+            switch (key) {
+                case MAIN_IMAGE:
+                    mMainImageUrl = (String) value;
+                    break;
+                case ICON_IMAGE:
+                    mIconImageUrl = (String) value;
+                    break;
+                case IMPRESSION_TRACKER:
+                    addImpressionTrackers(value);
+                    break;
+                case CLICK_TRACKER:
+                    mClickTracker = (String) value;
+                    break;
+                case CLICK_DESTINATION:
+                    mClickDestinationUrl = (String) value;
+                    break;
+                case CALL_TO_ACTION:
+                    mCallToAction = (String) value;
+                    break;
+                case TITLE:
+                    mTitle = (String) value;
+                    break;
+                case TEXT:
+                    mText = (String) value;
+                    break;
+                default:
+                    MoPubLog("Unable to add JSON key to internal mapping: " + key.name);
+                    break;
+            }
+        } catch (ClassCastException e) {
+            if (!key.required) {
+                MoPubLog("Ignoring class cast exception for optional defined key: " + key.name);
+            } else {
+                throw e;
+            }
+        }
+    }
+
+    private void addExtra(final String key, final Object value) {
+        mExtras.put(key, value);
+    }
+
+    private void addImpressionTrackers(final Object impressionTrackers) throws ClassCastException {
+        if (!(impressionTrackers instanceof JSONArray)) {
+            throw new ClassCastException("Expected impression trackers of type JSONArray.");
+        }
+
+        final JSONArray trackers = (JSONArray) impressionTrackers;
+
+        for (int i = 0; i < trackers.length(); i++) {
+            try {
+                mImpressionTrackers.add(trackers.getString(i));
+            } catch (JSONException e) {
+                // This will only occur if we access a non-existent index in JSONArray.
+                MoPubLog("Unable to parse impression trackers.");
+            }
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeUrlGenerator.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeUrlGenerator.java
new file mode 100644
index 00000000..6d9e7ab4
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeUrlGenerator.java
@@ -0,0 +1,87 @@
+package com.mopub.nativeads;
+
+import android.content.Context;
+import android.location.Location;
+import android.os.Build;
+
+import com.mopub.common.AdUrlGenerator;
+import com.mopub.common.GpsHelper;
+import com.mopub.common.LocationService;
+import com.mopub.common.util.DeviceUtils;
+import com.mopub.common.MoPub;
+
+class NativeUrlGenerator extends AdUrlGenerator {
+    private static int sLocationPrecision = 6;
+    private static LocationService.LocationAwareness sLocationAwareness
+            = LocationService.LocationAwareness.NORMAL;
+
+    NativeUrlGenerator(Context context) {
+        super(context);
+    }
+
+    @Override
+    public NativeUrlGenerator withAdUnitId(final String adUnitId) {
+        mAdUnitId = adUnitId;
+        return this;
+    }
+
+    NativeUrlGenerator withRequest(final RequestParameters requestParameters) {
+        if (requestParameters != null) {
+            mKeywords = requestParameters.getKeywords();
+            mLocation = requestParameters.getLocation();
+        }
+        return this;
+    }
+
+    @Override
+    public String generateUrlString(final String serverHostname) {
+        initUrlString(serverHostname, Constants.NATIVE_HANDLER);
+
+        setAdUnitId(mAdUnitId);
+
+        setSdkVersion(MoPub.SDK_VERSION);
+
+        setDeviceInfo(Build.MANUFACTURER, Build.MODEL, Build.PRODUCT);
+
+        setUdid(getUdidFromContext(mContext));
+
+        setDoNotTrack(GpsHelper.isLimitAdTrackingEnabled(mContext));
+
+        setKeywords(mKeywords);
+
+        Location location = mLocation;
+        if (location == null) {
+            location = LocationService.getLastKnownLocation(mContext,
+                                                            sLocationPrecision,
+                                                            sLocationAwareness);
+        }
+
+        setLocation(location);
+
+        setTimezone(getTimeZoneOffsetString());
+
+        setOrientation(mContext.getResources().getConfiguration().orientation);
+
+        setDensity(mContext.getResources().getDisplayMetrics().density);
+
+        String networkOperator = getNetworkOperator();
+        setMccCode(networkOperator);
+        setMncCode(networkOperator);
+
+        setIsoCountryCode(mTelephonyManager.getNetworkCountryIso());
+        setCarrierName(mTelephonyManager.getNetworkOperatorName());
+
+        setNetworkType(getActiveNetworkType());
+
+        setAppVersion(getAppVersionFromContext(mContext));
+
+        setTwitterAppInstalledFlag();
+
+        return getFinalUrlString();
+    }
+
+    @Override
+    protected void setSdkVersion(String sdkVersion) {
+        addParam("nsv", sdkVersion);
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/NativeViewHolder.java b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeViewHolder.java
new file mode 100644
index 00000000..ca0bc5d3
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/NativeViewHolder.java
@@ -0,0 +1,91 @@
+package com.mopub.nativeads;
+
+import android.view.View;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import static com.mopub.nativeads.NativeResponse.Parameter.isImageKey;
+import static com.mopub.nativeads.util.Utils.MoPubLog;
+
+class NativeViewHolder {
+    TextView titleView;
+    TextView textView;
+    TextView callToActionView;
+    ImageView mainImageView;
+    ImageView iconImageView;
+
+    // Use fromViewBinder instead of a constructor
+    private NativeViewHolder() {}
+
+    static NativeViewHolder fromViewBinder(final View view, final ViewBinder viewBinder) {
+        NativeViewHolder nativeViewHolder = new NativeViewHolder();
+
+        try {
+            nativeViewHolder.titleView = (TextView) view.findViewById(viewBinder.titleId);
+            nativeViewHolder.textView = (TextView) view.findViewById(viewBinder.textId);
+            nativeViewHolder.callToActionView = (TextView) view.findViewById(viewBinder.callToActionId);
+            nativeViewHolder.mainImageView = (ImageView) view.findViewById(viewBinder.mainImageId);
+            nativeViewHolder.iconImageView = (ImageView) view.findViewById(viewBinder.iconImageId);
+        } catch (ClassCastException e) {
+            MoPubLog("Could not cast View from id in ViewBinder to expected View type", e);
+            return null;
+        }
+
+        return nativeViewHolder;
+    }
+
+    void update(final NativeResponse nativeResponse) {
+        addTextView(titleView, nativeResponse.getTitle());
+        addTextView(textView, nativeResponse.getSubtitle());
+        addTextView(callToActionView, nativeResponse.getCallToAction());
+
+        nativeResponse.loadMainImage(mainImageView);
+        nativeResponse.loadIconImage(iconImageView);
+    }
+
+    void updateExtras(final View outerView,
+                      final NativeResponse nativeResponse,
+                      final ViewBinder viewBinder) {
+        for (final String key : viewBinder.extras.keySet()) {
+            final int resourceId = viewBinder.extras.get(key);
+            final View view = outerView.findViewById(resourceId);
+            final Object content = nativeResponse.getExtra(key);
+
+            if (isImageKey(key)) {
+                if (view instanceof ImageView) {
+                    // Clear previous image
+                    ((ImageView) view).setImageDrawable(null);
+                    nativeResponse.loadExtrasImage(key, (ImageView) view);
+                } else {
+                    MoPubLog("View bound to " + key + " should be an instance of ImageView.");
+                }
+            } else {
+                if (view instanceof TextView) {
+                    // Clear previous text value
+                    ((TextView) view).setText(null);
+                    if (content instanceof String) {
+                        addTextView((TextView) view, (String) content);
+                    }
+                } else {
+                    MoPubLog("View bound to " + key + " should be an instance of TextView.");
+                }
+            }
+        }
+    }
+
+    private void addTextView(final TextView textView, final String contents) {
+        if (textView == null) {
+            MoPubLog("Attempted to add text (" + contents + ") to null TextView.");
+            return;
+        }
+
+        // Clear previous value
+        textView.setText(null);
+
+        if (contents == null) {
+            MoPubLog("Attempted to set TextView contents to null.");
+        } else {
+            textView.setText(contents);
+        }
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/RequestParameters.java b/mopub-sdk/src/main/java/com/mopub/nativeads/RequestParameters.java
new file mode 100644
index 00000000..c3f6d995
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/RequestParameters.java
@@ -0,0 +1,40 @@
+package com.mopub.nativeads;
+
+import android.location.Location;
+
+public final class RequestParameters {
+    private final String mKeywords;
+    private final Location mLocation;
+
+    public final static class Builder {
+        private String keywords;
+        private Location location;
+
+        public final Builder keywords(String keywords) {
+            this.keywords = keywords;
+            return this;
+        }
+
+        public final Builder location(Location location) {
+            this.location = location;
+            return this;
+        }
+
+        public final RequestParameters build() {
+            return new RequestParameters(this);
+        }
+    }
+
+    private RequestParameters(Builder builder) {
+        mKeywords = builder.keywords;
+        mLocation = builder.location;
+    }
+
+    public final String getKeywords() {
+        return mKeywords;
+    }
+
+    public final Location getLocation() {
+        return mLocation;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/SpinningProgressView.java b/mopub-sdk/src/main/java/com/mopub/nativeads/SpinningProgressView.java
new file mode 100644
index 00000000..2b442392
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/SpinningProgressView.java
@@ -0,0 +1,78 @@
+package com.mopub.nativeads;
+
+import android.content.Context;
+import android.graphics.Color;
+import android.view.Gravity;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.LinearLayout;
+import android.widget.ProgressBar;
+
+import com.mopub.common.util.Dips;
+import com.mopub.common.util.Views;
+
+import static android.widget.RelativeLayout.LayoutParams.MATCH_PARENT;
+
+class SpinningProgressView extends ViewGroup {
+    private final ProgressBar mProgressBar;
+    private int mProgressIndicatorRadius;
+
+    SpinningProgressView(final Context context) {
+        super(context);
+
+        final LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(MATCH_PARENT, MATCH_PARENT);
+        params.gravity = Gravity.CENTER;
+        setLayoutParams(params);
+
+        setVisibility(GONE);
+        setBackgroundColor(Color.BLACK);
+        getBackground().setAlpha(180);
+
+        mProgressBar = new ProgressBar(context);
+        mProgressIndicatorRadius = Dips.asIntPixels(25, getContext());
+        mProgressBar.setIndeterminate(true);
+        addView(mProgressBar);
+    }
+
+    @Override
+    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
+        if (changed) {
+            final int centerX = (left + right) / 2;
+            final int centerY = (top + bottom) / 2;
+            mProgressBar.layout(
+                    centerX - mProgressIndicatorRadius,
+                    centerY - mProgressIndicatorRadius,
+                    centerX + mProgressIndicatorRadius,
+                    centerY + mProgressIndicatorRadius
+            );
+        }
+
+    }
+
+    boolean addToRoot(final View view) {
+        if (view == null) {
+            return false;
+        }
+
+        final View rootView = view.getRootView();
+
+        if (rootView != null && rootView instanceof ViewGroup) {
+            final ViewGroup rootViewGroup = (ViewGroup) rootView;
+
+            setVisibility(VISIBLE);
+            setMeasuredDimension(rootView.getWidth(), rootView.getHeight());
+
+            rootViewGroup.addView(this);
+            forceLayout();
+            return true;
+        }
+
+        return false;
+    }
+
+    boolean removeFromRoot() {
+        Views.removeFromParent(this);
+        setVisibility(GONE);
+        return true;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/UrlResolutionTask.java b/mopub-sdk/src/main/java/com/mopub/nativeads/UrlResolutionTask.java
new file mode 100644
index 00000000..cdd9050a
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/UrlResolutionTask.java
@@ -0,0 +1,96 @@
+package com.mopub.nativeads;
+
+import android.os.AsyncTask;
+
+import com.mopub.common.util.IntentUtils;
+
+import java.io.IOException;
+import java.net.HttpURLConnection;
+import java.net.URL;
+
+class UrlResolutionTask extends AsyncTask<String, Void, String> {
+    private static final int REDIRECT_LIMIT = 10;
+
+    interface UrlResolutionListener {
+        void onSuccess(String result);
+        void onFailure();
+    }
+
+    private final UrlResolutionListener mListener;
+
+    UrlResolutionTask(UrlResolutionListener listener) {
+        mListener = listener;
+    }
+
+    @Override
+    protected String doInBackground(String... urls) {
+        if (urls == null || urls.length == 0) {
+            return null;
+        }
+
+        String previousUrl = null;
+        try {
+            String locationUrl = urls[0];
+
+            int redirectCount = 0;
+            while (locationUrl != null && redirectCount < REDIRECT_LIMIT) {
+                // if location url is not http(s), assume it's an Android deep link
+                // this scheme will fail URL validation so we have to check early
+                if (!IntentUtils.isHttpUrl(locationUrl)) {
+                    return locationUrl;
+                }
+
+                previousUrl = locationUrl;
+                locationUrl = getRedirectLocation(locationUrl);
+                redirectCount++;
+            }
+
+        } catch (IOException e) {
+            return null;
+        }
+
+        return previousUrl;
+    }
+
+    private String getRedirectLocation(final String urlString) throws IOException {
+        final URL url = new URL(urlString);
+
+        HttpURLConnection httpUrlConnection = null;
+        try {
+            httpUrlConnection = (HttpURLConnection) url.openConnection();
+            httpUrlConnection.setInstanceFollowRedirects(false);
+
+            int responseCode = httpUrlConnection.getResponseCode();
+
+            if (responseCode >= 300 && responseCode < 400) {
+                return httpUrlConnection.getHeaderField("Location");
+            } else {
+                return null;
+            }
+        } finally {
+            if (httpUrlConnection != null) {
+                httpUrlConnection.disconnect();
+            }
+        }
+    }
+
+    @Override
+    protected void onPostExecute(final String resolvedUrl) {
+        super.onPostExecute(resolvedUrl);
+
+        if (isCancelled() || resolvedUrl == null) {
+            onCancelled();
+        } else {
+            mListener.onSuccess(resolvedUrl);
+        }
+    }
+
+    @Override
+    protected void onCancelled() {
+        super.onCancelled();
+
+        mListener.onFailure();
+    }
+}
+
+
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/ViewBinder.java b/mopub-sdk/src/main/java/com/mopub/nativeads/ViewBinder.java
new file mode 100644
index 00000000..e8309c70
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/ViewBinder.java
@@ -0,0 +1,78 @@
+package com.mopub.nativeads;
+
+import java.util.HashMap;
+import java.util.Map;
+
+public final class ViewBinder {
+    public final static class Builder {
+        private final int layoutId;
+        private int titleId;
+        private int textId;
+        private int callToActionId;
+        private int mainImageId;
+        private int iconImageId;
+        private Map<String, Integer> extras;
+
+        public Builder(final int layoutId) {
+            this.layoutId = layoutId;
+            this.extras = new HashMap<String, Integer>();
+        }
+
+        public final Builder titleId(final int titleId) {
+            this.titleId = titleId;
+            return this;
+        }
+
+        public final Builder textId(final int textId) {
+            this.textId = textId;
+            return this;
+        }
+
+        public final Builder callToActionId(final int callToActionId) {
+            this.callToActionId = callToActionId;
+            return this;
+        }
+
+        public final Builder mainImageId(final int mainImageId) {
+            this.mainImageId = mainImageId;
+            return this;
+        }
+
+        public final Builder iconImageId(final int iconImageId) {
+            this.iconImageId = iconImageId;
+            return this;
+        }
+
+        public final Builder addExtras(final Map<String, Integer> resourceIds) {
+            this.extras = new HashMap<String, Integer>(resourceIds);
+            return this;
+        }
+
+        public final Builder addExtra(final String key, final int resourceId) {
+            this.extras.put(key, resourceId);
+            return this;
+        }
+
+        public final ViewBinder build() {
+            return new ViewBinder(this);
+        }
+    }
+
+    final int layoutId;
+    final int titleId;
+    final int textId;
+    final int callToActionId;
+    final int mainImageId;
+    final int iconImageId;
+    final Map<String, Integer> extras;
+
+    private ViewBinder(final Builder builder) {
+        this.layoutId = builder.layoutId;
+        this.titleId = builder.titleId;
+        this.textId = builder.textId;
+        this.callToActionId = builder.callToActionId;
+        this.mainImageId = builder.mainImageId;
+        this.iconImageId = builder.iconImageId;
+        this.extras = builder.extras;
+    }
+}
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/util/Utils.java b/mopub-sdk/src/main/java/com/mopub/nativeads/util/Utils.java
new file mode 100644
index 00000000..bc0e069b
--- /dev/null
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/util/Utils.java
@@ -0,0 +1,15 @@
+package com.mopub.nativeads.util;
+
+import android.util.Log;
+
+import com.mopub.nativeads.Constants;
+
+public class Utils {
+    public static void MoPubLog(String message) {
+        MoPubLog(message, null);
+    }
+
+    public static void MoPubLog(String message, Exception exception) {
+        Log.d(Constants.LOGTAG, message, exception);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/common/GpsHelperTest.java b/mopub-sdk/src/test/java/com/mopub/common/GpsHelperTest.java
new file mode 100644
index 00000000..0f46c31f
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/GpsHelperTest.java
@@ -0,0 +1,360 @@
+/*
+ * Copyright (c) 2010-2013, MoPub Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *  Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in the
+ *   documentation and/or other materials provided with the distribution.
+ *
+ *  Neither the name of 'MoPub Inc.' nor the names of its contributors
+ *   may be used to endorse or promote products derived from this software
+ *   without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.mopub.common;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.SharedPreferences;
+
+import com.mopub.common.factories.MethodBuilderFactory;
+import com.mopub.common.util.test.support.TestMethodBuilderFactory;
+import com.mopub.mobileads.test.support.SdkTestRunner;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.concurrent.Semaphore;
+
+import static com.mopub.common.util.Reflection.MethodBuilder;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class GpsHelperTest {
+    private MethodBuilder methodBuilder;
+    private Activity context;
+    private TestAdInfo adInfo;
+    private Semaphore semaphore;
+    private GpsHelper.GpsHelperListener semaphoreGpsHelperListener;
+
+    // This class emulates the AdInfo class returned from the Google Play Services
+    // AdvertisingIdClient.getAdvertisingIdInfo method; need to implement getters for reflection calls
+    public static final class TestAdInfo {
+        public static final String ADVERTISING_ID = "38400000-8cf0-11bd-b23e-10b96e40000d";
+        public static final boolean LIMIT_AD_TRACKING_ENABLED = true;
+
+        public String getId() {
+            return ADVERTISING_ID;
+        }
+
+        public boolean isLimitAdTrackingEnabled() {
+            return LIMIT_AD_TRACKING_ENABLED;
+        }
+    }
+
+    @Before
+    public void setup() {
+    	context = new Activity();
+        adInfo = new TestAdInfo();
+
+        methodBuilder = TestMethodBuilderFactory.getSingletonMock();
+        when(methodBuilder.setStatic(any(Class.class))).thenReturn(methodBuilder);
+        when(methodBuilder.addParam(any(Class.class), any())).thenReturn(methodBuilder);
+
+        semaphore = new Semaphore(0);
+        semaphoreGpsHelperListener = new GpsHelper.GpsHelperListener() {
+            @Override
+            public void onFetchAdInfoCompleted() {
+                semaphore.release();
+            }
+        };
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        reset(methodBuilder);
+    }
+
+    @Test
+    public void isGpsAvailable_whenGooglePlayServicesIsLinked_shouldReturnTrue() throws Exception {
+        GpsHelper.setClassNamesForTesting();
+        when(methodBuilder.execute()).thenReturn(GpsHelper.GOOGLE_PLAY_SUCCESS_CODE);
+        assertThat(GpsHelper.isGpsAvailable(context)).isTrue();
+    }
+
+    @Test
+    public void isGpsAvailable_whenGooglePlayServicesReturnsNonSuccessCode_shouldReturnFalse() throws Exception {
+        GpsHelper.setClassNamesForTesting();
+        when(methodBuilder.execute()).thenReturn(GpsHelper.GOOGLE_PLAY_SUCCESS_CODE + 1);
+        assertThat(GpsHelper.isGpsAvailable(context)).isFalse();
+    }
+
+    @Test
+    public void isGpsAvailable_whenGooglePlayServicesReturnsNull_shouldReturnFalse() throws Exception {
+        GpsHelper.setClassNamesForTesting();
+        when(methodBuilder.execute()).thenReturn(null);
+        assertThat(GpsHelper.isGpsAvailable(context)).isFalse();
+    }
+
+    @Test
+    public void isGpsAvailable_whenGooglePlayServicesIsNotLinked_shouldReturnFalse() throws Exception {
+        assertThat(GpsHelper.isGpsAvailable(context)).isFalse();
+    }
+
+    @Test
+    public void asyncFetchAdvertisingInfo_whenGooglePlayServicesIsLinked_shouldPopulateSharedPreferences() throws Exception {
+        verifyCleanSharedPreferences(context);
+        GpsHelper.setClassNamesForTesting();
+        when(methodBuilder.execute()).thenReturn(
+                adInfo,
+                adInfo.ADVERTISING_ID,
+                adInfo.LIMIT_AD_TRACKING_ENABLED
+        );
+
+        GpsHelper.asyncFetchAdvertisingInfo(context, semaphoreGpsHelperListener);
+        semaphore.acquire();
+        verifySharedPreferences(context, adInfo);
+    }
+
+    @Test
+    public void asyncFetchAdvertisingInfo_whenReflectedMethodCallThrows_shouldNotPopulateSharedPreferences() throws Exception {
+        verifyCleanSharedPreferences(context);
+        GpsHelper.setClassNamesForTesting();
+        when(methodBuilder.execute()).thenThrow(new Exception());
+
+        GpsHelper.asyncFetchAdvertisingInfo(context, semaphoreGpsHelperListener);
+        semaphore.acquire();
+        verifyCleanSharedPreferences(context);
+    }
+
+    @Test
+    public void asyncFetchAdvertisingInfo_whenReflectedMethodCallReturnsNull_shouldNotPopulateSharedPreferences() throws Exception {
+        verifyCleanSharedPreferences(context);
+        GpsHelper.setClassNamesForTesting();
+        when(methodBuilder.execute()).thenReturn(null);
+
+        GpsHelper.asyncFetchAdvertisingInfo(context, semaphoreGpsHelperListener);
+        semaphore.acquire();
+        verifyCleanSharedPreferences(context);
+    }
+
+    @Test
+    public void asyncFetchAdvertisingInfoIfNotCached_whenGooglePlayServicesIsLinkedAndSharedPreferencesIsClean_shouldPopulateSharedPreferences() throws Exception {
+        verifyCleanSharedPreferences(context);
+        GpsHelper.setClassNamesForTesting();
+        when(methodBuilder.execute()).thenReturn(
+                GpsHelper.GOOGLE_PLAY_SUCCESS_CODE,
+                adInfo,
+                adInfo.ADVERTISING_ID,
+                adInfo.LIMIT_AD_TRACKING_ENABLED
+        );
+
+        GpsHelper.asyncFetchAdvertisingInfoIfNotCached(context, semaphoreGpsHelperListener);
+        semaphore.acquire();
+        verifySharedPreferences(context, adInfo);
+    }
+
+    @Test
+    public void asyncFetchAdvertisingInfoIfNotCached_whenGooglePlayServicesLinkedAndSharedPreferencesIsPopulated_shouldNotRePopulateSharedPreferences() throws Exception {
+        verifyCleanSharedPreferences(context);
+        populateAndVerifySharedPreferences(context, adInfo);
+        GpsHelper.setClassNamesForTesting();
+        when(methodBuilder.execute()).thenReturn(
+                GpsHelper.GOOGLE_PLAY_SUCCESS_CODE
+        );
+
+        GpsHelper.asyncFetchAdvertisingInfoIfNotCached(context, semaphoreGpsHelperListener);
+        semaphore.acquire();
+        verify(methodBuilder).execute();
+    }
+
+    @Test
+    public void asyncFetchAdvertisingInfoIfNotCached_whenGooglePlayServicesIsNotLinked_shouldNotPopulateSharedPreferences() throws Exception {
+        verifyCleanSharedPreferences(context);
+        GpsHelper.setClassNamesForTesting();
+        when(methodBuilder.execute()).thenReturn(
+                GpsHelper.GOOGLE_PLAY_SUCCESS_CODE + 1
+        );
+
+        GpsHelper.asyncFetchAdvertisingInfoIfNotCached(context, semaphoreGpsHelperListener);
+        semaphore.acquire();
+        verifyCleanSharedPreferences(context);
+    }
+
+    @Test
+    public void isSharedPreferencesPopulated_whenContainsAdvertisingIdKeyAndIsLimitAdTrackingEnabledKey_shouldReturnTrue() throws Exception {
+        verifyCleanSharedPreferences(context);
+        populateAndVerifySharedPreferences(context, adInfo);
+        assertThat(GpsHelper.isSharedPreferencesPopluated(context)).isTrue();
+    }
+
+    @Test
+    public void isSharedPreferencesPopulated_whenDoesntContainBothKeys_shouldReturnFalse() throws Exception {
+        verifyCleanSharedPreferences(context);
+        SharedPreferencesHelper.getSharedPreferences(context)
+                .edit()
+                .putString(GpsHelper.ADVERTISING_ID_KEY, adInfo.ADVERTISING_ID)
+                .commit();
+        assertThat(GpsHelper.isSharedPreferencesPopluated(context)).isFalse();
+
+        SharedPreferencesHelper.getSharedPreferences(context).edit().clear().commit();
+        verifyCleanSharedPreferences(context);
+        SharedPreferencesHelper.getSharedPreferences(context)
+                .edit()
+                .putBoolean(GpsHelper.IS_LIMIT_AD_TRACKING_ENABLED_KEY, adInfo.LIMIT_AD_TRACKING_ENABLED)
+                .commit();
+        assertThat(GpsHelper.isSharedPreferencesPopluated(context)).isFalse();
+    }
+
+    @Test
+    public void isSharedPreferencesPopulated_whenClean_shouldReturnFalse() throws Exception {
+        verifyCleanSharedPreferences(context);
+        assertThat(GpsHelper.isSharedPreferencesPopluated(context)).isFalse();
+    }
+
+    @Test
+    public void updateSharedPreferences_whenPassingInValidAdInfoObject_shouldUpdateSharedPreferences() throws Exception {
+        // Use the real MethodBuilderFactory for this test, not the mock one
+        // Most mocks are set by default in SdkTestRunner setup
+        MethodBuilderFactory.setInstance(new MethodBuilderFactory());
+        verifyCleanSharedPreferences(context);
+        GpsHelper.updateSharedPreferences(context, adInfo);
+        verifySharedPreferences(context, adInfo);
+    }
+
+    @Test
+    public void reflectedGetIsLimitAdTrackingEnabled_whenIsLimitAdTrackingEnabledIsSet_shouldReturnIsLimitAdTrackingEnabled() throws Exception {
+        MethodBuilderFactory.setInstance(new MethodBuilderFactory());
+        assertThat(GpsHelper.reflectedIsLimitAdTrackingEnabled(adInfo, false)).isEqualTo(adInfo.LIMIT_AD_TRACKING_ENABLED);
+    }
+
+    @Test
+    public void reflectedGetIsLimitAdTrackingEnabled_whenReflectedMethodCallThrows_shouldReturnDefaultValue() throws Exception {
+        when(methodBuilder.execute()).thenThrow(new Exception());
+        assertThat(GpsHelper.reflectedIsLimitAdTrackingEnabled(new Object(), false)).isFalse();
+        verify(methodBuilder).execute();
+        assertThat(GpsHelper.reflectedIsLimitAdTrackingEnabled(new Object(), true)).isTrue();
+        verify(methodBuilder, times(2)).execute();
+    }
+
+    @Test
+    public void reflectedGetIsLimitAdTrackingEnabled_whenReflectedMethodCallReturnsNull_shouldReturnDefaultValue() throws Exception {
+        when(methodBuilder.execute()).thenReturn(null);
+        assertThat(GpsHelper.reflectedIsLimitAdTrackingEnabled(new Object(), false)).isFalse();
+        verify(methodBuilder).execute();
+        assertThat(GpsHelper.reflectedIsLimitAdTrackingEnabled(new Object(), true)).isTrue();
+        verify(methodBuilder, times(2)).execute();
+    }
+
+    @Test
+    public void reflectedGetAdvertisingId_whenAdvertisingIdIsSet_shouldReturnAdvertisingId() throws Exception {
+        MethodBuilderFactory.setInstance(new MethodBuilderFactory());
+        assertThat(GpsHelper.reflectedGetAdvertisingId(adInfo, null)).isEqualTo(adInfo.ADVERTISING_ID);
+    }
+
+    @Test
+    public void reflectedGetAdvertisingId_whenReflectedMethodCallThrows_shouldReturnDefaultValue() throws Exception {
+        when(methodBuilder.execute()).thenThrow(new Exception());
+        assertThat(GpsHelper.reflectedGetAdvertisingId(new Object(), null)).isNull();
+        verify(methodBuilder).execute();
+        String defaultAdId = "TEST_DEFAULT";
+        assertThat(GpsHelper.reflectedGetAdvertisingId(new Object(), defaultAdId)).isEqualTo(defaultAdId);
+        verify(methodBuilder, times(2)).execute();
+    }
+
+    @Test
+    public void getAdvertisingId_whenGooglePlayServicesIsLinkedAndAdvertisingIdIsCached_shouldReturnAdvertisingId() throws Exception {
+        GpsHelper.setClassNamesForTesting();
+        when(methodBuilder.execute()).thenReturn(GpsHelper.GOOGLE_PLAY_SUCCESS_CODE);
+        SharedPreferencesHelper.getSharedPreferences(context)
+                .edit()
+                .putString(GpsHelper.ADVERTISING_ID_KEY, adInfo.ADVERTISING_ID)
+                .commit();
+        assertThat(GpsHelper.getAdvertisingId(context)).isEqualTo(adInfo.ADVERTISING_ID);
+    }
+
+    @Test
+    public void getAdvertisingId_whenGooglePlayServicesIsLinkedAndAdInfoIsNotCached_shouldReturnNull() throws Exception {
+        GpsHelper.setClassNamesForTesting();
+        when(methodBuilder.execute()).thenReturn(GpsHelper.GOOGLE_PLAY_SUCCESS_CODE);
+        assertThat(GpsHelper.getAdvertisingId(context)).isNull();
+    }
+
+    @Test
+    public void getAdvertisingId_whenGooglePlayServicesIsNotLinked_shouldReturnNull() throws Exception {
+        assertThat(GpsHelper.getAdvertisingId(context)).isNull();
+    }
+
+    @Test
+    public void isLimitAdTrackingEnabled_whenGooglePlayServicesIsLinkedAndLimitAdTrackingIsCached_shouldReturnLimitAdTracking() throws Exception {
+        GpsHelper.setClassNamesForTesting();
+        when(methodBuilder.execute()).thenReturn(GpsHelper.GOOGLE_PLAY_SUCCESS_CODE);
+        SharedPreferencesHelper.getSharedPreferences(context)
+                .edit()
+                .putBoolean(GpsHelper.IS_LIMIT_AD_TRACKING_ENABLED_KEY, adInfo.LIMIT_AD_TRACKING_ENABLED)
+                .commit();
+        assertThat(GpsHelper.isLimitAdTrackingEnabled(context)).isEqualTo(adInfo.LIMIT_AD_TRACKING_ENABLED);
+    }
+
+    @Test
+    public void isLimitAdTrackingEnabled_whenGooglePlayServicesIsLinkedAndAdInfoIsNotCached_shouldReturnFalse() throws Exception {
+        GpsHelper.setClassNamesForTesting();
+        when(methodBuilder.execute()).thenReturn(GpsHelper.GOOGLE_PLAY_SUCCESS_CODE);
+        assertThat(GpsHelper.isLimitAdTrackingEnabled(context)).isFalse();
+    }
+
+    @Test
+    public void isLimitAdTrackingEnabled_whenGooglePlayServicesIsNotLinked_shouldReturnFalse() throws Exception {
+        assertThat(GpsHelper.isLimitAdTrackingEnabled(context)).isFalse();
+    }
+
+    static public void populateAndVerifySharedPreferences(Context context, TestAdInfo adInfo) {
+        SharedPreferencesHelper.getSharedPreferences(context)
+                .edit()
+                .putString(GpsHelper.ADVERTISING_ID_KEY, adInfo.ADVERTISING_ID)
+                .putBoolean(GpsHelper.IS_LIMIT_AD_TRACKING_ENABLED_KEY, adInfo.LIMIT_AD_TRACKING_ENABLED)
+                .commit();
+        verifySharedPreferences(context, adInfo);
+    }
+
+    static public void verifySharedPreferences(Context context, TestAdInfo adInfo) {
+        SharedPreferences sharedPreferences = SharedPreferencesHelper.getSharedPreferences(context);
+        assertThat(sharedPreferences.contains(GpsHelper.ADVERTISING_ID_KEY)).isTrue();
+        assertThat(sharedPreferences.getString(GpsHelper.ADVERTISING_ID_KEY, null)).isEqualTo(adInfo.ADVERTISING_ID);
+        assertThat(sharedPreferences.contains(GpsHelper.IS_LIMIT_AD_TRACKING_ENABLED_KEY)).isTrue();
+        assertThat(sharedPreferences.getBoolean(GpsHelper.IS_LIMIT_AD_TRACKING_ENABLED_KEY, false)).isEqualTo(adInfo.LIMIT_AD_TRACKING_ENABLED);
+    }
+
+    static public void verifyCleanSharedPreferences(Context context) {
+        SharedPreferences sharedPreferences = SharedPreferencesHelper.getSharedPreferences(context);
+        assertThat(sharedPreferences.contains(GpsHelper.ADVERTISING_ID_KEY)).isFalse();
+        assertThat(sharedPreferences.contains(GpsHelper.IS_LIMIT_AD_TRACKING_ENABLED_KEY)).isFalse();
+    }
+}
+
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/AsyncTasksTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/AsyncTasksTest.java
similarity index 92%
rename from mopub-sdk/src/test/java/com/mopub/mobileads/util/AsyncTasksTest.java
rename to mopub-sdk/src/test/java/com/mopub/common/util/AsyncTasksTest.java
index e71ce79a..8cae5401 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/util/AsyncTasksTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/AsyncTasksTest.java
@@ -1,24 +1,23 @@
-package com.mopub.mobileads.util;
+package com.mopub.common.util;
 
 import android.os.AsyncTask;
 import android.os.Build;
 
-import com.mopub.mobileads.test.support.SdkTestRunner;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
 
 import static android.os.AsyncTask.THREAD_POOL_EXECUTOR;
-import static com.mopub.mobileads.util.VersionCode.HONEYCOMB_MR2;
-import static com.mopub.mobileads.util.VersionCode.ICE_CREAM_SANDWICH;
+import static com.mopub.common.util.VersionCode.HONEYCOMB_MR2;
+import static com.mopub.common.util.VersionCode.ICE_CREAM_SANDWICH;
 import static junit.framework.Assert.fail;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.verify;
 
-@RunWith(SdkTestRunner.class)
+@RunWith(RobolectricTestRunner.class)
 public class AsyncTasksTest {
 
     private AsyncTask<String, ?, ?> asyncTask;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/resource/DrawablesTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/DrawablesTest.java
similarity index 94%
rename from mopub-sdk/src/test/java/com/mopub/mobileads/resource/DrawablesTest.java
rename to mopub-sdk/src/test/java/com/mopub/common/util/DrawablesTest.java
index 3feeabbf..963e36a2 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/resource/DrawablesTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/DrawablesTest.java
@@ -30,16 +30,16 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package com.mopub.mobileads.resource;
+package com.mopub.common.util;
 
 import android.app.Activity;
-import com.mopub.mobileads.test.support.SdkTestRunner;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 
-@RunWith(SdkTestRunner.class)
+@RunWith(RobolectricTestRunner.class)
 public class DrawablesTest {
     @Test
     public void decodeImage_shouldCacheDrawables() throws Exception {
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/FilesTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/FilesTest.java
similarity index 96%
rename from mopub-sdk/src/test/java/com/mopub/mobileads/util/FilesTest.java
rename to mopub-sdk/src/test/java/com/mopub/common/util/FilesTest.java
index 2a87cb76..ca2e55c0 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/util/FilesTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/FilesTest.java
@@ -1,13 +1,12 @@
-package com.mopub.mobileads.util;
+package com.mopub.common.util;
 
 import android.app.Activity;
 
-import com.mopub.mobileads.test.support.SdkTestRunner;
-
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
 
 import java.io.*;
 
@@ -15,7 +14,7 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.stub;
 
-@RunWith(SdkTestRunner.class)
+@RunWith(RobolectricTestRunner.class)
 public class FilesTest {
 
     private Activity activity;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/UtilsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/IntentUtilsTest.java
similarity index 92%
rename from mopub-sdk/src/test/java/com/mopub/mobileads/UtilsTest.java
rename to mopub-sdk/src/test/java/com/mopub/common/util/IntentUtilsTest.java
index 3cc2dd4a..96b365ef 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/UtilsTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/IntentUtilsTest.java
@@ -30,16 +30,16 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package com.mopub.mobileads;
+package com.mopub.common.util;
 
 import android.content.Context;
 import android.content.Intent;
 import android.content.pm.PackageManager;
 import android.content.pm.ResolveInfo;
 import android.net.Uri;
-import com.mopub.mobileads.test.support.SdkTestRunner;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
 
 import java.util.*;
 
@@ -48,8 +48,8 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.stub;
 
-@RunWith(SdkTestRunner.class)
-public class UtilsTest {
+@RunWith(RobolectricTestRunner.class)
+public class IntentUtilsTest {
 
     @Test
     public void deviceCanHandleIntent_whenActivityCanResolveIntent_shouldReturnTrue() throws Exception {
@@ -65,7 +65,7 @@ public void deviceCanHandleIntent_whenActivityCanResolveIntent_shouldReturnTrue(
 
         stub(packageManager.queryIntentActivities(eq(specificIntent), eq(0))).toReturn(resolveInfos);
 
-        assertThat(Utils.deviceCanHandleIntent(context, specificIntent)).isTrue();
+        assertThat(IntentUtils.deviceCanHandleIntent(context, specificIntent)).isTrue();
     }
 
     @Test
@@ -84,7 +84,7 @@ public void deviceCanHandleIntent_whenActivityCanNotResolveIntent_shouldReturnFa
         otherIntent.setData(Uri.parse("other:"));
         stub(packageManager.queryIntentActivities(eq(specificIntent), eq(0))).toReturn(resolveInfos);
 
-        assertThat(Utils.deviceCanHandleIntent(context, otherIntent)).isFalse();
+        assertThat(IntentUtils.deviceCanHandleIntent(context, otherIntent)).isFalse();
     }
 
     @Test
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/ReflectionTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/ReflectionTest.java
similarity index 98%
rename from mopub-sdk/src/test/java/com/mopub/mobileads/util/ReflectionTest.java
rename to mopub-sdk/src/test/java/com/mopub/common/util/ReflectionTest.java
index 7e6874d1..78f7dac2 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/util/ReflectionTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/ReflectionTest.java
@@ -30,16 +30,17 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package com.mopub.mobileads.util;
+package com.mopub.common.util;
 
 import android.app.Activity;
 import android.view.View;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 
-import static com.mopub.mobileads.util.Reflection.MethodBuilder;
+import static com.mopub.common.util.Reflection.*;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.fest.assertions.api.Assertions.fail;
 
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/StreamsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/StreamsTest.java
similarity index 96%
rename from mopub-sdk/src/test/java/com/mopub/mobileads/util/StreamsTest.java
rename to mopub-sdk/src/test/java/com/mopub/common/util/StreamsTest.java
index 4551d0bd..0aab8870 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/util/StreamsTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/StreamsTest.java
@@ -30,18 +30,18 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package com.mopub.mobileads.util;
+package com.mopub.common.util;
 
-import com.mopub.mobileads.test.support.SdkTestRunner;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
 
 import java.io.*;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.fest.assertions.api.Assertions.fail;
 
-@RunWith(SdkTestRunner.class)
+@RunWith(RobolectricTestRunner.class)
 public class StreamsTest {
     @Test
     public void copyStream_shouldCopyContentsOfOneStreamToAnother() throws Exception {
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/StringsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/StringsTest.java
similarity index 94%
rename from mopub-sdk/src/test/java/com/mopub/mobileads/util/StringsTest.java
rename to mopub-sdk/src/test/java/com/mopub/common/util/StringsTest.java
index 8375bb93..986eb122 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/util/StringsTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/StringsTest.java
@@ -30,15 +30,15 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package com.mopub.mobileads.util;
+package com.mopub.common.util;
 
-import com.mopub.mobileads.test.support.SdkTestRunner;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 
-@RunWith(SdkTestRunner.class)
+@RunWith(RobolectricTestRunner.class)
 public class StringsTest {
     @Test
     public void isEmpty_shouldReturnValidResponse() throws Exception {
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/VersionCodeTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/VersionCodeTest.java
similarity index 87%
rename from mopub-sdk/src/test/java/com/mopub/mobileads/util/VersionCodeTest.java
rename to mopub-sdk/src/test/java/com/mopub/common/util/VersionCodeTest.java
index d3267d1d..a0c2ee1e 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/util/VersionCodeTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/VersionCodeTest.java
@@ -30,23 +30,23 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package com.mopub.mobileads.util;
+package com.mopub.common.util;
 
 import android.os.Build;
-import com.mopub.mobileads.test.support.SdkTestRunner;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
 
-import static com.mopub.mobileads.util.VersionCode.BASE;
-import static com.mopub.mobileads.util.VersionCode.CUR_DEVELOPMENT;
-import static com.mopub.mobileads.util.VersionCode.DONUT;
-import static com.mopub.mobileads.util.VersionCode.FROYO;
-import static com.mopub.mobileads.util.VersionCode.ICE_CREAM_SANDWICH;
-import static com.mopub.mobileads.util.VersionCode.JELLY_BEAN;
+import static com.mopub.common.util.VersionCode.BASE;
+import static com.mopub.common.util.VersionCode.CUR_DEVELOPMENT;
+import static com.mopub.common.util.VersionCode.DONUT;
+import static com.mopub.common.util.VersionCode.FROYO;
+import static com.mopub.common.util.VersionCode.ICE_CREAM_SANDWICH;
+import static com.mopub.common.util.VersionCode.JELLY_BEAN;
 import static org.fest.assertions.api.Assertions.assertThat;
 
-@RunWith(SdkTestRunner.class)
+@RunWith(RobolectricTestRunner.class)
 public class VersionCodeTest {
     @Test
     public void currentApiLevel_shouldReflectActualApiLevel() throws Exception {
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/ViewsTest.java b/mopub-sdk/src/test/java/com/mopub/common/util/ViewsTest.java
similarity index 96%
rename from mopub-sdk/src/test/java/com/mopub/mobileads/util/ViewsTest.java
rename to mopub-sdk/src/test/java/com/mopub/common/util/ViewsTest.java
index 1416f7fd..87053070 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/util/ViewsTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/ViewsTest.java
@@ -30,21 +30,22 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package com.mopub.mobileads.util;
+package com.mopub.common.util;
 
 import android.app.Activity;
 import android.content.Context;
 import android.view.View;
 import android.widget.RelativeLayout;
 import android.widget.TextView;
-import com.mopub.mobileads.test.support.SdkTestRunner;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
 
 import static org.fest.assertions.api.Assertions.assertThat;
 
-@RunWith(SdkTestRunner.class)
+@RunWith(RobolectricTestRunner.class)
 public class ViewsTest {
     private Context context;
     private View subject;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestDateAndTime.java b/mopub-sdk/src/test/java/com/mopub/common/util/test/support/TestDateAndTime.java
similarity index 96%
rename from mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestDateAndTime.java
rename to mopub-sdk/src/test/java/com/mopub/common/util/test/support/TestDateAndTime.java
index 796a828b..019568e6 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestDateAndTime.java
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/test/support/TestDateAndTime.java
@@ -30,9 +30,9 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package com.mopub.mobileads.test.support;
+package com.mopub.common.util.test.support;
 
-import com.mopub.mobileads.util.DateAndTime;
+import com.mopub.common.util.DateAndTime;
 
 import java.util.*;
 
diff --git a/mopub-sdk/src/test/java/com/mopub/common/util/test/support/TestMethodBuilderFactory.java b/mopub-sdk/src/test/java/com/mopub/common/util/test/support/TestMethodBuilderFactory.java
new file mode 100644
index 00000000..e928e301
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/common/util/test/support/TestMethodBuilderFactory.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2010-2013, MoPub Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *  Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in the
+ *   documentation and/or other materials provided with the distribution.
+ *
+ *  Neither the name of 'MoPub Inc.' nor the names of its contributors
+ *   may be used to endorse or promote products derived from this software
+ *   without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.mopub.common.util.test.support;
+
+import com.mopub.common.factories.MethodBuilderFactory;
+
+import static com.mopub.common.util.Reflection.MethodBuilder;
+import static org.mockito.Mockito.mock;
+
+public class TestMethodBuilderFactory extends MethodBuilderFactory {
+    private MethodBuilder mockMethodBuilder = mock(MethodBuilder.class);
+
+    public static MethodBuilder getSingletonMock() {
+        return getTestFactory().mockMethodBuilder;
+    }
+
+    private static TestMethodBuilderFactory getTestFactory() {
+        return ((TestMethodBuilderFactory) MethodBuilderFactory.instance);
+    }
+
+    @Override
+    public MethodBuilder internalCreate(Object object, String methodName) {
+        return mockMethodBuilder;
+    }
+}
+
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertReporterTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertReporterTest.java
index 9b31809a..e78a6989 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertReporterTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertReporterTest.java
@@ -40,7 +40,7 @@
 import android.view.View;
 import android.widget.TextView;
 import com.mopub.mobileads.test.support.SdkTestRunner;
-import com.mopub.mobileads.test.support.TestDateAndTime;
+import com.mopub.common.util.test.support.TestDateAndTime;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdConfigurationTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdConfigurationTest.java
index 1158f466..f150725f 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/AdConfigurationTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/AdConfigurationTest.java
@@ -3,8 +3,10 @@
 import android.app.Activity;
 import android.content.Context;
 import android.os.Build;
+
+import com.mopub.common.MoPub;
 import com.mopub.mobileads.test.support.SdkTestRunner;
-import com.mopub.mobileads.test.support.TestDateAndTime;
+import com.mopub.common.util.test.support.TestDateAndTime;
 import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
 import org.junit.Before;
 import org.junit.Test;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdFetcherTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdFetcherTest.java
index 281efdb9..f4380431 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/AdFetcherTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/AdFetcherTest.java
@@ -51,8 +51,8 @@
 import static com.mopub.mobileads.util.ResponseHeader.CUSTOM_EVENT_NAME;
 import static com.mopub.mobileads.util.ResponseHeader.FULL_AD_TYPE;
 import static com.mopub.mobileads.util.ResponseHeader.NATIVE_PARAMS;
-import static com.mopub.mobileads.util.VersionCode.HONEYCOMB_MR2;
-import static com.mopub.mobileads.util.VersionCode.ICE_CREAM_SANDWICH;
+import static com.mopub.common.util.VersionCode.HONEYCOMB_MR2;
+import static com.mopub.common.util.VersionCode.ICE_CREAM_SANDWICH;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyString;
 import static org.mockito.Matchers.eq;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdViewControllerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/AdViewControllerTest.java
index e6865365..c7244e63 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/AdViewControllerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/AdViewControllerTest.java
@@ -34,21 +34,30 @@
 
 import android.app.Activity;
 import android.content.Context;
+import android.location.Location;
 import android.net.ConnectivityManager;
 import android.os.Build;
 import android.view.Gravity;
 import android.view.View;
 import android.webkit.WebView;
 import android.widget.FrameLayout;
+
+import com.mopub.common.GpsHelper;
+import com.mopub.common.GpsHelperTest;
+import com.mopub.common.SharedPreferencesHelper;
+import com.mopub.common.util.test.support.TestMethodBuilderFactory;
+import com.mopub.common.MoPub;
 import com.mopub.mobileads.factories.HttpClientFactory;
 import com.mopub.mobileads.test.support.SdkTestRunner;
 import com.mopub.mobileads.test.support.TestAdFetcherFactory;
 import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
 import com.mopub.mobileads.test.support.ThreadUtils;
+
 import org.apache.http.HttpRequest;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.HttpClient;
 import org.apache.http.conn.ClientConnectionManager;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -59,11 +68,11 @@
 import java.lang.reflect.InvocationTargetException;
 
 import static android.Manifest.permission.ACCESS_NETWORK_STATE;
+import static com.mopub.common.util.Reflection.MethodBuilder;
 import static com.mopub.mobileads.AdViewController.DEFAULT_REFRESH_TIME_MILLISECONDS;
 import static com.mopub.mobileads.MoPubErrorCode.INTERNAL_ERROR;
 import static com.mopub.mobileads.MoPubErrorCode.NO_FILL;
 import static com.mopub.mobileads.test.support.ThreadUtils.NETWORK_DELAY;
-import static com.mopub.mobileads.util.Reflection.MethodBuilder;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.fest.assertions.api.Fail.fail;
 import static org.mockito.Matchers.any;
@@ -74,6 +83,7 @@
 import static org.mockito.Mockito.reset;
 import static org.mockito.Mockito.stub;
 import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
 import static org.robolectric.Robolectric.application;
 import static org.robolectric.Robolectric.shadowOf;
 
@@ -85,6 +95,7 @@
     private HttpClient httpClient;
     private AdFetcher adFetcher;
     private Activity context;
+    private MethodBuilder methodBuilder;
 
     @Before
     public void setup() {
@@ -96,6 +107,12 @@ public void setup() {
         subject = new AdViewController(context, moPubView);
         response = new TestHttpResponseWithHeaders(200, "I ain't got no-body");
         adFetcher = TestAdFetcherFactory.getSingletonMock();
+        methodBuilder = TestMethodBuilderFactory.getSingletonMock();
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        reset(methodBuilder);
     }
 
     @Test
@@ -282,6 +299,82 @@ public void loadAd_shouldScheduleRefreshIfNoNetworkConnectivity() throws Excepti
         assertThat(fakeHttpLayer.getLastSentHttpRequestInfo()).isNull();
     }
 
+    @Test
+    public void loadAd_whenGooglePlayServicesIsLinkedAndAdInfoIsNotCached_shouldCacheAdInfoBeforeFetchingAd() throws Exception {
+        SharedPreferencesHelper.getSharedPreferences(context).edit().clear().commit();
+        GpsHelperTest.verifyCleanSharedPreferences(context);
+
+        GpsHelper.setClassNamesForTesting();
+        GpsHelperTest.TestAdInfo adInfo = new GpsHelperTest.TestAdInfo();
+
+        when(methodBuilder.setStatic(any(Class.class))).thenReturn(methodBuilder);
+        when(methodBuilder.addParam(any(Class.class), any())).thenReturn(methodBuilder);
+        when(methodBuilder.execute()).thenReturn(
+                GpsHelper.GOOGLE_PLAY_SUCCESS_CODE,
+                adInfo,
+                adInfo.ADVERTISING_ID,
+                adInfo.LIMIT_AD_TRACKING_ENABLED
+        );
+
+        final AdViewController.AdViewControllerGpsHelperListener mockAdViewControllerGpsHelperListener
+                = mock(AdViewController.AdViewControllerGpsHelperListener.class);
+        subject.setGpsHelperListener(mockAdViewControllerGpsHelperListener);
+        subject.setAdUnitId("adUnitId");
+        subject.setLocation(new Location(""));
+        subject.loadAd();
+        Thread.sleep(500);
+
+        verify(mockAdViewControllerGpsHelperListener).onFetchAdInfoCompleted();
+        GpsHelperTest.verifySharedPreferences(context, adInfo);
+    }
+
+    @Test
+    public void loadAd_whenGooglePlayServicesIsNotLinked_shouldFetchAdFast() throws Exception {
+        SharedPreferencesHelper.getSharedPreferences(context).edit().clear().commit();
+        GpsHelperTest.verifyCleanSharedPreferences(context);
+
+        GpsHelper.setClassNamesForTesting();
+        when(methodBuilder.setStatic(any(Class.class))).thenReturn(methodBuilder);
+        when(methodBuilder.addParam(any(Class.class), any())).thenReturn(methodBuilder);
+        // return error code so it fails
+        when(methodBuilder.execute()).thenReturn(GpsHelper.GOOGLE_PLAY_SUCCESS_CODE + 1);
+
+        final AdViewController.AdViewControllerGpsHelperListener mockAdViewControllerGpsHelperListener
+                = mock(AdViewController.AdViewControllerGpsHelperListener.class);
+        subject.setGpsHelperListener(mockAdViewControllerGpsHelperListener);
+        subject.setAdUnitId("adUnitId");
+        subject.setLocation(new Location(""));
+        subject.loadAd();
+        // no need to sleep since it run the callback without an async task
+
+        verify(mockAdViewControllerGpsHelperListener).onFetchAdInfoCompleted();
+        GpsHelperTest.verifyCleanSharedPreferences(context);
+    }
+
+    @Test
+    public void loadAd_whenGooglePlayServicesIsLinkedAndAdInfoIsCached_shouldFetchAdFast() throws Exception {
+        GpsHelperTest.TestAdInfo adInfo = new GpsHelperTest.TestAdInfo();
+        GpsHelperTest.populateAndVerifySharedPreferences(context, adInfo);
+        GpsHelper.setClassNamesForTesting();
+
+        when(methodBuilder.setStatic(any(Class.class))).thenReturn(methodBuilder);
+        when(methodBuilder.addParam(any(Class.class), any())).thenReturn(methodBuilder);
+        when(methodBuilder.execute()).thenReturn(
+                GpsHelper.GOOGLE_PLAY_SUCCESS_CODE
+        );
+
+        final AdViewController.AdViewControllerGpsHelperListener mockAdViewControllerGpsHelperListener
+                = mock(AdViewController.AdViewControllerGpsHelperListener.class);
+        subject.setGpsHelperListener(mockAdViewControllerGpsHelperListener);
+        subject.setAdUnitId("adUnitId");
+        subject.setLocation(new Location(""));
+        subject.loadAd();
+        // no need to sleep since it run the callback without an async task
+
+        verify(mockAdViewControllerGpsHelperListener).onFetchAdInfoCompleted();
+        GpsHelperTest.verifySharedPreferences(context, adInfo);
+    }
+
     @Test
     public void loadNonJavascript_shouldFetchAd() throws Exception {
         String url = "http://www.guy.com";
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseHtmlWebViewTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseHtmlWebViewTest.java
index 691f6223..aeb012f8 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseHtmlWebViewTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseHtmlWebViewTest.java
@@ -45,8 +45,8 @@
 import org.robolectric.shadows.ShadowWebView;
 
 import static android.webkit.WebSettings.PluginState;
-import static com.mopub.mobileads.util.VersionCode.HONEYCOMB_MR2;
-import static com.mopub.mobileads.util.VersionCode.ICE_CREAM_SANDWICH;
+import static com.mopub.common.util.VersionCode.HONEYCOMB_MR2;
+import static com.mopub.common.util.VersionCode.ICE_CREAM_SANDWICH;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseInterstitialActivityTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseInterstitialActivityTest.java
index d973f79f..e88b5848 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseInterstitialActivityTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseInterstitialActivityTest.java
@@ -47,13 +47,13 @@
 import org.robolectric.Robolectric;
 import org.robolectric.shadows.ShadowLocalBroadcastManager;
 
+import static com.mopub.common.util.Drawables.INTERSTITIAL_CLOSE_BUTTON_NORMAL;
+import static com.mopub.common.util.Drawables.INTERSTITIAL_CLOSE_BUTTON_PRESSED;
 import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_DISMISS;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.ACTION_INTERSTITIAL_SHOW;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiver.getHtmlInterstitialIntentFilter;
 import static com.mopub.mobileads.EventForwardingBroadcastReceiverTest.getIntentForActionAndIdentifier;
-import static com.mopub.mobileads.resource.Drawables.INTERSTITIAL_CLOSE_BUTTON_NORMAL;
-import static com.mopub.mobileads.resource.Drawables.INTERSTITIAL_CLOSE_BUTTON_PRESSED;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseWebViewTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseWebViewTest.java
index e6f2844e..07124044 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/BaseWebViewTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/BaseWebViewTest.java
@@ -44,9 +44,9 @@
 import org.robolectric.Robolectric;
 import org.robolectric.shadows.ShadowWebView;
 
-import static com.mopub.mobileads.util.VersionCode.ECLAIR_MR1;
-import static com.mopub.mobileads.util.VersionCode.FROYO;
-import static com.mopub.mobileads.util.VersionCode.JELLY_BEAN_MR2;
+import static com.mopub.common.util.VersionCode.ECLAIR_MR1;
+import static com.mopub.common.util.VersionCode.FROYO;
+import static com.mopub.common.util.VersionCode.JELLY_BEAN_MR2;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/DiskLruCacheTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/DiskLruCacheTest.java
index dcc1b919..a7f1df7c 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/DiskLruCacheTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/DiskLruCacheTest.java
@@ -4,6 +4,7 @@
 import android.content.Context;
 import android.net.Uri;
 
+import com.mopub.common.util.Utils;
 import com.mopub.mobileads.test.support.SdkTestRunner;
 
 import org.junit.After;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/EventForwardingBroadcastReceiverTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/EventForwardingBroadcastReceiverTest.java
index 7f157fa2..cc8d91e4 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/EventForwardingBroadcastReceiverTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/EventForwardingBroadcastReceiverTest.java
@@ -36,8 +36,11 @@
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.support.v4.content.LocalBroadcastManager;
+
 import com.mopub.mobileads.factories.CustomEventInterstitialAdapterFactory;
 import com.mopub.mobileads.test.support.SdkTestRunner;
+
+import org.fest.util.Lists;
 import org.fest.util.Sets;
 import org.junit.Before;
 import org.junit.Ignore;
@@ -45,7 +48,9 @@
 import org.junit.runner.RunWith;
 import org.robolectric.shadows.ShadowLocalBroadcastManager;
 
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.Set;
 
 import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
 import static com.mopub.mobileads.CustomEventInterstitial.CustomEventInterstitialListener;
@@ -57,6 +62,7 @@
 import static com.mopub.mobileads.MoPubInterstitial.InterstitialAdListener;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlInterstitialWebViewTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlInterstitialWebViewTest.java
index aa5ed122..3a2ee83c 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlInterstitialWebViewTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlInterstitialWebViewTest.java
@@ -47,8 +47,8 @@
 import static com.mopub.mobileads.HtmlInterstitialWebView.HtmlInterstitialWebViewListener;
 import static com.mopub.mobileads.HtmlInterstitialWebView.MOPUB_JS_INTERFACE_NAME;
 import static com.mopub.mobileads.MoPubErrorCode.NETWORK_INVALID_STATE;
-import static com.mopub.mobileads.util.VersionCode.GINGERBREAD_MR1;
-import static com.mopub.mobileads.util.VersionCode.HONEYCOMB;
+import static com.mopub.common.util.VersionCode.GINGERBREAD_MR1;
+import static com.mopub.common.util.VersionCode.HONEYCOMB;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlWebViewClientTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlWebViewClientTest.java
index edbe518a..68a85d2a 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlWebViewClientTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/HtmlWebViewClientTest.java
@@ -39,6 +39,8 @@
 import android.content.pm.ResolveInfo;
 import android.net.Uri;
 import android.webkit.WebView;
+
+import com.mopub.common.MoPubBrowser;
 import com.mopub.mobileads.test.support.SdkTestRunner;
 import org.junit.Before;
 import org.junit.Test;
@@ -47,7 +49,6 @@
 import org.robolectric.Robolectric;
 
 import static com.mopub.mobileads.MoPubErrorCode.UNSPECIFIED;
-import static com.mopub.mobileads.MraidBrowser.URL_EXTRA;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.doThrow;
@@ -190,7 +191,7 @@ public void shouldOverrideUrlLoading_withCustomApplicationIntent_withoutUserClic
     }
 
     @Test
-    public void shouldOverrideUrlLoading_withCustomApplicationIntent_withUserClick_butCanNotHandleCustomIntent_shouldDefaultToMraidBrowser() throws Exception {
+    public void shouldOverrideUrlLoading_withCustomApplicationIntent_withUserClick_butCanNotHandleCustomIntent_shouldDefaultToMoPubBrowser() throws Exception {
         String customUrl = "myintent://something";
         stub(htmlWebView.wasClicked()).toReturn(true);
         subject = new HtmlWebViewClient(htmlWebViewListener, htmlWebView, null, null);
@@ -201,7 +202,7 @@ public void shouldOverrideUrlLoading_withCustomApplicationIntent_withUserClick_b
         verify(htmlWebViewListener).onClicked();
         Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(startedIntent).isNotNull();
-        assertThat(startedIntent.getComponent().getClassName()).isEqualTo("com.mopub.mobileads.MraidBrowser");
+        assertThat(startedIntent.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
     }
 
     @Test
@@ -215,8 +216,8 @@ public void shouldOverrideUrlLoading_withHttpUrl_withUserClick_shouldOpenBrowser
         verify(htmlWebViewListener).onClicked();
 
         Intent startedActivity = assertActivityStarted();
-        assertThat(startedActivity.getComponent().getClassName()).isEqualTo("com.mopub.mobileads.MraidBrowser");
-        assertThat(startedActivity.getStringExtra(URL_EXTRA)).isEqualTo(validUrl);
+        assertThat(startedActivity.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
+        assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(validUrl);
         assertThat(startedActivity.getData()).isNull();
     }
 
@@ -241,7 +242,7 @@ public void shouldOverrideUrlLoading_withClickTrackingRedirect_withUserClick_sho
         subject.shouldOverrideUrlLoading(htmlWebView, validUrl);
 
         Intent startedActivity = assertActivityStarted();
-        assertThat(startedActivity.getStringExtra(URL_EXTRA)).isEqualTo("clickthrough&r=http%3A%2F%2Fwww.mopub.com");
+        assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo("clickthrough&r=http%3A%2F%2Fwww.mopub.com");
     }
 
     @Test
@@ -262,8 +263,8 @@ public void shouldOverrideUrlLoading_withEmptyUrl_withUserClick_shouldLoadAboutB
         subject.shouldOverrideUrlLoading(htmlWebView, "");
 
         Intent startedActivity = assertActivityStarted();
-        assertThat(startedActivity.getComponent().getClassName()).isEqualTo("com.mopub.mobileads.MraidBrowser");
-        assertThat(startedActivity.getStringExtra(URL_EXTRA)).isEqualTo("about:blank");
+        assertThat(startedActivity.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
+        assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo("about:blank");
         assertThat(startedActivity.getData()).isNull();
     }
 
@@ -310,8 +311,8 @@ public void shouldOverrideUrlLoading_withNativeBrowserScheme_butOpaqueUri_withUs
         subject.shouldOverrideUrlLoading(htmlWebView, opaqueNativeBrowserUriString);
 
         Intent startedActivity = assertActivityStarted();
-        assertThat(startedActivity.getComponent().getClassName()).isEqualTo("com.mopub.mobileads.MraidBrowser");
-        assertThat(startedActivity.getStringExtra(URL_EXTRA)).isEqualTo(opaqueNativeBrowserUriString);
+        assertThat(startedActivity.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
+        assertThat(startedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(opaqueNativeBrowserUriString);
         assertThat(startedActivity.getData()).isNull();
         verify(htmlWebViewListener).onClicked();
     }
@@ -364,9 +365,9 @@ public void onPageStarted_whenLoadedUrlStartsWithRedirect_withUserClick_shouldOp
         verify(view).stopLoading();
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(intent.getStringExtra(MraidBrowser.URL_EXTRA)).isEqualTo(url);
+        assertThat(intent.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(url);
         assertThat(intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
-        assertThat(intent.getComponent().getClassName()).isEqualTo("com.mopub.mobileads.MraidBrowser");
+        assertThat(intent.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
     }
 
     @Test
@@ -393,9 +394,9 @@ public void onPageStarted_whenLoadedUrlStartsWithRedirectAndHasClickthrough_with
         verify(view).stopLoading();
 
         Intent intent = Robolectric.getShadowApplication().getNextStartedActivity();
-        assertThat(intent.getStringExtra(MraidBrowser.URL_EXTRA)).isEqualTo(expectedTrackingUrl);
+        assertThat(intent.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(expectedTrackingUrl);
         assertThat(intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
-        assertThat(intent.getComponent().getClassName()).isEqualTo("com.mopub.mobileads.MraidBrowser");
+        assertThat(intent.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
     }
 
     @Test
@@ -411,7 +412,7 @@ public void onPageStarted_whenLoadedUrlStartsWithRedirectAndHasClickthrough_with
     }
 
     @Test
-    public void onPageStarted_whenLoadedUrlStartsWithRedirectAndHasClickthrough_withUserClick_whenMraidBrowserCannotHandleIntent_shouldOpenInNativeBrowser() throws Exception {
+    public void onPageStarted_whenLoadedUrlStartsWithRedirectAndHasClickthrough_withUserClick_whenMoPubBrowserCannotHandleIntent_shouldOpenInNativeBrowser() throws Exception {
         Context mockContext = mock(Context.class);
         stub(htmlWebView.wasClicked()).toReturn(true);
         stub(htmlWebView.getContext()).toReturn(mockContext);
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubActivityTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubActivityTest.java
index 83c02188..e10fd2a9 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubActivityTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubActivityTest.java
@@ -49,6 +49,7 @@
 import org.robolectric.shadows.ShadowLocalBroadcastManager;
 
 import static android.widget.RelativeLayout.LayoutParams;
+import static com.mopub.mobileads.AdFetcher.AD_CONFIGURATION_KEY;
 import static com.mopub.mobileads.AdFetcher.CLICKTHROUGH_URL_KEY;
 import static com.mopub.mobileads.AdFetcher.HTML_RESPONSE_BODY_KEY;
 import static com.mopub.mobileads.AdFetcher.REDIRECT_URL_KEY;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidBrowserControllerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubBrowserControllerTest.java
similarity index 90%
rename from mopub-sdk/src/test/java/com/mopub/mobileads/MraidBrowserControllerTest.java
rename to mopub-sdk/src/test/java/com/mopub/mobileads/MoPubBrowserControllerTest.java
index 641f640d..dd3cce49 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidBrowserControllerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubBrowserControllerTest.java
@@ -37,6 +37,8 @@
 import android.content.Intent;
 import android.content.pm.ResolveInfo;
 import android.net.Uri;
+
+import com.mopub.common.MoPubBrowser;
 import com.mopub.mobileads.test.support.SdkTestRunner;
 import org.junit.Before;
 import org.junit.Test;
@@ -49,8 +51,8 @@
 import static org.mockito.Mockito.verify;
 
 @RunWith(SdkTestRunner.class)
-public class MraidBrowserControllerTest {
-    private MraidBrowserController subject;
+public class MoPubBrowserControllerTest {
+    private MoPubBrowserController subject;
     private MraidView mraidView;
     private Context context;
     private MraidView.MraidListener mraidListener;
@@ -62,7 +64,7 @@ public void setUp() throws Exception {
         mraidListener = mock(MraidView.MraidListener.class);
         mraidView.setMraidListener(mraidListener);
 
-        subject = new MraidBrowserController(mraidView);
+        subject = new MoPubBrowserController(mraidView);
     }
 
     @Test
@@ -79,7 +81,7 @@ public void open_withApplicationUrl_shouldStartNewIntent() throws Exception {
     }
 
     @Test
-    public void open_withHttpApplicationUrl_shouldStartMraidBrowser() throws Exception {
+    public void open_withHttpApplicationUrl_shouldStartMoPubBrowser() throws Exception {
         String applicationUrl = "http://blah";
 
         subject.open(applicationUrl);
@@ -87,11 +89,11 @@ public void open_withHttpApplicationUrl_shouldStartMraidBrowser() throws Excepti
         Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(startedIntent).isNotNull();
         assertThat(startedIntent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
-        assertThat(startedIntent.getComponent().getClassName()).isEqualTo("com.mopub.mobileads.MraidBrowser");
+        assertThat(startedIntent.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
     }
 
     @Test
-    public void open_withApplicationUrlThatCantBeHandled_shouldDefaultToMraidBrowser() throws Exception {
+    public void open_withApplicationUrlThatCantBeHandled_shouldDefaultToMoPubBrowser() throws Exception {
         String applicationUrl = "canthandleme://blah";
 
         subject.open(applicationUrl);
@@ -99,8 +101,8 @@ public void open_withApplicationUrlThatCantBeHandled_shouldDefaultToMraidBrowser
         Intent startedIntent = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(startedIntent).isNotNull();
         assertThat(startedIntent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK).isNotEqualTo(0);
-        assertThat(startedIntent.getComponent().getClassName()).isEqualTo("com.mopub.mobileads.MraidBrowser");
-        assertThat(startedIntent.getStringExtra("extra_url")).isEqualTo(applicationUrl);
+        assertThat(startedIntent.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
+        assertThat(startedIntent.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo(applicationUrl);
     }
 
     @Test
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubConversionTrackerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubConversionTrackerTest.java
index 23347e6e..7ff77b61 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubConversionTrackerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubConversionTrackerTest.java
@@ -33,8 +33,17 @@
 package com.mopub.mobileads;
 
 import android.app.Activity;
+import android.provider.Settings;
+
+import com.mopub.common.GpsHelper;
+import com.mopub.common.GpsHelperTest;
+import com.mopub.common.util.Reflection.MethodBuilder;
+import com.mopub.common.util.Utils;
+import com.mopub.common.util.test.support.TestMethodBuilderFactory;
 import com.mopub.mobileads.test.support.SdkTestRunner;
+
 import org.apache.http.HttpRequest;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -43,18 +52,34 @@
 import org.robolectric.tester.org.apache.http.HttpRequestInfo;
 
 import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.when;
+import static org.robolectric.Robolectric.application;
 
 @RunWith(SdkTestRunner.class)
 public class MoPubConversionTrackerTest {
     private MoPubConversionTracker subject;
     private Activity context;
     private FakeHttpLayer fakeHttpLayer;
+    private MethodBuilder methodBuilder;
+    private String expectedUdid;
+    private boolean dnt = false;
+    private static final String TEST_UDID = "20b013c721c";
 
     @Before
     public void setUp() throws Exception {
         subject = new MoPubConversionTracker();
         context = new Activity();
         fakeHttpLayer = Robolectric.getFakeHttpLayer();
+        methodBuilder = TestMethodBuilderFactory.getSingletonMock();
+        Settings.Secure.putString(application.getContentResolver(), Settings.Secure.ANDROID_ID, TEST_UDID);
+        expectedUdid = "sha%3A" + Utils.sha1(TEST_UDID);
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        reset(methodBuilder);
     }
 
     @Test
@@ -90,12 +115,42 @@ public void reportAppOpen_onEmptyResponse_shouldMakeSecondRequest() throws Excep
         assertThat(requestWasMade()).isTrue();
     }
 
+    @Test
+    public void reportAppOpen_whenGooglePlayServicesIsLinkedAndAdInfoIsNotCached_shouldUseAdInfoParams() throws Exception {
+        GpsHelper.setClassNamesForTesting();
+        GpsHelperTest.verifyCleanSharedPreferences(context);
+        GpsHelperTest.TestAdInfo adInfo = new GpsHelperTest.TestAdInfo();
+
+        when(methodBuilder.setStatic(any(Class.class))).thenReturn(methodBuilder);
+        when(methodBuilder.addParam(any(Class.class), any())).thenReturn(methodBuilder);
+        when(methodBuilder.execute()).thenReturn(
+                adInfo,
+                adInfo.ADVERTISING_ID,
+                adInfo.LIMIT_AD_TRACKING_ENABLED,
+                GpsHelper.GOOGLE_PLAY_SUCCESS_CODE
+        );
+
+        expectedUdid = "ifa%3A" + adInfo.ADVERTISING_ID;
+        dnt = true;
+
+        fakeHttpLayer.addPendingHttpResponse(200, "doesn't matter what this is as long as it's not nothing");
+        subject.reportAppOpen(context);
+        Thread.sleep(500); // extra sleep since there are 2 async tasks
+        assertThat(requestWasMade()).isTrue();
+    }
+
     private boolean requestWasMade() throws Exception {
-        String expectedUrl = new StringBuilder("http://ads.mopub.com/m/open")
+        StringBuilder stringBuilder = new StringBuilder("http://ads.mopub.com/m/open")
                 .append("?v=6")
                 .append("&id=").append("com.mopub.mobileads")
-                .append("&udid=sha%3A").append("")
-                .append("&av=").append("1.0")
+                .append("&udid=").append(expectedUdid);
+
+        if (dnt) {
+            stringBuilder.append("&dnt=1");
+        }
+
+        String expectedUrl = stringBuilder.append("&av=")
+                .append("1.0")
                 .toString();
 
         Thread.sleep(500);
@@ -105,6 +160,8 @@ private boolean requestWasMade() throws Exception {
         }
         HttpRequest request = lastSentHttpRequestInfo.getHttpRequest();
         fakeHttpLayer.clearRequestInfos();
-        return request.getRequestLine().getUri().equals(expectedUrl);
+        String actualUrl = request.getRequestLine().getUri();
+        return actualUrl.equals(expectedUrl);
     }
 }
+
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubInterstitialTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubInterstitialTest.java
index 7c1bc37f..64138d8c 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubInterstitialTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MoPubInterstitialTest.java
@@ -33,6 +33,8 @@
 package com.mopub.mobileads;
 
 import android.app.Activity;
+
+import com.mopub.common.LocationService;
 import com.mopub.mobileads.test.support.TestAdViewControllerFactory;
 import com.mopub.mobileads.test.support.TestCustomEventInterstitialAdapterFactory;
 import org.junit.Before;
@@ -42,11 +44,11 @@
 import java.math.BigDecimal;
 import java.util.*;
 
+import static com.mopub.common.LocationService.*;
 import static com.mopub.mobileads.MoPubErrorCode.ADAPTER_NOT_FOUND;
 import static com.mopub.mobileads.MoPubErrorCode.CANCELLED;
 import static com.mopub.mobileads.MoPubErrorCode.INTERNAL_ERROR;
 import static com.mopub.mobileads.MoPubErrorCode.UNSPECIFIED;
-import static com.mopub.mobileads.MoPubView.LocationAwareness.LOCATION_AWARENESS_NORMAL;
 import static com.mopub.mobileads.util.ResponseHeader.CUSTOM_EVENT_DATA;
 import static com.mopub.mobileads.util.ResponseHeader.CUSTOM_EVENT_HTML_DATA;
 import static com.mopub.mobileads.util.ResponseHeader.CUSTOM_EVENT_NAME;
@@ -127,8 +129,8 @@ public void getInterstitialAdListenerTest() throws Exception {
     @Test
     public void setLocationAwarenessTest() throws Exception {
         subject.setInterstitialView(interstitialView);
-        subject.setLocationAwareness(LOCATION_AWARENESS_NORMAL);
-        verify(interstitialView).setLocationAwareness(eq(LOCATION_AWARENESS_NORMAL));
+        subject.setLocationAwareness(LocationAwareness.NORMAL);
+        verify(interstitialView).setLocationAwareness(eq(LocationAwareness.NORMAL));
     }
 
     @Test
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidDisplayControllerTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidDisplayControllerTest.java
index 453f51be..601e02ca 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/MraidDisplayControllerTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/MraidDisplayControllerTest.java
@@ -80,9 +80,9 @@
 import static com.mopub.mobileads.MraidCommandStorePicture.MIME_TYPE_HEADER;
 import static com.mopub.mobileads.MraidVideoPlayerActivityTest.assertMraidVideoPlayerActivityStarted;
 import static com.mopub.mobileads.util.Mraids.ANDROID_CALENDAR_CONTENT_TYPE;
-import static com.mopub.mobileads.util.VersionCode.ECLAIR;
-import static com.mopub.mobileads.util.VersionCode.FROYO;
-import static com.mopub.mobileads.util.VersionCode.ICE_CREAM_SANDWICH;
+import static com.mopub.common.util.VersionCode.ECLAIR;
+import static com.mopub.common.util.VersionCode.FROYO;
+import static com.mopub.common.util.VersionCode.ICE_CREAM_SANDWICH;
 import static java.io.File.*;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.any;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoDownloadTaskTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoDownloadTaskTest.java
index 1ad2e61f..436ab6f7 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoDownloadTaskTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoDownloadTaskTest.java
@@ -2,10 +2,13 @@
 
 import android.app.Activity;
 import android.net.Uri;
+
+import com.mopub.common.util.Streams;
+import com.mopub.common.util.Utils;
 import com.mopub.mobileads.test.support.SdkTestRunner;
 import com.mopub.mobileads.test.support.StreamUtils;
 import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
-import com.mopub.mobileads.util.Streams;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Ignore;
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewTest.java
index b7a20424..b0e39e2e 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewTest.java
@@ -37,6 +37,8 @@
 import android.content.Intent;
 import android.media.MediaPlayer;
 import android.view.View;
+
+import com.mopub.common.MoPubBrowser;
 import com.mopub.mobileads.test.support.GestureUtils;
 import com.mopub.mobileads.test.support.SdkTestRunner;
 import com.mopub.mobileads.test.support.TestHttpResponseWithHeaders;
@@ -190,7 +192,7 @@ public void onTouch_withTouchUp_whenVideoLessThan16Seconds_andClickBeforeEnd_sho
     }
 
     @Test
-    public void onTouch_withTouchUp_whenVideoLessThan16Seconds_andClickAfterEnd_shouldStartMraidBrowser() throws Exception {
+    public void onTouch_withTouchUp_whenVideoLessThan16Seconds_andClickAfterEnd_shouldStartMoPubBrowser() throws Exception {
         Intent intent = createIntentForVastVideo();
         addExtrasToStub(intent, VIDEO_CLICK_THROUGH_URL, "http://clickThroughUrl");
 
@@ -207,8 +209,8 @@ public void onTouch_withTouchUp_whenVideoLessThan16Seconds_andClickAfterEnd_shou
 
         Intent nextStartedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(nextStartedActivity).isNotNull();
-        assertThat(nextStartedActivity.getStringExtra(MraidBrowser.URL_EXTRA)).isEqualTo("http://clickThroughUrl");
-        assertThat(nextStartedActivity.getComponent().getClassName()).isEqualTo("com.mopub.mobileads.MraidBrowser");
+        assertThat(nextStartedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo("http://clickThroughUrl");
+        assertThat(nextStartedActivity.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
     }
 
     @Test
@@ -232,7 +234,7 @@ public void onTouch_withTouchUp_whenVideoLongerThan16Seconds_andClickBefore5Seco
     }
 
     @Test
-    public void onTouch_withTouchUp_whenVideoLongerThan16Seconds_andClickAfter5Seconds_shouldStartMraidBrowser() throws Exception {
+    public void onTouch_withTouchUp_whenVideoLongerThan16Seconds_andClickAfter5Seconds_shouldStartMoPubBrowser() throws Exception {
         Intent intent = createIntentForVastVideo();
         addExtrasToStub(intent, VIDEO_CLICK_THROUGH_URL, "http://clickThroughUrl");
 
@@ -249,8 +251,8 @@ public void onTouch_withTouchUp_whenVideoLongerThan16Seconds_andClickAfter5Secon
 
         Intent nextStartedActivity = Robolectric.getShadowApplication().getNextStartedActivity();
         assertThat(nextStartedActivity).isNotNull();
-        assertThat(nextStartedActivity.getStringExtra(MraidBrowser.URL_EXTRA)).isEqualTo("http://clickThroughUrl");
-        assertThat(nextStartedActivity.getComponent().getClassName()).isEqualTo("com.mopub.mobileads.MraidBrowser");
+        assertThat(nextStartedActivity.getStringExtra(MoPubBrowser.DESTINATION_URL_KEY)).isEqualTo("http://clickThroughUrl");
+        assertThat(nextStartedActivity.getComponent().getClassName()).isEqualTo("com.mopub.common.MoPubBrowser");
     }
 
     @Test
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/AdUrlGeneratorTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/WebViewUrlGeneratorTest.java
similarity index 82%
rename from mopub-sdk/src/test/java/com/mopub/mobileads/AdUrlGeneratorTest.java
rename to mopub-sdk/src/test/java/com/mopub/mobileads/WebViewUrlGeneratorTest.java
index 1ffd952c..76f79c4d 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/AdUrlGeneratorTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/WebViewUrlGeneratorTest.java
@@ -41,6 +41,15 @@
 import android.os.Build;
 import android.provider.Settings;
 import android.telephony.TelephonyManager;
+
+import com.mopub.common.AdUrlGenerator;
+import com.mopub.common.GpsHelper;
+import com.mopub.common.GpsHelperTest;
+import com.mopub.common.SharedPreferencesHelper;
+import com.mopub.common.util.Reflection.MethodBuilder;
+import com.mopub.common.MoPub;
+import com.mopub.common.util.Utils;
+import com.mopub.common.util.test.support.TestMethodBuilderFactory;
 import com.mopub.mobileads.test.support.SdkTestRunner;
 
 import org.junit.After;
@@ -62,45 +71,51 @@
 import static android.net.ConnectivityManager.TYPE_MOBILE_SUPL;
 import static android.net.ConnectivityManager.TYPE_WIFI;
 import static android.telephony.TelephonyManager.NETWORK_TYPE_UNKNOWN;
-import static com.mopub.mobileads.AdUrlGenerator.MoPubNetworkType;
-import static com.mopub.mobileads.AdUrlGenerator.TwitterAppInstalledStatus;
-import static com.mopub.mobileads.util.Strings.isEmpty;
+import static com.mopub.common.AdUrlGenerator.MoPubNetworkType;
+import static com.mopub.common.util.Strings.isEmpty;
+import static com.mopub.mobileads.WebViewAdUrlGenerator.TwitterAppInstalledStatus;
 import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.when;
 import static org.robolectric.Robolectric.application;
 import static org.robolectric.Robolectric.shadowOf;
-import static org.mockito.Mockito.doReturn;
 
 @RunWith(SdkTestRunner.class)
-public class AdUrlGeneratorTest {
+public class WebViewUrlGeneratorTest {
 
-    private AdUrlGenerator subject;
+    private WebViewAdUrlGenerator subject;
     private static final String TEST_UDID = "20b013c721c";
-    private String expectedUdidSha;
+    private String expectedUdid;
     private Configuration configuration;
     private ShadowTelephonyManager shadowTelephonyManager;
     private ShadowConnectivityManager shadowConnectivityManager;
     private Activity context;
+    private MethodBuilder methodBuilder;
 
     @Before
     public void setup() {
         context = new Activity();
         shadowOf(context).grantPermissions(ACCESS_NETWORK_STATE);
-        subject = new AdUrlGenerator(context);
+        subject = new WebViewAdUrlGenerator(context);
         Settings.Secure.putString(application.getContentResolver(), Settings.Secure.ANDROID_ID, TEST_UDID);
-        expectedUdidSha = Utils.sha1(TEST_UDID);
+        expectedUdid = "sha%3A" + Utils.sha1(TEST_UDID);
         configuration = application.getResources().getConfiguration();
         shadowTelephonyManager = shadowOf((TelephonyManager) application.getSystemService(Context.TELEPHONY_SERVICE));
         shadowConnectivityManager = shadowOf((ConnectivityManager) application.getSystemService(Context.CONNECTIVITY_SERVICE));
+        methodBuilder = TestMethodBuilderFactory.getSingletonMock();
     }
 
     @After
     public void tearDown() throws Exception {
         AdUrlGenerator.setTwitterAppInstalledStatus(TwitterAppInstalledStatus.UNKNOWN);
+        reset(methodBuilder);
     }
 
     @Test
     public void generateAdUrl_shouldIncludeMinimumFields() throws Exception {
-        String expectedAdUrl = new AdUrlBuilder(expectedUdidSha).build();
+        String expectedAdUrl = new AdUrlBuilder(expectedUdid).build();
 
         String adUrl = generateMinimumUrlString();
 
@@ -109,7 +124,7 @@ public void generateAdUrl_shouldIncludeMinimumFields() throws Exception {
 
     @Test
     public void generateAdUrl_shouldRunMultipleTimes() throws Exception {
-        String expectedAdUrl = new AdUrlBuilder(expectedUdidSha).build();
+        String expectedAdUrl = new AdUrlBuilder(expectedUdid).build();
 
         String adUrl = generateMinimumUrlString();
         assertThat(adUrl).isEqualTo(expectedAdUrl);
@@ -119,7 +134,7 @@ public void generateAdUrl_shouldRunMultipleTimes() throws Exception {
 
     @Test
     public void generateAdUrl_shouldIncludeAllFields() throws Exception {
-        final String expectedAdUrl = new AdUrlBuilder(expectedUdidSha)
+        final String expectedAdUrl = new AdUrlBuilder(expectedUdid)
                 .withAdUnitId("adUnitId")
                 .withQuery("key%3Avalue")
                 .withLatLon("20.1%2C30.0", "1")
@@ -160,7 +175,7 @@ public void generateAdUrl_shouldRecognizeOrientation() throws Exception {
 
     @Test
     public void generateAdUrl_shouldHandleFunkyNetworkOperatorCodes() throws Exception {
-        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdidSha);
+        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
 
         shadowTelephonyManager.setNetworkOperator("123456");
         String adUrl = generateMinimumUrlString();
@@ -185,7 +200,7 @@ public void generateAdUrl_shouldHandleFunkyNetworkOperatorCodes() throws Excepti
 
     @Test
     public void generateAdurl_whenOnCDMA_shouldGetOwnerStringFromSimCard() throws Exception {
-        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdidSha);
+        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
         shadowTelephonyManager.setPhoneType(TelephonyManager.PHONE_TYPE_CDMA);
         shadowTelephonyManager.setSimState(TelephonyManager.SIM_STATE_READY);
         shadowTelephonyManager.setNetworkOperator("123456");
@@ -196,7 +211,7 @@ public void generateAdurl_whenOnCDMA_shouldGetOwnerStringFromSimCard() throws Ex
 
     @Test
     public void generateAdurl_whenSimNotReady_shouldDefaultToNetworkOperator() throws Exception {
-        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdidSha);
+        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
         shadowTelephonyManager.setPhoneType(TelephonyManager.PHONE_TYPE_CDMA);
         shadowTelephonyManager.setSimState(TelephonyManager.SIM_STATE_ABSENT);
         shadowTelephonyManager.setNetworkOperator("123456");
@@ -207,7 +222,7 @@ public void generateAdurl_whenSimNotReady_shouldDefaultToNetworkOperator() throw
 
     @Test
     public void generateAdUrl_shouldSetNetworkType() throws Exception {
-        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdidSha);
+        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
         String adUrl;
 
         shadowConnectivityManager.setActiveNetworkInfo(createNetworkInfo(TYPE_DUMMY));
@@ -246,7 +261,7 @@ public void generateAdUrl_shouldSetNetworkType() throws Exception {
 
     @Test
     public void generateAdUrl_whenNoNetworkPermission_shouldGenerateUnknownNetworkType() throws Exception {
-        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdidSha);
+        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
 
         shadowOf(context).denyPermissions(ACCESS_NETWORK_STATE);
         shadowConnectivityManager.setActiveNetworkInfo(createNetworkInfo(TYPE_MOBILE));
@@ -258,9 +273,9 @@ public void generateAdUrl_whenNoNetworkPermission_shouldGenerateUnknownNetworkTy
 
     @Test
     public void generateAdUrl_whenTwitterIsNotInstalled_shouldProcessAndNotSetTwitterInstallStatusOnFirstRequest() throws Exception {
-        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdidSha);
+        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
 
-        AdUrlGenerator spySubject = Mockito.spy(subject);
+        WebViewAdUrlGenerator spySubject = Mockito.spy(subject);
         AdUrlGenerator.setTwitterAppInstalledStatus(TwitterAppInstalledStatus.UNKNOWN);
         doReturn(TwitterAppInstalledStatus.NOT_INSTALLED).when(spySubject).getTwitterAppInstallStatus();
 
@@ -271,9 +286,9 @@ public void generateAdUrl_whenTwitterIsNotInstalled_shouldProcessAndNotSetTwitte
 
     @Test
     public void generateAdUrl_whenTwitterIsInstalled_shouldProcessAndSetTwitterInstallStatusOnFirstRequest() throws Exception {
-        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdidSha);
+        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
 
-        AdUrlGenerator spySubject = Mockito.spy(subject);
+        WebViewAdUrlGenerator spySubject = Mockito.spy(subject);
         AdUrlGenerator.setTwitterAppInstalledStatus(TwitterAppInstalledStatus.UNKNOWN);
         doReturn(TwitterAppInstalledStatus.INSTALLED).when(spySubject).getTwitterAppInstallStatus();
 
@@ -284,9 +299,9 @@ public void generateAdUrl_whenTwitterIsInstalled_shouldProcessAndSetTwitterInsta
 
     @Test
     public void generateAdUrl_shouldNotProcessTwitterInstallStatusIfStatusIsAlreadySet() throws Exception {
-        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdidSha);
+        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
 
-        AdUrlGenerator spySubject = Mockito.spy(subject);
+        WebViewAdUrlGenerator spySubject = Mockito.spy(subject);
         AdUrlGenerator.setTwitterAppInstalledStatus(TwitterAppInstalledStatus.NOT_INSTALLED);
         doReturn(TwitterAppInstalledStatus.INSTALLED).when(spySubject).getTwitterAppInstallStatus();
 
@@ -297,7 +312,7 @@ public void generateAdUrl_shouldNotProcessTwitterInstallStatusIfStatusIsAlreadyS
 
     @Test
     public void generateAdUrl_shouldTolerateNullActiveNetwork() throws Exception {
-        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdidSha);
+        AdUrlBuilder urlBuilder = new AdUrlBuilder(expectedUdid);
         shadowConnectivityManager.setActiveNetworkInfo(null);
 
         String adUrl = generateMinimumUrlString();
@@ -305,6 +320,27 @@ public void generateAdUrl_shouldTolerateNullActiveNetwork() throws Exception {
         assertThat(adUrl).isEqualTo(urlBuilder.withNetworkType(MoPubNetworkType.UNKNOWN).build());
     }
 
+    @Test
+    public void generateAdUrl_whenGooglePlayServicesIsLinkedAndAdInfoIsCached_shouldUseAdInfoParams() throws Exception {
+        GpsHelper.setClassNamesForTesting();
+        when(methodBuilder.setStatic(any(Class.class))).thenReturn(methodBuilder);
+        when(methodBuilder.addParam(any(Class.class), any())).thenReturn(methodBuilder);
+        when(methodBuilder.execute()).thenReturn(GpsHelper.GOOGLE_PLAY_SUCCESS_CODE);
+
+        GpsHelperTest.TestAdInfo adInfo = new GpsHelperTest.TestAdInfo();
+        SharedPreferencesHelper.getSharedPreferences(context)
+                .edit()
+                .putString(GpsHelper.ADVERTISING_ID_KEY, adInfo.ADVERTISING_ID)
+                .putBoolean(GpsHelper.IS_LIMIT_AD_TRACKING_ENABLED_KEY, adInfo.LIMIT_AD_TRACKING_ENABLED)
+                .commit();
+
+        expectedUdid = "ifa%3A" + adInfo.ADVERTISING_ID;
+        String expectedAdUrl = new AdUrlBuilder(expectedUdid)
+                .withDnt(adInfo.LIMIT_AD_TRACKING_ENABLED)
+                .build();
+        assertThat(generateMinimumUrlString()).isEqualTo(expectedAdUrl);
+    }
+
     private NetworkInfo createNetworkInfo(int type) {
         return ShadowNetworkInfo.newInstance(null,
                 type,
@@ -316,7 +352,7 @@ private String generateMinimumUrlString() {
     }
 
     private static class AdUrlBuilder {
-        private String expectedUdidSha;
+        private String expectedUdid;
         private String adUnitId = "";
         private String query = "";
         private String latLon = "";
@@ -325,12 +361,13 @@ private String generateMinimumUrlString() {
         private String mcc = "";
         private String countryIso = "";
         private String carrierName = "";
+        private String dnt = "";
         private MoPubNetworkType networkType = MoPubNetworkType.MOBILE;
-        private int externalStoragePermission;
         private TwitterAppInstalledStatus twitterAppInstalledStatus = TwitterAppInstalledStatus.UNKNOWN;
+        private int externalStoragePermission;
 
-        public AdUrlBuilder(String expectedUdidSha) {
-            this.expectedUdidSha = expectedUdidSha;
+        public AdUrlBuilder(String expectedUdid) {
+            this.expectedUdid = expectedUdid;
         }
 
         public String build() {
@@ -341,7 +378,8 @@ public String build() {
                     "&dn=" + Build.MANUFACTURER +
                     "%2C" + Build.MODEL +
                     "%2C" + Build.PRODUCT +
-                    "&udid=sha%3A" + expectedUdidSha +
+                    "&udid=" + expectedUdid +
+                    paramIfNotEmpty("dnt", dnt) +
                     paramIfNotEmpty("q", query) +
                     (isEmpty(latLon) ? "" : "&ll=" + latLon + "&lla=" + locationAccuracy) +
                     "&z=-0700" +
@@ -410,6 +448,13 @@ public AdUrlBuilder withTwitterAppInstalledStatus(TwitterAppInstalledStatus stat
             return this;
         }
 
+        public AdUrlBuilder withDnt(boolean dnt) {
+            if (dnt) {
+                this.dnt = "1";
+            }
+            return this;
+        }
+
         private String paramIfNotEmpty(String key, String value) {
             if (isEmpty(value)) {
                 return "";
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/FileUtils.java b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/FileUtils.java
index 272992e0..1e8b63a7 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/FileUtils.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/FileUtils.java
@@ -32,7 +32,7 @@
 
 package com.mopub.mobileads.test.support;
 
-import com.mopub.mobileads.util.Streams;
+import com.mopub.common.util.Streams;
 
 import java.io.*;
 
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/SdkTestRunner.java b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/SdkTestRunner.java
index e16beeae..217ba1d0 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/SdkTestRunner.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/test/support/SdkTestRunner.java
@@ -32,6 +32,10 @@
 
 package com.mopub.mobileads.test.support;
 
+import com.mopub.common.factories.MethodBuilderFactory;
+import com.mopub.common.util.DateAndTime;
+import com.mopub.common.util.test.support.TestDateAndTime;
+import com.mopub.common.util.test.support.TestMethodBuilderFactory;
 import com.mopub.mobileads.factories.AdFetcherFactory;
 import com.mopub.mobileads.factories.AdViewControllerFactory;
 import com.mopub.mobileads.factories.CustomEventBannerAdapterFactory;
@@ -46,7 +50,7 @@
 import com.mopub.mobileads.factories.VastManagerFactory;
 import com.mopub.mobileads.factories.VastVideoDownloadTaskFactory;
 import com.mopub.mobileads.factories.ViewGestureDetectorFactory;
-import com.mopub.mobileads.util.DateAndTime;
+
 import org.junit.runners.model.InitializationError;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.DefaultTestLifecycle;
@@ -82,6 +86,7 @@ public void prepareTest(Object test) {
             ViewGestureDetectorFactory.setInstance(new TestViewGestureDetectorFactory());
             VastManagerFactory.setInstance(new TestVastManagerFactory());
             VastVideoDownloadTaskFactory.setInstance(new TestVastVideoDownloadTaskFactory());
+            MethodBuilderFactory.setInstance(new TestMethodBuilderFactory());
 
             MockitoAnnotations.initMocks(test);
         }
diff --git a/mopub-sdk/src/test/java/com/mopub/mobileads/util/MraidsTest.java b/mopub-sdk/src/test/java/com/mopub/mobileads/util/MraidsTest.java
index cbe71238..5f9bd441 100644
--- a/mopub-sdk/src/test/java/com/mopub/mobileads/util/MraidsTest.java
+++ b/mopub-sdk/src/test/java/com/mopub/mobileads/util/MraidsTest.java
@@ -51,8 +51,8 @@
 
 import java.util.*;
 
-import static com.mopub.mobileads.util.VersionCode.HONEYCOMB_MR2;
-import static com.mopub.mobileads.util.VersionCode.ICE_CREAM_SANDWICH;
+import static com.mopub.common.util.VersionCode.HONEYCOMB_MR2;
+import static com.mopub.common.util.VersionCode.ICE_CREAM_SANDWICH;
 import static org.fest.assertions.api.Assertions.assertThat;
 import static org.mockito.Matchers.argThat;
 import static org.mockito.Matchers.eq;
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/AdapterHelperTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/AdapterHelperTest.java
new file mode 100644
index 00000000..0d4d3c36
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/AdapterHelperTest.java
@@ -0,0 +1,176 @@
+package com.mopub.nativeads;
+
+import android.app.Activity;
+
+import com.mopub.nativeads.test.support.SdkTestRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+public class AdapterHelperTest {
+    private AdapterHelper subject;
+    private Activity context;
+    private int contentRowCount;
+    private int start;
+    private int interval;
+
+    @Before
+    public void setUp() throws Exception {
+        context = new Activity();
+    }
+
+    @Test
+    public void adapterHelper_withContentRowCountOf10_shouldCalculateCorrectly() throws Exception {
+        contentRowCount = 10;
+
+        start = 0;
+        interval = 2;
+        subject = new AdapterHelper(context, start, interval);
+
+//      acacacacacacacacacac
+        assertThat(subject.shiftedCount(contentRowCount)).isEqualTo(20);
+        validateRows(20, start, interval);
+        assertThat(subject.shiftedPosition(1)).isEqualTo(0);
+        assertThat(subject.shiftedPosition(3)).isEqualTo(1);
+        assertThat(subject.shiftedPosition(5)).isEqualTo(2);
+        assertThat(subject.shiftedPosition(7)).isEqualTo(3);
+        assertThat(subject.shiftedPosition(9)).isEqualTo(4);
+        assertThat(subject.shiftedPosition(11)).isEqualTo(5);
+        assertThat(subject.shiftedPosition(13)).isEqualTo(6);
+        assertThat(subject.shiftedPosition(15)).isEqualTo(7);
+        assertThat(subject.shiftedPosition(17)).isEqualTo(8);
+        assertThat(subject.shiftedPosition(19)).isEqualTo(9);
+
+        start = 0;
+        interval = 6;
+        subject = new AdapterHelper(context, start, interval);
+
+//      acccccaccccc
+        assertThat(subject.shiftedCount(contentRowCount)).isEqualTo(12);
+        validateRows(12, start, interval);
+        assertThat(subject.shiftedPosition(1)).isEqualTo(0);
+        assertThat(subject.shiftedPosition(2)).isEqualTo(1);
+        assertThat(subject.shiftedPosition(3)).isEqualTo(2);
+        assertThat(subject.shiftedPosition(4)).isEqualTo(3);
+        assertThat(subject.shiftedPosition(5)).isEqualTo(4);
+        assertThat(subject.shiftedPosition(7)).isEqualTo(5);
+        assertThat(subject.shiftedPosition(8)).isEqualTo(6);
+        assertThat(subject.shiftedPosition(9)).isEqualTo(7);
+        assertThat(subject.shiftedPosition(10)).isEqualTo(8);
+        assertThat(subject.shiftedPosition(11)).isEqualTo(9);
+
+        start = 0;
+        interval = 11;
+        subject = new AdapterHelper(context, start, interval);
+
+//      acccccccccc
+        assertThat(subject.shiftedCount(contentRowCount)).isEqualTo(11);
+        validateRows(11, start, interval);
+        assertThat(subject.shiftedPosition(1)).isEqualTo(0);
+        assertThat(subject.shiftedPosition(5)).isEqualTo(4);
+        assertThat(subject.shiftedPosition(10)).isEqualTo(9);
+
+        start = 0;
+        interval = 4;
+        subject = new AdapterHelper(context, start, interval);
+
+//      acccacccacccac
+        assertThat(subject.shiftedCount(contentRowCount)).isEqualTo(14);
+        validateRows(14, start, interval);
+
+        start = 5;
+        interval = 6;
+        subject = new AdapterHelper(context, start, interval);
+
+//      cccccaccccc
+        assertThat(subject.shiftedCount(contentRowCount)).isEqualTo(11);
+        validateRows(11, start, interval);
+        assertThat(subject.shiftedPosition(4)).isEqualTo(4);
+        assertThat(subject.shiftedPosition(6)).isEqualTo(5);
+        assertThat(subject.shiftedPosition(10)).isEqualTo(9);
+
+        start = 5;
+        interval = 5;
+        subject = new AdapterHelper(context, start, interval);
+
+//      cccccaccccac
+        assertThat(subject.shiftedCount(contentRowCount)).isEqualTo(12);
+        validateRows(12, start, interval);
+        assertThat(subject.shiftedPosition(6)).isEqualTo(5);
+        assertThat(subject.shiftedPosition(11)).isEqualTo(9);
+
+        start = 3;
+        interval = 4;
+        subject = new AdapterHelper(context, start, interval);
+
+//      cccacccacccac
+        assertThat(subject.shiftedCount(contentRowCount)).isEqualTo(13);
+        validateRows(13, start, interval);
+        assertThat(subject.shiftedPosition(0)).isEqualTo(0);
+        assertThat(subject.shiftedPosition(2)).isEqualTo(2);
+        assertThat(subject.shiftedPosition(12)).isEqualTo(9);
+
+        start = 10;
+        interval = 100;
+        subject = new AdapterHelper(context, start, interval);
+
+//      cccccccccc
+        assertThat(subject.shiftedCount(contentRowCount)).isEqualTo(10);
+        validateRows(10, start, interval);
+        assertThat(subject.shiftedPosition(3)).isEqualTo(3);
+        assertThat(subject.shiftedPosition(7)).isEqualTo(7);
+        assertThat(subject.shiftedPosition(9)).isEqualTo(9);
+
+        start = 0;
+        interval = 10;
+        subject = new AdapterHelper(context, start, interval);
+
+//      acccccccccac
+        assertThat(subject.shiftedCount(contentRowCount)).isEqualTo(12);
+        validateRows(12, start, interval);
+        assertThat(subject.shiftedPosition(1)).isEqualTo(0);
+        assertThat(subject.shiftedPosition(9)).isEqualTo(8);
+        assertThat(subject.shiftedPosition(11)).isEqualTo(9);
+    }
+
+    @Test
+    public void adapterHelper_withContentRowCountOf1_shouldCalculateCorrectly() throws Exception {
+        contentRowCount = 1;
+        start = 0;
+        interval = 2;
+        subject = new AdapterHelper(context, start, interval);
+
+//      ac
+        assertThat(subject.shiftedCount(contentRowCount)).isEqualTo(2);
+        validateRows(2, start, interval);
+        assertThat(subject.shiftedPosition(1)).isEqualTo(0);
+
+        // We can still query for large numbers since the calculation assumes an infinite list
+        assertThat(subject.shiftedPosition(1001)).isEqualTo(500);
+
+        start = 1;
+        interval = 2;
+        subject = new AdapterHelper(context, start, interval);
+
+//      c
+        assertThat(subject.shiftedCount(contentRowCount)).isEqualTo(1);
+        validateRows(1, start, interval);
+        assertThat(subject.shiftedPosition(0)).isEqualTo(0);
+    }
+
+    private void validateRows(int totalRows, int start, int interval) {
+        for (int i = 0; i < totalRows; ++i) {
+            if (i == start) {
+                assertThat(subject.isAdPosition(i)).isTrue();
+            } else if (i > start && ((i - start) % (interval) == 0)) {
+                assertThat(subject.isAdPosition(i)).isTrue();
+            } else {
+                assertThat(subject.isAdPosition(i)).isFalse();
+            }
+        }
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/CacheServiceTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/CacheServiceTest.java
new file mode 100644
index 00000000..56748b71
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/CacheServiceTest.java
@@ -0,0 +1,161 @@
+package com.mopub.nativeads;
+
+import android.app.Activity;
+import android.support.v4.util.LruCache;
+
+import com.mopub.nativeads.test.support.SdkTestRunner;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.InputStream;
+import java.util.concurrent.Semaphore;
+
+import static com.mopub.nativeads.CacheService.DiskLruCacheGetListener;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+
+@RunWith(SdkTestRunner.class)
+public class CacheServiceTest {
+
+    private Activity context;
+    private String key1;
+    private String data1;
+    private String getKey;
+    private byte[] getBytes;
+    private DiskLruCacheGetListener diskCacheGetListener;
+    private Semaphore semaphore;
+
+    @Before
+    public void setUp() throws Exception {
+        context = new Activity();
+        key1 = "http://www.mopub.com/";
+        data1 = "image_data_1";
+
+        semaphore = new Semaphore(0);
+        diskCacheGetListener = mock(DiskLruCacheGetListener.class);
+        doAnswer(new Answer() {
+            @Override
+            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+                Object[] args = invocationOnMock.getArguments();
+                CacheServiceTest.this.getKey = (String)args[0];
+                CacheServiceTest.this.getBytes = (byte[])args[1];
+                semaphore.release();
+                return null;
+            }
+        }).when(diskCacheGetListener).onComplete(anyString(), any(byte[].class));
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        CacheService.clearAndNullCaches();
+    }
+
+    @Test
+    public void initializeCaches_withValidContext_shouldCreateNewCachesIdempotently() throws Exception {
+        assertThat(CacheService.getDiskLruCache()).isNull();
+
+        CacheService.initializeCaches(context);
+        DiskLruCache diskLruCache = CacheService.getDiskLruCache();
+        assertThat(diskLruCache).isNotNull();
+        LruCache<String, byte[]> memoryLruCache = CacheService.getMemoryLruCache();
+        assertThat(memoryLruCache).isNotNull();
+
+        CacheService.initializeCaches(context);
+        assertThat(diskLruCache).isEqualTo(CacheService.getDiskLruCache());
+        assertThat(memoryLruCache).isEqualTo(CacheService.getMemoryLruCache());
+    }
+    
+    @Test
+    public void getDiskLruCacheDirectory_shouldReturnValidCacheDirectory() throws Exception {
+        File file = CacheService.getDiskCacheDirectory(context);
+        String expectedPath = context.getCacheDir().toString() + "/mopub-cache";
+        assertThat(file.getAbsolutePath()).isEqualTo(expectedPath);
+    }
+
+    @Test
+    public void diskLruCacheGet_whenPopulated_shouldReturnValue() throws Exception {
+        CacheService.initializeCaches(context);
+        CacheService.putToDiskCache(key1, data1.getBytes());
+        assertThat(CacheService.getFromDiskCache(key1)).isEqualTo(data1.getBytes());
+    }
+
+    @Test
+    public void diskLruCacheGet_whenEmpty_shouldReturnNull() throws Exception {
+        CacheService.initializeCaches(context);
+        verifyCachesAreEmpty();
+        assertThat(CacheService.getFromDiskCache(key1)).isNull();
+    }
+
+    @Test
+    public void diskLruCacheAsyncGet_whenPopulated_shouldReturnValue() throws Exception {
+        CacheService.initializeCaches(context);
+        verifyCachesAreEmpty();
+        CacheService.putToDiskCache(key1, data1.getBytes());
+        CacheService.getFromDiskCacheAsync(key1, diskCacheGetListener);
+        semaphore.acquire();
+        assertThat(getKey).isEqualTo(key1);
+        assertThat(getBytes).isEqualTo(data1.getBytes());
+    }
+
+    @Test
+    public void diskLruCacheAsyncGet_whenEmpty_shouldReturnNull() throws Exception {
+        CacheService.initializeCaches(context);
+        CacheService.getFromDiskCacheAsync(key1, diskCacheGetListener);
+        semaphore.acquire();
+        assertThat(getKey).isEqualTo(key1);
+        assertThat(getBytes).isNull();
+    }
+
+    @Test
+    public void diskLruCachePut_withEmptyStringKey_shouldPutCorrectly() throws Exception {
+        // this works because an empty string sha1 hashes to a valid key
+        CacheService.initializeCaches(context);
+        CacheService.putToDiskCache("", data1.getBytes());
+        assertThat(CacheService.getFromDiskCache("")).isEqualTo(data1.getBytes());
+    }
+
+    @Test
+    public void diskLruCachePut_withNullKey_shouldNotPut() throws Exception {
+        // null value produces empty string key which is invalid for disk lru cache
+        CacheService.initializeCaches(context);
+        verifyCachesAreEmpty();
+        CacheService.putToDiskCache(null, data1.getBytes());
+        verifyCachesAreEmpty();
+    }
+
+    @Test
+    public void createValidDiskLruCacheKey_withNullValue_shouldReturnEmptyString() throws Exception {
+        CacheService.initializeCaches(context);
+        assertThat(CacheService.createValidDiskCacheKey(null)).isEqualTo("");
+    }
+
+    @Test
+    public void diskLruCacheAsyncPut_whenEmpty_shouldReturnNull() throws Exception {
+        CacheService.initializeCaches(context);
+        CacheService.putToDiskCacheAsync(key1, data1.getBytes());
+        Thread.sleep(500);
+        assertThat(CacheService.getFromDiskCache(key1)).isEqualTo(data1.getBytes());
+    }
+
+    private static InputStream getInputStreamFromString(final String string) {
+        return spy(new ByteArrayInputStream(string.getBytes()));
+    }
+
+    static void verifyCachesAreEmpty() {
+        assertThat(CacheService.getMemoryLruCache()).isNotNull();
+        assertThat(CacheService.getMemoryLruCache().size()).isEqualTo(0);
+        assertThat(CacheService.getDiskLruCache()).isNotNull();
+        assertThat(CacheService.getDiskLruCache().size()).isEqualTo(0);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/DownloadTaskTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/DownloadTaskTest.java
new file mode 100644
index 00000000..1051c009
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/DownloadTaskTest.java
@@ -0,0 +1,130 @@
+package com.mopub.nativeads;
+
+import com.mopub.nativeads.test.support.SdkTestRunner;
+
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.client.methods.HttpUriRequest;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.tester.org.apache.http.FakeHttpLayer;
+
+import java.util.concurrent.Semaphore;
+
+import static junit.framework.Assert.fail;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.spy;
+
+@RunWith(SdkTestRunner.class)
+public class DownloadTaskTest {
+
+    private DownloadTask mDownloadTask;
+    private DownloadTask.DownloadTaskListener mDownloadTaskListener;
+    private Semaphore mSemaphore;
+    private String mUrl;
+    private DownloadResponse mDownloadResponse;
+    private HttpGet httpGet;
+    private String mTestResponse;
+    private FakeHttpLayer mFakeHttpLayer;
+
+    @Before
+    public void setUp() throws Exception {
+        mSemaphore = new Semaphore(0);
+        mDownloadTaskListener = new DownloadTask.DownloadTaskListener() {
+            @Override
+            public void onComplete(String url, DownloadResponse response) {
+                mUrl = url;
+                mDownloadResponse = response;
+                mSemaphore.release();
+            }
+        };
+        mDownloadTask = spy(new DownloadTask(mDownloadTaskListener));
+        try {
+            httpGet = new HttpGet("http://www.mopub.com/");
+        } catch (IllegalArgumentException e) {
+            fail("Could not initialize HttpGet in test");
+        }
+        mTestResponse = "TEST RESPONSE";
+        mFakeHttpLayer = Robolectric.getFakeHttpLayer();
+    }
+
+    @Test
+    public void execute_whenDownloadTaskAndHttpClientCompleteSuccessfully_shouldReturn200HttpResponse() throws Exception {
+        mFakeHttpLayer.addPendingHttpResponse(200, mTestResponse);
+        mDownloadTask.execute(httpGet);
+        mSemaphore.acquire();
+        assertThat(mUrl).isEqualTo(httpGet.getURI().toString());
+        assertThat(mDownloadResponse.getStatusCode()).isEqualTo(200);
+        assertThat(HttpResponses.asResponseString(mDownloadResponse)).isEqualTo(mTestResponse);
+    }
+
+    @Test
+    public void execute_whenDownloadTaskCompletesSuccessfullyAndHttpClientTimesOut_shouldReturn599HttpResponse() throws Exception {
+        mFakeHttpLayer.addPendingHttpResponse(599, "");
+        mDownloadTask.execute(httpGet);
+        mSemaphore.acquire();
+        assertThat(mUrl).isEqualTo(httpGet.getURI().toString());
+        assertThat(mDownloadResponse.getStatusCode()).isEqualTo(599);
+        assertThat(HttpResponses.asResponseString(mDownloadResponse)).isEqualTo("");
+    }
+
+    @Test
+    public void execute_whenDownloadTaskIsCancelledBeforeExecute_shouldReturnNullHttpReponseAndNullUrl() throws Exception {
+        mFakeHttpLayer.addPendingHttpResponse(200, mTestResponse);
+        mDownloadTask.cancel(true);
+        mDownloadTask.execute(httpGet);
+        mSemaphore.acquire();
+        assertThat(mUrl).isEqualTo(null);
+        assertThat(mDownloadResponse).isEqualTo(null);
+    }
+
+    @Ignore("pending")
+    @Test
+    public void execute_whenDownloadTaskIsCancelledDuringDoInBackground_shouldReturnNullHttpReponse() throws Exception {
+        // need a way to reliably cancel task during doInBackground
+    }
+
+    @Ignore("pending")
+    @Test
+    public void execute_whenHttpUriRequestThrowsIOException_shouldCancelTaskAndReturnNullHttpResponse() throws Exception {
+        // need a way to force HttpUriRequest to throw on execute
+    }
+
+    @Test
+    public void execute_whenHttpUriRequestIsNull_shouldReturnNullHttpReponseAndNullUrl() throws Exception {
+        mDownloadTask.execute((HttpUriRequest) null);
+        mSemaphore.acquire();
+        assertThat(mUrl).isEqualTo(null);
+        assertThat(mDownloadResponse).isEqualTo(null);
+    }
+
+    @Test
+    public void execute_whenHttpUriRequestIsNullArray_shouldReturnNullHttpReponseAndNullUrl() throws Exception {
+        mDownloadTask.execute((HttpUriRequest[])null);
+        mSemaphore.acquire();
+        assertThat(mUrl).isEqualTo(null);
+        assertThat(mDownloadResponse).isEqualTo(null);
+    }
+
+    @Test
+    public void execute_whenHttpUriRequestIsArray_shouldOnlyReturnFirstResponse() throws Exception {
+        mFakeHttpLayer.addPendingHttpResponse(200, mTestResponse);
+        mFakeHttpLayer.addPendingHttpResponse(500, "");
+        mDownloadTask.execute(httpGet, new HttpGet("http://www.twitter.com/"));
+        mSemaphore.acquire();
+        assertThat(mDownloadResponse.getStatusCode()).isEqualTo(200);
+        assertThat(HttpResponses.asResponseString(mDownloadResponse)).isEqualTo(mTestResponse);
+    }
+
+    @Test
+    public void downLoadTask_whenConstructedWithNullListener_shouldThrowIllegalArgumentException() throws Exception {
+        try {
+            new DownloadTask(null);
+            fail("DownloadTask didn't throw IllegalArgumentException when constructed with null");
+        } catch (IllegalArgumentException e) {
+            // passed
+        }
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/HttpResponsesTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/HttpResponsesTest.java
new file mode 100644
index 00000000..d1f93650
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/HttpResponsesTest.java
@@ -0,0 +1,148 @@
+package com.mopub.nativeads;
+
+import android.graphics.Bitmap;
+
+import com.mopub.nativeads.DownloadResponse;
+import com.mopub.nativeads.test.support.SdkTestRunner;
+import com.mopub.nativeads.HttpResponses;
+
+import org.json.JSONArray;
+import org.json.JSONObject;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+import static org.robolectric.Robolectric.shadowOf;
+
+@RunWith(SdkTestRunner.class)
+public class HttpResponsesTest {
+
+    private DownloadResponse downloadResponse1;
+
+    @Before
+    public void setUp() throws Exception {
+        downloadResponse1 = mock(DownloadResponse.class);
+    }
+
+    @Test
+    public void asBitmap_shouldReturnBitmap() throws Exception {
+        String imageData = "fake_bitmap_data";
+        when(downloadResponse1.getByteArray()).thenReturn(imageData.getBytes());
+
+        final Bitmap bitmap = HttpResponses.asBitmap(downloadResponse1);
+
+        assertThat(bitmap).isNotNull();
+        assertThat(bitmap).isInstanceOf(Bitmap.class);
+        assertThat(shadowOf(bitmap).getCreatedFromBytes()).isEqualTo(imageData.getBytes());
+    }
+
+    @Test
+    public void asBitmap_withNullResponse_shouldReturnNull() throws Exception {
+        final Bitmap bitmap = HttpResponses.asBitmap(null);
+
+        assertThat(bitmap).isNull();
+    }
+
+    @Test
+    public void asJsonObject_withEmptyJsonString_shouldReturnEmptyJsonObjectAndCloseStream() throws Exception {
+        String jsonData = "{}";
+        when(downloadResponse1.getByteArray()).thenReturn(jsonData.getBytes());
+
+        final JSONObject expectedJsonObject = new JSONObject();
+
+        final JSONObject actualJsonObject = HttpResponses.asJsonObject(downloadResponse1);
+
+        assertThat(actualJsonObject).isEqualsToByComparingFields(expectedJsonObject);
+    }
+
+    @Test
+    public void asJsonObject_withShallowJsonString_shouldReturnPopulatedJsonObjectAndCloseStream() throws Exception {
+        String jsonData = "{\"key1\":\"value1\",\"key2\":\"2\",\"key3\":\"null\"}";
+        when(downloadResponse1.getByteArray()).thenReturn(jsonData.getBytes());
+
+        JSONObject expectedJsonObject = new JSONObject();
+        expectedJsonObject.put("key1", "value1");
+        expectedJsonObject.put("key2", 2);
+        expectedJsonObject.put("key3", JSONObject.NULL);
+
+        final JSONObject actualJsonObject = HttpResponses.asJsonObject(downloadResponse1);
+
+        assertThat(actualJsonObject).isEqualsToByComparingFields(expectedJsonObject);
+    }
+
+    @Test
+    public void asJsonObject_withDeepJsonString_shouldReturnPopulatedJsonObjectAndCloseStream() throws Exception {
+        String jsonData = "{\"key1\":\"value1\",\"key2\":[\"a\",\"b\"]}";
+        when(downloadResponse1.getByteArray()).thenReturn(jsonData.getBytes());
+
+        JSONObject expectedJsonObject = new JSONObject();
+        expectedJsonObject.put("key1", "value1");
+        final JSONArray jsonArray = new JSONArray();
+        jsonArray.put("a");
+        jsonArray.put("b");
+        expectedJsonObject.put("key2", jsonArray);
+
+        final JSONObject actualJsonObject = HttpResponses.asJsonObject(downloadResponse1);
+
+        assertThat(actualJsonObject).isEqualsToByComparingFields(expectedJsonObject);
+    }
+
+    @Test
+    public void asJsonObject_withMalformedJsonString_shouldReturnNullAndCloseStream() throws Exception {
+        String jsonData = "{whoops, forgot closing brace";
+        when(downloadResponse1.getByteArray()).thenReturn(jsonData.getBytes());
+
+        final JSONObject jsonObject = HttpResponses.asJsonObject(downloadResponse1);
+
+        assertThat(jsonObject).isNull();
+    }
+
+    @Test
+    public void asJsonObject_asResponseStringReturnsNull_shouldReturnNull() throws Exception {
+        when(downloadResponse1.getByteArray()).thenReturn(null);
+        assertThat(HttpResponses.asJsonObject(downloadResponse1)).isNull();
+    }
+
+    @Test
+    public void asJsonObject_withNullResponse_shouldReturnNull() throws Exception {
+        final JSONObject jsonObject = HttpResponses.asJsonObject(null);
+
+        assertThat(jsonObject).isNull();
+    }
+
+    @Test
+    public void asResponseString_withMultipleLines_shouldReturnResponseAndCloseStream() throws Exception {
+        String responseData = "1\n2\n3\n4";
+        when(downloadResponse1.getByteArray()).thenReturn(responseData.getBytes());
+
+        final String responseString = HttpResponses.asResponseString(downloadResponse1);
+
+        assertThat(responseString).isEqualTo(responseData);
+    }
+
+    @Test
+    public void asResponseString_shouldReturnResponseAndCloseStream() throws Exception {
+        String responseData = "response_string";
+        when(downloadResponse1.getByteArray()).thenReturn(responseData.getBytes());
+
+        final String responseString = HttpResponses.asResponseString(downloadResponse1);
+
+        assertThat(responseString).isEqualTo(responseData);
+    }
+
+    @Test
+    public void asResponseString_newStringThrowsException_shouldReturnNull() throws Exception {
+        when(downloadResponse1.getByteArray()).thenReturn(null);
+        assertThat(HttpResponses.asResponseString(downloadResponse1)).isNull();
+    }
+
+    @Test
+    public void asResponseString_withNullResponse_shouldReturnNull() throws Exception {
+        final String responseString = HttpResponses.asResponseString(null);
+
+        assertThat(responseString).isNull();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/ImageDiskTaskManagerTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/ImageDiskTaskManagerTest.java
new file mode 100644
index 00000000..05841644
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/ImageDiskTaskManagerTest.java
@@ -0,0 +1,161 @@
+package com.mopub.nativeads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.graphics.Bitmap;
+
+import com.mopub.nativeads.test.support.SdkTestRunner;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
+import org.robolectric.tester.org.apache.http.FakeHttpLayer;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.Semaphore;
+
+import static com.mopub.nativeads.ImageTaskManager.ImageTaskManagerListener;
+import static junit.framework.Assert.fail;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.anyMap;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.robolectric.Robolectric.shadowOf;
+
+@RunWith(SdkTestRunner.class)
+public class ImageDiskTaskManagerTest {
+
+    private ImageTaskManagerListener imageTaskManagerListener;
+    private Semaphore semaphore;
+    private Map<String, Bitmap> bitmaps;
+    private FakeHttpLayer fakeHttpLayer;
+    private String url1;
+    private String url2;
+    private String url3;
+    private String imageData1;
+    private String imageData2;
+    private String imageData3;
+    private List<String> list;
+    private Context context;
+
+    @Before
+    public void setUp() throws Exception {
+        context = new Activity();
+        semaphore = new Semaphore(0);
+        imageTaskManagerListener = mock(ImageTaskManagerListener.class);
+        doAnswer(new Answer() {
+            @Override
+            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+                Object[] args = invocationOnMock.getArguments();
+                Map<String, Bitmap> bitmaps = (Map)args[0];
+                ImageDiskTaskManagerTest.this.bitmaps = bitmaps;
+                semaphore.release();
+                return null;
+            }
+        }).when(imageTaskManagerListener).onSuccess(anyMap());
+        doAnswer(new Answer() {
+            @Override
+            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+                semaphore.release();
+                return null;
+            }
+        }).when(imageTaskManagerListener).onFail();
+
+        fakeHttpLayer = Robolectric.getFakeHttpLayer();
+        url1 = "http://www.mopub.com/";
+        url2 = "http://www.twitter.com";
+        url3 = "http://www.guydot.com";
+        imageData1 = "image_data_1";
+        imageData2 = "image_data_2";
+        imageData3 = "image_data_3";
+
+        list = new ArrayList<String>();
+        list.add(url1);
+        list.add(url2);
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        CacheService.clearAndNullCaches();
+    }
+
+    @Test
+    public void constructor_withNullUrlsList_shouldThrowIllegalArgumentException() throws Exception {
+        try {
+            new ImageDiskTaskManager(null, imageTaskManagerListener);
+            fail("Should have thrown IllegalArgumentException");
+        } catch (IllegalArgumentException e) {
+            // pass
+        }
+    }
+
+    @Test
+    public void constructor_withNullInUrlsList_shouldThrowIllegalArgumentException() throws Exception {
+        List<String> myList = new ArrayList<String>();
+        myList.add(null);
+        try {
+            new ImageDiskTaskManager(myList, imageTaskManagerListener);
+            fail("Should have thrown IllegalArgumentException");
+        } catch (IllegalArgumentException e) {
+            // pass
+        }
+    }
+
+    @Test
+    public void constructor_withNullImageTaskManagerListener_shouldThrowIllegalArgumentException() throws Exception {
+        try {
+            new ImageDiskTaskManager(list, null);
+            fail("Should have thrown IllegalArgumentException");
+        } catch (IllegalArgumentException e) {
+            // pass
+        }
+    }
+
+    @Test
+    public void execute_withEmptyDiskCache_shouldReturnNullsInMap() throws Exception {
+        new ImageDiskTaskManager(list, imageTaskManagerListener).execute();
+        semaphore.acquire();
+
+        assertThat(bitmaps.size()).isEqualTo(2);
+        assertThat(bitmaps.containsKey(url1)).isTrue();
+        assertThat(bitmaps.containsKey(url2)).isTrue();
+        assertThat(bitmaps.get(url1)).isNull();
+        assertThat(bitmaps.get(url2)).isNull();
+    }
+
+    @Test
+    public void execute_withPopulatedDiskCache_shouldReturnImagesInMap() throws Exception {
+        CacheService.initializeCaches(context);
+        CacheServiceTest.verifyCachesAreEmpty();
+        CacheService.putToDiskCache(url1, imageData1.getBytes());
+        CacheService.putToDiskCache(url2, imageData2.getBytes());
+
+        new ImageDiskTaskManager(list, imageTaskManagerListener).execute();
+        semaphore.acquire();
+
+        assertThat(bitmaps.size()).isEqualTo(2);
+        assertThat(shadowOf(bitmaps.get(url1)).getCreatedFromBytes()).isEqualTo(imageData1.getBytes());
+        assertThat(shadowOf(bitmaps.get(url2)).getCreatedFromBytes()).isEqualTo(imageData2.getBytes());
+    }
+
+    @Test
+    public void execute_withPartiallyPopulatedDiskCache_shouldReturnSomeImagesInMap() throws Exception {
+        CacheService.initializeCaches(context);
+        CacheServiceTest.verifyCachesAreEmpty();
+        CacheService.putToDiskCache(url1, imageData1.getBytes());
+
+        new ImageDiskTaskManager(list, imageTaskManagerListener).execute();
+        semaphore.acquire();
+
+        assertThat(bitmaps.size()).isEqualTo(2);
+        assertThat(shadowOf(bitmaps.get(url1)).getCreatedFromBytes()).isEqualTo(imageData1.getBytes());
+        assertThat(bitmaps.containsKey(url2)).isTrue();
+        assertThat(bitmaps.get(url2)).isNull();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/ImageDownloadTaskManagerTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/ImageDownloadTaskManagerTest.java
new file mode 100644
index 00000000..3c6734f8
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/ImageDownloadTaskManagerTest.java
@@ -0,0 +1,256 @@
+package com.mopub.nativeads;
+
+import android.graphics.Bitmap;
+
+import com.mopub.nativeads.test.support.SdkTestRunner;
+
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.params.BasicHttpParams;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
+import org.robolectric.tester.org.apache.http.FakeHttpLayer;
+import org.robolectric.tester.org.apache.http.TestHttpResponse;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Map;
+import java.util.concurrent.Semaphore;
+
+import static junit.framework.Assert.fail;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.anyMap;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+import static org.robolectric.Robolectric.shadowOf;
+
+@RunWith(SdkTestRunner.class)
+public class ImageDownloadTaskManagerTest {
+
+    private ImageDownloadTaskManager subject;
+    private ImageDownloadTaskManager.ImageTaskManagerListener mMockImageTaskManagerListener;
+    private Semaphore semaphore;
+    private Map<String, Bitmap> networkImages;
+    private FakeHttpLayer fakeHttpLayer;
+    private String url1;
+    private String url2;
+
+    @Before
+    public void setUp() throws Exception {
+        semaphore = new Semaphore(0);
+        mMockImageTaskManagerListener = mock(ImageDownloadTaskManager.ImageTaskManagerListener.class);
+        doAnswer(new Answer() {
+            @Override
+            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+                Object[] args = invocationOnMock.getArguments();
+                Map<String, Bitmap> map = (Map)args[0];
+                ImageDownloadTaskManagerTest.this.networkImages = map;
+                semaphore.release();
+                return null;
+            }
+        }).when(mMockImageTaskManagerListener).onSuccess(anyMap());
+        doAnswer(new Answer() {
+            @Override
+            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+                semaphore.release();
+                return null;
+            }
+        }).when(mMockImageTaskManagerListener).onFail();
+
+        fakeHttpLayer = Robolectric.getFakeHttpLayer();
+        url1 = "http://www.mopub.com/";
+        url2 = "http://www.twitter.com";
+    }
+
+    @Test
+    public void constructor_withValidUrlListAndListener_shouldReturnNewImageDownloadTaskManager() throws Exception {
+        subject = new ImageDownloadTaskManager(
+                Arrays.asList(url1, url2),
+                mMockImageTaskManagerListener
+        );
+    }
+
+    @Test
+    public void constructor_withEmptyUrlListAndListener_shouldReturnNewImageDownloadTaskManager() throws Exception {
+        subject = new ImageDownloadTaskManager(
+                new ArrayList<String>(),
+                mMockImageTaskManagerListener
+        );
+    }
+
+    @Test
+    public void constructor_withInvalidUrlList_shouldThrowIllegalArgumentException() throws Exception {
+        try {
+            subject = new ImageDownloadTaskManager(
+                    Arrays.asList("BAD URL", url2),
+                    mMockImageTaskManagerListener
+            );
+            fail("ImageDownloadTaskManager didn't throw an illegal argument exception");
+        } catch (IllegalArgumentException e) {
+            // pass
+        }
+
+        try {
+            subject = new ImageDownloadTaskManager(
+                    Arrays.asList(url1, null),
+                    mMockImageTaskManagerListener
+            );
+            fail("ImageDownloadTaskManager didn't throw an illegal argument exception");
+        } catch (IllegalArgumentException e) {
+            // pass
+        }
+    }
+
+    @Test
+    public void constructor_withAnyNullParams_shouldThrowIllegalArgumentException() throws Exception {
+        try {
+            subject = new ImageDownloadTaskManager(
+                    null,
+                    mMockImageTaskManagerListener
+            );
+            fail("ImageDownloadTaskManager didn't throw an illegal argument exception");
+        } catch (IllegalArgumentException e) {
+            // pass
+        }
+
+        try {
+            subject = new ImageDownloadTaskManager(
+                    Arrays.asList(url1, url2),
+                    null
+            );
+            fail("ImageDownloadTaskManager didn't throw an illegal argument exception");
+        } catch (IllegalArgumentException e) {
+            // pass
+        }
+    }
+
+    @Test
+    public void execute_withValidUrlListAndListenerAndHttpResponses_shouldReturnMapOfUrlToBitmap() throws Exception {
+        subject = new ImageDownloadTaskManager(
+                Arrays.asList(url1, url2),
+                mMockImageTaskManagerListener
+        );
+
+        String imageData1 = "image_data_1";
+        Robolectric.addHttpResponseRule(
+                url1,
+                new TestHttpResponse(200, imageData1)
+        );
+
+        String imageData2 = "image_data_2";
+        Robolectric.addHttpResponseRule(
+                url2,
+                new TestHttpResponse(200, imageData2)
+        );
+
+        subject.execute();
+        semaphore.acquire();
+
+        assertThat(networkImages.keySet()).containsOnly(url1, url2);
+
+        Bitmap bitmap1 = networkImages.get(url1);
+        assertThat(shadowOf(bitmap1).getCreatedFromBytes()).isEqualTo(imageData1.getBytes());
+
+        Bitmap bitmap2 = networkImages.get(url2);
+        assertThat(shadowOf(bitmap2).getCreatedFromBytes()).isEqualTo(imageData2.getBytes());
+
+        verify(mMockImageTaskManagerListener).onSuccess(anyMap());
+        verify(mMockImageTaskManagerListener, never()).onFail();
+    }
+
+    @Test
+    public void execute_withEmptyUrlList_shouldReturnEmptyMap() throws Exception {
+        subject = new ImageDownloadTaskManager(
+                new ArrayList<String>(),
+                mMockImageTaskManagerListener
+        );
+
+        subject.execute();
+        semaphore.acquire();
+
+        assertThat(networkImages.isEmpty()).isTrue();
+        verify(mMockImageTaskManagerListener).onSuccess(anyMap());
+        verify(mMockImageTaskManagerListener, never()).onFail();
+    }
+
+    @Test
+    public void execute_withSingleNon200Response_shouldFailAllTasks() throws Exception {
+        subject = new ImageDownloadTaskManager(
+                Arrays.asList(url1, url1, url1, url1, url1),
+                mMockImageTaskManagerListener
+        );
+
+        fakeHttpLayer.addPendingHttpResponse(200, "");
+        fakeHttpLayer.addPendingHttpResponse(200, "");
+        fakeHttpLayer.addPendingHttpResponse(200, "");
+        fakeHttpLayer.addPendingHttpResponse(200, "");
+        fakeHttpLayer.addPendingHttpResponse(599, "");
+
+        subject.execute();
+        semaphore.acquire();
+
+        verify(mMockImageTaskManagerListener, never()).onSuccess(anyMap());
+        verify(mMockImageTaskManagerListener).onFail();
+    }
+
+    @Test
+    public void execute_withMultipleNon200Response_shouldFailAllTasks() throws Exception {
+        subject = new ImageDownloadTaskManager(
+                Arrays.asList(url1, url1, url1, url1, url1),
+                mMockImageTaskManagerListener
+        );
+
+        fakeHttpLayer.addPendingHttpResponse(599, "");
+        fakeHttpLayer.addPendingHttpResponse(599, "");
+        fakeHttpLayer.addPendingHttpResponse(599, "");
+        fakeHttpLayer.addPendingHttpResponse(599, "");
+        fakeHttpLayer.addPendingHttpResponse(599, "");
+
+        subject.execute();
+        semaphore.acquire();
+
+        verify(mMockImageTaskManagerListener, never()).onSuccess(anyMap());
+        verify(mMockImageTaskManagerListener).onFail();
+    }
+
+    @Ignore("need to fix concurrency logic")
+    @Test
+    public void execute_withSingleInvalidHttpResponse_shouldFailAllTasks() throws Exception {
+        subject = new ImageDownloadTaskManager(
+                Arrays.asList(url1, url1, url1, url1, url1),
+                mMockImageTaskManagerListener
+        );
+
+        fakeHttpLayer.addPendingHttpResponse(200, "");
+        fakeHttpLayer.addPendingHttpResponse(200, "");
+        fakeHttpLayer.addPendingHttpResponse(200, "");
+        fakeHttpLayer.addPendingHttpResponse(200, "");
+        fakeHttpLayer.addPendingHttpResponse(createMockHttpResponseThatThrowsOnGetContent());
+
+        subject.execute();
+        semaphore.acquire();
+
+        verify(mMockImageTaskManagerListener, never()).onSuccess(anyMap());
+        verify(mMockImageTaskManagerListener).onFail();
+    }
+
+    private static HttpResponse createMockHttpResponseThatThrowsOnGetContent() throws IOException {
+        HttpEntity mockHttpEntity = mock(HttpEntity.class);
+        when(mockHttpEntity.getContent()).thenThrow(new IOException());
+
+        TestHttpResponse mockHttpResponse = mock(TestHttpResponse.class);
+        when(mockHttpResponse.getStatusLine()).thenReturn(mockHttpResponse.new TestStatusLine());
+        when(mockHttpResponse.getParams()).thenReturn(new BasicHttpParams());
+        when(mockHttpResponse.getEntity()).thenReturn(mockHttpEntity);
+        return mockHttpResponse;
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/ImageServiceTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/ImageServiceTest.java
new file mode 100644
index 00000000..30152591
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/ImageServiceTest.java
@@ -0,0 +1,332 @@
+package com.mopub.nativeads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+
+import com.mopub.nativeads.test.support.SdkTestRunner;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
+import org.robolectric.tester.org.apache.http.FakeHttpLayer;
+
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.Semaphore;
+
+import static com.mopub.nativeads.ImageService.ImageServiceListener;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.anyMap;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.robolectric.Robolectric.shadowOf;
+
+@RunWith(SdkTestRunner.class)
+public class ImageServiceTest {
+
+    private ImageServiceListener imageServiceListener;
+    private Semaphore semaphore;
+    private Map<String, Bitmap> bitmaps;
+    private FakeHttpLayer fakeHttpLayer;
+    private String url1;
+    private String url2;
+    private String url3;
+    private String imageData1;
+    private String imageData2;
+    private String imageData3;
+    private Context context;
+
+    @Before
+    public void setUp() throws Exception {
+        semaphore = new Semaphore(0);
+        imageServiceListener = mock(ImageServiceListener.class);
+        doAnswer(new Answer() {
+            @Override
+            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+                Object[] args = invocationOnMock.getArguments();
+                Map<String, Bitmap> bitmaps = (Map)args[0];
+                ImageServiceTest.this.bitmaps = bitmaps;
+                semaphore.release();
+                return null;
+            }
+        }).when(imageServiceListener).onSuccess(anyMap());
+        doAnswer(new Answer() {
+            @Override
+            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+                semaphore.release();
+                return null;
+            }
+        }).when(imageServiceListener).onFail();
+
+        fakeHttpLayer = Robolectric.getFakeHttpLayer();
+        url1 = "http://www.mopub.com/";
+        url2 = "http://www.twitter.com";
+        url3 = "http://www.guydot.com";
+        imageData1 = "image_data_1";
+        imageData2 = "image_data_2";
+        imageData3 = "image_data_3";
+        context = new Activity();
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        CacheService.clearAndNullCaches();
+    }
+
+    @Test
+    public void get_shouldInitializeCaches() throws Exception {
+        CacheService.clearAndNullCaches();
+        assertThat(CacheService.getMemoryLruCache()).isNull();
+        assertThat(CacheService.getDiskLruCache()).isNull();
+
+        ImageService.get(context, new ArrayList<String>(), imageServiceListener);
+
+        assertThat(CacheService.getMemoryLruCache()).isNotNull();
+        assertThat(CacheService.getDiskLruCache()).isNotNull();
+    }
+
+    @Test
+    public void get_withImageInMemoryCache_shouldReturnImage() throws Exception {
+        CacheService.initializeCaches(context);
+        CacheServiceTest.verifyCachesAreEmpty();
+        CacheService.putToMemoryCache(url1, imageData1.getBytes());
+
+        ImageService.get(context, Arrays.asList(url1), imageServiceListener);
+        // no need for semaphore since memory cache is synchronous
+
+        assertThat(shadowOf(bitmaps.get(url1)).getCreatedFromBytes()).isEqualTo(imageData1.getBytes());
+    }
+
+    @Test
+    public void get_withImageInDiskCache_shouldReturnImage() throws Exception {
+        CacheService.initializeCaches(context);
+        CacheServiceTest.verifyCachesAreEmpty();
+        CacheService.putToDiskCache(url1, imageData1.getBytes());
+
+        ImageService.get(context, Arrays.asList(url1), imageServiceListener);
+        semaphore.acquire();
+
+        assertThat(fakeHttpLayer.getLastSentHttpRequestInfo()).isNull();
+        assertThat(shadowOf(bitmaps.get(url1)).getCreatedFromBytes()).isEqualTo(imageData1.getBytes());
+    }
+
+    @Test
+    public void get_withEmptyCaches_shouldGetImageFromNetwork() throws Exception {
+        CacheService.initializeCaches(context);
+        CacheServiceTest.verifyCachesAreEmpty();
+
+        fakeHttpLayer.addPendingHttpResponse(200, imageData1);
+
+        ImageService.get(context, Arrays.asList(url1), imageServiceListener);
+        semaphore.acquire();
+
+        assertThat(shadowOf(bitmaps.get(url1)).getCreatedFromBytes()).isEqualTo(imageData1.getBytes());
+    }
+
+    @Test
+    public void get_withImagesInMemoryCacheAndDiskCache_shouldReturnBothImages() throws Exception {
+        CacheService.initializeCaches(context);
+        CacheServiceTest.verifyCachesAreEmpty();
+
+        CacheService.putToMemoryCache(url1, imageData1.getBytes());
+        CacheService.putToDiskCache(url2, imageData2.getBytes());
+
+        ImageService.get(context, Arrays.asList(url1, url2), imageServiceListener);
+        semaphore.acquire();
+
+        assertThat(shadowOf(bitmaps.get(url1)).getCreatedFromBytes()).isEqualTo(imageData1.getBytes());
+        assertThat(fakeHttpLayer.getLastSentHttpRequestInfo()).isNull();
+        assertThat(shadowOf(bitmaps.get(url2)).getCreatedFromBytes()).isEqualTo(imageData2.getBytes());
+    }
+
+    @Test
+    public void get_withImagesInMemoryAndNetwork_shouldReturnBothImages() throws Exception {
+        CacheService.initializeCaches(context);
+        CacheServiceTest.verifyCachesAreEmpty();
+
+        CacheService.putToMemoryCache(url1, imageData1.getBytes());
+        fakeHttpLayer.addPendingHttpResponse(200, imageData2);
+
+        ImageService.get(context, Arrays.asList(url1, url2), imageServiceListener);
+        semaphore.acquire();
+
+        assertThat(shadowOf(bitmaps.get(url1)).getCreatedFromBytes()).isEqualTo(imageData1.getBytes());
+        assertThat(fakeHttpLayer.getLastSentHttpRequestInfo().getHttpHost().toString()).isEqualTo(url2);
+        assertThat(shadowOf(bitmaps.get(url2)).getCreatedFromBytes()).isEqualTo(imageData2.getBytes());
+    }
+
+    @Test
+    public void get_withImagesInDiskAndNetwork_shouldReturnBothImages() throws Exception {
+        CacheService.initializeCaches(context);
+        CacheServiceTest.verifyCachesAreEmpty();
+
+        CacheService.putToDiskCache(url1, imageData1.getBytes());
+        fakeHttpLayer.addPendingHttpResponse(200, imageData2);
+
+        ImageService.get(context, Arrays.asList(url1, url2), imageServiceListener);
+        semaphore.acquire();
+
+        assertThat(shadowOf(bitmaps.get(url1)).getCreatedFromBytes()).isEqualTo(imageData1.getBytes());
+        assertThat(fakeHttpLayer.getLastSentHttpRequestInfo().getHttpHost().toString()).isEqualTo(url2);
+        assertThat(shadowOf(bitmaps.get(url2)).getCreatedFromBytes()).isEqualTo(imageData2.getBytes());
+    }
+
+    @Test
+    public void get_withImagesInMemoryAndDiskAndNetwork_shouldReturnAllImages() throws Exception {
+        CacheService.initializeCaches(context);
+        CacheServiceTest.verifyCachesAreEmpty();
+
+        CacheService.putToMemoryCache(url1, imageData1.getBytes());
+        CacheService.putToDiskCache(url2, imageData2.getBytes());
+        fakeHttpLayer.addPendingHttpResponse(200, imageData3);
+
+        ImageService.get(context, Arrays.asList(url1, url2, url3), imageServiceListener);
+        semaphore.acquire();
+
+        assertThat(shadowOf(bitmaps.get(url1)).getCreatedFromBytes()).isEqualTo(imageData1.getBytes());
+        assertThat(shadowOf(bitmaps.get(url2)).getCreatedFromBytes()).isEqualTo(imageData2.getBytes());
+        assertThat(shadowOf(bitmaps.get(url3)).getCreatedFromBytes()).isEqualTo(imageData3.getBytes());
+    }
+
+    @Test
+    public void get_withSameKeysInMemoryAndDiskCache_shouldReturnValueFromMemoryCache() throws Exception {
+        CacheService.initializeCaches(context);
+        CacheServiceTest.verifyCachesAreEmpty();
+
+        CacheService.putToMemoryCache(url1, imageData2.getBytes());
+        CacheService.putToDiskCache(url1, imageData1.getBytes());
+
+        ImageService.get(context, Arrays.asList(url1), imageServiceListener);
+        semaphore.acquire();
+
+        assertThat(shadowOf(bitmaps.get(url1)).getCreatedFromBytes()).isEqualTo(imageData2.getBytes());
+    }
+
+    @Test
+    public void get_withSameKeysInMemoryAndNetwork_shouldReturnValueFromMemoryCache() throws Exception {
+        CacheService.initializeCaches(context);
+        CacheServiceTest.verifyCachesAreEmpty();
+
+        CacheService.putToMemoryCache(url1, imageData2.getBytes());
+        fakeHttpLayer.addPendingHttpResponse(200, imageData1);
+
+        ImageService.get(context, Arrays.asList(url1), imageServiceListener);
+        semaphore.acquire();
+
+        assertThat(shadowOf(bitmaps.get(url1)).getCreatedFromBytes()).isEqualTo(imageData2.getBytes());
+    }
+
+    @Test
+    public void get_withSameKeysInDiskAndNetwork_shouldReturnValueFromDiskCache() throws Exception {
+        CacheService.initializeCaches(context);
+        CacheServiceTest.verifyCachesAreEmpty();
+
+        CacheService.putToDiskCache(url1, imageData2.getBytes());
+        fakeHttpLayer.addPendingHttpResponse(200, imageData1);
+
+        ImageService.get(context, Arrays.asList(url1), imageServiceListener);
+        semaphore.acquire();
+
+        assertThat(shadowOf(bitmaps.get(url1)).getCreatedFromBytes()).isEqualTo(imageData2.getBytes());
+    }
+
+    @Test
+    public void get_withNetworkFailure_shouldFail() throws Exception {
+        CacheService.initializeCaches(context);
+        CacheServiceTest.verifyCachesAreEmpty();
+
+        CacheService.putToMemoryCache(url1, imageData1.getBytes());
+        CacheService.putToDiskCache(url2, imageData2.getBytes());
+        fakeHttpLayer.addPendingHttpResponse(500, imageData3);
+
+        ImageService.get(context, Arrays.asList(url1, url2, url3), imageServiceListener);
+        semaphore.acquire();
+
+        assertThat(bitmaps).isNull();
+    }
+
+    @Test
+    public void get_withMultipleNetworkSuccessAndOneFailure_shouldFail() throws Exception {
+        CacheService.initializeCaches(context);
+        CacheServiceTest.verifyCachesAreEmpty();
+
+        fakeHttpLayer.addPendingHttpResponse(200, imageData1);
+        fakeHttpLayer.addPendingHttpResponse(200, imageData2);
+        fakeHttpLayer.addPendingHttpResponse(500, imageData3);
+
+        ImageService.get(context, Arrays.asList(url1, url2, url3), imageServiceListener);
+        semaphore.acquire();
+
+        assertThat(bitmaps).isNull();
+    }
+
+    @Test
+    public void putBitmapsInCache_populatesCaches() throws Exception {
+        CacheService.initializeCaches(context);
+
+        Bitmap bitmap1 = BitmapFactory.decodeStream(getInputStreamFromString(imageData1));
+        Bitmap bitmap2 = BitmapFactory.decodeStream(getInputStreamFromString(imageData2));
+
+        Map<String, Bitmap> bitmaps = new HashMap<String, Bitmap>(2);
+        bitmaps.put(url1, bitmap1);
+        bitmaps.put(url2, bitmap2);
+
+        assertThat(ImageService.getBitmapFromDiskCache(url1)).isNull();
+        assertThat(ImageService.getBitmapFromDiskCache(url2)).isNull();
+        assertThat(ImageService.getBitmapFromMemoryCache(url1)).isNull();
+        assertThat(ImageService.getBitmapFromMemoryCache(url2)).isNull();
+
+        ImageService.putBitmapsInCache(bitmaps);
+        Thread.sleep(500); // disk cache put is async
+
+        assertThat(ImageService.getBitmapFromDiskCache(url1)).isNotNull();
+        assertThat(ImageService.getBitmapFromDiskCache(url2)).isNotNull();
+        assertThat(ImageService.getBitmapFromMemoryCache(url1)).isNotNull();
+        assertThat(ImageService.getBitmapFromMemoryCache(url2)).isNotNull();
+    }
+
+    @Test
+    public void getBitmapsFromMemoryCache_withEmptyCacheAndTwoUrls_returnsNoCacheHitsAndTwoCacheMisses() throws Exception {
+        CacheService.initializeCaches(context);
+        assertThat(CacheService.getMemoryLruCache().size()).isEqualTo(0);
+
+        Map<String, Bitmap> cacheHits = new HashMap<String, Bitmap>(2);
+        List<String> cacheMisses =
+                ImageService.getBitmapsFromMemoryCache(Arrays.asList(url1, url2), cacheHits);
+
+        assertThat(cacheHits).isEmpty();
+        assertThat(cacheMisses).containsOnly(url1, url2);
+    }
+
+    @Test
+    public void getBitmapsFromMemoryCache_withOneCacheEntryAndTwoUrls_returnsOneCacheHitAndOneCacheMiss() throws Exception {
+        CacheService.initializeCaches(context);
+
+        assertThat(CacheService.getMemoryLruCache().size()).isEqualTo(0);
+
+        CacheService.putToMemoryCache(url1, imageData1.getBytes());
+
+        Map<String, Bitmap> cacheHits = new HashMap<String, Bitmap>(2);
+        List<String> cacheMisses =
+                ImageService.getBitmapsFromMemoryCache(Arrays.asList(url1, url2), cacheHits);
+
+        assertThat(cacheHits.keySet()).containsOnly(url1);
+        assertThat(cacheMisses).containsOnly(url2);
+    }
+
+    private static InputStream getInputStreamFromString(final String string) {
+        return spy(new ByteArrayInputStream(string.getBytes()));
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/ImageViewServiceTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/ImageViewServiceTest.java
new file mode 100644
index 00000000..72753719
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/ImageViewServiceTest.java
@@ -0,0 +1,190 @@
+package com.mopub.nativeads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.widget.ImageView;
+
+import com.mopub.nativeads.test.support.SdkTestRunner;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.tester.org.apache.http.FakeHttpLayer;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.robolectric.Robolectric.shadowOf;
+
+@RunWith(SdkTestRunner.class)
+public class ImageViewServiceTest {
+
+    private ImageView imageView;
+    private String url1;
+    private String url2;
+    private String imageData1;
+    private String imageData2;
+    private FakeHttpLayer fakeHttpLayer;
+
+    @Before
+    public void setUp() throws Exception {
+        Context context = new Activity();
+        imageView = new ImageView(context);
+        CacheService.initializeCaches(context);
+        url1 = "http://www.mopub.com/";
+        url2 = "http://www.twitter.com/";
+        imageData1 = "image_data_1";
+        imageData2 = "image_data_2";
+        fakeHttpLayer = Robolectric.getFakeHttpLayer();
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        CacheService.clearAndNullCaches();
+    }
+
+    @Test
+    public void loadImageView_withImageInMemoryCache_shouldLoadImageData() throws Exception {
+        CacheServiceTest.verifyCachesAreEmpty();
+        CacheService.putToMemoryCache(url1, imageData1.getBytes());
+
+        assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNull();
+
+        ImageViewService.loadImageView(url1, imageView);
+
+        assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNotNull();
+        assertThat(shadowOf(getBitmapFromImageView(imageView)).getCreatedFromBytes())
+                .isEqualTo(imageData1.getBytes());
+    }
+
+    @Test
+    public void loadImageView_withImageInDiskCache_shouldLoadImageDataAsync() throws Exception {
+        CacheServiceTest.verifyCachesAreEmpty();
+        CacheService.putToDiskCache(url1, imageData1.getBytes());
+
+        assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNull();
+
+        ImageViewService.loadImageView(url1, imageView);
+        Thread.sleep(500);
+
+        assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNotNull();
+        assertThat(shadowOf(getBitmapFromImageView(imageView)).getCreatedFromBytes())
+                .isEqualTo(imageData1.getBytes());
+    }
+
+    @Test
+    public void loadImageView_withImageInNetwork_shouldLoadImageDataAsync() throws Exception {
+        CacheServiceTest.verifyCachesAreEmpty();
+        fakeHttpLayer.addPendingHttpResponse(200, imageData1);
+
+        assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNull();
+
+        ImageViewService.loadImageView(url1, imageView);
+        Thread.sleep(500);
+
+        assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNotNull();
+        assertThat(shadowOf(getBitmapFromImageView(imageView)).getCreatedFromBytes())
+                .isEqualTo(imageData1.getBytes());
+    }
+
+    @Test
+    public void loadImageView_withImageInNetworkAndUniqueIdChanges_shouldNotLoadImageData() throws Exception {
+        CacheServiceTest.verifyCachesAreEmpty();
+        assertThat(imageView.getDrawable()).isNull();
+        fakeHttpLayer.addPendingHttpResponse(200, imageData1);
+
+        assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNull();
+
+        Robolectric.getBackgroundScheduler().pause();
+        ImageViewService.loadImageView(url1, imageView);
+
+        // Change unique id before running async task to simulate another image load
+        ImageViewService.setImageViewUniqueId(imageView);
+
+        Robolectric.getBackgroundScheduler().runOneTask();
+        Robolectric.getBackgroundScheduler().unPause();
+        Thread.sleep(500);
+
+        assertThat(imageView.getDrawable()).isNull();
+    }
+
+    @Test
+    public void loadImageView_withImageInNetworkAndUniqueIdIsNull_shouldNotLoadImageData() throws Exception {
+        CacheServiceTest.verifyCachesAreEmpty();
+        assertThat(imageView.getDrawable()).isNull();
+        fakeHttpLayer.addPendingHttpResponse(200, imageData1);
+
+        assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNull();
+
+        Robolectric.getBackgroundScheduler().pause();
+        ImageViewService.loadImageView(url1, imageView);
+
+        // Change unique id before running async task to simulate another image load
+        ImageViewService.setViewTag(imageView, null);
+
+        Robolectric.getBackgroundScheduler().runOneTask();
+        Robolectric.getBackgroundScheduler().unPause();
+        Thread.sleep(500);
+
+        assertThat(imageView.getDrawable()).isNull();
+    }
+
+    @Test
+    public void loadImageView_withTwoNetworkRequests_shouldLoadSecondImageData() throws Exception {
+        CacheServiceTest.verifyCachesAreEmpty();
+        assertThat(imageView.getDrawable()).isNull();
+        fakeHttpLayer.addPendingHttpResponse(200, imageData1);
+        fakeHttpLayer.addPendingHttpResponse(200, imageData2);
+
+        assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNull();
+
+        Robolectric.getBackgroundScheduler().pause();
+        ImageViewService.loadImageView(url1, imageView);
+        ImageViewService.loadImageView(url2, imageView);
+
+        Robolectric.getBackgroundScheduler().runOneTask();
+        Robolectric.getBackgroundScheduler().runOneTask();
+        Robolectric.getBackgroundScheduler().unPause();
+        Thread.sleep(500);
+
+        assertThat(shadowOf(getBitmapFromImageView(imageView)).getCreatedFromBytes())
+                .isEqualTo(imageData2.getBytes());
+    }
+
+    @Test
+    public void loadImageView_shouldClearDrawable() throws Exception {
+        CacheServiceTest.verifyCachesAreEmpty();
+        assertThat(imageView.getDrawable()).isNull();
+        fakeHttpLayer.addPendingHttpResponse(200, imageData1);
+        fakeHttpLayer.addPendingHttpResponse(200, imageData2);
+
+        assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNull();
+
+        ImageViewService.loadImageView(url1, imageView);
+        Thread.sleep(500);
+        assertThat(shadowOf(getBitmapFromImageView(imageView)).getCreatedFromBytes())
+                .isEqualTo(imageData1.getBytes());
+
+        Robolectric.getBackgroundScheduler().pause();
+        ImageViewService.loadImageView(url2, imageView);
+        assertThat(imageView.getDrawable()).isNull();
+    }
+
+    @Test
+    public void loadImageView_withEmptyCachesAndNetworkFailure_shouldNotLoadImageDataAsync() throws Exception {
+        CacheServiceTest.verifyCachesAreEmpty();
+        fakeHttpLayer.addPendingHttpResponse(500, imageData1);
+
+        ImageViewService.loadImageView(url1, imageView);
+        Thread.sleep(500);
+
+        assertThat(ImageViewService.getImageViewUniqueId(imageView)).isNotNull();
+        assertThat(imageView.getDrawable()).isNull();
+    }
+
+    static Bitmap getBitmapFromImageView(final ImageView imageView) {
+        return ((BitmapDrawable)imageView.getDrawable()).getBitmap();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/ImpressionTrackingManagerTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/ImpressionTrackingManagerTest.java
new file mode 100644
index 00000000..c6445a99
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/ImpressionTrackingManagerTest.java
@@ -0,0 +1,317 @@
+package com.mopub.nativeads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.graphics.Rect;
+import android.view.View;
+
+import com.mopub.nativeads.test.support.SdkTestRunner;
+
+import org.json.JSONArray;
+import org.json.JSONObject;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
+import org.robolectric.shadows.ShadowSystemClock;
+import org.robolectric.tester.org.apache.http.TestHttpResponse;
+
+import java.util.Map;
+
+import static com.mopub.nativeads.ImpressionTrackingManager.NativeResponseWrapper;
+import static com.mopub.nativeads.ImpressionTrackingManager.VisibilityCheck;
+import static com.mopub.nativeads.MoPubNative.MoPubNativeListener;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(SdkTestRunner.class)
+public class ImpressionTrackingManagerTest {
+    private static final String IMPRESSION_TRACKER = "url1";
+
+    private View view;
+    private NativeResponse nativeResponse;
+    private Context context;
+    private MoPubNativeListener mopubNativeListener;
+    private JSONObject fakeJsonObject;
+
+    @Before
+    public void setUp() throws Exception {
+        context = new Activity();
+        mopubNativeListener = mock(MoPubNativeListener.class);
+        view = getViewMock(View.VISIBLE, 100, 100, 100, 100);
+        fakeJsonObject = new JSONObject();
+        fakeJsonObject.put("imptracker", new JSONArray("[\"url1\", \"url2\"]"));
+        fakeJsonObject.put("clktracker", "expected clicktracker");
+        nativeResponse = new NativeResponse(fakeJsonObject);
+        Robolectric.addPendingHttpResponse(new TestHttpResponse(200, ""));
+
+        // We need this to ensure that our SystemClock starts
+        ShadowSystemClock.uptimeMillis();
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        ImpressionTrackingManager.purgeViews();
+    }
+
+    @Ignore("pending")
+    @Test
+    public void start_shouldScheduleVisibilityCheck() throws Exception {
+        Robolectric.getBackgroundScheduler().pause();
+        assertThat(Robolectric.getBackgroundScheduler().enqueuedTaskCount()).isEqualTo(0);
+        ImpressionTrackingManager.start();
+        assertThat(Robolectric.getBackgroundScheduler().enqueuedTaskCount()).isEqualTo(1);
+    }
+
+    @Ignore("pending")
+    @Test
+    public void start_onSubsequentInvocations_shouldDoNothing() throws Exception {
+    }
+
+    @Ignore("pending")
+    @Test
+    public void stop_shouldCancelVisibilityChecks() throws Exception {
+    }
+
+    @Ignore("pending")
+    @Test
+    public void stop_beforeStartIsCalled_doesNothing() throws Exception {
+    }
+
+    @Test
+    public void addView_shouldAddViewToHashMap() throws Exception {
+        ImpressionTrackingManager.addView(view, nativeResponse, mopubNativeListener);
+        Map<View, NativeResponseWrapper> keptViews = ImpressionTrackingManager.getKeptViews();
+        assertThat(keptViews).hasSize(1);
+        assertThat(keptViews.get(view).mNativeResponse).isEqualTo(nativeResponse);
+    }
+
+    @Test
+    public void addView_whenViewIsNull_shouldNotAddView() throws Exception {
+        ImpressionTrackingManager.addView(null, nativeResponse, mopubNativeListener);
+        Map<View, NativeResponseWrapper> keptViews = ImpressionTrackingManager.getKeptViews();
+        assertThat(keptViews).isEmpty();
+    }
+
+    @Test
+    public void addView_whenNativeResponseIsNull_shouldNotAddView() throws Exception {
+        ImpressionTrackingManager.addView(view, null, mopubNativeListener);
+        Map<View, NativeResponseWrapper> keptViews = ImpressionTrackingManager.getKeptViews();
+        assertThat(keptViews).isEmpty();
+    }
+
+    @Test
+    public void removeView_shouldRemoveViewFromKeptViews() throws Exception {
+        View view1 = mock(View.class);
+        View view2 = mock(View.class);
+
+        ImpressionTrackingManager.addView(view1, nativeResponse, mopubNativeListener);
+        ImpressionTrackingManager.addView(view2, nativeResponse, mopubNativeListener);
+        assertThat(ImpressionTrackingManager.getKeptViews()).hasSize(2);
+
+        ImpressionTrackingManager.removeView(view2);
+        assertThat(ImpressionTrackingManager.getKeptViews()).hasSize(1);
+        assertThat(ImpressionTrackingManager.getKeptViews().keySet()).containsOnly(view1);
+    }
+
+    @Test
+    public void removeView_whenThereAreNoKeptViews_shouldDoNothing() throws Exception {
+        assertThat(ImpressionTrackingManager.getKeptViews()).isEmpty();
+
+        ImpressionTrackingManager.removeView(view);
+
+        assertThat(ImpressionTrackingManager.getKeptViews()).isEmpty();
+    }
+
+    @Test
+    public void removeView_whenViewIsNull_shouldDoNothing() throws Exception {
+        ImpressionTrackingManager.addView(view, nativeResponse, mopubNativeListener);
+
+        assertThat(ImpressionTrackingManager.getKeptViews()).hasSize(1);
+        ImpressionTrackingManager.removeView(null);
+        assertThat(ImpressionTrackingManager.getKeptViews()).hasSize(1);
+    }
+
+    @Test
+    public void visibilityCheckRun_whenWrapperIsNull_shouldNotTrackImpression() throws Exception {
+        ImpressionTrackingManager.addView(view, nativeResponse, mopubNativeListener);
+
+        // This doesn't normally happen; perhaps we're being overly defensive
+        ImpressionTrackingManager.getKeptViews().put(view, null);
+
+        new VisibilityCheck().run();
+        assertThat(nativeResponse.getRecordedImpression()).isFalse();
+        assertImpressionTracked(nativeResponse, false);
+    }
+
+    @Test
+    public void visibilityCheckRun_whenNativeResponseIsNull_shouldNotTrackImpression() throws Exception {
+        ImpressionTrackingManager.addView(view, nativeResponse, mopubNativeListener);
+
+        // This doesn't normally happen; perhaps we're being overly defensive
+        ImpressionTrackingManager.getKeptViews().put(view, new NativeResponseWrapper(null, null));
+
+        new VisibilityCheck().run();
+        assertThat(nativeResponse.getRecordedImpression()).isFalse();
+        assertImpressionTracked(nativeResponse, false);
+    }
+
+    @Test
+    public void visibilityCheckRun_whenNativeResponseHasRecordedImpression_shouldNotTrackImpression() throws Exception {
+        ImpressionTrackingManager.addView(view, nativeResponse, mopubNativeListener);
+        nativeResponse.recordImpression();
+        assertThat(nativeResponse.getRecordedImpression()).isTrue();
+
+        new VisibilityCheck().run();
+        assertImpressionTracked(nativeResponse, false);
+    }
+
+    @Test
+    public void visibilityCheckRun_whenViewIsInvisible_shouldNotTrackImpression() throws Exception {
+        view.setVisibility(View.INVISIBLE);
+        ImpressionTrackingManager.addView(view, nativeResponse, mopubNativeListener);
+
+        new VisibilityCheck().run();
+        assertThat(nativeResponse.getRecordedImpression()).isFalse();
+        assertImpressionTracked(nativeResponse, false);
+    }
+
+    @Test
+    public void visibilityCheckRun_whenLastViewedTimestampIsZero_shouldUpdateTimestampAndNotTrackImpression() throws Exception {
+        ImpressionTrackingManager.addView(view, nativeResponse, mopubNativeListener);
+
+        assertThat(ImpressionTrackingManager.getKeptViews().get(view).mFirstVisibleTimestamp).isEqualTo(0);
+
+        Robolectric.getUiThreadScheduler().advanceBy(111);
+        new VisibilityCheck().run();
+
+        assertThat(ImpressionTrackingManager.getKeptViews().get(view).mFirstVisibleTimestamp).isEqualTo(111);
+        assertThat(nativeResponse.getRecordedImpression()).isFalse();
+        assertImpressionTracked(nativeResponse, false);
+    }
+
+    @Test
+    public void visibilityCheckRun_whenLastViewedTimestampIsNotZeroAndLessThanOneSecondHasElapsed_shouldNotTrackImpression() throws Exception {
+        // Force the last viewed timestamp to be a known value
+        NativeResponseWrapper nativeResponseWrapper = new NativeResponseWrapper(nativeResponse, mopubNativeListener);
+        nativeResponseWrapper.mFirstVisibleTimestamp = 5555;
+        ImpressionTrackingManager.getKeptViews().put(view, nativeResponseWrapper);
+
+        // We progress 999 milliseconds
+        Robolectric.getUiThreadScheduler().advanceBy(5555 + 999);
+        new VisibilityCheck().run();
+
+        assertThat(nativeResponse.getRecordedImpression()).isFalse();
+        assertImpressionTracked(nativeResponse, false);
+    }
+
+    @Ignore("Review race condition")
+    @Test
+    public void visibilityCheckRun_whenLastViewedTimestampIsNotZeroAndMoreThanOneSecondHasElapsed_shouldTrackImpression() throws Exception {
+        // Force the last viewed timestamp to be a known value
+        NativeResponseWrapper nativeResponseWrapper = new NativeResponseWrapper(nativeResponse, mopubNativeListener);
+        nativeResponseWrapper.mFirstVisibleTimestamp = 5555;
+        ImpressionTrackingManager.getKeptViews().put(view, nativeResponseWrapper);
+
+        // We progress 1000 milliseconds
+        Robolectric.getUiThreadScheduler().advanceBy(5555 + 1000);
+        new VisibilityCheck().run();
+
+        assertThat(nativeResponse.getRecordedImpression()).isTrue();
+        assertImpressionTracked(nativeResponse, true);
+    }
+
+    @Test
+    public void isVisible_whenViewIsEntirelyOnScreen_shouldReturnTrue() throws Exception {
+        view = getViewMock(View.VISIBLE, 100, 100, 100, 100);
+
+        assertThat(VisibilityCheck.isVisible(view)).isTrue();
+    }
+
+    @Test
+    public void isVisible_whenViewIs50PercentVisible_shouldReturnTrue() throws Exception {
+        view = getViewMock(View.VISIBLE, 50, 100, 100, 100);
+
+        assertThat(VisibilityCheck.isVisible(view)).isTrue();
+    }
+
+    @Test
+    public void isVisible_whenViewIs49PercentVisible_shouldReturnFalse() throws Exception {
+        view = getViewMock(View.VISIBLE, 49, 100, 100, 100);
+
+        assertThat(VisibilityCheck.isVisible(view)).isFalse();
+    }
+
+    @Test
+    public void isVisible_whenVisibleAreaIsZero_shouldReturnFalse() throws Exception {
+        view = getViewMock(View.VISIBLE, 0, 0, 100, 100);
+
+        assertThat(VisibilityCheck.isVisible(view)).isFalse();
+    }
+
+    @Test
+    public void isVisible_whenViewIsInvisibleOrGone_shouldReturnFalse() throws Exception {
+        View view = getViewMock(View.INVISIBLE, 100, 100, 100, 100);
+        assertThat(VisibilityCheck.isVisible(view)).isFalse();
+
+        reset(view);
+        view = getViewMock(View.GONE, 100, 100, 100, 100);
+        assertThat(VisibilityCheck.isVisible(view)).isFalse();
+    }
+
+    @Test
+    public void isVisible_whenViewHasZeroWidthAndHeight_shouldReturnFalse() throws Exception {
+        view = getViewMock(View.VISIBLE, 100, 100, 0, 0);
+
+        assertThat(VisibilityCheck.isVisible(view)).isFalse();
+    }
+
+    @Test
+    public void isVisible_whenViewIsNull_shouldReturnFalse() throws Exception {
+        assertThat(VisibilityCheck.isVisible(null)).isFalse();
+    }
+
+    private View getViewMock(final int visibility,
+                             final int visibleWidth, final int visibleHeight,
+                             final int viewWidth, final int viewHeight) {
+        View view = mock(View.class);
+        when(view.getContext()).thenReturn(context);
+        when(view.getVisibility()).thenReturn(visibility);
+        when(view.getGlobalVisibleRect(any(Rect.class)))
+                .thenAnswer(new Answer<Boolean>() {
+                    @Override
+                    public Boolean answer(InvocationOnMock invocationOnMock) throws Throwable {
+                        Object[] args = invocationOnMock.getArguments();
+                        Rect rect = (Rect) args[0];
+                        rect.set(0, 0, visibleWidth, visibleHeight);
+                        return true;
+                    }
+                });
+        when(view.getWidth()).thenReturn(viewWidth);
+        when(view.getHeight()).thenReturn(viewHeight);
+
+        return view;
+    }
+
+    private void assertImpressionTracked(final NativeResponse nativeResponseMock, final boolean wasTracked) {
+        // Ensure that we fired off the HttpGets for each of the impression trackers
+        if (wasTracked) {
+            assertThat(Robolectric.getFakeHttpLayer().getSentHttpRequestInfos().size()).isEqualTo(1);
+            final String actualUri = Robolectric.getFakeHttpLayer().getLastSentHttpRequestInfo().getHttpRequest().getRequestLine().getUri();
+            assertThat(actualUri).isEqualTo(IMPRESSION_TRACKER);
+            verify(mopubNativeListener).onNativeImpression(view);
+        } else {
+            assertThat(Robolectric.getFakeHttpLayer().getLastSentHttpRequestInfo()).isNull();
+            verify(mopubNativeListener, never()).onNativeImpression(view);
+        }
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeTest.java
new file mode 100644
index 00000000..8e348801
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeTest.java
@@ -0,0 +1,128 @@
+package com.mopub.nativeads;
+
+import android.app.Activity;
+
+import com.mopub.common.GpsHelper;
+import com.mopub.common.GpsHelperTest;
+import com.mopub.common.SharedPreferencesHelper;
+import com.mopub.common.util.test.support.TestMethodBuilderFactory;
+import com.mopub.nativeads.test.support.SdkTestRunner;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+
+import java.util.concurrent.Semaphore;
+
+import static android.Manifest.permission.ACCESS_NETWORK_STATE;
+import static android.Manifest.permission.INTERNET;
+import static com.mopub.common.util.Reflection.MethodBuilder;
+import static com.mopub.nativeads.MoPubNative.MoPubNativeListener;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+import static org.robolectric.Robolectric.shadowOf;
+
+@RunWith(SdkTestRunner.class)
+public class MoPubNativeTest {
+    private MoPubNative subject;
+    private MethodBuilder methodBuilder;
+    private Activity context;
+    private RequestParameters requestParameters;
+    private MoPubNative.NativeGpsHelperListener nativeGpsHelperListener;
+    private Semaphore semaphore;
+    private static final String adUnitId = "test_adunit_id";
+
+    @Before
+    public void setup() {
+        context = new Activity();
+        shadowOf(context).grantPermissions(ACCESS_NETWORK_STATE);
+        shadowOf(context).grantPermissions(INTERNET);
+        requestParameters = new RequestParameters.Builder().build();
+        subject = new MoPubNative(context, adUnitId, mock(MoPubNativeListener.class));
+        methodBuilder = TestMethodBuilderFactory.getSingletonMock();
+        nativeGpsHelperListener = mock(MoPubNative.NativeGpsHelperListener.class);
+        semaphore = new Semaphore(0);
+        doAnswer(new Answer() {
+            @Override
+            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
+                semaphore.release();
+                return null;
+            }
+        }).when(nativeGpsHelperListener).onFetchAdInfoCompleted();
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        reset(methodBuilder);
+    }
+
+    @Ignore("fix concurrency issues")
+    @Test
+    public void makeRequest_whenGooglePlayServicesIsLinkedAndAdInfoIsNotCached_shouldCacheAdInfoBeforeFetchingAd() throws Exception {
+        SharedPreferencesHelper.getSharedPreferences(context).edit().clear().commit();
+        GpsHelperTest.verifyCleanSharedPreferences(context);
+
+        GpsHelper.setClassNamesForTesting();
+        GpsHelperTest.TestAdInfo adInfo = new GpsHelperTest.TestAdInfo();
+
+        when(methodBuilder.setStatic(any(Class.class))).thenReturn(methodBuilder);
+        when(methodBuilder.addParam(any(Class.class), any())).thenReturn(methodBuilder);
+        when(methodBuilder.execute()).thenReturn(
+                GpsHelper.GOOGLE_PLAY_SUCCESS_CODE,
+                adInfo,
+                adInfo.ADVERTISING_ID,
+                adInfo.LIMIT_AD_TRACKING_ENABLED
+        );
+
+        subject.makeRequest(requestParameters, nativeGpsHelperListener);
+        semaphore.acquire();
+
+        verify(nativeGpsHelperListener).onFetchAdInfoCompleted();
+        GpsHelperTest.verifySharedPreferences(context, adInfo);
+    }
+
+    @Test
+    public void loadAd_whenGooglePlayServicesIsNotLinked_shouldFetchAdFast() throws Exception {
+        SharedPreferencesHelper.getSharedPreferences(context).edit().clear().commit();
+        GpsHelperTest.verifyCleanSharedPreferences(context);
+
+        GpsHelper.setClassNamesForTesting();
+        when(methodBuilder.setStatic(any(Class.class))).thenReturn(methodBuilder);
+        when(methodBuilder.addParam(any(Class.class), any())).thenReturn(methodBuilder);
+        // return error code so it fails
+        when(methodBuilder.execute()).thenReturn(GpsHelper.GOOGLE_PLAY_SUCCESS_CODE + 1);
+
+        subject.makeRequest(requestParameters, nativeGpsHelperListener);
+        // no need to sleep since it run the callback without an async task
+
+        verify(nativeGpsHelperListener).onFetchAdInfoCompleted();
+        GpsHelperTest.verifyCleanSharedPreferences(context);
+    }
+
+    @Test
+    public void loadAd_whenGooglePlayServicesIsLinkedAndAdInfoIsCached_shouldFetchAdFast() throws Exception {
+        GpsHelperTest.TestAdInfo adInfo = new GpsHelperTest.TestAdInfo();
+        GpsHelperTest.populateAndVerifySharedPreferences(context, adInfo);
+        GpsHelper.setClassNamesForTesting();
+
+        when(methodBuilder.setStatic(any(Class.class))).thenReturn(methodBuilder);
+        when(methodBuilder.addParam(any(Class.class), any())).thenReturn(methodBuilder);
+        when(methodBuilder.execute()).thenReturn(
+                GpsHelper.GOOGLE_PLAY_SUCCESS_CODE
+        );
+
+        subject.makeRequest(requestParameters, nativeGpsHelperListener);
+        // no need to sleep since it run the callback without an async task
+
+        verify(nativeGpsHelperListener).onFetchAdInfoCompleted();
+        GpsHelperTest.verifySharedPreferences(context, adInfo);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdViewHelperTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdViewHelperTest.java
new file mode 100644
index 00000000..6dbb346e
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdViewHelperTest.java
@@ -0,0 +1,166 @@
+package com.mopub.nativeads;
+
+import android.app.Activity;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.Button;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.RelativeLayout;
+import android.widget.TextView;
+
+import com.mopub.common.util.Utils;
+import com.mopub.nativeads.test.support.SdkTestRunner;
+
+import org.json.JSONArray;
+import org.json.JSONObject;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+
+import static com.mopub.nativeads.MoPubNative.MoPubNativeListener;
+import static com.mopub.nativeads.NativeAdViewHelper.NativeViewClickListener;
+import static org.fest.assertions.api.Assertions.assertThat;
+
+@RunWith(SdkTestRunner.class)
+public class NativeAdViewHelperTest {
+    private Activity context;
+    private RelativeLayout relativeLayout;
+    private ViewGroup viewGroup;
+    private NativeResponse nativeResponse;
+    private ViewBinder viewBinder;
+    private MoPubNativeListener mopubNativeListener;
+    private JSONObject fakeJsonObject;
+    private TextView titleView;
+    private TextView textView;
+    private TextView callToActionView;
+    private ImageView mainImageView;
+    private ImageView iconImageView;
+
+    @Before
+    public void setUp() throws Exception {
+        context = new Activity();
+        relativeLayout = new RelativeLayout(context);
+        relativeLayout.setId((int) Utils.generateUniqueId());
+        viewGroup = new LinearLayout(context);
+
+        fakeJsonObject = new JSONObject();
+        fakeJsonObject.put("imptracker", new JSONArray("[\"url1\", \"url2\"]"));
+        fakeJsonObject.put("clktracker", "expected clicktracker");
+        nativeResponse = new NativeResponse(fakeJsonObject);
+
+        titleView = new TextView(context);
+        titleView.setId((int) Utils.generateUniqueId());
+        textView = new TextView(context);
+        textView.setId((int) Utils.generateUniqueId());
+        callToActionView = new Button(context);
+        callToActionView.setId((int) Utils.generateUniqueId());
+        mainImageView = new ImageView(context);
+        mainImageView.setId((int) Utils.generateUniqueId());
+        iconImageView = new ImageView(context);
+        iconImageView.setId((int) Utils.generateUniqueId());
+
+        relativeLayout.addView(titleView);
+        relativeLayout.addView(textView);
+        relativeLayout.addView(callToActionView);
+        relativeLayout.addView(mainImageView);
+        relativeLayout.addView(iconImageView);
+
+        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
+                .titleId(titleView.getId())
+                .textId(textView.getId())
+                .callToActionId(callToActionView.getId())
+                .mainImageId(mainImageView.getId())
+                .iconImageId(iconImageView.getId())
+                .build();
+    }
+
+    @After
+    public void tearDown() throws Exception {
+    }
+
+    @Test
+    public void getAdView_whenCallToActionIsAButton_shouldAttachClickListenersToConvertViewAndCtaButton() throws Exception {
+        assertThat(relativeLayout.performClick()).isFalse();
+        assertThat(callToActionView.performClick()).isFalse();
+        NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, nativeResponse, viewBinder, null);
+        assertThat(relativeLayout.performClick()).isTrue();
+        assertThat(callToActionView.performClick()).isTrue();
+    }
+
+    @Test
+    public void getAdView_whenCallToActionIsATextView_shouldAttachClickListenersToConvertViewOnly() throws Exception {
+        relativeLayout.removeView(callToActionView);
+        callToActionView = new TextView(context);
+        callToActionView.setId((int) Utils.generateUniqueId());
+        relativeLayout.addView(callToActionView);
+
+        assertThat(relativeLayout.performClick()).isFalse();
+        assertThat(callToActionView.performClick()).isFalse();
+
+        NativeAdViewHelper.getAdView(relativeLayout, viewGroup, context, nativeResponse, viewBinder, null);
+
+        assertThat(relativeLayout.performClick()).isTrue();
+        assertThat(callToActionView.performClick()).isFalse();
+    }
+
+    @Test
+    public void getOrCreateNativeViewHolder_withNoViewHolder_shouldCreateNativeViewHolder() throws Exception {
+        assertThat(ImageViewService.getViewTag(relativeLayout)).isNull();
+        NativeAdViewHelper.getOrCreateNativeViewHolder(relativeLayout, viewBinder);
+        final NativeViewHolder nativeViewHolder = NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
+        compareNativeViewHolders(nativeViewHolder, (NativeViewHolder) ImageViewService.getViewTag(relativeLayout));
+    }
+
+    @Test
+    public void getOrCreateNativeViewHolder_whenViewTagHasOtherObject_shouldCreateNativeViewHolder() throws Exception {
+        assertThat(ImageViewService.getViewTag(relativeLayout)).isNull();
+        ImageViewService.setViewTag(relativeLayout, new Object());
+        NativeAdViewHelper.getOrCreateNativeViewHolder(relativeLayout, viewBinder);
+        final NativeViewHolder nativeViewHolder = NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
+        compareNativeViewHolders(nativeViewHolder, (NativeViewHolder) ImageViewService.getViewTag(relativeLayout));
+    }
+
+    @Test
+    public void getOrCreateNativeViewHolder_whenViewTagHasNativeViewHolder_shouldNotCreateNativeViewHolder() throws Exception {
+        assertThat(ImageViewService.getViewTag(relativeLayout)).isNull();
+        final NativeViewHolder nativeViewHolder = NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
+        ImageViewService.setViewTag(relativeLayout, nativeViewHolder);
+        NativeAdViewHelper.getOrCreateNativeViewHolder(relativeLayout, viewBinder);
+        assertThat(ImageViewService.getViewTag(relativeLayout)).isEqualTo(nativeViewHolder);
+    }
+
+    @Test
+    public void onClick_shouldQueueClickTrackerAndUrlResolutionTasks() throws Exception {
+        NativeViewClickListener nativeViewClickListener = new NativeViewClickListener(context, "clickTrackerUrl", "destinationUrl", null);
+
+        Robolectric.getBackgroundScheduler().pause();
+        assertThat(Robolectric.getBackgroundScheduler().enqueuedTaskCount()).isEqualTo(0);
+        nativeViewClickListener.onClick(new View(context));
+
+        assertThat(Robolectric.getBackgroundScheduler().enqueuedTaskCount()).isEqualTo(2);
+    }
+
+    @Test
+    public void onClick_withNullDestinationUrl_shouldNotQueueUrlResolutionTask() throws Exception {
+        NativeViewClickListener nativeViewClickListener = new NativeViewClickListener(context, "clickTrackerUrl", null, null);
+
+        Robolectric.getBackgroundScheduler().pause();
+        assertThat(Robolectric.getBackgroundScheduler().enqueuedTaskCount()).isEqualTo(0);
+        nativeViewClickListener.onClick(new View(context));
+
+        // 1 task for async ping to click tracker
+        assertThat(Robolectric.getBackgroundScheduler().enqueuedTaskCount()).isEqualTo(1);
+    }
+
+    static private void compareNativeViewHolders(final NativeViewHolder nativeViewHolder1,
+                                                 final NativeViewHolder nativeViewHolder2) {
+        assertThat(nativeViewHolder1.titleView).isEqualTo(nativeViewHolder2.titleView);
+        assertThat(nativeViewHolder1.textView).isEqualTo(nativeViewHolder2.textView);
+        assertThat(nativeViewHolder1.callToActionView).isEqualTo(nativeViewHolder2.callToActionView);
+        assertThat(nativeViewHolder1.mainImageView).isEqualTo(nativeViewHolder2.mainImageView);
+        assertThat(nativeViewHolder1.iconImageView).isEqualTo(nativeViewHolder2.iconImageView);
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeResponseTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeResponseTest.java
new file mode 100644
index 00000000..9bb3abb9
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeResponseTest.java
@@ -0,0 +1,269 @@
+package com.mopub.nativeads;
+
+import com.mopub.mobileads.test.support.SdkTestRunner;
+
+import org.json.JSONArray;
+import org.json.JSONObject;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+
+import static com.mopub.nativeads.NativeResponse.Parameter;
+import static com.mopub.nativeads.NativeResponse.Parameter.requiredKeys;
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.fest.assertions.api.Assertions.fail;
+
+@RunWith(SdkTestRunner.class)
+public class NativeResponseTest {
+
+    private JSONObject fakeJsonObject;
+    private NativeResponse subject;
+
+    @Before
+    public void setUp() throws Exception {
+        fakeJsonObject = new JSONObject();
+        fakeJsonObject.put("imptracker", new JSONArray("[\"url1\", \"url2\"]"));
+        fakeJsonObject.put("clktracker", "expected clicktracker");
+    }
+
+    @Test
+    public void parameter_requiredKeys_shouldOnlyContainTheRequiredKeys() throws Exception {
+        final HashSet<String> expectedKeys = new HashSet<String>();
+        expectedKeys.add("imptracker");
+        expectedKeys.add("clktracker");
+
+        assertThat(requiredKeys).isEqualTo(expectedKeys);
+    }
+
+    @Test
+    public void parameter_fromString_shouldReturnParameterOnMatch() throws Exception {
+        final Parameter parameter = Parameter.from("title");
+
+        assertThat(parameter).isEqualTo(Parameter.TITLE);
+    }
+
+    @Test
+    public void parameter_fromString_shouldReturnNullOnIllegalKey() throws Exception {
+        final Parameter parameter = Parameter.from("random gibberish");
+
+        assertThat(parameter).isNull();
+    }
+
+    @Test
+    public void constructor_whenMissingRequiredKeys_shouldThrowIllegalArgumentException() throws Exception {
+        fakeJsonObject.remove("imptracker");
+
+        try {
+            subject = new NativeResponse(fakeJsonObject);
+            fail("Expected IllegalArgumentException");
+        } catch (IllegalArgumentException e) {
+            // pass
+        }
+    }
+
+    @Test
+    public void constructor_whenExpectedKeyOfWrongType_shouldThrowIllegalArgumentException() throws Exception {
+        fakeJsonObject.put("clktracker", 100);
+
+        try {
+            subject = new NativeResponse(fakeJsonObject);
+            fail("Expected IllegalArgumentException");
+        } catch (IllegalArgumentException e) {
+            // pass
+        }
+    }
+
+    @Test
+    public void constructor_shouldSetRequiredExpectedFields() throws Exception {
+        subject = new NativeResponse(fakeJsonObject);
+
+        assertThat(subject.getImpressionTrackers()).containsOnly("url1", "url2");
+        assertThat(subject.getClickTracker()).isEqualTo("expected clicktracker");
+    }
+
+    @Test
+    public void constructor_shouldSetOptionalExpectedFields() throws Exception {
+        fakeJsonObject.put("title", "expected title");
+        fakeJsonObject.put("text", "expected text");
+        fakeJsonObject.put("mainimage", "expected mainimage");
+        fakeJsonObject.put("iconimage", "expected iconimage");
+
+        fakeJsonObject.put("clk", "expected clk");
+
+        fakeJsonObject.put("fallback", "expected fallback");
+        fakeJsonObject.put("ctatext", "expected ctatext");
+        fakeJsonObject.put("starrating", 5.0);
+
+        subject = new NativeResponse(fakeJsonObject);
+
+        assertThat(subject.getTitle()).isEqualTo("expected title");
+        assertThat(subject.getSubtitle()).isEqualTo("expected text");
+        assertThat(subject.getMainImageUrl()).isEqualTo("expected mainimage");
+        assertThat(subject.getIconImageUrl()).isEqualTo("expected iconimage");
+
+        assertThat(subject.getClickDestinationUrl()).isEqualTo("expected clk");
+
+//        assertThat(subject.getFallback()).isEqualTo("expected fallback");
+        assertThat(subject.getImpressionTrackers()).containsOnly("url1", "url2");
+        assertThat(subject.getClickTracker()).isEqualTo("expected clicktracker");
+        assertThat(subject.getCallToAction()).isEqualTo("expected ctatext");
+//        assertThat(subject.getStarRating()).isEqualTo(5.0);
+    }
+
+    @Test
+    public void constructor_whenImpressionTrackersIsNotJSONArray_shouldThrowIllegalArgumentException() throws Exception {
+        // An array list is not the same thing as a JSONArray
+        final List<String> impressionTrackers = new ArrayList<String>();
+        impressionTrackers.add("url1");
+        impressionTrackers.add("url2");
+        fakeJsonObject.put("imptracker", impressionTrackers);
+
+        try {
+            subject = new NativeResponse(fakeJsonObject);
+            fail("Expected constructor to throw an IllegalArgumentException");
+        } catch (IllegalArgumentException e) {
+            // pass
+        }
+    }
+
+    @Test
+    public void constructor_whenImpressionTrackersContainsNonStrings_willCoerceToString() throws Exception {
+        /**
+         * At this level of abstraction, we don't actually care that these Strings resolve to valid
+         * URLs. We just want to ensure that the constructor does not throw an exception.
+         */
+        final JSONArray impressionTrackers = new JSONArray();
+        impressionTrackers.put("url1");
+        impressionTrackers.put(JSONObject.NULL);
+        impressionTrackers.put(2.12);
+        fakeJsonObject.put("imptracker", impressionTrackers);
+
+        subject = new NativeResponse(fakeJsonObject);
+
+        assertThat(subject.getImpressionTrackers()).containsOnly("url1", "null", "2.12");
+    }
+
+    @Test
+    public void constructor_shouldSetExtraFields() throws Exception {
+        List<Object> array = new ArrayList<Object>();
+        array.add("index1");
+        array.add(-10);
+
+        Map<String, Object> map = new HashMap<String, Object>();
+        map.put("one", "a");
+        map.put("two", "b");
+
+        fakeJsonObject.put("key1", "yay json");
+        fakeJsonObject.put("key2", 5);
+        fakeJsonObject.put("key3", new JSONArray(array));
+        fakeJsonObject.put("key4", new JSONObject(map));
+
+        subject = new NativeResponse(fakeJsonObject);
+
+        assertThat(subject.getExtra("key1")).isEqualTo("yay json");
+        assertThat(subject.getExtra("key2")).isEqualTo(5);
+        assertThat((JSONArray) subject.getExtra("key3")).isEqualsToByComparingFields(new JSONArray(array));
+        assertThat((JSONObject) subject.getExtra("key4")).isEqualsToByComparingFields(new JSONObject(map));
+    }
+
+    @Test
+    public void getExtrasImageUrls_whenNoExtras_shouldReturnEmptyList() throws Exception {
+        subject = new NativeResponse(fakeJsonObject);
+
+        assertThat(subject.getExtrasImageUrls()).isEmpty();
+    }
+
+    @Test
+    public void getExtrasImageUrls_whenExtrasDoesNotContainImageKeys_shouldReturnEmptyList() throws Exception {
+        // getExtrasImageUrls requires the key to end with a case-insensitive "image" to be counted as an image
+        fakeJsonObject.put("imageAtFront", "ignored");
+        fakeJsonObject.put("middle_image_in_key", "ignored");
+        fakeJsonObject.put("other", "ignored");
+
+        subject = new NativeResponse(fakeJsonObject);
+
+        assertThat(subject.getExtrasImageUrls()).isEmpty();
+    }
+
+    @Test
+    public void getExtrasImageUrls_whenExtrasContainsImages_shouldReturnImageUrls() throws Exception {
+        // getExtrasImageUrls requires the key to end with a case-insensitive "image" to be counted as an image
+        fakeJsonObject.put("test_image", "image_url_1");
+        fakeJsonObject.put("filler", "ignored");
+        fakeJsonObject.put("otherIMAGE", "image_url_2");
+        fakeJsonObject.put("more filler", "ignored");
+        fakeJsonObject.put("lastimage", "image_url_3");
+
+        subject = new NativeResponse(fakeJsonObject);
+
+        assertThat(subject.getExtrasImageUrls()).containsOnly("image_url_1", "image_url_2", "image_url_3");
+    }
+
+    @Ignore("pending")
+    @Test
+    public void loadExtrasImage_shouldAsyncLoadImages() throws Exception {
+        // no easy way to test this since nothing can be mocked
+        // also not a critical test since it directly calls another service
+    }
+
+    @Test
+    public void getAllImageUrls_withNoExtraImages_shouldReturnEmptyList() throws Exception {
+        subject = new NativeResponse(fakeJsonObject);
+
+        assertThat(subject.getAllImageUrls()).isEmpty();
+    }
+
+    @Test
+    public void getAllImageUrls_withExtraImagesAndMainAndIconImages_shouldIncludeThemAlongWithMainAndIconImageUrls() throws Exception {
+        fakeJsonObject.put("mainimage", "expected mainimage");
+        fakeJsonObject.put("iconimage", "expected iconimage");
+
+        fakeJsonObject.put("extra1_image", "expected extra1_image");
+        fakeJsonObject.put("extra2_image", "expected extra2_image");
+
+        subject = new NativeResponse(fakeJsonObject);
+
+        assertThat(subject.getAllImageUrls()).containsOnly(
+                "expected mainimage",
+                "expected iconimage",
+                "expected extra1_image",
+                "expected extra2_image"
+        );
+    }
+
+    @Test
+    public void getAllImageUrls_withOnlyExtrasImages_shouldNotIncludeMainOrIconImages() throws Exception {
+        fakeJsonObject.put("extra1_image", "expected extra1_image");
+        fakeJsonObject.put("extra2_image", "expected extra2_image");
+
+        subject = new NativeResponse(fakeJsonObject);
+
+        assertThat(subject.getAllImageUrls()).containsOnly("expected extra1_image", "expected extra2_image");
+    }
+
+    @Test
+    public void recordImpression_shouldSaveImpressionStateWithIdempotence() throws Exception {
+        subject = new NativeResponse(fakeJsonObject);
+        assertThat(subject.getRecordedImpression()).isFalse();
+
+        subject.recordImpression();
+        assertThat(subject.getRecordedImpression()).isTrue();
+
+        subject.recordImpression();
+        assertThat(subject.getRecordedImpression()).isTrue();
+    }
+
+    @Ignore("pending")
+    @Test
+    public void loadMainAndIconImages_shouldAsyncLoadImages() throws Exception {
+        // no easy way to test this since nothing can be mocked
+        // also not a critical test since it directly calls another service
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/NativeViewHolderTest.java b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeViewHolderTest.java
new file mode 100644
index 00000000..0311a18e
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/NativeViewHolderTest.java
@@ -0,0 +1,319 @@
+package com.mopub.nativeads;
+
+import android.app.Activity;
+import android.content.Context;
+import android.view.ViewGroup;
+import android.widget.Button;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.RelativeLayout;
+import android.widget.TextView;
+
+import com.mopub.common.util.Utils;
+import com.mopub.nativeads.test.support.SdkTestRunner;
+
+import org.json.JSONArray;
+import org.json.JSONObject;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.fest.assertions.api.Assertions.assertThat;
+import static org.robolectric.Robolectric.shadowOf;
+
+@RunWith(SdkTestRunner.class)
+public class NativeViewHolderTest {
+    private Context context;
+    private RelativeLayout relativeLayout;
+    private ViewGroup viewGroup;
+    private NativeResponse nativeResponse;
+    private ViewBinder viewBinder;
+    private MoPubNative.MoPubNativeListener mopubNativeListener;
+    private JSONObject fakeJsonObject;
+    private TextView titleView;
+    private TextView textView;
+    private TextView callToActionView;
+    private ImageView mainImageView;
+    private ImageView iconImageView;
+    private TextView extrasTextView;
+    private ImageView extrasImageView;
+
+    @Before
+    public void setUp() throws Exception {
+        context = new Activity();
+        relativeLayout = new RelativeLayout(context);
+        relativeLayout.setId((int) Utils.generateUniqueId());
+        viewGroup = new LinearLayout(context);
+
+        fakeJsonObject = new JSONObject();
+
+        // Only mandatory json fields
+        fakeJsonObject.put("imptracker", new JSONArray("[\"url1\", \"url2\"]"));
+        fakeJsonObject.put("clktracker", "expected clicktracker");
+
+        // Fields in the web ui
+        titleView = new TextView(context);
+        titleView.setId((int) Utils.generateUniqueId());
+        textView = new TextView(context);
+        textView.setId((int) Utils.generateUniqueId());
+        callToActionView = new Button(context);
+        callToActionView.setId((int) Utils.generateUniqueId());
+        mainImageView = new ImageView(context);
+        mainImageView.setId((int) Utils.generateUniqueId());
+        iconImageView = new ImageView(context);
+        iconImageView.setId((int) Utils.generateUniqueId());
+
+        // Extras
+        extrasTextView = new TextView(context);
+        extrasTextView.setId((int) Utils.generateUniqueId());
+        extrasImageView = new ImageView(context);
+        extrasImageView.setId((int) Utils.generateUniqueId());
+
+        relativeLayout.addView(titleView);
+        relativeLayout.addView(textView);
+        relativeLayout.addView(callToActionView);
+        relativeLayout.addView(mainImageView);
+        relativeLayout.addView(iconImageView);
+        relativeLayout.addView(extrasTextView);
+        relativeLayout.addView(extrasImageView);
+    }
+
+    @After
+    public void tearDown() throws Exception {
+    }
+
+    @Test
+    public void fromViewBinder_shouldPopulateClassFields() throws Exception {
+        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
+                .titleId(titleView.getId())
+                .textId(textView.getId())
+                .callToActionId(callToActionView.getId())
+                .mainImageId(mainImageView.getId())
+                .iconImageId(iconImageView.getId())
+                .build();
+
+        NativeViewHolder nativeViewHolder =
+                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
+
+        assertThat(nativeViewHolder.titleView).isEqualTo(titleView);
+        assertThat(nativeViewHolder.textView).isEqualTo(textView);
+        assertThat(nativeViewHolder.callToActionView).isEqualTo(callToActionView);
+        assertThat(nativeViewHolder.mainImageView).isEqualTo(mainImageView);
+        assertThat(nativeViewHolder.iconImageView).isEqualTo(iconImageView);
+    }
+
+    @Test
+    public void fromViewBinder_withSubsetOfFields_shouldLeaveOtherFieldsNull() throws Exception {
+        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
+                .titleId(titleView.getId())
+                .iconImageId(iconImageView.getId())
+                .build();
+
+        NativeViewHolder nativeViewHolder =
+                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
+
+        assertThat(nativeViewHolder.titleView).isEqualTo(titleView);
+        assertThat(nativeViewHolder.textView).isNull();
+        assertThat(nativeViewHolder.callToActionView).isNull();
+        assertThat(nativeViewHolder.mainImageView).isNull();
+        assertThat(nativeViewHolder.iconImageView).isEqualTo(iconImageView);
+    }
+
+    @Test
+    public void fromViewBinder_withNonExistantIds_shouldLeaveFieldsNull() throws Exception {
+        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
+                .titleId((int) Utils.generateUniqueId())
+                .textId((int) Utils.generateUniqueId())
+                .callToActionId((int) Utils.generateUniqueId())
+                .mainImageId((int) Utils.generateUniqueId())
+                .iconImageId((int) Utils.generateUniqueId())
+                .build();
+
+        NativeViewHolder nativeViewHolder =
+                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
+
+        assertThat(nativeViewHolder.titleView).isNull();
+        assertThat(nativeViewHolder.textView).isNull();
+        assertThat(nativeViewHolder.callToActionView).isNull();
+        assertThat(nativeViewHolder.mainImageView).isNull();
+        assertThat(nativeViewHolder.iconImageView).isNull();
+    }
+
+    @Test
+    public void update_shouldAddValuesToViews() throws Exception {
+        // Setup for cache state for image gets
+        CacheService.initializeCaches(context);
+        CacheService.putToMemoryCache("mainimageurl", "mainimagedata".getBytes());
+        CacheService.putToMemoryCache("iconimageurl", "iconimagedata".getBytes());
+
+        fakeJsonObject.put("title", "titletext");
+        fakeJsonObject.put("text", "texttext");
+        fakeJsonObject.put("mainimage", "mainimageurl");
+        fakeJsonObject.put("iconimage", "iconimageurl");
+        fakeJsonObject.put("ctatext", "cta");
+        nativeResponse = new NativeResponse(fakeJsonObject);
+
+        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
+                .titleId(titleView.getId())
+                .textId(textView.getId())
+                .callToActionId(callToActionView.getId())
+                .mainImageId(mainImageView.getId())
+                .iconImageId(iconImageView.getId())
+                .build();
+
+        NativeViewHolder nativeViewHolder =
+                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
+
+        nativeViewHolder.update(nativeResponse);
+
+        assertThat(titleView.getText()).isEqualTo("titletext");
+        assertThat(textView.getText()).isEqualTo("texttext");
+        assertThat(callToActionView.getText()).isEqualTo("cta");
+        assertThat(shadowOf(ImageViewServiceTest.getBitmapFromImageView(mainImageView))
+                .getCreatedFromBytes()).isEqualTo("mainimagedata".getBytes());
+        assertThat(shadowOf(ImageViewServiceTest.getBitmapFromImageView(iconImageView))
+                .getCreatedFromBytes()).isEqualTo("iconimagedata".getBytes());
+    }
+
+    @Test
+    public void update_withMissingNativeResponseFields_shouldClearPreviousValues() throws Exception {
+        // Set previous values that should be cleared
+        titleView.setText("previoustitletext");
+        textView.setText("previoustexttext");
+        callToActionView.setText("previousctatext");
+        mainImageView.setImageBitmap(ImageService.byteArrayToBitmap("previousmainimagedata".getBytes()));
+        iconImageView.setImageBitmap(ImageService.byteArrayToBitmap("previousiconimagedata".getBytes()));
+
+        // Only required fields in native response
+        nativeResponse = new NativeResponse(fakeJsonObject);
+
+        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
+                .titleId(titleView.getId())
+                .textId(textView.getId())
+                .callToActionId(callToActionView.getId())
+                .mainImageId(mainImageView.getId())
+                .iconImageId(iconImageView.getId())
+                .build();
+
+        NativeViewHolder nativeViewHolder =
+                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
+
+        nativeViewHolder.update(nativeResponse);
+
+        assertThat(titleView.getText()).isEqualTo("");
+        assertThat(textView.getText()).isEqualTo("");
+        assertThat(callToActionView.getText()).isEqualTo("");
+        assertThat(mainImageView.getDrawable()).isNull();
+        assertThat(iconImageView.getDrawable()).isNull();
+    }
+
+    @Test
+    public void update_withDifferentViewBinder_shouldNotClearPreviousValues() throws Exception {
+        // Set previous values that should be cleared
+        titleView.setText("previoustitletext");
+        textView.setText("previoustexttext");
+
+        fakeJsonObject.put("ctatext", "cta");
+        nativeResponse = new NativeResponse(fakeJsonObject);
+
+        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
+                .callToActionId(callToActionView.getId())
+                .build();
+
+        NativeViewHolder nativeViewHolder =
+                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
+
+        nativeViewHolder.update(nativeResponse);
+
+        assertThat(titleView.getText()).isEqualTo("previoustitletext");
+        assertThat(textView.getText()).isEqualTo("previoustexttext");
+        assertThat(callToActionView.getText()).isEqualTo("cta");
+    }
+
+    @Test
+    public void updateExtras_shouldAddValuesToViews() throws Exception {
+        // Setup for cache state for image gets
+        CacheService.initializeCaches(context);
+        CacheService.putToMemoryCache("extrasimageurl", "extrasimagedata".getBytes());
+
+        fakeJsonObject.put("extrastext", "extrastexttext");
+        fakeJsonObject.put("extrasimage", "extrasimageurl");
+        nativeResponse = new NativeResponse(fakeJsonObject);
+
+        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
+                .addExtra("extrastext", extrasTextView.getId())
+                .addExtra("extrasimage", extrasImageView.getId())
+                .build();
+
+        NativeViewHolder nativeViewHolder =
+                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
+
+        nativeViewHolder.updateExtras(relativeLayout, nativeResponse, viewBinder);
+
+        assertThat(extrasTextView.getText()).isEqualTo("extrastexttext");
+        assertThat(shadowOf(ImageViewServiceTest.getBitmapFromImageView(extrasImageView))
+                .getCreatedFromBytes()).isEqualTo("extrasimagedata".getBytes());
+    }
+
+    @Test
+    public void updateExtras_withMissingExtrasValues_shouldClearPreviousValues() throws Exception {
+        extrasTextView.setText("previousextrastext");
+        extrasImageView.setImageBitmap(ImageService.byteArrayToBitmap("previousextrasimagedata".getBytes()));
+
+        nativeResponse = new NativeResponse(fakeJsonObject);
+
+        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
+                .addExtra("extrastext", extrasTextView.getId())
+                .addExtra("extrasimage", extrasImageView.getId())
+                .build();
+
+        NativeViewHolder nativeViewHolder =
+                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
+
+        assertThat(extrasTextView.getText()).isEqualTo("previousextrastext");
+        assertThat(shadowOf(ImageViewServiceTest.getBitmapFromImageView(extrasImageView))
+                .getCreatedFromBytes()).isEqualTo("previousextrasimagedata".getBytes());
+
+        nativeViewHolder.updateExtras(relativeLayout, nativeResponse, viewBinder);
+
+        assertThat(extrasTextView.getText()).isEqualTo("");
+        assertThat(extrasImageView.getDrawable()).isNull();
+    }
+
+    @Test
+    public void updateExtras_withMismatchingViewTypes_shouldNotSetValues() throws Exception {
+        fakeJsonObject.put("extrastext", "extrastexttext");
+        fakeJsonObject.put("extrasimage", "extrasimageurl");
+        nativeResponse = new NativeResponse(fakeJsonObject);
+
+        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
+                .addExtra("extrastext", extrasImageView.getId())
+                .addExtra("extrasimage", extrasTextView.getId())
+                .build();
+
+        NativeViewHolder nativeViewHolder =
+                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
+
+        assertThat(extrasTextView.getText()).isEqualTo("");
+        assertThat(extrasImageView.getDrawable()).isNull();
+
+        nativeViewHolder.updateExtras(relativeLayout, nativeResponse, viewBinder);
+
+        assertThat(extrasTextView.getText()).isEqualTo("");
+        assertThat(extrasImageView.getDrawable()).isNull();
+    }
+
+    @Test
+    public void fromViewBinder_withMixedViewTypes_shouldReturnNull() throws Exception {
+        viewBinder = new ViewBinder.Builder(relativeLayout.getId())
+                .titleId(mainImageView.getId())
+                .textId(textView.getId())
+                .build();
+
+        NativeViewHolder nativeViewHolder =
+                NativeViewHolder.fromViewBinder(relativeLayout, viewBinder);
+
+        assertThat(nativeViewHolder).isNull();
+    }
+}
diff --git a/mopub-sdk/src/test/java/com/mopub/nativeads/test/support/SdkTestRunner.java b/mopub-sdk/src/test/java/com/mopub/nativeads/test/support/SdkTestRunner.java
new file mode 100644
index 00000000..ba31ed34
--- /dev/null
+++ b/mopub-sdk/src/test/java/com/mopub/nativeads/test/support/SdkTestRunner.java
@@ -0,0 +1,30 @@
+package com.mopub.nativeads.test.support;
+
+import com.mopub.common.factories.MethodBuilderFactory;
+import com.mopub.common.util.test.support.TestMethodBuilderFactory;
+
+import org.junit.runners.model.InitializationError;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.DefaultTestLifecycle;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.TestLifecycle;
+
+public class SdkTestRunner extends RobolectricTestRunner {
+
+    public SdkTestRunner(Class<?> testClass) throws InitializationError {
+        super(testClass);
+    }
+
+    @Override
+    protected Class<? extends TestLifecycle> getTestLifecycleClass() {
+        return TestLifeCycleWithInjection.class;
+    }
+
+    public static class TestLifeCycleWithInjection extends DefaultTestLifecycle {
+        @Override
+        public void prepareTest(Object test) {
+            MethodBuilderFactory.setInstance(new TestMethodBuilderFactory());
+            MockitoAnnotations.initMocks(test);
+        }
+    }
+}
diff --git a/more b/more
new file mode 100644
index 00000000..6a23f99c
--- /dev/null
+++ b/more
@@ -0,0 +1,182 @@
+# On branch master
+# You have unmerged paths.
+#   (fix conflicts and run "git commit")
+#
+# Changes to be committed:
+#
+#	deleted:    .idea/libraries/support_v4_19_1_0.xml
+#	modified:   CHANGELOG.md
+#	modified:   README.md
+#	modified:   extras/src/com/mopub/mobileads/GoogleAdMobBanner.java
+#	modified:   extras/src/com/mopub/mobileads/GooglePlayServicesBanner.java
+#	modified:   extras/src/com/mopub/mobileads/InMobiBanner.java
+#	modified:   mopub-sample/AndroidManifest.xml
+#	modified:   mopub-sample/pom.xml
+#	modified:   mopub-sample/project.properties
+#	new file:   mopub-sample/res/layout/empty_ad_row.xml
+#	modified:   mopub-sample/res/layout/main.xml
+#	new file:   mopub-sample/res/layout/native_ad_row.xml
+#	new file:   mopub-sample/res/layout/nativetab.xml
+#	new file:   mopub-sample/res/layout/text_row.xml
+#	renamed:    mopub-sample/src/main/java/com/mopub/simpleadsdemo/AboutTab.java -> mopub-sample/src/main/java/com/mopub/simpleadsdemo/AboutFragment.java
+#	renamed:    mopub-sample/src/main/java/com/mopub/simpleadsdemo/BannersTab.java -> mopub-sample/src/main/java/com/mopub/simpleadsdemo/BannersFragment.java
+#	renamed:    mopub-sample/src/main/java/com/mopub/simpleadsdemo/InterstitialsTab.java -> mopub-sample/src/main/java/com/mopub/simpleadsdemo/InterstitialFragment.java
+#	new file:   mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeAdapter.java
+#	new file:   mopub-sample/src/main/java/com/mopub/simpleadsdemo/NativeFragment.java
+#	modified:   mopub-sample/src/main/java/com/mopub/simpleadsdemo/SimpleAdsDemo.java
+#	new file:   mopub-sdk/scripts/mavenize_support_library
+#	renamed:    mopub-sdk/src/main/java/com/mopub/mobileads/AdUrlGenerator.java -> mopub-sdk/src/main/java/com/mopub/common/AdUrlGenerator.java
+#	renamed:    mopub-sdk/src/main/java/com/mopub/mobileads/BaseUrlGenerator.java -> mopub-sdk/src/main/java/com/mopub/common/BaseUrlGenerator.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/common/GpsHelper.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/common/LocationService.java
+#	renamed:    mopub-sdk/src/main/java/com/mopub/mobileads/MoPub.java -> mopub-sdk/src/main/java/com/mopub/common/MoPub.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/common/MoPubBrowser.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/common/SharedPreferencesHelper.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/common/factories/MethodBuilderFactory.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/common/util/AsyncTasks.java
+#	renamed:    mopub-sdk/src/main/java/com/mopub/mobileads/util/DateAndTime.java -> mopub-sdk/src/main/java/com/mopub/common/util/DateAndTime.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/common/util/DeviceUtils.java
+#	renamed:    mopub-sdk/src/main/java/com/mopub/mobileads/util/Dips.java -> mopub-sdk/src/main/java/com/mopub/common/util/Dips.java
+#	renamed:    mopub-sdk/src/main/java/com/mopub/mobileads/resource/Drawables.java -> mopub-sdk/src/main/java/com/mopub/common/util/Drawables.java
+#	renamed:    mopub-sdk/src/main/java/com/mopub/mobileads/util/Files.java -> mopub-sdk/src/main/java/com/mopub/common/util/Files.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/common/util/IntentUtils.java
+#	renamed:    mopub-sdk/src/main/java/com/mopub/mobileads/util/Reflection.java -> mopub-sdk/src/main/java/com/mopub/common/util/Reflection.java
+#	renamed:    mopub-sdk/src/main/java/com/mopub/mobileads/util/Streams.java -> mopub-sdk/src/main/java/com/mopub/common/util/Streams.java
+#	renamed:    mopub-sdk/src/main/java/com/mopub/mobileads/util/Strings.java -> mopub-sdk/src/main/java/com/mopub/common/util/Strings.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/common/util/Utils.java
+#	renamed:    mopub-sdk/src/main/java/com/mopub/mobileads/util/VersionCode.java -> mopub-sdk/src/main/java/com/mopub/common/util/VersionCode.java
+#	renamed:    mopub-sdk/src/main/java/com/mopub/mobileads/util/Views.java -> mopub-sdk/src/main/java/com/mopub/common/util/Views.java
+#	modified:   mopub-sdk/src/main/java/com/mopub/mobileads/AdAlertReporter.java
+#	modified:   mopub-sdk/src/main/java/com/mopub/mobileads/AdConfiguration.java
+#	modified:   mopub-sdk/src/main/java/com/mopub/mobileads/AdFetcher.java
+#	modified:   mopub-sdk/src/main/java/com/mopub/mobileads/AdLoadTask.java
+#	modified:   mopub-sdk/src/main/java/com/mopub/mobileads/AdTypeTranslator.java
+#	modified:   mopub-sdk/src/main/java/com/mopub/mobileads/AdViewController.java
+#	modified:   mopub-sdk/src/main/java/com/mopub/mobileads/BaseHtmlWebView.java
+#	modified:   mopub-sdk/src/main/java/com/mopub/mobileads/BaseInterstitialActivity.java
+#	modified:   mopub-sdk/src/main/java/com/mopub/mobileads/BaseWebView.java
+#	modified:   mopub-sdk/src/main/java/com/mopub/mobileads/DiskLruCache.java
+#	modified:   mopub-sdk/src/main/java/com/mopub/mobileads/HtmlInterstitialWebView.java
+#	modified:   mopub-sdk/src/main/java/com/mopub/mobileads/HtmlWebViewClient.java
+#	renamed:    mopub-sdk/src/main/java/com/mopub/mobileads/MraidBrowserController.java -> mopub-sdk/src/main/java/com/mopub/mobileads/MoPubBrowserController.java
+#	modified:   mopub-sdk/src/main/java/com/mopub/mobileads/MoPubConversionTracker.java
+#	modified:   mopub-sdk/src/main/java/com/mopub/mobileads/MoPubInterstitial.java
+#	modified:   mopub-sdk/src/main/java/com/mopub/mobileads/MoPubView.java
+#	modified:   mopub-sdk/src/main/java/com/mopub/mobileads/MraidActivity.java
+#	deleted:    mopub-sdk/src/main/java/com/mopub/mobileads/MraidBrowser.java
+#	modified:   mopub-sdk/src/main/java/com/mopub/mobileads/MraidDisplayController.java
+#	modified:   mopub-sdk/src/main/java/com/mopub/mobileads/MraidView.java
+#	deleted:    mopub-sdk/src/main/java/com/mopub/mobileads/Utils.java
+#	modified:   mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoDownloadTask.java
+#	modified:   mopub-sdk/src/main/java/com/mopub/mobileads/VastVideoView.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/mobileads/WebViewAdUrlGenerator.java
+#	deleted:    mopub-sdk/src/main/java/com/mopub/mobileads/util/AsyncTasks.java
+#	modified:   mopub-sdk/src/main/java/com/mopub/mobileads/util/Mraids.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/mobileads/util/Utils.java
+#	modified:   mopub-sdk/src/main/java/com/mopub/mobileads/util/vast/VastManager.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/nativeads/AdapterHelper.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/nativeads/CacheService.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/nativeads/Constants.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/nativeads/DiskLruCache.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/nativeads/DiskLruCacheStrictLineReader.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/nativeads/DiskLruCacheUtil.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/nativeads/DownloadResponse.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/nativeads/DownloadTask.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/nativeads/HttpResponses.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/nativeads/ImageDiskTaskManager.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/nativeads/ImageDownloadTaskManager.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/nativeads/ImageService.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/nativeads/ImageTaskManager.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/nativeads/ImageViewService.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/nativeads/ImpressionTrackingManager.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/nativeads/MoPubNative.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/nativeads/NativeAdViewHelper.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/nativeads/NativeErrorCode.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/nativeads/NativeHttpClient.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/nativeads/NativeResponse.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/nativeads/NativeUrlGenerator.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/nativeads/NativeViewHolder.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/nativeads/RequestParameters.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/nativeads/SpinningProgressView.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/nativeads/UrlResolutionTask.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/nativeads/ViewBinder.java
+#	new file:   mopub-sdk/src/main/java/com/mopub/nativeads/util/Utils.java
+#	new file:   mopub-sdk/src/test/java/com/mopub/common/GpsHelperTest.java
+#	renamed:    mopub-sdk/src/test/java/com/mopub/mobileads/util/AsyncTasksTest.java -> mopub-sdk/src/test/java/com/mopub/common/util/AsyncTasksTest.java
+#	renamed:    mopub-sdk/src/test/java/com/mopub/mobileads/resource/DrawablesTest.java -> mopub-sdk/src/test/java/com/mopub/common/util/DrawablesTest.java
+#	renamed:    mopub-sdk/src/test/java/com/mopub/mobileads/util/FilesTest.java -> mopub-sdk/src/test/java/com/mopub/common/util/FilesTest.java
+#	renamed:    mopub-sdk/src/test/java/com/mopub/mobileads/UtilsTest.java -> mopub-sdk/src/test/java/com/mopub/common/util/IntentUtilsTest.java
+#	renamed:    mopub-sdk/src/test/java/com/mopub/mobileads/util/ReflectionTest.java -> mopub-sdk/src/test/java/com/mopub/common/util/ReflectionTest.java
+#	renamed:    mopub-sdk/src/test/java/com/mopub/mobileads/util/StreamsTest.java -> mopub-sdk/src/test/java/com/mopub/common/util/StreamsTest.java
+#	renamed:    mopub-sdk/src/test/java/com/mopub/mobileads/util/StringsTest.java -> mopub-sdk/src/test/java/com/mopub/common/util/StringsTest.java
+#	renamed:    mopub-sdk/src/test/java/com/mopub/mobileads/util/VersionCodeTest.java -> mopub-sdk/src/test/java/com/mopub/common/util/VersionCodeTest.java
+#	renamed:    mopub-sdk/src/test/java/com/mopub/mobileads/util/ViewsTest.java -> mopub-sdk/src/test/java/com/mopub/common/util/ViewsTest.java
+#	renamed:    mopub-sdk/src/test/java/com/mopub/mobileads/test/support/TestDateAndTime.java -> mopub-sdk/src/test/java/com/mopub/common/util/test/support/TestDateAndTime.java
+#	new file:   mopub-sdk/src/test/java/com/mopub/common/util/test/support/TestMethodBuilderFactory.java
+#	modified:   mopub-sdk/src/test/java/com/mopub/mobileads/AdAlertReporterTest.java
+#	modified:   mopub-sdk/src/test/java/com/mopub/mobileads/AdConfigurationTest.java
+#	modified:   mopub-sdk/src/test/java/com/mopub/mobileads/AdFetcherTest.java
+#	modified:   mopub-sdk/src/test/java/com/mopub/mobileads/AdViewControllerTest.java
+#	modified:   mopub-sdk/src/test/java/com/mopub/mobileads/BaseHtmlWebViewTest.java
+#	modified:   mopub-sdk/src/test/java/com/mopub/mobileads/BaseInterstitialActivityTest.java
+#	modified:   mopub-sdk/src/test/java/com/mopub/mobileads/BaseWebViewTest.java
+#	modified:   mopub-sdk/src/test/java/com/mopub/mobileads/DiskLruCacheTest.java
+#	modified:   mopub-sdk/src/test/java/com/mopub/mobileads/EventForwardingBroadcastReceiverTest.java
+#	modified:   mopub-sdk/src/test/java/com/mopub/mobileads/HtmlInterstitialWebViewTest.java
+#	modified:   mopub-sdk/src/test/java/com/mopub/mobileads/HtmlWebViewClientTest.java
+#	modified:   mopub-sdk/src/test/java/com/mopub/mobileads/MoPubActivityTest.java
+#	renamed:    mopub-sdk/src/test/java/com/mopub/mobileads/MraidBrowserControllerTest.java -> mopub-sdk/src/test/java/com/mopub/mobileads/MoPubBrowserControllerTest.java
+#	modified:   mopub-sdk/src/test/java/com/mopub/mobileads/MoPubConversionTrackerTest.java
+#	modified:   mopub-sdk/src/test/java/com/mopub/mobileads/MoPubInterstitialTest.java
+#	modified:   mopub-sdk/src/test/java/com/mopub/mobileads/MraidDisplayControllerTest.java
+#	modified:   mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoDownloadTaskTest.java
+#	modified:   mopub-sdk/src/test/java/com/mopub/mobileads/VastVideoViewTest.java
+#	renamed:    mopub-sdk/src/test/java/com/mopub/mobileads/AdUrlGeneratorTest.java -> mopub-sdk/src/test/java/com/mopub/mobileads/WebViewUrlGeneratorTest.java
+#	modified:   mopub-sdk/src/test/java/com/mopub/mobileads/test/support/FileUtils.java
+#	modified:   mopub-sdk/src/test/java/com/mopub/mobileads/test/support/SdkTestRunner.java
+#	modified:   mopub-sdk/src/test/java/com/mopub/mobileads/util/MraidsTest.java
+#	new file:   mopub-sdk/src/test/java/com/mopub/nativeads/AdapterHelperTest.java
+#	new file:   mopub-sdk/src/test/java/com/mopub/nativeads/CacheServiceTest.java
+#	new file:   mopub-sdk/src/test/java/com/mopub/nativeads/DownloadTaskTest.java
+#	new file:   mopub-sdk/src/test/java/com/mopub/nativeads/HttpResponsesTest.java
+#	new file:   mopub-sdk/src/test/java/com/mopub/nativeads/ImageDiskTaskManagerTest.java
+#	new file:   mopub-sdk/src/test/java/com/mopub/nativeads/ImageDownloadTaskManagerTest.java
+#	new file:   mopub-sdk/src/test/java/com/mopub/nativeads/ImageServiceTest.java
+#	new file:   mopub-sdk/src/test/java/com/mopub/nativeads/ImageViewServiceTest.java
+#	new file:   mopub-sdk/src/test/java/com/mopub/nativeads/ImpressionTrackingManagerTest.java
+#	new file:   mopub-sdk/src/test/java/com/mopub/nativeads/MoPubNativeTest.java
+#	new file:   mopub-sdk/src/test/java/com/mopub/nativeads/NativeAdViewHelperTest.java
+#	new file:   mopub-sdk/src/test/java/com/mopub/nativeads/NativeResponseTest.java
+#	new file:   mopub-sdk/src/test/java/com/mopub/nativeads/NativeViewHolderTest.java
+#	new file:   mopub-sdk/src/test/java/com/mopub/nativeads/test/support/SdkTestRunner.java
+#	modified:   robotium-sample/AndroidManifest.xml
+#	modified:   robotium-sample/pom.xml
+#	modified:   robotium-tests/AndroidManifest.xml
+#	modified:   robotium-tests/pom.xml
+#	modified:   robotium-tests/src/main/java/com/mopub/mobileads/test/RobotiumTestSupportActivityTest.java
+#
+# Unmerged paths:
+#   (use "git add/rm <file>..." as appropriate to mark resolution)
+#
+#	deleted by us:      mopub-sdk/AndroidManifest.xml
+#	deleted by us:      mopub-sdk/libs/android-support-v4.jar
+#	deleted by us:      mopub-sdk/pom.xml
+#
+# Changes not staged for commit:
+#   (use "git add <file>..." to update what will be committed)
+#   (use "git checkout -- <file>..." to discard changes in working directory)
+#
+#	modified:   .gradle/1.11/taskArtifacts/cache.properties.lock
+#	modified:   .gradle/1.11/taskArtifacts/fileHashes.bin
+#	modified:   .gradle/1.11/taskArtifacts/fileSnapshots.bin
+#	modified:   .gradle/1.11/taskArtifacts/outputFileStates.bin
+#	modified:   .gradle/1.11/taskArtifacts/taskArtifacts.bin
+#	modified:   mopub-sdk/build/bundles/debug/classes.jar
+#	modified:   mopub-sdk/build/bundles/release/classes.jar
+#	modified:   mopub-sdk/build/libs/mopub-sdk.aar
+#
+# Untracked files:
+#   (use "git add <file>..." to include in what will be committed)
+#
+#	.idea/libraries/
+#	more
diff --git a/robotium-sample/AndroidManifest.xml b/robotium-sample/AndroidManifest.xml
index da26771a..180580a9 100644
--- a/robotium-sample/AndroidManifest.xml
+++ b/robotium-sample/AndroidManifest.xml
@@ -3,7 +3,7 @@
       package="com.mopub.mobileads.robotium"
       android:versionCode="1"
       android:versionName="1.0">
-    <uses-sdk android:minSdkVersion="4" />
+    <uses-sdk android:minSdkVersion="8" />
 
     <uses-permission android:name="android.permission.INTERNET" />
     <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
@@ -21,7 +21,7 @@
 
         <activity android:name="com.mopub.mobileads.MoPubActivity" android:configChanges="keyboardHidden|orientation"/>
         <activity android:name="com.mopub.mobileads.MraidActivity" android:configChanges="keyboardHidden|orientation"/>
-        <activity android:name="com.mopub.mobileads.MraidBrowser" android:configChanges="keyboardHidden|orientation"/>
+        <activity android:name="com.mopub.common.MoPubBrowser" android:configChanges="keyboardHidden|orientation"/>
     </application>
 
 </manifest>
diff --git a/robotium-sample/pom.xml b/robotium-sample/pom.xml
index 73df9a7c..d33aa213 100644
--- a/robotium-sample/pom.xml
+++ b/robotium-sample/pom.xml
@@ -89,7 +89,7 @@
             <plugin>
                 <groupId>com.jayway.maven.plugins.android.generation2</groupId>
                 <artifactId>android-maven-plugin</artifactId>
-                <version>3.6.0</version>
+                <version>3.8.2</version>
                 <configuration>
                     <sdk>
                         <!-- platform or api level (api level 4 = platform 1.6)-->
diff --git a/robotium-tests/AndroidManifest.xml b/robotium-tests/AndroidManifest.xml
index 1e853d46..7d522746 100644
--- a/robotium-tests/AndroidManifest.xml
+++ b/robotium-tests/AndroidManifest.xml
@@ -3,7 +3,7 @@
 		package="com.mopub.mobileads.test"
 		android:versionCode="1"
 		android:versionName="1.0">
-	<uses-sdk android:minSdkVersion="4"/>
+	<uses-sdk android:minSdkVersion="8"/>
 
     <instrumentation android:targetPackage="com.mopub.mobileads.robotium" android:name="android.test.InstrumentationTestRunner" />
 
diff --git a/robotium-tests/pom.xml b/robotium-tests/pom.xml
index 4c7d9b5f..5303374a 100644
--- a/robotium-tests/pom.xml
+++ b/robotium-tests/pom.xml
@@ -59,7 +59,7 @@
             <plugin>
                 <groupId>com.jayway.maven.plugins.android.generation2</groupId>
                 <artifactId>android-maven-plugin</artifactId>
-                <version>3.6.0</version>
+                <version>3.8.2</version>
                 <configuration>
                     <sdk>
                         <!-- platform or api level (api level 4 = platform 1.6)-->
diff --git a/robotium-tests/src/main/java/com/mopub/mobileads/test/RobotiumTestSupportActivityTest.java b/robotium-tests/src/main/java/com/mopub/mobileads/test/RobotiumTestSupportActivityTest.java
index ec4a86cb..3ddad10e 100644
--- a/robotium-tests/src/main/java/com/mopub/mobileads/test/RobotiumTestSupportActivityTest.java
+++ b/robotium-tests/src/main/java/com/mopub/mobileads/test/RobotiumTestSupportActivityTest.java
@@ -33,17 +33,17 @@
 package com.mopub.mobileads.test;
 
 import android.test.ActivityInstrumentationTestCase2;
-import android.view.View;
 import android.widget.Button;
 import android.widget.EditText;
+
+import com.mopub.common.MoPubBrowser;
 import com.mopub.mobileads.MoPubActivity;
 import com.mopub.mobileads.MoPubErrorCode;
 import com.mopub.mobileads.MoPubInterstitial;
 import com.mopub.mobileads.MoPubView;
-import com.mopub.mobileads.MraidBrowser;
-import com.mopub.mobileads.robotium.*;
 import com.mopub.mobileads.robotium.R;
 import com.robotium.solo.Solo;
+import com.mopub.mobileads.robotium.RobotiumTestSupportActivity;
 
 import static com.mopub.mobileads.MoPubInterstitial.InterstitialAdListener;
 
@@ -98,7 +98,7 @@ public void testMoPubBannerLoadAndClick() throws Exception {
         Thread.sleep(NETWORK_SLEEP_TIME);
         assertTrue("Banner was not clicked.", listener.bannerWasClicked());
 
-        solo.assertCurrentActivity("expected an MraidBrowser", MraidBrowser.class);
+        solo.assertCurrentActivity("expected a MoPubBrowser", MoPubBrowser.class);
     }
 
     public void testMoPubInterstitialLoadShowAndClick() throws Exception {
@@ -117,7 +117,7 @@ public void testMoPubInterstitialLoadShowAndClick() throws Exception {
 
         solo.clickOnView(solo.getCurrentActivity().findViewById(android.R.id.content));
         Thread.sleep(NETWORK_SLEEP_TIME);
-        solo.assertCurrentActivity("expected MraidBrowser", MraidBrowser.class);
+        solo.assertCurrentActivity("expected MoPubBrowser", MoPubBrowser.class);
     }
 
     public void testMoPubInterstitialLoadShowAndDismissWithCloseButton() throws Exception {
