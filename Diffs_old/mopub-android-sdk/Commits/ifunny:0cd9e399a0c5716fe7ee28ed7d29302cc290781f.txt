diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubStreamAdPlacer.java b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubStreamAdPlacer.java
index 7fc52325..bbe673ae 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubStreamAdPlacer.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/MoPubStreamAdPlacer.java
@@ -332,25 +332,12 @@ void handlePositioningLoad(@NonNull final MoPubClientPositioning positioning) {
 	void handleAdsAvailable() {
 		// If we've already placed ads, just notify that we need placement.
 		if (mHasPlacedAds) {
-			notifyNeedsPlacement();
+//			notifyNeedsPlacement();
 			return;
 		}
 
 		// Otherwise, we may need to place initial ads.
 		if (mHasReceivedPositions) {
-			int stackedCount = mPendingPlacementData.getStackedCount();
-			if (stackedCount > 0) {
-				for (int i = 0; i < stackedCount; ++i) {
-					final NativeResponse adResponse = mAdSource.dequeueAd();
-					if (adResponse == null) {
-						return;
-					}
-
-					final NativeAdData adData = createAdData(adResponse);
-					int insertPosition = mPendingPlacementData.placeInStack(adData);
-					mAdLoadedListener.onAdLoaded(insertPosition);
-				}
-			}
 			placeInitialAds(mPendingPlacementData);
 		}
 		mHasReceivedAds = true;
@@ -362,8 +349,12 @@ private void placeInitialAds(PlacementData placementData) {
 		removeAdsInRange(0, mItemCount);
 
 		mPlacementData = placementData;
-		placeAds();
+//		placeAds();
 		mHasPlacedAds = true;
+		for (Integer integer : delayedStackRequests){
+			placeAd(integer);
+		}
+		delayedStackRequests.clear();
 	}
 
 	public void setVisibleRange(int start, int end) {
@@ -371,6 +362,10 @@ public void setVisibleRange(int start, int end) {
 		mVisibleRangeEnd = end;
 	}
 
+	public void stackPlace(int position){
+		delayedStackRequests.add(position);
+	}
+
 	public int getItemCount() {
 		return mItemCount;
 	}
@@ -379,6 +374,10 @@ public boolean isAdLoaded(int position) {
 		return mPlacementData.isAdLoaded(position);
 	}
 
+	public boolean isAdLoadedByOriginalPosition(int position) {
+		return mPlacementData.isAdLoadedByOriginalPosition(position);
+	}
+
 	public boolean isAdLoadedByIndex(int index) {
 		return mPlacementData.isAdLoadedByIndex(index);
 	}
@@ -477,6 +476,11 @@ public NativeAdData getAdDataByIndex(final int index) {
 		return mPlacementData.getPlacedAdByIndex(index);
 	}
 
+	@Nullable
+	public NativeAdData getAdDataByOriginalPosition(final int index) {
+		return mPlacementData.getPlacedAdByOriginalPosition(index);
+	}
+
 	/**
 	 * Gets the ad at the given position, or {@code null} if there is no ad at the given position.
 	 * <p/>
@@ -684,9 +688,9 @@ public void setItemCount(final int originalCount) {
 		mItemCount = mPlacementData.getAdjustedCount(originalCount);
 
 		// If we haven't already placed ads, we'll let ads get placed by the normal loadAds call
-		if (mHasPlacedAds) {
-			notifyNeedsPlacement();
-		}
+//		if (mHasPlacedAds) {
+//			notifyNeedsPlacement();
+//		}
 	}
 
 	/**
@@ -755,13 +759,13 @@ public void moveItem(final int originalPosition, final int newPosition) {
 
 	private void notifyNeedsPlacement() {
 		// Avoid posting if this method has already been called.
-		if (mNeedsPlacement) {
-			return;
-		}
-		mNeedsPlacement = true;
-
-		// Post the placement to happen on the next UI render loop.
-		mPlacementHandler.post(mPlacementRunnable);
+//		if (mNeedsPlacement) {
+//			return;
+//		}
+//		mNeedsPlacement = true;
+//
+//		// Post the placement to happen on the next UI render loop.
+//		mPlacementHandler.post(mPlacementRunnable);
 	}
 
 	/**
@@ -773,7 +777,7 @@ private void placeAds() {
 				if (!tryPlaceAd(integer)) {
 					return;
 				}
-			}else {
+			} else {
 				MoPubLog.e("there is no place for stacked ad");
 			}
 		}
@@ -819,6 +823,13 @@ public boolean tryPlaceAdsInRange(final int start, final int end) {
 		return true;
 	}
 
+	public boolean placeAd(int position) {
+		if (mPlacementData.shouldPlaceAd(position)) {
+			return tryPlaceAd(position);
+		}
+		return false;
+	}
+
 	/**
 	 * Attempts to place an ad at the given position, returning false if there is no ad available to
 	 * be placed.
@@ -826,7 +837,7 @@ public boolean tryPlaceAdsInRange(final int start, final int end) {
 	 * @param position The position to place the ad at.
 	 * @return false if there is no ad available to be placed.
 	 */
-	private boolean tryPlaceAd(final int position) {
+	public boolean tryPlaceAd(final int position) {
 		final NativeResponse adResponse = mAdSource.dequeueAd();
 		if (adResponse == null) {
 			return false;
@@ -840,33 +851,6 @@ private boolean tryPlaceAd(final int position) {
 		return true;
 	}
 
-	public void stackPlace(final int position) {
-		stackPlace(position, mPlacementData);
-	}
-
-	public void stackPlace(final int position, PlacementData placementData) {
-		if (!mHasReceivedPositions) {
-			delayedStackRequests.add(position);
-			return;
-		}
-
-		if (!placementData.shouldPlaceAd(position)) {
-			return;
-		}
-		final NativeResponse adResponse = mAdSource.dequeueAd();
-		NativeAdData adData = null;
-		if (adResponse != null) {
-			adData = createAdData(adResponse);
-		}
-
-		placementData.placeAd(position, adData);
-		mItemCount++;
-
-		if (adData != null) {
-			mAdLoadedListener.onAdLoaded(position);
-		}
-	}
-
 	@NonNull
 	private NativeAdData createAdData(@NonNull final NativeResponse adResponse) {
 		Preconditions.checkNotNull(mAdUnitId);
diff --git a/mopub-sdk/src/main/java/com/mopub/nativeads/PlacementData.java b/mopub-sdk/src/main/java/com/mopub/nativeads/PlacementData.java
index 1f76ba95..5ffba84a 100644
--- a/mopub-sdk/src/main/java/com/mopub/nativeads/PlacementData.java
+++ b/mopub-sdk/src/main/java/com/mopub/nativeads/PlacementData.java
@@ -6,7 +6,6 @@
 import com.mopub.common.logging.MoPubLog;
 import com.mopub.nativeads.MoPubNativeAdPositioning.MoPubClientPositioning;
 
-import java.util.LinkedList;
 import java.util.List;
 
 /**
@@ -21,94 +20,94 @@
  *
  * For example, consider the following ad positions:
  * ORIGINAL LIST    ADJUSTED LIST
- *   Item 0           Item 0
- *   Item 1           Ad
- *   Item 2           Item 1
- *   Item 3           Ad
- *                    Item 2
- *                    Ad
- *                    Item 3
+ * Item 0           Item 0
+ * Item 1           Ad
+ * Item 2           Item 1
+ * Item 3           Ad
+ * Item 2
+ * Ad
+ * Item 3
  *
  * List starts as:
- *   Item 0
- *   Item 1
- *   Item 2
- *   Item 3
+ * Item 0
+ * Item 1
+ * Item 2
+ * Item 3
  * desiredOriginalPositions: {1, 2, 3}
  * desiredInsertionPositions: {1, 2, 3}
  * originalPositions: {}
  * adjustedPositions: {}
  *
  * If we place at position 2:
- *   Item 0
- *   Item 1
- *   Ad
- *   Item 2
- *   Item 3
+ * Item 0
+ * Item 1
+ * Ad
+ * Item 2
+ * Item 3
  * desiredOriginalPositions: {1, 3}
  * desiredInsertionPositions: {1, 4}
  * originalPositions: {2}
  * adjustedPositions: {2}
  *
  * If the developer adds a content item at position 2
- *   Item 0
- *   Item 1
- *   New Item
- *   Ad
- *   Item 3
- *   Item 4
+ * Item 0
+ * Item 1
+ * New Item
+ * Ad
+ * Item 3
+ * Item 4
  * desiredOriginalPositions: {1, 4}
  * desiredInsertionPositions: {1, 5}
  * originalPositions: {3}
  * adjustedPositions: {3}
  *
  * Now, place at position 1
- *   Item 0
- *   Ad
- *   Item 1
- *   New Item
- *   Ad
- *   Item 3
- *   Item 4
+ * Item 0
+ * Ad
+ * Item 1
+ * New Item
+ * Ad
+ * Item 3
+ * Item 4
  * desiredOriginalPositions: {4}
  * desiredInsertionPositions: {6}
  * originalPositions: {1, 3}
  * adjustedPositions: {1, 4}
  *
  * Place at position 6
- *   Item 0
- *   Ad
- *   Item 1
- *   New Item
- *   Ad
- *   Item 3
- *   Ad
- *   Item 4
+ * Item 0
+ * Ad
+ * Item 1
+ * New Item
+ * Ad
+ * Item 3
+ * Ad
+ * Item 4
  * desiredOriginalPositions: {}
  * desiredInsertionPositions: {}
  * originalPositions: {1, 3, 4}
  * adjustedPositions: {1, 4, 6}
  *
  * Clear ad at position 1
- *   Item 0
- *   Item 1
- *   New Item
- *   Ad
- *   Item 3
- *   Ad
- *   Item 4
+ * Item 0
+ * Item 1
+ * New Item
+ * Ad
+ * Item 3
+ * Ad
+ * Item 4
  * desiredOriginalPositions: {1}
  * desiredInsertionPositions: {1}
  * originalPositions: {3, 4}
  * adjustedPositions: {3, 5}
  *
  * Clear ad at position 5
- *   Item 0
- *   Item 1
- *   New Item
- *   Ad
- *   Item 3
- *   Item 4
+ * Item 0
+ * Item 1
+ * New Item
+ * Ad
+ * Item 3
+ * Item 4
  * desiredOriginalPositions: {1, 4}
  * desiredInsertionPositions: {1, 5}
  * originalPositions: {3}
@@ -120,191 +119,186 @@
  * - Places an ad (moves positions from desired to placed) in O(N)
  */
 class PlacementData {
-    /**
-     * Returned when positions are not found.
-     */
-    public final static int NOT_FOUND = -1;
+	/**
+	 * Returned when positions are not found.
+	 */
+	public final static int NOT_FOUND = -1;
 
-    // Cap the number of ads to avoid unrestrained memory usage. 200 allows the 5 positioning
-    // arrays to fit in less than 4K.
-    private final static int MAX_ADS = 200;
+	// Cap the number of ads to avoid unrestrained memory usage. 200 allows the 5 positioning
+	// arrays to fit in less than 4K.
+	private final static int MAX_ADS = 200;
 
-    // Initialize all of these to their max capacity. This prevents garbage collection when
-    // reallocating the list, which causes noticeable stuttering when scrolling on some devices.
+	// Initialize all of these to their max capacity. This prevents garbage collection when
+	// reallocating the list, which causes noticeable stuttering when scrolling on some devices.
     @NonNull private final int[] mDesiredOriginalPositions = new int[MAX_ADS];
     @NonNull private final int[] mDesiredInsertionPositions = new int[MAX_ADS];
-    private int mDesiredCount = 0;
+	private int mDesiredCount = 0;
     @NonNull private final int[] mOriginalAdPositions = new int[MAX_ADS];
     @NonNull private final int[] mAdjustedAdPositions = new int[MAX_ADS];
     @NonNull private final NativeAdData[] mAdDataObjects = new NativeAdData[MAX_ADS];
-    @NonNull private final LinkedList<Integer> stackedPositions = new LinkedList<>();
-    private int mPlacedCount = 0;
-
-    /**
-     * @param desiredInsertionPositions Insertion positions, expressed as original positions
-     */
-    private PlacementData(@NonNull final int[] desiredInsertionPositions) {
-        mDesiredCount = Math.min(desiredInsertionPositions.length, MAX_ADS);
-        System.arraycopy(desiredInsertionPositions, 0, mDesiredInsertionPositions, 0, mDesiredCount);
-        System.arraycopy(desiredInsertionPositions, 0, mDesiredOriginalPositions, 0, mDesiredCount);
-    }
-
-    @NonNull
-    static PlacementData fromAdPositioning(@NonNull final MoPubClientPositioning adPositioning) {
-        final List<Integer> fixed = adPositioning.getFixedPositions();
-        final int interval = adPositioning.getRepeatingInterval();
-
-        final int size = (interval == MoPubClientPositioning.NO_REPEAT ? fixed.size() : MAX_ADS);
-        final int[] desiredInsertionPositions = new int[size];
-
-        // Fixed positions are in terms of final positions. Calculate current insertion positions
-        // by decrementing numAds at each index.
-        int numAds = 0;
-        int lastPos = 0;
-        for (final Integer position : fixed) {
-            lastPos = position - numAds;
-            desiredInsertionPositions[numAds++] = lastPos;
-        }
-
-        // Expand the repeating positions, if there are any
-        while (numAds < size) {
-            lastPos = lastPos + interval - 1;
-            desiredInsertionPositions[numAds++] = lastPos;
-        }
-        return new PlacementData(desiredInsertionPositions);
-    }
-
-    @NonNull
-    static PlacementData empty() {
-        return new PlacementData(new int[] {});
-    }
-
-    /**
-     * Whether the given position should be an ad.
-     */
-    boolean shouldPlaceAd(final int position) {
-        final int index = binarySearch(mDesiredInsertionPositions, 0, mDesiredCount, position);
-        return index >= 0;
-    }
-
-    /**
-     * The next position after this position that should be an ad. Returns NOT_FOUND if there are no
-     * more ads.
-     */
-    int nextInsertionPosition(final int position) {
-        final int index = binarySearchGreaterThan(
-                mDesiredInsertionPositions, mDesiredCount, position);
-        if (index == mDesiredCount) {
-            return NOT_FOUND;
-        }
-        return mDesiredInsertionPositions[index];
-    }
-
-    /**
-     * The next position after this position that should be an ad. Returns NOT_FOUND if there
-     * are no more ads.
-     */
-    int previousInsertionPosition(final int position) {
-        final int index = binarySearchFirstEquals(
-                mDesiredInsertionPositions, mDesiredCount, position);
-        if (index == 0) {
-            return NOT_FOUND;
-        }
-        return mDesiredInsertionPositions[index - 1];
-    }
-
-    /**
-     * Sets ad data at the given position.
-     */
-    void placeAd(final int adjustedPosition, final NativeAdData adData) {
-        // See if this is a insertion ad
-        final int desiredIndex = binarySearchFirstEquals(
-                mDesiredInsertionPositions, mDesiredCount, adjustedPosition);
-        if (desiredIndex == mDesiredCount
-                || mDesiredInsertionPositions[desiredIndex] != adjustedPosition) {
-            MoPubLog.w("Attempted to insert an ad at an invalid position");
-            return;
-        }
-
-        // Add to placed array
-        final int originalPosition = mDesiredOriginalPositions[desiredIndex];
-        int placeIndex = binarySearchGreaterThan(
-                mOriginalAdPositions, mPlacedCount, originalPosition);
-        if (placeIndex < mPlacedCount) {
-            final int num = mPlacedCount - placeIndex;
-            System.arraycopy(mOriginalAdPositions, placeIndex,
-                    mOriginalAdPositions, placeIndex + 1, num);
-            System.arraycopy(mAdjustedAdPositions, placeIndex,
-                    mAdjustedAdPositions, placeIndex + 1, num);
-            System.arraycopy(mAdDataObjects, placeIndex, mAdDataObjects, placeIndex + 1, num);
-        }
-        mOriginalAdPositions[placeIndex] = originalPosition;
-        mAdjustedAdPositions[placeIndex] = adjustedPosition;
-	    if (adData != null) {
-		    mAdDataObjects[placeIndex] = adData;
-	    }
-	    else {
-		    stackedPositions.add(placeIndex);
-	    }
-	    mPlacedCount++;
-
-        // Remove desired index
-        final int num = mDesiredCount - desiredIndex - 1;
-        System.arraycopy(mDesiredInsertionPositions, desiredIndex + 1,
-                mDesiredInsertionPositions, desiredIndex, num);
-        System.arraycopy(mDesiredOriginalPositions, desiredIndex + 1,
-                mDesiredOriginalPositions, desiredIndex, num);
-        mDesiredCount--;
-
-        // Increment adjusted positions
-        for (int i = desiredIndex; i < mDesiredCount; ++i) {
-            mDesiredInsertionPositions[i]++;
-        }
-        for (int i = placeIndex + 1; i < mPlacedCount; ++i) {
-            mAdjustedAdPositions[i]++;
-        }
-    }
-
-    /**
-     * @see {@link com.mopub.nativeads.MoPubStreamAdPlacer#isAd(int)}
-     */
-    boolean isPlacedAd(final int position) {
-        final int index = binarySearch(mAdjustedAdPositions, 0, mPlacedCount, position);
-        return index >= 0;
-    }
-
-    boolean isAdLoaded(final int position) {
-        final int index = binarySearch(mAdjustedAdPositions, 0, mPlacedCount, position);
-        return index >=0;
-    }
-
-	boolean isAdLoadedByIndex(final int index){
-		if (index >=0){
-			return getPlacedCount()>index;
+	private int mPlacedCount = 0;
+
+	/**
+	 * @param desiredInsertionPositions Insertion positions, expressed as original positions
+	 */
+	private PlacementData(@NonNull final int[] desiredInsertionPositions) {
+		mDesiredCount = Math.min(desiredInsertionPositions.length, MAX_ADS);
+		System.arraycopy(desiredInsertionPositions, 0, mDesiredInsertionPositions, 0, mDesiredCount);
+		System.arraycopy(desiredInsertionPositions, 0, mDesiredOriginalPositions, 0, mDesiredCount);
+	}
+
+	@NonNull
+	static PlacementData fromAdPositioning(@NonNull final MoPubClientPositioning adPositioning) {
+		final List<Integer> fixed = adPositioning.getFixedPositions();
+		final int interval = adPositioning.getRepeatingInterval();
+
+		final int size = (interval == MoPubClientPositioning.NO_REPEAT ? fixed.size() : MAX_ADS);
+		final int[] desiredInsertionPositions = new int[size];
+
+		// Fixed positions are in terms of final positions. Calculate current insertion positions
+		// by decrementing numAds at each index.
+		int numAds = 0;
+		int lastPos = 0;
+		for (final Integer position : fixed) {
+			lastPos = position - numAds;
+			desiredInsertionPositions[numAds++] = lastPos;
 		}
-		return false;
+
+		// Expand the repeating positions, if there are any
+		while (numAds < size) {
+			lastPos = lastPos + interval - 1;
+			desiredInsertionPositions[numAds++] = lastPos;
+		}
+		return new PlacementData(desiredInsertionPositions);
+	}
+
+	@NonNull
+	static PlacementData empty() {
+		return new PlacementData(new int[]{});
+	}
+
+	/**
+	 * Whether the given position should be an ad.
+	 */
+	public boolean shouldPlaceAd(final int position) {
+		final int index = binarySearch(mDesiredInsertionPositions, 0, mDesiredCount, position);
+		return index >= 0;
+	}
+
+	/**
+	 * The next position after this position that should be an ad. Returns NOT_FOUND if there are no
+	 * more ads.
+	 */
+	int nextInsertionPosition(final int position) {
+		final int index = binarySearchGreaterThan(
+				mDesiredInsertionPositions, mDesiredCount, position);
+		if (index == mDesiredCount) {
+			return NOT_FOUND;
+		}
+		return mDesiredInsertionPositions[index];
+	}
+
+	/**
+	 * The next position after this position that should be an ad. Returns NOT_FOUND if there
+	 * are no more ads.
+	 */
+	int previousInsertionPosition(final int position) {
+		final int index = binarySearchFirstEquals(
+				mDesiredInsertionPositions, mDesiredCount, position);
+		if (index == 0) {
+			return NOT_FOUND;
+		}
+		return mDesiredInsertionPositions[index - 1];
+	}
+
+	/**
+	 * Sets ad data at the given position.
+	 */
+	void placeAd(final int adjustedPosition, final NativeAdData adData) {
+		// See if this is a insertion ad
+		final int desiredIndex = binarySearchFirstEquals(
+				mDesiredInsertionPositions, mDesiredCount, adjustedPosition);
+		if (desiredIndex == mDesiredCount
+				|| mDesiredInsertionPositions[desiredIndex] != adjustedPosition) {
+			MoPubLog.w("Attempted to insert an ad at an invalid position");
+			return;
+		}
+
+		// Add to placed array
+		final int originalPosition = mDesiredOriginalPositions[desiredIndex];
+		int placeIndex = binarySearchGreaterThan(
+				mOriginalAdPositions, mPlacedCount, originalPosition);
+		if (placeIndex < mPlacedCount) {
+			final int num = mPlacedCount - placeIndex;
+			System.arraycopy(mOriginalAdPositions, placeIndex,
+					mOriginalAdPositions, placeIndex + 1, num);
+			System.arraycopy(mAdjustedAdPositions, placeIndex,
+					mAdjustedAdPositions, placeIndex + 1, num);
+			System.arraycopy(mAdDataObjects, placeIndex, mAdDataObjects, placeIndex + 1, num);
+		}
+		mOriginalAdPositions[placeIndex] = originalPosition;
+		mAdjustedAdPositions[placeIndex] = adjustedPosition;
+		if (adData != null) {
+			mAdDataObjects[placeIndex] = adData;
+		}
+		mPlacedCount++;
+
+		// Remove desired index
+		final int num = mDesiredCount - desiredIndex - 1;
+		System.arraycopy(mDesiredInsertionPositions, desiredIndex + 1,
+				mDesiredInsertionPositions, desiredIndex, num);
+		System.arraycopy(mDesiredOriginalPositions, desiredIndex + 1,
+				mDesiredOriginalPositions, desiredIndex, num);
+		mDesiredCount--;
+
+		// Increment adjusted positions
+		for (int i = desiredIndex; i < mDesiredCount; ++i) {
+			mDesiredInsertionPositions[i]++;
+		}
+		for (int i = placeIndex + 1; i < mPlacedCount; ++i) {
+			mAdjustedAdPositions[i]++;
+		}
+	}
+
+	/**
+	 * @see {@link com.mopub.nativeads.MoPubStreamAdPlacer#isAd(int)}
+	 */
+	boolean isPlacedAd(final int position) {
+		final int index = binarySearch(mAdjustedAdPositions, 0, mPlacedCount, position);
+		return index >= 0;
 	}
 
-	int getStackedCount(){
-		return stackedPositions.size();
+	boolean isAdLoaded(final int position) {
+		final int index = binarySearch(mAdjustedAdPositions, 0, mPlacedCount, position);
+		return index >= 0;
 	}
 
-	int placeInStack(final NativeAdData adData){
-		int placeIndex = stackedPositions.getFirst();
-		mAdDataObjects[placeIndex] = adData;
-		stackedPositions.removeFirst();
-		return mAdjustedAdPositions[placeIndex];
+	boolean isAdLoadedByOriginalPosition(final int position) {
+		final int index = binarySearch(mOriginalAdPositions, 0, mPlacedCount, position);
+		return index >= 0;
 	}
 
-    /**
-     * Returns the ad data associated with the given ad position, or {@code null} if there is
-     * no ad at this position.
-     */
-    @Nullable
-    NativeAdData getPlacedAd(final int position) {
-        final int index = binarySearch(mAdjustedAdPositions, 0, mPlacedCount, position);
-        return getPlacedAdByIndex(index);
-    }
+	boolean isAdLoadedByIndex(final int index) {
+		if (index >= 0) {
+			return getPlacedCount() > index;
+		}
+		return false;
+	}
+
+	/**
+	 * Returns the ad data associated with the given ad position, or {@code null} if there is
+	 * no ad at this position.
+	 */
+	@Nullable
+	NativeAdData getPlacedAd(final int position) {
+		final int index = binarySearch(mAdjustedAdPositions, 0, mPlacedCount, position);
+		return getPlacedAdByIndex(index);
+	}
+
+	NativeAdData getPlacedAdByOriginalPosition(final int position) {
+		final int index = binarySearch(mOriginalAdPositions, 0, mPlacedCount, position);
+		return getPlacedAdByIndex(index);
+	}
 
 	@Nullable
 	NativeAdData getPlacedAdByIndex(final int index) {
@@ -314,275 +308,281 @@ NativeAdData getPlacedAdByIndex(final int index) {
 		return mAdDataObjects[index];
 	}
 
-    /**
-     * Returns all placed ad positions. This method allocates new memory on every invocation. Do
-     * not call it from performance critical code.
-     */
-    @NonNull
-    int[] getPlacedAdPositions() {
-        int[] positions = new int[mPlacedCount];
-        System.arraycopy(mAdjustedAdPositions, 0, positions, 0, mPlacedCount);
-        return positions;
-    }
-
-    /**
-     * @see com.mopub.nativeads.MoPubStreamAdPlacer#getOriginalPosition(int)
-     */
-    int getOriginalPosition(final int position) {
-        final int index = binarySearch(mAdjustedAdPositions, 0, mPlacedCount, position);
-
-        // No match, ~index is the number of ads before this pos.
-        if (index < 0) {
-            return position - ~index;
-        }
-
-        // This is an ad - there is no original position
-        return NOT_FOUND;
-    }
-
-    int getPlacedPosition(final int position) {
-        final int index = binarySearch(mAdjustedAdPositions, 0, mPlacedCount, position);
-
-        // No match, ~index is the number of ads before this pos.
-        if (index < 0) {
-            return position - ~index;
-        }
-
-        return position - index;
-    }
-
-    int getInsertPosition(final int position) {
-        final int index = binarySearchGreaterThan(mAdjustedAdPositions, mPlacedCount, position);
-
-        return position - index;
-    }
-
-    /**
-     * @see com.mopub.nativeads.MoPubStreamAdPlacer#getAdjustedPosition(int)
-     */
-    int getAdjustedPosition(final int originalPosition) {
-        // This is an ad. Since binary search doesn't properly handle dups, find the first non-ad.
-        int index = binarySearchGreaterThan(mOriginalAdPositions, mPlacedCount, originalPosition);
-        return originalPosition + index;
-    }
-
-    int getAdIndex(final int adjustedPosition){
-        final int index = binarySearch(mAdjustedAdPositions, 0, mPlacedCount, adjustedPosition);
-	    return index;
-    }
-
-    int getPlacedCount(){
-        return mPlacedCount;
-    }
-
-    /**
-     * @see com.mopub.nativeads.MoPubStreamAdPlacer#getOriginalCount(int)
-     */
-    int getOriginalCount(final int count) {
-        if (count == 0) {
-            return 0;
-        }
-
-        // The last item will never be an ad
-        final int originalPos = getOriginalPosition(count - 1);
-        return (originalPos == NOT_FOUND) ? NOT_FOUND : originalPos + 1;
-    }
-
-    /**
-     * @see com.mopub.nativeads.MoPubStreamAdPlacer#getAdjustedCount(int)
-     */
-    int getAdjustedCount(final int originalCount) {
-        if (originalCount == 0) {
-            return 0;
-        }
-        return getAdjustedPosition(originalCount - 1) + 1;
-    }
-
-    /**
-     * Clears the ads in the given range. After calling this method, the ad positions
-     * will be removed from the placed ad positions and put back into the desired ad insertion
-     * positions.
-     */
-    int clearAdsInRange(final int adjustedStartRange, final int adjustedEndRange) {
-        // Temporary arrays to store the cleared positions. Using temporary arrays makes it
-        // easy to debug what positions are being cleared.
-        int[] clearOriginalPositions = new int[mPlacedCount];
-        int[] clearAdjustedPositions = new int[mPlacedCount];
-        int clearCount = 0;
-
-        // Add to the clear position arrays any positions that fall inside
-        // [adjustedRangeStart, adjustedRangeEnd).
-        for (int i = 0; i < mPlacedCount; ++i) {
-            int originalPosition = mOriginalAdPositions[i];
-            int adjustedPosition = mAdjustedAdPositions[i];
-            if (adjustedStartRange <= adjustedPosition && adjustedPosition < adjustedEndRange) {
-                // When copying adjusted positions, subtract the current clear count because there
-                // is no longer an ad incrementing the desired insertion position.
-                clearOriginalPositions[clearCount] = originalPosition;
-                clearAdjustedPositions[clearCount] = adjustedPosition - clearCount;
-
-                // Destroying and nulling out the ad objects to avoids a memory leak.
-                mAdDataObjects[i].getAd().destroy();
-                mAdDataObjects[i] = null;
-                clearCount++;
-            } else if (clearCount > 0) {
-                // The position is not in the range; shift it by the number of cleared ads.
-                int newIndex = i - clearCount;
-                mOriginalAdPositions[newIndex] = originalPosition;
-                mAdjustedAdPositions[newIndex] = adjustedPosition - clearCount;
-                mAdDataObjects[newIndex] = mAdDataObjects[i];
-            }
-        }
-
-        // If we have cleared nothing, this method was a no-op.
-        if (clearCount == 0) {
-            return 0;
-        }
-
-        // Modify the desired positions arrays in order to make space to put back the
-        // cleared ad positions. For example if the desired array was {1, 10,
-        // 15} and we need to insert {3, 7} we'll shift the desired array to be {1, ?, ? , 10, 15}.
-        int firstCleared = clearAdjustedPositions[0];
-        int desiredIndex = binarySearchFirstEquals(
-                mDesiredInsertionPositions, mDesiredCount, firstCleared);
-        for (int i = mDesiredCount - 1; i >= desiredIndex; --i) {
-            mDesiredOriginalPositions[i + clearCount] = mDesiredOriginalPositions[i];
-            mDesiredInsertionPositions[i + clearCount] = mDesiredInsertionPositions[i] - clearCount;
-        }
-
-        // Copy the cleared ad positions into the desired arrays.
-        for (int i = 0; i < clearCount; ++i) {
-            mDesiredOriginalPositions[desiredIndex + i] = clearOriginalPositions[i];
-            mDesiredInsertionPositions[desiredIndex + i] = clearAdjustedPositions[i];
-        }
-
-        // Update the array counts, and we're done.
-        mDesiredCount = mDesiredCount + clearCount;
-        mPlacedCount = mPlacedCount - clearCount;
-        return clearCount;
-    }
-
-    /**
-     * Clears the ads in the given range. After calling this method the ad's position
-     * will be back to the desired insertion positions.
-     */
-    void clearAds() {
-        if (mPlacedCount == 0) {
-            return;
-        }
-
-        clearAdsInRange(0, mAdjustedAdPositions[mPlacedCount - 1] + 1);
-    }
-
-    /**
-     * @see com.mopub.nativeads.MoPubStreamAdPlacer#insertItem(int)
-     */
-    void insertItem(final int originalPosition) {
-
-        // Increment desired arrays.
-        int indexToIncrement = binarySearchFirstEquals(
-                mDesiredOriginalPositions, mDesiredCount, originalPosition);
-        for (int i = indexToIncrement; i < mDesiredCount; ++i) {
-            mDesiredOriginalPositions[i]++;
-            mDesiredInsertionPositions[i]++;
-        }
-
-        // Increment placed arrays.
-        indexToIncrement = binarySearchFirstEquals(
-                mOriginalAdPositions, mPlacedCount, originalPosition);
-        for (int i = indexToIncrement; i < mPlacedCount; ++i) {
-            mOriginalAdPositions[i]++;
-            mAdjustedAdPositions[i]++;
-        }
-    }
-
-    /**
-     * @see com.mopub.nativeads.MoPubStreamAdPlacer#removeItem(int)
-     */
-    void removeItem(final int originalPosition) {
-        // When removing items, we only decrement ad position values *greater* than the original
-        // position we're removing. The original position associated with an ad is the original
-        // position of the first content item after the ad, so we shouldn't change the original
-        // position of an ad that matches the original position removed.
-        int indexToDecrement = binarySearchGreaterThan(
-                mDesiredOriginalPositions, mDesiredCount, originalPosition);
-
-        // Decrement desired arrays.
-        for (int i = indexToDecrement; i < mDesiredCount; ++i) {
-            mDesiredOriginalPositions[i]--;
-            mDesiredInsertionPositions[i]--;
-        }
-
-        indexToDecrement = binarySearchGreaterThan(
-                mOriginalAdPositions, mPlacedCount, originalPosition);
-
-        for (int i = indexToDecrement; i < mPlacedCount; ++i) {
-            mOriginalAdPositions[i]--;
-            mAdjustedAdPositions[i]--;
-        }
-    }
-
-    /**
-     * @see com.mopub.nativeads.MoPubStreamAdPlacer#moveItem(int, int)
-     */
-    void moveItem(final int originalPosition, final int newPosition) {
-        removeItem(originalPosition);
-        insertItem(newPosition);
-    }
-
-    private static int binarySearchFirstEquals(int[] array, int count, int value) {
-        int index = binarySearch(array, 0, count, value);
-
-        // If not found, binarySearch returns the 2's complement of the index of the nearest
-        // value higher than the target value, which is also the insertion index.
-        if (index < 0) {
-            return ~index;
-        }
-
-        int duplicateValue = array[index];
-        while (index >= 0 && array[index] == duplicateValue) {
-            index--;
-        }
-
-        return index + 1;
-    }
-
-    private static int binarySearchGreaterThan(int[] array, int count, int value) {
-        int index = binarySearch(array, 0, count, value);
-
-        // If not found, binarySearch returns the 2's complement of the index of the nearest
-        // value higher than the target value, which is also the insertion index.
-        if (index < 0) {
-            return ~index;
-        }
-
-        int duplicateValue = array[index];
-        while (index < count && array[index] == duplicateValue) {
-            index++;
-        }
-
-        return index;
-    }
-
-    /**
-     * Copied from Arrays.java, which isn't available until Gingerbread.
-     */
-    private static int binarySearch(int[] array, int startIndex, int endIndex, int value) {
-        int lo = startIndex;
-        int hi = endIndex - 1;
-
-        while (lo <= hi) {
-            int mid = (lo + hi) >>> 1;
-            int midVal = array[mid];
-
-            if (midVal < value) {
-                lo = mid + 1;
-            } else if (midVal > value) {
-                hi = mid - 1;
-            } else {
-                return mid;  // value found
-            }
-        }
-        return ~lo;  // value not present
-    }
+	/**
+	 * Returns all placed ad positions. This method allocates new memory on every invocation. Do
+	 * not call it from performance critical code.
+	 */
+	@NonNull
+	int[] getPlacedAdPositions() {
+		int[] positions = new int[mPlacedCount];
+		System.arraycopy(mAdjustedAdPositions, 0, positions, 0, mPlacedCount);
+		return positions;
+	}
+
+	/**
+	 * @see com.mopub.nativeads.MoPubStreamAdPlacer#getOriginalPosition(int)
+	 */
+	int getOriginalPosition(final int position) {
+		final int index = binarySearch(mAdjustedAdPositions, 0, mPlacedCount, position);
+
+		// No match, ~index is the number of ads before this pos.
+		if (index < 0) {
+			return position - ~index;
+		}
+
+		// This is an ad - there is no original position
+		return NOT_FOUND;
+	}
+
+	int getPlacedPosition(final int position) {
+		final int index = binarySearch(mAdjustedAdPositions, 0, mPlacedCount, position);
+
+		// No match, ~index is the number of ads before this pos.
+		if (index < 0) {
+			return position - ~index;
+		}
+
+		return position - index;
+	}
+
+	int getInsertPosition(final int position) {
+		final int index = binarySearchGreaterThan(mAdjustedAdPositions, mPlacedCount, position);
+
+		return position - index;
+	}
+
+	/**
+	 * @see com.mopub.nativeads.MoPubStreamAdPlacer#getAdjustedPosition(int)
+	 */
+	int getAdjustedPosition(final int originalPosition) {
+		// This is an ad. Since binary search doesn't properly handle dups, find the first non-ad.
+		int index = binarySearchGreaterThan(mOriginalAdPositions, mPlacedCount, originalPosition);
+		return originalPosition + index;
+	}
+
+	int getAdIndex(final int adjustedPosition) {
+		int adjIndex = binarySearch(mAdjustedAdPositions, 0, mPlacedCount, adjustedPosition);
+		if (adjIndex < 0) {
+			adjIndex = 0;
+		}
+		int originalPosition = adjustedPosition - adjIndex;
+		int index = binarySearch(mOriginalAdPositions, 0, mPlacedCount, originalPosition);
+//		final int index = binarySearch(mAdjustedAdPositions, 0, mPlacedCount, adjustedPosition);
+		return index;
+	}
+
+	int getPlacedCount() {
+		return mPlacedCount;
+	}
+
+	/**
+	 * @see com.mopub.nativeads.MoPubStreamAdPlacer#getOriginalCount(int)
+	 */
+	int getOriginalCount(final int count) {
+		if (count == 0) {
+			return 0;
+		}
+
+		// The last item will never be an ad
+		final int originalPos = getOriginalPosition(count - 1);
+		return (originalPos == NOT_FOUND) ? NOT_FOUND : originalPos + 1;
+	}
+
+	/**
+	 * @see com.mopub.nativeads.MoPubStreamAdPlacer#getAdjustedCount(int)
+	 */
+	int getAdjustedCount(final int originalCount) {
+		if (originalCount == 0) {
+			return 0;
+		}
+		return getAdjustedPosition(originalCount - 1) + 1;
+	}
+
+	/**
+	 * Clears the ads in the given range. After calling this method, the ad positions
+	 * will be removed from the placed ad positions and put back into the desired ad insertion
+	 * positions.
+	 */
+	int clearAdsInRange(final int adjustedStartRange, final int adjustedEndRange) {
+		// Temporary arrays to store the cleared positions. Using temporary arrays makes it
+		// easy to debug what positions are being cleared.
+		int[] clearOriginalPositions = new int[mPlacedCount];
+		int[] clearAdjustedPositions = new int[mPlacedCount];
+		int clearCount = 0;
+
+		// Add to the clear position arrays any positions that fall inside
+		// [adjustedRangeStart, adjustedRangeEnd).
+		for (int i = 0; i < mPlacedCount; ++i) {
+			int originalPosition = mOriginalAdPositions[i];
+			int adjustedPosition = mAdjustedAdPositions[i];
+			if (adjustedStartRange <= adjustedPosition && adjustedPosition < adjustedEndRange) {
+				// When copying adjusted positions, subtract the current clear count because there
+				// is no longer an ad incrementing the desired insertion position.
+				clearOriginalPositions[clearCount] = originalPosition;
+				clearAdjustedPositions[clearCount] = adjustedPosition - clearCount;
+
+				// Destroying and nulling out the ad objects to avoids a memory leak.
+				mAdDataObjects[i].getAd().destroy();
+				mAdDataObjects[i] = null;
+				clearCount++;
+			} else if (clearCount > 0) {
+				// The position is not in the range; shift it by the number of cleared ads.
+				int newIndex = i - clearCount;
+				mOriginalAdPositions[newIndex] = originalPosition;
+				mAdjustedAdPositions[newIndex] = adjustedPosition - clearCount;
+				mAdDataObjects[newIndex] = mAdDataObjects[i];
+			}
+		}
+
+		// If we have cleared nothing, this method was a no-op.
+		if (clearCount == 0) {
+			return 0;
+		}
+
+		// Modify the desired positions arrays in order to make space to put back the
+		// cleared ad positions. For example if the desired array was {1, 10,
+		// 15} and we need to insert {3, 7} we'll shift the desired array to be {1, ?, ? , 10, 15}.
+		int firstCleared = clearAdjustedPositions[0];
+		int desiredIndex = binarySearchFirstEquals(
+				mDesiredInsertionPositions, mDesiredCount, firstCleared);
+		for (int i = mDesiredCount - 1; i >= desiredIndex; --i) {
+			mDesiredOriginalPositions[i + clearCount] = mDesiredOriginalPositions[i];
+			mDesiredInsertionPositions[i + clearCount] = mDesiredInsertionPositions[i] - clearCount;
+		}
+
+		// Copy the cleared ad positions into the desired arrays.
+		for (int i = 0; i < clearCount; ++i) {
+			mDesiredOriginalPositions[desiredIndex + i] = clearOriginalPositions[i];
+			mDesiredInsertionPositions[desiredIndex + i] = clearAdjustedPositions[i];
+		}
+
+		// Update the array counts, and we're done.
+		mDesiredCount = mDesiredCount + clearCount;
+		mPlacedCount = mPlacedCount - clearCount;
+		return clearCount;
+	}
+
+	/**
+	 * Clears the ads in the given range. After calling this method the ad's position
+	 * will be back to the desired insertion positions.
+	 */
+	void clearAds() {
+		if (mPlacedCount == 0) {
+			return;
+		}
+
+		clearAdsInRange(0, mAdjustedAdPositions[mPlacedCount - 1] + 1);
+	}
+
+	/**
+	 * @see com.mopub.nativeads.MoPubStreamAdPlacer#insertItem(int)
+	 */
+	void insertItem(final int originalPosition) {
+
+		// Increment desired arrays.
+		int indexToIncrement = binarySearchFirstEquals(
+				mDesiredOriginalPositions, mDesiredCount, originalPosition);
+		for (int i = indexToIncrement; i < mDesiredCount; ++i) {
+			mDesiredOriginalPositions[i]++;
+			mDesiredInsertionPositions[i]++;
+		}
+
+		// Increment placed arrays.
+		indexToIncrement = binarySearchFirstEquals(
+				mOriginalAdPositions, mPlacedCount, originalPosition);
+		for (int i = indexToIncrement; i < mPlacedCount; ++i) {
+			mOriginalAdPositions[i]++;
+			mAdjustedAdPositions[i]++;
+		}
+	}
+
+	/**
+	 * @see com.mopub.nativeads.MoPubStreamAdPlacer#removeItem(int)
+	 */
+	void removeItem(final int originalPosition) {
+		// When removing items, we only decrement ad position values *greater* than the original
+		// position we're removing. The original position associated with an ad is the original
+		// position of the first content item after the ad, so we shouldn't change the original
+		// position of an ad that matches the original position removed.
+		int indexToDecrement = binarySearchGreaterThan(
+				mDesiredOriginalPositions, mDesiredCount, originalPosition);
+
+		// Decrement desired arrays.
+		for (int i = indexToDecrement; i < mDesiredCount; ++i) {
+			mDesiredOriginalPositions[i]--;
+			mDesiredInsertionPositions[i]--;
+		}
+
+		indexToDecrement = binarySearchGreaterThan(
+				mOriginalAdPositions, mPlacedCount, originalPosition);
+
+		for (int i = indexToDecrement; i < mPlacedCount; ++i) {
+			mOriginalAdPositions[i]--;
+			mAdjustedAdPositions[i]--;
+		}
+	}
+
+	/**
+	 * @see com.mopub.nativeads.MoPubStreamAdPlacer#moveItem(int, int)
+	 */
+	void moveItem(final int originalPosition, final int newPosition) {
+		removeItem(originalPosition);
+		insertItem(newPosition);
+	}
+
+	private static int binarySearchFirstEquals(int[] array, int count, int value) {
+		int index = binarySearch(array, 0, count, value);
+
+		// If not found, binarySearch returns the 2's complement of the index of the nearest
+		// value higher than the target value, which is also the insertion index.
+		if (index < 0) {
+			return ~index;
+		}
+
+		int duplicateValue = array[index];
+		while (index >= 0 && array[index] == duplicateValue) {
+			index--;
+		}
+
+		return index + 1;
+	}
+
+	private static int binarySearchGreaterThan(int[] array, int count, int value) {
+		int index = binarySearch(array, 0, count, value);
+
+		// If not found, binarySearch returns the 2's complement of the index of the nearest
+		// value higher than the target value, which is also the insertion index.
+		if (index < 0) {
+			return ~index;
+		}
+
+		int duplicateValue = array[index];
+		while (index < count && array[index] == duplicateValue) {
+			index++;
+		}
+
+		return index;
+	}
+
+	/**
+	 * Copied from Arrays.java, which isn't available until Gingerbread.
+	 */
+	private static int binarySearch(int[] array, int startIndex, int endIndex, int value) {
+		int lo = startIndex;
+		int hi = endIndex - 1;
+
+		while (lo <= hi) {
+			int mid = (lo + hi) >>> 1;
+			int midVal = array[mid];
+
+			if (midVal < value) {
+				lo = mid + 1;
+			} else if (midVal > value) {
+				hi = mid - 1;
+			} else {
+				return mid;  // value found
+			}
+		}
+		return ~lo;  // value not present
+	}
 }
