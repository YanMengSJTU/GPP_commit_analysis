diff --git a/.github/ISSUE_TEMPLATE.md b/.github/ISSUE_TEMPLATE.md
new file mode 100644
index 00000000..bf067267
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE.md
@@ -0,0 +1,27 @@
+## Issue/提问须知
+**在提交issue之前，我们应该先查询是否已经有相关的issue以及[常见问题](https://github.com/Tencent/tinker/wiki/Tinker-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98)。提交issue时，我们需要写明issue的原因，以及编译或运行过程的日志(加载进程以及Patch进程)。issue需要以下面的格式：**
+
+```
+异常类型：app运行时异常/编译异常
+
+手机型号：如:Nexus 5(如是编译异常，则可以不填)
+
+手机系统版本：如:Android 5.0 (如是编译异常，则可以不填)
+
+tinker版本：如:1.7.7
+
+gradle版本：如:2.10
+
+是否使用热更新SDK： 如 TinkerPatch SDK 或者 Bugly SDK
+
+系统：如:Mac
+
+堆栈/日志：
+1. 如是编译异常，请在执行gradle命令时，加上--stacktrace;
+2. 日志我们需要过滤"Tinker."关键字;
+3. 对于合成失败的情况，请给出:patch进程的日志,这里需要将Android Moniter右上角设为No Filter。
+```
+
+提问题时若使用`不能用/没效果/有问题/报错`此类模糊表达，但又没给出任何代码截图报错的，将绝对不会有任何反馈。这种issue也是一律直接关闭的,大家可以参阅[提问的智慧](https://github.com/tvvocold/How-To-Ask-Questions-The-Smart-Way)。
+
+Tinker是一个开源项目，希望大家遇到问题时要学会先思考，看看sample与Tinker的源码，更鼓励大家给我们提pr.
\ No newline at end of file
diff --git a/README.md b/README.md
index 27a8f89d..fb0500be 100644
--- a/README.md
+++ b/README.md
@@ -1,8 +1,8 @@
 ## Tinker
 [![license](http://img.shields.io/badge/license-BSD3-brightgreen.svg?style=flat)](https://github.com/Tencent/tinker/blob/master/LICENSE)
-[![Release Version](https://img.shields.io/badge/release-1.7.7-red.svg)](https://github.com/Tencent/tinker/releases) 
+[![Release Version](https://img.shields.io/badge/release-1.9.1-red.svg)](https://github.com/Tencent/tinker/releases)
 [![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg)](https://github.com/Tencent/tinker/pulls)
-[![WeChat Approved](https://img.shields.io/badge/Wechat_Approved-1.7.7-red.svg)](https://github.com/Tencent/tinker/wiki)
+[![WeChat Approved](https://img.shields.io/badge/Wechat_Approved-1.9.0-red.svg)](https://github.com/Tencent/tinker/wiki)
 
 Tinker is a hot-fix solution library for Android, it supports dex, library and resources update without reinstalling apk.
 
@@ -14,7 +14,7 @@ Add tinker-gradle-plugin as a dependency in your main `build.gradle` in the root
 ```gradle
 buildscript {
     dependencies {
-        classpath ('com.tencent.tinker:tinker-patch-gradle-plugin:1.7.7')
+        classpath ('com.tencent.tinker:tinker-patch-gradle-plugin:1.9.1')
     }
 }
 ```
@@ -24,9 +24,9 @@ Then you need to "apply" the plugin and add dependencies by adding the following
 ```gradle
 dependencies {
     //optional, help to generate the final application 
-    provided('com.tencent.tinker:tinker-android-anno:1.7.7')
+    provided('com.tencent.tinker:tinker-android-anno:1.9.1')
     //tinker's main Android lib
-    compile('com.tencent.tinker:tinker-android-lib:1.7.7') 
+    compile('com.tencent.tinker:tinker-android-lib:1.9.1')
 }
 ...
 ...
diff --git a/build.gradle b/build.gradle
index 41297d17..e35b7423 100644
--- a/build.gradle
+++ b/build.gradle
@@ -28,6 +28,7 @@ ext {
     compileSdkVersion = 23
     targetSdkVersion = compileSdkVersion
     buildToolsVersion = '23.0.2'
+    supportLibVersion = '23.0.1'
     javaVersion = JavaVersion.VERSION_1_7
 
     GROUP = 'com.tencent.tinker'
diff --git a/gradle.properties b/gradle.properties
index 2691a69d..51b25818 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -16,5 +16,5 @@
 # This option should only be used with decoupled projects. More details, visit
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
-VERSION_NAME_PREFIX=1.7.7
+VERSION_NAME_PREFIX=1.9.2
 VERSION_NAME_SUFFIX=
\ No newline at end of file
diff --git a/settings.gradle b/settings.gradle
index ed01852c..593ab980 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -7,3 +7,4 @@ include ':tinker-build:tinker-patch-lib'
 include ':tinker-build:tinker-patch-gradle-plugin'
 include ':third-party:aosp-dexutils'
 include ':third-party:bsdiff-util'
+include ':third-party:tinker-ziputils'
diff --git a/third-party/bsdiff-util/src/main/java/com/tencent/tinker/bsdiff/BSPatch.java b/third-party/bsdiff-util/src/main/java/com/tencent/tinker/bsdiff/BSPatch.java
index 2e8d7269..e31e4fd6 100644
--- a/third-party/bsdiff-util/src/main/java/com/tencent/tinker/bsdiff/BSPatch.java
+++ b/third-party/bsdiff-util/src/main/java/com/tencent/tinker/bsdiff/BSPatch.java
@@ -110,10 +110,10 @@ public static int patchLessMemory(RandomAccessFile oldFile, int oldsize, byte[]
             return RETURN_DIFF_FILE_ERR;
         }
 
-        int commentLenPos = oldsize - extLen - 2;
-        if (commentLenPos <= 2) {
-            return RETURN_OLD_FILE_ERR;
-        }
+//        int commentLenPos = oldsize - extLen - 2;
+//        if (commentLenPos <= 2) {
+//            return RETURN_OLD_FILE_ERR;
+//        }
 
         DataInputStream diffIn = new DataInputStream(new ByteArrayInputStream(diffBuf, 0, diffSize));
 
@@ -167,10 +167,10 @@ public static int patchLessMemory(RandomAccessFile oldFile, int oldsize, byte[]
                     return RETURN_DIFF_FILE_ERR;
                 }
                 for (int i = 0; i < ctrl[0]; i++) {
-                    if (oldpos + i == commentLenPos) {
-                        oldBuffer[i] = 0;
-                        oldBuffer[i + 1] = 0;
-                    }
+//                    if (oldpos + i == commentLenPos) {
+//                        oldBuffer[i] = 0;
+//                        oldBuffer[i + 1] = 0;
+//                    }
 
                     if ((oldpos + i >= 0) && (oldpos + i < oldsize)) {
                         buffer[i] += oldBuffer[i];
diff --git a/third-party/tinker-ziputils/.gitignore b/third-party/tinker-ziputils/.gitignore
new file mode 100644
index 00000000..796b96d1
--- /dev/null
+++ b/third-party/tinker-ziputils/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/third-party/tinker-ziputils/NOTICE.txt b/third-party/tinker-ziputils/NOTICE.txt
new file mode 100644
index 00000000..a513af6c
--- /dev/null
+++ b/third-party/tinker-ziputils/NOTICE.txt
@@ -0,0 +1,190 @@
+   Original work Copyright (c) 2005-2008, The Android Open Source Project
+   Modified work Copyright (C) 2016 THL A29 Limited, a Tencent company.
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
diff --git a/third-party/tinker-ziputils/build.gradle b/third-party/tinker-ziputils/build.gradle
new file mode 100644
index 00000000..1844d317
--- /dev/null
+++ b/third-party/tinker-ziputils/build.gradle
@@ -0,0 +1,19 @@
+apply plugin: 'java'
+
+[compileJava, compileTestJava, javadoc]*.options*.encoding = 'UTF-8'
+
+version rootProject.ext.VERSION_NAME
+group rootProject.ext.GROUP
+
+task buildTinkerSdk(type: Copy, dependsOn: [build]) {
+    group = "tinker"
+    from('build/libs') {
+        include '*.jar'
+        exclude '*javadoc.jar'
+        exclude '*-sources.jar'
+    }
+    into(rootProject.file("buildSdk/android"))
+}
+
+apply from: rootProject.file('gradle/java-artifacts.gradle')
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
diff --git a/third-party/tinker-ziputils/gradle.properties b/third-party/tinker-ziputils/gradle.properties
new file mode 100644
index 00000000..d1004141
--- /dev/null
+++ b/third-party/tinker-ziputils/gradle.properties
@@ -0,0 +1,19 @@
+#
+# Tencent is pleased to support the open source community by making Tinker available.
+#
+# Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+#
+# Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+# compliance with the License. You may obtain a copy of the License at
+#
+# https://opensource.org/licenses/BSD-3-Clause
+#
+# Unless required by applicable law or agreed to in writing, software distributed under the License is
+# distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+# either express or implied. See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+POM_ARTIFACT_ID=tinker-ziputils
+POM_NAME=Tinker Zip Utils
+POM_PACKAGING=jar
\ No newline at end of file
diff --git a/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/Arrays.java b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/Arrays.java
new file mode 100644
index 00000000..373c33a6
--- /dev/null
+++ b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/Arrays.java
@@ -0,0 +1,30 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.ziputils.ziputil;
+
+/**
+ * modify by zhangshaowen on 16/6/7.
+ */
+public class Arrays {
+    public static void checkOffsetAndCount(int arrayLength, int offset, int count) {
+        if ((offset | count) < 0 || offset > arrayLength || arrayLength - offset < count) {
+//            throw new ArrayIndexOutOfBoundsException(arrayLength, offset,
+//                count);
+            throw new ArrayIndexOutOfBoundsException(offset);
+        }
+    }
+}
diff --git a/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/BufferIterator.java b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/BufferIterator.java
new file mode 100644
index 00000000..d99291ab
--- /dev/null
+++ b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/BufferIterator.java
@@ -0,0 +1,35 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.ziputils.ziputil;
+
+/**
+ * modify by zhangshaowen on 16/6/7.
+ */
+public abstract class BufferIterator {
+    /**
+     * Seeks to the absolute position {@code offset}, measured in bytes from the start.
+     */
+    public abstract void seek(int offset);
+    /**
+     * Skips forwards or backwards {@code byteCount} bytes from the current position.
+     */
+    public abstract void skip(int byteCount);
+
+    public abstract int readInt();
+
+    public abstract short readShort();
+}
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/HeapBufferIterator.java b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/HeapBufferIterator.java
similarity index 74%
rename from tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/HeapBufferIterator.java
rename to third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/HeapBufferIterator.java
index d6591ce8..10ed4dd4 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/HeapBufferIterator.java
+++ b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/HeapBufferIterator.java
@@ -1,20 +1,20 @@
 /*
- * Copyright (C) 2010 The Android Open Source Project
+ * Tencent is pleased to support the open source community by making Tinker available.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
-package com.tencent.tinker.commons.ziputil;
+package com.tencent.tinker.ziputils.ziputil;
 
 import java.nio.ByteOrder;
 
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/Memory.java b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/Memory.java
similarity index 83%
rename from tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/Memory.java
rename to third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/Memory.java
index cf7b75dc..e09095d7 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/Memory.java
+++ b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/Memory.java
@@ -1,21 +1,20 @@
 /*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
+ * Tencent is pleased to support the open source community by making Tinker available.
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
  *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
-package com.tencent.tinker.commons.ziputil;
+package com.tencent.tinker.ziputils.ziputil;
 
 import java.nio.ByteOrder;
 
diff --git a/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/SizeOf.java b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/SizeOf.java
new file mode 100644
index 00000000..228cb97c
--- /dev/null
+++ b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/SizeOf.java
@@ -0,0 +1,31 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.ziputils.ziputil;
+
+/**
+ * modify by zhangshaowen on 16/6/7.
+ */
+public final class SizeOf {
+    public static final int CHAR = 2;
+    public static final int DOUBLE = 8;
+    public static final int FLOAT = 4;
+    public static final int INT = 4;
+    public static final int LONG = 8;
+    public static final int SHORT = 2;
+    private SizeOf() {
+    }
+}
diff --git a/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/StandardCharsets.java b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/StandardCharsets.java
new file mode 100644
index 00000000..0bdc98e6
--- /dev/null
+++ b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/StandardCharsets.java
@@ -0,0 +1,29 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.ziputils.ziputil;
+
+import java.nio.charset.Charset;
+
+/**
+ * modify by zhangshaowen on 16/6/7.
+ */
+public final class StandardCharsets {
+    public static final Charset UTF_8 = Charset.forName("UTF-8");
+
+    private StandardCharsets() {
+    }
+}
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/Streams.java b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/Streams.java
similarity index 91%
rename from tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/Streams.java
rename to third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/Streams.java
index 4af128a4..38df1bc7 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/Streams.java
+++ b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/Streams.java
@@ -1,20 +1,20 @@
 /*
- * Copyright (C) 2010 The Android Open Source Project
+ * Tencent is pleased to support the open source community by making Tinker available.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
-package com.tencent.tinker.commons.ziputil;
+package com.tencent.tinker.ziputils.ziputil;
 
 import java.io.ByteArrayOutputStream;
 import java.io.EOFException;
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/TinkerZipEntry.java b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/TinkerZipEntry.java
similarity index 92%
rename from tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/TinkerZipEntry.java
rename to third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/TinkerZipEntry.java
index 54510611..8e275cf2 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/TinkerZipEntry.java
+++ b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/TinkerZipEntry.java
@@ -1,21 +1,20 @@
 /*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
+ * Tencent is pleased to support the open source community by making Tinker available.
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
  *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
-package com.tencent.tinker.commons.ziputil;
+package com.tencent.tinker.ziputils.ziputil;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -107,6 +106,20 @@ public TinkerZipEntry(TinkerZipEntry ze) {
         localHeaderRelOffset = ze.localHeaderRelOffset;
         dataOffset = ze.dataOffset;
     }
+
+    public TinkerZipEntry(TinkerZipEntry ze, String name) {
+        this.name = name;
+        comment = ze.comment;
+        time = ze.time;
+        size = ze.size;
+        compressedSize = ze.compressedSize;
+        crc = ze.crc;
+        compressionMethod = ze.compressionMethod;
+        modDate = ze.modDate;
+        extra = ze.extra;
+        localHeaderRelOffset = ze.localHeaderRelOffset;
+        dataOffset = ze.dataOffset;
+    }
     /*
      * Internal constructor.  Creates a new ZipEntry by reading the
      * Central Directory Entry (CDE) from "in", which must be positioned
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/TinkerZipFile.java b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/TinkerZipFile.java
similarity index 96%
rename from tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/TinkerZipFile.java
rename to third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/TinkerZipFile.java
index dbc8f48b..e81d5f88 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/TinkerZipFile.java
+++ b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/TinkerZipFile.java
@@ -1,21 +1,20 @@
 /*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
+ * Tencent is pleased to support the open source community by making Tinker available.
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
  *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
-package com.tencent.tinker.commons.ziputil;
+package com.tencent.tinker.ziputils.ziputil;
 
 import java.io.BufferedInputStream;
 import java.io.Closeable;
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/TinkerZipOutputStream.java b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/TinkerZipOutputStream.java
similarity index 96%
rename from tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/TinkerZipOutputStream.java
rename to third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/TinkerZipOutputStream.java
index 62aabf47..02bc9a3f 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/TinkerZipOutputStream.java
+++ b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/TinkerZipOutputStream.java
@@ -1,21 +1,20 @@
 /*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
+ * Tencent is pleased to support the open source community by making Tinker available.
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
  *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
-package com.tencent.tinker.commons.ziputil;
+package com.tencent.tinker.ziputils.ziputil;
 
 // import libcore.util.CountingOutputStream;
 // import libcore.util.EmptyArray;
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/resutil/ResUtil.java b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/TinkerZipUtil.java
similarity index 78%
rename from tinker-commons/src/main/java/com/tencent/tinker/commons/resutil/ResUtil.java
rename to third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/TinkerZipUtil.java
index b9780090..24f61d28 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/resutil/ResUtil.java
+++ b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/TinkerZipUtil.java
@@ -14,12 +14,9 @@
  * limitations under the License.
  */
 
-package com.tencent.tinker.commons.resutil;
-
-import com.tencent.tinker.commons.ziputil.TinkerZipEntry;
-import com.tencent.tinker.commons.ziputil.TinkerZipFile;
-import com.tencent.tinker.commons.ziputil.TinkerZipOutputStream;
+package com.tencent.tinker.ziputils.ziputil;
 
+import java.io.BufferedInputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
@@ -28,7 +25,7 @@
 /**
  * Created by zhangshaowen on 16/8/10.
  */
-public class ResUtil {
+public class TinkerZipUtil {
     private static final int BUFFER_SIZE = 16384;
 
     public static void extractTinkerEntry(TinkerZipFile apk, TinkerZipEntry zipEntry, TinkerZipOutputStream outputStream) throws IOException {
@@ -49,6 +46,16 @@ public static void extractTinkerEntry(TinkerZipFile apk, TinkerZipEntry zipEntry
         }
     }
 
+    public static void extractTinkerEntry(TinkerZipEntry zipEntry, InputStream inputStream, TinkerZipOutputStream outputStream) throws IOException {
+        outputStream.putNextEntry(zipEntry);
+        byte[] buffer = new byte[BUFFER_SIZE];
+
+        for (int length = inputStream.read(buffer); length != -1; length = inputStream.read(buffer)) {
+            outputStream.write(buffer, 0, length);
+        }
+        outputStream.closeEntry();
+    }
+
     public static void extractLargeModifyFile(TinkerZipEntry sourceArscEntry, File newFile, long newFileCrc, TinkerZipOutputStream outputStream) throws IOException {
         TinkerZipEntry newArscZipEntry = new TinkerZipEntry(sourceArscEntry);
 
@@ -56,9 +63,9 @@ public static void extractLargeModifyFile(TinkerZipEntry sourceArscEntry, File n
         newArscZipEntry.setSize(newFile.length());
         newArscZipEntry.setCompressedSize(newFile.length());
         newArscZipEntry.setCrc(newFileCrc);
-        FileInputStream in = null;
+        BufferedInputStream in = null;
         try {
-            in = new FileInputStream(newFile);
+            in = new BufferedInputStream(new FileInputStream(newFile));
             outputStream.putNextEntry(new TinkerZipEntry(newArscZipEntry));
             byte[] buffer = new byte[BUFFER_SIZE];
 
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/ZipConstants.java b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/ZipConstants.java
similarity index 51%
rename from tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/ZipConstants.java
rename to third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/ZipConstants.java
index 2bb0e394..ca1873a2 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/ZipConstants.java
+++ b/third-party/tinker-ziputils/src/main/java/com/tencent/tinker/ziputils/ziputil/ZipConstants.java
@@ -1,21 +1,20 @@
 /*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
+ * Tencent is pleased to support the open source community by making Tinker available.
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
  *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
-package com.tencent.tinker.commons.ziputil;
+package com.tencent.tinker.ziputils.ziputil;
 
 /**
  * modify by zhangshaowen on 16/6/7.
diff --git a/tinker-android/tinker-android-anno/src/main/java/com/tencent/tinker/anno/DefaultLifeCycle.java b/tinker-android/tinker-android-anno/src/main/java/com/tencent/tinker/anno/DefaultLifeCycle.java
index ddd5db1b..275c0c90 100644
--- a/tinker-android/tinker-android-anno/src/main/java/com/tencent/tinker/anno/DefaultLifeCycle.java
+++ b/tinker-android/tinker-android-anno/src/main/java/com/tencent/tinker/anno/DefaultLifeCycle.java
@@ -39,6 +39,4 @@
     int flags();
 
     boolean loadVerifyFlag() default false;
-
-
 }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java
index 5fa176b2..26f7d4c2 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java
@@ -170,12 +170,26 @@ private static void installNativeLibraryPath(ClassLoader classLoader, File folde
             TinkerLog.e(TAG, "installNativeLibraryPath, folder %s is illegal", folder);
             return;
         }
-        if (Build.VERSION.SDK_INT >= 23) {
+        // android o sdk_int 26
+        // for android o preview sdk_int 25
+        if ((Build.VERSION.SDK_INT == 25 && Build.VERSION.PREVIEW_SDK_INT != 0)
+            || Build.VERSION.SDK_INT > 25) {
+            try {
+                V25.install(classLoader, folder);
+                return;
+            } catch (Throwable throwable) {
+                // install fail, try to treat it as v23
+                // some preview N version may go here
+                TinkerLog.e(TAG, "installNativeLibraryPath, v25 fail, sdk: %d, error: %s, try to fallback to V23",
+                        Build.VERSION.SDK_INT, throwable.getMessage());
+                V23.install(classLoader, folder);
+            }
+        } else if (Build.VERSION.SDK_INT >= 23) {
             try {
                 V23.install(classLoader, folder);
             } catch (Throwable throwable) {
                 // install fail, try to treat it as v14
-                TinkerLog.e(TAG, "installNativeLibraryPath, v23 fail, sdk: %d, error: %s",
+                TinkerLog.e(TAG, "installNativeLibraryPath, v23 fail, sdk: %d, error: %s, try to fallback to V14",
                     Build.VERSION.SDK_INT, throwable.getMessage());
 
                 V14.install(classLoader, folder);
@@ -235,4 +249,26 @@ private static void install(ClassLoader classLoader, File folder)  throws Throwa
         }
     }
 
+    private static final class V25 {
+        private static void install(ClassLoader classLoader, File folder)  throws Throwable {
+            Field pathListField = ShareReflectUtil.findField(classLoader, "pathList");
+            Object dexPathList = pathListField.get(classLoader);
+
+            Field nativeLibraryDirectories = ShareReflectUtil.findField(dexPathList, "nativeLibraryDirectories");
+
+            List<File> libDirs = (List<File>) nativeLibraryDirectories.get(dexPathList);
+            libDirs.add(0, folder);
+            Field systemNativeLibraryDirectories =
+                    ShareReflectUtil.findField(dexPathList, "systemNativeLibraryDirectories");
+            List<File> systemLibDirs = (List<File>) systemNativeLibraryDirectories.get(dexPathList);
+            Method makePathElements =
+                    ShareReflectUtil.findMethod(dexPathList, "makePathElements", List.class);
+            libDirs.addAll(systemLibDirs);
+            Object[] elements = (Object[]) makePathElements.
+                    invoke(dexPathList, libDirs);
+            Field nativeLibraryPathElements = ShareReflectUtil.findField(dexPathList, "nativeLibraryPathElements");
+            nativeLibraryPathElements.setAccessible(true);
+            nativeLibraryPathElements.set(dexPathList, elements);
+        }
+    }
 }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java
index 52651e30..7feebcef 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/listener/DefaultPatchListener.java
@@ -20,7 +20,9 @@
 
 import com.tencent.tinker.lib.service.TinkerPatchService;
 import com.tencent.tinker.lib.tinker.Tinker;
+import com.tencent.tinker.lib.tinker.TinkerLoadResult;
 import com.tencent.tinker.lib.util.TinkerServiceInternals;
+import com.tencent.tinker.lib.util.UpgradePatchRetry;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
 import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
@@ -46,8 +48,9 @@ public DefaultPatchListener(Context context) {
      */
     @Override
     public int onPatchReceived(String path) {
+        File patchFile = new File(path);
 
-        int returnCode = patchCheck(path);
+        int returnCode = patchCheck(path, SharePatchFileUtil.getMD5(patchFile));
 
         if (returnCode == ShareConstants.ERROR_PATCH_OK) {
             TinkerPatchService.runPatchService(context, path);
@@ -55,10 +58,9 @@ public int onPatchReceived(String path) {
             Tinker.with(context).getLoadReporter().onLoadPatchListenerReceiveFail(new File(path), returnCode);
         }
         return returnCode;
-
     }
 
-    protected int patchCheck(String path) {
+    protected int patchCheck(String path, String patchMd5) {
         Tinker manager = Tinker.with(context);
         //check SharePreferences also
         if (!manager.isTinkerEnabled() || !ShareTinkerInternals.isTinkerEnableWithSharedPreferences(context)) {
@@ -79,6 +81,26 @@ protected int patchCheck(String path) {
         if (TinkerServiceInternals.isTinkerPatchServiceRunning(context)) {
             return ShareConstants.ERROR_PATCH_RUNNING;
         }
+        if (ShareTinkerInternals.isVmJit()) {
+            return ShareConstants.ERROR_PATCH_JIT;
+        }
+
+        Tinker tinker = Tinker.with(context);
+
+        if (tinker.isTinkerLoaded()) {
+            TinkerLoadResult tinkerLoadResult = tinker.getTinkerLoadResultIfPresent();
+            if (tinkerLoadResult != null && !tinkerLoadResult.useInterpretMode) {
+                String currentVersion = tinkerLoadResult.currentVersion;
+                if (patchMd5.equals(currentVersion)) {
+                    return ShareConstants.ERROR_PATCH_ALREADY_APPLY;
+                }
+            }
+        }
+
+        if (!UpgradePatchRetry.getInstance(context).onPatchListenerCheck(patchMd5)) {
+            return ShareConstants.ERROR_PATCH_RETRY_COUNT_LIMIT;
+        }
+
         return ShareConstants.ERROR_PATCH_OK;
     }
 
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BasePatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BasePatchInternal.java
index 732166f2..78c0e3be 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BasePatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BasePatchInternal.java
@@ -16,6 +16,7 @@
 
 package com.tencent.tinker.lib.patch;
 
+import com.tencent.tinker.commons.util.StreamUtil;
 import com.tencent.tinker.lib.util.TinkerLog;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
@@ -25,6 +26,8 @@
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
 
@@ -36,7 +39,7 @@
 
     protected static final String DEX_PATH             = ShareConstants.DEX_PATH;
     protected static final String SO_PATH              = ShareConstants.SO_PATH;
-    protected static final String DEX_OPTIMIZE_PATH    = ShareConstants.DEX_OPTIMIZE_PATH;
+    protected static final String DEX_OPTIMIZE_PATH    = ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH;
     protected static final int    MAX_EXTRACT_ATTEMPTS = ShareConstants.MAX_EXTRACT_ATTEMPTS;
     protected static final String DEX_META_FILE        = ShareConstants.DEX_META_FILE;
     protected static final String SO_META_FILE         = ShareConstants.SO_META_FILE;
@@ -45,40 +48,46 @@
     protected static final int TYPE_DEX         = ShareConstants.TYPE_DEX;
     protected static final int TYPE_Library     = ShareConstants.TYPE_LIBRARY;
     protected static final int TYPE_RESOURCE    = ShareConstants.TYPE_RESOURCE;
+    protected static final int TYPE_CLASS_N_DEX = ShareConstants.TYPE_CLASS_N_DEX;
+
 
     public static boolean extract(ZipFile zipFile, ZipEntry entryFile, File extractTo, String targetMd5, boolean isDex) throws IOException {
         int numAttempts = 0;
         boolean isExtractionSuccessful = false;
         while (numAttempts < MAX_EXTRACT_ATTEMPTS && !isExtractionSuccessful) {
             numAttempts++;
-            BufferedInputStream bis = new BufferedInputStream(zipFile.getInputStream(entryFile));
-            FileOutputStream fos = new FileOutputStream(extractTo);
-            BufferedOutputStream out = new BufferedOutputStream(fos);
+            InputStream is = null;
+            OutputStream os = null;
 
             TinkerLog.i(TAG, "try Extracting " + extractTo.getPath());
 
             try {
+                is = new BufferedInputStream(zipFile.getInputStream(entryFile));
+                os = new BufferedOutputStream(new FileOutputStream(extractTo));
                 byte[] buffer = new byte[ShareConstants.BUFFER_SIZE];
-                int length = bis.read(buffer);
-                while (length != -1) {
-                    out.write(buffer, 0, length);
-                    length = bis.read(buffer);
+                int length = 0;
+                while ((length = is.read(buffer)) > 0) {
+                    os.write(buffer, 0, length);
                 }
             } finally {
-                SharePatchFileUtil.closeQuietly(out);
-                SharePatchFileUtil.closeQuietly(bis);
+                StreamUtil.closeQuietly(os);
+                StreamUtil.closeQuietly(is);
             }
-
-            if (isDex) {
-                isExtractionSuccessful = SharePatchFileUtil.verifyDexFileMd5(extractTo, targetMd5);
+            if (targetMd5 != null) {
+                if (isDex) {
+                    isExtractionSuccessful = SharePatchFileUtil.verifyDexFileMd5(extractTo, targetMd5);
+                } else {
+                    isExtractionSuccessful = SharePatchFileUtil.verifyFileMd5(extractTo, targetMd5);
+                }
             } else {
-                isExtractionSuccessful = SharePatchFileUtil.verifyFileMd5(extractTo, targetMd5);
+                // treat it as true
+                isExtractionSuccessful = true;
             }
             TinkerLog.i(TAG, "isExtractionSuccessful: %b", isExtractionSuccessful);
 
             if (!isExtractionSuccessful) {
-                extractTo.delete();
-                if (extractTo.exists()) {
+                final boolean succ = extractTo.delete();
+                if (!succ || extractTo.exists()) {
                     TinkerLog.e(TAG, "Failed to delete corrupted dex " + extractTo.getPath());
                 }
             }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BsDiffPatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BsDiffPatchInternal.java
index 7414b007..8a0b8a31 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BsDiffPatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/BsDiffPatchInternal.java
@@ -21,6 +21,7 @@
 import android.os.SystemClock;
 
 import com.tencent.tinker.bsdiff.BSPatch;
+import com.tencent.tinker.commons.util.StreamUtil;
 import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.util.TinkerLog;
 import com.tencent.tinker.loader.TinkerRuntimeException;
@@ -182,8 +183,8 @@ private static boolean extractBsDiffInternals(Context context, String dir, Strin
                         newStream = patch.getInputStream(patchFileEntry);
                         BSPatch.patchFast(oldStream, newStream, extractedFile);
                     } finally {
-                        SharePatchFileUtil.closeQuietly(oldStream);
-                        SharePatchFileUtil.closeQuietly(newStream);
+                        StreamUtil.closeQuietly(oldStream);
+                        StreamUtil.closeQuietly(newStream);
                     }
 
                     //go go go bsdiff get the
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
index fa72d59b..eb1b83e5 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
@@ -18,18 +18,25 @@
 
 import android.content.Context;
 import android.content.pm.ApplicationInfo;
+import android.os.Build;
 import android.os.SystemClock;
 
 import com.tencent.tinker.commons.dexpatcher.DexPatchApplier;
+import com.tencent.tinker.commons.util.StreamUtil;
 import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.util.TinkerLog;
-import com.tencent.tinker.loader.TinkerParallelDexOptimizer;
+import com.tencent.tinker.loader.TinkerDexOptimizer;
 import com.tencent.tinker.loader.TinkerRuntimeException;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.ShareDexDiffPatchInfo;
+import com.tencent.tinker.loader.shareutil.ShareElfFile;
 import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
 import com.tencent.tinker.loader.shareutil.ShareSecurityCheck;
 import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
+import com.tencent.tinker.ziputils.ziputil.TinkerZipEntry;
+import com.tencent.tinker.ziputils.ziputil.TinkerZipFile;
+import com.tencent.tinker.ziputils.ziputil.TinkerZipOutputStream;
+import com.tencent.tinker.ziputils.ziputil.TinkerZipUtil;
 
 import java.io.BufferedInputStream;
 import java.io.BufferedOutputStream;
@@ -38,6 +45,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Vector;
 import java.util.zip.ZipEntry;
@@ -45,19 +53,19 @@
 import java.util.zip.ZipInputStream;
 import java.util.zip.ZipOutputStream;
 
-import dalvik.system.DexFile;
-
 /**
  * Created by zhangshaowen on 16/4/12.
  */
 public class DexDiffPatchInternal extends BasePatchInternal {
     protected static final String TAG = "Tinker.DexDiffPatchInternal";
 
-    protected static final int WAIT_ASYN_OAT_TIME = 8 * 1000;
+    protected static final int WAIT_ASYN_OAT_TIME = 15 * 1000;
     protected static final int MAX_WAIT_COUNT     = 30;
 
-    private static ArrayList<File> optFiles = new ArrayList<>();
-    private static List<File> failOptDexFile = new Vector<>();
+    private static ArrayList<File>                      optFiles      = new ArrayList<>();
+    private static ArrayList<ShareDexDiffPatchInfo>     patchList     = new ArrayList<>();
+    private static HashMap<ShareDexDiffPatchInfo, File> classNDexInfo = new HashMap<>();
+    private static boolean                              isVmArt       = ShareTinkerInternals.isVmArt();
 
 
     protected static boolean tryRecoverDexFiles(Tinker manager, ShareSecurityCheck checker, Context context,
@@ -80,16 +88,16 @@ protected static boolean tryRecoverDexFiles(Tinker manager, ShareSecurityCheck c
         return result;
     }
 
-    protected static boolean waitDexOptFile() {
+    protected static boolean waitAndCheckDexOptFile(File patchFile, Tinker manager) {
         if (optFiles.isEmpty()) {
             return true;
         }
-
-        int size = optFiles.size() * 6;
+        // should use patch list size
+        int size = patchList.size() * 8;
         if (size > MAX_WAIT_COUNT) {
             size = MAX_WAIT_COUNT;
         }
-        TinkerLog.i(TAG, "dex count: %d, final wait time: %d", optFiles.size(), size);
+        TinkerLog.i(TAG, "raw dex count: %d, dex opt dex count: %d, final wait times: %d", patchList.size(), optFiles.size(), size);
 
         for (int i = 0; i < size; i++) {
             if (!checkAllDexOptFile(optFiles, i + 1)) {
@@ -100,19 +108,53 @@ protected static boolean waitDexOptFile() {
                 }
             }
         }
-
+        List<File> failDexFiles = new ArrayList<>();
         // check again, if still can be found, just return
         for (File file : optFiles) {
-            TinkerLog.i(TAG, "check dex optimizer file %s, size %d", file.getName(), file.length());
+            TinkerLog.i(TAG, "check dex optimizer file exist: %s, size %d", file.getPath(), file.length());
 
             if (!SharePatchFileUtil.isLegalFile(file)) {
                 TinkerLog.e(TAG, "final parallel dex optimizer file %s is not exist, return false", file.getName());
-                // don't report fail
-//                manager.getPatchReporter()
-//                    .onPatchDexOptFail(patchFile, file, file.getParentFile().getPath(),
-//                        file.getName(), new TinkerRuntimeException("dexOpt file:" + file.getName() + " is not exist"));
-                return false;
+                failDexFiles.add(file);
+            }
+        }
+        if (!failDexFiles.isEmpty()) {
+            manager.getPatchReporter().onPatchDexOptFail(patchFile, failDexFiles,
+                new TinkerRuntimeException(ShareConstants.CHECK_DEX_OAT_EXIST_FAIL));
+            return false;
+        }
+        if (Build.VERSION.SDK_INT >= 21) {
+            Throwable lastThrowable = null;
+            for (File file : optFiles) {
+                TinkerLog.i(TAG, "check dex optimizer file format: %s, size %d", file.getName(), file.length());
+                int returnType;
+                try {
+                    returnType = ShareElfFile.getFileTypeByMagic(file);
+                } catch (IOException e) {
+                    // read error just continue
+                    continue;
+                }
+                if (returnType == ShareElfFile.FILE_TYPE_ELF) {
+                    ShareElfFile elfFile = null;
+                    try {
+                        elfFile = new ShareElfFile(file);
+                    } catch (Throwable e) {
+                        TinkerLog.e(TAG, "final parallel dex optimizer file %s is not elf format, return false", file.getName());
+                        failDexFiles.add(file);
+                        lastThrowable = e;
+                    } finally {
+                        StreamUtil.closeQuietly(elfFile);
+                    }
+                }
+            }
+            if (!failDexFiles.isEmpty()) {
+                Throwable returnThrowable = lastThrowable == null
+                    ? new TinkerRuntimeException(ShareConstants.CHECK_DEX_OAT_FORMAT_FAIL)
+                    : new TinkerRuntimeException(ShareConstants.CHECK_DEX_OAT_FORMAT_FAIL, lastThrowable);
 
+                manager.getPatchReporter().onPatchDexOptFail(patchFile, failDexFiles,
+                    returnThrowable);
+                return false;
             }
         }
         return true;
@@ -126,14 +168,149 @@ private static boolean patchDexExtractViaDexDiff(Context context, String patchVe
             return false;
         }
 
-        final Tinker manager = Tinker.with(context);
-
         File dexFiles = new File(dir);
         File[] files = dexFiles.listFiles();
+        List<File> legalFiles = new ArrayList<>();
+        // may have directory in android o
+        if (files != null) {
+            for (File file : files) {
+                if (file.isFile()) {
+                    legalFiles.add(file);
+                }
+            }
+        }
+
+        final String optimizeDexDirectory = patchVersionDirectory + "/" + DEX_OPTIMIZE_PATH + "/";
+        return dexOptimizeDexFiles(context, legalFiles, optimizeDexDirectory, patchFile);
+
+    }
+
+    private static boolean checkClassNDexFiles(final String dexFilePath) {
+       if (patchList.isEmpty() || !isVmArt) {
+            return false;
+        }
+        ShareDexDiffPatchInfo testInfo = null;
+        File testFile = null;
+
+        for (ShareDexDiffPatchInfo info : patchList) {
+            File dexFile = new File(dexFilePath + info.realName);
+            String fileName = dexFile.getName();
+
+            if (ShareConstants.CLASS_N_PATTERN.matcher(fileName).matches()) {
+                classNDexInfo.put(info, dexFile);
+            }
+            if (info.rawName.startsWith(ShareConstants.TEST_DEX_NAME)) {
+                testInfo = info;
+                testFile = dexFile;
+            }
+        }
+        if (testInfo != null) {
+            classNDexInfo.put(ShareTinkerInternals.changeTestDexToClassN(testInfo, classNDexInfo.size() + 1), testFile);
+        }
+
+        File classNFile = new File(dexFilePath, ShareConstants.CLASS_N_APK_NAME);
+        boolean result = true;
+        if (classNFile.exists()) {
+            for (ShareDexDiffPatchInfo info : classNDexInfo.keySet()) {
+                if (!SharePatchFileUtil.verifyDexFileMd5(classNFile, info.rawName, info.destMd5InArt)) {
+                    TinkerLog.e(TAG, "verify dex file md5 error, entry name; %s, file len: %d", info.rawName, classNFile.length());
+                    result = false;
+                    break;
+                }
+            }
+            if (!result) {
+                SharePatchFileUtil.safeDeleteFile(classNFile);
+            }
+        } else {
+            result = false;
+        }
+
+        if (result) {
+            // delete classN dex if exist
+            for (File dexFile : classNDexInfo.values()) {
+                SharePatchFileUtil.safeDeleteFile(dexFile);
+            }
+        }
+
+        return result;
+    }
+
+    private static boolean mergeClassNDexFiles(final Context context, final File patchFile, final String dexFilePath) {
+        // only merge for art vm
+        if (patchList.isEmpty() || !isVmArt) {
+            return true;
+        }
+
+        File classNFile = new File(dexFilePath, ShareConstants.CLASS_N_APK_NAME);
+
+        // repack just more than one classN.dex
+        if (classNDexInfo.isEmpty()) {
+            TinkerLog.w(TAG, "classNDexInfo size: %d, no need to merge classN dex files", classNDexInfo.size());
+            return true;
+        }
+        long start = System.currentTimeMillis();
+        boolean result = true;
+        TinkerZipOutputStream out = null;
+        try {
+            out = new TinkerZipOutputStream(new BufferedOutputStream(new FileOutputStream(classNFile)));
+            for (ShareDexDiffPatchInfo info : classNDexInfo.keySet()) {
+                File dexFile = classNDexInfo.get(info);
+
+                if (info.isJarMode) {
+                    TinkerZipFile dexZipFile = null;
+                    InputStream inputStream = null;
+                    try {
+                        dexZipFile = new TinkerZipFile(dexFile);
+                        TinkerZipEntry rawDexZipEntry = dexZipFile.getEntry(ShareConstants.DEX_IN_JAR);
+                        TinkerZipEntry newDexZipEntry = new TinkerZipEntry(rawDexZipEntry, info.rawName);
+                        inputStream = dexZipFile.getInputStream(rawDexZipEntry);
+                        TinkerZipUtil.extractTinkerEntry(newDexZipEntry, inputStream, out);
+                    } finally {
+                        StreamUtil.closeQuietly(inputStream);
+                        StreamUtil.closeQuietly(dexZipFile);
+                    }
+                } else {
+                    TinkerZipEntry dexZipEntry = new TinkerZipEntry(info.rawName);
+                    TinkerZipUtil.extractLargeModifyFile(dexZipEntry, dexFile, Long.parseLong(info.newDexCrC), out);
+                }
+
+            }
+        } catch (Throwable throwable) {
+            TinkerLog.printErrStackTrace(TAG, throwable, "merge classN file");
+            result = false;
+        } finally {
+            StreamUtil.closeQuietly(out);
+        }
+
+        if (result) {
+            for (ShareDexDiffPatchInfo info : classNDexInfo.keySet()) {
+                if (!SharePatchFileUtil.verifyDexFileMd5(classNFile, info.rawName, info.destMd5InArt)) {
+                    result = false;
+                    TinkerLog.e(TAG, "verify dex file md5 error, entry name; %s, file len: %d", info.rawName, classNFile.length());
+                    break;
+                }
+            }
+        }
+        if (result) {
+            for (File dexFile : classNDexInfo.values()) {
+                SharePatchFileUtil.safeDeleteFile(dexFile);
+            }
+        } else {
+            TinkerLog.e(TAG, "merge classN dex error, try delete temp file");
+            SharePatchFileUtil.safeDeleteFile(classNFile);
+            Tinker.with(context).getPatchReporter().onPatchTypeExtractFail(patchFile, classNFile, classNFile.getName(), TYPE_CLASS_N_DEX);
+        }
+        TinkerLog.i(TAG, "merge classN dex file %s, result: %b, size: %d, use: %dms",
+            classNFile.getPath(), result, classNFile.length(), (System.currentTimeMillis() - start));
+        return result;
+    }
+
+    private static boolean dexOptimizeDexFiles(Context context, List<File> dexFiles, String optimizeDexDirectory, final File patchFile) {
+        final Tinker manager = Tinker.with(context);
+
         optFiles.clear();
 
-        if (files != null) {
-            final String optimizeDexDirectory = patchVersionDirectory + "/" + DEX_OPTIMIZE_PATH + "/";
+        if (dexFiles != null) {
             File optimizeDexDirectoryFile = new File(optimizeDexDirectory);
 
             if (!optimizeDexDirectoryFile.exists() && !optimizeDexDirectoryFile.mkdirs()) {
@@ -141,80 +318,49 @@ private static boolean patchDexExtractViaDexDiff(Context context, String patchVe
                 return false;
             }
             // add opt files
-            for (File file : files) {
+            for (File file : dexFiles) {
                 String outputPathName = SharePatchFileUtil.optimizedPathFor(file, optimizeDexDirectoryFile);
                 optFiles.add(new File(outputPathName));
             }
 
-            TinkerLog.w(TAG, "patch recover, try to optimize dex file count:%d", files.length);
-
+            TinkerLog.i(TAG, "patch recover, try to optimize dex file count:%d, optimizeDexDirectory:%s", dexFiles.size(), optimizeDexDirectory);
             // only use parallel dex optimizer for art
-            if (ShareTinkerInternals.isVmArt()) {
-                failOptDexFile.clear();
-                // try parallel dex optimizer
-                TinkerParallelDexOptimizer.optimizeAll(
-                    files, optimizeDexDirectoryFile,
-                    new TinkerParallelDexOptimizer.ResultCallback() {
-                        long startTime;
-
-                        @Override
-                        public void onStart(File dexFile, File optimizedDir) {
-                            startTime = System.currentTimeMillis();
-                            TinkerLog.i(TAG, "start to parallel optimize dex %s, size: %d", dexFile.getPath(), dexFile.length());
-                        }
-
-                        @Override
-                        public void onSuccess(File dexFile, File optimizedDir, File optimizedFile) {
-                            // Do nothing.
-                            TinkerLog.i(TAG, "success to parallel optimize dex %s, opt file size: %d, use time %d",
-                                dexFile.getPath(), optimizedFile.length(), (System.currentTimeMillis() - startTime));
-                        }
-
-                        @Override
-                        public void onFailed(File dexFile, File optimizedDir, Throwable thr) {
-                            TinkerLog.i(TAG, "fail to parallel optimize dex %s use time %d",
-                                dexFile.getPath(), (System.currentTimeMillis() - startTime));
-                            failOptDexFile.add(dexFile);
-                        }
+            // for Android O version, it is very strange. If we use parallel dex optimizer, it won't work
+            final List<File> failOptDexFile = new Vector<>();
+            final Throwable[] throwable = new Throwable[1];
+
+            // try parallel dex optimizer
+            TinkerDexOptimizer.optimizeAll(
+                    dexFiles, optimizeDexDirectoryFile,
+                new TinkerDexOptimizer.ResultCallback() {
+                    long startTime;
+
+                    @Override
+                    public void onStart(File dexFile, File optimizedDir) {
+                        startTime = System.currentTimeMillis();
+                        TinkerLog.i(TAG, "start to parallel optimize dex %s, size: %d", dexFile.getPath(), dexFile.length());
                     }
-                );
-                // try again
-                for (File retryDexFile : failOptDexFile) {
-                    try {
-                        String outputPathName = SharePatchFileUtil.optimizedPathFor(retryDexFile, optimizeDexDirectoryFile);
-
-                        if (!SharePatchFileUtil.isLegalFile(retryDexFile)) {
-                            manager.getPatchReporter().onPatchDexOptFail(patchFile, retryDexFile,
-                                optimizeDexDirectory, retryDexFile.getName(), new TinkerRuntimeException("retry dex optimize file is not exist, name: " + retryDexFile.getName()));
-                            return false;
-                        }
-                        TinkerLog.i(TAG, "try to retry dex optimize file, path: %s, size: %d", retryDexFile.getPath(), retryDexFile.length());
-                        long start = System.currentTimeMillis();
-                        DexFile.loadDex(retryDexFile.getAbsolutePath(), outputPathName, 0);
 
-                        TinkerLog.i(TAG, "success retry dex optimize file, path: %s, opt file size: %d, use time: %d",
-                            retryDexFile.getPath(), new File(outputPathName).length(), (System.currentTimeMillis() - start));
-                    } catch (Throwable e) {
-                        TinkerLog.e(TAG, "retry dex optimize or load failed, path:" + retryDexFile.getPath());
-                        manager.getPatchReporter().onPatchDexOptFail(patchFile, retryDexFile, optimizeDexDirectory, retryDexFile.getName(), e);
-                        return false;
+                    @Override
+                    public void onSuccess(File dexFile, File optimizedDir, File optimizedFile) {
+                        // Do nothing.
+                        TinkerLog.i(TAG, "success to parallel optimize dex %s, opt file:%s, opt file size: %d, use time %d",
+                            dexFile.getPath(), optimizedFile.getPath(), optimizedFile.length(), (System.currentTimeMillis() - startTime));
                     }
-                }
-            // for dalvik, machine hardware performance is much worse than art machine
-            } else {
-                for (File file : files) {
-                    try {
-                        String outputPathName = SharePatchFileUtil.optimizedPathFor(file, optimizeDexDirectoryFile);
-                        long start = System.currentTimeMillis();
-                        DexFile.loadDex(file.getAbsolutePath(), outputPathName, 0);
-                        TinkerLog.i(TAG, "success single dex optimize file, path: %s, opt file size: %d, use time: %d", file.getPath(), new File(outputPathName).length(),
-                            (System.currentTimeMillis() - start));
-                    } catch (Throwable e) {
-                        TinkerLog.e(TAG, "single dex optimize or load failed, path:" + file.getPath());
-                        manager.getPatchReporter().onPatchDexOptFail(patchFile, file, optimizeDexDirectory, file.getName(), e);
-                        return false;
+
+                    @Override
+                    public void onFailed(File dexFile, File optimizedDir, Throwable thr) {
+                        TinkerLog.i(TAG, "fail to parallel optimize dex %s use time %d",
+                            dexFile.getPath(), (System.currentTimeMillis() - startTime));
+                        failOptDexFile.add(dexFile);
+                        throwable[0] = thr;
                     }
                 }
+            );
+
+            if (!failOptDexFile.isEmpty()) {
+                manager.getPatchReporter().onPatchDexOptFail(patchFile, failOptDexFile, throwable[0]);
+                return false;
             }
         }
         return true;
@@ -223,6 +369,7 @@ public void onFailed(File dexFile, File optimizedDir, Throwable thr) {
     /**
      * for ViVo or some other rom, they would make dex2oat asynchronous
      * so we need to check whether oat file is actually generated.
+     *
      * @param files
      * @param count
      * @return
@@ -239,8 +386,7 @@ private static boolean checkAllDexOptFile(ArrayList<File> files, int count) {
 
     private static boolean extractDexDiffInternals(Context context, String dir, String meta, File patchFile, int type) {
         //parse
-        ArrayList<ShareDexDiffPatchInfo> patchList = new ArrayList<>();
-
+        patchList.clear();
         ShareDexDiffPatchInfo.parseDexDiffPatchInfo(meta, patchList);
 
         if (patchList.isEmpty()) {
@@ -263,10 +409,14 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
                 TinkerLog.w(TAG, "applicationInfo == null!!!!");
                 return false;
             }
+
             String apkPath = applicationInfo.sourceDir;
             apk = new ZipFile(apkPath);
             patch = new ZipFile(patchFile);
-
+            if (checkClassNDexFiles(dir)) {
+                TinkerLog.w(TAG, "class n dex file %s is already exist, and md5 match, just continue", ShareConstants.CLASS_N_APK_NAME);
+                return true;
+            }
             for (ShareDexDiffPatchInfo info : patchList) {
                 long start = System.currentTimeMillis();
 
@@ -281,11 +431,11 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
                 String dexDiffMd5 = info.dexDiffMd5;
                 String oldDexCrc = info.oldDexCrC;
 
-                if (!ShareTinkerInternals.isVmArt() && info.destMd5InDvm.equals("0")) {
+                if (!isVmArt && info.destMd5InDvm.equals("0")) {
                     TinkerLog.w(TAG, "patch dex %s is only for art, just continue", patchRealPath);
                     continue;
                 }
-                String extractedFileMd5 = ShareTinkerInternals.isVmArt() ? info.destMd5InArt : info.destMd5InDvm;
+                String extractedFileMd5 = isVmArt ? info.destMd5InArt : info.destMd5InDvm;
 
                 if (!SharePatchFileUtil.checkIfMd5Valid(extractedFileMd5)) {
                     TinkerLog.w(TAG, "meta file md5 invalid, type:%s, name: %s, md5: %s", ShareTinkerInternals.getTypeString(type), info.rawName, extractedFileMd5);
@@ -327,7 +477,7 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
                     }
                 } else if (dexDiffMd5.equals("0")) {
                     // skip process old dex for real dalvik vm
-                    if (!ShareTinkerInternals.isVmArt()) {
+                    if (!isVmArt) {
                         continue;
                     }
 
@@ -391,9 +541,12 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
                     }
 
                     TinkerLog.w(TAG, "success recover dex file: %s, size: %d, use time: %d",
-                            extractedFile.getPath(), extractedFile.length(), (System.currentTimeMillis() - start));
+                        extractedFile.getPath(), extractedFile.length(), (System.currentTimeMillis() - start));
                 }
             }
+            if (!mergeClassNDexFiles(context, patchFile, dir)) {
+                return false;
+            }
         } catch (Throwable e) {
             throw new TinkerRuntimeException("patch " + ShareTinkerInternals.getTypeString(type) + " extract failed (" + e.getMessage() + ").", e);
         } finally {
@@ -419,17 +572,14 @@ private static boolean extractDexToJar(ZipFile zipFile, ZipEntry entryFile, File
         while (numAttempts < MAX_EXTRACT_ATTEMPTS && !isExtractionSuccessful) {
             numAttempts++;
 
-            FileOutputStream fos = new FileOutputStream(extractTo);
-            InputStream in = zipFile.getInputStream(entryFile);
-
             ZipOutputStream zos = null;
             BufferedInputStream bis = null;
 
             TinkerLog.i(TAG, "try Extracting " + extractTo.getPath());
             try {
                 zos = new ZipOutputStream(new
-                        BufferedOutputStream(fos));
-                bis = new BufferedInputStream(in);
+                    BufferedOutputStream(new FileOutputStream(extractTo)));
+                bis = new BufferedInputStream(zipFile.getInputStream(entryFile));
 
                 byte[] buffer = new byte[ShareConstants.BUFFER_SIZE];
                 ZipEntry entry = new ZipEntry(ShareConstants.DEX_IN_JAR);
@@ -441,16 +591,16 @@ private static boolean extractDexToJar(ZipFile zipFile, ZipEntry entryFile, File
                 }
                 zos.closeEntry();
             } finally {
-                SharePatchFileUtil.closeQuietly(bis);
-                SharePatchFileUtil.closeQuietly(zos);
+                StreamUtil.closeQuietly(bis);
+                StreamUtil.closeQuietly(zos);
             }
 
             isExtractionSuccessful = SharePatchFileUtil.verifyDexFileMd5(extractTo, targetMd5);
             TinkerLog.i(TAG, "isExtractionSuccessful: %b", isExtractionSuccessful);
 
             if (!isExtractionSuccessful) {
-                extractTo.delete();
-                if (extractTo.exists()) {
+                final boolean succ = extractTo.delete();
+                if (!succ || extractTo.exists()) {
                     TinkerLog.e(TAG, "Failed to delete corrupted dex " + extractTo.getPath());
                 }
             }
@@ -469,7 +619,7 @@ private static boolean extractDexToJar(ZipFile zipFile, ZipEntry entryFile, File
 //    }
 
     private static boolean extractDexFile(ZipFile zipFile, ZipEntry entryFile, File extractTo, ShareDexDiffPatchInfo dexInfo) throws IOException {
-        final String fileMd5 = ShareTinkerInternals.isVmArt() ? dexInfo.destMd5InArt : dexInfo.destMd5InDvm;
+        final String fileMd5 = isVmArt ? dexInfo.destMd5InArt : dexInfo.destMd5InDvm;
         final String rawName = dexInfo.rawName;
         final boolean isJarMode = dexInfo.isJarMode;
         //it is raw dex and we use jar mode, so we need to zip it!
@@ -481,26 +631,20 @@ private static boolean extractDexFile(ZipFile zipFile, ZipEntry entryFile, File
 
     /**
      * Generate patched dex file (May wrapped it by a jar if needed.)
-     * @param baseApk
-     *   OldApk.
-     * @param patchPkg
-     *   Patch package, it is also a zip file.
-     * @param oldDexEntry
-     *   ZipEntry of old dex.
-     * @param patchFileEntry
-     *   ZipEntry of patch file. (also ends with .dex) This could be null.
-     * @param patchInfo
-     *   Parsed patch info from package-meta.txt
-     * @param patchedDexFile
-     *   Patched dex file, may be a jar.
-     *
-     * <b>Notice: patchFileEntry and smallPatchInfoFile cannot both be null.</b>
      *
+     * @param baseApk        OldApk.
+     * @param patchPkg       Patch package, it is also a zip file.
+     * @param oldDexEntry    ZipEntry of old dex.
+     * @param patchFileEntry ZipEntry of patch file. (also ends with .dex) This could be null.
+     * @param patchInfo      Parsed patch info from package-meta.txt
+     * @param patchedDexFile Patched dex file, may be a jar.
+     *                       <p>
+     *                       <b>Notice: patchFileEntry and smallPatchInfoFile cannot both be null.</b>
      * @throws IOException
      */
     private static void patchDexFile(
-            ZipFile baseApk, ZipFile patchPkg, ZipEntry oldDexEntry, ZipEntry patchFileEntry,
-            ShareDexDiffPatchInfo patchInfo,  File patchedDexFile) throws IOException {
+        ZipFile baseApk, ZipFile patchPkg, ZipEntry oldDexEntry, ZipEntry patchFileEntry,
+        ShareDexDiffPatchInfo patchInfo, File patchedDexFile) throws IOException {
         InputStream oldDexStream = null;
         InputStream patchFileStream = null;
         try {
@@ -527,21 +671,21 @@ private static void patchDexFile(
                             }
                             new DexPatchApplier(zis, patchFileStream).executeAndSaveTo(zos);
                         } finally {
-                            SharePatchFileUtil.closeQuietly(zis);
+                            StreamUtil.closeQuietly(zis);
                         }
                     } else {
                         new DexPatchApplier(oldDexStream, patchFileStream).executeAndSaveTo(zos);
                     }
                     zos.closeEntry();
                 } finally {
-                    SharePatchFileUtil.closeQuietly(zos);
+                    StreamUtil.closeQuietly(zos);
                 }
             } else {
                 new DexPatchApplier(oldDexStream, patchFileStream).executeAndSaveTo(patchedDexFile);
             }
         } finally {
-            SharePatchFileUtil.closeQuietly(oldDexStream);
-            SharePatchFileUtil.closeQuietly(patchFileStream);
+            StreamUtil.closeQuietly(oldDexStream);
+            StreamUtil.closeQuietly(patchFileStream);
         }
     }
 
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/ResDiffPatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/ResDiffPatchInternal.java
index 5bdbf310..cfd9ebf9 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/ResDiffPatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/ResDiffPatchInternal.java
@@ -21,10 +21,7 @@
 import android.os.SystemClock;
 
 import com.tencent.tinker.bsdiff.BSPatch;
-import com.tencent.tinker.commons.resutil.ResUtil;
-import com.tencent.tinker.commons.ziputil.TinkerZipEntry;
-import com.tencent.tinker.commons.ziputil.TinkerZipFile;
-import com.tencent.tinker.commons.ziputil.TinkerZipOutputStream;
+import com.tencent.tinker.commons.util.StreamUtil;
 import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.util.TinkerLog;
 import com.tencent.tinker.loader.TinkerRuntimeException;
@@ -33,6 +30,10 @@
 import com.tencent.tinker.loader.shareutil.ShareResPatchInfo;
 import com.tencent.tinker.loader.shareutil.ShareSecurityCheck;
 import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
+import com.tencent.tinker.ziputils.ziputil.TinkerZipEntry;
+import com.tencent.tinker.ziputils.ziputil.TinkerZipFile;
+import com.tencent.tinker.ziputils.ziputil.TinkerZipOutputStream;
+import com.tencent.tinker.ziputils.ziputil.TinkerZipUtil;
 
 import java.io.BufferedOutputStream;
 import java.io.File;
@@ -94,6 +95,8 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
         }
         File directory = new File(dir);
 
+        File tempResFileDirectory = new File(directory, "res_temp");
+
         File resOutput = new File(directory, ShareConstants.RES_NAME);
         //check result file whether already exist
         if (resOutput.exists()) {
@@ -118,7 +121,8 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
             }
             String apkPath = applicationInfo.sourceDir;
 
-            if (!checkAndExtractResourceLargeFile(context, apkPath, directory, patchFile, resPatchInfo, type)) {
+
+            if (!checkAndExtractResourceLargeFile(context, apkPath, directory, tempResFileDirectory, patchFile, resPatchInfo, type)) {
                 return false;
             }
 
@@ -146,7 +150,7 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
                             && !resPatchInfo.modRes.contains(name)
                             && !resPatchInfo.largeModRes.contains(name)
                             && !name.equals(ShareConstants.RES_MANIFEST)) {
-                            ResUtil.extractTinkerEntry(oldApk, zipEntry, out);
+                            TinkerZipUtil.extractTinkerEntry(oldApk, zipEntry, out);
                             totalEntryCount++;
                         }
                     }
@@ -159,7 +163,7 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
                     manager.getPatchReporter().onPatchTypeExtractFail(patchFile, resOutput, ShareConstants.RES_MANIFEST, type);
                     return false;
                 }
-                ResUtil.extractTinkerEntry(oldApk, manifestZipEntry, out);
+                TinkerZipUtil.extractTinkerEntry(oldApk, manifestZipEntry, out);
                 totalEntryCount++;
 
                 for (String name : resPatchInfo.largeModRes) {
@@ -170,7 +174,7 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
                         return false;
                     }
                     ShareResPatchInfo.LargeModeInfo largeModeInfo = resPatchInfo.largeModMap.get(name);
-                    ResUtil.extractLargeModifyFile(largeZipEntry, largeModeInfo.file, largeModeInfo.crc, out);
+                    TinkerZipUtil.extractLargeModifyFile(largeZipEntry, largeModeInfo.file, largeModeInfo.crc, out);
                     totalEntryCount++;
                 }
 
@@ -181,7 +185,12 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
                         manager.getPatchReporter().onPatchTypeExtractFail(patchFile, resOutput, name, type);
                         return false;
                     }
-                    ResUtil.extractTinkerEntry(newApk, addZipEntry, out);
+                    if (resPatchInfo.storeRes.containsKey(name)) {
+                        File storeFile = resPatchInfo.storeRes.get(name);
+                        TinkerZipUtil.extractLargeModifyFile(addZipEntry, storeFile, addZipEntry.getCrc(), out);
+                    } else {
+                        TinkerZipUtil.extractTinkerEntry(newApk, addZipEntry, out);
+                    }
                     totalEntryCount++;
                 }
 
@@ -192,23 +201,23 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
                         manager.getPatchReporter().onPatchTypeExtractFail(patchFile, resOutput, name, type);
                         return false;
                     }
-                    ResUtil.extractTinkerEntry(newApk, modZipEntry, out);
+                    if (resPatchInfo.storeRes.containsKey(name)) {
+                        File storeFile = resPatchInfo.storeRes.get(name);
+                        TinkerZipUtil.extractLargeModifyFile(modZipEntry, storeFile, modZipEntry.getCrc(), out);
+                    } else {
+                        TinkerZipUtil.extractTinkerEntry(newApk, modZipEntry, out);
+                    }
                     totalEntryCount++;
                 }
+                // set comment back
+                out.setComment(oldApk.getComment());
             } finally {
-                if (out != null) {
-                    out.close();
-                }
-                if (oldApk != null) {
-                    oldApk.close();
-                }
-                if (newApk != null) {
-                    newApk.close();
-                }
+                StreamUtil.closeQuietly(out);
+                StreamUtil.closeQuietly(oldApk);
+                StreamUtil.closeQuietly(newApk);
+
                 //delete temp files
-                for (ShareResPatchInfo.LargeModeInfo largeModeInfo : resPatchInfo.largeModMap.values()) {
-                    SharePatchFileUtil.safeDeleteFile(largeModeInfo.file);
-                }
+                SharePatchFileUtil.deleteDir(tempResFileDirectory);
             }
             boolean result = SharePatchFileUtil.checkResourceArscMd5(resOutput, resPatchInfo.resArscMd5);
 
@@ -227,7 +236,7 @@ private static boolean extractResourceDiffInternals(Context context, String dir,
         return true;
     }
 
-    private static boolean checkAndExtractResourceLargeFile(Context context, String apkPath, File directory,
+    private static boolean checkAndExtractResourceLargeFile(Context context, String apkPath, File directory, File tempFileDirtory,
                                                             File patchFile, ShareResPatchInfo resPatchInfo, int type) {
         long start = System.currentTimeMillis();
         Tinker manager = Tinker.with(context);
@@ -252,10 +261,34 @@ private static boolean checkAndExtractResourceLargeFile(Context context, String
             }
 
             //resource arsc is not changed, just return true
-            if (resPatchInfo.largeModRes.isEmpty()) {
-                TinkerLog.i(TAG, "no large modify resources, just return");
+            if (resPatchInfo.largeModRes.isEmpty() && resPatchInfo.storeRes.isEmpty()) {
+                TinkerLog.i(TAG, "no large modify or store resources, just return");
                 return true;
             }
+            patchZipFile = new ZipFile(patchFile);
+
+            for (String name : resPatchInfo.storeRes.keySet()) {
+                long storeStart = System.currentTimeMillis();
+                File destCopy = new File(tempFileDirtory, name);
+                SharePatchFileUtil.ensureFileDirectory(destCopy);
+
+                ZipEntry patchEntry = patchZipFile.getEntry(name);
+                if (patchEntry == null) {
+                    TinkerLog.w(TAG, "store patch entry is null. path:" + name);
+                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, destCopy, name, type);
+                    return false;
+                }
+                extract(patchZipFile, patchEntry, destCopy, null, false);
+                //fast check, only check size
+                if (patchEntry.getSize() != destCopy.length()) {
+                    TinkerLog.w(TAG, "resource meta file size mismatch, type:%s, name: %s, patch size: %d, file size; %d", ShareTinkerInternals.getTypeString(type), name, patchEntry.getSize(), destCopy.length());
+                    manager.getPatchReporter().onPatchPackageCheckFail(patchFile, BasePatchInternal.getMetaCorruptedCode(type));
+                    return false;
+                }
+                resPatchInfo.storeRes.put(name, destCopy);
+
+                TinkerLog.w(TAG, "success recover store file:%s, file size:%d, use time:%d", destCopy.getPath(), destCopy.length(), (System.currentTimeMillis() - storeStart));
+            }
             for (String name : resPatchInfo.largeModRes) {
                 long largeStart = System.currentTimeMillis();
                 ShareResPatchInfo.LargeModeInfo largeModeInfo = resPatchInfo.largeModMap.get(name);
@@ -266,7 +299,7 @@ private static boolean checkAndExtractResourceLargeFile(Context context, String
                     return false;
                 }
 
-                largeModeInfo.file = new File(directory, name);
+                largeModeInfo.file = new File(tempFileDirtory, name);
                 SharePatchFileUtil.ensureFileDirectory(largeModeInfo.file);
 
                 //we do not check the intermediate files' md5 to save time, use check whether it is 32 length
@@ -275,7 +308,6 @@ private static boolean checkAndExtractResourceLargeFile(Context context, String
                     manager.getPatchReporter().onPatchPackageCheckFail(patchFile, BasePatchInternal.getMetaCorruptedCode(type));
                     return false;
                 }
-                patchZipFile = new ZipFile(patchFile);
                 ZipEntry patchEntry = patchZipFile.getEntry(name);
                 if (patchEntry == null) {
                     TinkerLog.w(TAG, "large mod patch entry is null. path:" + name);
@@ -296,8 +328,8 @@ private static boolean checkAndExtractResourceLargeFile(Context context, String
                     newStream = patchZipFile.getInputStream(patchEntry);
                     BSPatch.patchFast(oldStream, newStream, largeModeInfo.file);
                 } finally {
-                    SharePatchFileUtil.closeQuietly(oldStream);
-                    SharePatchFileUtil.closeQuietly(newStream);
+                    StreamUtil.closeQuietly(oldStream);
+                    StreamUtil.closeQuietly(newStream);
                 }
                 //go go go bsdiff get the
                 if (!SharePatchFileUtil.verifyFileMd5(largeModeInfo.file, largeModeInfo.md5)) {
@@ -308,7 +340,7 @@ private static boolean checkAndExtractResourceLargeFile(Context context, String
                 }
                 TinkerLog.w(TAG, "success recover large modify file:%s, file size:%d, use time:%d", largeModeInfo.file.getPath(), largeModeInfo.file.length(), (System.currentTimeMillis() - largeStart));
             }
-            TinkerLog.w(TAG, "success recover all large modify use time:%d", (System.currentTimeMillis() - start));
+            TinkerLog.w(TAG, "success recover all large modify and store resources use time:%d", (System.currentTimeMillis() - start));
         } catch (Throwable e) {
 //            e.printStackTrace();
             throw new TinkerRuntimeException("patch " + ShareTinkerInternals.getTypeString(type) +  " extract failed (" + e.getMessage() + ").", e);
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
index 72257dac..2ae8a1d3 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
@@ -64,23 +64,30 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
             return false;
         }
 
-        //it is a new patch, so we should not find a exist
-        SharePatchInfo oldInfo = manager.getTinkerLoadResultIfPresent().patchInfo;
         String patchMd5 = SharePatchFileUtil.getMD5(patchFile);
-
         if (patchMd5 == null) {
             TinkerLog.e(TAG, "UpgradePatch tryPatch:patch md5 is null, just return");
             return false;
         }
-
         //use md5 as version
         patchResult.patchVersion = patchMd5;
 
+        TinkerLog.i(TAG, "UpgradePatch tryPatch:patchMd5:%s", patchMd5);
+
+        //check ok, we can real recover a new patch
+        final String patchDirectory = manager.getPatchDirectory().getAbsolutePath();
+
+        File patchInfoLockFile = SharePatchFileUtil.getPatchInfoLockFile(patchDirectory);
+        File patchInfoFile = SharePatchFileUtil.getPatchInfoFile(patchDirectory);
+
+        SharePatchInfo oldInfo = SharePatchInfo.readAndCheckPropertyWithLock(patchInfoFile, patchInfoLockFile);
+
+        //it is a new patch, so we should not find a exist
         SharePatchInfo newInfo;
 
         //already have patch
         if (oldInfo != null) {
-            if (oldInfo.oldVersion == null || oldInfo.newVersion == null) {
+            if (oldInfo.oldVersion == null || oldInfo.newVersion == null || oldInfo.oatDir == null) {
                 TinkerLog.e(TAG, "UpgradePatch tryPatch:onPatchInfoCorrupted");
                 manager.getPatchReporter().onPatchInfoCorrupted(patchFile, oldInfo.oldVersion, oldInfo.newVersion);
                 return false;
@@ -91,26 +98,23 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
                 manager.getPatchReporter().onPatchVersionCheckFail(patchFile, oldInfo, patchMd5);
                 return false;
             }
-            newInfo = new SharePatchInfo(oldInfo.oldVersion, patchMd5, Build.FINGERPRINT);
+            // if it is interpret now, use changing flag to wait main process
+            final String finalOatDir = oldInfo.oatDir.equals(ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH)
+                ? ShareConstants.CHANING_DEX_OPTIMIZE_PATH : oldInfo.oatDir;
+            newInfo = new SharePatchInfo(oldInfo.oldVersion, patchMd5, Build.FINGERPRINT, finalOatDir);
         } else {
-            newInfo = new SharePatchInfo("", patchMd5, Build.FINGERPRINT);
+            newInfo = new SharePatchInfo("", patchMd5, Build.FINGERPRINT, ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH);
         }
 
-        //check ok, we can real recover a new patch
-        final String patchDirectory = manager.getPatchDirectory().getAbsolutePath();
-
-        TinkerLog.i(TAG, "UpgradePatch tryPatch:patchMd5:%s", patchMd5);
-
+        //it is a new patch, we first delete if there is any files
+        //don't delete dir for faster retry
+//        SharePatchFileUtil.deleteDir(patchVersionDirectory);
         final String patchName = SharePatchFileUtil.getPatchVersionDirectory(patchMd5);
 
         final String patchVersionDirectory = patchDirectory + "/" + patchName;
 
         TinkerLog.i(TAG, "UpgradePatch tryPatch:patchVersionDirectory:%s", patchVersionDirectory);
 
-        //it is a new patch, we first delete if there is any files
-        //don't delete dir for faster retry
-//        SharePatchFileUtil.deleteDir(patchVersionDirectory);
-
         //copy file
         File destPatchFile = new File(patchVersionDirectory + "/" + SharePatchFileUtil.getPatchVersionFile(patchMd5));
 
@@ -145,14 +149,12 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
         }
 
         // check dex opt file at last, some phone such as VIVO/OPPO like to change dex2oat to interpreted
-        // just warn
-        if (!DexDiffPatchInternal.waitDexOptFile()) {
+        if (!DexDiffPatchInternal.waitAndCheckDexOptFile(patchFile, manager)) {
             TinkerLog.e(TAG, "UpgradePatch tryPatch:new patch recover, check dex opt file failed");
+            return false;
         }
 
-        final File patchInfoFile = manager.getPatchInfoFile();
-
-        if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, newInfo, SharePatchFileUtil.getPatchInfoLockFile(patchDirectory))) {
+        if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, newInfo, patchInfoLockFile)) {
             TinkerLog.e(TAG, "UpgradePatch tryPatch:new patch recover, rewrite patch info failed");
             manager.getPatchReporter().onPatchInfoCorrupted(patchFile, newInfo.oldVersion, newInfo.newVersion);
             return false;
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java
index a45555e9..f6f6b67c 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java
@@ -21,8 +21,10 @@
 
 import com.tencent.tinker.lib.service.TinkerPatchService;
 import com.tencent.tinker.lib.tinker.Tinker;
+import com.tencent.tinker.lib.tinker.TinkerInstaller;
 import com.tencent.tinker.lib.tinker.TinkerLoadResult;
 import com.tencent.tinker.lib.util.TinkerLog;
+import com.tencent.tinker.lib.util.UpgradePatchRetry;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
 import com.tencent.tinker.loader.shareutil.SharePatchInfo;
@@ -58,7 +60,7 @@ public DefaultLoadReporter(Context context) {
      */
     @Override
     public void onLoadPatchListenerReceiveFail(File patchFile, int errorCode) {
-        TinkerLog.i(TAG, "patch loadReporter onLoadPatchListenerReceiveFail: patch receive fail:%s, code:%d",
+        TinkerLog.i(TAG, "patch loadReporter onLoadPatchListenerReceiveFail: patch receive fail: %s, code: %d",
             patchFile.getAbsolutePath(), errorCode);
     }
 
@@ -92,6 +94,8 @@ public void onLoadPatchVersionChanged(String oldVersion, String newVersion, File
         TinkerLog.i(TAG, "onLoadPatchVersionChanged, try kill all other process");
         //kill all other process to ensure that all process's code is the same.
         ShareTinkerInternals.killAllOtherProcess(context);
+        // reset retry count to 1, for interpret retry
+        UpgradePatchRetry.getInstance(context).onPatchResetMaxCheck(newVersion);
 
         //delete old patch files
         File[] files = patchDirectoryFile.listFiles();
@@ -105,6 +109,34 @@ public void onLoadPatchVersionChanged(String oldVersion, String newVersion, File
         }
     }
 
+    /**
+     * After system ota, we will try to load dex with interpret mode
+     *
+     * @param type type define as following
+     *             {@code ShareConstants.TYPE_INTERPRET_OK}                                    it is ok, using interpret mode
+     *             {@code ShareConstants.TYPE_INTERPRET_GET_INSTRUCTION_SET_ERROR}             get instruction set from exist oat file fail
+     *             {@code ShareConstants.TYPE_INTERPRET_COMMAND_ERROR}                         use command line to generate interpret oat file fail
+     * @param e
+     */
+    @Override
+    public void onLoadInterpret(int type, Throwable e) {
+        TinkerLog.i(TAG, "patch loadReporter onLoadInterpret: type: %d, throwable: %s",
+            type, e);
+        switch (type) {
+            case ShareConstants.TYPE_INTERPRET_GET_INSTRUCTION_SET_ERROR:
+                TinkerLog.e(TAG, "patch loadReporter onLoadInterpret fail, can get instruction set from existed oat file");
+                break;
+            case ShareConstants.TYPE_INTERPRET_COMMAND_ERROR:
+                TinkerLog.e(TAG, "patch loadReporter onLoadInterpret fail, command line to interpret return error");
+                break;
+            case ShareConstants.TYPE_INTERPRET_OK:
+                TinkerLog.i(TAG, "patch loadReporter onLoadInterpret ok");
+                break;
+        }
+
+        retryPatch();
+    }
+
     /**
      * some files is not found,
      * we'd like to recover the old patch with {@link TinkerPatchService} in OldPatchProcessor mode
@@ -117,15 +149,20 @@ public void onLoadPatchVersionChanged(String oldVersion, String newVersion, File
      *                    {@code ShareConstants.TYPE_DEX}         patch dex file or directory not found
      *                    {@code ShareConstants.TYPE_LIBRARY}     patch lib file or directory not found
      *                    {@code ShareConstants.TYPE_RESOURCE}    patch lib file or directory not found
-     *
      * @param isDirectory whether is directory for the file type
      */
     @Override
     public void onLoadFileNotFound(File file, int fileType, boolean isDirectory) {
-        TinkerLog.i(TAG, "patch loadReporter onLoadFileNotFound: patch file not found: %s, fileType:%d, isDirectory:%b",
+        TinkerLog.i(TAG, "patch loadReporter onLoadFileNotFound: patch file not found: %s, fileType: %d, isDirectory: %b",
             file.getAbsolutePath(), fileType, isDirectory);
 
-        checkAndCleanPatch();
+        // only try to recover opt file
+        // check dex opt file at last, some phone such as VIVO/OPPO like to change dex2oat to interpreted
+        if (fileType == ShareConstants.TYPE_DEX_OPT) {
+            retryPatch();
+        } else {
+            checkAndCleanPatch();
+        }
     }
 
     /**
@@ -142,7 +179,7 @@ public void onLoadFileNotFound(File file, int fileType, boolean isDirectory) {
      */
     @Override
     public void onLoadFileMd5Mismatch(File file, int fileType) {
-        TinkerLog.i(TAG, "patch load Reporter onLoadFileMd5Mismatch: patch file md5 mismatch file: %s, fileType:%d", file.getAbsolutePath(), fileType);
+        TinkerLog.i(TAG, "patch load Reporter onLoadFileMd5Mismatch: patch file md5 mismatch file: %s, fileType: %d", file.getAbsolutePath(), fileType);
         //clean patch for safety
         checkAndCleanPatch();
     }
@@ -174,7 +211,7 @@ public void onLoadPatchInfoCorrupted(String oldVersion, String newVersion, File
      */
     @Override
     public void onLoadResult(File patchDirectory, int loadCode, long cost) {
-        TinkerLog.i(TAG, "patch loadReporter onLoadResult: patch load result, path:%s, code:%d, cost:%d", patchDirectory.getAbsolutePath(), loadCode, cost);
+        TinkerLog.i(TAG, "patch loadReporter onLoadResult: patch load result, path:%s, code: %d, cost: %dms", patchDirectory.getAbsolutePath(), loadCode, cost);
         //you can just report the result here
     }
 
@@ -185,11 +222,11 @@ public void onLoadResult(File patchDirectory, int loadCode, long cost) {
      * you can disable patch as {@link DefaultLoadReporter#onLoadException(Throwable, int)}
      *
      * @param e
-     * @param errorCode    exception code
-     *                     {@code ShareConstants.ERROR_LOAD_EXCEPTION_UNKNOWN}        unknown exception
-     *                     {@code ShareConstants.ERROR_LOAD_EXCEPTION_DEX}            exception when load dex
-     *                     {@code ShareConstants.ERROR_LOAD_EXCEPTION_RESOURCE}       exception when load resource
-     *                     {@code ShareConstants.ERROR_LOAD_EXCEPTION_UNCAUGHT}       exception unCaught
+     * @param errorCode exception code
+     *                  {@code ShareConstants.ERROR_LOAD_EXCEPTION_UNKNOWN}        unknown exception
+     *                  {@code ShareConstants.ERROR_LOAD_EXCEPTION_DEX}            exception when load dex
+     *                  {@code ShareConstants.ERROR_LOAD_EXCEPTION_RESOURCE}       exception when load resource
+     *                  {@code ShareConstants.ERROR_LOAD_EXCEPTION_UNCAUGHT}       exception unCaught
      */
     @Override
     public void onLoadException(Throwable e, int errorCode) {
@@ -204,9 +241,6 @@ public void onLoadException(Throwable e, int errorCode) {
                 ShareTinkerInternals.setTinkerDisableWithSharedPreferences(context);
                 TinkerLog.i(TAG, "dex exception disable tinker forever with sp");
                 break;
-            case ShareConstants.ERROR_LOAD_EXCEPTION_DEX_OPT:
-                TinkerLog.i(TAG, "patch load parallel dex opt exception: %s", e);
-                break;
             case ShareConstants.ERROR_LOAD_EXCEPTION_RESOURCE:
                 if (e.getMessage().contains(ShareConstants.CHECK_RES_INSTALL_FAIL)) {
                     TinkerLog.e(TAG, "patch loadReporter onLoadException: tinker res check fail:" + e.getMessage());
@@ -220,6 +254,14 @@ public void onLoadException(Throwable e, int errorCode) {
                 TinkerLog.i(TAG, "patch loadReporter onLoadException: patch load unCatch exception: %s", e);
                 ShareTinkerInternals.setTinkerDisableWithSharedPreferences(context);
                 TinkerLog.i(TAG, "unCaught exception disable tinker forever with sp");
+
+                String uncaughtString = SharePatchFileUtil.checkTinkerLastUncaughtCrash(context);
+                if (!ShareTinkerInternals.isNullOrNil(uncaughtString)) {
+                    File laseCrashFile = SharePatchFileUtil.getPatchLastCrashFile(context);
+                    SharePatchFileUtil.safeDeleteFile(laseCrashFile);
+                    // found really crash reason
+                    TinkerLog.e(TAG, "tinker uncaught real exception:" + uncaughtString);
+                }
                 break;
             case ShareConstants.ERROR_LOAD_EXCEPTION_UNKNOWN:
                 TinkerLog.i(TAG, "patch loadReporter onLoadException: patch load unknown exception: %s", e);
@@ -251,7 +293,7 @@ public void onLoadException(Throwable e, int errorCode) {
     @Override
     public void onLoadPackageCheckFail(File patchFile, int errorCode) {
         TinkerLog.i(TAG, "patch loadReporter onLoadPackageCheckFail: "
-            + "load patch package check fail file path:%s, errorCode:%d", patchFile.getAbsolutePath(), errorCode);
+            + "load patch package check fail file path: %s, errorCode: %d", patchFile.getAbsolutePath(), errorCode);
         checkAndCleanPatch();
     }
 
@@ -274,9 +316,30 @@ public void checkAndCleanPatch() {
                     ShareTinkerInternals.killAllOtherProcess(context);
                 }
             }
-
         }
         tinker.cleanPatch();
 
     }
+
+    public boolean retryPatch() {
+        final Tinker tinker = Tinker.with(context);
+        if (!tinker.isMainProcess()) {
+            return false;
+        }
+
+        File patchVersionFile = tinker.getTinkerLoadResultIfPresent().patchVersionFile;
+        if (patchVersionFile != null) {
+            if (UpgradePatchRetry.getInstance(context).onPatchListenerCheck(SharePatchFileUtil.getMD5(patchVersionFile))) {
+                TinkerLog.i(TAG, "try to repair oat file on patch process");
+                TinkerInstaller.onReceiveUpgradePatch(context, patchVersionFile.getAbsolutePath());
+                return true;
+            }
+//          else {
+//                TinkerLog.i(TAG, "repair retry exceed must max time, just clean");
+//                checkAndCleanPatch();
+//            }
+        }
+
+        return false;
+    }
 }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java
index 9d1dca7e..cc43ae28 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java
@@ -23,11 +23,14 @@
 import com.tencent.tinker.lib.service.DefaultTinkerResultService;
 import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.util.TinkerLog;
+import com.tencent.tinker.lib.util.UpgradePatchRetry;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
+import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
 import com.tencent.tinker.loader.shareutil.SharePatchInfo;
 import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
 
 import java.io.File;
+import java.util.List;
 
 /**
  * Created by zhangshaowen on 16/3/14.
@@ -37,6 +40,7 @@
  */
 public class DefaultPatchReporter implements PatchReporter {
     private static final String TAG = "Tinker.DefaultPatchReporter";
+    private static boolean shouldRetry = false;
     protected final Context context;
 
     public DefaultPatchReporter(Context context) {
@@ -53,6 +57,9 @@ public DefaultPatchReporter(Context context) {
     @Override
     public void onPatchServiceStart(Intent intent) {
         TinkerLog.i(TAG, "patchReporter onPatchServiceStart: patch service start");
+        shouldRetry = false;
+        UpgradePatchRetry.getInstance(context).onPatchServiceStart(intent);
+
     }
 
     /**
@@ -73,7 +80,7 @@ public void onPatchServiceStart(Intent intent) {
      */
     @Override
     public void onPatchPackageCheckFail(File patchFile, int errorCode) {
-        TinkerLog.i(TAG, "patchReporter onPatchPackageCheckFail: package check failed. path:%s, code:%d",
+        TinkerLog.i(TAG, "patchReporter onPatchPackageCheckFail: package check failed. path: %s, code: %d",
             patchFile.getAbsolutePath(), errorCode);
         //only meta corrupted, need to delete temp files. others is just in the check time!
         if (errorCode == ShareConstants.ERROR_PACKAGE_CHECK_DEX_META_CORRUPTED
@@ -94,7 +101,7 @@ public void onPatchPackageCheckFail(File patchFile, int errorCode) {
      */
     @Override
     public void onPatchVersionCheckFail(File patchFile, SharePatchInfo oldPatchInfo, String patchFileVersion) {
-        TinkerLog.i(TAG, "patchReporter onPatchVersionCheckFail: patch version exist. path:%s, version:%s",
+        TinkerLog.i(TAG, "patchReporter onPatchVersionCheckFail: patch version exist. path: %s, version: %s",
             patchFile.getAbsolutePath(), patchFileVersion);
         //no need to delete temp files, because it is only in the check time!
     }
@@ -114,7 +121,7 @@ public void onPatchVersionCheckFail(File patchFile, SharePatchInfo oldPatchInfo,
      */
     @Override
     public void onPatchTypeExtractFail(File patchFile, File extractTo, String filename, int fileType) {
-        TinkerLog.i(TAG, "patchReporter onPatchTypeExtractFail: file extract fail type:%s, path:%s, extractTo:%s, filename:%s",
+        TinkerLog.i(TAG, "patchReporter onPatchTypeExtractFail: file extract fail type: %s, path: %s, extractTo: %s, filename: %s",
             ShareTinkerInternals.getTypeString(fileType), patchFile.getPath(), extractTo.getPath(), filename);
         //delete temp files
         Tinker.with(context).cleanPatchByVersion(patchFile);
@@ -124,17 +131,24 @@ public void onPatchTypeExtractFail(File patchFile, File extractTo, String filena
      * dex opt failed
      *
      * @param patchFile      the input patch file to recover
-     * @param dexFile        the dex file
-     * @param optDirectory
-     * @param dexName        dexName try to dexOpt
+     * @param dexFiles       the dex files
+     * @param t
      */
     @Override
-    public void onPatchDexOptFail(File patchFile, File dexFile, String optDirectory, String dexName, Throwable t) {
-        TinkerLog.i(TAG, "patchReporter onPatchDexOptFail: dex opt fail path:%s, dexPath:%s, optDir:%s, dexName:%s",
-            patchFile.getAbsolutePath(), dexFile.getPath(), optDirectory, dexName);
+    public void onPatchDexOptFail(File patchFile, List<File> dexFiles, Throwable t) {
+        TinkerLog.i(TAG, "patchReporter onPatchDexOptFail: dex opt fail path: %s, dex size: %d",
+            patchFile.getAbsolutePath(), dexFiles.size());
         TinkerLog.printErrStackTrace(TAG, t, "onPatchDexOptFail:");
-        //delete temp files
-        Tinker.with(context).cleanPatchByVersion(patchFile);
+
+        // some phone such as VIVO/OPPO like to change dex2oat to interpreted may go here
+        // check oat file if it is elf format
+        if (t.getMessage().contains(ShareConstants.CHECK_DEX_OAT_EXIST_FAIL)
+            || t.getMessage().contains(ShareConstants.CHECK_DEX_OAT_FORMAT_FAIL)) {
+            shouldRetry = true;
+            deleteOptFiles(dexFiles);
+        } else {
+            Tinker.with(context).cleanPatchByVersion(patchFile);
+        }
     }
 
     /**
@@ -146,9 +160,12 @@ public void onPatchDexOptFail(File patchFile, File dexFile, String optDirectory,
      */
     @Override
     public void onPatchResult(File patchFile, boolean success, long cost) {
-        TinkerLog.i(TAG, "patchReporter onPatchResult: patch all result path:%s, success:%b, cost:%d",
+        TinkerLog.i(TAG, "patchReporter onPatchResult: patch all result path: %s, success: %b, cost: %d",
             patchFile.getAbsolutePath(), success, cost);
-        //you can just report the result here
+        // if should retry don't delete the temp file
+        if (!shouldRetry) {
+            UpgradePatchRetry.getInstance(context).onPatchServiceResult();
+        }
     }
 
     /**
@@ -161,7 +178,7 @@ public void onPatchResult(File patchFile, boolean success, long cost) {
      */
     @Override
     public void onPatchInfoCorrupted(File patchFile, String oldVersion, String newVersion) {
-        TinkerLog.i(TAG, "patchReporter onPatchInfoCorrupted: patch info is corrupted. old:%s, new:%s",
+        TinkerLog.i(TAG, "patchReporter onPatchInfoCorrupted: patch info is corrupted. old: %s, new: %s",
             oldVersion, newVersion);
         //patch.info is corrupted, just clean all patch
         Tinker.with(context).cleanPatch();
@@ -177,7 +194,7 @@ public void onPatchInfoCorrupted(File patchFile, String oldVersion, String newVe
      */
     @Override
     public void onPatchException(File patchFile, Throwable e) {
-        TinkerLog.i(TAG, "patchReporter onPatchException: patch exception path:%s, throwable:%s",
+        TinkerLog.i(TAG, "patchReporter onPatchException: patch exception path: %s, throwable: %s",
             patchFile.getAbsolutePath(), e.getMessage());
         TinkerLog.e(TAG, "tinker patch exception, welcome to submit issue to us: https://github.com/Tencent/tinker/issues");
 //        if (e.getMessage().contains(ShareConstants.CHECK_VM_PROPERTY_FAIL)) {
@@ -190,4 +207,11 @@ public void onPatchException(File patchFile, Throwable e) {
         ////delete temp files, I think we don't have to clean all patch
         Tinker.with(context).cleanPatchByVersion(patchFile);
     }
+
+    private void deleteOptFiles(List<File> dexFiles) {
+        for (File file : dexFiles) {
+            SharePatchFileUtil.safeDeleteFile(file);
+        }
+    }
+
 }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java
index 6ff69254..48818506 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/LoadReporter.java
@@ -52,6 +52,15 @@
      */
     void onLoadPatchVersionChanged(String oldVersion, String newVersion, File patchDirectoryFile, String currentPatchName);
 
+    /**
+     * After system ota, we will try to load dex with interpret mode
+     * @param type type define as following
+     *             {@code ShareConstants.TYPE_INTERPRET_OK}                                    it is ok, using interpret mode
+     *             {@code ShareConstants.TYPE_INTERPRET_GET_INSTRUCTION_SET_ERROR}             get instruction set from exist oat file fail
+     *             {@code ShareConstants.TYPE_INTERPRET_COMMAND_ERROR}                         use command line to generate interpret oat file fail
+     * @param e
+     */
+    void onLoadInterpret(int type, Throwable e);
     /**
      * the load patch process is end, we can see the cost times and the return code
      * return codes are define in {@link com.tencent.tinker.loader.shareutil.ShareConstants}
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java
index 7ba65da4..fee683bf 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/PatchReporter.java
@@ -24,6 +24,7 @@
 import com.tencent.tinker.loader.shareutil.SharePatchInfo;
 
 import java.io.File;
+import java.util.List;
 
 /**
  * Created by zhangshaowen on 16/3/14.
@@ -89,12 +90,10 @@
      * dex opt failed
      *
      * @param patchFile      the input patch file to recover
-     * @param dexFile        the dex file
-     * @param optDirectory
-     * @param dexName        dexName try to dexOpt
+     * @param dexFiles       the dex file
      * @param t              throwable
      */
-    void onPatchDexOptFail(File patchFile, File dexFile, String optDirectory, String dexName, Throwable t);
+    void onPatchDexOptFail(File patchFile, List<File> dexFiles, Throwable t);
 
 
     /**
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java
index 3cc8aa01..570558ae 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java
@@ -102,11 +102,9 @@ public static Tinker with(Context context) {
         if (!sInstalled) {
             throw new TinkerRuntimeException("you must install tinker before get tinker sInstance");
         }
-        if (sInstance == null) {
-            synchronized (Tinker.class) {
-                if (sInstance == null) {
-                    sInstance = new Builder(context).build();
-                }
+        synchronized (Tinker.class) {
+            if (sInstance == null) {
+                sInstance = new Builder(context).build();
             }
         }
         return sInstance;
@@ -266,6 +264,21 @@ public void cleanPatch() {
         SharePatchFileUtil.deleteDir(patchDirectory);
     }
 
+    /**
+     * rollback patch should restart all process
+     */
+    public void rollbackPatch() {
+        if (!isTinkerLoaded()) {
+            TinkerLog.w(TAG, "rollbackPatch: tinker is not loaded, just return");
+            return;
+        }
+        // kill all other process
+        ShareTinkerInternals.killAllOtherProcess(context);
+        // clean patch
+        cleanPatch();
+        // kill itself
+        android.os.Process.killProcess(android.os.Process.myPid());
+    }
     /**
      * clean the patch version files, such as tinker/patch-641e634c
      *
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerApplicationHelper.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerApplicationHelper.java
index b3363b47..a64b331f 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerApplicationHelper.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerApplicationHelper.java
@@ -28,6 +28,7 @@
 
 import java.io.File;
 import java.util.HashMap;
+import java.util.Map;
 
 /**
  * sometimes, you may want to install tinker later, or never install tinker in some process.
@@ -317,7 +318,8 @@ public static boolean loadLibraryFromTinker(ApplicationLike applicationLike, Str
                 File patchVersionDirectory = new File(patchDirectory.getAbsolutePath() + "/" + SharePatchFileUtil.getPatchVersionDirectory(currentVersion));
                 String libPrePath = patchVersionDirectory.getAbsolutePath() + "/" + ShareConstants.SO_PATH;
 
-                for (String name : loadLibraries.keySet()) {
+                for (Map.Entry<String, String> libEntry : loadLibraries.entrySet()) {
+                    final String name = libEntry.getKey();
                     if (name.equals(relativeLibPath)) {
                         String patchLibraryPath = libPrePath + "/" + name;
                         File library = new File(patchLibraryPath);
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java
index 3b5b06f2..e50fa87a 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java
@@ -40,10 +40,14 @@
     public SharePatchInfo patchInfo;
     //@Nullable
     public String         currentVersion;
+    //@Nullable
+    public String         oatDir;
+
+    public boolean versionChanged;
 
-    public boolean                 versionChanged;
+    public boolean useInterpretMode;
 
-    public boolean                 systemOTA;
+    public boolean systemOTA;
 
     //@Nullable
     public File                    patchVersionDirectory;
@@ -74,8 +78,14 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
 
         costTime = ShareIntentUtil.getIntentPatchCostTime(intentResult);
         systemOTA = ShareIntentUtil.getBooleanExtra(intentResult, ShareIntentUtil.INTENT_PATCH_SYSTEM_OTA, false);
+        oatDir = ShareIntentUtil.getStringExtra(intentResult, ShareIntentUtil.INTENT_PATCH_OAT_DIR);
+        useInterpretMode = ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH.equals(oatDir);
+
+        final boolean isMainProcess = tinker.isMainProcess();
+
+        TinkerLog.i(TAG, "parseTinkerResult loadCode:%d, process name:%s, main process:%b, systemOTA:%b, fingerPrint:%s, oatDir:%s, useInterpretMode:%b",
+            loadCode, ShareTinkerInternals.getProcessName(context), isMainProcess, systemOTA, Build.FINGERPRINT, oatDir, useInterpretMode);
 
-        TinkerLog.i(TAG, "parseTinkerResult loadCode:%d, systemOTA:%b", loadCode, systemOTA);
         //@Nullable
         final String oldVersion = ShareIntentUtil.getStringExtra(intentResult, ShareIntentUtil.INTENT_PATCH_OLD_VERSION);
         //@Nullable
@@ -84,9 +94,6 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
         final File patchDirectory = tinker.getPatchDirectory();
         final File patchInfoFile = tinker.getPatchInfoFile();
 
-        final boolean isMainProcess = tinker.isMainProcess();
-
-
         if (oldVersion != null && newVersion != null) {
             if (isMainProcess) {
                 currentVersion = newVersion;
@@ -106,7 +113,7 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
                 resourceDirectory = new File(patchVersionDirectory, ShareConstants.RES_PATH);
                 resourceFile = new File(resourceDirectory, ShareConstants.RES_NAME);
             }
-            patchInfo = new SharePatchInfo(oldVersion, newVersion, Build.FINGERPRINT);
+            patchInfo = new SharePatchInfo(oldVersion, newVersion, Build.FINGERPRINT, oatDir);
             versionChanged = !(oldVersion.equals(newVersion));
         }
 
@@ -122,9 +129,6 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
                 case ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_LOAD_EXCEPTION:
                     errorCode = ShareConstants.ERROR_LOAD_EXCEPTION_DEX;
                     break;
-                case ShareConstants.ERROR_LOAD_PATCH_VERSION_PARALLEL_DEX_OPT_EXCEPTION:
-                    errorCode = ShareConstants.ERROR_LOAD_EXCEPTION_DEX_OPT;
-                    break;
                 case ShareConstants.ERROR_LOAD_PATCH_VERSION_RESOURCE_LOAD_EXCEPTION:
                     errorCode = ShareConstants.ERROR_LOAD_EXCEPTION_RESOURCE;
                     break;
@@ -307,6 +311,12 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
                 tinker.getLoadReporter().onLoadFileMd5Mismatch(resourceFile,
                     ShareConstants.TYPE_RESOURCE);
                 break;
+            case ShareConstants.ERROR_LOAD_PATCH_GET_OTA_INSTRUCTION_SET_EXCEPTION:
+                tinker.getLoadReporter().onLoadInterpret(ShareConstants.TYPE_INTERPRET_GET_INSTRUCTION_SET_ERROR, ShareIntentUtil.getIntentInterpretException(intentResult));
+                break;
+            case ShareConstants.ERROR_LOAD_PATCH_OTA_INTERPRET_ONLY_EXCEPTION:
+                tinker.getLoadReporter().onLoadInterpret(ShareConstants.TYPE_INTERPRET_COMMAND_ERROR, ShareIntentUtil.getIntentInterpretException(intentResult));
+                break;
             case ShareConstants.ERROR_LOAD_OK:
                 TinkerLog.i(TAG, "oh yeah, tinker load all success");
                 tinker.setTinkerLoaded(true);
@@ -316,6 +326,9 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
 
                 packageConfig = ShareIntentUtil.getIntentPackageConfig(intentResult);
 
+                if (useInterpretMode) {
+                    tinker.getLoadReporter().onLoadInterpret(ShareConstants.TYPE_INTERPRET_OK, null);
+                }
                 if (isMainProcess && versionChanged) {
                     //change the old version to new
                     tinker.getLoadReporter().onLoadPatchVersionChanged(oldVersion, newVersion, patchDirectory, patchVersionDirectory.getName());
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerLog.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerLog.java
index cb677c5d..6a75ed36 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerLog.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/TinkerLog.java
@@ -26,39 +26,39 @@
     private static TinkerLogImp debugLog = new TinkerLogImp() {
 
         @Override
-        public void v(final String tag, final String msg, final Object... obj) {
-            String log = obj == null ? msg : String.format(msg, obj);
+        public void v(final String tag, final String format, final Object... params) {
+            String log = (params == null || params.length == 0) ? format : String.format(format, params);
             android.util.Log.v(tag, log);
         }
 
         @Override
-        public void i(final String tag, final String msg, final Object... obj) {
-            String log = obj == null ? msg : String.format(msg, obj);
+        public void i(final String tag, final String format, final Object... params) {
+            String log = (params == null || params.length == 0) ? format : String.format(format, params);
             android.util.Log.i(tag, log);
 
         }
 
         @Override
-        public void d(final String tag, final String msg, final Object... obj) {
-            String log = obj == null ? msg : String.format(msg, obj);
+        public void d(final String tag, final String format, final Object... params) {
+            String log = (params == null || params.length == 0) ? format : String.format(format, params);
             android.util.Log.d(tag, log);
         }
 
         @Override
-        public void w(final String tag, final String msg, final Object... obj) {
-            String log = obj == null ? msg : String.format(msg, obj);
+        public void w(final String tag, final String format, final Object... params) {
+            String log = (params == null || params.length == 0) ? format : String.format(format, params);
             android.util.Log.w(tag, log);
         }
 
         @Override
-        public void e(final String tag, final String msg, final Object... obj) {
-            String log = obj == null ? msg : String.format(msg, obj);
+        public void e(final String tag, final String format, final Object... params) {
+            String log = (params == null || params.length == 0) ? format : String.format(format, params);
             android.util.Log.e(tag, log);
         }
 
         @Override
-        public void printErrStackTrace(String tag, Throwable tr, String format, Object... obj) {
-            String log = obj == null ? format : String.format(format, obj);
+        public void printErrStackTrace(String tag, Throwable tr, String format, Object... params) {
+            String log = (params == null || params.length == 0) ? format : String.format(format, params);
             if (log == null) {
                 log = "";
             }
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/UpgradePatchRetry.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/UpgradePatchRetry.java
similarity index 84%
rename from tinker-sample-android/app/src/main/java/tinker/sample/android/util/UpgradePatchRetry.java
rename to tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/UpgradePatchRetry.java
index a714b94f..c0e8ee8b 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/UpgradePatchRetry.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/util/UpgradePatchRetry.java
@@ -14,16 +14,15 @@
  * limitations under the License.
  */
 
-package tinker.sample.android.util;
+package com.tencent.tinker.lib.util;
 
 import android.content.Context;
 import android.content.Intent;
 
+import com.tencent.tinker.commons.util.StreamUtil;
 import com.tencent.tinker.lib.service.TinkerPatchService;
 import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.tinker.TinkerInstaller;
-import com.tencent.tinker.lib.util.TinkerLog;
-import com.tencent.tinker.lib.util.TinkerServiceInternals;
 import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
 
 import java.io.File;
@@ -32,8 +31,6 @@
 import java.io.IOException;
 import java.util.Properties;
 
-import tinker.sample.android.reporter.SampleTinkerReport;
-
 /**
  * optional
  * tinker :patch process may killed by some reason, we can retry it to increase upgrade success rate
@@ -49,15 +46,13 @@
 
     private static final String RETRY_FILE_MD5_PROPERTY = "md5";
     private static final String RETRY_COUNT_PROPERTY    = "times";
-    private static final int    RETRY_MAX_COUNT         = 4;
-
-
-    private boolean isRetryEnable = false;
+    private static final int    RETRY_MAX_COUNT         = 5;
+    private static UpgradePatchRetry sInstance;
+    private boolean isRetryEnable = true;
     private File    retryInfoFile = null;
     private File    tempPatchFile = null;
-
     private Context context = null;
-    private static UpgradePatchRetry sInstance;
+    private int maxRetryCount = RETRY_MAX_COUNT;
 
     /**
      * you must set after tinker has installed
@@ -77,36 +72,48 @@ public static UpgradePatchRetry getInstance(Context context) {
         return sInstance;
     }
 
-    public void onPatchRetryLoad() {
+    public void setRetryEnable(boolean enable) {
+        isRetryEnable = enable;
+    }
+
+    public void setMaxRetryCount(int count) {
+        if (count <= 0) {
+            TinkerLog.e(TAG, "max count must large than 0");
+            return;
+        }
+        maxRetryCount = count;
+    }
+
+    public boolean onPatchRetryLoad() {
         if (!isRetryEnable) {
             TinkerLog.w(TAG, "onPatchRetryLoad retry disabled, just return");
-            return;
+            return false;
         }
         Tinker tinker = Tinker.with(context);
         //only retry on main process
         if (!tinker.isMainProcess()) {
             TinkerLog.w(TAG, "onPatchRetryLoad retry is not main process, just return");
-            return;
+            return false;
         }
 
         if (!retryInfoFile.exists()) {
             TinkerLog.w(TAG, "onPatchRetryLoad retry info not exist, just return");
-            return;
+            return false;
         }
 
         if (TinkerServiceInternals.isTinkerPatchServiceRunning(context)) {
             TinkerLog.w(TAG, "onPatchRetryLoad tinker service is running, just return");
-            return;
+            return false;
         }
         //must use temp file
         String path = tempPatchFile.getAbsolutePath();
         if (path == null || !new File(path).exists()) {
             TinkerLog.w(TAG, "onPatchRetryLoad patch file: %s is not exist, just return", path);
-            return;
+            return false;
         }
         TinkerLog.w(TAG, "onPatchRetryLoad patch file: %s is exist, retry to patch", path);
         TinkerInstaller.onReceiveUpgradePatch(context, path);
-        SampleTinkerReport.onReportRetryPatch();
+        return true;
     }
 
     public void onPatchServiceStart(Intent intent) {
@@ -144,7 +151,7 @@ public void onPatchServiceStart(Intent intent) {
                 retryInfo.times = "1";
             } else {
                 int nowTimes = Integer.parseInt(retryInfo.times);
-                if (nowTimes >= RETRY_MAX_COUNT) {
+                if (nowTimes >= maxRetryCount) {
                     SharePatchFileUtil.safeDeleteFile(tempPatchFile);
                     TinkerLog.w(TAG, "onPatchServiceStart retry more than max count, delete retry info file!");
                     return;
@@ -177,7 +184,7 @@ public boolean onPatchListenerCheck(String md5) {
         RetryInfo retryInfo = RetryInfo.readRetryProperty(retryInfoFile);
         if (md5.equals(retryInfo.md5)) {
             int nowTimes = Integer.parseInt(retryInfo.times);
-            if (nowTimes >= RETRY_MAX_COUNT) {
+            if (nowTimes >= maxRetryCount) {
                 TinkerLog.w(TAG, "onPatchListenerCheck, retry count %d must exceed than max retry count", nowTimes);
                 SharePatchFileUtil.safeDeleteFile(tempPatchFile);
                 return false;
@@ -185,6 +192,29 @@ public boolean onPatchListenerCheck(String md5) {
         }
         return true;
     }
+
+    public boolean onPatchResetMaxCheck(String md5) {
+        if (!isRetryEnable) {
+            TinkerLog.w(TAG, "onPatchResetMaxCheck retry disabled, just return");
+            return true;
+        }
+        if (!retryInfoFile.exists()) {
+            TinkerLog.w(TAG, "onPatchResetMaxCheck retry file is not exist, just return");
+            return true;
+        }
+        if (md5 == null) {
+            TinkerLog.w(TAG, "onPatchResetMaxCheck md5 is null, just return");
+            return true;
+        }
+        RetryInfo retryInfo = RetryInfo.readRetryProperty(retryInfoFile);
+
+        if (md5.equals(retryInfo.md5)) {
+            TinkerLog.i(TAG, "onPatchResetMaxCheck, reset max check to 1");
+            retryInfo.times = "1";
+            RetryInfo.writeRetryProperty(retryInfoFile, retryInfo);
+        }
+        return true;
+    }
     /**
      * if we receive any result, we can delete the temp retry info file
      */
@@ -198,13 +228,9 @@ public void onPatchServiceResult() {
         if (tempPatchFile.exists()) {
             SharePatchFileUtil.safeDeleteFile(tempPatchFile);
         }
-    }
 
-    public void setRetryEnable(boolean enable) {
-        isRetryEnable = enable;
     }
 
-
     private void copyToTempFile(File patchFile) {
         if (patchFile.getAbsolutePath().equals(tempPatchFile.getAbsolutePath())) {
             return;
@@ -241,7 +267,7 @@ static RetryInfo readRetryProperty(File infoFile) {
             } catch (IOException e) {
                 TinkerLog.e(TAG, "fail to readRetryProperty:" + e);
             } finally {
-                SharePatchFileUtil.closeQuietly(inputStream);
+                StreamUtil.closeQuietly(inputStream);
             }
 
             return new RetryInfo(md5, times);
@@ -268,7 +294,7 @@ static void writeRetryProperty(File infoFile, RetryInfo info) {
 //                e.printStackTrace();
                 TinkerLog.printErrStackTrace(TAG, e, "retry write property fail");
             } finally {
-                SharePatchFileUtil.closeQuietly(outputStream);
+                StreamUtil.closeQuietly(outputStream);
             }
 
         }
diff --git a/tinker-android/tinker-android-loader/build.gradle b/tinker-android/tinker-android-loader/build.gradle
index b65288cc..971a76e0 100644
--- a/tinker-android/tinker-android-loader/build.gradle
+++ b/tinker-android/tinker-android-loader/build.gradle
@@ -11,12 +11,17 @@ android {
     defaultConfig {
         minSdkVersion rootProject.ext.minSdkVersion
         targetSdkVersion rootProject.ext.targetSdkVersion
+
+        buildConfigField "String", "TINKER_VERSION", "\"${rootProject.ext.VERSION_NAME}\""
+
+        manifestPlaceholders = [TINKER_VERSION: "${rootProject.ext.VERSION_NAME}"]
     }
 }
 
 dependencies {
     compile fileTree(dir: 'libs', include: ['*.jar'])
     testCompile 'junit:junit:4.12'
+    compile "com.android.support:support-annotations:${rootProject.ext.supportLibVersion}"
 }
 
 task buildTinkerSdk(type: Copy, dependsOn: [build]) {
diff --git a/tinker-android/tinker-android-loader/src/main/AndroidManifest.xml b/tinker-android/tinker-android-loader/src/main/AndroidManifest.xml
index 8b6db826..0c8107e9 100644
--- a/tinker-android/tinker-android-loader/src/main/AndroidManifest.xml
+++ b/tinker-android/tinker-android-loader/src/main/AndroidManifest.xml
@@ -1,7 +1,69 @@
-<manifest
-    package="com.tencent.tinker.loader">
-
+<manifest package="com.tencent.tinker.loader"
+          xmlns:android="http://schemas.android.com/apk/res/android">
     <application>
+        <activity android:name=".hotplug.ActivityStubs$STDStub_00" />
+        <activity android:name=".hotplug.ActivityStubs$STDStub_01" />
+        <activity android:name=".hotplug.ActivityStubs$STDStub_02" />
+        <activity android:name=".hotplug.ActivityStubs$STDStub_03" />
+        <activity android:name=".hotplug.ActivityStubs$STDStub_04" />
+        <activity android:name=".hotplug.ActivityStubs$STDStub_05" />
+        <activity android:name=".hotplug.ActivityStubs$STDStub_06" />
+        <activity android:name=".hotplug.ActivityStubs$STDStub_07" />
+        <activity android:name=".hotplug.ActivityStubs$STDStub_08" />
+        <activity android:name=".hotplug.ActivityStubs$STDStub_09" />
+
+        <activity android:name=".hotplug.ActivityStubs$STDStub_00_T" android:theme="@android:style/Theme.Translucent" />
+        <activity android:name=".hotplug.ActivityStubs$STDStub_01_T" android:theme="@android:style/Theme.Translucent" />
+        <activity android:name=".hotplug.ActivityStubs$STDStub_02_T" android:theme="@android:style/Theme.Translucent" />
+
+        <activity android:name=".hotplug.ActivityStubs$SGTStub_00" android:launchMode="singleTop" />
+        <activity android:name=".hotplug.ActivityStubs$SGTStub_01" android:launchMode="singleTop" />
+        <activity android:name=".hotplug.ActivityStubs$SGTStub_02" android:launchMode="singleTop" />
+        <activity android:name=".hotplug.ActivityStubs$SGTStub_03" android:launchMode="singleTop" />
+        <activity android:name=".hotplug.ActivityStubs$SGTStub_04" android:launchMode="singleTop" />
+        <activity android:name=".hotplug.ActivityStubs$SGTStub_05" android:launchMode="singleTop" />
+        <activity android:name=".hotplug.ActivityStubs$SGTStub_06" android:launchMode="singleTop" />
+        <activity android:name=".hotplug.ActivityStubs$SGTStub_07" android:launchMode="singleTop" />
+        <activity android:name=".hotplug.ActivityStubs$SGTStub_08" android:launchMode="singleTop" />
+        <activity android:name=".hotplug.ActivityStubs$SGTStub_09" android:launchMode="singleTop" />
+
+        <activity android:name=".hotplug.ActivityStubs$SGTStub_00_T" android:launchMode="singleTop" android:theme="@android:style/Theme.Translucent" />
+        <activity android:name=".hotplug.ActivityStubs$SGTStub_01_T" android:launchMode="singleTop" android:theme="@android:style/Theme.Translucent" />
+        <activity android:name=".hotplug.ActivityStubs$SGTStub_02_T" android:launchMode="singleTop" android:theme="@android:style/Theme.Translucent" />
+
+        <activity android:name=".hotplug.ActivityStubs$SGTKStub_00" android:launchMode="singleTask" />
+        <activity android:name=".hotplug.ActivityStubs$SGTKStub_01" android:launchMode="singleTask" />
+        <activity android:name=".hotplug.ActivityStubs$SGTKStub_02" android:launchMode="singleTask" />
+        <activity android:name=".hotplug.ActivityStubs$SGTKStub_03" android:launchMode="singleTask" />
+        <activity android:name=".hotplug.ActivityStubs$SGTKStub_04" android:launchMode="singleTask" />
+        <activity android:name=".hotplug.ActivityStubs$SGTKStub_05" android:launchMode="singleTask" />
+        <activity android:name=".hotplug.ActivityStubs$SGTKStub_06" android:launchMode="singleTask" />
+        <activity android:name=".hotplug.ActivityStubs$SGTKStub_07" android:launchMode="singleTask" />
+        <activity android:name=".hotplug.ActivityStubs$SGTKStub_08" android:launchMode="singleTask" />
+        <activity android:name=".hotplug.ActivityStubs$SGTKStub_09" android:launchMode="singleTask" />
+
+        <activity android:name=".hotplug.ActivityStubs$SGTKStub_00_T" android:launchMode="singleTask" android:theme="@android:style/Theme.Translucent" />
+        <activity android:name=".hotplug.ActivityStubs$SGTKStub_01_T" android:launchMode="singleTask" android:theme="@android:style/Theme.Translucent" />
+        <activity android:name=".hotplug.ActivityStubs$SGTKStub_02_T" android:launchMode="singleTask" android:theme="@android:style/Theme.Translucent" />
+
+        <activity android:name=".hotplug.ActivityStubs$SIStub_00" android:launchMode="singleInstance" />
+        <activity android:name=".hotplug.ActivityStubs$SIStub_01" android:launchMode="singleInstance" />
+        <activity android:name=".hotplug.ActivityStubs$SIStub_02" android:launchMode="singleInstance" />
+        <activity android:name=".hotplug.ActivityStubs$SIStub_03" android:launchMode="singleInstance" />
+        <activity android:name=".hotplug.ActivityStubs$SIStub_04" android:launchMode="singleInstance" />
+        <activity android:name=".hotplug.ActivityStubs$SIStub_05" android:launchMode="singleInstance" />
+        <activity android:name=".hotplug.ActivityStubs$SIStub_06" android:launchMode="singleInstance" />
+        <activity android:name=".hotplug.ActivityStubs$SIStub_07" android:launchMode="singleInstance" />
+        <activity android:name=".hotplug.ActivityStubs$SIStub_08" android:launchMode="singleInstance" />
+        <activity android:name=".hotplug.ActivityStubs$SIStub_09" android:launchMode="singleInstance" />
+
+        <activity android:name=".hotplug.ActivityStubs$SIStub_00_T" android:launchMode="singleInstance" android:theme="@android:style/Theme.Translucent" />
+        <activity android:name=".hotplug.ActivityStubs$SIStub_01_T" android:launchMode="singleInstance" android:theme="@android:style/Theme.Translucent" />
+        <activity android:name=".hotplug.ActivityStubs$SIStub_02_T" android:launchMode="singleInstance" android:theme="@android:style/Theme.Translucent" />
+
+        <meta-data
+            android:name="tinker_version"
+            android:value="${TINKER_VERSION}"/>
 
     </application>
 
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AbstractTinkerLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AbstractTinkerLoader.java
index 111e38c2..926977df 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AbstractTinkerLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AbstractTinkerLoader.java
@@ -25,5 +25,5 @@
  * Created by zhangshaowen on 16/4/30.
  */
 public abstract class AbstractTinkerLoader {
-    abstract public Intent tryLoad(TinkerApplication app, int tinkerFlag, boolean tinkerLoadVerifyFlag);
+    abstract public Intent tryLoad(TinkerApplication app);
 }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
index 3fa21b51..aa156098 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
@@ -24,10 +24,8 @@
 import com.tencent.tinker.loader.shareutil.ShareReflectUtil;
 
 import java.io.File;
-import java.io.IOException;
+import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
 import java.util.List;
 
 import dalvik.system.DexFile;
@@ -38,42 +36,81 @@
  */
 @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
 class AndroidNClassLoader extends PathClassLoader {
-    static ArrayList<DexFile> oldDexFiles = new ArrayList<>();
-    PathClassLoader originClassLoader;
+    private static final String TAG = "Tinker.NClassLoader";
 
-    private AndroidNClassLoader(String dexPath, PathClassLoader parent) {
+    private final PathClassLoader originClassLoader;
+    private String applicationClassName;
+
+    private AndroidNClassLoader(String dexPath, PathClassLoader parent, Application application) {
         super(dexPath, parent.getParent());
         originClassLoader = parent;
+        String name = application.getClass().getName();
+        if (name != null && !name.equals("android.app.Application")) {
+            applicationClassName = name;
+        }
     }
 
-    private static AndroidNClassLoader createAndroidNClassLoader(PathClassLoader original) throws Exception {
-        //let all element ""
-        AndroidNClassLoader androidNClassLoader = new AndroidNClassLoader("",  original);
-        Field originPathList = ShareReflectUtil.findField(original, "pathList");
-        Object originPathListObject = originPathList.get(original);
-        //should reflect definingContext also
-        Field originClassloader = ShareReflectUtil.findField(originPathListObject, "definingContext");
-        originClassloader.set(originPathListObject, androidNClassLoader);
-        //copy pathList
-        Field pathListField = ShareReflectUtil.findField(androidNClassLoader, "pathList");
-        //just use PathClassloader's pathList
-        pathListField.set(androidNClassLoader, originPathListObject);
-
-        //we must recreate dexFile due to dexCache
-        List<File> additionalClassPathEntries = new ArrayList<>();
-        Field dexElement = ShareReflectUtil.findField(originPathListObject, "dexElements");
-        Object[] originDexElements = (Object[]) dexElement.get(originPathListObject);
-        for (Object element : originDexElements) {
-            DexFile dexFile = (DexFile) ShareReflectUtil.findField(element, "dexFile").get(element);
-            additionalClassPathEntries.add(new File(dexFile.getName()));
-            //protect for java.lang.AssertionError: Failed to close dex file in finalizer.
-            oldDexFiles.add(dexFile);
+    @SuppressWarnings("unchecked")
+    private static Object recreateDexPathList(Object originalDexPathList, ClassLoader newDefiningContext) throws Exception {
+        final Field dexElementsField = ShareReflectUtil.findField(originalDexPathList, "dexElements");
+        final Object[] dexElements = (Object[]) dexElementsField.get(originalDexPathList);
+        final Field nativeLibraryDirectoriesField = ShareReflectUtil.findField(originalDexPathList, "nativeLibraryDirectories");
+        final List<File> nativeLibraryDirectories = (List<File>) nativeLibraryDirectoriesField.get(originalDexPathList);
+
+        final StringBuilder dexPathBuilder = new StringBuilder();
+        final Field dexFileField = ShareReflectUtil.findField(dexElements.getClass().getComponentType(), "dexFile");
+
+        boolean isFirstItem = true;
+        for (Object dexElement : dexElements) {
+            final DexFile dexFile = (DexFile) dexFileField.get(dexElement);
+            if (dexFile == null) {
+                continue;
+            }
+            if (isFirstItem) {
+                isFirstItem = false;
+            } else {
+                dexPathBuilder.append(File.pathSeparator);
+            }
+            dexPathBuilder.append(dexFile.getName());
         }
-        Method makePathElements = ShareReflectUtil.findMethod(originPathListObject, "makePathElements", List.class, File.class,
-            List.class);
-        ArrayList<IOException> suppressedExceptions = new ArrayList<>();
-        Object[] newDexElements = (Object[]) makePathElements.invoke(originPathListObject, additionalClassPathEntries, null, suppressedExceptions);
-        dexElement.set(originPathListObject, newDexElements);
+
+        final String dexPath = dexPathBuilder.toString();
+
+        final StringBuilder libraryPathBuilder = new StringBuilder();
+        isFirstItem = true;
+        for (File libDir : nativeLibraryDirectories) {
+            if (libDir == null) {
+                continue;
+            }
+            if (isFirstItem) {
+                isFirstItem = false;
+            } else {
+                libraryPathBuilder.append(File.pathSeparator);
+            }
+            libraryPathBuilder.append(libDir.getAbsolutePath());
+        }
+
+        final String libraryPath = libraryPathBuilder.toString();
+
+        final Constructor<?> dexPathListConstructor = ShareReflectUtil.findConstructor(originalDexPathList, ClassLoader.class, String.class, String.class, File.class);
+        return dexPathListConstructor.newInstance(newDefiningContext, dexPath, libraryPath, null);
+    }
+
+    private static AndroidNClassLoader createAndroidNClassLoader(PathClassLoader originalClassLoader, Application application) throws Exception {
+        //let all element ""
+        final AndroidNClassLoader androidNClassLoader = new AndroidNClassLoader("",  originalClassLoader, application);
+        final Field pathListField = ShareReflectUtil.findField(originalClassLoader, "pathList");
+        final Object originPathList = pathListField.get(originalClassLoader);
+
+        // To avoid 'dex file register with multiple classloader' exception on Android O, we must keep old
+        // dexPathList in original classloader so that after the newly loaded base dex was bound to
+        // AndroidNClassLoader we can still load class in base dex from original classloader.
+
+        Object newPathList = recreateDexPathList(originPathList, androidNClassLoader);
+
+        // Update new classloader's pathList.
+        pathListField.set(androidNClassLoader, newPathList);
+
         return androidNClassLoader;
     }
 
@@ -90,7 +127,7 @@ private static void reflectPackageInfoClassloader(Application application, Class
     }
 
     public static AndroidNClassLoader inject(PathClassLoader originClassLoader, Application application) throws Exception {
-        AndroidNClassLoader classLoader = createAndroidNClassLoader(originClassLoader);
+        AndroidNClassLoader classLoader = createAndroidNClassLoader(originClassLoader, application);
         reflectPackageInfoClassloader(application, classLoader);
         return classLoader;
     }
@@ -107,7 +144,10 @@ public static AndroidNClassLoader inject(PathClassLoader originClassLoader, Appl
 
     public Class<?> findClass(String name) throws ClassNotFoundException {
         // loader class use default pathClassloader to load
-        if (name != null && name.startsWith("com.tencent.tinker.loader.") && !name.equals("com.tencent.tinker.loader.TinkerTestDexLoad")) {
+        if ((name != null
+                && name.startsWith("com.tencent.tinker.loader.")
+                && !name.equals(SystemClassLoaderAdder.CHECK_DEX_CLASS))
+                || (applicationClassName != null && applicationClassName.equals(name))) {
             return originClassLoader.loadClass(name);
         }
         return super.findClass(name);
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
index 6c8199fa..47566786 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
@@ -32,8 +32,12 @@
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
 import java.util.List;
 import java.util.ListIterator;
+import java.util.Map;
 import java.util.zip.ZipFile;
 
 import dalvik.system.DexFile;
@@ -43,20 +47,20 @@
  * Created by zhangshaowen on 16/3/18.
  */
 public class SystemClassLoaderAdder {
+    public static final String CHECK_DEX_CLASS = "com.tencent.tinker.loader.TinkerTestDexLoad";
+    public static final String CHECK_DEX_FIELD = "isPatch";
     private static final String TAG = "Tinker.ClassLoaderAdder";
-
-    private static final String CHECK_DEX_CLASS = "com.tencent.tinker.loader.TinkerTestDexLoad";
-    private static final String CHECK_DEX_FIELD = "isPatch";
-
     private static int sPatchDexCount = 0;
 
     @SuppressLint("NewApi")
     public static void installDexes(Application application, PathClassLoader loader, File dexOptDir, List<File> files)
         throws Throwable {
+        Log.i(TAG, "installDexes dexOptDir: " + dexOptDir.getAbsolutePath() + ", dex size:" + files.size());
 
         if (!files.isEmpty()) {
+            files = createSortedAdditionalPathEntries(files);
             ClassLoader classLoader = loader;
-            if (Build.VERSION.SDK_INT >= 24) {
+            if (Build.VERSION.SDK_INT >= 24 && !checkIsProtectedApp(files)) {
                 classLoader = AndroidNClassLoader.inject(loader, application);
             }
             //because in dalvik, if inner class is not the same classloader with it wrapper class.
@@ -109,6 +113,77 @@ private static boolean checkDexInstall(ClassLoader classLoader) throws ClassNotF
         return isPatch;
     }
 
+    private static boolean checkIsProtectedApp(List<File> files) {
+        if (!files.isEmpty()) {
+            for (File file : files) {
+                if (file == null) {
+                    continue;
+                }
+                if (file.getName().startsWith(ShareConstants.CHANGED_CLASSES_DEX_NAME)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    private static List<File> createSortedAdditionalPathEntries(List<File> additionalPathEntries) {
+        final List<File> result = new ArrayList<>(additionalPathEntries);
+
+        final Map<String, Boolean> matchesClassNPatternMemo = new HashMap<>();
+        for (File file : result) {
+            final String name = file.getName();
+            matchesClassNPatternMemo.put(name, ShareConstants.CLASS_N_PATTERN.matcher(name).matches());
+        }
+        Collections.sort(result, new Comparator<File>() {
+            @Override
+            public int compare(File lhs, File rhs) {
+                if (lhs == null && rhs == null) {
+                    return 0;
+                }
+                if (lhs == null) {
+                    return -1;
+                }
+                if (rhs == null) {
+                    return 1;
+                }
+
+                final String lhsName = lhs.getName();
+                final String rhsName = rhs.getName();
+                if (lhsName.equals(rhsName)) {
+                    return 0;
+                }
+
+                final String testDexSuffix = ShareConstants.TEST_DEX_NAME;
+                // test.dex should always be at tail.
+                if (lhsName.startsWith(testDexSuffix)) {
+                    return 1;
+                }
+                if (rhsName.startsWith(testDexSuffix)) {
+                    return -1;
+                }
+
+                final boolean isLhsNameMatchClassN = matchesClassNPatternMemo.get(lhsName);
+                final boolean isRhsNameMatchClassN = matchesClassNPatternMemo.get(rhsName);
+                if (isLhsNameMatchClassN && isRhsNameMatchClassN) {
+                    final int lhsDotPos = lhsName.indexOf('.');
+                    final int rhsDotPos = rhsName.indexOf('.');
+                    final int lhsId = (lhsDotPos > 7 ? Integer.parseInt(lhsName.substring(7, lhsDotPos)) : 1);
+                    final int rhsId = (rhsDotPos > 7 ? Integer.parseInt(rhsName.substring(7, rhsDotPos)) : 1);
+                    return (lhsId == rhsId ? 0 : (lhsId < rhsId ? -1 : 1));
+                } else if (isLhsNameMatchClassN) {
+                    // Dex name that matches class N rules should always be at first.
+                    return -1;
+                } else if (isRhsNameMatchClassN) {
+                    return 1;
+                }
+                return lhsName.compareTo(rhsName);
+            }
+        });
+
+        return result;
+    }
+
     /**
      * Installer for platform versions 23.
      */
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java
index 90ebc589..6f6a3988 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java
@@ -17,11 +17,11 @@
 package com.tencent.tinker.loader;
 
 import android.annotation.TargetApi;
-import android.app.Application;
 import android.content.Intent;
 import android.os.Build;
 import android.util.Log;
 
+import com.tencent.tinker.loader.app.TinkerApplication;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.ShareDexDiffPatchInfo;
 import com.tencent.tinker.loader.shareutil.ShareIntentUtil;
@@ -32,6 +32,7 @@
 import java.io.File;
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.HashSet;
 
 import dalvik.system.PathClassLoader;
 
@@ -44,13 +45,18 @@
 
     private static final String TAG = "Tinker.TinkerDexLoader";
 
-    private static final String                           DEX_MEAT_FILE     = ShareConstants.DEX_META_FILE;
-    private static final String                           DEX_PATH          = ShareConstants.DEX_PATH;
-    private static final String                           DEX_OPTIMIZE_PATH = ShareConstants.DEX_OPTIMIZE_PATH;
-    private static final ArrayList<ShareDexDiffPatchInfo> dexList           = new ArrayList<>();
+    private static final String DEX_MEAT_FILE               = ShareConstants.DEX_META_FILE;
+    private static final String DEX_PATH                    = ShareConstants.DEX_PATH;
+    private static final String DEFAULT_DEX_OPTIMIZE_PATH   = ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH;
+    private static final String INTERPRET_DEX_OPTIMIZE_PATH = ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH;
 
-    private static boolean   parallelOTAResult;
-    private static Throwable parallelOTAThrowable;
+    private static final ArrayList<ShareDexDiffPatchInfo> loadDexList = new ArrayList<>();
+
+
+    //    private static File testOptDexFile;
+    private static HashSet<ShareDexDiffPatchInfo> classNDexInfo = new HashSet<>();
+
+    private static boolean isVmArt = ShareTinkerInternals.isVmArt();
 
     private TinkerDexLoader() {
     }
@@ -62,8 +68,8 @@ private TinkerDexLoader() {
      * @param application The application.
      */
     @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-    public static boolean loadTinkerJars(Application application, boolean tinkerLoadVerifyFlag, String directory, Intent intentResult, boolean isSystemOTA) {
-        if (dexList.isEmpty()) {
+    public static boolean loadTinkerJars(final TinkerApplication application, String directory, String oatDir, Intent intentResult, boolean isSystemOTA) {
+        if (loadDexList.isEmpty() && classNDexInfo.isEmpty()) {
             Log.w(TAG, "there is no dex to load");
             return true;
         }
@@ -77,24 +83,21 @@ public static boolean loadTinkerJars(Application application, boolean tinkerLoad
             return false;
         }
         String dexPath = directory + "/" + DEX_PATH + "/";
-        File optimizeDir = new File(directory + "/" + DEX_OPTIMIZE_PATH);
-//        Log.i(TAG, "loadTinkerJars: dex path: " + dexPath);
-//        Log.i(TAG, "loadTinkerJars: opt path: " + optimizeDir.getAbsolutePath());
 
         ArrayList<File> legalFiles = new ArrayList<>();
 
-        final boolean isArtPlatForm = ShareTinkerInternals.isVmArt();
-        for (ShareDexDiffPatchInfo info : dexList) {
+        for (ShareDexDiffPatchInfo info : loadDexList) {
             //for dalvik, ignore art support dex
             if (isJustArtSupportDex(info)) {
                 continue;
             }
+
             String path = dexPath + info.realName;
             File file = new File(path);
 
-            if (tinkerLoadVerifyFlag) {
+            if (application.isTinkerLoadVerifyFlag()) {
                 long start = System.currentTimeMillis();
-                String checkMd5 = isArtPlatForm ? info.destMd5InArt : info.destMd5InDvm;
+                String checkMd5 = getInfoMd5(info);
                 if (!SharePatchFileUtil.verifyDexFileMd5(file, checkMd5)) {
                     //it is good to delete the mismatch file
                     ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_MD5_MISMATCH);
@@ -106,15 +109,56 @@ public static boolean loadTinkerJars(Application application, boolean tinkerLoad
             }
             legalFiles.add(file);
         }
+        // verify merge classN.apk
+        if (isVmArt && !classNDexInfo.isEmpty()) {
+            File classNFile = new File(dexPath + ShareConstants.CLASS_N_APK_NAME);
+            long start = System.currentTimeMillis();
+
+            if (application.isTinkerLoadVerifyFlag()) {
+                for (ShareDexDiffPatchInfo info : classNDexInfo) {
+                    if (!SharePatchFileUtil.verifyDexFileMd5(classNFile, info.rawName, info.destMd5InArt)) {
+                        ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_MD5_MISMATCH);
+                        intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_MISMATCH_DEX_PATH,
+                            classNFile.getAbsolutePath());
+                        return false;
+                    }
+                }
+            }
+            Log.i(TAG, "verify dex file:" + classNFile.getPath() + " md5, use time: " + (System.currentTimeMillis() - start));
+
+            legalFiles.add(classNFile);
+        }
+        File optimizeDir = new File(directory + "/" + oatDir);
 
         if (isSystemOTA) {
-            parallelOTAResult = true;
-            parallelOTAThrowable = null;
-            Log.w(TAG, "systemOTA, try parallel oat dexes!!!!!");
+            final boolean[] parallelOTAResult = {true};
+            final Throwable[] parallelOTAThrowable = new Throwable[1];
+            String targetISA;
+            try {
+                targetISA = ShareTinkerInternals.getCurrentInstructionSet();
+            } catch (Throwable throwable) {
+                Log.i(TAG, "getCurrentInstructionSet fail:" + throwable);
+//                try {
+//                    targetISA = ShareOatUtil.getOatFileInstructionSet(testOptDexFile);
+//                } catch (Throwable throwable) {
+                // don't ota on the front
+                deleteOutOfDateOATFile(directory);
+
+                intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_INTERPRET_EXCEPTION, throwable);
+                ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_GET_OTA_INSTRUCTION_SET_EXCEPTION);
+                return false;
+//                }
+            }
 
-            TinkerParallelDexOptimizer.optimizeAll(
-                legalFiles, optimizeDir,
-                new TinkerParallelDexOptimizer.ResultCallback() {
+            deleteOutOfDateOATFile(directory);
+
+            Log.w(TAG, "systemOTA, try parallel oat dexes, targetISA:" + targetISA);
+            // change dir
+            optimizeDir = new File(directory + "/" + INTERPRET_DEX_OPTIMIZE_PATH);
+
+            TinkerDexOptimizer.optimizeAll(
+                legalFiles, optimizeDir, true, targetISA,
+                new TinkerDexOptimizer.ResultCallback() {
                     long start;
 
                     @Override
@@ -126,20 +170,23 @@ public void onStart(File dexFile, File optimizedDir) {
                     @Override
                     public void onSuccess(File dexFile, File optimizedDir, File optimizedFile) {
                         // Do nothing.
-                        Log.i(TAG, "success to optimize dex " + dexFile.getPath() + "use time " + (System.currentTimeMillis() - start));
+                        Log.i(TAG, "success to optimize dex " + dexFile.getPath() + ", use time " + (System.currentTimeMillis() - start));
                     }
+
                     @Override
                     public void onFailed(File dexFile, File optimizedDir, Throwable thr) {
-                        parallelOTAResult = false;
-                        parallelOTAThrowable = thr;
-                        Log.i(TAG, "fail to optimize dex " + dexFile.getPath() + "use time " + (System.currentTimeMillis() - start));
+                        parallelOTAResult[0] = false;
+                        parallelOTAThrowable[0] = thr;
+                        Log.i(TAG, "fail to optimize dex " + dexFile.getPath() + ", use time " + (System.currentTimeMillis() - start));
                     }
                 }
             );
-            if (!parallelOTAResult) {
+
+
+            if (!parallelOTAResult[0]) {
                 Log.e(TAG, "parallel oat dexes failed");
-                intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION, parallelOTAThrowable);
-                ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_PARALLEL_DEX_OPT_EXCEPTION);
+                intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_INTERPRET_EXCEPTION, parallelOTAThrowable[0]);
+                ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_OTA_INTERPRET_ONLY_EXCEPTION);
                 return false;
             }
         }
@@ -160,25 +207,29 @@ public void onFailed(File dexFile, File optimizedDir, Throwable thr) {
      * all the dex files in meta file exist?
      * fast check, only check whether exist
      *
-     * @param directory
      * @return boolean
      */
-    public static boolean checkComplete(String directory, ShareSecurityCheck securityCheck, Intent intentResult) {
+    public static boolean checkComplete(String directory, ShareSecurityCheck securityCheck, String oatDir, Intent intentResult) {
         String meta = securityCheck.getMetaContentMap().get(DEX_MEAT_FILE);
         //not found dex
         if (meta == null) {
             return true;
         }
-        dexList.clear();
-        ShareDexDiffPatchInfo.parseDexDiffPatchInfo(meta, dexList);
+        loadDexList.clear();
+        classNDexInfo.clear();
 
-        if (dexList.isEmpty()) {
+        ArrayList<ShareDexDiffPatchInfo> allDexInfo = new ArrayList<>();
+        ShareDexDiffPatchInfo.parseDexDiffPatchInfo(meta, allDexInfo);
+
+        if (allDexInfo.isEmpty()) {
             return true;
         }
 
         HashMap<String, String> dexes = new HashMap<>();
 
-        for (ShareDexDiffPatchInfo info : dexList) {
+        ShareDexDiffPatchInfo testInfo = null;
+
+        for (ShareDexDiffPatchInfo info : allDexInfo) {
             //for dalvik, ignore art support dex
             if (isJustArtSupportDex(info)) {
                 continue;
@@ -188,7 +239,22 @@ public static boolean checkComplete(String directory, ShareSecurityCheck securit
                 ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL);
                 return false;
             }
-            dexes.put(info.realName, info.destMd5InDvm);
+            if (isVmArt && info.rawName.startsWith(ShareConstants.TEST_DEX_NAME)) {
+                testInfo = info;
+            } else if (isVmArt && ShareConstants.CLASS_N_PATTERN.matcher(info.realName).matches()) {
+                classNDexInfo.add(info);
+            } else {
+                dexes.put(info.realName, getInfoMd5(info));
+                loadDexList.add(info);
+            }
+        }
+
+        if (isVmArt
+            && (testInfo != null || !classNDexInfo.isEmpty())) {
+            if (testInfo != null) {
+                classNDexInfo.add(ShareTinkerInternals.changeTestDexToClassN(testInfo, classNDexInfo.size() + 1));
+            }
+            dexes.put(ShareConstants.CLASS_N_APK_NAME, "");
         }
         //tinker/patch.info/patch-641e634c/dex
         String dexDirectory = directory + "/" + DEX_PATH + "/";
@@ -199,12 +265,13 @@ public static boolean checkComplete(String directory, ShareSecurityCheck securit
             ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_DIRECTORY_NOT_EXIST);
             return false;
         }
-        String optimizeDexDirectory = directory + "/" + DEX_OPTIMIZE_PATH + "/";
+        String optimizeDexDirectory = directory + "/" + oatDir + "/";
         File optimizeDexDirectoryFile = new File(optimizeDexDirectory);
 
         //fast check whether there is any dex files missing
         for (String name : dexes.keySet()) {
             File dexFile = new File(dexDirectory + name);
+
             if (!SharePatchFileUtil.isLegalFile(dexFile)) {
                 intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_MISSING_DEX_PATH, dexFile.getAbsolutePath());
                 ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_FILE_NOT_EXIST);
@@ -217,6 +284,10 @@ public static boolean checkComplete(String directory, ShareSecurityCheck securit
                 ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_OPT_FILE_NOT_EXIST);
                 return false;
             }
+//            // find test dex
+//            if (dexOptFile.getName().startsWith(ShareConstants.TEST_DEX_NAME)) {
+//                testOptDexFile = dexOptFile;
+//            }
         }
 
         //if is ok, add to result intent
@@ -224,8 +295,22 @@ public static boolean checkComplete(String directory, ShareSecurityCheck securit
         return true;
     }
 
+    private static String getInfoMd5(ShareDexDiffPatchInfo info) {
+        return isVmArt ? info.destMd5InArt : info.destMd5InDvm;
+    }
+
+    private static void deleteOutOfDateOATFile(String directory) {
+        String optimizeDexDirectory = directory + "/" + DEFAULT_DEX_OPTIMIZE_PATH + "/";
+        SharePatchFileUtil.deleteDir(optimizeDexDirectory);
+        // delete android o
+        if (ShareTinkerInternals.isAfterAndroidO()) {
+            String androidODexDirectory = directory + "/" + DEX_PATH + "/" + ShareConstants.ANDROID_O_DEX_OPTIMIZE_PATH + "/";
+            SharePatchFileUtil.deleteDir(androidODexDirectory);
+        }
+    }
+
     private static boolean isJustArtSupportDex(ShareDexDiffPatchInfo dexDiffPatchInfo) {
-        if (ShareTinkerInternals.isVmArt()) {
+        if (isVmArt) {
             return false;
         }
 
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexOptimizer.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexOptimizer.java
new file mode 100644
index 00000000..bd06f78b
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexOptimizer.java
@@ -0,0 +1,226 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.loader;
+
+import android.os.Build;
+import android.util.Log;
+
+import com.tencent.tinker.loader.shareutil.ShareFileLockHelper;
+import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
+
+import dalvik.system.DexFile;
+
+/**
+ * Created by tangyinsheng on 2016/11/15.
+ */
+
+public final class TinkerDexOptimizer {
+    private static final String TAG = "Tinker.ParallelDex";
+
+    private static final String INTERPRET_LOCK_FILE_NAME = "interpret.lock";
+
+    /**
+     * Optimize (trigger dexopt or dex2oat) dexes.
+     *
+     * @param dexFiles
+     * @param optimizedDir
+     * @param cb
+     * @return If all dexes are optimized successfully, return true. Otherwise return false.
+     */
+    public static boolean optimizeAll(Collection<File> dexFiles, File optimizedDir, ResultCallback cb) {
+        return optimizeAll(dexFiles, optimizedDir, false, null, cb);
+    }
+
+    public static boolean optimizeAll(Collection<File> dexFiles, File optimizedDir,
+                                      boolean useInterpretMode, String targetISA, ResultCallback cb) {
+        ArrayList<File> sortList = new ArrayList<>(dexFiles);
+        // sort input dexFiles with its file length
+        Collections.sort(sortList, new Comparator<File>() {
+            @Override
+            public int compare(File lhs, File rhs) {
+                long diffSize = lhs.length() - rhs.length();
+                if (diffSize > 0) {
+                    return 1;
+                } else if (diffSize == 0) {
+                    return 0;
+                } else {
+                    return -1;
+                }
+            }
+        });
+        Collections.reverse(sortList);
+        for (File dexFile : sortList) {
+            OptimizeWorker worker = new OptimizeWorker(dexFile, optimizedDir, useInterpretMode, targetISA, cb);
+            if (!worker.run()) {
+                return false;
+            }
+        }
+        return true;
+
+
+    }
+
+    public interface ResultCallback {
+        void onStart(File dexFile, File optimizedDir);
+
+        void onSuccess(File dexFile, File optimizedDir, File optimizedFile);
+
+        void onFailed(File dexFile, File optimizedDir, Throwable thr);
+    }
+
+    private static class OptimizeWorker {
+        private static String targetISA = null;
+
+        private final File           dexFile;
+        private final File           optimizedDir;
+        private final boolean        useInterpretMode;
+        private final ResultCallback callback;
+
+        OptimizeWorker(File dexFile, File optimizedDir, boolean useInterpretMode, String targetISA, ResultCallback cb) {
+            this.dexFile = dexFile;
+            this.optimizedDir = optimizedDir;
+            this.useInterpretMode = useInterpretMode;
+            this.callback = cb;
+            this.targetISA = targetISA;
+        }
+
+        public boolean run() {
+            try {
+                if (!SharePatchFileUtil.isLegalFile(dexFile)) {
+                    if (callback != null) {
+                        callback.onFailed(dexFile, optimizedDir,
+                            new IOException("dex file " + dexFile.getAbsolutePath() + " is not exist!"));
+                        return false;
+                    }
+                }
+                if (callback != null) {
+                    callback.onStart(dexFile, optimizedDir);
+                }
+                String optimizedPath = SharePatchFileUtil.optimizedPathFor(this.dexFile, this.optimizedDir);
+                if (useInterpretMode) {
+                    interpretDex2Oat(dexFile.getAbsolutePath(), optimizedPath);
+                } else {
+                    DexFile.loadDex(dexFile.getAbsolutePath(), optimizedPath, 0);
+                }
+                if (callback != null) {
+                    callback.onSuccess(dexFile, optimizedDir, new File(optimizedPath));
+                }
+            } catch (final Throwable e) {
+                Log.e(TAG, "Failed to optimize dex: " + dexFile.getAbsolutePath(), e);
+                if (callback != null) {
+                    callback.onFailed(dexFile, optimizedDir, e);
+                    return false;
+                }
+            }
+            return true;
+        }
+
+        private void interpretDex2Oat(String dexFilePath, String oatFilePath) throws IOException {
+            // add process lock for interpret mode
+            final File oatFile = new File(oatFilePath);
+            if (!oatFile.exists()) {
+                oatFile.getParentFile().mkdirs();
+            }
+
+            File lockFile = new File(oatFile.getParentFile(), INTERPRET_LOCK_FILE_NAME);
+            ShareFileLockHelper fileLock = null;
+            try {
+                fileLock = ShareFileLockHelper.getFileLock(lockFile);
+
+                final List<String> commandAndParams = new ArrayList<>();
+                commandAndParams.add("dex2oat");
+                // for 7.1.1, duplicate class fix
+                if (Build.VERSION.SDK_INT >= 24) {
+                    commandAndParams.add("--runtime-arg");
+                    commandAndParams.add("-classpath");
+                    commandAndParams.add("--runtime-arg");
+                    commandAndParams.add("&");
+                }
+                commandAndParams.add("--dex-file=" + dexFilePath);
+                commandAndParams.add("--oat-file=" + oatFilePath);
+                commandAndParams.add("--instruction-set=" + targetISA);
+                if (Build.VERSION.SDK_INT > 25) {
+                    commandAndParams.add("--compiler-filter=quicken");
+                } else {
+                    commandAndParams.add("--compiler-filter=interpret-only");
+                }
+
+                final ProcessBuilder pb = new ProcessBuilder(commandAndParams);
+                pb.redirectErrorStream(true);
+                final Process dex2oatProcess = pb.start();
+                StreamConsumer.consumeInputStream(dex2oatProcess.getInputStream());
+                StreamConsumer.consumeInputStream(dex2oatProcess.getErrorStream());
+                try {
+                    final int ret = dex2oatProcess.waitFor();
+                    if (ret != 0) {
+                        throw new IOException("dex2oat works unsuccessfully, exit code: " + ret);
+                    }
+                } catch (InterruptedException e) {
+                    throw new IOException("dex2oat is interrupted, msg: " + e.getMessage(), e);
+                }
+            } finally {
+                try {
+                    if (fileLock != null) {
+                        fileLock.close();
+                    }
+                } catch (IOException e) {
+                    Log.w(TAG, "release interpret Lock error", e);
+                }
+            }
+        }
+    }
+
+    private static class StreamConsumer {
+        static final Executor STREAM_CONSUMER = Executors.newSingleThreadExecutor();
+
+        static void consumeInputStream(final InputStream is) {
+            STREAM_CONSUMER.execute(new Runnable() {
+                @Override
+                public void run() {
+                    if (is == null) {
+                        return;
+                    }
+                    final byte[] buffer = new byte[256];
+                    try {
+                        while ((is.read(buffer)) > 0) {
+                            // To satisfy checkstyle rules.
+                        }
+                    } catch (IOException ignored) {
+                        // Ignored.
+                    } finally {
+                        try {
+                            is.close();
+                        } catch (Exception ignored) {
+                            // Ignored.
+                        }
+                    }
+                }
+            });
+        }
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
index 2c517745..ccf2bfff 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
@@ -19,10 +19,12 @@
 import android.content.Context;
 import android.content.Intent;
 import android.content.SharedPreferences;
+import android.os.Build;
 import android.os.SystemClock;
 import android.util.Log;
 
 import com.tencent.tinker.loader.app.TinkerApplication;
+import com.tencent.tinker.loader.hotplug.ComponentHotplug;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.ShareIntentUtil;
 import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
@@ -49,21 +51,30 @@
      * only main process can handle patch version change or incomplete
      */
     @Override
-    public Intent tryLoad(TinkerApplication app, int tinkerFlag, boolean tinkerLoadVerifyFlag) {
+    public Intent tryLoad(TinkerApplication app) {
         Intent resultIntent = new Intent();
 
         long begin = SystemClock.elapsedRealtime();
-        tryLoadPatchFilesInternal(app, tinkerFlag, tinkerLoadVerifyFlag, resultIntent);
+        tryLoadPatchFilesInternal(app, resultIntent);
         long cost = SystemClock.elapsedRealtime() - begin;
         ShareIntentUtil.setIntentPatchCostTime(resultIntent, cost);
         return resultIntent;
     }
 
-    private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, boolean tinkerLoadVerifyFlag, Intent resultIntent) {
+    private void tryLoadPatchFilesInternal(TinkerApplication app, Intent resultIntent) {
+        final int tinkerFlag = app.getTinkerFlags();
+
         if (!ShareTinkerInternals.isTinkerEnabled(tinkerFlag)) {
+            Log.w(TAG, "tryLoadPatchFiles: tinker is disable, just return");
             ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_DISABLE);
             return;
         }
+        if (ShareTinkerInternals.isInPatchProcess(app)) {
+            Log.w(TAG, "tryLoadPatchFiles: we don't load patch with :patch process itself, just return");
+            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_DISABLE);
+            return;
+
+        }
         //tinker
         File patchDirectoryFile = SharePatchFileUtil.getPatchDirectory(app);
         if (patchDirectoryFile == null) {
@@ -102,8 +113,9 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
 
         String oldVersion = patchInfo.oldVersion;
         String newVersion = patchInfo.newVersion;
+        String oatDex = patchInfo.oatDir;
 
-        if (oldVersion == null || newVersion == null) {
+        if (oldVersion == null || newVersion == null || oatDex == null) {
             //it is nice to clean patch
             Log.w(TAG, "tryLoadPatchFiles:onPatchInfoCorrupted");
             ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_CORRUPTED);
@@ -115,8 +127,12 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
 
         boolean mainProcess = ShareTinkerInternals.isInMainProcess(app);
         boolean versionChanged = !(oldVersion.equals(newVersion));
+        boolean oatModeChanged = oatDex.equals(ShareConstants.CHANING_DEX_OPTIMIZE_PATH) && mainProcess;
+        oatDex = ShareTinkerInternals.getCurrentOatMode(app, oatDex);
+        resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OAT_DIR, oatDex);
 
         String version = oldVersion;
+
         if (versionChanged && mainProcess) {
             version = newVersion;
         }
@@ -136,6 +152,7 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
         }
         //tinker/patch.info/patch-641e634c
         String patchVersionDirectory = patchDirectoryPath + "/" + patchName;
+
         File patchVersionDirectoryFile = new File(patchVersionDirectory);
 
         if (!patchVersionDirectoryFile.exists()) {
@@ -146,7 +163,8 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
         }
 
         //tinker/patch.info/patch-641e634c/patch-641e634c.apk
-        File patchVersionFile = new File(patchVersionDirectoryFile.getAbsolutePath(), SharePatchFileUtil.getPatchVersionFile(version));
+        final String patchVersionFileRelPath = SharePatchFileUtil.getPatchVersionFile(version);
+        File patchVersionFile = (patchVersionFileRelPath != null ? new File(patchVersionDirectoryFile.getAbsolutePath(), patchVersionFileRelPath) : null);
 
         if (!SharePatchFileUtil.isLegalFile(patchVersionFile)) {
             Log.w(TAG, "tryLoadPatchFiles:onPatchVersionFileNotFound");
@@ -171,7 +189,7 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
 
         if (isEnabledForDex) {
             //tinker/patch.info/patch-641e634c/dex
-            boolean dexCheck = TinkerDexLoader.checkComplete(patchVersionDirectory, securityCheck, resultIntent);
+            boolean dexCheck = TinkerDexLoader.checkComplete(patchVersionDirectory, securityCheck, oatDex, resultIntent);
             if (!dexCheck) {
                 //file not found, do not load patch
                 Log.w(TAG, "tryLoadPatchFiles:dex check fail");
@@ -202,20 +220,32 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
                 return;
             }
         }
-        //only work for art platform oat
-        boolean isSystemOTA = ShareTinkerInternals.isVmArt() && ShareTinkerInternals.isSystemOTA(patchInfo.fingerPrint);
+        //only work for art platform oat，because of interpret, refuse 4.4 art oat
+        //android o use quicken default, we don't need to use interpret mode
+        boolean isSystemOTA = ShareTinkerInternals.isVmArt()
+            && ShareTinkerInternals.isSystemOTA(patchInfo.fingerPrint)
+            && Build.VERSION.SDK_INT >= 21 && !ShareTinkerInternals.isAfterAndroidO();
+
         resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_SYSTEM_OTA, isSystemOTA);
 
         //we should first try rewrite patch info file, if there is a error, we can't load jar
-        if (isSystemOTA
-            || (mainProcess && versionChanged)) {
+        if ((mainProcess && versionChanged)
+             || oatModeChanged) {
             patchInfo.oldVersion = version;
+            patchInfo.oatDir = oatDex;
+
             //update old version to new
             if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, patchInfo, patchInfoLockFile)) {
                 ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL);
                 Log.w(TAG, "tryLoadPatchFiles:onReWritePatchInfoCorrupted");
                 return;
             }
+            if (oatModeChanged) {
+                // delete interpret odex
+                // for android o, directory change. Fortunately, we don't need to support android o interpret mode any more
+                Log.i(TAG, "tryLoadPatchFiles:oatModeChanged, try to delete interpret optimize files");
+                SharePatchFileUtil.deleteDir(patchVersionDirectory + "/" + ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH);
+            }
         }
         if (!checkSafeModeCount(app)) {
             resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION, new TinkerRuntimeException("checkSafeModeCount fail"));
@@ -223,9 +253,26 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
             Log.w(TAG, "tryLoadPatchFiles:checkSafeModeCount fail");
             return;
         }
+
         //now we can load patch jar
         if (isEnabledForDex) {
-            boolean loadTinkerJars = TinkerDexLoader.loadTinkerJars(app, tinkerLoadVerifyFlag, patchVersionDirectory, resultIntent, isSystemOTA);
+            boolean loadTinkerJars = TinkerDexLoader.loadTinkerJars(app, patchVersionDirectory, oatDex, resultIntent, isSystemOTA);
+
+            if (isSystemOTA) {
+                // update fingerprint after load success
+                patchInfo.fingerPrint = Build.FINGERPRINT;
+                patchInfo.oatDir = loadTinkerJars ? ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH : ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH;
+                // reset to false
+                oatModeChanged = false;
+
+                if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, patchInfo, patchInfoLockFile)) {
+                    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL);
+                    Log.w(TAG, "tryLoadPatchFiles:onReWritePatchInfoCorrupted");
+                    return;
+                }
+                // update oat dir
+                resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OAT_DIR, patchInfo.oatDir);
+            }
             if (!loadTinkerJars) {
                 Log.w(TAG, "tryLoadPatchFiles:onPatchLoadDexesFail");
                 return;
@@ -234,12 +281,23 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
 
         //now we can load patch resource
         if (isEnabledForResource) {
-            boolean loadTinkerResources = TinkerResourceLoader.loadTinkerResources(app, tinkerLoadVerifyFlag, patchVersionDirectory, resultIntent);
+            boolean loadTinkerResources = TinkerResourceLoader.loadTinkerResources(app, patchVersionDirectory, resultIntent);
             if (!loadTinkerResources) {
                 Log.w(TAG, "tryLoadPatchFiles:onPatchLoadResourcesFail");
                 return;
             }
         }
+
+        // Init component hotplug support.
+        if (isEnabledForDex && isEnabledForResource) {
+            ComponentHotplug.install(app, securityCheck);
+        }
+
+        // kill all other process if oat mode change
+        if (oatModeChanged) {
+            ShareTinkerInternals.killAllOtherProcess(app);
+            Log.i(TAG, "tryLoadPatchFiles:oatModeChanged, try to kill all other process");
+        }
         //all is ok!
         ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_OK);
         Log.i(TAG, "tryLoadPatchFiles: load end, ok!");
@@ -261,6 +319,4 @@ private boolean checkSafeModeCount(TinkerApplication application) {
         sp.edit().putInt(ShareConstants.TINKER_SAFE_MODE_COUNT, count).commit();
         return true;
     }
-
-
 }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerParallelDexOptimizer.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerParallelDexOptimizer.java
deleted file mode 100644
index e2481a05..00000000
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerParallelDexOptimizer.java
+++ /dev/null
@@ -1,146 +0,0 @@
-/*
- * Tencent is pleased to support the open source community by making Tinker available.
- *
- * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
- *
- * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- *
- * https://opensource.org/licenses/BSD-3-Clause
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is
- * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
- * either express or implied. See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.tencent.tinker.loader;
-
-import android.util.Log;
-
-import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
-
-import dalvik.system.DexFile;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.atomic.AtomicInteger;
-
-/**
- * Created by tangyinsheng on 2016/11/15.
- */
-
-public final class TinkerParallelDexOptimizer {
-    private static final String TAG = "Tinker.ParallelDex";
-
-    /**
-     * Optimize (trigger dexopt or dex2oat) dexes.
-     *
-     * @param dexFiles
-     * @param optimizedDir
-     * @param cb
-     *
-     * @return
-     *  If all dexes are optimized successfully, return true. Otherwise return false.
-     */
-    public synchronized static boolean optimizeAll(File[] dexFiles, File optimizedDir, ResultCallback cb) {
-        final AtomicInteger successCount = new AtomicInteger(0);
-        return optimizeAllLocked(Arrays.asList(dexFiles), optimizedDir, successCount, cb);
-    }
-
-    /**
-     * Optimize (trigger dexopt or dex2oat) dexes.
-     *
-     * @param dexFiles
-     * @param optimizedDir
-     * @param cb
-     *
-     * @return
-     *  If all dexes are optimized successfully, return true. Otherwise return false.
-     */
-    public synchronized static boolean optimizeAll(Collection<File> dexFiles, File optimizedDir, ResultCallback cb) {
-        final AtomicInteger successCount = new AtomicInteger(0);
-        return optimizeAllLocked(dexFiles, optimizedDir, successCount, cb);
-    }
-
-    private static boolean optimizeAllLocked(Collection<File> dexFiles, File optimizedDir, AtomicInteger successCount, ResultCallback cb) {
-        final CountDownLatch lauch = new CountDownLatch(dexFiles.size());
-        final ExecutorService threadPool = Executors.newCachedThreadPool();
-        long startTick = System.nanoTime();
-        for (File dexFile : dexFiles) {
-            OptimizeWorker worker = new OptimizeWorker(dexFile, optimizedDir, successCount, lauch, cb);
-            threadPool.submit(worker);
-        }
-        try {
-            lauch.await();
-            long timeCost = (System.nanoTime() - startTick) / 1000000;
-            if (successCount.get() == dexFiles.size()) {
-                Log.i(TAG, "All dexes are optimized successfully, cost: " + timeCost + " ms.");
-                return true;
-            } else {
-                Log.e(TAG, "Dexes optimizing failed, some dexes are not optimized.");
-                return false;
-            }
-        } catch (InterruptedException e) {
-            Log.w(TAG, "Dex optimizing was interrupted.", e);
-            return false;
-        } finally {
-            threadPool.shutdown();
-        }
-    }
-
-    public interface ResultCallback {
-        void onStart(File dexFile, File optimizedDir);
-        void onSuccess(File dexFile, File optimizedDir, File optimizedFile);
-        void onFailed(File dexFile, File optimizedDir, Throwable thr);
-    }
-
-    private static class OptimizeWorker implements Runnable {
-        private final File dexFile;
-        private final File optimizedDir;
-        private final AtomicInteger successCount;
-        private final CountDownLatch waitingLauch;
-        private final ResultCallback callback;
-
-        OptimizeWorker(File dexFile, File optimizedDir, AtomicInteger successCount, CountDownLatch lauch, ResultCallback cb) {
-            this.dexFile = dexFile;
-            this.optimizedDir = optimizedDir;
-            this.successCount = successCount;
-            this.waitingLauch = lauch;
-            this.callback = cb;
-        }
-
-        @Override
-        public void run() {
-            try {
-                if (!SharePatchFileUtil.isLegalFile(dexFile)) {
-                    if (callback != null) {
-                        callback.onFailed(dexFile, optimizedDir,
-                            new IOException("dex file " + dexFile.getAbsolutePath() + " is not exist!"));
-                    }
-                }
-                if (callback != null) {
-                    callback.onStart(dexFile, optimizedDir);
-                }
-                String optimizedPath = SharePatchFileUtil.optimizedPathFor(this.dexFile, this.optimizedDir);
-                DexFile.loadDex(dexFile.getAbsolutePath(), optimizedPath, 0);
-                successCount.incrementAndGet();
-                if (callback != null) {
-                    callback.onSuccess(dexFile, optimizedDir, new File(optimizedPath));
-                }
-            } catch (final Throwable e) {
-                Log.e(TAG, "Failed to optimize dex: " + dexFile.getAbsolutePath(), e);
-                if (callback != null) {
-                    callback.onFailed(dexFile, optimizedDir, e);
-                }
-            } finally {
-                this.waitingLauch.countDown();
-            }
-        }
-    }
-}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourceLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourceLoader.java
index 167231b3..82a72983 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourceLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourceLoader.java
@@ -20,6 +20,7 @@
 import android.content.Intent;
 import android.util.Log;
 
+import com.tencent.tinker.loader.app.TinkerApplication;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.ShareIntentUtil;
 import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
@@ -44,7 +45,7 @@ private TinkerResourceLoader() {
     /**
      * Load tinker resources
      */
-    public static boolean loadTinkerResources(Context context, boolean tinkerLoadVerifyFlag, String directory, Intent intentResult) {
+    public static boolean loadTinkerResources(TinkerApplication application, String directory, Intent intentResult) {
         if (resPatchInfo == null || resPatchInfo.resArscMd5 == null) {
             return true;
         }
@@ -52,7 +53,7 @@ public static boolean loadTinkerResources(Context context, boolean tinkerLoadVer
         File resourceFile = new File(resourceString);
         long start = System.currentTimeMillis();
 
-        if (tinkerLoadVerifyFlag) {
+        if (application.isTinkerLoadVerifyFlag()) {
             if (!SharePatchFileUtil.checkResourceArscMd5(resourceFile, resPatchInfo.resArscMd5)) {
                 Log.e(TAG, "Failed to load resource file, path: " + resourceFile.getPath() + ", expect md5: " + resPatchInfo.resArscMd5);
                 ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_RESOURCE_MD5_MISMATCH);
@@ -61,13 +62,13 @@ public static boolean loadTinkerResources(Context context, boolean tinkerLoadVer
             Log.i(TAG, "verify resource file:" + resourceFile.getPath() + " md5, use time: " + (System.currentTimeMillis() - start));
         }
         try {
-            TinkerResourcePatcher.monkeyPatchExistingResources(context, resourceString);
+            TinkerResourcePatcher.monkeyPatchExistingResources(application, resourceString);
             Log.i(TAG, "monkeyPatchExistingResources resource file:" + resourceString + ", use time: " + (System.currentTimeMillis() - start));
         } catch (Throwable e) {
             Log.e(TAG, "install resources failed");
             //remove patch dex if resource is installed failed
             try {
-                SystemClassLoaderAdder.uninstallPatchDex(context.getClassLoader());
+                SystemClassLoaderAdder.uninstallPatchDex(application.getClassLoader());
             } catch (Throwable throwable) {
                 Log.e(TAG, "uninstallPatchDex failed", e);
             }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
index 975c4e17..6d640c36 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
@@ -17,14 +17,18 @@
 package com.tencent.tinker.loader;
 
 import android.content.Context;
+import android.content.pm.ApplicationInfo;
 import android.content.res.AssetManager;
 import android.content.res.Resources;
+import android.os.Build;
 import android.util.ArrayMap;
 import android.util.Log;
 
 import com.tencent.tinker.loader.shareutil.ShareConstants;
+import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
 import com.tencent.tinker.loader.shareutil.ShareReflectUtil;
 
+import java.io.InputStream;
 import java.lang.ref.WeakReference;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
@@ -41,19 +45,19 @@
  * Thanks for Android Fragmentation
  */
 class TinkerResourcePatcher {
-    private static final String TAG                     = "Tinker.ResourcePatcher";
-    private static final String TEST_ASSETS_VALUE       = "only_use_to_test_tinker_resource.txt";
+    private static final String TAG               = "Tinker.ResourcePatcher";
+    private static final String TEST_ASSETS_VALUE = "only_use_to_test_tinker_resource.txt";
 //    private static final String MIUI_RESOURCE_CLASSNAME = "android.content.res.MiuiResources";
 
     // original object
-    private static Collection<WeakReference<Resources>>  references               = null;
-    private static Object                                currentActivityThread    = null;
-    private static AssetManager                          newAssetManager          = null;
+    private static Collection<WeakReference<Resources>> references            = null;
+    private static Object                               currentActivityThread = null;
+    private static AssetManager                         newAssetManager       = null;
     //    private static ArrayMap<?, WeakReference<?>>         resourceImpls            = null;
 
     // method
-    private static Method                                addAssetPathMethod       = null;
-    private static Method                                ensureStringBlocksMethod = null;
+    private static Method addAssetPathMethod       = null;
+    private static Method ensureStringBlocksMethod = null;
 
     // field
     private static Field assetsFiled           = null;
@@ -61,7 +65,7 @@
     private static Field resDir                = null;
     private static Field packagesFiled         = null;
     private static Field resourcePackagesFiled = null;
-//    private static Field        publicSourceDirField     = null;
+    private static Field publicSourceDirField  = null;
 
 //    private static boolean isMiuiSystem = false;
 
@@ -127,8 +131,6 @@ public static void isResourceCanPatch(Context context) throws Throwable {
                 // N moved the resources to mResourceReferences
                 Field mResourceReferences = resourcesManagerClass.getDeclaredField("mResourceReferences");
                 mResourceReferences.setAccessible(true);
-//                resourceImpls = (ArrayMap<?, WeakReference<?>>) mResourceReferences.get("mResourceImpls");
-
                 references = (Collection<WeakReference<Resources>>) mResourceReferences.get(resourcesManager);
             }
         } else {
@@ -142,23 +144,29 @@ public static void isResourceCanPatch(Context context) throws Throwable {
         if (references == null) {
             throw new IllegalStateException("resource references is null");
         }
-        try {
+        // fix jianGuo pro has private field 'mAssets' with Resource
+        // try use mResourcesImpl first
+        if (SDK_INT >= 24) {
+            try {
+                // N moved the mAssets inside an mResourcesImpl field
+                resourcesImplFiled = Resources.class.getDeclaredField("mResourcesImpl");
+                resourcesImplFiled.setAccessible(true);
+            } catch (Throwable ignore) {
+                // for safety
+                assetsFiled = Resources.class.getDeclaredField("mAssets");
+                assetsFiled.setAccessible(true);
+            }
+        } else {
             assetsFiled = Resources.class.getDeclaredField("mAssets");
             assetsFiled.setAccessible(true);
-        } catch (Throwable ignore) {
-            // N moved the mAssets inside an mResourcesImpl field
-            resourcesImplFiled = Resources.class.getDeclaredField("mResourcesImpl");
-            resourcesImplFiled.setAccessible(true);
         }
-
 //        final Resources resources = context.getResources();
 //        isMiuiSystem = resources != null && MIUI_RESOURCE_CLASSNAME.equals(resources.getClass().getName());
 
-//        try {
-//            publicSourceDirField = ShareReflectUtil.findField(ApplicationInfo.class, "publicSourceDir");
-//        } catch (NoSuchFieldException e) {
-//            throw new IllegalStateException("cannot find 'mInstrumentation' field");
-//        }
+        try {
+            publicSourceDirField = ShareReflectUtil.findField(ApplicationInfo.class, "publicSourceDir");
+        } catch (NoSuchFieldException ignore) {
+        }
     }
 
     /**
@@ -219,7 +227,15 @@ public static void monkeyPatchExistingResources(Context context, String external
         // Handle issues caused by WebView on Android N.
         // Issue: On Android N, if an activity contains a webview, when screen rotates
         // our resource patch may lost effects.
-//        publicSourceDirField.set(context.getApplicationInfo(), externalResourceFile);
+        // for 5.x/6.x, we found Couldn't expand RemoteView for StatusBarNotification Exception
+        if (Build.VERSION.SDK_INT >= 24) {
+            try {
+                if (publicSourceDirField != null) {
+                    publicSourceDirField.set(context.getApplicationInfo(), externalResourceFile);
+                }
+            } catch (Throwable ignore) {
+            }
+        }
 
         if (!checkResUpdate(context)) {
             throw new TinkerRuntimeException(ShareConstants.CHECK_RES_INSTALL_FAIL);
@@ -237,7 +253,6 @@ private static void clearPreloadTypedArrayIssue(Resources resources) {
 //        if (!isMiuiSystem) {
 //            return;
 //        }
-
         Log.w(TAG, "try to clear typedArray cache!");
         // Clear typedArray cache.
         try {
@@ -258,13 +273,16 @@ private static void clearPreloadTypedArrayIssue(Resources resources) {
     }
 
     private static boolean checkResUpdate(Context context) {
+        InputStream is = null;
         try {
-            Log.e(TAG, "checkResUpdate success, found test resource assets file " + TEST_ASSETS_VALUE);
-            context.getAssets().open(TEST_ASSETS_VALUE);
+            is = context.getAssets().open(TEST_ASSETS_VALUE);
         } catch (Throwable e) {
             Log.e(TAG, "checkResUpdate failed, can't find test resource assets file " + TEST_ASSETS_VALUE + " e:" + e.getMessage());
             return false;
+        } finally {
+            SharePatchFileUtil.closeQuietly(is);
         }
+        Log.i(TAG, "checkResUpdate success, found test resource assets file " + TEST_ASSETS_VALUE);
         return true;
     }
 }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerTestAndroidNClassLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerTestAndroidNClassLoader.java
new file mode 100644
index 00000000..44c90d3e
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerTestAndroidNClassLoader.java
@@ -0,0 +1,39 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.loader;
+
+/**
+ * Created by tangyinsheng on 17/3/15.
+ *
+ * This class is used to test if our AndroidNClassLoader can load classes in base.apk
+ * after its pathList is updated.
+ *
+ * <b> DO NOT touch this class in any places !! </b>
+ *
+ * <b>
+ *     If you change name of this class, you should also make such change in these places:
+ *      TinkerProguardConfigTask.groovy
+ *      TinkerMultidexConfigTask.groovy
+ *      AndroidNClassLoader.java
+ * </b>
+ */
+public final class TinkerTestAndroidNClassLoader {
+
+    private TinkerTestAndroidNClassLoader() {
+        throw new UnsupportedOperationException();
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerUncaughtHandler.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerUncaughtHandler.java
index 8471914c..79b85ed9 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerUncaughtHandler.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerUncaughtHandler.java
@@ -47,7 +47,7 @@ public TinkerUncaughtHandler(Context context) {
 
     @Override
     public void uncaughtException(Thread thread, Throwable ex) {
-        Log.e(TAG, "catch exception when loading tinker:" + Log.getStackTraceString(ex));
+        Log.e(TAG, "TinkerUncaughtHandler catch exception:" + Log.getStackTraceString(ex));
         ueh.uncaughtException(thread, ex);
 
         if (crashFile != null) {
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/ApplicationLike.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/ApplicationLike.java
index ca0a9059..4278e3f1 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/ApplicationLike.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/ApplicationLike.java
@@ -114,5 +114,9 @@ public AssetManager getAssets(AssetManager assetManager) {
     public Object getSystemService(String name, Object service) {
         return service;
     }
+
+    public Context getBaseContext(Context base) {
+        return base;
+    }
 }
 
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java
index bcdab701..a656923a 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/app/TinkerApplication.java
@@ -29,6 +29,8 @@
 import com.tencent.tinker.loader.TinkerLoader;
 import com.tencent.tinker.loader.TinkerRuntimeException;
 import com.tencent.tinker.loader.TinkerUncaughtHandler;
+import com.tencent.tinker.loader.hotplug.ComponentHotplug;
+import com.tencent.tinker.loader.hotplug.UnsupportedEnvironmentException;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.ShareIntentUtil;
 import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
@@ -64,6 +66,7 @@
     private final boolean tinkerLoadVerifyFlag;
     private final String  delegateClassName;
     private final String  loaderClassName;
+
     /**
      * if we have load patch, we should use safe mode
      */
@@ -92,7 +95,6 @@ protected TinkerApplication(int tinkerFlags, String delegateClassName,
         this.delegateClassName = delegateClassName;
         this.loaderClassName = loaderClassName;
         this.tinkerLoadVerifyFlag = tinkerLoadVerifyFlag;
-
     }
 
     protected TinkerApplication(int tinkerFlags, String delegateClassName) {
@@ -156,9 +158,9 @@ private void loadTinker() {
             //reflect tinker loader, because loaderClass may be define by user!
             Class<?> tinkerLoadClass = Class.forName(loaderClassName, false, getClassLoader());
 
-            Method loadMethod = tinkerLoadClass.getMethod(TINKER_LOADER_METHOD, TinkerApplication.class, int.class, boolean.class);
+            Method loadMethod = tinkerLoadClass.getMethod(TINKER_LOADER_METHOD, TinkerApplication.class);
             Constructor<?> constructor = tinkerLoadClass.getConstructor();
-            tinkerResultIntent = (Intent) loadMethod.invoke(constructor.newInstance(), this, tinkerFlags, tinkerLoadVerifyFlag);
+            tinkerResultIntent = (Intent) loadMethod.invoke(constructor.newInstance(), this);
         } catch (Throwable e) {
             //has exception, put exception error code
             ShareIntentUtil.setIntentReturnCode(tinkerResultIntent, ShareConstants.ERROR_LOAD_PATCH_UNKNOWN_EXCEPTION);
@@ -170,6 +172,11 @@ private void loadTinker() {
     public void onCreate() {
         super.onCreate();
         ensureDelegate();
+        try {
+            ComponentHotplug.ensureComponentHotplugInstalled(this);
+        } catch (UnsupportedEnvironmentException e) {
+            throw new TinkerRuntimeException("failed to make sure that ComponentHotplug logic is fine.", e);
+        }
         applicationLike.onCreate();
     }
 
@@ -242,7 +249,24 @@ public Object getSystemService(String name) {
         return service;
     }
 
+    @Override
+    public Context getBaseContext() {
+        Context base = super.getBaseContext();
+        if (applicationLike != null) {
+            return applicationLike.getBaseContext(base);
+        }
+        return base;
+    }
+
     public void setUseSafeMode(boolean useSafeMode) {
         this.useSafeMode = useSafeMode;
     }
+
+    public boolean isTinkerLoadVerifyFlag() {
+        return tinkerLoadVerifyFlag;
+    }
+
+    public int getTinkerFlags() {
+        return tinkerFlags;
+    }
 }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/ActivityStubManager.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/ActivityStubManager.java
new file mode 100644
index 00000000..3aab4593
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/ActivityStubManager.java
@@ -0,0 +1,92 @@
+package com.tencent.tinker.loader.hotplug;
+
+import android.content.pm.ActivityInfo;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Created by tangyinsheng on 2017/7/31.
+ */
+
+public class ActivityStubManager {
+    private static final String TAG = "Tinker.ActivityStubManager";
+
+    private static Map<String, String> sTargetToStubClassNameMap = new HashMap<>();
+
+    private static final int[] STANDARD_STUB_COUNT_SLOTS
+            = {ActivityStubs.STANDARD_STUB_COUNT, ActivityStubs.STANDARD_TRSNAPARENT_STUB_COUNT};
+    private static final int[] SINGLETOP_STUB_COUNT_SLOTS
+            = {ActivityStubs.SINGLETOP_STUB_COUNT, ActivityStubs.SINGLETOP_TRSNAPARENT_STUB_COUNT};
+    private static final int[] SINGLETASK_STUB_COUNT_SLOTS
+            = {ActivityStubs.SINGLETASK_STUB_COUNT, ActivityStubs.SINGLETASK_TRSNAPARENT_STUB_COUNT};
+    private static final int[] SINGLEINSTANCE_STUB_COUNT_SLOTS
+            = {ActivityStubs.SINGLEINSTANCE_STUB_COUNT, ActivityStubs.SINGLEINSTANCE_TRSNAPARENT_STUB_COUNT};
+
+    private static final int[] NEXT_STANDARD_STUB_IDX_SLOTS = {0, 0};
+    private static final int[] NEXT_SINGLETOP_STUB_IDX_SLOTS = {0, 0};
+    private static final int[] NEXT_SINGLETASK_STUB_IDX_SLOTS = {0, 0};
+    private static final int[] NEXT_SINGLEINSTANCE_STUB_IDX_SLOTS = {0, 0};
+
+    private static final int NOTRANSPARENT_SLOT_INDEX = 0;
+    private static final int TRANSPARENT_SLOT_INDEX = 1;
+
+    public static String assignStub(String targetClassName, int launchMode, boolean isTransparent) {
+        String stubClassName = sTargetToStubClassNameMap.get(targetClassName);
+        if (stubClassName != null) {
+            return stubClassName;
+        }
+
+        String stubNameFormat;
+        final int[] nextStubIdxSlots;
+        final int[] countSlots;
+        final int slotIdx;
+        switch (launchMode) {
+            case ActivityInfo.LAUNCH_SINGLE_TOP: {
+                stubNameFormat = ActivityStubs.SINGLETOP_STUB_CLASSNAME_FORMAT;
+                nextStubIdxSlots = NEXT_SINGLETOP_STUB_IDX_SLOTS;
+                countSlots = SINGLETOP_STUB_COUNT_SLOTS;
+                break;
+            }
+            case ActivityInfo.LAUNCH_SINGLE_TASK: {
+                stubNameFormat = ActivityStubs.SINGLETASK_STUB_CLASSNAME_FORMAT;
+                nextStubIdxSlots = NEXT_SINGLETASK_STUB_IDX_SLOTS;
+                countSlots = SINGLETASK_STUB_COUNT_SLOTS;
+                break;
+            }
+            case ActivityInfo.LAUNCH_SINGLE_INSTANCE: {
+                stubNameFormat = ActivityStubs.SINGLEINSTANCE_STUB_CLASSNAME_FORMAT;
+                nextStubIdxSlots = NEXT_SINGLEINSTANCE_STUB_IDX_SLOTS;
+                countSlots = SINGLEINSTANCE_STUB_COUNT_SLOTS;
+                break;
+            }
+            case ActivityInfo.LAUNCH_MULTIPLE:
+            default: {
+                stubNameFormat = ActivityStubs.STARDARD_STUB_CLASSNAME_FORMAT;
+                nextStubIdxSlots = NEXT_STANDARD_STUB_IDX_SLOTS;
+                countSlots = STANDARD_STUB_COUNT_SLOTS;
+                break;
+            }
+        }
+        if (isTransparent) {
+            stubNameFormat += ActivityStubs.TRANSPARENT_STUB_FORMAT_SUFFIX;
+            slotIdx = TRANSPARENT_SLOT_INDEX;
+        } else {
+            slotIdx = NOTRANSPARENT_SLOT_INDEX;
+        }
+
+        int stubIndex = nextStubIdxSlots[slotIdx]++;
+        if (stubIndex >= countSlots[slotIdx]) {
+            stubIndex = nextStubIdxSlots[slotIdx] = 0;
+        }
+
+        stubClassName = String.format(stubNameFormat, stubIndex);
+        sTargetToStubClassNameMap.put(targetClassName, stubClassName);
+
+        return stubClassName;
+    }
+
+    private ActivityStubManager() {
+        throw new UnsupportedOperationException();
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/ActivityStubs.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/ActivityStubs.java
new file mode 100644
index 00000000..bc838cf3
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/ActivityStubs.java
@@ -0,0 +1,95 @@
+package com.tencent.tinker.loader.hotplug;
+
+import android.app.Activity;
+
+/**
+ * Created by tangyinsheng on 2017/8/3.
+ */
+
+final class ActivityStubs {
+    static final String STUB_PACKAGE_NAME = ActivityStubs.class.getPackage().getName();
+
+    static final String STARDARD_STUB_CLASSNAME_FORMAT
+            = STUB_PACKAGE_NAME + "." + ActivityStubs.class.getSimpleName() + "$STDStub_%02X";
+    static final String SINGLETOP_STUB_CLASSNAME_FORMAT
+            = STUB_PACKAGE_NAME + "." + ActivityStubs.class.getSimpleName() + "$SGTStub_%02X";
+    static final String SINGLETASK_STUB_CLASSNAME_FORMAT
+            = STUB_PACKAGE_NAME + "." + ActivityStubs.class.getSimpleName() + "$SGTKStub_%02X";
+    static final String SINGLEINSTANCE_STUB_CLASSNAME_FORMAT
+            = STUB_PACKAGE_NAME + "." + ActivityStubs.class.getSimpleName() + "$SIStub_%02X";
+
+    static final String TRANSPARENT_STUB_FORMAT_SUFFIX = "_T";
+
+    static final int STANDARD_STUB_COUNT = 10;
+    static final int STANDARD_TRSNAPARENT_STUB_COUNT = 3;
+    static final int SINGLETOP_STUB_COUNT = 10;
+    static final int SINGLETOP_TRSNAPARENT_STUB_COUNT = 3;
+    static final int SINGLETASK_STUB_COUNT = 10;
+    static final int SINGLETASK_TRSNAPARENT_STUB_COUNT = 3;
+    static final int SINGLEINSTANCE_STUB_COUNT = 10;
+    static final int SINGLEINSTANCE_TRSNAPARENT_STUB_COUNT = 3;
+
+    public static final class STDStub_00 extends Activity { }
+    public static final class STDStub_01 extends Activity { }
+    public static final class STDStub_02 extends Activity { }
+    public static final class STDStub_03 extends Activity { }
+    public static final class STDStub_04 extends Activity { }
+    public static final class STDStub_05 extends Activity { }
+    public static final class STDStub_06 extends Activity { }
+    public static final class STDStub_07 extends Activity { }
+    public static final class STDStub_08 extends Activity { }
+    public static final class STDStub_09 extends Activity { }
+
+    public static final class STDStub_00_T extends Activity { }
+    public static final class STDStub_01_T extends Activity { }
+    public static final class STDStub_02_T extends Activity { }
+
+    public static final class SGTStub_00 extends Activity { }
+    public static final class SGTStub_01 extends Activity { }
+    public static final class SGTStub_02 extends Activity { }
+    public static final class SGTStub_03 extends Activity { }
+    public static final class SGTStub_04 extends Activity { }
+    public static final class SGTStub_05 extends Activity { }
+    public static final class SGTStub_06 extends Activity { }
+    public static final class SGTStub_07 extends Activity { }
+    public static final class SGTStub_08 extends Activity { }
+    public static final class SGTStub_09 extends Activity { }
+
+    public static final class SGTStub_00_T extends Activity { }
+    public static final class SGTStub_01_T extends Activity { }
+    public static final class SGTStub_02_T extends Activity { }
+
+    public static final class SGTKStub_00 extends Activity { }
+    public static final class SGTKStub_01 extends Activity { }
+    public static final class SGTKStub_02 extends Activity { }
+    public static final class SGTKStub_03 extends Activity { }
+    public static final class SGTKStub_04 extends Activity { }
+    public static final class SGTKStub_05 extends Activity { }
+    public static final class SGTKStub_06 extends Activity { }
+    public static final class SGTKStub_07 extends Activity { }
+    public static final class SGTKStub_08 extends Activity { }
+    public static final class SGTKStub_09 extends Activity { }
+
+    public static final class SGTKStub_00_T extends Activity { }
+    public static final class SGTKStub_01_T extends Activity { }
+    public static final class SGTKStub_02_T extends Activity { }
+
+    public static final class SIStub_00 extends Activity { }
+    public static final class SIStub_01 extends Activity { }
+    public static final class SIStub_02 extends Activity { }
+    public static final class SIStub_03 extends Activity { }
+    public static final class SIStub_04 extends Activity { }
+    public static final class SIStub_05 extends Activity { }
+    public static final class SIStub_06 extends Activity { }
+    public static final class SIStub_07 extends Activity { }
+    public static final class SIStub_08 extends Activity { }
+    public static final class SIStub_09 extends Activity { }
+
+    public static final class SIStub_00_T extends Activity { }
+    public static final class SIStub_01_T extends Activity { }
+    public static final class SIStub_02_T extends Activity { }
+
+    private ActivityStubs() {
+        throw new UnsupportedOperationException();
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/ComponentHotplug.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/ComponentHotplug.java
new file mode 100644
index 00000000..e98b2d37
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/ComponentHotplug.java
@@ -0,0 +1,103 @@
+package com.tencent.tinker.loader.hotplug;
+
+import android.content.Context;
+import android.os.Handler;
+import android.util.Log;
+
+import com.tencent.tinker.loader.app.TinkerApplication;
+import com.tencent.tinker.loader.hotplug.handler.AMSInterceptHandler;
+import com.tencent.tinker.loader.hotplug.handler.MHMessageHandler;
+import com.tencent.tinker.loader.hotplug.handler.PMSInterceptHandler;
+import com.tencent.tinker.loader.hotplug.interceptor.HandlerMessageInterceptor;
+import com.tencent.tinker.loader.hotplug.interceptor.ServiceBinderInterceptor;
+import com.tencent.tinker.loader.shareutil.ShareReflectUtil;
+import com.tencent.tinker.loader.shareutil.ShareSecurityCheck;
+
+import java.lang.reflect.Field;
+
+/**
+ * Created by tangyinsheng on 2017/7/31.
+ */
+
+public final class ComponentHotplug {
+    private static final String TAG = "Tinker.ComponentHotplug";
+
+    private static volatile boolean sInstalled = false;
+    private static ServiceBinderInterceptor sAMSInterceptor;
+    private static ServiceBinderInterceptor sPMSInterceptor;
+    private static HandlerMessageInterceptor sMHMessageInterceptor;
+
+    public synchronized static void install(TinkerApplication app, ShareSecurityCheck checker) throws UnsupportedEnvironmentException {
+        if (!sInstalled) {
+            try {
+                if (IncrementComponentManager.init(app, checker)) {
+                    sAMSInterceptor = new ServiceBinderInterceptor(app, EnvConsts.ACTIVITY_MANAGER_SRVNAME, new AMSInterceptHandler(app));
+                    sPMSInterceptor = new ServiceBinderInterceptor(app, EnvConsts.PACKAGE_MANAGER_SRVNAME, new PMSInterceptHandler());
+
+                    final Handler mH = fetchMHInstance(app);
+                    sMHMessageInterceptor = new HandlerMessageInterceptor(mH, new MHMessageHandler(app));
+
+                    sAMSInterceptor.install();
+                    sPMSInterceptor.install();
+                    sMHMessageInterceptor.install();
+
+                    sInstalled = true;
+
+                    Log.i(TAG, "installed successfully.");
+                }
+            } catch (Throwable thr) {
+                uninstall();
+                throw new UnsupportedEnvironmentException(thr);
+            }
+        }
+    }
+
+    public synchronized static void ensureComponentHotplugInstalled(TinkerApplication app) throws UnsupportedEnvironmentException {
+        // Some environments may reset AMS, PMS and mH，which cause component hotplug feature
+        // being unavailable. So we reinstall them here.
+        if (sInstalled) {
+            try {
+                sAMSInterceptor.install();
+                sPMSInterceptor.install();
+                sMHMessageInterceptor.install();
+            } catch (Throwable thr) {
+                uninstall();
+                throw new UnsupportedEnvironmentException(thr);
+            }
+        } else {
+            Log.i(TAG, "method install() is not invoked, ignore ensuring operations.");
+        }
+    }
+
+    private static Handler fetchMHInstance(Context context) {
+        final Object activityThread = ShareReflectUtil.getActivityThread(context, null);
+        if (activityThread == null) {
+            throw new IllegalStateException("failed to fetch instance of ActivityThread.");
+        }
+        try {
+            final Field mHField = ShareReflectUtil.findField(activityThread, "mH");
+            final Handler mH = (Handler) mHField.get(activityThread);
+            return mH;
+        } catch (Throwable thr) {
+            throw new IllegalStateException(thr);
+        }
+    }
+
+    public synchronized static void uninstall()  {
+        if (sInstalled) {
+            try {
+                sAMSInterceptor.uninstall();
+                sPMSInterceptor.uninstall();
+                sMHMessageInterceptor.uninstall();
+            } catch (Throwable thr) {
+                Log.e(TAG, "exception when uninstall.", thr);
+            }
+
+            sInstalled = false;
+        }
+    }
+
+    private ComponentHotplug() {
+        throw new UnsupportedOperationException();
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/EnvConsts.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/EnvConsts.java
new file mode 100644
index 00000000..b8a38b25
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/EnvConsts.java
@@ -0,0 +1,21 @@
+package com.tencent.tinker.loader.hotplug;
+
+import android.content.Context;
+
+/**
+ * Created by tangyinsheng on 2017/8/3.
+ */
+
+public final class EnvConsts {
+    public static final String ACTIVITY_MANAGER_SRVNAME = Context.ACTIVITY_SERVICE;
+    public static final String PACKAGE_MANAGER_SRVNAME = "package";
+
+    public static final String INTENT_EXTRA_OLD_COMPONENT = "tinker_iek_old_component";
+
+    // Please keep it synchronized with the other one defined in 'TypedValue' class
+    public static final String INCCOMPONENT_META_FILE = "assets/inc_component_meta.txt";
+
+    private EnvConsts() {
+        throw new UnsupportedOperationException();
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/IncrementComponentManager.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/IncrementComponentManager.java
new file mode 100644
index 00000000..4aef786c
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/IncrementComponentManager.java
@@ -0,0 +1,629 @@
+package com.tencent.tinker.loader.hotplug;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.ContextWrapper;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.ActivityInfo;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.ResolveInfo;
+import android.content.res.Resources;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.PatternMatcher;
+import android.text.TextUtils;
+import android.util.Log;
+import android.util.Xml;
+
+import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
+import com.tencent.tinker.loader.shareutil.ShareReflectUtil;
+import com.tencent.tinker.loader.shareutil.ShareSecurityCheck;
+
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+
+import java.io.IOException;
+import java.io.StringReader;
+import java.lang.reflect.Method;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Created by tangyinsheng on 2017/8/3.
+ */
+
+public final class IncrementComponentManager {
+    private static final String TAG = "Tinker.IncrementCompMgr";
+
+    private static final int TAG_ACTIVITY = 0;
+    private static final int TAG_SERVICE = 1;
+    private static final int TAG_PROVIDER = 2;
+    private static final int TAG_RECEIVER = 3;
+
+    private static Context sContext = null;
+    private static String sPackageName = null;
+    private static volatile boolean sInitialized = false;
+    private static final Map<String, ActivityInfo> sClassNameToActivityInfoMap = new HashMap<>();
+    private static final Map<String, IntentFilter> sClassNameToIntentFilterMap = new HashMap<>();
+
+
+    private static abstract class AttrTranslator<T_RESULT> {
+        final void translate(Context context, int tagType, XmlPullParser parser, T_RESULT result) {
+            onInit(context, tagType, parser);
+
+            final int attrCount = parser.getAttributeCount();
+            for (int i = 0; i < attrCount; ++i) {
+                final String attrPrefix = parser.getAttributePrefix(i);
+                if (!"android".equals(attrPrefix)) {
+                    continue;
+                }
+                final String attrName = parser.getAttributeName(i);
+                final String attrValue = parser.getAttributeValue(i);
+                onTranslate(context, tagType, attrName, attrValue, result);
+            }
+        }
+
+        void onInit(Context context, int tagType, XmlPullParser parser) {
+            // Do nothing.
+        }
+
+        abstract void onTranslate(Context context, int tagType, String attrName, String attrValue, T_RESULT result);
+    }
+
+    private static final AttrTranslator<ActivityInfo> sActivityInfoAttrTranslator = new AttrTranslator<ActivityInfo>() {
+
+        @Override
+        void onInit(Context context, int tagType, XmlPullParser parser) {
+            try {
+                if (tagType == TAG_ACTIVITY
+                        && (parser.getEventType() != XmlPullParser.START_TAG
+                        || !"activity".equals(parser.getName()))) {
+                    throw new IllegalStateException("unexpected xml parser state when parsing incremental component manifest.");
+                }
+            } catch (XmlPullParserException e) {
+                throw new IllegalStateException(e);
+            }
+        }
+
+        @Override
+        void onTranslate(Context context, int tagType, String attrName, String attrValue, ActivityInfo result) {
+            if ("name".equals(attrName)) {
+                if (attrValue.charAt(0) == '.') {
+                    result.name = context.getPackageName() + attrValue;
+                } else {
+                    result.name = attrValue;
+                }
+            } else if ("parentActivityName".equals(attrName)) {
+                if (Build.VERSION.SDK_INT >= 16) {
+                    if (attrValue.charAt(0) == '.') {
+                        result.parentActivityName = context.getPackageName() + attrValue;
+                    } else {
+                        result.parentActivityName = attrValue;
+                    }
+                }
+            } else if ("exported".equals(attrName)) {
+                result.exported = "true".equalsIgnoreCase(attrValue);
+            } else if ("launchMode".equals(attrName)) {
+                result.launchMode = parseLaunchMode(attrValue);
+            } else if ("theme".equals(attrName)) {
+                final Resources res = context.getResources();
+                final String packageName = context.getPackageName();
+                result.theme = res.getIdentifier(attrValue, "style", packageName);
+            } else if ("uiOptions".equals(attrName)) {
+                if (Build.VERSION.SDK_INT >= 14) {
+                    result.uiOptions = Integer.decode(attrValue);
+                }
+            } else if ("permission".equals(attrName)) {
+                result.permission = attrValue;
+            } else if ("taskAffinity".equals(attrName)) {
+                result.taskAffinity = attrValue;
+            } else if ("multiprocess".equals(attrName)) {
+                if ("true".equalsIgnoreCase(attrValue)) {
+                    result.flags |= ActivityInfo.FLAG_MULTIPROCESS;
+                } else {
+                    result.flags &= ~ActivityInfo.FLAG_MULTIPROCESS;
+                }
+            } else if ("finishOnTaskLaunch".equals(attrName)) {
+                if ("true".equalsIgnoreCase(attrValue)) {
+                    result.flags |= ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH;
+                } else {
+                    result.flags &= ~ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH;
+                }
+            } else if ("clearTaskOnLaunch".equals(attrName)) {
+                if ("true".equalsIgnoreCase(attrValue)) {
+                    result.flags |= ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH;
+                } else {
+                    result.flags &= ~ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH;
+                }
+            } else if ("noHistory".equals(attrName)) {
+                if ("true".equalsIgnoreCase(attrValue)) {
+                    result.flags |= ActivityInfo.FLAG_NO_HISTORY;
+                } else {
+                    result.flags &= ~ActivityInfo.FLAG_NO_HISTORY;
+                }
+            } else if ("alwaysRetainTaskState".equals(attrName)) {
+                if ("true".equalsIgnoreCase(attrValue)) {
+                    result.flags |= ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE;
+                } else {
+                    result.flags &= ~ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE;
+                }
+            } else if ("stateNotNeeded".equals(attrName)) {
+                if ("true".equalsIgnoreCase(attrValue)) {
+                    result.flags |= ActivityInfo.FLAG_STATE_NOT_NEEDED;
+                } else {
+                    result.flags &= ~ActivityInfo.FLAG_STATE_NOT_NEEDED;
+                }
+            } else if ("excludeFromRecents".equals(attrName)) {
+                if ("true".equalsIgnoreCase(attrValue)) {
+                    result.flags |= ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
+                } else {
+                    result.flags &= ~ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
+                }
+            } else if ("allowTaskReparenting".equals(attrName)) {
+                if ("true".equalsIgnoreCase(attrValue)) {
+                    result.flags |= ActivityInfo.FLAG_ALLOW_TASK_REPARENTING;
+                } else {
+                    result.flags &= ~ActivityInfo.FLAG_ALLOW_TASK_REPARENTING;
+                }
+            } else if ("finishOnCloseSystemDialogs".equals(attrName)) {
+                if ("true".equalsIgnoreCase(attrValue)) {
+                    result.flags |= ActivityInfo.FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS;
+                } else {
+                    result.flags &= ~ActivityInfo.FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS;
+                }
+            } else if ("showOnLockScreen".equals(attrName) || "showForAllUsers".equals(attrName)) {
+                if (Build.VERSION.SDK_INT >= 23) {
+                    final int flag = ShareReflectUtil
+                            .getValueOfStaticIntField(ActivityInfo.class, "FLAG_SHOW_FOR_ALL_USERS", 0);
+                    if ("true".equalsIgnoreCase(attrValue)) {
+                        result.flags |= flag;
+                    } else {
+                        result.flags &= ~flag;
+                    }
+                }
+            } else if ("immersive".equals(attrName)) {
+                if (Build.VERSION.SDK_INT >= 18) {
+                    if ("true".equalsIgnoreCase(attrValue)) {
+                        result.flags |= ActivityInfo.FLAG_IMMERSIVE;
+                    } else {
+                        result.flags &= ~ActivityInfo.FLAG_IMMERSIVE;
+                    }
+                }
+            } else if ("hardwareAccelerated".equals(attrName)) {
+                if (Build.VERSION.SDK_INT >= 11) {
+                    if ("true".equalsIgnoreCase(attrValue)) {
+                        result.flags |= ActivityInfo.FLAG_HARDWARE_ACCELERATED;
+                    } else {
+                        result.flags &= ~ActivityInfo.FLAG_HARDWARE_ACCELERATED;
+                    }
+                }
+            } else if ("documentLaunchMode".equals(attrName)) {
+                if (Build.VERSION.SDK_INT >= 21) {
+                    result.documentLaunchMode = Integer.decode(attrValue);
+                }
+            } else if ("maxRecents".equals(attrName)) {
+                if (Build.VERSION.SDK_INT >= 21) {
+                    result.maxRecents = Integer.decode(attrValue);
+                }
+            } else if ("configChanges".equals(attrName)) {
+                result.configChanges = Integer.decode(attrValue);
+            } else if ("windowSoftInputMode".equals(attrName)) {
+                result.softInputMode = Integer.decode(attrValue);
+            } else if ("persistableMode".equals(attrName)) {
+                if (Build.VERSION.SDK_INT >= 21) {
+                    result.persistableMode = Integer.decode(attrValue);
+                }
+            } else if ("allowEmbedded".equals(attrName)) {
+                final int flag = ShareReflectUtil
+                        .getValueOfStaticIntField(ActivityInfo.class, "FLAG_ALLOW_EMBEDDED", 0);
+                if ("true".equalsIgnoreCase(attrValue)) {
+                    result.flags |= flag;
+                } else {
+                    result.flags &= ~flag;
+                }
+            } else if ("autoRemoveFromRecents".equals(attrName)) {
+                if (Build.VERSION.SDK_INT >= 21) {
+                    if ("true".equalsIgnoreCase(attrValue)) {
+                        result.flags |= ActivityInfo.FLAG_AUTO_REMOVE_FROM_RECENTS;
+                    } else {
+                        result.flags &= ~ActivityInfo.FLAG_AUTO_REMOVE_FROM_RECENTS;
+                    }
+                }
+            } else if ("relinquishTaskIdentity".equals(attrName)) {
+                if (Build.VERSION.SDK_INT >= 21) {
+                    if ("true".equalsIgnoreCase(attrValue)) {
+                        result.flags |= ActivityInfo.FLAG_RELINQUISH_TASK_IDENTITY;
+                    } else {
+                        result.flags &= ~ActivityInfo.FLAG_RELINQUISH_TASK_IDENTITY;
+                    }
+                }
+            } else if ("resumeWhilePausing".equals(attrName)) {
+                if (Build.VERSION.SDK_INT >= 21) {
+                    if ("true".equalsIgnoreCase(attrValue)) {
+                        result.flags |= ActivityInfo.FLAG_RESUME_WHILE_PAUSING;
+                    } else {
+                        result.flags &= ~ActivityInfo.FLAG_RESUME_WHILE_PAUSING;
+                    }
+                }
+            } else if ("screenOrientation".equals(attrName)) {
+                result.screenOrientation = parseScreenOrientation(attrValue);
+            } else if ("label".equals(attrName)) {
+                final String strOrResId = attrValue;
+                int id = 0;
+                try {
+                    id = context.getResources().getIdentifier(strOrResId, "string", sPackageName);
+                } catch (Throwable ignored) {
+                    // Ignored.
+                }
+                if (id != 0) {
+                    result.labelRes = id;
+                } else {
+                    result.nonLocalizedLabel = strOrResId;
+                }
+            } else if ("icon".equals(attrName)) {
+                try {
+                    result.icon = context.getResources().getIdentifier(attrValue, null, sPackageName);
+                } catch (Throwable ignored) {
+                    // Ignored.
+                }
+            } else if ("banner".equals(attrName)) {
+                if (Build.VERSION.SDK_INT >= 20) {
+                    try {
+                        result.banner = context.getResources().getIdentifier(attrValue, null, sPackageName);
+                    } catch (Throwable ignored) {
+                        // Ignored.
+                    }
+                }
+            } else if ("logo".equals(attrName)) {
+                try {
+                    result.logo = context.getResources().getIdentifier(attrValue, null, sPackageName);
+                } catch (Throwable ignored) {
+                    // Ignored.
+                }
+            }
+        }
+
+        private int parseLaunchMode(String attrValue) {
+            if ("standard".equalsIgnoreCase(attrValue)) {
+                return ActivityInfo.LAUNCH_MULTIPLE;
+            } else if ("singleTop".equalsIgnoreCase(attrValue)) {
+                return ActivityInfo.LAUNCH_SINGLE_TOP;
+            } else if ("singleTask".equalsIgnoreCase(attrValue)) {
+                return ActivityInfo.LAUNCH_SINGLE_TASK;
+            } else if ("singleInstance".equalsIgnoreCase(attrValue)) {
+                return ActivityInfo.LAUNCH_SINGLE_INSTANCE;
+            } else {
+                Log.w(TAG, "Unknown launchMode: " + attrValue);
+                return ActivityInfo.LAUNCH_MULTIPLE;
+            }
+        }
+
+        private int parseScreenOrientation(String attrValue) {
+            if ("unspecified".equalsIgnoreCase(attrValue)) {
+                return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
+            } else if ("behind".equalsIgnoreCase(attrValue)) {
+                return ActivityInfo.SCREEN_ORIENTATION_BEHIND;
+            } else if ("landscape".equalsIgnoreCase(attrValue)) {
+                return ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
+            } else if ("portrait".equalsIgnoreCase(attrValue)) {
+                return ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
+            } else if ("reverseLandscape".equalsIgnoreCase(attrValue)) {
+                return ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE;
+            } else if ("reversePortrait".equalsIgnoreCase(attrValue)) {
+                return ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT;
+            } else if ("sensorLandscape".equalsIgnoreCase(attrValue)) {
+                return ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE;
+            } else if ("sensorPortrait".equalsIgnoreCase(attrValue)) {
+                return ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT;
+            } else if ("sensor".equalsIgnoreCase(attrValue)) {
+                return ActivityInfo.SCREEN_ORIENTATION_SENSOR;
+            } else if ("fullSensor".equalsIgnoreCase(attrValue)) {
+                return ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR;
+            } else if ("nosensor".equalsIgnoreCase(attrValue)) {
+                return ActivityInfo.SCREEN_ORIENTATION_NOSENSOR;
+            } else if ("user".equalsIgnoreCase(attrValue)) {
+                return ActivityInfo.SCREEN_ORIENTATION_USER;
+            } else if (Build.VERSION.SDK_INT >= 18 && "fullUser".equalsIgnoreCase(attrValue)) {
+                return ActivityInfo.SCREEN_ORIENTATION_FULL_USER;
+            } else if (Build.VERSION.SDK_INT >= 18 && "locked".equalsIgnoreCase(attrValue)) {
+                return ActivityInfo.SCREEN_ORIENTATION_LOCKED;
+            } else if (Build.VERSION.SDK_INT >= 18 && "userLandscape".equalsIgnoreCase(attrValue)) {
+                return ActivityInfo.SCREEN_ORIENTATION_USER_LANDSCAPE;
+            } else if (Build.VERSION.SDK_INT >= 18 && "userPortrait".equalsIgnoreCase(attrValue)) {
+                return ActivityInfo.SCREEN_ORIENTATION_USER_PORTRAIT;
+            } else {
+                return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
+            }
+        }
+    };
+
+    public static synchronized boolean init(Context context, ShareSecurityCheck checker) throws IOException {
+        if (!checker.getMetaContentMap().containsKey(EnvConsts.INCCOMPONENT_META_FILE)) {
+            Log.i(TAG, "package has no incremental component meta, skip init.");
+            return false;
+        }
+        while (context instanceof ContextWrapper) {
+            final Context baseCtx = ((ContextWrapper) context).getBaseContext();
+            if (baseCtx == null) {
+                break;
+            }
+            context = baseCtx;
+        }
+        sContext = context;
+        sPackageName = context.getPackageName();
+        final String xmlMeta = checker.getMetaContentMap().get(EnvConsts.INCCOMPONENT_META_FILE);
+        StringReader sr = new StringReader(xmlMeta);
+        XmlPullParser parser = null;
+        try {
+            parser = Xml.newPullParser();
+            parser.setInput(sr);
+            int event = parser.getEventType();
+            while (event != XmlPullParser.END_DOCUMENT) {
+                switch (event) {
+                    case XmlPullParser.START_TAG:
+                        final String tagName = parser.getName();
+                        if ("activity".equalsIgnoreCase(tagName)) {
+                            final ActivityInfo aInfo = parseActivity(context, parser);
+                            sClassNameToActivityInfoMap.put(aInfo.name, aInfo);
+                        } else if ("service".equalsIgnoreCase(tagName)) {
+                            // TODO support service component.
+                        } else if ("receiver".equalsIgnoreCase(tagName)) {
+                            // TODO support receiver component.
+                        } else if ("provider".equalsIgnoreCase(tagName)) {
+                            // TODO support provider component.
+                        }
+                        break;
+                    default:
+                        break;
+                }
+                event = parser.next();
+            }
+            sInitialized = true;
+            return true;
+        } catch (XmlPullParserException e) {
+            throw new IOException(e);
+        } finally {
+            if (parser != null) {
+                try {
+                    parser.setInput(null);
+                } catch (Throwable ignored) {
+                    // Ignored.
+                }
+            }
+            SharePatchFileUtil.closeQuietly(sr);
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    private static synchronized ActivityInfo parseActivity(Context context, XmlPullParser parser)
+            throws XmlPullParserException, IOException {
+        final ActivityInfo aInfo = new ActivityInfo();
+        final ApplicationInfo appInfo = context.getApplicationInfo();
+
+        aInfo.applicationInfo = appInfo;
+        aInfo.packageName = sPackageName;
+        aInfo.processName = appInfo.processName;
+        aInfo.launchMode = ActivityInfo.LAUNCH_MULTIPLE;
+        aInfo.permission = appInfo.permission;
+        aInfo.screenOrientation = ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
+        aInfo.taskAffinity = appInfo.taskAffinity;
+
+        if (Build.VERSION.SDK_INT >= 11 && (appInfo.flags & ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != 0) {
+            aInfo.flags |= ActivityInfo.FLAG_HARDWARE_ACCELERATED;
+        }
+
+        if (Build.VERSION.SDK_INT >= 21) {
+            aInfo.documentLaunchMode = ActivityInfo.DOCUMENT_LAUNCH_NONE;
+        }
+        if (Build.VERSION.SDK_INT >= 14) {
+            aInfo.uiOptions = appInfo.uiOptions;
+        }
+
+        sActivityInfoAttrTranslator.translate(context, TAG_ACTIVITY, parser, aInfo);
+
+        final int outerDepth = parser.getDepth();
+        while (true) {
+            final int type = parser.next();
+            if (type == XmlPullParser.END_DOCUMENT
+                    || (type == XmlPullParser.END_TAG && parser.getDepth() <= outerDepth)) {
+                break;
+            } else if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
+                continue;
+            }
+
+            final String tagName = parser.getName();
+            if ("intent-filter".equalsIgnoreCase(tagName)) {
+                parseIntentFilter(context, aInfo.name, parser);
+            } else if ("meta-data".equalsIgnoreCase(tagName)) {
+                parseMetaData(context, aInfo, parser);
+            }
+        }
+
+        return aInfo;
+    }
+
+    private static synchronized void parseIntentFilter(Context context, String componentName, XmlPullParser parser)
+            throws XmlPullParserException, IOException {
+        final IntentFilter intentFilter = new IntentFilter();
+
+        final String priorityStr = parser.getAttributeValue(null, "priority");
+        if (!TextUtils.isEmpty(priorityStr)) {
+            intentFilter.setPriority(Integer.decode(priorityStr));
+        }
+
+        final String autoVerify = parser.getAttributeValue(null, "autoVerify");
+        if (!TextUtils.isEmpty(autoVerify)) {
+            try {
+                final Method setAutoVerifyMethod
+                        = ShareReflectUtil.findMethod(IntentFilter.class, "setAutoVerify", boolean.class);
+                setAutoVerifyMethod.invoke(intentFilter, "true".equalsIgnoreCase(autoVerify));
+            } catch (Throwable ignored) {
+                // Ignored.
+            }
+        }
+
+        final int outerDepth = parser.getDepth();
+        while (true) {
+            final int type = parser.next();
+            if (type == XmlPullParser.END_DOCUMENT
+                    || (type == XmlPullParser.END_TAG && parser.getDepth() <= outerDepth)) {
+                break;
+            } else if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
+                continue;
+            }
+
+            final String tagName = parser.getName();
+            if ("action".equals(tagName)) {
+                final String name = parser.getAttributeValue(null, "name");
+                if (name != null) {
+                    intentFilter.addAction(name);
+                }
+            } else if ("category".equals(tagName)) {
+                final String name = parser.getAttributeValue(null, "name");
+                if (name != null) {
+                    intentFilter.addCategory(name);
+                }
+            } else if ("data".equals(tagName)) {
+                final String mimeType = parser.getAttributeValue(null, "mimeType");
+                if (mimeType != null) {
+                    try {
+                        intentFilter.addDataType(mimeType);
+                    } catch (IntentFilter.MalformedMimeTypeException e) {
+                        throw new XmlPullParserException("bad mimeType", parser, e);
+                    }
+                }
+                final String scheme = parser.getAttributeValue(null, "scheme");
+                if (scheme != null) {
+                    intentFilter.addDataScheme(scheme);
+                }
+                if (Build.VERSION.SDK_INT >= 19) {
+                    final String ssp = parser.getAttributeValue(null, "ssp");
+                    if (ssp != null) {
+                        intentFilter.addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_LITERAL);
+                    }
+                    final String sspPrefix = parser.getAttributeValue(null, "sspPrefix");
+                    if (sspPrefix != null) {
+                        intentFilter.addDataSchemeSpecificPart(sspPrefix, PatternMatcher.PATTERN_PREFIX);
+                    }
+                    final String sspPattern = parser.getAttributeValue(null, "sspPattern");
+                    if (sspPattern != null) {
+                        intentFilter.addDataSchemeSpecificPart(sspPattern, PatternMatcher.PATTERN_SIMPLE_GLOB);
+                    }
+                }
+                final String host = parser.getAttributeValue(null, "host");
+                final String port = parser.getAttributeValue(null, "port");
+                if (host != null) {
+                    intentFilter.addDataAuthority(host, port);
+                }
+                final String path = parser.getAttributeValue(null, "path");
+                if (path != null) {
+                    intentFilter.addDataPath(path, PatternMatcher.PATTERN_LITERAL);
+                }
+                final String pathPrefix = parser.getAttributeValue(null, "pathPrefix");
+                if (pathPrefix != null) {
+                    intentFilter.addDataPath(pathPrefix, PatternMatcher.PATTERN_PREFIX);
+                }
+                final String pathPattern = parser.getAttributeValue(null, "pathPattern");
+                if (pathPattern != null) {
+                    intentFilter.addDataPath(pathPattern, PatternMatcher.PATTERN_SIMPLE_GLOB);
+                }
+            }
+            skipCurrentTag(parser);
+        }
+
+        sClassNameToIntentFilterMap.put(componentName, intentFilter);
+    }
+
+    private static synchronized void parseMetaData(Context context, ActivityInfo aInfo, XmlPullParser parser)
+            throws XmlPullParserException, IOException {
+        final ClassLoader myCl = IncrementComponentManager.class.getClassLoader();
+        final String name = parser.getAttributeValue(null, "name");
+        final String value = parser.getAttributeValue(null, "value");
+        if (!TextUtils.isEmpty(name)) {
+            if (aInfo.metaData == null) {
+                aInfo.metaData = new Bundle(myCl);
+            }
+            aInfo.metaData.putString(name, value);
+        }
+    }
+
+    private static void skipCurrentTag(XmlPullParser parser) throws IOException, XmlPullParserException {
+        int outerDepth = parser.getDepth();
+        int type;
+        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT
+                && (type != XmlPullParser.END_TAG
+                || parser.getDepth() > outerDepth)) {
+        }
+    }
+
+    private static synchronized void ensureInitialized() {
+        if (!sInitialized) {
+            throw new IllegalStateException("Not initialized!!");
+        }
+    }
+
+    public static boolean isIncrementActivity(String className) {
+        ensureInitialized();
+        return className != null && sClassNameToActivityInfoMap.containsKey(className);
+    }
+
+    public static ActivityInfo queryActivityInfo(String className) {
+        ensureInitialized();
+        return (className != null ? sClassNameToActivityInfoMap.get(className) : null);
+    }
+
+    // TODO needs to support rest type of components.
+    public static ResolveInfo resolveIntent(Intent intent) {
+        ensureInitialized();
+
+        int maxPriority = -1;
+        String bestComponentName = null;
+        IntentFilter respFilter = null;
+        int bestMatchRes = 0;
+
+        final ComponentName component = intent.getComponent();
+        if (component != null) {
+            final String compName = component.getClassName();
+            if (sClassNameToActivityInfoMap.containsKey(compName)) {
+                bestComponentName = compName;
+                maxPriority = 0;
+            }
+        } else {
+            for (Map.Entry<String, IntentFilter> item : sClassNameToIntentFilterMap.entrySet()) {
+                final String componentName = item.getKey();
+                final IntentFilter intentFilter = item.getValue();
+                final int matchRes = intentFilter.match(intent.getAction(), intent.getType(),
+                        intent.getScheme(), intent.getData(), intent.getCategories(), TAG);
+                final boolean matches = (matchRes != IntentFilter.NO_MATCH_ACTION)
+                        && (matchRes != IntentFilter.NO_MATCH_CATEGORY)
+                        && (matchRes != IntentFilter.NO_MATCH_DATA)
+                        && (matchRes != IntentFilter.NO_MATCH_TYPE);
+                final int priority = intentFilter.getPriority();
+                if (matches && priority > maxPriority) {
+                    maxPriority = priority;
+                    bestComponentName = componentName;
+                    respFilter = intentFilter;
+                    bestMatchRes = matchRes;
+                }
+            }
+        }
+        if (bestComponentName != null) {
+            final ResolveInfo result = new ResolveInfo();
+            result.activityInfo = sClassNameToActivityInfoMap.get(bestComponentName);
+            result.filter = respFilter;
+            result.match = bestMatchRes;
+            result.priority = maxPriority;
+            result.resolvePackageName = sPackageName;
+            result.icon = result.activityInfo.icon;
+            result.labelRes = result.activityInfo.labelRes;
+            return result;
+        } else {
+            return null;
+        }
+    }
+
+    private IncrementComponentManager() {
+        throw new UnsupportedOperationException();
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/UnsupportedEnvironmentException.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/UnsupportedEnvironmentException.java
new file mode 100644
index 00000000..091cedd3
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/UnsupportedEnvironmentException.java
@@ -0,0 +1,16 @@
+package com.tencent.tinker.loader.hotplug;
+
+/**
+ * Created by tangyinsheng on 2017/7/31.
+ */
+
+public class UnsupportedEnvironmentException extends UnsupportedOperationException {
+
+    public UnsupportedEnvironmentException(String msg) {
+        super(msg);
+    }
+
+    public UnsupportedEnvironmentException(Throwable thr) {
+        super(thr);
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/handler/AMSInterceptHandler.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/handler/AMSInterceptHandler.java
new file mode 100644
index 00000000..8dc7faf9
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/handler/AMSInterceptHandler.java
@@ -0,0 +1,180 @@
+package com.tencent.tinker.loader.hotplug.handler;
+
+import android.app.ActivityManager;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.ContextWrapper;
+import android.content.Intent;
+import android.content.pm.ActivityInfo;
+import android.content.pm.ResolveInfo;
+import android.content.res.Resources;
+import android.content.res.TypedArray;
+
+import com.tencent.tinker.loader.hotplug.ActivityStubManager;
+import com.tencent.tinker.loader.hotplug.EnvConsts;
+import com.tencent.tinker.loader.hotplug.IncrementComponentManager;
+import com.tencent.tinker.loader.hotplug.interceptor.ServiceBinderInterceptor.BinderInvocationHandler;
+import com.tencent.tinker.loader.shareutil.ShareIntentUtil;
+import com.tencent.tinker.loader.shareutil.ShareReflectUtil;
+
+import java.lang.reflect.Method;
+
+/**
+ * Created by tangyinsheng on 2017/7/31.
+ */
+
+public class AMSInterceptHandler implements BinderInvocationHandler {
+    private static final String TAG = "Tinker.AMSIntrcptHndlr";
+
+    private static final int[] TRANSLUCENT_ATTR_ID = {android.R.attr.windowIsTranslucent};
+    private static final int INTENT_SENDER_ACTIVITY;
+
+    static {
+        int val = 0;
+        try {
+            val = (int) ShareReflectUtil.findField(ActivityManager.class, "INTENT_SENDER_ACTIVITY").get(null);
+        } catch (Throwable thr) {
+            thr.printStackTrace();
+            val = 2;
+        }
+        INTENT_SENDER_ACTIVITY = val;
+    }
+
+    private final Context mContext;
+
+    public AMSInterceptHandler(Context context) {
+        while (context instanceof ContextWrapper) {
+            final Context baseCtx = ((ContextWrapper) context).getBaseContext();
+            if (baseCtx == null) {
+                break;
+            }
+            context = baseCtx;
+        }
+        mContext = context;
+    }
+
+    @Override
+    public Object invoke(Object target, Method method, Object[] args) throws Throwable {
+        final String methodName = method.getName();
+        if ("startActivity".equals(methodName)) {
+            return handleStartActivity(target, method, args);
+        } else if ("startActivities".equals(methodName)) {
+            return handleStartActivities(target, method, args);
+        } else if ("startActivityAndWait".equals(methodName)) {
+            return handleStartActivity(target, method, args);
+        } else if ("startActivityWithConfig".equals(methodName)) {
+            return handleStartActivity(target, method, args);
+        } else if ("startActivityAsUser".equals(methodName)) {
+            return handleStartActivity(target, method, args);
+        } else if ("getIntentSender".equals(methodName)) {
+            return handleGetIntentSender(target, method, args);
+        }
+        return method.invoke(target, args);
+    }
+
+    private Object handleStartActivity(Object target, Method method, Object[] args) throws Throwable {
+        int intentIdx = -1;
+        for (int i = 0; i < args.length; ++i) {
+            if (args[i] instanceof Intent) {
+                intentIdx = i;
+                break;
+            }
+        }
+        if (intentIdx != -1) {
+            final Intent newIntent = new Intent((Intent) args[intentIdx]);
+            processActivityIntent(newIntent);
+            args[intentIdx] = newIntent;
+        }
+        return method.invoke(target, args);
+    }
+
+    private Object handleStartActivities(Object target, Method method, Object[] args) throws Throwable {
+        int intentArrIdx = -1;
+        for (int i = 0; i < args.length; ++i) {
+            if (args[i] instanceof Intent[]) {
+                intentArrIdx = i;
+                break;
+            }
+        }
+        if (intentArrIdx != -1) {
+            final Intent[] oldIntentArr = (Intent[]) args[intentArrIdx];
+            for (int i = 0; i < oldIntentArr.length; ++i) {
+                final Intent newIntent = new Intent(oldIntentArr[i]);
+                processActivityIntent(newIntent);
+                oldIntentArr[i] = newIntent;
+            }
+        }
+        return method.invoke(target, args);
+    }
+
+    private Object handleGetIntentSender(Object target, Method method, Object[] args) throws Throwable {
+        int intentArrIdx = -1;
+        for (int i = 0; i < args.length; ++i) {
+            if (args[i] instanceof Intent[]) {
+                intentArrIdx = i;
+                break;
+            }
+        }
+        if (intentArrIdx != -1) {
+            final int intentType = (int) args[0];
+            if (intentType == INTENT_SENDER_ACTIVITY) {
+                final Intent[] oldIntentArr = (Intent[]) args[intentArrIdx];
+                for (int i = 0; i < oldIntentArr.length; ++i) {
+                    final Intent newIntent = new Intent(oldIntentArr[i]);
+                    processActivityIntent(newIntent);
+                    oldIntentArr[i] = newIntent;
+                }
+            }
+        }
+        return method.invoke(target, args);
+    }
+
+    private void processActivityIntent(Intent intent) {
+        String origPackageName = null;
+        String origClassName = null;
+        if (intent.getComponent() != null) {
+            origPackageName = intent.getComponent().getPackageName();
+            origClassName = intent.getComponent().getClassName();
+        } else {
+            ResolveInfo rInfo = mContext.getPackageManager().resolveActivity(intent, 0);
+            if (rInfo == null) {
+                rInfo = IncrementComponentManager.resolveIntent(intent);
+            }
+            if (rInfo != null && rInfo.filter != null && rInfo.filter.hasCategory(Intent.CATEGORY_DEFAULT)) {
+                origPackageName = rInfo.activityInfo.packageName;
+                origClassName = rInfo.activityInfo.name;
+            }
+        }
+        if (IncrementComponentManager.isIncrementActivity(origClassName)) {
+            final ActivityInfo origInfo = IncrementComponentManager.queryActivityInfo(origClassName);
+            final boolean isTransparent = hasTransparentTheme(origInfo);
+            final String stubClassName = ActivityStubManager.assignStub(origClassName, origInfo.launchMode, isTransparent);
+            storeAndReplaceOriginalComponentName(intent, origPackageName, origClassName, stubClassName);
+        }
+    }
+
+    private void storeAndReplaceOriginalComponentName(Intent intent, String origPackageName, String origClassName, String stubClassName) {
+        final ComponentName origComponentName = new ComponentName(origPackageName, origClassName);
+        ShareIntentUtil.fixIntentClassLoader(intent, mContext.getClassLoader());
+        intent.putExtra(EnvConsts.INTENT_EXTRA_OLD_COMPONENT, origComponentName);
+        final ComponentName stubComponentName = new ComponentName(origPackageName, stubClassName);
+        intent.setComponent(stubComponentName);
+    }
+
+    private boolean hasTransparentTheme(ActivityInfo activityInfo) {
+        final int theme = activityInfo.getThemeResource();
+        final Resources.Theme themeObj = mContext.getResources().newTheme();
+        themeObj.applyStyle(theme, true);
+        TypedArray ta = null;
+        try {
+            ta = themeObj.obtainStyledAttributes(TRANSLUCENT_ATTR_ID);
+            return ta.getBoolean(0, false);
+        } catch (Throwable thr) {
+            return false;
+        } finally {
+            if (ta != null) {
+                ta.recycle();
+            }
+        }
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/handler/MHMessageHandler.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/handler/MHMessageHandler.java
new file mode 100644
index 00000000..3959b408
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/handler/MHMessageHandler.java
@@ -0,0 +1,152 @@
+package com.tencent.tinker.loader.hotplug.handler;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.ContextWrapper;
+import android.content.Intent;
+import android.content.pm.ActivityInfo;
+import android.os.IBinder;
+import android.os.Message;
+import android.util.Log;
+
+import com.tencent.tinker.loader.hotplug.EnvConsts;
+import com.tencent.tinker.loader.hotplug.IncrementComponentManager;
+import com.tencent.tinker.loader.shareutil.ShareIntentUtil;
+import com.tencent.tinker.loader.shareutil.ShareReflectUtil;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+
+import static com.tencent.tinker.loader.hotplug.interceptor.HandlerMessageInterceptor.MessageHandler;
+
+/**
+ * Created by tangyinsheng on 2017/7/31.
+ */
+
+public class MHMessageHandler implements MessageHandler {
+    private static final String TAG = "Tinker.MHMsgHndlr";
+
+    private static final int LAUNCH_ACTIVITY;
+
+    static {
+        int launchActivity = 0;
+        try {
+            final Class<?> hClazz = Class.forName("android.app.ActivityThread$H");
+            launchActivity = ShareReflectUtil.findField(hClazz, "LAUNCH_ACTIVITY").getInt(null);
+        } catch (Throwable thr) {
+            // Fallback to default value.
+            launchActivity = 100;
+        }
+        LAUNCH_ACTIVITY = launchActivity;
+    }
+
+    private final Context mContext;
+
+    public MHMessageHandler(Context context) {
+        while (context instanceof ContextWrapper) {
+            final Context baseCtx = ((ContextWrapper) context).getBaseContext();
+            if (baseCtx == null) {
+                break;
+            }
+            context = baseCtx;
+        }
+        mContext = context;
+    }
+
+    @Override
+    public boolean handleMessage(Message msg) {
+        int what = msg.what;
+        if (what == LAUNCH_ACTIVITY) {
+            try {
+                final Object activityClientRecord = msg.obj;
+                if (activityClientRecord == null) {
+                    Log.w(TAG, "msg: [" + msg.what + "] has no 'obj' value.");
+                    return false;
+                }
+                final Field intentField = ShareReflectUtil.findField(activityClientRecord, "intent");
+                final Intent maybeHackedIntent = (Intent) intentField.get(activityClientRecord);
+                if (maybeHackedIntent == null) {
+                    Log.w(TAG, "cannot fetch intent from message received by mH.");
+                    return false;
+                }
+
+                ShareIntentUtil.fixIntentClassLoader(maybeHackedIntent, mContext.getClassLoader());
+
+                final ComponentName oldComponent = maybeHackedIntent.getParcelableExtra(EnvConsts.INTENT_EXTRA_OLD_COMPONENT);
+                if (oldComponent == null) {
+                    Log.w(TAG, "oldComponent was null, start " + maybeHackedIntent.getComponent() + " next.");
+                    return false;
+                }
+                final Field activityInfoField = ShareReflectUtil.findField(activityClientRecord, "activityInfo");
+                final ActivityInfo aInfo = (ActivityInfo) activityInfoField.get(activityClientRecord);
+                if (aInfo == null) {
+                    return false;
+                }
+                final ActivityInfo targetAInfo = IncrementComponentManager.queryActivityInfo(oldComponent.getClassName());
+                if (targetAInfo == null) {
+                    Log.e(TAG, "Failed to query target activity's info,"
+                            + " perhaps the target is not hotpluged component. Target: " + oldComponent.getClassName());
+                    return false;
+                }
+                fixActivityScreenOrientation(activityClientRecord, targetAInfo.screenOrientation);
+                fixStubActivityInfo(aInfo, targetAInfo);
+                maybeHackedIntent.setComponent(oldComponent);
+                maybeHackedIntent.removeExtra(EnvConsts.INTENT_EXTRA_OLD_COMPONENT);
+            } catch (Throwable thr) {
+                Log.e(TAG, "exception in handleMessage.", thr);
+            }
+        }
+
+        return false;
+    }
+
+    private void fixStubActivityInfo(ActivityInfo stubAInfo, ActivityInfo targetAInfo) {
+        copyInstanceFields(targetAInfo, stubAInfo);
+    }
+
+    private <T> void copyInstanceFields(T srcObj, T destObj) {
+        if (srcObj == null || destObj == null) {
+            return;
+        }
+        Class<?> infoClazz = srcObj.getClass();
+        while (!infoClazz.equals(Object.class)) {
+            final Field[] fields = infoClazz.getDeclaredFields();
+            for (Field field : fields) {
+                if (field.isSynthetic()) {
+                    continue;
+                }
+                final int modifiers = field.getModifiers();
+                if (Modifier.isStatic(modifiers)) {
+                    continue;
+                }
+                if (!field.isAccessible()) {
+                    field.setAccessible(true);
+                }
+                try {
+                    field.set(destObj, field.get(srcObj));
+                } catch (Throwable ignored) {
+                    // Ignored.
+                }
+            }
+            infoClazz = infoClazz.getSuperclass();
+        }
+    }
+
+    private void fixActivityScreenOrientation(Object activityClientRecord, int screenOrientation) {
+        if (screenOrientation == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
+            screenOrientation = ActivityInfo.SCREEN_ORIENTATION_USER;
+        }
+        try {
+            final Field tokenField = ShareReflectUtil.findField(activityClientRecord, "token");
+            final Object token = tokenField.get(activityClientRecord);
+            final Class<?> activityManagerNativeClazz = Class.forName("android.app.ActivityManagerNative");
+            final Method getDefaultMethod = ShareReflectUtil.findMethod(activityManagerNativeClazz, "getDefault");
+            final Object amn = getDefaultMethod.invoke(null);
+            final Method setRequestedOrientationMethod = ShareReflectUtil.findMethod(amn, "setRequestedOrientation", IBinder.class, int.class);
+            setRequestedOrientationMethod.invoke(amn, token, screenOrientation);
+        } catch (Throwable thr) {
+            Log.e(TAG, "Failed to fix screen orientation.", thr);
+        }
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/handler/PMSInterceptHandler.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/handler/PMSInterceptHandler.java
new file mode 100644
index 00000000..e163780d
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/handler/PMSInterceptHandler.java
@@ -0,0 +1,110 @@
+package com.tencent.tinker.loader.hotplug.handler;
+
+import android.content.ComponentName;
+import android.content.Intent;
+import android.util.Log;
+
+import com.tencent.tinker.loader.hotplug.IncrementComponentManager;
+import com.tencent.tinker.loader.hotplug.interceptor.ServiceBinderInterceptor;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+/**
+ * Created by tangyinsheng on 2017/7/31.
+ */
+
+public class PMSInterceptHandler implements ServiceBinderInterceptor.BinderInvocationHandler {
+    private static final String TAG = "Tinker.PMSIntrcptHndlr";
+
+    @Override
+    public Object invoke(Object target, Method method, Object[] args) throws Throwable {
+        final String methodName = method.getName();
+        if ("getActivityInfo".equals(methodName)) {
+            return handleGetActivityInfo(target, method, args);
+        } else if ("resolveIntent".equals(methodName)) {
+            return handleResolveIntent(target, method, args);
+        } else {
+            return method.invoke(target, args);
+        }
+    }
+
+    private Object handleGetActivityInfo(Object target, Method method, Object[] args) throws Throwable {
+        final Class<?>[] methodExceptionTypes = method.getExceptionTypes();
+        try {
+            final Object res = method.invoke(target, args);
+            if (res != null) {
+                return res;
+            } else {
+                ComponentName componentName = null;
+                int compNameIdx = 0;
+                while (compNameIdx < args.length) {
+                    if (args[compNameIdx] instanceof ComponentName) {
+                        Log.i(TAG, "locate componentName field of " + method.getName() + " done at idx: " + compNameIdx);
+                        componentName = (ComponentName) args[compNameIdx];
+                        break;
+                    }
+                    ++compNameIdx;
+                }
+                if (componentName != null) {
+                    return IncrementComponentManager.queryActivityInfo(componentName.getClassName());
+                } else {
+                    Log.w(TAG, "failed to locate componentName field of " + method.getName()
+                            + ", notice any crashes or mistakes after resolve works.");
+                    return null;
+                }
+            }
+        } catch (InvocationTargetException e) {
+            final Throwable targetThr = e.getTargetException();
+            if (methodExceptionTypes != null && methodExceptionTypes.length > 0) {
+                throw (targetThr != null ? targetThr : e);
+            } else {
+                Log.e(TAG, "unexpected exception.", (targetThr != null ? targetThr : e));
+                return null;
+            }
+        } catch (Throwable thr) {
+            Log.e(TAG, "unexpected exception.", thr);
+            return null;
+        }
+    }
+
+    private Object handleResolveIntent(Object target, Method method, Object[] args) throws Throwable {
+        final Class<?>[] methodExceptionTypes = method.getExceptionTypes();
+        try {
+            final Object res = method.invoke(target, args);
+            if (res != null) {
+                return res;
+            } else {
+                Log.w(TAG, "failed to resolve activity in base package, try again in patch package.");
+                Intent intent = null;
+                int intentIdx = 0;
+                while (intentIdx < args.length) {
+                    if (args[intentIdx] instanceof Intent) {
+                        Log.i(TAG, "locate intent field of " + method.getName() + " done at idx: " + intentIdx);
+                        intent = (Intent) args[intentIdx];
+                        break;
+                    }
+                    ++intentIdx;
+                }
+                if (intent != null) {
+                    return IncrementComponentManager.resolveIntent(intent);
+                } else {
+                    Log.w(TAG, "failed to locate intent field of " + method.getName()
+                            + ", notice any crashes or mistakes after resolve works.");
+                    return null;
+                }
+            }
+        } catch (InvocationTargetException e) {
+            final Throwable targetThr = e.getTargetException();
+            if (methodExceptionTypes != null && methodExceptionTypes.length > 0) {
+                throw (targetThr != null ? targetThr : e);
+            } else {
+                Log.e(TAG, "unexpected exception.", (targetThr != null ? targetThr : e));
+                return null;
+            }
+        } catch (Throwable thr) {
+            Log.e(TAG, "unexpected exception.", thr);
+            return null;
+        }
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/interceptor/HandlerMessageInterceptor.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/interceptor/HandlerMessageInterceptor.java
new file mode 100644
index 00000000..2cbc7238
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/interceptor/HandlerMessageInterceptor.java
@@ -0,0 +1,94 @@
+package com.tencent.tinker.loader.hotplug.interceptor;
+
+import android.os.Handler;
+import android.os.Message;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.tencent.tinker.loader.shareutil.ShareReflectUtil;
+
+import java.lang.reflect.Field;
+
+/**
+ * Created by tangyinsheng on 2017/7/31.
+ */
+
+public class HandlerMessageInterceptor extends Interceptor<Handler.Callback> {
+    private final Handler mTarget;
+    private final MessageHandler mMessageHandler;
+
+    private static Field sMCallbackField = null;
+
+    static {
+        synchronized (HandlerMessageInterceptor.class) {
+            if (sMCallbackField == null) {
+                try {
+                    sMCallbackField = ShareReflectUtil.findField(Handler.class, "mCallback");
+                } catch (Throwable ignored) {
+                    // ignored.
+                }
+            }
+        }
+    }
+
+    public HandlerMessageInterceptor(Handler target, MessageHandler messageHandler) {
+        mTarget = target;
+        mMessageHandler = messageHandler;
+    }
+
+    @Nullable
+    @Override
+    protected Handler.Callback fetchTarget() throws Throwable {
+        return (Handler.Callback) sMCallbackField.get(mTarget);
+    }
+
+    @NonNull
+    @Override
+    protected Handler.Callback decorate(@Nullable final Handler.Callback callback) throws Throwable {
+        if (callback != null && ITinkerHotplugProxy.class.isAssignableFrom(callback.getClass())) {
+            // Already intercepted, just return the target.
+            return callback;
+        } else {
+            return new CallbackWrapper(mMessageHandler, callback);
+        }
+    }
+
+    @Override
+    protected void inject(@Nullable Handler.Callback decorated) throws Throwable {
+        sMCallbackField.set(mTarget, decorated);
+    }
+
+    public interface MessageHandler {
+        boolean handleMessage(Message msg);
+    }
+
+    private static class CallbackWrapper implements Handler.Callback, ITinkerHotplugProxy {
+        private final MessageHandler   mMessageHandler;
+        private final Handler.Callback mOrigCallback;
+        private volatile boolean mIsInHandleMethod;
+
+        CallbackWrapper(MessageHandler messageHandler, Handler.Callback origCallback) {
+            mMessageHandler = messageHandler;
+            mOrigCallback = origCallback;
+            mIsInHandleMethod = false;
+        }
+
+        @Override
+        public boolean handleMessage(Message message) {
+            boolean result = false;
+            if (mIsInHandleMethod) {
+                // Reentered, this may happen if origCallback calls back to us which forms a loop.
+                return result;
+            } else {
+                mIsInHandleMethod = true;
+            }
+            if (mMessageHandler.handleMessage(message)) {
+                result = true;
+            } else if (mOrigCallback != null) {
+                result = mOrigCallback.handleMessage(message);
+            }
+            mIsInHandleMethod = false;
+            return result;
+        }
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/interceptor/InterceptFailedException.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/interceptor/InterceptFailedException.java
new file mode 100644
index 00000000..2814f2e7
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/interceptor/InterceptFailedException.java
@@ -0,0 +1,12 @@
+package com.tencent.tinker.loader.hotplug.interceptor;
+
+/**
+ * Created by tangyinsheng on 2017/7/31.
+ */
+
+public class InterceptFailedException extends Exception {
+
+    public InterceptFailedException(Throwable thr) {
+        super(thr);
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/interceptor/Interceptor.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/interceptor/Interceptor.java
new file mode 100644
index 00000000..94e67e8d
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/interceptor/Interceptor.java
@@ -0,0 +1,57 @@
+package com.tencent.tinker.loader.hotplug.interceptor;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.Log;
+
+/**
+ * Created by tangyinsheng on 2017/7/31.
+ */
+
+public abstract class Interceptor<T_TARGET> {
+    private static final String TAG = "Tinker.Interceptor";
+
+    private T_TARGET mTarget = null;
+    private volatile boolean mInstalled = false;
+
+    protected @Nullable abstract T_TARGET fetchTarget() throws Throwable;
+
+    protected @NonNull T_TARGET decorate(@Nullable T_TARGET target) throws Throwable {
+        return target;
+    }
+
+    protected abstract void inject(@Nullable T_TARGET decorated) throws Throwable;
+
+    public synchronized void install() throws InterceptFailedException {
+        try {
+            final T_TARGET target = fetchTarget();
+            mTarget = target;
+            final T_TARGET decorated = decorate(target);
+            if (decorated != target) {
+                inject(decorated);
+            } else {
+                Log.w(TAG, "target: " + target + " was already hooked.");
+            }
+            mInstalled = true;
+        } catch (Throwable thr) {
+            mTarget = null;
+            throw new InterceptFailedException(thr);
+        }
+    }
+
+    public synchronized void uninstall() throws InterceptFailedException {
+        if (mInstalled) {
+            try {
+                inject(mTarget);
+                mTarget = null;
+                mInstalled = false;
+            } catch (Throwable thr) {
+                throw new InterceptFailedException(thr);
+            }
+        }
+    }
+
+    protected interface ITinkerHotplugProxy {
+        // Marker interface for proxy objects created by tinker.
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/interceptor/ServiceBinderInterceptor.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/interceptor/ServiceBinderInterceptor.java
new file mode 100644
index 00000000..25212bf6
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/hotplug/interceptor/ServiceBinderInterceptor.java
@@ -0,0 +1,258 @@
+package com.tencent.tinker.loader.hotplug.interceptor;
+
+import android.content.Context;
+import android.content.ContextWrapper;
+import android.content.pm.PackageManager;
+import android.os.IBinder;
+import android.os.IInterface;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.Log;
+
+import com.tencent.tinker.loader.hotplug.EnvConsts;
+import com.tencent.tinker.loader.shareutil.ShareReflectUtil;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.Method;
+import java.lang.reflect.Proxy;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * Created by tangyinsheng on 2017/7/31.
+ */
+
+public class ServiceBinderInterceptor extends Interceptor<IBinder> {
+    private static final String TAG = "Tinker.SvcBndrIntrcptr";
+
+    private final Context mBaseContext;
+    private final String mServiceName;
+    private final BinderInvocationHandler mBinderInvocationHandler;
+
+    private static Class<?> sServiceManagerClazz = null;
+    private static Field sSCacheField = null;
+    private static Method sGetServiceMethod = null;
+
+    static {
+        synchronized (ServiceBinderInterceptor.class) {
+            if (sServiceManagerClazz == null) {
+                try {
+                    sServiceManagerClazz = Class.forName("android.os.ServiceManager");
+                    sSCacheField = ShareReflectUtil.findField(sServiceManagerClazz, "sCache");
+                    sGetServiceMethod = ShareReflectUtil.findMethod(sServiceManagerClazz, "getService", String.class);
+                } catch (Throwable thr) {
+                    Log.e(TAG, "unexpected exception.", thr);
+                }
+            }
+        }
+    }
+
+    public ServiceBinderInterceptor(Context context, String serviceName, BinderInvocationHandler binderInvocationHandler) {
+        while (context != null && context instanceof ContextWrapper) {
+            context = ((ContextWrapper) context).getBaseContext();
+        }
+        mBaseContext = context;
+        mServiceName = serviceName;
+        mBinderInvocationHandler = binderInvocationHandler;
+    }
+
+    @Nullable
+    @Override
+    protected IBinder fetchTarget() throws Throwable {
+        return (IBinder) sGetServiceMethod.invoke(null, mServiceName);
+    }
+
+    @NonNull
+    @Override
+    protected IBinder decorate(@Nullable IBinder target) throws Throwable {
+        if (target == null) {
+            throw new IllegalStateException("target is null.");
+        }
+        if (ITinkerHotplugProxy.class.isAssignableFrom(target.getClass())) {
+            // Already intercepted, just return the target.
+            return target;
+        } else {
+            return createProxy(getAllInterfacesThroughDeriveChain(target.getClass()),
+                    new FakeClientBinderHandler(target, mBinderInvocationHandler));
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    protected void inject(@Nullable IBinder decorated) throws Throwable {
+        final Map<String, IBinder> sCache = (Map<String, IBinder>) sSCacheField.get(null);
+        sCache.put(mServiceName, decorated);
+        if (Context.ACTIVITY_SERVICE.equals(mServiceName)) {
+            fixAMSBinderCache(decorated);
+        } else if (EnvConsts.PACKAGE_MANAGER_SRVNAME.equals(mServiceName)) {
+            fixPMSBinderCache(mBaseContext, decorated);
+        }
+    }
+
+    private static void fixAMSBinderCache(IBinder fakeBinder) throws Throwable {
+        Object singletonObj = null;
+        try {
+            final Class<?> amsNativeClazz = Class.forName("android.app.ActivityManagerNative");
+            final Field gDefaultField = ShareReflectUtil.findField(amsNativeClazz, "gDefault");
+            singletonObj = gDefaultField.get(null);
+        } catch (Throwable thr) {
+            final Class<?> amClazz = Class.forName("android.app.ActivityManager");
+            final Field iActivityManagerSingletonField = ShareReflectUtil.findField(amClazz, "IActivityManagerSingleton");
+            singletonObj = iActivityManagerSingletonField.get(null);
+        }
+
+        final Field mInstanceField = ShareReflectUtil.findField(singletonObj, "mInstance");
+        final IInterface originalInterface = (IInterface) mInstanceField.get(singletonObj);
+
+        if (originalInterface == null || ITinkerHotplugProxy.class.isAssignableFrom(originalInterface.getClass())) {
+            return;
+        }
+
+        final IInterface fakeInterface = fakeBinder.queryLocalInterface(fakeBinder.getInterfaceDescriptor());
+        if (fakeInterface == null || !ITinkerHotplugProxy.class.isAssignableFrom(fakeInterface.getClass())) {
+            throw new IllegalStateException("fakeBinder does not return fakeInterface, binder: " + fakeBinder + ", itf: " + fakeInterface);
+        }
+        mInstanceField.set(singletonObj, fakeInterface);
+    }
+
+    private static void fixPMSBinderCache(Context context, IBinder fakeBinder) throws Throwable {
+        final Class<?> activityThreadClazz = Class.forName("android.app.ActivityThread");
+        final Field sPackageManagerField = ShareReflectUtil.findField(activityThreadClazz, "sPackageManager");
+        final IInterface originalInterface = (IInterface) sPackageManagerField.get(null);
+        if (originalInterface != null && !ITinkerHotplugProxy.class.isAssignableFrom(originalInterface.getClass())) {
+            final IInterface fakeInterface = fakeBinder.queryLocalInterface(fakeBinder.getInterfaceDescriptor());
+            if (fakeInterface == null || !ITinkerHotplugProxy.class.isAssignableFrom(fakeInterface.getClass())) {
+                throw new IllegalStateException("fakeBinder does not return fakeInterface, binder: " + fakeBinder + ", itf: " + fakeInterface);
+            }
+            sPackageManagerField.set(null, fakeInterface);
+        }
+
+        final Class<?> applicationPackageManagerClazz = Class.forName("android.app.ApplicationPackageManager");
+        final Field mPMField = ShareReflectUtil.findField(applicationPackageManagerClazz, "mPM");
+        final PackageManager pm = context.getPackageManager();
+        final IInterface originalInterface2 = (IInterface) mPMField.get(pm);
+        if (originalInterface2 != null && !ITinkerHotplugProxy.class.isAssignableFrom(originalInterface2.getClass())) {
+            final IInterface fakeInterface = fakeBinder.queryLocalInterface(fakeBinder.getInterfaceDescriptor());
+            if (fakeInterface == null || !ITinkerHotplugProxy.class.isAssignableFrom(fakeInterface.getClass())) {
+                throw new IllegalStateException("fakeBinder does not return fakeInterface, binder: " + fakeBinder + ", itf: " + fakeInterface);
+            }
+            mPMField.set(pm, fakeInterface);
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    private static <T> T createProxy(Class<?>[] itfs, InvocationHandler handler) {
+        final Class<?>[] mergedItfs = new Class<?>[itfs.length + 1];
+        System.arraycopy(itfs, 0, mergedItfs, 0, itfs.length);
+        mergedItfs[itfs.length] = ITinkerHotplugProxy.class;
+        ClassLoader cl = null;
+        try {
+            cl = Thread.currentThread().getContextClassLoader();
+            return (T) Proxy.newProxyInstance(cl, mergedItfs, handler);
+        } catch (Throwable thr) {
+            final Set<ClassLoader> uniqueCls = new HashSet<>(4);
+            for (Class<?> itf : mergedItfs) {
+                uniqueCls.add(itf.getClassLoader());
+            }
+            if (uniqueCls.size() == 1) {
+                cl = uniqueCls.iterator().next();
+            } else {
+                cl = new ClassLoader() {
+                    @Override
+                    protected Class<?> loadClass(String className, boolean resolve)
+                            throws ClassNotFoundException {
+                        for (ClassLoader cl : uniqueCls) {
+                            final Class<?> res = cl.loadClass(className);
+                            if (res != null) {
+                                return res;
+                            }
+                        }
+                        throw new ClassNotFoundException("cannot find class: " + className);
+                    }
+                };
+            }
+            try {
+                return (T) Proxy.newProxyInstance(cl, mergedItfs, handler);
+            } catch (Throwable thr2) {
+                throw new RuntimeException("cl: " + cl, thr);
+            }
+        }
+    }
+
+    private static Class<?>[] getAllInterfacesThroughDeriveChain(Class<?> clazz) {
+        if (clazz == null) {
+            return null;
+        }
+        final Set<Class<?>> itfs = new HashSet<>(10);
+        while (!Object.class.equals(clazz)) {
+            itfs.addAll(Arrays.asList(clazz.getInterfaces()));
+            clazz = clazz.getSuperclass();
+        }
+        return itfs.toArray(new Class<?>[itfs.size()]);
+    }
+
+    public interface BinderInvocationHandler {
+        Object invoke(Object target, Method method, Object[] args) throws Throwable;
+    }
+
+    private static class FakeClientBinderHandler implements InvocationHandler {
+        private final BinderInvocationHandler mBinderInvocationHandler;
+        private final IBinder mOriginalClientBinder;
+
+        FakeClientBinderHandler(IBinder originalClientBinder, BinderInvocationHandler binderInvocationHandler) {
+            mOriginalClientBinder = originalClientBinder;
+            mBinderInvocationHandler = binderInvocationHandler;
+        }
+
+        @Override
+        public Object invoke(Object fakeClientBinder, Method method, Object[] args) throws Throwable {
+            if ("queryLocalInterface".equals(method.getName())) {
+                final String itfName = mOriginalClientBinder.getInterfaceDescriptor();
+                String stubClassName = null;
+                if (itfName.equals("android.app.IActivityManager")) {
+                    stubClassName = "android.app.ActivityManagerNative";
+                } else {
+                    stubClassName = itfName + "$Stub";
+                }
+                final Class<?> stubClazz = Class.forName(stubClassName);
+                final Method asInterfaceMethod
+                        = ShareReflectUtil.findMethod(stubClazz, "asInterface", IBinder.class);
+
+                final IInterface originalInterface
+                        = (IInterface) asInterfaceMethod.invoke(null, mOriginalClientBinder);
+
+                final InvocationHandler fakeInterfaceHandler
+                        = new FakeInterfaceHandler(originalInterface, (IBinder) fakeClientBinder, mBinderInvocationHandler);
+
+                return createProxy(getAllInterfacesThroughDeriveChain(originalInterface.getClass()), fakeInterfaceHandler);
+            } else {
+                return method.invoke(mOriginalClientBinder, args);
+            }
+        }
+    }
+
+    private static class FakeInterfaceHandler implements InvocationHandler {
+        private final BinderInvocationHandler mBinderInvocationHandler;
+        private final IBinder mOriginalClientBinder;
+        private final IInterface mOriginalInterface;
+
+        FakeInterfaceHandler(IInterface originalInterface, IBinder originalClientBinder,
+                             BinderInvocationHandler binderInvocationHandler) {
+            mOriginalInterface = originalInterface;
+            mOriginalClientBinder = originalClientBinder;
+            mBinderInvocationHandler = binderInvocationHandler;
+        }
+
+        @Override
+        public Object invoke(Object fakeIInterface, Method method, Object[] args) throws Throwable {
+            if ("asBinder".equals(method.getName())) {
+                return mOriginalClientBinder;
+            } else {
+                return mBinderInvocationHandler.invoke(mOriginalInterface, method, args);
+            }
+        }
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
index 9d485d78..a7d2b324 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
@@ -16,11 +16,15 @@
 
 package com.tencent.tinker.loader.shareutil;
 
+import com.tencent.tinker.loader.BuildConfig;
+
+import java.util.regex.Pattern;
+
 /**
  * Created by zhangshaowen on 16/3/24.
  */
 public class ShareConstants {
-    public static final String TINKER_VERSION = "1.7.7";
+    public static final String TINKER_VERSION = BuildConfig.TINKER_VERSION;
 
     public static final int BUFFER_SIZE         = 16384;
     public static final int MD5_LENGTH          = 32;
@@ -42,14 +46,31 @@
     public static final String SO_PATH      = "lib";
 
 
-    public static final String DEX_META_FILE     = "assets/dex_meta.txt";
-    public static final String DEX_PATH          = "dex";
-    public static final String DEX_OPTIMIZE_PATH = "odex";
-    public static final String DEX_SUFFIX        = ".dex";
-    public static final String JAR_SUFFIX        = ".jar";
+    public static final String DEX_META_FILE               = "assets/dex_meta.txt";
+    public static final String DEX_PATH                    = "dex";
+    public static final String DEFAULT_DEX_OPTIMIZE_PATH   = "odex";
+    public static final String ANDROID_O_DEX_OPTIMIZE_PATH = "oat";
+
+    public static final String INTERPRET_DEX_OPTIMIZE_PATH = "interpet";
+    public static final String CHANING_DEX_OPTIMIZE_PATH   = "changing";
+
+    public static final Pattern CLASS_N_PATTERN = Pattern.compile("classes(?:[2-9]{0,1}|[1-9][0-9]+)\\.dex(\\.jar)?");
+
+
+    public static final String DEX_SUFFIX  = ".dex";
+    public static final String JAR_SUFFIX  = ".jar";
+    public static final String ODEX_SUFFIX = ".odex";
+
+    public static final String TEST_DEX_NAME            = "test.dex";
+    public static final String CHANGED_CLASSES_DEX_NAME = "changed_classes.dex";
+    public static final String CLASS_N_APK_NAME         = "tinker_classN.apk";
 
     public static final String CHECK_DEX_INSTALL_FAIL = "checkDexInstall failed";
     public static final String CHECK_RES_INSTALL_FAIL = "checkResInstall failed";
+
+    public static final String CHECK_DEX_OAT_EXIST_FAIL  = "checkDexOptExist failed";
+    public static final String CHECK_DEX_OAT_FORMAT_FAIL = "checkDexOptFormat failed";
+
 //    public static final String CHECK_VM_PROPERTY_FAIL = "checkVmArtProperty failed";
 
 
@@ -64,6 +85,8 @@
     public static final String RES_LARGE_MOD_TITLE = "large modify:";
     public static final String RES_DEL_TITLE       = "delete:";
     public static final String RES_PATTERN_TITLE   = "pattern:";
+    public static final String RES_STORE_TITLE     = "store:";
+
 
     public static final String DEXMODE_RAW = "raw";
     public static final String DEXMODE_JAR = "jar";
@@ -104,9 +127,10 @@
     public static final int TYPE_PATCH_INFO = 2;
     public static final int TYPE_DEX        = 3;
 
-    public static final int TYPE_DEX_OPT  = 4;
-    public static final int TYPE_LIBRARY  = 5;
-    public static final int TYPE_RESOURCE = 6;
+    public static final int TYPE_DEX_OPT     = 4;
+    public static final int TYPE_LIBRARY     = 5;
+    public static final int TYPE_RESOURCE    = 6;
+    public static final int TYPE_CLASS_N_DEX = 7;
 
 
     public static final int TINKER_DISABLE             = 0x00;
@@ -117,33 +141,34 @@
     public static final int TINKER_ENABLE_ALL          = TINKER_DEX_MASK | TINKER_NATIVE_LIBRARY_MASK | TINKER_RESOURCE_MASK;
 
     //load error code
-    public static final int ERROR_LOAD_OK                                       = 0;
-    public static final int ERROR_LOAD_DISABLE                                  = -1;
-    public static final int ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST                = -2;
-    public static final int ERROR_LOAD_PATCH_INFO_NOT_EXIST                     = -3;
-    public static final int ERROR_LOAD_PATCH_INFO_CORRUPTED                     = -4;
-    public static final int ERROR_LOAD_PATCH_INFO_BLANK                         = -5;
-    public static final int ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST        = -6;
-    public static final int ERROR_LOAD_PATCH_VERSION_FILE_NOT_EXIST             = -7;
-    public static final int ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL                 = -8;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_DIRECTORY_NOT_EXIST    = -9;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_FILE_NOT_EXIST         = -10;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_OPT_FILE_NOT_EXIST     = -11;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_CLASSLOADER_NULL       = -12;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_MD5_MISMATCH           = -13;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_LOAD_EXCEPTION         = -14;
-    public static final int ERROR_LOAD_PATCH_VERSION_PARALLEL_DEX_OPT_EXCEPTION = -15;
-
-    public static final int ERROR_LOAD_PATCH_VERSION_LIB_DIRECTORY_NOT_EXIST      = -16;
-    public static final int ERROR_LOAD_PATCH_VERSION_LIB_FILE_NOT_EXIST           = -17;
-    public static final int ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL              = -18;
-    public static final int ERROR_LOAD_PATCH_UNKNOWN_EXCEPTION                    = -19;
+    public static final int ERROR_LOAD_OK                                      = 0;
+    public static final int ERROR_LOAD_DISABLE                                 = -1;
+    public static final int ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST               = -2;
+    public static final int ERROR_LOAD_PATCH_INFO_NOT_EXIST                    = -3;
+    public static final int ERROR_LOAD_PATCH_INFO_CORRUPTED                    = -4;
+    public static final int ERROR_LOAD_PATCH_INFO_BLANK                        = -5;
+    public static final int ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST       = -6;
+    public static final int ERROR_LOAD_PATCH_VERSION_FILE_NOT_EXIST            = -7;
+    public static final int ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL                = -8;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_DIRECTORY_NOT_EXIST   = -9;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_FILE_NOT_EXIST        = -10;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_OPT_FILE_NOT_EXIST    = -11;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_CLASSLOADER_NULL      = -12;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_MD5_MISMATCH          = -13;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_LOAD_EXCEPTION        = -14;
+    public static final int ERROR_LOAD_PATCH_GET_OTA_INSTRUCTION_SET_EXCEPTION = -15;
+    public static final int ERROR_LOAD_PATCH_OTA_INTERPRET_ONLY_EXCEPTION      = -16;
+
+    public static final int ERROR_LOAD_PATCH_VERSION_LIB_DIRECTORY_NOT_EXIST      = -17;
+    public static final int ERROR_LOAD_PATCH_VERSION_LIB_FILE_NOT_EXIST           = -18;
+    public static final int ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL              = -19;
+    public static final int ERROR_LOAD_PATCH_UNKNOWN_EXCEPTION                    = -20;
     //resource
-    public static final int ERROR_LOAD_PATCH_VERSION_RESOURCE_DIRECTORY_NOT_EXIST = -20;
-    public static final int ERROR_LOAD_PATCH_VERSION_RESOURCE_FILE_NOT_EXIST      = -21;
-    public static final int ERROR_LOAD_PATCH_VERSION_RESOURCE_LOAD_EXCEPTION      = -22;
-    public static final int ERROR_LOAD_PATCH_VERSION_RESOURCE_MD5_MISMATCH        = -23;
-    public static final int ERROR_LOAD_PATCH_UNCAUGHT_EXCEPTION                   = -24;
+    public static final int ERROR_LOAD_PATCH_VERSION_RESOURCE_DIRECTORY_NOT_EXIST = -21;
+    public static final int ERROR_LOAD_PATCH_VERSION_RESOURCE_FILE_NOT_EXIST      = -22;
+    public static final int ERROR_LOAD_PATCH_VERSION_RESOURCE_LOAD_EXCEPTION      = -23;
+    public static final int ERROR_LOAD_PATCH_VERSION_RESOURCE_MD5_MISMATCH        = -24;
+    public static final int ERROR_LOAD_PATCH_UNCAUGHT_EXCEPTION                   = -25;
 
     public static final int ERROR_LOAD_GET_INTENT_FAIL = -10000;
 
@@ -153,15 +178,18 @@
     public static final int ERROR_LOAD_EXCEPTION_DEX      = -2;
     public static final int ERROR_LOAD_EXCEPTION_RESOURCE = -3;
     public static final int ERROR_LOAD_EXCEPTION_UNCAUGHT = -4;
-    public static final int ERROR_LOAD_EXCEPTION_DEX_OPT  = -5;
-
+    public static final int ERROR_LOAD_EXCEPTION_COMPONENT_HOTPLUG = -5;
 
     //patch listener error code
-    public static final int ERROR_PATCH_OK        = 0;
-    public static final int ERROR_PATCH_DISABLE   = -1;
-    public static final int ERROR_PATCH_NOTEXIST  = -2;
-    public static final int ERROR_PATCH_RUNNING   = -3;
-    public static final int ERROR_PATCH_INSERVICE = -4;
+    public static final int ERROR_PATCH_OK                = 0;
+    public static final int ERROR_PATCH_DISABLE           = -1;
+    public static final int ERROR_PATCH_NOTEXIST          = -2;
+    public static final int ERROR_PATCH_RUNNING           = -3;
+    public static final int ERROR_PATCH_INSERVICE         = -4;
+    public static final int ERROR_PATCH_JIT               = -5;
+    public static final int ERROR_PATCH_ALREADY_APPLY     = -6;
+    public static final int ERROR_PATCH_RETRY_COUNT_LIMIT = -7;
+
 
     //package check error code
     public static final int ERROR_PACKAGE_CHECK_OK                        = 0;
@@ -174,4 +202,11 @@
     public static final int ERROR_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL       = -7;
     public static final int ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED   = -8;
     public static final int ERROR_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT    = -9;
+
+    // interpret error type
+    public static final int TYPE_INTERPRET_OK                        = 0;
+    public static final int TYPE_INTERPRET_GET_INSTRUCTION_SET_ERROR = 1;
+    public static final int TYPE_INTERPRET_COMMAND_ERROR             = 2;
+
+
 }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareDexDiffPatchInfo.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareDexDiffPatchInfo.java
index a623f195..80b1d88f 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareDexDiffPatchInfo.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareDexDiffPatchInfo.java
@@ -28,6 +28,8 @@
     public final String destMd5InDvm;
     public final String destMd5InArt;
     public final String oldDexCrC;
+    public final String newDexCrC;
+
     public final String dexDiffMd5;
 
     public final String path;
@@ -42,7 +44,8 @@
     public final String realName;
 
 
-    public ShareDexDiffPatchInfo(String name, String path, String destMd5InDvm, String destMd5InArt, String dexDiffMd5, String oldDexCrc, String dexMode) {
+    public ShareDexDiffPatchInfo(String name, String path, String destMd5InDvm, String destMd5InArt,
+                                 String dexDiffMd5, String oldDexCrc, String newDexCrC, String dexMode) {
         // TODO Auto-generated constructor stub
         this.rawName = name;
         this.path = path;
@@ -50,6 +53,7 @@ public ShareDexDiffPatchInfo(String name, String path, String destMd5InDvm, Stri
         this.destMd5InArt = destMd5InArt;
         this.dexDiffMd5 = dexDiffMd5;
         this.oldDexCrC = oldDexCrc;
+        this.newDexCrC = newDexCrC;
         this.dexMode = dexMode;
         if (dexMode.equals(ShareConstants.DEXMODE_JAR)) {
             this.isJarMode = true;
@@ -75,8 +79,8 @@ public static void parseDexDiffPatchInfo(String meta, ArrayList<ShareDexDiffPatc
             if (line == null || line.length() <= 0) {
                 continue;
             }
-            final String[] kv = line.split(",", 7);
-            if (kv == null || kv.length < 7) {
+            final String[] kv = line.split(",", 8);
+            if (kv == null || kv.length < 8) {
                 continue;
             }
 
@@ -87,9 +91,12 @@ public static void parseDexDiffPatchInfo(String meta, ArrayList<ShareDexDiffPatc
             final String destMd5InArt = kv[3].trim();
             final String dexDiffMd5 = kv[4].trim();
             final String oldDexCrc = kv[5].trim();
-            final String dexMode = kv[6].trim();
+            final String newDexCrc = kv[6].trim();
+
+            final String dexMode = kv[7].trim();
 
-            ShareDexDiffPatchInfo dexInfo = new ShareDexDiffPatchInfo(name, path, destMd5InDvm, destMd5InArt, dexDiffMd5, oldDexCrc, dexMode);
+            ShareDexDiffPatchInfo dexInfo = new ShareDexDiffPatchInfo(name, path, destMd5InDvm, destMd5InArt,
+                dexDiffMd5, oldDexCrc, newDexCrc, dexMode);
             dexList.add(dexInfo);
         }
 
@@ -120,6 +127,8 @@ public String toString() {
         sb.append(",");
         sb.append(oldDexCrC);
         sb.append(",");
+        sb.append(newDexCrC);
+        sb.append(",");
         sb.append(dexDiffMd5);
         sb.append(",");
         sb.append(dexMode);
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareElfFile.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareElfFile.java
new file mode 100755
index 00000000..54f36ed1
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareElfFile.java
@@ -0,0 +1,385 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.loader.shareutil;
+
+import java.io.Closeable;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.channels.FileChannel;
+import java.nio.charset.Charset;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Created by tangyinsheng on 2017/3/13.
+ */
+
+public class ShareElfFile implements Closeable {
+    public static final int FILE_TYPE_OTHERS = -1;
+    public static final int FILE_TYPE_ODEX = 0;
+    public static final int FILE_TYPE_ELF = 1;
+
+    private final FileInputStream fis;
+    private final Map<String, SectionHeader> sectionNameToHeaderMap = new HashMap<>();
+    public ElfHeader elfHeader = null;
+    public ProgramHeader[] programHeaders = null;
+    public SectionHeader[] sectionHeaders = null;
+
+    public ShareElfFile(File file) throws IOException {
+        fis = new FileInputStream(file);
+        final FileChannel channel = fis.getChannel();
+
+        elfHeader = new ElfHeader(channel);
+
+        final ByteBuffer headerBuffer = ByteBuffer.allocate(128);
+
+        headerBuffer.limit(elfHeader.ePhEntSize);
+        headerBuffer.order(elfHeader.eIndent[ElfHeader.EI_DATA] == ElfHeader.ELFDATA2LSB ? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN);
+        channel.position(elfHeader.ePhOff);
+        programHeaders = new ProgramHeader[elfHeader.ePhNum];
+        for (int i = 0; i < programHeaders.length; ++i) {
+            readUntilLimit(channel, headerBuffer, "failed to read phdr.");
+            programHeaders[i] = new ProgramHeader(headerBuffer, elfHeader.eIndent[ElfHeader.EI_CLASS]);
+        }
+
+        channel.position(elfHeader.eShOff);
+        headerBuffer.limit(elfHeader.eShEntSize);
+        sectionHeaders = new SectionHeader[elfHeader.eShNum];
+        for (int i = 0; i < sectionHeaders.length; ++i) {
+            readUntilLimit(channel, headerBuffer, "failed to read shdr.");
+            sectionHeaders[i] = new SectionHeader(headerBuffer, elfHeader.eIndent[ElfHeader.EI_CLASS]);
+        }
+
+        if (elfHeader.eShStrNdx > 0) {
+            final SectionHeader shStrTabSectionHeader = sectionHeaders[elfHeader.eShStrNdx];
+            final ByteBuffer shStrTab = getSection(shStrTabSectionHeader);
+            for (SectionHeader shdr : sectionHeaders) {
+                shStrTab.position(shdr.shName);
+                shdr.shNameStr = readCString(shStrTab);
+                sectionNameToHeaderMap.put(shdr.shNameStr, shdr);
+            }
+        }
+    }
+
+    private static void assertInRange(int b, int lb, int ub, String errMsg) throws IOException {
+        if (b < lb || b > ub) {
+            throw new IOException(errMsg);
+        }
+    }
+
+    public static int getFileTypeByMagic(File file) throws IOException {
+        InputStream is = null;
+        try {
+            final byte[] magicBuf = new byte[4];
+            is = new FileInputStream(file);
+            is.read(magicBuf);
+            if (magicBuf[0] == 'd' && magicBuf[1] == 'e' && magicBuf[2] == 'y' && magicBuf[3] == '\n') {
+                return FILE_TYPE_ODEX;
+            } else if (magicBuf[0] == 0x7F && magicBuf[1] == 'E' && magicBuf[2] == 'L' && magicBuf[3] == 'F') {
+                return FILE_TYPE_ELF;
+            } else {
+                return FILE_TYPE_OTHERS;
+            }
+        } finally {
+            if (is != null) {
+                try {
+                    is.close();
+                } catch (Throwable thr) {
+                    // Ignored.
+                }
+            }
+        }
+    }
+
+    public static void readUntilLimit(FileChannel channel, ByteBuffer bufferOut, String errMsg) throws IOException {
+        bufferOut.rewind();
+        int bytesRead = channel.read(bufferOut);
+        if (bytesRead != bufferOut.limit()) {
+            throw new IOException(errMsg + " Rest bytes insufficient, expect to read "
+                    + bufferOut.limit() + " bytes but only "
+                    + bytesRead + " bytes were read.");
+        }
+        bufferOut.flip();
+    }
+
+    public static String readCString(ByteBuffer buffer) {
+        final byte[] rawBuffer = buffer.array();
+        int begin = buffer.position();
+        while (buffer.hasRemaining() && rawBuffer[buffer.position()] != 0) {
+            buffer.position(buffer.position() + 1);
+        }
+        // Move to the start of next cstring.
+        buffer.position(buffer.position() + 1);
+        return new String(rawBuffer, begin, buffer.position() - begin - 1, Charset.forName("ASCII"));
+    }
+
+    public FileChannel getChannel() {
+        return fis.getChannel();
+    }
+
+    public boolean is32BitElf() {
+        return (elfHeader.eIndent[ElfHeader.EI_CLASS] == ElfHeader.ELFCLASS32);
+    }
+
+    public ByteOrder getDataOrder() {
+        return (elfHeader.eIndent[ElfHeader.EI_DATA] == ElfHeader.ELFDATA2LSB ? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN);
+    }
+
+    public SectionHeader getSectionHeaderByName(String name) {
+        return sectionNameToHeaderMap.get(name);
+    }
+
+    public ByteBuffer getSection(SectionHeader sectionHeader) throws IOException {
+        final ByteBuffer result = ByteBuffer.allocate((int) sectionHeader.shSize);
+        fis.getChannel().position(sectionHeader.shOffset);
+        readUntilLimit(fis.getChannel(), result, "failed to read section: " + sectionHeader.shNameStr);
+        return result;
+    }
+
+    public ByteBuffer getSegment(ProgramHeader programHeader) throws IOException {
+        final ByteBuffer result = ByteBuffer.allocate((int) programHeader.pFileSize);
+        fis.getChannel().position(programHeader.pOffset);
+        readUntilLimit(fis.getChannel(), result, "failed to read segment (type: " + programHeader.pType + ").");
+        return result;
+    }
+
+    @Override
+    public void close() throws IOException {
+        fis.close();
+        sectionNameToHeaderMap.clear();
+        programHeaders = null;
+        sectionHeaders = null;
+    }
+
+    public static class ElfHeader {
+        // Elf indent field index.
+        public static final int EI_CLASS = 4;
+        public static final int EI_DATA = 5;
+        public static final int EI_VERSION = 6;
+        // Elf classes.
+        public static final int ELFCLASS32 = 1;
+        public static final int ELFCLASS64 = 2;
+        // Elf data encoding.
+        public static final int ELFDATA2LSB = 1;
+        public static final int ELFDATA2MSB = 2;
+        // Elf types.
+        public static final int ET_NONE = 0;
+        public static final int ET_REL = 1;
+        public static final int ET_EXEC = 2;
+        public static final int ET_DYN = 3;
+        public static final int ET_CORE = 4;
+        public static final int ET_LOPROC = 0xff00;
+        public static final int ET_HIPROC = 0xffff;
+        // Elf indent version.
+        public static final int EV_CURRENT = 1;
+        private static final int EI_NINDENT = 16;
+        public final byte[] eIndent = new byte[EI_NINDENT];
+        public final short eType;
+        public final short eMachine;
+        public final int eVersion;
+        public final long eEntry;
+        public final long ePhOff;
+        public final long eShOff;
+        public final int eFlags;
+        public final short eEhSize;
+        public final short ePhEntSize;
+        public final short ePhNum;
+        public final short eShEntSize;
+        public final short eShNum;
+        public final short eShStrNdx;
+
+        private ElfHeader(FileChannel channel) throws IOException {
+            channel.position(0);
+            channel.read(ByteBuffer.wrap(eIndent));
+            if (eIndent[0] != 0x7F || eIndent[1] != 'E' || eIndent[2] != 'L' || eIndent[3] != 'F') {
+                throw new IOException(String.format("bad elf magic: %x %x %x %x.", eIndent[0], eIndent[1], eIndent[2], eIndent[3]));
+            }
+
+            assertInRange(eIndent[EI_CLASS], ELFCLASS32, ELFCLASS64, "bad elf class: " + eIndent[EI_CLASS]);
+            assertInRange(eIndent[EI_DATA], ELFDATA2LSB, ELFDATA2MSB, "bad elf data encoding: " + eIndent[EI_DATA]);
+
+            final ByteBuffer restBuffer = ByteBuffer.allocate(eIndent[EI_CLASS] == ELFCLASS32 ? 36 : 48);
+            restBuffer.order(eIndent[EI_DATA] == ELFDATA2LSB ? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN);
+            readUntilLimit(channel, restBuffer, "failed to read rest part of ehdr.");
+
+            eType = restBuffer.getShort();
+            eMachine = restBuffer.getShort();
+
+            eVersion = restBuffer.getInt();
+            assertInRange(eVersion, EV_CURRENT, EV_CURRENT, "bad elf version: " + eVersion);
+
+            switch (eIndent[EI_CLASS]) {
+                case ELFCLASS32:
+                    eEntry = restBuffer.getInt();
+                    ePhOff = restBuffer.getInt();
+                    eShOff = restBuffer.getInt();
+                    break;
+                case ELFCLASS64:
+                    eEntry = restBuffer.getLong();
+                    ePhOff = restBuffer.getLong();
+                    eShOff = restBuffer.getLong();
+                    break;
+                default:
+                    throw new IOException("Unexpected elf class: " + eIndent[EI_CLASS]);
+            }
+            eFlags = restBuffer.getInt();
+            eEhSize = restBuffer.getShort();
+            ePhEntSize = restBuffer.getShort();
+            ePhNum = restBuffer.getShort();
+            eShEntSize = restBuffer.getShort();
+            eShNum = restBuffer.getShort();
+            eShStrNdx = restBuffer.getShort();
+        }
+    }
+
+    public static class ProgramHeader {
+        // Segment types.
+        public static final int PT_NULL = 0;
+        public static final int PT_LOAD = 1;
+        public static final int PT_DYNAMIC = 2;
+        public static final int PT_INTERP = 3;
+        public static final int PT_NOTE = 4;
+        public static final int PT_SHLIB = 5;
+        public static final int PT_PHDR = 6;
+        public static final int PT_LOPROC = 0x70000000;
+        public static final int PT_HIPROC = 0x7fffffff;
+
+        // Segment flags.
+        public static final int PF_R = 0x04;
+        public static final int PF_W = 0x02;
+        public static final int PF_X = 0x01;
+
+        public final int pType;
+        public final int pFlags;
+        public final long pOffset;
+        public final long pVddr;
+        public final long pPddr;
+        public final long pFileSize;
+        public final long pMemSize;
+        public final long pAlign;
+
+        private ProgramHeader(ByteBuffer buffer, int elfClass) throws IOException {
+            switch (elfClass) {
+                case ElfHeader.ELFCLASS32:
+                    pType = buffer.getInt();
+                    pOffset = buffer.getInt();
+                    pVddr = buffer.getInt();
+                    pPddr = buffer.getInt();
+                    pFileSize = buffer.getInt();
+                    pMemSize = buffer.getInt();
+                    pFlags = buffer.getInt();
+                    pAlign = buffer.getInt();
+                    break;
+                case ElfHeader.ELFCLASS64:
+                    pType = buffer.getInt();
+                    pFlags = buffer.getInt();
+                    pOffset = buffer.getLong();
+                    pVddr = buffer.getLong();
+                    pPddr = buffer.getLong();
+                    pFileSize = buffer.getLong();
+                    pMemSize = buffer.getLong();
+                    pAlign = buffer.getLong();
+                    break;
+                default:
+                    throw new IOException("Unexpected elf class: " + elfClass);
+            }
+        }
+    }
+
+    public static class SectionHeader {
+        // Special section indexes.
+        public static final int SHN_UNDEF = 0;
+        public static final int SHN_LORESERVE = 0xff00;
+        public static final int SHN_LOPROC = 0xff00;
+        public static final int SHN_HIPROC = 0xff1f;
+        public static final int SHN_ABS = 0xfff1;
+        public static final int SHN_COMMON = 0xfff2;
+        public static final int SHN_HIRESERVE = 0xffff;
+
+        // Section types.
+        public static final int SHT_NULL = 0;
+        public static final int SHT_PROGBITS = 1;
+        public static final int SHT_SYMTAB = 2;
+        public static final int SHT_STRTAB = 3;
+        public static final int SHT_RELA = 4;
+        public static final int SHT_HASH = 5;
+        public static final int SHT_DYNAMIC = 6;
+        public static final int SHT_NOTE = 7;
+        public static final int SHT_NOBITS = 8;
+        public static final int SHT_REL = 9;
+        public static final int SHT_SHLIB = 10;
+        public static final int SHT_DYNSYM = 11;
+        public static final int SHT_LOPROC = 0x70000000;
+        public static final int SHT_HIPROC = 0x7fffffff;
+        public static final int SHT_LOUSER = 0x80000000;
+        public static final int SHT_HIUSER = 0xffffffff;
+
+        // Section flags.
+        public static final int SHF_WRITE = 0x1;
+        public static final int SHF_ALLOC = 0x2;
+        public static final int SHF_EXECINSTR = 0x4;
+        public static final int SHF_MASKPROC = 0xf0000000;
+
+        public final int shName;
+        public final int shType;
+        public final long shFlags;
+        public final long shAddr;
+        public final long shOffset;
+        public final long shSize;
+        public final int shLink;
+        public final int shInfo;
+        public final long shAddrAlign;
+        public final long shEntSize;
+        public String shNameStr;
+
+        private SectionHeader(ByteBuffer buffer, int elfClass) throws IOException {
+            switch (elfClass) {
+                case ElfHeader.ELFCLASS32:
+                    shName = buffer.getInt();
+                    shType = buffer.getInt();
+                    shFlags = buffer.getInt();
+                    shAddr = buffer.getInt();
+                    shOffset = buffer.getInt();
+                    shSize = buffer.getInt();
+                    shLink = buffer.getInt();
+                    shInfo = buffer.getInt();
+                    shAddrAlign = buffer.getInt();
+                    shEntSize = buffer.getInt();
+                    break;
+                case ElfHeader.ELFCLASS64:
+                    shName = buffer.getInt();
+                    shType = buffer.getInt();
+                    shFlags = buffer.getLong();
+                    shAddr = buffer.getLong();
+                    shOffset = buffer.getLong();
+                    shSize = buffer.getLong();
+                    shLink = buffer.getInt();
+                    shInfo = buffer.getInt();
+                    shAddrAlign = buffer.getLong();
+                    shEntSize = buffer.getLong();
+                    break;
+                default:
+                    throw new IOException("Unexpected elf class: " + elfClass);
+            }
+            shNameStr = null;
+        }
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareIntentUtil.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareIntentUtil.java
index 7cf48852..5fe80960 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareIntentUtil.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareIntentUtil.java
@@ -17,9 +17,11 @@
 package com.tencent.tinker.loader.shareutil;
 
 import android.content.Intent;
+import android.os.Bundle;
 import android.util.Log;
 
 import java.io.Serializable;
+import java.lang.reflect.Field;
 import java.util.ArrayList;
 import java.util.HashMap;
 
@@ -42,6 +44,9 @@
     public static final  String INTENT_PATCH_PACKAGE_PATCH_CHECK = "intent_patch_package_patch_check";
     public static final  String INTENT_PATCH_PACKAGE_CONFIG      = "intent_patch_package_config";
     public static final  String INTENT_PATCH_SYSTEM_OTA          = "intent_patch_system_ota";
+    public static final  String INTENT_PATCH_OAT_DIR             = "intent_patch_oat_dir";
+    public static final  String INTENT_PATCH_INTERPRET_EXCEPTION = "intent_patch_interpret_exception";
+
 
     private static final String TAG                              = "ShareIntentUtil";
 
@@ -61,10 +66,18 @@ public static long getIntentPatchCostTime(Intent intent) {
         return intent.getLongExtra(INTENT_PATCH_COST_TIME, 0);
     }
 
-    public static Exception getIntentPatchException(Intent intent) {
+    public static Throwable getIntentPatchException(Intent intent) {
         Serializable serializable = getSerializableExtra(intent, INTENT_PATCH_EXCEPTION);
         if (serializable != null) {
-            return (Exception) serializable;
+            return (Throwable) serializable;
+        }
+        return null;
+    }
+
+    public static Throwable getIntentInterpretException(Intent intent) {
+        Serializable serializable = getSerializableExtra(intent, INTENT_PATCH_INTERPRET_EXCEPTION);
+        if (serializable != null) {
+            return (Throwable) serializable;
         }
         return null;
     }
@@ -179,4 +192,19 @@ public static long getLongExtra(Intent intent, String name, long defaultValue) {
         }
         return ret;
     }
+
+    public static void fixIntentClassLoader(Intent intent, ClassLoader cl) {
+        try {
+            final Field mExtrasField = ShareReflectUtil.findField(Intent.class, "mExtras");
+            Bundle extra = (Bundle) mExtrasField.get(intent);
+            if (extra == null) {
+                extra = new Bundle();
+                mExtrasField.set(intent, extra);
+            }
+        } catch (Throwable thr) {
+            thr.printStackTrace();
+        } finally {
+            intent.setExtrasClassLoader(cl);
+        }
+    }
 }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareOatUtil.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareOatUtil.java
new file mode 100755
index 00000000..d77c1af7
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareOatUtil.java
@@ -0,0 +1,151 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.loader.shareutil;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
+import java.nio.charset.Charset;
+
+/**
+ * Created by tangyinsheng on 2017/3/14.
+ */
+
+public final class ShareOatUtil {
+    private static final String TAG = "Tinker.OatUtil";
+
+    private ShareOatUtil() {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Get instruction set used to generate {@code oatFile}.
+     *
+     * @param oatFile
+     *  the oat file.
+     * @return
+     *  the instruction used to generate this oat file, if the oat file does not
+     *  contain this value, an empty string will be returned.
+     *
+     * @throws IOException
+     *  If anything wrong when parsing the elf format or locating target field in oat header.
+     */
+    public static String getOatFileInstructionSet(File oatFile) throws Throwable {
+        ShareElfFile elfFile = null;
+        String result = "";
+        try {
+            elfFile = new ShareElfFile(oatFile);
+            final ShareElfFile.SectionHeader roDataHdr = elfFile.getSectionHeaderByName(".rodata");
+            if (roDataHdr == null) {
+                throw new IOException("Unable to find .rodata section.");
+            }
+
+            final FileChannel channel = elfFile.getChannel();
+            channel.position(roDataHdr.shOffset);
+
+            final byte[] oatMagicAndVersion = new byte[8];
+            ShareElfFile.readUntilLimit(channel, ByteBuffer.wrap(oatMagicAndVersion), "Failed to read oat magic and version.");
+
+            if (oatMagicAndVersion[0] != 'o'
+                    || oatMagicAndVersion[1] != 'a'
+                    || oatMagicAndVersion[2] != 't'
+                    || oatMagicAndVersion[3] != '\n') {
+                throw new IOException(
+                        String.format("Bad oat magic: %x %x %x %x",
+                                oatMagicAndVersion[0],
+                                oatMagicAndVersion[1],
+                                oatMagicAndVersion[2],
+                                oatMagicAndVersion[3])
+                );
+            }
+
+            final int versionOffsetFromOatBegin = 4;
+            final int versionBytes = 3;
+
+            final String oatVersion = new String(oatMagicAndVersion,
+                    versionOffsetFromOatBegin, versionBytes, Charset.forName("ASCII"));
+            try {
+                Integer.parseInt(oatVersion);
+            } catch (NumberFormatException e) {
+                throw new IOException("Bad oat version: " + oatVersion);
+            }
+
+            ByteBuffer buffer = ByteBuffer.allocate(128);
+            buffer.order(elfFile.getDataOrder());
+            // TODO This is a risk point, since each oat version may use a different offset.
+            // So far it's ok. Perhaps we should use oatVersionNum to judge the right offset in
+            // the future.
+            final int isaNumOffsetFromOatBegin = 12;
+            channel.position(roDataHdr.shOffset + isaNumOffsetFromOatBegin);
+            buffer.limit(4);
+            ShareElfFile.readUntilLimit(channel, buffer, "Failed to read isa num.");
+
+            int isaNum = buffer.getInt();
+            if (isaNum < 0 || isaNum >= InstructionSet.values().length) {
+                throw new IOException("Bad isa num: " + isaNum);
+            }
+
+            switch (InstructionSet.values()[isaNum]) {
+                case kArm:
+                case kThumb2:
+                    result = "arm";
+                    break;
+                case kArm64:
+                    result = "arm64";
+                    break;
+                case kX86:
+                    result = "x86";
+                    break;
+                case kX86_64:
+                    result = "x86_64";
+                    break;
+                case kMips:
+                    result = "mips";
+                    break;
+                case kMips64:
+                    result = "mips64";
+                    break;
+                case kNone:
+                    result = "none";
+                    break;
+                default:
+                    throw new IOException("Should not reach here.");
+            }
+        } finally {
+            if (elfFile != null) {
+                try {
+                    elfFile.close();
+                } catch (Exception ignored) {
+                    // Ignored.
+                }
+            }
+        }
+        return result;
+    }
+
+    private enum InstructionSet {
+        kNone,
+        kArm,
+        kArm64,
+        kThumb2,
+        kX86,
+        kX86_64,
+        kMips,
+        kMips64
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java
index 419efd88..c6ecb5e7 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java
@@ -16,10 +16,14 @@
 
 package com.tencent.tinker.loader.shareutil;
 
+import android.annotation.SuppressLint;
 import android.content.Context;
 import android.content.pm.ApplicationInfo;
+import android.os.Build;
 import android.util.Log;
 
+import com.tencent.tinker.loader.TinkerRuntimeException;
+
 import java.io.BufferedInputStream;
 import java.io.BufferedReader;
 import java.io.Closeable;
@@ -39,6 +43,8 @@
 public class SharePatchFileUtil {
     private static final String TAG = "Tinker.PatchFileUtil";
 
+    private static char[] hexDigits = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
+
     /**
      * data dir, such as /data/data/tinker.sample.android/tinker
      * @param context
@@ -128,8 +134,37 @@ public static String checkTinkerLastUncaughtCrash(Context context) {
 
     }
 
+    /**
+     * Closes the given {@code obj}. Suppresses any exceptions.
+     */
+    @SuppressLint("NewApi")
+    public static void closeQuietly(Object obj) {
+        if (obj == null) return;
+        if (obj instanceof Closeable) {
+            try {
+                ((Closeable) obj).close();
+            } catch (Throwable ignored) {
+                // Ignored.
+            }
+        } else if (Build.VERSION.SDK_INT >= 19 && obj instanceof AutoCloseable) {
+            try {
+                ((AutoCloseable) obj).close();
+            } catch (Throwable ignored) {
+                // Ignored.
+            }
+        } else if (obj instanceof ZipFile) {
+            try {
+                ((ZipFile) obj).close();
+            } catch (Throwable ignored) {
+                // Ignored.
+            }
+        } else {
+            throw new IllegalArgumentException("obj: " + obj + " cannot be closed.");
+        }
+    }
+
     public static final boolean isLegalFile(File file) {
-        return file != null && file.exists() && file.isFile() && file.length() > 0;
+        return file != null && file.exists() && file.canRead() && file.isFile() && file.length() > 0;
     }
 
     /**
@@ -164,9 +199,9 @@ public static final boolean safeDeleteFile(File file) {
             return true;
         }
 
-        Log.i(TAG, "safeDeleteFile, try to delete path: " + file.getPath());
-
         if (file.exists()) {
+            Log.i(TAG, "safeDeleteFile, try to delete path: " + file.getPath());
+
             boolean deleted = file.delete();
             if (!deleted) {
                 Log.e(TAG, "Failed to delete file, try to delete when exit. path: " + file.getPath());
@@ -232,7 +267,11 @@ public static boolean isRawDexFile(String fileName) {
      * dex may wrap with jar
      */
     public static boolean verifyDexFileMd5(File file, String md5) {
-        if (file == null || md5 == null) {
+        return verifyDexFileMd5(file, ShareConstants.DEX_IN_JAR, md5);
+    }
+
+    public static boolean verifyDexFileMd5(File file, String entryName, String md5) {
+        if (file == null || md5 == null || entryName == null) {
             return false;
         }
         //if it is not the raw dex, we check the stream instead
@@ -244,26 +283,27 @@ public static boolean verifyDexFileMd5(File file, String md5) {
             ZipFile dexJar = null;
             try {
                 dexJar = new ZipFile(file);
-                ZipEntry classesDex = dexJar.getEntry(ShareConstants.DEX_IN_JAR);
+                ZipEntry classesDex = dexJar.getEntry(entryName);
                 // no code
                 if (null == classesDex) {
                     Log.e(TAG, "There's no entry named: " + ShareConstants.DEX_IN_JAR + " in " + file.getAbsolutePath());
                     return false;
                 }
+                InputStream is = null;
+                try {
+                    is = dexJar.getInputStream(classesDex);
+                    fileMd5 = getMD5(is);
+                } catch (Throwable e) {
+                    Log.e(TAG, "exception occurred when get md5: " + file.getAbsolutePath(), e);
+                } finally {
+                    closeQuietly(is);
+                }
                 fileMd5 = getMD5(dexJar.getInputStream(classesDex));
             } catch (Throwable e) {
                 Log.e(TAG, "Bad dex jar file: " + file.getAbsolutePath(), e);
                 return false;
             } finally {
-                // Bugfix: some device redefined ZipFile, which is not implemented closeable.
-                // SharePatchFileUtil.closeZip(dexJar);
-                if (dexJar != null) {
-                    try {
-                        dexJar.close();
-                    } catch (Throwable thr) {
-                        // Ignored.
-                    }
-                }
+                closeZip(dexJar);
             }
         }
 
@@ -353,6 +393,25 @@ public final static String getMD5(final InputStream is) {
         }
     }
 
+    public static String getMD5(byte[] buffer) {
+        try {
+            MessageDigest mdTemp = MessageDigest.getInstance("MD5");
+            mdTemp.update(buffer);
+            byte[] md = mdTemp.digest();
+            int j = md.length;
+            char[] str = new char[j * 2];
+            int k = 0;
+            for (int i = 0; i < j; i++) {
+                byte byte0 = md[i];
+                str[k++] = hexDigits[byte0 >>> 4 & 0xf];
+                str[k++] = hexDigits[byte0 & 0xf];
+            }
+            return new String(str);
+        } catch (Exception e) {
+            return null;
+        }
+    }
+
     /**
      * Get the md5 for the file. call getMD5(FileInputStream is, int bufLen) inside.
      *
@@ -367,31 +426,46 @@ public static String getMD5(final File file) {
         try {
             fin = new FileInputStream(file);
             String md5 = getMD5(fin);
-            fin.close();
             return md5;
-
         } catch (Exception e) {
             return null;
-
         } finally {
-            try {
-                if (fin != null) {
-                    fin.close();
-                }
-            } catch (IOException e) {
-
-            }
+            closeQuietly(fin);
         }
     }
 
     /**
      * change the jar file path as the makeDexElements do
+     * Android O change its path
      *
      * @param path
      * @param optimizedDirectory
      * @return
      */
     public static String optimizedPathFor(File path, File optimizedDirectory) {
+        if (ShareTinkerInternals.isAfterAndroidO()) {
+            // dex_location = /foo/bar/baz.jar
+            // odex_location = /foo/bar/oat/<isa>/baz.odex
+
+            String currentInstructionSet;
+            try {
+                currentInstructionSet = ShareTinkerInternals.getCurrentInstructionSet();
+            } catch (Exception e) {
+                throw new TinkerRuntimeException("getCurrentInstructionSet fail:", e);
+            }
+
+            File parentFile = path.getParentFile();
+            String fileName = path.getName();
+            int index = fileName.lastIndexOf('.');
+            if (index > 0) {
+                fileName = fileName.substring(0, index);
+            }
+
+            String result = parentFile.getAbsolutePath() + "/oat/"
+                + currentInstructionSet + "/" + fileName + ShareConstants.ODEX_SUFFIX;
+            return result;
+        }
+
         String fileName = path.getName();
         if (!fileName.endsWith(ShareConstants.DEX_SUFFIX)) {
             int lastDot = fileName.lastIndexOf(".");
@@ -409,19 +483,6 @@ public static String optimizedPathFor(File path, File optimizedDirectory) {
         return result.getPath();
     }
 
-    /**
-     * Closes the given {@code Closeable}. Suppresses any IO exceptions.
-     */
-    public static void closeQuietly(Closeable closeable) {
-        try {
-            if (closeable != null) {
-                closeable.close();
-            }
-        } catch (IOException e) {
-            Log.w(TAG, "Failed to close resource", e);
-        }
-    }
-
     public static void closeZip(ZipFile zipFile) {
         try {
             if (zipFile != null) {
@@ -449,7 +510,7 @@ public static boolean checkResourceArscMd5(File resOutput, String destMd5) {
                     return true;
                 }
             } finally {
-                SharePatchFileUtil.closeQuietly(inputStream);
+                closeQuietly(inputStream);
             }
 
         } catch (Throwable e) {
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java
index 71a96450..98a056f4 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java
@@ -31,20 +31,25 @@
  * Created by zhangshaowen on 16/3/16.
  */
 public class SharePatchInfo {
+    private static final String TAG = "Tinker.PatchInfo";
+
     public static final int    MAX_EXTRACT_ATTEMPTS = ShareConstants.MAX_EXTRACT_ATTEMPTS;
     public static final String OLD_VERSION          = ShareConstants.OLD_VERSION;
     public static final String NEW_VERSION          = ShareConstants.NEW_VERSION;
     public static final String FINGER_PRINT         = "print";
-    private static final String TAG = "PatchInfo";
+    public static final String OAT_DIR              = "dir";
+    public static final String DEFAULT_DIR   = ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH;
     public String oldVersion;
     public String newVersion;
     public String fingerPrint;
+    public String oatDir;
 
-    public SharePatchInfo(String oldVer, String newVew, String finger) {
+    public SharePatchInfo(String oldVer, String newVew, String finger, String oatDir) {
         // TODO Auto-generated constructor stub
         this.oldVersion = oldVer;
         this.newVersion = newVew;
         this.fingerPrint = finger;
+        this.oatDir = oatDir;
     }
 
     public static SharePatchInfo readAndCheckPropertyWithLock(File pathInfoFile, File lockFile) {
@@ -69,7 +74,7 @@ public static SharePatchInfo readAndCheckPropertyWithLock(File pathInfoFile, Fil
                     fileLock.close();
                 }
             } catch (IOException e) {
-                Log.i(TAG, "releaseInfoLock error", e);
+                Log.w(TAG, "releaseInfoLock error", e);
             }
         }
 
@@ -110,6 +115,7 @@ private static SharePatchInfo readAndCheckProperty(File pathInfoFile) {
         String oldVer = null;
         String newVer = null;
         String lastFingerPrint = null;
+        String oatDIr = null;
 
         while (numAttempts < MAX_EXTRACT_ATTEMPTS && !isReadPatchSuccessful) {
             numAttempts++;
@@ -121,9 +127,10 @@ private static SharePatchInfo readAndCheckProperty(File pathInfoFile) {
                 oldVer = properties.getProperty(OLD_VERSION);
                 newVer = properties.getProperty(NEW_VERSION);
                 lastFingerPrint = properties.getProperty(FINGER_PRINT);
+                oatDIr = properties.getProperty(OAT_DIR);
             } catch (IOException e) {
 //                e.printStackTrace();
-                Log.e(TAG, "read property failed, e:" + e);
+                Log.w(TAG, "read property failed, e:" + e);
             } finally {
                 SharePatchFileUtil.closeQuietly(inputStream);
             }
@@ -142,7 +149,7 @@ private static SharePatchInfo readAndCheckProperty(File pathInfoFile) {
         }
 
         if (isReadPatchSuccessful) {
-            return new SharePatchInfo(oldVer, newVer, lastFingerPrint);
+            return new SharePatchInfo(oldVer, newVer, lastFingerPrint, oatDIr);
         }
 
         return null;
@@ -152,12 +159,23 @@ private static boolean rewritePatchInfoFile(File pathInfoFile, SharePatchInfo in
         if (pathInfoFile == null || info == null) {
             return false;
         }
+        // write fingerprint if it is null or nil
+        if (ShareTinkerInternals.isNullOrNil(info.fingerPrint)) {
+            info.fingerPrint = Build.FINGERPRINT;
+        }
+        if (ShareTinkerInternals.isNullOrNil(info.oatDir)) {
+            info.oatDir = DEFAULT_DIR;
+        }
         Log.i(TAG, "rewritePatchInfoFile file path:"
             + pathInfoFile.getAbsolutePath()
             + " , oldVer:"
             + info.oldVersion
             + ", newVer:"
-            + info.newVersion);
+            + info.newVersion
+            + ", fingerprint:"
+            + info.fingerPrint
+            + ", oatDir:"
+            + info.oatDir);
 
         boolean isWritePatchSuccessful = false;
         int numAttempts = 0;
@@ -173,7 +191,8 @@ private static boolean rewritePatchInfoFile(File pathInfoFile, SharePatchInfo in
             Properties newProperties = new Properties();
             newProperties.put(OLD_VERSION, info.oldVersion);
             newProperties.put(NEW_VERSION, info.newVersion);
-            newProperties.put(FINGER_PRINT, Build.FINGERPRINT);
+            newProperties.put(FINGER_PRINT, info.fingerPrint);
+            newProperties.put(OAT_DIR, info.oatDir);
 
             FileOutputStream outputStream = null;
             try {
@@ -181,7 +200,8 @@ private static boolean rewritePatchInfoFile(File pathInfoFile, SharePatchInfo in
                 String comment = "from old version:" + info.oldVersion + " to new version:" + info.newVersion;
                 newProperties.store(outputStream, comment);
             } catch (Exception e) {
-                e.printStackTrace();
+//                e.printStackTrace();
+                Log.w(TAG, "write property failed, e:" + e);
             } finally {
                 SharePatchFileUtil.closeQuietly(outputStream);
             }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareReflectUtil.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareReflectUtil.java
index 7ebc1dbd..688a4cd0 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareReflectUtil.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareReflectUtil.java
@@ -19,6 +19,7 @@
 import android.content.Context;
 
 import java.lang.reflect.Array;
+import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 import java.util.Arrays;
@@ -104,6 +105,68 @@ public static Method findMethod(Object instance, String name, Class<?>... parame
             + " not found in " + instance.getClass());
     }
 
+    /**
+     * Locates a given method anywhere in the class inheritance hierarchy.
+     *
+     * @param clazz          a class to search the method into.
+     * @param name           method name
+     * @param parameterTypes method parameter types
+     * @return a method object
+     * @throws NoSuchMethodException if the method cannot be located
+     */
+    public static Method findMethod(Class<?> clazz, String name, Class<?>... parameterTypes)
+            throws NoSuchMethodException {
+        for (; clazz != null; clazz = clazz.getSuperclass()) {
+            try {
+                Method method = clazz.getDeclaredMethod(name, parameterTypes);
+
+                if (!method.isAccessible()) {
+                    method.setAccessible(true);
+                }
+
+                return method;
+            } catch (NoSuchMethodException e) {
+                // ignore and search next
+            }
+        }
+
+        throw new NoSuchMethodException("Method "
+                + name
+                + " with parameters "
+                + Arrays.asList(parameterTypes)
+                + " not found in " + clazz);
+    }
+
+    /**
+     * Locates a given constructor anywhere in the class inheritance hierarchy.
+     *
+     * @param instance       an object to search the constructor into.
+     * @param parameterTypes constructor parameter types
+     * @return a constructor object
+     * @throws NoSuchMethodException if the constructor cannot be located
+     */
+    public static Constructor<?> findConstructor(Object instance, Class<?>... parameterTypes)
+            throws NoSuchMethodException {
+        for (Class<?> clazz = instance.getClass(); clazz != null; clazz = clazz.getSuperclass()) {
+            try {
+                Constructor<?> ctor = clazz.getDeclaredConstructor(parameterTypes);
+
+                if (!ctor.isAccessible()) {
+                    ctor.setAccessible(true);
+                }
+
+                return ctor;
+            } catch (NoSuchMethodException e) {
+                // ignore and search next
+            }
+        }
+
+        throw new NoSuchMethodException("Constructor"
+                + " with parameters "
+                + Arrays.asList(parameterTypes)
+                + " not found in " + instance.getClass());
+    }
+
     /**
      * Replace the value of a field containing a non null array, by a new array containing the
      * elements of the original array plus the elements of extraElements.
@@ -182,4 +245,19 @@ public static Object getActivityThread(Context context,
         }
     }
 
+    /**
+     * Handy method for fetching hidden integer constant value in system classes.
+     *
+     * @param clazz
+     * @param fieldName
+     * @return
+     */
+    public static int getValueOfStaticIntField(Class<?> clazz, String fieldName, int defVal) {
+        try {
+            final Field field = findField(clazz, fieldName);
+            return field.getInt(null);
+        } catch (Throwable thr) {
+            return defVal;
+        }
+    }
 }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareResPatchInfo.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareResPatchInfo.java
index 2aff9593..4aff46ca 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareResPatchInfo.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareResPatchInfo.java
@@ -31,10 +31,12 @@
 public class ShareResPatchInfo {
     public String arscBaseCrc = null;
 
-    public String                         resArscMd5  = null;
-    public ArrayList<String>              addRes      = new ArrayList<>();
-    public ArrayList<String>              deleteRes   = new ArrayList<>();
-    public ArrayList<String>              modRes      = new ArrayList<>();
+    public String                resArscMd5 = null;
+    public ArrayList<String>     addRes     = new ArrayList<>();
+    public ArrayList<String>     deleteRes  = new ArrayList<>();
+    public ArrayList<String>     modRes     = new ArrayList<>();
+    public HashMap<String, File> storeRes   = new HashMap<>();
+
     //use linkHashMap instead?
     public ArrayList<String>              largeModRes = new ArrayList<>();
     public HashMap<String, LargeModeInfo> largeModMap = new HashMap<>();
@@ -97,6 +99,13 @@ public static void parseAllResPatchInfo(String meta, ShareResPatchInfo info) {
                     info.deleteRes.add(lines[i + 1]);
                     i++;
                 }
+            } else if (line.startsWith(ShareConstants.RES_STORE_TITLE)) {
+                final String[] kv = line.split(":", 2);
+                int size = Integer.parseInt(kv[1]);
+                for (; size > 0; size--) {
+                    info.storeRes.put(lines[i + 1], null);
+                    i++;
+                }
             }
         }
 
@@ -177,13 +186,16 @@ public String toString() {
         for (String del : deleteRes) {
             sb.append("deletedSet:" + del + "\n");
         }
+        for (String store : storeRes.keySet()) {
+            sb.append("storeSet:" + store + "\n");
+        }
         return sb.toString();
     }
 
     public static class LargeModeInfo {
-        public String md5  = null;
+        public String md5 = null;
         public long crc;
-        public File   file = null;
+        public File file = null;
     }
 
 }
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareSecurityCheck.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareSecurityCheck.java
index 921984cb..ca75d93b 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareSecurityCheck.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareSecurityCheck.java
@@ -27,10 +27,7 @@
 import java.io.ByteArrayInputStream;
 import java.io.File;
 import java.io.IOException;
-import java.security.PublicKey;
 import java.security.cert.Certificate;
-import java.security.cert.CertificateFactory;
-import java.security.cert.X509Certificate;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.jar.JarEntry;
@@ -40,22 +37,22 @@
  * Created by zhangshaowen on 16/3/10.
  */
 public class ShareSecurityCheck {
-    private static final String    TAG        = "ShareSecurityCheck";
+    private static final String TAG           = "Tinker.SecurityCheck";
     /**
      * static to faster
      * public key
      */
-    private static       PublicKey mPublicKey = null;
+    private static       String mPublicKeyMd5 = null;
 
     private final Context                 mContext;
     private final HashMap<String, String> metaContentMap;
-    private       HashMap<String, String> packageProperties;
+    private final HashMap<String, String> packageProperties;
 
     public ShareSecurityCheck(Context context) {
         mContext = context;
         metaContentMap = new HashMap<>();
-
-        if (mPublicKey == null) {
+        packageProperties = new HashMap<>();
+        if (mPublicKeyMd5 == null) {
             init(mContext);
         }
     }
@@ -70,7 +67,7 @@ public ShareSecurityCheck(Context context) {
      * @return HashMap<String, String>
      */
     public HashMap<String, String> getPackagePropertiesIfPresent() {
-        if (packageProperties != null) {
+        if (!packageProperties.isEmpty()) {
             return packageProperties;
         }
 
@@ -93,9 +90,7 @@ public ShareSecurityCheck(Context context) {
             if (kv == null || kv.length < 2) {
                 continue;
             }
-            if (packageProperties == null) {
-                packageProperties = new HashMap<>();
-            }
+
             packageProperties.put(kv[0].trim(), kv[1].trim());
         }
         return packageProperties;
@@ -121,16 +116,14 @@ public boolean verifyPatchMetaSignature(File path) {
                     continue;
                 }
                 //for faster, only check the meta.txt files
-                //we will check other files's mad5 written in meta files
+                //we will check other files's md5 written in meta files
                 if (!name.endsWith(ShareConstants.META_SUFFIX)) {
                     continue;
                 }
                 metaContentMap.put(name, SharePatchFileUtil.loadDigestes(jarFile, jarEntry));
                 Certificate[] certs = jarEntry.getCertificates();
-                if (certs == null) {
-                    return false;
-                }
-                if (!check(path, certs)) {
+
+                if (certs == null || !check(path, certs)) {
                     return false;
                 }
             }
@@ -155,8 +148,9 @@ private boolean check(File path, Certificate[] certs) {
         if (certs.length > 0) {
             for (int i = certs.length - 1; i >= 0; i--) {
                 try {
-                    certs[i].verify(mPublicKey);
-                    return true;
+                    if (mPublicKeyMd5.equals(SharePatchFileUtil.getMD5(certs[i].getEncoded()))) {
+                        return true;
+                    }
                 } catch (Exception e) {
                     Log.e(TAG, path.getAbsolutePath(), e);
                 }
@@ -172,10 +166,10 @@ private void init(Context context) {
             PackageManager pm = context.getPackageManager();
             String packageName = context.getPackageName();
             PackageInfo packageInfo = pm.getPackageInfo(packageName, PackageManager.GET_SIGNATURES);
-            CertificateFactory certFactory = CertificateFactory.getInstance("X.509");
-            stream = new ByteArrayInputStream(packageInfo.signatures[0].toByteArray());
-            X509Certificate cert = (X509Certificate) certFactory.generateCertificate(stream);
-            mPublicKey = cert.getPublicKey();
+            mPublicKeyMd5 = SharePatchFileUtil.getMD5(packageInfo.signatures[0].toByteArray());
+            if (mPublicKeyMd5 == null) {
+                throw new TinkerRuntimeException("get public key md5 is null");
+            }
         } catch (Exception e) {
             throw new TinkerRuntimeException("ShareSecurityCheck init public key fail", e);
         } finally {
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
index 6024ba9c..2316a727 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
@@ -30,7 +30,9 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.PrintStream;
+import java.lang.reflect.Method;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Properties;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
@@ -41,18 +43,43 @@
  * Created by zhangshaowen on 16/3/10.
  */
 public class ShareTinkerInternals {
-    private static final String TAG = "Tinker.TinkerInternals";
+    private static final String  TAG       = "Tinker.TinkerInternals";
     private static final boolean VM_IS_ART = isVmArt(System.getProperty("java.vm.version"));
+    private static final boolean VM_IS_JIT = isVmJitInternal();
+
+    private static final String  PATCH_PROCESS_NAME    = ":patch";
+    private static       Boolean isPatchProcess        = null;
     /**
      * or you may just hardcode them in your app
      */
-    private static String processName = null;
-    private static String tinkerID = null;
+    private static       String  processName           = null;
+    private static       String  tinkerID              = null;
+    private static       String  currentInstructionSet = null;
 
     public static boolean isVmArt() {
         return VM_IS_ART || Build.VERSION.SDK_INT >= 21;
     }
 
+    public static boolean isVmJit() {
+        return VM_IS_JIT && Build.VERSION.SDK_INT < 24;
+    }
+
+    public static boolean isAfterAndroidO() {
+        return Build.VERSION.SDK_INT > 25;
+    }
+
+    public static String getCurrentInstructionSet() throws Exception {
+        if (currentInstructionSet != null) {
+            return currentInstructionSet;
+        }
+        Class<?> clazz = Class.forName("dalvik.system.VMRuntime");
+        Method currentGet = clazz.getDeclaredMethod("getCurrentInstructionSet");
+
+        currentInstructionSet = (String) currentGet.invoke(null);
+        Log.d(TAG, "getCurrentInstructionSet:" + currentInstructionSet);
+        return currentInstructionSet;
+    }
+
     public static boolean isSystemOTA(String lastFingerPrint) {
         String currentFingerprint = Build.FINGERPRINT;
         if (lastFingerPrint == null
@@ -72,6 +99,21 @@ public static boolean isSystemOTA(String lastFingerPrint) {
         }
     }
 
+    public static ShareDexDiffPatchInfo changeTestDexToClassN(ShareDexDiffPatchInfo rawDexInfo, int index) {
+        if (rawDexInfo.rawName.startsWith(ShareConstants.TEST_DEX_NAME)) {
+            String newName;
+            if (index != 1) {
+                newName = "classes" + index + ".dex";
+            } else {
+                newName = "classes.dex";
+            }
+            return new ShareDexDiffPatchInfo(newName, rawDexInfo.path, rawDexInfo.destMd5InDvm, rawDexInfo.destMd5InArt,
+                rawDexInfo.dexDiffMd5, rawDexInfo.oldDexCrC, rawDexInfo.newDexCrC, rawDexInfo.dexMode);
+        }
+
+        return null;
+    }
+
     public static boolean isNullOrNil(final String object) {
         if ((object == null) || (object.length() <= 0)) {
             return true;
@@ -81,6 +123,7 @@ public static boolean isNullOrNil(final String object) {
 
     /**
      * thinker package check
+     *
      * @param context
      * @param tinkerFlag
      * @param patchFile
@@ -94,6 +137,7 @@ public static int checkTinkerPackage(Context context, int tinkerFlag, File patch
         }
         return returnCode;
     }
+
     /**
      * check patch file signature and TINKER_ID
      *
@@ -157,6 +201,7 @@ public static int checkPackageAndTinkerFlag(ShareSecurityCheck securityCheck, in
     /**
      * not like {@cod ShareSecurityCheck.getPackagePropertiesIfPresent}
      * we don't check Signatures or other files, we just get the package meta's properties directly
+     *
      * @param patchFile
      * @return
      */
@@ -246,6 +291,7 @@ public static String getTypeString(int type) {
 
     /**
      * you can set Tinker disable in runtime at some times!
+     *
      * @param context
      */
     public static void setTinkerDisableWithSharedPreferences(Context context) {
@@ -255,6 +301,7 @@ public static void setTinkerDisableWithSharedPreferences(Context context) {
 
     /**
      * can't load or receive any patch!
+     *
      * @param context
      * @return
      */
@@ -279,13 +326,40 @@ public static boolean isTinkerEnabledAll(int flag) {
     }
 
     public static boolean isInMainProcess(Context context) {
-        String pkgName = context.getPackageName();
+        String mainProcessName = null;
+        ApplicationInfo applicationInfo = context.getApplicationInfo();
+        if (applicationInfo != null) {
+            mainProcessName = applicationInfo.processName;
+        }
+        if (isNullOrNil(mainProcessName)) {
+            mainProcessName = context.getPackageName();
+        }
         String processName = getProcessName(context);
         if (processName == null || processName.length() == 0) {
             processName = "";
         }
 
-        return pkgName.equals(processName);
+        return mainProcessName.equals(processName);
+    }
+
+    public static boolean isInPatchProcess(Context context) {
+        if (isPatchProcess != null) {
+            return isPatchProcess;
+        }
+
+        isPatchProcess = getProcessName(context).endsWith(PATCH_PROCESS_NAME);
+        return isPatchProcess;
+    }
+
+    public static String getCurrentOatMode(Context context, String current) {
+        if (current.equals(ShareConstants.CHANING_DEX_OPTIMIZE_PATH)) {
+            if (isInMainProcess(context)) {
+                current = ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH;
+            } else {
+                current = ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH;
+            }
+        }
+        return current;
     }
 
     public static void killAllOtherProcess(Context context) {
@@ -293,9 +367,15 @@ public static void killAllOtherProcess(Context context) {
         if (am == null) {
             return;
         }
+        List<ActivityManager.RunningAppProcessInfo> appProcessList = am
+            .getRunningAppProcesses();
+
+        if (appProcessList == null) {
+            return;
+        }
         // NOTE: getRunningAppProcess() ONLY GIVE YOU THE PROCESS OF YOUR OWN PACKAGE IN ANDROID M
         // BUT THAT'S ENOUGH HERE
-        for (ActivityManager.RunningAppProcessInfo ai : am.getRunningAppProcesses()) {
+        for (ActivityManager.RunningAppProcessInfo ai : appProcessList) {
             // KILL OTHER PROCESS OF MINE
             if (ai.uid == android.os.Process.myUid() && ai.pid != android.os.Process.myPid()) {
                 android.os.Process.killProcess(ai.pid);
@@ -331,19 +411,26 @@ private static String getProcessNameInternal(final Context context) {
         ActivityManager activityManager =
             (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
 
-        try {
-            for (ActivityManager.RunningAppProcessInfo process : activityManager.getRunningAppProcesses()) {
-                if (process.pid == myPid) {
-                    myProcess = process;
-                    break;
+        if (activityManager != null) {
+            List<ActivityManager.RunningAppProcessInfo> appProcessList = activityManager
+                .getRunningAppProcesses();
+
+            if (appProcessList != null) {
+                try {
+                    for (ActivityManager.RunningAppProcessInfo process : appProcessList) {
+                        if (process.pid == myPid) {
+                            myProcess = process;
+                            break;
+                        }
+                    }
+                } catch (Exception e) {
+                    Log.e(TAG, "getProcessNameInternal exception:" + e.getMessage());
                 }
-            }
-        } catch (Exception e) {
-            Log.e(TAG, "getProcessNameInternal exception:" + e.getMessage());
-        }
 
-        if (myProcess != null) {
-            return myProcess.processName;
+                if (myProcess != null) {
+                    return myProcess.processName;
+                }
+            }
         }
 
         byte[] b = new byte[128];
@@ -353,7 +440,7 @@ private static String getProcessNameInternal(final Context context) {
             int len = in.read(b);
             if (len > 0) {
                 for (int i = 0; i < len; i++) { // lots of '0' in tail , remove them
-                    if (b[i] > 128 || b[i] <= 0) {
+                    if ((((int) b[i]) & 0xFF) > 128 || b[i] <= 0) {
                         len = i;
                         break;
                     }
@@ -362,7 +449,7 @@ private static String getProcessNameInternal(final Context context) {
             }
 
         } catch (Exception e) {
-            e.printStackTrace();
+            Log.e(TAG, "getProcessNameInternal exception:" + e.getMessage());
         } finally {
             try {
                 if (in != null) {
@@ -377,6 +464,7 @@ private static String getProcessNameInternal(final Context context) {
 
     /**
      * vm whether it is art
+     *
      * @return
      */
     private static boolean isVmArt(String versionString) {
@@ -398,23 +486,44 @@ private static boolean isVmArt(String versionString) {
         return isArt;
     }
 
+    private static boolean isVmJitInternal() {
+        try {
+            Class<?> clazz = Class.forName("android.os.SystemProperties");
+            Method mthGet = clazz.getDeclaredMethod("get", String.class);
+
+            String jit = (String) mthGet.invoke(null, "dalvik.vm.usejit");
+            String jitProfile = (String) mthGet.invoke(null, "dalvik.vm.usejitprofiles");
+
+            //usejit is true and usejitprofiles is null
+            if (!isNullOrNil(jit) && isNullOrNil(jitProfile) && jit.equals("true")) {
+                return true;
+            }
+        } catch (Throwable e) {
+            Log.e(TAG, "isVmJitInternal ex:" + e);
+        }
+        return false;
+    }
+
     public static String getExceptionCauseString(final Throwable ex) {
+        if (ex == null) return "";
+
         final ByteArrayOutputStream bos = new ByteArrayOutputStream();
         final PrintStream ps = new PrintStream(bos);
 
         try {
             // print directly
             Throwable t = ex;
-            while (t.getCause() != null) {
-                t = t.getCause();
+            while (true) {
+                Throwable cause = t.getCause();
+                if (cause == null) {
+                    break;
+                }
+                t = cause;
             }
             t.printStackTrace(ps);
             return toVisualString(bos.toString());
         } finally {
-            try {
-                bos.close();
-            } catch (IOException e) {
-            }
+            SharePatchFileUtil.closeQuietly(ps);
         }
     }
 
diff --git a/tinker-build/tinker-patch-cli/tool_output/merge_mapping.py b/tinker-build/tinker-patch-cli/tool_output/merge_mapping.py
index 6fcbd55e..a60fda39 100644
--- a/tinker-build/tinker-patch-cli/tool_output/merge_mapping.py
+++ b/tinker-build/tinker-patch-cli/tool_output/merge_mapping.py
@@ -97,16 +97,16 @@ def do_merge(self):
                 current_data = self.current_classes[key]
                 # 如果当前的类没有被混淆，则保留，否则用之前的mapping里面的内容覆盖
                 # ___.___ -> ___.___:
-                if current_data.raw_line.split("->")[0] == current_data.raw_line.split("->")[1][:-1]:
+                if current_data.raw_line.split("->")[0] != current_data.raw_line.split("->")[1][:-1]:
                     current_data.raw_line = data.raw_line
                 new_method_list = []
                 # 处理方法
-                for line in current_data.filed_methods:
+                for line in current_data.field_methods:
                     result, new_line = self.find_same_methods(line, data)
                     # 只有找到才写入
                     if result:
                         new_method_list.append(new_line)
-                current_data.filed_methods = new_method_list
+                current_data.field_methods = new_method_list
             # 新的混淆不在旧的里面，则删除
             else:
                 del self.current_classes[key]
@@ -116,7 +116,7 @@ def find_same_methods(self, line, data):
         # 这里是特殊情况，如果在当前mapping发现查找的这个并没有混淆，就不打算保留在mapping文件中
         if search_name == search_new_name:
             return False, ""
-        for method_line in data.filed_methods:
+        for method_line in data.field_methods:
             target_name, target_complete_name, target_new_name = self.get_name_and_complete_name_and_new_name(method_line)
             # 这里必须要用最完整的信息来进行比较，避免重载的影响
             if search_complete_name == target_complete_name:
@@ -157,7 +157,7 @@ def print_new_mapping(self):
                 if key in self.current_classes:
                     data = self.current_classes[key]
                     fw.write(data.raw_line)
-                    for line in data.filed_methods:
+                    for line in data.field_methods:
                         fw.write(line)
 
 
diff --git a/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml b/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml
index de0c6c99..41d46696 100644
--- a/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml
+++ b/tinker-build/tinker-patch-cli/tool_output/tinker_config.xml
@@ -24,6 +24,20 @@
 
         <!--if you don't set sevenZip path, we just use 7za to try-->
         <sevenZipPath value="/usr/local/bin/7za"/>
+
+        <!--Whether tinker should treat the base apk as the one being protected by app-->
+        <!--protection tools.-->
+        <!--If this attribute is true, the generated patch package will contain a-->
+        <!--dex including all changed classes instead of any dexdiff patch-info files.-->
+        <isProtectedApp value="false"/>
+
+        <!--Whether tinker should support component hotplug (add new component dynamically).-->
+        <!--If this attribute is true, the component added in new apk will be available after-->
+        <!--patch is successfully loaded. Otherwise an error would be announced when generating patch-->
+        <!--on compile-time.-->
+        <!---->
+        <!--Notice that currently this feature is incubating and only support NON-EXPORTED Activity-->
+        <supportHotplugComponent value="false"/>
     </issue>
 
     <issue id="dex">
@@ -52,7 +66,7 @@
         <!--it support * or ? pattern.-->
         <!--for library in assets, we would just recover them in the patch directory-->
         <!--you can get them in TinkerLoadResult with Tinker-->
-        <pattern value="lib/armeabi/*.so"/>
+        <pattern value="lib/*/*.so"/>
     </issue>
 
     <issue id="resource">
diff --git a/tinker-build/tinker-patch-cli/tool_output/tinker_multidexkeep.pro b/tinker-build/tinker-patch-cli/tool_output/tinker_multidexkeep.pro
index 263db733..5c9f4c5b 100644
--- a/tinker-build/tinker-patch-cli/tool_output/tinker_multidexkeep.pro
+++ b/tinker-build/tinker-patch-cli/tool_output/tinker_multidexkeep.pro
@@ -1,21 +1,27 @@
+#tinker multidex keep patterns:
 -keep public class * implements com.tencent.tinker.loader.app.ApplicationLifeCycle {
-    *;
+    <init>();
+    void onBaseContextAttached(android.content.Context);
 }
 
 -keep public class * extends com.tencent.tinker.loader.TinkerLoader {
-    *;
+    <init>();
 }
 
 -keep public class * extends android.app.Application {
-    *;
+     <init>();
+     void attachBaseContext(android.content.Context);
 }
 
-#your dex.loader pattern here
--keep class com.tencent.tinker.loader.** {
-    *;
+-keep class com.tencent.tinker.loader.TinkerTestAndroidNClassLoader {
+    <init>();
 }
 
+#your dex.loader patterns here
 -keep class tinker.sample.android.app.SampleApplication {
-    *;
+    <init>();
 }
 
+-keep class com.tencent.tinker.loader.** {
+    <init>();
+}
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-cli/tool_output/tinker_proguard.pro b/tinker-build/tinker-patch-cli/tool_output/tinker_proguard.pro
index e4ef8030..85e96b50 100644
--- a/tinker-build/tinker-patch-cli/tool_output/tinker_proguard.pro
+++ b/tinker-build/tinker-patch-cli/tool_output/tinker_proguard.pro
@@ -25,7 +25,16 @@
     *;
 }
 
+-keep public class com.tencent.tinker.loader.TinkerTestAndroidNClassLoader {
+    *;
+}
+
+#for command line version, we must keep all the loader class to avoid proguard mapping conflict
 #your dex.loader pattern here
--keep class com.tencent.tinker.loader.**
--keep class tinker.sample.android.app.SampleApplication
+-keep public class com.tencent.tinker.loader.** {
+    *;
+}
 
+-keep class tinker.sample.android.app.SampleApplication {
+    *;
+}
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
index 9fe162e9..80825350 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
@@ -20,6 +20,7 @@ import com.tencent.tinker.build.gradle.extension.*
 import com.tencent.tinker.build.gradle.task.*
 import com.tencent.tinker.build.util.FileOperation
 import com.tencent.tinker.build.util.TypedValue
+import com.tencent.tinker.build.util.Utils
 import org.gradle.api.GradleException
 import org.gradle.api.Plugin
 import org.gradle.api.Project
@@ -57,6 +58,24 @@ class TinkerPatchPlugin implements Plugin<Project> {
             throw new GradleException('generateTinkerApk: Android Application plugin required')
         }
 
+        def android = project.extensions.android
+
+        try {
+            //close preDexLibraries
+            android.dexOptions.preDexLibraries = false
+
+            //open jumboMode
+            android.dexOptions.jumboMode = true
+
+            //disable aapt2
+            reflectAapt2Flag()
+
+            //disable dex archive mode
+            disableArchiveDex()
+        } catch (Throwable e) {
+            //no preDexLibraries field, just continue
+        }
+
         project.afterEvaluate {
             def configuration = project.tinkerPatch
 
@@ -65,23 +84,13 @@ class TinkerPatchPlugin implements Plugin<Project> {
                 return
             }
 
-            def android = project.extensions.android
-
-            //open jumboMode
-            android.dexOptions.jumboMode = true
-
-            //close preDexLibraries
-            try {
-                android.dexOptions.preDexLibraries = false
-            } catch (Throwable e) {
-                //no preDexLibraries field, just continue
-            }
-
             project.logger.error("----------------------tinker build warning ------------------------------------")
             project.logger.error("tinker auto operation: ")
             project.logger.error("excluding annotation processor and source template from app packaging. Enable dx jumboMode to reduce package size.")
             project.logger.error("enable dx jumboMode to reduce package size.")
             project.logger.error("disable preDexLibraries to prevent ClassDefNotFoundException when your app is booting.")
+            project.logger.error("disable aapt2 so far for resource id keeping.")
+            project.logger.error("disable archive dex mode so far for keeping dex apply.")
             project.logger.error("")
             project.logger.error("tinker will change your build configs:")
             project.logger.error("we will add TINKER_ID=${configuration.buildConfig.tinkerId} in your build output manifest file build/intermediates/manifests/full/*")
@@ -115,6 +124,7 @@ class TinkerPatchPlugin implements Plugin<Project> {
 
                 def variantOutput = variant.outputs.first()
                 def variantName = variant.name.capitalize()
+                def variantData = variant.variantData
 
                 def instantRunTask = getInstantRunTask(project, variantName)
                 if (instantRunTask != null) {
@@ -126,33 +136,45 @@ class TinkerPatchPlugin implements Plugin<Project> {
                 }
 
                 TinkerPatchSchemaTask tinkerPatchBuildTask = project.tasks.create("tinkerPatch${variantName}", TinkerPatchSchemaTask)
-                tinkerPatchBuildTask.dependsOn variant.assemble
 
-                tinkerPatchBuildTask.signConfig = variant.apkVariantData.variantConfiguration.signingConfig
+                tinkerPatchBuildTask.signConfig = variantData.variantConfiguration.signingConfig
 
                 variant.outputs.each { output ->
-                    tinkerPatchBuildTask.buildApkPath = output.outputFile
-                    File parentFile = output.outputFile
-                    tinkerPatchBuildTask.outputFolder = "${parentFile.getParentFile().getParentFile().getAbsolutePath()}/" + TypedValue.PATH_DEFAULT_OUTPUT + "/" + variant.dirName
+                    setPatchNewApkPath(configuration, output, variant, tinkerPatchBuildTask)
+                    setPatchOutputFolder(configuration, output, variant, tinkerPatchBuildTask)
                 }
 
                 // Create a task to add a build TINKER_ID to AndroidManifest.xml
                 // This task must be called after "process${variantName}Manifest", since it
                 // requires that an AndroidManifest.xml exists in `build/intermediates`.
                 TinkerManifestTask manifestTask = project.tasks.create("tinkerProcess${variantName}Manifest", TinkerManifestTask)
-                manifestTask.manifestPath = variantOutput.processManifest.manifestOutputFile
+
+                if (variantOutput.processManifest.properties['manifestOutputFile'] != null) {
+                    manifestTask.manifestPath = variantOutput.processManifest.manifestOutputFile
+                } else if (variantOutput.processResources.properties['manifestFile'] != null) {
+                    manifestTask.manifestPath = variantOutput.processResources.manifestFile
+                }
                 manifestTask.mustRunAfter variantOutput.processManifest
 
                 variantOutput.processResources.dependsOn manifestTask
 
                 //resource id
                 TinkerResourceIdTask applyResourceTask = project.tasks.create("tinkerProcess${variantName}ResourceId", TinkerResourceIdTask)
-                applyResourceTask.resDir = variantOutput.processResources.resDir
+
+                if (variantOutput.processResources.properties['resDir'] != null) {
+                    applyResourceTask.resDir = variantOutput.processResources.resDir
+                } else if (variantOutput.processResources.properties['inputResourcesDir'] != null) {
+                    applyResourceTask.resDir = variantOutput.processResources.inputResourcesDir.getFiles().first()
+                }
                 //let applyResourceTask run after manifestTask
                 applyResourceTask.mustRunAfter manifestTask
 
                 variantOutput.processResources.dependsOn applyResourceTask
 
+                if (manifestTask.manifestPath == null || applyResourceTask.resDir == null) {
+                    throw new RuntimeException("manifestTask.manifestPath or applyResourceTask.resDir is null.")
+                }
+
                 // Add this proguard settings file to the list
                 boolean proguardEnable = variant.getBuildType().buildType.minifyEnabled
 
@@ -169,13 +191,17 @@ class TinkerPatchPlugin implements Plugin<Project> {
                 }
 
                 // Add this multidex proguard settings file to the list
-                boolean multiDexEnabled = variant.apkVariantData.variantConfiguration.isMultiDexEnabled()
+                boolean multiDexEnabled = variantData.variantConfiguration.isMultiDexEnabled()
 
                 if (multiDexEnabled) {
                     TinkerMultidexConfigTask multidexConfigTask = project.tasks.create("tinkerProcess${variantName}MultidexKeep", TinkerMultidexConfigTask)
                     multidexConfigTask.applicationVariant = variant
                     multidexConfigTask.mustRunAfter manifestTask
 
+                    // for java.io.FileNotFoundException: app/build/intermediates/multi-dex/release/manifest_keep.txt
+                    // for gradle 3.x gen manifest_keep move to processResources task
+                    multidexConfigTask.mustRunAfter variantOutput.processResources
+
                     def multidexTask = getMultiDexTask(project, variantName)
                     if (multidexTask != null) {
                         multidexTask.dependsOn multidexConfigTask
@@ -187,13 +213,92 @@ class TinkerPatchPlugin implements Plugin<Project> {
                 }
 
                 if (configuration.buildConfig.keepDexApply
-                    && FileOperation.isLegalFile(project.tinkerPatch.oldApk)) {
+                        && FileOperation.isLegalFile(project.tinkerPatch.oldApk)) {
                     com.tencent.tinker.build.gradle.transform.ImmutableDexTransform.inject(project, variant)
                 }
             }
         }
     }
 
+    /**
+     * Specify the output folder of tinker patch result.
+     *
+     * @param configuration the tinker configuration 'tinkerPatch'
+     * @param output the output of assemble result
+     * @param variant the variant
+     * @param tinkerPatchBuildTask the task that tinker patch uses
+     */
+    void setPatchOutputFolder(configuration, output, variant, tinkerPatchBuildTask) {
+        File parentFile = output.outputFile
+        String outputFolder = "${configuration.outputFolder}";
+        if (!Utils.isNullOrNil(outputFolder)) {
+            outputFolder = "${outputFolder}/${TypedValue.PATH_DEFAULT_OUTPUT}/${variant.dirName}"
+        } else {
+            outputFolder =
+                    "${parentFile.getParentFile().getParentFile().getAbsolutePath()}/${TypedValue.PATH_DEFAULT_OUTPUT}/${variant.dirName}"
+        }
+        tinkerPatchBuildTask.outputFolder = outputFolder
+    }
+
+    void reflectAapt2Flag() {
+        try {
+            def booleanOptClazz = Class.forName('com.android.build.gradle.options.BooleanOption')
+            def enableAAPT2Field = booleanOptClazz.getDeclaredField('ENABLE_AAPT2')
+            enableAAPT2Field.setAccessible(true)
+            def enableAAPT2EnumObj = enableAAPT2Field.get(null)
+            def defValField = enableAAPT2EnumObj.getClass().getDeclaredField('defaultValue')
+            defValField.setAccessible(true)
+            defValField.set(enableAAPT2EnumObj, false)
+        } catch (Throwable thr) {
+            // To some extends, class not found means we are in lower version of android gradle
+            // plugin, so just ignore that exception.
+            if (!(thr instanceof ClassNotFoundException)) {
+                project.logger.error("reflectAapt2Flag error: ${thr.getMessage()}.")
+            }
+        }
+    }
+
+    void disableArchiveDex() {
+        try {
+            def booleanOptClazz = Class.forName('com.android.build.gradle.options.BooleanOption')
+            def enableDexArchiveField = booleanOptClazz.getDeclaredField('ENABLE_DEX_ARCHIVE')
+            enableDexArchiveField.setAccessible(true)
+            def enableDexArchiveEnumObj = enableDexArchiveField.get(null)
+            def defValField = enableDexArchiveEnumObj.getClass().getDeclaredField('defaultValue')
+            defValField.setAccessible(true)
+            defValField.set(enableDexArchiveEnumObj, false)
+        } catch (Throwable thr) {
+            // To some extends, class not found means we are in lower version of android gradle
+            // plugin, so just ignore that exception.
+            if (!(thr instanceof ClassNotFoundException)) {
+                project.logger.error("reflectDexArchiveFlag error: ${thr.getMessage()}.")
+            }
+        }
+    }
+
+    /**
+     * Specify the new apk path. If the new apk file is specified by {@code tinkerPatch.buildConfig.newApk},
+     * just use it as the new apk input for tinker patch, otherwise use the assemble output.
+     *
+     * @param project the project which applies this plugin
+     * @param configuration the tinker configuration 'tinkerPatch'
+     * @param output the output of assemble result
+     * @param variant the variant
+     * @param tinkerPatchBuildTask the task that tinker patch uses
+     */
+    void setPatchNewApkPath(configuration, output, variant, tinkerPatchBuildTask) {
+        def newApkPath = configuration.newApk
+        if (!Utils.isNullOrNil(newApkPath)) {
+            if (FileOperation.isLegalFile(newApkPath)) {
+                tinkerPatchBuildTask.buildApkPath = newApkPath
+                return
+            }
+        }
+
+        tinkerPatchBuildTask.buildApkPath = output.outputFile
+        tinkerPatchBuildTask.dependsOn variant.assemble
+    }
+
     Task getMultiDexTask(Project project, String variantName) {
         String multiDexTaskName = "transformClassesWithMultidexlistFor${variantName}"
         return project.tasks.findByName(multiDexTaskName)
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerBuildConfigExtension.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerBuildConfigExtension.groovy
index 7d109793..106b2f17 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerBuildConfigExtension.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerBuildConfigExtension.groovy
@@ -45,6 +45,25 @@ public class TinkerBuildConfigExtension {
      */
     String tinkerId
 
+    /**
+     * Whether tinker should treat the base apk as the one being protected by app
+     * protection tools.
+     * If this attribute is true, the generated patch package will contain a
+     * dex including all changed classes instead of any dexdiff patch-info files.
+     * default: false
+     */
+    boolean isProtectedApp
+
+    /**
+     * Whether tinker should support component hotplug (add new component dynamically).
+     * If this attribute is true, the component added in new apk will be available after
+     * patch is successfully loaded. Otherwise an error would be announced when generating patch
+     * on compile-time.
+     *
+     * <b>Notice that currently this feature is incubating and only support NON-EXPORTED Activity</b>
+     */
+    boolean supportHotplugComponent
+
     private Project project
 
     boolean usingResourceMapping
@@ -53,7 +72,7 @@ public class TinkerBuildConfigExtension {
      * if keepDexApply is true,class in which dex refer to the old apk.
      * open this can reduce the dex diff file size.
      */
-    boolean keepDexApply;
+    boolean keepDexApply
 
     public TinkerBuildConfigExtension(Project project) {
         this.project = project
@@ -62,6 +81,7 @@ public class TinkerBuildConfigExtension {
         tinkerId = null
         usingResourceMapping = false
         keepDexApply = false
+        isProtectedApp = false
     }
 
     void checkParameter() {
@@ -75,6 +95,8 @@ public class TinkerBuildConfigExtension {
     public String toString() {
         """| applyMapping = ${applyMapping}
            | applyResourceMapping = ${applyResourceMapping}
+           | isProtectedApp = ${isProtectedApp}
+           | supportHotplugComponent = ${supportHotplugComponent}
            | keepDexApply = ${keepDexApply}
            | tinkerId = ${tinkerId}
         """.stripMargin()
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerDexExtension.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerDexExtension.groovy
index f600b499..e2429f03 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerDexExtension.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerDexExtension.groovy
@@ -44,6 +44,7 @@ public class TinkerDexExtension {
      */
     Iterable<String> loader;
 
+    Iterable<String> ignoreWarningLoader;
 
     private Project project;
 
@@ -51,6 +52,7 @@ public class TinkerDexExtension {
         dexMode = "jar"
         pattern = []
         loader = []
+        ignoreWarningLoader = []
         this.project = project
     }
 
@@ -65,6 +67,7 @@ public class TinkerDexExtension {
         """| dexMode = ${dexMode}
            | pattern = ${pattern}
            | loader = ${loader}
+           | ignoreWarningLoader = ${ignoreWarningLoader}
         """.stripMargin()
     }
 }
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy
index c3b86141..3b99a728 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/extension/TinkerPatchExtension.groovy
@@ -30,6 +30,16 @@ public class TinkerPatchExtension {
      */
     String oldApk
 
+    /**
+     * Specify a folder for the outputs where place the tinker patch results.
+     */
+    String outputFolder
+
+    /**
+     * Specify the new apk path instead of running assemble task again.
+     */
+    String newApk;
+
     /**
      * If there is loader class changes,
      * or Activity, Service, Receiver, Provider change, it will terminal
@@ -52,6 +62,8 @@ public class TinkerPatchExtension {
 
     public TinkerPatchExtension() {
         oldApk = ""
+        outputFolder = ""
+        newApk = ""
         ignoreWarning = false
         useSign = true
         tinkerEnable = true
@@ -73,6 +85,8 @@ public class TinkerPatchExtension {
     @Override
     public String toString() {
         """| oldApk = ${oldApk}
+           | outputFolder = ${outputFolder}
+           | newApk = ${newApk}
            | ignoreWarning = ${ignoreWarning}
            | tinkerEnable = ${tinkerEnable}
            | useSign = ${useSign}
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerManifestTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerManifestTask.groovy
index 2c4b19d1..cd30bd09 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerManifestTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerManifestTask.groovy
@@ -18,6 +18,7 @@ package com.tencent.tinker.build.gradle.task
 
 import com.tencent.tinker.build.gradle.TinkerPatchPlugin
 import com.tencent.tinker.build.util.FileOperation
+import com.tencent.tinker.commons.util.StreamUtil
 import groovy.xml.Namespace
 import org.gradle.api.DefaultTask
 import org.gradle.api.GradleException
@@ -62,27 +63,34 @@ public class TinkerManifestTask extends DefaultTask {
 
     void writeManifestMeta(String path, String name, String value) {
         def ns = new Namespace("http://schemas.android.com/apk/res/android", "android")
-
-        def xml = new XmlParser().parse(new InputStreamReader(new FileInputStream(path), "utf-8"))
-
-        def application = xml.application[0]
-        if (application) {
-            def metaDataTags = application['meta-data']
-
-            // remove any old TINKER_ID elements
-            def tinkerId = metaDataTags.findAll {
-                it.attributes()[ns.name].equals(name)
-            }.each {
-                it.parent().remove(it)
+        def isr = null
+        def pw = null
+        try {
+            isr = new InputStreamReader(new FileInputStream(path), "utf-8")
+            def xml = new XmlParser().parse(isr)
+            def application = xml.application[0]
+            if (application) {
+                def metaDataTags = application['meta-data']
+
+                // remove any old TINKER_ID elements
+                def tinkerId = metaDataTags.findAll {
+                    it.attributes()[ns.name].equals(name)
+                }.each {
+                    it.parent().remove(it)
+                }
+
+                // Add the new TINKER_ID element
+                application.appendNode('meta-data', [(ns.name): name, (ns.value): value])
+
+                // Write the manifest file
+                pw = new PrintWriter(path, "utf-8")
+                def printer = new XmlNodePrinter(pw)
+                printer.preserveWhitespace = true
+                printer.print(xml)
             }
-
-            // Add the new TINKER_ID element
-            application.appendNode('meta-data', [(ns.name): name, (ns.value): value])
-
-            // Write the manifest file
-            def printer = new XmlNodePrinter(new PrintWriter(path, "utf-8"))
-            printer.preserveWhitespace = true
-            printer.print(xml)
+        } finally {
+            StreamUtil.closeQuietly(pw)
+            StreamUtil.closeQuietly(isr)
         }
     }
 
@@ -103,14 +111,21 @@ public class TinkerManifestTask extends DefaultTask {
     }
 
     String readManifestApplicationName(String path) {
-        def xml = new XmlParser().parse(new InputStreamReader(new FileInputStream(path), "utf-8"))
-        def ns = new Namespace("http://schemas.android.com/apk/res/android", "android")
-
-        def application = xml.application[0]
-        if (application) {
-            return application.attributes()[ns.name]
+        def isr = null
+        try {
+            isr = new InputStreamReader(new FileInputStream(path), "utf-8")
+            def xml = new XmlParser().parse(isr)
+            def ns = new Namespace("http://schemas.android.com/apk/res/android", "android")
+
+            def application = xml.application[0]
+            if (application) {
+                return application.attributes()[ns.name]
+            } else {
+                return null
+            }
+        } finally {
+            StreamUtil.closeQuietly(isr)
         }
-        return null
     }
 }
 
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy
index 0476e862..2b148947 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerMultidexConfigTask.groovy
@@ -29,15 +29,17 @@ public class TinkerMultidexConfigTask extends DefaultTask {
     static final String MULTIDEX_CONFIG_PATH = TinkerPatchPlugin.TINKER_INTERMEDIATES + "tinker_multidexkeep.pro"
     static final String MULTIDEX_CONFIG_SETTINGS =
             "-keep public class * implements com.tencent.tinker.loader.app.ApplicationLifeCycle {\n" +
-                    "    *;\n" +
+                    "    <init>(...);\n" +
+                    "    void onBaseContextAttached(android.content.Context);\n" +
                     "}\n" +
                     "\n" +
                     "-keep public class * extends com.tencent.tinker.loader.TinkerLoader {\n" +
-                    "    *;\n" +
+                    "    <init>(...);\n" +
                     "}\n" +
                     "\n" +
                     "-keep public class * extends android.app.Application {\n" +
-                    "    *;\n" +
+                    "     <init>();\n" +
+                    "     void attachBaseContext(android.content.Context);\n" +
                     "}\n"
 
 
@@ -60,7 +62,15 @@ public class TinkerMultidexConfigTask extends DefaultTask {
              .append("#tinker multidex keep patterns:\n")
              .append(MULTIDEX_CONFIG_SETTINGS)
              .append("\n")
-             .append("#your dex.loader patterns here\n")
+
+        // This class must be placed in main dex so that we can use it to check if new pathList
+        // in AndroidNClassLoader is fine when under the protected app (whose main dex is always encrypted).
+        lines.append("-keep class com.tencent.tinker.loader.TinkerTestAndroidNClassLoader {\n" +
+                "    <init>(...);\n" +
+                "}\n")
+             .append("\n")
+
+        lines.append("#your dex.loader patterns here\n")
 
         Iterable<String> loader = project.extensions.tinkerPatch.dex.loader
         for (String pattern : loader) {
@@ -70,11 +80,13 @@ public class TinkerMultidexConfigTask extends DefaultTask {
                 }
             }
             lines.append("-keep class " + pattern + " {\n" +
-                    "    *;\n" +
+                    "    <init>(...);\n" +
                     "}\n")
                     .append("\n")
         }
 
+
+
         // Write our recommended proguard settings to this file
         FileWriter fr = new FileWriter(file.path)
         try {
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy
index 87d674ad..6a674fda 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerPatchSchemaTask.groovy
@@ -67,7 +67,10 @@ public class TinkerPatchSchemaTask extends DefaultTask {
                .setOutBuilder(outputFolder)
                .setIgnoreWarning(configuration.ignoreWarning)
                .setDexFilePattern(new ArrayList<String>(configuration.dex.pattern))
+               .setIsProtectedApp(configuration.buildConfig.isProtectedApp)
+               .setIsComponentHotplugSupported(configuration.buildConfig.supportHotplugComponent)
                .setDexLoaderPattern(new ArrayList<String>(configuration.dex.loader))
+               .setDexIgnoreWarningLoaderPattern(new ArrayList<String>(configuration.dex.ignoreWarningLoader))
                .setDexMode(configuration.dex.dexMode)
                .setSoFilePattern(new ArrayList<String>(configuration.lib.pattern))
                .setResourceFilePattern(new ArrayList<String>(configuration.res.pattern))
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy
index e98a0935..23230b52 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerProguardConfigTask.groovy
@@ -52,6 +52,9 @@ public class TinkerProguardConfigTask extends DefaultTask {
                     "-keep public class com.tencent.tinker.loader.TinkerTestDexLoad {\n" +
                     "    *;\n" +
                     "}\n" +
+                    "-keep public class com.tencent.tinker.loader.TinkerTestAndroidNClassLoader {\n" +
+                    "    *;\n" +
+                    "}\n" +
                     "\n"
 
 
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/ImmutableDexTransform.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/ImmutableDexTransform.groovy
index 92a80fcf..25f5fff1 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/ImmutableDexTransform.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/ImmutableDexTransform.groovy
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
  *
- * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * Licensed under the BSD 3-Clause License (the "License") you may not use this file except in
  * compliance with the License. You may obtain a copy of the License at
  *
  * https://opensource.org/licenses/BSD-3-Clause
@@ -17,14 +17,8 @@
 package com.tencent.tinker.build.gradle.transform
 
 import com.android.annotations.NonNull
-import com.android.build.api.transform.Format
-import com.android.build.api.transform.JarInput;
-import com.android.build.api.transform.QualifiedContent
-import com.android.build.api.transform.Transform;
-import com.android.build.api.transform.TransformException
-import com.android.build.api.transform.TransformInput
-import com.android.build.api.transform.TransformInvocation
-import com.android.build.api.transform.TransformOutputProvider
+import com.android.build.api.transform.*
+import com.android.build.gradle.internal.pipeline.TransformManager
 import com.android.build.gradle.internal.pipeline.TransformTask
 import com.android.build.gradle.internal.transforms.DexTransform
 import com.google.common.base.Joiner
@@ -36,15 +30,15 @@ import com.tencent.tinker.build.immutable.ClassSimDef
 import com.tencent.tinker.build.immutable.DexRefData
 import com.tencent.tinker.build.util.FileOperation
 import com.tencent.tinker.build.util.Utils
+import org.gradle.api.Action
 import org.gradle.api.GradleException
 import org.gradle.api.Project
 import org.gradle.api.Task
 import org.gradle.api.execution.TaskExecutionGraph
 import org.gradle.api.execution.TaskExecutionGraphListener
-import org.gradle.api.logging.Logging
+import org.gradle.api.tasks.JavaExec
 
-
-import java.lang.reflect.Field;
+import java.lang.reflect.Field
 import java.util.zip.ZipEntry
 import java.util.zip.ZipFile
 import java.util.zip.ZipOutputStream
@@ -56,7 +50,7 @@ public class ImmutableDexTransform extends Transform {
 
     public static final String TASK_WORK_DIR = "keep_dex"
 
-    private static final Joiner PATH_JOINER = Joiner.on(File.separatorChar);
+    private static final Joiner PATH_JOINER = Joiner.on(File.separatorChar)
 
     Project project
 
@@ -66,8 +60,6 @@ public class ImmutableDexTransform extends Transform {
 
     File baseDexDir
 
-    File dxOutDir
-
     File mainDexListFile
 
     String varName
@@ -86,23 +78,22 @@ public class ImmutableDexTransform extends Transform {
         this.varName = variant.name.capitalize()
         this.varDirName = variant.getDirName()
         this.oldApkPath = project.tinkerPatch.oldApk
-        this.mainDexListFile = dexTransform.mainDexListFile
+        if (dexTransform.mainDexListFile instanceof File) {
+            this.mainDexListFile = dexTransform.mainDexListFile
+        } else {
+            this.mainDexListFile = dexTransform.mainDexListFile.getSingleFile()
+        }
     }
 
     public void initFileEnv(TransformOutputProvider outputProvider) {
         classPreDir = getDirInWorkDir("class_pre")
         baseDexDir = getDirInWorkDir("base_dex")
-        dxOutDir = outputProvider.getContentLocation("main",
-                getOutputTypes(), getScopes(),
-                Format.DIRECTORY);
 
         classPreDir.mkdirs()
         baseDexDir.mkdirs()
-        dxOutDir.mkdirs()
 
         FileOperation.cleanDir(classPreDir)
         FileOperation.cleanDir(baseDexDir)
-        FileOperation.cleanDir(dxOutDir)
     }
 
     private File getDirInWorkDir(String name) {
@@ -118,7 +109,7 @@ public class ImmutableDexTransform extends Transform {
     @NonNull
     @Override
     public Set<QualifiedContent.ContentType> getOutputTypes() {
-        return dexTransform.getOutputTypes();
+        return dexTransform.getOutputTypes()
     }
 
     @NonNull
@@ -161,11 +152,10 @@ public class ImmutableDexTransform extends Transform {
 
     @Override
     void transform(TransformInvocation transformInvocation) throws TransformException, IOException, InterruptedException {
-
         // because multi dex is enable,we only process jar file.
-        List<JarInput> jarInputs = Lists.newArrayList();
+        List<JarInput> jarInputs = Lists.newArrayList()
         for (TransformInput input : transformInvocation.getInputs()) {
-            jarInputs.addAll(input.getJarInputs());
+            jarInputs.addAll(input.getJarInputs())
         }
         //because the multi-dex is turned on,so the jarInput.size()==1 in theory.
         if (jarInputs.size() != 1) {
@@ -175,7 +165,7 @@ public class ImmutableDexTransform extends Transform {
         }
 
         //init
-        initFileEnv(transformInvocation.getOutputProvider());
+        initFileEnv(transformInvocation.getOutputProvider())
         //get all old dex
         ArrayList<File> oldDexList = new ArrayList<>()
         traversal(new ZipFile(oldApkPath), { ZipEntry zipEntry, byte[] bytes ->
@@ -254,11 +244,20 @@ public class ImmutableDexTransform extends Transform {
 
         //a list for all dex's path,use for checkClassConsistence mtd
         ArrayList<String> dexPathList = new ArrayList<>()
+
+        def dxOutDir = transformInvocation.outputProvider.getContentLocation("main",
+                getOutputTypes(), TransformManager.SCOPE_FULL_PROJECT, Format.DIRECTORY)
+        if (dxOutDir.exists()) {
+            FileOperation.cleanDir(dxOutDir)
+        } else {
+            dxOutDir.mkdirs()
+        }
+
         classPreDir.eachFile { classZip ->
             String classIndexName = classZip.name - ".jar"
             String dexPath = "${dxOutDir.absolutePath}/${classIndexName}.dex"
             dexPathList.add(dexPath)
-            doDex(classIndexName, classZip, project.android.getDexOptions())
+            doDex(dexPath, classZip, project.android.getDexOptions())
         }
 
         checkClassConsistence(dexPathList, allClassSet)
@@ -331,27 +330,35 @@ public class ImmutableDexTransform extends Transform {
     }
 
 
-    private void doDex(String classIndexName, File classZip, def dexOptions) {
-        ArrayList<String> execArgs = new ArrayList()
-        def dex = "${project.android.getSdkDirectory()}/build-tools/${project.android.buildToolsVersion}/dx"
-        execArgs.add(dex.toString())
-        execArgs.add("--dex")
-        if (dexOptions.getJumboMode()) {
-            execArgs.add("--force-jumbo");
-        }
-        if (dexOptions.getIncremental()) {
-            execArgs.add("--incremental");
-            execArgs.add("--no-strict");
-        }
-        execArgs.add("--output=${dxOutDir.absolutePath}/${classIndexName}.dex".toString())
-        execArgs.add(classZip.absolutePath)
-        project.logger.info(execArgs.toString())
-        Utils.exec(execArgs, null)
+    private void doDex(String dexPath, File classZip, def dexOptions) {
+
+        def dexJar = "${project.android.getSdkDirectory()}/build-tools/${project.android.buildToolsVersion}/lib/dx.jar"
+        def task = project.tasks.create("dx" + (classZip.name - ".jar") + varName, JavaExec.class, new Action<JavaExec>() {
+            @Override
+            void execute(JavaExec javaExec) {
+                ArrayList<String> execArgs = new ArrayList()
+                execArgs.add("--dex")
+                if (dexOptions.getJumboMode()) {
+                    execArgs.add("--force-jumbo")
+                }
+                if (dexOptions.getIncremental()) {
+                    execArgs.add("--incremental")
+                    execArgs.add("--no-strict")
+                }
+                execArgs.add("--output=${dexPath}")
+                execArgs.add(classZip.absolutePath)
+                project.logger.info(execArgs.toString())
+                javaExec.setClasspath(project.files(dexJar))
+                javaExec.setMain("com.android.dx.command.Main")
+                javaExec.setArgs(execArgs)
+            }
+        })
+        task.execute()
     }
 
     public static void inject(Project project, def variant) {
         project.logger.info("prepare inject dex transform ")
-        if (!variant.apkVariantData.variantConfiguration.isMultiDexEnabled()) {
+        if (!variant.variantData.variantConfiguration.isMultiDexEnabled()) {
             project.logger.warn("multidex is diable. we will not replace the dex transform.")
             return
         }
@@ -378,12 +385,12 @@ public class ImmutableDexTransform extends Transform {
                             field.setAccessible(true)
                             field.set(task, hookDexTransform)
                             project.logger.warn("transform class after hook: " + task.transform.getClass())
-                            break;
+                            break
                         }
                     }
                 }
             }
-        });
+        })
 
     }
 
@@ -494,14 +501,14 @@ public class ImmutableDexTransform extends Transform {
 
     public static void traversal(ZipFile zipFile, Closure callback) {
         try {
-            Enumeration<? extends ZipEntry> enumeration = zipFile.entries();
+            Enumeration<? extends ZipEntry> enumeration = zipFile.entries()
             while (enumeration.hasMoreElements()) {
-                ZipEntry entry = enumeration.nextElement();
+                ZipEntry entry = enumeration.nextElement()
                 callback.call(entry, zipFile.getInputStream(entry).bytes)
             }
         } catch (IOException e) {
-            e.printStackTrace();
-            Utils.closeQuietly(zipFile);
+            e.printStackTrace()
+            Utils.closeQuietly(zipFile)
         }
     }
 }
diff --git a/tinker-build/tinker-patch-lib/build.gradle b/tinker-build/tinker-patch-lib/build.gradle
index 669e3811..239c258c 100644
--- a/tinker-build/tinker-patch-lib/build.gradle
+++ b/tinker-build/tinker-patch-lib/build.gradle
@@ -9,9 +9,12 @@ group rootProject.ext.GROUP
 dependencies {
     compile fileTree(dir: 'libs', include: ['*.jar'])
     compile project(':tinker-commons')
-    compile group: 'com.tencent.mm', name: 'apk-parser-lib', version: '1.0.0'
+    compile group: 'com.tencent.mm', name: 'apk-parser-lib', version: '1.2.3'
     compile group: 'com.google.guava', name: 'guava', version: '11.0.2'
     compile group: 'org.ow2.asm', name: 'asm', version: '5.0.3'
+    compile group: 'org.smali', name: 'dexlib2', version: '2.1.3'
+
+    compile (group: 'dom4j', name: 'dom4j', version: '1.6.1')
 }
 
 sourceSets {
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
index 29de1521..4ee01229 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/AaptUtil.java
@@ -18,6 +18,7 @@
 
 import com.tencent.tinker.build.aapt.RDotTxtEntry.IdType;
 import com.tencent.tinker.build.aapt.RDotTxtEntry.RType;
+import com.tencent.tinker.commons.util.StreamUtil;
 
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
@@ -80,7 +81,7 @@ public static AaptResourceCollector collectResource(List<String> resourceDirecto
 
     public static AaptResourceCollector collectResource(List<String> resourceDirectoryList, Map<RType, Set<RDotTxtEntry>> rTypeResourceMap) {
         AaptResourceCollector resourceCollector = new AaptResourceCollector(rTypeResourceMap);
-        List<com.tencent.tinker.build.aapt.RDotTxtEntry> references = new ArrayList<com.tencent.tinker.build.aapt.RDotTxtEntry>();
+        List<RDotTxtEntry> references = new ArrayList<>();
         for (String resourceDirectory : resourceDirectoryList) {
             try {
                 collectResources(resourceDirectory, resourceCollector);
@@ -304,7 +305,7 @@ private static void addToResourceCollector(AaptResourceCollector resourceCollect
                 resourceCollector.addResource(RType.STYLEABLE, IdType.INT, String.format("%s_%s", resourceName, attrName), Integer.toString(count++));
 
                 if (!rawAttrName.startsWith("android:")) {
-                    resourceCollector.addIntResourceIfNotPresent(RType.ATTR, attrName);
+                    resourceCollector.addIntResourceIfNotPresent(RType.ATTR, rawAttrName);
                     resourceCollector.addRTypeResourceName(RType.ATTR, rawAttrName, nodeToString(attrNode, true), resourceDirectory);
                 }
             }
@@ -397,10 +398,7 @@ public static void writeRJava(String outputDirectory, String packageName, Map<RT
         } catch (Exception e) {
             throw new AaptUtilException(e);
         } finally {
-            if (writer != null) {
-                writer.flush();
-                writer.close();
-            }
+            StreamUtil.closeQuietly(writer);
         }
     }
 
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/DefaultFileCopyProcessor.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/DefaultFileCopyProcessor.java
index f20d4682..83bd529e 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/DefaultFileCopyProcessor.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/DefaultFileCopyProcessor.java
@@ -16,6 +16,8 @@
 
 package com.tencent.tinker.build.aapt;
 
+import com.tencent.tinker.commons.util.StreamUtil;
+
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
@@ -41,22 +43,19 @@ public boolean copyFileToFileProcess(final String from, final String to, final b
                     toFile = toFile + "_copy";
                 }
                 FileUtil.createFile(toFile);
-                InputStream inputStream = new FileInputStream(fromFile);
-                OutputStream outputStream = new FileOutputStream(toFile);
+                InputStream inputStream = null;
+                OutputStream outputStream = null;
                 try {
+                    inputStream = new FileInputStream(fromFile);
+                    outputStream = new FileOutputStream(toFile);
                     byte[] buffer = new byte[Constant.Capacity.BYTES_PER_KB];
                     int length = -1;
                     while ((length = inputStream.read(buffer, 0, buffer.length)) != -1) {
                         outputStream.write(buffer, 0, length);
-                        outputStream.flush();
                     }
                 } finally {
-                    if (inputStream != null) {
-                        inputStream.close();
-                    }
-                    if (outputStream != null) {
-                        outputStream.close();
-                    }
+                    StreamUtil.closeQuietly(outputStream);
+                    StreamUtil.closeQuietly(inputStream);
                 }
             } else {
                 FileUtil.createDirectory(to);
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/FileUtil.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/FileUtil.java
index ad2b5eb1..1a3db2d6 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/FileUtil.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/FileUtil.java
@@ -16,6 +16,8 @@
 
 package com.tencent.tinker.build.aapt;
 
+import com.tencent.tinker.commons.util.StreamUtil;
+
 import java.io.BufferedReader;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
@@ -292,14 +294,16 @@ private static void copyFileToPath(final String fromFile, final String toPath, f
                     }
                 }
                 if (contains) {
-                    InputStream inputStream = zipFile.getInputStream(zipEntry);
                     String outputFullFilename = outputDirectoryAbsolutePath + Constant.Symbol.SLASH_LEFT + zipEntryName;
                     if (zipEntry.isDirectory()) {
                         createDirectory(outputFullFilename);
                     } else {
+                        InputStream inputStream = null;
                         createFile(outputFullFilename);
-                        OutputStream outputStream = new FileOutputStream(outputFullFilename);
+                        OutputStream outputStream = null;
                         try {
+                            inputStream = zipFile.getInputStream(zipEntry);
+                            outputStream = new FileOutputStream(outputFullFilename);
                             byte[] buffer = new byte[Constant.Capacity.BYTES_PER_KB];
                             int length = -1;
                             while ((length = inputStream.read(buffer, 0, buffer.length)) != -1) {
@@ -307,12 +311,8 @@ private static void copyFileToPath(final String fromFile, final String toPath, f
                                 outputStream.flush();
                             }
                         } finally {
-                            if (inputStream != null) {
-                                inputStream.close();
-                            }
-                            if (outputStream != null) {
-                                outputStream.close();
-                            }
+                            StreamUtil.closeQuietly(outputStream);
+                            StreamUtil.closeQuietly(inputStream);
                         }
                         storeFileList.add(outputFullFilename);
                     }
@@ -321,13 +321,7 @@ private static void copyFileToPath(final String fromFile, final String toPath, f
         } catch (Exception e) {
             throw new FileUtilException(e);
         } finally {
-            try {
-                if (zipFile != null) {
-                    zipFile.close();
-                }
-            } catch (Exception e) {
-                e.printStackTrace();
-            }
+            StreamUtil.closeQuietly(zipFile);
         }
         return storeFileList;
     }
@@ -454,18 +448,8 @@ public static void zip(String outputZipFullFilename, String inputZipFullFilename
         } catch (Exception e) {
             throw new FileUtilException(e);
         } finally {
-            try {
-                if (zipOutputStream != null) {
-                    zipOutputStream.finish();
-                    zipOutputStream.flush();
-                    zipOutputStream.close();
-                }
-                if (zipFile != null) {
-                    zipFile.close();
-                }
-            } catch (Exception e) {
-                throw new FileUtilException(e);
-            }
+            StreamUtil.closeQuietly(zipOutputStream);
+            StreamUtil.closeQuietly(zipFile);
         }
     }
 
@@ -497,13 +481,7 @@ public static void mergeZip(String zipOutputFullFilename, List<String> mergeZipF
         } catch (Exception e) {
             throw new FileUtilException(e);
         } finally {
-            try {
-                if (zipOutputStream != null) {
-                    zipOutputStream.close();
-                }
-            } catch (Exception e) {
-                throw new FileUtilException(e);
-            }
+            StreamUtil.closeQuietly(zipOutputStream);
         }
     }
 
@@ -527,9 +505,7 @@ public static void addZipEntry(ZipOutputStream zipOutputStream, ZipEntry zipEntr
         } catch (ZipException e) {
             // do nothing
         } finally {
-            if (inputStream != null) {
-                inputStream.close();
-            }
+            StreamUtil.closeQuietly(inputStream);
             zipOutputStream.closeEntry();
         }
     }
@@ -549,20 +525,8 @@ public static void addZipEntry(ZipOutputStream zipOutputStream, ZipEntry zipEntr
         } catch (FileNotFoundException e) {
             throw new FileUtilException(e);
         } finally {
-            if (inputStream != null) {
-                try {
-                    inputStream.close();
-                } catch (IOException e) {
-                    throw new FileUtilException(e);
-                }
-            }
-            if (byteArrayOutputStream != null) {
-                try {
-                    byteArrayOutputStream.close();
-                } catch (IOException e) {
-                    throw new FileUtilException(e);
-                }
-            }
+            StreamUtil.closeQuietly(byteArrayOutputStream);
+            StreamUtil.closeQuietly(inputStream);
         }
         return byteArrayOutputStream.toByteArray();
     }
@@ -574,29 +538,18 @@ public static void addZipEntry(ZipOutputStream zipOutputStream, ZipEntry zipEntr
      * @param byteArray
      */
     public static void writeFile(String outputFullFilename, byte[] byteArray) {
-        InputStream inputStream = new ByteArrayInputStream(byteArray);
+        InputStream inputStream = null;
         FileUtil.createFile(outputFullFilename);
         OutputStream outputStream = null;
         try {
+            inputStream = new ByteArrayInputStream(byteArray);
             outputStream = new FileOutputStream(outputFullFilename);
             copyStream(inputStream, outputStream);
         } catch (FileNotFoundException e) {
             throw new FileUtilException(e);
         } finally {
-            if (inputStream != null) {
-                try {
-                    inputStream.close();
-                } catch (IOException e) {
-                    throw new FileUtilException(e);
-                }
-            }
-            if (outputStream != null) {
-                try {
-                    outputStream.close();
-                } catch (IOException e) {
-                    throw new FileUtilException(e);
-                }
-            }
+            StreamUtil.closeQuietly(outputStream);
+            StreamUtil.closeQuietly(inputStream);
         }
     }
 
@@ -640,25 +593,13 @@ public static void mergeFile(String outputFullFilename, List<String> fullFilenam
                     } catch (Exception e) {
                         throw new FileUtilException(e);
                     } finally {
-                        if (inputStream != null) {
-                            try {
-                                inputStream.close();
-                            } catch (IOException e) {
-                                throw new FileUtilException(e);
-                            }
-                        }
+                        StreamUtil.closeQuietly(inputStream);
                     }
                 }
             } catch (Exception e) {
                 throw new FileUtilException(e);
             } finally {
-                if (outputStream != null) {
-                    try {
-                        outputStream.close();
-                    } catch (IOException e) {
-                        throw new FileUtilException(e);
-                    }
-                }
+                StreamUtil.closeQuietly(outputStream);
             }
         }
     }
@@ -873,20 +814,8 @@ public static void differZip(String differentOutputFullFilename, String oldZipFu
         } catch (Exception e) {
             throw new FileUtilException(e);
         } finally {
-            if (newZipFile != null) {
-                try {
-                    newZipFile.close();
-                } catch (IOException e) {
-                    throw new FileUtilException(e);
-                }
-            }
-            if (zipOutputStream != null) {
-                try {
-                    zipOutputStream.finish();
-                } catch (IOException e) {
-                    throw new FileUtilException(e);
-                }
-            }
+            StreamUtil.closeQuietly(zipOutputStream);
+            StreamUtil.closeQuietly(newZipFile);
         }
     }
 
@@ -905,13 +834,7 @@ public static void generateSimpleFile(String templateFullFilename, String output
         } catch (Exception e) {
             throw new FileUtilException(e);
         } finally {
-            if (inputStream != null) {
-                try {
-                    inputStream.close();
-                } catch (IOException e) {
-                    throw new FileUtilException(e);
-                }
-            }
+            StreamUtil.closeQuietly(inputStream);
         }
     }
 
@@ -946,20 +869,8 @@ public static void generateSimpleFile(InputStream templateInputStream, String ou
         } catch (Exception e) {
             throw new FileUtilException(e);
         } finally {
-            if (bufferedReader != null) {
-                try {
-                    bufferedReader.close();
-                } catch (IOException e) {
-                    throw new FileUtilException(e);
-                }
-            }
-            if (outputStream != null) {
-                try {
-                    outputStream.close();
-                } catch (Exception e) {
-                    throw new FileUtilException(e);
-                }
-            }
+            StreamUtil.closeQuietly(outputStream);
+            StreamUtil.closeQuietly(bufferedReader);
         }
     }
 
@@ -1122,13 +1033,7 @@ public static Properties getProperties(String propertiesFullFilename) {
             } catch (Exception e) {
                 throw new FileUtilException(e);
             } finally {
-                if (inputStream != null) {
-                    try {
-                        inputStream.close();
-                    } catch (Exception e) {
-                        throw new FileUtilException(e);
-                    }
-                }
+                StreamUtil.closeQuietly(inputStream);
             }
         }
         return properties;
@@ -1164,14 +1069,7 @@ public static void saveProperties(Properties properties, String outputFullFilena
             } catch (Exception e) {
                 throw new FileUtilException(e);
             } finally {
-                if (outputStream != null) {
-                    try {
-                        outputStream.flush();
-                        outputStream.close();
-                    } catch (Exception e) {
-                        throw new FileUtilException(e);
-                    }
-                }
+                StreamUtil.closeQuietly(outputStream);
             }
         }
     }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/Generator.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/Generator.java
index 452349e3..a1ce7585 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/Generator.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/Generator.java
@@ -16,8 +16,10 @@
 
 package com.tencent.tinker.build.aapt;
 
+import com.tencent.tinker.commons.util.StreamUtil;
+
+import java.io.BufferedInputStream;
 import java.io.FileInputStream;
-import java.io.IOException;
 import java.io.InputStream;
 import java.security.MessageDigest;
 
@@ -35,10 +37,14 @@
     public static String md5File(String fullFilename) {
         String result = null;
         if (fullFilename != null) {
+            InputStream is = null;
             try {
-                result = md5File(new FileInputStream(fullFilename));
+                is = new BufferedInputStream(new FileInputStream(fullFilename));
+                result = md5File(is);
             } catch (Exception e) {
                 throw new RuntimeException(e);
+            } finally {
+                StreamUtil.closeQuietly(is);
             }
         }
         return result;
@@ -64,11 +70,7 @@ public static String md5File(final InputStream inputStream) {
             } catch (Exception e) {
                 e.printStackTrace();
             } finally {
-                try {
-                    inputStream.close();
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
+                StreamUtil.closeQuietly(inputStream);
             }
         }
         return result;
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/JavaXmlUtil.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/JavaXmlUtil.java
index c6400b75..dfefca41 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/JavaXmlUtil.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/JavaXmlUtil.java
@@ -16,10 +16,16 @@
 
 package com.tencent.tinker.build.aapt;
 
+import com.tencent.tinker.commons.util.StreamUtil;
+
 import org.w3c.dom.Document;
+import org.xml.sax.EntityResolver;
+import org.xml.sax.InputSource;
+import org.xml.sax.SAXException;
 
 import java.io.File;
 import java.io.FileOutputStream;
+import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 
@@ -43,6 +49,14 @@ private static DocumentBuilder getDocumentBuilder() {
         DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
         try {
             documentBuilder = documentBuilderFactory.newDocumentBuilder();
+            // Block any external content resolving actions since we don't need them and a report
+            // says these actions may cause security problems.
+            documentBuilder.setEntityResolver(new EntityResolver() {
+                @Override
+                public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException {
+                    return new InputSource();
+                }
+            });
         } catch (Exception e) {
             throw new JavaXmlUtilException(e);
         }
@@ -116,13 +130,7 @@ public static void saveDocument(final Document document, final String outputFull
         } catch (Exception e) {
             throw new JavaXmlUtilException(e);
         } finally {
-            if (outputStream != null) {
-                try {
-                    outputStream.close();
-                } catch (Exception e) {
-                    throw new JavaXmlUtilException(e);
-                }
-            }
+            StreamUtil.closeQuietly(outputStream);
         }
     }
 
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/PatchUtil.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/PatchUtil.java
index 9cd3e3af..baf19107 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/PatchUtil.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/aapt/PatchUtil.java
@@ -18,6 +18,7 @@
 
 import com.tencent.tinker.build.aapt.RDotTxtEntry.IdType;
 import com.tencent.tinker.build.aapt.RDotTxtEntry.RType;
+import com.tencent.tinker.commons.util.StreamUtil;
 
 import java.io.BufferedReader;
 import java.io.File;
@@ -72,13 +73,7 @@
             } catch (Exception e) {
                 e.printStackTrace();
             } finally {
-                if (bufferedReader != null) {
-                    try {
-                        bufferedReader.close();
-                    } catch (Exception e) {
-                        e.printStackTrace();
-                    }
-                }
+                StreamUtil.closeQuietly(bufferedReader);
             }
         }
         return rTypeResourceMap;
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidParser.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidParser.java
index b417847d..167a7490 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidParser.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/apkparser/AndroidParser.java
@@ -17,32 +17,49 @@
 package com.tencent.tinker.build.apkparser;
 
 import com.tencent.tinker.build.patch.Configuration;
-
-import net.dongliu.apk.parser.ApkParser;
-import net.dongliu.apk.parser.bean.ApkMeta;
-import net.dongliu.apk.parser.exception.ParserException;
-import net.dongliu.apk.parser.struct.StringPool;
-import net.dongliu.apk.parser.struct.resource.ResourceTable;
-import net.dongliu.apk.parser.utils.ParseUtils;
+import com.tencent.tinker.commons.util.StreamUtil;
 
 import org.w3c.dom.Document;
 import org.w3c.dom.NamedNodeMap;
 import org.w3c.dom.Node;
 import org.w3c.dom.NodeList;
+import org.xml.sax.EntityResolver;
+import org.xml.sax.InputSource;
+import org.xml.sax.SAXException;
 
+import java.io.BufferedInputStream;
 import java.io.ByteArrayInputStream;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
+import java.io.InputStream;
 import java.nio.ByteBuffer;
 import java.text.ParseException;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
 
 import javax.xml.parsers.DocumentBuilder;
 import javax.xml.parsers.DocumentBuilderFactory;
 
+import tinker.net.dongliu.apk.parser.ApkParser;
+import tinker.net.dongliu.apk.parser.bean.ApkMeta;
+import tinker.net.dongliu.apk.parser.exception.ParserException;
+import tinker.net.dongliu.apk.parser.parser.ApkMetaTranslator;
+import tinker.net.dongliu.apk.parser.parser.BinaryXmlParser;
+import tinker.net.dongliu.apk.parser.parser.CompositeXmlStreamer;
+import tinker.net.dongliu.apk.parser.parser.ResourceTableParser;
+import tinker.net.dongliu.apk.parser.parser.XmlTranslator;
+import tinker.net.dongliu.apk.parser.struct.AndroidConstants;
+import tinker.net.dongliu.apk.parser.struct.ResourceValue;
+import tinker.net.dongliu.apk.parser.struct.StringPool;
+import tinker.net.dongliu.apk.parser.struct.resource.ResourceTable;
+import tinker.net.dongliu.apk.parser.struct.xml.Attribute;
+import tinker.net.dongliu.apk.parser.utils.ParseUtils;
+import tinker.net.dongliu.apk.parser.utils.Utils;
+
 /**
  * Created by zhangshaowen on 16/5/5.
  */
@@ -124,18 +141,73 @@ public static void editResourceTableString(String from, String to, File originFi
         }
 
         //write array to file
-        FileOutputStream fileOutputStream = new FileOutputStream(destFile);
+        FileOutputStream fileOutputStream = null;
         try {
+            fileOutputStream = new FileOutputStream(destFile);
             fileOutputStream.write(array);
         } finally {
-            fileOutputStream.close();
+            StreamUtil.closeQuietly(fileOutputStream);
         }
     }
 
     public static AndroidParser getAndroidManifest(File file) throws IOException, ParseException {
-        ApkParser apkParser = new ApkParser(file);
-        AndroidParser androidManifest = new AndroidParser(apkParser.getApkMeta(), apkParser.getManifestXml());
-        return androidManifest;
+        ZipFile zf = null;
+        try {
+            zf = new ZipFile(file);
+            final ByteBuffer arscData = getZipEntryData(zf, AndroidConstants.RESOURCE_FILE);
+            final ResourceTableParser resTableParser = new ResourceTableParser(arscData);
+            resTableParser.parse();
+            final ResourceTable resTable = resTableParser.getResourceTable();
+
+            final ByteBuffer manifestData = getZipEntryData(zf, AndroidConstants.MANIFEST_FILE);
+            final BinaryXmlParser xmlParser = new BinaryXmlParser(manifestData, resTable);
+            final ApkMetaTranslator metaTranslator = new ApkMetaTranslator();
+            final XmlTranslatorForPatch xmlTranslator = new XmlTranslatorForPatch();
+            final CompositeXmlStreamer compositeStreamer = new CompositeXmlStreamer(metaTranslator, xmlTranslator);
+            xmlParser.setXmlStreamer(compositeStreamer);
+            xmlParser.parse();
+
+            AndroidParser androidManifest = new AndroidParser(metaTranslator.getApkMeta(), xmlTranslator.getXml());
+            return androidManifest;
+        } finally {
+            if (zf != null) {
+                try {
+                    zf.close();
+                } catch (Throwable ignored) {
+                    // Ignored.
+                }
+            }
+        }
+    }
+
+    private static ByteBuffer getZipEntryData(ZipFile zf, String entryPath) throws IOException {
+        final ZipEntry entry = zf.getEntry(entryPath);
+        InputStream is = null;
+        try {
+            is = new BufferedInputStream(zf.getInputStream(entry));
+            final byte[] data = Utils.toByteArray(is);
+            return ByteBuffer.wrap(data);
+        } finally {
+            if (is != null) {
+                try {
+                    is.close();
+                } catch (Throwable ignored) {
+                    // Ignored.
+                }
+            }
+        }
+    }
+
+    private static final class XmlTranslatorForPatch extends XmlTranslator {
+
+        @Override
+        public void onAttribute(Attribute attribute) {
+            final ResourceValue attrVal = attribute.getTypedValue();
+            if (attrVal != null && attrVal instanceof ResourceValue.ReferenceResourceValue) {
+                attribute.setValue(attrVal.toString());
+            }
+            super.onAttribute(attribute);
+        }
     }
 
     private static String getAttribute(NamedNodeMap namedNodeMap, String name) {
@@ -169,6 +241,14 @@ private void parse() throws ParserException {
         Document document;
         try {
             DocumentBuilder builder = builderFactory.newDocumentBuilder();
+            // Block any external content resolving actions since we don't need them and a report
+            // says these actions may cause security problems.
+            builder.setEntityResolver(new EntityResolver() {
+                @Override
+                public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException {
+                    return new InputSource();
+                }
+            });
             document = builder.parse(new ByteArrayInputStream(xml.getBytes("UTF-8")));
             Node manifestNode = document.getElementsByTagName("manifest").item(0);
             NodeList nodes = manifestNode.getChildNodes();
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/builder/PatchBuilder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/builder/PatchBuilder.java
index 7b2e0d3e..cd435ff0 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/builder/PatchBuilder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/builder/PatchBuilder.java
@@ -21,10 +21,13 @@
 import com.tencent.tinker.build.util.FileOperation;
 import com.tencent.tinker.build.util.Logger;
 import com.tencent.tinker.build.util.TypedValue;
+import com.tencent.tinker.commons.util.StreamUtil;
 
+import java.io.BufferedInputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
+import java.io.InputStream;
 import java.security.Key;
 import java.security.KeyStore;
 import java.util.ArrayList;
@@ -84,23 +87,28 @@ public void buildPatch() throws Exception {
     }
 
     private String getSignatureAlgorithm() throws Exception {
-        FileInputStream fileIn = new FileInputStream(config.mSignatureFile);
-        KeyStore keyStore = KeyStore.getInstance("JKS");
-        keyStore.load(fileIn, config.mStorePass.toCharArray());
-        Key key = keyStore.getKey(config.mStoreAlias, config.mKeyPass.toCharArray());
-        String keyAlgorithm = key.getAlgorithm();
-        String signatureAlgorithm;
-        if (keyAlgorithm.equalsIgnoreCase("DSA")) {
-            signatureAlgorithm = "SHA1withDSA";
-        } else if (keyAlgorithm.equalsIgnoreCase("RSA")) {
-            signatureAlgorithm = "SHA1withRSA";
-        } else if (keyAlgorithm.equalsIgnoreCase("EC")) {
-            signatureAlgorithm = "SHA1withECDSA";
-        } else {
-            throw new RuntimeException("private key is not a DSA or "
-                    + "RSA key");
+        InputStream is = null;
+        try {
+            is = new BufferedInputStream(new FileInputStream(config.mSignatureFile));
+            KeyStore keyStore = KeyStore.getInstance("JKS");
+            keyStore.load(is, config.mStorePass.toCharArray());
+            Key key = keyStore.getKey(config.mStoreAlias, config.mKeyPass.toCharArray());
+            String keyAlgorithm = key.getAlgorithm();
+            String signatureAlgorithm;
+            if (keyAlgorithm.equalsIgnoreCase("DSA")) {
+                signatureAlgorithm = "SHA1withDSA";
+            } else if (keyAlgorithm.equalsIgnoreCase("RSA")) {
+                signatureAlgorithm = "SHA1withRSA";
+            } else if (keyAlgorithm.equalsIgnoreCase("EC")) {
+                signatureAlgorithm = "SHA1withECDSA";
+            } else {
+                throw new RuntimeException("private key is not a DSA or "
+                        + "RSA key");
+            }
+            return signatureAlgorithm;
+        } finally {
+            StreamUtil.closeQuietly(is);
         }
-        return signatureAlgorithm;
     }
 
     /**
@@ -157,7 +165,7 @@ private void generateUnsignedApk(File output) throws IOException {
             throw new IOException(String.format(
                 "Missing patch unzip files, path=%s\n", tempOutDir.getAbsolutePath()));
         }
-        FileOperation.zipInputDir(tempOutDir, output);
+        FileOperation.zipInputDir(tempOutDir, output, null);
 
         if (!output.exists()) {
             throw new IOException(String.format(
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
index 77d4e980..8c78db62 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
@@ -21,10 +21,12 @@
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.DexFormat;
 import com.tencent.tinker.build.dexpatcher.DexPatchGenerator;
+import com.tencent.tinker.build.dexpatcher.util.ChangedClassesDexClassInfoCollector;
 import com.tencent.tinker.build.info.InfoWriter;
 import com.tencent.tinker.build.patch.Configuration;
 import com.tencent.tinker.build.util.DexClassesComparator;
 import com.tencent.tinker.build.util.DexClassesComparator.DexClassInfo;
+import com.tencent.tinker.build.util.DexClassesComparator.DexGroup;
 import com.tencent.tinker.build.util.ExcludedClassModifiedChecker;
 import com.tencent.tinker.build.util.FileOperation;
 import com.tencent.tinker.build.util.Logger;
@@ -35,6 +37,17 @@
 import com.tencent.tinker.commons.dexpatcher.DexPatchApplier;
 import com.tencent.tinker.commons.dexpatcher.DexPatcherLogger.IDexPatcherLogger;
 
+import org.jf.dexlib2.builder.BuilderMutableMethodImplementation;
+import org.jf.dexlib2.dexbacked.DexBackedDexFile;
+import org.jf.dexlib2.iface.DexFile;
+import org.jf.dexlib2.iface.Field;
+import org.jf.dexlib2.iface.Method;
+import org.jf.dexlib2.iface.MethodImplementation;
+import org.jf.dexlib2.writer.builder.BuilderField;
+import org.jf.dexlib2.writer.builder.BuilderMethod;
+import org.jf.dexlib2.writer.builder.DexBuilder;
+import org.jf.dexlib2.writer.io.FileDataStore;
+
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
@@ -53,6 +66,7 @@
  */
 public class DexDiffDecoder extends BaseDecoder {
     private static final String TEST_DEX_NAME = "test.dex";
+    private static final String CHANGED_CLASSES_DEX_NAME = "changed_classes.dex";
 
     private final InfoWriter logWriter;
     private final InfoWriter metaWriter;
@@ -178,11 +192,125 @@ public void onAllPatchesEnd() throws Exception {
             return;
         }
 
-        generatePatchInfoFile();
+        if (config.mIsProtectedApp) {
+            generateChangedClassesDexFile();
+        } else {
+            generatePatchInfoFile();
+        }
 
         addTestDex();
     }
 
+    @SuppressWarnings("NewApi")
+    private void generateChangedClassesDexFile() throws IOException {
+        final String dexMode = config.mDexRaw ? "raw" : "jar";
+        final File dest = new File(config.mTempResultDir + "/" + CHANGED_CLASSES_DEX_NAME);
+
+        Logger.d("\nBuilding changed classes dex: %s, size: %d\n", dest.getAbsolutePath(), dest.length());
+
+        List<File> oldDexList = new ArrayList<>();
+        List<File> newDexList = new ArrayList<>();
+        for (AbstractMap.SimpleEntry<File, File> oldAndNewDexFilePair : oldAndNewDexFilePairList) {
+            File oldDexFile = oldAndNewDexFilePair.getKey();
+            File newDexFile = oldAndNewDexFilePair.getValue();
+            if (oldDexFile != null) {
+                oldDexList.add(oldDexFile);
+            }
+            if (newDexFile != null) {
+                newDexList.add(newDexFile);
+            }
+        }
+
+        DexGroup oldDexGroup = DexGroup.wrap(oldDexList);
+        DexGroup newDexGroup = DexGroup.wrap(newDexList);
+
+        ChangedClassesDexClassInfoCollector collector = new ChangedClassesDexClassInfoCollector();
+        collector.setExcludedClassPatterns(config.mDexLoaderPattern);
+        collector.setLogger(dexPatcherLoggerBridge);
+        collector.setIncludeRefererToRefererAffectedClasses(true);
+
+        Set<DexClassInfo> classInfosInChangedClassesDex = collector.doCollect(oldDexGroup, newDexGroup);
+
+        Set<Dex> owners = new HashSet<>();
+        Map<Dex, Set<String>> ownerToDescOfChangedClassesMap = new HashMap<>();
+        for (DexClassInfo classInfo : classInfosInChangedClassesDex) {
+            owners.add(classInfo.owner);
+            Set<String> descOfChangedClasses = ownerToDescOfChangedClassesMap.get(classInfo.owner);
+            if (descOfChangedClasses == null) {
+                descOfChangedClasses = new HashSet<>();
+                ownerToDescOfChangedClassesMap.put(classInfo.owner, descOfChangedClasses);
+            }
+            descOfChangedClasses.add(classInfo.classDesc);
+        }
+
+        DexBuilder dexBuilder = DexBuilder.makeDexBuilder();
+        for (Dex dex : owners) {
+            Set<String> descOfChangedClassesInCurrDex = ownerToDescOfChangedClassesMap.get(dex);
+            DexFile dexFile = new DexBackedDexFile(org.jf.dexlib2.Opcodes.forApi(20), dex.getBytes());
+            for (org.jf.dexlib2.iface.ClassDef classDef : dexFile.getClasses()) {
+                if (!descOfChangedClassesInCurrDex.contains(classDef.getType())) {
+                    continue;
+                }
+
+                Logger.d("Class %s will be added into changed classes dex ...", classDef.getType());
+
+                List<BuilderField> builderFields = new ArrayList<>();
+                for (Field field : classDef.getFields()) {
+                    final BuilderField builderField = dexBuilder.internField(
+                            field.getDefiningClass(),
+                            field.getName(),
+                            field.getType(),
+                            field.getAccessFlags(),
+                            field.getInitialValue(),
+                            field.getAnnotations()
+                    );
+                    builderFields.add(builderField);
+                }
+                List<BuilderMethod> builderMethods = new ArrayList<>();
+
+                for (Method method : classDef.getMethods()) {
+                    MethodImplementation methodImpl = method.getImplementation();
+                    if (methodImpl != null) {
+                        methodImpl = new BuilderMutableMethodImplementation(dexBuilder, methodImpl);
+                    }
+                    BuilderMethod builderMethod = dexBuilder.internMethod(
+                            method.getDefiningClass(),
+                            method.getName(),
+                            method.getParameters(),
+                            method.getReturnType(),
+                            method.getAccessFlags(),
+                            method.getAnnotations(),
+                            methodImpl
+                    );
+                    builderMethods.add(builderMethod);
+                }
+                dexBuilder.internClassDef(
+                        classDef.getType(),
+                        classDef.getAccessFlags(),
+                        classDef.getSuperclass(),
+                        classDef.getInterfaces(),
+                        classDef.getSourceFile(),
+                        classDef.getAnnotations(),
+                        builderFields,
+                        builderMethods
+                );
+            }
+        }
+
+        // Write constructed changed classes dex to file and record it in meta file.
+        FileDataStore fileDataStore = new FileDataStore(dest);
+        dexBuilder.writeTo(fileDataStore);
+
+        final String md5 = MD5.getMD5(dest);
+
+        String meta = CHANGED_CLASSES_DEX_NAME + "," + "" + "," + md5 + "," + md5 + "," + 0
+                + "," + 0 + "," + 0 + "," + dexMode;
+
+        Logger.d("\nDexDecoder:write changed classes dex meta file data: %s", meta);
+
+        metaWriter.writeLineToInfoFile(meta);
+    }
+
     @SuppressWarnings("NewApi")
     private void generatePatchInfoFile() throws IOException {
         generatePatchedDexInfoFile();
@@ -234,16 +362,11 @@ private void logDexesToDexMeta() throws IOException {
             final String dexName = getRelativeDexName(oldDexFile, newDexFile);
             final RelatedInfo relatedInfo = dexNameToRelatedInfoMap.get(dexName);
             if (!relatedInfo.oldMd5.equals(relatedInfo.newMd5)) {
-                //logToDexMeta(newDexFile, oldDexFile, relatedInfo.dexDiffFile, relatedInfo.newOrFullPatchedMd5, relatedInfo.smallPatchedMd5, relatedInfo.dexDiffMd5);
                 logToDexMeta(newDexFile, oldDexFile, relatedInfo.dexDiffFile, relatedInfo.newOrFullPatchedMd5, relatedInfo.newOrFullPatchedMd5, relatedInfo.dexDiffMd5);
             } else {
                 // For class N dexes, if new dex is the same as old dex, we should log it as 'copy directly'
                 // in dex meta to fix problems in Art environment.
                 if (realClassNDexFiles.contains(oldDexFile)) {
-                    //if (!"0".equals(relatedInfo.smallPatchedMd5)) {
-                    //    logToDexMeta(newDexFile, oldDexFile, null, "0", relatedInfo.smallPatchedMd5, "0");
-                    //}
-
                     // Bugfix: However, if what we would copy directly is main dex, we should do an additional diff operation
                     // so that patch applier would help us remove all loader classes of it in runtime.
                     if (dexName.equals(DexFormat.DEX_IN_JAR_NAME)) {
@@ -352,7 +475,7 @@ private void addTestDex() throws IOException {
         String md5 = MD5.getMD5(is, 1024);
         is.close();
 
-        String meta = TEST_DEX_NAME + "," + "" + "," + md5 + "," + md5 + "," + 0 + "," + 0 + "," + dexMode;
+        String meta = TEST_DEX_NAME + "," + "" + "," + md5 + "," + md5 + "," + 0 + "," + 0 + "," + 0 + "," + dexMode;
 
         File dest = new File(config.mTempResultDir + "/" + TEST_DEX_NAME);
         FileOperation.copyResourceUsingStream(TEST_DEX_NAME, dest);
@@ -542,7 +665,9 @@ protected void logToDexMeta(File newOrFullPatchedFile, File oldFile, File dexDif
                 }
             }
 
-            String meta = fileName + "," + parentRelative + "," + destMd5InDvm + "," + destMd5InArt + "," + dexDiffMd5 + "," + oldCrc + "," + dexMode;
+            String newCrc = FileOperation.getZipEntryCrc(config.mNewApkFile, relative);
+            String meta = fileName + "," + parentRelative + "," + destMd5InDvm + ","
+                + destMd5InArt + "," + dexDiffMd5 + "," + oldCrc + "," + newCrc + "," + dexMode;
 
             Logger.d("DexDecoder:write meta file data: %s", meta);
             metaWriter.writeLineToInfoFile(meta);
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ManifestDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ManifestDecoder.java
index 642b4482..1f1a5bc2 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ManifestDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ManifestDecoder.java
@@ -22,17 +22,46 @@
 import com.tencent.tinker.build.util.Logger;
 import com.tencent.tinker.build.util.TinkerPatchException;
 import com.tencent.tinker.build.util.TypedValue;
+import com.tencent.tinker.build.util.Utils;
 
+import org.dom4j.Attribute;
+import org.dom4j.Document;
+import org.dom4j.DocumentException;
+import org.dom4j.DocumentHelper;
+import org.dom4j.Element;
+import org.dom4j.io.XMLWriter;
+
+import java.io.BufferedOutputStream;
 import java.io.File;
+import java.io.FileOutputStream;
 import java.io.IOException;
+import java.io.OutputStream;
 import java.text.ParseException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
 import java.util.List;
+import java.util.Set;
 
 /**
  * Created by zhangshaowen on 16/4/6.
  */
 
 public class ManifestDecoder extends BaseDecoder {
+    private static final String XML_NODENAME_APPLICATION        = "application";
+    private static final String XML_NODENAME_USES_SDK           = "uses-sdk";
+    private static final String XML_NODEATTR_MIN_SDK_VERSION    = "minSdkVersion";
+    private static final String XML_NODEATTR_TARGET_SDK_VERSION = "targetSdkVersion";
+    private static final String XML_NODEATTR_PACKAGE            = "package";
+    private static final String XML_NODENAME_ACTIVITY           = "activity";
+    private static final String XML_NODENAME_SERVICE            = "service";
+    private static final String XML_NODENAME_RECEIVER           = "receiver";
+    private static final String XML_NODENAME_PROVIDER           = "provider";
+    private static final String XML_NODEATTR_NAME               = "name";
+    private static final String XML_NODEATTR_EXPORTED           = "exported";
+    private static final String XML_NODEATTR_PROCESS            = "process";
+    private static final String XML_NODENAME_INTENTFILTER       = "intent-filter";
 
     public ManifestDecoder(Configuration config) throws IOException {
         super(config);
@@ -40,59 +69,235 @@ public ManifestDecoder(Configuration config) throws IOException {
 
     @Override
     public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatchException {
-        final boolean ignoreWarning = config.mIgnoreWarning;
         try {
             AndroidParser oldAndroidManifest = AndroidParser.getAndroidManifest(oldFile);
             AndroidParser newAndroidManifest = AndroidParser.getAndroidManifest(newFile);
+
             //check minSdkVersion
             int minSdkVersion = Integer.parseInt(oldAndroidManifest.apkMeta.getMinSdkVersion());
 
             if (minSdkVersion < TypedValue.ANDROID_40_API_LEVEL) {
                 if (config.mDexRaw) {
-                    if (ignoreWarning) {
-                        //ignoreWarning, just log
-                        Logger.e("Warning:ignoreWarning is true, but your old apk's minSdkVersion %d is below 14, you should set the dexMode to 'jar', otherwise, it will crash at some time", minSdkVersion);
-                    } else {
-                        Logger.e("Warning:ignoreWarning is false, but your old apk's minSdkVersion %d is below 14, you should set the dexMode to 'jar', otherwise, it will crash at some time", minSdkVersion);
-
-                        throw new TinkerPatchException(
-                            String.format("ignoreWarning is false, but your old apk's minSdkVersion %d is below 14, you should set the dexMode to 'jar', otherwise, it will crash at some time", minSdkVersion)
-                        );
-                    }
+                    final StringBuilder sb = new StringBuilder();
+                    sb.append("your old apk's minSdkVersion ")
+                      .append(minSdkVersion)
+                      .append(" is below 14, you should set the dexMode to 'jar', ")
+                      .append("otherwise, it will crash at some time");
+                    announceWarningOrException(sb.toString());
                 }
             }
 
-            //check whether there is any new Android Component
-            List<String> oldAndroidComponent = oldAndroidManifest.getComponents();
-            List<String> newAndroidComponent = newAndroidManifest.getComponents();
+            final String oldXml = oldAndroidManifest.xml.trim();
+            final String newXml = newAndroidManifest.xml.trim();
+            final boolean isManifestChanged = !oldXml.equals(newXml);
+
+            if (!isManifestChanged) {
+                Logger.d("\nManifest has no changes, skip rest decode works.");
+                return false;
+            }
+
+            // check whether there is any new Android Component and get their names.
+            // so far only Activity increment can pass checking.
+            final Set<String> incActivities = getIncrementActivities(oldAndroidManifest.activities, newAndroidManifest.activities);
+            final Set<String> incServices = getIncrementServices(oldAndroidManifest.services, newAndroidManifest.services);
+            final Set<String> incReceivers = getIncrementReceivers(oldAndroidManifest.receivers, newAndroidManifest.receivers);
+            final Set<String> incProviders = getIncrementProviders(oldAndroidManifest.providers, newAndroidManifest.providers);
+
+            final boolean hasIncComponent = (!incActivities.isEmpty() || !incServices.isEmpty()
+                    || !incProviders.isEmpty() || !incReceivers.isEmpty());
+
+            if (!config.mSupportHotplugComponent && hasIncComponent) {
+                announceWarningOrException("manifest was changed, while hot plug component support mode is disabled. "
+                        + "Such changes will not take effect.");
+            }
+
+            // generate increment manifest.
+            if (hasIncComponent) {
+                final Document newXmlDoc = DocumentHelper.parseText(newAndroidManifest.xml);
+                final Document incXmlDoc = DocumentHelper.createDocument();
+
+                final Element newRootNode = newXmlDoc.getRootElement();
+                final String packageName = newRootNode.attributeValue(XML_NODEATTR_PACKAGE);
+                if (Utils.isNullOrNil(packageName)) {
+                    throw new TinkerPatchException("Unable to find package name from manifest: " + newFile.getAbsolutePath());
+                }
+
+                final Element newAppNode = newRootNode.element(XML_NODENAME_APPLICATION);
+
+                final Element incAppNode = incXmlDoc.addElement(newAppNode.getQName());
+                copyAttributes(newAppNode, incAppNode);
 
-            for (String newComponentName : newAndroidComponent) {
-                boolean found = false;
-                for (String oldComponentName : oldAndroidComponent) {
-                    if (newComponentName.equals(oldComponentName)) {
-                        found = true;
-                        break;
+                if (!incActivities.isEmpty()) {
+                    final List<Element> newActivityNodes = newAppNode.elements(XML_NODENAME_ACTIVITY);
+                    final List<Element> incActivityNodes = getIncrementActivityNodes(packageName, newActivityNodes, incActivities);
+                    for (Element node : incActivityNodes) {
+                        incAppNode.add(node.detach());
                     }
                 }
-                if (!found) {
-                    if (ignoreWarning) {
-                        Logger.e("Warning:ignoreWarning is true, but we found a new AndroidComponent %s, it will crash at some time", newComponentName);
-                    } else {
-                        Logger.e("Warning:ignoreWarning is false, but we found a new AndroidComponent %s, it will crash at some time", newComponentName);
-                        throw new TinkerPatchException(
-                            String.format("ignoreWarning is false, but we found a new AndroidComponent %s, it will crash at some time", newComponentName)
-                        );
+
+                if (!incServices.isEmpty()) {
+                    final List<Element> newServiceNodes = newAppNode.elements(XML_NODENAME_SERVICE);
+                    final List<Element> incServiceNodes = getIncrementServiceNodes(packageName, newServiceNodes, incServices);
+                    for (Element node : incServiceNodes) {
+                        incAppNode.add(node.detach());
                     }
                 }
+
+                if (!incReceivers.isEmpty()) {
+                    final List<Element> newReceiverNodes = newAppNode.elements(XML_NODENAME_RECEIVER);
+                    final List<Element> incReceiverNodes = getIncrementReceiverNodes(packageName, newReceiverNodes, incReceivers);
+                    for (Element node : incReceiverNodes) {
+                        incAppNode.add(node.detach());
+                    }
+                }
+
+                if (!incProviders.isEmpty()) {
+                    final List<Element> newProviderNodes = newAppNode.elements(XML_NODENAME_PROVIDER);
+                    final List<Element> incProviderNodes = getIncrementProviderNodes(packageName, newProviderNodes, incProviders);
+                    for (Element node : incProviderNodes) {
+                        incAppNode.add(node.detach());
+                    }
+                }
+
+                final File incXmlOutput = new File(config.mTempResultDir, TypedValue.INCCOMPONENT_META_FILE);
+                if (!incXmlOutput.exists()) {
+                    incXmlOutput.getParentFile().mkdirs();
+                }
+                OutputStream os = null;
+                try {
+                    os = new BufferedOutputStream(new FileOutputStream(incXmlOutput));
+                    final XMLWriter docWriter = new XMLWriter(os);
+                    docWriter.write(incXmlDoc);
+                    docWriter.close();
+                } finally {
+                    Utils.closeQuietly(os);
+                }
+            }
+
+            if (isManifestChanged && !hasIncComponent) {
+                Logger.d("\nManifest was changed, while there's no any new components added."
+                       + " Make sure if such changes were all you expected.\n");
             }
 
         } catch (ParseException e) {
             e.printStackTrace();
-            throw new TinkerPatchException("parse android manifest error!");
+            throw new TinkerPatchException("Parse android manifest error!");
+        } catch (DocumentException e) {
+            e.printStackTrace();
+            throw new TinkerPatchException("Parse android manifest by dom4j error!");
+        } catch (IOException e) {
+            e.printStackTrace();
+            throw new TinkerPatchException("Failed to generate increment manifest.", e);
         }
+
         return false;
     }
 
+    private Set<String> getIncrementActivities(Collection<String> oldActivities, Collection<String> newActivities) {
+        final Set<String> incNames = new HashSet<>(newActivities);
+        incNames.removeAll(oldActivities);
+        return incNames;
+    }
+
+    private Set<String> getIncrementServices(Collection<String> oldServices, Collection<String> newServices) {
+        final Set<String> incNames = new HashSet<>(newServices);
+        incNames.removeAll(oldServices);
+        if (!incNames.isEmpty()) {
+            announceWarningOrException("found added services: " + incNames.toString()
+                    + "\n currently tinker does not support increase new services, "
+                    + "such these changes would not take effect.");
+        }
+        return incNames;
+    }
+
+    private Set<String> getIncrementReceivers(Collection<String> oldReceivers, Collection<String> newReceivers) {
+        final Set<String> incNames = new HashSet<>(newReceivers);
+        incNames.removeAll(oldReceivers);
+        if (!incNames.isEmpty()) {
+            announceWarningOrException("found added receivers: " + incNames.toString()
+                    + "\n currently tinker does not support increase new receivers, "
+                    + "such these changes would not take effect.");
+        }
+        return incNames;
+    }
+
+    private Set<String> getIncrementProviders(Collection<String> oldProviders, Collection<String> newProviders) {
+        final Set<String> incNames = new HashSet<>(newProviders);
+        incNames.removeAll(oldProviders);
+        if (!incNames.isEmpty()) {
+            announceWarningOrException("found added providers: " + incNames.toString()
+                    + "\n currently tinker does not support increase new providers, "
+                    + "such these changes would not take effect.");
+        }
+        return incNames;
+    }
+
+    private List<Element> getIncrementActivityNodes(String packageName, List<Element> newActivityNodes, Collection<String> incActivities) {
+        final List<Element> result = new ArrayList<>();
+        for (Element newActivityNode : newActivityNodes) {
+            String activityClazzName = newActivityNode.attributeValue(XML_NODEATTR_NAME);
+            if (activityClazzName.charAt(0) == '.') {
+                activityClazzName = packageName + activityClazzName;
+            }
+            if (!incActivities.contains(activityClazzName)) {
+                continue;
+            }
+            final String exportedVal = newActivityNode.attributeValue(XML_NODEATTR_EXPORTED,
+                    Utils.isNullOrNil(newActivityNode.elements(XML_NODENAME_INTENTFILTER)) ? "false" : "true");
+            if ("true".equalsIgnoreCase(exportedVal)) {
+                announceWarningOrException(
+                        String.format("found a new exported activity %s"
+                                + ", tinker does not support increase exported activity.", activityClazzName)
+                );
+            }
+            final String processVal = newActivityNode.attributeValue(XML_NODEATTR_PROCESS);
+            if (processVal != null && processVal.charAt(0) == ':') {
+                announceWarningOrException(
+                        String.format("found a new activity %s which would be run in standalone process"
+                                + ", tinker does not support increase such kind of activities.", activityClazzName)
+                );
+            }
+
+            Logger.d("Found increment activity: " + activityClazzName);
+
+            result.add(newActivityNode);
+        }
+        return result;
+    }
+
+    private List<Element> getIncrementServiceNodes(String packageName, List<Element> newServiceNodes, Collection<String> incServices) {
+        announceWarningOrException("currently tinker does not support increase new services.");
+        return Collections.emptyList();
+    }
+
+    private List<Element> getIncrementReceiverNodes(String packageName, List<Element> newReceiverNodes, Collection<String> incReceivers) {
+        announceWarningOrException("currently tinker does not support increase new receivers.");
+        return Collections.emptyList();
+    }
+
+    private List<Element> getIncrementProviderNodes(String packageName, List<Element> newProviderNodes, Collection<String> incProviders) {
+        announceWarningOrException("currently tinker does not support increase new providers.");
+        return Collections.emptyList();
+    }
+
+    private void copyAttributes(Element srcNode, Element destNode) {
+        for (Object attrObj : srcNode.attributes()) {
+            final Attribute attr = (Attribute) attrObj;
+            destNode.addAttribute(attr.getQName(), attr.getValue());
+        }
+    }
+
+    private void announceWarningOrException(String message) {
+        if (config.mIgnoreWarning) {
+            final String msg = "Warning:ignoreWarning is true, but " + message;
+            Logger.e(msg);
+        } else {
+            final String msg = "Warning:ignoreWarning is false, " + message;
+            Logger.e(msg);
+            throw new TinkerPatchException(msg);
+        }
+    }
+
     @Override
     public void onAllPatchesStart() throws IOException, TinkerPatchException {
 
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java
index d5c82b75..872f3a3b 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java
@@ -37,6 +37,8 @@
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
 
 /**
  * Created by zhangshaowen on 16/8/8.
@@ -45,15 +47,16 @@
     private static final String TEST_RESOURCE_NAME        = "only_use_to_test_tinker_resource.txt";
     private static final String TEST_RESOURCE_ASSETS_PATH = "assets/" + TEST_RESOURCE_NAME;
 
-    private static final String TEMP_RES_ZIP  = "temp_res.zip";
-    private static final String TEMP_RES_7ZIP = "temp_res_7ZIP.zip";
-    private final InfoWriter                     logWriter;
-    private final InfoWriter                     metaWriter;
-    private       ArrayList<String>              addedSet;
-    private       ArrayList<String>              modifiedSet;
-    private       ArrayList<String>              largeModifiedSet;
-    private       HashMap<String, LargeModeInfo> largeModifiedMap;
-    private ArrayList<String> deletedSet;
+    private static final String TEMP_RES_ZIP = "temp_res.zip";
+    private final InfoWriter        logWriter;
+    private final InfoWriter        metaWriter;
+    private       ArrayList<String> addedSet;
+    private       ArrayList<String> modifiedSet;
+    private       ArrayList<String> storedSet;
+
+    private ArrayList<String>              largeModifiedSet;
+    private HashMap<String, LargeModeInfo> largeModifiedMap;
+    private ArrayList<String>              deletedSet;
 
     public ResDiffDecoder(Configuration config, String metaPath, String logPath) throws IOException {
         super(config);
@@ -74,6 +77,7 @@ public ResDiffDecoder(Configuration config, String metaPath, String logPath) thr
         largeModifiedSet = new ArrayList<>();
         largeModifiedMap = new HashMap<>();
         deletedSet = new ArrayList<>();
+        storedSet = new ArrayList<>();
     }
 
     @Override
@@ -82,6 +86,12 @@ public void clean() {
         logWriter.close();
     }
 
+    /**
+     * last modify or store files
+     *
+     * @param file
+     * @return
+     */
     private boolean checkLargeModFile(File file) {
         long length = file.length();
         if (length > config.mLargeModSize * TypedValue.K_BYTES) {
@@ -144,11 +154,11 @@ public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatch
                 return false;
             }
         }
-        dealWithModeFile(name, newMd5, oldFile, newFile, outputFile);
+        dealWithModifyFile(name, newMd5, oldFile, newFile, outputFile);
         return true;
     }
 
-    private boolean dealWithModeFile(String name, String newMd5, File oldFile, File newFile, File outputFile) throws IOException {
+    private boolean dealWithModifyFile(String name, String newMd5, File oldFile, File newFile, File outputFile) throws IOException {
         if (checkLargeModFile(newFile)) {
             if (!outputFile.getParentFile().exists()) {
                 outputFile.getParentFile().mkdirs();
@@ -279,7 +289,7 @@ public void onAllPatchesEnd() throws IOException, TinkerPatchException {
         final File tempResFiles = config.mTempResultDir;
 
         //gen zip resources_out.zip
-        FileOperation.zipInputDir(tempResFiles, tempResZip);
+        FileOperation.zipInputDir(tempResFiles, tempResZip, null);
         File extractToZip = new File(config.mOutFolder + File.separator + TypedValue.RES_OUT);
 
         String resZipMd5 = Utils.genResOutputFile(extractToZip, tempResZip, config,
@@ -292,25 +302,6 @@ public void onAllPatchesEnd() throws IOException, TinkerPatchException {
         //delete temp file
         FileOperation.deleteFile(tempResZip);
 
-        //gen zip resources_out_7z.zip
-        File extractTo7Zip = new File(config.mOutFolder + File.separator + TypedValue.RES_OUT_7ZIP);
-        File tempRes7Zip = new File(config.mOutFolder + File.separator + TEMP_RES_7ZIP);
-
-        //ensure 7zip is enable
-        if (FileOperation.sevenZipInputDir(tempResFiles, tempRes7Zip, config)) {
-            //7zip whether actual exist
-            if (tempRes7Zip.exists()) {
-
-                String res7zipMd5 = Utils.genResOutputFile(extractTo7Zip, tempRes7Zip, config,
-                    addedSet, modifiedSet, deletedSet, largeModifiedSet, largeModifiedMap);
-                //delete temp file
-                FileOperation.deleteFile(tempRes7Zip);
-                Logger.e("Final 7zip resource: %s, size=%d, md5=%s", extractTo7Zip.getName(), extractTo7Zip.length(), res7zipMd5);
-                logWriter.writeLineToInfoFile(
-                    String.format("Final 7zip resource: %s, size=%d, md5=%s", extractTo7Zip.getName(), extractTo7Zip.length(), res7zipMd5)
-                );
-            }
-        }
         //first, write resource meta first
         //use resources.arsc's base crc to identify base.apk
         String arscBaseCrc = FileOperation.getZipEntryCrc(config.mOldApkFile, TypedValue.RES_ARSC);
@@ -333,11 +324,45 @@ public void onAllPatchesEnd() throws IOException, TinkerPatchException {
         for (String item : patterns) {
             writeMetaFile(item);
         }
+
+        //add store files
+        getCompressMethodFromApk();
+
         //write meta file, write large modify first
         writeMetaFile(largeModifiedSet, TypedValue.LARGE_MOD);
         writeMetaFile(modifiedSet, TypedValue.MOD);
         writeMetaFile(addedSet, TypedValue.ADD);
         writeMetaFile(deletedSet, TypedValue.DEL);
+        writeMetaFile(storedSet, TypedValue.STORED);
+
+    }
+
+    private void getCompressMethodFromApk() {
+        ZipFile zipFile = null;
+        try {
+            zipFile = new ZipFile(config.mNewApkFile);
+            ArrayList<String> sets = new ArrayList<>();
+            sets.addAll(modifiedSet);
+            sets.addAll(addedSet);
+
+            ZipEntry zipEntry;
+            for (String name : sets) {
+                zipEntry = zipFile.getEntry(name);
+                if (zipEntry != null && zipEntry.getMethod() == ZipEntry.STORED) {
+                    storedSet.add(name);
+                }
+            }
+
+        } catch (Throwable throwable) {
+
+        } finally {
+            if (zipFile != null) {
+                try {
+                    zipFile.close();
+                } catch (IOException e) {
+                }
+            }
+        }
     }
 
     private void removeIgnoreChangeFile(ArrayList<String> array) {
@@ -371,6 +396,9 @@ private void writeMetaFile(ArrayList<String> set, int mode) {
                 case TypedValue.DEL:
                     title = TypedValue.DEL_TITLE + set.size();
                     break;
+                case TypedValue.STORED:
+                    title = TypedValue.STORE_TITLE + set.size();
+                    break;
             }
             metaWriter.writeLineToInfoFile(title);
             for (String name : set) {
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/DexPatchGenerator.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/DexPatchGenerator.java
index ce25e7e4..03fff09d 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/DexPatchGenerator.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/DexPatchGenerator.java
@@ -33,7 +33,6 @@
 import com.tencent.tinker.android.dex.StringData;
 import com.tencent.tinker.android.dex.TypeList;
 import com.tencent.tinker.android.dex.io.DexDataBuffer;
-import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 import com.tencent.tinker.build.dexpatcher.algorithms.diff.AnnotationSectionDiffAlgorithm;
 import com.tencent.tinker.build.dexpatcher.algorithms.diff.AnnotationSetRefListSectionDiffAlgorithm;
 import com.tencent.tinker.build.dexpatcher.algorithms.diff.AnnotationSetSectionDiffAlgorithm;
@@ -54,6 +53,8 @@
 import com.tencent.tinker.commons.dexpatcher.DexPatcherLogger;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
 import com.tencent.tinker.commons.dexpatcher.struct.PatchOperation;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
+import com.tencent.tinker.commons.util.StreamUtil;
 
 import java.io.BufferedOutputStream;
 import java.io.File;
@@ -278,13 +279,7 @@ public void executeAndSaveTo(File file) throws IOException {
             os = new BufferedOutputStream(new FileOutputStream(file));
             executeAndSaveTo(os);
         } finally {
-            if (os != null) {
-                try {
-                    os.close();
-                } catch (Exception e) {
-                    // ignored.
-                }
-            }
+            StreamUtil.closeQuietly(os);
         }
     }
 
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/ChangedClassesDexClassInfoCollector.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/ChangedClassesDexClassInfoCollector.java
new file mode 100644
index 00000000..6fb11914
--- /dev/null
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/dexpatcher/util/ChangedClassesDexClassInfoCollector.java
@@ -0,0 +1,252 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.build.dexpatcher.util;
+
+import com.tencent.tinker.android.dex.ClassData;
+import com.tencent.tinker.android.dex.ClassDef;
+import com.tencent.tinker.android.dex.Code;
+import com.tencent.tinker.android.dex.Dex;
+import com.tencent.tinker.android.dex.FieldId;
+import com.tencent.tinker.android.dex.MethodId;
+import com.tencent.tinker.android.dex.ProtoId;
+import com.tencent.tinker.android.dx.instruction.InstructionCodec;
+import com.tencent.tinker.android.dx.instruction.InstructionReader;
+import com.tencent.tinker.android.dx.instruction.InstructionVisitor;
+import com.tencent.tinker.android.dx.instruction.ShortArrayCodeInput;
+import com.tencent.tinker.build.util.DexClassesComparator;
+import com.tencent.tinker.commons.dexpatcher.DexPatcherLogger;
+
+import java.io.EOFException;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Set;
+
+import static com.tencent.tinker.build.util.DexClassesComparator.DexClassInfo;
+import static com.tencent.tinker.build.util.DexClassesComparator.DexGroup;
+
+/**
+ * Created by tangyinsheng on 2017/2/26.
+ */
+
+public class ChangedClassesDexClassInfoCollector {
+    private static final String TAG = "ChangedClassesDexClassInfoCollector";
+
+    private static final DexPatcherLogger logger = new DexPatcherLogger();
+    private final Set<String> excludedClassPatterns = new HashSet<>();
+    private boolean includeRefererToRefererAffectedClasses = false;
+
+    public ChangedClassesDexClassInfoCollector setExcludedClassPatterns(Collection<String> loaderClassPatterns) {
+        this.excludedClassPatterns.clear();
+        this.excludedClassPatterns.addAll(loaderClassPatterns);
+        return this;
+    }
+
+    public ChangedClassesDexClassInfoCollector clearExcludedClassPatterns() {
+        this.excludedClassPatterns.clear();
+        return this;
+    }
+
+    public ChangedClassesDexClassInfoCollector setLogger(DexPatcherLogger.IDexPatcherLogger loggerImpl) {
+        logger.setLoggerImpl(loggerImpl);
+        return this;
+    }
+
+    public ChangedClassesDexClassInfoCollector setIncludeRefererToRefererAffectedClasses(boolean enabled) {
+        this.includeRefererToRefererAffectedClasses = enabled;
+        return this;
+    }
+
+    public Set<DexClassInfo> doCollect(DexGroup oldDexGroup, DexGroup newDexGroup) {
+        final Set<String> classDescsInResult = new HashSet<>();
+        final Set<DexClassInfo> result = new HashSet<>();
+
+        DexClassesComparator dexClassCmptor = new DexClassesComparator("*");
+        dexClassCmptor.setCompareMode(DexClassesComparator.COMPARE_MODE_NORMAL);
+        dexClassCmptor.setIgnoredRemovedClassDescPattern(excludedClassPatterns);
+        dexClassCmptor.setLogger(logger.getLoggerImpl());
+        dexClassCmptor.startCheck(oldDexGroup, newDexGroup);
+
+        // So far we collected infos of all added, changed, and deleted classes.
+        result.addAll(dexClassCmptor.getAddedClassInfos());
+
+        final Collection<DexClassInfo[]> changedClassInfos = dexClassCmptor.getChangedClassDescToInfosMap().values();
+
+        for (DexClassInfo[] oldAndNewInfoPair : changedClassInfos) {
+            final DexClassInfo newClassInfo = oldAndNewInfoPair[1];
+
+            logger.i(TAG, "Add class %s to changed classes dex.", newClassInfo.classDesc);
+            result.add(newClassInfo);
+        }
+
+        for (DexClassInfo classInfo : result) {
+            classDescsInResult.add(classInfo.classDesc);
+        }
+
+        if (includeRefererToRefererAffectedClasses) {
+            // Then we also need to add classes who refer to classes with referrer
+            // affected changes to the result. (referrer affected change means the changes
+            // that may cause referrer refer to wrong target.)
+            dexClassCmptor.setCompareMode(DexClassesComparator.COMPARE_MODE_REFERRER_AFFECTED_CHANGE_ONLY);
+            dexClassCmptor.startCheck(oldDexGroup, newDexGroup);
+
+            Set<String> referrerAffectedChangedClassDescs = dexClassCmptor.getChangedClassDescToInfosMap().keySet();
+            Set<DexClassInfo> oldClassInfos = oldDexGroup.getClassInfosInDexesWithDuplicateCheck();
+
+            for (DexClassInfo oldClassInfo : oldClassInfos) {
+                if (!classDescsInResult.contains(oldClassInfo.classDesc)
+                        && isClassReferToAnyClasses(oldClassInfo, referrerAffectedChangedClassDescs)) {
+                    logger.i(TAG, "Add class %s in old dex to changed classes dex since it is affected by modified referee.", oldClassInfo.classDesc);
+                    result.add(oldClassInfo);
+                }
+            }
+        }
+
+        return result;
+    }
+
+    private boolean isClassReferToAnyClasses(DexClassInfo classInfo, Set<String> refereeClassDescs) {
+        if (classInfo.classDef.classDataOffset == ClassDef.NO_OFFSET) {
+            return false;
+        }
+        ClassData classData = classInfo.owner.readClassData(classInfo.classDef);
+        for (ClassData.Method method : classData.directMethods) {
+            if (isMethodReferToAnyClasses(classInfo, method, refereeClassDescs)) {
+                return true;
+            }
+        }
+        for (ClassData.Method method : classData.virtualMethods) {
+            if (isMethodReferToAnyClasses(classInfo, method, refereeClassDescs)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private boolean isMethodReferToAnyClasses(DexClassInfo classInfo, ClassData.Method method, Set<String> refereeClassDescs) {
+        if (method.codeOffset == ClassDef.NO_OFFSET) {
+            return false;
+        }
+        Code methodCode = classInfo.owner.readCode(method);
+        InstructionReader ir = new InstructionReader(new ShortArrayCodeInput(methodCode.instructions));
+        ReferToClassesCheckVisitor rtcv = new ReferToClassesCheckVisitor(classInfo.owner, method, refereeClassDescs);
+        try {
+            ir.accept(rtcv);
+        } catch (EOFException e) {
+            // Should not be here.
+        }
+        return rtcv.isReferToAnyRefereeClasses;
+    }
+
+    private static class ReferToClassesCheckVisitor extends InstructionVisitor {
+        private final Dex owner;
+        private final ClassData.Method method;
+        private final Collection<String> refereeClassDescs;
+
+        private boolean isReferToAnyRefereeClasses = false;
+
+        ReferToClassesCheckVisitor(Dex owner, ClassData.Method method, Collection<String> refereeClassDescs) {
+            super(null);
+            this.owner = owner;
+            this.method = method;
+            this.refereeClassDescs = refereeClassDescs;
+        }
+
+        @Override
+        public void visitZeroRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal) {
+            processIndexByType(index, indexType);
+        }
+
+        @Override
+        public void visitOneRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a) {
+            processIndexByType(index, indexType);
+        }
+
+        @Override
+        public void visitTwoRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b) {
+            processIndexByType(index, indexType);
+        }
+
+        @Override
+        public void visitThreeRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c) {
+            processIndexByType(index, indexType);
+        }
+
+        @Override
+        public void visitFourRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c, int d) {
+            processIndexByType(index, indexType);
+        }
+
+        @Override
+        public void visitFiveRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c, int d, int e) {
+            processIndexByType(index, indexType);
+        }
+
+        @Override
+        public void visitRegisterRangeInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int registerCount) {
+            processIndexByType(index, indexType);
+        }
+
+        private void processIndexByType(int index, int indexType) {
+            String typeName = null;
+            String refInfoInLog = null;
+            switch (indexType) {
+                case InstructionCodec.INDEX_TYPE_TYPE_REF: {
+                    typeName = owner.typeNames().get(index);
+                    refInfoInLog = "init referrer-affected class";
+                    break;
+                }
+                case InstructionCodec.INDEX_TYPE_FIELD_REF: {
+                    final FieldId fieldId = owner.fieldIds().get(index);
+                    typeName = owner.typeNames().get(fieldId.declaringClassIndex);
+                    refInfoInLog = "referencing to field: " + owner.strings().get(fieldId.nameIndex);
+                    break;
+                }
+                case InstructionCodec.INDEX_TYPE_METHOD_REF: {
+                    final MethodId methodId = owner.methodIds().get(index);
+                    typeName = owner.typeNames().get(methodId.declaringClassIndex);
+                    refInfoInLog = "invoking method: " + getMethodProtoTypeStr(methodId);
+                    break;
+                }
+            }
+            if (typeName != null && refereeClassDescs.contains(typeName)) {
+                MethodId methodId = owner.methodIds().get(method.methodIndex);
+                logger.i(
+                        TAG,
+                        "Method %s in class %s referenced referrer-affected class %s by %s",
+                        getMethodProtoTypeStr(methodId),
+                        owner.typeNames().get(methodId.declaringClassIndex),
+                        typeName,
+                        refInfoInLog
+                );
+                isReferToAnyRefereeClasses = true;
+            }
+        }
+
+        private String getMethodProtoTypeStr(MethodId methodId) {
+            StringBuilder strBuilder = new StringBuilder();
+            strBuilder.append(owner.strings().get(methodId.nameIndex));
+            ProtoId protoId = owner.protoIds().get(methodId.protoIndex);
+            strBuilder.append('(');
+            short[] paramTypeIds = owner.parameterTypeIndicesFromMethodId(methodId);
+            for (short typeId : paramTypeIds) {
+                strBuilder.append(owner.typeNames().get(typeId));
+            }
+            strBuilder.append(')').append(owner.typeNames().get(protoId.returnTypeIndex));
+            return strBuilder.toString();
+        }
+    }
+}
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/info/PatchInfoGen.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/info/PatchInfoGen.java
index 39ad80ef..cd2d4b01 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/info/PatchInfoGen.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/info/PatchInfoGen.java
@@ -20,10 +20,13 @@
 import com.tencent.tinker.build.patch.Configuration;
 import com.tencent.tinker.build.util.TinkerPatchException;
 import com.tencent.tinker.build.util.TypedValue;
+import com.tencent.tinker.commons.util.StreamUtil;
 
+import java.io.BufferedOutputStream;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
+import java.io.OutputStream;
 import java.text.ParseException;
 import java.util.Properties;
 
@@ -69,7 +72,12 @@ public void gen() throws Exception {
         }
 
         String comment = "base package config field";
-        newProperties.store(new FileOutputStream(packageInfoFile, false), comment);
-
+        OutputStream os = null;
+        try {
+            os = new BufferedOutputStream(new FileOutputStream(packageInfoFile, false));
+            newProperties.store(os, comment);
+        } finally {
+            StreamUtil.closeQuietly(os);
+        }
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java
index e61122ff..fe5c30a3 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/Configuration.java
@@ -20,11 +20,13 @@
 import com.tencent.tinker.build.util.TinkerPatchException;
 import com.tencent.tinker.build.util.TypedValue;
 import com.tencent.tinker.build.util.Utils;
+import com.tencent.tinker.commons.util.StreamUtil;
 
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 import org.w3c.dom.Node;
 import org.w3c.dom.NodeList;
+import org.xml.sax.EntityResolver;
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
 
@@ -59,13 +61,15 @@
     protected static final String ATTR_VALUE = "value";
     protected static final String ATTR_NAME  = "name";
 
-    protected static final String ATTR_IGNORE_WARNING    = "ignoreWarning";
-    protected static final String ATTR_USE_SIGN          = "useSign";
-    protected static final String ATTR_SEVEN_ZIP_PATH    = "sevenZipPath";
-    protected static final String ATTR_DEX_MODE          = "dexMode";
-    protected static final String ATTR_PATTERN           = "pattern";
-    protected static final String ATTR_RES_IGNORE_CHANGE = "ignoreChange";
-    protected static final String ATTR_RES_LARGE_MOD     = "largeModSize";
+    protected static final String ATTR_IGNORE_WARNING            = "ignoreWarning";
+    protected static final String ATTR_IS_PROTECTED_APP          = "isProtectedApp";
+    protected static final String ATTR_SUPPORT_HOTPLUG_COMPONENT = "supportHotplugComponent";
+    protected static final String ATTR_USE_SIGN                  = "useSign";
+    protected static final String ATTR_SEVEN_ZIP_PATH            = "sevenZipPath";
+    protected static final String ATTR_DEX_MODE                  = "dexMode";
+    protected static final String ATTR_PATTERN                   = "pattern";
+    protected static final String ATTR_IGNORE_CHANGE             = "ignoreChange";
+    protected static final String ATTR_RES_LARGE_MOD             = "largeModSize";
 
     protected static final String ATTR_LOADER       = "loader";
     protected static final String ATTR_CONFIG_FIELD = "configField";
@@ -77,13 +81,14 @@
     /**
      * base config data
      */
-    public String           mOldApkPath;
-    public String           mNewApkPath;
-    public String           mOutFolder;
-    public File             mOldApkFile;
-    public File             mNewApkFile;
-    public boolean          mIgnoreWarning;
-
+    public String  mOldApkPath;
+    public String  mNewApkPath;
+    public String  mOutFolder;
+    public File    mOldApkFile;
+    public File    mNewApkFile;
+    public boolean mIgnoreWarning;
+    public boolean mIsProtectedApp;
+    public boolean mSupportHotplugComponent;
     /**
      * lib config
      */
@@ -93,6 +98,8 @@
      */
     public HashSet<Pattern> mDexFilePattern;
     public HashSet<String>  mDexLoaderPattern;
+    public HashSet<String>  mDexIgnoreWarningLoaderPattern;
+
     public boolean          mDexRaw;
     /**
      * resource config
@@ -142,6 +149,7 @@ public Configuration(File config, File outputFile, File oldApkFile, File newApkF
         mSoFilePattern = new HashSet<>();
         mDexFilePattern = new HashSet<>();
         mDexLoaderPattern = new HashSet<>();
+        mDexIgnoreWarningLoaderPattern = new HashSet<>();
 
         mResFilePattern = new HashSet<>();
         mResRawPattern = new HashSet<>();
@@ -171,6 +179,7 @@ public Configuration(InputParam param) throws IOException, TinkerPatchException
         mSoFilePattern = new HashSet<>();
         mDexFilePattern = new HashSet<>();
         mDexLoaderPattern = new HashSet<>();
+        mDexIgnoreWarningLoaderPattern = new HashSet<>();
 
         mResFilePattern = new HashSet<>();
         mResRawPattern = new HashSet<>();
@@ -199,7 +208,7 @@ public Configuration(InputParam param) throws IOException, TinkerPatchException
         mUseApplyResource = param.useApplyResource;
 
         mDexLoaderPattern.addAll(param.dexLoaderPattern);
-
+        mDexIgnoreWarningLoaderPattern.addAll(param.dexIgnoreWarningLoaderPattern);
         //can be only raw or jar
         if (param.dexMode.equals("raw")) {
             mDexRaw = true;
@@ -215,6 +224,10 @@ public Configuration(InputParam param) throws IOException, TinkerPatchException
 
         mIgnoreWarning = param.ignoreWarning;
 
+        mIsProtectedApp = param.isProtectedApp;
+
+        mSupportHotplugComponent = param.supportHotplugComponent;
+
         mSevenZipPath = param.sevenZipPath;
         mPackageFields = param.configFields;
 
@@ -236,6 +249,7 @@ public String toString() {
         sb.append("newApk:" + mNewApkPath + "\n");
         sb.append("outputFolder:" + mOutFolder + "\n");
         sb.append("isIgnoreWarning:" + mIgnoreWarning + "\n");
+        sb.append("isProtectedApp:" + mIsProtectedApp + "\n");
         sb.append("7-ZipPath:" + mSevenZipPath + "\n");
         sb.append("useSignAPk:" + mUseSignAPk + "\n");
 
@@ -257,6 +271,9 @@ public String toString() {
         for (String name : mDexLoaderPattern) {
             sb.append("dex loader:" + name + "\n");
         }
+        for (String name : mDexIgnoreWarningLoaderPattern) {
+            sb.append("dex ignore warning loader:" + name.toString() + "\n");
+        }
 
         sb.append("lib configs: \n");
         for (Pattern name : mSoFilePattern) {
@@ -353,6 +370,14 @@ void readXmlConfig(File xmlConfigFile)
             factory.setNamespaceAware(false);
             factory.setValidating(false);
             DocumentBuilder builder = factory.newDocumentBuilder();
+            // Block any external content resolving actions since we don't need them and a report
+            // says these actions may cause security problems.
+            builder.setEntityResolver(new EntityResolver() {
+                @Override
+                public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException {
+                    return new InputSource();
+                }
+            });
             Document document = builder.parse(source);
             NodeList issues = document.getElementsByTagName(TAG_ISSUE);
             for (int i = 0, count = issues.getLength(); i < count; i++) {
@@ -383,13 +408,7 @@ void readXmlConfig(File xmlConfigFile)
                 }
             }
         } finally {
-            if (input != null) {
-                try {
-                    input.close();
-                } catch (IOException e) {
-                    System.exit(-1);
-                }
-            }
+            StreamUtil.closeQuietly(input);
         }
     }
 
@@ -409,6 +428,10 @@ private void readPropertyFromXml(Node node) throws IOException {
                     }
                     if (tagName.equals(ATTR_IGNORE_WARNING)) {
                         mIgnoreWarning = value.equals("true");
+                    } else if (tagName.equals(ATTR_IS_PROTECTED_APP)) {
+                        mIsProtectedApp = value.equals("true");
+                    } else if (tagName.equals(ATTR_SUPPORT_HOTPLUG_COMPONENT)) {
+                        mSupportHotplugComponent = value.equals("true");
                     } else if (tagName.equals(ATTR_USE_SIGN)) {
                         mUseSignAPk = value.equals("true");
                     } else if (tagName.equals(ATTR_SEVEN_ZIP_PATH)) {
@@ -489,6 +512,8 @@ private void readDexPatternsFromXml(Node node) throws IOException {
                         addToPatterns(value, mDexFilePattern);
                     } else if (tagName.equals(ATTR_LOADER)) {
                         mDexLoaderPattern.add(value);
+                    } else if (tagName.equals(ATTR_IGNORE_CHANGE)) {
+                        mDexIgnoreWarningLoaderPattern.add(value);
                     } else {
                         System.err.println("unknown dex tag " + tagName);
                     }
@@ -530,7 +555,7 @@ private void readResPatternsFromXml(Node node) throws IOException {
                     if (tagName.equals(ATTR_PATTERN)) {
                         mResRawPattern.add(value);
                         addToPatterns(value, mResFilePattern);
-                    } else if (tagName.equals(ATTR_RES_IGNORE_CHANGE)) {
+                    } else if (tagName.equals(ATTR_IGNORE_CHANGE)) {
                         addToPatterns(value, mResIgnoreChangePattern);
                     } else if (tagName.equals(ATTR_RES_LARGE_MOD)) {
                         mLargeModSize = Integer.valueOf(value);
@@ -575,5 +600,4 @@ private void addToPatterns(String value, HashSet<Pattern> patterns) throws IOExc
         patterns.add(pattern);
     }
 
-}
-
+}
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java
index e56d4eac..31976019 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/patch/InputParam.java
@@ -35,13 +35,17 @@
     public final String  storealias;
     public final String  storepass;
     public final boolean ignoreWarning;
+    public final boolean isProtectedApp;
+    public final boolean supportHotplugComponent;
     public final boolean useSign;
 
     /**
      * tinkerPatch.dex
      */
-    public final ArrayList<String>       dexFilePattern;
-    public final ArrayList<String>       dexLoaderPattern;
+    public final ArrayList<String> dexFilePattern;
+    public final ArrayList<String> dexLoaderPattern;
+    public final ArrayList<String> dexIgnoreWarningLoaderPattern;
+
     public final String                  dexMode;
     /**
      * tinkerPatch.lib
@@ -81,10 +85,14 @@ private InputParam(
         String storealias,
         String storepass,
         boolean ignoreWarning,
+        boolean isProtectedApp,
+        boolean supportHotplugComponent,
         boolean useSign,
 
         ArrayList<String> dexFilePattern,
         ArrayList<String> dexLoaderPattern,
+        ArrayList<String> dexIgnoreChangeLoaderPattern,
+
         String dexMode,
         ArrayList<String> soFilePattern,
         ArrayList<String> resourceFilePattern,
@@ -103,10 +111,13 @@ private InputParam(
         this.storealias = storealias;
         this.storepass = storepass;
         this.ignoreWarning = ignoreWarning;
+        this.isProtectedApp = isProtectedApp;
+        this.supportHotplugComponent = supportHotplugComponent;
         this.useSign = useSign;
 
         this.dexFilePattern = dexFilePattern;
         this.dexLoaderPattern = dexLoaderPattern;
+        this.dexIgnoreWarningLoaderPattern = dexIgnoreChangeLoaderPattern;
         this.dexMode = dexMode;
 
         this.soFilePattern = soFilePattern;
@@ -132,13 +143,17 @@ private InputParam(
         private String  storealias;
         private String  storepass;
         private boolean ignoreWarning;
+        private boolean isProtectedApp;
+        private boolean isComponentHotplugSupported;
         private boolean useSign;
 
         /**
          * tinkerPatch.dex
          */
-        private ArrayList<String>       dexFilePattern;
-        private ArrayList<String>       dexLoaderPattern;
+        private ArrayList<String> dexFilePattern;
+        private ArrayList<String> dexLoaderPattern;
+        private ArrayList<String> dexIgnoreWarningLoaderPattern;
+
         private String                  dexMode;
         /**
          * tinkerPatch.lib
@@ -243,11 +258,26 @@ public Builder setIgnoreWarning(boolean ignoreWarning) {
             return this;
         }
 
+        public Builder setIsProtectedApp(boolean isProtectedApp) {
+            this.isProtectedApp = isProtectedApp;
+            return this;
+        }
+
+        public Builder setIsComponentHotplugSupported(boolean isComponentHotplugSupported) {
+            this.isComponentHotplugSupported = isComponentHotplugSupported;
+            return this;
+        }
+
         public Builder setDexLoaderPattern(ArrayList<String> dexLoaderPattern) {
             this.dexLoaderPattern = dexLoaderPattern;
             return this;
         }
 
+        public Builder setDexIgnoreWarningLoaderPattern(ArrayList<String> loader) {
+            this.dexIgnoreWarningLoaderPattern = loader;
+            return this;
+        }
+
         public Builder setDexMode(String dexMode) {
             this.dexMode = dexMode;
             return this;
@@ -278,9 +308,12 @@ public InputParam create() {
                     storealias,
                     storepass,
                     ignoreWarning,
+                    isProtectedApp,
+                    isComponentHotplugSupported,
                     useSign,
                     dexFilePattern,
                     dexLoaderPattern,
+                    dexIgnoreWarningLoaderPattern,
                     dexMode,
                     soFilePattern,
                     resourceFilePattern,
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/DexClassesComparator.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/DexClassesComparator.java
index d0c99383..5c2eb055 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/DexClassesComparator.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/DexClassesComparator.java
@@ -57,12 +57,16 @@
  * Created by tangyinsheng on 2016/4/14.
  */
 public final class DexClassesComparator {
-    public static final int COMPARE_MODE_NORMAL = 0;
-    public static final int COMPARE_MODE_CAUSE_REF_CHANGE_ONLY = 1;
     private static final String TAG = "DexClassesComparator";
+
+    public static final int COMPARE_MODE_NORMAL = 0;
+    public static final int COMPARE_MODE_REFERRER_AFFECTED_CHANGE_ONLY = 1;
+
     private static final int DBG_FIRST_SPECIAL = 0x0A;  // the smallest special opcode
     private static final int DBG_LINE_BASE   = -4;      // the smallest line number increment
     private static final int DBG_LINE_RANGE  = 15;      // the number of line increments represented
+
+    private int compareMode = COMPARE_MODE_NORMAL;
     private final List<DexClassInfo> addedClassInfoList = new ArrayList<>();
     private final List<DexClassInfo> deletedClassInfoList = new ArrayList<>();
     // classDesc => [oldClassInfo, newClassInfo]
@@ -73,17 +77,17 @@
     private final Set<String> newDescriptorOfClassesToCheck = new HashSet<>();
     private final Map<String, DexClassInfo> oldClassDescriptorToClassInfoMap = new HashMap<>();
     private final Map<String, DexClassInfo> newClassDescriptorToClassInfoMap = new HashMap<>();
+
     // Record class descriptors whose references key (index or offset) of methods and fields
     // are changed.
     private final Set<String> refAffectedClassDescs = new HashSet<>();
     private final DexPatcherLogger logger = new DexPatcherLogger();
-    private int compareMode = COMPARE_MODE_NORMAL;
 
     public DexClassesComparator(String patternStringOfClassDescToCheck) {
         patternsOfClassDescToCheck.add(
-            Pattern.compile(
-                PatternUtils.dotClassNamePatternToDescriptorRegEx(patternStringOfClassDescToCheck)
-            )
+                Pattern.compile(
+                        PatternUtils.dotClassNamePatternToDescriptorRegEx(patternStringOfClassDescToCheck)
+                )
         );
     }
 
@@ -100,9 +104,9 @@ public DexClassesComparator(String... patternStringsOfClassDescToCheck) {
     public DexClassesComparator(Collection<String> patternStringsOfClassDescToCheck) {
         for (String patternStr : patternStringsOfClassDescToCheck) {
             patternsOfClassDescToCheck.add(
-                Pattern.compile(
-                    PatternUtils.dotClassNamePatternToDescriptorRegEx(patternStr)
-                )
+                    Pattern.compile(
+                            PatternUtils.dotClassNamePatternToDescriptorRegEx(patternStr)
+                    )
             );
         }
     }
@@ -122,15 +126,15 @@ public void setIgnoredRemovedClassDescPattern(Collection<String> patternStringsO
         patternsOfIgnoredRemovedClassDesc.clear();
         for (String patternStr : patternStringsOfLoaderClassDesc) {
             patternsOfIgnoredRemovedClassDesc.add(
-                Pattern.compile(
-                    PatternUtils.dotClassNamePatternToDescriptorRegEx(patternStr)
-                )
+                    Pattern.compile(
+                            PatternUtils.dotClassNamePatternToDescriptorRegEx(patternStr)
+                    )
             );
         }
     }
 
     public void setCompareMode(int mode) {
-        if (mode == COMPARE_MODE_NORMAL || mode == COMPARE_MODE_CAUSE_REF_CHANGE_ONLY) {
+        if (mode == COMPARE_MODE_NORMAL || mode == COMPARE_MODE_REFERRER_AFFECTED_CHANGE_ONLY) {
             this.compareMode = mode;
         } else {
             throw new IllegalArgumentException("bad compare mode: " + mode);
@@ -224,19 +228,22 @@ public void startCheck(DexGroup oldDexGroup, DexGroup newDexGroup) {
             // from result.
             if (Utils.isStringMatchesPatterns(desc, patternsOfIgnoredRemovedClassDesc)) {
                 logger.i(TAG, "Ignored deleted class: %s", desc);
-                continue;
             } else {
                 logger.i(TAG, "Deleted class: %s", desc);
+                deletedClassInfoList.add(oldClassDescriptorToClassInfoMap.get(desc));
             }
-            deletedClassInfoList.add(oldClassDescriptorToClassInfoMap.get(desc));
         }
 
         Set<String> addedClassDescs = new HashSet<>(newDescriptorOfClassesToCheck);
         addedClassDescs.removeAll(oldDescriptorOfClassesToCheck);
 
         for (String desc : addedClassDescs) {
-            logger.i(TAG, "Added class: %s", desc);
-            addedClassInfoList.add(newClassDescriptorToClassInfoMap.get(desc));
+            if (Utils.isStringMatchesPatterns(desc, patternsOfIgnoredRemovedClassDesc)) {
+                logger.i(TAG, "Ignored added class: %s", desc);
+            } else {
+                logger.i(TAG, "Added class: %s", desc);
+                addedClassInfoList.add(newClassDescriptorToClassInfoMap.get(desc));
+            }
         }
 
         Set<String> mayBeChangedClassDescs = new HashSet<>(oldDescriptorOfClassesToCheck);
@@ -253,24 +260,32 @@ public void startCheck(DexGroup oldDexGroup, DexGroup newDexGroup) {
                             oldClassInfo.classDef,
                             newClassInfo.classDef
                     )) {
-                        logger.i(TAG, "Changed class: %s", desc);
-                        changedClassDescToClassInfosMap.put(
-                                desc, new DexClassInfo[]{oldClassInfo, newClassInfo}
-                        );
+                        if (Utils.isStringMatchesPatterns(desc, patternsOfIgnoredRemovedClassDesc)) {
+                            logger.i(TAG, "Ignored changed class: %s", desc);
+                        } else {
+                            logger.i(TAG, "Changed class: %s", desc);
+                            changedClassDescToClassInfosMap.put(
+                                    desc, new DexClassInfo[]{oldClassInfo, newClassInfo}
+                            );
+                        }
                     }
                     break;
                 }
-                case COMPARE_MODE_CAUSE_REF_CHANGE_ONLY: {
-                    if (isClassChangeAffectedToRef(
+                case COMPARE_MODE_REFERRER_AFFECTED_CHANGE_ONLY: {
+                    if (isClassChangeAffectedToReferrer(
                             oldClassInfo.owner,
                             newClassInfo.owner,
                             oldClassInfo.classDef,
                             newClassInfo.classDef
                     )) {
-                        logger.i(TAG, "Ref-changed class: %s", desc);
-                        changedClassDescToClassInfosMap.put(
-                                desc, new DexClassInfo[]{oldClassInfo, newClassInfo}
-                        );
+                        if (Utils.isStringMatchesPatterns(desc, patternsOfIgnoredRemovedClassDesc)) {
+                            logger.i(TAG, "Ignored referrer-affected changed class: %s", desc);
+                        } else {
+                            logger.i(TAG, "Referrer-affected change class: %s", desc);
+                            changedClassDescToClassInfosMap.put(
+                                    desc, new DexClassInfo[]{oldClassInfo, newClassInfo}
+                            );
+                        }
                     }
                     break;
                 }
@@ -278,7 +293,7 @@ public void startCheck(DexGroup oldDexGroup, DexGroup newDexGroup) {
         }
     }
 
-    private boolean isClassChangeAffectedToRef(
+    private boolean isClassChangeAffectedToReferrer(
             Dex oldDex,
             Dex newDex,
             ClassDef oldClassDef,
@@ -295,7 +310,7 @@ private boolean isClassChangeAffectedToRef(
             }
 
             // Any changes on superclass could affect refs of members in current class.
-            if (isTypeChangeAffectedToRef(
+            if (isTypeChangeAffectedToReferrer(
                     oldDex, newDex, oldClassDef.supertypeIndex, newClassDef.supertypeIndex
             )) {
                 result = true;
@@ -306,7 +321,7 @@ private boolean isClassChangeAffectedToRef(
             // of members in current class.
             short[] oldInterfaceTypeIds = oldDex.interfaceTypeIndicesFromClassDef(oldClassDef);
             short[] newInterfaceTypeIds = newDex.interfaceTypeIndicesFromClassDef(newClassDef);
-            if (isTypeIdsChangeAffectedToRef(
+            if (isTypeIdsChangeAffectedToReferrer(
                     oldDex, newDex, oldInterfaceTypeIds, newInterfaceTypeIds, false
             )) {
                 result = true;
@@ -319,7 +334,7 @@ private boolean isClassChangeAffectedToRef(
                     (oldClassDef.classDataOffset != 0 ? oldDex.readClassData(oldClassDef) : null);
             ClassData newClassData =
                     (newClassDef.classDataOffset != 0 ? newDex.readClassData(newClassDef) : null);
-            if (isClassDataChangeAffectedToRef(
+            if (isClassDataChangeAffectedToReferrer(
                     oldDex, newDex, oldClassData, newClassData
             )) {
                 result = true;
@@ -334,7 +349,7 @@ private boolean isClassChangeAffectedToRef(
         return result;
     }
 
-    private boolean isTypeChangeAffectedToRef(
+    private boolean isTypeChangeAffectedToReferrer(
             Dex oldDex, Dex newDex, int oldTypeId, int newTypeId
     ) {
         if (oldTypeId != ClassDef.NO_INDEX && newTypeId != ClassDef.NO_INDEX) {
@@ -349,7 +364,7 @@ private boolean isTypeChangeAffectedToRef(
             ClassDef oldClassDef = (oldClassInfo != null ? oldClassInfo.classDef : null);
             ClassDef newClassDef = (newClassInfo != null ? newClassInfo.classDef : null);
             if (oldClassDef != null && newClassDef != null) {
-                return isClassChangeAffectedToRef(oldClassInfo.owner, newClassInfo.owner, oldClassDef, newClassDef);
+                return isClassChangeAffectedToReferrer(oldClassInfo.owner, newClassInfo.owner, oldClassDef, newClassDef);
             } else
             if (oldClassDef == null && newClassDef == null) {
                 return false;
@@ -366,7 +381,7 @@ private boolean isTypeChangeAffectedToRef(
         return false;
     }
 
-    private boolean isTypeIdsChangeAffectedToRef(
+    private boolean isTypeIdsChangeAffectedToReferrer(
             Dex oldDex,
             Dex newDex,
             short[] oldTypeIds,
@@ -386,7 +401,7 @@ private boolean isTypeIdsChangeAffectedToRef(
                     return true;
                 }
             } else {
-                if (isTypeChangeAffectedToRef(oldDex, newDex, oldTypeIds[i], newTypeIds[i])) {
+                if (isTypeChangeAffectedToReferrer(oldDex, newDex, oldTypeIds[i], newTypeIds[i])) {
                     return true;
                 }
             }
@@ -395,32 +410,32 @@ private boolean isTypeIdsChangeAffectedToRef(
         return false;
     }
 
-    private boolean isClassDataChangeAffectedToRef(
+    private boolean isClassDataChangeAffectedToReferrer(
             Dex oldDex,
             Dex newDex,
             ClassData oldClassData,
             ClassData newClassData
     ) {
         if (oldClassData != null && newClassData != null) {
-            if (isFieldsChangeAffectedToRef(
+            if (isFieldsChangeAffectedToReferrer(
                     oldDex, newDex, oldClassData.instanceFields, newClassData.instanceFields
             )) {
                 return true;
             }
 
-            if (isFieldsChangeAffectedToRef(
+            if (isFieldsChangeAffectedToReferrer(
                     oldDex, newDex, oldClassData.staticFields, newClassData.staticFields
             )) {
                 return true;
             }
 
-            if (isMethodsChangeAffectedToRef(
+            if (isMethodsChangeAffectedToReferrer(
                     oldDex, newDex, oldClassData.directMethods, newClassData.directMethods
             )) {
                 return true;
             }
 
-            if (isMethodsChangeAffectedToRef(
+            if (isMethodsChangeAffectedToReferrer(
                     oldDex, newDex, oldClassData.virtualMethods, newClassData.virtualMethods
             )) {
                 return true;
@@ -433,7 +448,7 @@ private boolean isClassDataChangeAffectedToRef(
         return false;
     }
 
-    private boolean isFieldsChangeAffectedToRef(
+    private boolean isFieldsChangeAffectedToReferrer(
             Dex oldDex,
             Dex newDex,
             Field[] oldFields,
@@ -471,7 +486,7 @@ private boolean isFieldsChangeAffectedToRef(
         return false;
     }
 
-    private boolean isMethodsChangeAffectedToRef(
+    private boolean isMethodsChangeAffectedToReferrer(
             Dex oldDex,
             Dex newDex,
             Method[] oldMethods,
@@ -516,7 +531,7 @@ private boolean isMethodsChangeAffectedToRef(
 
             short[] oldParameterIds = oldDex.parameterTypeIndicesFromMethodId(oldMethodId);
             short[] newParameterIds = newDex.parameterTypeIndicesFromMethodId(newMethodId);
-            if (isTypeIdsChangeAffectedToRef(
+            if (isTypeIdsChangeAffectedToReferrer(
                     oldDex, newDex, oldParameterIds, newParameterIds, true
             )) {
                 return true;
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/ExcludedClassModifiedChecker.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/ExcludedClassModifiedChecker.java
index e87132ff..1ed5a31c 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/ExcludedClassModifiedChecker.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/ExcludedClassModifiedChecker.java
@@ -26,6 +26,8 @@
 import java.io.File;
 import java.io.IOException;
 import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
@@ -45,19 +47,25 @@
     private static final int STMCODE_ERROR_LOADER_CLASS_FOUND_IN_SECONDARY_NEW_DEX = 0x06;
     private static final int STMCODE_ERROR_LOADER_CLASS_CHANGED                    = 0x07;
     private static final int STMCODE_END                                           = 0x08;
-    private final Configuration config;
+    private final Configuration        config;
     private final DexClassesComparator dexCmptor;
-    private Dex oldDex = null;
-    private Dex newDex = null;
-    private List<DexClassInfo> deletedClassInfos = null;
-    private List<DexClassInfo> addedClassInfos = null;
-    private Map<String, DexClassInfo[]> changedClassInfosMap = null;
-    private Set<String> oldClassesDescToCheck = new HashSet<>();
-    private Set<String> newClassesDescToCheck = new HashSet<>();
+    private Dex                         oldDex                = null;
+    private Dex                         newDex                = null;
+    private List<DexClassInfo>          deletedClassInfos     = null;
+    private List<DexClassInfo>          addedClassInfos       = null;
+    private Map<String, DexClassInfo[]> changedClassInfosMap  = null;
+    private Set<String>                 oldClassesDescToCheck = new HashSet<>();
+    private Set<String>                 newClassesDescToCheck = new HashSet<>();
+    private HashSet<Pattern>            ignoreChangeWarning   = new HashSet<>();
 
     public ExcludedClassModifiedChecker(Configuration config) {
         this.config = config;
         this.dexCmptor = new DexClassesComparator(config.mDexLoaderPattern);
+        for (String classname : config.mDexIgnoreWarningLoaderPattern) {
+            ignoreChangeWarning.add(Pattern.compile(
+                PatternUtils.dotClassNamePatternToDescriptorRegEx(classname)
+            ));
+        }
     }
 
     public void checkIfExcludedClassWasModifiedInNewDex(File oldFile, File newFile) throws IOException, TinkerPatchException {
@@ -98,7 +106,7 @@ public void checkIfExcludedClassWasModifiedInNewDex(File oldFile, File newFile)
                             dexCmptor.startCheck(oldDex, newDex);
                             deletedClassInfos = dexCmptor.getDeletedClassInfos();
                             addedClassInfos = dexCmptor.getAddedClassInfos();
-                            changedClassInfosMap = dexCmptor.getChangedClassDescToInfosMap();
+                            changedClassInfosMap = new HashMap<>(dexCmptor.getChangedClassDescToInfosMap());
 
                             // All loader classes are in new dex, while none of them in old one.
                             if (deletedClassInfos.isEmpty() && changedClassInfosMap.isEmpty() && !addedClassInfos.isEmpty()) {
@@ -106,6 +114,14 @@ public void checkIfExcludedClassWasModifiedInNewDex(File oldFile, File newFile)
                             } else {
                                 if (deletedClassInfos.isEmpty() && addedClassInfos.isEmpty()) {
                                     // class descriptor is completely matches, see if any contents changes.
+                                    ArrayList<String> removeClasses = new ArrayList<>();
+                                    for (String classname : changedClassInfosMap.keySet()) {
+                                        if (Utils.checkFileInPattern(ignoreChangeWarning, classname)) {
+                                            Logger.e("loader class pattern: " + classname + " has changed, but it match ignore change pattern, just ignore!");
+                                            removeClasses.add(classname);
+                                        }
+                                    }
+                                    changedClassInfosMap.keySet().removeAll(removeClasses);
                                     if (changedClassInfosMap.isEmpty()) {
                                         stmCode = STMCODE_END;
                                     } else {
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/FileOperation.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/FileOperation.java
index 62fa8630..5df99138 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/FileOperation.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/FileOperation.java
@@ -17,6 +17,7 @@
 package com.tencent.tinker.build.util;
 
 import com.tencent.tinker.build.patch.Configuration;
+import com.tencent.tinker.commons.util.StreamUtil;
 
 import java.io.BufferedInputStream;
 import java.io.BufferedOutputStream;
@@ -86,20 +87,14 @@ public static long getFileSizes(File f) {
         }
         long size = 0;
         if (f.exists() && f.isFile()) {
-            FileInputStream fis = null;
+            InputStream fis = null;
             try {
-                fis = new FileInputStream(f);
+                fis = new BufferedInputStream(new FileInputStream(f));
                 size = fis.available();
             } catch (IOException e) {
                 e.printStackTrace();
             } finally {
-                try {
-                    if (fis != null) {
-                        fis.close();
-                    }
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
+                StreamUtil.closeQuietly(fis);
             }
         }
         return size;
@@ -146,12 +141,8 @@ public static void copyResourceUsingStream(String name, File dest) throws IOExce
                 os.write(buffer, 0, length);
             }
         } finally {
-            if (is != null) {
-                is.close();
-            }
-            if (os != null) {
-                os.close();
-            }
+            StreamUtil.closeQuietly(os);
+            StreamUtil.closeQuietly(is);
         }
     }
 
@@ -172,12 +163,8 @@ public static void copyFileUsingStream(File source, File dest) throws IOExceptio
                 os.write(buffer, 0, length);
             }
         } finally {
-            if (is != null) {
-                is.close();
-            }
-            if (os != null) {
-                os.close();
-            }
+            StreamUtil.closeQuietly(os);
+            StreamUtil.closeQuietly(is);
         }
     }
 
@@ -247,13 +234,16 @@ public static void unZipAPk(String fileName, String filePath) throws IOException
      * @param zipFile     output zip file
      * @throws IOException
      */
-    public static void zipFiles(Collection<File> resFileList, File zipFile) throws IOException {
+    public static void zipFiles(Collection<File> resFileList, File zipFile, String comment) throws IOException {
         ZipOutputStream zipout = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(zipFile), TypedValue.BUFFER_SIZE));
         for (File resFile : resFileList) {
             if (resFile.exists()) {
                 zipFile(resFile, zipout, "");
             }
         }
+        if (comment != null) {
+            zipout.setComment(comment);
+        }
         zipout.close();
     }
 
@@ -290,32 +280,37 @@ private static void zipFile(File resFile, ZipOutputStream zipout, String rootpat
     private static byte[] readContents(final File file) throws IOException {
         final ByteArrayOutputStream output = new ByteArrayOutputStream();
         final int bufferSize = TypedValue.BUFFER_SIZE;
+        InputStream in = null;
         try {
-            final FileInputStream in = new FileInputStream(file);
-            final BufferedInputStream bIn = new BufferedInputStream(in);
+            in = new BufferedInputStream(new FileInputStream(file));
             int length;
             byte[] buffer = new byte[bufferSize];
             byte[] bufferCopy;
-            while ((length = bIn.read(buffer, 0, bufferSize)) != -1) {
+            while ((length = in.read(buffer, 0, bufferSize)) > 0) {
                 bufferCopy = new byte[length];
                 System.arraycopy(buffer, 0, bufferCopy, 0, length);
                 output.write(bufferCopy);
             }
-            bIn.close();
         } finally {
-            output.close();
+            StreamUtil.closeQuietly(output);
+            StreamUtil.closeQuietly(in);
         }
         return output.toByteArray();
     }
 
     public static long getFileCrc32(File file) throws IOException {
-        InputStream inputStream = new FileInputStream(file);
-        CRC32 crc = new CRC32();
-        int cnt;
-        while ((cnt = inputStream.read()) != -1) {
-            crc.update(cnt);
+        InputStream inputStream = null;
+        try {
+            inputStream = new BufferedInputStream(new FileInputStream(file));
+            CRC32 crc = new CRC32();
+            int cnt;
+            while ((cnt = inputStream.read()) != -1) {
+                crc.update(cnt);
+            }
+            return crc.getValue();
+        } finally {
+            StreamUtil.closeQuietly(inputStream);
         }
-        return crc.getValue();
     }
 
     public static String getZipEntryCrc(File file, String entryName) {
@@ -364,14 +359,14 @@ public static String getZipEntryMd5(File file, String entryName) {
         return null;
     }
 
-    public static void zipInputDir(File inputDir, File outputFile) throws IOException {
+    public static void zipInputDir(File inputDir, File outputFile, String comment) throws IOException {
         File[] unzipFiles = inputDir.listFiles();
         List<File> collectFiles = new ArrayList<>();
         for (File f : unzipFiles) {
             collectFiles.add(f);
         }
 
-        FileOperation.zipFiles(collectFiles, outputFile);
+        FileOperation.zipFiles(collectFiles, outputFile, comment);
     }
 
     public static boolean sevenZipInputDir(File inputDir, File outputFile, Configuration config) {
@@ -380,21 +375,32 @@ public static boolean sevenZipInputDir(File inputDir, File outputFile, Configura
         String cmd = config.mSevenZipPath;
 
         ProcessBuilder pb = new ProcessBuilder(cmd, "a", "-tzip", outputFile.getAbsolutePath(), path, "-mx9");
-        Process pro;
+        pb.redirectErrorStream(true);
+        Process pro = null;
+        LineNumberReader reader = null;
         try {
             pro = pb.start();
-            InputStreamReader ir = new InputStreamReader(pro.getInputStream());
-            LineNumberReader input = new LineNumberReader(ir);
-            while (input.readLine() != null) {
+            reader = new LineNumberReader(new InputStreamReader(pro.getInputStream()));
+            while (reader.readLine() != null) {
             }
-            //destroy the stream
-            pro.waitFor();
-            pro.destroy();
-        } catch (IOException | InterruptedException e) {
+        } catch (IOException e) {
 //            e.printStackTrace();
             FileOperation.deleteFile(outputFile);
             Logger.e("7a patch file failed, you should set the zipArtifact, or set the path directly");
             return false;
+        } finally {
+            //destroy the stream
+            try {
+                pro.waitFor();
+            } catch (Throwable ignored) {
+                // Ignored.
+            }
+            try {
+                pro.destroy();
+            } catch (Throwable ignored) {
+                // Ignored.
+            }
+            StreamUtil.closeQuietly(reader);
         }
         return true;
     }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/MD5.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/MD5.java
index a7106ec6..5d1cd965 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/MD5.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/MD5.java
@@ -16,9 +16,10 @@
 
 package com.tencent.tinker.build.util;
 
+import com.tencent.tinker.commons.util.StreamUtil;
+
 import java.io.File;
 import java.io.FileInputStream;
-import java.io.IOException;
 import java.io.InputStream;
 import java.security.MessageDigest;
 
@@ -218,13 +219,7 @@ public static String getMD5(final File file, final int bufLen) {
             return null;
 
         } finally {
-            try {
-                if (fin != null) {
-                    fin.close();
-                }
-            } catch (IOException e) {
-
-            }
+            StreamUtil.closeQuietly(fin);
         }
     }
 
@@ -262,13 +257,7 @@ public static String getMD5(final File file, final int offset, final int length)
             return null;
 
         } finally {
-            try {
-                if (fin != null) {
-                    fin.close();
-                }
-            } catch (IOException e) {
-
-            }
+            StreamUtil.closeQuietly(fin);
         }
     }
 
@@ -288,12 +277,7 @@ public static String getMD5ExtendBytes(final File file, final int offset, final
             return null;
 
         } finally {
-            try {
-                if (fin != null) {
-                    fin.close();
-                }
-            } catch (IOException e) {
-            }
+            StreamUtil.closeQuietly(fin);
         }
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/TypedValue.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/TypedValue.java
index 13120a8d..56413803 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/TypedValue.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/TypedValue.java
@@ -24,19 +24,18 @@
 
     public static final int K_BYTES = 1024;
 
-    public static final String FILE_TXT                 = ".txt";
-    public static final String FILE_XML                 = ".xml";
-    public static final String FILE_APK                 = ".apk";
-    public static final String FILE_CONFIG              = "config.xml";
-    public static final String FILE_LOG                 = "log.txt";
-    public static final String SO_LOG_FILE              = "so_log.txt";
-    public static final String SO_META_FILE             = "so_meta.txt";
-    public static final String DEX_LOG_FILE             = "dex_log.txt";
-    public static final String DEX_META_FILE            = "dex_meta.txt";
-    public static final String DEX_TEMP_PATCH_DIR       = "tempPatchedDexes";
-    public static final String DEX_SMALLPATCH_INFO_FILE = "smallpatch_info.ddextra";
-    public static final String RES_LOG_FILE             = "res_log.txt";
-    public static final String RES_META_TXT             = "res_meta.txt";
+    public static final String FILE_TXT           = ".txt";
+    public static final String FILE_XML           = ".xml";
+    public static final String FILE_APK           = ".apk";
+    public static final String FILE_CONFIG        = "config.xml";
+    public static final String FILE_LOG           = "log.txt";
+    public static final String SO_LOG_FILE        = "so_log.txt";
+    public static final String SO_META_FILE       = "so_meta.txt";
+    public static final String DEX_LOG_FILE       = "dex_log.txt";
+    public static final String DEX_META_FILE      = "dex_meta.txt";
+    public static final String DEX_TEMP_PATCH_DIR = "tempPatchedDexes";
+    public static final String RES_LOG_FILE       = "res_log.txt";
+    public static final String RES_META_TXT       = "res_meta.txt";
 
     public static final String FILE_ASSETS = "assets";
 
@@ -45,6 +44,9 @@
 
     public static final String PACKAGE_META_FILE = "package_meta.txt";
 
+    // Please keep it synchronized with the other one defined in 'EnvConsts' class
+    public static final String INCCOMPONENT_META_FILE = "assets/inc_component_meta.txt";
+
     public static final String PATH_DEFAULT_OUTPUT = "tinkerPatch";
 
     public static final String PATH_PATCH_FILES   = "tinker_result";
@@ -55,23 +57,23 @@
     public static final double DEX_JAR_PATCH_MAX_RATIO = 1.0;
     public static final double BSDIFF_PATCH_MAX_RATIO  = 0.8;
 
-    public static final String RES_ARSC        = "resources.arsc";
-    public static final String RES_MANIFEST    = "AndroidManifest.xml";
-    public static final String RES_OUT         = "resources_out.zip";
-    public static final String RES_OUT_7ZIP    = "resources_out_7z.zip";
+    public static final String RES_ARSC     = "resources.arsc";
+    public static final String RES_MANIFEST = "AndroidManifest.xml";
+    public static final String RES_OUT      = "resources_out.zip";
+    public static final String RES_OUT_7ZIP = "resources_out_7z.zip";
 
     public static final int ADD       = 1;
     public static final int MOD       = 2;
     public static final int DEL       = 3;
     public static final int LARGE_MOD = 4;
+    public static final int STORED    = 5;
+
 
     public static final String ADD_TITLE       = "add:";
     public static final String MOD_TITLE       = "modify:";
     public static final String LARGE_MOD_TITLE = "large modify:";
     public static final String DEL_TITLE       = "delete:";
     public static final String PATTERN_TITLE   = "pattern:";
-
-    public static final String TEST_STRING_VALUE_A = "only use for test tinker resource: a";
-    public static final String TEST_STRING_VALUE_B = "only use for test tinker resource: b";
+    public static final String STORE_TITLE     = "store:";
 
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Utils.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Utils.java
index fabadf31..e0bad90a 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Utils.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Utils.java
@@ -18,10 +18,11 @@
 
 import com.tencent.tinker.build.decoder.ResDiffDecoder;
 import com.tencent.tinker.build.patch.Configuration;
-import com.tencent.tinker.commons.resutil.ResUtil;
-import com.tencent.tinker.commons.ziputil.TinkerZipEntry;
-import com.tencent.tinker.commons.ziputil.TinkerZipFile;
-import com.tencent.tinker.commons.ziputil.TinkerZipOutputStream;
+import com.tencent.tinker.commons.util.StreamUtil;
+import com.tencent.tinker.ziputils.ziputil.TinkerZipUtil;
+import com.tencent.tinker.ziputils.ziputil.TinkerZipEntry;
+import com.tencent.tinker.ziputils.ziputil.TinkerZipFile;
+import com.tencent.tinker.ziputils.ziputil.TinkerZipOutputStream;
 
 import java.io.BufferedOutputStream;
 import java.io.BufferedReader;
@@ -74,6 +75,14 @@ public static String convertToPatternString(String input) {
         return input;
     }
 
+    public static boolean isNullOrNil(final String object) {
+        return (object == null) || (object.length() <= 0);
+    }
+
+    public static boolean isNullOrNil(final Collection<?> collection) {
+        return (collection == null || collection.isEmpty());
+    }
+
     public static boolean isStringMatchesPatterns(String str, Collection<Pattern> patterns) {
         for (Pattern pattern : patterns) {
             if (pattern.matcher(str).matches()) {
@@ -114,11 +123,15 @@ public static boolean checkFileInPattern(HashSet<Pattern> patterns, String key)
     public static String genResOutputFile(File output, File newZipFile, Configuration config,
                                     ArrayList<String> addedSet, ArrayList<String> modifiedSet, ArrayList<String> deletedSet,
                                     ArrayList<String> largeModifiedSet, HashMap<String, ResDiffDecoder.LargeModeInfo> largeModifiedMap) throws IOException {
-        TinkerZipFile oldApk = new TinkerZipFile(config.mOldApkFile);
-        TinkerZipFile newApk = new TinkerZipFile(newZipFile);
-        TinkerZipOutputStream out = new TinkerZipOutputStream(new BufferedOutputStream(new FileOutputStream(output)));
+        TinkerZipFile oldApk = null;
+        TinkerZipFile newApk = null;
+        TinkerZipOutputStream out = null;
 
         try {
+            oldApk = new TinkerZipFile(config.mOldApkFile);
+            newApk = new TinkerZipFile(newZipFile);
+            out = new TinkerZipOutputStream(new BufferedOutputStream(new FileOutputStream(output)));
+
             final Enumeration<? extends TinkerZipEntry> entries = oldApk.entries();
             while (entries.hasMoreElements()) {
                 TinkerZipEntry zipEntry = entries.nextElement();
@@ -137,7 +150,7 @@ public static String genResOutputFile(File output, File newZipFile, Configuratio
                         && !modifiedSet.contains(name)
                         && !largeModifiedSet.contains(name)
                         && !name.equals(TypedValue.RES_MANIFEST)) {
-                        ResUtil.extractTinkerEntry(oldApk, zipEntry, out);
+                        TinkerZipUtil.extractTinkerEntry(oldApk, zipEntry, out);
                     }
                 }
             }
@@ -148,7 +161,7 @@ public static String genResOutputFile(File output, File newZipFile, Configuratio
                     String.format("can't found resource file %s from old apk file %s", TypedValue.RES_MANIFEST, config.mOldApkFile.getAbsolutePath())
                 );
             }
-            ResUtil.extractTinkerEntry(oldApk, manifestZipEntry, out);
+            TinkerZipUtil.extractTinkerEntry(oldApk, manifestZipEntry, out);
 
             for (String name : largeModifiedSet) {
                 TinkerZipEntry largeZipEntry = oldApk.getEntry(name);
@@ -158,7 +171,7 @@ public static String genResOutputFile(File output, File newZipFile, Configuratio
                     );
                 }
                 ResDiffDecoder.LargeModeInfo largeModeInfo = largeModifiedMap.get(name);
-                ResUtil.extractLargeModifyFile(largeZipEntry, largeModeInfo.path, largeModeInfo.crc, out);
+                TinkerZipUtil.extractLargeModifyFile(largeZipEntry, largeModeInfo.path, largeModeInfo.crc, out);
             }
 
             for (String name : addedSet) {
@@ -168,7 +181,7 @@ public static String genResOutputFile(File output, File newZipFile, Configuratio
                         String.format("can't found add resource file %s from new apk file %s", name, config.mNewApkFile.getAbsolutePath())
                     );
                 }
-                ResUtil.extractTinkerEntry(newApk, addZipEntry, out);
+                TinkerZipUtil.extractTinkerEntry(newApk, addZipEntry, out);
             }
 
             for (String name : modifiedSet) {
@@ -178,12 +191,12 @@ public static String genResOutputFile(File output, File newZipFile, Configuratio
                         String.format("can't found add resource file %s from new apk file %s", name, config.mNewApkFile.getAbsolutePath())
                     );
                 }
-                ResUtil.extractTinkerEntry(newApk, modZipEntry, out);
+                TinkerZipUtil.extractTinkerEntry(newApk, modZipEntry, out);
             }
         } finally {
-            out.close();
-            oldApk.close();
-            newApk.close();
+            StreamUtil.closeQuietly(out);
+            StreamUtil.closeQuietly(oldApk);
+            StreamUtil.closeQuietly(newApk);
         }
         return MD5.getMD5(output);
     }
@@ -234,15 +247,24 @@ public static void exec(ArrayList<String> args, File path) throws RuntimeExcepti
             ps.directory(path);
         }
         Process pr = ps.start();
-        BufferedReader ins = new BufferedReader(new InputStreamReader(pr.getInputStream()));
-        String line;
-        while ((line = ins.readLine()) != null) {
-            System.out.println(line);
-        }
-        if (pr.waitFor() != 0) {
-            throw new RuntimeException("exec cmd failed! args: " + args);
+        BufferedReader ins = null;
+        try {
+            ins = new BufferedReader(new InputStreamReader(pr.getInputStream()));
+            String line;
+            while ((line = ins.readLine()) != null) {
+                System.out.println(line);
+            }
+            if (pr.waitFor() != 0) {
+                throw new RuntimeException("exec cmd failed! args: " + args);
+            }
+        } finally {
+            try {
+                pr.destroy();
+            } catch (Throwable ignored) {
+                // Ignored.
+            }
+            StreamUtil.closeQuietly(ins);
         }
-        ins.close();
     }
 
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/org/jf/dexlib2/builder/BuilderMutableMethodImplementation.java b/tinker-build/tinker-patch-lib/src/main/java/org/jf/dexlib2/builder/BuilderMutableMethodImplementation.java
new file mode 100644
index 00000000..71e6168d
--- /dev/null
+++ b/tinker-build/tinker-patch-lib/src/main/java/org/jf/dexlib2/builder/BuilderMutableMethodImplementation.java
@@ -0,0 +1,1141 @@
+/*
+ * Copyright 2013, Google Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer
+ * in the documentation and/or other materials provided with the
+ * distribution.
+ *     * Neither the name of Google Inc. nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * *** This file is NOT a part of DexLib2 project. ***
+ *
+ * Tricky ways for converting MethodImplementation in DexFile into the corresponding
+ * one in DexBuilder.
+ *
+ * If you pass null as DexBuilder, this class behavior the same as
+ * what {@link org.jf.dexlib2.builder.MutableMethodImplementation} would do.
+ */
+
+package org.jf.dexlib2.builder;
+
+import com.google.common.base.Function;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Sets;
+
+import org.jf.dexlib2.DebugItemType;
+import org.jf.dexlib2.Opcode;
+import org.jf.dexlib2.builder.debug.BuilderEndLocal;
+import org.jf.dexlib2.builder.debug.BuilderEpilogueBegin;
+import org.jf.dexlib2.builder.debug.BuilderLineNumber;
+import org.jf.dexlib2.builder.debug.BuilderPrologueEnd;
+import org.jf.dexlib2.builder.debug.BuilderRestartLocal;
+import org.jf.dexlib2.builder.debug.BuilderSetSourceFile;
+import org.jf.dexlib2.builder.debug.BuilderStartLocal;
+import org.jf.dexlib2.builder.instruction.BuilderArrayPayload;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction10t;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction10x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction11n;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction11x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction12x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction20bc;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction20t;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction21c;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction21ih;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction21lh;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction21s;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction21t;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction22b;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction22c;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction22s;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction22t;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction22x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction23x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction25x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction30t;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction31c;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction31i;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction31t;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction32x;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction35c;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction3rc;
+import org.jf.dexlib2.builder.instruction.BuilderInstruction51l;
+import org.jf.dexlib2.builder.instruction.BuilderPackedSwitchPayload;
+import org.jf.dexlib2.builder.instruction.BuilderSparseSwitchPayload;
+import org.jf.dexlib2.iface.ExceptionHandler;
+import org.jf.dexlib2.iface.MethodImplementation;
+import org.jf.dexlib2.iface.TryBlock;
+import org.jf.dexlib2.iface.debug.DebugItem;
+import org.jf.dexlib2.iface.debug.EndLocal;
+import org.jf.dexlib2.iface.debug.LineNumber;
+import org.jf.dexlib2.iface.debug.RestartLocal;
+import org.jf.dexlib2.iface.debug.SetSourceFile;
+import org.jf.dexlib2.iface.debug.StartLocal;
+import org.jf.dexlib2.iface.instruction.Instruction;
+import org.jf.dexlib2.iface.instruction.SwitchElement;
+import org.jf.dexlib2.iface.instruction.formats.ArrayPayload;
+import org.jf.dexlib2.iface.instruction.formats.Instruction10t;
+import org.jf.dexlib2.iface.instruction.formats.Instruction10x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction11n;
+import org.jf.dexlib2.iface.instruction.formats.Instruction11x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction12x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction20bc;
+import org.jf.dexlib2.iface.instruction.formats.Instruction20t;
+import org.jf.dexlib2.iface.instruction.formats.Instruction21c;
+import org.jf.dexlib2.iface.instruction.formats.Instruction21ih;
+import org.jf.dexlib2.iface.instruction.formats.Instruction21lh;
+import org.jf.dexlib2.iface.instruction.formats.Instruction21s;
+import org.jf.dexlib2.iface.instruction.formats.Instruction21t;
+import org.jf.dexlib2.iface.instruction.formats.Instruction22b;
+import org.jf.dexlib2.iface.instruction.formats.Instruction22c;
+import org.jf.dexlib2.iface.instruction.formats.Instruction22s;
+import org.jf.dexlib2.iface.instruction.formats.Instruction22t;
+import org.jf.dexlib2.iface.instruction.formats.Instruction22x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction23x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction25x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction30t;
+import org.jf.dexlib2.iface.instruction.formats.Instruction31c;
+import org.jf.dexlib2.iface.instruction.formats.Instruction31i;
+import org.jf.dexlib2.iface.instruction.formats.Instruction31t;
+import org.jf.dexlib2.iface.instruction.formats.Instruction32x;
+import org.jf.dexlib2.iface.instruction.formats.Instruction35c;
+import org.jf.dexlib2.iface.instruction.formats.Instruction3rc;
+import org.jf.dexlib2.iface.instruction.formats.Instruction51l;
+import org.jf.dexlib2.iface.instruction.formats.PackedSwitchPayload;
+import org.jf.dexlib2.iface.instruction.formats.SparseSwitchPayload;
+import org.jf.dexlib2.iface.reference.Reference;
+import org.jf.dexlib2.iface.reference.StringReference;
+import org.jf.dexlib2.iface.reference.TypeReference;
+import org.jf.dexlib2.writer.builder.DexBuilder;
+import org.jf.util.ExceptionWithContext;
+
+import java.util.AbstractList;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+/**
+ * Created by tangyinsheng on 2017/02/16.
+ */
+public class BuilderMutableMethodImplementation implements MethodImplementation {
+    private final DexBuilder dexBuilder;
+    private final int registerCount;
+    private final ArrayList<MethodLocation> instructionList = Lists.newArrayList(new MethodLocation(null, 0, 0));
+    private final ArrayList<BuilderTryBlock> tryBlocks = Lists.newArrayList();
+    private boolean fixInstructions = true;
+
+    public BuilderMutableMethodImplementation(DexBuilder dexBuilder, @Nonnull MethodImplementation methodImplementation) {
+        this.dexBuilder = dexBuilder;
+
+        this.registerCount = methodImplementation.getRegisterCount();
+
+        int codeAddress = 0;
+        int index = 0;
+
+        for (Instruction instruction : methodImplementation.getInstructions()) {
+            codeAddress += instruction.getCodeUnits();
+            index++;
+
+            instructionList.add(new MethodLocation(null, codeAddress, index));
+        }
+
+        final int[] codeAddressToIndex = new int[codeAddress + 1];
+        Arrays.fill(codeAddressToIndex, -1);
+
+        for (int i = 0; i < instructionList.size(); i++) {
+            codeAddressToIndex[instructionList.get(i).codeAddress] = i;
+        }
+
+        List<Task> switchPayloadTasks = Lists.newArrayList();
+        index = 0;
+        for (final Instruction instruction : methodImplementation.getInstructions()) {
+            final MethodLocation location = instructionList.get(index);
+            final Opcode opcode = instruction.getOpcode();
+            if (opcode == Opcode.PACKED_SWITCH_PAYLOAD || opcode == Opcode.SPARSE_SWITCH_PAYLOAD) {
+                switchPayloadTasks.add(new Task() {
+                    @Override
+                    public void perform() {
+                        convertAndSetInstruction(location, codeAddressToIndex, instruction);
+                    }
+                });
+            } else {
+                convertAndSetInstruction(location, codeAddressToIndex, instruction);
+            }
+            index++;
+        }
+
+        // the switch payload instructions must be converted last, so that any switch statements that refer to them
+        // have created the referring labels that we look for
+        for (Task switchPayloadTask : switchPayloadTasks) {
+            switchPayloadTask.perform();
+        }
+
+        for (DebugItem debugItem : methodImplementation.getDebugItems()) {
+            int debugCodeAddress = debugItem.getCodeAddress();
+            int locationIndex = mapCodeAddressToIndex(codeAddressToIndex, debugCodeAddress);
+            MethodLocation debugLocation = instructionList.get(locationIndex);
+            BuilderDebugItem builderDebugItem = convertDebugItem(debugItem);
+            debugLocation.getDebugItems().add(builderDebugItem);
+            builderDebugItem.location = debugLocation;
+        }
+
+        for (TryBlock<? extends ExceptionHandler> tryBlock : methodImplementation.getTryBlocks()) {
+            Label startLabel = newLabel(codeAddressToIndex, tryBlock.getStartCodeAddress());
+            Label endLabel = newLabel(codeAddressToIndex, tryBlock.getStartCodeAddress() + tryBlock.getCodeUnitCount());
+
+            for (ExceptionHandler exceptionHandler : tryBlock.getExceptionHandlers()) {
+                tryBlocks.add(new BuilderTryBlock(startLabel, endLabel,
+                        (TypeReference) convertReference(exceptionHandler.getExceptionTypeReference()),
+                        newLabel(codeAddressToIndex, exceptionHandler.getHandlerCodeAddress())));
+            }
+        }
+    }
+
+    private interface Task {
+        void perform();
+    }
+
+    public BuilderMutableMethodImplementation(DexBuilder dexBuilder, int registerCount) {
+        this.dexBuilder = dexBuilder;
+        this.registerCount = registerCount;
+    }
+
+    @Override
+    public int getRegisterCount() {
+        return registerCount;
+    }
+
+    @Nonnull
+    public List<BuilderInstruction> getInstructions() {
+        if (fixInstructions) {
+            fixInstructions();
+        }
+
+        return new AbstractList<BuilderInstruction>() {
+            @Override
+            public BuilderInstruction get(int i) {
+                if (i >= size()) {
+                    throw new IndexOutOfBoundsException();
+                }
+                if (fixInstructions) {
+                    fixInstructions();
+                }
+                return instructionList.get(i).instruction;
+            }
+
+            @Override
+            public int size() {
+                if (fixInstructions) {
+                    fixInstructions();
+                }
+                // don't include the last MethodLocation, which always has a null instruction
+                return instructionList.size() - 1;
+            }
+        };
+    }
+
+    @Nonnull
+    @Override
+    public List<BuilderTryBlock> getTryBlocks() {
+        if (fixInstructions) {
+            fixInstructions();
+        }
+        return Collections.unmodifiableList(tryBlocks);
+    }
+
+    @Nonnull
+    @Override
+    public Iterable<? extends DebugItem> getDebugItems() {
+        if (fixInstructions) {
+            fixInstructions();
+        }
+        return Iterables.concat(
+                Iterables.transform(instructionList, new Function<MethodLocation, Iterable<? extends DebugItem>>() {
+                    @Nullable
+                    @Override
+                    public Iterable<? extends DebugItem> apply(@Nullable MethodLocation input) {
+                        assert input != null;
+                        if (fixInstructions) {
+                            throw new IllegalStateException("This iterator was invalidated by a change to"
+                                    + " this MutableMethodImplementation.");
+                        }
+                        return input.getDebugItems();
+                    }
+                }));
+    }
+
+    public void addCatch(@Nullable TypeReference type, @Nonnull Label from,
+                         @Nonnull Label to, @Nonnull Label handler) {
+        tryBlocks.add(new BuilderTryBlock(from, to, type, handler));
+    }
+
+    public void addCatch(@Nullable String type, @Nonnull Label from, @Nonnull Label to,
+                         @Nonnull Label handler) {
+        tryBlocks.add(new BuilderTryBlock(from, to, type, handler));
+    }
+
+    public void addCatch(@Nonnull Label from, @Nonnull Label to, @Nonnull Label handler) {
+        tryBlocks.add(new BuilderTryBlock(from, to, handler));
+    }
+
+    public void addInstruction(int index, BuilderInstruction instruction) {
+        // the end check here is intentially >= rather than >, because the list always includes an "empty"
+        // (null instruction) MethodLocation at the end. To add an instruction to the end of the list, the user would
+        // provide the index of this empty item, which would be size() - 1.
+        if (index >= instructionList.size()) {
+            throw new IndexOutOfBoundsException();
+        }
+
+        if (index == instructionList.size() - 1) {
+            addInstruction(instruction);
+            return;
+        }
+        int codeAddress = instructionList.get(index).getCodeAddress();
+        MethodLocation newLoc = new MethodLocation(instruction, codeAddress, index);
+        instructionList.add(index, newLoc);
+        instruction.location = newLoc;
+
+        codeAddress += instruction.getCodeUnits();
+
+        for (int i = index + 1; i < instructionList.size(); i++) {
+            MethodLocation location = instructionList.get(i);
+            location.index++;
+            location.codeAddress = codeAddress;
+            if (location.instruction != null) {
+                codeAddress += location.instruction.getCodeUnits();
+            } else {
+                // only the last MethodLocation should have a null instruction
+                assert i == instructionList.size() - 1;
+            }
+        }
+
+        this.fixInstructions = true;
+    }
+
+    public void addInstruction(@Nonnull BuilderInstruction instruction) {
+        MethodLocation last = instructionList.get(instructionList.size() - 1);
+        last.instruction = instruction;
+        instruction.location = last;
+
+        int nextCodeAddress = last.codeAddress + instruction.getCodeUnits();
+        instructionList.add(new MethodLocation(null, nextCodeAddress, instructionList.size()));
+
+        this.fixInstructions = true;
+    }
+
+    public void replaceInstruction(int index, @Nonnull BuilderInstruction replacementInstruction) {
+        if (index >= instructionList.size() - 1) {
+            throw new IndexOutOfBoundsException();
+        }
+
+        MethodLocation replaceLocation = instructionList.get(index);
+        replacementInstruction.location = replaceLocation;
+        BuilderInstruction old = replaceLocation.instruction;
+        assert old != null;
+        old.location = null;
+        replaceLocation.instruction = replacementInstruction;
+
+        // TODO: factor out index/address fix up loop
+        int codeAddress = replaceLocation.codeAddress + replaceLocation.instruction.getCodeUnits();
+        for (int i = index + 1; i < instructionList.size(); i++) {
+            MethodLocation location = instructionList.get(i);
+            location.codeAddress = codeAddress;
+
+            Instruction instruction = location.getInstruction();
+            if (instruction != null) {
+                codeAddress += instruction.getCodeUnits();
+            } else {
+                assert i == instructionList.size() - 1;
+            }
+        }
+
+        this.fixInstructions = true;
+    }
+
+    public void removeInstruction(int index) {
+        if (index >= instructionList.size() - 1) {
+            throw new IndexOutOfBoundsException();
+        }
+
+        MethodLocation toRemove = instructionList.get(index);
+        toRemove.instruction = null;
+        MethodLocation next = instructionList.get(index + 1);
+        toRemove.mergeInto(next);
+
+        instructionList.remove(index);
+        int codeAddress = toRemove.codeAddress;
+        for (int i = index; i < instructionList.size(); i++) {
+            MethodLocation location = instructionList.get(i);
+            location.index = i;
+            location.codeAddress = codeAddress;
+
+            Instruction instruction = location.getInstruction();
+            if (instruction != null) {
+                codeAddress += instruction.getCodeUnits();
+            } else {
+                assert i == instructionList.size() - 1;
+            }
+        }
+
+        this.fixInstructions = true;
+    }
+
+    public void swapInstructions(int index1, int index2) {
+        if (index1 >= instructionList.size() - 1 || index2 >= instructionList.size() - 1) {
+            throw new IndexOutOfBoundsException();
+        }
+        MethodLocation first = instructionList.get(index1);
+        MethodLocation second = instructionList.get(index2);
+
+        // only the last MethodLocation may have a null instruction
+        assert first.instruction != null;
+        assert second.instruction != null;
+
+        first.instruction.location = second;
+        second.instruction.location = first;
+
+        {
+            BuilderInstruction tmp = second.instruction;
+            second.instruction = first.instruction;
+            first.instruction = tmp;
+        }
+
+        if (index2 < index1) {
+            int tmp = index2;
+            index2 = index1;
+            index1 = tmp;
+        }
+
+        int codeAddress = first.codeAddress + first.instruction.getCodeUnits();
+        for (int i = index1 + 1; i <= index2; i++) {
+            MethodLocation location = instructionList.get(i);
+            location.codeAddress = codeAddress;
+
+            Instruction instruction = location.instruction;
+            assert instruction != null;
+            codeAddress += location.instruction.getCodeUnits();
+        }
+
+        this.fixInstructions = true;
+    }
+
+    @Nullable
+    private BuilderInstruction getFirstNonNop(int startIndex) {
+
+        for (int i = startIndex; i < instructionList.size() - 1; i++) {
+            BuilderInstruction instruction = instructionList.get(i).instruction;
+            assert instruction != null;
+            if (instruction.getOpcode() != Opcode.NOP) {
+                return instruction;
+            }
+        }
+        return null;
+    }
+
+    private void fixInstructions() {
+        HashSet<MethodLocation> payloadLocations = Sets.newHashSet();
+
+        for (MethodLocation location : instructionList) {
+            BuilderInstruction instruction = location.instruction;
+            if (instruction != null) {
+                switch (instruction.getOpcode()) {
+                    case SPARSE_SWITCH:
+                    case PACKED_SWITCH: {
+                        MethodLocation targetLocation =
+                                ((BuilderOffsetInstruction) instruction).getTarget().getLocation();
+                        BuilderInstruction targetInstruction = targetLocation.instruction;
+                        if (targetInstruction == null) {
+                            throw new IllegalStateException(String.format("Switch instruction at address/index "
+                                    + "0x%x/%d points to the end of the method.", location.codeAddress, location.index));
+                        }
+
+                        if (targetInstruction.getOpcode() == Opcode.NOP) {
+                            targetInstruction = getFirstNonNop(targetLocation.index + 1);
+                        }
+                        if (targetInstruction == null || !(targetInstruction instanceof BuilderSwitchPayload)) {
+                            throw new IllegalStateException(String.format("Switch instruction at address/index "
+                                            + "0x%x/%d does not refer to a payload instruction.",
+                                    location.codeAddress, location.index));
+                        }
+                        if ((instruction.opcode == Opcode.PACKED_SWITCH
+                                && targetInstruction.getOpcode() != Opcode.PACKED_SWITCH_PAYLOAD)
+                                || (instruction.opcode == Opcode.SPARSE_SWITCH
+                                        && targetInstruction.getOpcode() != Opcode.SPARSE_SWITCH_PAYLOAD)) {
+                            throw new IllegalStateException(String.format("Switch instruction at address/index "
+                                            + "0x%x/%d refers to the wrong type of payload instruction.",
+                                    location.codeAddress, location.index));
+                        }
+
+                        if (!payloadLocations.add(targetLocation)) {
+                            throw new IllegalStateException("Multiple switch instructions refer to the same payload. "
+                                    + "This is not currently supported. Please file a bug :)");
+                        }
+
+                        ((BuilderSwitchPayload) targetInstruction).referrer = location;
+                        break;
+                    }
+                }
+            }
+        }
+
+        boolean madeChanges;
+        do {
+            madeChanges = false;
+
+            for (int index = 0; index < instructionList.size(); index++) {
+                MethodLocation location = instructionList.get(index);
+                BuilderInstruction instruction = location.instruction;
+                if (instruction != null) {
+                    switch (instruction.getOpcode()) {
+                        case GOTO: {
+                            int offset = ((BuilderOffsetInstruction) instruction).internalGetCodeOffset();
+                            if (offset < Byte.MIN_VALUE || offset > Byte.MAX_VALUE) {
+                                BuilderOffsetInstruction replacement;
+                                if (offset < Short.MIN_VALUE || offset > Short.MAX_VALUE) {
+                                    replacement = new BuilderInstruction30t(Opcode.GOTO_32,
+                                            ((BuilderOffsetInstruction) instruction).getTarget());
+                                } else {
+                                    replacement = new BuilderInstruction20t(Opcode.GOTO_16,
+                                            ((BuilderOffsetInstruction) instruction).getTarget());
+                                }
+                                replaceInstruction(location.index, replacement);
+                                madeChanges = true;
+                            }
+                            break;
+                        }
+                        case GOTO_16: {
+                            int offset = ((BuilderOffsetInstruction) instruction).internalGetCodeOffset();
+                            if (offset < Short.MIN_VALUE || offset > Short.MAX_VALUE) {
+                                BuilderOffsetInstruction replacement = new BuilderInstruction30t(Opcode.GOTO_32,
+                                        ((BuilderOffsetInstruction) instruction).getTarget());
+                                replaceInstruction(location.index, replacement);
+                                madeChanges = true;
+                            }
+                            break;
+                        }
+                        case SPARSE_SWITCH_PAYLOAD:
+                        case PACKED_SWITCH_PAYLOAD:
+                            if (((BuilderSwitchPayload) instruction).referrer == null) {
+                                // if the switch payload isn't referenced, just remove it
+                                removeInstruction(index);
+                                index--;
+                                madeChanges = true;
+                                break;
+                            }
+                            // intentional fall-through
+                        case ARRAY_PAYLOAD: {
+                            if ((location.codeAddress & 0x01) != 0) {
+                                int previousIndex = location.index - 1;
+                                MethodLocation previousLocation = instructionList.get(previousIndex);
+                                Instruction previousInstruction = previousLocation.instruction;
+                                assert previousInstruction != null;
+                                if (previousInstruction.getOpcode() == Opcode.NOP) {
+                                    removeInstruction(previousIndex);
+                                    index--;
+                                } else {
+                                    addInstruction(location.index, new BuilderInstruction10x(Opcode.NOP));
+                                    index++;
+                                }
+                                madeChanges = true;
+                            }
+                            break;
+                        }
+                    }
+                }
+            }
+        } while (madeChanges);
+
+        fixInstructions = false;
+    }
+
+    private int mapCodeAddressToIndex(@Nonnull int[] codeAddressToIndex, int codeAddress) {
+        int index;
+        do {
+            index = codeAddressToIndex[codeAddress];
+            if (index < 0) {
+                codeAddress--;
+            } else {
+                return index;
+            }
+        } while (true);
+    }
+
+    private int mapCodeAddressToIndex(int codeAddress) {
+        float avgCodeUnitsPerInstruction = 1.9f;
+
+        int index = (int) (codeAddress / avgCodeUnitsPerInstruction);
+        if (index >= instructionList.size()) {
+            index = instructionList.size() - 1;
+        }
+
+        MethodLocation guessedLocation = instructionList.get(index);
+
+        if (guessedLocation.codeAddress == codeAddress) {
+            return index;
+        } else if (guessedLocation.codeAddress > codeAddress) {
+            do {
+                index--;
+            } while (instructionList.get(index).codeAddress > codeAddress);
+            return index;
+        } else {
+            do {
+                index++;
+            }
+            while (index < instructionList.size() && instructionList.get(index).codeAddress <= codeAddress);
+            return index - 1;
+        }
+    }
+
+    @Nonnull
+    public Label newLabelForAddress(int codeAddress) {
+        if (codeAddress < 0 || codeAddress > instructionList.get(instructionList.size() - 1).codeAddress) {
+            throw new IndexOutOfBoundsException(String.format("codeAddress %d out of bounds", codeAddress));
+        }
+        MethodLocation referent = instructionList.get(mapCodeAddressToIndex(codeAddress));
+        return referent.addNewLabel();
+    }
+
+    @Nonnull
+    public Label newLabelForIndex(int instructionIndex) {
+        if (instructionIndex < 0 || instructionIndex >= instructionList.size()) {
+            throw new IndexOutOfBoundsException(String.format("instruction index %d out of bounds", instructionIndex));
+        }
+        MethodLocation referent = instructionList.get(instructionIndex);
+        return referent.addNewLabel();
+    }
+
+    @Nonnull
+    private Label newLabel(@Nonnull int[] codeAddressToIndex, int codeAddress) {
+        MethodLocation referent = instructionList.get(mapCodeAddressToIndex(codeAddressToIndex, codeAddress));
+        return referent.addNewLabel();
+    }
+
+    private static class SwitchPayloadReferenceLabel extends Label {
+        @Nonnull
+        public MethodLocation switchLocation;
+    }
+
+    @Nonnull
+    public Label newSwitchPayloadReferenceLabel(@Nonnull MethodLocation switchLocation,
+                                                @Nonnull int[] codeAddressToIndex, int codeAddress) {
+        MethodLocation referent = instructionList.get(mapCodeAddressToIndex(codeAddressToIndex, codeAddress));
+        SwitchPayloadReferenceLabel label = new SwitchPayloadReferenceLabel();
+        label.switchLocation = switchLocation;
+        referent.getLabels().add(label);
+        return label;
+    }
+
+    private void setInstruction(@Nonnull MethodLocation location, @Nonnull BuilderInstruction instruction) {
+        location.instruction = instruction;
+        instruction.location = location;
+    }
+
+    private void convertAndSetInstruction(@Nonnull MethodLocation location, int[] codeAddressToIndex,
+                                          @Nonnull Instruction instruction) {
+        switch (instruction.getOpcode().format) {
+            case Format10t:
+                setInstruction(location, newBuilderInstruction10t(location.codeAddress,
+                        codeAddressToIndex,
+                        (Instruction10t) instruction));
+                return;
+            case Format10x:
+                setInstruction(location, newBuilderInstruction10x((Instruction10x) instruction));
+                return;
+            case Format11n:
+                setInstruction(location, newBuilderInstruction11n((Instruction11n) instruction));
+                return;
+            case Format11x:
+                setInstruction(location, newBuilderInstruction11x((Instruction11x) instruction));
+                return;
+            case Format12x:
+                setInstruction(location, newBuilderInstruction12x((Instruction12x) instruction));
+                return;
+            case Format20bc:
+                setInstruction(location, newBuilderInstruction20bc((Instruction20bc) instruction));
+                return;
+            case Format20t:
+                setInstruction(location, newBuilderInstruction20t(location.codeAddress,
+                        codeAddressToIndex,
+                        (Instruction20t) instruction));
+                return;
+            case Format21c:
+                setInstruction(location, newBuilderInstruction21c((Instruction21c) instruction));
+                return;
+            case Format21ih:
+                setInstruction(location, newBuilderInstruction21ih((Instruction21ih) instruction));
+                return;
+            case Format21lh:
+                setInstruction(location, newBuilderInstruction21lh((Instruction21lh) instruction));
+                return;
+            case Format21s:
+                setInstruction(location, newBuilderInstruction21s((Instruction21s) instruction));
+                return;
+            case Format21t:
+                setInstruction(location, newBuilderInstruction21t(location.codeAddress,
+                        codeAddressToIndex,
+                        (Instruction21t) instruction));
+                return;
+            case Format22b:
+                setInstruction(location, newBuilderInstruction22b((Instruction22b) instruction));
+                return;
+            case Format22c:
+                setInstruction(location, newBuilderInstruction22c((Instruction22c) instruction));
+                return;
+            case Format22s:
+                setInstruction(location, newBuilderInstruction22s((Instruction22s) instruction));
+                return;
+            case Format22t:
+                setInstruction(location, newBuilderInstruction22t(location.codeAddress,
+                        codeAddressToIndex,
+                        (Instruction22t) instruction));
+                return;
+            case Format22x:
+                setInstruction(location, newBuilderInstruction22x((Instruction22x) instruction));
+                return;
+            case Format23x:
+                setInstruction(location, newBuilderInstruction23x((Instruction23x) instruction));
+                return;
+            case Format25x:
+                setInstruction(location, newBuilderInstruction25x((Instruction25x) instruction));
+                return;
+            case Format30t:
+                setInstruction(location, newBuilderInstruction30t(location.codeAddress,
+                        codeAddressToIndex,
+                        (Instruction30t) instruction));
+                return;
+            case Format31c:
+                setInstruction(location, newBuilderInstruction31c((Instruction31c) instruction));
+                return;
+            case Format31i:
+                setInstruction(location, newBuilderInstruction31i((Instruction31i) instruction));
+                return;
+            case Format31t:
+                setInstruction(location, newBuilderInstruction31t(location, codeAddressToIndex,
+                        (Instruction31t) instruction));
+                return;
+            case Format32x:
+                setInstruction(location, newBuilderInstruction32x((Instruction32x) instruction));
+                return;
+            case Format35c:
+                setInstruction(location, newBuilderInstruction35c((Instruction35c) instruction));
+                return;
+            case Format3rc:
+                setInstruction(location, newBuilderInstruction3rc((Instruction3rc) instruction));
+                return;
+            case Format51l:
+                setInstruction(location, newBuilderInstruction51l((Instruction51l) instruction));
+                return;
+            case PackedSwitchPayload:
+                setInstruction(location,
+                        newBuilderPackedSwitchPayload(location, codeAddressToIndex, (PackedSwitchPayload) instruction));
+                return;
+            case SparseSwitchPayload:
+                setInstruction(location,
+                        newBuilderSparseSwitchPayload(location, codeAddressToIndex, (SparseSwitchPayload) instruction));
+                return;
+            case ArrayPayload:
+                setInstruction(location, newBuilderArrayPayload((ArrayPayload) instruction));
+                return;
+            default:
+                throw new ExceptionWithContext("Instruction format %s not supported", instruction.getOpcode().format);
+        }
+    }
+
+    @Nonnull
+    private BuilderInstruction10t newBuilderInstruction10t(int codeAddress, int[] codeAddressToIndex,
+                                                           @Nonnull Instruction10t instruction) {
+        return new BuilderInstruction10t(
+                instruction.getOpcode(),
+                newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset()));
+    }
+
+    @Nonnull
+    private BuilderInstruction10x newBuilderInstruction10x(@Nonnull Instruction10x instruction) {
+        return new BuilderInstruction10x(
+                instruction.getOpcode());
+    }
+
+    @Nonnull
+    private BuilderInstruction11n newBuilderInstruction11n(@Nonnull Instruction11n instruction) {
+        return new BuilderInstruction11n(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getNarrowLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction11x newBuilderInstruction11x(@Nonnull Instruction11x instruction) {
+        return new BuilderInstruction11x(
+                instruction.getOpcode(),
+                instruction.getRegisterA());
+    }
+
+    @Nonnull
+    private BuilderInstruction12x newBuilderInstruction12x(@Nonnull Instruction12x instruction) {
+        return new BuilderInstruction12x(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB());
+    }
+
+    @Nonnull
+    private BuilderInstruction20bc newBuilderInstruction20bc(@Nonnull Instruction20bc instruction) {
+        return new BuilderInstruction20bc(
+                instruction.getOpcode(),
+                instruction.getVerificationError(),
+                convertReference(instruction.getReference()));
+    }
+
+    @Nonnull
+    private BuilderInstruction20t newBuilderInstruction20t(int codeAddress, int[] codeAddressToIndex,
+                                                           @Nonnull Instruction20t instruction) {
+        return new BuilderInstruction20t(
+                instruction.getOpcode(),
+                newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset()));
+    }
+
+    @Nonnull
+    private BuilderInstruction21c newBuilderInstruction21c(@Nonnull Instruction21c instruction) {
+        return new BuilderInstruction21c(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                convertReference(instruction.getReference()));
+    }
+
+    @Nonnull
+    private BuilderInstruction21ih newBuilderInstruction21ih(@Nonnull Instruction21ih instruction) {
+        return new BuilderInstruction21ih(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getNarrowLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction21lh newBuilderInstruction21lh(@Nonnull Instruction21lh instruction) {
+        return new BuilderInstruction21lh(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getWideLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction21s newBuilderInstruction21s(@Nonnull Instruction21s instruction) {
+        return new BuilderInstruction21s(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getNarrowLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction21t newBuilderInstruction21t(int codeAddress, int[] codeAddressToIndex,
+                                                           @Nonnull Instruction21t instruction) {
+        return new BuilderInstruction21t(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset()));
+    }
+
+    @Nonnull
+    private BuilderInstruction22b newBuilderInstruction22b(@Nonnull Instruction22b instruction) {
+        return new BuilderInstruction22b(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB(),
+                instruction.getNarrowLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction22c newBuilderInstruction22c(@Nonnull Instruction22c instruction) {
+        return new BuilderInstruction22c(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB(),
+                convertReference(instruction.getReference()));
+    }
+
+    @Nonnull
+    private BuilderInstruction22s newBuilderInstruction22s(@Nonnull Instruction22s instruction) {
+        return new BuilderInstruction22s(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB(),
+                instruction.getNarrowLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction22t newBuilderInstruction22t(int codeAddress, int[] codeAddressToIndex,
+                                                           @Nonnull Instruction22t instruction) {
+        return new BuilderInstruction22t(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB(),
+                newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset()));
+    }
+
+    @Nonnull
+    private BuilderInstruction22x newBuilderInstruction22x(@Nonnull Instruction22x instruction) {
+        return new BuilderInstruction22x(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB());
+    }
+
+    @Nonnull
+    private BuilderInstruction23x newBuilderInstruction23x(@Nonnull Instruction23x instruction) {
+        return new BuilderInstruction23x(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB(),
+                instruction.getRegisterC());
+    }
+
+    @Nonnull
+    private BuilderInstruction30t newBuilderInstruction30t(int codeAddress, int[] codeAddressToIndex,
+                                                           @Nonnull Instruction30t instruction) {
+        return new BuilderInstruction30t(
+                instruction.getOpcode(),
+                newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset()));
+    }
+
+    @Nonnull
+    private BuilderInstruction31c newBuilderInstruction31c(@Nonnull Instruction31c instruction) {
+        return new BuilderInstruction31c(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                convertReference(instruction.getReference()));
+    }
+
+    @Nonnull
+    private BuilderInstruction31i newBuilderInstruction31i(@Nonnull Instruction31i instruction) {
+        return new BuilderInstruction31i(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getNarrowLiteral());
+    }
+
+    @Nonnull
+    private BuilderInstruction31t newBuilderInstruction31t(@Nonnull MethodLocation location, int[] codeAddressToIndex,
+                                                           @Nonnull Instruction31t instruction) {
+        int codeAddress = location.getCodeAddress();
+        Label newLabel;
+        if (instruction.getOpcode() != Opcode.FILL_ARRAY_DATA) {
+            // if it's a sparse switch or packed switch
+            newLabel = newSwitchPayloadReferenceLabel(location, codeAddressToIndex, codeAddress + instruction.getCodeOffset());
+        } else {
+            newLabel = newLabel(codeAddressToIndex, codeAddress + instruction.getCodeOffset());
+        }
+        return new BuilderInstruction31t(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                newLabel);
+    }
+
+    @Nonnull
+    private BuilderInstruction32x newBuilderInstruction32x(@Nonnull Instruction32x instruction) {
+        return new BuilderInstruction32x(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getRegisterB());
+    }
+
+    @Nonnull
+    private BuilderInstruction35c newBuilderInstruction35c(@Nonnull Instruction35c instruction) {
+        return new BuilderInstruction35c(
+                instruction.getOpcode(),
+                instruction.getRegisterCount(),
+                instruction.getRegisterC(),
+                instruction.getRegisterD(),
+                instruction.getRegisterE(),
+                instruction.getRegisterF(),
+                instruction.getRegisterG(),
+                convertReference(instruction.getReference()));
+    }
+
+    @Nonnull
+    private BuilderInstruction25x newBuilderInstruction25x(@Nonnull Instruction25x instruction) {
+        return new BuilderInstruction25x(
+                instruction.getOpcode(),
+                instruction.getParameterRegisterCount(),
+                instruction.getRegisterFixedC(),
+                instruction.getRegisterParameterD(),
+                instruction.getRegisterParameterE(),
+                instruction.getRegisterParameterF(),
+                instruction.getRegisterParameterG());
+    }
+
+    @Nonnull
+    private BuilderInstruction3rc newBuilderInstruction3rc(@Nonnull Instruction3rc instruction) {
+        return new BuilderInstruction3rc(
+                instruction.getOpcode(),
+                instruction.getStartRegister(),
+                instruction.getRegisterCount(),
+                convertReference(instruction.getReference()));
+    }
+
+    @Nonnull
+    private BuilderInstruction51l newBuilderInstruction51l(@Nonnull Instruction51l instruction) {
+        return new BuilderInstruction51l(
+                instruction.getOpcode(),
+                instruction.getRegisterA(),
+                instruction.getWideLiteral());
+    }
+
+    @Nullable
+    private MethodLocation findSwitchForPayload(@Nonnull MethodLocation payloadLocation) {
+        MethodLocation location = payloadLocation;
+        MethodLocation switchLocation = null;
+        do {
+            for (Label label : location.getLabels()) {
+                if (label instanceof SwitchPayloadReferenceLabel) {
+                    if (switchLocation != null) {
+                        throw new IllegalStateException("Multiple switch instructions refer to the same payload. "
+                                + "This is not currently supported. Please file a bug :)");
+                    }
+                    switchLocation = ((SwitchPayloadReferenceLabel) label).switchLocation;
+                }
+            }
+
+            // A switch instruction can refer to the payload instruction itself, or to a nop before the payload
+            // instruction.
+            // We need to search for all occurrences of a switch reference, so we can detect when multiple switch
+            // statements refer to the same payload
+            // TODO: confirm that it could refer to the first NOP in a series of NOPs preceding the payload
+            if (location.index == 0) {
+                return switchLocation;
+            }
+            location = instructionList.get(location.index - 1);
+            if (location.instruction == null || location.instruction.getOpcode() != Opcode.NOP) {
+                return switchLocation;
+            }
+        } while (true);
+    }
+
+    @Nonnull
+    private BuilderPackedSwitchPayload newBuilderPackedSwitchPayload(@Nonnull MethodLocation location,
+                                                                     @Nonnull int[] codeAddressToIndex,
+                                                                     @Nonnull PackedSwitchPayload instruction) {
+        List<? extends SwitchElement> switchElements = instruction.getSwitchElements();
+        if (switchElements.size() == 0) {
+            return new BuilderPackedSwitchPayload(0, null);
+        }
+
+        MethodLocation switchLocation = findSwitchForPayload(location);
+        int baseAddress;
+        if (switchLocation == null) {
+            baseAddress = 0;
+        } else {
+            baseAddress = switchLocation.codeAddress;
+        }
+
+        List<Label> labels = Lists.newArrayList();
+        for (SwitchElement element : switchElements) {
+            labels.add(newLabel(codeAddressToIndex, element.getOffset() + baseAddress));
+        }
+
+        return new BuilderPackedSwitchPayload(switchElements.get(0).getKey(), labels);
+    }
+
+    @Nonnull
+    private BuilderSparseSwitchPayload newBuilderSparseSwitchPayload(@Nonnull MethodLocation location,
+                                                                     @Nonnull int[] codeAddressToIndex,
+                                                                     @Nonnull SparseSwitchPayload instruction) {
+        List<? extends SwitchElement> switchElements = instruction.getSwitchElements();
+        if (switchElements.size() == 0) {
+            return new BuilderSparseSwitchPayload(null);
+        }
+
+        MethodLocation switchLocation = findSwitchForPayload(location);
+        int baseAddress;
+        if (switchLocation == null) {
+            baseAddress = 0;
+        } else {
+            baseAddress = switchLocation.codeAddress;
+        }
+
+        List<SwitchLabelElement> labelElements = Lists.newArrayList();
+        for (SwitchElement element : switchElements) {
+            labelElements.add(new SwitchLabelElement(element.getKey(),
+                    newLabel(codeAddressToIndex, element.getOffset() + baseAddress)));
+        }
+
+        return new BuilderSparseSwitchPayload(labelElements);
+    }
+
+    @Nonnull
+    private BuilderArrayPayload newBuilderArrayPayload(@Nonnull ArrayPayload instruction) {
+        return new BuilderArrayPayload(instruction.getElementWidth(), instruction.getArrayElements());
+    }
+
+    private Reference convertReference(@Nonnull Reference reference) {
+        if (reference != null && this.dexBuilder != null) {
+            return this.dexBuilder.internReference(reference);
+        } else {
+            return reference;
+        }
+    }
+
+    @Nonnull
+    private BuilderDebugItem convertDebugItem(@Nonnull DebugItem debugItem) {
+        switch (debugItem.getDebugItemType()) {
+            case DebugItemType.START_LOCAL: {
+                StartLocal startLocal = (StartLocal) debugItem;
+                return new BuilderStartLocal(startLocal.getRegister(),
+                        (StringReference) convertReference(startLocal.getNameReference()),
+                        (TypeReference) convertReference(startLocal.getTypeReference()),
+                        (StringReference) convertReference(startLocal.getSignatureReference()));
+            }
+            case DebugItemType.END_LOCAL: {
+                EndLocal endLocal = (EndLocal) debugItem;
+                return new BuilderEndLocal(endLocal.getRegister());
+            }
+            case DebugItemType.RESTART_LOCAL: {
+                RestartLocal restartLocal = (RestartLocal) debugItem;
+                return new BuilderRestartLocal(restartLocal.getRegister());
+            }
+            case DebugItemType.PROLOGUE_END:
+                return new BuilderPrologueEnd();
+            case DebugItemType.EPILOGUE_BEGIN:
+                return new BuilderEpilogueBegin();
+            case DebugItemType.LINE_NUMBER: {
+                LineNumber lineNumber = (LineNumber) debugItem;
+                return new BuilderLineNumber(lineNumber.getLineNumber());
+            }
+            case DebugItemType.SET_SOURCE_FILE: {
+                SetSourceFile setSourceFile = (SetSourceFile) debugItem;
+                return new BuilderSetSourceFile(
+                        (StringReference) convertReference(setSourceFile.getSourceFileReference())
+                );
+            }
+            default:
+                throw new ExceptionWithContext("Invalid debug item type: " + debugItem.getDebugItemType());
+        }
+    }
+}
\ No newline at end of file
diff --git a/tinker-commons/build.gradle b/tinker-commons/build.gradle
index b7de68c6..9b52ca65 100644
--- a/tinker-commons/build.gradle
+++ b/tinker-commons/build.gradle
@@ -10,6 +10,7 @@ dependencies {
     compile fileTree(dir: 'libs', include: ['*.jar'])
     compile project(':third-party:aosp-dexutils')
     compile project(':third-party:bsdiff-util')
+    compile project(':third-party:tinker-ziputils')
 }
 
 task buildTinkerSdk(type: Copy, dependsOn: [build]) {
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/DexPatchApplier.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/DexPatchApplier.java
index 1d9f7fef..8882049b 100644
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/DexPatchApplier.java
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/dexpatcher/DexPatchApplier.java
@@ -33,7 +33,6 @@
 import com.tencent.tinker.android.dex.TableOfContents;
 import com.tencent.tinker.android.dex.TypeList;
 import com.tencent.tinker.android.dex.util.CompareUtils;
-import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
 import com.tencent.tinker.commons.dexpatcher.algorithms.patch.AnnotationSectionPatchAlgorithm;
 import com.tencent.tinker.commons.dexpatcher.algorithms.patch.AnnotationSetRefListSectionPatchAlgorithm;
 import com.tencent.tinker.commons.dexpatcher.algorithms.patch.AnnotationSetSectionPatchAlgorithm;
@@ -51,6 +50,8 @@
 import com.tencent.tinker.commons.dexpatcher.algorithms.patch.TypeIdSectionPatchAlgorithm;
 import com.tencent.tinker.commons.dexpatcher.algorithms.patch.TypeListSectionPatchAlgorithm;
 import com.tencent.tinker.commons.dexpatcher.struct.DexPatchFile;
+import com.tencent.tinker.commons.dexpatcher.util.SparseIndexMap;
+import com.tencent.tinker.commons.util.StreamUtil;
 
 import java.io.BufferedOutputStream;
 import java.io.File;
@@ -257,13 +258,7 @@ public void executeAndSaveTo(File file) throws IOException {
             os = new BufferedOutputStream(new FileOutputStream(file));
             executeAndSaveTo(os);
         } finally {
-            if (os != null) {
-                try {
-                    os.close();
-                } catch (Exception e) {
-                    // ignored.
-                }
-            }
+            StreamUtil.closeQuietly(os);
         }
     }
 }
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/util/StreamUtil.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/util/StreamUtil.java
new file mode 100644
index 00000000..9a3ff542
--- /dev/null
+++ b/tinker-commons/src/main/java/com/tencent/tinker/commons/util/StreamUtil.java
@@ -0,0 +1,30 @@
+package com.tencent.tinker.commons.util;
+
+import java.io.Closeable;
+import java.util.zip.ZipFile;
+
+/**
+ * Created by tomystang on 2017/11/16.
+ */
+
+public final class StreamUtil {
+
+    /**
+     * Closes the given {@code obj}. Suppresses any exceptions.
+     */
+    @SuppressWarnings("NewApi")
+    public static void closeQuietly(Object obj) {
+        if (obj == null) return;
+        try {
+            if (obj instanceof Closeable) {
+                ((Closeable) obj).close();
+            } else if (obj instanceof AutoCloseable) {
+                ((AutoCloseable) obj).close();
+            } else if (obj instanceof ZipFile) {
+                ((ZipFile) obj).close();
+            }
+        } catch (Throwable ignored) {
+            // ignored.
+        }
+    }
+}
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/Arrays.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/Arrays.java
deleted file mode 100644
index 8712e839..00000000
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/Arrays.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.tencent.tinker.commons.ziputil;
-
-/**
- * modify by zhangshaowen on 16/6/7.
- */
-public class Arrays {
-    public static void checkOffsetAndCount(int arrayLength, int offset, int count) {
-        if ((offset | count) < 0 || offset > arrayLength || arrayLength - offset < count) {
-//            throw new ArrayIndexOutOfBoundsException(arrayLength, offset,
-//                count);
-            throw new ArrayIndexOutOfBoundsException(offset);
-        }
-    }
-}
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/BufferIterator.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/BufferIterator.java
deleted file mode 100644
index 7c175e54..00000000
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/BufferIterator.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.tencent.tinker.commons.ziputil;
-
-/**
- * modify by zhangshaowen on 16/6/7.
- */
-public abstract class BufferIterator {
-    /**
-     * Seeks to the absolute position {@code offset}, measured in bytes from the start.
-     */
-    public abstract void seek(int offset);
-    /**
-     * Skips forwards or backwards {@code byteCount} bytes from the current position.
-     */
-    public abstract void skip(int byteCount);
-
-    public abstract int readInt();
-
-    public abstract short readShort();
-}
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/SizeOf.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/SizeOf.java
deleted file mode 100644
index 03458938..00000000
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/SizeOf.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.tencent.tinker.commons.ziputil;
-
-/**
- * modify by zhangshaowen on 16/6/7.
- */
-public final class SizeOf {
-    public static final int CHAR = 2;
-    public static final int DOUBLE = 8;
-    public static final int FLOAT = 4;
-    public static final int INT = 4;
-    public static final int LONG = 8;
-    public static final int SHORT = 2;
-    private SizeOf() {
-    }
-}
diff --git a/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/StandardCharsets.java b/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/StandardCharsets.java
deleted file mode 100644
index caa1fbf4..00000000
--- a/tinker-commons/src/main/java/com/tencent/tinker/commons/ziputil/StandardCharsets.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.tencent.tinker.commons.ziputil;
-
-import java.nio.charset.Charset;
-
-/**
- * modify by zhangshaowen on 16/6/7.
- */
-public final class StandardCharsets {
-    public static final Charset UTF_8 = Charset.forName("UTF-8");
-
-    private StandardCharsets() {
-    }
-}
diff --git a/tinker-sample-android/app/build.gradle b/tinker-sample-android/app/build.gradle
index 269372f3..1790e7ce 100644
--- a/tinker-sample-android/app/build.gradle
+++ b/tinker-sample-android/app/build.gradle
@@ -1,26 +1,45 @@
 apply plugin: 'com.android.application'
 
-
-
 dependencies {
-    compile fileTree(dir: 'libs', include: ['*.jar'])
-    testCompile 'junit:junit:4.12'
-    compile "com.android.support:appcompat-v7:23.1.1"
-    compile("com.tencent.tinker:tinker-android-lib:${TINKER_VERSION}") { changing = true }
-    provided("com.tencent.tinker:tinker-android-anno:${TINKER_VERSION}") { changing = true }
-
-    compile "com.android.support:multidex:1.0.1"
-
-    //use to test multiDex
+    if (is_gradle_3()) {
+        implementation fileTree(dir: 'libs', include: ['*.jar'])
+        testImplementation 'junit:junit:4.12'
+        implementation "com.android.support:appcompat-v7:23.1.1"
+        implementation("com.tencent.tinker:tinker-android-lib:${TINKER_VERSION}") { changing = true }
+        annotationProcessor("com.tencent.tinker:tinker-android-anno:${TINKER_VERSION}") { changing = true }
+        compileOnly("com.tencent.tinker:tinker-android-anno:${TINKER_VERSION}") { changing = true }
+
+        implementation "com.android.support:multidex:1.0.1"
+        //use to test multiDex
+//    implementation group: 'com.google.guava', name: 'guava', version: '19.0'
+//    implementation "org.scala-lang:scala-library:2.11.7"
+
+        //use for local maven test
+//        implementation("com.tencent.tinker:tinker-android-loader:${TINKER_VERSION}") { changing = true }
+//        implementation("com.tencent.tinker:aosp-dexutils:${TINKER_VERSION}") { changing = true }
+//        implementation("com.tencent.tinker:bsdiff-util:${TINKER_VERSION}") { changing = true }
+//        implementation("com.tencent.tinker:tinker-ziputils:${TINKER_VERSION}") { changing = true }
+//        implementation("com.tencent.tinker:tinker-commons:${TINKER_VERSION}") { changing = true }
+    } else {
+        compile fileTree(dir: 'libs', include: ['*.jar'])
+        testCompile 'junit:junit:4.12'
+        compile "com.android.support:appcompat-v7:23.1.1"
+        compile("com.tencent.tinker:tinker-android-lib:${TINKER_VERSION}") { changing = true }
+        provided("com.tencent.tinker:tinker-android-anno:${TINKER_VERSION}") { changing = true }
+
+        compile "com.android.support:multidex:1.0.1"
+
+        //use to test multiDex
 //    compile group: 'com.google.guava', name: 'guava', version: '19.0'
 //    compile "org.scala-lang:scala-library:2.11.7"
 
-    //use for local maven test
-//    compile("com.tencent.tinker:tinker-android-loader:${TINKER_VERSION}") { changing = true }
-//    compile("com.tencent.tinker:aosp-dexutils:${TINKER_VERSION}") { changing = true }
-//    compile("com.tencent.tinker:bsdiff-util:${TINKER_VERSION}") { changing = true }
-//    compile("com.tencent.tinker:tinker-commons:${TINKER_VERSION}") { changing = true }
-
+        //use for local maven test
+//        compile("com.tencent.tinker:tinker-android-loader:${TINKER_VERSION}") { changing = true }
+//        compile("com.tencent.tinker:aosp-dexutils:${TINKER_VERSION}") { changing = true }
+//        compile("com.tencent.tinker:bsdiff-util:${TINKER_VERSION}") { changing = true }
+//        compile("com.tencent.tinker:tinker-ziputils:${TINKER_VERSION}") { changing = true }
+//        compile("com.tencent.tinker:tinker-commons:${TINKER_VERSION}") { changing = true }
+    }
 }
 
 def gitSha() {
@@ -38,8 +57,8 @@ def gitSha() {
 def javaVersion = JavaVersion.VERSION_1_7
 
 android {
-    compileSdkVersion 23
-    buildToolsVersion "23.0.2"
+    compileSdkVersion 26
+    buildToolsVersion '26.0.2'
 
     compileOptions {
         sourceCompatibility javaVersion
@@ -69,7 +88,7 @@ android {
 
     defaultConfig {
         applicationId "tinker.sample.android"
-        minSdkVersion 10
+        minSdkVersion 14
         targetSdkVersion 22
         versionCode 1
         versionName "1.0.0"
@@ -88,7 +107,7 @@ android {
          * so we can get the newly git version easily!
          */
         buildConfigField "String", "TINKER_ID", "\"${getTinkerIdValue()}\""
-        buildConfigField "String", "PLATFORM",  "\"all\""
+        buildConfigField "String", "PLATFORM", "\"all\""
     }
 
 //    aaptOptions{
@@ -110,7 +129,7 @@ android {
         release {
             minifyEnabled true
             signingConfig signingConfigs.release
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), project.file('proguard-rules.pro')
         }
         debug {
             debuggable true
@@ -246,6 +265,26 @@ if (buildWithTinker()) {
              * open this can reduce the dex diff file size.
              */
             keepDexApply = false
+
+            /**
+             * optional, default 'false'
+             * Whether tinker should treat the base apk as the one being protected by app
+             * protection tools.
+             * If this attribute is true, the generated patch package will contain a
+             * dex including all changed classes instead of any dexdiff patch-info files.
+             */
+            isProtectedApp = false
+
+            /**
+             * optional, default 'false'
+             * Whether tinker should support component hotplug (add new component dynamically).
+             * If this attribute is true, the component added in new apk will be available after
+             * patch is successfully loaded. Otherwise an error would be announced when generating patch
+             * on compile-time.
+             *
+             * <b>Notice that currently this feature is incubating and only support NON-EXPORTED Activity</b>
+             */
+            supportHotplugComponent = false
         }
 
         dex {
@@ -275,8 +314,8 @@ if (buildWithTinker()) {
              *
              */
             loader = [
-                      //use sample, let BaseBuildInfo unchangeable with tinker
-                      "tinker.sample.android.app.BaseBuildInfo"
+                    //use sample, let BaseBuildInfo unchangeable with tinker
+                    "tinker.sample.android.app.BaseBuildInfo"
             ]
         }
 
@@ -350,7 +389,7 @@ if (buildWithTinker()) {
              * optional，default '7za'
              * the 7zip artifact path, it will use the right 7za with your platform
              */
-           zipArtifact = "com.tencent.mm:SevenZip:1.1.10"
+            zipArtifact = "com.tencent.mm:SevenZip:1.1.10"
             /**
              * optional，default '7za'
              * you can specify the 7za path yourself, it will overwrite the zipArtifact value
@@ -360,19 +399,20 @@ if (buildWithTinker()) {
     }
 
     List<String> flavors = new ArrayList<>();
-    project.android.productFlavors.each {flavor ->
+    project.android.productFlavors.each { flavor ->
         flavors.add(flavor.name)
     }
     boolean hasFlavors = flavors.size() > 0
+    def date = new Date().format("MMdd-HH-mm-ss")
+
     /**
-    * bak apk and mapping
-    */
+     * bak apk and mapping
+     */
     android.applicationVariants.all { variant ->
         /**
          * task type, you want to bak
          */
         def taskName = variant.name
-        def date = new Date().format("MMdd-HH-mm-ss")
 
         tasks.all {
             if ("assemble${taskName.capitalize()}".equalsIgnoreCase(it.name)) {
@@ -383,7 +423,7 @@ if (buildWithTinker()) {
                         def newFileNamePrefix = hasFlavors ? "${fileNamePrefix}" : "${fileNamePrefix}-${date}"
 
                         def destPath = hasFlavors ? file("${bakPath}/${project.name}-${date}/${variant.flavorName}") : bakPath
-                        from variant.outputs.outputFile
+                        from variant.outputs.first().outputFile
                         into destPath
                         rename { String fileName ->
                             fileName.replace("${fileNamePrefix}.apk", "${newFileNamePrefix}.apk")
diff --git a/tinker-sample-android/app/proguard-rules.pro b/tinker-sample-android/app/proguard-rules.pro
index 36186f49..d1da995f 100644
--- a/tinker-sample-android/app/proguard-rules.pro
+++ b/tinker-sample-android/app/proguard-rules.pro
@@ -17,3 +17,8 @@
 #}
 -keepattributes SourceFile,LineNumberTable
 
+-dontwarn com.google.**
+
+-dontwarn com.android.**
+
+
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/SampleApplicationLike.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/SampleApplicationLike.java
index 9233951e..5aef75a3 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/SampleApplicationLike.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/SampleApplicationLike.java
@@ -26,10 +26,13 @@
 import com.tencent.tinker.anno.DefaultLifeCycle;
 import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.tinker.TinkerInstaller;
+import com.tencent.tinker.lib.util.TinkerLog;
 import com.tencent.tinker.loader.app.ApplicationLifeCycle;
 import com.tencent.tinker.loader.app.DefaultApplicationLike;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 
+import java.util.regex.Pattern;
+
 import tinker.sample.android.Log.MyLogImp;
 import tinker.sample.android.util.SampleApplicationContext;
 import tinker.sample.android.util.TinkerManager;
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/crash/SampleUncaughtExceptionHandler.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/crash/SampleUncaughtExceptionHandler.java
index a4c6c184..90dcd767 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/crash/SampleUncaughtExceptionHandler.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/crash/SampleUncaughtExceptionHandler.java
@@ -65,22 +65,26 @@ public void uncaughtException(Thread thread, Throwable ex) {
      * If it use Xposed, we can just clean patch or mention user to uninstall it.
      */
     private void tinkerPreVerifiedCrashHandler(Throwable ex) {
+        ApplicationLike applicationLike = TinkerManager.getTinkerApplicationLike();
+        if (applicationLike == null || applicationLike.getApplication() == null) {
+            TinkerLog.w(TAG, "applicationlike is null");
+            return;
+        }
+
+        if (!TinkerApplicationHelper.isTinkerLoadSuccess(applicationLike)) {
+            TinkerLog.w(TAG, "tinker is not loaded");
+            return;
+        }
+
         Throwable throwable = ex;
         boolean isXposed = false;
         while (throwable != null) {
             if (!isXposed) {
                 isXposed = Utils.isXposedExists(throwable);
             }
-            if (isXposed) {
-                //method 1
-                ApplicationLike applicationLike = TinkerManager.getTinkerApplicationLike();
-                if (applicationLike == null || applicationLike.getApplication() == null) {
-                    return;
-                }
 
-                if (!TinkerApplicationHelper.isTinkerLoadSuccess(applicationLike)) {
-                    return;
-                }
+            // xposed?
+            if (isXposed) {
                 boolean isCausedByXposed = false;
                 //for art, we can't know the actually crash type
                 //just ignore art
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleLoadReporter.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleLoadReporter.java
index bc2acd22..05dd146e 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleLoadReporter.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleLoadReporter.java
@@ -21,16 +21,11 @@
 import android.os.MessageQueue;
 
 import com.tencent.tinker.lib.reporter.DefaultLoadReporter;
-import com.tencent.tinker.lib.tinker.Tinker;
-import com.tencent.tinker.lib.tinker.TinkerInstaller;
-import com.tencent.tinker.lib.util.TinkerLog;
+import com.tencent.tinker.lib.util.UpgradePatchRetry;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
-import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
-import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
 
 import java.io.File;
 
-import tinker.sample.android.util.UpgradePatchRetry;
 
 /**
  * optional, you can just use DefaultLoadReporter
@@ -58,26 +53,19 @@ public void onLoadResult(File patchDirectory, int loadCode, long cost) {
                 break;
         }
         Looper.getMainLooper().myQueue().addIdleHandler(new MessageQueue.IdleHandler() {
-            @Override public boolean queueIdle() {
-                UpgradePatchRetry.getInstance(context).onPatchRetryLoad();
+            @Override
+            public boolean queueIdle() {
+                if (UpgradePatchRetry.getInstance(context).onPatchRetryLoad()) {
+                    SampleTinkerReport.onReportRetryPatch();
+                }
                 return false;
             }
         });
     }
+
     @Override
     public void onLoadException(Throwable e, int errorCode) {
         super.onLoadException(e, errorCode);
-        switch (errorCode) {
-            case ShareConstants.ERROR_LOAD_EXCEPTION_UNCAUGHT:
-                String uncaughtString = SharePatchFileUtil.checkTinkerLastUncaughtCrash(context);
-                if (!ShareTinkerInternals.isNullOrNil(uncaughtString)) {
-                    File laseCrashFile = SharePatchFileUtil.getPatchLastCrashFile(context);
-                    SharePatchFileUtil.safeDeleteFile(laseCrashFile);
-                    // found really crash reason
-                    TinkerLog.e(TAG, "tinker uncaught real exception:" + uncaughtString);
-                }
-                break;
-        }
         SampleTinkerReport.onLoadException(e, errorCode);
     }
 
@@ -89,35 +77,14 @@ public void onLoadFileMd5Mismatch(File file, int fileType) {
 
     /**
      * try to recover patch oat file
+     *
      * @param file
      * @param fileType
      * @param isDirectory
      */
     @Override
     public void onLoadFileNotFound(File file, int fileType, boolean isDirectory) {
-        TinkerLog.i(TAG, "patch loadReporter onLoadFileNotFound: patch file not found: %s, fileType:%d, isDirectory:%b",
-            file.getAbsolutePath(), fileType, isDirectory);
-
-        // only try to recover opt file
-        // check dex opt file at last, some phone such as VIVO/OPPO like to change dex2oat to interpreted
-        if (fileType == ShareConstants.TYPE_DEX_OPT) {
-            Tinker tinker = Tinker.with(context);
-            //we can recover at any process except recover process
-            if (tinker.isMainProcess()) {
-                File patchVersionFile = tinker.getTinkerLoadResultIfPresent().patchVersionFile;
-                if (patchVersionFile != null) {
-                    if (UpgradePatchRetry.getInstance(context).onPatchListenerCheck(SharePatchFileUtil.getMD5(patchVersionFile))) {
-                        TinkerLog.i(TAG, "try to repair oat file on patch process");
-                        TinkerInstaller.onReceiveUpgradePatch(context, patchVersionFile.getAbsolutePath());
-                    } else {
-                        TinkerLog.i(TAG, "repair retry exceed must max time, just clean");
-                        checkAndCleanPatch();
-                    }
-                }
-            }
-        } else {
-            checkAndCleanPatch();
-        }
+        super.onLoadFileNotFound(file, fileType, isDirectory);
         SampleTinkerReport.onLoadFileNotFound(fileType);
     }
 
@@ -133,6 +100,12 @@ public void onLoadPatchInfoCorrupted(String oldVersion, String newVersion, File
         SampleTinkerReport.onLoadInfoCorrupted();
     }
 
+    @Override
+    public void onLoadInterpret(int type, Throwable e) {
+        super.onLoadInterpret(type, e);
+        SampleTinkerReport.onLoadInterpretReport(type, e);
+    }
+
     @Override
     public void onLoadPatchVersionChanged(String oldVersion, String newVersion, File patchDirectoryFile, String currentPatchName) {
         super.onLoadPatchVersionChanged(oldVersion, newVersion, patchDirectoryFile, currentPatchName);
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchListener.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchListener.java
index 17a63497..1407c8a7 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchListener.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchListener.java
@@ -21,8 +21,6 @@
 import android.content.SharedPreferences;
 
 import com.tencent.tinker.lib.listener.DefaultPatchListener;
-import com.tencent.tinker.lib.tinker.Tinker;
-import com.tencent.tinker.lib.tinker.TinkerLoadResult;
 import com.tencent.tinker.lib.util.TinkerLog;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
@@ -33,7 +31,6 @@
 
 import tinker.sample.android.app.BuildInfo;
 import tinker.sample.android.crash.SampleUncaughtExceptionHandler;
-import tinker.sample.android.util.UpgradePatchRetry;
 import tinker.sample.android.util.Utils;
 
 /**
@@ -64,41 +61,21 @@ public SamplePatchListener(Context context) {
      * @return
      */
     @Override
-    public int patchCheck(String path) {
+    public int patchCheck(String path, String patchMd5) {
         File patchFile = new File(path);
         TinkerLog.i(TAG, "receive a patch file: %s, file size:%d", path, SharePatchFileUtil.getFileOrDirectorySize(patchFile));
-        int returnCode = super.patchCheck(path);
+        int returnCode = super.patchCheck(path, patchMd5);
 
         if (returnCode == ShareConstants.ERROR_PATCH_OK) {
             returnCode = Utils.checkForPatchRecover(NEW_PATCH_RESTRICTION_SPACE_SIZE_MIN, maxMemory);
         }
 
         if (returnCode == ShareConstants.ERROR_PATCH_OK) {
-            String patchMd5 = SharePatchFileUtil.getMD5(patchFile);
             SharedPreferences sp = context.getSharedPreferences(ShareConstants.TINKER_SHARE_PREFERENCE_CONFIG, Context.MODE_MULTI_PROCESS);
             //optional, only disable this patch file with md5
             int fastCrashCount = sp.getInt(patchMd5, 0);
             if (fastCrashCount >= SampleUncaughtExceptionHandler.MAX_CRASH_COUNT) {
                 returnCode = Utils.ERROR_PATCH_CRASH_LIMIT;
-            } else {
-                //for upgrade patch, version must be not the same
-                //for repair patch, we won't has the tinker load flag
-                Tinker tinker = Tinker.with(context);
-
-                if (tinker.isTinkerLoaded()) {
-                    TinkerLoadResult tinkerLoadResult = tinker.getTinkerLoadResultIfPresent();
-                    if (tinkerLoadResult != null) {
-                        String currentVersion = tinkerLoadResult.currentVersion;
-                        if (patchMd5.equals(currentVersion)) {
-                            returnCode = Utils.ERROR_PATCH_ALREADY_APPLY;
-                        }
-                    }
-                }
-            }
-            //check whether retry so many times
-            if (returnCode == ShareConstants.ERROR_PATCH_OK) {
-                returnCode = UpgradePatchRetry.getInstance(context).onPatchListenerCheck(patchMd5)
-                    ? ShareConstants.ERROR_PATCH_OK : Utils.ERROR_PATCH_RETRY_COUNT_LIMIT;
             }
         }
         // Warning, it is just a sample case, you don't need to copy all of these
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchReporter.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchReporter.java
index af0753f0..9099bb4c 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchReporter.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SamplePatchReporter.java
@@ -23,14 +23,14 @@
 import com.tencent.tinker.loader.shareutil.SharePatchInfo;
 
 import java.io.File;
-
-import tinker.sample.android.util.UpgradePatchRetry;
+import java.util.List;
 
 /**
  * optional, you can just use DefaultPatchReporter
  * Created by zhangshaowen on 16/4/8.
  */
 public class SamplePatchReporter extends DefaultPatchReporter {
+    private final static String TAG = "Tinker.SamplePatchReporter";
     public SamplePatchReporter(Context context) {
         super(context);
     }
@@ -39,12 +39,11 @@ public SamplePatchReporter(Context context) {
     public void onPatchServiceStart(Intent intent) {
         super.onPatchServiceStart(intent);
         SampleTinkerReport.onApplyPatchServiceStart();
-        UpgradePatchRetry.getInstance(context).onPatchServiceStart(intent);
     }
 
     @Override
-    public void onPatchDexOptFail(File patchFile, File dexFile, String optDirectory, String dexName, Throwable t) {
-        super.onPatchDexOptFail(patchFile, dexFile, optDirectory, dexName, t);
+    public void onPatchDexOptFail(File patchFile, List<File> dexFiles, Throwable t) {
+        super.onPatchDexOptFail(patchFile, dexFiles, t);
         SampleTinkerReport.onApplyDexOptFail(t);
     }
 
@@ -70,7 +69,6 @@ public void onPatchPackageCheckFail(File patchFile, int errorCode) {
     public void onPatchResult(File patchFile, boolean success, long cost) {
         super.onPatchResult(patchFile, success, cost);
         SampleTinkerReport.onApplied(cost, success);
-        UpgradePatchRetry.getInstance(context).onPatchServiceResult();
     }
 
     @Override
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleTinkerReport.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleTinkerReport.java
index a2d5a74e..b0fa2309 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleTinkerReport.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/reporter/SampleTinkerReport.java
@@ -54,14 +54,17 @@
     public static final int KEY_TRY_APPLY_MEMORY_LIMIT            = 78;
     public static final int KEY_TRY_APPLY_CRASH_LIMIT             = 79;
     public static final int KEY_TRY_APPLY_CONDITION_NOT_SATISFIED = 80;
+    public static final int KEY_TRY_APPLY_JIT                     = 81;
 
     //Key -- apply detail
     public static final int KEY_APPLIED_UPGRADE      = 100;
     public static final int KEY_APPLIED_UPGRADE_FAIL = 101;
 
     public static final int KEY_APPLIED_EXCEPTION                               = 120;
-    public static final int KEY_APPLIED_DEXOPT                                  = 121;
-    public static final int KEY_APPLIED_INFO_CORRUPTED                          = 122;
+    public static final int KEY_APPLIED_DEXOPT_OTHER                            = 121;
+    public static final int KEY_APPLIED_DEXOPT_EXIST                            = 122;
+    public static final int KEY_APPLIED_DEXOPT_FORMAT                           = 123;
+    public static final int KEY_APPLIED_INFO_CORRUPTED                          = 124;
     //package check
     public static final int KEY_APPLIED_PACKAGE_CHECK_SIGNATURE                 = 150;
     public static final int KEY_APPLIED_PACKAGE_CHECK_DEX_META                  = 151;
@@ -74,18 +77,18 @@
     public static final int KEY_APPLIED_PACKAGE_CHECK_TINKERFLAG_NOT_SUPPORT    = 158;
 
     //version check
-    public static final int KEY_APPLIED_VERSION_CHECK                           = 180;
+    public static final int KEY_APPLIED_VERSION_CHECK      = 180;
     //extract error
-    public static final int KEY_APPLIED_PATCH_FILE_EXTRACT                      = 181;
-    public static final int KEY_APPLIED_DEX_EXTRACT                             = 182;
-    public static final int KEY_APPLIED_LIB_EXTRACT                             = 183;
-    public static final int KEY_APPLIED_RESOURCE_EXTRACT                        = 184;
+    public static final int KEY_APPLIED_PATCH_FILE_EXTRACT = 181;
+    public static final int KEY_APPLIED_DEX_EXTRACT        = 182;
+    public static final int KEY_APPLIED_LIB_EXTRACT        = 183;
+    public static final int KEY_APPLIED_RESOURCE_EXTRACT   = 184;
     //cost time
-    public static final int KEY_APPLIED_SUCC_COST_5S_LESS                       = 200;
-    public static final int KEY_APPLIED_SUCC_COST_10S_LESS                      = 201;
-    public static final int KEY_APPLIED_SUCC_COST_30S_LESS                      = 202;
-    public static final int KEY_APPLIED_SUCC_COST_60S_LESS                      = 203;
-    public static final int KEY_APPLIED_SUCC_COST_OTHER                         = 204;
+    public static final int KEY_APPLIED_SUCC_COST_5S_LESS  = 200;
+    public static final int KEY_APPLIED_SUCC_COST_10S_LESS = 201;
+    public static final int KEY_APPLIED_SUCC_COST_30S_LESS = 202;
+    public static final int KEY_APPLIED_SUCC_COST_60S_LESS = 203;
+    public static final int KEY_APPLIED_SUCC_COST_OTHER    = 204;
 
     public static final int KEY_APPLIED_FAIL_COST_5S_LESS  = 205;
     public static final int KEY_APPLIED_FAIL_COST_10S_LESS = 206;
@@ -132,6 +135,11 @@
     public static final int KEY_LOADED_SUCC_COST_5000_LESS = 403;
     public static final int KEY_LOADED_SUCC_COST_OTHER     = 404;
 
+    public static final int KEY_LOADED_INTERPRET_GET_INSTRUCTION_SET_ERROR = 450;
+    public static final int KEY_LOADED_INTERPRET_INTERPRET_COMMAND_ERROR   = 451;
+    public static final int KEY_LOADED_INTERPRET_TYPE_INTERPRET_OK         = 452;
+
+
     interface Reporter {
         void onReport(int key);
 
@@ -174,13 +182,16 @@ public static void onTryApplyFail(int errorCode) {
             case ShareConstants.ERROR_PATCH_RUNNING:
                 reporter.onReport(KEY_TRY_APPLY_RUNNING);
                 break;
+            case ShareConstants.ERROR_PATCH_JIT:
+                reporter.onReport(KEY_TRY_APPLY_JIT);
+                break;
             case Utils.ERROR_PATCH_ROM_SPACE:
                 reporter.onReport(KEY_TRY_APPLY_ROM_SPACE);
                 break;
             case Utils.ERROR_PATCH_GOOGLEPLAY_CHANNEL:
                 reporter.onReport(KEY_TRY_APPLY_GOOGLEPLAY);
                 break;
-            case Utils.ERROR_PATCH_ALREADY_APPLY:
+            case ShareConstants.ERROR_PATCH_ALREADY_APPLY:
                 reporter.onReport(KEY_TRY_APPLY_ALREADY_APPLY);
                 break;
             case Utils.ERROR_PATCH_CRASH_LIMIT:
@@ -192,6 +203,7 @@ public static void onTryApplyFail(int errorCode) {
             case Utils.ERROR_PATCH_CONDITION_NOT_SATISFIED:
                 reporter.onReport(KEY_TRY_APPLY_CONDITION_NOT_SATISFIED);
                 break;
+
         }
     }
 
@@ -288,6 +300,25 @@ public static void onLoadFileNotFound(int fileType) {
         }
     }
 
+    public static void onLoadInterpretReport(int type, Throwable e) {
+        if (reporter == null) {
+            return;
+        }
+        switch (type) {
+            case ShareConstants.TYPE_INTERPRET_GET_INSTRUCTION_SET_ERROR:
+                reporter.onReport(KEY_LOADED_INTERPRET_GET_INSTRUCTION_SET_ERROR);
+                reporter.onReport("Tinker Exception:interpret occur exception " + Utils.getExceptionCauseString(e));
+                break;
+            case ShareConstants.TYPE_INTERPRET_COMMAND_ERROR:
+                reporter.onReport(KEY_LOADED_INTERPRET_INTERPRET_COMMAND_ERROR);
+                reporter.onReport("Tinker Exception:interpret occur exception " + Utils.getExceptionCauseString(e));
+                break;
+            case ShareConstants.TYPE_INTERPRET_OK:
+                reporter.onReport(KEY_LOADED_INTERPRET_TYPE_INTERPRET_OK);
+                break;
+        }
+    }
+
     public static void onLoadFileMisMatch(int fileType) {
         if (reporter == null) {
             return;
@@ -355,8 +386,14 @@ public static void onApplyDexOptFail(Throwable throwable) {
         if (reporter == null) {
             return;
         }
-        reporter.onReport(KEY_APPLIED_DEXOPT);
-        reporter.onReport("Tinker Exception:apply tinker occur exception " + Utils.getExceptionCauseString(throwable));
+        if (throwable.getMessage().contains(ShareConstants.CHECK_DEX_OAT_EXIST_FAIL)) {
+            reporter.onReport(KEY_APPLIED_DEXOPT_EXIST);
+        } else if (throwable.getMessage().contains(ShareConstants.CHECK_DEX_OAT_FORMAT_FAIL)) {
+            reporter.onReport(KEY_APPLIED_DEXOPT_FORMAT);
+        } else {
+            reporter.onReport(KEY_APPLIED_DEXOPT_OTHER);
+            reporter.onReport("Tinker Exception:apply tinker occur exception " + Utils.getExceptionCauseString(throwable));
+        }
     }
 
     public static void onApplyInfoCorrupted() {
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/service/SampleResultService.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/service/SampleResultService.java
index 3b62551f..34550ba8 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/service/SampleResultService.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/service/SampleResultService.java
@@ -16,10 +16,6 @@
 
 package tinker.sample.android.service;
 
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
 import android.os.Handler;
 import android.os.Looper;
 import android.widget.Toast;
@@ -28,7 +24,6 @@
 import com.tencent.tinker.lib.service.PatchResult;
 import com.tencent.tinker.lib.util.TinkerLog;
 import com.tencent.tinker.lib.util.TinkerServiceInternals;
-import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
 
 import java.io.File;
 
@@ -80,7 +75,7 @@ public void run() {
                     //we can wait process at background, such as onAppBackground
                     //or we can restart when the screen off
                     TinkerLog.i(TAG, "tinker wait screen to restart process");
-                    new ScreenState(getApplicationContext(), new ScreenState.IOnScreenOff() {
+                    new Utils.ScreenState(getApplicationContext(), new Utils.ScreenState.IOnScreenOff() {
                         @Override
                         public void onScreenOff() {
                             restartProcess();
@@ -102,31 +97,4 @@ private void restartProcess() {
         android.os.Process.killProcess(android.os.Process.myPid());
     }
 
-    static class ScreenState {
-        interface IOnScreenOff {
-            void onScreenOff();
-        }
-
-        ScreenState(Context context, final IOnScreenOff onScreenOffInterface) {
-            IntentFilter filter = new IntentFilter();
-            filter.addAction(Intent.ACTION_SCREEN_OFF);
-            context.registerReceiver(new BroadcastReceiver() {
-
-                @Override
-                public void onReceive(Context context, Intent in) {
-                    String action = in == null ? "" : in.getAction();
-                    TinkerLog.i(TAG, "ScreenReceiver action [%s] ", action);
-                    if (Intent.ACTION_SCREEN_OFF.equals(action)) {
-
-                        context.unregisterReceiver(this);
-
-                        if (onScreenOffInterface != null) {
-                            onScreenOffInterface.onScreenOff();
-                        }
-                    }
-                }
-            }, filter);
-        }
-    }
-
 }
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/TinkerManager.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/util/TinkerManager.java
index d22e30f5..e3af535f 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/TinkerManager.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/util/TinkerManager.java
@@ -23,6 +23,7 @@
 import com.tencent.tinker.lib.reporter.PatchReporter;
 import com.tencent.tinker.lib.tinker.TinkerInstaller;
 import com.tencent.tinker.lib.util.TinkerLog;
+import com.tencent.tinker.lib.util.UpgradePatchRetry;
 import com.tencent.tinker.loader.app.ApplicationLike;
 
 import tinker.sample.android.crash.SampleUncaughtExceptionHandler;
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/Utils.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/util/Utils.java
index 8767307d..7c19509b 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/Utils.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/util/Utils.java
@@ -16,9 +16,14 @@
 
 package tinker.sample.android.util;
 
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
 import android.os.Environment;
 import android.os.StatFs;
 
+import com.tencent.tinker.lib.util.TinkerLog;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 
 import java.io.ByteArrayOutputStream;
@@ -30,18 +35,17 @@
  * Created by zhangshaowen on 16/4/7.
  */
 public class Utils {
+    private static final String TAG = "Tinker.Utils";
 
     /**
      * the error code define by myself
      * should after {@code ShareConstants.ERROR_PATCH_INSERVICE
      */
-    public static final int ERROR_PATCH_GOOGLEPLAY_CHANNEL      = -5;
-    public static final int ERROR_PATCH_ROM_SPACE               = -6;
-    public static final int ERROR_PATCH_MEMORY_LIMIT            = -7;
-    public static final int ERROR_PATCH_ALREADY_APPLY           = -8;
-    public static final int ERROR_PATCH_CRASH_LIMIT             = -9;
-    public static final int ERROR_PATCH_RETRY_COUNT_LIMIT       = -10;
-    public static final int ERROR_PATCH_CONDITION_NOT_SATISFIED = -11;
+    public static final int ERROR_PATCH_GOOGLEPLAY_CHANNEL      = -20;
+    public static final int ERROR_PATCH_ROM_SPACE               = -21;
+    public static final int ERROR_PATCH_MEMORY_LIMIT            = -22;
+    public static final int ERROR_PATCH_CRASH_LIMIT             = -23;
+    public static final int ERROR_PATCH_CONDITION_NOT_SATISFIED = -24;
 
     public static final String PLATFORM = "platform";
 
@@ -154,4 +158,30 @@ private static String toVisualString(String src) {
             return src;
         }
     }
+
+    public static class ScreenState {
+        public interface IOnScreenOff {
+            void onScreenOff();
+        }
+
+        public ScreenState(final Context context, final IOnScreenOff onScreenOffInterface) {
+            IntentFilter filter = new IntentFilter();
+            filter.addAction(Intent.ACTION_SCREEN_OFF);
+
+            context.registerReceiver(new BroadcastReceiver() {
+
+                @Override
+                public void onReceive(Context context, Intent in) {
+                    String action = in == null ? "" : in.getAction();
+                    TinkerLog.i(TAG, "ScreenReceiver action [%s] ", action);
+                    if (Intent.ACTION_SCREEN_OFF.equals(action)) {
+                        if (onScreenOffInterface != null) {
+                            onScreenOffInterface.onScreenOff();
+                        }
+                    }
+                    context.unregisterReceiver(this);
+                }
+            }, filter);
+        }
+    }
 }
diff --git a/tinker-sample-android/build.gradle b/tinker-sample-android/build.gradle
index 08af2ebf..35bd3a36 100644
--- a/tinker-sample-android/build.gradle
+++ b/tinker-sample-android/build.gradle
@@ -2,10 +2,15 @@
 buildscript {
     repositories {
         mavenLocal()
+        google()
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.2.0'
+        if (project.hasProperty('GRADLE_3') && GRADLE_3.equalsIgnoreCase('TRUE')) {
+            classpath 'com.android.tools.build:gradle:3.0.0-rc2'
+        } else {
+            classpath 'com.android.tools.build:gradle:2.3.3'
+        }
         classpath "com.tencent.tinker:tinker-patch-gradle-plugin:${TINKER_VERSION}"
     }
 }
@@ -13,7 +18,13 @@ buildscript {
 allprojects {
     repositories {
         mavenLocal()
+        google()
         jcenter()
     }
 }
 
+def is_gradle_3() {
+    return hasProperty('GRADLE_3') && GRADLE_3.equalsIgnoreCase('TRUE')
+}
+
+
diff --git a/tinker-sample-android/gradle.properties b/tinker-sample-android/gradle.properties
index 25a8de5a..31d743c1 100644
--- a/tinker-sample-android/gradle.properties
+++ b/tinker-sample-android/gradle.properties
@@ -17,4 +17,5 @@
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
 
-TINKER_VERSION=1.7.7
+TINKER_VERSION=1.9.2
+GRADLE_3=true
\ No newline at end of file
diff --git a/tinker-sample-android/gradle/wrapper/gradle-wrapper.properties b/tinker-sample-android/gradle/wrapper/gradle-wrapper.properties
index 86d6158a..be4d6574 100644
--- a/tinker-sample-android/gradle/wrapper/gradle-wrapper.properties
+++ b/tinker-sample-android/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Wed Oct 21 11:34:03 PDT 2015
+#Tue Oct 24 15:01:44 CST 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip
diff --git a/tinker-sample-android/proguard-rules.pro b/tinker-sample-android/proguard-rules.pro
deleted file mode 100644
index ca7ea794..00000000
--- a/tinker-sample-android/proguard-rules.pro
+++ /dev/null
@@ -1,17 +0,0 @@
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in /Users/zhangshaowen/Library/Android/sdk/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the proguardFiles
-# directive in build.gradle.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
diff --git a/tinker-sample-android/updateTinkerLib.sh b/tinker-sample-android/updateTinkerLib.sh
index 30ae62b1..8511ab5f 100755
--- a/tinker-sample-android/updateTinkerLib.sh
+++ b/tinker-sample-android/updateTinkerLib.sh
@@ -2,4 +2,4 @@
 rm -rf ~/.gradle/caches/modules-2/metadata-2.16/descriptors/com.tencent.tinker
 
 #rm -rf ~/.m2/repository/com/tencent/tinker
-#adb push ./app/build/outputs/tinkerPatch/debug/patch_signed_7zip.apk /storage/sdcard0/
\ No newline at end of file
+#adb push ./app/build/outputs/tinkerPatch/debug/patch_signed_7zip.apk /sdcard/
\ No newline at end of file
