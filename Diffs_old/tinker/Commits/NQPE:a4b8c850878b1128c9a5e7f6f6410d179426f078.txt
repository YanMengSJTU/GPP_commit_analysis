diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
index 3fa21b51..5651c29f 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/AndroidNClassLoader.java
@@ -38,6 +38,23 @@
  */
 @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
 class AndroidNClassLoader extends PathClassLoader {
+    /**
+     * 我们知道，在Dalvik虚拟机中，总是在运行时通过JIT（Just-In—Time）把字节码文件编译成机器码文件再执行，
+     * 这样跑起来程序就很慢，所在ART上，改为AOT（Ahead-Of—Time）提前编译，
+     * 即在安装应用或OTA系统升级时提前把字节码编译成机器码，这样就可以直接执行了，提高了运行效率。
+     * 但是AOT有个缺点就是每次执行的时间都太长了，并且占用的ROM空间又很大，
+     * 所以在Android N上Google做了混合编译同时支持JIT和AOT。混合编译的作用简单来说，在应用运行时分析运行过的代码以及“热代码”，
+     * 并将配置存储下来。在设备空闲与充电时，ART仅仅编译这份配置中的“热代码”。
+     *简单来说，就是在应用安装和首次运行不做AOT编译，先让用户愉快的玩耍起来，
+     * 然后把在运行中JIT解释执行的那部分代码收集起来，在手机空闲的时候通过dex2aot编译生成一份名为app image的base.art文件，
+     * 然后在下次启动的时候一次性把app image加载进来到缓存，预先加载代替用时查找以提升应用的性能。
+     *这种方式对热补丁的影响就是，app image中已经存在的类会被插入到ClassLoader的ClassTable，再次加载类时，
+     * 直接从ClassTable中取而不会走DefineClass。假设base.art文件在补丁前已经存在，这里存在三种情况：
+     *1.补丁修改的类都不appimage中；这种情况是最理想的，此时补丁机制依然有效；
+     *2.补丁修改的类部分在appimage中；这种情况我们只能更新一部分的类，此时是最危险的。一部分类是新的，一部分类是旧的，app可能会出现地址错乱而出现crash。
+     *3.补丁修改的类全部在appimage中；这种情况只是造成补丁不生效，app并不会因此造成crash。
+     *Tinker的解决方案是，完全废弃掉PathClassloader，而采用一个新建Classloader来加载后续的所有类，即可达到将cache无用化的效果
+     */
     static ArrayList<DexFile> oldDexFiles = new ArrayList<>();
     PathClassLoader originClassLoader;
 
@@ -46,6 +63,16 @@ private AndroidNClassLoader(String dexPath, PathClassLoader parent) {
         originClassLoader = parent;
     }
 
+    /**
+     *新建一个AndroidNClassLoader 它的parent是originPathClassLoader。
+     *注意，PathClassLoader的optimizedDirectory只能是null，这个后面还有用。
+     *找到originPathClassLoader中的pathList 和 pathList中的类型为ClassLoader的definingContext。
+     *替换definingContext为AndroidNClassLoader
+     *将AndroidNClassLoader中的pathList替换为originPathClassLoader的pathList。
+     * @param original
+     * @return
+     * @throws Exception
+     */
     private static AndroidNClassLoader createAndroidNClassLoader(PathClassLoader original) throws Exception {
         //let all element ""
         AndroidNClassLoader androidNClassLoader = new AndroidNClassLoader("",  original);
@@ -60,6 +87,7 @@ private static AndroidNClassLoader createAndroidNClassLoader(PathClassLoader ori
         pathListField.set(androidNClassLoader, originPathListObject);
 
         //we must recreate dexFile due to dexCache
+        //可能androidN上会存在dex缓存 所以需要把dexElements重新makePathElements一次新的来消除缓存
         List<File> additionalClassPathEntries = new ArrayList<>();
         Field dexElement = ShareReflectUtil.findField(originPathListObject, "dexElements");
         Object[] originDexElements = (Object[]) dexElement.get(originPathListObject);
@@ -77,6 +105,14 @@ private static AndroidNClassLoader createAndroidNClassLoader(PathClassLoader ori
         return androidNClassLoader;
     }
 
+    /**
+     * 将application以及mPackageInfo中的ClassLoader都替换为AndroidNClassLoader
+     * 作用是替换掉了mPackageInfo中的ClassLoader，mPackageInfo是LoadedApk的对象，代表了APK文件在内存中的表示，
+     * 诸如Apk文件的代码和资源，甚至代码里面的Activity，Service等组件的信息我们都可以通过此对象获取。
+     * @param application
+     * @param reflectClassLoader
+     * @throws Exception
+     */
     private static void reflectPackageInfoClassloader(Application application, ClassLoader reflectClassLoader) throws Exception {
         String defBase = "mBase";
         String defPackageInfo = "mPackageInfo";
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
index 6c8199fa..e9cb2c88 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java
@@ -52,7 +52,7 @@
 
     @SuppressLint("NewApi")
     public static void installDexes(Application application, PathClassLoader loader, File dexOptDir, List<File> files)
-        throws Throwable {
+            throws Throwable {
 
         if (!files.isEmpty()) {
             ClassLoader classLoader = loader;
@@ -111,13 +111,17 @@ private static boolean checkDexInstall(ClassLoader classLoader) throws ClassNotF
 
     /**
      * Installer for platform versions 23.
+     * 23 <= SDK < 24
+     Android 6.0 <= Android系统 < Android 7.0
+     Android6.0以后把makeDexElements给改了，改成了makePathElements(List,File,List)，
+     如果找不到的话再找一下makeDexElements(List,File,List)。其余没啥区别。
      */
     private static final class V23 {
 
         private static void install(ClassLoader loader, List<File> additionalClassPathEntries,
                                     File optimizedDirectory)
-            throws IllegalArgumentException, IllegalAccessException,
-            NoSuchFieldException, InvocationTargetException, NoSuchMethodException, IOException {
+                throws IllegalArgumentException, IllegalAccessException,
+                NoSuchFieldException, InvocationTargetException, NoSuchMethodException, IOException {
             /* The patched class loader is expected to be a descendant of
              * dalvik.system.BaseDexClassLoader. We modify its
              * dalvik.system.DexPathList pathList field to append additional DEX
@@ -127,8 +131,8 @@ private static void install(ClassLoader loader, List<File> additionalClassPathEn
             Object dexPathList = pathListField.get(loader);
             ArrayList<IOException> suppressedExceptions = new ArrayList<IOException>();
             ShareReflectUtil.expandFieldArray(dexPathList, "dexElements", makePathElements(dexPathList,
-                new ArrayList<File>(additionalClassPathEntries), optimizedDirectory,
-                suppressedExceptions));
+                    new ArrayList<File>(additionalClassPathEntries), optimizedDirectory,
+                    suppressedExceptions));
             if (suppressedExceptions.size() > 0) {
                 for (IOException e : suppressedExceptions) {
                     Log.w(TAG, "Exception in makePathElement", e);
@@ -143,14 +147,14 @@ private static void install(ClassLoader loader, List<File> additionalClassPathEn
          * {@code private static final dalvik.system.DexPathList#makePathElements}.
          */
         private static Object[] makePathElements(
-            Object dexPathList, ArrayList<File> files, File optimizedDirectory,
-            ArrayList<IOException> suppressedExceptions)
-            throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {
+                Object dexPathList, ArrayList<File> files, File optimizedDirectory,
+                ArrayList<IOException> suppressedExceptions)
+                throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {
 
             Method makePathElements;
             try {
                 makePathElements = ShareReflectUtil.findMethod(dexPathList, "makePathElements", List.class, File.class,
-                    List.class);
+                        List.class);
             } catch (NoSuchMethodException e) {
                 Log.e(TAG, "NoSuchMethodException: makePathElements(List,File,List) failure");
                 try {
@@ -173,13 +177,17 @@ private static void install(ClassLoader loader, List<File> additionalClassPathEn
 
     /**
      * Installer for platform versions 19.
+     * 19 <= SDK < 23
+     Android 4.4 <= Android系统 < Android 6.0
+     跟v14的区别不大，只是在makeDexElements方法中多加了一个参数suppressedExceptions异常数组，
+     另外在makeDexElements的catch异常中多加了一次重试
      */
     private static final class V19 {
 
         private static void install(ClassLoader loader, List<File> additionalClassPathEntries,
                                     File optimizedDirectory)
-            throws IllegalArgumentException, IllegalAccessException,
-            NoSuchFieldException, InvocationTargetException, NoSuchMethodException, IOException {
+                throws IllegalArgumentException, IllegalAccessException,
+                NoSuchFieldException, InvocationTargetException, NoSuchMethodException, IOException {
             /* The patched class loader is expected to be a descendant of
              * dalvik.system.BaseDexClassLoader. We modify its
              * dalvik.system.DexPathList pathList field to append additional DEX
@@ -189,8 +197,8 @@ private static void install(ClassLoader loader, List<File> additionalClassPathEn
             Object dexPathList = pathListField.get(loader);
             ArrayList<IOException> suppressedExceptions = new ArrayList<IOException>();
             ShareReflectUtil.expandFieldArray(dexPathList, "dexElements", makeDexElements(dexPathList,
-                new ArrayList<File>(additionalClassPathEntries), optimizedDirectory,
-                suppressedExceptions));
+                    new ArrayList<File>(additionalClassPathEntries), optimizedDirectory,
+                    suppressedExceptions));
             if (suppressedExceptions.size() > 0) {
                 for (IOException e : suppressedExceptions) {
                     Log.w(TAG, "Exception in makeDexElement", e);
@@ -204,14 +212,14 @@ private static void install(ClassLoader loader, List<File> additionalClassPathEn
          * {@code private static final dalvik.system.DexPathList#makeDexElements}.
          */
         private static Object[] makeDexElements(
-            Object dexPathList, ArrayList<File> files, File optimizedDirectory,
-            ArrayList<IOException> suppressedExceptions)
-            throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {
+                Object dexPathList, ArrayList<File> files, File optimizedDirectory,
+                ArrayList<IOException> suppressedExceptions)
+                throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {
 
             Method makeDexElements = null;
             try {
                 makeDexElements = ShareReflectUtil.findMethod(dexPathList, "makeDexElements", ArrayList.class, File.class,
-                    ArrayList.class);
+                        ArrayList.class);
             } catch (NoSuchMethodException e) {
                 Log.e(TAG, "NoSuchMethodException: makeDexElements(ArrayList,File,ArrayList) failure");
                 try {
@@ -233,8 +241,8 @@ private static void install(ClassLoader loader, List<File> additionalClassPathEn
 
         private static void install(ClassLoader loader, List<File> additionalClassPathEntries,
                                     File optimizedDirectory)
-            throws IllegalArgumentException, IllegalAccessException,
-            NoSuchFieldException, InvocationTargetException, NoSuchMethodException {
+                throws IllegalArgumentException, IllegalAccessException,
+                NoSuchFieldException, InvocationTargetException, NoSuchMethodException {
             /* The patched class loader is expected to be a descendant of
              * dalvik.system.BaseDexClassLoader. We modify its
              * dalvik.system.DexPathList pathList field to append additional DEX
@@ -243,19 +251,39 @@ private static void install(ClassLoader loader, List<File> additionalClassPathEn
             Field pathListField = ShareReflectUtil.findField(loader, "pathList");
             Object dexPathList = pathListField.get(loader);
             ShareReflectUtil.expandFieldArray(dexPathList, "dexElements", makeDexElements(dexPathList,
-                new ArrayList<File>(additionalClassPathEntries), optimizedDirectory));
+                    new ArrayList<File>(additionalClassPathEntries), optimizedDirectory));
         }
 
         /**
          * A wrapper around
          * {@code private static final dalvik.system.DexPathList#makeDexElements}.
+         * private static Element[] makeDexElements(ArrayList<File> files,
+         * File optimizedDirectory) {
+         * ArrayList<Element> elements = new ArrayList<Element>();
+         * for (File file : files) {
+         * ZipFile zip = null;
+         * DexFile dex = null;
+         * String name = file.getName();
+         * if (name.endsWith(DEX_SUFFIX)) {
+         * dex = loadDexFile(file, optimizedDirectory);
+         * } else if (name.endsWith(APK_SUFFIX) || name.endsWith(JAR_SUFFIX)
+         * || name.endsWith(ZIP_SUFFIX)) {
+         * zip = new ZipFile(file);
+         * }
+         * ……
+         * if ((zip != null) || (dex != null)) {
+         * elements.add(new Element(file, zip, dex));
+         * }
+         * }
+         * return elements.toArray(new Element[elements.size()]);
+         * }
          */
         private static Object[] makeDexElements(
-            Object dexPathList, ArrayList<File> files, File optimizedDirectory)
-            throws IllegalAccessException, InvocationTargetException,
-            NoSuchMethodException {
+                Object dexPathList, ArrayList<File> files, File optimizedDirectory)
+                throws IllegalAccessException, InvocationTargetException,
+                NoSuchMethodException {
             Method makeDexElements =
-                ShareReflectUtil.findMethod(dexPathList, "makeDexElements", ArrayList.class, File.class);
+                    ShareReflectUtil.findMethod(dexPathList, "makeDexElements", ArrayList.class, File.class);
 
             return (Object[]) makeDexElements.invoke(dexPathList, files, optimizedDirectory);
         }
@@ -266,8 +294,8 @@ private static void install(ClassLoader loader, List<File> additionalClassPathEn
      */
     private static final class V4 {
         private static void install(ClassLoader loader, List<File> additionalClassPathEntries, File optimizedDirectory)
-            throws IllegalArgumentException, IllegalAccessException,
-            NoSuchFieldException, IOException {
+                throws IllegalArgumentException, IllegalAccessException,
+                NoSuchFieldException, IOException {
             /* The patched class loader is expected to be a descendant of
              * dalvik.system.DexClassLoader. We modify its
              * fields mPaths, mFiles, mZips and mDexs to append additional DEX
@@ -283,7 +311,7 @@ private static void install(ClassLoader loader, List<File> additionalClassPathEn
             ZipFile[] extraZips = new ZipFile[extraSize];
             DexFile[] extraDexs = new DexFile[extraSize];
             for (ListIterator<File> iterator = additionalClassPathEntries.listIterator();
-                 iterator.hasNext();) {
+                 iterator.hasNext(); ) {
                 File additionalEntry = iterator.next();
                 String entryPath = additionalEntry.getAbsolutePath();
                 path.append(':').append(entryPath);
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java
index 90ebc589..8f57f6dc 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java
@@ -76,6 +76,7 @@ public static boolean loadTinkerJars(Application application, boolean tinkerLoad
             ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_CLASSLOADER_NULL);
             return false;
         }
+        //tinker/patch-2c150d85/dex/
         String dexPath = directory + "/" + DEX_PATH + "/";
         File optimizeDir = new File(directory + "/" + DEX_OPTIMIZE_PATH);
 //        Log.i(TAG, "loadTinkerJars: dex path: " + dexPath);
@@ -92,7 +93,7 @@ public static boolean loadTinkerJars(Application application, boolean tinkerLoad
             String path = dexPath + info.realName;
             File file = new File(path);
 
-            if (tinkerLoadVerifyFlag) {
+            if (tinkerLoadVerifyFlag) {//默认一般不验证MD5
                 long start = System.currentTimeMillis();
                 String checkMd5 = isArtPlatForm ? info.destMd5InArt : info.destMd5InDvm;
                 if (!SharePatchFileUtil.verifyDexFileMd5(file, checkMd5)) {
@@ -107,6 +108,14 @@ public static boolean loadTinkerJars(Application application, boolean tinkerLoad
             legalFiles.add(file);
         }
 
+
+        /**
+         * 至于全量新Dex在系统OTA之后触发dex2oat
+         * 可能导致App启动时ANR的问题，
+         * Tinker是通过在进入ApplicationLike之前判断fingerprint是否变化来得知系统是否进行过OTA，
+         * 然后根据判断结果手动触发多线程dex2oat加以缓解的。
+         */
+        //如果是厂商OTA 优化dex TODO
         if (isSystemOTA) {
             parallelOTAResult = true;
             parallelOTAThrowable = null;
@@ -157,6 +166,13 @@ public void onFailed(File dexFile, File optimizedDir, Throwable thr) {
     }
 
     /**
+     * 主要验证assets/dex_meta.txt里面的dex信息是否与补丁的真实dex匹配存在
+     *
+     * 补丁包assets/dex_meta.txt 里面的信息
+     * 以','分隔 分别对应：name, path, destMd5InDvm, destMd5InArt, dexDiffMd5, oldDexCrc, dexMode
+     * classes.dex,,3fa38034d90cf6fbd4207a4c0789dfb2,3fa38034d90cf6fbd4207a4c0789dfb2,8e244ce569c4b6c9c786d3b51d29ed32,2699196016,jar
+     * test.dex,,56900442eb5b7e1de45449d0685e6e00,56900442eb5b7e1de45449d0685e6e00,0,0,jar
+     * 主要是将meta信息里面的 K:info.realName V:info.destMd5InDvm 打包为map传入intent里面
      * all the dex files in meta file exist?
      * fast check, only check whether exist
      *
@@ -170,6 +186,7 @@ public static boolean checkComplete(String directory, ShareSecurityCheck securit
             return true;
         }
         dexList.clear();
+        //meta里面的信息封装为ShareDexDiffPatchInfo类 并add进dexList里
         ShareDexDiffPatchInfo.parseDexDiffPatchInfo(meta, dexList);
 
         if (dexList.isEmpty()) {
@@ -179,6 +196,7 @@ public static boolean checkComplete(String directory, ShareSecurityCheck securit
         HashMap<String, String> dexes = new HashMap<>();
 
         for (ShareDexDiffPatchInfo info : dexList) {
+            //默认一般都是dvm art双支持
             //for dalvik, ignore art support dex
             if (isJustArtSupportDex(info)) {
                 continue;
@@ -190,7 +208,7 @@ public static boolean checkComplete(String directory, ShareSecurityCheck securit
             }
             dexes.put(info.realName, info.destMd5InDvm);
         }
-        //tinker/patch.info/patch-641e634c/dex
+        //tinker/patch-2c150d85/dex/
         String dexDirectory = directory + "/" + DEX_PATH + "/";
 
         File dexDir = new File(dexDirectory);
@@ -199,6 +217,7 @@ public static boolean checkComplete(String directory, ShareSecurityCheck securit
             ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_DIRECTORY_NOT_EXIST);
             return false;
         }
+        //tinker/patch-2c150d85/odex/ 这个应该是dex优化目录
         String optimizeDexDirectory = directory + "/" + DEX_OPTIMIZE_PATH + "/";
         File optimizeDexDirectoryFile = new File(optimizeDexDirectory);
 
@@ -211,6 +230,7 @@ public static boolean checkComplete(String directory, ShareSecurityCheck securit
                 return false;
             }
             //check dex opt whether complete also
+            //查看优化文件是否存在
             File dexOptFile = new File(SharePatchFileUtil.optimizedPathFor(dexFile, optimizeDexDirectoryFile));
             if (!SharePatchFileUtil.isLegalFile(dexOptFile)) {
                 intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_MISSING_DEX_PATH, dexOptFile.getAbsolutePath());
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
index c0b85083..95c2faa9 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
@@ -171,10 +171,12 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
         resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_CONFIG, securityCheck.getPackagePropertiesIfPresent());
 
         final boolean isEnabledForDex = ShareTinkerInternals.isTinkerEnabledForDex(tinkerFlag);
-
+        //是否支持补丁修改dex类型
         if (isEnabledForDex) {
             //tinker/patch-2c150d85/dex
             //2017/1/17 18:33 分析断点
+            //主要是验证meta信息里面dex是否与补丁匹配
+            //并且将meta信息里面的 K:info.realName V:info.destMd5InDvm 打包为map传入intent里面
             boolean dexCheck = TinkerDexLoader.checkComplete(patchVersionDirectory, securityCheck, resultIntent);
             if (!dexCheck) {
                 //file not found, do not load patch
@@ -183,10 +185,11 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
             }
         }
 
+        //检查so补丁 TODO
         final boolean isEnabledForNativeLib = ShareTinkerInternals.isTinkerEnabledForNativeLib(tinkerFlag);
 
         if (isEnabledForNativeLib) {
-            //tinker/patch.info/patch-641e634c/lib
+            //tinker/patch-641e634c/lib
             boolean libCheck = TinkerSoLoader.checkComplete(patchVersionDirectory, securityCheck, resultIntent);
             if (!libCheck) {
                 //file not found, do not load patch
@@ -195,10 +198,11 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
             }
         }
 
-        //check resource
+        //check resource 检查res资源补丁
         final boolean isEnabledForResource = ShareTinkerInternals.isTinkerEnabledForResource(tinkerFlag);
         Log.w(TAG, "tryLoadPatchFiles:isEnabledForResource:" + isEnabledForResource);
         if (isEnabledForResource) {
+            //根据res_meta.xml文件中记载的信息检查文件(res/resources.apk)是否存在
             boolean resourceCheck = TinkerResourceLoader.checkComplete(app, patchVersionDirectory, securityCheck, resultIntent);
             if (!resourceCheck) {
                 //file not found, do not load patch
@@ -206,7 +210,7 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
                 return;
             }
         }
-        //only work for art platform oat
+        //only work for art platform oat //ota应该是ROM厂商的系统升级
         boolean isSystemOTA = ShareTinkerInternals.isVmArt() && ShareTinkerInternals.isSystemOTA(patchInfo.fingerPrint);
         resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_SYSTEM_OTA, isSystemOTA);
 
@@ -214,7 +218,7 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
         if (isSystemOTA
             || (mainProcess && versionChanged)) {
             patchInfo.oldVersion = version;
-            //update old version to new
+            //update old version to new 替换oldversion为newversion
             if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, patchInfo, patchInfoLockFile)) {
                 ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL);
                 Log.w(TAG, "tryLoadPatchFiles:onReWritePatchInfoCorrupted");
@@ -227,17 +231,20 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
             Log.w(TAG, "tryLoadPatchFiles:checkSafeModeCount fail");
             return;
         }
+        //前面的一系列都是检查补丁的信息情况 通过检查后 下面就进入真正的加载补丁功能
         //now we can load patch jar
         if (isEnabledForDex) {
+            //真正的开始加载补丁dex
             boolean loadTinkerJars = TinkerDexLoader.loadTinkerJars(app, tinkerLoadVerifyFlag, patchVersionDirectory, resultIntent, isSystemOTA);
             if (!loadTinkerJars) {
                 Log.w(TAG, "tryLoadPatchFiles:onPatchLoadDexesFail");
                 return;
             }
         }
-
+        //真正加载res资源
         //now we can load patch resource
         if (isEnabledForResource) {
+            //真正加载res资源
             boolean loadTinkerResources = TinkerResourceLoader.loadTinkerResources(app, tinkerLoadVerifyFlag, patchVersionDirectory, resultIntent);
             if (!loadTinkerResources) {
                 Log.w(TAG, "tryLoadPatchFiles:onPatchLoadResourcesFail");
@@ -250,6 +257,11 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
         return;
     }
 
+    /**
+     * 检查加载补丁安全次数是否超标
+     * @param application
+     * @return
+     */
     private boolean checkSafeModeCount(TinkerApplication application) {
         String processName = ShareTinkerInternals.getProcessName(application);
         String preferName = ShareConstants.TINKER_OWN_PREFERENCE_CONFIG + processName;
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourceLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourceLoader.java
index 167231b3..f7040b2e 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourceLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourceLoader.java
@@ -52,7 +52,7 @@ public static boolean loadTinkerResources(Context context, boolean tinkerLoadVer
         File resourceFile = new File(resourceString);
         long start = System.currentTimeMillis();
 
-        if (tinkerLoadVerifyFlag) {
+        if (tinkerLoadVerifyFlag) {//一般默认不验证MD5
             if (!SharePatchFileUtil.checkResourceArscMd5(resourceFile, resPatchInfo.resArscMd5)) {
                 Log.e(TAG, "Failed to load resource file, path: " + resourceFile.getPath() + ", expect md5: " + resPatchInfo.resArscMd5);
                 ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_RESOURCE_MD5_MISMATCH);
@@ -80,6 +80,7 @@ public static boolean loadTinkerResources(Context context, boolean tinkerLoadVer
     }
 
     /**
+     * 根据res_meta.xml文件中记载的信息检查文件(res/resources.apk)是否存在
      * resource file exist?
      * fast check, only check whether exist
      *
@@ -118,6 +119,7 @@ public static boolean checkComplete(Context context, String directory, ShareSecu
             return false;
         }
         try {
+            //判断是否支持反射更新资源
             TinkerResourcePatcher.isResourceCanPatch(context);
         } catch (Throwable e) {
             Log.e(TAG, "resource hook check failed.", e);
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
index 975c4e17..0d6b84a0 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
@@ -65,6 +65,16 @@
 
 //    private static boolean isMiuiSystem = false;
 
+    /**
+     * 判断是否支持反射更新资源
+     * 按照步骤来吧，首先新建一个AssetManager对象，其中对BaiduROM做了兼容(BaiduAssetManager)，拿到其中的addAssetPath方法的反射addAssetPathMethod，然后拿到ensureStringBlocks的反射，然后区分版本拿到Resources的集合。
+     SDK >= 19，从ResourcesManager中拿到mActiveResources变量，是个持有Resources的ArrayMap，赋值给references，Android N中该变量叫做mResourceReferences
+     SDK < 19，从ActivityThread中获取mActiveResources，是个HashMap持有Resources，赋值给references
+     如果references为空，说明该系统不支持资源补丁，throw 一个IllegalStateException被上层调用catch。
+
+     * @param context
+     * @throws Throwable
+     */
     public static void isResourceCanPatch(Context context) throws Throwable {
         //   - Replace mResDir to point to the external resource file instead of the .apk. This is
         //     used as the asset path for new Resources objects.
@@ -162,6 +172,12 @@ public static void isResourceCanPatch(Context context) throws Throwable {
     }
 
     /**
+     * 调用monkeyPatchExistingResources方法(这个方法的名字跟InstantRun的资源补丁方法名是一样的)，
+     * 将补丁资源路径(res/resources.apk)传递进去，
+     * 简单描述为反射调用新建的AssetManager的addAssetPath将路径穿进去，
+     * 然后主动调用ensureStringBlocks方法确保资源的字符串索引创建出来；
+     * 然后循环遍历持有Resources对象的references集合，依次替换其中的AssetManager为新建的AssetManager，
+     * 最后调用Resources.updateConfiguration将Resources对象的配置信息更新到最新状态，完成整个资源替换的过程。
      * @param context
      * @param externalResourceFile
      * @throws Throwable
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
index 9d485d78..0ae9ad7b 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
@@ -85,7 +85,7 @@
     public static final String TINKER_ENABLE_CONFIG           = "tinker_enable_";
 
     /**
-     * only for each process
+     * only for each process 就是SP的key:TINKER_OWN_PREFERENCE_CONFIG+ processName
      */
     public static final String TINKER_OWN_PREFERENCE_CONFIG = "tinker_own_config_";
     public static final String TINKER_SAFE_MODE_COUNT       = "safe_mode_count";
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareDexDiffPatchInfo.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareDexDiffPatchInfo.java
index a623f195..bf20c62f 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareDexDiffPatchInfo.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareDexDiffPatchInfo.java
@@ -66,6 +66,15 @@ public ShareDexDiffPatchInfo(String name, String path, String destMd5InDvm, Stri
         }
     }
 
+    /**
+     *
+     * 以','分隔 分别对应：name, path, destMd5InDvm, destMd5InArt, dexDiffMd5, oldDexCrc, dexMode
+     * assets/dex_meta.txt ：classes.dex,,3fa38034d90cf6fbd4207a4c0789dfb2,3fa38034d90cf6fbd4207a4c0789dfb2,8e244ce569c4b6c9c786d3b51d29ed32,2699196016,jar
+     *                       test.dex,,56900442eb5b7e1de45449d0685e6e00,56900442eb5b7e1de45449d0685e6e00,0,0,jar
+     * 封装为ShareDexDiffPatchInfo类 并add进dexList里
+     * @param meta assets/dex_meta.txt里面的字符串
+     * @param dexList
+     */
     public static void parseDexDiffPatchInfo(String meta, ArrayList<ShareDexDiffPatchInfo> dexList) {
         if (meta == null || meta.length() == 0) {
             return;
@@ -95,6 +104,11 @@ public static void parseDexDiffPatchInfo(String meta, ArrayList<ShareDexDiffPatc
 
     }
 
+    /**
+     * 验证ShareDexDiffPatchInfo在art或在dvm虚拟机中是否拥有匹配的md5
+     * @param info
+     * @return
+     */
     public static boolean checkDexDiffPatchInfo(ShareDexDiffPatchInfo info) {
         if (info == null) {
             return false;
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java
index 419efd88..5d1ef981 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java
@@ -398,6 +398,7 @@ public static String optimizedPathFor(File path, File optimizedDirectory) {
             if (lastDot < 0) {
                 fileName += ShareConstants.DEX_SUFFIX;
             } else {
+                //将.jar结尾的换为.dex
                 StringBuilder sb = new StringBuilder(lastDot + 4);
                 sb.append(fileName, 0, lastDot);
                 sb.append(ShareConstants.DEX_SUFFIX);
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java
index 6964e213..2060018b 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java
@@ -79,6 +79,13 @@ public static SharePatchInfo readAndCheckPropertyWithLock(File pathInfoFile, Fil
         return patchInfo;
     }
 
+    /**
+     * 将以前oldversion换为newversion并且写入patchinfofile里面
+     * @param pathInfoFile
+     * @param info
+     * @param lockFile
+     * @return
+     */
     public static boolean rewritePatchInfoFileWithLock(File pathInfoFile, SharePatchInfo info, File lockFile) {
         if (pathInfoFile == null || info == null || lockFile == null) {
             return false;
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareReflectUtil.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareReflectUtil.java
index 7ebc1dbd..8c33c75d 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareReflectUtil.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareReflectUtil.java
@@ -107,7 +107,11 @@ public static Method findMethod(Object instance, String name, Class<?>... parame
     /**
      * Replace the value of a field containing a non null array, by a new array containing the
      * elements of the original array plus the elements of extraElements.
-     *
+     * 注意传进来的值分别是pathList,”dexElements”和新生成的dexElements数组，
+     * 找到pathList的原始oldDexElements，然后生成一个新的数组combined，
+     * 长度是oldDexElements.length + newDexElements.length。
+     * 然后将newDexElements拷贝到combined的前面，将oldDexElements拷贝的combined的剩余位置，
+     * 我们称之为dex前置。
      * @param instance      the instance whose field is to be modified.
      * @param fieldName     the field to modify.
      * @param extraElements elements to append at the end of the array.
@@ -117,10 +121,11 @@ public static void expandFieldArray(Object instance, String fieldName, Object[]
         Field jlrField = findField(instance, fieldName);
 
         Object[] original = (Object[]) jlrField.get(instance);
+        //getClass().getComponentType()返回表示数组组件类型的 Class。如果此类不表示数组类，则此方法返回null
         Object[] combined = (Object[]) Array.newInstance(original.getClass().getComponentType(), original.length + extraElements.length);
 
         // NOTE: changed to copy extraElements first, for patch load first
-
+        //将newDexElements拷贝到combined的前面，将oldDexElements拷贝的combined的剩余位置
         System.arraycopy(extraElements, 0, combined, 0, extraElements.length);
         System.arraycopy(original, 0, combined, extraElements.length, original.length);
 
