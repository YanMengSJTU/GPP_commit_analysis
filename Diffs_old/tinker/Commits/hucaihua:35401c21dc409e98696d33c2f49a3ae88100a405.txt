diff --git a/README.md b/README.md
index 48b74f87..b1a559b4 100644
--- a/README.md
+++ b/README.md
@@ -1,6 +1,6 @@
 ## Tinker
 [![license](http://img.shields.io/badge/license-BSD3-brightgreen.svg?style=flat)](https://github.com/Tencent/tinker/blob/master/LICENSE)
-[![Release Version](https://img.shields.io/badge/release-1.7.3-red.svg)](https://github.com/Tencent/tinker/releases) 
+[![Release Version](https://img.shields.io/badge/release-1.7.5-red.svg)](https://github.com/Tencent/tinker/releases) 
 [![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg)](https://github.com/Tencent/tinker/pulls)
 [![WeChat Approved](https://img.shields.io/badge/Wechat_Approved-1.6.2-red.svg)](https://github.com/Tencent/tinker/wiki)
 
@@ -14,7 +14,7 @@ Add tinker-gradle-plugin as a dependency in your main `build.gradle` in the root
 ```gradle
 buildscript {
     dependencies {
-        classpath ('com.tencent.tinker:tinker-patch-gradle-plugin:1.7.3')
+        classpath ('com.tencent.tinker:tinker-patch-gradle-plugin:1.7.5')
     }
 }
 ```
@@ -24,9 +24,9 @@ Then you need to "apply" the plugin and add dependencies by adding the following
 ```gradle
 dependencies {
     //optional, help to generate the final application 
-    provided('com.tencent.tinker:tinker-android-anno:1.7.3')
+    provided('com.tencent.tinker:tinker-android-anno:1.7.5')
     //tinker's main Android lib
-    compile('com.tencent.tinker:tinker-android-lib:1.7.3') 
+    compile('com.tencent.tinker:tinker-android-lib:1.7.5') 
 }
 ...
 ...
diff --git a/gradle.properties b/gradle.properties
index 89e660e7..c59d32ae 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -16,5 +16,5 @@
 # This option should only be used with decoupled projects. More details, visit
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
-VERSION_NAME_PREFIX=1.7.3
+VERSION_NAME_PREFIX=1.7.5
 VERSION_NAME_SUFFIX=
\ No newline at end of file
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
index 2ab8a3de..7728158c 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java
@@ -18,13 +18,12 @@
 
 import android.content.Context;
 import android.content.pm.ApplicationInfo;
-import android.os.Build;
 import android.os.SystemClock;
 
 import com.tencent.tinker.commons.dexpatcher.DexPatchApplier;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
 import com.tencent.tinker.lib.tinker.Tinker;
 import com.tencent.tinker.lib.util.TinkerLog;
+import com.tencent.tinker.loader.TinkerParallelDexOptimizer;
 import com.tencent.tinker.loader.TinkerRuntimeException;
 import com.tencent.tinker.loader.shareutil.ShareConstants;
 import com.tencent.tinker.loader.shareutil.ShareDexDiffPatchInfo;
@@ -32,8 +31,6 @@
 import com.tencent.tinker.loader.shareutil.ShareSecurityCheck;
 import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
 
-import dalvik.system.DexFile;
-
 import java.io.BufferedInputStream;
 import java.io.BufferedOutputStream;
 import java.io.File;
@@ -72,9 +69,7 @@ protected static boolean tryRecoverDexFiles(Tinker manager, ShareSecurityCheck c
         return result;
     }
 
-    private static boolean patchDexExtractViaDexDiff(Context context, String patchVersionDirectory, String meta, File patchFile, boolean isUpgradePatch) {
-        checkVmArtProperty();
-
+    private static boolean patchDexExtractViaDexDiff(Context context, String patchVersionDirectory, String meta, final File patchFile, final boolean isUpgradePatch) {
         String dir = patchVersionDirectory + "/" + DEX_PATH + "/";
 
         int dexType = ShareTinkerInternals.isVmArt() ? TYPE_DEX_FOR_ART : TYPE_DEX;
@@ -83,39 +78,41 @@ private static boolean patchDexExtractViaDexDiff(Context context, String patchVe
             return false;
         }
 
-        Tinker manager = Tinker.with(context);
+        final Tinker manager = Tinker.with(context);
 
         File dexFiles = new File(dir);
         File[] files = dexFiles.listFiles();
 
         if (files != null) {
-            String optimizeDexDirectory = patchVersionDirectory + "/" + DEX_OPTIMIZE_PATH + "/";
+            final String optimizeDexDirectory = patchVersionDirectory + "/" + DEX_OPTIMIZE_PATH + "/";
             File optimizeDexDirectoryFile = new File(optimizeDexDirectory);
 
             if (!optimizeDexDirectoryFile.exists()) {
                 optimizeDexDirectoryFile.mkdirs();
             }
 
-            for (File file : files) {
-                try {
-                    String outputPathName = SharePatchFileUtil.optimizedPathFor(file, optimizeDexDirectoryFile);
-                    long start = System.currentTimeMillis();
-                    DexFile.loadDex(file.getAbsolutePath(), outputPathName, 0);
-                    TinkerLog.i(TAG, "success dex optimize file, path: %s, use time: %d", file.getPath(), (System.currentTimeMillis() - start));
-                } catch (Throwable e) {
-                    TinkerLog.e(TAG, "dex optimize or load failed, path:" + file.getPath());
-                    //delete file
-                    SharePatchFileUtil.safeDeleteFile(file);
-                    manager.getPatchReporter().onPatchDexOptFail(patchFile, file, optimizeDexDirectory, file.getName(), e, isUpgradePatch);
-                    return false;
-                }
-            }
+            boolean isSuccess = TinkerParallelDexOptimizer.optimizeAll(
+                    files, optimizeDexDirectoryFile,
+                    new TinkerParallelDexOptimizer.ResultCallback() {
+                        @Override
+                        public void onSuccess(File dexFile, File optimizedDir) {
+                            // Do nothing.
+                        }
+
+                        @Override
+                        public void onFailed(File dexFile, File optimizedDir, Throwable thr) {
+                            SharePatchFileUtil.safeDeleteFile(dexFile);
+                            manager.getPatchReporter().onPatchDexOptFail(patchFile, dexFile, optimizeDexDirectory, dexFile.getName(), thr, isUpgradePatch);
+                        }
+                    }
+            );
+
+            return isSuccess;
         }
 
         return true;
     }
 
-
     private static boolean extractDexDiffInternals(Context context, String dir, String meta, File patchFile, int type, boolean isUpgradePatch) {
         //parse
         ArrayList<ShareDexDiffPatchInfo> patchList = new ArrayList<>();
@@ -146,28 +143,6 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
             apk = new ZipFile(apkPath);
             patch = new ZipFile(patchFile);
 
-            SmallPatchedDexItemFile smallPatchInfoFile = null;
-
-            if (ShareTinkerInternals.isVmArt()) {
-                File extractedFile = new File(dir + ShareConstants.DEX_SMALLPATCH_INFO_FILE);
-                ZipEntry smallPatchInfoEntry = patch.getEntry(ShareConstants.DEX_SMALLPATCH_INFO_FILE);
-                if (smallPatchInfoEntry != null) {
-                    InputStream smallPatchInfoIs = null;
-                    try {
-                        smallPatchInfoIs = patch.getInputStream(smallPatchInfoEntry);
-                        smallPatchInfoFile = new SmallPatchedDexItemFile(smallPatchInfoIs);
-                    } catch (Throwable e) {
-                        TinkerLog.w(TAG, "failed to read small patched info. reason: " + e.getMessage());
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, ShareConstants.DEX_SMALLPATCH_INFO_FILE, type, isUpgradePatch);
-                        return false;
-                    } finally {
-                        SharePatchFileUtil.closeQuietly(smallPatchInfoIs);
-                    }
-                } else {
-                    TinkerLog.w(TAG, "small patch info is not exists, it's ok now.");
-                }
-            }
-
             for (ShareDexDiffPatchInfo info : patchList) {
                 long start = System.currentTimeMillis();
 
@@ -227,7 +202,7 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
                         return false;
                     }
                 } else if (dexDiffMd5.equals("0")) {
-                    // skip process old dex for dalvik vm
+                    // skip process old dex for real dalvik vm
                     if (!ShareTinkerInternals.isVmArt()) {
                         continue;
                     }
@@ -246,21 +221,12 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
                         return false;
                     }
 
-                    InputStream oldDexIs = null;
-                    try {
-                        oldDexIs = apk.getInputStream(rawApkFileEntry);
-                        new DexPatchApplier(oldDexIs, (int) rawApkFileEntry.getSize(), null, smallPatchInfoFile).executeAndSaveTo(extractedFile);
-                    } catch (Throwable e) {
-                        TinkerLog.w(TAG, "Failed to recover dex file " + extractedFile.getPath());
-                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type, isUpgradePatch);
-                        SharePatchFileUtil.safeDeleteFile(extractedFile);
-                        return false;
-                    } finally {
-                        SharePatchFileUtil.closeQuietly(oldDexIs);
-                    }
+                    // Small patched dex generating strategy was disabled, we copy full original dex directly now.
+                    //patchDexFile(apk, patch, rawApkFileEntry, null, info, smallPatchInfoFile, extractedFile);
+                    extractDexFile(apk, rawApkFileEntry, extractedFile, info);
 
                     if (!SharePatchFileUtil.verifyDexFileMd5(extractedFile, extractedFileMd5)) {
-                        TinkerLog.w(TAG, "Failed to recover dex file " + extractedFile.getPath());
+                        TinkerLog.w(TAG, "Failed to recover dex file when verify patched dex: " + extractedFile.getPath());
                         manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type, isUpgradePatch);
                         SharePatchFileUtil.safeDeleteFile(extractedFile);
                         return false;
@@ -291,61 +257,20 @@ private static boolean extractDexDiffInternals(Context context, String dir, Stri
                         return false;
                     }
 
-                    final boolean isRawDexFile = SharePatchFileUtil.isRawDexFile(info.rawName);
-                    InputStream oldInputStream = apk.getInputStream(rawApkFileEntry);
-                    InputStream newInputStream = patch.getInputStream(patchFileEntry);
-                    //if it is not the dex file or we are using jar mode, we should repack the output dex to jar
-                    try {
-                        if (!isRawDexFile || info.isJarMode) {
-                            FileOutputStream fos = new FileOutputStream(extractedFile);
-                            ZipOutputStream zos = new ZipOutputStream(new
-                                BufferedOutputStream(fos));
-
-                            try {
-                                zos.putNextEntry(new ZipEntry(ShareConstants.DEX_IN_JAR));
-                                //it is not a raw dex file, we do not want to any temp files
-                                int oldDexSize;
-                                if (!isRawDexFile) {
-                                    ZipEntry entry;
-                                    ZipInputStream zis = new ZipInputStream(oldInputStream);
-                                    while ((entry = zis.getNextEntry()) != null) {
-                                        if (ShareConstants.DEX_IN_JAR.equals(entry.getName())) break;
-                                    }
-                                    if (entry == null) {
-                                        throw new TinkerRuntimeException("can't recognize zip dex format file:" + extractedFile.getAbsolutePath());
-                                    }
-                                    oldInputStream = zis;
-                                    oldDexSize = (int) entry.getSize();
-                                } else {
-                                    oldDexSize = (int) rawApkFileEntry.getSize();
-                                }
-                                new DexPatchApplier(oldInputStream, oldDexSize, newInputStream, smallPatchInfoFile).executeAndSaveTo(zos);
-                                zos.closeEntry();
-                            } finally {
-                                SharePatchFileUtil.closeQuietly(zos);
-                            }
-
-                        } else {
-                            new DexPatchApplier(oldInputStream, (int) rawApkFileEntry.getSize(), newInputStream, smallPatchInfoFile).executeAndSaveTo(extractedFile);
-                        }
-                    } finally {
-                        SharePatchFileUtil.closeQuietly(oldInputStream);
-                        SharePatchFileUtil.closeQuietly(newInputStream);
-                    }
+                    patchDexFile(apk, patch, rawApkFileEntry, patchFileEntry, info, extractedFile);
 
                     if (!SharePatchFileUtil.verifyDexFileMd5(extractedFile, extractedFileMd5)) {
-                        TinkerLog.w(TAG, "Failed to recover dex file " + extractedFile.getPath());
+                        TinkerLog.w(TAG, "Failed to recover dex file when verify patched dex: " + extractedFile.getPath());
                         manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type, isUpgradePatch);
                         SharePatchFileUtil.safeDeleteFile(extractedFile);
                         return false;
                     }
+
                     TinkerLog.w(TAG, "success recover dex file: %s, use time: %d",
-                        extractedFile.getPath(), (System.currentTimeMillis() - start));
+                            extractedFile.getPath(), (System.currentTimeMillis() - start));
                 }
             }
-
         } catch (Throwable e) {
-//            e.printStackTrace();
             throw new TinkerRuntimeException("patch " + ShareTinkerInternals.getTypeString(type) + " extract failed (" + e.getMessage() + ").", e);
         } finally {
             SharePatchFileUtil.closeZip(apk);
@@ -379,7 +304,7 @@ private static boolean extractDexToJar(ZipFile zipFile, ZipEntry entryFile, File
             TinkerLog.i(TAG, "try Extracting " + extractTo.getPath());
             try {
                 zos = new ZipOutputStream(new
-                    BufferedOutputStream(fos));
+                        BufferedOutputStream(fos));
                 bis = new BufferedInputStream(in);
 
                 byte[] buffer = new byte[ShareConstants.BUFFER_SIZE];
@@ -409,15 +334,15 @@ private static boolean extractDexToJar(ZipFile zipFile, ZipEntry entryFile, File
         return isExtractionSuccessful;
     }
 
-    /**
-     * reject dalvik vm, but sdk version is larger than 21
-     */
-    private static void checkVmArtProperty() {
-        boolean art = ShareTinkerInternals.isVmArt();
-        if (!art && Build.VERSION.SDK_INT >= 21) {
-            throw new TinkerRuntimeException("it is dalvik vm, but sdk version " + Build.VERSION.SDK_INT + " is larger than 21!");
-        }
-    }
+//    /**
+//     * reject dalvik vm, but sdk version is larger than 21
+//     */
+//    private static void checkVmArtProperty() {
+//        boolean art = ShareTinkerInternals.isVmArt();
+//        if (!art && Build.VERSION.SDK_INT >= 21) {
+//            throw new TinkerRuntimeException(ShareConstants.CHECK_VM_PROPERTY_FAIL + ", it is dalvik vm, but sdk version " + Build.VERSION.SDK_INT + " is larger than 21!");
+//        }
+//    }
 
     private static boolean extractDexFile(ZipFile zipFile, ZipEntry entryFile, File extractTo, ShareDexDiffPatchInfo dexInfo) throws IOException {
         final String fileMd5 = ShareTinkerInternals.isVmArt() ? dexInfo.destMd5InArt : dexInfo.destMd5InDvm;
@@ -430,4 +355,70 @@ private static boolean extractDexFile(ZipFile zipFile, ZipEntry entryFile, File
         return extract(zipFile, entryFile, extractTo, fileMd5, true);
     }
 
+    /**
+     * Generate patched dex file (May wrapped it by a jar if needed.)
+     * @param baseApk
+     *   OldApk.
+     * @param patchPkg
+     *   Patch package, it is also a zip file.
+     * @param oldDexEntry
+     *   ZipEntry of old dex.
+     * @param patchFileEntry
+     *   ZipEntry of patch file. (also ends with .dex) This could be null.
+     * @param patchInfo
+     *   Parsed patch info from package-meta.txt
+     * @param patchedDexFile
+     *   Patched dex file, may be a jar.
+     *
+     * <b>Notice: patchFileEntry and smallPatchInfoFile cannot both be null.</b>
+     *
+     * @throws IOException
+     */
+    private static void patchDexFile(
+            ZipFile baseApk, ZipFile patchPkg, ZipEntry oldDexEntry, ZipEntry patchFileEntry,
+            ShareDexDiffPatchInfo patchInfo,  File patchedDexFile) throws IOException {
+        InputStream oldDexStream = null;
+        InputStream patchFileStream = null;
+        try {
+            oldDexStream = baseApk.getInputStream(oldDexEntry);
+            patchFileStream = (patchFileEntry != null ? patchPkg.getInputStream(patchFileEntry) : null);
+
+            final boolean isRawDexFile = SharePatchFileUtil.isRawDexFile(patchInfo.rawName);
+            if (!isRawDexFile || patchInfo.isJarMode) {
+                ZipOutputStream zos = null;
+                try {
+                    zos = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(patchedDexFile)));
+                    zos.putNextEntry(new ZipEntry(ShareConstants.DEX_IN_JAR));
+                    // Old dex is not a raw dex file.
+                    if (!isRawDexFile) {
+                        ZipInputStream zis = null;
+                        try {
+                            zis = new ZipInputStream(oldDexStream);
+                            ZipEntry entry;
+                            while ((entry = zis.getNextEntry()) != null) {
+                                if (ShareConstants.DEX_IN_JAR.equals(entry.getName())) break;
+                            }
+                            if (entry == null) {
+                                throw new TinkerRuntimeException("can't recognize zip dex format file:" + patchedDexFile.getAbsolutePath());
+                            }
+                            new DexPatchApplier(zis, (int) entry.getSize(), patchFileStream).executeAndSaveTo(zos);
+                        } finally {
+                            SharePatchFileUtil.closeQuietly(zis);
+                        }
+                    } else {
+                        new DexPatchApplier(oldDexStream, (int) oldDexEntry.getSize(), patchFileStream).executeAndSaveTo(zos);
+                    }
+                    zos.closeEntry();
+                } finally {
+                    SharePatchFileUtil.closeQuietly(zos);
+                }
+            } else {
+                new DexPatchApplier(oldDexStream, (int) oldDexEntry.getSize(), patchFileStream).executeAndSaveTo(patchedDexFile);
+            }
+        } finally {
+            SharePatchFileUtil.closeQuietly(oldDexStream);
+            SharePatchFileUtil.closeQuietly(patchFileStream);
+        }
+    }
+
 }
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/RepairPatch.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/RepairPatch.java
index 48a7395b..4ce5370c 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/RepairPatch.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/RepairPatch.java
@@ -66,9 +66,6 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
             return false;
         }
 
-        patchResult.patchTinkerID = signatureCheck.getNewTinkerID();
-        patchResult.baseTinkerID = signatureCheck.getTinkerID();
-
         //it is a old patch, so we should find a exist
         SharePatchInfo oldInfo = manager.getTinkerLoadResultIfPresent().patchInfo;
         String patchMd5 = SharePatchFileUtil.getMD5(patchFile);
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
index bde1e228..92f56a3b 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/UpgradePatch.java
@@ -17,6 +17,7 @@
 package com.tencent.tinker.lib.patch;
 
 import android.content.Context;
+import android.os.Build;
 
 import com.tencent.tinker.lib.service.PatchResult;
 import com.tencent.tinker.lib.tinker.Tinker;
@@ -63,9 +64,6 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
             return false;
         }
 
-        patchResult.patchTinkerID = signatureCheck.getNewTinkerID();
-        patchResult.baseTinkerID = signatureCheck.getTinkerID();
-
         //it is a new patch, so we should not find a exist
         SharePatchInfo oldInfo = manager.getTinkerLoadResultIfPresent().patchInfo;
         String patchMd5 = SharePatchFileUtil.getMD5(patchFile);
@@ -93,9 +91,9 @@ public boolean tryPatch(Context context, String tempPatchPath, PatchResult patch
                 manager.getPatchReporter().onPatchVersionCheckFail(patchFile, oldInfo, patchMd5, true);
                 return false;
             }
-            newInfo = new SharePatchInfo(oldInfo.oldVersion, patchMd5);
+            newInfo = new SharePatchInfo(oldInfo.oldVersion, patchMd5, Build.FINGERPRINT);
         } else {
-            newInfo = new SharePatchInfo("", patchMd5);
+            newInfo = new SharePatchInfo("", patchMd5, Build.FINGERPRINT);
         }
 
         //check ok, we can real recover a new patch
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java
index 7fe4c3e1..19f93f13 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultLoadReporter.java
@@ -215,6 +215,9 @@ public void onLoadException(Throwable e, int errorCode) {
                 ShareTinkerInternals.setTinkerDisableWithSharedPreferences(context);
                 TinkerLog.i(TAG, "dex exception disable tinker forever with sp");
                 break;
+            case ShareConstants.ERROR_LOAD_EXCEPTION_DEX_OPT:
+                TinkerLog.i(TAG, "patch load parallel dex opt exception: %s", e);
+                break;
             case ShareConstants.ERROR_LOAD_EXCEPTION_RESOURCE:
                 if (e.getMessage().contains(ShareConstants.CHECK_RES_INSTALL_FAIL)) {
                     TinkerLog.e(TAG, "tinker res check fail:" + e.getMessage());
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java
index f0e813f3..4bfc284d 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/reporter/DefaultPatchReporter.java
@@ -181,6 +181,10 @@ public void onPatchInfoCorrupted(File patchFile, String oldVersion, String newVe
     public void onPatchException(File patchFile, Throwable e, boolean isUpgradePatch) {
         TinkerLog.i(TAG, "patchReporter: patch exception path:%s, throwable:%s, isUpgrade:%b", patchFile.getAbsolutePath(), e.getMessage(), isUpgradePatch);
         TinkerLog.e(TAG, "tinker patch exception, welcome to submit issue to us: https://github.com/Tencent/tinker/issues");
+//        if (e.getMessage().contains(ShareConstants.CHECK_VM_PROPERTY_FAIL)) {
+//            ShareTinkerInternals.setTinkerDisableWithSharedPreferences(context);
+//            TinkerLog.i(TAG, "check vm property exception disable tinker forever with sp");
+//        }
         TinkerLog.printErrStackTrace(TAG, e, "tinker patch exception");
         //don't accept request any more!
         Tinker.with(context).setTinkerDisable();
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/AbstractResultService.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/AbstractResultService.java
index 0ecb1bca..19061bae 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/AbstractResultService.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/AbstractResultService.java
@@ -32,7 +32,6 @@
 
     private static final String RESULT_EXTRA = "result_extra";
 
-    private static Class<? extends AbstractResultService> resultServiceClass = null;
 
     /**
      * Creates an IntentService.  Invoked by your subclass's constructor.
@@ -41,27 +40,17 @@ public AbstractResultService() {
         super(AbstractResultService.class.getSimpleName());
     }
 
-    public static void runResultService(Context context, PatchResult result) {
+    public static void runResultService(Context context, PatchResult result, String resultServiceClass) {
         if (resultServiceClass == null) {
             throw new TinkerRuntimeException("resultServiceClass is null.");
         }
-        Intent intent = new Intent(context, resultServiceClass);
+        Intent intent = new Intent();
+        intent.setClassName(context, resultServiceClass);
         intent.putExtra(RESULT_EXTRA, result);
 
         context.startService(intent);
     }
 
-    public static void setResultServiceClass(Class<? extends AbstractResultService> serviceClass) {
-        resultServiceClass = serviceClass;
-        //try to load
-        try {
-            Class.forName(serviceClass.getName());
-        } catch (ClassNotFoundException e) {
-//            e.printStackTrace();
-        }
-
-    }
-
     @Override
     protected void onHandleIntent(Intent intent) {
         if (intent == null) {
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/PatchResult.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/PatchResult.java
index 9991c4e0..8ad6e9ad 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/PatchResult.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/PatchResult.java
@@ -35,12 +35,6 @@
     //@Nullable
     public String patchVersion;
 
-    //@Nullable
-    public String patchTinkerID;
-
-    //@Nullable
-    public String baseTinkerID;
-
     @Override
     public String toString() {
         StringBuffer sb = new StringBuffer();
@@ -52,12 +46,6 @@ public String toString() {
         if (patchVersion != null) {
             sb.append("patchVersion:" + patchVersion + "\n");
         }
-        if (patchTinkerID != null) {
-            sb.append("patchTinkerID:" + patchTinkerID + "\n");
-        }
-        if (baseTinkerID != null) {
-            sb.append("baseTinkerID:" + baseTinkerID + "\n");
-        }
 
         if (e != null) {
             sb.append("Throwable:" + e.getMessage() + "\n");
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
index 5afbdf35..49abd8f4 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/service/TinkerPatchService.java
@@ -42,9 +42,12 @@
 
     private static final String        PATCH_PATH_EXTRA      = "patch_path_extra";
     private static final String        PATCH_NEW_EXTRA       = "patch_new_extra";
+    private static final String        RESULT_CLASS_EXTRA    = "patch_result_class";
+
     private static       AbstractPatch upgradePatchProcessor = null;
-    private static       AbstractPatch repairPatchProcessor  = null;
-    private static       int           notificationId        = ShareConstants.TINKER_PATCH_SERVICE_NOTIFICATION;
+    private static       AbstractPatch                          repairPatchProcessor = null;
+    private static       int                                    notificationId       = ShareConstants.TINKER_PATCH_SERVICE_NOTIFICATION;
+    private static       Class<? extends AbstractResultService> resultServiceClass   = null;
 
     /**
      * Creates an IntentService.  Invoked by your subclass's constructor.
@@ -57,13 +60,20 @@ public static void runPatchService(Context context, String path, boolean isUpgra
         Intent intent = new Intent(context, TinkerPatchService.class);
         intent.putExtra(PATCH_PATH_EXTRA, path);
         intent.putExtra(PATCH_NEW_EXTRA, isUpgradePatch);
-
+        intent.putExtra(RESULT_CLASS_EXTRA, resultServiceClass.getName());
         context.startService(intent);
     }
 
-    public static void setPatchProcessor(AbstractPatch upgradePatch, AbstractPatch repairPatch) {
+    public static void setPatchProcessor(AbstractPatch upgradePatch, AbstractPatch repairPatch, Class<? extends AbstractResultService> serviceClass) {
         upgradePatchProcessor = upgradePatch;
         repairPatchProcessor = repairPatch;
+        resultServiceClass = serviceClass;
+        //try to load
+        try {
+            Class.forName(serviceClass.getName());
+        } catch (ClassNotFoundException e) {
+//            e.printStackTrace();
+        }
     }
 
     public static String getPatchPathExtra(Intent intent) {
@@ -73,6 +83,13 @@ public static String getPatchPathExtra(Intent intent) {
         return ShareIntentUtil.getStringExtra(intent, PATCH_PATH_EXTRA);
     }
 
+    public static String getPatchResultExtra(Intent intent) {
+        if (intent == null) {
+            throw new TinkerRuntimeException("getPatchResultExtra, but intent is null");
+        }
+        return ShareIntentUtil.getStringExtra(intent, RESULT_CLASS_EXTRA);
+    }
+
     public static boolean getPatchUpgradeExtra(Intent intent) {
         if (intent == null) {
             throw new TinkerRuntimeException("getPatchUpgradeExtra, but intent is null");
@@ -144,15 +161,15 @@ protected void onHandleIntent(Intent intent) {
         patchResult.costTime = cost;
         patchResult.e = e;
 
-        AbstractResultService.runResultService(context, patchResult);
+        AbstractResultService.runResultService(context, patchResult, getPatchResultExtra(intent));
 
     }
 
     private void increasingPriority() {
-        if (Build.VERSION.SDK_INT > 24) {
-            TinkerLog.i(TAG, "for Android 7.1, we just ignore increasingPriority job");
-            return;
-        }
+//        if (Build.VERSION.SDK_INT > 24) {
+//            TinkerLog.i(TAG, "for Android 7.1, we just ignore increasingPriority job");
+//            return;
+//        }
         TinkerLog.i(TAG, "try to increase patch process priority");
         try {
             Notification notification = new Notification();
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java
index 8e46e2e7..c115dbb3 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/Tinker.java
@@ -136,8 +136,7 @@ public void install(Intent intentResult, Class<? extends AbstractResultService>
                         AbstractPatch upgradePatch, AbstractPatch repairPatch
     ) {
         sInstalled = true;
-        AbstractResultService.setResultServiceClass(serviceClass);
-        TinkerPatchService.setPatchProcessor(upgradePatch, repairPatch);
+        TinkerPatchService.setPatchProcessor(upgradePatch, repairPatch, serviceClass);
 
         if (!isTinkerEnabled()) {
             TinkerLog.e(TAG, "tinker is disabled");
diff --git a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java
index 46316274..ddeb1791 100644
--- a/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java
+++ b/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/tinker/TinkerLoadResult.java
@@ -18,6 +18,7 @@
 
 import android.content.Context;
 import android.content.Intent;
+import android.os.Build;
 
 import com.tencent.tinker.lib.util.TinkerLog;
 import com.tencent.tinker.loader.TinkerRuntimeException;
@@ -100,7 +101,7 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
                 resourceDirectory = new File(patchVersionDirectory, ShareConstants.RES_PATH);
                 resourceFile = new File(resourceDirectory, ShareConstants.RES_NAME);
             }
-            patchInfo = new SharePatchInfo(oldVersion, newVersion);
+            patchInfo = new SharePatchInfo(oldVersion, newVersion, Build.FINGERPRINT);
             versionChanged = !(oldVersion.equals(newVersion));
         }
 
@@ -116,6 +117,9 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
                 case ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_LOAD_EXCEPTION:
                     errorCode = ShareConstants.ERROR_LOAD_EXCEPTION_DEX;
                     break;
+                case ShareConstants.ERROR_LOAD_PATCH_VERSION_PARALLEL_DEX_OPT_EXCEPTION:
+                    errorCode = ShareConstants.ERROR_LOAD_EXCEPTION_DEX_OPT;
+                    break;
                 case ShareConstants.ERROR_LOAD_PATCH_VERSION_RESOURCE_LOAD_EXCEPTION:
                     errorCode = ShareConstants.ERROR_LOAD_EXCEPTION_RESOURCE;
                     break;
@@ -319,33 +323,6 @@ public boolean parseTinkerResult(Context context, Intent intentResult) {
 
     }
 
-    /**
-     * get the base tinkerId
-     *
-     * @return
-     */
-    public String getTinkerID() {
-        if (packageConfig != null) {
-            String tinkerId = packageConfig.get(ShareConstants.TINKER_ID);
-            return tinkerId;
-        }
-        return null;
-    }
-
-    /**
-     * get the new tinkerId
-     *
-     * @return
-     */
-    public String getNewTinkerID() {
-        if (packageConfig != null) {
-            String tinkerId = packageConfig.get(ShareConstants.NEW_TINKER_ID);
-
-            return tinkerId;
-        }
-        return null;
-    }
-
     /**
      * get package configs
      *
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java
index 2d8ed266..2b17dcee 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerDexLoader.java
@@ -29,12 +29,12 @@
 import com.tencent.tinker.loader.shareutil.ShareSecurityCheck;
 import com.tencent.tinker.loader.shareutil.ShareTinkerInternals;
 
-import dalvik.system.PathClassLoader;
-
 import java.io.File;
 import java.util.ArrayList;
 import java.util.HashMap;
 
+import dalvik.system.PathClassLoader;
+
 /**
  * Created by zhangshaowen on 16/3/8.
  * check the complete of the dex files
@@ -49,6 +49,9 @@
     private static final String                           DEX_OPTIMIZE_PATH = ShareConstants.DEX_OPTIMIZE_PATH;
     private static final ArrayList<ShareDexDiffPatchInfo> dexList           = new ArrayList<>();
 
+    private static boolean   parallelOTAResult;
+    private static Throwable parallelOTAThrowable;
+
     private TinkerDexLoader() {
     }
 
@@ -59,7 +62,7 @@ private TinkerDexLoader() {
      * @param application The application.
      */
     @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-    public static boolean loadTinkerJars(Application application, boolean tinkerLoadVerifyFlag, String directory, Intent intentResult) {
+    public static boolean loadTinkerJars(Application application, boolean tinkerLoadVerifyFlag, String directory, Intent intentResult, boolean isSystemOTA) {
         if (dexList.isEmpty()) {
             Log.w(TAG, "there is no dex to load");
             return true;
@@ -103,6 +106,33 @@ public static boolean loadTinkerJars(Application application, boolean tinkerLoad
             }
             legalFiles.add(file);
         }
+
+        if (isSystemOTA) {
+            parallelOTAResult = true;
+            parallelOTAThrowable = null;
+            Log.w(TAG, "systemOTA, try parallel oat dexes!!!!!");
+
+            TinkerParallelDexOptimizer.optimizeAll(
+                legalFiles, optimizeDir,
+                new TinkerParallelDexOptimizer.ResultCallback() {
+                    @Override
+                    public void onSuccess(File dexFile, File optimizedDir) {
+                        // Do nothing.
+                    }
+                    @Override
+                    public void onFailed(File dexFile, File optimizedDir, Throwable thr) {
+                        parallelOTAResult = false;
+                        parallelOTAThrowable = thr;
+                    }
+                }
+            );
+            if (!parallelOTAResult) {
+                Log.e(TAG, "parallel oat dexes failed");
+                intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION, parallelOTAThrowable);
+                ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_PARALLEL_DEX_OPT_EXCEPTION);
+                return false;
+            }
+        }
         try {
             SystemClassLoaderAdder.installDexes(application, classLoader, optimizeDir, legalFiles);
         } catch (Throwable e) {
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
index adfb88f7..a94227da 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java
@@ -197,8 +197,12 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
                 return;
             }
         }
+        //only work for art platform oat
+        boolean isSystemOTA = ShareTinkerInternals.isVmArt() && ShareTinkerInternals.isSystemOTA(patchInfo.fingerPrint);
+
         //we should first try rewrite patch info file, if there is a error, we can't load jar
-        if (mainProcess && versionChanged) {
+        if (isSystemOTA
+            || (mainProcess && versionChanged)) {
             patchInfo.oldVersion = version;
             //update old version to new
             if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, patchInfo, patchInfoLockFile)) {
@@ -215,7 +219,7 @@ private void tryLoadPatchFilesInternal(TinkerApplication app, int tinkerFlag, bo
         }
         //now we can load patch jar
         if (isEnabledForDex) {
-            boolean loadTinkerJars = TinkerDexLoader.loadTinkerJars(app, tinkerLoadVerifyFlag, patchVersionDirectory, resultIntent);
+            boolean loadTinkerJars = TinkerDexLoader.loadTinkerJars(app, tinkerLoadVerifyFlag, patchVersionDirectory, resultIntent, isSystemOTA);
             if (!loadTinkerJars) {
                 Log.w(TAG, "tryLoadPatchFiles:onPatchLoadDexesFail");
                 return;
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerParallelDexOptimizer.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerParallelDexOptimizer.java
new file mode 100644
index 00000000..6e69f849
--- /dev/null
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerParallelDexOptimizer.java
@@ -0,0 +1,134 @@
+/*
+ * Tencent is pleased to support the open source community by making Tinker available.
+ *
+ * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
+ *
+ * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * https://opensource.org/licenses/BSD-3-Clause
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.tencent.tinker.loader;
+
+import android.util.Log;
+
+import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
+
+import dalvik.system.DexFile;
+
+import java.io.File;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * Created by tangyinsheng on 2016/11/15.
+ */
+
+public final class TinkerParallelDexOptimizer {
+    private static final String TAG = "ParallelDexOptimizer";
+
+    /**
+     * Optimize (trigger dexopt or dex2oat) dexes.
+     *
+     * @param dexFiles
+     * @param optimizedDir
+     * @param cb
+     *
+     * @return
+     *  If all dexes are optimized successfully, return true. Otherwise return false.
+     */
+    public synchronized static boolean optimizeAll(File[] dexFiles, File optimizedDir, ResultCallback cb) {
+        final AtomicInteger successCount = new AtomicInteger(0);
+        return optimizeAllLocked(Arrays.asList(dexFiles), optimizedDir, successCount, cb);
+    }
+
+    /**
+     * Optimize (trigger dexopt or dex2oat) dexes.
+     *
+     * @param dexFiles
+     * @param optimizedDir
+     * @param cb
+     *
+     * @return
+     *  If all dexes are optimized successfully, return true. Otherwise return false.
+     */
+    public synchronized static boolean optimizeAll(Collection<File> dexFiles, File optimizedDir, ResultCallback cb) {
+        final AtomicInteger successCount = new AtomicInteger(0);
+        return optimizeAllLocked(dexFiles, optimizedDir, successCount, cb);
+    }
+
+    private static boolean optimizeAllLocked(Collection<File> dexFiles, File optimizedDir, AtomicInteger successCount, ResultCallback cb) {
+        final CountDownLatch lauch = new CountDownLatch(dexFiles.size());
+        final ExecutorService threadPool = Executors.newCachedThreadPool();
+        long startTick = System.nanoTime();
+        for (File dexFile : dexFiles) {
+            OptimizeWorker worker = new OptimizeWorker(dexFile, optimizedDir, successCount, lauch, cb);
+            threadPool.submit(worker);
+        }
+        try {
+            lauch.await();
+            long timeCost = (System.nanoTime() - startTick) / 1000000;
+            if (successCount.get() == dexFiles.size()) {
+                Log.i(TAG, "All dexes are optimized successfully, cost: " + timeCost + " ms.");
+                return true;
+            } else {
+                Log.e(TAG, "Dexes optimizing failed, some dexes are not optimized.");
+                return false;
+            }
+        } catch (InterruptedException e) {
+            Log.w(TAG, "Dex optimizing was interrupted.", e);
+            return false;
+        } finally {
+            threadPool.shutdown();
+        }
+    }
+
+    public interface ResultCallback {
+        void onSuccess(File dexFile, File optimizedDir);
+        void onFailed(File dexFile, File optimizedDir, Throwable thr);
+    }
+
+    private static class OptimizeWorker implements Runnable {
+        private final File dexFile;
+        private final File optimizedDir;
+        private final AtomicInteger successCount;
+        private final CountDownLatch waitingLauch;
+        private final ResultCallback callback;
+
+        OptimizeWorker(File dexFile, File optimizedDir, AtomicInteger successCount, CountDownLatch lauch, ResultCallback cb) {
+            this.dexFile = dexFile;
+            this.optimizedDir = optimizedDir;
+            this.successCount = successCount;
+            this.waitingLauch = lauch;
+            this.callback = cb;
+        }
+
+        @Override
+        public void run() {
+            try {
+                DexFile.loadDex(dexFile.getAbsolutePath(), SharePatchFileUtil.optimizedPathFor(this.dexFile, this.optimizedDir), 0);
+                successCount.incrementAndGet();
+                if (callback != null) {
+                    callback.onSuccess(dexFile, optimizedDir);
+                }
+            } catch (final Exception e) {
+                Log.e(TAG, "Failed to optimize dex: " + dexFile.getAbsolutePath(), e);
+                if (callback != null) {
+                    callback.onFailed(dexFile, optimizedDir, e);
+                }
+            } finally {
+                this.waitingLauch.countDown();
+            }
+        }
+    }
+}
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
index e3db652f..060bf0d8 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareConstants.java
@@ -39,8 +39,6 @@
     public static final String SO_META_FILE = "assets/so_meta.txt";
     public static final String SO_PATH      = "lib";
 
-    // If you changed this value, please change the same value in TypedValue, too.
-    public static final String DEX_SMALLPATCH_INFO_FILE = "smallpatch_info.ddextra";
 
     public static final String DEX_META_FILE            = "assets/dex_meta.txt";
     public static final String DEX_PATH                 = "dex";
@@ -50,6 +48,8 @@
 
     public static final String CHECK_DEX_INSTALL_FAIL = "checkDexInstall failed";
     public static final String CHECK_RES_INSTALL_FAIL = "checkResInstall failed";
+//    public static final String CHECK_VM_PROPERTY_FAIL = "checkVmArtProperty failed";
+
 
     public static final String RES_META_FILE       = "assets/res_meta.txt";
     public static final String RES_ARSC            = "resources.arsc";
@@ -123,13 +123,15 @@
     public static final int ERROR_LOAD_PATCH_INFO_BLANK                           = -5;
     public static final int ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST          = -6;
     public static final int ERROR_LOAD_PATCH_VERSION_FILE_NOT_EXIST               = -7;
-    public static final int ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL                   = -9;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_DIRECTORY_NOT_EXIST      = -10;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_FILE_NOT_EXIST           = -11;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_OPT_FILE_NOT_EXIST       = -12;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_CLASSLOADER_NULL         = -13;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_MD5_MISMATCH             = -14;
-    public static final int ERROR_LOAD_PATCH_VERSION_DEX_LOAD_EXCEPTION           = -15;
+    public static final int ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL                   = -8;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_DIRECTORY_NOT_EXIST      = -9;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_FILE_NOT_EXIST           = -10;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_OPT_FILE_NOT_EXIST       = -11;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_CLASSLOADER_NULL         = -12;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_MD5_MISMATCH             = -13;
+    public static final int ERROR_LOAD_PATCH_VERSION_DEX_LOAD_EXCEPTION           = -14;
+    public static final int ERROR_LOAD_PATCH_VERSION_PARALLEL_DEX_OPT_EXCEPTION   = -15;
+
     public static final int ERROR_LOAD_PATCH_VERSION_LIB_DIRECTORY_NOT_EXIST      = -16;
     public static final int ERROR_LOAD_PATCH_VERSION_LIB_FILE_NOT_EXIST           = -17;
     public static final int ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL              = -18;
@@ -149,6 +151,7 @@
     public static final int ERROR_LOAD_EXCEPTION_DEX      = -2;
     public static final int ERROR_LOAD_EXCEPTION_RESOURCE = -3;
     public static final int ERROR_LOAD_EXCEPTION_UNCAUGHT = -4;
+    public static final int ERROR_LOAD_EXCEPTION_DEX_OPT  = -5;
 
 
     //recover error code
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java
index ddfee922..31d368ad 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchFileUtil.java
@@ -208,17 +208,25 @@ public static boolean verifyDexFileMd5(File file, String md5) {
             try {
                 dexJar = new ZipFile(file);
                 ZipEntry classesDex = dexJar.getEntry(ShareConstants.DEX_IN_JAR);
-
                 // no code
                 if (null == classesDex) {
+                    Log.e(TAG, "There's no entry named: " + ShareConstants.DEX_IN_JAR + " in " + file.getAbsolutePath());
                     return false;
                 }
                 fileMd5 = getMD5(dexJar.getInputStream(classesDex));
             } catch (IOException e) {
-//                e.printStackTrace();
+                Log.e(TAG, "Bad dex jar file: " + file.getAbsolutePath(), e);
                 return false;
             } finally {
-                SharePatchFileUtil.closeZip(dexJar);
+                // Bugfix: some device redefined ZipFile, which is not implemented closeable.
+                // SharePatchFileUtil.closeZip(dexJar);
+                if (dexJar != null) {
+                    try {
+                        dexJar.close();
+                    } catch (Throwable thr) {
+                        // Ignored.
+                    }
+                }
             }
         }
 
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java
index f787fb38..0f07dcad 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/SharePatchInfo.java
@@ -16,6 +16,7 @@
 
 package com.tencent.tinker.loader.shareutil;
 
+import android.os.Build;
 import android.util.Log;
 
 import com.tencent.tinker.loader.TinkerRuntimeException;
@@ -33,14 +34,17 @@
     public static final int    MAX_EXTRACT_ATTEMPTS = ShareConstants.MAX_EXTRACT_ATTEMPTS;
     public static final String OLD_VERSION          = ShareConstants.OLD_VERSION;
     public static final String NEW_VERSION          = ShareConstants.NEW_VERSION;
+    public static final String FINGER_PRINT         = "print";
     private static final String TAG = "PatchInfo";
     public String oldVersion;
     public String newVersion;
+    public String fingerPrint;
 
-    public SharePatchInfo(String oldVer, String newVew) {
+    public SharePatchInfo(String oldVer, String newVew, String finger) {
         // TODO Auto-generated constructor stub
         this.oldVersion = oldVer;
         this.newVersion = newVew;
+        this.fingerPrint = finger;
     }
 
     public static SharePatchInfo readAndCheckPropertyWithLock(File pathInfoFile, File lockFile) {
@@ -99,6 +103,7 @@ private static SharePatchInfo readAndCheckProperty(File pathInfoFile) {
         int numAttempts = 0;
         String oldVer = null;
         String newVer = null;
+        String lastFingerPrint = null;
 
         while (numAttempts < MAX_EXTRACT_ATTEMPTS && !isReadPatchSuccessful) {
             numAttempts++;
@@ -109,8 +114,10 @@ private static SharePatchInfo readAndCheckProperty(File pathInfoFile) {
                 properties.load(inputStream);
                 oldVer = properties.getProperty(OLD_VERSION);
                 newVer = properties.getProperty(NEW_VERSION);
+                lastFingerPrint = properties.getProperty(FINGER_PRINT);
             } catch (IOException e) {
-                e.printStackTrace();
+//                e.printStackTrace();
+                Log.e(TAG, "read property failed, e:" + e);
             } finally {
                 SharePatchFileUtil.closeQuietly(inputStream);
             }
@@ -118,7 +125,7 @@ private static SharePatchInfo readAndCheckProperty(File pathInfoFile) {
             if (oldVer == null || newVer == null) {
                 continue;
             }
-            //oldver may be "" or 32 md5
+            //oldVer may be "" or 32 md5
             if ((!oldVer.equals("") && !SharePatchFileUtil.checkIfMd5Valid(oldVer)) || !SharePatchFileUtil.checkIfMd5Valid(newVer)) {
                 Log.w(TAG, "path info file  corrupted:" + pathInfoFile.getAbsolutePath());
                 continue;
@@ -128,7 +135,7 @@ private static SharePatchInfo readAndCheckProperty(File pathInfoFile) {
         }
 
         if (isReadPatchSuccessful) {
-            return new SharePatchInfo(oldVer, newVer);
+            return new SharePatchInfo(oldVer, newVer, lastFingerPrint);
         }
 
         return null;
@@ -159,6 +166,8 @@ private static boolean rewritePatchInfoFile(File pathInfoFile, SharePatchInfo in
             Properties newProperties = new Properties();
             newProperties.put(OLD_VERSION, info.oldVersion);
             newProperties.put(NEW_VERSION, info.newVersion);
+            newProperties.put(FINGER_PRINT, Build.FINGERPRINT);
+
             FileOutputStream outputStream = null;
             try {
                 outputStream = new FileOutputStream(pathInfoFile, false);
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareSecurityCheck.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareSecurityCheck.java
index d62e4693..40185a59 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareSecurityCheck.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareSecurityCheck.java
@@ -64,32 +64,6 @@ public ShareSecurityCheck(Context context) {
         return metaContentMap;
     }
 
-    /**
-     * get the base tinkerId
-     *
-     * @return
-     */
-    public String getTinkerID() {
-        if (packageProperties != null) {
-            String tinkerId = packageProperties.get(ShareConstants.TINKER_ID);
-            return tinkerId;
-        }
-        return null;
-    }
-
-    /**
-     * get the new tinkerId
-     *
-     * @return
-     */
-    public String getNewTinkerID() {
-        if (packageProperties != null) {
-            String tinkerId = packageProperties.get(ShareConstants.NEW_TINKER_ID);
-
-            return tinkerId;
-        }
-        return null;
-    }
     /**
      * Nullable
      *
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
index aba789cc..b1e73272 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/shareutil/ShareTinkerInternals.java
@@ -21,6 +21,7 @@
 import android.content.SharedPreferences;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
+import android.os.Build;
 import android.util.Log;
 
 import java.io.File;
@@ -47,7 +48,26 @@
     private static String tinkerID = null;
 
     public static boolean isVmArt() {
-        return VM_IS_ART;
+        return VM_IS_ART || Build.VERSION.SDK_INT >= 21;
+    }
+
+    public static boolean isSystemOTA(String lastFingerPrint) {
+        String currentFingerprint = Build.FINGERPRINT;
+        if (lastFingerPrint == null
+            || lastFingerPrint.equals("")
+            || currentFingerprint == null
+            || currentFingerprint.equals("")) {
+            Log.d(TAG, "fingerprint empty:" + lastFingerPrint + ",current:" + currentFingerprint);
+            return false;
+        } else {
+            if (lastFingerPrint.equals(currentFingerprint)) {
+                Log.d(TAG, "same fingerprint:" + currentFingerprint);
+                return false;
+            } else {
+                Log.d(TAG, "system OTA,fingerprint not equal:" + lastFingerPrint + "," + currentFingerprint);
+                return true;
+            }
+        }
     }
 
     public static boolean isNullOrNil(final String object) {
@@ -101,6 +121,7 @@ public static int checkSignatureAndTinkerID(Context context, File patchFile, Sha
             return ShareConstants.ERROR_PACKAGE_CHECK_PATCH_TINKER_ID_NOT_FOUND;
         }
         if (!oldTinkerId.equals(patchTinkerId)) {
+            Log.e(TAG, "tinkerId is not equal, base is " + oldTinkerId + ", but patch is " + patchTinkerId);
             return ShareConstants.ERROR_PACKAGE_CHECK_TINKER_ID_NOT_EQUAL;
         }
         return ShareConstants.ERROR_PACKAGE_CHECK_OK;
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
index 8f539a16..d3da11b3 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/TinkerPatchPlugin.groovy
@@ -51,27 +51,35 @@ class TinkerPatchPlugin implements Plugin<Project> {
 
         def configuration = project.tinkerPatch
 
-        project.android.registerTransform(new AuxiliaryInjectTransform(project))
+        if (!project.plugins.hasPlugin('com.android.application')) {
+            throw new GradleException('generateTinkerApk: Android Application plugin required')
+        }
 
-        project.afterEvaluate {
-            if (!project.plugins.hasPlugin('com.android.application')) {
-                throw new GradleException('generateTinkerApk: Android Application plugin required')
-            }
+        def android = project.extensions.android
 
-            def android = project.extensions.android
-            //add the tinker anno resource to the package exclude option
-            android.packagingOptions.exclude("META-INF/services/javax.annotation.processing.Processor")
-            android.packagingOptions.exclude("TinkerAnnoApplication.tmpl")
-            //open jumboMode
-            android.dexOptions.jumboMode = true
-            //close preDexLibraries
-            try {
-                android.dexOptions.preDexLibraries = false
-            } catch (Throwable e) {
-                //no preDexLibraries field, just continue
-            }
+        //add the tinker anno resource to the package exclude option
+        android.packagingOptions.exclude("META-INF/services/javax.annotation.processing.Processor")
+        android.packagingOptions.exclude("TinkerAnnoApplication.tmpl")
+
+        //open jumboMode
+        android.dexOptions.jumboMode = true
 
+        //close preDexLibraries
+        try {
+            android.dexOptions.preDexLibraries = false
+        } catch (Throwable e) {
+            //no preDexLibraries field, just continue
+        }
+
+        android.registerTransform(new AuxiliaryInjectTransform(project))
+
+        project.afterEvaluate {
             project.logger.error("----------------------tinker build warning ------------------------------------")
+            project.logger.error("tinker auto operation: ")
+            project.logger.error("excluding annotation processor and source template from app packaging. Enable dx jumboMode to reduce package size.")
+            project.logger.error("enable dx jumboMode to reduce package size.")
+            project.logger.error("disable preDexLibraries to prevent ClassDefNotFoundException when your app is booting.")
+            project.logger.error("")
             project.logger.error("tinker will change your build configs:")
             project.logger.error("we will add TINKER_ID=${configuration.buildConfig.tinkerId} in your build output manifest file build/intermediates/manifests/full/*")
             project.logger.error("")
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerManifestTask.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerManifestTask.groovy
index 50af6687..13fb0928 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerManifestTask.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/task/TinkerManifestTask.groovy
@@ -31,6 +31,8 @@ import org.gradle.api.tasks.TaskAction
 public class TinkerManifestTask extends DefaultTask {
     static final String MANIFEST_XML = TinkerPatchPlugin.TINKER_INTERMEDIATES + "AndroidManifest.xml"
     static final String TINKER_ID = "TINKER_ID"
+    static final String TINKER_ID_PREFIX = "tinker_id_"
+
     String manifestPath
     TinkerManifestTask() {
         group = 'tinker'
@@ -43,6 +45,9 @@ public class TinkerManifestTask extends DefaultTask {
         if (tinkerValue == null || tinkerValue.isEmpty()) {
             throw new GradleException('tinkerId is not set!!!')
         }
+
+        tinkerValue = TINKER_ID_PREFIX + tinkerValue
+
         project.logger.error("tinker add ${tinkerValue} to your AndroidManifest.xml ${manifestPath}")
 
         def ns = new Namespace("http://schemas.android.com/apk/res/android", "android")
diff --git a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/AuxiliaryInjectTransform.groovy b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/AuxiliaryInjectTransform.groovy
index c1a929b0..0e56aefc 100644
--- a/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/AuxiliaryInjectTransform.groovy
+++ b/tinker-build/tinker-patch-gradle-plugin/src/main/groovy/com/tencent/tinker/build/gradle/transform/AuxiliaryInjectTransform.groovy
@@ -259,6 +259,8 @@ public class AuxiliaryInjectTransform extends Transform {
             }
 
             if (!jarInputs.isEmpty()) {
+                Map<String, String> entryNameToJarPathMap = new HashMap<>()
+
                 jarInputs.each { jarInput ->
                     File jarInputFile = jarInput.file
                     File jarOutputFile = transformInvocation.outputProvider.getContentLocation(
@@ -285,6 +287,13 @@ public class AuxiliaryInjectTransform extends Transform {
                             AuxiliaryClassInjector.processJar(jarInputFile, jarOutputFile, new ProcessJarCallback() {
                                 @Override
                                 boolean onProcessClassEntry(String entryName) {
+                                    final String lastContainsJarPath = entryNameToJarPathMap.get(entryName)
+                                    if (lastContainsJarPath != null) {
+                                        printWarnLog("Duplicate zip entry ${entryName} found in ${lastContainsJarPath} and ${jarInputFile.absolutePath}")
+                                    } else {
+                                        entryNameToJarPathMap.put(entryName, jarInputFile.absolutePath)
+                                    }
+
                                     // If disabled or not a class file, skip transforming them.
                                     if (!this.isEnabled || !entryName.endsWith('.class')) {
                                         return false
@@ -337,7 +346,7 @@ public class AuxiliaryInjectTransform extends Transform {
 
     private void printWarnLog(String fmt, Object... vals) {
         final String title = TRANSFORM_NAME.capitalize()
-        this.project.logger.warn("[{}] {}", title,
+        this.project.logger.error("[{}] {}", title,
                 (vals == null || vals.length == 0 ? fmt : String.format(fmt, vals)))
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjector.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjector.java
index a74cfea6..ca82f447 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjector.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/auxiliaryclass/AuxiliaryClassInjector.java
@@ -87,9 +87,9 @@ private static void processJarHelper(File jarIn, File jarOut, ProcessJarCallback
             Map<String, Integer> processedEntryNamesMap = new HashMap<>();
             while ((entryIn = zis.getNextEntry()) != null) {
                 final String entryName = entryIn.getName();
-                ZipEntry entryOut = new ZipEntry(entryIn);
-                entryOut.setCompressedSize(-1);
                 if (!processedEntryNamesMap.containsKey(entryName)) {
+                    ZipEntry entryOut = new ZipEntry(entryIn);
+                    entryOut.setCompressedSize(-1);
                     zos.putNextEntry(entryOut);
                     if (!entryIn.isDirectory()) {
                         if (entryName.endsWith(".class")) {
@@ -104,14 +104,6 @@ private static void processJarHelper(File jarIn, File jarOut, ProcessJarCallback
                     }
                     zos.closeEntry();
                     processedEntryNamesMap.put(entryName, 1);
-                } else {
-                    int duplicateCount = processedEntryNamesMap.get(entryName);
-                    final String wrapperJarName
-                            = jarOut.getName().substring(0, jarOut.getName().lastIndexOf(".jar"))
-                            + "_dup_ew_" + duplicateCount + ".jar";
-                    File wrapperJarOut = new File(jarOut.getParentFile(), wrapperJarName);
-                    wrapEntryByJar(entryOut, zis, wrapperJarOut);
-                    processedEntryNamesMap.put(entryName, duplicateCount + 1);
                 }
             }
         } finally {
@@ -120,18 +112,6 @@ private static void processJarHelper(File jarIn, File jarOut, ProcessJarCallback
         }
     }
 
-    private static void wrapEntryByJar(ZipEntry ze, InputStream eData, File jarOut) throws IOException {
-        ZipOutputStream zos = null;
-        try {
-            zos = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(jarOut)));
-            zos.putNextEntry(ze);
-            Streams.copy(eData, zos);
-            zos.closeEntry();
-        } finally {
-            closeQuietly(zos);
-        }
-    }
-
     private static void processClass(InputStream classIn, OutputStream classOut) throws IOException {
         ClassReader cr = new ClassReader(classIn);
         ClassWriter cw = new ClassWriter(0);
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ApkDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ApkDecoder.java
index 679f3e2f..d099a697 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ApkDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ApkDecoder.java
@@ -116,7 +116,7 @@ public boolean patch(File oldFile, File newFile) throws Exception {
         for (File duplicateRes : resDuplicateFiles) {
 //            resPatchDecoder.patch(duplicateRes, null);
             Logger.e("Warning: res file %s is also match at dex or library pattern, "
-                + "we treat it as unchanged in the new resource_out.zip", getRelativeStringByOldDir(duplicateRes));
+                + "we treat it as unchanged in the new resource_out.zip", getRelativePathStringToOldFile(duplicateRes));
         }
 
         soPatchDecoder.onAllPatchesEnd();
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/BaseDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/BaseDecoder.java
index d6550847..8ea4eb5e 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/BaseDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/BaseDecoder.java
@@ -58,20 +58,16 @@ public Path getOutputPath(File file) {
         return config.mTempResultDir.toPath().resolve(getRelativePath(file));
     }
 
-    public String getRelativeString(File file) {
-        return config.mTempUnzipNewDir.toPath().relativize(file.toPath()).toString().replace("\\", "/");
+    public String getRelativePathStringToOldFile(File oldFile) {
+        return config.mTempUnzipOldDir.toPath().relativize(oldFile.toPath()).toString().replace("\\", "/");
     }
 
-    public String getParentRelativeString(File file) {
-        return config.mTempUnzipNewDir.toPath().relativize(file.getParentFile().toPath()).toString().replace("\\", "/");
+    public String getRelativePathStringToNewFile(File newFile) {
+        return config.mTempUnzipNewDir.toPath().relativize(newFile.toPath()).toString().replace("\\", "/");
     }
 
-    public String getRelativeStringByOldDir(File file) {
-        return config.mTempUnzipOldDir.toPath().relativize(file.toPath()).toString().replace("\\", "/");
-    }
-
-    public String getParentRelativeStringByOldDir(File file) {
-        return config.mTempUnzipOldDir.toPath().relativize(file.getParentFile().toPath()).toString().replace("\\", "/");
+    public String getParentRelativePathStringToNewFile(File newFile) {
+        return config.mTempUnzipNewDir.toPath().relativize(newFile.getParentFile().toPath()).toString().replace("\\", "/");
     }
 
     /**
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/BsDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/BsDiffDecoder.java
index 48e27930..a46b0d8b 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/BsDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/BsDiffDecoder.java
@@ -118,8 +118,8 @@ protected void writeLogFiles(File newFile, File oldFile, File bsDiff, String new
         if (metaWriter == null && logWriter == null) {
             return;
         }
-        String parentRelative = getParentRelativeString(newFile);
-        String relative = getRelativeString(newFile);
+        String parentRelative = getParentRelativePathStringToNewFile(newFile);
+        String relative = getRelativePathStringToNewFile(newFile);
 
         if (metaWriter != null) {
             String fileName = newFile.getName();
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
index 0a298879..14f16490 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/DexDiffDecoder.java
@@ -18,14 +18,11 @@
 
 
 import com.google.common.io.Files;
-
 import com.tencent.tinker.android.dex.ClassDef;
 import com.tencent.tinker.android.dex.Dex;
 import com.tencent.tinker.android.dex.DexFormat;
-import com.tencent.tinker.android.dx.util.Hex;
 import com.tencent.tinker.build.dexpatcher.DexPatchGenerator;
 import com.tencent.tinker.build.dexpatcher.util.SmallDexClassInfoCollector;
-import com.tencent.tinker.build.dexpatcher.util.SmallDexPatchGenerator;
 import com.tencent.tinker.build.info.InfoWriter;
 import com.tencent.tinker.build.patch.Configuration;
 import com.tencent.tinker.build.util.DexClassesComparator;
@@ -40,7 +37,6 @@
 import com.tencent.tinker.build.util.Utils;
 import com.tencent.tinker.commons.dexpatcher.DexPatchApplier;
 import com.tencent.tinker.commons.dexpatcher.DexPatcherLogger.IDexPatcherLogger;
-import com.tencent.tinker.commons.dexpatcher.struct.SmallPatchedDexItemFile;
 
 import org.jf.dexlib2.Opcodes;
 import org.jf.dexlib2.builder.BuilderMutableMethodImplementation;
@@ -48,6 +44,7 @@
 import org.jf.dexlib2.iface.DexFile;
 import org.jf.dexlib2.iface.Field;
 import org.jf.dexlib2.iface.Method;
+import org.jf.dexlib2.iface.MethodImplementation;
 import org.jf.dexlib2.writer.builder.BuilderField;
 import org.jf.dexlib2.writer.builder.BuilderMethod;
 import org.jf.dexlib2.writer.builder.DexBuilder;
@@ -121,13 +118,21 @@ public void onAllPatchesStart() throws IOException, TinkerPatchException {
 
     }
 
+    /**
+     * Provide /oldFileRoot/dir/to/oldDex, /newFileRoot/dir/to/newDex,
+     * return dir/to/oldDex or dir/to/newDex if any one is not null.
+     */
+    protected String getRelativeDexName(File oldDexFile, File newDexFile) {
+        return oldDexFile != null ? getRelativePathStringToOldFile(oldDexFile) : getRelativePathStringToNewFile(newDexFile);
+    }
+
     @SuppressWarnings("NewApi")
     @Override
     public boolean patch(final File oldFile, final File newFile) throws IOException, TinkerPatchException {
+        final String dexName = getRelativeDexName(oldFile, newFile);
+
         // first of all, we should check input files if excluded classes were modified.
-        Logger.d("Check for loader classes in dex: %s",
-            (oldFile == null ? getRelativeString(newFile) : getRelativeString(oldFile))
-        );
+        Logger.d("Check for loader classes in dex: %s", dexName);
 
         try {
             excludedClassModifiedChecker.checkIfExcludedClassWasModifiedInNewDex(oldFile, newFile);
@@ -152,23 +157,23 @@ public boolean patch(final File oldFile, final File newFile) throws IOException,
 
         File dexDiffOut = getOutputPath(newFile).toFile();
 
-        final String newMd5 = MD5.getMD5(newFile);
+        final String newMd5 = getRawOrWrappedDexMD5(newFile);
 
         //new add file
         if (oldFile == null || !oldFile.exists() || oldFile.length() == 0) {
             hasDexChanged = true;
             if (!config.mUsePreGeneratedPatchDex) {
-                copyNewDexAndMarkInMeta(newFile, newMd5, dexDiffOut);
+                copyNewDexAndLogToDexMeta(newFile, newMd5, dexDiffOut);
                 return true;
             }
         }
 
-        final String oldMd5 = MD5.getMD5(oldFile);
+        final String oldMd5 = getRawOrWrappedDexMD5(oldFile);
 
         if ((oldMd5 != null && !oldMd5.equals(newMd5)) || (oldMd5 == null && newMd5 != null)) {
             hasDexChanged = true;
             if (oldMd5 != null) {
-                checkAddedOrDeletedClasses(oldFile, newFile);
+                collectAddedOrDeletedClasses(oldFile, newFile);
             }
         }
 
@@ -179,7 +184,6 @@ public boolean patch(final File oldFile, final File newFile) throws IOException,
         // collect current old dex file and corresponding new dex file for further processing.
         oldAndNewDexFilePairList.add(new AbstractMap.SimpleEntry<>(oldFile, newFile));
 
-        final String dexName = (oldFile != null ? oldFile.getName() : newFile.getName());
         dexNameToRelatedInfoMap.put(dexName, relatedInfo);
 
         return true;
@@ -197,10 +201,16 @@ public void onAllPatchesEnd() throws Exception {
         } else {
             generatePatchInfoFile();
         }
+
+        addTestDex();
     }
 
     @SuppressWarnings("NewApi")
     private void generateStubModePatchDex() throws IOException {
+        Logger.e("\n!!!! It's proved that pre-generated dex mode has the same problem"
+                + " when inline optimization is done in the OS whose version is equal to or larger than 5.0. !!!!"
+                + "\n!!!! We're strongly NOT recommend you to use this mode now. !!!!\n");
+
         List<File> oldDexList = new ArrayList<>();
         List<File> newDexList = new ArrayList<>();
         for (AbstractMap.SimpleEntry<File, File> oldAndNewDexFilePair : oldAndNewDexFilePairList) {
@@ -254,6 +264,12 @@ private void generateStubModePatchDex() throws IOException {
                     }
                     List<BuilderMethod> builderMethods = new ArrayList<>();
                     for (Method parsedMethod : parsedClassDef.getMethods()) {
+                        MethodImplementation methodImpl = null;
+                        if (parsedMethod.getImplementation() != null) {
+                            methodImpl = new BuilderMutableMethodImplementation(
+                                    dexBuilder, parsedMethod.getImplementation()
+                            );
+                        }
                         BuilderMethod builderMethod = dexBuilder.internMethod(
                                 parsedMethod.getDefiningClass(),
                                 parsedMethod.getName(),
@@ -261,9 +277,7 @@ private void generateStubModePatchDex() throws IOException {
                                 parsedMethod.getReturnType(),
                                 parsedMethod.getAccessFlags(),
                                 parsedMethod.getAnnotations(),
-                                new BuilderMutableMethodImplementation(
-                                        dexBuilder, parsedMethod.getImplementation()
-                                )
+                                methodImpl
                         );
                         builderMethods.add(builderMethod);
                     }
@@ -296,28 +310,89 @@ private void generateStubModePatchDex() throws IOException {
         final String md5 = MD5.getMD5(dest);
 
         String meta = PREGENERATED_PATCH_DEX_NAME + "," + "" + "," + md5 + "," + md5 + "," + 0
-                        + "," + 0 + "," + dexMode;
+                + "," + 0 + "," + dexMode;
 
         Logger.d("\nPre-generated patch dex: %s, size:%d", dest.getAbsolutePath(), dest.length());
         Logger.d("DexDecoder:write pre-generated patch dex meta file data: %s", meta);
 
         metaWriter.writeLineToInfoFile(meta);
-
-        addTestDex();
     }
 
     @SuppressWarnings("NewApi")
     private void generatePatchInfoFile() throws IOException {
+        generatePatchedDexInfoFile();
+
+        // generateSmallPatchedDexInfoFile is blocked by issue we found in ART environment
+        // which indicates that if inline optimization is done on patched class, some error
+        // such as crash, ClassCastException, mistaken string fetching, etc. would happen.
+        //
+        // Instead, we will log all classN dexes as 'copy directly' in dex-meta, so that
+        // tinker patch applying procedure will copy them out and load them in ART environment.
+
+        //generateSmallPatchedDexInfoFile();
+
+        logDexesToDexMeta();
+
+        checkCrossDexMovingClasses();
+    }
+
+    @SuppressWarnings("NewApi")
+    private void logDexesToDexMeta() throws IOException {
+        Map<String, File> dexNameToClassNOldDexFileMap = new HashMap<>();
+        Set<File> realClassNDexFiles = new HashSet<>();
+
+        for (AbstractMap.SimpleEntry<File, File> oldAndNewDexFilePair : oldAndNewDexFilePairList) {
+            File oldFile = oldAndNewDexFilePair.getKey();
+            final String dexName = getRelativeDexName(oldFile, null);
+            if (isDexNameMatchesClassNPattern(dexName)) {
+                dexNameToClassNOldDexFileMap.put(dexName, oldFile);
+            }
+        }
+
+        // If we meet a case like:
+        // classes.dex, classes2.dex, classes4.dex, classes5.dex
+        // Since classes3.dex is missing, according to the logic in AOSP, we should not treat
+        // rest dexes as part of class N dexes.
+        for (int i = 0; i < dexNameToClassNOldDexFileMap.size(); ++i) {
+            final String expectedDexName = (i == 0 ? DexFormat.DEX_IN_JAR_NAME : "classes" + (i + 1) + ".dex");
+            if (dexNameToClassNOldDexFileMap.containsKey(expectedDexName)) {
+                File oldDexFile = dexNameToClassNOldDexFileMap.get(expectedDexName);
+                realClassNDexFiles.add(oldDexFile);
+            } else {
+                break;
+            }
+        }
+
+        for (AbstractMap.SimpleEntry<File, File> oldAndNewDexFilePair : oldAndNewDexFilePairList) {
+            final File oldDexFile = oldAndNewDexFilePair.getKey();
+            final File newDexFile = oldAndNewDexFilePair.getValue();
+            final String dexName = getRelativeDexName(oldDexFile, newDexFile);
+            final RelatedInfo relatedInfo = dexNameToRelatedInfoMap.get(dexName);
+            if (!relatedInfo.oldMd5.equals(relatedInfo.newMd5)) {
+                //logToDexMeta(newDexFile, oldDexFile, relatedInfo.dexDiffFile, relatedInfo.newOrFullPatchedMd5, relatedInfo.smallPatchedMd5, relatedInfo.dexDiffMd5);
+                logToDexMeta(newDexFile, oldDexFile, relatedInfo.dexDiffFile, relatedInfo.newOrFullPatchedMd5, relatedInfo.newOrFullPatchedMd5, relatedInfo.dexDiffMd5);
+            } else {
+                // For class N dexes, if new dex is the same as old dex, we should log it as 'copy directly'
+                // in dex meta to fix problems in Art environment.
+                if (realClassNDexFiles.contains(oldDexFile)) {
+                    //if (!"0".equals(relatedInfo.smallPatchedMd5)) {
+                    //    logToDexMeta(newDexFile, oldDexFile, null, "0", relatedInfo.smallPatchedMd5, "0");
+                    //}
+                    logToDexMeta(newDexFile, oldDexFile, null, "0", relatedInfo.oldMd5, "0");
+                }
+            }
+        }
+    }
+
+    @SuppressWarnings("NewApi")
+    private void generatePatchedDexInfoFile() {
         File tempFullPatchDexPath = new File(config.mOutFolder + File.separator + TypedValue.DEX_TEMP_PATCH_DIR + File.separator + "dalvik");
-        ensureDirectoryExist(tempFullPatchDexPath);
-        File tempSmallPatchDexPath = new File(config.mOutFolder + File.separator + TypedValue.DEX_TEMP_PATCH_DIR + File.separator + "art");
-        ensureDirectoryExist(tempSmallPatchDexPath);
 
         // Generate dex diff out and full patched dex if a pair of dex is different.
         for (AbstractMap.SimpleEntry<File, File> oldAndNewDexFilePair : oldAndNewDexFilePairList) {
             File oldFile = oldAndNewDexFilePair.getKey();
             File newFile = oldAndNewDexFilePair.getValue();
-            final String dexName = oldFile.getName();
+            final String dexName = getRelativeDexName(oldFile, newFile);
             RelatedInfo relatedInfo = dexNameToRelatedInfoMap.get(dexName);
 
             if (!relatedInfo.oldMd5.equals(relatedInfo.newMd5)) {
@@ -350,6 +425,9 @@ private void generatePatchInfoFile() throws IOException {
                 Logger.d("\nGen %s patch file:%s, size:%d, md5:%s", dexName, relatedInfo.dexDiffFile.getAbsolutePath(), relatedInfo.dexDiffFile.length(), relatedInfo.dexDiffMd5);
 
                 File tempFullPatchedDexFile = new File(tempFullPatchDexPath, dexName);
+                if (!tempFullPatchedDexFile.exists()) {
+                    ensureDirectoryExist(tempFullPatchedDexFile.getParentFile());
+                }
 
                 try {
                     new DexPatchApplier(oldFile, dexDiffOut).executeAndSaveTo(tempFullPatchedDexFile);
@@ -383,129 +461,30 @@ private void generatePatchInfoFile() throws IOException {
                 relatedInfo.newOrFullPatchedMd5 = relatedInfo.newMd5;
             }
         }
+    }
 
-        Set<File> classNOldDexFiles = new HashSet<>();
-
-        for (AbstractMap.SimpleEntry<File, File> oldAndNewDexFilePair : oldAndNewDexFilePairList) {
-            File oldFile = oldAndNewDexFilePair.getKey();
-            final String dexName = oldFile.getName();
-
-            if (isDexNameMatchesClassNPattern(dexName)) {
-                classNOldDexFiles.add(oldFile);
-            }
-        }
-
-        // If we meet a case like:
-        // classes.dex, classes2.dex, classes4.dex, classes5.dex
-        // Since classes3.dex is missing, according to the logic in AOSP, we should not treat
-        // rest dexes as part of class N dexes.
-        Map<String, File> dexNameToClassNOldDexFileMap = new HashMap<>();
-        for (File classNOldDex : classNOldDexFiles) {
-            dexNameToClassNOldDexFileMap.put(classNOldDex.getName(), classNOldDex);
-        }
-
-        boolean isRestDexNotInClassN = false;
-        for (int i = 0; i < classNOldDexFiles.size(); ++i) {
-            final String expectedDexName = (i == 0 ? DexFormat.DEX_IN_JAR_NAME : "classes" + (i + 1) + ".dex");
-            if (!dexNameToClassNOldDexFileMap.containsKey(expectedDexName)) {
-                isRestDexNotInClassN = true;
-            } else {
-                if (isRestDexNotInClassN) {
-                    File mistakenClassNOldDexFile = dexNameToClassNOldDexFileMap.get(expectedDexName);
-                    classNOldDexFiles.remove(mistakenClassNOldDexFile);
-                }
-            }
-        }
-
-        File tempSmallPatchInfoFile = new File(config.mTempResultDir, TypedValue.DEX_SMALLPATCH_INFO_FILE);
-        ensureDirectoryExist(tempSmallPatchInfoFile.getParentFile());
-
-        // So far we know whether a pair of dex is belong to class N dexes or other dexes.
-        // Then we collect class N dex pairs and other dex pairs by separate their old dex
-        // and full patched dex into different list.
-        SmallDexPatchGenerator smallDexPatchGenerator = new SmallDexPatchGenerator();
-        smallDexPatchGenerator.setLoaderClassPatterns(config.mDexLoaderPattern);
-        smallDexPatchGenerator.setLogger(dexPatcherLoggerBridge);
-
-        logWriter.writeLineToInfoFile("\nStart collecting old dex and full patched dex...");
-
-        List<File> classNOldDexFileList = new ArrayList<>();
-        List<File> classNFullPatchedDexFileList = new ArrayList<>();
-        List<File> otherOldDexFileList = new ArrayList<>();
-        List<File> otherFullPatchedDexFileList = new ArrayList<>();
-        for (AbstractMap.SimpleEntry<File, File> oldAndNewDexFilePair : oldAndNewDexFilePairList) {
-            File oldFile = oldAndNewDexFilePair.getKey();
-            final String dexName = oldFile.getName();
-            File fullPatchedFile = dexNameToRelatedInfoMap.get(dexName).newOrFullPatchedFile;
-            if (classNOldDexFiles.contains(oldFile)) {
-                classNOldDexFileList.add(oldFile);
-                classNFullPatchedDexFileList.add(fullPatchedFile);
-            } else {
-                otherOldDexFileList.add(oldFile);
-                otherFullPatchedDexFileList.add(fullPatchedFile);
-            }
-        }
-
-        logWriter.writeLineToInfoFile(String.format("\nCollected class N old dexes: %s", classNOldDexFileList));
-        logWriter.writeLineToInfoFile(String.format("Collected class N full patched dexes: %s", classNFullPatchedDexFileList));
-        logWriter.writeLineToInfoFile(String.format("\nCollected other old dexes: %s", otherOldDexFileList));
-        logWriter.writeLineToInfoFile(String.format("Collected other full patched dexes: %s", otherFullPatchedDexFileList));
-
-        smallDexPatchGenerator.appendDexGroup(DexGroup.wrap(classNOldDexFileList), DexGroup.wrap(classNFullPatchedDexFileList));
-
-        if (!otherOldDexFileList.isEmpty()) {
-            smallDexPatchGenerator.appendDexGroup(DexGroup.wrap(otherOldDexFileList), DexGroup.wrap(otherFullPatchedDexFileList));
-        }
-
-        try {
-            Logger.d("Start generating small patch info file...");
-            smallDexPatchGenerator.executeAndSaveTo(tempSmallPatchInfoFile);
-        } catch (Exception e) {
-            throw new TinkerPatchException("\nFailed to generate small patch info file.", e);
-        }
-        if (!tempSmallPatchInfoFile.exists()) {
-            throw new TinkerPatchException("can not find the small patch info file:" + tempSmallPatchInfoFile.getAbsolutePath());
+    private void addTestDex() throws IOException {
+        //write test dex
+        String dexMode = "jar";
+        if (config.mDexRaw) {
+            dexMode = "raw";
         }
 
-        SmallPatchedDexItemFile smallPatchedDexItemFile = new SmallPatchedDexItemFile(tempSmallPatchInfoFile);
+        final InputStream is = DexDiffDecoder.class.getResourceAsStream("/" + TEST_DEX_NAME);
+        String md5 = MD5.getMD5(is, 1024);
+        is.close();
 
-        // Generate small patched dex and write meta.
-        for (AbstractMap.SimpleEntry<File, File> oldAndNewDexFilePair : oldAndNewDexFilePairList) {
-            File oldFile = oldAndNewDexFilePair.getKey();
-            File newFile = oldAndNewDexFilePair.getValue();
-            final String dexName = oldFile.getName();
-            final String oldDexSignStr = Hex.toHexString(new Dex(oldFile).computeSignature(false));
-            File tempSmallPatchedFile = new File(tempSmallPatchDexPath, dexName);
-            RelatedInfo relatedInfo = dexNameToRelatedInfoMap.get(dexName);
-            File dexDiffFile = relatedInfo.dexDiffFile;
+        String meta = TEST_DEX_NAME + "," + "" + "," + md5 + "," + md5 + "," + 0 + "," + 0 + "," + dexMode;
 
-            if (!smallPatchedDexItemFile.isSmallPatchedDexEmpty(oldDexSignStr)) {
-                try {
-                    new DexPatchApplier(oldFile, dexDiffFile, smallPatchedDexItemFile).executeAndSaveTo(tempSmallPatchedFile);
-                } catch (Exception e) {
-                    e.printStackTrace();
-                    throw new TinkerPatchException(
-                            "Failed to generate temporary small patched dex, which makes MD5 generating procedure of small patched dex failed, either.", e
-                    );
-                }
-                if (!tempSmallPatchedFile.exists()) {
-                    throw new TinkerPatchException("can not find the temporary small patched dex file:" + tempSmallPatchInfoFile.getAbsolutePath());
-                }
-                relatedInfo.smallPatchedMd5 = MD5.getMD5(tempSmallPatchedFile);
-                Logger.d("\nGen %s for art small dex file:%s, size:%d, md5:%s", dexName, tempSmallPatchedFile.getAbsolutePath(), tempSmallPatchedFile.length(), relatedInfo.smallPatchedMd5);
-
-                if (relatedInfo.oldMd5.equals(relatedInfo.newMd5)) {
-                    // Unmodified dex, which has no dexDiffFile, and is ignored in dvm environment.
-                    // So we pass zero string to destMd5InDvm and dexDiffMd5.
-                    writeLogFiles(newFile, oldFile, relatedInfo.dexDiffFile, "0", relatedInfo.smallPatchedMd5, "0");
-                } else {
-                    writeLogFiles(newFile, oldFile, relatedInfo.dexDiffFile, relatedInfo.newOrFullPatchedMd5, relatedInfo.smallPatchedMd5, relatedInfo.dexDiffMd5);
-                }
-            }
-        }
+        File dest = new File(config.mTempResultDir + "/" + TEST_DEX_NAME);
+        FileOperation.copyResourceUsingStream(TEST_DEX_NAME, dest);
+        Logger.d("\nAdd test install result dex: %s, size:%d", dest.getAbsolutePath(), dest.length());
+        Logger.d("DexDecoder:write test dex meta file data: %s", meta);
 
-        addTestDex();
+        metaWriter.writeLineToInfoFile(meta);
+    }
 
+    private void checkCrossDexMovingClasses() {
         // Here we will check if any classes that were deleted in one dex
         // would be added to another dex. e.g. classA is deleted in dex0 and
         // added in dex1.
@@ -535,33 +514,11 @@ private void generatePatchInfoFile() throws IOException {
         }
     }
 
-    @Override
-    public void clean() {
-        metaWriter.close();
-        logWriter.close();
-    }
-
-    private void ensureDirectoryExist(File dir) {
-        if (!dir.exists()) {
-            if (!dir.mkdirs()) {
-                throw new TinkerPatchException("failed to create directory: " + dir);
-            }
-        }
-    }
-
-    private boolean isDexNameMatchesClassNPattern(String dexName) {
-        return (dexName.matches("^classes[0-9]*\\.dex$"));
-    }
-
-    private void copyNewDexAndMarkInMeta(File newFile, String newMd5, File output) throws IOException {
-        newMd5 = checkNewDexAndMd5(newMd5, newFile);
-        FileOperation.copyFileUsingStream(newFile, output);
-        writeLogFiles(newFile, null, null, newMd5, newMd5, "0");
-    }
-
-    private void checkAddedOrDeletedClasses(File oldFile, File newFile) throws IOException {
-        // Before starting real diff works, we collect added class descriptor
-        // and deleted class descriptor for further analysing.
+    /**
+     * Before starting real diff works, we collect added class descriptor
+     * and deleted class descriptor for further analysing in {@code checkCrossDexMovingClasses}.
+     */
+    private void collectAddedOrDeletedClasses(File oldFile, File newFile) throws IOException {
         Dex oldDex = new Dex(oldFile);
         Dex newDex = new Dex(newFile);
 
@@ -612,6 +569,15 @@ private void checkAddedOrDeletedClasses(File oldFile, File newFile) throws IOExc
         }
     }
 
+    private boolean isDexNameMatchesClassNPattern(String dexName) {
+        return (dexName.matches("^classes[0-9]*\\.dex$"));
+    }
+
+    private void copyNewDexAndLogToDexMeta(File newFile, String newMd5, File output) throws IOException {
+        FileOperation.copyFileUsingStream(newFile, output);
+        logToDexMeta(newFile, null, null, newMd5, newMd5, "0");
+    }
+
     private void checkDexChange(Dex originDex, Dex newDex) {
         DexClassesComparator classesCmptor = new DexClassesComparator("*");
         classesCmptor.setIgnoredRemovedClassDescPattern(config.mDexLoaderPattern);
@@ -652,59 +618,6 @@ private void checkDexChange(Dex originDex, Dex newDex) {
         }
     }
 
-    private void addTestDex() throws IOException {
-        //write test dex
-        String dexMode = "jar";
-        if (config.mDexRaw) {
-            dexMode = "raw";
-        }
-
-        final InputStream is = DexDiffDecoder.class.getResourceAsStream("/" + TEST_DEX_NAME);
-        String md5 = MD5.getMD5(is, 1024);
-        is.close();
-
-        String meta = TEST_DEX_NAME + "," + "" + "," + md5 + "," + md5 + "," + 0 + "," + 0 + "," + dexMode;
-
-        File dest = new File(config.mTempResultDir + "/" + TEST_DEX_NAME);
-        FileOperation.copyResourceUsingStream(TEST_DEX_NAME, dest);
-        Logger.d("\nAdd test install result dex: %s, size:%d", dest.getAbsolutePath(), dest.length());
-        Logger.d("DexDecoder:write test dex meta file data: %s", meta);
-
-        metaWriter.writeLineToInfoFile(meta);
-    }
-
-    private String checkNewDexAndMd5(String md5, File dexFile) {
-        String name = dexFile.getName();
-        if (name.endsWith(".dex")) {
-            return md5;
-        } else {
-            try {
-                final JarFile dexJar = new JarFile(dexFile);
-                ZipEntry classesDex = dexJar.getEntry(DexFormat.DEX_IN_JAR_NAME);
-                // no code
-                if (null == classesDex) {
-                    throw new TinkerPatchException(
-                        String.format("dex jar file %s do not contain 'classes.dex', it is not a correct dex jar file!", dexFile.getAbsolutePath())
-                    );
-                }
-
-                return MD5.getMD5(dexJar.getInputStream(classesDex), 1024 * 100);
-            } catch (IOException e) {
-                throw new TinkerPatchException(
-                    String.format("dex file %s is not end with '.dex', but it is not a correct dex jar file also!", dexFile.getAbsolutePath()), e
-                );
-            }
-        }
-    }
-
-    private String getRelativeStringBy(File file, File reference) {
-        File actualReference = reference.getParentFile();
-        if (actualReference == null) {
-            actualReference = reference;
-        }
-        return actualReference.toPath().relativize(file.toPath()).toString().replace("\\", "/");
-    }
-
     /**
      * Construct dex meta-info and write it to meta file and log.
      *
@@ -723,12 +636,12 @@ private String getRelativeStringBy(File file, File reference) {
      *
      * @throws IOException
      */
-    protected void writeLogFiles(File newOrFullPatchedFile, File oldFile, File dexDiffFile, String destMd5InDvm, String destMd5InArt, String dexDiffMd5) throws IOException {
+    protected void logToDexMeta(File newOrFullPatchedFile, File oldFile, File dexDiffFile, String destMd5InDvm, String destMd5InArt, String dexDiffMd5) throws IOException {
         if (metaWriter == null && logWriter == null) {
             return;
         }
-        String parentRelative = getParentRelativeString(newOrFullPatchedFile);
-        String relative = getRelativeString(newOrFullPatchedFile);
+        String parentRelative = getParentRelativePathStringToNewFile(newOrFullPatchedFile);
+        String relative = getRelativePathStringToNewFile(newOrFullPatchedFile);
 
         if (metaWriter != null) {
             String fileName = newOrFullPatchedFile.getName();
@@ -765,6 +678,60 @@ protected void writeLogFiles(File newOrFullPatchedFile, File oldFile, File dexDi
         }
     }
 
+    @Override
+    public void clean() {
+        metaWriter.close();
+        logWriter.close();
+    }
+
+    private String getRawOrWrappedDexMD5(File dexOrJarFile) {
+        final String name = dexOrJarFile.getName();
+        if (name.endsWith(".dex")) {
+            return MD5.getMD5(dexOrJarFile);
+        } else {
+            JarFile dexJar = null;
+            try {
+                dexJar = new JarFile(dexOrJarFile);
+                ZipEntry classesDex = dexJar.getEntry(DexFormat.DEX_IN_JAR_NAME);
+                // no code
+                if (classesDex == null) {
+                    throw new TinkerPatchException(
+                            String.format("Jar file %s do not contain 'classes.dex', it is not a correct dex jar file!", dexOrJarFile.getAbsolutePath())
+                    );
+                }
+                return MD5.getMD5(dexJar.getInputStream(classesDex), 1024 * 100);
+            } catch (IOException e) {
+                throw new TinkerPatchException(
+                        String.format("File %s is not end with '.dex', but it is not a correct dex jar file !", dexOrJarFile.getAbsolutePath()), e
+                );
+            } finally {
+                if (dexJar != null) {
+                    try {
+                        dexJar.close();
+                    } catch (Exception e) {
+                        // Ignored.
+                    }
+                }
+            }
+        }
+    }
+
+    private String getRelativeStringBy(File file, File reference) {
+        File actualReference = reference.getParentFile();
+        if (actualReference == null) {
+            actualReference = reference;
+        }
+        return actualReference.toPath().relativize(file.toPath()).toString().replace("\\", "/");
+    }
+
+    private void ensureDirectoryExist(File dir) {
+        if (!dir.exists()) {
+            if (!dir.mkdirs()) {
+                throw new TinkerPatchException("failed to create directory: " + dir);
+            }
+        }
+    }
+
     private final class RelatedInfo {
         File newOrFullPatchedFile = null;
         /**
@@ -781,39 +748,38 @@ protected void writeLogFiles(File newOrFullPatchedFile, File oldFile, File dexDi
          *  newDex md5, if new dex is marked to be copied directly;
          */
         String newOrFullPatchedMd5 = "0";
-        String smallPatchedMd5 = "0";
     }
 
     private final class DexPatcherLoggerBridge implements IDexPatcherLogger {
-        private final InfoWriter logWritter;
+        private final InfoWriter logWriter;
 
         DexPatcherLoggerBridge(InfoWriter logWritter) {
-            this.logWritter = logWritter;
+            this.logWriter = logWritter;
         }
 
         @Override
         public void v(String msg) {
-            this.logWritter.writeLineToInfoFile(msg);
+            this.logWriter.writeLineToInfoFile(msg);
         }
 
         @Override
         public void d(String msg) {
-            this.logWritter.writeLineToInfoFile(msg);
+            this.logWriter.writeLineToInfoFile(msg);
         }
 
         @Override
         public void i(String msg) {
-            this.logWritter.writeLineToInfoFile(msg);
+            this.logWriter.writeLineToInfoFile(msg);
         }
 
         @Override
         public void w(String msg) {
-            this.logWritter.writeLineToInfoFile(msg);
+            this.logWriter.writeLineToInfoFile(msg);
         }
 
         @Override
         public void e(String msg) {
-            this.logWritter.writeLineToInfoFile(msg);
+            this.logWriter.writeLineToInfoFile(msg);
         }
     }
 }
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java
index 9ec77664..114fc223 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/ResDiffDecoder.java
@@ -92,11 +92,11 @@ private boolean checkLargeModFile(File file) {
 
     @Override
     public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatchException {
-        String name = getRelativeString(newFile);
+        String name = getRelativePathStringToNewFile(newFile);
 
         //actually, it won't go below
         if (newFile == null || !newFile.exists()) {
-            String relativeStringByOldDir = getRelativeStringByOldDir(oldFile);
+            String relativeStringByOldDir = getRelativePathStringToOldFile(oldFile);
             if (Utils.checkFileInPattern(config.mResIgnoreChangePattern, relativeStringByOldDir)) {
                 Logger.e("found delete resource: " + relativeStringByOldDir + " ,but it match ignore change pattern, just ignore!");
                 return false;
@@ -178,25 +178,25 @@ private void writeResLog(File newFile, File oldFile, int mode) throws IOExceptio
             String relative;
             switch (mode) {
                 case TypedValue.ADD:
-                    relative = getRelativeString(newFile);
+                    relative = getRelativePathStringToNewFile(newFile);
                     Logger.d("Found add resource: " + relative);
                     log = "add resource: " + relative + ", oldSize=" + FileOperation.getFileSizes(oldFile) + ", newSize="
                         + FileOperation.getFileSizes(newFile);
                     break;
                 case TypedValue.MOD:
-                    relative = getRelativeString(newFile);
+                    relative = getRelativePathStringToNewFile(newFile);
                     Logger.d("Found modify resource: " + relative);
                     log = "modify resource: " + relative + ", oldSize=" + FileOperation.getFileSizes(oldFile) + ", newSize="
                         + FileOperation.getFileSizes(newFile);
                     break;
                 case TypedValue.DEL:
-                    relative = getRelativeStringByOldDir(oldFile);
+                    relative = getRelativePathStringToOldFile(oldFile);
                     Logger.d("Found deleted resource: " + relative);
                     log = "deleted resource: " + relative + ", oldSize=" + FileOperation.getFileSizes(oldFile) + ", newSize="
                         + FileOperation.getFileSizes(newFile);
                     break;
                 case TypedValue.LARGE_MOD:
-                    relative = getRelativeString(newFile);
+                    relative = getRelativePathStringToNewFile(newFile);
                     Logger.d("Found large modify resource: " + relative + " size:" + newFile.length());
                     log = "large modify resource: " + relative + ", oldSize=" + FileOperation.getFileSizes(oldFile) + ", newSize="
                         + FileOperation.getFileSizes(newFile);
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/UniqueDexDiffDecoder.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/UniqueDexDiffDecoder.java
index 46a61f7c..88258320 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/UniqueDexDiffDecoder.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/decoder/UniqueDexDiffDecoder.java
@@ -48,4 +48,4 @@ public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatch
         return added;
     }
 
-}
+}
\ No newline at end of file
diff --git a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Logger.java b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Logger.java
index 777c3245..93115188 100644
--- a/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Logger.java
+++ b/tinker-build/tinker-patch-lib/src/main/java/com/tencent/tinker/build/util/Logger.java
@@ -51,6 +51,7 @@ public static void d(final String format, final Object... obj) {
         }
         //add \n
         System.out.printf(log + "\n");
+        System.out.flush();
 
         logWriter.writeLineToInfoFile(log);
     }
@@ -66,8 +67,9 @@ public static void e(final String format, final Object... obj) {
         }
         //add \n
         System.err.printf(log + "\n");
-        logWriter.writeLineToInfoFile(log);
+        System.err.flush();
 
+        logWriter.writeLineToInfoFile(log);
     }
 
 }
diff --git a/tinker-sample-android/app/build.gradle b/tinker-sample-android/app/build.gradle
index 516f6b4e..b5578980 100644
--- a/tinker-sample-android/app/build.gradle
+++ b/tinker-sample-android/app/build.gradle
@@ -93,7 +93,7 @@ android {
          * client version would update with patch
          * so we can get the newly git version easily!
          */
-        buildConfigField "String", "CLIENTVERSION", "\"${getTinkerIdValue()}\""
+        buildConfigField "String", "TINKER_ID", "\"${getTinkerIdValue()}\""
         buildConfigField "String", "PLATFORM",  "\"all\""
     }
 
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/BaseBuildInfo.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/BaseBuildInfo.java
index 4ffa7d4d..eca15927 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/BaseBuildInfo.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/BaseBuildInfo.java
@@ -16,10 +16,13 @@
 
 package tinker.sample.android.app;
 
+import tinker.sample.android.BuildConfig;
+
 /**
  * Created by zhangshaowen on 16/6/30.
  * we add BaseBuildInfo to loader pattern, so it won't change with patch!
  */
 public class BaseBuildInfo {
     public static String TEST_MESSAGE = "I won't change with tinker patch!";
+    public static String BASE_TINKER_ID = BuildConfig.TINKER_ID;
 }
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/BuildInfo.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/BuildInfo.java
index 58ea3527..e1d73f52 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/BuildInfo.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/BuildInfo.java
@@ -31,7 +31,7 @@
     public static int     VERSION_CODE = BuildConfig.VERSION_CODE;
 
     public static String MESSAGE       = BuildConfig.MESSAGE;
-    public static String CLIENTVERSION = BuildConfig.CLIENTVERSION;
+    public static String TINKER_ID     = BuildConfig.TINKER_ID;
     public static String PLATFORM      = BuildConfig.PLATFORM;
 
 }
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/MainActivity.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/MainActivity.java
index bc55dc62..068de2d4 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/app/MainActivity.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/app/MainActivity.java
@@ -104,16 +104,19 @@ public boolean showInfo(Context context) {
         Tinker tinker = Tinker.with(getApplicationContext());
         if (tinker.isTinkerLoaded()) {
             sb.append(String.format("[patch is loaded] \n"));
-            sb.append(String.format("[buildConfig CLIENTVERSION] %s \n", BuildInfo.CLIENTVERSION));
+            sb.append(String.format("[buildConfig TINKER_ID] %s \n", BuildInfo.TINKER_ID));
+            sb.append(String.format("[buildConfig BASE_TINKER_ID] %s \n", BaseBuildInfo.BASE_TINKER_ID));
+
             sb.append(String.format("[buildConfig MESSSAGE] %s \n", BuildInfo.MESSAGE));
             sb.append(String.format("[TINKER_ID] %s \n", tinker.getTinkerLoadResultIfPresent().getPackageConfigByName(ShareConstants.TINKER_ID)));
-            sb.append(String.format("[REAL TINKER_ID] %s \n", tinker.getTinkerLoadResultIfPresent().getTinkerID()));
             sb.append(String.format("[packageConfig patchMessage] %s \n", tinker.getTinkerLoadResultIfPresent().getPackageConfigByName("patchMessage")));
             sb.append(String.format("[TINKER_ID Rom Space] %d k \n", tinker.getTinkerRomSpace()));
 
         } else {
             sb.append(String.format("[patch is not loaded] \n"));
-            sb.append(String.format("[buildConfig CLIENTVERSION] %s \n", BuildInfo.CLIENTVERSION));
+            sb.append(String.format("[buildConfig TINKER_ID] %s \n", BuildInfo.TINKER_ID));
+            sb.append(String.format("[buildConfig BASE_TINKER_ID] %s \n", BaseBuildInfo.BASE_TINKER_ID));
+
             sb.append(String.format("[buildConfig MESSSAGE] %s \n", BuildInfo.MESSAGE));
             sb.append(String.format("[TINKER_ID] %s \n", ShareTinkerInternals.getManifestTinkerID(getApplicationContext())));
         }
diff --git a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/UpgradePatchRetry.java b/tinker-sample-android/app/src/main/java/tinker/sample/android/util/UpgradePatchRetry.java
index 714749e6..816ced7b 100644
--- a/tinker-sample-android/app/src/main/java/tinker/sample/android/util/UpgradePatchRetry.java
+++ b/tinker-sample-android/app/src/main/java/tinker/sample/android/util/UpgradePatchRetry.java
@@ -49,7 +49,7 @@
 
     private static final String RETRY_FILE_MD5_PROPERTY = "md5";
     private static final String RETRY_COUNT_PROPERTY    = "times";
-    private static final int    RETRY_MAX_COUNT         = 2;
+    private static final int    RETRY_MAX_COUNT         = 3;
 
     private boolean isRetryEnable = false;
     private File    retryInfoFile = null;
diff --git a/tinker-sample-android/gradle.properties b/tinker-sample-android/gradle.properties
index eda0fddb..6d6ac6c1 100644
--- a/tinker-sample-android/gradle.properties
+++ b/tinker-sample-android/gradle.properties
@@ -17,4 +17,4 @@
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
 
-TINKER_VERSION=1.7.3
+TINKER_VERSION=1.7.5
