diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
index aece8d6a..cc8e52e1 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcePatcher.java
@@ -32,9 +32,12 @@
 import java.lang.ref.WeakReference;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
+import java.util.Set;
 
 import static android.os.Build.VERSION.SDK_INT;
 import static android.os.Build.VERSION_CODES.KITKAT;
@@ -52,6 +55,7 @@
 
     // original object
     private static Collection<WeakReference<Resources>> references = null;
+    private static Map<?, ?> cachedResourcesOrImpls = null;
     private static Object currentActivityThread = null;
     private static AssetManager newAssetManager = null;
 
@@ -121,19 +125,23 @@ public static void isResourceCanPatch(Context context) throws Throwable {
                 final ArrayMap<?, WeakReference<Resources>> activeResources19 =
                         (ArrayMap<?, WeakReference<Resources>>) fMActiveResources.get(resourcesManager);
                 references = activeResources19.values();
+                cachedResourcesOrImpls = activeResources19;
             } catch (NoSuchFieldException ignore) {
                 // N moved the resources to mResourceReferences
                 final Field mResourceReferences = findField(resourcesManagerClass, "mResourceReferences");
+                final Field mResourceImpls = findField(resourcesManagerClass, "mResourceImpls");
                 references = (Collection<WeakReference<Resources>>) mResourceReferences.get(resourcesManager);
+                cachedResourcesOrImpls = (Map<?, ?>) mResourceImpls.get(resourcesManager);
             }
         } else {
             final Field fMActiveResources = findField(activityThread, "mActiveResources");
             final HashMap<?, WeakReference<Resources>> activeResources7 =
                     (HashMap<?, WeakReference<Resources>>) fMActiveResources.get(currentActivityThread);
             references = activeResources7.values();
+            cachedResourcesOrImpls = activeResources7;
         }
         // check resource
-        if (references == null) {
+        if (references == null || cachedResourcesOrImpls == null) {
             throw new IllegalStateException("resource references is null");
         }
 
@@ -158,6 +166,10 @@ public static void isResourceCanPatch(Context context) throws Throwable {
         } catch (NoSuchFieldException ignore) {
             // Ignored.
         }
+
+        // check if there is a correct class ResourcesKey.
+        // throw exception to prevent patching action
+        TinkerResourcesKey.checkClassCorrect();
     }
 
     /**
@@ -228,6 +240,13 @@ public static void monkeyPatchExistingResources(Context context, String external
             resources.updateConfiguration(resources.getConfiguration(), resources.getDisplayMetrics());
         }
 
+        try {
+            addResourcesKeys(context, externalResourceFile, cachedResourcesOrImpls);
+        } catch (Throwable t) {
+            Log.w(TAG, "add ResourcesKeys failed.", t);
+            throw t;
+        }
+
         // Handle issues caused by WebView on Android N.
         // Issue: On Android N, if an activity contains a webview, when screen rotates
         // our resource patch may lost effects.
@@ -274,6 +293,28 @@ private static void clearPreloadTypedArrayIssue(Resources resources) {
         }
     }
 
+    private static void addResourcesKeys(Context context, String externalResourcePath, Map caches) throws Exception {
+        ApplicationInfo appInfo = context.getApplicationInfo();
+        List<Map.Entry> targets = new ArrayList<>();
+
+        Set<Map.Entry> entries = caches.entrySet();
+        for (Map.Entry e : entries) {
+            Object rk = e.getKey();
+            String resDir = TinkerResourcesKey.getResDir(rk);
+            Log.w(TAG, "resourcesKey.resDir = " + resDir);
+            if (appInfo.sourceDir.equalsIgnoreCase(resDir)) {
+                targets.add(e);
+            }
+        }
+
+        for (Map.Entry entry : targets) {
+            Object oldKey = entry.getKey();
+            Object newKey = TinkerResourcesKey.newKey(oldKey, externalResourcePath);
+            caches.put(newKey, entry.getValue());
+            Log.w(TAG, "resourcesKey.newKey = " + newKey);
+        }
+    }
+
     private static boolean checkResUpdate(Context context) {
         InputStream is = null;
         try {
diff --git a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcesKey.java b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcesKey.java
index d235bdb8..d244e042 100644
--- a/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcesKey.java
+++ b/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerResourcesKey.java
@@ -16,6 +16,17 @@
 
 package com.tencent.tinker.loader;
 
+import android.content.res.Configuration;
+import android.os.Build;
+import android.os.IBinder;
+import android.util.Log;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.util.Arrays;
+
+import static com.tencent.tinker.loader.shareutil.ShareReflectUtil.findField;
+
 /**
  * Created by zhangshaowen on 17/1/12.
  *
@@ -25,20 +36,414 @@
  */
 public class TinkerResourcesKey {
 
-    private static final class V24 {
+    private static final String TAG = "Tinker.ResourcesKey";
 
+    public static String lookOverUnadaptedInfo() {
+        try {
+            checkClassCorrect();
+        } catch (Throwable ignore) {
+            StringBuilder info = new StringBuilder("ClassInfo { ");
+            try {
+                Class ResourcesKeyClazz = BaseKey.ResourcesKeyClazz;
+                info.append(ResourcesKeyClazz.getName()).append(", ");
+                Constructor[] constructors = ResourcesKeyClazz.getDeclaredConstructors();
+                for (Constructor c : constructors) {
+                    if (c == null) {
+                        continue;
+                    }
+                    c.setAccessible(true);
+                    Class[] args = c.getParameterTypes();
+                    if (args != null && args.length > 0) {
+                        info.append(Arrays.deepToString(args)).append(", ");
+                    }
+                }
+            } catch (Throwable e) {
+                info.append("err=" + e.getMessage()).append(" ");
+            }
+            info.append("}");
+            return info.toString();
+        }
+        return null;
+    }
 
+    static void checkClassCorrect() throws Throwable {
+        BaseKey keyWrap = createLyingKey();
+        keyWrap.getConstructor();
     }
 
-    private static final class V19 {
+    static String getResDir(Object resourcesKey) throws Exception {
+        return (String) BaseKey.mResDirField.get(resourcesKey);
+    }
 
+    static Object newKey(Object oldKey, String newResourcePath) throws Exception {
+        BaseKey keyWrap = createLyingKey();
+        if (keyWrap != null) {
+            return keyWrap.getNewKey(oldKey, newResourcePath);
+        }
+        throw new IllegalAccessException("can not create new ResourcesKey object");
     }
 
-    private static final class V17 {
+    private static BaseKey createLyingKey() {
+        final int sdk = Build.VERSION.SDK_INT;
+        BaseKey key = null;
+        if (sdk >= 24) {
+            key =  new V24();
+        } else if (sdk >= 23) {
+            key =  new V23();
+        } else if (sdk >= 19) {
+            key =  new V19();
+        } else if (sdk >= 17) {
+            key =  new V17();
+        } else if (sdk >= 16) {
+            key =  new V16();
+        }
+        try {
+            key.getConstructor();
+        } catch (Throwable e) {
+            key = monkeyTryingKey();
+            if (key != null) {
+                Log.w(TAG, "monkey trying ResourcesKey success");
+            }
+        }
+        return key;
+    }
 
+    private static BaseKey monkeyTryingKey() {
+        BaseKey key = null;
+        for (int i = 0; ; i++) {
+            try {
+                if (i == 0) {
+                    key = new Customized.A();
+                } else if (i == 1) {
+                    key = new Customized.B();
+                } else if (i == 2) {
+                    key = new Customized.C();
+                } else {
+                    break;
+                }
+                key.getConstructor();
+            } catch (Throwable ignore) {
+                key = null;
+                continue;
+            }
+            break;
+        }
+        return key;
     }
 
-    private static final class V7 {
 
+    private abstract static class BaseKey {
+        static final Class ResourcesKeyClazz;
+        static final Field mResDirField;
+
+        static {
+            try {
+                Class rkc; // monkey check the resources key class
+                try {
+                    rkc = Class.forName("android.content.res.ResourcesKey");
+                } catch (Exception ignore) {
+                    rkc = Class.forName("android.app.ActivityThread$ResourcesKey");
+                }
+                ResourcesKeyClazz = rkc;
+                mResDirField = findField(ResourcesKeyClazz, "mResDir");
+            } catch (Exception ignore) {
+                throw new RuntimeException(ignore);
+            }
+        }
+
+        String resDir;
+
+        abstract Constructor getConstructor() throws Exception;
+
+        Object getNewKey(Object oldKey, String newResDir) throws Exception {
+            this.resDir = newResDir;
+            return null;
+        }
+    }
+
+    private abstract static class CommonKey extends BaseKey {
+        static final Field mDisplayIdField;
+        static final Field mOverrideConfigurationField;
+
+        static {
+            try {
+                mDisplayIdField = findField(ResourcesKeyClazz, "mDisplayId");
+                mOverrideConfigurationField = findField(ResourcesKeyClazz, "mOverrideConfiguration");
+            } catch (Throwable t) {
+                throw new RuntimeException(t);
+            }
+        }
+
+        int displayId;
+        Configuration configuration;
+
+        @Override
+        Object getNewKey(Object oldKey, String newResDir) throws Exception {
+            super.getNewKey(oldKey, newResDir);
+            displayId = (int) mDisplayIdField.get(oldKey);
+            configuration = (Configuration) mOverrideConfigurationField.get(oldKey);
+            return null;
+        }
     }
+
+    private static final class V24 extends CommonKey {
+        static final Field mSplitResDirsField;
+        static final Field mOverlayDirsField;
+        static final Field mLibDirsField;
+        static final Field mCompatInfoField;
+
+        static {
+            try {
+                mSplitResDirsField = findField(ResourcesKeyClazz, "mSplitResDirs");
+                mOverlayDirsField = findField(ResourcesKeyClazz, "mOverlayDirs");
+                mLibDirsField = findField(ResourcesKeyClazz, "mLibDirs");
+                mCompatInfoField = findField(ResourcesKeyClazz, "mCompatInfo");
+            } catch (Exception e) {
+                throw new RuntimeException(e);
+            }
+        }
+
+        @Override
+        Constructor getConstructor() throws Exception {
+            Class CompatibilityInfoClazz = Class.forName("android.content.res.CompatibilityInfo");
+            Constructor cst = ResourcesKeyClazz.getDeclaredConstructor(
+                    String.class, String[].class, String[].class, String[].class, int.class, Configuration.class, CompatibilityInfoClazz);
+            cst.setAccessible(true);
+            return cst;
+        }
+
+        @Override
+        Object getNewKey(Object oldKey, String newResDir) throws Exception {
+            super.getNewKey(oldKey, newResDir);
+            String[] splitResDirs = (String[]) mSplitResDirsField.get(oldKey);
+            String[] overlayDirs = (String[]) mOverlayDirsField.get(oldKey);
+            String[] libDirs = (String[]) mLibDirsField.get(oldKey);
+            Object compatInfo = mCompatInfoField.get(oldKey);
+            return getConstructor()
+                    .newInstance(resDir, splitResDirs, overlayDirs, libDirs, displayId, configuration, compatInfo);
+        }
+    }
+
+    private static final class V23 extends CommonKey {
+        static final Field mScaleField;
+
+        static {
+            try {
+                mScaleField = findField(ResourcesKeyClazz, "mScale");
+            } catch (Exception e) {
+                throw new RuntimeException(e);
+            }
+        }
+
+        @Override
+        Constructor getConstructor() throws Exception {
+            Constructor cst = ResourcesKeyClazz.getDeclaredConstructor(
+                    String.class, int.class, Configuration.class, float.class);
+            cst.setAccessible(true);
+            return cst;
+        }
+
+        @Override
+        Object getNewKey(Object oldKey, String newResDir) throws Exception {
+            super.getNewKey(oldKey, newResDir);
+            float scale = (float) mScaleField.get(oldKey);
+            return getConstructor()
+                    .newInstance(resDir, displayId, configuration, scale);
+        }
+    }
+
+    private static final class V19 extends CommonKey {
+        static final Field mScaleField;
+        static final Field mTokenField;
+
+        static {
+            try {
+                mScaleField = findField(ResourcesKeyClazz, "mScale");
+                mTokenField = findField(ResourcesKeyClazz, "mToken");
+            } catch (Exception e) {
+                throw new RuntimeException(e);
+            }
+        }
+
+        @Override
+        Constructor getConstructor() throws Exception {
+            Constructor cst = ResourcesKeyClazz.getDeclaredConstructor(
+                    String.class, int.class, Configuration.class, float.class, IBinder.class);
+            cst.setAccessible(true);
+            return cst;
+        }
+
+        @Override
+        Object getNewKey(Object oldKey, String newResDir) throws Exception {
+            super.getNewKey(oldKey, newResDir);
+            float scale = (float) mScaleField.get(oldKey);
+            IBinder token = (IBinder) mTokenField.get(oldKey);
+            return getConstructor()
+                    .newInstance(resDir, displayId, configuration, scale, token);
+        }
+    }
+
+    /**
+     * the same as {@link V23}
+     */
+    private static final class V17 extends CommonKey {
+        static final Field mScaleField;
+
+        static {
+            try {
+                mScaleField = findField(ResourcesKeyClazz, "mScale");
+            } catch (Exception e) {
+                throw new RuntimeException(e);
+            }
+        }
+
+        @Override
+        Constructor getConstructor() throws Exception {
+            Constructor cst = ResourcesKeyClazz.getDeclaredConstructor(
+                    String.class, int.class, Configuration.class, float.class);
+            cst.setAccessible(true);
+            return cst;
+        }
+
+        @Override
+        Object getNewKey(Object oldKey, String newResDir) throws Exception {
+            super.getNewKey(oldKey, newResDir);
+            float scale = (float) mScaleField.get(oldKey);
+            return getConstructor()
+                    .newInstance(resDir, displayId, configuration, scale);
+        }
+    }
+
+    private static final class V16 extends BaseKey {
+        static final Field mScaleField;
+
+        static {
+            try {
+                mScaleField = findField(ResourcesKeyClazz, "mScale");
+            } catch (Exception e) {
+                throw new RuntimeException(e);
+            }
+        }
+
+        @Override
+        Constructor getConstructor() throws Exception {
+            Constructor cst = ResourcesKeyClazz.getDeclaredConstructor(
+                    String.class, float.class);
+            cst.setAccessible(true);
+            return cst;
+        }
+
+        @Override
+        Object getNewKey(Object oldKey, String newResDir) throws Exception {
+            super.getNewKey(oldKey, newResDir);
+            float scale = (float) mScaleField.get(oldKey);
+            return getConstructor()
+                    .newInstance(resDir, scale);
+        }
+    }
+
+
+    private static class Customized {
+
+        private static final class A extends CommonKey {
+            static final Field mScaleField;
+            static final Field mIsThemeableField;
+
+            static {
+                try {
+                    mScaleField = findField(ResourcesKeyClazz, "mScale");
+                    mIsThemeableField = findField(ResourcesKeyClazz, "mIsThemeable");
+                } catch (Exception e) {
+                    throw new RuntimeException(e);
+                }
+            }
+
+            @Override
+            Constructor getConstructor() throws Exception {
+                Constructor cst = ResourcesKeyClazz.getDeclaredConstructor(
+                        String.class, int.class, Configuration.class, float.class, boolean.class);
+                cst.setAccessible(true);
+                return cst;
+            }
+
+            @Override
+            Object getNewKey(Object oldKey, String newResDir) throws Exception {
+                super.getNewKey(oldKey, newResDir);
+                float scale = (float) mScaleField.get(oldKey);
+                boolean isThemeable = (boolean) mIsThemeableField.get(oldKey);
+                return getConstructor()
+                        .newInstance(resDir, displayId, configuration, scale, isThemeable);
+            }
+        }
+
+        private static final class B extends CommonKey {
+            static final Field mScaleField;
+            static final Field mTokenField;
+            static final Field mIsThemeableField;
+
+            static {
+                try {
+                    mScaleField = findField(ResourcesKeyClazz, "mScale");
+                    mTokenField = findField(ResourcesKeyClazz, "mToken");
+                    mIsThemeableField = findField(ResourcesKeyClazz, "mIsThemeable");
+                } catch (Exception e) {
+                    throw new RuntimeException(e);
+                }
+            }
+
+            @Override
+            Constructor getConstructor() throws Exception {
+                Constructor cst = ResourcesKeyClazz.getDeclaredConstructor(
+                        String.class, int.class, Configuration.class, float.class, IBinder.class, boolean.class);
+                cst.setAccessible(true);
+                return cst;
+            }
+
+            @Override
+            Object getNewKey(Object oldKey, String newResDir) throws Exception {
+                super.getNewKey(oldKey, newResDir);
+                float scale = (float) mScaleField.get(oldKey);
+                IBinder token = (IBinder) mTokenField.get(oldKey);
+                boolean isThemeable = (boolean) mIsThemeableField.get(oldKey);
+                return getConstructor()
+                        .newInstance(resDir, displayId, configuration, scale, token, isThemeable);
+            }
+        }
+
+        private static final class C extends CommonKey {
+            static final Field mScaleField;
+            static final Field mTokenField;
+            static final Field mIsThemeableField;
+
+            static {
+                try {
+                    mScaleField = findField(ResourcesKeyClazz, "mScale");
+                    mTokenField = findField(ResourcesKeyClazz, "mToken");
+                    mIsThemeableField = findField(ResourcesKeyClazz, "mIsThemeable");
+                } catch (Exception e) {
+                    throw new RuntimeException(e);
+                }
+            }
+
+            @Override
+            Constructor getConstructor() throws Exception {
+                Constructor cst = ResourcesKeyClazz.getDeclaredConstructor(
+                        String.class, int.class, Configuration.class, float.class, boolean.class, IBinder.class);
+                cst.setAccessible(true);
+                return cst;
+            }
+
+            @Override
+            Object getNewKey(Object oldKey, String newResDir) throws Exception {
+                super.getNewKey(oldKey, newResDir);
+                float scale = (float) mScaleField.get(oldKey);
+                IBinder token = (IBinder) mTokenField.get(oldKey);
+                boolean isThemeable = (boolean) mIsThemeableField.get(oldKey);
+                return getConstructor()
+                        .newInstance(resDir, displayId, configuration, scale, isThemeable, token);
+            }
+        }
+
+    }
+
 }
